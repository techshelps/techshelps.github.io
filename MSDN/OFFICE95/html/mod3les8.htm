<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Lesson 8: API's and DLL's</title>
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<H1>Lesson 8: API's and DLL's</font></H1>

<p><b>Lesson
Objectives</b></font></p>
  
        <p>Upon
        completion of this lesson, the participant will be able
        to:</font></p>
    


<ul>
    <li>Define API
        and DLL.</font></li>
    <li>Describe
        how to declare an API function.</font></li>
    <li>Describe
        how to use API functions to hide a window, show a window,
        make a window &quot;always on top&quot;, and how to tell
        if an application is running and whether it is visible or
        not.</font></li>
</ul>
  
        <p><b>Some Topics to
        be introduced in this lesson include:</b></font></p>
    
    <ul>
        <li>Where
            To Find Information About Specific API Functions</font></li>
        <li>How To
            Get API Declarations and Global Constants Into a
            Macro</font></li>
        <li>API
            functions To Manipulate and Get Information About
            Application Windows</font></li>
        <li>API
            functions To Pass Data Between Applications Using
            Global Memory and the ClipBoard.</font></li>
    </ul>
    <p><b><i>API's
    and DLL's</i></b></font></p>
    
        
            <p>A
            DLL (Dynamic-link library) is a set of procedures
            that can be called from windows applications. There
            are plenty of standard DLL's available. The Windows
            API includes the User, GDI, and Kernel libraries.
            Other examples of API's are MAPI (messaging API) and
            TAPI (telephony API). Documentation about what
            procedures are in various API libraries is usually
            found in the appropriate SDK (software development
            kit). VB3 Professional Edition includes Win31wh.hlp,
            a help file that ships with the Windows SDK. It's in
            the WinAPI subdirectory of VB3, and documents Windows
            API procedures. Win31wh.hlp uses C language syntax,
            but you need not be a C programmer to get the gist of
            what a procedure is for. To call a DLL procedure from
            a macro, you first declare it in the declarations
            area at the top of a module. Declarations are
            technical statements telling your macro where to find
            the DLL procedure, how to pass data to it (if it
            takes arguments), and what data the procedure will
            return, if any. Instead of entering declarations
            manually, you usually copy them from some
            documentation text or help file. VB3 also includes
            Win31API.hlp, which has declarations that you can
            copy and paste into the declarations area of one of
            your modules. VB3 and applications that support
            Visual Basic for Applications can call DLL
            procedures.</font></p>
        
        <p><b>API
        DECLARATIONS</b></font></p>
        
            <p>Before
            you can use a procedure from a DLL, you must declare
            it. The declarations are entered or pasted into the
            declaration area in a module. A Declaration must be
            on one line, unless the macro editor in the
            application has a continuation character. For
            example, in Visual Basic for Applications you can use
            the underscore character to continue a logical line
            to the next physical line. You can't do that in VB3. </font></p>
            <p>Most
            declarations include arguments. When you call the
            procedure in your macro, you replace the arguments
            just like you would when calling a macro procedure.
            Some of the API procedures have flag arguments that
            must be set to one of a few predefined values. The
            same documentation that contains the declaration
            statements also contains a list of global constants
            that you can copy and paste into the declaration area
            of a module. You can then use the named constants
            when you call the procedure. In some cases, you are
            allowed to pass the sum of two constants for a flag
            to combined two actions, for example:</font></p>
            <p><b>SWP_NOMOVE
            + SWP_NOSIZE</b></font></p>
            <p>Most
            of the API declarations are function procedures
            instead of sub procedures. Often they return only a
            success/failure flag. You can ignore the return value
            if you have no use for it, by not assigning a
            variable when you call the function, and not using (
            )'s around the argument list. For example, both of
            the following are legal:</font></p>
        
        <p><b>nPreviousState
        = ShowWindow(handle, SW_SHOWMAXIMIZED)</b></font></p>
        <p><b>ShowWindow
        handle, SW_SHOWMAXIMIZED</b></font></p>
        
            <p>In
            the declaration examples below, return values that
            are usually ignored are not discussed. See the API
            documentation for information on these return values.</font></p>
            <p>There
            are some examples of API declarations below, along
            with some comments about what the procedures do.
            There are also some examples of MSProject and Excel
            procedures that use them. Most of these examples
            could be run from any application that supports
            Visual Basic for Applications (like Excel and
            MSProject) or from VB3, except where indicated
            otherwise. These examples require that the API
            procedures used be declared in the declaration area
            of a module.</font></p>
        
    
    <p><b><i>Some
    Window-Related Procedures</i></b></font></p>
    
        
            <p>The
            first set of API procedures manipulate or get
            information about windows:</font></p>
            
                <ul>
                    <li>GetActiveWindow</font></li>
                    <li>SetWindowPos</font></li>
                    <li>ShowWindow</font></li>
                    <li>GetClassname</font></li>
                    <li>FindWindow</font></li>
                    <li>IsWindowVisible</font></li>
                </ul>
            
        
        <p><b>GetActiveWindow</b></font></p>
        <p><b>Declare
        Function GetActiveWindow Lib &quot;USER&quot; () As
        Integer</b></font></p>
        
            <p>GetActiveWindow
            returns the handle to the active window. A window
            handle is an integer that identifies a window. It's
            not of much use by itself, but the window handle is
            usually passed to other procedures when talking
            actions or requesting data about a specific window.
            You normally assign it to an integer variable, for
            example,</font></p>
        
        <p><b>handle
        = GetActiveWindow()</b></font></p>
    
    <p><b>SetWindowPos</b></font></p>
    
        <p><b>Declare
        Sub SetWindowPos Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        hWnd As Integer, _</b></font></p>
        <p><b>ByVal
        hWndInsertAfter As Integer, _</b></font></p>
        <p><b>ByVal
        x As Integer, ByVal y As Integer, _</b></font></p>
        <p><b>ByVal
        cx As Integer, ByVal cy As Integer, _</b></font></p>
        <p><b>ByVal
        wFlags As Integer)</b></font></p>
        
            <p>SetWindowPos
            can be used to move or resize a window, and change
            the position (zorder) of the specified window within
            the stack of windows. Below is a description of its
            arguments:</font></p>
            <p><i><u>hWnd</u></i></font></p>
            <p>Handle
            to the window you want to effect.</font></p>
            <p><i><u>hWndInsertAfter</u></i></font></p>
            <p>A
            value that specifies the desired zorder. You can
            either declare and pass one of the constants below,
            or pass the actual number. If you use the named
            constants, you must put them in the declaration area
            of a module:</font></p>
        
        <p><b>Global
        Const HWND_TOP = 0</b></font></p>
        <p><b>Global
        Const HWND_BOTTOM = 1</b></font></p>
        <p><b>Global
        Const HWND_TOPMOST = -1</b></font></p>
        <p><b>Global
        Const HWND_NOTOPMOST = -2</b></font></p>
        
            <p><i><u>wFlags</u></i></font></p>
            <p>A
            flag that helps describe what you want to do with the
            window. Here's a few of the possible constants it can
            be:</font></p>
        
        <p><b>Global
        Const SWP_NOSIZE = &amp;h1</b></font></p>
        <p><b>Global
        Const SWP_NOMOVE = &amp;h2</b></font></p>
        <p><b>Global
        Const SWP_SHOWWINDOW = &amp;h40</b></font></p>
        <p><b>Global
        Const SWP_HIDEWINDOW = &amp;h80</b></font></p>
        
            <p><i><u>x,y</u></i></font></p>
            <p>Cordinates
            where you want the upper left corner of the window.
            Ignored if you include SWP_NOSIZE in wFlags.</font></p>
            <p><i><u>cx,cy</u></i>
            </font></p>
            <p>Width
            and height you want for the window. Ignored if you
            include SWP_NOMOVE in wFlags.</font></p>
        
    
    <p><b>ShowWindow </b></font></p>
    
        <p><b>Declare
        Function ShowWindow Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        hWnd As Integer, ByVal nCmdShow As Integer) As Integer</b></font></p>
        
            <p>The
            ShowWindow procedure can make the specified window
            visible or invisible, as well as maximize, minimize,
            or normalize it. If you use ShowWindow to hide an
            application window, then that application will no
            longer be in the Windows Task List. The return value
            tells what state the window was in before you called
            the procedure. You normally won't use the returned
            value. Below is a description of its arguments:</font></p>
            <p><i><u>hWnd</u></i></font></p>
            <p>Handle
            to the window you want to effect.</font></p>
            <p><i><u>nCmdShow</u></i></font></p>
            <p>A
            flag that helps describe what you want to do with the
            window. Here's a few of the possible constants it can
            be:</font></p>
        
        <p><b>Global
        Const SW_HIDE = 0</b></font></p>
        <p><b>Global
        Const SW_SHOWNORMAL = 1</b></font></p>
        <p><b>Global
        Const SW_SHOWMINIMIZED = 2</b></font></p>
        <p><b>Global
        Const SW_SHOWMAXIMIZED = 3</b></font></p>
    
    <p><b>GetClassname</b></font></p>
    
        <p><b>Declare
        Function GetClassname Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        hWnd As Integer, _</b></font></p>
        <p><b>ByVal
        lpClassname As String, _</b></font></p>
        <p><b>ByVal
        nMaxCount As Integer) As Integer</b></font></p>
        
            <p>Each
            window has a Classname associated with it that can be
            used in other procedures to get information about the
            window. The API GetClassname function returns the
            Classname of the window that you specify. For
            example, by using this function, you would discover
            that the Classname of the MSProject application
            window is &quot;JWinproj-WhimperMainClass&quot;.</font></p>
            <p><i><u>hWnd</u></i></font></p>
            <p>Handle
            to the window you want to effect.</font></p>
            <p><i><u>lpClassname</u></i></font></p>
            <p>Memory
            address or string variable name where you want the
            Classname placed. You usually pass it the name of a
            fixed length string variable. When the procedure is
            done, it will have assigned the Classname to your
            variable. When you declare the fixed length string
            variable, give it a length equal to the maximum
            number of characters you want it to return (in case
            the Classname is really long). Here's an example of a
            variable declaration that reserves room for 10
            characters:</font></p>
        
        <p><b>Dim s
        As String * 10</b></font></p>
        
            <p>After
            the procedure is done, you could see the Classname
            with the command:</font></p>
        
        <p><b>MsgBox
        s</b></font></p>
        
            <p><i><u>nMaxCount</u></i></font></p>
            <p>Maximum
            number of characters you want it to place in
            lpClassname.</font></p>
        
    
    <p><b>FindWindow</b></font></p>
    
        <p><b>Declare
        Function FindWindow Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        lpClassname As Any, ByVal lpWindowName As Any) As Integer</b></font></p>
        
            <p>FindWindow
            can tell if a specific application is running, even
            if the application is running invisibly (not in the
            Windows Task List). You need to provide a Classname
            or window title bar caption (see GetClassname for a
            method for discovering application Classnames). The
            return value is a handle to the window, or 0 if it
            can't find it. You normally assign the return value
            to an integer variable, for example,</font></p>
        
        <p><b>handle
        = FindWindow(&quot;JWinproj-WhimperMainClass&quot;,
        0&amp;)</b></font></p>
        
            <p><i><u>lpClassname</u></i></font></p>
            <p>String
            with the Classname, or 0&amp; to ignore.</font></p>
            <p><i><u>lpWindowName</u></i></font></p>
            <p>String
            with the window title, or 0&amp; to ignore</font></p>
        
    
    <p><b>IsWindowVisible</b></font></p>
    
        <p><b>Declare
        Function IsWindowVisible Lib &quot;User&quot; _</b></font></p>
        <p><b>(ByVal
        hWnd As Integer) As Integer</b></font></p>
        
            <p>IsWindowVisible
            can tell if an application window is visible (in the
            Windows Task List) or not.</font></p>
            <p><i><u>hWnd</u></i></font></p>
            <p>Handle
            to the window you are inquiring about.</font></p>
            <p>You
            need to provide a handle to the window of interest.
            Normally the handle returned by FindWindow is used.
            IsWindowVisible returns True if the window is visible
            or False if it is not, so IsWindowVisible is normally
            used in an <b>IF</b> statement.</font></p>
        
    
    <p><b><i>Examples
    of Window-Related Procedures</i></b></font></p>
    
        
            <p>The
            examples below assume the appropriate declarations
            and global constants, as described above, have be
            placed in the declaration area of a module.</font></p>
        
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            Excel macro gives a message that tells if MSProject
            is running, and if it is, it tells whether it is in
            the Windows Task List (running visibly) or not.</font></p>
        
        <p><b>Sub
        WhatAboutMSProject()</b></font></p>
        <p><b>Dim
        handle As Integer</b></font></p>
        <p><b>handle
        = FindWindow(&quot;JWinproj-WhimperMainClass&quot;,
        0&amp;)</b></font></p>
        <p><b>If
        handle = 0 Then</b></font></p>
        <p><b>MsgBox
        &quot;MSProject is not running&quot;</b></font></p>
        <p><b>ElseIf
        IsWindowVisible(handle) then</b></font></p>
        <p><b>MsgBox
        &quot;MSProject is in the Windows Task List&quot;</b></font></p>
        <p><b>Else</b></font></p>
        <p><b>MsgBox
        &quot;MSProject is running, but is not &quot; &amp; _</b></font></p>
        <p><b>&quot;in
        the Windows Task List&quot;</b></font></p>
        <p><b>End
        If</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            macro makes the active window topmost, i.e.
            &quot;always on top&quot;. The coordinates for moving
            and sizing are ignored, so it passes zeroes for those
            arguments.</font></p>
        
        <p><b>Sub
        MakeActiveWindowTopMost()</b></font></p>
        <p><b>SetWindowPos
        GetActiveWindow(), _</b></font></p>
        <p><b>HWND_TOPMOST,
        0, 0, 0, 0, SWP_NOMOVE + SWP_NOSIZE</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            macro makes the active window not topmost, i.e.
            &quot;not always on top&quot;. The coordinates for
            moving and sizing are ignored, so it passes zeroes
            for those arguments.</font></p>
        
        <p><b>Sub
        MakeActiveWindowNotTopMost()</b></font></p>
        <p><b>SetWindowPos
        GetActiveWindow(), _</b></font></p>
        <p><b>HWND_NOTOPMOST,
        0, 0, 0, 0, SWP_NOMOVE + SWP_NOSIZE</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            MSProject macro allows you to discover the Classname
            of any window. When it runs, it minimizes MSProject
            to a topmost icon and the caption under the icon will
            say &quot;Microsoft Project - &quot; followed by the
            Classname of whatever window is active, for example
            you would see the following caption under it if Excel
            were active:</font></p>
            <p><b>Microsoft
            Project - XLMAIN</b></font></p>
            <p>It
            works by going into a DoEvents loop which uses the
            API procedures GetActiveWindow and GetClassname, and
            displays the returned Classname in the MSProject
            window caption. The fixed length string sClassname is
            used to hold the returned Classname (maximum 30
            characters), and the string sOldClassname is used to
            tell when the Classname has changed.</font></p>
        
        <p><b>Sub
        ShowClassnames()</b></font></p>
        <p><b>'DECLARE
        A STRING VARIABLE WITH ROOM FOR 30 CHARACTERS</b></font></p>
        <p><b>Dim
        sClassname As String * 30 </b></font></p>
        <p><b>Dim
        sOldClassname As String</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>MsgBox
        &quot;This MSProject macro displays Classnames &quot;
        &amp; _</b></font></p>
        <p><b>&quot;of
        the active window under a minimized &quot; &amp; _</b></font></p>
        <p><b>&quot;MSProject
        icon, after the hyphen. &quot; &amp; _</b></font></p>
        <p><b>&quot;To
        end the macro, maximize MSProject.&quot;</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>MakeActiveWindowTopMost</b></font></p>
        <p><b>sOldClassname
        = &quot;&quot;</b></font></p>
        <p><b>AppMinimize</b></font></p>
        <p><b>Do</b></font></p>
        <p><b>DoEvents</b></font></p>
        <p><b>GetClassname
        GetActiveWindow(), sClassname, 30</b></font></p>
        <p><b>If
        sClassname &lt;&gt; sOldClassname Then</b></font></p>
        <p><b>ActiveWindow.Caption
        = sClassname</b></font></p>
        <p><b>sOldClassname
        = sClassname</b></font></p>
        <p><b>End
        If</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>Loop
        While WindowState = pjMinimized</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>ActiveWindow.Caption
        = ActiveProject.Name</b></font></p>
        <p><b>MakeActiveWindowNotTopMost</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            MSProject macro checks if Excel is running, and if it
            is, it makes it invisible (removes it from the
            Windows Task List). If more than one instance of
            Excel is running, it only effects one instance.</font></p>
        
        <p><b>Sub
        HideExcel()</b></font></p>
        <p><b>Dim
        handle As Integer</b></font></p>
        <p><b>handle
        = FindWindow(&quot;XLMAIN&quot;, 0&amp;)</b></font></p>
        <p><b>If
        handle = 0 Then</b></font></p>
        <p><b>MsgBox
        &quot;Excel is not running&quot;</b></font></p>
        <p><b>Else</b></font></p>
        <p><b>ShowWindow
        handle, SW_HIDE</b></font></p>
        <p><b>End
        If</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            MSProject macro checks if Excel is running, and if it
            is, it makes it visible (puts it in the Windows Task
            List) and maximizes it. If more than one instance of
            Excel is running, it only effects one instance.</font></p>
        
        <p><b>Sub
        ShowExcel()</b></font></p>
        <p><b>Dim
        handle As Integer</b></font></p>
        <p><b>handle
        = FindWindow(&quot;XLMAIN&quot;, 0&amp;)</b></font></p>
        <p><b>If
        handle = 0 Then</b></font></p>
        <p><b>MsgBox
        &quot;Excel is not running&quot;</b></font></p>
        <p><b>Else</b></font></p>
        <p><b>ShowWindow
        handle, SW_SHOWMAXIMIZED</b></font></p>
        <p><b>End
        If</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b><i>Some
    Memory Allocation and Clipboard Procedures</i></b></font></p>
    
        
            <p>These
            procedures are used for passing data between
            applications.</font></p>
            
                <ul>
                    <li>GlobalAlloc</font></li>
                    <li>GlobalLock</font></li>
                    <li>GlobalUnlock</font></li>
                    <li>GlobalFree</font></li>
                    <li>lstrcpy</font></li>
                    <li>lstrcpyn</font></li>
                    <li>lstrlen</font></li>
                    <li>OpenClipboard</font></li>
                    <li>EmptyClipboard</font></li>
                    <li>SetClipboard</font></li>
                    <li>GetClipboardData</font></li>
                    <li>CloseClipboard</font></li>
                </ul>
            
        
        <p><b>GlobalAlloc</b></font></p>
        <p><b>Declare
        Function GlobalAlloc Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        wFlags As Integer, ByVal dwBytes As Long) As Integer</b></font></p>
        
            <p>Allocates
            global memory of the specified kind and amount and
            returns a memory block id.</font></p>
            <p>In
            Windows, global blocks of memory that can be shared
            by applications are identified in two ways: By a
            block id number, and by a memory address. There are
            also different kinds of memory blocks, for example,
            moveable blocks that windows is allowed to move
            around in memory to optimize system performance,
            fixed blocks that it can't move, and blocks with
            other characteristics. You tell the GloballAlloc
            function what kind of memory you want and how much.
            It returns 0 if there isn't enough available,
            otherwise it returns the id number for the block. You
            normally assign it to an integer variable, for
            example:</font></p>
        
        <p><b>MemoryBlockId
        = GlobalAlloc(GMEM_DDESHARE, 100&amp;)</b></font></p>
        <p><b>If
        MemoryBlockId = 0 Then</b></font></p>
        <p><b>MsgBox
        &quot;Not enough free memory&quot;</b></font></p>
        <p><b>End</b></font></p>
        <p><b>End
        If</b></font></p>
        
            <p><i><u>dwBytes</u></i></font></p>
            <p>Long
            integer that tells how many bytes to allocate.</font></p>
            <p><i><u>wFlags</u></i></font></p>
            <p>Determines
            what &quot;kind&quot; of memory. The safest kind to
            use is DDE share memory, because windows will
            automatically free this memory when the application
            that allocated it quits. The corresponding constant
            for this type of memory is shown below. See the API
            documentation for other possible kinds of memory.</font></p>
        
        <p><b>Global
        Const GMEM_DDESHARE = &amp;h2000</b></font></p>
    
    <p><b>GlobalLock</b></font></p>
    
        <p><b>Declare
        Function GlobalLock Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        hMem As Integer) As Long</b></font></p>
        
            <p>Locks
            the specified memory block and returns an address.
            You must lock it before you can use it. When locked,
            Windows will insure that no other applications will
            mess with the contents of that memory block. It's
            analogous to record locking. In addition, GlobalAlloc
            is used to convert memory block id numbers into
            memory block addresses. Some procedures must be
            passed ids, while others require addresses. You
            normally assign it to a long integer variable, for
            example:</font></p>
        
        <p><b>MemoryBlockAddress
        = GlobalLock(MemoryBlockId)</b></font></p>
        
            <p>where
            MemoryBlockId might have been the result of a
            GlobalAlloc call.</font></p>
            <p><i><u>hMem</u></i></font></p>
            <p>Id
            of the memory block you want to lock.</font></p>
        
    
    <p><b>GlobalUnlock</b></font></p>
    
        <p><b>Declare
        Function GlobalUnlock Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        hMem As Integer) As Integer</b></font></p>
        
            <p><i><u>hMem</u></i></font></p>
            <p>Id
            of the memory block you want to unlock. You must
            unlock a global memory block before you can free it.</font></p>
            <p></font>&nbsp;</p>
        
    
    <p><b>GlobalFree</b></font></p>
    
        <p><b>Declare
        Function GlobalFree Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        hMem As Integer) As Integer</b></font></p>
        
            <p><i><u>hMem</u></i></font></p>
            <p>Id
            of the memory block you want to free.</font></p>
        
    
    <p><b>lstrcpy</b></font></p>
    
        <p><b>Declare
        Function lstrcpy Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        lpString1 As Any, ByVal lpString2 As Any) As Long</b></font></p>
        
            <p>This
            function is used to copy data from one string (or
            memory block) to another. The content of lpString2 is
            copied to into the string lpString1; lpString1 must
            have enough room to hold lpString2. The character 0
            marks the end of a string or the data to be copied
            from a memory block, up to a maximum of 64K
            characters (bytes).</font></p>
            <p>When
            you pass a string variable or constant to this
            function, you are actually passing a memory block
            address. The terms &quot;string&quot; and
            &quot;memory block address&quot; are interchangeable
            in this context.</font></p>
            <p><i><u>lpString1</u></i></font></p>
            <p>Target
            memory address or string.</font></p>
            <p><i><u>lpString2</u></i></font></p>
            <p>Source
            memory address or string.</font></p>
        
    
    <p><b>lstrcpyn</b></font></p>
    
        <p><b>Declare
        Function lstrcpyn Lib &quot;KERNEL&quot; _</b></font></p>
        <p><b>(ByVal
        lpString1 As Any, ByVal lpString2 As Any, _</b></font></p>
        <p><b>ByVal
        nChars As Integer) As Long</b></font></p>
        
            <p>Like
            lstrcpy, but it allows you to specify a maximum
            number of characters to copy. Much safer.</font></p>
            <p><i><u>lpString1</u></i></font></p>
            <p>Target
            memory address or string. You must reserve at least
            as much room (minus 1) as you specify by the nChars
            argument.</font></p>
            <p><i><u>lpString2</u></i></font></p>
            <p>Source
            memory address or string.</font></p>
            <p><i><u>nChars</u></i></font></p>
            <p>The
            maximum number of characters you want to copy. You
            actually have to specify one more than the number of
            characters you want, because it counts the 0
            character. For example, if lpString2 is the string
            &quot;Happy&quot; and you specify nChars=3, then
            lpString1 becomes &quot;Ha&quot;.</font></p>
        
    
    <p><b>lstrlen</b></font></p>
    
        <p><b>Declare
        Function lstrlen Lib &quot;Kernel&quot; _</b></font></p>
        <p><b>(ByVal
        lpString As Any) As Integer</b></font></p>
        
            <p>This
            function is used to get the length of a string .The
            character 0 marks the end the string. The length
            returned does not count the 0.</font></p>
            <p><i><u>lpString</u></i></font></p>
            <p>Memory
            address or string you want to measure.</font></p>
        
    
    <p><b>OpenClipboard</b></font></p>
    
        <p><b>Declare
        Function OpenClipboard Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        hWnd As Integer) As Integer</b></font></p>
        
            <p>Opens
            the Clipboard so it can be accessed.</font></p>
            <p><i><u>hWnd</u></i></font></p>
            <p>Handle
            of the window accessing the Clipboard; you usually
            pass the result returned from GetActiveWindow().</font></p>
        
    
    <p><b>EmptyClipboard </b></font></p>
    
        <p><b>Declare
        Function EmptyClipboard Lib &quot;USER&quot; () As
        Integer</b></font></p>
        
            <p>Used
            to clear the Clipboard.</font></p>
        
    
    <p><b>SetClipboardData</b></font></p>
    
        <p><b>Declare
        Function SetClipboardData Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        wFormat As Integer, ByVal hMem As Integer) As Integer</b></font></p>
        
            <p>Used
            to put data on the Clipboard. You tell it the format
            of the data and where it's at (pass a memory block
            id).</font></p>
            <p><i><u>wFormat</u></i></font></p>
            <p>Constant
            that determines the kind of data you are copying to
            the Clipboard, i.e. the Clipboard format. See the API
            documentation for the possible choices. For text,
            use:</font></p>
            <p><b>Global
            Const CF_TEXT = 1</b></font></p>
            <p><i><u>hMem</u></i></font></p>
            <p>Id
            of the memory block you want &quot;copied to the
            Clipboard&quot;</font></p>
        
    
    <p><b>GetClipboardData</b></font></p>
    
        <p><b>Declare
        Function GetClipboardData Lib &quot;USER&quot; _</b></font></p>
        <p><b>(ByVal
        wFormat As Integer) As Integer</b></font></p>
        
            <p>Used
            to get data from the Clipboard. You tell it what kind
            (format) of data you want. It returns a memory block
            id for the memory where the Clipboard data is
            located. You normally assign it to an integer
            variable, for example:</font></p>
        
        <p><b>MemoryBlockId
        = GetClipboardData(CF_TEXT)</b></font></p>
        
            <p>You
            normally use GlobalLock to convert the id to an
            address and then use lstrcpy to copy the data into a
            string variable.</font></p>
            <p><i><u>wFormat</u></i></font></p>
            <p>Same
            as in SetClipboardData</font></p>
        
    
    <p><b>CloseClipboard</b></font></p>
    
        <p><b>Declare
        Function CloseClipboard Lib &quot;USER&quot; () As
        Integer</b></font></p>
        
            <p>You
            must close the Clipboard so other applications can
            use it. You can place this before any OpenClipboard
            call to insure that the Clipboard isn't already open.</font></p>
        
    
    <p><b><i>Examples
    of Memory Allocation and Clipboard Procedures</i></b></font></p>
    
        
            <p>The
            examples below assume the appropriate declarations
            and global constants, as described above, have be
            placed in the declaration area of a module.</font></p>
        
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            macro allows you to enter text in an InputBox and
            assign it to a string variable. The contents of the
            string variable is then placed on the Clipboard,
            (without placing it in any cell and without using
            EditCopy). The string variable value is copied to a
            global memory block, and then the Clipboard is told
            to point there. Note that you don't use GlobalFree to
            free up this memory block - the Clipboard is
            responsible for the memory after you use the
            SetClipboardData procedure.</font></p>
        
        <p><b>Sub
        PutTextOnClipboard()</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>Dim
        MemoryBlockId As Integer</b></font></p>
        <p><b>Dim
        MemoryBlockAddress As Long</b></font></p>
        <p><b>Dim s
        As String </b></font></p>
        <p></font>&nbsp;</p>
        <p><b>s =
        InputBox(&quot;Enter text to put on Clipboard&quot;)</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>OpenClipboard
        GetActiveWindow()</b></font></p>
        <p><b>EmptyClipboard</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>'ALLOCATE
        A GLOBAL MEMORY BLOCK</b></font></p>
        <p><b>MemoryBlockId
        = GlobalAlloc(GMEM_DDESHARE, Len(s))</b></font></p>
        <p><b>'CONVERT
        THE MEMORY BLOCK ID INTO AN ADDRESS</b></font></p>
        <p><b>MemoryBlockAddress
        = GlobalLock(MemoryBlockId)</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>'COPY
        THE STRING VARIABLE S INTO THE MEMORY BLOCK</b></font></p>
        <p><b>lstrcpy
        MemoryBlockAddress, s</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>'TELL
        THE CLIPBOARD WHERE TO GET ITS DATA FROM</b></font></p>
        <p><b>SetClipboardData
        CF_TEXT, MemoryBlockId</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>CloseClipboard</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>MsgBox
        &quot;Open up the Clipboard. Your string should be
        there.&quot;</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>End
        Sub</b></font></p>
    
    <p><b>Example</b></font></p>
    
        
            <p>This
            macro copies a maximum of 100 characters from the
            Clipboard directly into a string variable (without
            placing it in any cell and without using EditPaste).
            Then the macro shows the contents of the string
            variable.</font></p>
        
        <p><b>Sub
        GetTextFromClipboard()</b></font></p>
        <p><b>Dim
        MemoryBlockId As Integer</b></font></p>
        <p><b>Dim
        MemoryBlockAddress As Long</b></font></p>
        <p><b>Dim s
        As String * 100 'Must reserve room in the string</b></font></p>
        <p></font>&nbsp;</p>
        <p><b>OpenClipboard
        GetActiveWindow()</b></font></p>
        <p><b>MemoryBlockId
        = GetClipboardData(CF_TEXT)</b></font></p>
        <p><b>MemoryBlockAddress
        = GlobalLock(MemoryBlockId)</b></font></p>
        <p><b>lstrcpyn
        s, MemoryBlockAddress, 101 'Plus 1 for the 0 character</b></font></p>
        <p><b>GlobalUnlock
        MemoryBlockId</b></font></p>
        <p><b>CloseClipboard</b></font></p>
        <p><b>MsgBox
        &quot;The text on the Clipboard is: &quot; &amp; s</b></font></p>
        <p><b>End
        Sub</b></font></p>
    
    <H1><i>Lesson
    8 Exercises</i></H1>   
<ol>
 <li>Write an
    MSProject macro that starts a new instance of the Calculator
    application that comes with Windows (Calc.exe) and makes it a
    top most window.</font></li><br> <br>
    <li>Write an
    MSProject macro that clears the Clipboard and then waits in a
    DoEvents loop until it sees the word &quot;hello&quot; on the
    Clipboard. At that point, it activates the Microsoft Project
    window and displays a message &quot;goodbye&quot;. Use the
    appropriate API calls to do this - see the
    GetTextFromClipBoard example. Use lstrcpyn where nchars=6 (1
    + length of &quot;hello&quot;).</font></li>

</FONT></BODY>
</html>
