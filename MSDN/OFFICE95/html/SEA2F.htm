<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Exiting an Error Handler</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><body bgcolor="#FFFFFF" link=#003399 vlink=#996699>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT FACE="Verdana, Arial, Hevetica" SIZE="2">

<H2>Exiting an Error Handler</H2><P CLASS="t">The FileExists function presented earlier in this chapter uses the <B>Resume </B>statement within the error handler to rerun the statement that originally caused the error, and it uses the <B>Resume Next</B> statement to run the statement following the statement at which the error occurred.</P>
<P CLASS="t">You can use one of a number of statements to exit an error handler. The statement you use on any given occasion depends on the circumstances, as explained in the following table.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="66pt" VALIGN="TOP"><COL WIDTH="282pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="thf"><B>Statement</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="th"><B>Description</B></P></FONT></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tr"></P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt"><B>Resume Next</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt">Resumes execution at the statement immediately following the one that caused the error. Use this statement to skip over the statement that caused the error.</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt"><B>Resume</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt">Resumes execution at the statement that caused the error. Use this statement to repeat an operation after you've corrected the error.</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt"><B>Resume</B> <I>line</I></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt">Resumes execution at the label specified by <I>line</I>,<I> </I>where<I> line </I>is a nonzero line number or line label that's in the same procedure as the error handler. Because jumping to specific line numbers results in unstructured code, using this statement isn't recommended.</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt"><B>Error Err</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="tt">Triggers the most recent run-time error again. When this statement is run within the error handler, Visual Basic searches the calls list for another error handler.</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<P CLASS="t">The preceding table assumes that the error occurred in the same procedure as the error handler. If this isn't the case, Visual Basic searches the procedures in the calls list for another error handler. For more information about this situation, see the following section, "Handling Unanticipated Errors."</P>
<P CLASS="t">The following illustration shows how the <B>Resume</B> and <B>Resume Next</B> statements differ.</P>
<P CLASS="a">    <img src="APG0901.gif"></P>
<P CLASS="t">Generally, you use <B>Resume</B> whenever the user must correct the situation that caused the error before program execution can continue. Use <B>Resume Next</B> whenever a correction by the user isn't required, and you want to continue program execution without trying again to run the statement that caused the error. With <B>Resume Next</B>, you can write an error handler that never reveals run-time errors to the user.</P>
<P CLASS="t">For example, the following function uses an error handler to perform "safe" division on its arguments without revealing errors that might occur. <B>Null</B> is returned if errors do occur.</P>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2">Function Divide(numer, denom)
Const ERR_DIV0 = 11, ERR_OVERFLOW = 6, ERR_ILLFUNC = 5    
On Error GoTo MathHandler
    Divide    = numer / denom
    Exit Function
MathHandler:
    If Err = ERR_DIV0 Or Err = ERR_OVERFLOW Or Err = ERR_ILLFUNC Then
        Divide = Null        ' If error was Division by zero, Overflow,
                            ' or Illegal function call, return Null.
    Else
        MsgBox "Unanticipated error " &amp; Err &amp; ": " &amp; Error, _ <BR>          vbExclamation
        Divide = Null
    End If                    ' In all cases, Resume Next continues
    Resume Next                ' execution at the Exit Function statement.</FONT></PRE>
<P CLASS="spacing"><BR></P>
<PRE><FONT FACE="Courier" SIZE="2">End Function
</FONT></PRE></FONT>
</FONT></BODY></HTML>
