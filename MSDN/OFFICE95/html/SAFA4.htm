<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using DLLs from Visual Basic</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><body bgcolor="#FFFFFF" link=#003399 vlink=#996699>
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><FONT FACE="Verdana, Arial, Hevetica" SIZE="2">

<H1 CLASS="title">Using DLLs from Visual Basic</H1><P CLASS="t">  </P>
<P CLASS="t">Microsoft Office Technical Documentation Group</P>
<P CLASS="t">Created: November, 1995</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Office 95 Samples">
<PARAM name="Item2" value="3902">
</OBJECT><a href="javascript:sample1.Click()">
Click to open or copy the ADVDLL project files</A></P><P CLASS="t"></P>
<P CLASS="t">Using DLL functions from Visual Basic, Applications Edition, in Microsoft Excel is very similar to using DLL functions from Visual Basic. Chapter 26 of the <I>Microsoft Visual Basic</I> <I>Programmer's Guide</I> for version 4.0 of Visual Basic provides detailed guidelines and examples for calling DLL functions from Visual Basic. This article provides more specific information about using DLL functions from Visual Basic in Microsoft Excel.</P>
<P CLASS="t">The examples in this article were prepared and tested with Microsoft Visual C++ version 2.2, and run on Microsoft Windows 95. Visual C++ version 2.2 includes the OLE 2 header files and libraries required to create DLLs using variants, strings, objects, and arrays as described in this article.</P>
<P CLASS="t">You can use another C compiler and linker if they are capable of creating DLLs. In this case, you must also have the Microsoft OLE 2 Software Developer's Kit (SDK) to create DLLs using variants, strings, objects, or arrays.</P>
<P CLASS="t">In addition to the Help provided with Visual C++ and the OLE 2 SDK, Chapter 6 in Volume 2 of the <I>OLE 2 Programmer's Reference</I> provides valuable information about the functions used in the examples in this article.</P>
<P CLASS="t">Rewriting 16-bit DLL Code for Windows 95</P>
<P CLASS="t">Most 16-bit C-language DLL code will not work in Windows 95 without some modifications. The following sections discuss the changes required to run 16-bit DLL and Visual Basic code with Microsoft Excel for Windows 95. For more information about modifying 16-bit Visual Basic code and C-language DLLs, see the article "Porting 16-Bit Office-Based Solutions to 32-Bit Office" and Chapter 28 of the <I>Microsoft Visual Basic</I> <I>Programmer's Guide</I> for version 4.0 of Visual Basic.</P>
<P CLASS="t">Variable Size</P>
<P CLASS="t">In C-language DLLs written for 16-bit Windows, variables declared as integers (with the int data type) occupy 2 bytes (16 bits). In 32-bit Windows, the int data type occupies 4 bytes (32 bits). In both 16- and 32-bit Microsoft Excel VBA code, the <B>Integer</B> data type occupies only 16 bits, so in Microsoft Excel for Windows 95, the <B>Integer</B> and int data types are not equivalent.</P>
<P CLASS="t">The following table shows the data-type equivalencies for both 16- and 32-bit Windows.</P>
<P CLASS="t">  </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="17pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>Visual Basic data type</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><BR>Size of variable</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">16-bit Windows data types</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">32-bit Windows data types</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t"></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="17pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>Integer</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">2 bytes</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>int</B>, <B>short</B>, <B>WORD</B>, <B>HWND</B>, <B>HANDLE</B>, <B>WCHAR</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>short</B>, <B>WCHAR</B></P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>Long</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">4 bytes</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>long</B>, <B>LPSTR</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>int</B>, <B>long</B>, <B>HANDLE</B>, <B>HWND</B>, <B>LPSTR</B></P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">If your DLL code uses the int data type with arguments either passed in or returned to Visual Basic code, you must change those arguments to use the short data type.</P>
<P CLASS="t">String Variables and Unicode</P>
<P CLASS="t">One significant difference between 16-bit and 32-bit environments is in how string data is stored and manipulated. Visual Basic in Microsoft Excel uses ANSI (American National Standards Institute) characters (a single byte represents each character) to store and manipulate strings in both 16- and 32-bit versions. Conversely, 32-bit OLE Automation and the 32-bit OLE 2 API use Unicode (two bytes represent each character) to store and manipulate strings.</P>
<P CLASS="t">  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="41pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>Environment</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Character set used</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="41pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Windows 3.1 and Windows for Workgroups</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">ANSI</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">16- and 32-bit Visual Basic in Microsoft Excel, and 16-bit object libraries</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">ANSI</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Windows 95 API</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">ANSI</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">32-bit object libraries</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Unicode</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Windows NT API</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Unicode</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">OLE Automation in Windows NT</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Unicode</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">OLE Automation in Windows 95</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Unicode</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">When you pass string data from Visual Basic in Microsoft Excel, the data uses ANSI characters. You can leave the strings in ANSI format if you are simply passing them back to Microsoft Excel or calling a Windows 95 system function, but you may need Unicode characters if you use OLE Automation or you call an OLE 2 API function. You can use the MultiByteToWideChar function to convert an ANSI string to Unicode, and the WideCharToMultiByte function to convert a Unicode string to ANSI.</P>
<P CLASS="t">In addition, because Microsoft Excel uses ANSI characters in BSTR variables, you cannot use the standard OLE string allocation and reallocation functions (these functions now create Unicode strings). Two new functions, SysAllocStringByteLen and SysStringByteLen,  have been added to operate on single-byte character strings.</P>
<P CLASS="t">Windows API Functions</P>
<P CLASS="t">If your Visual Basic code calls a Windows API function, you will need to change the declaration in the Visual Basic code so that the correct system DLL is linked and the correct function is called. The easiest way to change the Visual Basic declaration is to look up the Windows API function in the Win32api.txt file and copy the declaration from that file into your Visual Basic code. For more information about calling 32-bit Windows system functions, see the article "Porting 16-Bit Office-Based Solutions to 32-Bit Office."</P>
<P CLASS="t">Using the Declare Statement</P>
<P CLASS="t">Before you can call a DLL function from Visual Basic, you must use the Declare statement to identify the function, the name of the DLL where it is located, and its argument types. Once the function is declared in a Visual Basic module, you can call it just as if it were part of your code.</P>
<P CLASS="t">For example, the following C-language function calculates the circumference of a circle given the circle's radius:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">double __declspec(dllexport) DoubleArg(double dRadius)</P>
<P CLASS="t">{</P>
<P CLASS="t">    return dRadius * 2 * 3.14159;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">In Microsoft Windows 95 and Windows NT, DLL functions called from Microsoft Excel must be declared using the __declspec(dllexport) keywords. In 16-bit Windows, DLL functions use the FAR PASCAL calling convention, and on the Apple Macintosh, code-resource functions use the pascal calling convention. The examples in this article were written to run on Microsoft Windows 95. If you are using 16-bit Windows or the Apple Macintosh, modify the examples accordingly.</P>
<P CLASS="t">This Visual Basic code uses the DoubleArg C function to display a table of circumference values:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function DoubleArg Lib "advdll32" _</P>
<P CLASS="t">    (ByVal radius As Double) As Double</P>
<P CLASS="t"></P>
<P CLASS="t">Sub CircumferenceTable()</P>
<P CLASS="t">    Worksheets(1).Activate</P>
<P CLASS="t">    Cells(1, 1).Value = "Radius"</P>
<P CLASS="t">    Cells(1, 2).Value = "Circumference"</P>
<P CLASS="t">    For i = 1 To 10</P>
<P CLASS="t">        Cells(i + 1, 1).Value = i</P>
<P CLASS="t">        Cells(i + 1, 2).Value = DoubleArg(i)</P>
<P CLASS="t">    Next</P>
<P CLASS="t">    Columns("a:b").AutoFit</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">The Declare statement uses the <B>ByVal</B> keyword because the argument is passed by value. Visual Basic coerces the variable <I>i</I> to type <B>Double</B> even though it is not explicitly declared in the code (with a <B>Dim</B> statement).</P>
<P CLASS="t">The REGISTER Macro Function</P>
<P CLASS="t">The REGISTER macro function and the <B>Declare</B> Visual Basic statement are not equivalent. Using the REGISTER function registers the DLL function only for the macro sheet or the worksheet. You cannot call the function from a Visual Basic module without using the <B>Declare</B> statement, even if you have already used the REGISTER function and called the same DLL function from a macro sheet. You can, however, call the function on a macro sheet by using the <B>ExecuteExcel4Macro</B> method to call the registered DLL function just as you would call any other Microsoft Excel macro function.</P>
<P CLASS="t">Similarly, DLL functions declared as public functions in a Visual Basic module can be called from any Visual Basic module in the workbook, but cannot be called from a macro sheet or worksheet. Public functions are those declared without either the <B>Public</B> or <B>Private</B> keywords (or explicitly declared with the <B>Public</B> keyword). If you declare the DLL function as <B>Private</B>, you can call the function only from the Visual Basic module where it is declared. You must use the REGISTER function before you can call the DLL function from a macro sheet or a worksheet, even if you have already used the <B>Declare</B> statement and called the same DLL function from a Visual Basic module.</P>
<P CLASS="t">To use the same DLL function in Visual Basic, on a macro sheet, and on a worksheet, you must both declare the function in a Visual Basic module <I>and</I> use the REGISTER function on the macro sheet and worksheet.</P>
<P CLASS="t">In addition, the REGISTER and UNREGISTER functions allow you to dynamically load and unload DLL functions. This is not possible in Visual Basic. Once a DLL function is loaded by a Visual Basic module (the first time a declared function in the DLL runs), the DLL remains loaded until you close the workbook that contains the Visual Basic module.</P>
<P CLASS="t">You can use the dynamic loading behavior of the REGISTER and UNREGISTER functions by creating a stub macro on a macro sheet. The stub macro should accept appropriate arguments for the DLL function, register the DLL function, call it, unregister it, and return the return value from the DLL function. You can then use the <B>ExecuteExcel4Macro</B> function to call the stub macro from Visual Basic. The stub macro in turn calls the DLL and returns to Visual Basic.</P>
<P CLASS="t">Passing Arguments by Reference</P>
<P CLASS="t">By default, Visual Basic passes arguments by reference, rather than by value. This means that the DLL function can modify the argument. When an argument is passed by reference, you must declare it as a pointer in the DLL function C-language prototype.</P>
<P CLASS="t">For example, this C-language function modifies its argument by multiplying it by two. The function returns <B>False</B> if the argument is less than zero.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) PointerArg(short *pn)</P>
<P CLASS="t">{                                                      </P>
<P CLASS="t">    if (*pn &lt; 0)</P>
<P CLASS="t">        return 0;    // False in Visual Basic</P>
<P CLASS="t">        </P>
<P CLASS="t">    *pn *= 2;</P>
<P CLASS="t">    return -1;        // True in Visual Basic</P>
<P CLASS="t">}                   </P>
<P CLASS="t">  </P>
<P CLASS="t">The Visual Basic declaration for this function does not include the <B>ByVal</B> keyword. You may include the <B>ByRef</B> keyword, but it isn't necessary.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function PointerArg Lib "advdll32" _</P>
<P CLASS="t">    (d As Integer) As Boolean</P>
<P CLASS="t"></P>
<P CLASS="t">Sub TestPointerArg()</P>
<P CLASS="t">    Dim n As Integer</P>
<P CLASS="t">    n = CInt(InputBox("Number?"))</P>
<P CLASS="t">    r = PointerArg(n)</P>
<P CLASS="t">    MsgBox n &amp; ":" &amp; r</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Using Variants</P>
<P CLASS="t">Passing an argument of <B>Variant</B> data type is very similar to passing any other argument type. In the DLL, you can use the VARIANT data structure to access the data contained in the argument. See Chapter 5 in Volume 2 of the <I>OLE 2 Programmer's Reference</I> for descriptions of the VARIANT data type.</P>
<P CLASS="t">The VARIANT type is a C-language structure containing a single member for the variable type, three reserved members, and a large named union that is used to access the variable data depending on the type.</P>
<P CLASS="t">For example, this C-language function determines the data type contained in the VARIANT argument passed by Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) VariantArg(VARIANT vt)</P>
<P CLASS="t">{   </P>
<P CLASS="t">    int i;</P>
<P CLASS="t">    char *pcBuf;</P>
<P CLASS="t">                                                      </P>
<P CLASS="t">    if (vt.vt == VT_DISPATCH)        // variant is an object</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">    else if (vt.vt == VT_BSTR) {    // variant is a string</P>
<P CLASS="t">        i = SysStringLen(vt.bstrVal);</P>
<P CLASS="t">        pcBuf = (char *)malloc(i + 1);</P>
<P CLASS="t">        WideCharToMultiByte(CP_ACP, 0, vt.bstrVal, i, pcBuf, i, NULL, NULL);</P>
<P CLASS="t">        i = atoi(pcBuf);</P>
<P CLASS="t">        free(pcBuf);</P>
<P CLASS="t">        return (short)i;</P>
<P CLASS="t">    }</P>
<P CLASS="t">    else if (vt.vt == VT_I2)        // variant is an integer</P>
<P CLASS="t">        return vt.iVal;</P>
<P CLASS="t">    else                            // variant is something else</P>
<P CLASS="t">        return -3;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">  </P>
<P CLASS="t"><B>Note</B>   When Microsoft Excel passes a <B>Variant</B> variable containing a string to a DLL, the string is in Unicode format. To use this string in functions requiring ANSI characters, you must convert the string using the WideCharToMultiByte function.</P>
<P CLASS="t">  </P>
<P CLASS="t">This Visual Basic code declares and calls the VariantArg function:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function VariantArg Lib "advdll32" _</P>
<P CLASS="t">    (ByVal v As Variant) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub VariantArgTest()</P>
<P CLASS="t">    MsgBox VariantArg(Worksheets(1))    ' -1</P>
<P CLASS="t">    MsgBox VariantArg("25")             ' 25</P>
<P CLASS="t">    MsgBox VariantArg(5)                ' 5</P>
<P CLASS="t">    MsgBox VariantArg(3.2)              ' -3</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">You could use this information to implement a function that accepts either a <B>Range</B> object or a text description of a range. If the argument contains an object, you can use IDispatch to access properties and methods of the object directly. If the argument contains a string, you can use IDispatch to create an object and then access its properties and methods.</P>
<P CLASS="t">Visual Basic in Microsoft Excel does not support all the data types supported by the VARIANT structure. The following table shows the allowed data types and their value constants. Microsoft Excel never returns a <B>Variant</B> of a data type not shown on this list.</P>
<P CLASS="t">  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="44pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t"><B>Data Type</B></P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Variant Constant</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t"></P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="46pt" VALIGN="TOP"><COL WIDTH="44pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Boolean</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_BOOL</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Currency (scaled integer)</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_CY</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Date</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_DATE</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Double (double-precision floating-point)</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_R8</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Integer</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_I2</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Long (long integer)</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_I4</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Object</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_DISPATCH</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">Single (single-precision floating-point)</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_R4</P></FONT></TD></TR><TR><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">String</P></FONT></TD><TD VALIGN="TOP">
	<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<P CLASS="t">VT_BSTR</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">Variants and Objects</P>
<P CLASS="t">The VariantArg function shows how you declare and call a DLL function with a <B>Variant</B> passed by value. A <B>Variant</B> passed by reference would be declared in C as a pointer to a VARIANT structure.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">void VariantByRef(LPVARIANT *pvar)</P>
<P CLASS="t">  </P>
<P CLASS="t">While it is possible to pass an object as a <B>Variant</B>, it is also possible to specifically declare a function that accepts only an object. An object is passed as a dispatch pointer, either by value:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">void ObjectByVal(LPDISPATCH pdisp)</P>
<P CLASS="t">  </P>
<P CLASS="t">or by reference:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">void ObjectByRef(LPDISPATCH *ppdisp)</P>
<P CLASS="t">  </P>
<P CLASS="t">When you pass a variant or object by reference, remember that your DLL code must free any allocated object, string, or array before replacing it. Failure to free allocations results in memory leaks. More information about freeing allocated strings and arrays appears in the following sections.</P>
<P CLASS="t"><B>Return Values</B></P>
<P CLASS="t">When your function returns an object, it is declared as returning a dispatch pointer:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">LPDISPATCH ReturnsObject(void)</P>
<P CLASS="t">  </P>
<P CLASS="t">Returning a Variant is simple:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">VARIANT ReturnsVariant(void)</P>
<P CLASS="t">  </P>
<P CLASS="t">Using Strings</P>
<P CLASS="t">When Visual Basic passes a string by reference to a C-language DLL, it uses a special OLE 2 data type called a BSTR. OLE Automation allows BSTR strings to be allocated and freed by any component that supports this data type.</P>
<P CLASS="t">In most cases, a BSTR can be treated like a pointer to a null-terminated string. In general, it's best if your C-language code does not directly manipulate the string data. You can dereference the pointer to copy data <I>from</I> the BSTR, however.</P>
<P CLASS="t">Instead of directly manipulating BSTR data, OLE Automation provides several functions that should be used to allocate, free, and reallocate BSTR values. These functions are listed in Chapter 6 in Volume 2 of the <I>OLE 2 Programmer's Reference.</I></P>
<P CLASS="t">  </P>
<P CLASS="t"><B>Note</B>   Because Microsoft Excel uses ANSI characters in BSTR variables, you cannot use the standard OLE string allocation and reallocation functions (these functions expect Unicode strings). Two new functions, SysAllocStringByteLen and SysStringByteLen,  have been added to operate on single-byte character strings.</P>
<P CLASS="t">  </P>
<P CLASS="t">When you pass a string by reference, your C-language function should declare the argument as a pointer to a BSTR. The pointer will never be NULL, but if the Visual Basic string is unassigned (that is, created with the <B>Dim</B> statement but not assigned a value), the BSTR pointed to will be NULL. If the string is assigned but empty, the first character will be a null character, and the string length will be zero.</P>
<P CLASS="t">The pointer may also reference a NULL pointer if the original variable was created as a <B>Variant</B> type, but not assigned a value. Visual Basic would coerce the variant to a string when it called the DLL, but because the variant is empty, it behaves like a declared but unassigned string.</P>
<P CLASS="t">The following code example tests for these conditions:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) SType(BSTR *pbstr)</P>
<P CLASS="t">{</P>
<P CLASS="t">    if (pbstr == NULL)     // pointer is null; will never happen</P>
<P CLASS="t">        return 1;</P>
<P CLASS="t">    if (*pbstr == NULL)    // string (or variant) is allocated by VB </P>
<P CLASS="t">                        // with Dim statement,</P>
<P CLASS="t">                        // but not yet assigned</P>
<P CLASS="t">        return 2;</P>
<P CLASS="t">    if (*pbstr[0] == 0)    // string is allocated </P>
<P CLASS="t">                        // and assigned to empty string ("")</P>
<P CLASS="t">        return 3;</P>
<P CLASS="t">    // string has a value; ANSI characters can be accessed at *pbstr</P>
<P CLASS="t">    return 4;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">This Visual Basic code declares and calls the SType function:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function SType Lib "advdll32" _</P>
<P CLASS="t">    (s As String) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub STypeTest()</P>
<P CLASS="t">    Dim s As String</P>
<P CLASS="t">    MsgBox SType(s) 'displays 2</P>
<P CLASS="t">    s = ""</P>
<P CLASS="t">    MsgBox SType(s) 'displays 3</P>
<P CLASS="t">    s = "test"</P>
<P CLASS="t">    MsgBox SType(s) 'displays 4</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Allocating BSTR Values</P>
<P CLASS="t">You should always use OLE functions to operate on BSTR values. If you need to change a BSTR value, first test the BSTR to see if it is already assigned. If it isn't, you may use the SysAllocStringByteLen function to assign a value to the BSTR. If the BSTR is already assigned, you must free the current assignment (with the SysFreeString function) before you can use SysAllocStringByteLen.</P>
<P CLASS="t">The following C-language code copies some number of characters from one BSTR into another. Notice that this example tests the second BSTR to see if it is already assigned. If it is, the example uses the SysFreeString function to free the existing string before replacing it.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) StringArgs(BSTR *pbstrArg1,</P>
<P CLASS="t">    BSTR *pbstrArg2, int cch)</P>
<P CLASS="t">{   </P>
<P CLASS="t">    // return error code if requested characters </P>
<P CLASS="t">    // less than zero, or input string is unassigned </P>
<P CLASS="t">    // or has too few characters</P>
<P CLASS="t">                                                               </P>
<P CLASS="t">    if (cch &lt; 0 || *pbstrArg1 == NULL || </P>
<P CLASS="t">            (int)SysStringByteLen(*pbstrArg1) &lt; cch)</P>
<P CLASS="t">        return -1;        </P>
<P CLASS="t">                                                                                </P>
<P CLASS="t">    if (*pbstrArg2 != NULL) {     // argument string is already assigned; </P>
<P CLASS="t">                                // we must free before allocating</P>
<P CLASS="t">        SysFreeString(*pbstrArg2);</P>
<P CLASS="t">    }</P>
<P CLASS="t"></P>
<P CLASS="t">    if ((*pbstrArg2 = SysAllocStringByteLen((char *)*pbstrArg1, cch))</P>
<P CLASS="t">             == NULL)</P>
<P CLASS="t">        return -2;</P>
<P CLASS="t">        </P>
<P CLASS="t">    return 0;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">This Visual Basic code declares and calls the StringArgs function:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function StringArgs Lib "advdll32" _</P>
<P CLASS="t">    (inpStr As String, outStr As String, _</P>
<P CLASS="t">    ByVal n As Integer) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub StringArgsTest()</P>
<P CLASS="t">    Dim newStr As String</P>
<P CLASS="t">    x = StringArgs("abracadabra", newStr, 5)</P>
<P CLASS="t">    MsgBox x &amp; ":" &amp; newStr</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Using User-Defined Data Structures</P>
<P CLASS="t">The <B>Type</B> statement in Visual Basic can be used to create user-defined data structures. For example, the following Visual Basic data type and C-language structure are equivalent.</P>
<P CLASS="t">In Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Type ARG</P>
<P CLASS="t">    i as Integer</P>
<P CLASS="t">    str as String</P>
<P CLASS="t">End Type</P>
<P CLASS="t">  </P>
<P CLASS="t">In C:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">typedef struct {</P>
<P CLASS="t">    int i;</P>
<P CLASS="t">    BSTR str;</P>
<P CLASS="t">} ARG;</P>
<P CLASS="t">  </P>
<P CLASS="t">User-defined data types cannot be passed by value; they must be passed by reference. Your C function should declare the argument as a pointer to the structure. If the structure contains BSTR values (as this example does) the rules discussed above apply to those values; you must test the BSTR before you reassign it (and free it if it is already allocated).</P>
<P CLASS="t">For example, this C-language function fills a structure with a string and the length of the string:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) StructArg(ARG *parg, char *szArg)</P>
<P CLASS="t">{   </P>
<P CLASS="t">    unsigned int cch;        </P>
<P CLASS="t">    BSTR bstr;</P>
<P CLASS="t">                      </P>
<P CLASS="t">    if (parg == NULL)</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">    </P>
<P CLASS="t">    // allocate a local string first; if this fails, </P>
<P CLASS="t">    // we have not touched the passed-in string</P>
<P CLASS="t">    </P>
<P CLASS="t">    cch = strlen(szArg);</P>
<P CLASS="t">    if ((bstr = SysAllocStringByteLen(szArg, cch)) == NULL)</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">        </P>
<P CLASS="t">    if (parg-&gt;bstr != NULL)    // string is already assigned</P>
<P CLASS="t">        SysFreeString(parg-&gt;bstr);</P>
<P CLASS="t">        </P>
<P CLASS="t">    parg-&gt;s = (short)cch;</P>
<P CLASS="t">    parg-&gt;bstr = bstr;</P>
<P CLASS="t">    </P>
<P CLASS="t">    return parg-&gt;s;</P>
<P CLASS="t">} </P>
<P CLASS="t">  </P>
<P CLASS="t">Declared and called from Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function StructArg Lib "advdll32" _</P>
<P CLASS="t">    (a As ARG, ByVal s As String) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub StructArgTest()</P>
<P CLASS="t">    Dim x As ARG</P>
<P CLASS="t">    MsgBox StructArg(x, "abracadabra")</P>
<P CLASS="t">    MsgBox x.str &amp; ":" &amp; x.i    'displays string and length</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Using Arrays</P>
<P CLASS="t">OLE 2 provides a special data type for arrays passed from Visual Basic to a DLL. This data type, called a SAFEARRAY, allows both Visual Basic and the DLL to allocate, free, and access array data in a controlled way.</P>
<P CLASS="t">Your DLL should always use OLE Automation functions to allocate and access safe arrays. These functions are described in Chapter 6 in Volume 2 of the <I>OLE 2 Programmer's Reference.</I> When OLE Automation passes a safe array to your DLL, you receive a pointer to a pointer to the array itself. Like BSTR pointers, a SAFEARRAY pointer may point to a NULL array if the array has been declared but not yet dimensioned:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Dim a() as Integer</P>
<P CLASS="t">  </P>
<P CLASS="t">The pointer itself will never be NULL, however.</P>
<P CLASS="t">The following example determines the upper and lower bounds of an array and then loops through the array producing the sum of the elements in the array:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) SumArray(</P>
<P CLASS="t">    FPSAFEARRAY *ppsa, long *plResult)</P>
<P CLASS="t">{          </P>
<P CLASS="t">    short sElem;</P>
<P CLASS="t">    long lLb, lUb, l, lResult;</P>
<P CLASS="t">                  </P>
<P CLASS="t">    if (*ppsa == NULL) // array has not been initialized</P>
<P CLASS="t">        return -4;</P>
<P CLASS="t">    </P>
<P CLASS="t">    if ((*ppsa)-&gt;cDims != 1)    // check number of dimensions</P>
<P CLASS="t">        return -5;</P>
<P CLASS="t">                                      </P>
<P CLASS="t">    // get the upper and lower bounds of the array</P>
<P CLASS="t">                                        </P>
<P CLASS="t">    if (FAILED(SafeArrayGetLBound(*ppsa, 1, &amp;lLb)) ||</P>
<P CLASS="t">            FAILED(SafeArrayGetUBound(*ppsa, 1, &amp;lUb)))</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">    </P>
<P CLASS="t">    // loop through the array and add the elements</P>
<P CLASS="t">    </P>
<P CLASS="t">    for (l = lLb, lResult = 0; l &lt;= lUb; l++) {                  </P>
<P CLASS="t">        if (FAILED(SafeArrayGetElement(*ppsa, &amp;l, &amp;sElem)))</P>
<P CLASS="t">            return -2;                           </P>
<P CLASS="t">        lResult += sElem;</P>
<P CLASS="t">    } </P>
<P CLASS="t">        </P>
<P CLASS="t">    *plResult = lResult;             </P>
<P CLASS="t">    return 0;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">Declared and called from Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function SumArray Lib "advdll32" _</P>
<P CLASS="t">    (a() As Integer, r As Long) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub SumArrayTest()</P>
<P CLASS="t">    Dim n(5) As Integer</P>
<P CLASS="t">    Dim result As Long</P>
<P CLASS="t">    For i = 0 To 5</P>
<P CLASS="t">        n(i) = 2</P>
<P CLASS="t">    Next</P>
<P CLASS="t">    x = SumArray(n, result)</P>
<P CLASS="t">    MsgBox x &amp; ":" &amp; result</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Visual Basic does minimal type checking and enforcement on array element size. Because this function was declared as accepting only an array of integers, it is safe to use an integer element in the call to the SafeArrayGetElement function in the DLL. If the function was declared as accepting an array of any type, however, the Visual Basic code might pass an array of long values; in this case, the C-language function would produce incorrect results. If your DLL function must accept an array of any type, you should use an array of variants and check the variant type in the DLL.</P>
<P CLASS="t">Static Arrays</P>
<P CLASS="t">If you declare and dimension an array:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Dim x(5) as String</P>
<P CLASS="t">  </P>
<P CLASS="t">The pointer you receive in your C function points to a static array (the fFeatures element of the SAFEARRAY structure has the FADF_STATIC flag set). You can read and redimension the array, but you cannot modify the pointer, and you cannot copy over the array. If you need to modify the array in the DLL (to create a new one, for example), you must not dimension it in Visual Basic.</P>
<P CLASS="t">Allocating Arrays</P>
<P CLASS="t">Your DLL can create new safe arrays or change the size of existing arrays. When you create a new array, you should use a local variable rather than modify a passed-in array pointer. Once the allocation and any subsequent operations on the array are successful, you can assign the passed-in pointer to the local pointer and return from the function.</P>
<P CLASS="t">The following example accepts an array pointer and creates an array containing 10 integer elements. If the passed-in array has already been initialized, the function redimensions the existing array.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) NewArray(FPSAFEARRAY *ppsa)</P>
<P CLASS="t">{              </P>
<P CLASS="t">    SAFEARRAY *psa;</P>
<P CLASS="t">    SAFEARRAYBOUND sa;</P>
<P CLASS="t">    </P>
<P CLASS="t">    sa.lLbound = 1;       </P>
<P CLASS="t">    sa.cElements = 10;</P>
<P CLASS="t">                      </P>
<P CLASS="t">    if (*ppsa == NULL) { //array not yet initialized               </P>
<P CLASS="t">        if ((psa = SafeArrayCreate(VT_I2, 1, &amp;sa)) == NULL)</P>
<P CLASS="t">            return -2;</P>
<P CLASS="t">        *ppsa = psa;</P>
<P CLASS="t">    }</P>
<P CLASS="t">    else {</P>
<P CLASS="t">        if ((*ppsa)-&gt;cDims != 1)    // check array dimensions</P>
<P CLASS="t">            return -1;                // fail if multi-dimension</P>
<P CLASS="t">                              </P>
<P CLASS="t">        if (FAILED(SafeArrayRedim(*ppsa, &amp;sa)))</P>
<P CLASS="t">            return -3;                    </P>
<P CLASS="t">    }</P>
<P CLASS="t">    </P>
<P CLASS="t">    return 0;</P>
<P CLASS="t">}</P>
<P CLASS="t">  </P>
<P CLASS="t">Declared and called from Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function NewArray Lib "advdll32" _</P>
<P CLASS="t">    (a() As Integer) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub NewArrayTest()</P>
<P CLASS="t">    Dim a(12) As Integer</P>
<P CLASS="t">    MsgBox NewArray(a) &amp; ":" &amp; LBound(a) &amp; ":" &amp; UBound(a)</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Destroying Arrays</P>
<P CLASS="t">Like BSTRs, SAFEARRAYs must be freed before they can be destroyed. When Visual Basic passes an existing array to your DLL, it is passed as a static array that cannot be destroyed. Your DLL can create its own arrays, however. When you no longer need an array, it should be destroyed.</P>
<P CLASS="t">You must be careful when you destroy an existing array. Freeing the array frees only the array memory; if the array contains any pointers (such as BSTR values) these will not be freed. In this case, you must free each BSTR element individually and then free the array. If you do not know what the array contains, you should probably not free or redimension the array.</P>
<P CLASS="t">Using Arrays of Strings</P>
<P CLASS="t">Safe arrays can contain elements of any allowable type, including BSTRs and user-defined data structures. BSTRs inside arrays should be manipulated with the same OLE Automation functions as ordinary BSTRs. Always remember to free any existing BSTR before allocating a new one, or use the reallocation function.</P>
<P CLASS="t">The following example creates or redimensions an array of strings. Any existing BSTR data in the array is freed before new data is copied into the array.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) StringArray(FPSAFEARRAY *ppsa)</P>
<P CLASS="t">{       </P>
<P CLASS="t">    LONG l;</P>
<P CLASS="t">    BSTR bstr; </P>
<P CLASS="t">    SAFEARRAY *psa;</P>
<P CLASS="t">    SAFEARRAYBOUND sa;</P>
<P CLASS="t">        </P>
<P CLASS="t">    sa.lLbound = 0;</P>
<P CLASS="t">    sa.cElements = 3;</P>
<P CLASS="t"></P>
<P CLASS="t">    if ((*ppsa)-&gt;cDims != 1)    // check array dimensions</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">                              </P>
<P CLASS="t">    if (*ppsa == NULL) { // array not yet initialized</P>
<P CLASS="t">        if ((psa = SafeArrayCreate(VT_BSTR, 1, &amp;sa)) == NULL)</P>
<P CLASS="t">            return -2;</P>
<P CLASS="t">        *ppsa = psa;</P>
<P CLASS="t">    }</P>
<P CLASS="t">    else if (FAILED(SafeArrayRedim(*ppsa, &amp;sa)))</P>
<P CLASS="t">        return -3;                    </P>
<P CLASS="t">        </P>
<P CLASS="t">    // loop through the array; get each element and free</P>
<P CLASS="t">    // any existing string, then allocate the new string</P>
<P CLASS="t">    // and put it in the array</P>
<P CLASS="t">    </P>
<P CLASS="t">    for (l = sa.lLbound; l &lt; (long)sa.cElements; l++) {</P>
<P CLASS="t">        if (FAILED(SafeArrayGetElement(*ppsa, &amp;l, &amp;bstr)))</P>
<P CLASS="t">            return -4;                                </P>
<P CLASS="t">        SysFreeString(bstr);</P>
<P CLASS="t">        if ((bstr = SysAllocStringByteLen("test string", 11)) == NULL)</P>
<P CLASS="t">            return -5;      </P>
<P CLASS="t">        if (FAILED(SafeArrayPutElement(*ppsa, &amp;l, bstr)))</P>
<P CLASS="t">            return -6;</P>
<P CLASS="t">    }                </P>
<P CLASS="t">    </P>
<P CLASS="t">    return 0;</P>
<P CLASS="t">}    </P>
<P CLASS="t">  </P>
<P CLASS="t">Declared and called from Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function StringArray Lib "advdll32" _</P>
<P CLASS="t">    (s() As String) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub StringArrayTest()</P>
<P CLASS="t">    Dim s(5) As String</P>
<P CLASS="t">    MsgBox StringArray(s) &amp; ":" &amp; s(1)</P>
<P CLASS="t">End Sub</P>
<P CLASS="t"></P>
<P CLASS="t">'start NewArray</P>
<P CLASS="t">Sub NewArrayTest()</P>
<P CLASS="t">    Dim a(12) As Integer</P>
<P CLASS="t">    MsgBox NewArray(a) &amp; ":" &amp; LBound(a) &amp; ":" &amp; UBound(a)</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Using Arrays of Data Structures</P>
<P CLASS="t">You cannot use the SafeArrayCreate function to create a new array of user-defined structures. Instead, you must use the SafeArrayAllocDescriptor function to create the array descriptor, then use the SafeArrayAllocData function to allocate space for the array data, and finally use the SafeArrayAccessData function to return a pointer to the data. The SafeArrayAccessData function locks the array data; when you are done with the array, you should call the SafeArrayUnaccessData function to unlock it.</P>
<P CLASS="t">You cannot replace an existing array, so if your Visual Basic code passes a dimensioned array you must redimension it. Remember to free any existing BSTR pointers in the array before overwriting them.</P>
<P CLASS="t">The following example creates or redimensions an array of data structures then copies an array of strings into the structures, adding the string length to each structure. Any existing BSTR data in the array is freed before new data is copied into the array.</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">short __declspec(dllexport) StructArray(FPSAFEARRAY *ppsaArg,</P>
<P CLASS="t">    FPSAFEARRAY *ppsaStr)</P>
<P CLASS="t">{               </P>
<P CLASS="t">    ARG *parg;</P>
<P CLASS="t">    SAFEARRAY *psa;</P>
<P CLASS="t">    BSTR *pbstr;</P>
<P CLASS="t">    ULONG i, cElements;</P>
<P CLASS="t">                           </P>
<P CLASS="t">    if (*ppsaStr == NULL)</P>
<P CLASS="t">        return -1;</P>
<P CLASS="t">        </P>
<P CLASS="t">    cElements = (*ppsaStr)-&gt;rgsabound[0].cElements;</P>
<P CLASS="t">    </P>
<P CLASS="t">      if (*ppsaArg == NULL) { // create a new array</P>
<P CLASS="t">      </P>
<P CLASS="t">        if (FAILED(SafeArrayAllocDescriptor(1, &amp;psa)))</P>
<P CLASS="t">             return -3;</P>
<P CLASS="t">    </P>
<P CLASS="t">        // set up the SAFEARRAY structure</P>
<P CLASS="t">        // and allocate data space</P>
<P CLASS="t">                            </P>
<P CLASS="t">        psa-&gt;fFeatures = 0;</P>
<P CLASS="t">          psa-&gt;cbElements = sizeof(ARG);                </P>
<P CLASS="t">          psa-&gt;rgsabound[0].cElements = cElements;</P>
<P CLASS="t">          psa-&gt;rgsabound[0].lLbound = (*ppsaStr)-&gt;rgsabound[0].lLbound;</P>
<P CLASS="t">  </P>
<P CLASS="t">          if (FAILED(SafeArrayAllocData(psa))) {</P>
<P CLASS="t">              SafeArrayDestroyDescriptor(psa);</P>
<P CLASS="t">            return -4;                      </P>
<P CLASS="t">        }</P>
<P CLASS="t">        </P>
<P CLASS="t">        // get a pointer to the new data</P>
<P CLASS="t">        </P>
<P CLASS="t">          if (FAILED(SafeArrayAccessData(psa, </P>
<P CLASS="t">                  (void **)&amp;parg))) {</P>
<P CLASS="t">            SafeArrayDestroy(psa);</P>
<P CLASS="t">            return -5;</P>
<P CLASS="t">          }                            </P>
<P CLASS="t">      } </P>
<P CLASS="t">      else { // redimension the old array</P>
<P CLASS="t">          if (FAILED(SafeArrayRedim(*ppsaArg, </P>
<P CLASS="t">                  (*ppsaStr)-&gt;rgsabound)))</P>
<P CLASS="t">              return -6;</P>
<P CLASS="t">        </P>
<P CLASS="t">        // get a pointer to the old data              </P>
<P CLASS="t">        </P>
<P CLASS="t">          if (FAILED(SafeArrayAccessData(*ppsaArg, </P>
<P CLASS="t">                  (void **)&amp;parg)))</P>
<P CLASS="t">              return -7;</P>
<P CLASS="t">      }</P>
<P CLASS="t">          </P>
<P CLASS="t">    // get a pointer to the string array data</P>
<P CLASS="t">                               </P>
<P CLASS="t">    if (FAILED(SafeArrayAccessData(*ppsaStr, </P>
<P CLASS="t">            (void **)&amp;pbstr)))</P>
<P CLASS="t">        return -8;</P>
<P CLASS="t">    </P>
<P CLASS="t">    // allocate strings in the structure array and </P>
<P CLASS="t">    // fill them with strings from the string array.</P>
<P CLASS="t">    // free any old BSTRs in the structure</P>
<P CLASS="t">                                   </P>
<P CLASS="t">      for (i = 0; i &lt; cElements; i++) {</P>
<P CLASS="t">          SysFreeString(parg[i].bstr);</P>
<P CLASS="t">        parg[i].s = strlen((char *)pbstr[i]);</P>
<P CLASS="t">          parg[i].bstr = </P>
<P CLASS="t">            SysAllocStringByteLen((char *)pbstr[i], parg[i].s);</P>
<P CLASS="t">       }</P>
<P CLASS="t">      </P>
<P CLASS="t">    // release pointers and move the structure</P>
<P CLASS="t">    // array pointer to the new array if we created one</P>
<P CLASS="t">                          </P>
<P CLASS="t">      SafeArrayUnaccessData(*ppsaStr);</P>
<P CLASS="t">    </P>
<P CLASS="t">    if (*ppsaArg == NULL) {</P>
<P CLASS="t">        SafeArrayUnaccessData(psa);</P>
<P CLASS="t">        *ppsaArg = psa;                         </P>
<P CLASS="t">    }</P>
<P CLASS="t">    else </P>
<P CLASS="t">        SafeArrayUnaccessData(*ppsaArg);</P>
<P CLASS="t">        </P>
<P CLASS="t">    return 0;</P>
<P CLASS="t">}                 </P>
<P CLASS="t">  </P>
<P CLASS="t">Declared and called from Visual Basic:</P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">Declare Function StructArray Lib "advdll32" _</P>
<P CLASS="t">    (x() As ARG, s() As String) As Integer</P>
<P CLASS="t"></P>
<P CLASS="t">Sub StructArrayTest()</P>
<P CLASS="t">    Dim x() As ARG</P>
<P CLASS="t">    Dim s(1 To 4) As String</P>
<P CLASS="t">    s(1) = "yellow"</P>
<P CLASS="t">    s(2) = "orange"</P>
<P CLASS="t">    s(3) = "blue"</P>
<P CLASS="t">    s(4) = "green"</P>
<P CLASS="t">    n = StructArray(x, s)</P>
<P CLASS="t">    If n = 0 Then</P>
<P CLASS="t">        Worksheets(1).Activate</P>
<P CLASS="t">        Range("a1:c25").Clear</P>
<P CLASS="t">        For i = LBound(x) To UBound(x)</P>
<P CLASS="t">            Cells(i + 1, 1) = i</P>
<P CLASS="t">            Cells(i + 1, 2) = x(i).str</P>
<P CLASS="t">            Cells(i + 1, 3) = x(i).i</P>
<P CLASS="t">        Next</P>
<P CLASS="t">    Else</P>
<P CLASS="t">        MsgBox "StructArray failed, returned" &amp; n</P>
<P CLASS="t">    End If</P>
<P CLASS="t">End Sub</P>
<P CLASS="t">  </P>
<P CLASS="t">Using the Microsoft Excel C API and Visual Basic</P>
<P CLASS="t">When you call a DLL function from Visual Basic in Microsoft Excel, the DLL function can use the Microsoft Excel C Applications Programming Interface (C API) functions to call back into Microsoft Excel. You cannot use the C API across processes, however. The DLL using the C API must be called from Visual Basic running in Microsoft Excel (a DLL called from Microsoft Project or Microsoft Visual Basic Professional cannot call the C API). In addition, the C API can only be called after Microsoft Excel has called the DLL. This qualification is met when Visual Basic in Microsoft Excel calls the DLL, and the DLL in turn calls the C API. When the DLL function is called by an external event (such as a DDE command from another application or a Windows timer), the DLL function cannot call the C API.</P>
<P CLASS="t">Type Libraries</P>
<P CLASS="t">You can create a type library for your DLL. The type library can contain constant and function declarations and other information about the DLL. Once you have created a type library, you can use the References command on the Tools menu in Microsoft Excel to load the type library. Once loaded, the constant and function declarations are available in Visual Basic without using <B>Declare</B> statements.</P>
<P CLASS="t">Visual Basic in Microsoft Excel does not support user-defined data-structure declarations in type libraries (user-defined data structures are those declared with the Visual Basic <B>Type</B> statement or the C/C++ struct statement). To use the structures in your Visual Basic code, you will have to add their declarations to the module.</P>
<P CLASS="t">For more information about creating type libraries, see Chapter 7 in Volume 2 of the <I>OLE 2 Programmer's Reference.</I></P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t">  </P>
<P CLASS="t"></P>
<P CLASS="t"></P>
<P CLASS="t"> </P></FONT>
</FONT></BODY></HTML>
