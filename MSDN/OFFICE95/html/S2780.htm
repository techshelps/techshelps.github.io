<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Subroutines and User-Defined Functions</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">


<FONT FACE="ARIAL,HELVETICA" SIZE="2"><H2 CLASS="h1">Subroutines and User-Defined Functions</H2><P CLASS="t">As your macros become more complicated, you can split the code into self-contained units called <I>subroutines</I> and <I>user-defined functions</I>. A subroutine carries out a task; it is like a custom-made statement. A user-defined function returns information and may also carry out a task. Subroutines and functions offer at least two advantages:</P>
<UL><LI>    Instructions stored in a subroutine or function are reusable. A complex macro may need to carry out a task more than once. Rather than duplicating the instructions, you can store them in a subroutine or function that the macro "calls" when needed. Moreover, subroutines and functions are available not just to the current macro but to other macros that might need them.</LI><LI>    Subroutines and functions allow you to break down complex tasks into smaller pieces. Instead of developing your macro in terms of one long process, you can break it down into manageable parts. Each subroutine or function can be tested separately, so you can more easily isolate problems and test the macro as a whole.</LI></UL><P></P>
<H3 CLASS="h3"><A NAME="sec0"></A>Subroutines</H3><P CLASS="t">A subroutine is a kind of macro within a macro. It carries out a particular task, just as the macro as a whole does. Virtually any part of a macro can be placed in a subroutine, but usually it only makes sense to create a subroutine for a part that is self-contained or that will be used more than once. For this reason, subroutines are generally not needed in simple macros.</P>
<P CLASS="t">Every macro has a main subroutine that begins with the instruction Sub MAIN. A&nbsp;subroutine that you create is defined in the same way as the main subroutine,<B> </B>but requires a different name:</P>
<P CLASS="syn"><B>Sub </B><I>SubroutineName</I>[<B>(</B><I>ArgumentList</I><B>)</B>]<BR>    <I>Series of instructions</I><BR><B>End Sub</B></P>
<P CLASS="t">The <I>SubroutineName</I> is whatever name you choose that isn't a reserved word or a&nbsp;variable name. The limitations are the same as those for variable names (see "Variables" in Chapter 3, "WordBasic Fundamentals"). <I>ArgumentList</I> is a list of variables, separated by commas, that accept values passed to the subroutine. See "Sharing Values Among Subroutines and Functions" later in this chapter.</P>
<P CLASS="t">The <B>Sub…End Sub</B> instructions cannot be placed within the main subroutine or within any other subroutine. In other words, you cannot nest subroutines as you can WordBasic control structures, such as <B>For…Next </B>loops or <B>If</B> conditionals.</P>
<P CLASS="t">On the other hand, the instruction that runs, or "calls," the subroutine <I>is</I> placed within another subroutine. You can use the <B>Call</B> statement to run a subroutine, or you can use just the name of the subroutine as the instruction. (The <B>Call</B> keyword makes the macro easier to read&nbsp;—&nbsp;it's clear that a subroutine and not a built-in WordBasic statement is being run.) After the instructions in the subroutine have been carried out, control reverts to the routine that called the subroutine, as shown in the following diagram.</P>
<P CLASS="a">    <img src="ATR0402.gif"></P>
<P CLASS="t">In the following example, the BeepMsgExit subroutine is called if the user chooses the Yes button in a message box that asks if he or she wants to quit Word:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    response&nbsp;=&nbsp;MsgBox("Do you want to quit Word?", 4)
    If response&nbsp;=&nbsp;-1 Then
        Call BeepMsgExit
    End If
End Sub

Sub BeepMsgExit
    Beep
    MsgBox("Quitting Word now...", -8) 
    FileExit 1
End Sub
</PRE>
<H3 CLASS="h3"><A NAME="sec1"></A>User-Defined Functions</H3><P CLASS="t">User-defined functions are similar to subroutines&nbsp;—&nbsp;they are self-contained units of code that are called from one or more subroutines. But unlike a subroutine, a user-defined function returns a value, just as built-in WordBasic functions do. The rules for using functions you create are the same as those for built-in functions. Generally, you define a function because WordBasic does not include a function designed to return the particular value you need.</P>
<P CLASS="t">You define new functions in a manner similar to subroutines, except that instead of using the <B>Sub</B> instruction, you use the <B>Function</B> instruction. The syntax is as follows:</P>
<P CLASS="syn"><B>Function</B>  <I>FunctionName</I>[(<I>ArgumentList</I>)]<BR><I>    Series of instructions<BR></I>    <I>FunctionName</I>&nbsp;=&nbsp;<I>value</I><BR><B>End Function</B></P>
<P CLASS="t">The <I>ArgumentList</I> is a list of variables, separated by commas, that accept values passed to the function. The function returns a value by assigning it to the function name itself, using the syntax <I>FunctionName</I>&nbsp;=&nbsp;<I>value</I>. A user-defined function can return either a numeric or string value. Functions that return string values have function names that end with the dollar sign ($).</P>
<P CLASS="t">In the following example, the MyDateTime$ function is called by the main subroutine to display the date and time in a message box. Note that no arguments are passed to this function, so it does not end with parentheses as a built-in Word function would (for example, <B>Font$</B><B>()</B>); it looks just like a variable.</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    MsgBox "The date and time is: " + MyDateTime$
End Sub

Function MyDateTime$
    mDate$ = Date$()
    mTime$ = Time$()  
    MyDateTime$ = mDate$ + " " + mTime$
End Function
</PRE>
<H3 CLASS="h3"><A NAME="sec2"></A>Sharing Values Among Subroutines and Functions</H3><P CLASS="t">By default, a variable is available only within the subroutine or function in which it is initially used. However, subroutines and functions often need to exchange or share values. The following two methods are available:</P>
<UL><LI>    You can use a <B>Dim Shared</B> instruction to declare a <I>shared </I>variable.</LI><LI>    You can <I>pass</I> values to a specific subroutine or function.</LI></UL><P></P>
<H4 CLASS="h4"><A NAME="sec3"></A>Shared Variables</H4><P CLASS="t">A shared variable can be used in any subroutine or function in the macro. Here is the syntax for declaring a shared variable:</P>
<P CLASS="syn"><B>Dim Shared</B> <I>Var</I><B>,</B> <I>Var1</I><B>,</B> <I>Var2</I>…</P>
<P CLASS="t">A single<B> Dim Shared</B> instruction can be used to declare several shared variables. Every type of variable, including number, string, and array variables, can be declared as shared. A <B>Dim</B> <B>Shared</B> instruction is not placed inside a subroutine or function since it applies to all the subroutines and functions within the macro. Generally, you declare shared variables at the beginning of a macro, before the main subroutine.</P>
<P CLASS="t">In the following example, the variable num is declared as shared:</P>
<P CLASS="spacing"><BR></P>
<PRE>Dim Shared num                    'Declare "num" as a shared variable
Sub MAIN
    num&nbsp;=&nbsp;6                        'Set the value of num
    AddTenRoutine                'Call the routine
End Sub

Sub AddTenRoutine
    num&nbsp;=&nbsp;num + 10                'Increase the value of num by 10
    Print num                    'Display the new value of num
End Sub
</PRE>
<P CLASS="t">The main subroutine sets num equal to 6, and then calls the AddTenRoutine subroutine. The subroutine adds 10 to num and then displays the value 16. If num was not declared as a shared variable, the value displayed would be 10, because num would have no value at the start of the AddTenRoutine subroutine.</P>
<P CLASS="t">Any subroutine can affect the value of a shared variable. If you have many subroutines, shared variables can be a source of problems. For example, you might intend to use a variable named "count" in two subroutines. Later on, if you forget that you've already used "count" and you use it in a new subroutine, you could create an error that might be difficult to find. You can avoid this problem by&nbsp;passing variable values through subroutine or function arguments.</P>
<H4 CLASS="h4"><A NAME="sec4"></A>Passing Values to Subroutines and Functions</H4><P CLASS="t">You can pass values from one subroutine or user-defined function directly to another through <I>arguments</I>. Arguments are variables in a subroutine or function that initially receive their values from the calling subroutine or function. Unlike shared variables, whose values can be affected by any subroutine or function, values passed to subroutines and user-defined functions can be affected only by the subroutines or functions involved.</P>
<P CLASS="t">Here is the syntax for subroutine arguments in the <B>Call </B>statement:</P>
<P CLASS="syn"><B>[Call]</B> <I>SubroutineName </I>[<I>argument1</I><B>, </B><I>argument2</I><B>,</B> …]</P>
<P CLASS="t">The syntax for passing values to a user-defined function is similar; the main difference is that the arguments are enclosed in parentheses:</P>
<P CLASS="syn"><I>FunctionName</I>[<B>(</B><I>argument1</I><B>, </B><I>argument2</I><B>,</B> …<B>)</B>]</P>
<P CLASS="t">Note that you can pass any number of values, each separated by a comma.</P>
<P CLASS="t">Here is an example of passing a value to the AddTenRoutine shown earlier:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    num&nbsp;=&nbsp;6                    'Set the value of num
    AddTenRoutine num        'Call the routine and specify "num"
End Sub

Sub AddTenRoutine(var1)
    var1&nbsp;=&nbsp;var1 + 10            'Increase the value of var1 by 10
    Print var1                'Display the new value of var1
End Sub
</PRE>
<P CLASS="t">The following example uses a function called FindAverage() to average two&nbsp;numbers. The variables a and b, defined as 6 and 10, are passed to the FindAverage() function, which averages the two values. The main subroutine then displays the result.</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    a = 6
    b = 10
    Print FindAverage(a, b)
End Sub

Function FindAverage(firstnum, secondnum)
    FindAverage = (firstnum + secondnum) / 2
End Function
</PRE>
<P CLASS="t">Note that the variable names in the subroutine or user-defined function do not&nbsp;have to match the names of the variables passed to it, but the order of the arguments must match. In the previous example, the value of the a variable is passed to the firstnum variable, and the value of b is passed to secondnum.</P>
<P CLASS="t">You can pass strings, numbers, and arrays to subroutines and user-defined functions. In the following example, the fontnames$() array is passed to the FillFontArray subroutine, which fills the array with the list of available font names.</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    lastelement = CountFonts() - 1
    Dim fontnames$(lastelement)
    FillFontArray$(fontnames$(), lastelement)
End Sub

Sub FillFontArray(array$(), maxcount)
    For arraycount = 0 To maxcount
        array$(arraycount) = Font$(arraycount + 1)
    Next
End Sub
</PRE>
<H4 CLASS="h4"><A NAME="sec5"></A>Passing Arguments "by Value"</H4><P CLASS="t">Normally, when you pass a variable to a subroutine or user-defined function, the subroutine or function can change the value of that variable not only within the subroutine or function itself but also in the calling subroutine. This is known as passing an argument "by reference." In the following example, the greeting$ variable is passed to the ChangeGreeting subroutine by reference. The main subroutine then displays the greeting, which the ChangeGreeting subroutine has&nbsp;changed from "Hello" to "What's up?"</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    greeting$&nbsp;=&nbsp;"Hello"
    ChangeGreeting greeting$
    MsgBox greeting$
End Sub

Sub ChangeGreeting(change$)
    change$ = "What's up?"
End Sub
</PRE>
<P CLASS="t">You can pass an argument and ensure that its value in the calling subroutine remains unchanged by passing the argument "by value." To pass an argument by&nbsp;value in WordBasic, you enclose it in parentheses.</P>
<P CLASS="t">In the following example, the greeting$ argument is passed by value, so when the&nbsp;main subroutine displays the greeting, the greeting remains "Hello."</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    greeting$ = "Hello"
    ChangeGreeting (greeting$)
    MsgBox greeting$
End Sub

Sub ChangeGreeting(change$)
    change$ = "What's up?"
End Sub
</PRE>
<P CLASS="t">In the following example, the variable a is passed by reference, while b is passed by value:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    a&nbsp;=&nbsp;6
    b&nbsp;=&nbsp;10
    OnePlusAverage a,(b)
    MsgBox "a =" + Str$(a) + " and b =" + Str$(b)
End Sub

Sub OnePlusAverage(firstval, secondval)
    firstval = firstval + 1
    secondval = secondval + 1
    avg =  (firstval + secondval) / 2
    Print avg
End Sub
</PRE>
<P CLASS="t">The OnePlusAverage subroutine adds 1 to each value passed to it, and then displays the average of the two values in the status bar. When the OnePlusAverage subroutine ends and control returns to the main subroutine, the main subroutine displays the following message box, which shows that the argument passed "by reference" changed, while the argument passed "by value" did not.</P>
<P CLASS="a">    <img src="ATR0403.gif"></P>
<P CLASS="t">Note that if you are passing more than one argument to a subroutine and you want&nbsp;to pass the first argument by value, you must enclose the list of arguments in&nbsp;parentheses. For example, if you wanted to pass a by value and b by reference, you would specify the following instruction:</P>
<P CLASS="spacing"><BR></P>
<PRE>OnePlusAverage((a),b)
</PRE>
<P CLASS="t">This issue doesn't arise when you're passing arguments to a user-defined function, since the list of arguments passed to a function must always be enclosed in parentheses.</P>
<H3 CLASS="h3"><A NAME="sec6"></A>Using Subroutines and Functions from Other Macros</H3><P CLASS="t">You can call subroutines and functions that are stored in other macros. This technique lets you create libraries of subroutines and functions so that you can avoid copying or rewriting code you use often.</P>
<P CLASS="t">To call a subroutine stored in another macro, use the following syntax:</P>
<P CLASS="syn">[<B>Call</B>]<I> MacroName</I><B>.</B><I>SubroutineName</I>[<B>(</B><I>ArgumentList</I><B>)</B>]</P>
<P CLASS="t"><I>MacroName </I>is the name of the macro containing the subroutine, and <I>SubroutineName</I> is the name of the subroutine you want to use. The optional <I>ArgumentList</I> is the list of values to be passed to the subroutine in the same way values are passed within the same macro. You can pass string and numeric values and arrays, just as you can within a macro.</P>
<P CLASS="t">The template in which the specified macro is stored can be the active template, the Normal template, or a loaded global template. Subroutines and functions stored in the Normal template are always available. For information on loading a&nbsp;template as a global template, see "Macros and Templates" in Chapter 2, "Getting Started with Macros."</P>
<P CLASS="t">The following example is a subroutine contained in a macro called Library:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MyBeep
    Beep : Beep : Beep                        'Beep three times
    For t&nbsp;=&nbsp;1 to 100 : Next                    'Pause
    Beep : Beep : Beep                        'Beep three times again
End Sub
</PRE>
<P CLASS="t">Here's an example of a macro that calls the MyBeep subroutine:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    YES = -1
    answer&nbsp;=&nbsp;Msgbox("Listen to MyBeep?", 36)    'Prompt user
    If answer = YES Then Library.MyBeep        'If yes, run MyBeep
End Sub
</PRE>
<P CLASS="t">To use a function stored in another macro, use the following syntax:<BR><I>MacroName</I><B>.</B><I>FunctionName</I><I>&nbsp;</I>[<B>(</B><I>ArgumentList</I><B>)</B>]. For example, suppose the following function is stored in the Library macro:</P>
<P CLASS="spacing"><BR></P>
<PRE>Function MyDateTime$
    mDate$&nbsp;=&nbsp;Date$()
    mTime$&nbsp;=&nbsp;Time$() 
    MyDateTime$&nbsp;=&nbsp;mDate$ + " " + mTime$
End Function
</PRE>
<P CLASS="t">In a macro called CheckDateTime, you could call this function as follows:</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
    MsgBox "The date and time is: " + Library.MyDateTime$
End Sub</PRE>
<P></P>

<TABLE COLS="1" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="348pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="sbrh"><B>Running Another Macro from Within Your Macro</B></P>
<P CLASS="sbrt">In addition to being able to call subroutines and functions stored in other macros, you can run entire macros from within your macro. It can be useful to call a macro for a specific task from within a larger macro that performs several tasks. You can call a macro in the same way you call a subroutine or function, with or without the optional <B>Call</B> keyword. For example, to call a macro named ChangeSettings, you can use the following instruction:</P>
<P CLASS="ct">Call ChangeSettings</P>
<P CLASS="ct"></P>
<P CLASS="sbrt">Or you can omit the <B>Call</B> keyword:</P>
<P CLASS="ct">ChangeSettings</P>
<P CLASS="ct"></P>
<P CLASS="sbrt">You can also use <B>ToolsMacro</B> to run a macro:</P>
<P CLASS="ct">ToolsMacro .Name = "ChangeSettings", .Show = 3, .Run</P>
<P CLASS="ct"></P>
<P CLASS="sbrt">One advantage of using <B>ToolsMacro</B> to run a macro is that you can specify the template where the macro you want to run is stored. In the previous example, <B>ToolsMacro</B> will run the ChangeSettings macro stored in the template attached to the active document. When you use the <B>Call </B>statement, Word looks for the called macro first in the template that contains the calling macro. Only if the macro is not found there does Word look in other templates. This distinction between <B>ToolsMacro </B>and <B>Call </B>can make a difference if different available templates contain macros with the same names.</P>
<P CLASS="sbrh"><B></B></P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<P CLASS="t">Here are some points to be aware of when calling subroutines or functions from another macro:</P>
<UL><LI>    Shared variables declared in one macro are not available in another. Each time&nbsp;a macro calls a subroutine or function from another macro, any shared variables declared in the macro being called are reinitialized.</LI><LI>    You can pass values to a macro's main subroutine just as you can pass values to any other subroutine. Note, however, that the main subroutine must be set up to receive values. For example, a main subroutine or function set up with the instruction Sub MAIN(a, b) requires two values from a macro that calls it. If you set up a main subroutine to accept values in this way, you can only run the macro that contains it by calling it from another macro.</LI><LI>    A macro cannot use the syntax for calling a subroutine or function in another macro to call a subroutine or function within itself. For example, if the macro CheckDateTime contained the MyBeep subroutine within it, the instruction Call CheckDateTime.MyBeep would generate an error. Similarly, a subroutine or function called from another macro cannot call a subroutine or function from the macro that is calling it.</LI><LI>    Limit calls between macros to four or five levels of nesting. For example, when macro A calls a subroutine in macro B that in turn calls a subroutine in macro C that calls macro D, three levels of nesting are involved.</LI><LI>    If more than one macro with a specified name is available, Word first looks for the macro stored in the same template as the calling macro. For example, suppose the Normal template and another template called Sample both contain a macro called Welcome. If a macro stored in the Normal template opens a document attached to the Sample template and then calls a subroutine within Welcome, Word runs the subroutine in the Welcome macro stored in the Normal template, even though Sample is the active template (since it is attached to the active document). If the called subroutine does not exist in the Welcome macro stored in Normal, Word generates an error (Word does not look for the subroutine in the Sample template's Welcome macro).</LI></UL><P></P>
<P></P>
<P CLASS="nh"><B>Important</B></P>
<P CLASS="nt">You cannot call a subroutine or user-defined function stored in another macro if the name of the subroutine or function is the same as the name of an argument for a WordBasic statement that corresponds to a dialog box. For example, Library.Wrap generates an error because .Wrap is an argument for the <B>EditFind</B> statement.</P>
<P></P></FONT></FONT></BODY></HTML>
