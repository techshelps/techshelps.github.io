<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the CAPILIB Functions</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">


<FONT FACE="ARIAL,HELVETICA" SIZE="2"><H2 CLASS="h1">Using the CAPILIB Functions</H2><P CLASS="t">CAPILIB provides a toolbox of functions to simplify your Word API programming tasks. This section takes a close look at these functions and how to use them to build Word operators, pass arrays, and customize Word.</P>
<H3 CLASS="h3"><A NAME="sec0"></A>The Word Command Buffer (WCB)</H3><P CLASS="t">WCB is a data structure defined in WDCAPI.H. This structure is used by the various functions in CAPILIB to help build up the array of WDOPR parameters to be passed to the <B>wdCommandDispatch</B> function. The constant MaxArgs, found in WDCAPI.H, determines the maximum number of WDOPR parameters that can be built up. MaxArgs is safely set to 34, an argument count much greater than you'll probably ever need. cArgs is automatically incremented as WDOPR arguments are built up by the CAPILIB functions, and contains the actual count of the WDOPR arguments. </P>
<P CLASS="spacing"><BR></P>
<PRE>typedef struct
{
    short    cArgs;
    WDOPR    wdoprReturn;
    WDOPR    wdoprArgs[MaxArgs];
} WCB;
</PRE>
<H3 CLASS="h3"><A NAME="sec1"></A>Functions in CAPILIB</H3><P CLASS="t">There are eighteen functions in CAPILIB, which can be grouped into seven categories:</P>
<UL><LI>    Initialize WCB</LI><LI>    Add dialog fields</LI><LI>    Add parameters</LI><LI>    Define arrays</LI><LI>    Call a Word command</LI><LI>    Register functions in Word</LI><LI>    Assign functions in Word</LI></UL><P></P>
<P CLASS="t">You should include the header file CAPILIB.H in modules that call these functions. </P>
<H4 CLASS="h4"><A NAME="sec2"></A>Initialize WCB</H4><P CLASS="t">The first function initializes the WCB structure before building up the WDOPR arguments. The InitWCB function sets the cArgs count to 0 (zero) and sets up the return type. It is very important to call this function first; if cArgs is not initialized and set to the proper count, <B>wdCommandDispatch</B> will behave unpredictably. </P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
void InitWCB( WCB far *lpwcb, ushort retType, LPUCHAR lpBuffer, 
    ushort cBufferSize );

// Macintosh
void InitWCB( WCB *lpwcb, ushort retType, StringPtr lpBuffer, 
    ushort cBufferSize );
</PRE>
<P CLASS="t">The parameters to InitWCB are as follows.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="thf"><B>Parameter</B></P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="th"><B>Description</B></P></FONT></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tr"></P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">lpwcb</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">A pointer to the WCB to be initialized. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">retType</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The return type of the command. This lets the InitWCB function prepare the return WDOPR's contents. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">lpBuffer</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Pointer to the start of buffer. If the returned information will be<BR>a string buffer, the return WDOPR will only contain a pointer to<BR>a buffer.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">cBufferSize</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The return buffer's allocated length. </P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<H4 CLASS="h4"><A NAME="sec3"></A>Add Dialog Fields</H4><P CLASS="t">After InitWCB has been called, you build up WDOPR arguments one at a time by calling the other functions. Each of these functions increments the cArgs count and initializes the fields in a single WDOPR argument. </P>
<P CLASS="t">These four functions add field parameters for dialog commands:</P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
void AddShortDlgField( WCB far *lpwcb, short ShortVal, ushort FieldId,
    ushort fMode );
void AddLongDlgField( WCB far *lpwcb, long LongVal, ushort FieldId,
    ushort fMode );
void AddDoubleDlgField( WCB far *lpwcb, double DoubleVal,
    ushort FieldId, short fMode );
void AddStringDlgField( WCB far *lpwcb, LPUCHAR lpStr, ushort FieldId,
    ushort fMode, ushort cBufferSize );

// Macintosh
void AddShortDlgField( WCB *lpwcb, short ShortVal, ushort FieldId,
    ushort fMode );
void AddLongDlgField( WCB     *lpwcb, long LongVal, ushort FieldId,
    ushort fMode );
void AddDoubleDlgField( WCB *lpwcb, double DoubleVal, ushort FieldId,
    ushort fMode );
void AddStringDlgField( WCB *lpwcb, StringPtr lpStr, ushort FieldId,
    ushort fMode, ushort cBufferSize );
</PRE>
<P CLASS="t">Here's a description of each of the parameters of these functions.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="thf"><B>Parameter</B></P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="th"><B>Description</B></P></FONT></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tr"></P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">lpwcb</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The address of the WCB structure. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">ShortVal </P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The field's data, of the type indicated in the name of each function.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">FieldId</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The field's ID. A list of field ID constants is provided in WDFID.H, which should be included in modules calling the Word API functions. These constants have names that closely parallel the dialog command field names in WordBasic. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">fMode </P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Indicates the input/output mode for the given dialog command field. Set this field using the constants INPUT, OUTPUT, or both. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">cBufferSize </P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The allocated space for the string buffer.</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<H4 CLASS="h4"><A NAME="sec4"></A>Add Parameters</H4><P CLASS="t">The next group of functions is called to build parameters for statements other than those that correspond to dialog boxes. The WDOPR argument in this case doesn't have field names, and the input/output information is irrelevant. For these reasons, only two parameters are passed to these functions: the WCB address, and the WDOPR argument data of the type indicated in the function's name.</P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
void AddShortParam( WCB far *lpwcb, short ShortVal );
void AddLongParam( WCB far *lpwcb, long LongVal );
void AddDoubleParam( WCB far *lpwcb, double DoubleVal );
void AddStringParam( WCB far *lpwcb, LPUCHAR lpStr );

// Macintosh
void AddShortParam( WCB *lpwcb, short ShortVal );
void AddLongParam( WCB *lpwcb, long LongVal );
void AddDoubleParam( WCB *lpwcb, double DoubleVal );
void AddStringParam( WCB *lpwcb, StringPtr lpStr );
</PRE>
<H4 CLASS="h4"><A NAME="sec5"></A>Define Arrays</H4><P CLASS="t">Three functions are provided to help you set up WDOPR arguments that pass arrays. </P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
ARRAY_DEF far * SetArrayDef( HANDLE *phArrDef, short cDimensions, ... );
void AddStringArray( WCB far *lpwcb, ARRAY_DEF far *ArrayDef, 
    LPUCHAR far *lpStrArray, ushort cBufferSize );
void AddDoubleArray( WCB far *lpwcb, ARRAY_DEF far *ArrayDef,
    double far *lpdblArray );

// Macintosh
ARRAY_DEF * SetArrayDef( Handle *phArrDef, short cDimensions, ... );
void AddStringArray( WCB *lpwcb, ARRAY_DEF *ArrayDef, StringPtr 
    *lpStrArray, ushort cBufferSize );
void AddDoubleArray( WCB *lpwcb, ARRAY_DEF *ArrayDef, double 
    *lpdblArray );
</PRE>
<P CLASS="t">The first function, SetArrayDef, builds the ArrayDef parameter required in the WDOPR when arrays are passed. ARRAY_DEF contains information on the number of dimensions and the size of each dimension for an array. The other two functions, AddStringArray and AddDoubleArray, build the WDOPR argument, filling in the data structure with pointers to an array and its associated ARRAY_DEF. When adding a string array, one additional parameter is passed to indicate the allocated size of each string in the array. Note that all strings in an array are allocated to the same maximum size, although the actual null-terminated strings may be of a shorter length. </P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">SetArrayDef allocates memory. After using an array, your WLL function needs to free that memory. For example, given the array hArrayDef, a function should deallocate memory as follows:</P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
GlobalUnlock( hArrayDef );
GlobalFree( hArrayDef );

// Macintosh
HUnlock( hArrayDef );
DisposHandle( hArrayDef );
</PRE>
<P></P>
<P CLASS="t">The following stripped-down Windows code fragments demonstrate how SetArrayDef can be used to build the array definition table for an array of strings. Note that this code is extracted from the example code on the Microsoft Word Developer's Kit disk; you might want to study the example in its entirety.</P>
<P CLASS="spacing"><BR></P>
<PRE>HANDLE          hArrayDef;
ARRAY_DEF far * ArrayDef;
LPSTR           lpStrArray[ARRAYSIZE]; 
char            strArray[ARRAYSIZE][64];

ArrayDef = SetArrayDef( &amp;hArrayDef, 1, ARRAYSIZE );

InitWCB( &amp;wcb, TypeShort, NULL, 0 );
AddStringArray( &amp;wcb, ArrayDef, lpStrArray, 64 );
</PRE>
<H4 CLASS="h4"><A NAME="sec6"></A>Call a WordBasic Statement or Function</H4><P CLASS="t">This function uses a subset of the other CAPILIB functions to fill a WCB for a WordBasic statement or function that does not correspond to a dialog box; it then dispatches the command to Word and returns the result. You can use this as an efficient way to dispatch WordBasic statements and functions in your WLL.</P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
short CallCapi( LPWCB far *wcb, short CommandID, ushort retType, LPSTR lpBuffer, ushort cBufferSize, LPSTR lpszFormat, ... );

//Macintosh
short CallCapi( WCB *wcb, short CommandID, ushort retType, StringPtr lpBuffer, ushort cBufferSize, StringPtr lpszFormat, ... );
</PRE>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="276pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="thf"><B>Parameter</B></P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="th"><B>Description</B></P></FONT></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tr"></P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">*wcb</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Pointer to the WCB structure. </P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">CommandID</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The WordBasic statement or function to be called; CommandID cannot correspond to a dialog box.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">retType</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The return type of the WordBasic statement or function.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">lpBuffer</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Buffer to store the return string, if any.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">cBufferSize</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Size of the buffer specified by lpBuffer.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">lpszFormat</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">String describing the type of the arguments passed to CommandID. This list should be a string of characters that identify the type of each argument that follows. Use the following characters:</P>
<P CLASS="tt">i    Integer</P>
<P CLASS="tt">l    Long</P>
<P CLASS="tt">d    Double</P>
<P CLASS="tt">s    String</P>
<P CLASS="tt">For example, if the statement or function takes a string argument followed by an integer argument, lpszFormat would be "si"; the following argument list would be a string argument and an integer. CallCapi automatically parses this list and fills the WCB with the data in the specified order.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">...</P></FONT></TD><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">The list of arguments to dispatch with the statement, in the order specified by lpszFormat.</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P CLASS="t">The following Macintosh example demonstrates how you can use CallCapi to dispatch the <B>wdMsgBox</B> statement in a single instruction.</P>
<P CLASS="spacing"><BR></P>
<PRE>CallCapi (&amp;wcb, wdMsgBox, TypeVoid, NULL, 0, "ss", "Timer Hit!", "Examp WLL");
</PRE>
<H4 CLASS="h4"><A NAME="sec7"></A>Register Functions in Word</H4><P CLASS="t">The final group of functions provided in CAPILIB provides help with several common programming tasks in your WLL. These functions set up their WDOPR arguments and call <B>wdCommandDispatch</B> in the same way your code will. For this reason they provide excellent working examples of the use of the other CAPILIB functions.</P>
<P CLASS="t">To be callable from Word, functions must be registered with Word. The CAPIRegister function simplifies this task for you. The DocID parameter (passed in to <B>wdAutoOpen</B>), the name of your new function, and a description are the only parameters to this function. </P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
short CAPIRegister( short DocID, LPUCHAR lpszFunctionName, LPUCHAR
    lpszDescription );

// Macintosh
short CAPIRegister( short DocID, StringPtr lpszFunctionName, StringPtr 
    lpszDescription );
</PRE>
<P CLASS="t">DocID is a document identifier. It is used to register functions in Word and to customize Word to assign registered functions to toolbar buttons, menus, and shortcut keys.</P>
<P CLASS="t">Just as you choose the names for macros in Word templates, the name you choose for each registered add-in function should be unique to avoid naming conflicts during a Word session. If two or more add-in functions in two or more WLLs are registered under the same name, Word will run the function in the WLL listed first in the list of loaded global templates and add-ins in the Templates And Add-ins dialog box (Templates command, File menu).</P>
<P CLASS="t">A description is not required. If you specify a null value for lpszDescription, CAPIRegister ignores that parameter.</P>
<H4 CLASS="h4"><A NAME="sec8"></A>Assign Functions in Word</H4><P CLASS="t">The final group of functions helps you assign registered functions to toolbar buttons, menus, or shortcut keys. Other than the DocID, the parameters all correspond closely to parameters for the equivalent WordBasic statements <B>AddButton</B>, <B>NewToolbar</B>, <B>ToolsCustomizeMenu</B>, <B>ToolsCustomizeMenuBar</B>, and <B>ToolsCustomizeKeyboard</B>.</P>
<P CLASS="spacing"><BR></P>
<PRE>// Windows
short CAPIAddButton( short DocID, LPUCHAR lpszToolbar, short cPosition,
    LPUCHAR lpszMacro, LPUCHAR lpszFace ); 
short CAPIAddToolbar( short DocID, LPUCHAR lpszToolbar )
short CAPIAddMenu( short DocID, LPUCHAR lpszMenuName, short Position,
    short MenuType );
short CAPIAddMenuItem( short DocID, LPUCHAR lpszMenu, LPUCHAR lpszName,
    LPUCHAR lpszMenuText, short Position, short MenuType );
short CAPIAddKey( short DocID, short KeyCode, LPUCHAR lpszName );

// Macintosh
short CAPIAddButton( short DocID, StringPtr lpszToolbar, short 
    cPosition, StringPtr lpszMacro, StringPtr lpszFace );
short CAPIAddToolbar( short DocID, StringPtr lpszToolbar );
short CAPIAddMenu( short DocID, StringPtr lpszMenuName, short 
    Position, short MenuType );
short CAPIAddMenuItem( short DocID, StringPtr lpszMenu, StringPtr 
    lpszName, StringPtr lpszMenuText, short Position, short MenuType );
short CAPIAddKey( short DocID, short KeyCode, StringPtr lpszName );
</PRE>
<P CLASS="t">When a WLL passes DocID as the context in which to customize Word, all customization is temporary; the template is not "dirtied" and all customization is removed automatically when the WLL is unloaded. </P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">If you want to make customization in Word permanent, pass the numeric value 0 (zero) to modify the Normal template or 1 to modify the active template (if other than the Normal template) instead of DocID. Note, however, that if you pass a context other than DocID, the template will be dirtied; you should include<BR>a <B>wdAutoRemove</B> function in your WLL to deliberately clean up the Word environment when the WLL is unloaded.</P>
<P></P>
<P CLASS="t">For more information about these functions, see "Customizing Word with CAPILIB" later in this section.</P>
<H3 CLASS="h3"><A NAME="sec9"></A>Building Word Operators with CAPILIB</H3><P CLASS="t">The following example code demonstrates the steps in building two WDOPR arguments for a call to <B>wdCommandDispatch</B>. The two WDOPR arguments pass the number of columns and the number of rows for a new table created by the WordBasic <B>TableInsertTable</B> statement. The WCB structure named wcb is first initialized by a call to InitWCB, the two WDOPR string field arguments are built up, and then <B>wdCommandDispatch</B> is called to perform the <B>TableInsertTable</B> statement. When activated, this block of code inserts a 4 by 12 table in the current document.</P>
<P CLASS="spacing"><BR></P>
<PRE>// Initialize the WCB - this zero's the WDOPR count
InitWCB( &amp;wcb, TypeVoid, NULL, 0 );

// Build WDOPR arguments for number of columns and rows
AddStringDlgField( &amp;wcb, "4", fidNumColumns, fMode, 0 );
AddStringDlgField( &amp;wcb, "12", fidNumRows, fMode, 0 );

// Call into Word's TableInsertTable command
err = wdCommandDispatch ( wdTableInsertTable, CommandAction, 
    wcb.cArgs, wcb.wdoprArgs, lpwdoprNil );
</PRE>
<P CLASS="t">The last parameter to <B>wdCommandDispatch</B> is lpwdoprNil. Take a look in WDCAPI.H to see how the lpwdoprNil data type is defined as a WDOPR pointer to a zero. Use this when the Word API command doesn't return a WDOPR argument in the last parameter to <B>wdCommandDispatch</B>.</P>
<H3 CLASS="h3"><A NAME="sec10"></A>Passing Arrays with CAPILIB</H3><P CLASS="t">To use the CAPILIB functions to build a WDOPR that passes an array, follow this general procedure:</P>
<UL><LI>    Call SetArrayDef to set up the number and size of the array's dimensions.</LI><LI>    For doubles, call AddDoubleArray, passing the ArrayDef and the double array.</LI><LI>    For strings, call AddStringArray, passing the ArrayDef, the string array, and an array of pointers to each string in the array. </LI></UL><P></P>
<H4 CLASS="h4"><A NAME="sec11"></A>Example of Passing a Double Array</H4><P CLASS="t">The following Windows code fragments demonstrate the passing of an array of doubles in a Word API function, using CAPILIB functions. Note that ArrayDef, in this case, is set up for a one-dimension array sized ARRAYSIZE. In the case of a multiple-dimensional array, you would pass different values to the SetArrayDef function. </P>
<P CLASS="spacing"><BR></P>
<PRE>// Related declarations
HANDLE            hArrayDef;
ARRAY_DEF far * ArrayDef;
double            array[ARRAYSIZE];

// Set the array definition
ArrayDef = SetArrayDef( &amp;hArrayDef, 1, ARRAYSIZE );

// Build a double array WDOPR
InitWCB( &amp;wcb, TypeVoid, NULL, 0 );
AddDoubleArray( &amp;wcb, ArrayDef, array );

// Use wdCommandDispatch here

// Free allocated ArrayDef
GlobalUnlock( hArrayDef );
GlobalFree( hArrayDef );
</PRE>
<H4 CLASS="h4"><A NAME="sec12"></A>Example of Passing a String Array</H4><P CLASS="t">The following lines of Windows code illustrate the general procedure for handling string arrays using the CAPILIB module functions. The important concept to grasp here is the way the various parts of the WDOPR's data structure are loaded with the appropriate data. The string contents are contained in the character array strArray, pointers to each of these strings are loaded into lpStrArray, and the string array's dimensions and sizes are loaded into ArrayDef. Each of these<BR>parts of the WDOPR data structure must be loaded correctly for passing<BR>string array data.</P>
<P CLASS="spacing"><BR></P>
<PRE>// Related declarations
HANDLE            hArrayDef;
ARRAY_DEF far * ArrayDef;
LPSTR            lpStrArray[ARRAYSIZE]; 
char            strArray[ARRAYSIZE][MAXLENGTH];  

// Set the array definition
ArrayDef = SetArrayDef( &amp;hArrayDef, 1, ARRAYSIZE );

// Set the array of LPSTR to point to a buffer
for( i = 0; i &lt; ARRAYSIZE; i++ )
    lpStrArray[i] = strArray[i];

// Build a string array WDOPR
InitWCB( &amp;wcb, TypeShort, NULL, 0 );
AddStringArray( &amp;wcb, ArrayDef, lpStrArray, MAXLENGTH );

// Use wdCommandDispatch here

// Free allocated ArrayDef
GlobalUnlock( hArrayDef );
GlobalFree( hArrayDef );
</PRE>
<H3 CLASS="h3"><A NAME="sec13"></A>Customizing Word with CAPILIB</H3><P CLASS="t">A WLL function registered in Word can be called from any WordBasic macro, just like any built-in statement. You also can assign a new Word API function to<BR>a toolbar button, menu item, or shortcut key. The proper place to make such an assignment is in the <B>wdAutoOpen</B> function. This function runs automatically when the WLL is loaded, making your function associations automatic. There are several <B>wdCommandDispatch</B> commands that let you make these assignments in a manner analogous to the way WordBasic works. Specific CAPILIB functions simplify the process even further.</P>
<H4 CLASS="h4"><A NAME="sec14"></A>Adding a Command</H4><P CLASS="t">An add-in function registered in Word extends WordBasic and is immediately available as a new command that can be included as an instruction in any macro. Use the CAPIRegister function in CAPILIB to register your add-in function.</P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">A WLL function that requires arguments from a WordBasic macro cannot be registered in Word. This kind of function must be declared in the WordBasic macro with the WordBasic <B>Declare</B> statement.</P>
<P></P>
<H4 CLASS="h4"><A NAME="sec15"></A>Adding a Toolbar Button</H4><P CLASS="t">The following lines of code demonstrate how a toolbar button labeled "Table," assigned to the new function MyTable, can be added to the standard toolbar using the appropriate CAPILIB function. This line of code would normally go in the <B>wdAutoOpen</B> function of a WLL to create the button when the WLL is loaded. </P>
<P CLASS="spacing"><BR></P>
<PRE>err = CAPIAddButton( DocID, "Standard", cPosition, "MyTable",
    "Table" );
</PRE>
<P CLASS="t">A related function in CAPILIB, CAPIAddToolbar, lets you add your own toolbar, to which you can then add buttons. For example:</P>
<P CLASS="spacing"><BR></P>
<PRE>err = CAPIAddToolbar( DocID, "MyToolbar" );
</PRE>
<H4 CLASS="h4"><A NAME="sec16"></A>Adding a Menu Item</H4><P CLASS="t">You can easily add a menu item and assign a registered function to it. The CAPIAddMenuItem function in CAPILIB simplifies the process. For example, the following line of code adds a new menu item labeled "String Array Test" to the end of the File menu and assigns the function StringArray to it:</P>
<P CLASS="spacing"><BR></P>
<PRE>err = CAPIAddMenuItem( DocID, "File", "StringArray", "String Array
    Test", -1, 0 );
</PRE>
<P CLASS="t">A related function, CAPIAddMenu, lets you add a new menu to the main<BR>menu bar and assign to it a name that can be used to further build the menu<BR>with CAPIAddMenuItem.</P>
<H4 CLASS="h4"><A NAME="sec17"></A>Adding a Shortcut Key</H4><P CLASS="t">A registered Word API function can also be assigned to a shortcut key using<BR>the CAPIAddKey function provided in CAPILIB. For example:</P>
<P CLASS="spacing"><BR></P>
<PRE>err = CAPIAddKey( DocID, KeyCode, "MyNewFunction" );
</PRE>
<P CLASS="t">This line of code assigns the Word API function MyNewFunction to the shortcut key indicated by KeyCode in the current document. For a complete description of the various KeyCode integers, see <B>ToolsCustomizeKeyboard</B> in Part 2, "WordBasic Reference."</P></FONT></FONT></BODY></HTML>
