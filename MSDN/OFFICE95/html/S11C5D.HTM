<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>On Error Statement</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso8859-1"><style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">

<FONT FACE="Verdana, Arial, Hevetica" SIZE="2"><FONT FACE="Verdana, Arial, Helvetica" SIZE="2">
<H1><A NAME="sec160"></A>On Error Statement</H1><P CLASS="t">  </P>
<H2><A NAME="sec161"></A>Description</H2><P>Enables an error-handling routine and specifies the location of the routine within a procedure; can also be used to disable an error-handling routine.</P>
<H2><A NAME="sec162"></A>Syntax</H2><P><B>On Error</B> <B>GoTo</B> <I>line</I> <B>On Error Resume Next</B><B>On Error</B> <B>GoTo</B> <B>0</B></P>
<P></P>
<P></P>
<P>The <B>On Error </B>statement syntax can have any of the following forms:</P>
<P CLASS="t">  </P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="132pt" VALIGN="TOP"><COL WIDTH="237pt" VALIGN="TOP"></COLGROUP><TBODY><TR><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t"><B>Statement</B></P></TD><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t"><B>Description</B></P></TD></TR><TR><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t"><B>On Error GoTo</B><I> line </I></P></TD><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t">Enables the error-handling routine that starts at <I>line</I>, which is any line label or line number. Thereafter, if a run-time error occurs, control branches to <I>line</I>, making the error handler active<I>. </I>The specified <I>line</I> must be in the same procedure as the <B>On Error</B> statement; otherwise, a compile-time error occurs.</P></TD></TR><TR><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t"><B>On Error Resume Next</B></P></TD><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t">Specifies that when a run-time error occurs, control goes to the statement immediately following the statement where the error occurred; that is, execution continues. It’s recommended to use this form rather than <B>On Error</B> <B>GoTo </B>when accessing objects.</P></TD></TR><TR><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t"><B>On Error GoTo 0</B></P></TD><td VALIGN="TOP">
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2"><P CLASS="t">Disables any enabled error handler in the current procedure.</P></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><H2><A NAME="sec163"></A>Remarks</H2><P>If you don’t use an <B>On Error</B> statement, any run-time error that occurs is fatal; that is, an error message is displayed and execution stops.</P>
<P>An “enabled” error handler is one that has been turned on by an <B>On Error </B>statement; an “active” error handler is an enabled handler that is in the process of handling an error. If an error occurs while an error handler is active (between the occurrence of the error and a <B>Resume</B>, <B>Exit Sub</B>, <B>Exit Function</B>, or <B>Exit Property</B> statement), the current procedure’s error handler can’t handle the error. Control returns to the calling procedure; if the calling procedure has an enabled error handler, it is activated to handle the error. If the calling procedure’s error handler is also active, control passes back through previous calling procedures until an enabled, but inactive, error handler is found. If no inactive, enabled error handler is found, the error is fatal at the point at which it actually occurred. Each time the error handler passes control back to the calling procedure, that procedure becomes the current procedure. Once an error is handled by an error handler in any procedure, execution resumes in the current procedure at the point designated by the <B>Resume </B>statement.</P>
<P></P>
<P CLASS="t">  </P>
<P><B>Note</B>   An error-handling routine is not a <B>Sub</B> or <B>Function</B> procedure. It is a section of code marked by a line label or line number.</P>
<P CLASS="t">  </P>
<P></P>
<P>Error-handling routines rely on the value in the <B>Err</B> object’s <B>Number </B>property to determine the cause of the error. The error-handling routine should test or save relevant <B>Err</B> object property values before any other error can occur or before a procedure that could cause an error is called. The values in the <B>Err</B> object’s properties reflect only the most recent error. The error message associated with <B>Err.Number </B>is contained in <B>Err.Description</B>. </P>
<P><B>On Error Resume Next</B> causes execution to continue with the statement immediately following the statement that caused the run-time error, or with the statement immediately following the most recent call out of the procedure containing the <B>On Error Resume Next</B> statement. This allows execution to continue despite a run-time error. You can then build the error-handling routine inline within the procedure, rather than transfer control to another location within the procedure. An <B>On Error Resume Next </B>statement becomes inactive when another procedure is called, so you should execute an <B>On Error Resume Next</B> statement in each called routine if you want inline error handling within that routine. </P>
<P></P>
<P CLASS="t">  </P>
<P><B>Note</B>   The <B>On Error Resume Next</B> construct may be preferable to <B>On Error GoTo</B> when dealing with errors generated during access to other objects, since it permits unambiguous identification of the object whose error code is being returned. Checking <B>Err</B> after each interaction with an object removes ambiguity about which object your code was accessing when the error occurred because the context is immediate. Thus, you can be sure of which object placed the error code in <B>Err.Number</B>, as well as which object originally generated the error (the one specified in <B>Err.Source</B>).</P>
<P CLASS="t">  </P>
<P></P>
<P><B>On Error GoTo 0</B> disables error handling in the current procedure. It doesn’t specify line 0 as the start of the error-handling code, even if the procedure contains a line numbered 0. Without an <B>On Error GoTo 0</B> statement, an error handler is automatically disabled when a procedure is exited.</P>
<P>To prevent error-handling code from running when no error has occurred, place an <B>Exit Sub, Exit Function</B>, or <B>Exit Property</B> statement, as appropriate, immediately before the error-handling routine, as in the following example:</P>
<P CLASS="t">  </P>
<P CLASS="spacing"><BR></P>
<PRE>Sub InitializeMatrix(Var1, Var2, Var3, Var4)
    On Error GoTo ErrorHandler
    . . .
    Exit Sub:
    . . .
    Resume NextSub
</PRE>
<P CLASS="t">  </P>
<P>Here, the error-handling code follows the <B>Exit Sub</B> statement and precedes the <B>End Sub</B> statement to separate it from the normal procedure flow. This is only one possible solution — error-handling code can be placed anywhere in a procedure.</P>
<P>Untrapped errors in OLE Automation objects are returned to the controlling application when the OLE Automation object is running as an executable file. Within the development environment, they are only returned to the OLE Automation controller if the proper options are set. See your host application’s documentation for a description of which options should be set during debugging, how to set them, and whether the host can create classes and OLE Automation objects. </P>
<P>When writing an OLE Automation object, if your object accesses other objects, you should try to handle errors passed back from them unhandled. If you cannot handle such errors, your object should pass them back to the caller of your object, but should first map the error code in <B>Err.Number</B> to one of your own errors. You should specify your error by adding your error code to the constant <B>vbObjectError</B>. For example, if your error code is 1052, assign it as follows:</P>
<P CLASS="t">  </P>
<P CLASS="spacing"><BR></P>
<PRE>Err.Number = vbObjectError + 1052
</PRE>
<P CLASS="t">  </P>
<P></P>
<P CLASS="t">  </P>
<P><B>Note</B>   On 32-bit Microsoft Windows operating systems, system errors during calls to dynamic-link libraries (DLL), do not raise exceptions and cannot be trapped with Visual Basic error trapping. When calling DLL functions, you should check each return value for success or failure (according to the API specifications), and in the event of a failure, check the value in the <B>Err</B> object’s <B>LastDLLError</B> property.</P>
<P CLASS="t">  </P>
<P></P>
<H2><A NAME="sec164"></A>See Also</H2><P><B>End</B> Statement, <B>Err</B> Object, <B>Exit</B> Statement, <B>LastDLLError</B> Property, <B>Resume</B> Statement.</P>
<H2><A NAME="sec165"></A>Example</H2><P>This example first uses the <B>On Error</B> <B>GoTo</B> statement to specify the location of an error-handling routine within a procedure. In the example, an attempt to delete an open file generates error number 55. The error is handled in the error-handling routine and control is then returned to the statement that caused it. The <B>On Error GoTo 0 </B> statement turns off error trapping. Then the <B>On Error Resume Next</B> statement is used to defer error trapping so that the context for the error generated by the next statement can be known for certain. Note that <B>Err.Clear</B> is used to clear the <B>Err </B>object’s properties after the error is handled.</P>
<P CLASS="t">  </P>
<P CLASS="spacing"><BR></P>
<PRE>Sub OnErrorStatementDemo()
        On Error GoTo ErrorHandler        ' Enable error-handling 
                                        ' routine.
        Open "TESTFILE" For Output As #1    ' Open file for output.
        Kill "TESTFILE"                    ' Attempt to delete open 
                                        ' file.
        On Error Goto 0                    ' Turn off error trapping.
        On Error Resume Next                ' Defer error trapping.
        ObjectRef = GetObject("MyWord.Basic")    ' Try to start
                                                ' nonexistent object, 
                                                ' then test for OLE
        If Err.Number = 440 Then                    ' Automation error.
            ' Tell user what happened. Then clear the Err object.
            Msg = "There was an error attempting to open the " &amp; _
                "OLE object!"
            MsgBox Msg, , "Deferred Error Test"
            Err.Clear                    ' Clear Err object fields 
        End If    
    Exit Sub                                ' Exit to avoid handler.
    ErrorHandler:                        ' Error-handling routine.
        Select Case Err.Number            ' Evaluate error number.
            Case 55                        ' "File already open" error.
                Close #1    ' Close open file.
            Case Else
                ' Handle other situations here... 
        End Select
        ' Resume execution at same line that caused the error.
        Resume    Sub
</PRE>
<P CLASS="t">  </P>
<P CLASS="t"> </P>
</FONT></FONT></BODY></HTML>
