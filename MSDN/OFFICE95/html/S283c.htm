<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Sequential File Access</TITLE><META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=Windows-1252">
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGPROPERTIES="FIXED" TEXT="#000000" BGCOLOR="#FFFFFF">


<FONT FACE="ARIAL,HELVETICA" SIZE="2"><H2 CLASS="h1">Using Sequential File Access</H2><P CLASS="t">WordBasic includes a set of statements and functions you can use to access<BR>text files without opening them in a document window. This kind of interaction<BR>is called <I>file input and output</I>, or <I>file I/O</I>. Using file input, a macro can "read"<BR>a file to retrieve information from it ("input" refers to input from the file into the macro). Using file output, a macro can "write" to a file to store information ("output" refers to output from the macro to the file). WordBasic supports <I>sequential</I> file I/O, or sequential file access, a kind of file I/O supported by most varieties of the Basic programming language. In sequential file access, the information in the file is usually read or written in sequence, from the beginning of the file to the end.</P>
<P CLASS="t">Sequential file access is used most often to provide a macro with information.<BR>For example, a macro designed to work on a series of files can use sequential<BR>file access to retrieve a list of filenames from a text file.</P>
<P CLASS="t">The advantage of sequential file access is that it's fast. If a macro needs to read or store information, sequential file access can do it more quickly than statements that open a file in a document window. The disadvantage, of course, is that sequential file access is more rigid than working with a file in a document window. It's difficult to go directly to a specific place in a file, and you can't<BR>read from a file and write to it at the same time.</P>
<P></P>
<P CLASS="nh"><B>Note</B></P>
<P CLASS="nt">Sequential file-access statements and functions are designed to work with text-only files, not Word document files. While it is possible to open a Word document for sequential access, it isn't useful to do so because Word documents contain formatting codes that make the file very difficult to read from or write to through sequential access. To work with a Word document, open it in a document window.</P>
<P></P>
<H3 CLASS="h3"><A NAME="sec0"></A>Opening a File for Sequential Access</H3><P CLASS="t">When you open a file for sequential access, you specify whether you want to read from the file or write to it. If a macro needs both to read from and write to a file, it must open the file to read from it, close it, and then reopen the file to write to it. A macro can have as many as four files open at a time for sequential access.</P>
<P CLASS="t">To open a file for sequential access, you use the <B>Open</B> statement, which has the following syntax:</P>
<P CLASS="syn"><B>Open</B> <I>Name$</I> <B>For</B> <I>Mode</I> <B>As</B> [<B>#</B>]<I>FileNumber</I></P>
<P CLASS="t"><I>Name$</I> is the name of the file to open and <I>FileNumber</I> is a number between 1<BR>and 4 that other sequential access instructions use to refer to the open file. <I>Mode</I> indicates how the file is to be used: for input, output, or appending. The modes are described as follows.</P>

<TABLE COLS="3" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="274pt" VALIGN="TOP"><COL WIDTH="1pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="thf"><B>Mode</B></P></FONT></TD><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="th"><B>Explanation</B></P></FONT></TD></TR><TR><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tr"></P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt"><B>Input</B></P></FONT></TD><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Opens the text file so that data may be read from the file into the macro. When you open a file for input you can use <B>Read</B>, <B>Input</B>, <B>Line Input</B>, and <B>Input$</B><B>()</B> instructions to read from the file. If the specified text file isn't found, an error occurs.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt"><B>Output</B></P></FONT></TD><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Opens the text file so that data may be written from the macro to the file. When you open a file for output, you can use <B>Write</B> and <B>Print</B> instructions to write to the file. Opening a file for output deletes the existing contents of the file, even if you do not write to the file. If the specified text file isn't found, a new file is created.</P></FONT></TD></TR><TR><TD VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt"><B>Append</B></P></FONT></TD><TD COLSPAN="2" VALIGN="TOP"><FONT FACE="ARIAL,HELVETICA" SIZE="2"><P CLASS="tt">Opens the text file so that data may be written from the macro to the file. When you open a file to append, you can use <B>Write</B> and <B>Print</B> instructions to write to the file. The existing contents of the file remain and the information you write is added to the end of the file. If the specified text file isn't found, a new file is created.</P></FONT></TD></TR></TBODY></TABLE>
<P CLASS="spacing"><BR></P><P></P>
<P CLASS="t">The following diagram shows the relationship between a macro and a text file in the different modes, along with the sequential file-access statements and functions available in those modes.</P>
<P CLASS="a">    <img src="ATR0904.gif"></P>
<H3 CLASS="h3"><A NAME="sec1"></A>Writing to a File</H3><P CLASS="t">WordBasic includes two statements for writing to a file: <B>Write</B> and <B>Print</B>. You can use these statements to write both strings and numbers. Each instruction creates a single line in a text file. In Windows, each line of the text file ends with the carriage-return and linefeed characters (character codes 13 and 10); on the Macintosh, each line ends with a single carriage-return (character code 13). You can think of each line as a single data record that can have multiple fields containing different values. Each <B>Write</B> and <B>Print</B> instruction writes sequentially to the text file, adding one line of data after another for as long as the file is open.</P>
<H4 CLASS="h4"><A NAME="sec2"></A>Write</H4><P CLASS="t">The<B> Write</B> statement is designed to write data that can be easily read by the complementary <B>Read</B> statement. The syntax of <B>Write</B> is as follows:</P>
<P CLASS="syn"><B>Write</B> <B>#</B><I>FileNumber</I><B>,</B> <I>Expression1</I>[<I>$</I>] [<B>,&nbsp;</B><I>Expression2</I>[<I>$</I>]] [<B>,&nbsp;</B><FONT FACE="Symbol">¼</FONT>]</P>
<P CLASS="t"><I>FileNumber</I> refers to the number you assigned to the file when you opened it. An <I>Expression</I> contains the data you're writing to the file. Usually, <I>Expression</I> is a string or numeric variable, but it could also be a numeric expression or a function that returns a string or number. For example, the following instruction writes the currently selected text to a file:</P>
<P CLASS="spacing"><BR></P>
<PRE>Write #1, Selection$()
</PRE>
<P CLASS="t"><B>Write</B> places quotation marks around string values, but not around numeric values; it places a comma between each value as a delimiter. For example, the instruction</P>
<P CLASS="spacing"><BR></P>
<PRE>Write #1, name$, age, employeeNum
</PRE>
<P CLASS="t">creates a line such as the following in the text file:</P>
<P CLASS="spacing"><BR></P>
<PRE>"John Jones", 32, 12345
</PRE>
<H4 CLASS="h4"><A NAME="sec3"></A>Print</H4><P CLASS="t">Unlike <B>Write</B>, the <B>Print</B> statement does not have a complementary statement designed to read whatever it writes. <B>Print</B> is most useful if you want to write data to a file that may be read by another application. You can also use <B>Print</B> to write information to be read by the <B>Line Input</B> statement. The syntax for <B>Print</B> is as follows:</P>
<P CLASS="syn"><B>Print</B> <B>#</B><I>FileNumber</I><B>,</B><I> Expression1</I>[<I>$</I>] [<B>;</B> <I>or</I> <B>,</B><I> Expression2</I>[<I>$</I>]] [<B>;</B> <I>or</I> <B>, </B><FONT FACE="Symbol">¼</FONT>]</P>
<P CLASS="t"><I>FileNumber</I> refers to the number you assigned to the file when you opened it. <I>Expression</I> contains the data you're writing to the file, usually a variable, number, or string.</P>
<P CLASS="t">String and numeric values can be separated by either a semicolon or a comma. Values separated by a semicolon are joined together in the text file with a space inserted before numbers. For example, the instruction</P>
<P CLASS="spacing"><BR></P>
<PRE>Print #1, name$; age; employeeNum
</PRE>
<P CLASS="t">creates a line such as the following in the text file:</P>
<P CLASS="spacing"><BR></P>
<PRE>John Jones 32 12345
</PRE>
<P CLASS="t">Values separated by a comma are separated by a tab character in the text file. For example, the instruction</P>
<P CLASS="spacing"><BR></P>
<PRE>Print #1, "Jones", "123 1st Street"
</PRE>
<P CLASS="t">results in the following line, with a tab character between "Jones" and "123 1st Street":</P>
<P CLASS="spacing"><BR></P>
<PRE>Jones    123 1st Street
</PRE>
<P CLASS="t">None of the WordBasic sequential access instructions that read files recognize<BR>tab characters as delimiters, but many applications support file formats that use<BR>tab characters as delimiters. For example, you could use <B>Print</B> to create a tab-delimited file for a database program.</P>
<H3 CLASS="h3"><A NAME="sec4"></A>Reading from a File</H3><P CLASS="t">The sequential file-access statements <B>Write</B> and <B>Print</B> write information sequentially, adding one line of information after another for as long as the file<BR>is open. The information is read in the same way; after one instruction reads information, the next instruction begins reading the next piece of information, in sequence. All the statements and functions that read sequential files read a line at a time (delimited by a paragraph mark), except <B>Input$</B><B>()</B>, which reads a specified number of characters.</P>
<H4 CLASS="h4"><A NAME="sec5"></A>Read</H4><P CLASS="t">The<B> Read</B> statement is designed to read information written with <B>Write</B>. Here is the syntax:</P>
<P CLASS="syn"><B>Read</B> <B>#</B><I>FileNumber</I><B>,</B><I> Variable1</I>[<B>$</B>]<I> </I>[<B>,&nbsp;</B><I>Variable2</I>[<B>$</B>]]<I> </I>[<B>,&nbsp;</B><I>Variable3</I>[<B>$</B>]]<I> </I>[<B>,&nbsp;</B><FONT FACE="Symbol">¼]</FONT></P>
<P CLASS="t"><B>Read</B> can read both numeric and string values and can read multiple values from a single line when the values are delimited by commas. It removes quotation marks from string values (placed there by <B>Write</B>) and can also accept strings that are not enclosed in quotation marks. <B>Read</B> can accept a string with as many as 65,280 characters; longer strings are truncated. The following example reads values into one string variable and two numeric variables:</P>
<P CLASS="spacing"><BR></P>
<PRE>Read #1, name$, age, employeeNum
</PRE>
<H4 CLASS="h4"><A NAME="sec6"></A>Input</H4><P CLASS="t">Like <B>Read</B>, the <B>Input</B> statement can read multiple values from a single line when the values are delimited by commas. However, <B>Input</B> does not remove quotation marks from strings, so it doesn't work well with <B>Write</B>, which places quotation marks around string values. <B>Input</B> uses the same syntax as <B>Read</B>, as shown in this example:</P>
<P CLASS="spacing"><BR></P>
<PRE>Input #1, name$, age, employeeNum
</PRE>
<H4 CLASS="h4"><A NAME="sec7"></A>Line Input</H4><P CLASS="t">The<B> Line Input</B> statement reads an entire line, including commas or other delimiters, and places it into a string variable. Here is the syntax:</P>
<P CLASS="syn"><B>Line Input</B> <B>#</B><I>FileNumber</I><B>,</B><I> Variable</I><B>$</B></P>
<P CLASS="t"><I>Variable</I> must be a string variable, even if the line contains numbers only. A line is delimited by a paragraph mark. <B>Line Input</B> can accept lines as long as 65,280 characters; longer lines are truncated.</P>
<H4 CLASS="h4"><A NAME="sec8"></A>Input$()</H4><P CLASS="t">With the <B>Input$</B><B>()</B><B> </B>statement, you specify exactly how many characters to read. Here is the syntax:</P>
<P CLASS="syn"><B>Input$(</B><I>NumChars</I><B>,</B> [<B>#</B>]<I>FileNumber</I><B>)</B></P>
<P CLASS="t"><I>NumChars</I> is the number of characters <B>Input$</B><B>()</B> reads from the file identified<BR>by <I>FileNumber</I>. <B>Input$</B><B>()</B> can read any number of lines (as many lines as are contained in the specified number of characters) and returns every character within the specified range of characters, including delimiters such as commas<BR>and carriage returns.</P>
<P CLASS="t"><B>Input$</B><B>()</B> is generally not as useful as the other statements that read sequential files, but you can use it to read a file that uses delimiters that the other sequential file-access statements and functions don't support.</P>
<P CLASS="t">In the following example, <B>Input$</B><B>()</B> is used to read a file in which values are delimited by a space character. The file contains 20 employee numbers, which <B>Input$</B><B>()</B> reads into an array. Each employee number is five characters long and is separated from the following number by a space. Each time <B>Input$</B><B>()</B> reads five characters, it also moves the point at which data is read five characters ahead, so that the next <B>Input$</B><B>()</B> instruction begins reading the next character. Because there is a space between each number, the macro includes the instruction space$ = Input$(1, #1), whose purpose is just to read the space preceding the next number. Otherwise, the second <B>Input$</B><B>()</B> instruction would begin by reading<BR>the space character and miss part of the next employee number.</P>
<P CLASS="spacing"><BR></P>
<PRE>Dim empNums(19)
Open "EMPNUMS.DAT" For Input As #1
    For count = 0 To 19
        empNums(count) = Val(Input$(5, #1))
        space$ = Input$(1, #1)
    Next
Close #1
</PRE>
<H3 CLASS="h3"><A NAME="sec9"></A>Closing a File</H3><P CLASS="t">As mentioned earlier, once you've opened a file in a specific mode — for input, output, or appending — you have to close it before you can open it in a different mode. For example, if a macro opens a file to read some information from it and then needs to overwrite the existing information or append additional information, it must close the file and then reopen it in the appropriate mode. Here is the syntax of the <B>Close</B> statement:</P>
<P CLASS="syn"><B>Close</B> [[<B>#</B>]<I>FileNumber</I>]</P>
<P CLASS="t"><I>FileNumber</I> is the number of the file to close. If <I>FileNumber</I> is not specified, all files opened with the <B>Open</B> statement are closed.</P>
<H3 CLASS="h3"><A NAME="sec10"></A>Other Sequential Access Statements and Functions</H3><P CLASS="t">WordBasic includes four other sequential file-access statements and functions: <B>Eof</B><B>()</B>, <B>Lof</B><B>()</B>, <B>Seek</B>, and <B>Seek</B><B>()</B>.</P>
<H4 CLASS="h4"><A NAME="sec11"></A>Eof()</H4><P CLASS="t">The <B>Eof</B><B>()</B> function returns a value of –1 when the end of a file has been reached. Typically, <B>Eof</B><B>()</B> is used to control a <B>While</B><FONT FACE="Symbol"><B>¼</B></FONT><B>Wend</B> loop that reads a file until it reaches the file's end. Here is the syntax for <B>Eof</B><B>()</B>:</P>
<P CLASS="syn"><B>Eof</B>([<B>#</B>]<I>FileNumber</I><B>)</B></P>
<P CLASS="t"><I>FileNumber</I> is the number assigned to the file when it was opened. The following example reads a list of Word document filenames from a text file. For each document filename, the corresponding file is opened, the DoFormattingRoutine<B> </B>subroutine (not shown here) performs various formatting actions, and the file is closed. The <B>Eof</B><B>()</B> function controls a <B>While</B><FONT FACE="Symbol"><B>¼</B></FONT><B>Wend</B> loop, so that every filename in FILES.TXT is read until the end of the file is reached.</P>
<P CLASS="spacing"><BR></P>
<PRE>Sub MAIN
Open "FILES.TXT" For Input As #1
While Not Eof(#1)
    Read #1, file$
    FileOpen file$
    DoFormattingRoutine
    FileClose 1
Wend
Close #1
End Sub
</PRE>
<H4 CLASS="h4"><A NAME="sec12"></A>Lof()</H4><P CLASS="t">The <B>Lof</B><B>()</B> function returns the length of a file, in bytes, opened with an <B>Open</B> instruction. Each byte corresponds to one character in the file. Among other things, you can use <B>Lof</B><B>()</B> to determine whether a file contains any information. Here is the syntax for <B>Lof</B><B>()</B>:</P>
<P CLASS="syn"><B>Lof(</B>[<B>#</B>]<I>FileNumber</I><B>)</B></P>
<P CLASS="t"><I>FileNumber</I> is the number you assigned to the file when you opened it. The following example determines whether a file contains any information before opening it for output and overwriting it. After the file is opened for input, the <B>Lof</B><B>()</B> function is used to determine whether or not the file already contains information. If it does, a message box is displayed, asking if you want to overwrite the file. If you choose the Yes button in the message box, the file<BR>is closed and then reopened for output.</P>
<P CLASS="spacing"><BR></P>
<PRE>YES = - 1
Open "EMPNUMS.DAT" For Input As #1
If Lof(#1) &gt; 0 Then
    answer = MsgBox("Do you want to overwrite this file?", 4)
    If answer = YES Then
        Close #1
        Open "EMPNUMS.DAT" For Output As #1
        'Series of instructions to write information to the file
    End If
End If
Close #1
</PRE>
<H4 CLASS="h4"><A NAME="sec13"></A>Seek, Seek()</H4><P CLASS="t">The <B>Seek</B> statement changes the point in a file at which information is retrieved or stored. Here is the syntax:</P>
<P CLASS="syn"><B>Seek</B> [<B>#</B>]<I>FileNumber</I><B>,</B><I> Count</I></P>
<P CLASS="t">The <B>Seek</B><B>()</B> function returns the point in the file where information will next be retrieved or stored. Here is the syntax:</P>
<P CLASS="syn"><B>Seek(</B>[<B>#</B>]<I>FileNumber</I><B>)</B></P>
<P CLASS="t">Usually the <B>Seek</B> statement and <B>Seek</B><B>()</B> function are used together. You use the <B>Seek</B><B>()</B> function to return the position of an item; then you use the <B>Seek</B> statement to move directly to that location.</P>
<P CLASS="t">You can use <B>Seek</B> with other sequential access statements and functions to write information into the middle of a file rather than appending it at the end, but this technique has limited use. Whatever is written to the file overwrites the corresponding number of characters in the same position in the file.</P>
<P CLASS="t">The following example is part of a macro to sort mail messages by sender and by subject. The text file MSGS.TXT contains sender names and subject categories. This example searches for the heading "Monthly Reports" in the file, records its position in the variable readposition, and then closes the file. Next, the file is opened to append information to the file, and then closed again. Finally, the file is reopened for input and the instruction Seek #1, readposition moves directly to the position where the "Monthly Reports" heading is located.</P>
<P CLASS="spacing"><BR></P>
<PRE>Open "MSGS.TXT" For Input As #1
While Not Eof(#1) And searchtext$ &lt;&gt; "Monthly Reports"
    readposition = Seek(#1)
    Line Input #1, searchtext$
Wend
Close #1
Open "MSGS.TXT" For Append As #1
    'Series of instructions to append data to the file
Close #1
Open "MSGS.TXT" For Input As #1
Seek #1, readposition
</PRE></FONT></FONT></BODY></HTML>
