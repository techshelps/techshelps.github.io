<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML><HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso8859-1">
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">

<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Index Object</title>

<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

>


	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->




<H2>

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Index Object</h2>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Description</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<b>Index</b> objects specify
the order of records accessed from database tables and whether or
not duplicate records are accepted. <b>Index</b> objects also
provide efficient access to data. For external databases, <b>Index</b>
objects describe the indexes established for external tables.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Remarks</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

The Microsoft Jet database
engine maintains all base table indexes automatically. Indexes
are updated whenever you add, change, or delete records from the
base table. Once the database is created, use the <b>CompactDatabase</b>
method periodically to bring index statistics up-to-date.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

The Jet database engine uses
indexes when it joins tables and creates <b>Recordset</b>
objects. Indexes determine the order of records returned by
table-type <b>Recordset</b> objects, but they don't determine the
order in which records are stored in the base table or the order
of records returned from any other type of recordset.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

When accessing a table-type <b>Recordset</b>
object, you specify the order of records using the object's <b>Index</b>
property. Set this property to the <b>Name</b> property setting
of an existing <b>Index</b> object in the <b>Indexes</b>
collection. This collection is contained by the <b>TableDef</b>
object underlying the <b>Recordset</b> object that you're
populating. For example, to order your table-type <b>Recordset</b>
object by the ZIP_INDEX index, you could use the following code.</p>

<pre>Set dbsBiblio = Workspaces(0).OpenDatabase(&quot;Biblio.mdb&quot;)
Set rstPublishers = dbsBiblio.OpenRecordset(&quot;Publishers&quot;, dbOpenTable)
rstPublishers.Index = &quot;ZIP_INDEX&quot;
</pre>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Tip</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

You don't have to create
indexes for a table, but for large, unindexed tables, accessing a
specific record or processing joins can take a long time.
Conversely, having too many indexes can slow down updates to the
database as each of the table indexes is amended.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

The <b>Attributes</b> property
of each <b>Field</b> object in the index determines the order of
records returned and consequently determines which access
techniques to use for that index.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Each <b>Field</b> object in the
<b>Fields</b> collection of an <b>Index</b> object is a component
of the index. You define a new <b>Index</b> object by setting its
properties before you append it to a collection, which makes the <b>Index</b>
object available for subsequent use.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Note</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

You can modify the <b>Name</b>
property setting of an existing <b>Index</b> object only if the <b>Updatable</b>
property setting of the containing <b>TableDef</b> object is <b>True</b>.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Using an <b>Index</b> object
and its properties, you can:</p>

<ul>
    <li>

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Use the <b>Required</b> property to
        determine whether the <b>Field</b> objects in the index
        require values that are not <b>Null</b>, then use the <b>IgnoreNulls</b>
        property to determine whether the <b>Null</b> values have
        index entries.</li>
    <li>

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Use the <b>Primary</b> and <b>Unique</b>
        properties to determine the ordering and uniqueness of
        the <b>Index</b> object.</li>
</ul>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

When you set a primary key for
a table, the Jet database engine automatically defines it as the
primary index. A primary index consists of one or more fields
that uniquely identify all records in a table in a predefined
order. Because the primary index field must be unique, the Jet
database engine automatically sets the <b>Unique</b> property of
the primary <b>Index</b> object to <b>True</b>. If the primary
index consists of more than one field, each field can contain
duplicate values, but the combination of values from all the
indexed fields must be unique. A primary index consists of a key
for the table and is always made up of the same fields as the
primary key.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Important</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Make sure your data complies
with the attributes of your new index. If your index requires
unique values, make sure that there are no duplicates in existing
data records. If duplicates exist, the Jet database engine can't
create the index, resulting in a trappable error when you attempt
to use the <b>Append</b> method on the new index.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

When you create a relationship
that enforces referential integrity, the Jet database engine
automatically creates an index with the <b>Foreign</b> property,
set as the foreign key in the referencing table. After you've
established a table relationship, the Jet database engine
prevents additions or changes to the database that violate that
relationship. If you set the <b>Attributes</b> property of the <b>Relation</b>
object to allow cascade update and cascade delete operations, the
Jet database engine updates or deletes records in related tables
automatically.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Note</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

The <b>Clustered</b> property
is ignored for databases that use the Jet database engine, which
doesn't support clustered indexes.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Properties</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<b>Clustered </b>Property,<b>
DistinctCount </b>Property,<b> Foreign </b>Property,<b>
IgnoreNulls </b>Property,<b> Name </b>Property,<b> Primary </b>Property,<b>
Required </b>Property,<b> Unique </b>Property.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Methods</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<b>CreateField </b>Method,<b>
CreateProperty </b>Method.</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>See Also</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<b>Attributes </b>Property;<b>
CreateIndex </b>Method;<b> Index </b>Property,<b> OrdinalPosition
</b>Property; Appendix, &quot;Data Access Object Hierarchy.&quot;</p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Example</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

This example creates a new <b>TableDef</b>
object and two new <b>Field</b> objects, appends the <b>Field</b>
objects to the <b>Fields</b> collection in the new <b>TableDef</b>,
and appends the <b>TableDef</b> to the <b>TableDefs</b>
collection in the database. Then it creates a new primary <b>Index</b>
object, includes the two <b>Field</b> objects in it, and appends
the <b>Index</b> to the <b>Indexes</b> collection of the <b>TableDef</b>.
Finally, the example enumerates the<b> Index</b> objects in the
current database.</p>

<pre class="spacing">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

Function EnumerateIndex () As Integer
Dim dbsDefault As Database, tdfTest As TableDef
Dim fldOne As Field, fldTwo As Field, idxPrimary As Index
Dim I As Integer
' Get workspace and database.
Set dbsDefault = _
DBEngine.Workspaces(0).OpenDatabase(&quot;Northwind.mdb&quot;)
' Create table with two fields.
Set tdfTest = dbsDefault.CreateTableDef(&quot;MyTable&quot;)
Set fldOne = tdfTest.CreateField(&quot;Field1&quot;, dbLong)
fldOne.Required = True ' No Null values allowed.
tdfTest.Fields.Append fldOne
Set fldTwo = tdfTest.CreateField(&quot;Field2&quot;, dbLong)
fldTwo.Required = True ' No Null values allowed.
tdfTest.Fields.Append fldTwo
dbsDefault.TableDefs.Append tdfTest
' Create primary index for those two fields.
Set idxPrimary = tdfTest.CreateIndex(&quot;MyIndex&quot;)
idxPrimary.Primary = True
Set fldOne = tdfTest.CreateField(&quot;Field1&quot;)
idxPrimary.Fields.Append fldOne</pre>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

&nbsp;</p>

<pre>    Set fldTwo = tdfTest.CreateField(&quot;Field2&quot;)
    idxPrimary.Fields.Append fldTwo
    tdfTest.Indexes.Append idxPrimary
    ' Enumerate index and its fields.
    Debug.Print &quot;Index: &quot;; idxPrimary.Name
    Debug.Print &quot;  Required: &quot;; idxPrimary.Required
    Debug.Print &quot;  IgnoreNulls: &quot;; idxPrimary.IgnoreNulls
    Debug.Print &quot;  Primary: &quot;; idxPrimary.Primary
    Debug.Print &quot;  Clustered: &quot;; idxPrimary.Clustered
    Debug.Print &quot;  Unique: &quot;; idxPrimary.Unique
    Debug. Print &quot;  Foreign: &quot;; idxPrimary.Foreign
    Debug.Print
    Debug.Print &quot;Fields in Index: &quot;;
    For I = 0 To idxPrimary.Fields.Count - 1
        Debug.Print &quot; &quot;; idxPrimary.Fields(I).Name;
    Next I
    Debug.Print
    EnumerateIndex = True
End Function
</pre>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

This example opens a table-type
<b>Recordset</b> and selects an index for the <b>Recordset</b>.
By setting an index, the Microsoft Jet database engine returns
records in the order specified by the index. Without an index,
table-type <b>Recordset</b> objects return records from the
database table in no particular order.</p>

<br>
</p>

<pre>Dim dbsDefault As Database
Dim rstTitles as Recordset
' Get workspace and database.
Set dbsDefault = _
     DBEngine.Workspaces(0).OpenDatabase(&quot;Northwind.mdb&quot;)
Set rstTitles = dbsDefault.OpenRecordset(&quot;Titles&quot;)
rstTitles.Index = &quot;MyIndex&quot;
.
.
.
</pre>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

<strong>Example (Microsoft
Access)</strong></p>



	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->

The following example creates a
new index on an Employees table.</p>

<br>
</p>

<pre>Sub NewIndex()
    Dim dbs As Database, tdf As TableDef, idx As Index
    Dim fld As Field

    ' Return Database object pointing to current database.
    Set dbs = CurrentDb
    Set tdf = dbs.TableDefs!Employees
    Set idx = tdf.CreateIndex(&quot;LastNameIndex&quot;)
    Set fld = idx.CreateField(&quot;LastName&quot;)
    idx.Fields.Append fld
    tdf.Indexes.Append idx
End Sub</pre>
</BODY>

</html>
