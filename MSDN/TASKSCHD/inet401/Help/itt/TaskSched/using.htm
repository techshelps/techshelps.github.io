<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Programming the Task Scheduler</TITLE>

<META NAME=MS-HKWD CONTENT="Programming the Task Scheduler">
<META NAME="Keywords" CONTENT="Internet Tools & Technologies">
<META NAME="Platform" CONTENT="Windows, Win95, WinNT, Mac">
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; CHARSET=iso8859-1">
<META NAME="MS.LOCALE" CONTENT="EN-US">
<META NAME="ROBOTS" CONTENT="all">


<SCRIPT>
//<!--
var g_isIE = false, g_isNav = false, g_iMaj = 0, g_sPlat = "";
// -->
</SCRIPT>
<SCRIPT SRC="../../code/ver.js"></SCRIPT>


<SCRIPT DEFER SRC="../../code/common.js"></SCRIPT>
<SCRIPT DEFER>
//<!--
function InitPage()
{
	if (g_isIE && g_iMaj >= 4)	
	{
		SetTOC();
	}
}
//-->
</SCRIPT>

<LINK REL="stylesheet" HREF="/msdn/sdk/inetsdk/help/basicsdkIE4.css" TYPE="text/css">
<!-- STYLE_START -->


<SCRIPT>
//<!--
   var sVR = '../../'	// Set root for the style sheet
   var sCSS = '<LINK REL="stylesheet" HREF="' + sVR;

   if(g_isIE)
   {
	   if (g_iMaj >= 4) // For MSIE 4.0 or later
	   {
		   sCSS += 'basicSDKIE4';
		   if (g_sPlat == "Win") // Windows only for now
		   {
			   document.createStyleSheet(sVR + 'advSDKIE4.css');
		   }
	   }
	   else // For MSIE 3.0 or earlier
	   {
		   sCSS += 'basicSDKIE3';
	   }
   }
   else if (g_isNav) // For all Nav versions
   {
	   sCSS += 'basicSDKNAV';
   }
   else
   {
	   sCSS += 'basicSDKIE3'; // default to IE3 sheet
   }

   sCSS += (sCSS == '' ? '' : '.css" TYPE="text/css">');

   document.write(sCSS);
//-->
</SCRIPT>
<!-- STYLE_END -->
</HEAD>
<BODY onload="InitPage()" BGCOLOR="#FFFFFF">

<A NAME="pagetop"></A><A NAME="ch_task_using"></A>
<!-- NAV_LINKS_START -->
<TABLE class=main BORDER=0 CELLSPACING="0" CELLPADDING="0" WIDTH="10%"><TR><TD ROWSPAN="3" VALIGN="TOP" WIDTH="121"><IMG SRC="../../art/headbar2.gif" WIDTH="121" HEIGHT="82" BORDER=0 ALT="Programming the Task Scheduler"></TD><TD ROWSPAN="2" VALIGN="TOP" WIDTH="186"><IMG SRC="../../art/headbard.gif" WIDTH="186" HEIGHT="44" BORDER=0 ALT="Programming the Task Scheduler"></TD><TD VALIGN="TOP" WIDTH="470"><IMG SRC="../../art/replace1.gif" WIDTH="470" HEIGHT="17" BORDER=0 ALT="*"></TD></TR>
<TR><TD><PRE><IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_1" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Contents>
</object><A STYLE="color:black" ID=TOC HREF=JavaScript:hhal_1.Click()>Contents</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><object id="hhal_2" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Index_1sz1>
</object><A STYLE="color:black" HREF=JavaScript:hhal_2.Click()>Index</A>  <IMG SRC="../../art/arrowrht.gif" WIDTH="14" HEIGHT="14" ALIGN="MIDDLE" BORDER=0 ALT="*"><A STYLE="color:black" HREF="task.htm#book_task">Topic Contents</A></PRE></TD></TR>
<TR><TD COLSPAN="2"><PRE><IMG SRC="../../art/arrowlft.gif" WIDTH="17" HEIGHT="15" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Previous Topic:</B> <A STYLE="color:black" HREF="about.htm">About the Task Scheduler</A>
<IMG SRC="../../art/arrownxt.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER=0 ALT="*"><B>Next Topic:</B> <A  STYLE="color:black" HREF="RefList.htm">Task Scheduler Reference</A></PRE></TD></TR>
</TABLE>
<!-- NAV_LINKS_END -->
<BLOCKQUOTE class="body">
<!-- CONTENTS_START -->
<H1>Programming the Task Scheduler</H1>

<P>The collection of interfaces and methods available to the developer from the Task Scheduler represents the programmatic techniques necessary to implement the functionality of task management.

<P><A CLASS=tctop HREF="using.htm#Manipulating_Schedul"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Manipulating Scheduled Work Items</A><BR>
<P><A CLASS=tctop HREF="using.htm#Starting_the_Task_Sc"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Starting the Task Scheduler Service</A><BR>
<P><A CLASS=tctop HREF="using.htm#Task_Names"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Task Names</A><BR>
<P><A CLASS=tctop HREF="using.htm#Task_Triggers"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">Task Triggers</A><BR>
<P><A CLASS=tctop HREF="using.htm#The_Starting_Point__"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">The Starting Point: ITaskScheduler</A><BR>
<P><A CLASS=tctop HREF="using.htm#The_Target_Computer"><IMG SRC="../../art/arrowy.gif" WIDTH="6" HEIGHT="11" BORDER=0 ALT="arrowy.gif">The Target Computer</A><BR>
<H2><A NAME="Manipulating_Schedul">Manipulating Scheduled Work Items</A></H2>
<P>The <A HREF="ifaces/ischeduledworkitem/IScheduledWorkItem.htm#IScheduledWorkItem">IScheduledWorkItem</A> interface allows you to modify an existing work item's behaviors. When you have the interface pointer to <B>IScheduledWorkItem</B>, you have the ability to run, terminate, or modify the characteristics for a given task. The behavior and properties of each scheduled task are accessible through the <B>IScheduledWorkItem</B> interface.


 
<H2><A NAME="Starting_the_Task_Sc">Starting the Task Scheduler Service</A></H2>
<P>The Task Scheduler service is not started by default; the developer is responsible for determining the current running state of the Task Scheduler. The following code is an example of how to start the Task Scheduler service.

<PRE>
//+--------------------------------------------------------------------------
//
//  Function:   StartScheduler
//
//  Synopsis:   Start the task scheduler service if it isn't already running.
//
//  Returns:    ERROR_SUCCESS or a Win32 error code.
//
//  Notes:      This function works for either Win9x or Windows NT.
//              If the service is running but paused, does nothing.
//
//---------------------------------------------------------------------------

#define SCHED_CLASS             TEXT("SAGEWINDOWCLASS")
#define SCHED_TITLE             TEXT("SYSTEM AGENT COM WINDOW")
#define SCHED_SERVICE_APP_NAME  TEXT("mstask.exe")
#define SCHED_SERVICE_NAME      TEXT("Schedule")

DWORD 
StartScheduler()
{

    OSVERSIONINFO osver;

    osver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    // Determine what version of OS we are running on.
    GetVersionEx(&amp;osver);

    if (osver.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
    {
        // Start the Win95 version of TaskScheduler.

        HWND hwnd = FindWindow(SCHED_CLASS, SCHED_TITLE);

        if (hwnd != NULL)
        {
            // It is already running.
            return ERROR_SUCCESS;
        }

        //
        //  Execute the task scheduler process.
        //
        STARTUPINFO         sui;
        PROCESS_INFORMATION pi;

        ZeroMemory(&amp;sui, sizeof(sui));
        sui.cb = sizeof (STARTUPINFO);

        TCHAR szApp[MAX_PATH];
        LPTSTR pszPath;

        DWORD dwRet = SearchPath(NULL,
                                 SCHED_SERVICE_APP_NAME,
                                 NULL,
                                 MAX_PATH,
                                 szApp,
                                 &amp;pszPath);

        if (dwRet == 0)
        {
            return GetLastError();
        }

        BOOL fRet = CreateProcess(szApp,
                                  NULL,
                                  NULL,
                                  NULL,
                                  FALSE,
                                  CREATE_NEW_CONSOLE | CREATE_NEW_PROCESS_GROUP,
                                  NULL,
                                  NULL,
                                  &amp;sui,
                                  &amp;pi);

        if (fRet == 0)
        {
            return GetLastError();
        }

        CloseHandle(pi.hProcess);
        CloseHandle(pi.hThread);

        return ERROR_SUCCESS;
    }
    else
    {

        // If not Win95 then start the NT version as a TaskScheduler service.

        SC_HANDLE   hSC = NULL;
        SC_HANDLE   hSchSvc = NULL;

        hSC = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

        if (hSC == NULL)
        {
            return GetLastError();
        }

        hSchSvc = OpenService(hSC,
                              SCHED_SERVICE_NAME,
                              SERVICE_START | SERVICE_QUERY_STATUS);

        CloseServiceHandle(hSC);

        if (hSchSvc == NULL)
        {
            return GetLastError();
        }

        SERVICE_STATUS SvcStatus;

        if (QueryServiceStatus(hSchSvc, &amp;SvcStatus) == FALSE)
        {
            CloseServiceHandle(hSchSvc);
            return GetLastError();
        }

        if (SvcStatus.dwCurrentState == SERVICE_RUNNING)
        {
            // The service is already running.
            CloseServiceHandle(hSchSvc);
            return ERROR_SUCCESS;
        }

        if (StartService(hSchSvc, 0, NULL) == FALSE)
        {
            CloseServiceHandle(hSchSvc);
            return GetLastError();
        }

        CloseServiceHandle(hSchSvc);

        return ERROR_SUCCESS;
    }
}
</PRE>
<H2><A NAME="Task_Names">Task Names</A></H2>
<P>A task name is the name of the file that stores the task information. These files all have the .job extension and reside in the Tasks folder. You can retrieve the location of the Tasks folder from the registry by getting the data for the following value:

<PRE>HKEY_LOCAL_MACHINE
    SOFTWARE
        Microsoft
            SchedulingAgent
                TasksFolder
</PRE>
<P>
The task names are always given in wide characters, so you need to convert the string to ANSI characters if your application is not built for Unicode. The <B>ConvertString</B> function handles this for you.

<PRE>BOOL ConvertString(LPTSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
{
#ifdef UNICODE
    if(lstrcpyn(pszOut, pwszIn, dwSize))
        {
        return TRUE;
        }
#else
    if(WideCharToMultiByte( CP_ACP,
            0,
            pwszIn,
            -1,
            pszOut,
            dwSize,
            NULL,
            NULL))
        {
        return TRUE;
        }
#endif   // UNICODE

return FALSE;
}
</PRE>
<P>All the Task Scheduler methods that take a task name examine the name and add the .job extension if it is not already present.


 
<H3><A NAME="sec_creating_task<ti">Creating Tasks</A></H3>
<P>Listing the current tasks is all well and good, but how do you create your own task? There are two ways to do this. The first is to use <A HREF="ifaces/itaskscheduler/NewWorkItem.htm#ITaskScheduler__NewW">ITaskScheduler::NewWorkItem</A>. This method will instantiate an <A HREF="ifaces/itask/ITask.htm#ITask">ITask</A> interface and assign it the name you provide. The second is to call <A HREF="ifaces/itaskscheduler/AddWorkItem.htm#ITaskScheduler__AddW">ITaskScheduler::AddWorkItem</A>. When you take this route, it is your responsibility to instantiate the <B>ITask</B> interface and then add the task with the name you supply.

<P>The name you supply for the task must be unique within the Tasks folder. If a task with that name already exists, <A HREF="ifaces/itaskscheduler/NewWorkItem.htm#ITaskScheduler__NewW">ITaskScheduler::NewWorkItem</A> and <A HREF="ifaces/itaskscheduler/AddWorkItem.htm#ITaskScheduler__AddW">ITaskScheduler::AddWorkItem</A> return ERROR_FILE_EXISTS. If you get this return value, you should specify a different name and attempt to add the task again. 

 
<H3><A NAME="Deleting_Tasks">Deleting Tasks</A></H3>
<P>You use the <A HREF="ifaces/itaskscheduler/Delete.htm#ITaskScheduler__Dele">ITaskScheduler::Delete</A> method to delete a task. You simply supply the name of the task and, if the task is present, it will be deleted.

 
<H3><A NAME="sec_editing_a_task">Editing a Task</A></H3>
<P>When you are viewing the Tasks folder in Windows&#174; Explorer, you can edit the task by double-clicking it. When you do this, the scheduling agent actually calls the tasks object's <A HREF="ifaces/ischeduledworkitem/EditWorkItem.htm#IScheduledWorkItem__">IScheduledWorkItem::EditWorkItem</A> method. Fortunately, this method has been exposed, so you can do the same thing programmatically without having to implement all the user interface code and resources. The only thing you have to provide is a parent window handle. 
<P>
For more information on editing tasks, see <A HREF="using.htm#sec_task_property_sheet">Task Property Sheet</A>.


 
<H3><A NAME="Enumerating_Tasks">Enumerating Tasks</A></H3>
<P>To enumerate tasks, call <A HREF="ifaces/itaskscheduler/Enum.htm#ITaskScheduler__Enum">ITaskScheduler::Enum</A>. This gives you an <A HREF="ifaces/ienumworkitems/IEnumWorkItems.htm#IEnumWorkItems">IEnumWorkItems</A> interface pointer that you can use to retrieve the names of the tasks. When you have the name of a task, you can call <A HREF="ifaces/itaskscheduler/Activate.htm#ITaskScheduler__Acti">ITaskScheduler::Activate</A> to get the <A HREF="ifaces/itask/ITask.htm#ITask">ITask</A> interface for the task. When you have the <B>ITask</B> interface pointer, you can get or set any of the task information that you want. The following example enumerates all the tasks and adds them to a list view control to display them. For additional information on list views, see
<object id="hhal_3" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_List_View_Controls>
</object><A HREF=JavaScript:hhal_3.Click()>List View Controls</A>. 
<P><B>Note</B>  Before the list view is destroyed, the release method for <A HREF="ifaces/itask/ITask.htm#ITask">ITask</A> is called for each item in the list view. The caller of <A HREF="ifaces/itaskscheduler/Activate.htm#ITaskScheduler__Acti">ITaskScheduler::Activate</A> is responsible for releasing the returned pointer.
<PRE>BOOL LoadTaskList(HWND hwndListView)
{
HRESULT          hr;
IEnumWorkItems  *pEnum;

hr = g_pSchedulingAgent-&gt;Enum(&amp;pEnum);
if(SUCCEEDED(hr))
    {
    LPWSTR   *ppNames;
    DWORD    dwFetched;

    while(SUCCEEDED(pEnum-&gt;Next(5, &amp;ppNames, &amp;dwFetched)) &amp;&amp; dwFetched)
        {
        DWORD i;
        TCHAR szString[MAX_PATH];

        for(i = 0; i &lt; dwFetched; i++)
            {
            if(ConvertString(szString, *(ppNames + i), sizeof(szString)))
                {
                LV_ITEM  lvItem;
                ITask *pTask;

                ZeroMemory(&amp;lvItem, sizeof(lvItem));
                lvItem.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
                lvItem.pszText = szString;
                lvItem.iImage = I_IMAGECALLBACK;
                lvItem.iItem = ListView_GetItemCount(hwndListView);
            
                // Get the ITask for this task.
                hr = g_pSchedulingAgent-&gt;Activate(  *(ppNames + i), 
                        IID_ITask, 
                        (LPUNKNOWN*)&amp;pTask);
                if(SUCCEEDED(hr))
                    {
                lvItem.lParam = (LPARAM)pTask;

                // Add the item to the list.
                ListView_InsertItem(hwndListView, &amp;lvItem);
                }
            }

            // Free the string.
            CoTaskMemFree(*(ppNames + i));
            }
      
        // Free the array.
        CoTaskMemFree(ppNames);
        }

    pEnum-&gt;Release();
    return TRUE;
    }

return FALSE;
}
</PRE>
<H3><A NAME="Executing_and_Termin">Executing and Terminating a Task</A></H3>
<P>If you want to programmatically cause a task to run, you simply call the task object's <A HREF="ifaces/ischeduledworkitem/Run.htm#IScheduledWorkItem__">IScheduledWorkItem::Run</A> method. This method attempts to execute the task and returns as soon as the task has started. The Task Scheduler service must be running for this method to succeed.

<P>If it becomes necessary for you to terminate a running task, you can use <A HREF="ifaces/ischeduledworkitem/Terminate.htm#IScheduledWorkItem__">IScheduledWorkItem::Terminate</A>. This method attempts to terminate the task and returns a success/failure code, informing your application if it was successful or not. <B>IScheduledWorkItem::Terminate</B> attempts to gracefully shut down the application by sending it a WM_CLOSE message. It then waits approximately three minutes for the process to terminate. If the process has not terminated within that three minutes, <B>IScheduledWorkItem::Terminate</B> uses
<object id="hhal_4" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_4.Click()>TerminateProcess</A> to terminate the task. As you can see, there is potential here for data loss if the application must be terminated the hard way. Therefore, you should avoid terminating tasks if at all possible.

 
<H3><A NAME="Manipulating_Tasks__">Manipulating Tasks: ITask</A></H3>
<P><A HREF="ifaces/itask/ITask.htm#ITask">ITask</A> is the interface you use to control a task object. You can set and retrieve all of the task's information, execute and terminate the task, add and delete triggers, and even allow the user to modify the task with a standard user interface.

<P><A HREF="ifaces/itask/ITask.htm#ITask">ITask</A> implements all the methods necessary to set and retrieve all of the task's information. For a complete list of the methods for affecting the task, see the <B>ITask</B> references. The method names are rather self-explanatory.

 
<H3><A NAME="sec_task_property_sheet">Task Property Sheet</A></H3>
<P>The <A HREF="ifaces/iprovidetaskpage/GetPage.htm#IProvideTaskPage__Ge">IProvideTaskPage::GetPage</A> method provides the ability to retrieve the property sheet page associated with a task object. The information for the task object's general page, schedule, and settings is available from the <A HREF="ifaces/iprovidetaskpage/IProvideTaskPage.htm#IProvideTaskPage">GetPage</A> method.

<PRE>VOID EditTaskSettings(ITask *pTask)
{
    IProvideTaskPage   *ptp;
    PROPSHEETHEADER     psh;
    HPROPSHEETPAGE      hpage;
    
    // Display the "Settings" property page.
    pTask-&gt;QueryInterface(IID_IProvideTaskPage, (VOID**)(IProvideTaskPage**)&amp;ptp);
    
    // The settings will be saved to the task object on release.
    ptp-&gt;GetPage(TASKPAGE_SETTINGS, TRUE, &amp;hpage);
     
    // Display the page in its own property sheet.
    psh.dwSize=sizeof(PROPSHEETHEADER);
    psh.dwFlags=PSH_DEFAULT;
    psh.hwndParent=NULL;
    psh.hInstance=NULL;
    psh.pszCaption=TEXT("Just the settings page on the task object");
    psh.phpage=&amp;hpage;
    psh.nPages=1;
    
    PropertySheet(&amp;psh);
}
</PRE>
<H2><A NAME="Task_Triggers">Task Triggers</A></H2>
<P>Applications can use the methods available from the task scheduler interfaces to access, set, or modify the trigger for a task. Triggers specify task start times, repetition criteria, and other parameters.

 
<H3><A NAME="Creating_and_Deletin">Creating and Deleting Triggers</A></H3>
<P>When you use <A HREF="ifaces/ischeduledworkitem/CreateTrigger.htm#IScheduledWorkItem__">IScheduledWorkItem::CreateTrigger</A>, you are creating a brand new <A HREF="ifaces/itasktrigger/ITaskTrigger.htm#ITaskTrigger">ITaskTrigger</A> object. <B>IScheduledWorkItem::CreateTrigger</B> gives you both the new trigger's numeric index and the <B>ITaskTrigger</B> interface pointer. You can then use this interface to modify the trigger parameters. By the same token, <A HREF="ifaces/ischeduledworkitem/DeleteTrigger.htm#IScheduledWorkItem__">IScheduledWorkItem::DeleteTrigger</A> deletes the trigger that has the numeric index specified.

 
<H3><A NAME="Manipulating_Trigger">Manipulating Triggers: ITaskTrigger</A></H3>
<P>The <A HREF="ifaces/itasktrigger/ITaskTrigger.htm#ITaskTrigger">ITaskTrigger</A> interface allows you to modify an existing trigger's parameters, but how do you get the <B>ITaskTrigger</B> interface for a trigger object? There are two ways to do this:

<UL><LI>Create a new trigger using <A HREF="ifaces/ischeduledworkitem/CreateTrigger.htm#IScheduledWorkItem__">IScheduledWorkItem::CreateTrigger</A>.
<LI>Use <A HREF="ifaces/ischeduledworkitem/GetTrigger.htm#IScheduledWorkItem__">IScheduledWorkItem::GetTrigger</A>. This method takes the desired trigger's numerical index.
</UL>
<P>When you have the interface, you can use <A HREF="ifaces/itasktrigger/SetTrigger.htm#ITaskTrigger__SetTri">ITaskTrigger::SetTrigger</A> to set the trigger information and <A HREF="ifaces/itasktrigger/GetTrigger.htm#ITaskTrigger__GetTri">ITaskTrigger::GetTrigger</A> to get the trigger object's information. <A HREF="ifaces/itasktrigger/GetTriggerString.htm#ITaskTrigger__GetTri">ITaskTrigger::GetTriggerString</A> gives you a formatted string describing the trigger. You can use this string to display information about the trigger.

 
<H2><A NAME="The_Starting_Point__">The Starting Point: ITaskScheduler</A></H2>
<P>
The <A HREF="ifaces/itaskscheduler/ITaskScheduler.htm#ITaskScheduler">ITaskScheduler</A> interface is the starting point for programming the Task Scheduler. <B>ITaskScheduler</B> allows you to enumerate, add, modify, and delete tasks, and administer tasks on another computer. All you have to do to obtain the <B>ITaskScheduler</B> interface is to call
<object id="hhal_5" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_5.Click()>CoCreateInstance</A> with the scheduling agent class identifier and interface identifier. The following example shows how this is done.
<P>
<PRE>#include &lt;mstask.h&gt;

ITaskScheduler  *g_pSchedulingAgent;

BOOL Initialize(void)
{
HRESULT  hr;

CoInitialize(NULL);

hr = CoCreateInstance( CLSID_CSchedulingAgent, 
            NULL, 
            CLSCTX_INPROC_SERVER, 
            IID_ITaskScheduler, 
            (LPVOID*)&amp;g_pSchedulingAgent);

return SUCCEEDED(hr);
}
</PRE>
<P>When you no longer need the <A HREF="ifaces/itaskscheduler/ITaskScheduler.htm#ITaskScheduler">ITaskScheduler</A> interface, simply call its <B>Release</B> method. All of the methods contained within the
<object id="hhal_6" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_6.Click()>IUnknown</A> interface are inherited in <B>ITaskScheduler</B>; these include <B>QueryInterface</B>, <B>AddRef</B>, and <B>Release</B>.
Don't forget that you need to call
<object id="hhal_7" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_7.Click()>CoInitialize</A> or
<object id="hhal_8" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_8.Click()>OleInitialize</A> before calling
<object id="hhal_9" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_9.Click()>CoCreateInstance</A>. Also, be sure to call <B>CoUninitialize</B> or
<object id="hhal_10" type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink">
<PARAM name="Item1" value="">
<PARAM name="Item2" value=_win32_Further_Reading>
</object><A HREF=JavaScript:hhal_10.Click()>OleUninitialize</A> when you are done using OLE.


 
<H2><A NAME="The_Target_Computer">The Target Computer</A></H2>
<P>In Task Scheduler terms, the target computer is the computer to which any instance of the <A HREF="ifaces/itaskscheduler/ITaskScheduler.htm#ITaskScheduler">ITaskScheduler</A> interface is associated. All of the tasks that each instance of the <B>ITaskScheduler</B> interface controls are stored on the target computer and will run on the target computer. When you create a new instance of <B>ITaskScheduler</B>, the local computer is the target computer by default. 

<P>You can use <A HREF="ifaces/itaskscheduler/ITaskScheduler.htm#ITaskScheduler">ITaskScheduler</A> to administer tasks on a remote computer. There are constraints for remote task administration: 

<UL><LI>You can view tasks on a remote computer running Windows NT&#174; only if you are an administrator on that remote computer.

<LI>You can edit tasks on a remote Windows&#174; 95 computer only if that remote computer has remote registry software installed and shares the <I>x$</I> share, where <I>x</I> is the hard drive on which the Tasks folder resides.

<LI>A computer running Windows 95 must have the remote registry service installed before it can set the target computer to a remote computer, or be specified as a remote target computer.

<P>For more information on installing the remote registry service, see article <A HREF="http://www.microsoft.com/kb/articles/q141/4/60.htm" TARGET="_top">Q141460</A> in the Microsoft Knowledge Base.
</UL>
<P>You use <A HREF="ifaces/itaskscheduler/SetTargetComputer.htm#ITaskScheduler::SetTargetComputer">ITaskScheduler::SetTargetComputer</A> to change the target computer and <A HREF="ifaces/itaskscheduler/GetTargetComputer.htm#ITaskScheduler::GetTargetComputer">ITaskScheduler::GetTargetComputer</A> to get the name of the target computer. Computer names are always in Universal Naming Convention (UNC) format.


<!-- CONTENTS_END -->
<!-- START PAGE FOOTER -->
<H6><HR size=1></H6>
<P><A ID=line HREF="#pagetop"><IMG src="../../art/arrowup1.gif" WIDTH="17" HEIGHT="16" ALIGN="MIDDLE" BORDER="0" ALT="Up">&nbsp;Top of Page</A>
<BR><A ID=line HREF="http://www.microsoft.com/misc/cpyright.htm" TARGET="_top">&#169; 1997 Microsoft Corporation. All rights reserved. Terms of Use.</A>
<!-- END PAGE FOOTER -->
</BLOCKQUOTE>
</BODY>
</HTML>