<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="D:\CDs\templates\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Seven Percent Solution (September)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>The Seven Percent Solution</b></font></p>
    <p><font size="2">Rod Stephens</font></p>
    <p><font size="2"><i>In this month&#146;s column Rod explains
    how you can make more than $5 million. Of course you need to
    have $100 million to spend and just the right combination of
    investment opportunities. Those are problems that you have to
    solve on your own. But Rod gives you a </i>decision tree <i>to
    help.</i></font></p>
    <p><font size="2">SUPPOSE you have $100 million to spend on
    one of two investments. The first costs $75 million and
    promises a seven percent return. The second costs $80 million
    and yields a five percent return. Seven percent of $75
    million is $5.25 million and five percent of $80 million is
    $4 million. To make the most money, you should pick the seven
    percent solution.</font></p>
    <p><font size="2">Unfortunately, reality is rarely so simple.
    If you really had $100 million to spend, you would suddenly
    find you had dozens&#151;if not hundreds&#151;of new best
    friends, all willing to share the investment &quot;deal of
    the century&quot; with you. Obviously, even if you have a
    pretty good method for estimating the potential return from
    an investment, there&#146;s always a chance something will go
    wrong. In a complex mix of uncertain investments, picking the
    combination that will maximize your return is a much more
    difficult problem.</font></p>
    <p><font size="2">You can model this and many other difficult
    problems using <i>decision trees</i>. This month I&#146;ll
    explain what decision trees are and how you can use them to
    study these sorts of problems. I&#146;ll also describe two
    methods for searching a decision tree to find the best
    possible solution. I&#146;ll finish by describing a couple of
    <i>heuristic</i> methods for finding good solutions using
    decision trees. (Heuristic (adj. or noun): Of or relating to
    exploratory problem-solving techniques that utilize
    self-educating techniques. Related to &quot;common
    sense,&quot; or &quot;rule of thumb.&quot;) While heuristics
    aren&#146;t guaranteed to produce the best solution, they
    often produce very good results for search trees that are too
    big for other methods.</font></p>
    <p><font size="5"><b>The root of the problem</b></font></p>
    <p><font size="2">The investment problem I described earlier
    is actually a specific example of one of the classic problems
    in computer science: the <i>knapsack</i> problem. In this
    problem you have a &quot;knapsack&quot; of a certain size.
    You also have several objects of different sizes and values.
    Your goal is to fit objects into the knapsack to make the
    total value of the package as large as possible.</font></p>
    <p><font size="2">In the investment problem, the
    &quot;knapsack&quot; represents the amount&#151;$100
    million&#151;that you have to spend, and the objects
    represent the potential investments. Their sizes are their
    costs and their values are their profits. When you pick your
    investments, their combined cost must be no greater than the
    $100 million knapsack size. You want to maximize the profit
    returned by your investments while satisfying this
    constraint.</font></p>
    <p><font size="2">One way to think of the knapsack problem is
    to ask&#151;for each object&#151;whether that object should
    be part of the solution. If you make these decisions one at a
    time, you can model them using a decision tree. Each node in
    the decision tree represents one of these questions. For
    example, the root node represents the question, &quot;Should
    I spend money on the first investment?&quot;</font></p>
    <p><font size="2">Each branch out of a node represents one of
    the possible answers. For consistency, you can assume the
    left branch represents a &quot;yes&quot; answer to a question
    and the right branch represents a &quot;no&quot; answer.</font></p>
    <p><font size="2">Figure 1 shows a decision tree for the
    two-investment problem. Notice that the leftmost path through
    the tree isn&#146;t feasible because it costs more than the
    $100 million spending allowance. Notice also that the
    rightmost path through the tree corresponds to making no
    investments, costs nothing, and produces no profit. In any
    knapsack decision tree, the rightmost path will be feasible
    since it costs nothing.</font></p>
</blockquote>

<blockquote>
    <p><font size="5"><b>Climbing trees</b></font></p>
    <p><font size="2">Once you start thinking in terms of
    decision trees, you can convert the original problem into one
    of finding a path through the tree. The paths from the top to
    the bottom of the tree represent possible solutions to the
    knapsack problem. The branches you follow in a path indicate
    the decisions you should make to produce a particular
    solution. For instance, if you follow the &quot;yes&quot;
    branch at the second level in the tree, you should spend
    money on the second investment opportunity.</font></p>
    <p><font size="2">Your mission is to find the
    &quot;best&quot; path through the tree. In the knapsack
    problem you want to find the path to the leaf node with the
    greatest profit. In Figure 1, the second node from the left
    at the bottom of the tree has the largest profit, so the path
    to that node is the best path through the tree.</font></p>
    <p><font size="2">One way you could search for the best path
    is to examine them all. When you reach the bottom of the
    tree, first make sure the resulting solution is allowed. For
    example, in the investment example, the total cost of the
    investments in the solution must not exceed $100 million.
    Next, see if the result produced by the path is better than
    the best result you&#146;ve found so far. If so, store it
    somewhere and continue checking the rest of the tree. When
    you&#146;re finished, you&#146;ll have found the best
    possible combination of investments.</font></p>
    <p><font size="2">Since this method searches the entire tree,
    it is called an <i>exhaustive search</i>. As you&#146;ll see
    when you run the example programs, this kind of search can
    indeed be exhausting. Listing 1 shows code that finds the
    best possible solution using an exhaustive search. The Cost
    and Profit arrays hold the costs and profits provided by the
    different investments.</font></p>
    <p><font size="2">The Exhaust subroutine takes as a parameter
    the index of an item. It recursively explores the solutions
    possible with that item either included or excluded from the
    test solution. For example, when the item&#146;s index is
    three, the routine is considering a decision node at the
    third level of the decision tree. It first adds the item to
    the test solution and then recursively tests assignments for
    the remaining items. When that recursion returns, it excludes
    the item from the test solution and again recursively makes
    assignments for the other items.</font></p>
    <p><font size="2">When subroutine Exhaust is invoked for an
    item with an index greater than the total number of items
    available, it has already made assignments for all of the
    investment options. It then checks to see if the cost of the
    test solution fits within the spending allowance MAX_COST. If
    so, and if the profit provided by the test solution is
    greater than the best value found so far, the routine saves
    the test solution as the new best solution.</font></p>
    <p><font size="2"><b>Listing 1.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>Solving the knapsack problem with exhaustive
    search.</b></font></p>
    <p><font size="2" face="Courier New">' Allowed total cost.</font></p>
    <p><font size="2" face="Courier New">Const MAX_COST = 100</font></p>
    <p><font size="2" face="Courier New">' The number of items.</font></p>
    <p><font size="2" face="Courier New">Dim NumItems As Integer</font></p>
    <p><font size="2" face="Courier New">' The cost for item i.</font></p>
    <p><font size="2" face="Courier New">Dim Cost() As Integer</font></p>
    <p><font size="2" face="Courier New">' The profit for item i.</font></p>
    <p><font size="2" face="Courier New">Dim Profit() As Integer</font></p>
    <p><font size="2" face="Courier New">' Items in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestUse() As Integer</font></p>
    <p><font size="2" face="Courier New">' Profit in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestProfit As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Cost in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestCost As Integer</font></p>
    <p><font size="2" face="Courier New">' Best profit so far.</font></p>
    <p><font size="2" face="Courier New">Dim BestProfit As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Items in the best
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim BestUse() As Integer</font></p>
    <p><font size="2" face="Courier New">Sub Exhaust (item As
    Integer)</font></p>
    <p><font size="2" face="Courier New">Dim i As Integer</font></p>
    <p><font size="2" face="Courier New">' If all the items are
    either in or out,</font></p>
    <p><font size="2" face="Courier New">' see if this solution
    is better than the </font></p>
    <p><font size="2" face="Courier New">' current best.</font></p>
    <p><font size="2" face="Courier New">If item &gt;= NumItems
    Then</font></p>
    <p><font size="2" face="Courier New">If TestCost &lt;=
    MAX_COST And TestProfit &gt; _</font></p>
    <p><font size="2" face="Courier New">BestProfit Then</font></p>
    <p><font size="2" face="Courier New">' Save this solution.</font></p>
    <p><font size="2" face="Courier New">For i = 0 To NumItems -
    1</font></p>
    <p><font size="2" face="Courier New">BestUse(i) = TestUse(i)</font></p>
    <p><font size="2" face="Courier New">Next i</font></p>
    <p><font size="2" face="Courier New">BestProfit = TestProfit</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">'
    ***********************************</font></p>
    <p><font size="2" face="Courier New">' Try adding the item to
    the solution.</font></p>
    <p><font size="2" face="Courier New">'
    ***********************************</font></p>
    <p><font size="2" face="Courier New">' Add the item to the
    solution.</font></p>
    <p><font size="2" face="Courier New">TestUse(item) = True</font></p>
    <p><font size="2" face="Courier New">TestCost = TestCost +
    Cost(item)</font></p>
    <p><font size="2" face="Courier New">TestProfit = TestProfit
    + Profit(item)</font></p>
    <p><font size="2" face="Courier New">' Recursively examine
    the possibilities.</font></p>
    <p><font size="2" face="Courier New">Exhaust item + 1</font></p>
    <p><font size="2" face="Courier New">' Remove the item from
    the solution.</font></p>
    <p><font size="2" face="Courier New">TestUse(item) = False</font></p>
    <p><font size="2" face="Courier New">TestCost = TestCost -
    Cost(item)</font></p>
    <p><font size="2" face="Courier New">TestProfit = TestProfit
    - Profit(item)</font></p>
    <p><font size="2" face="Courier New">'
    ****************************************</font></p>
    <p><font size="2" face="Courier New">' Try keeping the item
    out of the solution.</font></p>
    <p><font size="2" face="Courier New">'
    ****************************************</font></p>
    <p><font size="2" face="Courier New">' Recursively examine
    the possibilities.</font></p>
    <p><font size="2" face="Courier New">Exhaust item + 1</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">The EXHAUST program on the Developer&#146;s
    Disk demonstrates this algorithm. Enter the number of items
    you want the program to work with, press the Randomize
    button, and the program will create that number of random
    costs and profits. If you prefer, you can enter specific
    values yourself by typing them into the text boxes.</font></p>
    <p><font size="2">When the values are ready, press the Solve
    button and the program will perform an exhaustive search of
    the decision tree. The program will indicate which items
    belong in the best solution and the best solution&#146;s cost
    and profit. The program will also tell you the elapsed time
    and the number of nodes in the decision tree. Be sure you
    test the program with a small number of items until you know
    how long it will take on your computer.</font></p>
    <p><font size="5"><b>From tiny acorns</b></font></p>
    <p><font size="2">From a tiny acorn grows the mighty oak.
    From only a few questions grows a huge decision tree. For the
    knapsack problem each question is answered by a
    &quot;yes&quot; or &quot;no.&quot; That means each internal
    node in the decision tree has two branches. If there are <i>N</i>
    objects to consider, the tree will be <i>N + 1</i> levels
    tall, so it will contain <i>2</i></font><font size="1"><i>N+1</i></font><font
    size="2"><i> - 1</i> or roughly <i>2</i></font><font size="1"><i>N+1</i></font><font
    size="2"> nodes. This is a <i>lot</i> of nodes. A decision
    tree representing 30 investments would contain more than two
    billion nodes. It will take even a fast computer a long time
    to search such a large tree exhaustively.</font></p>
    <p><font size="2">It takes my 90 MHz Pentium about one second
    to search the tree corresponding to a 15-item problem. It
    takes 33 seconds to search the tree for a 20-item problem.
    It&#146;s no coincidence that this is roughly 32 times
    longer. The tree for a 20-item problem contains five more
    items than the smaller problem so it will contain about <i>2</i></font><font
    size="1"><i>5</i></font><font size="2"><i> = 32</i> times as
    many nodes. Searching all of these nodes should take about 32
    times as long.</font></p>
    <p><font size="2">Because decision trees grow exponentially,
    you can use exhaustive search to solve only the smallest
    problems. Given that my computer takes about one second to
    solve a 15-item knapsack problem, a 40-item problem would
    take 2</font><font size="1">25</font><font size="2"> times as
    long or about a year. A 75-item problem would take more time
    to solve than the current age of the universe.</font></p>
    <p><font size="5"><b>Pruning with a chainsaw</b></font></p>
    <p><font size="2">You can make decision tree searching much
    faster if you can prune some of the branches. For example,
    suppose you had $100 million to spend on any of 40
    investments that each cost between $60 and $90 million. The
    complete decision tree for this problem contains 2</font><font
    size="1">41</font><font size="2"> nodes or a bit more than 2
    trillion nodes. <i>[Imagine Bill Gates&#146;
    dilemma.&#151;Ed.]</i></font></p>
    <p><font size="2">On the other hand, since the investments
    are so expensive, you know that only one at a time will fit
    within the $100 million you have to spend. At the first node
    in the tree, you decide whether the first investment option
    is part of the test solution. If it is, you can stop
    searching since you know you don&#146;t have enough money to
    add another investment to the solution.</font></p>
    <p><font size="2">Similarly, whenever you add any investment
    to the solution, you can stop searching the tree. In this
    example, you really need to follow only 40 different paths
    from the root of the tree to the leaves&#151;one
    corresponding to including each investment in the solution.
    You can skip the other trillion or so possible paths.</font></p>
    <p><font size="2">The branch and bound strategy (see Listing
    2) extends this idea to use upper and lower bounds on the
    test solution to prune the decision tree. When you ask the
    question, &quot;Should this item be part of the test
    solution?&quot; you first check to see if you have enough
    room left in your spending allowance. If the cost of the
    current test solution plus the cost of the new item is
    greater than the allowance, you don&#146;t need to
    recursively consider solutions that contain the item. In the
    previous example where every item is fairly expensive, this
    pruning strategy works well. After you have added one item to
    the test solution, the algorithm will prune every other
    branch from the tree that includes another item.</font></p>
    <p><font size="2">Another test you can use to prune the tree
    is to consider how much profit a branch could possibly bring.
    As you work through the tree, keep a running total of the
    amount of profit possible with items that you haven&#146;t
    considered. If the current profit of the <i>test</i> solution
    plus this total unused profit is no larger than the profit of
    the current <i>best</i> solution, there&#146;s no point in
    considering the test solution further. Even if you added
    every other item to the test solution, it wouldn&#146;t be an
    improvement over the best solution you have found so far.</font></p>
    <p><font size="2">If you use these tests to trim the tree,
    then every time the routine reaches the bottom of the tree it
    has found an improved solution. If the solution isn&#146;t
    better, it will be trimmed in the previous step. At that step
    the profit given by the current test solution plus the
    maximum possible profit remaining must be greater than the
    profit of the current best solution. Otherwise the algorithm
    won&#146;t continueconsidering the solution. Similarly, the
    solution <i>must</i> fit within the spending allowance (our
    constraint), or you&#146;d have trimmed that branch off in
    the previous step. </font></p>
    <p><font size="2">Thus every time you reach the bottom of the
    tree, you&#146;ve found a feasible solution that&#146;s
    better than any you&#146;ve seen before. You can update the
    best solution whenever you reach the bottom of the tree
    without performing any other tests.</font></p>
    <p><font size="2"><b>Listing 2</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b>. </b></font><font
    size="2"><b>Branch and bound.</b></font></p>
    <p><font size="2" face="Courier New">Option Explicit</font></p>
    <p><font size="2" face="Courier New">' Allowed total cost.</font></p>
    <p><font size="2" face="Courier New">Const MAX_COST = 100</font></p>
    <p><font size="2" face="Courier New">' The number of items.</font></p>
    <p><font size="2" face="Courier New">Dim NumItems As Integer</font></p>
    <p><font size="2" face="Courier New">' The cost for item i.</font></p>
    <p><font size="2" face="Courier New">Dim Cost() As Integer</font></p>
    <p><font size="2" face="Courier New">' The profit for item i.</font></p>
    <p><font size="2" face="Courier New">Dim Profit() As Integer</font></p>
    <p><font size="2" face="Courier New">' Total profit of unused
    items.</font></p>
    <p><font size="2" face="Courier New">Dim UnusedProfit As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Items in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestUse() As Integer</font></p>
    <p><font size="2" face="Courier New">' Profit in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestProfit As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Cost in the test
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim TestCost As Integer</font></p>
    <p><font size="2" face="Courier New">' Best profit so far.</font></p>
    <p><font size="2" face="Courier New">Dim BestProfit As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Items in the best
    solution.</font></p>
    <p><font size="2" face="Courier New">Dim BestUse() As Integer</font></p>
    <p><font size="2" face="Courier New">Sub BranchAndBound (item
    As Integer)</font></p>
    <p><font size="2" face="Courier New">Dim i As Integer</font></p>
    <p><font size="2" face="Courier New">Visited = Visited + 1</font></p>
    <p><font size="2" face="Courier New">' If we reached a leaf
    node, we know this</font></p>
    <p><font size="2" face="Courier New">' solution is an
    improvement so save it.</font></p>
    <p><font size="2" face="Courier New">If item &gt;= NumItems
    Then</font></p>
    <p><font size="2" face="Courier New">' Save this solution.</font></p>
    <p><font size="2" face="Courier New">For i = 0 To NumItems -
    1</font></p>
    <p><font size="2" face="Courier New">BestUse(i) = TestUse(i)</font></p>
    <p><font size="2" face="Courier New">Next i</font></p>
    <p><font size="2" face="Courier New">BestProfit = TestProfit</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">'
    ***********************************</font></p>
    <p><font size="2" face="Courier New">' Try adding the item to
    the solution.</font></p>
    <p><font size="2" face="Courier New">'
    ***********************************</font></p>
    <p><font size="2" face="Courier New">If TestCost + Cost(item)
    &lt;= MAX_COST And _</font></p>
    <p><font size="2" face="Courier New">TestProfit +
    UnusedProfit &gt; BestProfit Then</font></p>
    <p><font size="2" face="Courier New">' Add the item to the
    solution.</font></p>
    <p><font size="2" face="Courier New">TestUse(item) = True</font></p>
    <p><font size="2" face="Courier New">TestCost = TestCost +
    Cost(item)</font></p>
    <p><font size="2" face="Courier New">TestProfit = TestProfit
    + Profit(item)</font></p>
    <p><font size="2" face="Courier New">UnusedProfit =
    UnusedProfit - Profit(item)</font></p>
    <p><font size="2" face="Courier New">' Recursively examine
    the possibilities.</font></p>
    <p><font size="2" face="Courier New">BranchAndBound item + 1</font></p>
    <p><font size="2" face="Courier New">' Remove the item from
    the solution.</font></p>
    <p><font size="2" face="Courier New">TestUse(item) = False</font></p>
    <p><font size="2" face="Courier New">TestCost = TestCost -
    Cost(item)</font></p>
    <p><font size="2" face="Courier New">TestProfit = TestProfit
    - Profit(item)</font></p>
    <p><font size="2" face="Courier New">UnusedProfit =
    UnusedProfit + Profit(item)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">'
    ****************************************</font></p>
    <p><font size="2" face="Courier New">' Try keeping the item
    out of the solution.</font></p>
    <p><font size="2" face="Courier New">'
    ****************************************</font></p>
    <p><font size="2" face="Courier New">' Recursively examine
    the possibilities.</font></p>
    <p><font size="2" face="Courier New">If TestProfit +
    UnusedProfit - Profit(item) _</font></p>
    <p><font size="2" face="Courier New">&gt; BestProfit Then</font></p>
    <p><font size="2" face="Courier New">UnusedProfit =
    UnusedProfit - Profit(item)</font></p>
    <p><font size="2" face="Courier New">BranchAndBound item + 1</font></p>
    <p><font size="2" face="Courier New">UnusedProfit =
    UnusedProfit + Profit(item)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">Program BRANCH on the Developer&#146;s Disk
    uses both exhaustive search and branch and bound to solve the
    knapsack problem. Before you randomly create data, you can
    fill in the minimum and maximum values you want to allow for
    the costs and profits. If the items have large costs, branch
    and bound will be able to prune much of the tree and the
    program will examine a relatively small number of nodes. If
    the items have small costs, many items will be able to fit
    within a feasible solution, so the program will need to
    consider many more nodes and it will take longer. Try
    creating 20 random items with costs between 9 and 11. Since
    the items&#146; costs are similar and since many items will
    fit within the $100 million spending allowance, the program
    will need to consider many possible investment combinations.</font></p>
    <p><font size="2">Once the program has found a solution, it
    displays the items it selected, the cost and profit of the
    solution, and the time the program used. It also displays the
    number of nodes in the complete decision tree as well as the
    number of nodes it actually visited. You&#146;ll notice that
    branch and bound generally visits far fewer nodes than
    exhaustive search. For a 20-item knapsack problem, branch and
    bound might examine a few thousand or even just a few hundred
    nodes depending on the items&#146; costs and profits. An
    exhaustive search would examine all of the decision
    tree&#146;s two million-plus nodes&#151;unless you powered
    down or rebooted in frustration, that is.</font></p>
    <p><font size="5"><b>Close is better than nothing</b></font></p>
    <p><font size="2">If you add enough nodes to a decision tree,
    you can easily make a tree so large that even branch and
    bound won&#146;t be able to search it. For medium-sized
    problems, you could just let the program run for a month or
    two until it found a solution. Unfortunately, you
    wouldn&#146;t be able to use your computer for more important
    things like Solitaire and CompuServe&#146;s chat rooms. For
    really large problems, you may as well not even bother
    trying.</font></p>
    <p><font size="2">To solve these really big problems, you can
    turn to a <i>heuristic</i> (pronounced yoo-RIS-tik). A
    heuristic is an algorithm that will probably give a pretty
    good solution, but isn&#146;t guaranteed to find the
    absolutely best solution possible. System expert Dave Prerau
    uses as a heuristic for not getting speeding tickets: if you
    drive between 5 and 10 miles per hour above the speed limit,
    you probably won&#146;t get a ticket, but there&#146;s
    obviously no guarantee. <i>[Notice how circumspect Rod is on
    this issue, quoting an &quot;expert&quot; rather than
    offering his own heuristic for avoiding speeding
    tickets.&#151;Ed.]</i></font></p>
    <p><font size="2">For any given problem, you can come up with
    lots of different heuristics. Some will work better than
    others depending on the circumstances. One common type of
    heuristic is called a <i>hill climbing</i> algorithm (see
    Listing 3). At each step, a hill climbing heuristic attempts
    to move the solution as far as possible towards the goal of
    the problem. This kind of algorithm is called &quot;hill
    climbing&quot; because it&#146;s similar to a lost hiker
    trying to find the top of a mountain in a fog or in the dark.
    While the hiker can&#146;t see where the top of the mountain
    is, he can try to get there by always moving uphill. Of
    course, a hiker in the dark may get stuck on the top of a
    small hill and not reach the highest point on the mountain.
    Hill climbing heuristics suffer from this same problem. The
    algorithm can get stuck at a <i>local maximum </i>and be
    unable to find the <i>global maximum</i>.</font></p>
    <p><font size="2">In the knapsack problem, the goal is to
    find the largest profit possible. At each step, a hill
    climbing algorithm would add to the test solution the
    investment that provided the largest possible profit while
    fitting within the $100 million spending allowance. That
    moves the solution closer to the goal of finding a large
    profit.</font></p>
    <p><font size="2">If you begin by sorting the investments
    according to their profits, you can just run through the
    sorted list in order adding the next item that fits within
    the allowance. Even if you don&#146;t sort the list, you can
    search through the entire list each time you need to find the
    next item very quickly. If there are <i>N</i> investments,
    you may need to examine the list up to <i>N</i> times. At
    most you&#146;ll examine <i>N * N = N</i></font><font
    size="1"><i>2</i></font><font size="2"> items. This is far
    fewer operations than the <i>2</i></font><font size="1"><i>N+1</i></font><font
    size="2"> required by an exhaustive search. For <i>N = 40,</i>
    hill climbing would require at most 1,600 operations while
    exhaustive search would examine all two trillion nodes in the
    decision tree.</font></p>
    <p><font size="2"><b>Listing 3</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b>. </b></font><font
    size="2"><b>Hill climbing.</b></font></p>
    <p><font size="2" face="Courier New">Sub HillClimbing ()</font></p>
    <p><font size="2" face="Courier New">Dim unspent As Integer</font></p>
    <p><font size="2" face="Courier New">Dim best_i As Integer</font></p>
    <p><font size="2" face="Courier New">Dim best_profit As
    Integer</font></p>
    <p><font size="2" face="Courier New">Dim i As Integer</font></p>
    <p><font size="2" face="Courier New">unspent = MAX_COST</font></p>
    <p><font size="2" face="Courier New">Do</font></p>
    <p><font size="2" face="Courier New">' Find the next item
    with the largest profit</font></p>
    <p><font size="2" face="Courier New">' that will fit within
    the solution.</font></p>
    <p><font size="2" face="Courier New">best_profit = -1</font></p>
    <p><font size="2" face="Courier New">best_i = -1</font></p>
    <p><font size="2" face="Courier New">For i = 0 To NumItems -
    1</font></p>
    <p><font size="2" face="Courier New">If Not BestUse(i) And
    Cost(i) &lt;= _</font></p>
    <p><font size="2" face="Courier New">unspent And Profit(i)
    &gt; best_profit _</font></p>
    <p><font size="2" face="Courier New">Then</font></p>
    <p><font size="2" face="Courier New">best_i = i</font></p>
    <p><font size="2" face="Courier New">best_profit = Profit(i)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">Next i</font></p>
    <p><font size="2" face="Courier New">' If no more items will
    fit, we're done.</font></p>
    <p><font size="2" face="Courier New">If best_i &lt; 0 Then
    Exit Do</font></p>
    <p><font size="2" face="Courier New">' Add the item to the
    solution.</font></p>
    <p><font size="2" face="Courier New">BestUse(best_i) = True</font></p>
    <p><font size="2" face="Courier New">BestProfit = BestProfit
    + best_profit</font></p>
    <p><font size="2" face="Courier New">unspent = unspent -
    Cost(best_i)</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="5"><b>Least cost</b></font></p>
    <p><font size="2">Another common heuristic strategy is the <i>least
    cost </i>approach (see Listing 4). At each step instead of
    adding the item that moves the solution as close to the goal
    as possible, this strategy adds the item that has the
    smallest cost. This allows the algorithm to fit as many items
    as possible into the solution. If the items&#146; profits are
    roughly equal, the least cost strategy will produce a good
    solution.</font></p>
    <p><font size="2">The structure of a least cost heuristic is
    similar to that of a hill climbing algorithm. You can get the
    best performance by initially sorting the items according to
    their costs and then adding them in order until no more items
    will fit. Even if you search the entire list each time you
    need to pick an item, the least cost heuristic requires at
    most <i>N</i></font><font size="1"><i>2</i></font><font
    size="2"> steps rather than the <i>2</i></font><font size="1"><i>N+1</i></font><font
    size="2"> required by an exhaustive search. </font></p>
    <p><font size="2"><b>Listing 4. Least cost.</b></font></p>
    <p><font size="2" face="Courier New">Sub LeastCost ()</font></p>
    <p><font size="2" face="Courier New">Dim unspent As Integer</font></p>
    <p><font size="2" face="Courier New">Dim best_i As Integer</font></p>
    <p><font size="2" face="Courier New">Dim best_cost As Integer</font></p>
    <p><font size="2" face="Courier New">Dim i As Integer</font></p>
    <p><font size="2" face="Courier New">unspent = MAX_COST</font></p>
    <p><font size="2" face="Courier New">Do</font></p>
    <p><font size="2" face="Courier New">' Find the next item
    with the smallest</font></p>
    <p><font size="2" face="Courier New">' cost that will fit
    within the solution.</font></p>
    <p><font size="2" face="Courier New">best_cost = 32767</font></p>
    <p><font size="2" face="Courier New">best_i = -1</font></p>
    <p><font size="2" face="Courier New">For i = 0 To NumItems -
    1</font></p>
    <p><font size="2" face="Courier New">If Not BestUse(i) And
    Cost(i) &lt;= unspent _</font></p>
    <p><font size="2" face="Courier New">And Cost(i) &lt;
    best_cost Then</font></p>
    <p><font size="2" face="Courier New">best_i = i</font></p>
    <p><font size="2" face="Courier New">best_cost = Cost(i)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">Next i</font></p>
    <p><font size="2" face="Courier New">' If no more items will
    fit, we're done.</font></p>
    <p><font size="2" face="Courier New">If best_i &lt; 0 Then
    Exit Do</font></p>
    <p><font size="2" face="Courier New">' Add the item to the
    solution.</font></p>
    <p><font size="2" face="Courier New">BestUse(best_i) = True</font></p>
    <p><font size="2" face="Courier New">BestProfit = BestProfit
    + Profit(best_i)</font></p>
    <p><font size="2" face="Courier New">unspent = unspent -
    Cost(best_i)</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="5"><b>It&#146;s a jungle out there</b></font></p>
    <p><font size="2">Program HEUR on the Developer&#146;s Disk
    demonstrates exhaustive search, branch and bound, hill
    climbing, and the least cost heuristic. Be careful not to use
    exhaustive search on large problems. Try the program with
    several different ranges for costs and profits. You&#146;ll
    find that a least cost strategy works well when the range of
    profits is small. Hill climbing generally works well when the
    range of costs is small.</font></p>
    <p><font size="2">For any given problem, you can come up with
    many other heuristics. You might try a greatest cost strategy
    to try using up all of the spending allowance. You could pick
    random items to add to the solution until no more will fit.
    Since different trials using a random solution will give
    different results, you might examine several hundred or even
    several thousand random solutions.</font></p>
    <p><font size="2">For different data sets, different
    heuristics will be the best. Since these algorithms tend to
    be extremely fast, you should run as many as possible and
    pick the solution that is the overall winner. While you may
    not get the best result possible, you should get a solution
    that is &quot;good enough&quot; to be useful. Happy
    heuristics! </font></p>
    <p><font size="2"><i>Rod Stephens is president of Rocky
    Mountain Computer Consulting Inc., a custom software firm in
    Boulder, Colorado. His book </i></font><font size="2"
    face="MyriaMMIt_400 RG 600 NO"><i>Visual Basic Algorithms</i></font><font
    size="2"><i> describes dozens of algorithms like these. He is
    currently working on a book about graphics in VB. CompuServe
    102124,33.</i></font></p>
    <p>&nbsp;</p>
    <P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vbd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    September 1996 issue of Visual Basic Developer. Copyright
    1996, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual Basic Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
    <p>&nbsp;</p>
</blockquote>
</font></body>
</html>
