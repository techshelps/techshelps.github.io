<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="D:\CDs\templates\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Missing Link (June)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>The Missing Link</b></font></p>
    <p><font size="2">Rod Stephens</font></p>
    <p><font size="2"><i>Linked lists are standard fare in
    languages like C, C++, and Pascal. This month Rod shows how
    you can add linked lists to your VB programs, too.</i></font></p>
    <p><font size="2">IN my &quot;Tree Trimming,&quot; article in
    the August 1995 issue of <i>Visual Basic Developer</i> I
    showed you how to use dynamic data structures to build trees.
    You start by defining the tree&#146;s node structure using a
    VB Type statement and then allocate an array of these nodes.
    Some of the fields in the node structures are <i>pointers</i>
    that give the indexes of other nodes in the array.</font></p>
    <p><font size="2">A <i>linked list</i> is another dynamic
    data structure that uses pointers. By using a linked list,
    you can add and remove items from a list more easily than you
    can if you store the items in an array.</font></p>
    <p><font size="2">In this article I&#146;ll explain how to
    use linked lists in your VB programs, and how to use <i>threads
    </i>to present the items in a linked list in more than one
    order. I&#146;ll also describe an algorithm for compressing
    the items in a linked list to free unused memory if the list
    shrinks in size.</font></p>
    <p><font size="2">You start by using a Type<b> </b>statement
    to define a data structure to hold the items&#151;called <i>cells&#151;</i>in
    your linked list. A cell contains a pointer field, usually
    named Next, that links it to the next cell in the list. Cells
    also contain whatever other data you want to store in your
    list. If the list holds employee information, for instance,
    the other fields might be name, address, Social Security
    number, and so on:</font></p>
    <p><font size="2" face="Courier New">Type EmpCell</font></p>
    <p><font size="2" face="Courier New">EmpName As String</font></p>
    <p><font size="2" face="Courier New">Next As Integer</font></p>
    <p><font size="2" face="Courier New">End Type</font></p>
    <p><font size="2">You then create an array of these cells.
    The Next fields in each cell are indexes to this array:</font></p>
    <p><font size="2" face="Courier New">Dim TheCells(1 To 100)
    As EmpCell</font></p>
    <p><font size="2">Now you build a linked list using the
    cells&#146; Next fields to connect the cells in the array.
    For example, to make cell number 3 come after cell number 1
    in the linked list, you would set the Next pointer for cell
    number 1 to the value 3, like this:</font></p>
    <p><font size="2" face="Courier New">TheCells(1).Next = 3</font></p>
    <p><font size="2">Figure 1 shows a cell array holding a small
    linked list. Arrows show the cell to which each Next field
    points. The integer variable Top holds the index of the first
    cell in the linked list. In this case, the list begins with
    cell number 2.</font></p>
</blockquote>

<p><font size="2" face="Palatino,Book Antiqua"><img
src="Image11.gif" width="575" height="218"></font></p>

<blockquote>
    <p><font size="2"><b>Figure 1. An array holding a small
    linked list.</b></font></p>
    <p><font size="2">The Next pointer for cell 4 holds the
    special value, -32,768, which tells you that you&#146;ve
    reached the end of the list. To make your VB code a little
    clearer, you can define a constant END_OF_LIST to have this
    value.</font></p>
    <p><font size="2">The code shown in Listing 1 prints the
    names of the employees in a list like the one shown in Figure
    1. The integer variable ptr is initialized to the value Top,
    so it points to the beginning of the list. The code then uses
    a Do loop to move ptr through the list printing each
    employee&#146;s name in turn. After printing each name, the
    program advances ptr so it points to the next cell in the
    linked list using the Next pointer. Eventually, the value of
    ptr is set to END_OF_LIST and the Do loop terminates. The
    code would list the employees in Figure 1 in the order Smith,
    Jones, Baker, Johnson.</font></p>
    <p><font size="2"><b>Listing 1. Code to display the contents
    of a linked list.</b></font></p>
    <p><font size="2" face="Courier New">' Data structure to hold
    cell data.</font></p>
    <p><font size="2" face="Courier New">Type EmpCell</font></p>
    <p><font size="2" face="Courier New">EmpName As String ' Data
    used by the program.</font></p>
    <p><font size="2" face="Courier New">Next As Integer ' Next
    pointer.</font></p>
    <p><font size="2" face="Courier New">End Type</font></p>
    <p><font size="2" face="Courier New">' Array of cells used to
    build the list.</font></p>
    <p><font size="2" face="Courier New">Dim TheCells(1 To 10) As
    EmpCell</font></p>
    <p><font size="2" face="Courier New">' Pointer to indicate
    end of list.</font></p>
    <p><font size="2" face="Courier New">Const END_OF_LIST =
    -32768</font></p>
    <p><font size="2" face="Courier New">' Holds the top of the
    list.</font></p>
    <p><font size="2" face="Courier New">Dim Top As Integer</font></p>
    <p><font size="2" face="Courier New">' Print all the EmpName
    fields for </font></p>
    <p><font size="2" face="Courier New">'the cells in the list.</font></p>
    <p><font size="2" face="Courier New">Sub PrintNames ()</font></p>
    <p><font size="2" face="Courier New">Dim ptr As Integer</font></p>
    <p><font size="2" face="Courier New">ptr = Top ' Start at the
    top of the list.</font></p>
    <p><font size="2" face="Courier New">Do While ptr &lt;&gt;
    END_OF_LIST</font></p>
    <p><font size="2" face="Courier New">' Display this cell's
    EmpName field.</font></p>
    <p><font size="2" face="Courier New">Print
    TheCells(ptr).EmpName</font></p>
    <p><font size="2" face="Courier New">' Advance to the next
    cell in the list.</font></p>
    <p><font size="2" face="Courier New">ptr = TheCells(ptr).Next</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">When you work with a linked list, you
    generally don&#146;t care where in the cell array the list
    items are stored&#151;only the order of the items in the
    linked list matters. To make the structure of the list
    clearer, it&#146;s usually better to draw the cells in the
    order that is natural for the list. Figure 2 shows the list
    from Figure 1 drawn in its natural order. Arrows indicate the
    Next pointers and a box with an X in it represents the
    END_OF_LIST value.</font></p>
    <p>&nbsp;</p>
</blockquote>

<p><img src="VB696F2.gif" width="1245" height="150"></p>

<blockquote>
    <p><font size="2"><b>Figure 2. The &quot;natural&quot; order
    for a linked list.</b></font></p>
    <p><font size="2">It&#146;s much easier to add or remove
    items from a linked list than it is to add or remove them
    from a normal VB array. To add a new item at the top of a
    linked list, for example, you make the new cell&#146;s Next
    field point to the current value of Top and then set Top to
    point to the new cell.</font></p>
    <p><font size="2">It&#146;s also easy to add an item to the
    middle of a linked list or to remove an item from the top or
    middle of a linked list. These four operations are shown
    graphically in Figure 3; their VB source code is given in
    Listing 2.</font></p>
</blockquote>

<p><font size="2" face="Palatino,Book Antiqua"><img
src="Image12.gif" width="566" height="527"></font></p>

<blockquote>
    <p><font size="2"><b>Figure 3.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>Adding and removing items from a linked list.</b></font></p>
    <p><font size="2"><b>Listing 2. VB code to add or remove
    items from a linked list.</b></font></p>
    <p><font size="2" face="Courier New">' Add an item at the top
    of the list.</font></p>
    <p><font size="2" face="Courier New">Sub AddToTop (new_cell
    As Integer)</font></p>
    <p><font size="2" face="Courier New">TheCells(new_cell).Next
    = Top</font></p>
    <p><font size="2" face="Courier New">Top = new_cell</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2" face="Courier New">' Add an item after
    another item.</font></p>
    <p><font size="2" face="Courier New">Sub AddAfter (new_cell
    As Integer, _</font></p>
    <p><font size="2" face="Courier New">after_me As Integer)</font></p>
    <p><font size="2" face="Courier New">TheCells(new_cell).Next
    = _</font></p>
    <p><font size="2" face="Courier New">TheCells(after_me).Next</font></p>
    <p><font size="2" face="Courier New">TheCells(after_me).Next
    = new_cell</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2" face="Courier New">' Remove the top item
    from the list.</font></p>
    <p><font size="2" face="Courier New">Sub RemoveTop ()</font></p>
    <p><font size="2" face="Courier New">Top = TheCells(Top).Next</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2" face="Courier New">' Remove the item after
    another item.</font></p>
    <p><font size="2" face="Courier New">Sub RemoveAfter
    (after_me As Integer)</font></p>
    <p><font size="2" face="Courier New">Dim remove_me As Integer</font></p>
    <p><font size="2" face="Courier New">remove_me =
    TheCells(after_me).Next</font></p>
    <p><font size="2" face="Courier New">TheCells(after_me).Next
    = _</font></p>
    <p><font size="2" face="Courier New">TheCells(remove_me).Next</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">Compare these routines to the code you
    would need to add or remove an item from an array-based list.
    To add an item to the top of a list stored in an array, for
    example, you would need to move every item in the list over
    one position to make room for the new item. Using a linked
    list, you can add the new item in only two steps.</font></p>
    <p><font size="5"><b>A recycling program</b></font></p>
    <p><font size="2">To make list management more flexible, you
    can use a variable to keep track of the number of cells in
    the cell array. When you run out of unused cells, you resize
    the array to make more. You reduce the number of times you
    need to resize the array if you place unused cells in a
    &quot;garbage linked list.&quot; When you remove a cell from
    your linked list, you place it in the garbage list and, when
    you need a new cell, you recycle one from the garbage list
    (if it isn&#146;t empty, of course).</font></p>
    <p><font size="2">To make this easier you can write two
    routines NewCell and FreeCell to manage the garbage list.
    NewCell first checks to see if the garbage list is empty. If
    it is, the function redimensions the cell array and adds all
    of the new cells to the garbage list. It then returns the
    index of the first cell in the garbage list. If you pass the
    values for the EmpName and Next fields into the NewCell
    function, it also initializes the fields in the new cell for
    you. Subroutine FreeCell adds an unused cell to the garbage
    list. The VB code for function NewCell and subroutine
    FreeCell is shown in Listing 3.</font></p>
    <p><font size="2"><b>Listing 3</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b>.</b></font><font
    size="2"><b> VB code for NewCell and FreeCell.</b></font></p>
    <p><font size="2" face="Courier New">Dim TopGarbage As
    Integer</font></p>
    <p><font size="2" face="Courier New">Dim NumCells As Integer</font></p>
    <p><font size="2" face="Courier New">Dim TheCells() As
    EmpCell</font></p>
    <p><font size="2" face="Courier New">&lt;etc.&gt;</font></p>
    <p><font size="2" face="Courier New">Function NewCell
    (emp_name As String, _</font></p>
    <p><font size="2" face="Courier New">next_cell As Integer) As
    Integer</font></p>
    <p><font size="2" face="Courier New">Dim i As Integer</font></p>
    <p><font size="2" face="Courier New">' If the garbage list is
    empty, resize the cell</font></p>
    <p><font size="2" face="Courier New">' array and add the new
    cells to the garbage list.</font></p>
    <p><font size="2" face="Courier New">If TopGarbage =
    END_OF_LIST Then</font></p>
    <p><font size="2" face="Courier New">ReDim Preserve
    TheCells(1 To NumCells + 10)</font></p>
    <p><font size="2" face="Courier New">For i = NumCells + 1 To
    NumCells + 9</font></p>
    <p><font size="2" face="Courier New">TheCells(i).Next = i + 1</font></p>
    <p><font size="2" face="Courier New">Next i</font></p>
    <p><font size="2" face="Courier New">TheCells(NumCells +
    10).Next = END_OF_LIST</font></p>
    <p><font size="2" face="Courier New">TopGarbage = NumCells +
    1</font></p>
    <p><font size="2" face="Courier New">NumCells = NumCells + 10</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">' Allocate and
    initialize the new cell.</font></p>
    <p><font size="2" face="Courier New">NewCell = TopGarbage</font></p>
    <p><font size="2" face="Courier New">TheCells(TopGarbage).EmpName
    = emp_name</font></p>
    <p><font size="2" face="Courier New">TheCells(TopGarbage).Next
    = next_ptr</font></p>
    <p><font size="2" face="Courier New">TopGarbage =
    TheCells(TopGarbage).Next</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2" face="Courier New">Sub FreeCell (cell As
    Integer)</font></p>
    <p><font size="2" face="Courier New">TheCells(cell).Next =
    TopGarbage</font></p>
    <p><font size="2" face="Courier New">TopGarbage = cell</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">It&#146;s easy to manage linked lists by
    using these routines. To build the list described earlier
    containing the names Smith, Jones, Baker, Johnson, you could
    use code like this:</font></p>
    <p><font size="2" face="Courier New">' Initialize the garbage
    list so it is empty.</font></p>
    <p><font size="2" face="Courier New">TopGarbage = END_OF_LIST</font></p>
    <p>&nbsp;</p>
    <p><font size="2" face="Courier New">' Create the list from
    back to front.</font></p>
    <p><font size="2" face="Courier New">Top =
    NewCell(&quot;Johnson&quot;, END_OF_LIST)</font></p>
    <p><font size="2" face="Courier New">Top =
    NewCell(&quot;Baker&quot;, Top)</font></p>
    <p><font size="2" face="Courier New">Top =
    NewCell(&quot;Jones&quot;, Top)</font></p>
    <p><font size="2" face="Courier New">Top =
    NewCell(&quot;Smith&quot;, Top)</font></p>
    <p><font size="2">To remove the second entry,
    &quot;Jones,&quot; from the linked list, you could use this
    code:</font></p>
    <p><font size="2" face="Courier New">remove_me =
    TheCells(Top).Next</font></p>
    <p><font size="2" face="Courier New">RemoveAfter(Top)</font></p>
    <p><font size="2" face="Courier New">FreeCell(remove_me)</font></p>
    <p><font size="2">You could make this easier still by
    modifying the RemoveTop and RemoveAfter routines so they
    added the removed item to the top of the garbage list.</font></p>
    <p><font size="5"><b>Ordered linked lists</b></font></p>
    <p><font size="2">With only a little extra work, you can
    manage a linked list that keeps its cells in sorted order.
    When you add an item to the list, you search through the list
    until you find the spot where the new item belongs and then
    place the item at that position.</font></p>
    <p><font size="2">This a bit easier if you give the list two <i>sentinels</i>.
    The sentinels bound all of the values that the real items in
    the list might have&#151;all of the real data items must fall
    between the top and bottom sentinels. For employee names, you
    might let the top sentinel have the value &quot;&quot; (an
    empty string), because any real data must have a value
    greater than the empty string. The bottom sentinel might have
    the value &quot;~,&quot; which comes alphabetically after all
    letters a&#150;z and A&#150;Z. Figure 4 shows an ordered
    linked list containing the items Baker, Johnson, Jones,
    Smith.</font></p>
</blockquote>

<p><img src="VB696F4.gif" width="1770" height="296"></p>

<blockquote>
    <p><font size="2"><b>Figure 4.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>A linked list with sentinels.</b></font></p>
    <p><font size="2">To insert an item into a linked list with
    sentinels, start at the top sentinel and search for an item
    that belongs after the new item. Because the bottom sentinel
    holds a value that comes after all valid data values, you
    know that you&#146;ll eventually find such an item. Once you
    find this item, insert the new item before it. Similarly, to
    remove an item from the list, start at the top sentinel and
    search for an item with value greater than or equal to the
    target item. Once you find the target item, remove it from
    the list. </font><font color="#008080" size="2"
    face="MyriaMM_565 SB 600 NO">Listing 4</font><font size="2">
    shows the VB code for adding and removing items from an
    ordered linked list.</font></p>
    <p><font size="2"><b>Listing 4.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>Routines to add and remove items from an ordered
    linked list.</b></font></p>
    <p><font size="2" face="Courier New">Sub InsertItem (emp_name
    As String)</font></p>
    <p><font size="2" face="Courier New">Dim cell As Integer</font></p>
    <p><font size="2" face="Courier New">Dim ptr As Integer</font></p>
    <p><font size="2" face="Courier New">Dim nxt As Integer ' The
    item after ptr.</font></p>
    <p><font size="2" face="Courier New">' Start at the top
    sentinel.</font></p>
    <p><font size="2" face="Courier New">ptr = Top</font></p>
    <p><font size="2" face="Courier New">nxt = TheCells(ptr).Next</font></p>
    <p><font size="2" face="Courier New">Do While
    TheCells(nxt).EmpName &lt; emp_name</font></p>
    <p><font size="2" face="Courier New">ptr = nxt</font></p>
    <p><font size="2" face="Courier New">nxt = TheCells(ptr).Next</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">' Add the new cell
    between ptr and nxt.</font></p>
    <p><font size="2" face="Courier New">cell = NewCell(emp_name,
    nxt)</font></p>
    <p><font size="2" face="Courier New">TheCells(ptr).Next =
    cell</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2" face="Courier New">Sub DeleteItem (emp_name
    As String)</font></p>
    <p><font size="2" face="Courier New">Dim cell As Integer</font></p>
    <p><font size="2" face="Courier New">Dim ptr As Integer</font></p>
    <p><font size="2" face="Courier New">Dim nxt As Integer ' The
    item after ptr.</font></p>
    <p><font size="2" face="Courier New">' Start at the top
    sentinel.</font></p>
    <p><font size="2" face="Courier New">ptr = Top</font></p>
    <p><font size="2" face="Courier New">nxt = TheCells(ptr).Next</font></p>
    <p><font size="2" face="Courier New">Do While
    TheCells(nxt).EmpName &lt; emp_name</font></p>
    <p><font size="2" face="Courier New">ptr = nxt</font></p>
    <p><font size="2" face="Courier New">nxt = TheCells(ptr).Next</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">' If this is not the
    item, it is not in the list.</font></p>
    <p><font size="2" face="Courier New">If TheCells(nxt).EmpName
    &lt;&gt; emp_name Then</font></p>
    <p><font size="2" face="Courier New">Beep</font></p>
    <p><font size="2" face="Courier New">MsgBox &quot;Item &quot;
    &amp; emp_name &amp; &quot; is not _</font></p>
    <p><font size="2" face="Courier New">in the list.&quot;</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">' Remove the item.</font></p>
    <p><font size="2" face="Courier New">TheCells(ptr).Next =
    TheCells(nxt).Next</font></p>
    <p><font size="2" face="Courier New">FreeCell nxt</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="5"><b>Threads</b></font></p>
    <p><font size="2">Once you know how to build a sorted linked
    list, it&#146;s a small step to make a list that is sorted in
    more than one order: Merely give your cell structure a
    separate pointer to point to the next cell in each of the
    orderings. To list employees ordered by their names or Social
    Security numbers, for example, you might define the cell
    structure like this:</font></p>
    <p><font size="2" face="Courier New">Type EmpCell</font></p>
    <p><font size="2" face="Courier New">EmpName As String '
    Name.</font></p>
    <p><font size="2" face="Courier New">SSN As String ' Social
    Security number.</font></p>
    <p><font size="2" face="Courier New">NextName As Integer '
    Next cell in Name order.</font></p>
    <p><font size="2" face="Courier New">NextSSN As Integer '
    Next cell in Social </font></p>
    <p><font size="2" face="Courier New">' Security number order.</font></p>
    <p><font size="2" face="Courier New">End Type</font></p>
    <p><font size="2">The pointers that make up one of the
    orderings form a <i>thread</i> through the list. When you add
    a new cell to the list, be sure to update the pointers in all
    of the threads.</font></p>
    <p><font size="2">The Threads program on the Developer&#146;s
    Disk lets you experiment with a threaded linked list. You can
    enter a name and Social Security Number and press the Add
    button to add an employee to the list. You use the Name and
    SSN option buttons to tell the program which thread to use
    when displaying the list.</font></p>
    <p><font size="5"><b>Take out the trash</b></font></p>
    <p><font size="2">If the garbage list is empty, the NewCell
    function expands the cell array to make more cells when they
    are needed. When the garbage list becomes large, however, the
    FreeCell subroutine doesn&#146;t shrink the array to free
    unused entries. If you add many items to the linked list and
    then remove most of them, the garbage list might hold a lot
    of memory that you don&#146;t really need anymore. To free
    some of the unused garbage entries, you could create a new
    cell array, copy the list items into the new array in list
    order, resize the original cell array, and copy the items
    back. There is a much better method.</font></p>
    <p><font size="2">Suppose there are NumUsed items in use in
    the linked list. If you rearrange the list properly, you
    should be able to fit the list within the first NumUsed
    entries of the cell array. Start looking through the linked
    list until you find a cell that doesn&#146;t lie within the
    first NumUsed entries of the cell array. Next, look through
    the garbage list until you find a cell that is within the
    first NumUsed array entries. For every item in the list that
    is outside this range, there must be a garbage item inside
    the range&#151;you&#146;ll find one eventually. Now move the
    list entry into the garbage cell you found. Be sure to update
    all of the pointers correctly. Continue through the linked
    list until you&#146;ve moved every item into the first
    NumUsed entries. When you&#146;ve done so, you can resize the
    cell array and create a new garbage list containing the items
    at the end of the array. </font><font color="#008080"
    size="2" face="MyriaMM_565 SB 600 NO">Listing 5</font><font
    size="2"> shows a garbage collection routine that performs
    these tasks.</font></p>
    <p><font size="2"><b>Listing 5.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>A garbage collection routine.</b></font></p>
    <p><font size="2" face="Courier New">Sub CollectGarbage ()</font></p>
    <p><font size="2" face="Courier New">Dim cell As Integer</font></p>
    <p><font size="2" face="Courier New">Dim nxt As Integer</font></p>
    <p><font size="2" face="Courier New">Dim new_cell As Integer</font></p>
    <p><font size="2" face="Courier New">Dim num_used As Integer</font></p>
    <p><font size="2" face="Courier New">num_used = NumCells -
    NumGarbage</font></p>
    <p><font size="2" face="Courier New">' Compact the cells that
    are in use</font></p>
    <p><font size="2" face="Courier New">cell = Top ' The top
    sentinel</font></p>
    <p><font size="2" face="Courier New">' The cell after
    &quot;cell&quot;</font></p>
    <p><font size="2" face="Courier New">nxt =
    TheCells(cell).next</font></p>
    <p><font size="2" face="Courier New">Do While nxt &lt;&gt;
    END_OF_LIST</font></p>
    <p><font size="2" face="Courier New">' This cell needs to be
    moved</font></p>
    <p><font size="2" face="Courier New">If nxt &gt; num_used
    Then</font></p>
    <p><font size="2" face="Courier New">' Find an unused cell
    from the garbage list</font></p>
    <p><font size="2" face="Courier New">' that is in the first
    part of the array.</font></p>
    <p><font size="2" face="Courier New">Do While TopGarbage &gt;
    num_used</font></p>
    <p><font size="2" face="Courier New">TopGarbage =
    TheCells(TopGarbage).next</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">new_cell = TopGarbage</font></p>
    <p><font size="2" face="Courier New">TopGarbage =
    TheCells(TopGarbage).next</font></p>
    <p><font size="2" face="Courier New">' Move the cell's data</font></p>
    <p><font size="2" face="Courier New">TheCells(cell).next =
    new_cell</font></p>
    <p><font size="2" face="Courier New">TheCells(new_cell) =
    TheCells(nxt)</font></p>
    <p><font size="2" face="Courier New">nxt = new_cell</font></p>
    <p><font size="2" face="Courier New">End If ' End moving the
    cell</font></p>
    <p><font size="2" face="Courier New">' Go on to consider the
    next used item</font></p>
    <p><font size="2" face="Courier New">cell = nxt</font></p>
    <p><font size="2" face="Courier New">nxt =
    TheCells(cell).next</font></p>
    <p><font size="2" face="Courier New">Loop</font></p>
    <p><font size="2" face="Courier New">' Resize the array.</font></p>
    <p><font size="2" face="Courier New">NumCells = num_used</font></p>
    <p><font size="2" face="Courier New">ResizeArray</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">The Garbage program on the Developer&#146;s
    Disk manages a linked list with garbage collection. As it
    runs, the program displays the number of items in the garbage
    list and the maximum number of items the garbage list can
    hold before the list must be resized. If you add a bunch of
    items to the list and then delete them, the program runs the
    garbage collection routine.</font></p>
    <p><font size="2">When the cell array must be enlarged, the
    Garbage program adds only five items to it; the maximum
    number of entries the program allows in the garbage list is
    10. I chose these numbers make it easy for you to test the
    garbage collector. In a real application you&#146;d probably
    want to make these values larger so the array would be
    resized less often.</font></p>
    <p><font size="2"><i>Rod Stephens is president of Rocky
    Mountain Computer Consulting Inc., a custom software firm in
    Boulder, Colorado. He has been building applications for more
    than 12 years and is the author of </i></font><font size="2"
    face="MyriaMMIt_400 RG 600 NO"><i>Visual Basic Algorithms</i></font><font
    size="2"><i> (John Wiley &amp; Sons). CompuServe 102124,33.</i></font></p>
    <p>&nbsp;</p>
    <P align="center"><a
    href="http://www.pinppub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong><a
    href="http://www.pinpub.com/level3/l3nsmacc.htm"> </a><a
    href="http://www.pinppub.com/vbd/"><strong>http://www.pinppub.com/vbd/
    </strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the June
    1996 issue of Visual Basic Developer Copyright 1996, by
    Pinnacle Publishing, Inc., unless otherwise noted. All rights
    are reserved. Visual Basic Developer is an independently
    produced publication of Pinnacle Publishing, Inc. No part of
    this article may be used or reproduced in any fashion (except
    in brief quotations used in critical articles and reviews)
    without prior consent of Pinnacle Publishing, Inc. To contact
    Pinnacle Publishing, Inc., please call (800)&nbsp;788-1900 or
    (206)&nbsp;251-1900.</font></p>
</blockquote>
</font></body>
</html>
