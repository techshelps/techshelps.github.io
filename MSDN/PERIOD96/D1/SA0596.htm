<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Manage Replication Conflicts (May)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<H1>Manage Replication Conflicts</h1>

<P>Michael Kaplan and Lynn Shanklin</p>

<P><i>One of the trickiest problems of using
replication in Access 95 is dealing with data conflicts. Michael
and Lynn provide some design tips on minimizing data conflicts
and show how to create a custom conflict resolution function.</i></p>

<P>One of the primary reasons for using Access 95's
replication facilities is the ability to synchronize data between
replicas in a replica set. Dispersed users can make changes and
additions to the data in their copy of an application and then
share those changes with other users on either a scheduled basis
or on demand. One of the hardest parts of implementing
replication is how to deal with what happens when two users try
to update the same record. How you deal with this
situation&#151;known as a data conflict&#151;will affect the
integrity and consistency of your data.</p>

<P>In this article, we'll discuss some of the design
changes you may want to make to your application to minimize data
conflicts and data errors. We'll also give an example of a custom
conflict resolution function that will make sure the
&quot;winner&quot; of a data conflict is the most recently
updated record (and discuss why this problem is a little trickier
than it might appear at first).</p>

<H2>Conflict or error?</h2>

<P>Data conflicts are inevitable when a replicated
application is used in a multiuser environment. Access determines
the presence of <i>data conflicts</i> when you synchronize two
replicas. A data conflict occurs when two or more users have made
changes to the same record. During the synchronization exchange,
Access also notes the presence of any <i>data errors</i> or <i>design
errors</i>.</p>

<P>There are several scenarios that might cause a data
error. For example, a data error will occur when Jet tries to
synchronize a record that is locked. In this case, an error will
be generated, but Jet will automatically resubmit the change and
clear the error the next time it synchronizes the two replicas,
so you don't have to worry about this. A data error can also
occur if two users add records in two different replicas with the
same primary key values.</p>

<P>The way to avoid data errors is to carefully review
your database design to prevent them from happening. For example,
to avoid duplicate primary key values, you can use random
AutoNumbers or even GUIDs for primary keys in your tables. (This
isn't always the best solution because, if two records <i>are </i>duplicates,
then you need some way to determine that this is the case. Using
a GUID will guarantee that you get no data errors due to primary
key duplication, but it won't guarantee that you don't have two
records that contain duplicate information.) Generally, the best
way to prevent data errors is to try to avoid situations where
they occur. </p>

<P>Design errors can also occur as the result of a
synchronization attempt. A design error occurs whenever Jet tries
to update the schema of a replica and finds itself unable to do
so. This can happen when you make a large number of interrelated
schema changes in a step-by-step fashion. If the changes are
complex, you can, for example, put the replica in a situation
where it needs an object that isn't there yet. The best way to
avoid schema conflicts is to synchronize often while making
changes, dispersing changes to your users as soon as they are
ready rather than waiting until you have many changes to
synchronize. On the other hand, you don't want to replicate
schema changes until you're sure they are correct. You should
also try to make sure that all replicas in the set are
synchronized often so that none of them fall too far behind in
making schema changes.</p>

<H2>From conflict comes synthesis</h2>

<P>Data conflicts will probably be more common than
data errors. Any time two people update the same record, a
conflict will occur when their replicas are synchronized. By
default, Jet handles this in a predictable but rather arbitrary
fashion:</p>

<ul>
    <li>Whichever of the two records was updated most is declared
        the &quot;winner&quot; and the losing replica's data will
        be changed (if they are both updated the same number of
        times, then Jet chooses the winner randomly).</li>
    <li>The losing record will be placed in a conflict table <i>in
        the losing replica only</i>. </li>
</ul>

<P>Jet provides a conflict resolution interface to
resolve the conflicts. When you open a database that has
conflicts in it, Access displays a message box informing you that
there are conflicts, followed by the Resolve Replication
Conflicts dialog box shown in Figure 1. For example, the single
conflict record in Figure 2 is the result of our attempt to
change the company name of the first customer record in two
replicas of NORTHWIND.MDB to &quot;Alfred Futterkis&quot;and
&quot;Alfred Futterkte.&quot; We then synchronized the two
replicas and opened one of them (the losing replica). When we
chose to view conflicts, the form in Figure 2<b> </b>was created
by the Access Conflict Resolution Wizard. This form gives you the
chance to look at both records, make changes, and then choose
which one you want to be the actual winner. The next time you
synchronize this replica with another, the new change will be
propagated to other replicas.</p>

<p><img src="cnflctf1.gif" width="382" height="160"></p>

<P><b>Figure 1. The Conflicts and Errors dialog box,
which lists all of the tables that contain conflicts and errors
and lets you choose which ones you wish to resolve.</b></p>

<p><img src="cnflctf2.gif" width="538" height="353"></p>

<P><b>Figure 2. The Data Conflict Resolution form,
which Access creates dynamically to display each data conflict
for the user to review.</b></p>

<P>You can replace the Conflict Resolution Wizard
interface with your own custom conflict resolution function.
We'll discussed this later in the article.</p>

<H2>Minimizing conflicts in a database</h2>

<P>As in life itself, the best strategy for handling a
conflict is to try to keep it from happening in the first place.
This involves many subtle design changes and also requires that
you know detailed information about your application's
functionality and what users do with your application. You
especially need to know who is updating versus deleting versus
adding records to the database. You might want to consider one of
the following strategies:</p>

<ul>
    <li>Adding new records instead of editing existing ones.</li>
    <li>Splitting records when different users update different
        fields.</li>
    <li>Creating smarter synchronization schedules.</li>
</ul>

<H3>Adding new records instead of editing existing
ones</h3>

<P>Many applications track resources, such as
inventory. One common way to do this is to create a table such as
the one in Figure 3, which lists the current inventory for
several products. This simple table lists the item in one field
and the quantity in another.</p>

<p><img src="cnflctf3.gif" width="305" height="165"></p>

<P><b>Figure 3. Inventory table that will have
constant problems with conflicts.</b></p>

<P>The problem with this method in a replicated
application is easily seen: imagine that two different people
using different replicas decide to take catnip out of inventory.
This will produce a conflict when the two replicas are
synchronized, and you'd need to write a custom conflict
resolution function to combine the two changes together every
time this happened. This would guarantee multiple conflicts and
delay the time before each replica had the most accurate data.</p>

<P>The solution here is to use log type tables for each
transaction and then use a totals query that uses the Sum
function to get the current inventory. By doing this, each change
in the inventory will be an addition of a new record rather then
the editing of an existing one, so no conflicts will occur. Of
course, this solution has many benefits in a more standard
multiuser environment as well, as it reduces page locks and
maintains an audit trail. </p>

<H3>Splitting up records when different users update
different fields</h3>

<P>Since replication is done at the row level rather
then the field level, a common source of conflicts will be seen
when two different people or departments have to update different
fields in the same row. This will trigger a conflict even though
none of their changes overlap. This type of faux conflict can be
particularly annoying since it isn't <i>really</i> a conflict at
all. However, automating the resolution of this type of conflict
can be tricky.</p>

<P>Figure 4 shows an example of this situation: this
table is a list of software project code-names. In this case both
a program manager and a financial officer have to enter the date
they approved the project's budget, but each will edit only the
one field. </p>

<p><img src="cnflctf4.gif" width="512" height="195"></p>

<P><b>Figure 4. All the data in a single table will
cause conflicts when different fields are edited.</b></p>

<P>One solution might be to write an automated custom
conflict resolution function that would somehow compare every
single field to decide which to keep. A better solution is to
split the table into two, and create a one-to-one relationship
between them. By doing this the two users will never cause data
conflicts when the same &quot;record&quot; is edited because they
would really be editing data in two separate tables that were
joined together in a query. This solution can be crucial in
certain situations. For example, a customer service
representative is on the phone updating some of a customer's
information, after which they transfer the customer to another
department that does the same thing to other fields in this
customer's information record. This would guarantee a conflict
every time if the table containing the customer information
wasn't split into two tables. </p>

<H3>Creating smarter synchronization schedules</h3>

<P>Developers who have spent time working with Access
or any other database product know that they need to take the
actual business environment into account when planning the
application's user interface, the locking scheme, security, and
other features. This applies just as readily to replication,
where you need to plan out the synchronization schedule to match
the business environment where the application will be used.</p>

<P>An example of this would be an application used by a
department of motor vehicles. A customer checks in with an
employee who is using one replica of the application. This
employee edits the customer's address, or other changed
information. Then the customer spends time filling out forms
given to them by this employee. The customer then brings the
forms up to another employee working with a different replica,
which hasn't been synchronized to reflect the changes made by the
first employee. In addition to adding new information, this
employee changes the same information changed by the first
employee. This scenario could repeat itself several times during
the course of the day.</p>

<P>The solution is to look at the schedule by which
synchronizations take place. Obviously it would be important to
have the changes made by the first employee propagate
intelligently. Since you know that one replica will need the
information from another, you should synchronize them more often<font
face="Symbol">¾</font>in some cases every time new information
is added.</p>

<P>The key here is to look at the actual dynamics of
how the application is being used. While it's nice and easy to
say that all synchronizations should be done overnight, once an
hour, or by some other arbitrary schedule, it's much better to
plan them, so you can minimize potential conflicts. In this
example you might even want to create a way to synchronize on
demand so that if the second replica doesn't contain information
that the employee thinks it should, he or she can automatically
synchronize with the first replica to retrieve this information.</p>

<H2>Customizing the resolution of conflicts</h2>

<P>While the Conflict Resolution Wizard's interface
does have many strong points, it's geared at producing a user
interface and thus doesn't allow for the fact that in many cases
you might have some automated way of determining which record
should win. The strength of the Jet conflict resolution model is
its simplicity: by tracking the number of times a record is
changed, it's simple to determine which one was changed more
often. However, in many cases it isn't the best solution. You may
find any of the following schemes to be more reasonable,
depending on the needs of an individual application:</p>

<ul>
    <li>Security based (the changes made by some users or groups
        will always override the changes made by other users or
        groups).</li>
    <li>Last updated (whichever version of the record was updated
        last).</li>
    <li>Replica based (similar to security based, but it instead
        gives priority to the record versions that one replica
        makes over another replica's version).</li>
    <li>Random (the choice between versions would be completely
        random rather than only random when both are updated the
        same number of times).</li>
    <li>Knowledge based (the version that came from the replica
        that had most recently synchronized with other important
        replicas in the set would be chosen).</li>
    <li>Business rule based (producing some combination of the
        two records based on simple or complex
        application-specific rules).</li>
</ul>

<P>There are two steps to creating a custom conflict
resolution function:</p>

<ol>
    <li>Write the function.</li>
    <li>Create a new database property named <i>ReplicationConflictFunction</i>
        and set it equal to the name of the function.</li>
</ol>

<P>The function must be in a global, replicable module,
so it must be created in the design master and propagated to the
other replicas. The <i>ReplicationConflictFunction</i> property
(unlike most custom properties that you create) will be
propagated so that every replica will know to call this function
when conflicts are found. You can create this property right from
the Files, Database Properties Custom tab where you simply need
to create a property named <i>ReplicationConflictFunction</i>
with a value equal to the name of your function (including the
parentheses). For example, if the name of your function is
ConflictResolver, set the property to the following:</p>

<P><br>
</p>

<pre> ConflictResolver()</pre>

<P>If you write code to create the property, you must
include the optional DDL parameter of the CreateProperty method
and set this parameter to True. This setting indicates that the
property can't be changed or deleted unless the user has
dbSecWriteDef permission. If this property isn't set to True, the
function won't be called. (This is handled automatically for you
when you use Files, Database Properties.)</p>

<P>The function will never automatically be called in
non-Access (for example, Visual Basic) applications, so if you
aren't using Access or Replication Manager, you should make sure
your application calls this function itself. You can call the
custom conflict resolution function you create at any time
yourself (specifically, you can call it right after you
synchronize two replicas if you do so programmatically). Setting
the ReplicationConflictFunction property tells Access 95 only
which function to call when you first open a database and it
determines that unresolved conflicts exist. </p>

<H2>Creating a custom conflict resolution function</h2>

<P>As you might have gathered from looking at Figure 1,
the custom conflict resolution function must handle data errors
and design errors in addition to the data conflicts. In many
cases, you'll probably want a simple function that will sort out
how many errors there are and of what type, such as this:</p>

<P><br>
</p>

<pre> Function ConflictErrorResolver()
   On Error Resume Next

   Dim lngDC as Long  'Data Conflicts
   Dim lngDE as Long  'Data Errors
   Dim lngSE as Long  'Schema Errors
   Dim db as Database
   Dim fRetVal as Boolean
   Dim strMsg as String
   Dim strTitle as String

   Set db = CurrentDb()

   lngDC = db.TableDefs(&quot;MSysSideTables&quot;).RecordCount
   lngDE = db.TableDefs(&quot;MSysErrors&quot;).RecordCount
   lngSE = db.TableDefs(&quot;MSysSchemaProb&quot;).RecordCount

   'Inform user of data/schema errors if they exist
   If lngDE &lt;&gt;0 Or lngSE &lt;&gt;0 Then
      strMsg = &quot;There are &quot; &amp; lngDE &amp; &quot; data &quot; &amp; _
       &quot;errors and &quot; &amp; lngSE &amp; &quot; schema errors &quot; &amp; _
       &quot;in this replica. Contact your replica &quot; &amp; _
       &quot;administrator for information on &quot; &amp; _
       &quot;resolving these problems.&quot;
      strTitle = &quot;Data/Schema Errors&quot;
      MsgBox strMsg, , strTitle
   End If

   'Check for data conflicts
   If lngDC &gt; 0 Then
      fRetVal = ConflictResolver()
   End If
End Function</pre>

<P>This function calls another function named
ConflictResolver(), which does the actual data conflict
resolution. The next step is to build that function.</p>

<P>In order to supply a useful sample, we've chosen the
&quot;Last Updated&quot;scheme for determining which record is
the winner. To use this method, you'll need to add an
&quot;UpdatedLast&quot; date/time field, with a default value set
to Now(), to each table. You can handle the problem of making
sure the clocks on different PCs are synchronized with almost any
of the freeware and shareware utilities that synchronize clocks
on a network or to an atomic clock (two such applications are on
the Companion Disk this month). Also, if your application will be
crossing time zones, then you should look at the sidebar that
addresses this issue.</p>

<P>Here is the sample conflict resolution function in
its entirety:</p>

<P><br>
</p>

<pre> Public Function ConflictResolver()
  Dim db as Database
  Dim tdf As TableDef
  Dim fld as Field
  Dim rstConflict As Recordset
  Dim rstSource as Recordset

  Set db = CurrentDb()

  For Each tdf In db.TableDefs
    'Check to see if table has a conflict table
    If (tdf.ConflictTable &lt;&gt; &quot;&quot;) Then
      Set rstConflict = db.OpenRecordset( _
       tdf.ConflictTable, dbOpenTable)
      Set rstSource = db.OpenRecordset(tdf.Name, _
       dbOpenTable)
      rstSource.Index = &quot;s_GUID&quot;
      rstConflict.MoveFirst
      'Scroll through conflict table's records
      Do While Not rstConflict.EOF
        rstSource.Seek &quot;=&quot;, rstConflict![s_GUID]
        'Make sure match was retrieved in source
        If Not rstSource.NoMatch Then
          'Check to see if loser was more recent
          If rstSource!UpdatedLast &lt; _
           rstConflict!UpdatedLast Then
            On Error Resume Next
            rstSource.Edit
            'scroll through fields to update
            For each fld in rstSource.Fields
              rstSource(fld.Name) = _ 
               rstConflict(fld.Name)
            Next fld
            rstSource.Update
            On Error Goto 0
          End If
        End If
        'Delete conflict record
        rstConflict.Delete
        rstConflict.MoveNext
      Loop
      rstConflict.Close
      rstSource.Close
    End If
  Next tdf
End Function</pre>

<P>This function does the following:</p>

<ol>
    <li>Iterates through each TableDef in the database, looking
        to see if it has a conflict table (by checking the
        TableDef's ConflictTable property; if it's anything but a
        blank string, then the value of that property is the name
        of the conflict table).</li>
    <li>When a conflict table is found, it opens up recordsets on
        both the source table and the conflict table.</li>
    <li>It then moves through each record in the conflict table
        and uses the Seek method on the s_Guid field (which
        exists as a unique index in both tables) so that both the
        source table record and the conflicting record can be
        compared.</li>
    <li>It checks the UpdatedLast field in both tables and, if
        the source table (which contains the winning record)
        wasn't updated last, this record is replaced by the
        (formerly) losing record in the conflict table.
        Regardless of whether it wins or loses, the conflict
        record is then deleted.</li>
</ol>

<P>Here's the important line of code that makes the
UpdatedLast scheme work:</p>

<P><br>
</p>

<pre> If rstSource!UpdatedLast &lt; _
 rstConflict!UpdatedLast Then</pre>

<P>You can replace this comparison with any logical
method for determining whether or not the winning record needs to
be replaced by the losing record.</p>

<P>This particular custom conflict resolution function
is located in the sample database CNFLCT.MDB on the Companion
Disk. This database hasn't yet been made replicable, but you can
replicate it and then test it. Alternately, you can use it in
your own replica set by importing basConflict into your own
design master, making it replicable, and then setting the
ReplicationConflictFunction property to
&quot;ConflictErrorResolver()&quot; (if you need to do time zone
corrections, then don' forget to import basDate as well). Setting
the ReplicationConflictFunction property is optional; you can
actually call the function from your own application at any time.</p>

<H2>Conclusion</h2>

<P>The approaches to conflict prevention and resolution
that we've presented here are by no means exhaustive. Your
application may present unique problems that only time and the
use of your application will determine. Data conflicts between
replicas can be challenging to resolve, but the advantages of
using replication make facing the challenges worthwhile.</p>

<H3>Conflict Tables: A Limitation in Jet 3.0
Replication</h3>

<P>In Jet 3.0 a conflict table is only stored in the
replica in which the losing record was created. Thus, any
conflict resolution function that might override Jet's decision
and make this record a winner <i>must</i> be executed in the
replica in which the record was created.</p>

<P>The problem with this scenario is that if anything
happens to this database (for example, if it were deleted or
became unrepairable), then any of its records that lose in
conflicts with other replicas will be lost from the database.
Although the chance of having an unrepairable database is slim
and the chance of accidentally deleting the database can be
controlled through user education, the danger is nevertheless
present. </p>

<P>This limitation is one of the main reasons why your
first line of defense against data conflicts should be to develop
strategies in your application design to avoid them entirely.
Conflict resolution via a custom conflict resolution function
should always be the second line of defense. </p>

<H3>What About Replicas in Different Time Zones?</h3>

<P>Replicas that exist in different time zones
complicate figuring out which record was updated last. You can't
just compare the values in a date/time field. Since each will
define the time according to the current local time, you won't be
able to tell which one was truly updated last. For example, a
record in a replica in Seattle, Washington, (GMT -8:00) that is
updated at 5:39 p.m. local time was actually updated almost three
hours after a record in a replica in New York, New York, (GMT
-5:00) that is updated at 5:40 p.m. local time. If you use Now()
to update the LastUpdated field, however, your function will
think that the Seattle record was updated one minute earlier.
This doesn't even begin to get into the issue of daylight savings
and the various levels of compliance with it throughout the
United States and the world. So how can you really determine <i>which</i>
record is the last one that was updated?</p>

<P>You can't, unless you add code to correct for the
current time zone. Luckily, both Windows 95 and Windows NT
support the GetTimeZoneInformation API call. Since each user has
to specify the current time zone when installing Windows 95 or
Window NT, you can use the NowPlusTZBias() function shown here
instead of the regular Now() function in order to get the current
date/time plus the time zone bias:</p>

<P><br>
</p>

<pre> Function NowPlusTZBias() As Date
   'Returns the current date/time after 
   'correcting for the PC's time zone.

   Dim usrTZI As TIME_ZONE_INFORMATION
   Dim lngRetVal As Long
   
   lngRetVal = GetTimeZoneInformation(usrTZI)
   NowPlusTZBias = Now() + (usrTZI.Bias / 1440)
End Function</pre>

<P>This code and the API and Type declarations are
located in the basDate module in the CNFLCT.MDB database on the
Companion Disk. The only difference between using it and using
Now() is that you can't use it for the default value of a field
at the table level (since you can't call user-defined functions
from there), so instead you must use it as the default value of a
field at the form level. </p>

<P><i>Michael Kaplan is the owner of Trigeminal
Software Inc., a consulting firm that focuses on all types of
unusual interconnectivity solutions in Microsoft Access, SQL
Server, Visual Basic, and Office. He's an MVP on both the
CompuServe and the Microsoft Network MSAccess forum and is
working on a Special Report on Replication for Pinnacle's The
Pros Talk Access 95 series. CompuServe 102363,1726.</i></p>

<P><i>Lynn Shanklin is a writer with the Microsoft
Access User Education group, which provides all the documentation
for Access and related products like the ADT. She worked
extensively on Building Applications with Microsoft Access for
Windows 95, as well as the Solutions sample database and the
Access Developer's Toolkit for Windows 95 documentation.
CompuServe 73322,666.</i></p>

<P>&nbsp;</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong><a
href="http://www.pinpub.com/access/"> <strong>http://www.pinpub.com/access/.
</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the May 1996 issue
of Smart Access. Copyright 1996, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. Smart Access is
an independently produced publication of Pinnacle Publishing,
Inc. No part of this article may be used or reproduced in any
fashion (except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></body>
</html>
