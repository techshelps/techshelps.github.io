<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Trying On the Tree Control (October)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Trying On the Tree Control</h1>
<p>
Keith Bugg</p>
<p>
<i>Need to display data both graphically and in a hierarchy?  The new tree control in Windows 95 and NT is just what the doctor ordered. Here’s how to climb this handy interface tool.</i></p>
<p>
PRIOR to 1994 B.C. (Before CTreeCtrl), you had to work pretty hard to display data that was related in a hierarchy. It was a teeth-gnashing, Jolt-guzzling kind of job. The advent of the new common controls for Windows 95/NT has changed this situation. The class CTreeCtrl included in the new 32-bit common controls allows you to display hierarchical data and a lot more. In this article, I’ll delve into the theory and operation of this control and illustrate it with an example program you’ll find on the Developer’s Disk. The program uses a tree control to find all the directories and files on the root of the user’s C drive, and displays them accordingly. For the sake of simplicity, the program doesn’t scan beyond the first two levels, but you can easily extend the source to generate a complete directory tree. Figure 1 shows the control in action.</p>
<p><img src="bugga1.gif"></p>
<p>
<b>Figure 1. Output from the sample program.</b></p>
<h2>Tree theory 101</h2>
<p>
The idea behind the tree control is based on its namesake-the tree. Just as a tree has a root, a trunk, limbs, and leaves, so your data is similarly structured and each “level” can be represented by a unique bitmap. In addition, the bitmap can be modified on the fly to represent a change of state. For example, as shown in Figure 2, whenever you click on a directory icon in the example program, I change the bitmap from a closed folder to an open folder.</p>
<p><img src="bugga2.gif"></p>
<p>
<b>Figure 2. Icon change of state.</b></p>
<p>
Although the tree control draws all the lines when the data is collapsed or expanded, it’s up to you to manage the images. Because tree controls make considerable use of bitmap images, let’s take a closer look at how they’re used and managed. To begin, you’ll have to create (or import) all the different images you plan to use. My program uses four distinct images: the hard disk icon, the closed directory folder icon, the open (or selected) folder icon, and a generic file icon.</p>
<p>
These images are stored in a derived object from the class CImageList. An image list is not a control, but rather a drawing tool that can be thought of as a glorified bitmap manager. Another analogy for image lists is to think of them as a roll of film. Just like a roll of film, image lists are a stream of bitmaps that come with their own API functions you can call to perform most of the work for you. And just as a roll of film has a fixed size (such as 35mm), so the image list has a maximum height of 32,668 pixels. In other words, an image list bitmap can range in size from a single 32K by 32K pixel bitmap to 32,668 bitmaps, each one pixel wide. To determine the maximum number of images an image list will support, just divide 32K by the width of one of your images. When you need a particular image, you simply reference it by its index in the image list. </p>
<p>
The images you retrieve from your image list will be either <i>masked</i> or <i>unmasked</i>. The masked variety includes transparent pixels so that the background appears to shine through-just like an icon on the Windows 95 Desktop. On the other hand, the unmasked variety overwrites whatever is under it. For working with tree view controls, you’ll probably want to use the masked version.</p>
<h2>A supporting cast</h2>
<p>
Your tree control will need a supporting cast of special structures and unique data objects:</p>
<p>
<b>HTREEITEM</b><font face="Symbol"><span style="font-family:symbol">&#190;</span></font>A handle to an item in a tree control</p>
<p>
<b>TV_ITEM</b><font face="Symbol"><span style="font-family:symbol">&#190;</span></font>Structure for reading/writing tree item attributes.</p>
<p>
<b>TV_INSERTSTRUCT</b><font face="Symbol"><span style="font-family:symbol">&#190;</span></font>Structure used to add items to a tree control.</p>
<p>
Of these, the last two are the most important and most frequently used. They also work in tandem-the TV_ITEM is a “child” of the TV_INSERTSTRUCT “parent.” In general, the basic approach to programming a tree control can be summarized as follows:</p>
<p>
Define the control’s styles. </p>
<p>
Define an image list.</p>
<p>
Define members of a TV_ITEM structure.</p>
<p>
Insert the TV_ITEM into a TV_INSERTSTRUCT.</p>
<p>
Let’s examine each of these steps and then look at the sample program.</p>
<h2>Defining a tree style</h2>
<p>
Objects of class CTreeCtrl support several styles, all of which have a profound effect on the way a control looks and behaves. You’ll most likely assign one of the following styles to a tree control:</p>
<p>
<b>TVS_HASBUTTONS.</b> This style causes the control to display a box/button with a plus (+) sign in it when the item is collapsed and a minus (-) sign when it’s expanded. Clicking one of these buttons expands or collapses the item accordingly. Figure 1 shows this style in action.</p>
<p>
<b>TVS_EDITLABELS.</b> This style allows the user to edit the labels associated with the tree items.</p>
<p>
<b>TVS_HASLINES.</b> This style will display a dotted line between the items to show the relationship between them; the tree control in Figure 1 also has this style.</p>
<p>
<b>TVS_HASLINESATROOT.</b> This style tells the tree view control to draw lines linking child items to the root of the hierarchy. This style is also used with the control in Figure 1.</p>
<p>
There are additional but less frequently used styles. For an overview of all the styles, consult the Visual C++ documentation.</p>
<h2>Defining an image list</h2>
<p>
Your next step concerns the image list, which is where you’ll define the images that will be used in the tree control. You’ll need to create images that show the tree control item in its normal state plus any other special conditions (such as when the item is selected). The tree control requires these images to be of the type HICON and not HBITMAP as you might have expected. In the example program, I instantiated an object of class CImageList with the name m_ImageList. I then trapped the WM_CREATE message and used the Create() method to create the actual image list:</p>
<pre><font face="Courier New" size="3">int CTreeDlg::OnCreate(
              LPCREATESTRUCT lpCreateStruct)
{
   if (CDialog::OnCreate(lpCreateStruct) == -1)
      return -1;
&#09;
   // TODO: Add your specialized creation code here
   // Create the image list you will need

   m_ImageList.Create(BITMAP_WIDTH,
      BITMAP_HEIGHT,
      FALSE,   // list does not include masks
      NUM_BITMAPS,
      0 );   // list will not grow
   HICON hIcon;</font></pre>
<p>
Load the icon images when the image list is created. The order in which these are added is <i>very</i> important from a project management point of view because you’ll index into the list to use an appropriate image. For example, the icon for the root of the tree is the symbol for a hard disk drive-its index should be zero in your list. The next level down is a closed directory, with an index of 1. This makes it easy to relate the meaning of the image with the position in the tree control’s hierarchy. Here’s the code for this step (you might want to add some error traps and ASSERT statements here since I’ve omitted these for the sake of brevity):</p>
<pre><font face="Courier New" size="3">//
// load the icon images and add them 
// to the image lists
//
hIcon = ::LoadIcon (AfxGetResourceHandle(), 
                   MAKEINTRESOURCE(IDI_HARDDRV));
iDiskImage = m_ImageList.Add(hIcon);
//
// The order in which icons are added is 
// related to the hierarchy level!!
//
hIcon = ::LoadIcon (AfxGetResourceHandle(), 
              MAKEINTRESOURCE(IDI_FOLDER_CLOSE));
iDirectoryImage = m_ImageList.Add(hIcon);
hIcon = ::LoadIcon (AfxGetResourceHandle(), 
               MAKEINTRESOURCE(IDI_FOLDER_OPEN));
iFolderOpen = m_ImageList.Add(hIcon);
hIcon = ::LoadIcon (AfxGetResourceHandle(), 
                    MAKEINTRESOURCE(IDI_FILE));
iFileImage = m_ImageList.Add(hIcon);
//
// Make sure all of the bitmaps were added
//
if (m_ImageList.GetImageCount() &lt; NUM_BITMAPS)
&#09;return -1;

return 0;</font></pre>
<h2>The TV_ITEM structure</h2>
<p>
Now you have a control, assigned it some styles, and created the image list. The next step is to build the “leaves” of the tree. For this you’ll need the TV_ITEM structure. This is used to set and retrieve the attributes of a tree item. Its prototype is as follows (I’ve added descriptive comments for each member and discuss the less-than-obvious meaning of some of the members):</p>
<dl>
<dt>
  </dt>
<dd>
<pre><font face="Courier New" size="3">typedef struct _TV_ITEM {  tvi 
    // specifies which members are valid
    UINT       mask; &#09;&#09;&#09;
    // handle of tree item in question 
    HTREEITEM  hItem; &#09;&#09;&#09;
    // current state of the item 
&#09;  // (high-lighted and so on)
    UINT       state; &#09;&#09;&#09;
    // the bits of the state member that are valid
    UINT       stateMask; &#09;&#09;
    // text to display next to an item 
    LPSTR      pszText; &#09;&#09;
    // number of characters in pszText 
    int        cchTextMax; &#09;&#09;
    // index in CImageList for normal state 
    int        iImage; &#09;&#09;
    // index in CImageList for high-lighted state
    int        iSelectedImage;&#09;
    // flag indicating if an item has children 
    int        cChildren; &#09;&#09;
    // user-defined 32-bit value for the item 
    LPARAM     lParam; &#09;&#09;
} TV_ITEM, FAR *LPTV_ITEM; </font></pre>
</dd>
</dl>
<p>
The mask member is very important-it defines which of the other members have meaning. It’s most important when retrieving information from the control. Only the items you specify in the mask member are valid when reading. The various values that a mask can have (these can be ORed together) are summarized in Table 1.</p>
<dl>
<dt>
<b>Table 1. Values for mask members of TV_ITEM.</b></dt>
<dd>
<b>Mask value&#09;Meanings</b><p>
TVIF_CHILDREN&#09;The cChildren member is valid.</p>
<p>
TVIF_HANDLE&#09;The hItem member is valid.</p>
<p>
TVIF_IMAGE&#09;The iImage member is valid.</p>
<p>
TVIF_PARAM&#09;The lParam member is valid.</p>
<p>
TVIF_SELECTEDIMAGE&#09;The iSelectedImage member is valid.</p>
<p>
TVIF_STATE&#09;The state and stateMask members are valid.</p>
<p>
TVIF_TEXT&#09;The pszText and cchTextMax members are valid.</p>
</dd>
</dl>
<p>
The cChildren member acts as a flag indicating whether the associated tree item is at the end of the line or has something under it. When this member is 0, it means there are no children. The item is the parent of another, subordinate item when it is 1 or greater. Finally, the member can have the reserved word value I_CHILDRENCALLBACK, which indicates the parent window stores the index of the child node. In this case, the control must send a TVN_GETDISPINFO message to the parent whenever it needs the index of the child item.</p>
<h2>The TV_INSERTSTRUCT structure</h2>
<p>
Now that the items are defined, they can be added to the control. This requires the TV_INSERTSTRUCT structure. Again, I’ve added comments to the prototype to help illuminate its members:</p>
<h3>  </h3>
<pre><font face="Courier New" size="3">typedef struct _TV_INSERTSTRUCT {
    HTREEITEM hParent;&#09;&#09;
    // the handle of the parent item;
    // use TVI_ROOT or NULL for the root
    HTREEITEM hInsertAfter;&#09;
    // the handle of the item after which 
    // the item is to be added  
    TV_ITEM   item;&#09;&#09;
    // information about the item being added
} TV_INSERTSTRUCT;</font></pre>
<p>
In addition, hInsertAfter can have one of three values:</p>
<p>
<b>TVI_FIRST. </b>Insert the item at the beginning of the list.</p>
<p>
<b>TVI_LAST</b>. Insert the item at the end of the list.</p>
<p>
<b>TVI_SORT</b>. Insert the item into the list in alphabetical order.</p>
<p>
You’ll find both of these structures used in a method called AddOneItem() in the sample program. Let’s start wrapping things up by looking at this example.</p>
<h2>The sample program</h2>
<p>
The tree control code in the sample program is located in files TREEDLG.CPP and TREEDLG.H, which define the dialog box containing the tree control. This dialog box includes an “invisible” list box where the WS_VISIBLE property has been omitted. I use this control to temporarily hold the names of the directories and files. I trapped the WM_INITDIALOG message, used _chdir() to change to the root of the C: drive, and searched the drive for all directories. I placed the search result in the invisible list box, which in the sample has the member variable m_Invisible:</p>
<pre><font face="Courier New" size="3">// hard-code Drive C here (again!)
_chdir(&quot;c:\\&quot;);
m_Invisible_LB.Dir(DDL_DIRECTORY,&quot;*&quot; );
//
// Associate the image list with the tree
//</font></pre>
<p>
Since I built the image list when I overrode WM_CREATE, it’s all right to go ahead and associate it with the tree control; I then call AddTreeViewItems(). This method adds the icon for the “C” drive to the control, then adds all the cached directories in the invisible list box. As each directory is appended to the list the code changes to that path and finds all the files within, adding them to the control. I chose to stop the recursion at this level but you can easily modify this code to scan any additional subdirectories.</p>
<pre><font face="Courier New" size="3">m_Tree.SetImageList(&amp;m_ImageList,TVSIL_NORMAL);
//
// Add the directories to the tree view control
//
AddTreeViewItems();
//
//  Now get just the files, no directories
//

// Flush the invisible listbox
m_Invisible_LB.ResetContent();

// Save file names in list box
m_Invisible_LB.Dir(0x0 | !DDL_DIRECTORY,&quot;*.*&quot; );
char lpFileName[_MAX_PATH]; // working variable

// Initialize the working variable
memset(lpFileName,0,sizeof(lpFileName));
for(int i=0; i &lt; m_Invisible_LB.GetCount(); i++)
{
  // Get the file name and add it to the tree control
  m_Invisible_LB.GetText(i,lpFileName);&#09;
  AddOneItem(htDirectory, lpFileName, 
  (HTREEITEM)TVI_LAST, iFileImage,FALSE);
}</font></pre>
<p>
The rest of the code, which is available on the Developer’s Disk, is devoted to finding the files using _findfirst() and _findnext(). In each case, AddOneItem() appends items found to the tree control. The arguments for this method are the handle of the tree control, the text to display with the node, the handle of the node where the new item is to be inserted, the CImageList index of the icon to display, and a flag indicating whether the node has any children:</p>
<pre><font face="Courier New" size="3">HTREEITEM CTreeDlg::AddOneItem(HTREEITEM hParent,
                               LPSTR szText, 
                               HTREEITEM hInsAfter,
                               int iImage, 
                               BOOL bChildren)
{
  HTREEITEM hItem;       // return value
  TV_ITEM tvI;           // item structure
  TV_INSERTSTRUCT tvIns; // item insert structure
&#09;
  // *** set tvI.mask member ***
  if(bChildren)&#09;&#09;&#09;
     tvI.mask = TVIF_TEXT | TVIF_IMAGE | 
                TVIF_SELECTEDIMAGE | 
                TVIF_PARAM | 
                TVIF_CHILDREN;//item has children
  else  // item has no children
     tvI.mask = TVIF_TEXT | TVIF_IMAGE | 
                TVIF_SELECTEDIMAGE | 
                TVIF_PARAM;
&#09;
  // set text, text length, image 
  tvI.pszText = szText;
  tvI.cchTextMax = lstrlen(szText);
  tvI.iImage = iImage;

  // get type of icon to display
  if(bChildren)&#09; 
    // selected a folder, OK to change bitmap
    if(hParent != NULL)&#09;
      tvI.iSelectedImage = iFolderOpen;
    else  // selected the hard drive icon, 
          //don't change bitmap!!
      tvI.iSelectedImage = iImage;
  else
      tvI.iSelectedImage = iImage;
  tvI.cChildren= 1; // allow one more level down
&#09;
  // do the insert
  tvIns.item = tvI;
  tvIns.hInsertAfter = hInsAfter;
  tvIns.hParent = hParent;
  hItem = m_Tree.InsertItem(&amp;tvIns);
  return (hItem); // return (add error trap here)
}</font></pre>
<p>
Notice the BOOL flag bChildren-the value of this critter plays an important role in determining the settings for the tvI.mask element and in selecting the icon to display. For more sophisticated implementations of the tree control, you’ll probably want to change the bChildren flag to an integer value (call it iFlag) and use a switch() statement to manage icon selection. For example, setting iFlag to 0 might mean a .TXT file. A setting of 1 might be an .EXE file, 2 might be an .INI file, and so on.  </p>
<h2>Summary</h2>
<p>
Personally I found the tree control a stern taskmaster. It took time to get the hang of it-the paucity of sample code was my greatest obstacle. It took a lot of head-scratching, plus some trial and error, to come up with a working example. I strongly encourage you to examine the sample code in detail, especially the AddOneItem() method, since it uses the important structures.  </p>
<p>
Besides the obvious use of a tree control for disk structures, it would be useful in plenty of other types of data display. For example, you could use it to build a custom class inspector: the base class could be shown at the root, while derivatives would appear in the nodes. Or how about creating a fancy index into a WinHelp document or a database browser? Any time you have hierarchical data, you have an opportunity to spice up the user interface with the tree control.</p>
<p>
<i>Keith Bugg has been writing Visual C++ applications since version 1 was released. Keith has taken so much grief about his name he’s thinking of changing it to Viruss. When he isn’t programming, Keith enjoys brewing beer and riding his ATV. tristar@qsystems.net, http://www.qsystems.net/tristar/tristar.htm.</i></p>
<P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual C++ Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vcd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    October 1996 issue of Visual C++ Developer. Copyright
    1996, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual C++ Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
