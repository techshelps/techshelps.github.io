<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Buy Some Property (June)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<H1>Buy Some Property</h1>

<P>Peter Vogel</p>

<P><i>Create and use new properties for all your Data
Access Objects. In the process, you'll turn up two and a half
undocumented recordset properties.</i></p>

<P>Everything in Access has properties. For example, a
control has many properties&#151;including the Name and
ControlSource properties&#151;a form has Caption and ViewsAllowed
properties, and a table has Names and ValidationText properties.
Properties for any object are members of a collection, called the
Properties collection, which you can loop through for various
purposes. More importantly, you can create your own properties
using Data Access Objects (DAO) code. In this article I'll show
you how to work with the Properties collection and how to create
your own properties.</p>

<H2>Undocumented properties</h2>

<P>I'll begin by looking at the properties for a
recordset. This routine will create a recordset and loop through
its properties, displaying the name of each property in the
immediate window:</p>

<P><br>
</p>

<pre> Sub ListAttributes()
  Dim db as Database
  Dim rec as Recordset
  Dim intProp as Integer
  
  Set db = DBEngine(0)(0)
  Set rec = db.OpenRecordset(&quot;Select * _
  from MyTable&quot;)

  For intProp = 0 to rec.Properties.Count - 1
    Debug.Print rec.Properties(intProp).Name
  Next intProp

  rec.Close
End Sub</pre>

<P>What's interesting about this list is that three
undocumented properties, EditMode, AbsolutePosition, and
Description, appear in it. (Actually, Description may not appear
in the list&#151;more on this later.) You can perform a few tests
to find out more about these properties. To work with these
properties, you can refer to them by their position in the
collection. But, like any other collection, you can also
reference members of the Properties collection by name:</p>

<P><br>
</p>

<pre> Debug.Print rec.Properties(&quot;EditMode&quot;)</pre>

<P>To try setting the value of the EditMode property,
you could use this:</p>

<P><br>
</p>

<pre> rec.Properties(&quot;EditMode&quot;) = 1</pre>

<P>A little experimentation shows that EditMode has
three settings: 1 (after the Edit method is used on the
recordset), 2 (after the AddNew method), or 0 (all other times).
AbsolutePosition reflects the relative record number of the
current record (but not for table type recordsets). <i>[Dan
Haught discussed the AbsolutePosition property in an article in
the January 1996 issue.&#151;Ed.]</i> Both properties are
read-only.</p>

<P>The syntax for working with properties may appear
odd to you. This is the usual way you reference the EditMode
property of the rec recordset:</p>

<P><br>
</p>

<pre> rec.EditMode</pre>

<P>rec.EditMode works, and so does
rec.AbsolutePosition, but rec.Description doesn't. While the code
will compile, you'll get a &quot;Name not found in this
collection&quot; error message when you run the code. To see
what's special about this property, you'll have to go one step
further and look at the properties of these properties. Don't
give up, all this will turn out to be useful by the end of the
article.</p>

<H2>Alice's rabbit hole</h2>

<P>Members of the Properties collection also have
properties, which are also members of a collection, whose members
also have properties, which are also members of a collection, and
so on. This endless (I assume) regression is made simpler by the
fact that there are only four &quot;properties of a
property:&quot; Value, Name, Type, and Inherited:</p>

<ul>
    <li>Value is the default property of a property. When you
        refer to a property without specifying which of its
        properties you want, you get the property's Value
        property. (Are you confused yet? Don't worry, it's almost
        over). This just means that rec.AbsolutePosition.Value
        and rec.AbsolutePosition both return the value of the
        AbsolutePosition property for the rec recordset. </li>
    <li>Name is the name of the property, so that
        rec.AbsolutePosition.Name returns
        &quot;AbsolutePosition.&quot; </li>
    <li>Type returns an integer corresponding to Access'
        pre-defined datatype property constants. Because
        EditMode's type is an integer, rec.EditMode.Type returns
        3, the value of the DB_INTEGER constant. These constants
        are listed under Constants in the Access online help.</li>
    <li>The Inherited property of a property returns True if the
        property is inherited from some other object. </li>
</ul>

<P>This Inherited property is more interesting than the
other three. For a recordset, it turns out that the Description
property can be inherited. If the recordset is a dynaset and is
based on a single table, Description is inherited and contains
the description from the underlying table. However, a dynaset
based on multiple tables has no Description property. A
table-type recordset has a Description property, but its
Inherited property is set to False. As it turns out, this dynamic
Description property can't be accessed with the rec.Description
syntax, but can be accessed using either the
rec.Properties(&quot;Description&quot;) or
rec.Properties!Description syntax. Description is really half
undocumented: it's documented, but under the object it's
inherited from, the TableDef object.</p>

<H2>Some property of your own</h2>

<P>If Access can add and delete properties with
abandon, the question arises: can you? In a true object-oriented
environment, you could create a new subclass of an existing
class. If you needed your tables to have a property Access didn't
provide, you would create a NewTable subclass of Access' Table
class. This new class would inherit all the properties of its
parent class, plus whatever ones you cared to add. </p>

<P>Well, you can't do that, but you can add new
properties to individual Databases, TableDefs, Fields, Indexes,
and Queries. Why would you want to? Let me suggest two scenarios:</p>

<ul>
    <li>You split your order entry system into two .MDBs. One
        .MDB has all the data for the application; this .MDB
        exists only on your file server. The other .MDB has all
        the code, queries, and forms. A separate copy of this
        .MDB exists on each user's hard disk. Not all users are
        the same, though. Some users are located in the parts
        department, some in the whole goods division, and the two
        departments process orders differently. Rather than
        create a table of user control information, you could
        create new database properties that are set to reflect
        each user's needs. I'll show how adding a Location
        property to the database can handle this situation.</li>
    <li>In the December 1995 issue of <i>Smart Access</i>, Steve
        White presented a system for implementing upgrades to
        Access tables at remote sites. One part of that system
        was a table specifying the version level for each table
        in the system. This information could also be stored as a
        property of the table, so I'll also show you how to add a
        VersionNumber property to all of the tables in a
        database.</li>
</ul>

<P>I can think of three reasons for storing this
information in DAO properties rather than in tables. First,
information stored in properties is faster to access than table
information. Second, properties are less likely to be
changed/deleted by accident than tables. But the third reason is
the most important to me: it just seems like the right thing to
do. Location is a property of the database and should be stored
as such. </p>

<H2>Making properties</h2>

<P>Adding a property is a two-step process. The first
step is to create a property using the CreateProperty method of
the object. The second step is to add the property to the
appropriate object's properties collection:</p>

<P><br>
</p>

<pre> Dim db as Database
Dim prp as Property
Set db = DBEngine(0)(0)
Set prp = db.CreateProperty(&quot;Location&quot;,DB_TEXT, _
 &quot;Goderich&quot;)
db.Properties.Append prp</pre>

<P>The CreateProperty method takes up to three
arguments. The first is the name of the property, the second is
the datatype, and the third is a value to which you wish to
initialize the property. While you can omit the last two
arguments, the property object must have its type set before it
can be assigned a value, and it must have a value before it can
be added to any object. If you omit them when using the
CreateProperty method, you'll have to set them in separate
statements before appending the property:</p>

<P><br>
</p>

<pre> Set prp = db.CreateProperty(&quot;Location&quot;)
prp.Type = DB_TEXT
prp.Value = &quot;Goderich&quot;
db.Properties.Append prp</pre>

<P>Changing the value of a property that was previously
created is more straightforward:</p>

<P><br>
</p>

<pre> db.Properties(&quot;Location&quot;) = &quot;Kitchener&quot;</pre>

<P>In the order entry scenario, this is the code to
retrieve all the orders for the department specified in the
Location property of the database:</p>

<P><br>
</p>

<pre> Set rec = db.OpenRecordset(&quot;Select * From Orders _
 Where LocationName = '&quot; &amp;  _
 db.Properties(&quot;Location&quot;) &amp; &quot;'&quot;)</pre>

<P>Here are some notes on user-defined properties: </p>

<ul>
    <li>Properties created with the CreateProperty method can't
        be accessed using the object.propertyname syntax; you
        must use the object.Properties(propertyname) or
        object.Properties!propertyname syntax. This follows the
        usual rule of thumb&#151;if you name it yourself, you
        must use a ! (bang) in front of it.</li>
    <li>The property is created only for the object it's appended
        to. While the order entry database now has a Location
        property, no other database does. Nor will any new
        databases you create after this have this property unless
        you add the property to them. </li>
    <li>An object must be saved to disk before a property can be
        added to it.</li>
    <li>Once you append the property to the collection, you can
        only read and change the value. (You can't change the
        name or datatype of the property.)</li>
    <li>The name of the property must be unique within the
        collection&#151;no object can have two properties with
        the same name.</li>
    <li>You can't delete or change the type of the properties
        that are shipped with Access (the built-in properties).</li>
    <li>Of course, you may want to delete any properties you've
        created. If so, the syntax is object.Properties.Delete
        propertyname. To delete the Location property, use the
        following: <ul>
            <li>db.Properties.Delete &quot;Location&quot;</li>
        </ul>
    </li>
</ul>

<P>In the unlikely event someone may be adding or
deleting properties while you're working with them, you can use
the Refresh method on the Properties collection. This is
necessary because Access retrieves all members of the Properties
collection (or any other collection) when you first use it.
Access doesn't check whether the collection has acquired or lost
members, or whether the order of members has changed in the
collection, until you do a Refresh. To refresh the Properties
collection for the database use this syntax:</p>

<P><br>
</p>

<pre> db.Properties.Refresh</pre>

<H2>Working with tables</h2>

<P>Say that you'd like to add a VersionNumber property
to all the tables in a database. To make that job easier, you may
want to create a routine that sets the properties of a table.
I've created a function called intSetTableProperty() that does
this. I pass a table object, a property name, and a value to this
function. intSetTableProperty() attempts to set the property
specified to the value that is passed to it. If the property
doesn't exist for that table, the function creates the property
and initializes it to the passed value. If the property has to be
created, the function will set the property type to match the
type of the value passed to the routine. intSetTableProperty()
returns zero if the property was set and the error code generated
if the set fails (see Listing 1).</p>

<P>Using the intSetTableProperty() function, I can use
the TableDefs collection to create or reset the VersionNumber
property for all the tables in the database:</p>

<P><br>
</p>

<pre> Dim db as Database
Dim intTableDefs as Integer, intError as Integer
Set db = DBEngine(0)(0)</pre>

<P><br>
</p>

<pre> For intTableDefs = 0 to db.Tabledefs.Count - 1
  intError = intSetTableProperty _
   (db.TableDefs(intTableDefs),&quot;VersionNumber&quot;,1)
  If intError &lt;&gt; 0 Then
    MsgBox Error(intError)
  End If
Next intTableDefs</pre>

<P>The version control system described in scenario two
can now use the tables' new version number property to determine
whether a table should be upgraded. Once the upgrade is complete,
the intSetTableProperty() function would be called again to set
the table's version number to the version to which it has been
upgraded.</p>

<H2>Property manager</h2>

<P>Included on the Companion Disk is PROPUTIL.MDA, an
Access 2.0 Add-In that contains a utility called Property Manager
(see Figure 1). Property Manager provides a way to explore some
of Access' DAO objects and learn more about them. For instance,
it turns out that all QueryDefs have the ReturnsRecords property,
though the documentation says that only pass-through queries
should. With Property Manager you can create your own properties
and use those properties to store important information. In
addition to letting you review, change, and create properties,
Property Manager will allow you to change the name and type of
your properties on the fly.</p>

<p><img src="prop1.gif" width="696" height="336"></p>

<P><b>Figure 1. The Property Manager Add-In showing
the properties for tblMessages.</b></p>

<P>Working with the properties collection can only give
you a deeper understanding of what makes Access tick. Being able
to add your own properties to DAO objects is icing on the cake,
enabling you to add capabilities to your objects that weren't
there before. All in all, it adds up to more efficient and
effective applications.</p>

<P><i>[The techniques and code presented in this
article work in both Access 2 and Access 95, but the Property
Manager add-in works only with Access 2.&#151;Ed.]</i></p>

<P><b>Listing 1. This function sets a property of a
TableDef, creating the property if necessary.</b></p>

<ul>
    <li>Function intSetTableProperty _</li>
    <li>(ptdf As TableDef, pstrPropertyName As String, _</li>
    <li>pvar As Variant)</li>
    <li>&nbsp;</li>
    <li>Dim db As Database</li>
    <li>Dim prp As Property</li>
    <li>Dim ysnFail As Integer</li>
    <li>Dim intHoldError as integer</li>
    <li>&nbsp;</li>
    <li>On Error GoTo PropertyAdd_Err</li>
    <li>&nbsp;</li>
    <li>ysnFail = False</li>
    <li>intSetTableProperty = 0</li>
    <li>&nbsp;</li>
    <li>ptdf.Properties(pstrPropertyName) = pvar</li>
    <li>&nbsp;</li>
    <li>If ysnFail Then</li>
    <li>ysnFail = False</li>
    <li>Set db = DBEngine(0)(0)</li>
    <li>Set prp = db.CreateProperty(pstrPropertyName, _</li>
    <li>VarType(pvar),pvar)</li>
    <li>If Not ysnFail Then</li>
    <li>ptdf.Properties.Append prp</li>
    <li>End If</li>
    <li>If ysnFail Then</li>
    <li>intSetTableProperty = intHoldErr</li>
    <li>End If</li>
    <li>End If</li>
    <li>Exit Function</li>
    <li>&nbsp;</li>
    <li>PropertyAdd_Err:</li>
    <li>ysnFail = True</li>
    <li>intHoldError = Error</li>
    <li>Resume Next</li>
    <li>End Function</li>
</ul>

<P><b>Figure 1. The Property Manager Add-In showing
the properties for tblMessages.</b></p>

<P><i>Peter Vogel is the applications supervisor at
Champion Road Machinery, a Microsoft Certified Solution
Developer. </i></p>

<P><i>Internet peter.vogel@odyssey.on.ca.</i></p>

<P>&nbsp;</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>: </p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the June 1996
issue of Smart Access. Copyright 1996, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></body>
</html>
