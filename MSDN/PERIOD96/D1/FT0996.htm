<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Create an Automated Development Log (September)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<font face="verdana,arial,helvetica" size="2">
<H1>Create an Automated Development Log</h1>

<P>Doug Hennig</p>

<P><i>Logging programming changes has helped the
staff at Stonefield Systems Group in a lot of ways, including
systems documentation and tracking. It also serves as the
foundation for an automated system of generating incremental
distribution files when a new version of an application is
released. This month's column provides an automated logging tool
that can help you manage these issues.</i></p>

<P>More than a decade ago, I realized that the way I
was managing software development wasn't working. I'd get a
support call from a client, spend a long time trying to figure
out why the client got an error message but my version ran fine,
only to discover that several program components (I like to use
the generic term &quot;modules&quot;) on the client's system
weren't the same as the ones on mine. Sometimes this was caused
by my not installing all the pieces at the client site when a new
version was released, sometimes it was because the client didn't
install the new version I sent them. Either way, I couldn't just
install my copy of the modules on their system; what if those
modules impacted other pieces of the program or what if they
expected that other things (like table structures) had changed? I
needed to know exactly what differences there were between the
version the client had and the one I had.</p>

<P>If you're like me, you're so busy you can hardly
remember what you did last week let alone the details of what
changes you made months ago. I needed a better way to determine
what changes had been made to each module in an application and
when those changes were made. I decided to log every change I
made to every component in every application I've created since
then. Initially, I logged the changes in a Development Worksheet
form, but later I decided to create a FoxPro application and log
the changes to a table, because it made searching for a specific
module (especially library routines used in many applications)
easier. Our log files at Stonefield now have more than 35,000
records.</p>

<P>In this month's column we'll look at a development
logging system we use at Stonefield to record what changes were
made, when they were made, and to what modules in the
applications and tools we develop. Since we started using this
little tool, it has saved us on numerous occasions and also
serves as the basis of an automated system of delivering updates
to people who purchase our tools.</p>

<H2>Advantages of logging changes</h2>

<P>We've found that logging changes made to modules
gives us a lot of advantages:</p>

<ul>
    <li>The documentation for all changes made to all modules in
        an application are in one place. You don't have to scan
        through a dozen program files looking for change
        comments.</li>
    <li>Changes made to library routines can be examined when an
        older application using those routines needs to be
        maintained. In the past, we found that changing a library
        routine occasionally broke applications we hadn't looked
        at in some time after the application was rebuilt using
        the new library routines. The problem, of course, is that
        the only way to find out which parts of the application
        may have been affected is to retest everything. Using the
        development log, you can quickly check which library
        routines have changed since the application was released
        and concentrate on what impact those changes may have
        rather than worrying about every library routine.</li>
    <li>What if a client didn't install the last update you sent
        them? This is especially problematic if you have many
        customers using the application over a wide area. For
        example, Stonefield maintains a retail pharmacy
        application called <i>Pharmacy Partner</i> that's used by
        pharmacies all over two Canadian provinces. It isn't
        unheard of for a pharmacy to not install an update we
        send to them. When it comes time to install yet another
        update or to answer a support call, it's usually
        important to know what differences there are between
        older and newer versions. Having a log of changes allows
        you to go over the incremental differences between the
        versions and prepare to handle any issues that arise
        because of these differences.</li>
    <li>In his book <i>Code Complete</i>, Steve McConnell says
        that frequently changed routines or those previously
        found to be error prone are the most likely to continue
        to contain errors. By examining the history of the
        modules in an application, you can determine which
        modules have been edited the most, and target your
        efforts at cleaning those up or even completely rewriting
        them to eliminate the problems.</li>
    <li>In my experience, if something that used to work stops
        working, it's usually not because a file got corrupted
        but rather because something was changed. The most likely
        culprit is a recently changed program. By looking at the
        development log, you can determine which modules were
        changed and when. The problem is likely related to one of
        the most recent changed modules.</li>
    <li>In a multi-developer or multi-project environment, a
        project manager can tell what others have done on a
        project, which bugs have been fixed, which enhancements
        are finished, and so forth. Frequently I and other
        Stonefield developers are working on several projects at
        once, and the development log is another tool that helps
        me keep track of where I and the others are at in each
        one.</li>
</ul>

<H2>The big payoff: incremental distribution</h2>

<P>As important as logging module changes has been to
us, we recently discovered an even more useful benefit:
automating incremental distribution.</p>

<P>As a tool vendor, we're constantly maintaining our
products: adding new features, correcting defects, and so forth.
The problem: how do you distribute these changes (especially bug
fixes) on a timely and cost-effective basis to a large installed
base? Until recently, we would send out a &quot;maintenance
release&quot; on a floppy disk, but this gets expensive, takes
time to coordinate and distribute, often doesn't get the changes
out to customers as quickly as they're made, and can cause a lot
of headaches (if even five percent of the disks arrive
unreadable, each of those customers is going to phone and we'll
have to send them a replacement disk). We thought about making
the new release available on our Web site, but since a complete
product barely fits on a disk even after it is compressed, that
would make for large files to download. Also, how do you prevent
people who didn't buy your product from downloading the complete
product and getting it for free?</p>

<P>The solution we came up with was to electronically
distribute an incremental set of changes. This keeps the download
file small and allows us to post a new release on our Web site as
often as changes are made. The incremental changes are built into
a FoxPro APP that checks for the existence of a key file that's
part of the original product to ensure the update is being
installed by a legitimate customer. If it can't find the file, it
displays an error message and terminates. Otherwise, it copies
the incremental changes over the original files and updates the
product to the latest version.</p>

<P>The only downside to this process is managing the
creation of the incremental file. How do we track which changes
were made from one release to the next so we can ensure all
changes are distributed? Wait a second, isn't that what the
development log keeps track of? What if we could create an
automated routine that reads the development log file, picks up
the name of all modules changed in a given release, and then
packages them for distribution? We'll see how two routines,
MAKEUPD and INSTUPD, do just that.</p>

<H2>Using the development log</h2>

<P>The development log tool, DEVLOG, is provided on
this month's Developer's Disk in both Visual FoxPro and FoxPro
2.x (cross-platform DOS and Windows) versions. When you run the
appropriate version of DEVLOG.APP, it installs itself in the
FoxPro system menu bar (under the Tools pad in the case of the
VFP version and under the Program pad in the case of FoxPro 2.x),
so it's quickly available when you need it. I run DEVLOG.APP from
my FoxPro startup program (VFPSTART.PRG in the case of VFP and
FOXSTART.PRG in the case of FoxPro 2.x), so it's installed
automatically whenever I start up FoxPro.</p>

<P>Figure 1 shows the VFP version of DEVLOG (the user
interface for the FoxPro 2.x version is a little different but
the functionality is similar). To define the applications you're
working on in DEVLOG, choose the Application page, click on the
New button, and enter the name of the application and a shorthand
code for it. You can also delete applications in this page; doing
so also deletes all log entries for that application, so you're
prompted to ensure you want to do that.</p>

<p><img src="09henni.gif" width="539" height="309"></p>

<P><b>Figure 1. The VFP version of the development
log form.</b></p>

<P>The development log page is where you make log
entries. Select the name of the application from the Application
drop-down list. Then enter the version number of the application
and the date (the default is the current date, or the date
previously entered; this is handy when you are entering batches
of records at a time). Next, either enter the name of the module
(.PRG, .SCX, .FRX, and so on) or choose it from the existing
entries in the Module combo box (when you select the application,
the Module combo is populated with all modules from existing log
entries for this application). Enter a description of the changes
made in the Description edit box and choose the Save button. The
Module and Description controls clear, ready for you to enter the
next log entry for the same application, version, and date.</p>

<P>You can navigate through log entries on the List
page. If you wish to edit one of the entries, click on the Edit
button to activate the first page and place the selected entry in
it. If you wish to add a new entry without saving the selected
one, click on the New button.</p>

<H2>A closer look at the development log</h2>

<P>Unfortunately, the code for DEVLOG, MAKEUPD, and
INSTUPD is too long to publish here (it's available on the
Developer's Disk), but we'll look at a few interesting features
of these routines.</p>

<P>DEVLOG.PRG is a program used by both the VFP and
FoxPro 2.x versions of the development log as the main program in
the application. This means it must handle differences between
these versions. For example, while LOCAL is a valid command in
VFP, it gives a compile error in FoxPro 2.x, so DEVLOG.PRG uses
PRIVATE instead.</p>

<P>If DEVLOG.APP is called without any parameters, it
assumes this is an &quot;installation&quot; call, so DEVLOG.PRG
adds two new bars to the appropriate pad in the system menu bar
(under Tools for VFP and Program for FoxPro 2.x). The first bar
is simply a separator line while the second is &quot;Development
Log.&quot; Of course, if DEVLOG.APP has been run before, we don't
want to add it to the menu again, so we must handle that case:</p>

<P><br>
</p>

<pre> lnBar    = 0
lcPrompt = 'De\&lt;velopment Log'
lcBar    = strtran(lcPrompt, '\&lt;')

* Define the bar and popup used by the current
* version of FoxPro.

if 'Visual' $ version()
    lcPopup = '_MTOOLS'
    lcPad   = '_MSM_TOOLS'
else
    lcPopup = '_MPROG'
    lcPad   = '_MSM_PROG'
endif 'Visual' $ version()</pre>

<P><br>
</p>

<pre> * See if the bar already appears in the menu.

for lnI = cntbar(lcPopup) to 1 step -1
    if prmbar(lcPad, getbar(lcPad, lnI)) = lcBar
        lnBar = lnI
        exit
    endif prmbar(lcPad ...
next lnI

* If the bar isn't already there, add it to the
* appropriate pad.

if lnBar = 0
    lnBar = cntbar(lcPad) + 1
    define bar lnBar     of &amp;lcPad after _mlast ;
        prompt '\-'
    define bar lnBar + 1 of &amp;lcPad after _mlast ;
        prompt lcPrompt
else
    lnBar = lnBar - 1
endif lnBar = 0</pre>

<P>We also have to define what to do when the user
chooses &quot;Development Log&quot; from the menu, and this shows
another interesting idea. We want to avoid adding the directory
where DEVLOG.APP is located to the FoxPro path (if yours is like
mine, it's already cluttered enough), and we don't want to hard
code the location in the install routine, and yet we need to be
able to find the program when the user chooses the function from
the menu. Fortunately, SYS(16) returns the path and name of the
currently executing program, which not coincidentally is the same
one we need to run when the user chooses the menu item, so we can
get the location DEVLOG.APP is running from. We have to do a
little processing of what SYS(16) gives us to extract just the
path, and store the result in the variable lcDirectory. We can
then macro expand this variable in the ON SELECTION statement so
DEVLOG.APP can be found later:</p>

<P><br>
</p>

<pre> lcDirectory = substr(sys(16), ;
    rat(' ', sys(16)) + 1)
lcDirectory = left(lcDirectory, ;
    rat('\', lcDirectory))
on selection bar lnBar + 1 of &amp;lcPad ;
    do locfile('&amp;lcDirectory.DEVLOG.APP', 'APP', ;
    'Locate DEVLOG.APP') with 'Run'
set sysmenu save</pre>

<P>Notice the DO command passes a string to DEVLOG.APP.
This is so when it's called from the menu, it isn't an
&quot;installation&quot; call. The string passed is unimportant,
but I set it to &quot;Run&quot; so it's obvious what we're doing.
Also notice SET SYSMENU SAVE is used so if you later use SET
SYSMENU TO DEFAULT, Development Log is still available in the
menu.</p>

<P>DEVLOG.PRG creates the tables it needs (DEVLOG.DBF,
DEVAPPL.DBF, and DIRECTRY.DBF) if they don't exist. However, in
VFP, we need to ensure that these tables aren't inadvertently
added to any open database, so we need to use the FREE keyword in
the CREATE TABLE command. Since this would cause an error in
FoxPro 2.x, we create a variable called lcFree that either
contains the word FREEor a blank string, depending on the
version, and macro expand it in the CREATE TABLE statement. Thus,
in VFP the effective command is CREATE TABLE FREE, while in
FoxPro 2.x it's CREATE TABLE. To ensure that these tables are
created in the same directory as DEVLOG.APP, which may not be the
current directory, we use the same lcDirectory variable defined
earlier as the directory where the tables should be located:</p>

<P><br>
</p>

<pre> lcFree = iif('Visual' $ version(), 'free', '')
create table (lcDirectory + 'DEVLOG') &amp;lcFree ;
    (APPLIC C(10), ;
    VERSION C(4), ;
    DATE D, ;
    MODULE C(12), ;
    DESCRIP M)</pre>

<P>If DEVLOG.APP isn't called as an
&quot;installation&quot; call (in other words, you selected it
from the menu), it needs to run the appropriate routine:
DEVLOG.SPR in the case of FoxPro 2.x or the DEVLOG form in the
case of Visual FoxPro. Since these two routines are called
differently, DEVLOG.PRG must handle it:</p>

<P><br>
</p>

<pre> lcRun = iif('Visual' $ version(), ;
    'form DEVLOG', 'DEVLOG.SPR')
do &amp;lcRun with lcDirectory</pre>

<P>In the VFP version of the DEVLOG form, we want to
enable only the Save button when all the necessary information
has been entered. The following code was placed in the
InteractiveChange() method of each control:</p>

<P><br>
</p>

<pre> This.Parent.cmdSave.Refresh()</pre>

<P>This.Parent is used instead of Thisform because the
Save button is sitting on the same page in a pageframe as the
other controls. The Refresh() method of the Save button has the
following code:</p>

<P><br>
</p>

<pre> with This.Parent
    This.Enabled = not empty(.cboApplication.Value) and ;
        not empty(.txtDate.Value) and ;
        not empty(.cboModule.DisplayValue) and ;
        not empty(.edtDescription.Value)
endwith</pre>

<P>This ensures that as soon as the user starts typing
something in the last field needing to be filled in, the Save
button is enabled. Putting the call to cmdSave.Refresh() in the
Valid() method of each control instead of InteractiveChange()
would result in the Save button staying disabled until you try to
exit the control.</p>

<P>Because FoxPro 2.x doesn't easily support BROWSE
windows integrated with READ windows, the list of log entries is
implemented as a &quot;pick list&quot; routine instead. When you
choose the Find button, you're asked to select a module. Doing so
then brings up a BROWSE-based pick list of all log entries for
that module. Highlighting one record and pressing Enter brings
that record up for reading or editing.</p>

<H2>MAKEUPD and INSTUPD: Incremental Distribution</h2>

<P>MAKEUPD is provided as a form in VFP (DO FORM
MAKEUPD) and a project and associated files that you can use to
create an APP in FoxPro 2.x (DO MAKEUPD). MAKEUPD is simple: it
asks you to specify which application you're interested in
(including the version) and then creates an incremental
distribution file for that application. It does this by opening
DEVLOG.DBF, finding all entries for the specified application and
version, and then reading each file specified in the MODULE field
in each log record into the memo field of a table called
UPDATE.DBF using the APPEND MEMO FROM command. This table thus
contains the contents of each file changed in this version of the
application.</p>

<P>In addition to DEVLOG.DBF, MAKEUPD relies on a table
called DIRECTRY (which is created the first time you run DEVLOG)
that contains the directories where source code can be found for
each version of an application. MAKEUPD uses this table so it can
find where each of the modules logged in DEVLOG.DBF is located.
If the source code for an application is spread out over more
than one directory, create one record in DIRECTRY for each
directory in the application. MAKEUPD will automatically recurse
to each subdirectory under the defined directories, so you only
have to define the top level directories used for each
application. While you're filling out the contents of DIRECTRY,
enter into the KEYFILE field the name and location of a
&quot;key&quot; file that must exist on the customer's site to
ensure they're a valid owner of the product. </p>

<P>INSTUPD.APP is used at the customer site to update
their copy of the application with the changed files. The UPDATE
table created by MAKEUPD is included in the INSTUPD project. The
main program in INSTUPD.APP is very simple: it ensures the
&quot;key&quot; file for the application can be found (MAKEUPD
puts the name of this file, stored in DIRECTRY, into UPDATE.DBF),
then it copies out each file from the memo field in UPDATE.DBF,
overwriting any existing file on disk or installing a new file.
Thus, INSTUPD updates the application with the most recent set of
files. To create INSTUPD.APP, simply rebuild the INSTUPD project
after running MAKEUPD.</p>

<H2>Improvements</h2>

<P>Although DEVLOG.APP has done yeoman service for us,
several improvements could be made:</p>

<ul>
    <li>There's no built in reporting function. If you need to
        print reports by module, date, or application, those
        reports can easily be created.</li>
    <li>Since VCXs can include many classes and each class can
        have many methods, additional fields could be added to
        DEVLOG.DBF so you can indicate which class inside the VCX
        was changed and which method was affected by the change
        if you want this level of detail in discrete fields.</li>
    <li>The &quot;make update&quot; facility could be integrated
        with DEVLOG.APP.</li>
</ul>

<H2>Conclusion</h2>

<P>If you're using version control software to manage
application development, you probably already have the logging
functionality described in this article. However, many of the
smaller development shops I talk to don't use such software. If
you fall into this category, you'll find DEVLOG as useful as we
have.</p>

<P>Next month we'll look at some &quot;best
practice&quot; ideas for data handling in real world situations.
We'll explore some strategies for handling multiple sets of data
(such as test and production versions) in FoxPro 2.x and VFP,
handling data validation errors, and other issues that come up in
most applications.</p>

<P><i>Doug Hennig is a partner with Stonefield Systems
Group Inc. in Regina, Saskatchewan, Canada. He is the author of
Stonefield's add-on tools for FoxPro developers, including
Stonefield Data Dictionary for FoxPro 2.x and Stonefield Database
Toolkit for Visual FoxPro. He is also the author of The Visual
FoxPro Data Dictionary in Pinnacle Publishing's &quot;The Pros
Talk Visual FoxPro&quot; series. Doug has spoken at user groups
and regional conferences all over North America.
75156,2326@compuserve.com.</i></p>

<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the September 1996
issue of FoxTalk. Copyright 1996, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></body>
</html>
