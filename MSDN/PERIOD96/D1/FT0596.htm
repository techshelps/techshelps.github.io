<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Put Parameters in Perspective (May)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<font face="verdana,arial,helvetica" size="2">
<H1>Put Parameters in Perspective</h1>

<P>Doug Hennig</p>

<P><i>Concentrating on communication between routines
can reduce the number of errors in your applications by up to
one-third. This month's column examines some &quot;Best
Practices&quot; regarding the use of parameters.</i></p>

<P>Last month we discussed the concept of assertions,
which are pieces of code that test assumptions programmers make
to ensure the assumptions are true and the code doesn't break.
This month, we'll discuss parameters. This has a logical tie-in
to last month's column, since assertions are often used for
parameter testing.</p>

<P>Parameters seems like one of those topics that
should be a no-brainer, but good system design requires you to
look at how the different pieces of a system communicate. Studies
cited by Steve McConnell in his book <i>Code Complete</i> found
that 39 percent of all errors are due to internal interface
problems; in other words, modules that don't communicate properly
with each other. Spending time investigating this topic can
reduce the number of errors you encounter by more than one-third.</p>

<P>The first topic to consider is why you should use
parameters in the first place. I can't tell you how many projects
I've taken over from other consultants in which no parameters at
all were used. These systems used public or private variables to
communicate between programs. You can get away with that in the
xBASE languages because a variable is scoped to the routine that
created it and to all of its subroutines. The problem with this
is that it tightly couples a subroutine to the program that
called it. Normally, tight coupling is a bad practice.</p>

<P>Just in case you're fuzzy on this whole
&quot;good-bad&quot; thing, let's discuss coupling for a moment.
&quot;Coupling&quot; refers to how closely two programs are
intertwined. One way to couple two programs is to make one of
them use a lot of assumptions about the other, such as that
certain variables exist and contain certain values. Tightly
coupled routines are like Siamese twins: If they always live
together, the problems are tough enough, but taking them apart
requires very complex surgery.</p>

<P>There are probably a hundred reasons why loose
coupling is better than tight coupling, but here are a few:</p>

<ul>
    <li>If you edit one of the routines, you must look at the
        other routine to ensure that it isn't affected. That
        effectively doubles your maintenance load.</li>
    <li>Tighter coupling reduces portability, since the
        subroutine makes assumptions about the calling program
        that might not be true in a different system.</li>
    <li>A subroutine can inadvertently change the value of
        variables used by the calling routine. Visual FoxPro
        (VFP) introduced LOCAL variables to help reduce coupling,
        since you'll get an error message if you reference a
        variable local to a routine in one of its subroutines.</li>
</ul>

<P>Now that we have that out of the way, let's examine
some &quot;best practices&quot; for parameters.</p>

<H2>LPARAMETERS vs. PARAMETERS</h2>

<P>The PARAMETERS statement accepts parameters passed
to a function and implicitly makes them PRIVATE. This means that
subroutines called by the function can see and possibly change
the value of these parameters. VFP has a new LPARAMETERS
statement that makes the parameters LOCAL, thus hiding them from
any but the current routine. Since there's no downside to using
LPARAMETERS instead of PARAMETERS, always use LPARAMETERS. What
if a routine called by the function needs access to one of the
parameters? Simple&#151;explicitly pass it to the routine. This
reduces coupling between the two routines, so it's always a good
idea.</p>

<H2>Eliminating errors related to parameters</h2>

<P>How many times have you called a little-used FoxPro
function, only to get an error because the number or type of
parameters were incorrect? The error message alerts you to the
fact that the parameters are incorrect, which is better than
returning invalid results or hanging the computer. Your own
functions should do the same&#151;test the number, type, and
range of acceptable values for parameters. FoxPro has built-in
functions to help with this task, including PARAMETERS() and
TYPE().</p>

<P>One thing to watch out for: According to the FoxPro
Help, &quot;The value returned by PARAMETERS( ) is reset every
time a program, procedure, or user-defined function is called or
when ON KEY LABEL is executed.&quot; This means you must test the
value of PARAMETERS() in a function before calling any other
subroutine. I frequently save the value returned by PARAMETERS()
in a variable such as lnParameters so that I can test for the
number of parameters passed to this function, not the last
function called. You can also use the undocumented PCOUNT()
function, which was added in FoxPro 2.6 for dBASE compatibility
and works the way you might expect PARAMETERS() should work.</p>

<P>Although it's riskier, you could reduce the overhead
of parameter testing in an internal function (such as one called
by only one routine or a protected method in a VFP class) by
inserting assertion testing code during development and while
testing the function. You could then remove it from the
production version (see last month's &quot;Best Practices&quot;
column for ideas on assertion testing). Since such a function
will never be called other than from a known routine, you simply
need to ensure that the calling routine passes the correct
parameters to the function.</p>

<P>What should you do when you encounter bad parameters
passed to a function? The most obvious action is to display a
message using WAIT WINDOW or MESSAGEBOX. If you have an error
handler to log the error and gracefully exit the application, you
could also trigger an error in VFP using the ERROR command. The
ERROR command can accept an error number if the error you wish to
trigger matches a built-in VFP error (such as 1229, which is
&quot;too few arguments&quot;). You can also use a custom error
message. Instead of triggering an error, the function could
return a value indicating an error occurred (such as .F. or -1),
it could set a global flag such as glERROR_OCCURRED, or it could
exit the application using CANCEL or by calling an application
exit routine. The action I use most frequently is to display a
message and return a value indicating that an error has occurred.
This puts the onus on the calling routine to test if an error
occurred and to take appropriate action, but this is generally
more flexible than having the function simply exit the
application.</p>

<H2>Don't monkey with input-only parameters</h2>

<P>&quot;Input-only&quot; parameters are those whose
values are passed into the routine and aren't intended to be
changed upon return. Changing the value of input-only parameters
can have unexpected effects. Here's an example: the following
routine is used to determine if a name is a duplicate or not:</p>

<P><br>
</p>

<pre> parameters tcName
local llFound
tcName = upper(alltrim(tcName))
seek tcName
llFound = found()
return llFound</pre>

<P>This code is misleading: it gives the impression
that tcName's value isn't an input-only parameter when it really
should be, since changing the contents of tcName isn't the
intention of the routine. In addition, under certain conditions
this practice can actually cause the contents of a variable
passed to the routine to be changed. Parameters are passed to
procedures by reference, which means any changes made to the
parameters in the procedure are reflected back in the calling
routine. By default, parameters are passed to functions by value,
but that's controlled with the SET UDFPARMS command, and you
can't predict how that might be set on someone else's machine. If
it's set to &quot;REFERENCE&quot;, upon return from this routine,
the variable passed as the name to check has had its contents
trimmed and set in upper-case, which probably isn't desirable.</p>

<P>If you have to alter the contents of input-only
parameters, copy them to local variables and alter the local
variables. Here's the previous routine rewritten following this
idea:</p>

<P><br>
</p>

<pre> parameters tcName
local lcName, llFound
lcName = upper(alltrim(tcName))
seek lcName
llFound = found()
return llFound</pre>

<H2>Number of parameters</h2>

<P>In <i>Code Complete</i>, Steve McConnell suggests
that the number of parameters for a function should be kept to
seven or less. Whenever I break this rule, I pay for it. One
routine in <i>Stonefield Data Dictionary</i>, called LOOK_UP, has
nine parameters, while another called BROWSER has eight. Although
most of these parameters are well-documented both in the header
of each routine and in the user manual, guess which functions I
get the most support calls about?</p>

<P>There are several ways to reduce the number of
parameters needed by a routine. Although it's rarely a good idea,
under certain circumstances using global variables might be
useful. For example, in a FoxPro 2.x security function, instead
of passing the name of the user in a parameter, you could expect
that a global variable (such as gcUSER_NAME) contains it. Since
using global variables has a number of pitfalls, such as
increasing the coupling between a function and the routines that
call it, consider this option very carefully before using it.</p>

<P>Another possibility is to look up the needed
information in a table rather than passing it as a parameter. In
the case of the LOOK_UP and BROWSER functions mentioned earlier,
I couldn't reduce the number of parameters because of backward
compatibility. However, by looking in a table for the value to
use for unpassed parameters, I could limit how many needed to be
passed when called by new applications. Later, we'll discuss this
idea of unpassed or &quot;optional&quot; parameters some more.</p>

<P>VFP provides other solutions as well. For example,
if the function is a method in a class, you can use properties of
the class instead of passing parameters. Another useful technique
is to pass an object to a function. Properties of the object are
then available to the function without explicitly passing them as
parameters. This can also help solve another problem, that of how
to return more than one value from a function, or how to return
any value at all from a form instantiated from a class.</p>

<P>Let's say we have a class based on the Form base
class. The form displays a list of tables to reindex (passed into
the class in an array), a checkbox to indicate if the tables
should also be packed, and OK and Cancel buttons so the user can
decide whether or not to reindex. We want the form to be released
when the user chooses OK or Cancel and to return three sets of
values&#151;an array containing those tables chosen by the user,
a flag set to .T. if the tables should also be packed, and a flag
set to .T. if OK was chosen. The problem: The Show() method used
to display the form doesn't return anything but .T., and once the
form has been released, there's no way to examine any of its
properties.</p>

<P>To solve this, create a Parameter class:</p>

<P><br>
</p>

<pre> define class Parameter as custom
    dimension aParameters[1], aArray[1]
enddefine</pre>

<P>The sole purpose of this class is to act as a
container for values passed into or out of a function. The
aParameters property will contain one row for each individual
value needed, while aArray is used if an array must be passed.</p>

<P>Before calling a function, instantiate an object
from this class and initialize the aParameters and aArray
properties appropriately. Then pass the object to the function.
The function can update the aParameters and aArray properties of
the object before returning, and the calling routine can examine
these properties upon return from the function.</p>

<P>In the following example, we need two single-value
parameters (one, .T., indicates that the tables should be packed
and one indicates that OK was chosen), so the aParameters
property of the Parameter object is dimensioned to 2. The
SelectTablesForm class, which displays the form when its Show()
method is called, accepts the Parameter object in its Init()
method:</p>

<P><br>
</p>

<pre> oParms = createobject('Parameter')
dimension oParms.aParameters[2]
oForm = createobject('SelectTablesForm', oParms)
oForm.Show()</pre>

<P>When the user clicks on the OK button, the form puts
.T. in oParms.aParameters[1] if the pack checkbox was checked,
puts .T. in oParms.aParameters[2], and copies the names of
selected tables into the oParms.aArray property. If the user
clicks on Cancel, it puts .F. in oParms.aParameters[2]. Upon
return, the calling routine can examine the properties of oParms
to determine what actions to take.</p>

<P>The Companion Disk contains these classes and a
program called REINDEX.PRG that calls them.</p>

<P>The downside to passing an object to a function is
that both the function and the calling routine must have
knowledge of the properties of the object and have agreed upon
the structure of the returned values. This increases the coupling
between the function and the calling program.</p>

<H2>Optional parameters</h2>

<P>The simplest function to call is one that needs no
parameters. However, as I mentioned earlier, it's not a good idea
to minimize the number of parameters by increasing the coupling
of the function. Instead, look for opportunities to use optional
parameters. An &quot;optional&quot; parameter is one that can be
passed or not. If the parameter is passed, the function uses it;
if not, the function uses a default value instead or performs its
operation differently. An example of a built-in function that
accepts optional parameters is SEEK(). The first parameter, which
is required, is the value to look for. The second parameter, the
table to look in, is optional: if it isn't passed, the table in
the current work area is used. The VFP version of SEEK() supports
a third optional parameter, the tag to use. If it isn't
specified, SEEK() uses the current order for the table.</p>

<P>The advantage of using optional parameters is that
they usually make calling a function easier (there'll be fewer
parameters to type&#151;or even remember), yet provide additional
functionality when required.</p>

<P>There are a couple of ways you can detect if an
optional parameter was passed or not. You can use PARAMETERS() to
determine how many parameters were passed, and, if the number is
smaller than expected, assume that one or more optional
parameters were omitted. My preferred approach, however, is to
test the type of optional parameters. Unpassed parameters are
logical with a value of .F., so TYPE() returns &quot;L&quot; for
unpassed parameters. If that parameter should be logical even if
it's passed, no harm is done.</p>

<P>Here's a routine that handles optional parameters.
It's a wrapper program for the VFP ESSAGEBOX() function, one that
handles Yes or No questions only and returns .T. if the user
chose Yes or .F. if they chose No (this program is called YN.PRG
on the Companion Disk). The first parameter, which is required,
is the message to display. The second, which is optional, is the
title for the message box. If it isn't passed, the title of the
main VFP window is used. The third parameter, which also is
optional, is the default value for the function. If .T. is
passed, the Yes button is the default. If .F. is passed or isn't
passed at all (we don't care which), the No button is the
default:</p>

<P><br>
</p>

<pre> function YN
lparameters tcMessage, tcTitle, tlDefault
#include '\VFP\FOXPRO.H'
local lcTitle, llDefault
lcTitle = iif(type('tcTitle') = 'L', ;
  _screen.Caption, tcTitle)
return messagebox(tcMessage, ;
  MB_YESNO + MB_ICONQUESTION + ;
  iif(tlDefault, MB_DEFBUTTON1, MB_DEFBUTTON2), ;
  lcTitle) = IDYES</pre>

<P>Here are several examples of calling this function
(this code is in TESTYN.PRG on the Companion Disk):</p>

<P><br>
</p>

<pre> YN('Delete this record?')
YN('A serious error occurred. Terminate the ' + ;
  'application?', 'Application Error', .T.)
YN('Exiting system. Save current record?',, .T.)</pre>

<P>Notice the use of a double comma in the last
example. In FoxPro 2.x, you couldn't leave out a parameter in the
middle of a list of parameters; you had to provide a
&quot;dummy&quot; parameter (such as a blank string or .F.) in
its place. In VFP, you can simply omit the unpassed parameter by
entering nothing between its comma and the one following.</p>

<P>Although YN handled an unpassed tcTitle by assigning
a hard-coded default value to it (the screen's caption), if the
function is a method in a class, a better mechanism to use is to
have a property of the class contain the default to use. For
example, assume YN is a method in a general message handling
class. The class has a property called cTitle that's used as the
default title for all message boxes if a title isn't passed to a
method. In this case, this would be the line that assigns
lcTitle:</p>

<P><br>
</p>

<pre> lcTitle = iif(type('tcTitle') = 'L', ;
    This.cTitle, tcTitle)</pre>

<P>The Companion Disk includes a class called
MessageMgr with a YN method. TESTYN.PRG shows the same examples
calling this method as it did calling YN.PRG.</p>

<P>The advantage of this approach is flexibility. The
developer can specify the title to use once, then not have to
pass the title parameter unless it must be different for a
particular message box.</p>

<H2>Order of parameters</h2>

<P>While the order in which parameters are passed may
not seem important, it can make using a function easier. For
example, I was tired of constantly using ASCAN() followed by
ASUBSCRIPT() to find the row for a value in a multi-dimensional
array. Since laziness, not necessity, is the mother of invention,
I wrote a function called ArrayScan() that, when passed an array
and a value, returns the row where the value is found in the
array. Although the order of the parameters didn't matter, I
opted to pass the array first and the value second because that's
the order of parameters for ASCAN(). Now I don't have to remember
two different parameter schemes for similar functions; both
ASCAN() and ArrayScan() accept the same parameters, but
ArrayScan() works a bit differently.</p>

<P>To minimize the use of &quot;dummy&quot; parameters
or double commas when calling a function that supports optional
parameters, order the parameters in the order of likelihood of
use, with mandatory ones first. For example, if you expect to
specify the default button more often than the title for the
message box, the following would be a better choice for the order
of the parameters in the YN function examined earlier:</p>

<P><br>
</p>

<pre> lparameters tcMessage, tlDefault, tcTitle</pre>

<H2>Conclusion</h2>

<P>I hope this article has given you some ideas to
consider on a topic that you might have thought straight-forward.
Properly concentrating on communication between the routines in
your applications can go a long way toward eliminating errors.</p>

<P>Speaking of errors, next month we're going to
examine error handling in VFP. This can be a complex subject, so
we'll spend a couple of columns investigating the issues and take
a look at a general error handling class.</p>

<P><i>Doug Hennig is a partner with Stonefield
Systems Group Inc. in Regina, Saskatchewan, Canada. He is author
of Stonefield's add-on tools for FoxPro developers, including
Stonefield Data Dictionary for FoxPro 2.x and Stonefield Database
Toolkit for Visual FoxPro. He is also the author of The Visual
FoxPro Data Dictionary in Pinnacle Publishing's The Pros Talk
Visual FoxPro series. Doug has spoken at user groups and regional
conferences all over North America. CompuServe 75156,2326.</i></p>

<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the May 1996 issue
of FoxTalk. Copyright 1996, by Pinnacle Publishing, Inc., unless
otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></body>
</html>
