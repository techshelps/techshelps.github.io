<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Adobe application">
<meta name="Template" content="D:\CDs\templates\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Applied Reusability (August)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Applied Reusability</b></font></p>
    <p><font size="2">Phil Burtis</font></p>
    <p><font size="2"><i>Here Phil describes a generic VB4
    routine for sorting and finding field names in an Access/Jet
    database. He adds his own table with database metadata and,
    by adding two variables for each field name, creates a
    generic sort and find combo box capability that can readily
    be added to almost any application.</i></font></p>
    <p><font size="2">MAYBE it&#146;s just me, but it seems like
    all the applications I work on have a lot in common and that
    I end up recoding or at least modifying existing routines for
    every new project that comes along. VB4 was supposed to help
    minimize that, so I finally decided to see if the promise is
    true.</font></p>
    <p><font size="2">Many applications let users find a specific
    record within the recordset presently on the screen. I wanted
    to create a generic capability to provide not only find, but
    also sort functionality using VB4 (see Figure 1). </font></p>
</blockquote>

<p><font size="2" face="Palatino,Book Antiqua"><img
src="Image17.gif" width="299" height="334"></font></p>

<blockquote>
    <p><font size="2"><b>Figure 1. The project&#146;s test
    screen.</b></font></p>
    <p><font size="2">Note the small database display using text
    fields bound to a data control and the two combo boxes. The
    requirements for the project were that the combo boxes
    contain the field names of the database table shown on the
    display, and that by selecting a table field from the sort
    combo box, the display would be sorted on that field.
    Similarly, when the user selected a table field in the find
    combo box and provided a value, the first/next record in the
    database with that field matching the given value would be
    displayed. I also wanted to be able to change both the field
    names that appeared in the combo boxes and the order in which
    they appeared without code changes.</font></p>
    <p><font size="2">The solution I came up with was to add a
    new table called SortFind to the database. SortFind contains
    the name and type of each field in the main table in the
    database and has two columns to contain order indexes for
    both sorting and finding. The combo boxes can be filled with
    the names from this table and sorted by the order index when
    it isn&#146;t zero. Figure 2 shows a sample SortFind table.
    Notice that by numbering in increments of five or 10, you can
    later insert or reorder the way the combo boxes are filled.
    (For those who remember the days when BASIC had line numbers,
    you&#146;ll recognize the genesis of this idea.)</font></p>
</blockquote>

<p><font size="2" face="Palatino,Book Antiqua"><img
src="Image18.gif" width="573" height="141"></font></p>

<blockquote>
    <p><font size="2"><b>Figure 2. A sample SortFind table.</b></font></p>
    <p><font size="5"><b>The cFieldDef class</b></font></p>
    <p><font size="2">With the requirements and design in place,
    let&#146;s proceed with the implementation. The ability to
    create the SortFind table must exist to get started, so the
    first task is to develop a generic table making function. A
    table is a group of fields, and a field has a name, type,
    size, and possibly attributes. You need to be able to define
    those parameters for our SortFind table. A class seems like
    the natural choice in an object-oriented scheme. Classes are
    added into your VB project using the Insert Class Module
    command. Each class module has a generic section for
    variables and functions, and two specific functions:
    Class_Initialize for initializing an instance of this class
    when it&#146;s created and Class_Terminate for destroying
    that instance when it&#146;s closed (Set Obj = Nothing).</font></p>
    <p><font size="2">Listing 1 shows the class module for a
    class cFieldDef. This class has private members to contain
    the name, type, length, and attribute definitions for a
    field. It has procedures to Set and Get each of those
    members.</font></p>
    <p><font size="2"><b>Listing 1</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b>. </b></font><font
    size="2"><b>The class module for cFieldDef.</b></font></p>
    <p><font size="2" face="Courier New">'Class Name: cFieldDef</font></p>
    <p><font size="2" face="Courier New">'Originator: philb,
    Polar Bear Systems</font></p>
    <p><font size="2" face="Courier New">'Description: Defines a
    database table field</font></p>
    <p><font size="2" face="Courier New">'Functions: Let and Get
    for each private member</font></p>
    <p><font size="2" face="Courier New">'Version: 6.124.1</font></p>
    <p><font size="2" face="Courier New">Option Explicit</font></p>
    <p><font size="2" face="Courier New">'--- Public members
    ----------------------</font></p>
    <p><font size="2" face="Courier New">'--- Private members
    ----------------------</font></p>
    <p><font size="2" face="Courier New">Private m_FldName As
    String 'field name</font></p>
    <p><font size="2" face="Courier New">Private m_FldType As
    Integer 'field type</font></p>
    <p><font size="2" face="Courier New">Private m_FldLength As
    Integer 'field length </font></p>
    <p><font size="2" face="Courier New">'(if type = string)</font></p>
    <p><font size="2" face="Courier New">Private m_FldAttrib As
    Long 'field attributes</font></p>
    <p><font size="2" face="Courier New">Public Property Get
    FldAttrib() As Long</font></p>
    <p><font size="2" face="Courier New">FldAttrib = m_FldAttrib</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Let
    FldAttrib(lAttrib As Long)</font></p>
    <p><font size="2" face="Courier New">m_FldAttrib = lAttrib</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Get
    FldLength() As Integer</font></p>
    <p><font size="2" face="Courier New">FldLength = m_FldLength</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Let
    FldLength(iLen As Integer)</font></p>
    <p><font size="2" face="Courier New">m_FldLength = iLen</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Get
    FldName() As String</font></p>
    <p><font size="2" face="Courier New">FldName = m_FldName</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Let
    FldName(sName As String)</font></p>
    <p><font size="2" face="Courier New">m_FldName = sName</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Get
    FldType() As Integer</font></p>
    <p><font size="2" face="Courier New">FldType = m_FldType</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2" face="Courier New">Public Property Let
    FldType(iType As Integer)</font></p>
    <p><font size="2" face="Courier New">m_FldType = iType</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2">Using this class, you can define a new
    field using code like this:</font></p>
    <p><font size="2" face="Courier New">Dim MyField as New
    cFieldDef 'will call <i>Class_Initialize</i></font></p>
    <p><font size="2" face="Courier New">MyField.FldName =
    &quot;Counter&quot;</font></p>
    <p><font size="2" face="Courier New">MyField.FldType = dbLong</font></p>
    <p><font size="2" face="Courier New">MyField.FldAttrib =
    dbAutoIncrField</font></p>
    <p><font size="2" face="Courier New">Set MyField = Nothing
    'will call <i>Class_ Terminate</i></font></p>
    <p><font size="2">You may ask why you need a class
    here&#151;wouldn&#146;t a regular Field class work? Perhaps
    it would. My only justification is that the VB4 book
    recommends against using DAO objects when they aren&#146;t
    directly related to a database object, and it also just
    seemed better to have an additional level of abstraction in
    case in some implementation a field turned out different
    somehow.</font></p>
    <p><font size="2">Anyway, a field all by itself isn&#146;t
    too useful. But a group of fields makes up a table, so the
    next step is to make a collection of fields, which can be
    done using a <i>collection</i> object.</font></p>
    <p><font size="5"><b>The cFieldDefs collection class</b></font></p>
    <p><font size="2">Since in this case you only need a
    collection of fields to pass them to a routine to create a
    table, a very simple sequential collection will work fine.
    Listing 2 shows the class module for a class cFieldDefs. Its
    members are a collection of cFieldDef instances and a counter
    used to sequentially retrieve each instance. There are two
    functions: FldAdd(), which will add an instance to the
    collection, and FldGetNext(), which retrieves each one in
    order. Note that FldAdd() uses optional parameters for length
    and attributes, since many fields won&#146;t need them.
    Class_Initialize sets a counter to zero; Class_Terminate
    removes all instances from the collection. </font></p>
    <p><font size="2"><b>Listing 2.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>Class module for cFieldDefs using a collection.</b></font></p>
    <p><font size="2" face="Courier New">'Class Name: cFieldDefs</font></p>
    <p><font size="2" face="Courier New">'Originator: philb,
    Polar Bear Systems</font></p>
    <p><font size="2" face="Courier New">'Description: Maintains
    a collection of cFieldDef</font></p>
    <p><font size="2" face="Courier New">' fields(a collection of
    fields, is in effect, </font></p>
    <p><font size="2" face="Courier New">'a table)</font></p>
    <p><font size="2" face="Courier New">'Functions: Add to and
    GetNext from collection</font></p>
    <p><font size="2" face="Courier New">'Version: 6.124.2</font></p>
    <p><font size="2" face="Courier New">Option Explicit</font></p>
    <p><font size="2" face="Courier New">'--- Public members
    ----------------------</font></p>
    <p><font size="2" face="Courier New">'--- Private members
    ----------------------</font></p>
    <p><font size="2" face="Courier New">'the field definition</font></p>
    <p><font size="2" face="Courier New">Private m_FieldDefs As
    New Collection </font></p>
    <p><font size="2" face="Courier New">'the pointer to the next
    field to extract</font></p>
    <p><font size="2" face="Courier New">Private
    m_GetNext_Counter As Integer</font></p>
    <p><font size="2" face="Courier New">'Add a new field to the
    collection.</font></p>
    <p><font size="2" face="Courier New">'As only retrieval is
    needed at this point</font></p>
    <p><font size="2" face="Courier New">'this is sequential, no
    key index is used.</font></p>
    <p><font size="2" face="Courier New">'Note also that since
    only a name and type is needed,</font></p>
    <p><font size="2" face="Courier New">'len and attribs are
    optional. len is only needed</font></p>
    <p><font size="2" face="Courier New">'for strings, and
    attribs are almost always optional</font></p>
    <p><font size="2" face="Courier New">'Inputs:</font></p>
    <p><font size="2" face="Courier New">' name of field to add</font></p>
    <p><font size="2" face="Courier New">' type of the field
    (dbType)</font></p>
    <p><font size="2" face="Courier New">' [length of the field]
    (useful only for </font></p>
    <p><font size="2" face="Courier New">' type = dbText)</font></p>
    <p><font size="2" face="Courier New">' [attributes of the
    field]</font></p>
    <p><font size="2" face="Courier New">'Outputs:</font></p>
    <p><font size="2" face="Courier New">' none</font></p>
    <p><font size="2" face="Courier New">Public Function
    FldAdd(Name As String, DBType _</font></p>
    <p><font size="2" face="Courier New">As Integer, Optional
    Size As Variant, Optional _</font></p>
    <p><font size="2" face="Courier New">Attributes As Variant)</font></p>
    <p><font size="2" face="Courier New">Dim NewField As New
    cFieldDef</font></p>
    <p><font size="2" face="Courier New">With NewField</font></p>
    <p><font size="2" face="Courier New">.FldName = Name</font></p>
    <p><font size="2" face="Courier New">.FldType = DBType</font></p>
    <p><font size="2" face="Courier New">'optionals</font></p>
    <p><font size="2" face="Courier New">If IsMissing(Size) Then</font></p>
    <p><font size="2" face="Courier New">.FldLength = 0</font></p>
    <p><font size="2" face="Courier New">Else</font></p>
    <p><font size="2" face="Courier New">.FldLength = CInt(Size)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">If IsMissing(Attributes)
    Then</font></p>
    <p><font size="2" face="Courier New">.FldAttrib = 0</font></p>
    <p><font size="2" face="Courier New">Else</font></p>
    <p><font size="2" face="Courier New">.FldAttrib =
    CLng(Attributes)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">End With</font></p>
    <p><font size="2" face="Courier New">m_FieldDefs.Add NewField</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2" face="Courier New">'Retrieve the next field
    in line sequentially from</font></p>
    <p><font size="2" face="Courier New">'the collection. Return
    value is the current count:</font></p>
    <p><font size="2" face="Courier New">'when it returns 0 there
    is no more data to </font></p>
    <p><font size="2" face="Courier New">'be retrieved.</font></p>
    <p><font size="2" face="Courier New">'Usage, therefore:</font></p>
    <p><font size="2" face="Courier New">'While FldGetNext(parms)</font></p>
    <p><font size="2" face="Courier New">' deal with parms</font></p>
    <p><font size="2" face="Courier New">'Wend</font></p>
    <p><font size="2" face="Courier New">'Inputs:</font></p>
    <p><font size="2" face="Courier New">' none</font></p>
    <p><font size="2" face="Courier New">'Outputs:</font></p>
    <p><font size="2" face="Courier New">' name of field</font></p>
    <p><font size="2" face="Courier New">' type of the field
    (dbType)</font></p>
    <p><font size="2" face="Courier New">' length of the field
    (useful only for </font></p>
    <p><font size="2" face="Courier New">' type = dbText)</font></p>
    <p><font size="2" face="Courier New">' attributes of the
    field</font></p>
    <p><font size="2" face="Courier New">'Returns:</font></p>
    <p><font size="2" face="Courier New">' 0 at end of
    collection; else item number</font></p>
    <p><font size="2" face="Courier New">Public Function
    FldGetNext(sName As String, iType _</font></p>
    <p><font size="2" face="Courier New">As Integer, iLen As
    Integer, lAttrib As Long) _</font></p>
    <p><font size="2" face="Courier New">As Integer</font></p>
    <p><font size="2" face="Courier New">If m_FieldDefs.Count
    &gt; m_GetNext_Counter Then</font></p>
    <p><font size="2" face="Courier New">m_GetNext_Counter =
    m_GetNext_Counter + 1</font></p>
    <p><font size="2" face="Courier New">sName =
    m_FieldDefs(m_GetNext_Counter).FldName</font></p>
    <p><font size="2" face="Courier New">iType =
    m_FieldDefs(m_GetNext_Counter).FldType</font></p>
    <p><font size="2" face="Courier New">iLen =
    m_FieldDefs(m_GetNext_Counter).FldLength</font></p>
    <p><font size="2" face="Courier New">lAttrib =
    m_FieldDefs(m_GetNext_Counter).FldAttrib</font></p>
    <p><font size="2" face="Courier New">Else</font></p>
    <p><font size="2" face="Courier New">m_GetNext_Counter = 0</font></p>
    <p><font size="2" face="Courier New">sName = &quot;&quot;</font></p>
    <p><font size="2" face="Courier New">iType = 0</font></p>
    <p><font size="2" face="Courier New">iLen = 0</font></p>
    <p><font size="2" face="Courier New">lAttrib = 0</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">FldGetNext =
    m_GetNext_Counter</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2">Using this class, you can define a new
    table definition using code like this:</font></p>
    <p><font size="2" face="Courier New">'will call <i>Class_Initialize</i></font></p>
    <p><font size="2" face="Courier New">Dim MyFieldDefs As New
    cFieldDefs </font></p>
    <p><font size="2" face="Courier New">MyFieldDefs.FldAdd,
    &quot;Counter&quot;, dbLong, 0, _</font></p>
    <p><font size="2" face="Courier New">dbAutoIncrField</font></p>
    <p><font size="2" face="Courier New">MyFieldDefs.FldAdd
    &quot;StringField&quot;, dbText, 50</font></p>
    <p><font size="2" face="Courier New">MyFieldDefs.FldAdd
    &quot;IntField&quot;, dbInteger</font></p>
    <p><font size="2" face="Courier New">'will call <i>Class_
    Terminate</i></font></p>
    <p><font size="2" face="Courier New">Set MyFieldDefs =
    Nothing </font></p>
    <p><font size="2">At this point you have an interesting
    capability forming. Assuming in a moment you&#146;ll have a
    way to actually create an Access table with cFieldDefs, you
    could put a loop in a routine like the previous one to read a
    text file or an .INI file. If you did that, you could then
    create Access tables easily just by typing definitions in a
    text file. Especially during initial development, the ability
    to easily create, destroy, and re-create tables is often very
    handy. So already you may be getting some benefit from
    classes and collections.</font></p>
    <p><font size="5"><b>Create a table</b></font></p>
    <p><font size="2">The next step is to actually create a table
    using the cFieldDefs collection. Listing 3 shows a function
    that does just that. It deletes the table to start from
    scratch, then re-creates it using db.CreateTableDef(). It
    then loops through the cFieldDefs collection adding each
    field to the new table using tbdef.CreateField() as it goes.
    When all the fields are added, it commits the new table into
    the database. To loop through the cFieldDefs collection, it
    uses the following: </font></p>
    <p><font size="2" face="Courier New">While
    FldDefs.FldGetNext() É Wend</font></p>
    <p><font size="2">The FldGetNext() function is set up to
    return the next sequential instance in the collection until
    all of them have been returned, and then it returns 0.</font></p>
    <p><font size="2"><b>Listing 3.</b></font><font
    color="#008080" size="2" face="MyriaMM_565 SB 600 NO"><b> </b></font><font
    size="2"><b>Create a table using cFieldDefs.</b></font></p>
    <p><font size="2" face="Courier New">'This routine adds a
    table to an open database,</font></p>
    <p><font size="2" face="Courier New">'and sets up that table
    per the incoming field</font></p>
    <p><font size="2" face="Courier New">'definitions. Note if
    the table exists it will</font></p>
    <p><font size="2" face="Courier New">'delete it and re-create
    it.(This ended up being </font></p>
    <p><font size="2" face="Courier New">'faster than deleting
    each element on big tables.)</font></p>
    <p><font size="2" face="Courier New">'Inputs:</font></p>
    <p><font size="2" face="Courier New">' open database pointer</font></p>
    <p><font size="2" face="Courier New">' valid table name</font></p>
    <p><font size="2" face="Courier New">' valid cFieldDef class</font></p>
    <p><font size="2" face="Courier New">'Returns</font></p>
    <p><font size="2" face="Courier New">' 0 on success; else
    error code</font></p>
    <p><font size="2" face="Courier New">Public Function
    nAccessTableCreate(DB As Database, _</font></p>
    <p><font size="2" face="Courier New">sTableName As String,
    FldDefs As cFieldDefs) _</font></p>
    <p><font size="2" face="Courier New">As Integer</font></p>
    <p><font size="2" face="Courier New">Dim sName As String
    'field name</font></p>
    <p><font size="2" face="Courier New">Dim iType As Integer
    'field type</font></p>
    <p><font size="2" face="Courier New">Dim lAttrib As Long
    'field attributes</font></p>
    <p><font size="2" face="Courier New">Dim iLen As Integer
    'field length</font></p>
    <p><font size="2" face="Courier New">Dim TBDef As TableDef
    'new table definition</font></p>
    <p><font size="2" face="Courier New">Dim Fld As Field 'field
    definition</font></p>
    <p><font size="2" face="Courier New">On Error Resume Next
    'not to worry if not there</font></p>
    <p><font size="2" face="Courier New">DB.TableDefs.Delete
    sTableName 'delete the table</font></p>
    <p><font size="2" face="Courier New">DB.TableDefs.Refresh</font></p>
    <p><font size="2" face="Courier New">Err = 0</font></p>
    <p><font size="2" face="Courier New">On Error GoTo ATC_ErrHnd
    'set up to handle errors</font></p>
    <p><font size="2" face="Courier New">BeginTrans</font></p>
    <p><font size="2" face="Courier New">'create new table</font></p>
    <p><font size="2" face="Courier New">Set TBDef =
    DB.CreateTableDef(sTableName)</font></p>
    <p><font size="2" face="Courier New">'for each field in the
    incoming definitions...</font></p>
    <p><font size="2" face="Courier New">While
    FldDefs.FldGetNext(sName, iType, _</font></p>
    <p><font size="2" face="Courier New">iLen, lAttrib)</font></p>
    <p><font size="2" face="Courier New">'create it</font></p>
    <p><font size="2" face="Courier New">Set Fld =
    TBDef.CreateField(sName, _</font></p>
    <p><font size="2" face="Courier New">iType, iLen)</font></p>
    <p><font size="2" face="Courier New">Fld.Attributes = lAttrib</font></p>
    <p><font size="2" face="Courier New">'add it</font></p>
    <p><font size="2" face="Courier New">TBDef.Fields.Append Fld</font></p>
    <p><font size="2" face="Courier New">Wend</font></p>
    <p><font size="2" face="Courier New">'add the table</font></p>
    <p><font size="2" face="Courier New">DB.TableDefs.Append
    TBDef</font></p>
    <p><font size="2" face="Courier New">CommitTrans</font></p>
    <p><font size="2" face="Courier New">nAccessTableCreate = Err</font></p>
    <p><font size="2" face="Courier New">Exit Function</font></p>
    <p><font size="2" face="Courier New">ATC_ErrHnd:</font></p>
    <p><font size="2" face="Courier New">nAccessTableCreate = Err</font></p>
    <p><font size="2" face="Courier New">On Error Resume Next</font></p>
    <p><font size="2" face="Courier New">Rollback</font></p>
    <p><font size="2" face="Courier New">Exit Function</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2">If you&#146;re new to VB4, step back and
    think for a moment how you might have done this in VB3. You
    probably would have made a user Type variable to represent
    the cFieldDef. You&#146;d then have made an array of those
    where you now have cFieldDefs. There would most likely have
    been a bunch of ReDim Preserves going on, and some loops to
    cycle through such as the following: </font></p>
    <p><font size="2" face="Courier New">For I = 0 to
    Ubound(cFieldDefs) É Next I</font></p>
    <p><font size="2">And probably the array would have had
    fairly wide, if not global, scope. Usable? Probably. As easy
    to use, reuse, and maintain as the new method? Probably not.</font></p>
    <p><font size="5"><b>The cSortFind class</b></font></p>
    <p><font size="2">If a little class is good, more class must
    be better? The next step after creating the SortFind table is
    to read from it to fill in the combo boxes. I originally
    created some plain old functions to do that. But since this
    is supposed to be object oriented, wouldn&#146;t it make
    sense to encapsulate them into a single class? The cSortFind
    class came into being. It needs to know three things from the
    external world: the name of the database where the main table
    is, the main table name, and get a handle to any combo box
    that needs filling. The first two come from the Init()
    procedure. So to set up to use the class, you need the
    following lines:</font></p>
    <p><font size="2" face="Courier New">Dim MySortFind As
    cSortFind</font></p>
    <p><font size="2" face="Courier New">'will call <i>Class_Initialize</i></font></p>
    <p><font size="2" face="Courier New">Set MySortFind = New
    cSortFind </font></p>
    <p><font size="2" face="Courier New">MySortFind.Init DBName,
    TableName [,True]</font></p>
    <p><font size="2">The Init() function optional parameter True
    forces creation of a new SortFind table in cases where you
    know you must do so (like in the case of just creating the
    main database). Once it&#146;s set up, then to fill in a
    combo box you need one of these calls:</font></p>
    <p><font size="2" face="Courier New">MySortFind.ComboFillSort
    comboBox</font></p>
    <p><font size="2" face="Courier New">MySortFind.ComboFillFind
    comboBox</font></p>
    <p><font size="2">Is this a good use of a class? Well, it <i>does</i>
    encapsulate a handful of related functions, butin reality the
    same routines in a regular module that were marked private
    and had some static variables would function pretty much the
    same. It <i>does</i> keep you from calling ComboFill before
    at least setting a new class. And it returns gracefully if
    the Init() function hasn&#146;t been called. It might be nice
    if ComboFill would automatically create the SortFind table if
    there isn&#146;t one; it could do that since it knows the
    name of main table. And it might be nice if, when creating a
    SortFind table, it would keep one if already there and just
    process the changes so any of your manual changes to the
    index variables would stay in effect. Maybe it isn&#146;t
    such a bad use of class after all: anytime you have a better
    way to do something and you can keep that encapsulated in one
    place without external interface changes is good. And without
    much work you could create different instances pointing to
    different SortFind tables, maybe one for each user so they
    could customize it? Hmmm, food for thought.</font></p>
    <p><font size="5"><b>The demo project</b></font></p>
    <p><font size="2">One immediate benefit of all this is that
    to create a sample database for the project (available on
    your Developer&#146;s Disk), it was really quite easy to just
    hard code up a small sample table to start from. So if you
    click on the Make Test DB button on the demo, it will create
    a small database that represents a very simple
    problem-reporting application (not that any of us would have
    any problems to track, of course). By the way, if you should
    run the demo before you look at the code, you&#146;ll find it
    defaults to creating a database of
    {windows_temp}\sortfind.mdb. If you happen to have a file in
    your windows temp directory named that, it will delete it.
    Beware. It will then add the SortFind table. You can use
    Access or DataManager to change the contents of the SortFind
    table, and pressing Run Demo will cause the combo boxes to
    get filled in again based on your changes. This makes it easy
    to use the sort and find functions without needing to know
    the real field names in the database or hard code what the
    user could do. In the real application where this code is
    used, both the sort and find commands bring up separate forms
    that can be made to stay on top, and give multiple sort and
    find options: up to three sort fields can be set and you can
    find the first, next, or all records that meet your criteria,
    which can be either an exact match or a &quot;like&quot;
    match of the selected field.</font></p>
    <p><font size="2">By using the class and collection objects
    in VB4, you can create generic, solid, maintainable functions
    that let you create Access tables quite conveniently, and
    then use those functions to allow users to pick specific
    fields in the database to use to find and display their
    records. </font></p>
    <p><font size="2"><i>Phil Burtis has his own consulting
    company, Polar Bear Systems, and is also currently manager of
    software development for BE Aerospace Inc. of Irvine,
    California. CompuServe 74354,273.</i></font></p>
    <p>&nbsp;</p>
    <P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong><a href="http://www.pinpub.com/vbd/"> <strong>http://www.pinppub.com/vbd/
    </strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for i's content.</font></p>
    <p><font size="1">This article is reproduced from the August
    1996 issue of Visual Basic Developer. Copyright 1996, by
    Pinnacle Publishing, Inc., unless otherwise noted. All rights
    are reserved. Visual Basic Developer is an independently
    produced publication of Pinnacle Publishing, Inc. No part of
    this article may be used or reproduced in any fashion (except
    in brief quotations used in critical articles and reviews)
    without prior consent of Pinnacle Publishing, Inc. To contact
    Pinnacle Publishing, Inc., please call (800)&nbsp;788-1900 or
    (206)&nbsp;251-1900.</font></p>
</blockquote>
</font></body>
</html>
