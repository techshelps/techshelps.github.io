<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Create Word Letters with One Keystroke (September)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<H1>Create Word Letters with One Keystroke</h1>

<P>Stu Alderman</p>

<P><i>Getting two applications to work together in a
complementary and seamless fashion requires some effort, but the
rewards are worth it. Stu shows you how to use OLE Automation to
make Access create Word letters with a single keystroke.</i></p>

<P>I've used a number of contact and address management
packages over the years and each lacks one feature I've always
wanted: the ability to create and address a standard business
letter for the current contact with a single keystroke. While
most packages can export data or create merge lists, it's so
awkward to create a single letter that I usually just cut and
paste the data over to Word as I need it. I recently worked on a
project where this capability would be valuable, so I dug out all
the references I could find and proceeded to write my own.</p>

<P>In this article I'll present a small Access
application called Contact that maintains contact information and
addresses letters to the contacts on demand. In addition to
standard demographics, Contact also maintains an optional title
and salutation that you may use in the letter. In the event you
don't enter the title or salutation, Contact will make
intelligent decisions on how to address the letter. Your
personalized complementary closure will be included as well as a
custom Word macro, if you desire.</p>

<P>By making the process of creating business letters
easy, users are more likely to correspond with their contacts on
a regular basis. Both the time impact to the user and the quality
of the correspondence are improved. In many situations, regular
written correspondence can improve the contact relationship and
yield better results in a business association.</p>

<P>On the Developer's Disk, you'll find both Access 95
and Access 2.0 versions of the sample FileOpen
&quot;D:\ACCSMART\96_09\Proof\CONTACT.doc&quot; databases. In
this article, I'll present the Access 95 version of the code.
Most of the code is identical in the Access 2.0 version&#151;the
differences are highlighted in an accompanying sidebar. </p>

<H2>Application overview</h2>

<P>The sample application, Contact, contains a single
table, tblContacts that maintains a variety of information about
each contact you enter. Standard data for names, addresses, and
phone numbers is maintained as well as title, salutation, and
general notes fields. Adds, changes, and deletes are all
performed from the main application form, frmContMaint (see
Figure 1). The Finder combo box in the Form Header section can
quickly locate records based on the contact name. Additional
command buttons are supplied to create the business letter as
well as set user options.</p>

<p><img src="contact1.gif" width="519" height="328"></p>

<P><b>Figure 1. FrmContMaint is used for all
day-to-day operations of maintaining contact information and
generating business letters. </b></p>

<P>The Options command button on frmContMaint launches
a custom dialog box using frmOptions for setting user based
information (see Figure 2). Data items set using frmOptions are
global, fairly static, and best stored in the Windows registry.
Microsoft introduced the enhanced version of the registry with
Windows 95 and is encouraging all developers to use it for
storing this type of application-specific data. Previous versions
of Windows relied on initialization (.INI) files to store similar
data, but starting with Windows 95 you'll see less and less
reliance on .INI files. (The 2.0 version of this application uses
.INI files.)</p>

<p><img src="contact2.gif" width="348" height="236"></p>

<P><b>Figure 2. FrmOptions is used to maintain
personalized data in the Windows registry. </b></p>

<P>As with all Windows applications, you have to
consciously balance the features, capabilities, and resiliency
you want your application to have against how much development
effort is reasonable. The Contact sample application addresses
the following functional requirements:</p>

<ul>
    <li>The application should try to locate the Word executable
        file without user intervention. If the executable file
        can't be found or if there are multiple copies of Word,
        the user should be able to override the location
        information.</li>
    <li>When creating the Word document, either an existing
        instance of Word should be used or a new instance should
        be started.</li>
    <li>The user may not know or may not enter complete data
        regarding the contact's title or a suitable salutation
        for opening the letter. The application should make
        intelligent formatting decisions based on the existing
        data.</li>
</ul>

<P>The main form of Contact, frmContMain requires that
frmOptions be filled in before it will allow you to enter contact
information. The Options form is a logical place to start
examining the Contact application.</p>

<H2>The options form</h2>

<P>The Options form, frmOptions contains just three
fields for user data, each of which corresponds to an entry in
the Windows registry. Access 95 includes several new statements
(GetSetting, SaveSetting, and DeleteSetting) for reading and
writing data to an area of the Windows registry that has been set
aside for Visual Basic and Visual Basic for Applications
developers. Much of the code behind frmOptions uses the
GetSetting and SaveSetting statements which are described in
detail in Helen Feddema's article inthis issue. There is one
place in the code, however, where I need to read data from an
arbitrary key. Unfortunately, I can't use GetSetting because it
only reads keys below the VB and VBA Program Settings key. Thus,
I created a function, saGetRegEntry (located in basUtils), to
read data from any key in the registry.</p>

<P>The saGetRegEntry function is shown here:</p>

<P><br>
</p>

<pre> Function saGetRegEntry(strKey As String, _
 strSubKeys As String, strValName As String, _
 lngType As Long) As String

On Error GoTo saGetRegEntry_Err

  Dim lngResult As Long, lngKey As Long
  Dim lngHandle As Long, lngcbData As Long
  Dim strRet As String

  Select Case strKey
    Case &quot;HKEY_CLASSES_ROOT&quot;: lngKey = &amp;H80000000
    Case &quot;HKEY_CURRENT_CONFIG&quot;: lngKey = &amp;H80000005
    Case &quot;HKEY_CURRENT_USER&quot;: lngKey = &amp;H80000001
    Case &quot;HKEY_DYN_DATA&quot;: lngKey = &amp;H80000006
    Case &quot;HKEY_LOCAL_MACHINE&quot;: lngKey = &amp;H80000002
    Case &quot;HKEY_PERFORMANCE_DATA&quot;: lngKey = &amp;H80000004
    Case &quot;HKEY_USERS&quot;: lngKey = &amp;H80000003
    Case Else: Exit Function
  End Select
    
  If Not ERROR_SUCCESS = RegOpenKeyEx(lngKey, _
   strSubKeys, 0&amp;, KEY_READ, _
   lngHandle) Then Exit Function
  
  lngResult = RegQueryValueEx(lngHandle, strValName, _
   0&amp;, lngType, ByVal strRet, lngcbData)
  strRet = Space(lngcbData)
  lngResult = RegQueryValueEx(lngHandle, strValName, _
   0&amp;, lngType, ByVal strRet, lngcbData)
  
  If Not ERROR_SUCCESS = RegCloseKey(lngHandle) Then _
   lngType = -1&amp;
    
  saGetRegEntry = strRet
  
saGetRegEntry_Exit:
  On Error GoTo 0
  Exit Function

saGetRegEntry_Err:
  lngType = -1&amp;
  MsgBox Err &amp; &quot;&gt;  &quot; &amp; Error$, 16, _
   &quot;GenUtils/saGetRegEntry&quot;
  Resume saGetRegEntry_Exit

End Function</pre>

<P>SaGetRegEntry returns a string containing the value
of the registry entry. It accepts three strings as arguments:</p>

<ul>
    <li><b>strKey</b>&#151;The subkey area you want to query. The
        function equates &quot;HKEY_LOCAL_MACHINE&quot; to a
        predetermined handle to begin the search.</li>
    <li><b>strSubKeys</b>&#151;This parameter defines a path
        through the registry hierarchy toward the final entry you
        want to query.</li>
    <li><b>strValName</b>&#151;This parameter can define the last
        level of the hierarchy or can be left blank if that level
        is defined in strSubKeys.</li>
</ul>

<P>The lngType argument returns one of five values to
report the result of the call:</p>

<P><br>
</p>

<pre> -1 = Serious problem
0 = No data found
1 = Text
3 = Binary
4 = Double word</pre>

<P>I call saGetRegEntry in the load event procedure of
frmOptions. The code is shown here:</p>

<P><br>
</p>

<pre> strSubK = &quot;Software\Microsoft\Windows\Current&quot;
strSubK = strSubK &amp; &quot;Version\App Paths\&quot;
strSubK = strSubK &amp; &quot;winword.exe&quot;
strResult = _
 saGetRegEntry(&quot;HKEY_LOCAL_MACHINE&quot;, _
 strSubK, &quot;&quot;, lngType)</pre>

<H2>The Contact Maintenance form</h2>

<P>The Contact Maintenance form, frmContMaint, contains
all the logic for maintaining the Contact database. In addition
to maintaining contact data, users can launch the Options form
for changes and generate the individual business letters with the
Format Letter command button. Here's the code for the
cmdFormatLetter_Click event procedure:</p>

<P><br>
</p>

<pre> Private Sub cmdFormatLetter_Click()
On Error GoTo cmdFormatLetter_Err

  Dim objWord As Object
  Dim strWordExec As String
  Dim strAddressee As String
  Dim strSalutation As String
  
  If Len(txtLastName) = 0 Then Exit Sub
  
  AppActivate &quot;Microsoft Word&quot;, True
  Set objWord = CreateObject(&quot;Word.Basic&quot;)
  
  objWord.FileNew
  objWord.AppShow
  objWord.Insert Format$(Now, &quot;Long Date&quot;) &amp; _
   vbCrLf &amp; vbCrLf
  strAddressee = IIf(Len(txtTitle) &gt; 0, txtTitle &amp; _
    &quot; &quot;, &quot;&quot;) &amp; IIf(Len(txtFirstName) &gt; 0, _
    txtFirstName &amp; &quot; &quot;, &quot;&quot;) &amp; _
    IIf(Len(txtMidInit) &gt; 0, _
    txtMidInit &amp; &quot;. &quot;, &quot;&quot;) &amp; txtLastName
  objWord.Insert strAddressee &amp; vbCrLf
  objWord.Insert IIf(Len(txtAddress1) &gt; 0, _
   txtAddress1 &amp; vbCrLf, &quot;&quot;)
  objWord.Insert IIf(Len(txtAddress2) &gt; 0, _
   txtAddress2 &amp; vbCrLf, &quot;&quot;)
  objWord.Insert IIf(Len(txtAddress3) &gt; 0, _
   txtAddress3 &amp; vbCrLf &amp; vbCrLf, vbCrLf)
  If Len(txtSalutation) &gt; 0 Then
    strSalutation = &quot;Dear &quot; &amp; txtSalutation
  Else
    If Len(txtTitle) &gt; 0 Then
      strSalutation = &quot;Dear &quot; &amp; txtTitle &amp; &quot; &quot; &amp; _
       txtLastName
    Else
      strSalutation = &quot;Dear &quot; &amp; strAddressee
    End If
  End If
  objWord.Insert strSalutation &amp; &quot;:&quot; &amp; _
   vbCrLf &amp; vbCrLf &amp; vbCrLf &amp; vbCrLf
  objWord.Insert GetSetting(&quot;ContactDemo&quot;, _
   &quot;Settings&quot;, &quot;Closure&quot;, &quot;&quot;)
  objWord.StartOfDocument
  objWord.LineDown 2, 0
  If GetSetting(&quot;ContactDemo&quot;, &quot;Settings&quot;, _
   &quot;WordMacro&quot;, &quot;&quot;) &lt;&gt; &quot;&quot; Then
    objWord.ToolsMacro _
     GetSetting(&quot;ContactDemo&quot;, &quot;Settings&quot;, _
      &quot;WordMacro&quot;, &quot;&quot;), True
  End If

cmdFormatLetter_Exit:
  On Error GoTo 0
  Exit Sub

cmdFormatLetter_Err:
  Select Case Err
    Case 5    '* Word not running
      strWordExec = _
       GetSetting(&quot;ContactDemo&quot;, &quot;Settings&quot;, _
        &quot;WordPath&quot;, &quot;&quot;) &amp; &quot;\WINWORD.EXE&quot;
      If Dir(strWordExec) = &quot;&quot; Then
        MsgBox &quot;Microsoft Word was not found. &quot; &amp; _
         &quot;Check that you have the correct &quot; &amp; _
         &quot;Path entered in the &quot; &amp; _
         &quot;Options screen and try again.&quot;, 16
      Else
        varBitBucket = Shell(strWordExec, 3)
        Resume
      End If
    Case 537
      MsgBox &quot;The Microsoft Word Macro was &quot; &amp; _
       &quot;not found. Check that you have &quot; &amp; _
       &quot;supplied the name of a valid, existing &quot; &amp; _
       &quot;Macro to the Options screen and &quot; &amp; _
       &quot;try again.&quot;, 16
    Case Else
      MsgBox Err &amp; &quot;&gt;  &quot; &amp; Error$, 16, _
       &quot;frmContactss/cmdFormatLetter&quot;
  End Select
  Resume cmdFormatLetter_Exit

End Sub</pre>

<P>The AppActivate statement assumes that an instance
of Word is running and attempts to switch focus to that instance.
A trappable error results if there is no instance of Word and the
error handler assumes the job of getting Word started. The
registry entry for &quot;WordPath&quot; is retrieved into
strWordExec to which \WINWORD.EXE is appended. The Dir function
can be used to check for the existence of a file. It will return
the name of the first file found that matches its pathname
argument. Although the Access help file says a Null will be
returned if the file isn't found, Dir actually returns a
zero-length string. After successfully locating the executable,
the Shell function is used to launch Word. varBitBucket is a
global variant I declare in basUtils for data I'd just as soon
throw away. After launching Word, control is returned to the
AppActivate statement.</p>

<P>The next statement creates an OLE Automation object
using the Word application and the Basic object class. Since Word
starts with no documents loaded, you can use either
CreateObject(&quot;Word.Basic&quot;) or GetObject(&quot;&quot;,
&quot;Word.Basic&quot;). Either function will simply return a
reference to the running copy of Word. The object is assigned to
the objWord variable. A variety of instructions are then used to
manipulate the object. FileNew and AppShow create and make
visible a new Word document. The next set of Insert instructions
enter text into the document based on the current contact record.
The current date is entered using the system's &quot;Long
Date&quot; format. strAddressee contains the line of text for the
name of the addressee in the first line of the address section of
the letter. The IIf() functions are used to format the line
depending on the existence of the Title, FirstName, and MidInit
data for the contact (see Figure 3).</p>

<p><img src="contact3.gif" width="600" height="493"></p>

<P><b>Figure 3. Data formatting for the letter makes
educated decisions based on the information available. </b></p>

<P>The salutation line is formatted depending on the
existence of data in the txtSalutation text box. If salutation
data is missing, the procedure looks for title data and formats
the line using the txtTitle and txtLastName data. If the txtTitle
data is missing, the procedure uses strAddressee for the
salutation. After entering all the appropriate text, the
procedure uses StartOfDocument and LineDown to position the
cursor at the beginning of the addressee line. The last section
of the procedure checks for the existence of a Word macro entry
and attempts to execute the macro. Should the Word macro not
exist, a trappable error results and the procedure displays an
error message and exits.</p>

<H2>Conclusion</h2>

<P>Contact is a very simple application that
demonstrates a number of useful techniques that are essential to
well-designed applications. The application automatically
recognizes its initial instance (see the Form_Current event in
frmContMaint) and leads the user in the proper sequence for
entering data. A Word document is fairly freeform, yet an
intelligent application can make many of the right decisions when
creating the document while using incomplete data. If an
incorrect Word Path is entered, the user can simply delete the
Word Path data and close the form. That will signal the system to
search for the proper Word Path the next time the Options form is
opened.</p>

<P>You may wish to create a Word macro and experiment
with calling it from Contact. In my production system, I use a
macro that formats the date information to be right-justified on
the page. Since it's possible to count the lines of text entered,
you could use OLE Automation to position the cursor where the
body of the letter would start.</p>

<P><b>Access 2.0 Refinements</b></p>

<P>Although the examples in this article are based on
Access 95, the database&#151;CONTACT2.MDB on the Developer's
Disk&#151;is an Access 2.0 database with the same functionality
as the Access 95 version. You can open this database and
reference the Access 2.0 version of each module discussed in the
article. The major differences between databases are as follows:</p>

<ul>
    <li>A new feature for AppActivate in Access 95 is that if
        there is no exact match for the titletext parameter,
        AppActivate will select the first instance of an
        application whose title partially matches the titletext
        parameter. The 2.0 database has an extra function named
        saGetWordTitle to search for inexact matches.</li>
    <li>The construct, <i>txtField &amp; &quot;&quot;</i> is used
        several times in the 2.0 database to convert Null text
        fields to zero-length strings. The Format$ function is
        also used to convert Nulls to strings.</li>
    <li>Two functions, saGetSettingINI and saSaveSettingINI, have
        been included in the 2.0 database. These functions read
        and write information to .INI files instead of the
        registry.</li>
    <li>An saCRPipe function was added to the 2.0 database to
        allow .INI files to store multi-line text entries. This
        function writes CRLF pairs, Chr(13) &amp; Chr(10), to the
        .INI file as Pipe, Chr(124) characters. When reading the
        .INI file, it converts each Pipe character back to CRLF.</li>
    <li>Access 95's Dir command can be used to check the
        existence of a file. An saFileExists function is included
        in the 2.0 database to check for the existence of a file.</li>
</ul>

<P>Access 95 adds a number of refinements and added
capabilities throughout its implementation. The good news is that
most of these refinements can be ported down to Access 2.0 via
the flexibility of Access Basic and the Windows API.</p>

<P><i>Stu Alderman is a principal of Camarillo
Technology Associates, a consulting and system development
organization headquartered in Reno, Nevada. 702 747-2892,
CompuServe 102425,2531.</i></p>

<P>&nbsp;</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>:</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the September 1996
issue of Smart Access. Copyright 1996, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></body>
</html>
