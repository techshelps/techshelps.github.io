<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Header Controls for Windows 95 (May)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<H1>Header Controls for Windows 95</h1>

<P>Keith E. Bugg</p>

<P><i>The new header controls can be applied to a
wide range of applications. Keith Bugg shows you how.</i></p>

<P>THERE'S a new kid in town riding with the gang of
Windows 95 common controls&#151;the header control. A header
control is a horizontal window, generally placed above a column
of data, which contains a descriptive title for the column. But
that's not all&#151;they can also behave like push buttons. If
you've used Microsoft Excel, you've already been exposed to this
type of control. Figure 1 shows a header control based on the
sample program from the Companion Disk. Another classic example
of a header control can be found in the Windows 95 Explorer when
the Details option is checked from the View menu; a header
control appears at the top of the view with labels related to the
files being shown.</p>

<p><img src="bugg1b.gif" width="344" height="244"></p>

<P><b>Figure 1. Here's an example of a header control
in action. This one is from the sample program on the Companion
Disk.</b></p>

<P>Header controls are encapsulated in Visual C++
version 2.1 as class CHeaderCtrl. You can be create a header
control by calling CreateWindowEx() and specifying WC_HEADER as
the registered class name. Header controls use special structures
extensively&#151;these greatly influence the characteristics of
the header control.</p>

<H2>Header controls and properties</h2>

<P>Header controls (also referred to as header windows)
can be divided into parts called header items. The user can
re-size the width of header items, if desired. These items are
displayed as text on a gray background. With each item, you can
associate a string, a bitmap, and a 32-bit value defined by the
application. The first two properties are displayed within the
boundaries of the associated item. An item can have both text and
a bitmap simultaneously. In this case, the bitmap is shown above
the text. Should these overlap, the string takes priority and
occludes the image.</p>

<P>There is one caveat with header controls&#151;they
can't be accessed with the keyboard; hence, they don't accept the
input focus. Now let's take a look at the different header styles
supported by class CHeaderCtrl.</p>

<H2>Header window styles</h2>

<P>As with other controls, header controls can be
assigned various styles that influence their appearance and
behavior. These styles are set when you first create the control.
However, you can modify them later using GetWindowLong() and
SetWindowLong() API calls. The following is a brief list of the
header control window styles you can use.</p>

<H3>HDS_BUTTONS</h3>

<P>The HDS_BUTTONS style causes the header items to act
like command push buttons. For example, you might want to provide
the user with the ability to sort a list of names or numbers when
the header item is clicked. This is the style referred to earlier
with the Windows 95 File Explorer example.</p>

<H3>HDS_DIVIDERTRACK</h3>

<P>Use the HDS_DIVIDERTRACK style to provide the user a
means to adjust the width of the columns. You should provide this
functionality in most header controls you construct.</p>

<H3>HDS_HIDDEN</h3>

<P>The HDS_HIDDEN style lets you hide the header
window. This might be useful if the user is allowed to define the
titles for the header control in another part of the application.</p>

<H3>HDS_HORZ</h3>

<P>The HDS_HORZ style specifies a horizontal header
window.</p>

<P>Remember that header controls are almost always used
in tandem with another control, such as a list view control. This
is another reason why the HDS_DIVIDERTRACK style is important.</p>

<H2>Header window structures</h2>

<P>There are several new structures you need to know
about if you plan to use the header control extensively. These
play an important role in header messaging and notification
procedures. In this section, I'll go over these structures, show
you the prototypes, and hopefully, shed some insight into their
purpose.</p>

<H3>HD_ITEM</h3>

<P>You almost always need the HD_ITEM structure, as it
maintains information about the properties of each item in the
header control. You can also get this information by using the
Header_GetItem macro. The HD_ITEM structure is prototyped as
follows:</p>

<P><br>
</p>

<pre> typedef struct _HD_ITEM {
    UINT mask;      \\ mask flags 
    int cxy;        \\ item width or height
    LPSTR pszText;  \\ the item string
    HBITMAP hbm;    \\ handle of the item bitmap
    int cchText;    \\ length of the item string
    int fmt;        \\ format flags 
    LPARAM lParam;  \\ application-defined data
} HD_ITEM;</pre>

<P>Let me explain the components of this prototype in
greater detail. The mask member is a flag that specifies which of
the other members contain valid data. You have to get this right
because the mask member acts much like the conductor of an
orchestra; all the other members of the band must follow along.
It can be a combination of any of the following values:</p>

<ul>
    <li>HDI_BITMAP<font face="Symbol"></font>The hbm member
        contains a valid bitmap handle.</li>
    <li>HDI_FORMAT<font face="Symbol"></font>The fmt member is
        valid; shows how to draw the header item.</li>
    <li>HDI_HEIGHT<font face="Symbol"></font>The cxy member is
        valid and indicates the height of the item.</li>
    <li>HDI_WIDTH<font face="Symbol"></font>The cxy member is
        valid and is the width of the item.</li>
    <li>HDI_LPARAM<font face="Symbol"></font>The lParam member
        is valid. This is used in special situations like
        owner-drawn controls, and so on.</li>
    <li>HDI_TEXT<font face="Symbol"></font>The pszText and
        cchTextMax members are valid. This tells the header
        control &quot;text is on the way.&quot;</li>
</ul>

<P>The cxy member specifies the height, or width, of
the header control item. The value of the mask member determines
if this is height or width as designated by HDI_HEIGHT or
HDI_WIDTH.</p>

<ul>
    <li>The pszText member is the address of the text string to
        be displayed in the header control.</li>
    <li>The hbm member is the handle of a bitmap to be displayed
        in the header control.</li>
    <li>The cchText member is the length of the pszText member.</li>
</ul>

<P>The fmt member is a flag that specifies how to draw
the header item. It can be a combination of the following:</p>

<ul>
    <li>HDF_CENTER<font face="Symbol"></font>Center the item's
        contents (text or graphics).</li>
    <li>HDF_LEFT<font face="Symbol"></font>Left-justify the
        item's contents.</li>
    <li>HDF_RIGHT<font face="Symbol"></font>Right-justify the
        contents of the item.</li>
</ul>

<P>The fmt member can also be combined, using a Boolean
OR, with the following: </p>

<ul>
    <li>HDF_BITMAP<font face="Symbol"></font>The item displays
        a bitmap.</li>
    <li>HDF_OWNERDRAW<font face="Symbol"></font>The header
        window's parent window draws the item.</li>
    <li>HDF_STRING<font face="Symbol"></font>The item displays
        a text string.</li>
</ul>

<P>Finally, the<i> </i>lParam member is used for
application-defined item data.</p>

<H3>HD_LAYOUT</h3>

<P>The HD_LAYOUT structure, which you must use,
contains sizing and positioning information about the header
control. It's used with the HDM_LAYOUT message (more on this
later) and is prototyped as follows:</p>

<P><br>
</p>

<pre> typedef struct _HD_LAYOUT 
{
    \\ bounding rectangle coordinates
    RECT FAR *prc;
    \\ appropriate size for the header window
    WINDOWPOS FAR *pwpos;
} HD_LAYOUT;</pre>

<P>The prc member is the address of a RECT structure
that contains the coordinates of a bounding rectangle for the
header control.</p>

<P>The pwpos member is the address of a WINDOWPOS
structure that is filled with the correct size and position of
the header control. </p>

<H3>HD_NOTIFY</h3>

<P>The HD_NOTIFY structure contains the information
needed to process notification messages from a header control.
It's prototyped as follows:</p>

<P><br>
</p>

<pre> typedef struct _HD_NOTIFY 
{
    \\ common control notification structure
    NMHDR hdr;
    \\ index of the item
    int iItem;
    \\ index of the mouse button
    int iButton;
    \\ item information
    HD_ITEM *pitem;
} HD_NOTIFY;</pre>

<P>The hdr member is a notification message structure
that is shared by all the new common controls in Windows 95.</p>

<P>The iItem member is the index of the item associated
with the notification message.</p>

<P>The iButton member is a value reflecting the mouse
button that caused the notification message to be sent. The
possible values are as follows:</p>

<ul>
    <li>Left mouse button<font face="Symbol"></font>zero</li>
    <li>Right mouse button<font face="Symbol"></font>one</li>
    <li>Middle mouse button<font face="Symbol"></font>two</li>
</ul>

<P>The pitem member is the address of an HD_ITEM
structure for the header control item associated with the
notification message.</p>

<H3>HD_HITTESTINFO </h3>

<P>The HD_HITTESTINFO structure is used to store
information about a mouse cursor hit test. It's prototyped as
follows:</p>

<P><br>
</p>

<pre> typedef struct _HD_HITTESTINFO 
{
    POINT pt;
    UINT flags;
    int iItem;
} HD_HITTESTINFO;</pre>

<P>The pt member is the point, in client coordinates to
test.</p>

<P>The flags member receives the result of the hit
test. It can be one, or more, of the following:</p>

<ul>
    <li>HHT_NOWHERE<font face="Symbol"></font>The point is
        inside the header control but not over a header item.</li>
    <li>HHT_ONDIVIDER<font face="Symbol"></font>The point is on
        the divider between two header items. </li>
    <li>HHT_ONDIVOPEN<font face="Symbol"></font>The point is on
        the divider of an item that has zero width.</li>
    <li>HHT_ONHEADER<font face="Symbol"></font>The point is
        inside the rectangle of the header control.</li>
    <li>HHT_TOLEFT<font face="Symbol"></font>The point is to
        the left of the rectangle of the header control.</li>
    <li>HHT_TORIGHT<font face="Symbol"></font>The point is to
        the right of the rectangle of the header control.</li>
</ul>

<P>It's possible that two of these values can be
combined&#151;for example, when the mouse cursor is above and to
the right of the control's client area.</p>

<P>The iItem receives the index of the item at point
pt, if any.</p>

<H2>Header control messages</h2>

<P>Before we look at how to create a header window,
let's look at the messages that can be used with them. Header
controls are somewhat unique in that each message has a
corresponding macro that may be sent to the control. In the
upcoming discussion of the messages, I'll provide examples using
the SendMessage() API call. For these examples, the variable pHdr
is a CWnd pointer to the control, and hwndHeader is the handle of
the control. Hopefully, you'll see the role header control
structures play in manipulating the control. Now, on to the
messages.</p>

<H3>HDM_DELETEITEM</h3>

<P>This message is used to delete an item from a header
control. The wParam parameter is the index (zero based) of the
item to delete; the lParam parameter isn't used and should be set
to zero. The return value is TRUE if the item is successfully
deleted. For example this would delete the first item from the
header control:</p>

<P><br>
</p>

<pre> pHdr-&gt;SendMessage(HDM_DELETEITEM,0,0L);</pre>

<P>This is the associated macro for this message:</p>

<P><br>
</p>

<pre> BOOL<b> </b>Header_DeleteItem(<i>hwndHeader</i>, <i>index</i>);</pre>

<H3>HDM_GETITEM</h3>

<P>The HDM_GETITEM message is used to fetch information
about an item in a header control. The wParam parameter is the
index of the item to retrieve; the lParam parameter is the
address of an HD_ITEM structure that receives the information.
The return value is TRUE if the call succeeds and FALSE on
failure. To illustrate using this message to get the text item
information for the second item, I'll use this example:</p>

<P><br>
</p>

<pre> HD_ITEM hdItem;
// must set the mask member
hdItem.mask = HDI_TEXT;
pHdr-&gt;SendMessage(HDM_GETITEM, 1, (long)&amp;hdItem);</pre>

<P>If you set the mask member of the HD_ITEM structure
to zero, this message returns TRUE, but doesn't return any
information into the HD_ITEM structure. This is the associated
macro for this message:</p>

<P><br>
</p>

<pre> BOOL Header_GetItem(<i>hwndHeader</i>, <i>index</i>, <i>&amp;hdItem</i>);</pre>

<H3>HDM_GETITEMCOUNT</h3>

<P>The HDM_GETITEMCOUNT message returns a count of the
number of items in a header control. The wParam and lParam
parameters aren't used and are set to zero. The return value is
the number of items in the control, or minus one if an error
occurs:</p>

<P><br>
</p>

<pre> int nItems = pHdr-&gt;SendMessage(
             HDM_GETITEMCOUNT,0,0L);</pre>

<P>This is the associated macro for this message:</p>

<P><br>
</p>

<pre> int<b> </b>Header<b>_</b>GetItemCount(<i>hwndHeader</i>);</pre>

<H3>HDM_INSERTITEM</h3>

<P>The HDM_INSERTITEM message is used to insert a new
item into a header control. The wParam parameter is the
zero-based index of the header item after (or behind), in which
the new item will be inserted. Thus, if you have a header control
with, say, three items, and you wanted to insert a new item
between the second and third, wParam would be set to one. The
item is automatically inserted at the end of the header bar if
wParam is greater than or equal to the number of items currently
on the header control. The lParam parameter is the address of an
HD_ITEM structure containing information about the item being
inserted. If successful, the return value is the index of the
new, inserted item; it's minus one if an error occurs. The
following is an example:</p>

<P><br>
</p>

<pre> HD_ITEM phdi;            // the HD_ITEM structure
phdi.mask = HDI_FORMAT | HDI_WIDTH; 
phdi.fmt = HDF_LEFT;          // Left-justify the item.
phdi.mask |= HDI_TEXT;       // The .pszText member 
                              // is valid.
phdi.pszText = &quot;File Size&quot;;   // The text for the item.
phdi.cxy = 75;               // The initial width.
phdi.cchTextMax = lstrlen(phdi.pszText);
phdi.fmt |= HDF_STRING;      // This item is a string.

pHdr-&gt;SendMessage(HDM_INSERTITEM,1,(long)&amp;phdi);</pre>

<P>This inserts an item labeled &quot;File Size&quot;
as the third column of the header control. This is the associated
macro for this message:</p>

<P><br>
</p>

<pre> int Header_InsertItem(<i>hwndHeader</i>, <i>i</i>, <i>phdi</i>);</pre>

<H3>HDM_LAYOUT</h3>

<P>The HDM_LAYOUT message is used to get size and
location information about a header within a specified rectangle.
The wParam parameter isn't used and is set to zero. The lParam
parameter is the address of an HD_LAYOUT structure into which the
information is returned. The pwpos<i> </i>member receives the
information while the prc member specifies the bounding rectangle
for a new header window. The return value is TRUE upon success,
and FALSE on error. This is the associated macro for this
message:</p>

<P><br>
</p>

<pre> BOOL Header_Layout(<i>hwndHeader</i>, <i>playout</i>);</pre>

<H3>HDM_SETITEM</h3>

<P>The HDM_SETITME message is used to set the
attributes of a given header control item. The wParam parameter
is the zero-based index of the item to set; the lParam parameter
is the address of an HD_ITEM structure. The mask member of the
HD_ITEM structure specifies what attributes to set; the other
members contain the new attributes. The return value is TRUE if
the call is successful, and FALSE if it's unsuccessful.</p>

<P>Before any header item is actually changed, the
HDN_ITEMCHANGING notification message is sent to the parent
window. It can prevent the changes from proceeding by returning
FALSE. This lets you build additional safety checks into your
application. If the parent window decides the changes are
allowed, it returns TRUE. When the changes are complete, the
parent window receives an HDN_ITEMCHANGED notification. This is
the associated macro for this message:</p>

<P><br>
</p>

<pre> BOOL Header_SetItem(<i>hwndHeader</i>, <i>i</i>, <i>phdi</i>); </pre>

<P>Now we'll examine some code from the sample
application on the Companion Disk.</p>

<H2>A sample application</h2>

<P>For this example, the header control is used in a
dialog box. I created a new dialog box in App Studio, and gave it
the name CHdrCtr. I used Class Wizard to trap the WM_SHOWWINDOW
message; from this message handler I call a member function
CreateHdrCtrl() to actually create the header control. First,
here's the code from the WM_SHOWWINDOW message handler:</p>

<P><br>
</p>

<pre> // pointer to dialog box window
CWnd *pDlg;    

// get handle to dialog box    
HWND hHrdDlg;    
pDlg = CWnd::GetForegroundWindow();

// handle to dialog box
hHrdDlg = pDlg-&gt;GetSafeHwnd();

// function to create header ctrl.
CreateHdrCtrl(hHrdDlg, pDlg);        </pre>

<P>The only thing this snippet of code accomplishes is
to get a pointer and handle to the parent window, the dialog box.
The real work is done inside CreateHdrCtrl(). Lets look at it
now:</p>

<P><br>
</p>

<pre> HWND CHdrCtrl::CreateHdrCtrl(HWND hDlg, 
                             CWnd* pWin)
{
    HWND hwndHeader;  // handle to header control
    HD_ITEM phdi;  // HD_ITEM structure for header
    CWnd *pHdr;  // pointer to header child window
    RECT rRect;  // rectangle for sizing header
    HD_LAYOUT hd_layout; // HD_LAYOUT structure
    WINDOWPOS wp;            // for positioning header
    HINSTANCE hInstance; // application instance
  
  // instance of application
    hInstance = AfxGetInstanceHandle();</pre>

<P>At this point, I've defined the variables I'll need
and retrieved the instance of the application, hInstance. The
next step is to actually create the header control as a child
window:</p>

<P><br>
</p>

<pre> hwndHeader = CreateWindowEx(
    0L,             // No extended styles
    WC_HEADER,      // A header class window
    (LPCTSTR) NULL, // No default text
    WS_CHILD|WS_BORDER|HDS_BUTTONS|HDS_HORZ,
    0, 0, 0, 0,     // No size or position
    hDlg,           // Handle to the parent hWnd
    NULL,           // ID for the header window
    hInstance,      // Current instance
    NULL);

    if(hwndHeader == NULL)
    {
        AfxMessageBox(
          &quot;Failed to create header window.&quot;,
          MB_OK);
      return (HWND) NULL;
    }</pre>

<P>Now I have a header control. I used a very weak
error trap, which I included just to remind you to shore this up
before you use this code for anything serious. Next, I'm ready to
find the size of the parent window and position the header:</p>

<P><br>
</p>

<pre> pHdr = CWnd::FromHandle(hwndHeader);
// Get the rectangle of the dialog client area
pWin-&gt;GetClientRect(&amp;rRect);

hd_layout.prc = &amp;rRect;
hd_layout.pwpos = &amp;wp;

// Use the Header_Layout macro to find the 
// appropriate size for the window

pHdr-&gt;SendMessage(HDM_LAYOUT,0,(long)&amp;hd_layout);</pre>

<P>With the layout information in hand, I can populate
the HD_ITEM structure with some values that include a formatted
text string:</p>

<P><br>
</p>

<pre> phdi.mask = HDI_FORMAT | HDI_WIDTH; 

// Left-justify the item
phdi.fmt = HDF_LEFT; 

// The .pszText member is valid
phdi.mask |= HDI_TEXT; 

// The text for the item
phdi.pszText = &quot;Column 1&quot;;     

// The initial width
phdi.cxy = 75; 

phdi.cchTextMax = lstrlen(phdi.pszText);

// This item is a string
phdi.fmt |= HDF_STRING; </pre>

<P>Now I can insert this item. By changing the pszText
member, I can recycle this code to create and insert another
header item:</p>

<P><br>
</p>

<pre> 
pHdr-&gt;SendMessage(HDM_INSERTITEM,0,(long)&amp;phdi);
phdi.pszText = &quot;Column 2&quot;;  
pHdr-&gt;SendMessage(HDM_INSERTITEM,1,(long)&amp;phdi);  </pre>

<P>All that's left to do is position the child
window/header control and show it:</p>

<P><br>
</p>

<pre> pHdr-&gt;SetWindowPos(pWin,wp.x,wp.y,wp.cx,wp.cy,
                   wp.flags | SWP_SHOWWINDOW);
return hwndHeader;
}    // end member function CreateHdrCtrl()</pre>

<P>That's all there is to it! You should try
experimenting with the other messages, using this code as a
starting point.</p>

<H2>Summary</h2>

<P>The header control is a versatile control that
combines the usefulness of column labels with the power of push
buttons. They're great for applications that need, say, a quick
and easy reporting capability. Just remember, header controls
don't support a keyboard interface, so take care where and how
you use them. Also, bear in mind that header controls are
generally associated with another control&#151;after all, you
want to show something under those headings. Happy trails until
next time.</p>

<P><i>Keith Bugg has been developing Visual C++
applications since its first release. He's the author of several
books, including the newly published The MFC Windows Control
Construction Kit (ISBN 0-9644301-0-X from Tristar Systems Inc.,
800-628-0903). CompuServe 72203,3612, Internet
tristar@qsystems.net.</i></p>

<P>&nbsp;</p>

<P align="center"><a
href="http://www.pinpub.com/vcd/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Visual
C++ Developer and Pinnacle Publishing, <br>
visit their website at</strong> <a
href="http://www.pinpub.com/vcd/"><strong>http://www.pinppub.com/vcd/
</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the May 1996 issue
of Visual C++ Developer. Copyright 1996, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Visual C++
Developer is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></body>
</html>
