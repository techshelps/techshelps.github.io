<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Double Buffering with Class! (December)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><h1>Double Buffering with Class!</h1>
<p>
Michele Leroux</p>
<p>
<i>Double buffering may sound hard but it’s really not that bad, especially if you use the classes Michele has defined and that you’ll find on your Developer’s Disk.</i></p>
<p>
WHETHER you’re writing a full-blown game application or just moving a few sprites to add life to your interface, double buffering is the key to professional appearance and hot performance. Without it, display updates can seem awkward and unappealing. Though the concept of double buffering is uncomplicated (just read the first screen of the demo program), there are several steps involved: graphics preparation, the setup of necessary API functions, and the all-too-familiar palette issue. To get you off to a quick start, I’ll show you how to do double buffering using a half-dozen classes I’ve created. </p>
<p>
Rather than focus on the API and how I created the classes, I’ll explain how they work together. After all, that’s one of the main goals of creating classes in the first place: to hide complexity and distill functionality into a handful of easy-to-use properties and methods. Nevertheless, I’m assuming you’re comfortable with general Windows API functionality and that you’re somewhat familiar with the following topics:</p>
<p>
<b>Device Contexts.</b> Memory DCs store images in memory while display DCs are visible.</p>
<p>
<b>Blitting Graphics.</b> Copying from one DC to another.</p>
<p>
<b>Bitmap Transparency.</b> Copying rectangular bitmaps with a transparent color.</p>
<p>
<b>Using Logical Palettes.</b> Using the colors from image files to update the display.</p>
<p>
If you’re not, you can always refer to my book, <i>Instant VB Animation,</i> published by Wrox Press Inc. ($34.95 with CD-ROM, 800-USE-WROX or 312-465-3559, www.wrox.com). <i>[You might also want to refer to previous articles by Michele on VB Animation (February, March, and April 1995 issues), and her November 1995 and February 1996 articles on DIBSection.-Ed.]</i></p>
<h2>Introducing the classes</h2>
<p>
Here are the six classes you’ll find on your Developer’s Disk:</p>
<table>
<tr valign=top>
<td>
clsPalette</td>
<td>
Creates a logical palette from a bitmap file.</td>
</tr>
<tr valign=top>
<td>
clsBmp</td>
<td>
Creates a bitmap in memory from a file or other device context and provides access to properties and methods to display and manipulate it.</td>
</tr>
<tr valign=top>
<td>
clsMem</td>
<td>
Creates a double buffer and provides methods to work with it in conjunction with the associated display device context.</td>
</tr>
<tr valign=top>
<td>
clsRect</td>
<td>
Used in place of the RECT structure because structures can’t be passed as parameters to class module procedures.</td>
</tr>
<tr valign=top>
<td>
clsLocate</td>
<td>
Encapsulates some rectangle functionality to check the status of rectangles and points.</td>
</tr>
<tr valign=top>
<td>
clsMove</td>
<td>
Calculates and performs movement on a bitmap object while working with the double buffer for display updates.</td>
</tr>
</table><br>
<p>
Most of this article is about clsBmp, clsPalette, clsMem, and clsMove; the remaining two classes-clsRect and clsLocate-are simple support classes for the first three and will be mentioned only briefly. </p>
<h2>Planning ahead and palettes</h2>
<p>
Before these classes can be of use, you need to have a plan for the application content and the graphics to go with it. Figure 1 shows the background image used for the tutorial and its associated palette in the Bitedit.exe interface. This palette was also assigned to all of the other graphics used. When all graphics in an application share a palette, you can create a single logical palette and use it with all device contexts (DCs are where the graphics are stored in memory and displayed on screen), greatly simplifying life. </p>
<p><img src="leroux1.gif"></p>
<p>
<b>Figure 1. The background image used in your demo application.</b></p>
<p>
This preparation helps to prevent ugly palette shifts when displaying different graphics. Any graphics that are scheduled to appear in the display window at the same time should share the same colors. In some scenarios, where graphics are altered during the animation, this hard-coding of colors may not be possible, but when graphics are hard-coded, it is. </p>
<h2>Using<i> </i>clsPalette</h2>
<p>
Technically speaking, when the display mode is 256 colors every device context should have an associated palette that matches the colors of the image being stored by it. This is why the bitmap class (clsBmp which I’ll describe) has an hPalette property, as does the memory class (clsMem). A single logical palette accessed through the palette handle, hPalette, can be associated with many DCs such as those of clsBmp and clsMem. This explains why, if all graphics share the same palette and you know it, you can create one palette object (clsPalette) and share it among all DCs that require it. </p>
<p>
In the main module, modMain, the global palette object for the application is set up as follows:</p>
<pre><font face="Courier New" size="3">Public g_objPal As New clsPalette</font></pre>
<p>
The palette class has a single method and a single property. The Create method is passed the name of a bitmap file on disk, which it reads to get the bitmap’s color table (if any), and from this information creates a logical palette. The hPalette property is used to access this logical palette to assign it to DCs that require it. If the current display mode is high-color or better, the hPalette property will be 0; otherwise it will be a valid logical palette handle that clsBmp and clsMem can use. </p>
<p>
In frmDemo’s Load_Graphics procedure, the global palette’s Create method is called, passing it one of the graphics used in the tutorial:</p>
<pre><font face="Courier New" size="3">g_objPal.Create g_sPath &amp; &quot;backgrnd.bmp&quot;</font></pre>
<p>
In this case, because all graphics were prepared with the same color table as shown earlier, any of them could have been used to create the same logical palette.</p>
<h2>Using<i> </i>clsBmp</h2>
<p>
Our demo uses a sample background image along with several duck frames, each requiring a copy and mask image to create transparency. (Scene_5 shows you all graphics used in this demonstration.) Each of these graphics was loaded into its own bitmap class object, using clsBmp, in order to display them.</p>
<p>
This class has a method, ReadImage, which facilitates loading in the graphic from disk and copying the data into a memory device context. There are, however, several properties that must be set up in preparation for this call to ReadImage. Listing 1 shows the BmpDC_LoadNew procedure, to which you pass the name of the clsBmp object to be filled in along with its associated filename. ReadImage also holds the repeated property settings required each time a new bitmap is read into memory, and saves you from typing each of these lines of code every single time. Here’s a synopsis of the properties:</p>
<p>
MemBuffer is an important property because the bitmap ultimately will need to be copied to the display; the global memory object (clsMem) must be known to the bitmap object.</p>
<p>
The hPalette property refers to the palette handle to the logical palette the bitmap will use (assuming this is a global palette).</p>
<p>
The BlitMethod property is key because the bitmap data can be copied from the memory DC to any other DC using two methods: the BLT_COPY class constant (indicating that the bitmap can be copied as is from one DC to another) or the BLT_MASK class constant (indicating that the bitmap should be copied using a second mask image to create a transparent effect).</p>
<p>
The LoadMethod property is assigned depending on which of two methods the ReadImage method uses to read the image file. I use the LD_VBFILEIO class constant to indicate the file should be read in using manual file I/O functionality and the LD_PICTURE class constant to indicate that a PictureBox control will be used-temporarily-to read in the image, which is then copied from the PictureBox DC to the class’ associated memory DC. (This requires that a PictureBox is available on the Form for this purpose, which I’ll discuss later.)</p>
<p>
The BmpFile property stores the name of the image file to read from disk.</p>
<p>
The PicTemp property needs to be assigned only when using the LD_PICTURE LoadMethod as described previously (PictureBox properties: ScaleMode = 3, AutoRedraw = True).</p>
<p>
Once these properties have been properly set, the ReadImage method can be called. Assuming the bitmap doesn’t require transparency, the flag passed to the ReadImage method should be set to False, which means that the image being read in is the original bitmap image. (I’ll talk about the other possibility in a moment.) This method loads the filename in BmpFile to load the image into the PicTemp PictureBox control. Then the image data is copied from the PictureBox DC to the memory DC and the PictureBox image is cleared to release memory. During this reading process, the Width and Height properties of the class are set.</p>
<p>
The SetPosition method sets a rectangle property, rLoc, with the Left, Right, Top, and Bottom position of the bitmap with respect to the display. For initialization, the bitmap’s position is set to 0, 0. Speed is used when there is movement associated with the bitmap, and the default for this application is a speed of 30 pixels for each movement step (used later with clsMove).</p>
<h2>Using<i> </i>clsBmp for transparency</h2>
<p>
When a bitmap uses a mask and copy image to create transparency (as the duck images do-notice the graphics displayed in the demo), an extra step must be performed after reading in the "copy" graphic. In the case of the ducks, in Script_7 of frmDemo, a single bitmap object is created to move the duck (with transparency) across the display. Did you notice that there are no associated rectangles? The two duck images flashed in Script_6 are used within the same bitmap class to create this transparency. BmpDC_LoadNew is called as usual for the "copy" graphic (this is the duck frame on black, or the entire top row of duck graphics shown in the demo). Look at the sample code from Script_7:</p>
<pre><font face="Courier New" size="3">Dim objBmpDuckTrans As New clsBmp
BmpDC_LoadNew objBmpDuckTrans, &quot;duck1.bmp&quot;
BmpDC_LoadMask objBmpDuckTrans, &quot;duck1m.bmp&quot;</font></pre>
<p>
The BmpDC_LoadMask procedure, also shown in Listing 1, takes care of loading in the "mask" image for the transparent duck frame. A second filename property, MskFile, is provided for this purpose. This time, the call to ReadImage is passed True, which means the current "read" is for the mask portion of the bitmap class. This tells the internal functionality not to bother setting up such properties as Width and Height that are already taken care of from reading in the original "copy" bitmap. It’s in this function that the bitmap’s BlitMethod property is set to BLT_MASK so that the class knows how to send the data to other device contexts using both graphics rather than just the BmpFile graphic.</p>
<h2>Other clsBmp methods</h2>
<p>
I also use the Blit and CreateImage methods throughout the sample program. Blit, using the appropriate BlitMethod, copies the bitmap data (with or without the mask file, as appropriate) to the working buffer. And rather than creating a bitmap in memory from an image file on disk, the CreateImage method creates a memory DC with specified dimensions and fills it with the contents of another DC or some portion of it.</p>
<p>
<b>Listing 1. The BmpDC_LoadNew and BmpDC_LoadMap procedures.</b></p>
<dl>
<dt>
 </dt>
<dd>
<pre><font face="Courier New" size="3">Private Sub BmpDC_LoadNew(obj As clsBmp, _
    sFile As String)
  With obj
    Set .MemBuffer = g_objMem
    .hPalette = g_objPal.hPalette
    .BlitMethod = .BLT_COPY
    .LoadMethod = .LD_PICTURE
    .BmpFile = g_sPath &amp; sFile
    Set .PicTemp = picLoad
    .ReadImage False
    .SetPosition 0, 0
    .Speed = 30
  End With
End Sub

Private Sub BmpDC_LoadMask(obj As clsBmp, _
    sFile As String)
  With obj
    Set .PicTemp = picLoad
    .MskFile = g_sPath &amp; sFile
    .BlitMethod = .BLT_MASK
    .ReadImage True
  End With
End Sub</font></pre>
</dd>
</dl>
<h2>Using clsMem</h2>
<p>
This class links memory to the display. In your application, you’ll likely have a PictureBox or Form that will display the contents of the graphics display in its client area. The size of this display is used as the basis for the size of the double buffer in memory. This is demonstrated in Script_1 and Script_2 of the demonstration. </p>
<p>
In most applications, only one double buffer should be necessary for screen updates, so one global memory object should be defined for use throughout the application. In the code sample, modMain includes the following line which creates a new memory object for this purpose:</p>
<pre><font face="Courier New" size="3">Public g_objMem As New clsMem</font></pre>
<p>
The memory object, clsMem, requires that several properties be set and a few methods be called, in a particular order, to set up the double buffer for use:</p>
<p>
<b>Display. </b>Links the class to the display DC, a PictureBox or Form, and also sets up the Width and Height of the double buffer.</p>
<p>
<b>CreateDoubleBuffer</b>. Creates a back and work DC based on the Width and Height properties defined when the Display property was initialized.</p>
<p>
<b>hPalette</b>. Associates a logical palette with the double buffer DCs and the display DC.</p>
<p>
<b>BgInit</b>. Defines how the double buffer is initialized and can be set to the following class constants: </p>
<p>
<b>MEM_BGTILE</b>. Tile a bitmap into the buffer area.</p>
<p>
<b>MEM_BGBITMAP</b>. Stretch a bitmap to fit the &#09;&#09;buffer area.</p>
<p>
<b>MEM_BGDESKTOP</b>. Stretch the current desktop &#09;&#09;display to fit the buffer area.</p>
<p>
<b>InitDoubleBuffer</b>. Fills the two memory DCs, hdcWork and hdcBack created with the CreateDoubleBuffer method, with either a tiled bitmap, a stretched bitmap, or the desktop (based on the BgInit property).</p>
<p>
After these properties and methods have been set, the double buffer is ready for use. There are lots of methods within clsMem, so here’s a brief overview of their functionality:</p>
<p>
<b>UpdateDisplay.</b> Sends any changes to hdcWork to the display DC hdcDisp.</p>
<p>
<b>SaveWorkBuffer.</b> Copies the contents of hdcWork to hdcBack, and is used to save the current state of the working buffer in the backup buffer.</p>
<p>
<b>RestoreWorkBuffer</b>. Copies the contents of hdcBack to hdcWork, and is used to restore the contents of the working buffer with those of the backup buffer, to erase transitional changes made to the display.</p>
<p>
<b>ClearWorkBuffer</b>. Copies a rectangle from hdcBack to hdcWork to erase a specific rectangular area.</p>
<p>
<b>InvertRectArea</b>. Inverts the hdcWork buffer with a specified rectangle’s bounds.</p>
<p>
<b>InvertRectBounds</b>. Inverts the hdcWork buffer with a specified rectangular area.</p>
<h2>Using<i> </i>clsMove</h2>
<p>
This class is useful for cases where graphics are to be moved across the display. The catch is that the graphics must be loaded into a clsBmp object and the display attached to a clsMem object. A global clsMove object can be used throughout the application. Mine is defined in modMain with the other global class objects:</p>
<pre><font face="Courier New" size="3">Public g_objMove As New clsMove</font></pre>
<p>
To set up the class object, the global memory object should be associated with it so the clsMove instance knows where any bitmap data should be copied. The MemBuffer property, along with the MoveDisplay property in this case, is set up in the Form_Load:</p>
<pre><font face="Courier New" size="3">With g_objMove
  Set .MemBuffer = g_objMem
  .MoveDisplay = True
End With</font></pre>
<p>
The MoveDisplay property is used to tell the move object whether or not its Move method (to be described) is supposed to handle display updates. There are instances where you may not want this to be the case, but in our sample MoveDisplay is set to True. To use the Move method, a bitmap object must first be passed to the Init_Move method. Let’s look at the example from Script_7:</p>
<pre><font face="Courier New" size="3">With objBmpDuckTrans
  .SetPosition 320, 15
  .SetStopPosition 10, 220
  g_objMove.MoveMode = g_objMove.MOV_POINT
  g_objMove.Init_Move objBmpDuckTrans
  Wait_AnimComplete 100
...
...
End With</font></pre>
<p>
This code segment moves the first duck frame (with transparency) from its location in the top right corner of the screen to its destination in the Work DC of the display. Two position-setting procedures for the bitmap class are called to set its start and finish location on the display. The MoveMode property of the move class is set to the class constant MOV_POINT, which tells Init_Move to look at these two points and calculate an array of positions to move to based on the Speed for the bitmap. It also sets up the internal clsBmp object variable for the clsMove, so that the Move method knows what bitmap to act on.</p>
<p>
The Move method is called from the Wait_AnimComplete procedure inside the Form. Until the Complete property of g_objMove is set to True (it was set to False within the Init_Move method), Wait_AnimComplete performs a DoEvents loop calling:</p>
<pre><font face="Courier New" size="3">g_objMove.Move</font></pre>
<p>
With each movement the next item in the array of movement points is selected, and code similar to the following snippet is called:</p>
<pre><font face="Courier New" size="3">m_objMem.ClearWorkBuffer bmp.rLoc
bmp.SetPosition m_ptMovePos(m_nStep).X, m_ptMovePos(m_nStep).Y
If m_bMoveDisplay Then bmp.Blit
If m_bMoveDisplay Then m_objMem.UpdateDisplay</font></pre>
<p>
This code clears the work buffer of the memory object using the ClearWorkBuffer method. The rectangle cleared is the area covered by the bitmap being moved (defined here by "bmp"), before it’s moved. This rectangle is stored in the rLoc property of the bitmap class. The call to SetPosition takes the next step in the movement process-which also fills the rLoc property of the class with new rectangle values.</p>
<p>
If the MoveDisplay property was set to True, the bitmap’s Blit method is called. This sends the bitmap to the working buffer at its current position, using the appropriate method based on its BlitMethod property. Then the display is updated from the working buffer with a call to UpdateDisplay. UpdateDisplay will update only the rectangles that have changed. In this case, the dirty rectangle is the union of the first rectangle cleared and the new rectangle that was blit. This is demonstrated visually in Script_10 of the demonstration. </p>
<h2>What the demo does</h2>
<p>
Many of the steps just described illustrate the visual demonstration in the double-buffering demo. Text is displayed through each script of the demonstration, and the current script’s procedure name is referenced in the status bar at the bottom of the interface. This way, you can check out the display for the script as I’ve named it in this article. Each step in the script describes the necessary components and steps in double buffering, while using double buffering to perform some of the script effects!</p>
<h2>Create a new application . . . fast</h2>
<p>
Enough of laying the foundation. Now let’s (finally) go though the demo.</p>
<h4>Step 1: create the interface</h4>
<p>
You’ll need to add a new form to the project, as well as a PictureBox (if desired) to display information. In the double-buffering demo, I use a PictureBox as the device context where all graphics are displayed- called picDisplay. Below it are the demo’s navigation buttons where you can continue to the next scene or exit the demo. In addition, since the bitmap class uses the LD_PICTURE LoadMethod (described earlier), an additional PictureBox is added to the Form for this purpose. I called mine picLoad.</p>
<h4>Step 2: add the classes</h4>
<p>
I’ve already mentioned that this project uses six classes: clsBmp, clsPalette, clsMem, clsRect, clsLocate, and clsMove. Whew! Actually, as you’ve seen in the class descriptions, several of these classes rely on each other to display and work with graphics properly.</p>
<h4>Step 3: create the double buffer</h4>
<p>
I used my global clsMem object, g_objMem, and set its Display property to picDisplay. The next step is to call the CreateDoubleBuffer method as described earlier.</p>
<h4>Step 4: initialize the double buffer</h4>
<p>
For this demo, I use a solid grey background by tiling a grey bitmap into the buffer area. The clsMem property BgInit must be set to MEM_BGTILE to make this possible. The grey bitmap (grey.bmp) must be associated with a bitmap class, and the palette to be used for the entire demo must be created and associated with the double buffer. Then, InitDoubleBuffer can be called, passing the bitmap to tile. The following code is located in the Load_Graphics procedure in frmDemo:</p>
<pre><font face="Courier New" size="3">Dim objBmpTile As New clsBmp
With g_objMem
  BmpDC_LoadNew objBmpTile, &quot;grey.bmp&quot;
  .hPalette = g_objPal.hPalette
  .BgInit = .MEM_BGTILE
  .InitDoubleBuffer objBmpTile
End With</font></pre>
<h4>Step 5: updating the display</h4>
<p>
Once the double buffer has been initialized, the memory class is ready for use. The UpdateDisplay method of this class uses the information stored in the working DC (hdcWork) to update the display DC (hdcDisp) which in this case is picDisplay. In the paint event of picDisplay, the following code ensures that it always reflects the appropriate display:</p>
<pre><font face="Courier New" size="3">g_objMem.UpdateDisplay</font></pre>
<p>
By default, the UpdateDisplay method will copy the entire working buffer to the display. As mentioned earlier, if smaller changes are made to the working buffer, UpdateDisplay will update only the rectangle that surrounds those areas.</p>
<h2>Writing application content</h2>
<p>
Okay, now you have an interface and a display. What do you want to do with it? This is where the type of application will depict what the code requires. In your sample, the application itself is a demo that consists of a series of scripts that play one after another. For this application, foreground graphics to be displayed or animated are loaded within the current script and destroyed when the script is completed. Inside each script, bitmaps are copied strategically to the double buffer, using their respective bitmap class methods and the memory class. As changes are made to the working buffer, the display is updated on request by the code. </p>
<p>
Now that you know how the classes work and what each property and method does, take another look at the demo and see the code that makes it all function! This could be incredibly useful for starting up a new application from scratch in no time, and it’s all yours!</p>
<p>
<i>Michele Leroux is a programmer at ImageWare Software, a San Diego-based firm which specializes in interactive multimedia, imaging, and Internet applications. michele@emeraldcity.com. </i></p>
    <P align="center"><a
    href="http://www.pinpub.com/vbd/"><img src="Pinnacle.gif"
    border="0" width="216" height="72"></a></p>
    <P align="center"><strong>To find out more about
    Visual Basic Developer and Pinnacle Publishing, visit their
    website at</strong>: <a href="http://www.pinpub.com/vbd/"><strong>http://www.pinppub.com/vbd/</strong></a></p>
    <P align="center"><font size="1">Note: This is not
    a Microsoft Corporation website. <br>
    Microsoft is not responsible for its content.</font></p>
    <p><font size="1">This article is reproduced from the
    December 1996 issue of Visual Basic Developer. Copyright
    1996, by Pinnacle Publishing, Inc., unless otherwise noted.
    All rights are reserved. Visual Basic Developer is an
    independently produced publication of Pinnacle Publishing,
    Inc. No part of this article may be used or reproduced in any
    fashion (except in brief quotations used in critical articles
    and reviews) without prior consent of Pinnacle Publishing,
    Inc. To contact Pinnacle Publishing, Inc., please call
    (800)&nbsp;788-1900 or (206)&nbsp;251-1900.</font></p>
</font></BODY>
</HTML>
