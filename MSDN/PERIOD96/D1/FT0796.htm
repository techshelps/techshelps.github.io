<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Wrappers (July)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">

<font face="verdana,arial,helvetica" size="2">
<H1>Wrappers</h1>
<P>Steven Black</p>

<P><i>A decorator allows you to dynamically attach
additional responsibilities to an object. They provide a flexible
alternative to subclassing for extending functionality. Steve
examines different sorts of wrappers, including decorators, and
how they can mean different things in procedural and
object-oriented programming. </i></p>

<P>The term &quot;wrapper&quot; comes up all the time
and, depending on the context, can mean different things. The
different meanings can lead to confusion, so in this article
we'll look at wrappers, with a specific focus on object-oriented
wrappers. I'll discuss three sorts of wrappers: procedural
wrappers, functional wrappers, and the wrapper object-oriented
pattern, which is also known as a <i>decorator</i>.</p>

<H2>Procedural wrappers</h2>

<P>Procedural wrappers are a commonly used packaging
technique that can be used in all versions of FoxPro, and indeed
by most other computer languages.<i> </i>Most developers have
used the procedural wrappers at some point. A procedural wrapper<i>
</i>has little to do with object-oriented programming (OOP), even
though this is what most people first think of when someone says
&quot;wrapper&quot;. </p>

<P>The idea behind a procedural wrapper is to envelope
(wrap) the call to a function or program inside another function
or program. Because of hierarchical scoping, the memory variables
(except LOCAL variables in Visual FoxPro (VFP) and procedures of
the wrapper program can be referenced and called by the program
being wrapped.</p>

<P>Here's a great example of the usefulness of
procedural wrappers: In FoxPro 2.6, a good productivity tactic is
to <i>desnippetize</i> your screens. When you do this, you remove
code from snippets&#151;where it's hard to access&#151;replace it
with a function call, and move the code to a wrapper program.
When the screen executes the snippets, the code in the wrapper is
in-scope.</p>

<P>Not long ago there was much discussion about the
merits of desnippetizing. On one hand it leads to far shorter
development cycles and easier code maintenance. On the other
hand, pro-snippet folks say the transition to OOP (via a
conversion routine) would be easier if the code associated with
an &quot;object&quot; were kept there. </p>

<P>As it turns out, the automated conversion routines
in VFP don't make for very good VFP programs, much less do they
make decent OOP programs, so the point is moot. If you continue
to work in FoxPro for Windows or FoxPro for DOS and haven't yet
used a wrapper program to remove snippets from your screens, what
the heck are you waiting for!?</p>

<H2>Functional wrappers</h2>

<P>A <i>functional wrapper</i> dresses up a collection
of routines to make them look and behave like an object. For
example, consider a procedure file with the following functions.
(The actual code for these are in
HOME()+&quot;\GENMENU.PRG&quot;).</p>

<P><br>
</p>

<pre> * FileProc.PRG
FUNCTION justfname( filname)
* - Return just a filename

FUNCTION justpath( filname)
* - Return just the path

FUNCTION stripext( filename)
* - Strip the extension

FUNCTION strippath( filename)
* - Strip the path from a file name.</pre>

<P>The idea behind a functional wrapper is to take
procedural code and envelope it a DEFINE CLASS statement in order
to give it an &quot;object&quot; look. So the previous pseudocode
becomes the following:</p>

<P><br>
</p>

<pre> * FileProc.PRG
DEFINE CLASS FileStuff AS CUSTOM
  FUNCTION justfname( filename)
  * - Return just a filename

  FUNCTION justpath( filename)
  * - Return just the path name

  FUNCTION stripext( filename)
  * - Strip the file extension

  FUNCTION strippath( filename)
  * - Strip the path from a filename.
ENDDEFINE</pre>

<P>As you've probably concluded, using the functional
wrapper now involves creating an object, so instead of invoking
the following:</p>

<P><br>
</p>

<pre> *-- Make sure the procedures are in scope
SET PROCEDURE TO FileProc
lcHomeDir= justpath( SYS(16))</pre>

<P>you would instead use this:</p>

<P><br>
</p>

<pre> *-- Make sure the procedures are in scope
SET PROCEDURE TO FileProc
oFile= CREATE( &quot;FileStuff&quot;)
lcHomeDir= oFile.justpath( SYS(16))</pre>

<P>It seems like more typing, so why bother? There are
three reasons. First, functional wrappers are bona fides classes,
meaning you can subclass them to achieve some variant behavior.
Second, different methods can share the same name since the
object identifier makes each one distinct. Third, dealing with
procedures as objects is much more consistent with the way
everything else works in VFP.</p>

<P>There is considerable debate about the benefits of
using functional wrappers instead of procedures (see SPEEDIE-95
in the &quot;References&quot; sidebar), though their functional
utility is undeniable. In the end, it boils down to personal
preference, but making <i>everything </i>an object is probably a
mistake.</p>

<H2>The decorator wrapper pattern</h2>

<P>Finally, a <i>decorator wrapper </i>(I'll just call
it decorator) is an elegant OOP technique that can be handy in a
variety of situations. In particular, the decorator pattern is
useful for extending the functionality of a class without
polluting (or even needing) the original source. </p>

<P>But before I discuss the decorator pattern, let's
examine what happens when you allow a class to grow organically
with inheritance. To illustrate, consider the following class
interface for a frog:</p>

<P><br>
</p>

<pre> DEFINE CLASS Frog AS CUSTOM
  FUNCTION Jump(nValue)
  FUNCTION Eat()
ENDDEFINE</pre>

<P>Amphibians are easily created with Visual FoxPro.
Suppose that you need to create a new sort of frog, one that can
dance. You could subclass Frog as follows:</p>

<P><br>
</p>

<pre> DEFINE CLASS DancingFrog AS Frog
  FUNCTION Dance()
ENDDEFINE</pre>

<P>Suppose you later need a singing Frog. Within your
current hierarchy, you have several obvious options:</p>

<ul>
    <li>You could simply augment the DancingFrog with a Sing()
        method, perhaps renaming the class, if that's possible,
        to EntertainingFrog to better reflect its enhanced
        functionality.</li>
    <li>You could subclass the DancingFrog, add a Sing() method
        to the new subclass, and call the new class, say,
        DancingSingingFrog. </li>
    <li>You could insert a new Frog subclass in the hierarchy
        before DancingFrog, endow it with a Sing() method, and
        call it, say, SingingDancingFrog.</li>
    <li>You could make all Frogs able to sing by augmenting
        original Frog class.</li>
    <li>What the heck, you could vastly simplify this rapidly
        exploding hierarchy by eliminating the DancingFrog class
        and give every Frog the Sing() and Dance() methods in a
        single and monolithic Frog class. </li>
</ul>

<P>So, buffeted by the needs of this current
implementation, you make your choice and take your chances. What
if you later needed a burping frog, one that belches after meals?
Do you subclass again? If so, where? Do you add a Burp() method,
or do you simply augment the Eat() method because problem
analysis indicates that burping naturally follows from eating?
Again, which hierarchical level is best for modification? And
later, when you need a frog that can beg, roll-over, shake-a-leg,
and stay, a new question eventually arises: &quot;How did this
Frog class become such a mess?&quot;</p>

<P>At the outset, pragmatic reuse artists would be
correct in asking when, if ever, will the need for a singing,
dancing, and belching frog arise again? Why not just augment the
frog for this instance, without polluting with trivial nuance our
general, simple, and reusable Frog class?</p>

<P>The answer may be to use a decorator. A decorator,
in essence, is a class with mostly &quot;pass-through&quot;
behavior. It &quot;wraps&quot; a class by reference, forwarding
all messages to the reference except for the messages the wrapper
is designed to intercept. Setting up a decorator takes a bit of
work, but thereafter it's a snap to use. Consider the following
DecoFrog class:</p>

<P><br>
</p>

<pre> DEFINE CLASS DecoFrog AS CUSTOM   
    oRealFrog= .NULL.
  FUNCTION INIT( oFrog)
    THIS.oRealFrog= oFrog
  FUNCTION Jump(n)
    THIS.oRealFrog.Jump(n)
  FUNCTION Eat()
    THIS.oRealFrog.Eat()
ENDDEFINE</pre>

<P>To the outside world, the DecoFrog class has the
same programming interface as a Frog. But it's not a Frog, it's a
<i>lens</i> through which you can &quot;see&quot; a Frog. If you
need a specialized one-off Frog, such as one that sings, you
could do this:</p>

<P><br>
</p>

<pre> DEFINE CLASS DecoSingingFrog AS DecoFrog
  FUNCTION Sing()
    ? WAIT WINDOW &quot;It's not easy being green...&quot;
ENDDEFINE</pre>

<P>Similarly, you can define a dancing frog by simply
subclassing the class DecoFrog as follows:</p>

<P><br>
</p>

<pre> DEFINE CLASS DecoDancingFrog AS DecoFrog
  FUNCTION Dance()
    DecoFrog::Jump(+1)
    DecoFrog::Jump(-2)
    DecoFrog::Jump(+1)
ENDDEFINE</pre>

<P>Retrofitting a decorator is easy. For example,
before your code looked like this:</p>

<P><br>
</p>

<pre> Kermit=CREATE( &quot;Frog&quot;)</pre>

<P>Now, a singing frog can be substituted at run time
like this:</p>

<P><br>
</p>

<pre> Kermit=CREATE(&quot;Frog&quot;)
Kermit=CREATE(&quot;DecoSingingFrog&quot;,Kermit)  </pre>

<P>or more succinctly:</p>

<P><br>
</p>

<pre> Kermit=CREATE(&quot;DecoSingingFrog&quot;,CREATE(&quot;Frog&quot;))</pre>

<P>(Nesting CREATEOBJECT statements work fine in Visual
FoxPro).</p>

<P>Additionally, decorators can be chained, with
functionality added or modified as needed. This gives you
considerable pay-as-you-go flexibility. For example, to build a
singing and dancing frog, do as follows:</p>

<P><br>
</p>

<pre> Kermit=CREATE(&quot;Frog&quot;)  
Kermit=CREATE(&quot;DecoSingingFrog&quot;,Kermit)
Kermit=CREATE(&quot;DecoDancingFrog&quot;,Kermit)</pre>

<P>Or, if you prefer one line of code, use the
following:</p>

<P><br>
</p>

<pre> Kermit=CREATE(&quot;DecoDancingFrog&quot;, ;
         CREATE(&quot;DecoSingingFrog&quot;,CREATE(&quot;Frog&quot;)))</pre>

<P>This creates an object relationship illustrated by
the object diagram in Figure 1. </p>

<P><i>Voil&#136;!</i> You now have an ordinary Frog
named Kermit that appears, in this instance, with the ability to
sing and dance, and we didn't need to pollute the Frog class to
get it. In fact, we didn't need the source to class Frog.</p>

<H2>Decorator benefits</h2>

<P>Here are benefits that come from using decorators:</p>

<ul>
    <li>Decorators can be an effective substitute for
        multiple-inheritance, which isn't supported in Visual
        FoxPro. In the Kermit the Frog example, in some languages
        you could have used multiple inheritance to combine the
        Frog class and, say, an Elvis class to produce an
        entertaining frog. What we did instead is <i>wrap </i>an
        ordinary Frog object in various entertainment objects to
        extend the frog's capability as needed.</li>
    <li>You incur resource expenses on a pay-as-you-go basis
        because you can decide at run time what types of objects
        to create. Also, you don't need to foresee all the future
        functionality of a class, deferring to decorators as new
        needs arise.</li>
    <li>You can extend the functionality of a class knowing only
        its interface; source code usually isn't required.</li>
    <li>If you use a decorator to endow your classes with one-off
        characteristics, you can neatly avoid extending your
        class hierarchy to support the characteristic.</li>
    <li>In some situations you may be able to use a lightweight
        decorator&#151;one that doesn't expose the whole
        interface of the wrapped class&#151;in order to
        accomplish a simple task.</li>
</ul>

<H2>Decorator downsides</h2>

<P>As with all things, the &quot;no free lunch&quot;
pattern applies: You can't get the added flexibility afforded by
using a decorator without some tradeoffs. Here are some of them:</p>

<ul>
    <li>A decorated object isn't the same thing as the object
        itself. In the Frog example, if the line THIS.Eat()
        appears somewhere within the Frog class, it will call the
        Frog's Eat() method, and not the Eat() method that may be
        enhanced by a decorator. </li>
    <li>Decorators are best used with classes that use access
        functions to expose their properties. Querying and
        setting decorator properties without pass-through access
        functions doesn't touch the object being decorated.</li>
    <li>It takes more time to instantiate an object if one also
        instantiates one or more decorators, and once created, it
        takes slightly more time for messages to filter through
        layers of decorators to reach the object itself.</li>
    <li>People who aren't familiar with decorators are likely to
        find the proliferation of wrapper objects confusing.</li>
    <li>A decorator is, in fact, a second distinct class whose
        interface must be maintained in concert with the class it
        decorates. This can be problematic, but is alleviated
        somewhat by making the decorator a subclass of an
        abstract class, as in the diagram in Figure 2. In this
        way, decorators automatically get new interfaces,
        allowing you to wire the &quot;pass-through&quot;
        behavior at a later time. In the class diagrams in
        Figures 2 and 3, if the abstract class defines the
        complete interface for the concrete class (as it should),
        then new decorators appear automatically.</li>
</ul>

<H2>Conclusion</h2>

<P>Decorators change the appearance of an object in a
way that is fundamentally different from subclassing. Subclassing
changes class internals; a decorator changes the class
appearance.</p>

<P>Decorators aren't solutions for every situation, but
occasionally they're just the ticket. The next time you find
yourself sub-classing for the purposes of a particular
implementation, ask yourself if a decorator wouldn't better suit
your situation. </p>

<P><b>Figure 1. Object-oriented decorators change an
object by changing its &quot;skin.&quot; Here, DecoDancingFrog
and DecoSingingFrog effectively change the look of the Frog
object without changing the Frog itself.</b></p>

<P><b><img src="07black1.gif" width="391" height="78"></b></p>

<P><b>Figure 2. Making a decorator a subclass of an
abstract class allows you to map its interface to the class it
decorates.</b></p>

<P><b><img src="07black2.gif" width="259"
height="109"></b></p>

<P><b>Figure 3. Instantiantions of the decorator
automatically inherit the characteristics of the abstract class. <img
src="07black3.gif" width="298" height="178"></b></p>

<P>&nbsp;</p>

<H3>References</h3>

<P>Gamma, E., Helm, R., Johnson, R, and Vlissides, J.
(1994) Design Patterns, Elements of Object Oriented Software.
Reading, MA. Addison Wesley. ISBN 0-201-63361-2</p>

<P>[SPEEDIE-95] Speedie, D., (1995) To OOP and Back,
FoxPro Advisor Magazine April 1996, Advisor Publications. San
Diego CA.</p>

<P><i>Steven Black is the technical lead at SBC/UP!,
a FoxPro consulting company based in Kingston, Ontario, Canada.
He specializes in multilingual and multicultural FoxPro
development, software project turnarounds, and other challenges.
He is the author of Steven Black's INTL Toolkit, a framework for
multilingual FoxPro development in FoxPro 2.x and 3.0, and
several third-party GENSCRNX tools. 613-542-3293,
steveb@stevenblack.com, CompuServe 76200,2110.</i></p>

<P align="center"><a
href="http://www.pinpub.com/foxtalk/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about
FoxTalk and Pinnacle Publishing, visit their website at</strong> <br>
<a href="http://www.pinpub.com/foxtalk/"><strong>http://www.pinpub.com/foxtalk/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content..</font></p>

<P>This article is reproduced from the July 1996
issue of FoxTalk. Copyright 1996, by Pinnacle Publishing, Inc.,
unless otherwise noted. All rights are reserved. FoxTalk is an
independently produced publication of Pinnacle Publishing, Inc.
No part of this article may be used or reproduced in any fashion
(except in brief quotations used in critical articles and
reviews) without prior consent of Pinnacle Publishing, Inc. To
contact Pinnacle Publishing, Inc., please call (800)788-1900 or
(206)251-1900.</p>
</font></body>
</html>
