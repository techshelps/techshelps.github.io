<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Looking Under the Hood of the Jet 3.0 Engine (July)</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<H1>Looking Under the Hood of the Jet 3.0 Engine</h1>

<P>Michael Kaplan and Lynn Shanklin</p>

<P><i>One of the hardest parts of the optimization
process is figuring out exactly what Jet is doing when it reads
or writes data. Michael and Lynn discuss a new unsupported method
in Jet 3.0 that may tell you just what you need to know.</i></p>

<P>The Jet 3.0 Engine, which is used in Access, Visual
Basic, and other Microsoft applications, is an efficient tool for
storing and accessing data. It uses a cost-based query optimizer
that takes your queries and SQL statements and finds what it
thinks is the best plan for executing the query. It also includes
many other features, such as a cache and a read-ahead cache, that
it uses to store data you have accessed already (and might need
again), as well as data that it thinks you might need.</p>

<P>However, all of these built-in features make it
difficult to find the <i>best</i> way to use Jet. Between all
these different caches (and the Windows 95 cache as well),
there's no way to simply try a query two different ways with a
stopwatch, because you can never be sure exactly how much Jet is
helping you by storing information from one timing to the next.
To obtain accurate benchmarks, you need to run each version of
the query multiple times, and literally reboot the computer after
each test.</p>

<P>In this article, we'll introduce ISAMStats, a new
un-documented method of the DBEngine object, which doesn't tell
you how long a given operation takes but instead lets you examine
various statistics that tell you what Jet did when it executed
your request. You can use these statistics to help optimize any
query or function that accesses Jet 3.0 .MDB files.</p>

<H2>What is ISAMStats?</h2>

<P>ISAMStats is a new method of the DBEngine object. It
isn't documented in the <i>Building Applications</i> manual that
comes with Access 95, and you can't find it the online help,
either. Dan Haught and Jim Ferguson, however, have documented it
in the <i>Jet Database Engine Developer's Guide</i> (Microsoft
Press). </p>

<P>The ISAMStats method gives you information on the
various operations that Jet performs as it accesses and changes
data. You call it like this:</p>

<P><br>
</p>

<pre> lngValue = DBEngine.ISAMStats(lngStatNum [,fReset])</pre>

<P>You need to set the lngStatNum parameter, to one of
the long integer values shown in Table 1 to tell Jet which
statistic you wish to track. By setting the optional fReset
(Boolean) parameter to True, you tell Jet to reset the meter for
the statistic back to 0. If you don't specify the value of
fReset, it's assumed to be False. </p>

<P><b>Table 1. The values that ISAMStats can return.</b></p>

<table border="1" cols="3">
<COLGROUP><COL WIDTH="147pt" VALIGN="TOP"><COL WIDTH="42pt" VALIGN="TOP"><COL WIDTH="252pt" VALIGN="TOP"></COLGROUP><TBODY>    <tr>
        <td valign="top"><b>Statistic</b></td>
        <td valign="top"><b>Value</b></td>
        <td valign="top"><b>Comment</b></td>
    </tr>
    <tr>
        <td valign="top">Disk reads</td>
        <td valign="top">0</td>
        <td valign="top">Includes the number of total disk reads
        by Jet, including any reads by background threads and in
        filling the read-ahead cache. Each read may represent
        multiple pages.</td>
    </tr>
    <tr>
        <td valign="top">Disk writes</td>
        <td valign="top">1</td>
        <td valign="top">Includes background activity of Jet, and
        may represent multiple pages.</td>
    </tr>
    <tr>
        <td valign="top">Reads from cache</td>
        <td valign="top">2</td>
        <td valign="top">Any reads from this cache are not
        included in stats for value 0 or 3.</td>
    </tr>
    <tr>
        <td valign="top">Reads from read-ahead cache</td>
        <td valign="top">3</td>
        <td valign="top">The read-ahead cache is made up of pages
        that Jet anticipates you may need. These reads are not
        included in stats for value 0 or 2 . </td>
    </tr>
    <tr>
        <td valign="top">Locks placed</td>
        <td valign="top">4</td>
        <td valign="top">Represents every lock that is placed on
        a page (which is usually several records, since Jet's
        locking scheme uses 2K data pages).</td>
    </tr>
    <tr>
        <td valign="top">Release lock calls</td>
        <td valign="top">5</td>
        <td valign="top">Represents the number of times Jet has
        made a call to release locks. Since Jet can release
        multiple locks with a single call, this number and the
        number of locks placed will often differ.</td>
    </tr>
</TBODY></table>

<P><br>
</p>

<H2>An important detail</h2>

<P>You must make sure the DBEngine object has been
initialized before you use the ISAMStats method. Access 95 will
do this automatically, but if you're using Visual Basic 4, you'll
need to first initialize the engine. Failing to initialize the
DBEngine object may cause general protection faults and other
anomalies, so it's a step you don't want to skip. An easy way to
initialize DBEngine is to obtain the version number property with
a line of code such as this:</p>

<P><br>
</p>

<pre> lngVersion = DBEngine.Version</pre>

<P>If you already have a database loaded, then DBEngine
should already be initialized, but this is a good way to make
sure.</p>

<H2>Using the QueryStats 2.0 add-in</h2>

<P>On the Companion Disk is an add-in called
QueryStats, which uses the ISAMStats method. It allows you to
choose any saved query or function in your application and then
runs the function or query. The add-in returns the relevant
ISAMStat statistics, how long the query or function took to
execute, and the return value (if it was a function). When you
close the add-in, it places the gathered information in a table
(named ztblQueryStats) in your database, using a date/time field
as a primary key (so you can run the same function several times,
perhaps fine-tuning your code between trials). If you run it more
than once, the add-in will give you the option of loading your
old data. Even if you choose not to, the add-in will append the
new data to the table, preserving existing rows.</p>

<P>To install QueryStats, simply decompress the file
from the Companion Disk and copy QRYSTATS.MDA into your Access
directory. Choose Tools|Add-Ins|Add-In Manager, select the add-in
from the list and click on the Install button. You can invoke
QueryStats at any time by selecting Tools|Add-Ins|QueryStats.
Simply choose whether to run a query or a function, type in the
name, the parameters (if it's a function), and the type of
recordset you wanted returned (if it's a query that returns
records). The QueryStats form is shown in Figure 1, where it was
used on the Invoices and OrderList queries in the ORDERS.MDB
sample database that ships with Access 95.</p>

<p><img src="isamst1.gif" width="594" height="438"></p>

<P><b>Figure 1. The QueryStats 2.0 form, used with
the queries in ORDERS.MDB.</b></p>

<H2>How it works</h2>

<P>The heart of the procedure is located in the code
behind the OnClick event of the cmdRun button on frmQueryStats.
You can look at the full procedure by exiting Access, restarting
it, and then loading QRYSTATS.MDA as a regular database. (You
can't do this once you've run it as an add-in since Access won't
unload a library, and you'll get an error if you try to load it
as a both a library and a database.) When you exit and restart,
you're taking advantage of Access 95's &quot;load on demand&quot;
feature (which means that the add-in won't be loaded since it
hasn't yet been called). </p>

<P>You may want to look at some of the
behind-the-scenes work that we used to determine the type of
query (we used the Type property of the Querydef object, and
there are some interesting challenges in determining whether to
get a recordset or execute a query), but the key part of the
procedure (the part that uses ISAMStats) is shown here:</p>

<P><br>
</p>

<pre> 
'Store ISAMStats values for comparison later
lngTime = GetTickCount()
lngDiskRead = DBEngine.ISAMStats(0)
lngDiskWrite = DBEngine.ISAMStats(1)
lngCacheRead = DBEngine.ISAMStats(2)
lngCacheReadAhead = DBEngine.ISAMStats(3)
lngLocksPlaced = DBEngine.ISAMStats(4)
lngLocksReleased = DBEngine.ISAMStats(5)
  
Select Case Me![grpToExecute]
  Case qsRunVBA
    'Execute the Function
  Case qsRunSQL
    'Determine type query and execute
  Case Else
    'This option can't happen
End Select
  
'Get the ISAMStats values
lngDiskRead = DBEngine.ISAMStats(0) - _
 lngDiskRead
lngDiskWrite = DBEngine.ISAMStats(1) - _
 lngDiskWrite
lngCacheRead = DBEngine.ISAMStats(2) - _
 lngCacheRead
lngCacheReadAhead = DBEngine.ISAMStats(3) - _
 lngCacheReadAhead
lngLocksPlaced = DBEngine.ISAMStats(4) - _
 lngLocksPlaced
lngLocksReleased = DBEngine.ISAMStats(5) - _
 lngLocksReleased
lngTime = GetTickCount() - lngTime</pre>

<P>This portion of the code stores the current time
(using the GetTickCount API call) and the values of the six
ISAMStats statistics into variables, runs the function or query,
and then calculates the difference between the values before and
after the query/function executes.</p>

<H2>Conclusion</h2>

<P>The Jet 3.0 engine has some major enhancements that
improve its performance, but many of these enhancements make it
harder to optimize your applications. ISAMStats provides an easy
way to get the kind of feedback you need for the optimization
process.</p>

<H3>Using ISAMStats with NetWare</h3>

<P>If you use Access on a Novell NetWare 3.11 network,
then you're probably aware of the limitations NetWare places on
the number of record locks that you can place on a given file. In
fact, unless you get the patch from Novell to fix this problem,
you can crash the server by requesting too many record locks (see
the July 1994 issue for more details). Even if you get the patch,
you're still limited in the number of locks you can place before
the query simply fails (the maximum number this can be set to is
10,000).</p>

<P>One way around this problem is to use the ISAMStats
method to determine the number of locks that have been placed. By
having your application track how many locks are placed inside a
transaction (where the locks won't be released until you use the
Commit or Rollback methods), you'll no longer have to
&quot;guesstimate&quot; when a query is approaching the limit and
instead can use exact figures to determine how many locks have
been placed.</p>

<P>There is one limitation to this method. Since a
single &quot;Locks released&quot; call can release any number of
locks (or all of them), this method will be effective only in a
situation like a transaction, where you know that no locks will
be freed. This isn't a major problem, however, since large
transactions are one of the most common times that NetWare users
run into the problem. &#151;Michael Kaplan and Lynn Shanklin</p>

<P><i>Michael Kaplan is the owner of Trigeminal
Software Inc., a consulting firm that focuses on all types of
unusual interconnectivity solutions in Microsoft Access, SQL
Server, Visual Basic, and Office. He's an Access MVP and is
finishing up work on a Special Report on Replication for
Pinnacle's The Pros Talk Access 95 series. CompuServe
102363,1726.</i></p>

<P><i>Lynn Shanklin is a writer with the Microsoft
Access User Education group, which provides all the documentation
for Access and related products like the ADT. She worked on
Building Applications with Microsoft Access for Windows 95, as
well as the Solutions sample database and the Access Developer's
Toolkit for Windows 95 documentation. CompuServe 73322,666.</i></p>

<P>&nbsp;</p>

<P align="center"><a
href="http://www.pinpub.com/access/"><img src="Pinnacle.gif"
border="0" width="216" height="72"></a></p>

<P align="center"><strong>To find out more about Smart
Access and Pinnacle Publishing, visit their website at</strong>: </p>

<P align="center"><a
href="http://www.pinpub.com/access/"><strong>http://www.pinpub.com/access/</strong></a></p>

<P align="center"><font size="1">Note: This is not a
Microsoft Corporation website. <br>
Microsoft is not responsible for its content.</font></p>

<P>This article is reproduced from the July 1996
issue of Smart Access Copyright 1996, by Pinnacle Publishing,
Inc., unless otherwise noted. All rights are reserved. Smart
Access is an independently produced publication of Pinnacle
Publishing, Inc. No part of this article may be used or
reproduced in any fashion (except in brief quotations used in
critical articles and reviews) without prior consent of Pinnacle
Publishing, Inc. To contact Pinnacle Publishing, Inc., please
call (800)788-1900 or (206)251-1900.</p>
</font></body>
</html>
