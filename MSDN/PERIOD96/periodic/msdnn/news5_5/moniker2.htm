<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template" content="C:\MSOffice\Templates\NEWNEWS.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Tracking the Wily Web Data with URL Monikers
and OLE Hyperlinks</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<basefont face="verdana, arial, helvetica" color="#000000" size=2> 
<BODY bgcolor="#ffffff" vlink="#666666" link="#ff0000" text="#000000">


<p><font size="6">Tracking the Wily Web Data with URL Monikers
and OLE Hyperlinks</font></p>

<p><font size="2"><i>by Michael T. McKeown</i></font></p>

<p><font size="2">Uniform Resource Locator (URL) monikers and OLE
hyperlinks are two of the lower-level ActiveX services that
applications, ActiveX documents, and ActiveX controls can exploit
to easily download data or link to other documents on the
Internet. Although they are different technologies, OLE
hyperlinks are based on URL monikers.</font></p>

<p><font size="2">A URL is a string representation of a name and
location for an object on the Internet. Monikers are
system-provided objects that were introduced with the OLE2
specification. They exist as persistent COM components that
encapsulate both the ability to locate an object or data and to
retrieve that object or data into memory. Microsoft has combined
the two into URL monikers to reference data and objects located
at Internet locations referenced by URLs.</font></p>

<p><font size="2" face="verdana"><b>Asynchronous
monikers</b></font></p>

<p><font size="2">To be effective on the Internet, binding
operations must be carried out asynchronously. The ActiveX client
technology extends moniker capability to provide asynchronous
binding functionality over the Internet using the
&quot;Asynchronous Monikers&quot; specification.</font></p>

<p><font size="2">To bind to an object, the client requests the
system to create a moniker, via such calls as <b>MkParseDisplayName</b>,
<b>CreateFileMoniker</b>, <b>CreateItemMoniker</b>, or <b>CreateURLMoniker</b>.
The client asks the system to create a &quot;bind context&quot;
to hold generic parameters and information relating to the entire
bind operation. The bind context is created either by calling the
API <b>CreateBindCtx</b> directly or, in the instance of an
ActiveX control, by querying the container for its <i>IBindHost</i>
interface and calling its <b>GetBindCtx</b> member to do the
creation. This bind context is passed into the moniker, telling
the moniker to carry out the binding synchronously or
asynchronously.</font></p>

<p><font size="2">A URL moniker encapsulates the
protocol-specific WinInNet code to do the actual downloading of
the item to which it points. The WinInNet API encapsulates the
file, HTTP, FTP, and Gopher protocols on which URL monikers are
based. URL monikers handle synchronization of the client
process&#146;s message queue more transparently than the WinInNet
API. If neither URL monikers nor WinInNet meet your requirements
for maximum protocol control, you can write directly to Windows
Sockets 2.0.</font></p>

<p><font size="2">Note that Microsoft Internet Explorer 3.0 uses
URL monikers for all HTTP, FTP, and Gopher downloads of OLE
components and associated property data.</font></p>

<p><font size="2" face="verdana"><b>Progressive
downloading</b></font></p>

<p><font size="2">URL monikers allow any client (an ActiveX
control or another application) to bind asynchronously to a file
on the Internet. Once the download process is started, the system
updates the client with progress notifications using the new
ActiveX client interface <i>IBindStatusCallback</i>.</font></p>

<p><font size="2">The newest, easiest, and most efficient way to
download data from a URL is to use the UOS Win32 APIs. These work
equally well inside of any ActiveX framework (such as a
component, a document or frame window, or a scriptable object) or
are completely standalone.</font></p>

<p><font size="2">Unlike other complex interface negotiation
scenarios, these functions require knowledge of no more that two
COM interfaces, <i>IBindStatusCallback</i> and <i>IStream</i>.</font></p>

<p><font size="2">These APIs wrap URL monikers (which in turn
wraps WinInNet) for simplicity. All of the caching and threading
issues are handled automatically for you when you use them. In
addition, the UOS functions handle all of the host binding
negotiation operations if your code is inside an ActiveX Control
container, such as Microsoft Internet Explorer (IE) 3.0. The UOS
functions automatically do the right thing to manage download of
data in the ActiveX client framework.</font></p>

<p><font size="2">Each UOS function works in the same basic way.
The caller implements <i>IBindStatusCallback</i> (optional in
some cases) and then calls the function. <b>URLOpenStream</b> and
<b>URLOpenPullStream</b> require a message loop (<b>GetMessage/DispatchMessage</b>).</font></p>

<p><font size="2">These calls basically simplify the ability to
download a URL to a file with a single function call (optionally,
you can get progress notifications in the background).</font></p>

<p><font size="2">Create a blocking-type stream with a single
function that will block when you call <i>IStream::Read</i>.
Again, you can get optional progress notifications in the
background.</font></p>

<p><font size="2">Post an Internet query (using HTTT POST verb)
with a single call and get results back to a stream.</font></p>

<p><font size="2" face="verdana"><b>OLE hyperlinks</b></font></p>

<p><font size="2">HTML is the standard means of creating Web
pages because all browsers support it. It is not, however, the
optimal vehicle in all cases. With the ActiveX document
specification, documents such as a Visio drawing no longer have
to be compromised into an HTML representation. Built on top of
the OLE in-place activation model, a document can now be hosted
in the browser frame in its native representation.</font></p>

<p><font size="2">Users want to jump between locations within
HTML documents by clicking on hyperlinks and to maintain their
navigation history and their favorite Web page locations. Within
the ActiveX family of technologies, OLE hyperlinks allow the
definition of new, non-HTML document types that can be linked
together easily for navigation purposes. Hyperlinks also can jump
from standalone applications to HTML documents.</font></p>

<p><font size="2">ActiveX documents allow fully integrated
in-frame navigation with the browser, which is an ActiveX
document container. In addition, hyperlinking APIs and OLE
interfaces support non-ActiveX document applications.</font></p>

<p><font size="2">Using these new hyperlinking interfaces and
APIs, you can add hyperlinking capability to a standalone
application like Notepad. You can then click on text displayed in
Notepad and jump to the browser to view HTML. If you click on a
text file in the browser (and the browser doesn't automatically
interpret textual data), you can hyperlink back to Notepad to
view the page. An integrated global navigation and favorites
stack is maintained as users navigate between the browser and
other non-ActiveX document applications.</font></p>

<p><font size="2">OLE hyperlinks contain the information to jump
from one location to the other. The most important part of these
objects is the moniker pointing to the target. In the local case,
this would be a file moniker pointing to a file on the
user&#146;s machine or local network, or an item moniker that
points to a range of cells inside a spreadsheet or a document
inside a database. On the Internet, it's a URL moniker that
points to an HTTP or FTP location. OLE hyperlinks can link to any
object represented by any type of moniker.</font></p>

<p><font size="2">Large HTML documents by convention contain an
index of hyperlinks at the top to permit the user to jump easily
to those locations inside the document without having to manually
scroll down in search of navigation information. OLE hyperlinks
also contain this information in the form of a string passed to
the target document.</font></p>

<p><font size="2" face="verdana"><b>Hyperlink in two
ways</b></font></p>

<p><font size="2">The simple hyperlink navigation model exists as
a helper API allowing hyperlink navigation without knowledge of
any other hyperlink interfaces or objects; for example, an
embedded pushbutton enabling a user to jump to another page. The
model includes the following APIs:</font></p>

<p><font size="2"><b>HlinkSimpleNavigateToString</b> navigates to
the location pointed to by a URL string.</font></p>

<p><font size="2"><b>HlinkSimpleNavigateToMoniker</b> navigates
to the location pointed to the a URL Moniker.</font></p>

<p><font size="2"><b>HlinkGoBack</b> navigates back to the
previous location on the history list.</font></p>

<p><font size="2"><b>HlinkGoForward</b> navigates forward to the
next location on the history list.</font></p>

<p><font size="2">These APIs need information with respect to
where in the navigation stack the user currently is so that they
can go forward or backward properly.</font></p>

<p><font size="2">The APIs work in IE 3.0, as well as in any OLE
Hyperlink frame.</font></p>

<p><font size="2" face="verdana"><b>Behind the
wizard&#146;s curtain</b></font></p>

<p><font size="2">The architecture behind these calls centers
around the standard system object <b>HlinkObject</b>.
Encapsulated within it are the moniker pointing to the target
document, the location string within the document, and the
user-friendly name of that string. Also encapsulated within the
object is the ability to drive the navigation. The helper
hyperlink APIs discussed above create an <b>HlinkObject</b> from
the parameters passed into them and use this object to drive the
navigation.</font></p>

<p><font size="2">An <b>HlinkObject</b> can be created from
system calls such as <b>CreateHlink</b>, <b>CreateFromString</b>,
<b>CreateFromMoniker</b>, or <b>QueryFromData</b>. They can be
saved and loaded, since they support persistence via <i>IPersistStream</i>.
This means that they can be created from an <i>IDataObject</i>
object pointer and support creation via OLE drag and drop.</font></p>

<p><font size="2">The target document, which can be anything
pointed to by a moniker (including an ActiveX document hosted in
a frame, an object embedded inside another document, or a
standalone application), requires no special interface.</font></p>

<p><font size="2">A browse context is a global system object that
contains navigation information in the form of the navigation
stack and history. It is passed to the target through the <i>IHlinkTarget</i>
interface. If the target document is hosted as a standalone
application, it can expose a history list or back/forward
buttons. A targeted document can implement all or part of the </font><font
size="2" face="Arial"><i>IHlinkTarget</i></font><font size="2">
interface to integrate tightly with OLE hyperlinks.</font></p>

<p><font size="2">The document being navigated <i>from</i> is
called the hyperlink container, which can also serve as a
hyperlink target. In all cases, the hyperlink container is
responsible for the visual representation of the hyperlink.</font></p>

<p><font size="2">The hyperlink container also calls the
hyperlink APIs to execute the navigation and can expose a
hyperlink site interface (<i>IHlinkSite</i>) that receives
notification when the navigation operation is complete. The
document can use relative URLs to call back to the site and
request the document&#146;s base URL, resolving them into
absolute links.</font></p>

<p><font size="2">When a document is targeted, its outer
container is called a hyperlink frame. The <i>IHlinkFrame</i>
interface maintains the navigation stack and back/forward
buttons, and it specifies history and favorite locations.</font></p>

<p><font size="2"><i>Michael T. McKeown is an ActiveX client
evangelist in the Microsoft Developer Relations Group. To see the
complete article from which this excerpt was taken, look in the
Microsoft Site Builder Workshop </i><b><i><a href="http://microsoft.com/workshop/prog/prog-gen/moniker.htm">(http://microsoft.com/workshop/prog/prog-gen/moniker.htm)</a></i></b><i>.
The complete article can also be downloaded in Microsoft Word
format.</i></font>
<blockquote>
    <p align="center"><font color="#0000ff" size="3"
    face="verdana">URL monikers allow any client (an
    ActiveX control or another application) to bind
    asynchronously to a file on the Internet.</font>
    <p align="center"><font color="#0000ff" size="3"
    face="verdana">Within the ActiveX family of
    technologies, OLE hyperlinks allow the definition of new,
    non-HTML document types that can be linked together easily
    for navigation purposes. </font></p>

</blockquote>
</font></body>
</html>
