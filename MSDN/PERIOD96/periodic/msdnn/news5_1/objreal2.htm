<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\apps\WINWORD\TEMPLATE\NEWSART.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Deep C++</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<basefont face="verdana, arial, helvetica" color="#000000" size=2>
<BODY bgcolor="#ffffff" vlink="#666666" link="#ff0000" text="#000000">


<font size="6" face="verdana">Deep C++</font>

<p><font size="5" face="verdana">Get Real: Using Objects
in Real-World Programming</font></p>



<p><font size="2"><i>By Brian Overland</i></font></p>



<p><font size="2"><i>&quot;What is the nature of the real
world?&quot; asked the student.<br>
&quot;I don&#146;t know,&quot; said the professor,
&quot;I&#146;ve never been there.&quot;</i></font></p>

<p><font size="2">&#151; Anonymous graffiti artist</font></p>



<p><font size="2">By now you&#146;ve heard it all. Objects will
save the world. (Yes, but how?) To be a real programmer these
days, you&#146;ve got to learn the C++ language. (Yes, but why?)
Object orientation will solve all your problems. (Really? When?)
You may be exasperated with the hoopla, wondering if object
orientation is just an academic pet theory. Do I really need
object orientation, and what has it got to do with real
programming problems?</font></p>

<p><font size="2">The truth is that C++ is a significant tool for
helping you solve certain kinds of problems. It does not solve
problems for you,, nor does it even express solutions you
couldn&#146;t somehow express in C. But for certain real-world
problems, such as developing a graphical user interface, C++more
naturally expresses what you want the program to do. The C++
versions of such programs are more concise, more readable, and
less error-prone than their C counterparts.</font></p>

<p><font size="2">Languages, after all, are tools for expressing
ideas. In theory, you can express everything in English that you
can in another human language, but some languages do express
certain ideas more easily than others. This is why writers in
English sometimes borrow from French, for example, to acquire
that touch of <i>je ne sais quoi</i>. </font></p>

<p><font size="2">In fact, the versatility and expressiveness of
English is due precisely to the fact that it has stolen so much
from other languages. The same relationship exists between C++
and C: C++ can express everything that C can, and then some.</font></p>

<p><font size="4" face="verdana"><b>How the Hype Originated</b></font></p>

<p><font size="2">The only PR problem object orientation has ever
really had is one of overly high expectations. The history of
programming languages is one of dramatic evolution in programming
tools, progressing from machine language to object-oriented tools
such as C++ and Visual Basic. But the most dramatic progress
occurred in the early generations of languages. Later generations
have gradually introduced more subtle refinements&#151;a fact
people have lost sight of.</font></p>

<p><font size="2">Imagine the first computer programmers, who had
to write in machine language. This involved hand-assembly, a
tedious process of looking up the binary code for each
instruction. It wasn&#146;t long before people figured out that
this was exactly the sort of job the computer could do And so
assembly language was born.</font></p>

<p><font size="2">An assembly-language program is made up of at
least somewhat recognizable words. For example, the following
assembly program is vastly preferable to a jumble of hex code:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;.DATA</font>

<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;str DB
&quot;Hello, world!&quot;</font>

<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;.CODE</font>

<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;PUSH str</font>

<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;CALL print</font>

<p><font size="2">High-level languages represented another major
improvement, although not as dramatic as the first. Now these
semi-comprehensible lines of assembly code could be replaced by
an even easier to understand expression (as in BASICA):</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;PRINT
&quot;Hello, world!&quot;</font></p>
<p><font size="2">From there we move to structured languages,
which introduce superior ways of organizing code. But a
structured language does nothing to make a<i> one-line </i>program
easier to write or understand. You probably need to write at
least a 20- or 30-line program, in which you can make use of
complex conditional flow and variable scope, to see the value of
structured languages. .</font></p>

<p><font size="4" face="verdana"><b>The Last Step: Objects</b></font></p>

<p><font size="2">The most recent step, object orientation,
introduces even more subtle refinements. You won&#146;t see its
practical benefits in a one-line or even 30-line program, but in
much, much longer programs, possibly thousands of lines long.
Again, this is not because object orientation is a waste of time,
but because each successive generation of programming languages
addresses larger and more general issues of program organization.</font></p>

<p><font size="2">If you&#146;re a professional
programmer&#151;or even a dedicated student or hobbyist&#151;you
probably do write programs thousands of lines long. Therefore,
with a little patience, you should see ways to improve program
organization with object-oriented languages such as C++.</font></p>

<p><font size="2">The object-oriented approach is to determine
the principal data structures of your program and then organize
functions by the data on which they operate. Object orientation
tends to make very large programs easier to deal with. The
traditional approach to programming regards functions and data
structures as separate entities. That&#146;s fine when you have
only a dozen or so of each, but when you have hundreds of
structures, it&#146;s difficult to remember what function is
supposed to work on what data.</font></p>

<p><font size="2">C++ enables you to build the relationship of
functions to data structures into the source code itself. It also
enables you to use these relationships as the basis for privacy
and data access. These features not only make the workings of the
code more obvious to others who have to maintain it, but prevent
many causes of errors</font></p>

<p><font size="4" face="verdana"><b>Objects and Graphical
Systems</b></font></p>

<p><font size="2">Perhaps the most natural real-world application
of objects is in the world of graphical systems. An object on the
screen clearly has associated data: its size, location, etc. At
the same time, a graphics program gives you ways to manipulate
that object: you can change its size, color, and so on. This
functionality can certainly be provided through traditional
programming, but object orientation makes the connection between
code and data more explicit in the code itself. For example:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;class
CCircle {</font>

<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// Data
members for the circle</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private:</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;CPoint
center;</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;long radius;</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// Functions
for manipulating the circle</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;public: // </font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;void
Move(CPoint);</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;void
Resize(long);</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;void
Redraw(void);</font>
<BR><font color="#0000ff" size="2" face="Courier New">&nbsp;};</font>

<p><font size="2">The workings of a graphics program make the
connection between functions and data particularly important.
Considering how the program works, you&#146;d want the
fundamental units of organization to be <i>circle</i>, <i>square</i>,
<i>line</i>, <i>triangle</i>, etc., rather than <i>functions</i>
vs. <i>data</i>. And that&#146;s the essence of object
orientation.</font></p>

<p><font size="2">Graphical user environments are also natural
places to use object orientation. It&#146;s no coincidence that
the Microsoft Windows operating system uses many such concepts:
Windows are registered as <i>classes</i> and then instantiated,
just as objects are. Window classes can be <i>subclassed</i>,
which is really what inheritance in C++ does. Windows communicate
with each other by sending messages, which are much like method
calls. Windows apologists sometimes say that Windows-based
programming is <i>object-based</i>, not object-oriented, but my
own feeling is that (to quote Shakespeare) &quot;the lady doth
protest too much.&quot; The architecture of Windows truly
involves object-oriented ideas. This is why building
Windows-based programs with an application framework (such as
Microsoft Foundation classes) is a natural way to capitalize on
the real-world usefulness of C++.</font></p>

<p><font size="4" face="verdana"><b>Objects and the Future of
Object-Oriented Systems</b></font></p>

<p><font size="2">In the future, systems programming is liable to
utilize object-oriented concepts even more than Windows does now.
A leading architecture in this area is OLE 2.0, with its
Component Object Model (COM). The systems programming models of
the future take the object-oriented concepts of languages such as
C++ and raise them to the <i>system -level</i>, enabling any
object in the system to communicate with any other object in a
standard way.</font></p>

<p><font size="2">COM is a binary standard, meaning that you can
write all the code in C, as well in as C++. But it&#146;s no
coincidence that statements that use or implement COM are always
easier to express in C++. Consider this common method call
written in C++:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;pInterface-&gt;Release();</font>
<P><font size="2">Here&#146;s what it looks like in the C
version:</font></p>
<P><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;pInterface-&gt;lpVtbl-&gt;Release(pInterface);</font>



<p><font size="2">The C++ version is obviously more concise. This
is because there is harmony between the concepts of C++ and COM.
A C++ object and a COM object are not identical concepts, but
they have many things in common. C++ is a tool that expresses the
ideas of COM much more naturally than non-object-oriented
languages do.</font></p>

<p><font size="4" face="verdana"><b>Getting Started With C++</b></font></p>

<p><font size="2">So object orientation is most helpful in large
programs and in interaction with large, object-oriented systems
(Windows, for example). However, object-oriented concepts and
structures may be difficult to introduce into an existing code
base. It takes great effort to pull apart and redesign a program.
If you&#146;re fortunate, you can start using C++ on a new
project.</font></p>

<p><font size="2">Lacking that, the most practical way to start
gaining benefits from C++ is to start building re-usable
components that you can use in your project now. Or you can find
components in an application framework (for example, the <b>CString
</b>class in MFC) and start using them right away. C++ won&#146;t
produce components for you, but it does provide a superior way of
packaging them for reuse. </font></p>

<p><font size="2">There&#146;s nothing magical about C++; like
any language, it&#146;s only a tool. In the systems of the
future, however, you&#146;ll find that this tool will become
almost a requirement, one that will ultimately repay your
learning efforts.</font></p>

<p><font size="2"><i>Brian Overland has published several books
on C and C++, one of which has been translated into Polish and
Croatian, and has written on programming topics for many groups
at Microsoft. Before coming to Microsoft as a technical writer,
he was a professional programmer, actor, and drama critic.</i></font>

<p align="center"><font color="#0000ff" size="2" face="Arial">Some
languages express certain ideas more easily than others.</font>
<p align="center"><font color="#0000ff" size="2" face="Arial">C++
can express everything that C can, and then some.</font>
<p align="center"><font color="#0000ff" size="2" face="Arial">C++
enables you to build the relationship of functions to data
structures into the source code itself. </font></p>
<p align="center"><font color="#0000ff" size="2" face="Arial">It&#146;s
no coincidence that statements that use or implement COM are
always easier to express in C++.</font></p>

</font></body>
</html>
