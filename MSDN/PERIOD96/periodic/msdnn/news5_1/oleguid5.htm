<html>
<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template" content="C:\WORD6\TEMPLATE\newsart.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Made for Each Other: Greater Compatibility for OLE Controls and Containers</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<basefont face="verdana, arial, helvetica" color="#000000" size=2>
<BODY bgcolor="#ffffff" vlink="#666666" link="#ff0000" text="#000000">


<p><font size="6" face="verdana">Made for Each Other:
Greater Compatibility for OLE Controls and Containers</font></p>

<p><font size="2"><i>by Michael T. McKeown</i></font></p>

<p><font size="2">The good news: the growing use of OLE Controls
brings with it many new opportunities for applications to become
OLE control containers.</font></p>

<p><font size="2">The downside is that with these new containers
come control-container compatibility problems that were not
present under the basically single-container standard Visual
Basic Control (VBX) model. </font></p>

<p><font size="2">This article describes how a control developer
or a control-container developer can minimize these problems and
promote maximum compatibility across the industry.</font></p>

<p><font size="4" face="verdana"><b>OLE Provides More
Flexibility</b></font></p>

<p><font size="2">In contrast to the pre-defined static set of
functions exposed under the VBX model, the dynamic nature of OLE
allows an object to call <b>QueryInterface</b> on another object
to determine its interface capabilities at run time. While this
is great for flexibility, a developer may not know exactly which
interfaces to expect to see or that there is a need to expose
these interfaces to the container during control development.</font></p>

<p><font size="2">As a result, when the control is inserted into
a container that does not expose an OLE interface, method, or
feature that the developer expects to see, the control&#146;s
only option is to degrade itself gracefully and operate without
that functionality. Depending on the severity of this
degradation, the control may be crippled to the extent that it
might not even be able to complete the instantiation process.
Clearly, reduced functionality or, worse still, failure to create
is less than desirable.</font></p>

<p><font size="2">It would be much better if, as a developer, you
knew ahead of time which interfaces the containers using your
control required for optimal execution. This would allow you to
implement the interfaces that those containers expect your
control to provide. Additionally, you would know which interfaces
your control could count on the container providing to it.</font></p>

<p><font size="4" face="verdana"><b>ISVs Raise the Issue to
Microsoft</b></font></p>

<p><font size="2">Many independent software vendors who write OLE
Controls and containers raised this issue numerous times to
Microsoft. In response, Microsoft worked with them to compose a
set of guidelines to ensure maximum interoperability between
controls and containers.</font></p>

<p><font size="2">The<i> OLE Controls and Control Container
Guidelines</i> outline the minimum set of required interfaces,
methods, and features that a control and a container should
implement to interoperate well. Optional interfaces, which give
controls and control containers additional functionality and
capabilities, are also listed. It is certainly acceptable for
controls and containers to implement functionality beyond this
common base set; indeed, it is presumed. Adding extra capability
to a container, for instance, allows certain controls aware of
this extra functionality to operate with increased ability when
within that container.</font></p>

<p><font size="2">Therefore, a control running within any
container developed using these guidelines (or vice versa) can
make assumptions at design time about which interfaces and
methods it can depend on having provided to it. By the same
token, a developer now knows which interfaces and methods he or
she must provide for the container to operate correctly.</font></p>

<p><font size="2">This increased interoperability between the
controls and containers makes them more easily adaptable to
specific customer needs. From a marketing standpoint, a control
will sell much better if a wider range of containers can host it.
Similarly, a container that can host a multitude of controls will
be much more useful to developers than one that works only with a
limited set. Microsoft&#146;s own OLE Controls and containers
will follow these guidelines in future releases.</font></p>

<p><font size="2">The guidelines will be updated as controls
evolve to meet the needs of an ever-changing industry. The latest
version of the guidelines is scheduled to be in the January 1996
Microsoft Development Library (under Technical Articles), and can
also be found at the following locations:</font></p>

<p><font size="2">&nbsp;&nbsp;&nbsp;<i>FTP server</i>:
ftp://ftp.microsoft.com/developr/drg/ole-info/olecontrols</font>

<BR><font size="2">&nbsp;&nbsp;&nbsp;<i>CompuServe</i>: (WinObj forum) GO WINOBJ;
library #1 (MS Index/Info)</font>

<BR><font size="2">&nbsp;&nbsp;&nbsp;<i>World Wide Web</i>:
http://www.microsoft.com/intdev/inttech/ocxguide.htm</font>

<p><a name="_Toc340410468"><font size="4" face="verdana"><b>Guideline
Verification Software</b></font></a></p>

<p><font size="2">To encourage developers to embrace these
guidelines and provide a consistent means of verification,
Microsoft has developed a software implementation of version 1.1
of the guidelines document. Taking advantage of the new Microsoft
Foundation Class Library (MFC) 4.0 control container support
found in the Visual C++ development system version 4.0, the
&quot;Verification Container&quot; verifies that any OLE Control
placed into it implements the interfaces and methods listed in
the guidelines. Conversely, the &quot;Verification Control&quot;
verifies adherence to the guidelines for any OLE Control
container into which it is dropped.</font></p>

<p><font size="2">During the process of verification, these
modules verify only the <i>existence</i> of certain interfaces
and methods (and ambient properties for containers). They do not
attempt to verify correct semantic behavior of an
interface&#146;s methods, nor do they exercise full
functionality.</font></p>

<p><font size="2">The source code for both the verification
control and the container is publicly available and freely
distributable, allowing recompilation of the .EXE and .OCX files
for other processor platforms. The verification control and
container source code enables developers to debug their
applications to determine where and why failures occur, as well
as to provide a good, general-purpose control container sample
application.</font></p>

<p><font size="4" face="verdana"><b>The Verification Process</b></font></p>

<p><font size="2">For tutorial purposes, you may want to step
through the control or container code and follow the verification
process. Of course, you must first install Visual C++ 4.0 and the
debug MFC libraries. The Verification Container is debugged just
as any executable would be within the integrated development
environment (IDE).</font></p>

<p><font size="2">Load the project, build a debug version, and
then set your breakpoints at the lines you want to debug. An
added bonus is that if you instantiate a control that was
developed with MFC 4.0, you can then step into the MFC code and
observe the calls to <b>COleControl</b>, the base class for
controls developed with Visual C++ Control Wizard.</font></p>

<p><font size="2">Alternatively, using the Verification Control
you can step into an MFC container&#146;s (like the Verification
Container) code. Load the VControl project workspace into the IDE
and then, from the Build/Settings dialog box, select the Debug
tab. Enter the path to the debug version of the container on the
&quot;Executable for debug session&quot; line. You can then load
the specific source file for the container into the IDE and set
breakpoints strategically. Both of these approaches are excellent
lessons in understanding the specifics of the communication
between the container and its control.</font></p>

<p><a name="_Toc340410473"><font size="4" face="verdana"><b>Additional
Resources</b></font></a></p>

<p><font size="2">For additional information about OLE Controls,
Microsoft Press has published <i>OLE Controls Inside Out.</i>
This is highly recommended for anyone doing control and container
development. It deals in depth with many of the common issues
facing control developers, while also providing insight into the
inner-workings of the control architecture. Microsoft Press also
has published the second version of <i>Inside OLE,</i> which
explains the details of control and control container development
at a low level.</font></p>

<p><font size="2">For a description of the methodology behind the
design of the VControl and VContainer, as well as more detailed
usage information, please see the technical article titled<i> </i>&quot;Implementation
Notes for the OLE Control and Control Container Guidelines
Verification Software.&quot; It provides you with a
developer&#146;s view of the new classes added to MFC for control
containment support, as well as other issues to be aware of when
writing an OLE Control container using MFC.</font>

<p><font size="2">This article, the MFC source code, the built
verification container .EXE, the verification control .OCX, and a
setup program all accompany the guidelines and can be found in
the Development Library or at the online locations listed above
(look for a \VERIFY subdirectory).</font>

<p><font size="2"><i>Michael T. McKeown is a technical evangelist
for OLE in the Developer Relations Group.</i></font>

<p align="center"><font color="#0000ff" size="2" face="Arial">With
new containers come control-container compatibility problems that
were not present under the Visual Basic Control model.</font>

<p align="center"><font color="#0000ff" size="2" face="Arial">A
developer now knows which interfaces and methods to provide for
the container to operate correctly.</font></p>
</font></body>
</html>
