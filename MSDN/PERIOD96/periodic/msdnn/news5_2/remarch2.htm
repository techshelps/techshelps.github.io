<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm"
content="The Unused style macro was run!	10/26/94	11:28 AM">
<meta name="Template"
content="C:\apps\WINWORD\TEMPLATE\NEWSART.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Remote Automation: When, Why, and How</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<basefont face="verdana, arial, helvetica" color="#000000" size=2> 
<BODY bgcolor="#ffffff" vlink="#666666" link="#ff0000" text="#000000">


<p><font size="6" face="verdana">The Mysteries of Remote
Automation: When, Why, and How</font></p>

<p><font size="2"><i>by Ken Bergmann</i></font></p>

<p><font size="2">In the last few months, I have noticed a
phenomenon. And I don&#146;t mean the World Wide Web. I am
talking about the inundation of client/server developers with a
lot of hype about three-tiered architectures and distributed
processing.</font></p>

<p><font size="2">At the heart of this blizzard of information is
a new buzzword: Remote Automation. At developer conferences, on
the Net, in press articles, the mantra is: &quot;Remote
Automation will help you. Use Remote Automation in your system
and distribute the load. Remote Automation is your friend.&quot;</font></p>

<p><font size="2">Take a break, folks. Remote Automation
won&#146;t work for every system; it will only help in a very
small percentage of situations. The trick is understanding when
it will help, and then milking it for everything it&#146;s worth.</font></p>

<p><font size="2">This article details the existing Remote
Automation architecture and talks about the different issues
involved in the construction or deployment of Remote Automation
solutions. It assumes a solid knowledge of the Microsoft Visual
Basic programming system and a firm understanding of the OLE
Automation model and usage.</font></p>

<p><font size="2">It covers three main topics. The first section
is for developers who have used OLE servers before and who have
some understanding of Remote Automation, but who need the details
on how to turn their OLE server into a Remote Automation server. </font></p>

<p><font size="2">The second section moves through an example of
a Remote Automation server that allows clients to print Microsoft
Access reports from a remote database. The sample in this section
is designed to illustrate several key Remote Automation concepts.</font></p>

<p><font size="2">The third section outlines some of the more
abstract concepts involved in developing Remote Automation
solutions. These concepts should be helpful for anyone who wants
to understand the differences among the variety of Remote
Automation architectures.</font></p>

<p><font size="4" face="verdana"><b>The details of Remote
Automation</b></font></p>

<p><font size="2">First, let&#146;s run down some of the
specifics about Remote Automation&#146;s components.</font></p>

<p><font size="2">The server: </font></p>

<blockquote>
    <p><font size="2"><i>RACMGR32.EXE (Remote Automation
    Connection Manager for 32-bit operating systems)</i>. This
    application sets up an OLE server to accept Remote Automation
    requests. It allows the user to specify which network
    protocol to use, which security contexts are allowed, and
    other information for the Automation Manager. Information
    maintained in this application is stored in the system
    registry.</font></p>
    <p><font size="2"><i>RACMGR16.EXE (Remote Automation
    Connection Manager for 16-bit operating systems)</i>. This
    application serves the same purpose as RACMGR32.EXE, but it
    runs on 16-bit operating systems.</font></p>
    <p><font size="2"><i>AUTMGR32.EXE (Automation Manager for
    32-bit operating systems)</i>. This program uses the settings
    from the registry to proctor Remote Automation requests from
    the network through the automation proxy to the appropriate
    automation servers. This application must be running for a
    computer to accept Remote Automation requests.</font></p>
    <p><font size="2"><i>AUTPRX32.DLL (Remote Automation proxy
    for 32-bit applications)</i>. Automation Manager uses this
    dynamic-link library (DLL) to act as a proxy with a local
    automation client. This proxy relays automation requests to
    the Automation Manager over the network and from the network
    to the local automation client.</font></p>
    <p><font size="2"><i>AUTPRX16.DLL (Remote Automation proxy
    for 16-bit applications on 32-bit operating systems)</i>.
    This proxy performs the same function as AUTPRX32.DLL, but it
    services 16-bit applications.</font></p>
    <p><font size="2"><i>AUTPRX.DLL (Remote Automation proxy for
    16-bit applications on 16-bit operating systems)</i>. This
    proxy performs the same function as AUTPRX16.DLL, but it runs
    on 16-bit operating systems.</font></p>
</blockquote>

<p><font size="2">Figure 1 shows where the pieces go in your
system:</font></p>
<img src="REM1.gif" alt="Where the pieces go in your system">
<p><font color="#0000ff" size="1" face="Arial">&nbsp;&nbsp;&nbsp;&nbsp;<i>Figure 1: Where
the pieces go in your system</i></font></p>

<p><font size="2">Here are some more facts about what Remote
Automation uses today:</font></p>

<blockquote>
    <p><font size="2">A 32-bit operating system for a server
    platform: Windows NT or Windows 95.</font></p>
    <p><font size="2">A client machine running Windows 3.1 or
    later.</font></p>
    <p><font size="2">Visual Basic (16-bit) as a minimum
    development platform for the client executable.</font></p>
    <p><font size="2">Visual Basic (32-bit) Enterprise Edition as
    a minimum development environment for the server executable.</font></p>
    <p><font size="2"></font>&nbsp;</p>
</blockquote>
<p><font size="4" face="verdana"><b>How to set up the Remote
Automation components</b></font></p>

<p><font size="2">As should be apparent from Figure 1, you need
to have the Remote Automation proxy running on the client machine
and the Remote Automation Manager running on the server machine.</font></p>

<p><font size="2">Here are the steps to get an existing system
with both sets of source code (client and server) up and running
remotely. First, we&#146;ll outline the steps to create a client
installation package.</font></p>

<p><font size="4" face="verdana"><b>Creating the client
installation package</b></font></p>

<p><font size="2">Open the server&#146;s project file in the
Design Environment. On the <b>Tools</b> menu, click <b>Options</b>.
Select the <b>Project</b> tab. Ensure that the <b>OLE server</b>
is checked in the <b>StartMode</b> frame. Click <b>OK</b>.</font></p>

<p><font size="2">On the <b>File</b> menu, click <b>Make EXE.</b>
Press the Options button. Ensure that the <b>Remote Server
Support Files</b> option is checked. Press <b>OK</b>. Press <b>OK</b>
again to build the server executable.</font></p>

<p><font size="2">If you already have an executable for the
client, go to the next step; if not, build this executable now.</font></p>

<blockquote>
    <p><font size="2">Open the Visual Basic 4.0 Setup Wizard.
    Enter the path and file name for the project file for the
    client source code. Choose any options you want here. Press
    the <b>Next</b>. If you chose to build a new executable, this
    happens now. Continue with the next step when the Setup
    Wizard is at Step Four.</font></p>
    <p><font size="2">If your client application uses any local
    automation servers, these should be listed in the list box.
    Press the <b>Add OLE Servers</b>.</font></p>
    <p><font size="2">You should be at a <b>File Navigation</b>
    dialog box. Change the <b>Files of Type</b> combo box to
    display Remote OLE Servers (*.VBR). You will find a .VBR file
    in the same directory as the server executable. Choose this
    file and press <b>OK</b>.</font></p>
    <p><font size="2">You should now be at a <b>Remote OLE Server
    Details</b> dialog box. Enter the name of the server machine
    in the <b>Network Address</b> text box. Choose your primary
    network protocol from the <b>Network Protocol</b> combo box.
    Choose the authentication level you desire from the <b>Authentication</b>
    combo box. Press <b>OK</b>.</font></p>
    <p><font size="2">Continue through the Setup Wizard until you
    reach Step Six. Choose <b>Install in Application Directory</b>
    in the Deployment Model group box. Ensure that the check box
    for <b>Remote Automation support files</b> is <i>cleared</i>.
    Press the <b>Next</b> button.</font></p>
    <p><font size="2">Complete your work with the Setup Wizard.
    When done, you will have a complete client installation
    package. Run the SETUP.EXE that was created to install the
    client software on a client machine.</font></p>
</blockquote>

<p><font size="4" face="verdana"><b>Creating the server
installation package</b></font></p>

<p><font size="2">To create an installation package for the
server executable:</font></p>

<blockquote>
    <p><font size="2">Open the Visual Basic 4.0 Setup Wizard.
    Enter the path and file name for the project file for the
    server source code. Choose any options you want here. Press
    the Next button. If you chose to build a new executable, this
    happens now. Continue with the next step when the Setup
    Wizard is at Step Six.</font></p>
    <p><font size="2">When the Setup Wizard is at Step Six,
    choose <b>Install as an OLE Automation shared component</b>
    in the Deployment Model group box. Ensure that the check box
    for <b>Remote Automation support files</b> is checked. Press
    the Next button.</font></p>
    <p><font size="2">Complete your work with the Setup Wizard.
    When done, you will have a complete server installation
    package. Run the SETUP.EXE that was created to install the
    server software on a server machine.</font></p>
</blockquote>

<p><font size="2">At this point, you should have installation
packages for your client and your server. Install the software on
the respective machines. The server installation should create a
Remote Automation Management Folder or Group. The two icons
created in this folder or group can be used to set up and
administer all of the Remote Automation services for the server
machine.</font></p>

<p><font size="2">Run the Automation Manager application. This is
the component to which the clients will connect. It will pass
client requests to local OLE servers. Now go to a client machine
and install the client software. During the installation, the
information about the remote server is inserted into the registry
of the client machine.</font></p>

<p><font size="4" face="verdana"><b>Peripheral issues</b></font></p>

<p><font size="2">These are the basics, but there are some other
issues involved. If you want the user at a client machine to
control the server name or network transport that is used to
connect to the server machine, you will also need to install
RACMGR32.EXE on the client. Setup Wizard currently doesn&#146;t
do this. For an unattended system, there must be a facility to
ensure that the Automation Manager is started when the system
reboots. For situations where the network address of the server
machine changes, you will need to provide update mechanisms for
the clients to run on their local machines.</font></p>

<p><font size="2">These issues bring up the subject of
CLIREG32.EXE, a handy tool for a client installation included in
the setup package with the Setup Wizard. The purpose of
CLIREG32.EXE is to modify the registry of a client machine to
include the necessary entries for the client to perform Remote
Automation against the server. This utility accepts the following
parameters:</font></p>

<p><font size="2">&#149; &lt;VBR File&gt; = the name of the
remote server&#146;s .VBR file. This file is included with the
installation package. It contains the information to register the
server&#146;s .TLB file, which is also included.</font></p>

<p><font size="2">&#149; &#150;s = Specifies the network address
(server name) for the server machine.</font></p>

<p><font size="2">&#149; &#150;p = Specifies the network protocol
used to communicate with the server machine.</font></p>

<p><font size="2">&#149; &#150;a = Specifies the authentication
level used by the server machine.</font></p>

<p><font size="2">&#149; &#150;t = Specifies the type library
file.</font></p>

<p><font size="2">&#149; &#150;u = Installs the registry entries
from the .VBR file.</font></p>

<p><font size="2">&#149; &#150;q = Quiet mode, runs with no
dialogs.</font></p>

<p><font size="2">&#149; &#150;l = Logs any error information in
the CLIREG.LOG file.</font></p>

<p><font size="2">&#149; &#150;nologo = Specifies to not display
any copyright information.</font></p>

<p><font size="2">This is essentially the same information that
can be viewed and modified using RACMGR32.EXE. The difference is
that RACMGR32.EXE requires that the entries for the type library
already exist. Using CLIREG32.EXE&#146;s command-line interface
makes it easy to create a batch file to call this application and
handle the registration and configuration in one step. This would
be ideal for upgrading clients when a server name or OLE server
type library changes.</font></p>
<p><font size="4" face="verdana"><b>How to build a Remote
Automation server</b></font></p>

<p><font size="2">Building a Remote Automation server is really
not much different from building any other automation
server&#151;or so it appears at first. Indeed, implementing
Remote Automation servers is no different than implementing any
other automation server.</font></p>

<p><font size="2">But the design of a Remote Automation server
presents numerous issues that can directly affect its
architecture. Many of these issues are not nearly as critical to
the design of local automation servers because the cost involved
in moving data locally is so much less than moving it remotely.
With that in mind, here are some things to remember throughout
this section:</font></p>

<p><font size="2">I included the sample below so I can point out
some important considerations that went into the server design.
This server is a learning tool, and certainly not intended as a
real product. However, for the sample to be effective, it needs
to serve a purpose and show some real functionality. I use this
example to show the basics of building an automation server to
help readers focus on the real issues and not get bogged down in
the details of the class design.</font></p>

<p><font size="4" face="verdana"><b>Designing the server
interface</b></font></p>

<p><font size="2">The sample has both server (<b>RepGen</b>) and
client (<b>RepGenTest</b>) components. The server exposes, among
other things, a list of reports from Microsoft Access for Windows
95. It provides the basics of a network printing utility and
allows the user to print reports without having to have Microsoft
Access loaded on the user&#146;s machine.</font></p>

<p><font size="2">Anyway, this is what my class definition looks
like:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Private AccessApp As Access.Application</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Private sDBName As String</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Private sCurrentRep As String</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public fPhaseTwo As Boolean</font>
</p>
<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Property Get DBName() As String</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Property Let DBName(ByVal sVal As String)</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Function GetReport(ByVal sRepName As String) As Object</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Function InitializeAccess(ByVal sDBName As String) As Boolean</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Function ReportList() As Variant</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Sub PrintReport(Optional fAsync As Boolean)</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Private Sub ReportPrint()</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Sub TerminateAccess()</font></p>
<p><font size="2">Notice that I don&#146;t expose the application
object and that I have limited the scope of all objects as much
as possible. In the case of the <i>fPhaseTwo</i> variable, I
don&#146;t need property procedures because there isn&#146;t much
to it, and I wanted to minimize this code as much as possible.
Remote servers should always be as tight as possible.</font></p>

<p><font size="2" face="verdana"><b>Object references</b></font></p>

<p><font size="2">I always try to give users of my server as much
power as possible without slowing down the access mechanisms. So
I am just providing the client with a reference to a report
object. Essentially, once they have this reference, they can just
party on it and do whatever they want. Note that this isn&#146;t
always the best idea; if it weren&#146;t making a point for me, I
would probably remove the object reference on the <b>GetReport</b>
routine. The following lines of code from the function show why:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;sCurrentRep
= sRepName</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;AccessApp.DoCmd.OpenReport
sCurrentRep, acPreview</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Set
GetReport = AccessApp.Reports(sCurrentRep)</font></p>

<p><font size="2">There are two reasons I wouldn&#146;t usually
return an object reference like this. First, the report object I
am returning is a user interface construct (a window). This
generally isn&#146;t a good idea because you can&#146;t really
guarantee the life of such a window. Specifically in this case, I
can&#146;t be sure what the users are going to do to it; they
could easily freeze the interface on the remote machine.</font></p>

<p><font size="2">Secondly, the reference returned from the
function will require a cross-process call every time the user
accesses the object. Cross-process calls are very expensive for
an application, particularly when the processes are on two
different machines.</font></p>

<p><font size="4" face="verdana"><b>Notifications between the
client and the server</b></font></p>

<p><font size="2">For those who would like to understand what
callbacks and asynchronous processes look like in code, the <b>PrintReport</b>
routine shows one mechanism used to disjoint processes:</font></p>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Public Sub PrintReport(Optional fAsync As Boolean)</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;If IsMissing(fAsync) Then</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;ReportPrint</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Else</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;If fAsync Then</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;fPhaseTwo = False</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;tmMain.Enabled = True</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Else</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;ReportPrint</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;End If</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;End If</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;End SubEnd If</font></p>

<p><font size="2">In this example, I didn&#146;t use a standard
callback routine. Instead, I implemented a two-phase commit. The
point is: Don&#146;t always assume that standard implementations
will provide the most efficient support for the features in your
system. If you don&#146;t need the overhead of implementing full
callback routines, don&#146;t use them. In this example, I wanted
the user to have the choice to print reports in real time or
asynchronously. A two-phase commit provides this with almost no
code duplication.</font></p>

<p><font size="2">Figure 2 shows the synchronous process flow:</font></p>

<img src="REM2.gif" alt="A synchronous process flow">

<p><font color="#0000ff" size="1" face="Arial"><i>Figure 2: A
synchronous process flow</i></font></p>

<p><font size="2">Figure 3 illustrates the asynchronous process
flow:</font></p>


<img src="REM3.gif" alt="An asynchronous process flow">
<p><font color="#0000ff" size="1" face="Arial">&nbsp;&nbsp;&nbsp;<i>Figure 3: An
asynchronous process flow</i></font></p>

<p><font size="2">You can see that including the flag enables the
client to request the printing of a report asynchronously. The
client can have the report printed in real time simply by
omitting the flag. Of course, I could have just as easily
reversed these conditions and required a flag to print in real
time with no flag for asynchronous printing; it depends on my
server&#146;s expected usage.</font></p>

<p><font size="2">The other important point to glean from this is
the implementation of a local callback routine. Many people
consider callbacks useful only in distributed applications. As
Figure 3 shows, local callback routines can be very effective in
delegating the normal processes in a client/server system. For
more information about callback routines and process linkages,
see the next section, &quot;Remote Automation in
Perspective.&quot;</font></p>

<p><font size="5" face="Arial">Remote automation in perspective</font></p>

<p><font size="2">The object of this section is to provide a
high-level explanation of the decisions that go into specific
implementations of Remote Automation servers. It also attempts to
tie in the benefits or shortcomings of Remote Automation with the
issues faced in online transaction processing (OLTP) in
client/server development today.</font></p>

<p><font size="4" face="verdana"><b>The simple case</b></font></p>

<p><font size="2">The most basic use for Remote Automation is
fairly trivial: A Remote Automation server is instantiated on a
machine by a nonlocal client. The nonlocal client gives the
server the information it uses to do some form of processing.
Once the processing is completed, the server returns control to
the nonlocal client, and is then released by the nonlocal client.
Figure 4 shows this process:</font></p>

<img src="REM4.gif" alt="A basic use of Remote Automation">
<p><font color="#0000ff" size="1" face="Arial">&nbsp;&nbsp;&nbsp;<i>Figure 4: A
basic use of Remote Automation</i></font></p>

<p><font size="2">Here are some cases in which you might use this
process:</font></p>

<blockquote>
    <p><font size="2">Performing intense calculations on data
    that require lookup, such as computing taxes, risk analysis
    of loans, stellar cartography.</font></p>
    <p><font size="2">Massaging data based on business rules.
    This could include building matchcodes, retrieving or
    creating universal ID numbers, or doing full-text searches of
    the Library of Congress for words sounding like
    &quot;Vogon.&quot; You get the idea.</font></p>
    <p><font size="2">Encapsulating departmental processing
    routines into a common server. These could include, for
    example, routines for calculating the number of paydays for
    your department in the current quarter; figuring out the best
    time of day to ask your boss for a raise; or for returning
    the full title of anyone in the company when given an e-mail
    name (assuming you weren&#146;t using Microsoft Mail or
    Microsoft Exchange).</font></p>
    <p><font size="2">Launching processes that require custom
    software. These may include printing reports using &quot;My
    Favorite Report Writer for OS/2,&quot; retrieving data from
    the Internal Revenue Service, or writing a really cool app to
    e-mail a daily cartoon from the Internet to 4,000 of your
    closest friends.</font></p>
</blockquote>

<p><font size="2">This list is not very expansive and contains
items that have no reason to be distributed. This kind of
distribution just doesn&#146;t have much impact on the OLTP
solutions prevalent today.</font></p>

<p><font size="4" face="verdana"><b>Callback routines and
asynchronous processing</B></font></p>

<p><font size="2">The next most complex use for Remote Automation
is still pretty basic, but now the system can operate
asynchronously. Here the client passes a callback reference to
the server before requesting that server commence processing. The
server takes the data and the callback handle, and returns
control to the client by exiting the routine. It then wakes up on
its own, processes the data, and executes the callback method of
the callback object on the nonlocal client. Figure 5 shows this
process: </font></p>

<img src="REM5.gif" alt="Asynchronous Processing">
<p><font color="#0000ff" size="1" face="Arial">&nbsp;&nbsp;&nbsp;<i>Figure 5:
Asynchronous Processing</i></font></p>

<p><font size="2">The classification list and the performance
numbers for this approach are the same as when the client
controls the server. The difference is that the client machine
may be active during the time the server is processing. This
approach has some other subtleties that are not relevant at this
level of discussion. Suffice it to say that this approach usually
achieves only the smallest of performance gains and its
implementation can be extremely tricky.</font></p>

<p><font size="4" face="verdana"><b>The three-tiered model</b></font></p>

<p><font size="2">The most common use of Remote Automation is
controlling a server that proctors services from a set of
nonlocal servers to a set of nonlocal clients. In this case there
are at least three different machines that communicate,
theoretically, via Remote Automation (hence
&quot;three-tiered&quot;). Figure 6 illustrates the communication
paths between the machines and their physical relation to each
other:</font></p>

<img src="REM6.gif" alt="Remote Automation in a three-tiered model">
<p><font color="#0000ff" size="1" face="Arial">&nbsp;&nbsp;&nbsp;<i>Figure 6:
Remote Automation in a three-tiered model</i></font></p>

<p><font size="2">Here are some reasons to use this approach:</font></p>

<blockquote>
    <p><font size="2">You need to obtain a high level of
    abstraction between your front-end and your data. Usually
    this means that you are pulling data from more than one
    source. If you just want another layer between your SQL
    Server and your Visual Basic code, this shouldn&#146;t count.</font></p>
    <p><font size="2">You need a fire wall between your data
    network and your applications network. This usually occurs
    when you have the database on a server on one network with an
    application running on another network. The middleware will
    sit on the fence with access to both networks. Applications
    on the second network have no privileges into the first
    network; they can only manipulate the server that can, in
    turn, manipulate the data on the first network.</font></p>
    <p><font size="2">You have self-contained processes, such as
    batch report printers or data processors, that can be run in
    a scaled environment. These processes usually accept either
    limited startup information and just process predefined sets
    of data, or can be designed to operate on a job-by-job basis.
    The information for a job is sent to a proctoring server that
    hands out the job to a &quot;grunt boy&quot; (a.k.a.
    processor). The client can then monitor the job through the
    server. The server can be designed to spawn grunt boys as
    required to handle the current load of jobs.</font></p>
    <p><font size="2">You have several steps of data processing
    that must be coordinated but cannot tie up an end-user
    machine. By using this type of proctor to facilitate the
    processing, you can free the end-user&#146;s machine,
    periodically interrupting it as the job progresses. This
    differs from the previous case because it requires no
    callbacks or knowledge of the client or the processors to
    perform its tasks.</font></p>
</blockquote>

<p><font size="4" face="verdana"><b>Summary</B></font></p>

<p><font size="2">So now you&#146;ve had a look at the three main
types of Remote Automation. If you understand them, it should not
be hard to choose the right implementation for your system. But
remember the sample discussed previously. Sometimes the
implementation that is just right for you doesn&#146;t fall into
a single category; instead it falls right on the line. But, hey,
that&#146;s another article (which I haven&#146;t yet written).</font></p>

<p><font size="2"><i>Ken Bergmann, a developer and writer in the
Developer Network, is not really known for anything. His sole
redeeming factor is love of systems design. His prime motivation
as a writer usually takes the form of a precisely aimed boot to
the head.</i></font></p>



<p align="center"><font color="#0000ff" size="2" face="Arial">Take
a break, folks. Remote Automation won&#146;t work for every
system.</font>
<p align="center"><font color="#0000ff" size="2" face="Arial">The
design of a Remote Automation server presents numerous issues
which can directly affect its architecture.</font>
<p align="center"><font color="#0000ff" size="2" face="Arial">Always
try to give users of your server as much power as possible
without slowing down the access mechanisms.</font>
<p align="center"><font color="#0000ff" size="2" face="Arial">The
most common use of Remote Automation is controlling a server that
proctors services from a set of nonlocal servers to a set of
nonlocal clients.</font></p>
</font></body>
</html>
