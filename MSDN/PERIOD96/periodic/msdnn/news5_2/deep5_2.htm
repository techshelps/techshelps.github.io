<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\apps\WINWORD\TEMPLATE\NEWSART.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Deep C++:Don’t Let These Words Scare You</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>
<basefont face="verdana, arial, helvetica" color="#000000" size=2> 
<BODY bgcolor="#ffffff" vlink="#666666" link="#ff0000" text="#000000">


<p><font size="6" face="verdana">Deep C++: Don&#146;t Let
These Words Scare You</font></p>

<p><font size="2"><i>by Brian Overland</i></font></p>

<p><font size="2">In ancient Greece, the Pythagoreans met as a
secret brotherhood guarding the truths of mathematics.
Understanding these truths was only for the elite. One member was
even booted out for revealing a holy of holies: the knowledge
that the square root of two is irrational.</font></p>

<p><font size="2">In a manner perhaps not quite so deliberate, an
arcane priesthood seems to have developed around C++. If people
merely had to understand the syntax and practical benefits of the
language, perhaps the truths of C++ might be available to all.
But too often, people feel that unless they master a set of
strange, multisyllabic mantras&#151;words such as
&quot;polymorphism,&quot; &quot;abstraction,&quot; and
&quot;encapsulation&quot;&#151;they don&#146;t really understand
the essence of C++.</font></p>

<p><font size="4" face="verdana"><b>Polymorphism</b></font></p>

<p><font size="2">Polymorphism is a useful term if you&#146;re
going to talk about comparative languages and systems, because
the concept extends beyond the C++ mechanism (virtual functions).
It can take years to understand this term fully and (more
significantly) to comprehend when it could possibly make a
difference. In the context of C++ itself, you can replace
&quot;polymorphism&quot; with the phrase &quot;using virtual
functions.&quot; That&#146;s all it really means. </font></p>

<p><font size="2">In general, polymorphism is a technique for
making objects act more like independent, autonomous units.
Polymorphism de-centralizes control. </font></p>

<p><font size="2">In fact, the best way to understand the concept
is to look at the practical requirements of a system such as
Windows. Windows is a message-based architecture that involves
polymorphism. When the system sends a notification to an
application window (&quot;respond to a mouse click,&quot; for
instance), the system cannot anticipate all the possible
responses. If it could&#151;if there were a finite list of
responses to choose from&#151;Windows would be an incredibly
limited system. </font></p>

<p><font size="2">Polymorphism (literally, &quot;many forms&quot;
from Greek) really means unlimited possible responses. Because
there are an unlimited number of possible responses to the same
message, responses to Windows messages have to be polymorphic:.
In particular, new applications can be continually developed in
the future, each bringing with it new message-handling code.</font></p>

<p><font size="2">The innovation of object-oriented programming
is simply to build this flexibility into the structure of a
programming language. In C++, the virtual-function capability
lets you apply this kind of mechanism wherever you choose. In C,
you&#146;d have to use callback functions.</font></p>

<p><font size="2">Consider a call to a virtual <b>Print()</b>
function (an admittedly cliche cliched example):</font>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;Shape
*pShape;</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// Assign
pShape to print to</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// a class
derived from Shape</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;pShape-&gt;Print();</font></p>


<p><font size="2">The point of this example is that the call to <b>Print()</b>
will always call the derived class&#146;s implementation,
assuming that <b>Print()</b> is virtual. And because the
potential number of derived classes is unlimited, the number of
possible responses is unlimited. This works correctly even when
new classes are added after this code is compiled. New responses
can be added without recompiling the main program, just as new
Windows applications can be written without recompiling Windows
itself.</font></p>

<p><font size="4" face="verdana"><b>Virtual</b></font></p>

<p><font size="2">Virtual is a word greatly in vogue these days.
The name <i>virtual</i> is potentially misleading, by the way: It
means something that isn&#146;t quite real but has the behavior
of (that is, provides the <i>virtues</i> of) the real thing. But
in truth, virtual functions are completely real. They are
declared, defined, and used exactly as other member functions
are, except the virtual keyword is used one time: the first time
the function is declared. (This occurs in the base-class
declaration.)</font>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;class Shape
{</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;\\ ...</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;virtual void
Print(void);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;};</font></p>


<p><font size="2">Moreover, except in the case of pure virtual
functions (a subject for another column), a virtual function call
doesn&#146;t look or act differently from a &quot;real&quot;
function call. The difference is that with a virtual function,
the precise type of the object determines the actual function to
be called, even though this type may not be known until run time.
As shown in the previous section, this may happen because a call
is made through a pointer of base-class type. At run time, the
pointer <b>pShape</b> may be assigned to point to an object of a
derived class (a square or a circle, for example), which provides
its own version of<b> Print()</b>.</font></p>

<p><font size="2">This deferring of the function-call address to
run time is also called <i>late binding</i>. It happens not
through magic but through an indirect function call (using a
pointer to a function). Understanding this helps you understand
the trade-offs involved.</font></p>

<p><font size="2">Not all functions should be made virtual,
because there is a performance penalty: each class maintains a
pointer to its own implementation of the virtual function. This
detail is invisible to you at the source-code level, but it means
that you should make a function virtual only if it is going to be
overridden.</font></p>

<p><font size="4" face="verdana"><b>Encapsulation</b></font></p>

<p><font size="2">The term <i>encapsulation</i> is more
straightforward and easy to understand. (The major intimidation
factor is the number of syllables!) Encapsulation means &quot;to
shield from the outside world.&quot; It&#146;s probably more
accurate, though, to say that the outside world gets protected
from the inside of an object. Consider another common example: a
string class. It can be manipulated through functions&#151;the
preferred interface here&#151;but in this example, the data
member is incorrectly made public as well:</font>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;class String {</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;public:</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char array[256];</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *getstr(void);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *copystr(char *s);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;};</font>

<p><font size="2">Given this declaration, there&#146;s no reason
for a programmer to refer directly to the data member array,
seeing such reference as a shortcut. Now, we might not want a
programmer to do this, but there&#146;s nothing to stop him, and
we know people don&#146;t always read the documentation.</font></p>

<p><font size="2">A problem arises when the designers update this
class to make its use of storage more flexible and efficient.
They may rewrite the class as follows:</font>

<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;class String {</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;public:</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *p;</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char length;</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *getstr(void);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *copystr(char *s);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;};</font></p>



<p><font size="2">Now other programmer who have been using this
class all through their code, while innocently accessing the (now
nonexistent) data member array, have a serious problem. Code that
uses the <b>String</b> class is now riddled with errors. The
user&#146;s code is now seriously broken.</font></p>

<p><font size="2">Encapsulation, therefore, is primarily a way of
protecting the <i>user</i> of a class. Errors would not have
arisen in this case if the designers had decided to designate a
certain part of the class as its interface and made the rest
private. The private portion can be safely changed.</font></p>

<p><font size="2">The term <i>interface</i>, by the way, has
different meanings in different contexts, but it has a fairly
consistent definition among programmers. An interface is the
channel through which two entities can interact. (So, for
example, a user interface is the part of a system that a user can
interact with.)</font></p>

<p><font size="2">C++, much more than C, encourages well-defined
and well-enforced interfaces between parts of a program. As long
as interfaces are clearly understood and do not change,
programmers should be able to make changes to the rest of a
program much more safely. The result, in theory, should be fewer
bugs.</font></p>

<p><font size="2">In C++, you encapsulate a member by making it
private:</font>

<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;class String {</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// Internals (encapsulated)</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;private:</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *p;</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;.int length;</font>
</p>
<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;// Interface</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;public:</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *getstr(void);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;char *copystr(void);</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;};</font></p>

<p><font size="2">Yet if &quot;encapsulation&quot; is clear, <i>data
abstraction</i> is the source of endless confusion among C++
programmers. The problem is inconsistency in the way people use
the term, although the general notion is widely understood, if
somewhat foggily.</font></p>

<p><font size="2">Abstract is the opposite of concrete, but all
data types are ultimately concrete in C++, just as they are in
other languages. The data type without a representation is a data
type that doesn&#146;t exist in any real program, whether the
language is Fortran, Basic, Pascal, or C++.</font></p>

<p><font size="2">&quot;Data abstraction&quot; is meaningful as a
general goal of programming: to require the user of a data type
to need know nothing about the specific structure of the type. In
this regard, data abstraction has some connection to
encapsulation. Abstraction is the goal, encapsulation is a tool. </font></p>

<p><font size="2">There is no absolute link between the two
concepts, however. For example, a FILE* pointer is a good
representation of an abstract data type. A programmer using C can
use such a pointer without knowing what the layout of a FILE
structure is. Moreover, code that uses a FILE* pointer is
generally portable between different compilers and libraries,
each of whose concrete, internal representation of FILE is
different. Yet nothing prevents a programmer using C from looking
at this information and accessing it directly, ultimately
breaking the code when there&#146;s an attempt to port it.
Encapsulation isn&#146;t present in that case, though it might
very well be helpful.<i> </i></font></p>

<p><font size="2">For example, the following code should always
be portable, even though the actual layout of the FILE structure
may change dramatically from one implementation of C/C++ to the
next:</font>
<p><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;FILE *fp;</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;if (fp=fopen(&quot;DATA&quot;, &quot;r&quot;)</font>
<br><font color="#0000ff" size="2" face="Courier New">&nbsp;&nbsp;&nbsp;fprintf(fp,&quot;Hello, file.&quot;);</font></p>

<p><font size="4" face="verdana"><b>Ah, ha!</b></font></p>

<p><font size="2">C++ concepts, ultimately, are tools and
techniques designed to solve practical problems. If you program
long enough, you&#146;ll come across all these problems yourself,
so hopefully, when the terms are explained, your reaction should
be, &quot;Ah ha! That&#146;s what it&#146;s for!&quot; </font></p>

<p><font size="2">Such terms are not really forms of mysticism
imposed on you from above, like Pythagoras instructing students
at his feet.</font></p>

<p><font size="2"><i>Brian Overland has published several books
on C and C++, and has written on programming topics for many
groups at Microsoft. Before coming to Microsoft as a technical
writer, he was a professional programmer, actor, and drama
critic.</i></font></p>

</font></body>
</html>
