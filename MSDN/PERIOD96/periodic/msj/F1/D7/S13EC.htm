<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C/C++ Q&amp;A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css">
</HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  C/C++ Q&amp;A</H1><P>Paul DiLascia</P>
<P>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is the author of <I>Windows++: Writing Reusable Code</I><I> in C++</I> </P>
<P> (Addison-Wesley, 1992).</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4913">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the DLGIDLE project files.</A></P><P><OBJECT id=sample2 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Periodicals Samples">
<PARAM name="Item2" value="4914">
</OBJECT><a href="javascript:sample3.Click()">
Click to open or copy the SCBMOD3 project files.</A></P><P><OBJECT id=sample3 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4915">
</OBJECT><a href="javascript:sample3.Click()">

Click to open or copy the SCBMOD4 project files.</A></P><P>The first question this month is really a continuation of a question from last month's column. Phillipe Bernous asked how to implement a "modified indicator" that displays an asterisk in the title bar next to the document name if the document is modified. He implemented an indicator in the status bar using the normal MFC ON_UPDATE_COMMAND_UI mechanism. This enabled or disabled his status bar's "MOD" pane based on the return value from CDocument::IsModified. Phillipe wanted to know if there is a similar way to update the title bar with ON_UPDATE_COMMAND_UI.</P>
<P>In my answer, I explained that MFC doesn't use ON_UPDATE_COMMAND_UI to update the window title. I went on to show two different ways to solve his problem. In the first solution, I overrode CDocument::SetModifiedFlag to call CDocument::SetTitle whenever some other part of the code changed the document's modified flag. In the second solution, I overrode CFrameWnd::OnUpdateFrameTitle to append an asterisk to the document title if the document was modified, and wrote a CChildFrame::OnIdleUpdateCmdUI handler for WM_IDLEUPDATECMDUI. This handler called OnUpdateFrameTitle, making MFC update the title, whenever the current modified state changed from the last WM_IDLEUPDATCMDEUI message. This second solution resembled the ON_UPDATE_COMMAND_UI mechanism, and it wouldn't take much extra effort to actually implement title bar "panes" with ON_UPDATE_COMMAND_UI. I promised I'd show you how in the next column. Well, here we are!</P>
<P>I'll start with a question that makes sense whether or not you saw the previous column: how can you implement general-purpose title bar panes that are analogous to status bar panes and that you can update using ON_UPDATE_COMMAND_UI? By title bar pane I mean some portion of the window title that displays something interesting. It could display "*" for a modified document, the document's time and date of creation, or the name of the item you've selected (if your document has a notion of named items). Each pane should have an integer ID that you use to identify it in your message map entries.</P>
<P> </P>
<P><BR></P>
<PRE> ON_UPDATE_COMMAND_UI(ID_MOD_INDICATOR, OnUpdateMod)

void CScribbleDoc::OnUpdateMod(CCmdUI* pCmdUI)
{
      pCmdUI-&gt;SetText(IsModified() ? "*" : "");
}</PRE>
<P> </P>
<P>This code should display "*" in the title bar if you modify the current document.</P>
<P>It's not hard to set this up if you understand how MFC updates user-interface objects. The best way is to see how MFC handles status panes, then mimic that scheme for the title bar. </P>
<P>MFC updates status bar panes, toolbar buttons, and menu items by implementing a special CCmdUI-derived class for each particular kind of UI element. The base class, CCmdUI, provides access to a menu item. CStatusCmdUI and CToolCmdUI let you control the state of a status bar pane or toolbar button. CCmdUI has virtual functions like SetText and Enable that manipulate the item. In the case of a menu item, CCmdUI::SetText sets the menu item text and CCmdUI::Enable grays or ungrays it. For a toolbar button, CToolCmdUI::SetText does nothing (toolbar buttons don't have text) and CToolCmdUI::Enable enables the button. For status bar panes, CStatusCmdUI::SetText sets the text in the status bar pane and CStatusCmdUI::Enable shows or hides it. You don't ever need to know that there are several different kinds of CCmdUI floating around; you only need to call the right functions, SetText, Enable, SetCheck, and so on, from your ON_COMMAND_UPDATE_UI handler. Because these functions are virtual, they do the right thing for whatever kind of UI element the CCmdUI really represents: menu item, toolbar button, or status bar pane. So, to implement title bar panes, you need a new kind of CCmdUI.</P>
<P>The next question is, how and when does your UI handler get called? As part of its normal idle processing, MFC sets up a CCmdUI object for every menu item, toolbar button, and status bar pane in your app, then calls CCmdUI::DoUpdate for each one. CCmdUI::DoUpdate ends up groveling over your message maps looking for ON_UPDATE_ COMMAND_UI handlers with IDs that match the ID of the menu item, toolbar button, or status bar pane. (See my article "Meandering through the Maze of MFC Message and Command Routing," MSJ, July 1995.) Each object that owns user-interface items does this. For example, CStatusBar and CToolBar update their panes and buttons, respectively. CWinFrm updates menu items in response to WM_INITMENUPOPUP, not during the idle loop, because you need to update the menus only when the user clicks on one.</P>
<P>To review quickly, there are three steps for implementing title bar panes. First, implement a CTitleBar class that describes the panes. Second, derive a new class from CCmdUI with overrides for SetText, Enable, SetCheck, and so on. Third, hitch a ride on WM_IDLEUPDATECMDUI to sail these little CCmdUI beasties around the system so anybody can catch one just by adding an ON_UPDATE_COMMAND_UI handler in their message map. By "anybody," I mean any object that would normally receive command notifications, such as the frame, view, or document.</P>
<P>Since Scribble is the mother of all sample programs, I started with the Scribble program from the MFC tutorial and modified it to display two panes in the title: first, the asterisk that indicates the current document's modified state; and second, the number of strokes in the Scribble drawing formatted as "[S:n]" where n is the number of strokes. Since real estate on the title bar is expensive, I figured it would be OK to display "[S:n]" instead of something more user-friendly like, "The number of strokes in this here document you are right now looking at is: n". Besides, we're all nerds here.</P>
<P>Last month's solutions were SCBMOD1 and SCBMOD2, so I gave this solution the surprising name of SCBMOD3 (see <B>Figure 1</B>). I've only shown the changes from the original Scribble program, which are confined to ScribDoc, ChildFrm, and an entirely new module, TitleBar. <B>Figure 2</B> shows SCBMOD3 in action with a document that has five strokes. (In Scribble, a stroke represents a single mouse-down/mouse-up movement, and may contain many individual line segments.)</P>
<P><B> Figure 1  SCBMOD3</B></P>
<P>ScribDoc.h</P>
<P><BR></P>
<PRE> // Forward declaration of data structure class
class CStroke;

class CScribbleDoc : public CDocument {
protected:
    CScribbleDoc();
    DECLARE_DYNCREATE(CScribbleDoc)

    // The document keeps track of the current pen width on
    // behalf of all views. We'd like the user interface of
    // Scribble to be such that if the user chooses the Draw
    // Thick Line command, it will apply to all views, not just
    // the view that currently has the focus.

    UINT            m_nPenWidth;        // current user-selected pen width
    CPen            m_penCur;           // pen created according to
                                        // user-selected pen style (width)
public:
    CTypedPtrList&lt;CObList,CStroke*&gt;     m_strokeList;   
    CPen*           GetCurrentPen() { return &amp;m_penCur; }

    CStroke* NewStroke();
    
    //{{AFX_VIRTUAL(CScribbleDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    virtual void DeleteContents();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);

    //}}AFX_VIRTUAL

    virtual ~CScribbleDoc();

protected:
    void            InitDocument();
    //{{AFX_MSG(CScribbleDoc)
    // **MOD** new title bar handlers
    afx_msg void OnUpdateMod(CCmdUI* pCmdUI);
    afx_msg void OnUpdateNumStrokes(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CStroke
//
// A stroke is a series of connected points in the scribble drawing.
// A scribble document may have multiple strokes.

class CStroke : public CObject {
public:
    CStroke(UINT nPenWidth);
    CArray&lt;CPoint,CPoint&gt;  m_pointArray;   // series of connected points
    BOOL DrawStroke(CDC* pDC);
    virtual void Serialize(CArchive&amp; ar);

protected:
    CStroke();
    DECLARE_SERIAL(CStroke)
    UINT    m_nPenWidth;    // one pen width applies to entire stroke
};</PRE>
<P></P>
<P>ScribDoc.cpp</P>
<P><BR></P>
<PRE> #include "stdafx.h"
#include "Scribble.h"
#include "ScribDoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CScribbleDoc, CDocument)

BEGIN_MESSAGE_MAP(CScribbleDoc, CDocument)
    //{{AFX_MSG_MAP(CScribbleDoc)
    ON_UPDATE_COMMAND_UI(ID_TITLE_MOD,           OnUpdateMod)
    ON_UPDATE_COMMAND_UI(ID_TITLE_NUMSTROKES, OnUpdateNumStrokes)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CScribbleDoc::CScribbleDoc()
{
}

CScribbleDoc::~CScribbleDoc()
{
}

BOOL CScribbleDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    InitDocument();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CScribbleDoc serialization

void CScribbleDoc::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring()) {
    } else {
    }
    m_strokeList.Serialize(ar);
}

BOOL CScribbleDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;
    InitDocument(); 
    return TRUE;
}

void CScribbleDoc::DeleteContents() 
{
    while (!m_strokeList.IsEmpty()) {
        delete m_strokeList.RemoveHead();
    }
    CDocument::DeleteContents();
}

void CScribbleDoc::InitDocument()
{
    m_nPenWidth = 2; // default 2 pixel pen width
    m_penCur.CreatePen(PS_SOLID, m_nPenWidth, RGB(0,0,0)); // solid, black pen
}

CStroke* CScribbleDoc::NewStroke()
{
    CStroke* pStrokeItem = new CStroke(m_nPenWidth);
    m_strokeList.AddTail(pStrokeItem);
    SetModifiedFlag();  // Mark the document as having been modified, for
                        // purposes of confirming File Close.
    return pStrokeItem;
}

void CScribbleDoc::OnUpdateMod(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;SetText(IsModified() ? "*" : "");
    pCmdUI-&gt;m_bContinueRouting = TRUE;
}

void CScribbleDoc::OnUpdateNumStrokes(CCmdUI* pCmdUI)
{
    CString s;
    s.Format(" [S:%d]", m_strokeList.GetCount());
    pCmdUI-&gt;SetText(s);
    pCmdUI-&gt;m_bContinueRouting = TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CStroke

IMPLEMENT_SERIAL(CStroke, CObject, 1)

CStroke::CStroke()
{
}

CStroke::CStroke(UINT nPenWidth)
{
    m_nPenWidth = nPenWidth;
}

void CStroke::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring()) {
        ar &lt;&lt; (WORD)m_nPenWidth;
        m_pointArray.Serialize(ar);
    } else {
        WORD w;
        ar &gt;&gt; w;
        m_nPenWidth = w;
        m_pointArray.Serialize(ar);
    }
}

BOOL CStroke::DrawStroke(CDC* pDC)
{
    CPen penStroke;
    if (!penStroke.CreatePen(PS_SOLID, m_nPenWidth, RGB(0,0,0)))
        return FALSE;
    CPen* pOldPen = pDC-&gt;SelectObject(&amp;penStroke);
    pDC-&gt;MoveTo(m_pointArray[0]);
    for (int i=1; i &lt; m_pointArray.GetSize(); i++) {
        pDC-&gt;LineTo(m_pointArray[i]);
    }
    pDC-&gt;SelectObject(pOldPen);
    return TRUE;
}</PRE>
<P></P>
<P>TitleBar.h</P>
<P><BR></P>
<PRE> struct TITLEPANE;          // fwd ref

//////////////////
// A titlebar is not really a window, just an object that manages title 
// bar "inidcators", which are like panes in the status bar.
//
class CTitleBar : public CCmdTarget {
   DECLARE_DYNAMIC(CTitleBar)
   TITLEPANE*  m_arPanes;     // array of "panes" (inidicators)
   UINT        m_nCount;      // #panes
   CString     m_sPrevTitle;  // previous title
   CString     m_sTitle;      // current title
public:
   CTitleBar();
   ~CTitleBar();
   BOOL SetIndicators(const UINT* lpIDArray, int nIDCount);
   void OnIdleUpdate(CFrameWnd* pFrame, BOOL bDisableIfNoHndler);
};</PRE>
<P></P>
<P>TitleBar.cpp</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// Implementation for title bar
//
#include "stdafx.h"
#include "titlebar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CTitleBar, CCmdTarget)

//////////////////
// One of these for each inidicator
//
struct TITLEPANE {
   CString  m_sText;       // current text
   UINT     m_nID;         // indicator ID
   BOOL     m_bEnabled;    // enabled?
};

CTitleBar::CTitleBar()
{
   m_nCount  = 0;
   m_arPanes = NULL;
}

CTitleBar::~CTitleBar()
{
   delete [] m_arPanes;       // OK if NULL
}

//////////////////
// Call this when your frame is constructed, i.e., from OnCreate, to
// create the indicators.
//
BOOL CTitleBar::SetIndicators(const UINT* lpIDs, int nCount)
{
   // Allocate indicator array
   ASSERT(nCount&gt;0);
   m_arPanes = new TITLEPANE[nCount];
   ASSERT(m_arPanes);

   // Initialize panes
   for (int i=0; i&lt;nCount; i++) {
      TITLEPANE&amp; pane = m_arPanes[i];
      pane.m_nID = lpIDs[i];
      pane.m_bEnabled = TRUE;
   }
   m_nCount = nCount;
   return TRUE;
}

//////////////////
// This class is private to this file.
//
class CTitleCmdUI : public CCmdUI {
public: 
   TITLEPANE*  m_pPane;    // ptr to associate title pane

   // re-implementations:
   virtual void Enable(BOOL bOn);
   virtual void SetCheck(int nCheck);
   virtual void SetText(LPCTSTR lpszText);
};

void CTitleCmdUI::Enable(BOOL bOn)
{
   m_bEnableChanged = TRUE;   // used by MFC
   m_pPane-&gt;m_bEnabled = bOn;
}

void CTitleCmdUI::SetCheck(int nCheck)
{
   // no-op
}

void CTitleCmdUI::SetText(LPCTSTR lpszText)
{
   m_pPane-&gt;m_sText = lpszText;
}

//////////////////
// Do idle update of all title bar indicators
// You must handle WM_IDLEUPDATEUI from your frame window and
// call this method from your handler.
//
void CTitleBar::OnIdleUpdate(CFrameWnd* pFrame, BOOL bDisableIfNoHndler)
{
   m_sTitle.Empty();

   CTitleCmdUI cmdui;
   cmdui.m_nIndexMax = m_nCount;
   for (UINT i=0; i&lt;cmdui.m_nIndexMax; i++) {
      TITLEPANE&amp; pane = m_arPanes[i];
      cmdui.m_nIndex  = i;
      cmdui.m_pPane   = &amp;pane;
      cmdui.m_nID = pane.m_nID;
      cmdui.DoUpdate(pFrame, FALSE);
      if (pane.m_bEnabled)
         m_sTitle += pane.m_sText;
   }
   if (m_sPrevTitle != m_sTitle) {
      pFrame-&gt;OnUpdateFrameTitle(TRUE);
      CString title;
      pFrame-&gt;GetWindowText(title);
      title += m_sTitle;
      pFrame-&gt;SetWindowText(title);
      m_sPrevTitle = m_sTitle;
   }
}</PRE>
<P></P>
<P>ChildFrm.h</P>
<P><BR></P>
<PRE> #include "TitleBar.h"

class CChildFrame : public CMDIChildWnd {
    DECLARE_DYNCREATE(CChildFrame)
    CTitleBar    m_titleBar;        // **MOD** title bar info
    BOOL    m_bViewTitleInfo;       // **MOD** whether to display pane info

public:
    CChildFrame();
    virtual ~CChildFrame();
    //{{AFX_VIRTUAL(CChildFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

protected:
    //{{AFX_MSG(CChildFrame)
    // **MOD** new functions
    afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM);
    afx_msg void OnViewTitleInfo();
    afx_msg void OnUpdateUIViewTitleInfo(CCmdUI* pCmdUI);
    afx_msg void OnUpdateUINumStrokes(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};</PRE>
<P></P>
<P>ChildFrm.cpp</P>
<P><BR></P>
<PRE> #include "stdafx.h"
#include "Scribble.h"
#include "ChildFrm.h"
#include &lt;afxpriv.h&gt;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CChildFrame, CMDIChildWnd)
    //{{AFX_MSG_MAP(CChildFrame)
    ON_MESSAGE(WM_IDLEUPDATECMDUI, OnIdleUpdateCmdUI)
    ON_COMMAND(ID_VIEW_TITLE_INFO, OnViewTitleInfo)
    ON_UPDATE_COMMAND_UI(ID_VIEW_TITLE_INFO,  OnUpdateUIViewTitleInfo)
    ON_UPDATE_COMMAND_UI(ID_TITLE_NUMSTROKES, OnUpdateUINumStrokes)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CChildFrame::CChildFrame()
{
    // By default, don't display title pane info
    m_bViewTitleInfo = FALSE;

    // Create title bar indicators
    static UINT indicators[] = { ID_TITLE_MOD, ID_TITLE_NUMSTROKES };
    m_titleBar.SetIndicators(indicators, 
                             sizeof(indicators)/sizeof(indicators[0]));
}

CChildFrame::~CChildFrame()
{
}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CMDIChildWnd::PreCreateWindow(cs);
}

//////////////////
// **MOD** Handle idle command update
//
LRESULT CChildFrame::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
    m_titleBar.OnIdleUpdate(this, (BOOL)wParam);    // pass to title bar
    CMDIChildWnd::OnIdleUpdateCmdUI();              // pass to default handler
    return 0L;
}

//////////////////
// **MOD** command and command update handlers
//
void CChildFrame::OnViewTitleInfo()
{
    m_bViewTitleInfo = !m_bViewTitleInfo;
}

void CChildFrame::OnUpdateUIViewTitleInfo(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;SetCheck(m_bViewTitleInfo);
}

void CChildFrame::OnUpdateUINumStrokes(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;Enable(m_bViewTitleInfo);
}</PRE>
<P>Since title bar panes are not really panes at all (they're not windows), I need a little structure to describe each pane. I need an ID, a place to hold the text, and a flag that tells whether the pane is enabled.</P>
<P> </P>
<P><BR></P>
<PRE> struct TITLEPANE {
      CString      m_sText;         // current text
      UINT            m_nID;        // indicator ID
      BOOL            m_bEnabled;   // enabled?
};</PRE>
<P> </P>
<P><img src="cqa2.gif"></P>
<P><B> Figure 2  SCBMOD3 changes in Scribble</B></P>
<P></P>
<P>I also need a class to represent the whole title bar, which I will call CTitleBar. As titlebar.h shows, CTitleBar is just a pointer to an array of TITLEPANEs. To create a title bar in your app, instantiate a CTitleBar object in your frame window class and call CTitleBar::SetIndicators with an array of ints, the IDs for the indicators.</P>
<P> </P>
<P><BR></P>
<PRE> class CChildFrame : public CMDIChildWnd {
      CTitleBar      m_titleBar;   // title bar
                             ·
                             ·
                             ·
};

CChildFrame::CChildFrame()
{
      static UINT indicators[] = 
            { ID_TITLE_MOD, ID_TITLE_NUMSTROKES };

      // Create title bar indicators
      m_titleBar.SetIndicators(indicators, 
            sizeof(indicators)/sizeof(indicators[0]));
}</PRE>
<P> </P>
<P>This looks just like it would for status bar panes, only I do my initialization in the CChildFrame constructor instead of OnCreate. (I already had an empty constructor function and was too lazy to implement OnCreate and hook it up to the message map. Anything to avoid typing.) Also, note that the title bar belongs to the child frame, not the main frame. CTitleBar::SetIndicators allocates and initializes an array of TITLEPANEs based on the array of ints passed.</P>
<P>The only other thing you have to do to hook up the title panes is implement a handler for WM_IDLEUPDATECMDUI.</P>
<P> </P>
<P><BR></P>
<PRE> LRESULT 
CChildFrame::OnIdleUpdateCmdUI(WPARAM wParam, LPARAM)
{
      m_titleBar.OnIdleUpdate(this, (BOOL)wParam);
      CMDIChildWnd::OnIdleUpdateCmdUI();
      return 0L;
}</PRE>
<P> </P>
<P>The implementation is trivial; you just call the CTitleBar::OnIdleUpdate function I wrote, then call the default implementation for CMDIChildWnd (the order isn't really important). This is the only ugly part of the implementation. Ideally, you wouldn't need CChildFrame::OnIdleUpdateCmdUI; however, MFC is notoriously difficult when it comes to writing extension classes, and CTitleBar is really an extension class. There's no way for CTitleBar to hook WM_IDLEUPDATECMDUI invisibly on behalf of another window—aside from inserting its own WndProc, thereby circumventing MFC. Working by the book, you would derive a new class (CNewMDIChildWnd, for example) that handles the message, and make developers derive from that. Unfortunately, this tactic begs the question: what if someone else defines a CEvenNewerMDIChildWnd? Which one does the developer derive from? You can only use one.</P>
<P>My compromise solution is to give you the handler function, CTitleBar::OnIdleUpdate, but make you hook it up to WM_IDLEUPDATECMDUI yourself. What does CTitleBar::OnIdleUpdate actually do? This is where the CCmdUIs come in.</P>
<P>In titlebar.cpp, I derive a new class, CTitleCmdUI, that represents a user interface to a single TITLEPANE. It has SetText, Enable, and SetCheck overrides. SetText sets the text, Enable sets the m_bEnabled flag on, and SetCheck does nothing, but is needed to hide the SetCheck CTitleCmdUI inherits from CCmdUI. CTitleBar::OnIdleUpdate creates a CTitleCmdUI on the stack and loops over all the TITLEPANEs, successively pointing the CTitleCmdUI at each one before calling the magic CCmdUI::DoUpdate. If you remember, DoUpdate is the CCmdUI function that routes the darn thing to all the message maps. If there's an ON_UPDATE_COMMAND_UI anywhere for this title pane, MFC calls the handler, which calls SetText, Enable, or whatever it wants to update the title pane based on the current state of your app.</P>
<P>Once CTitleBar::OnIdleUpdate routes the panes all over the world, each TITLEPANE has the correct text and enable flag and you can actually set the title in the title bar. This is where my implementation differs slightly from menu items and status bar panes. When you call CCmdUI::SetText for a menu or status bar pane, the change is reflected immediately; with my CTitleCmdUI, SetText only changes the text in the TITLEPANE structure. Only after all the TITLEPANEs are updated do I actually change the window's title bar. This is necessary because the whole window title must be assembled by concatenating the normal MFC title (app and document names) with all the TITLEPANEs before setting the title with SetWindowText. Note that the order of the IDs in the original SetIndicators array of ints is the order they appear in the title bar. CTitleBar::OnIdleUpdate compares the new title with the previous one and calls SetWindowText only if the title changed since the last update. This avoids the screen flicker that would result if you set the window title on every idle update cycle.</P>
<P>That's about it. The only thing left to do is write the actual ON_UPDATE_COMMAND_UI handlers and put them in the message maps. Here's one for the stroke indicator:</P>
<P> </P>
<P><BR></P>
<PRE> BEGIN_MESSAGE_MAP(CScribbleDoc, CDocument)
                                    ·
                                    ·
                                    ·
      ON_UPDATE_COMMAND_UI(ID_TITLE_NUMSTROKES, 
                           OnUpdateNumStrokes)
END_MESSAGE_MAP()

void CScribbleDoc::OnUpdateNumStrokes(CCmdUI* pCmdUI)
{
      CString s;
      s.Format(" [S:%d]", m_strokeList.GetCount());
      pCmdUI-&gt;SetText(s);
      pCmdUI-&gt;m_bContinueRouting = TRUE;
}</PRE>
<P> </P>
<P>The last line lets other objects update the same CCmdUI item. In my case, I update the contents ("[S:%d]") in CScribbleDoc, but I update the enabled status in CChildFrame since it owns the m_bViewTitleInfo flag. Without setting m_bContinueRouting to TRUE, MFC would stop routing the CCmdUI as soon as CScribbleDoc handled it.</P>
<P>So, there you have it. Whether or not you want to implement title bar panes, at least now you understand how CCmdUI works. You should be able to implement any kind of UI indicator with ON_UPDATE_COMMAND_UI. For example, you can update a gallery, palette, or other UI widget with ON_UPDATE_CMD_UI. In general, it's much easier to update UI elements on demand than maintain them as your program's state changes. It also makes your code cleaner and more object-oriented.</P>
<P>Just to prove it could be done, I implemented another version of Scribble, SCBMOD4, where I derive a CMyTitleBar that handles the "View Title Info" command and manages the indicator panes. (In SCBMOD3, this is done in CChildFrame.) It seems more logical that the title bar should manage itself, rather than having the child frame do it. Both versions are included in the source code for this column. Use them with my blessing.</P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I'm having a problem with idle processing in a dialog-based app. My application is a "helper app" that runs under the Netscape browser. It primarily decodes incoming audio from an asynchronous socket and sends it to the wave device. My app begins by reading a number of audio buffers, then it decodes them and sends them to the device. I keep four or five buffers queued in the driver in cases of long network latency times, when another app is launched. On a 486/66, one second of audio takes 650 milliseconds to decode, which doesn't leave time to spare. The app must run under Win32s<FONT FACE="Symbol">Ò</FONT> 1.3 and Windows<FONT FACE="Symbol">Ò</FONT> for Workgroups 3.11, which is quite a constraint. To speed things up, I start reading data into my buffers as soon as the app is initialized. I do this in the OnIdle handler. Only when the user stops the audio or it finishes playing do I stop idle processing.</P>
<P>My problem is that OnIdle works fine for normal document/view apps, but it doesn't seem to work for a dialog-based app. My CApp::InitInstance calls dlg.DoModal, which calls CWnd::RunModalLoop, which never calls OnIdle. I thought I could do some background processing in WM_ENTERIDLE, but that message is sent to the dialog's parent. In my case, there is no parent window. Help!</P>
<P><I>Jim Kallimani</I></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>As you discovered, "modal" dialogs are really modeless in MFC 4.0. When you call CDialog::DoModal, MFC doesn't call ::DialogBox like it used to; instead, it calls ::Create-DialogIndirect (after great deliberation), then simulates the modal behavior by disabling the parent window and going into its own message loop. This is essentially what ::DialogBox does anyway. The benefit of doing it this way is that MFC owns the dialog's message loop, whereas the message loop was formerly hidden inside the Windows API function ::DialogBox. This lets MFC pump modal dialog messages through the normal MFC channels (CWinThread::PumpMessage) as it does for other kinds of windows. In particular, you can override CWnd::PreTranslateMessage for modal dialogs—for example, to implement accelerator keys. Earlier releases of MFC allowed you to implement your own PreTranslateMessage for a modal dialog. However, it was never called because CDialog::DoModal went directly to ::DialogBox, which doesn't return control to your program until one of your dialog message handlers calls EndDialog. Also, with ::DialogBox, it's impossible to do idle processing the normal MFC way since control disappears into ::DialogBox and doesn't come back until the dialog is over.</P>
<P>Instead, Windows has its own mechanism, WM_ENTERIDLE, for doing idle processing in a modal dialog. After processing one or more messages, Windows sends WM_ ENTERIDLE to the owner window of a modal dialog box or menu if no more messages are waiting in its queue. Only modal dialogs send WM_ENTERIDLE, not modeless ones. Since MFC now uses modeless dialogs even for modal ones, MFC has to manually send WM_ENTERIDLE itself in order to mimic modal dialogs—but only if the dialog has a parent window. Jim ran into trouble because there's no parent window to receive WM_ENTERIDLE. Are you totally confused yet?</P>
<P>If MFC pumps modal dialog messages through its standard message pump, why doesn't it call CWinApp::OnIdle as part of that processing? The problem is that CWnd::RunModalLoop calls CWinThread::PumpMessage, but the OnIdle stuff happens in CWinThread::Run. MFC calls CWinThread::Run to run your app after calling your app's InitInstance function. CWinThread::Run looks like this in condensed form:</P>
<P> </P>
<P><BR></P>
<PRE> // (from THRDCORE.CPP)
int CWinThread::Run()
{
      // for doing idle cycle
      BOOL bIdle = TRUE;
      LONG lIdleCount = 0;

      for (;;) {
            while (bIdle &amp;&amp; !::PeekMessage(...)) {
                  // call OnIdle while in bIdle state
                  if (!OnIdle(lIdleCount++))
                        // assume "no idle" state
                        bIdle = FALSE; 

            }

            // Get/Translate/Dispatch the message
            // (calls CWinThread::PumpMessage)
                                                  ·
                                                  ·
                                                  ·
      }
}</PRE>
<P> </P>
<P>I've cut a lot to highlight how idle processing works.  If there are no messages waiting, MFC calls CWinThread::OnIdle repeatedly with a count argument that's incremented every time. You can use the count to prioritize different kinds of idle processing. You might do formatting when the idle count is 1, then update a time-of-day clock on idle count 2. When your OnIdle returns FALSE, MFC stops calling it and waits until your thread gets another message, whereupon the idle cycle starts all over again.</P>
<P>The point is that modal dialogs never go through this code because CWnd::RunModalLoop calls CWinThread::PumpMessage directly from inside its own message loop. It doesn't call CWinThread::Run, so it never calls CWinThread::OnIdle. Folks in Redmond tell me this is by design. Apparently, it's dangerous to call OnIdle inside a modal dialog, because many message handlers create temporary CWnd objects, which they expect will exist through the duration of the dialog. Part of the default OnIdle processing is to free temporary handle maps.</P>
<P>(I can't resist telling you that, in my humble opinion, the whole temporary/permanent handle map mechanism MFC uses to associate HWNDs with CWnds is one of the biggest disaster areas in the entire framework—worse even than message maps themselves. The "temporary map" problem continually haunts programmers—especially in multithreaded apps, which makes them difficult to write in MFC.)</P>
<P>So, how do you handle idle processing in a dialog-based app where the dialog has no parent window? Fortunately, it's trivial. The MFC developers provided a hook: WM_KICKIDLE. RunModalLoop sends this MFC-private message repeatedly when there are no messages in your dialog's queue—just the way CWinThread::Run calls OnIdle. RunModalLoop even passes a counter and increments it for you. In effect, WM_KICKIDLE is the dialog equivalent of OnIdle. (Historical note: earlier versions of MFC did the modal/modeless swap and WM_KICKIDLE thing for property sheets. Apparently it worked so well they decided to make all modal dialogs modeless.)</P>
<P><B>Figure 3</B> shows DLGIDLE, a dialog-based app I wrote that does idle processing. <B>Figure 4 </B>shows it running (pretty boring), and <B>Figure 5</B> shows the TRACE messages displayed as I ran the mouse over the dialog. The TRACE messages represent idle processing you would do in your dialog.</P>
<P><B> Figure 3  DLGIDLE.CPP</B></P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// DLGIDLE 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// DLGIDLE illustrates how to implement a dialog-based app that
// does OnIdle processing. Compiles with VC++ 4.0 or greater.

#include "stdafx.h"
#include "resource.h"
#include "tracewin.h"
#include &lt;afxpriv.h&gt;              // For WM_KICKIDLE

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////////
// Dialog class
//
class CMyDlg : public CDialog {
public:
       CMyDlg() : CDialog(IDD_ABOUTBOX) {       }
       afx_msg LRESULT OnKickIdle(WPARAM, LPARAM);
       DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CMyDlg, CDialog)
       ON_MESSAGE(WM_KICKIDLE, OnKickIdle)
END_MESSAGE_MAP()

//////////////////
// Handle MFC private message WM_KICKIDLE. LPARAM is the idle count. 
// Return TRUE/FALSE continue/discontinue idle processing.
//
LRESULT CMyDlg::OnKickIdle(WPARAM, LPARAM lCount)
{
       // Do idle processing here, just like CWinApp::OnIdle
       //
       TRACE("CMyDlg::OnKickIdle, do priority %d stuff\n", lCount);
       return (lCount &lt;= 2);
}

////////////////////////////////////////////////////////////////
// Application class with OnIdle function.
//
class CMyApp : public CWinApp {
public:
       CMyApp();
       virtual BOOL InitInstance();
       DECLARE_MESSAGE_MAP()
};

CMyApp NEAR theApp;

BEGIN_MESSAGE_MAP(CMyApp, CWinApp)
       ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
       ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

CMyApp::CMyApp()
{
}

BOOL CMyApp::InitInstance()
{
       MfxTraceInit();
       CMyDlg dlg;
       m_pMainWnd = &amp;dlg;
       dlg.DoModal();
       return FALSE;
}</PRE>
<P><img src="cqa4.gif"></P>
<P><B> Figure 4  DLGIDLE.</B></P>
<P><img src="cqa5.gif"></P>
<P><B> Figure 5  Tracing DLGIDLE. </B></P>
<P>One word of warning: you might be tempted to call your main app's OnIdle function from OnKickIdle.</P>
<P> </P>
<P><BR></P>
<PRE> LRESULT CMyDlg::OnKickIdle(WPARAM, LPARAM lCount)
{
      return AfxGetApp()-&gt;OnIdle(lCount);
}</PRE>
<P> </P>
<P>The MFC folks tell me this is dangerous because of the temporary map problem. It's safer to do your idle processing directly inside OnKickIdle. If you want, you can combine common idle processing into a helper function that you call from both CApp::OnIdle and CMyDlg::OnKickIdle.</P>
<P>While I'm on the subject of idle processing, not all programmers know that there are OnIdle functions for CDocTemplate and CDocument! If you want to do idle processing in a document or document template, all you have to do is override one of these functions.</P>
<P>Have a question about programming in C or C++? You can mail it directly to C/C++ Q&amp;A, Microsoft Systems Journal, 825 Eighth Avenue, 18th Floor, New York, New York 10019, or send it to MSJ (re: C/C++ Q&amp;A) via:</P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="66pt" VALIGN="TOP"><COL WIDTH="339pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> <BR>Internet:</P></TD><TD VALIGN="TOP"><P>Paul DiLascia<BR>72400.2702@compuserve.com</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P></font></body></HTML>
