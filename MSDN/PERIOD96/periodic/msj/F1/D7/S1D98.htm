<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE Q&amp;A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  OLE Q&amp;A</H1><P>Don Box</P>
<P>Don Box has been working in networking and distributed object systems since 1989. He is currently chronicling the COM lifestyle in book form for Addison Wesley, and gives seminars on OLE and COM across the globe. Don can be reached at dbox@braintrust.com.</P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I am using dual interfaces to expose my objects to both C++ and Visual Basic<FONT FACE="Symbol">Ò</FONT> clients. Designing the interfaces was relatively painless once I passed simple data types as method parameters. I now need to pass user-defined structures as parameters and can't get it to work. Any suggestions?</P>
<P><font size="6" face="verdana,arial,helvetica">A</font>Your problem stems from the fact that dual interfaces suffer from the same limitation as normal dispatch interfaces: all parameters must be VARIANT-compatible. Both dispatch and dual interfaces (which ultimately are just an extension to dispatch interfaces) are meant to expose functionality to clients written in scripting languages, many of which are interpreted. To allow scripting clients to pass method parameters whose type may not be known until run time, you must use some alternative mechanism for passing parameters. This is the purpose of the VARIANT from IDispatch.</P>
<P>IDispatch uses the VARIANT data structure to pass generic, self-describing parameters between the caller and the object. As shown in <B>Figure 1</B>, the VARIANT is a discriminated union that contains a union of all supported data types accompanied by a type tag that describes which union member is actually valid. It is the responsibility of the caller to initialize the union member and set the type tag appropriately. The following code initializes an array of VARIANTs to contain two doubles and a short:</P>
<P> </P>
<P><BR></P>
<PRE> VARIANT args[3]; ZeroMemory(args, sizeof(args));
args[2].vt = VT_R8; args[2].dblVal = 2.0;
args[1].vt = VT_R8; args[1].dblVal = 4.5;
args[0].vt = VT_I2; args[0].iVal = 9;</PRE>
<P> </P>
<P>This array is now a suitable parameter list for use by IDispatch.</P>
<P><B> Figure 1  VARIANT.cpp</B></P>
<P><BR></P>
<PRE> typedef struct tagVARIANT{
    VARTYPE vt;
    WORD wReserved1;
    WORD wReserved2;
    WORD wReserved3;
    union {
      long          lVal;           /* VT_I4                */
      unsigned char bVal;           /* VT_UI1               */
      short         iVal;           /* VT_I2                */
      float         fltVal;         /* VT_R4                */
      double        dblVal;         /* VT_R8                */
      VARIANT_BOOL  boolVal;        /* VT_BOOL              */
      SCODE         scode;          /* VT_ERROR             */
      CY            cyVal;          /* VT_CY                */
      DATE          date;           /* VT_DATE              */
      BSTR          bstrVal;        /* VT_BSTR              */
      IUnknown      *punkVal;       /* VT_UNKNOWN           */
      IDispatch     *pdispVal;      /* VT_DISPATCH          */
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
      short         *piVal;         /* VT_BYREF|VT_I2       */
      long          *plVal;         /* VT_BYREF|VT_I4       */
      float         *pfltVal;       /* VT_BYREF|VT_R4       */
      double        *pdblVal;       /* VT_BYREF|VT_R8       */
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
      IDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */
      void          * byref;        /* Generic ByRef        */
    };
} VARIANT, VARIANTARG;</PRE>
<P>The type tag's value must be chosen from a limited set of values (see <B>Figure 2</B>). This list is fixed and is not user-extensible. If your data type is not found in the list, then you must somehow coerce your parameter into a data type supported by the VARIANT. While the VARIANT does contain a union member of type void * (selected by specifying VT_PTR), this member cannot be used when the object is located on a different thread or in a different process; the standard marshaler for IDispatch has no idea how to marshal the data that is referred to by the pointer.</P>
<P><img src="oleqa2.gif"></P>
<P><B> Figure 2  VARTYPEs </B></P>
<P>To understand how the VARIANT is used, consider the following simple interface:</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110022-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface IPoint : IDispatch
{
  [ id(10) ]
  HRESULT SetCoords([in] long x, [in] long y);
}</PRE>
<P> </P>
<P>Many environments are not capable of taking advantage of the dual interface (for example, Visual Basic 3.0 and Visual Basic for Applications). Clients written in these environments would access the SetCoords method indirectly via Invoke.</P>
<P> </P>
<P><BR></P>
<PRE> VARIANT args[2]; ZeroMemory(args, sizeof(args));
args[0].vt = VT_I4; args[0].lVal = 200;
args[1].vt = VT_I4; args[1].lVal = 100;

DISPPARAMS params = { args, 0, 2, 0 };
pDispatch-&gt;Invoke(10, IID_NULL, 0, 
                  DISPATCH_METHOD, &amp;params,
                  0, 0, 0);</PRE>
<P> </P>
<P>Since C++ and Visual Basic 4.0 are relatively strongly typed, these languages have no problem accessing the methods of a dual interface directly without using Invoke. These clients can simply call the SetCoords method directly.</P>
<P> </P>
<P><BR></P>
<PRE> pPoint-&gt;SetCoords(100, 200);</PRE>
<P> </P>
<P>Both code fragments accomplish the same task, but clients accessing the method directly will find a considerable performance gain, especially when the object is on the same thread as the caller.</P>
<P>The limitation imposed by the VARIANT is obvious for dispatch interfaces, as all logical parameters must be passed as an array of variants. If there isn't an appropriate union member to hold your parameter, there is probably no way to pass your parameter without some sort of manual type coercion. It is less obvious why this limitation applies to dual interfaces, as clients can access the method implementations directly. They can bypass the IDispatch::Invoke mechanism and pass the parameters directly on the stack instead of in a VARIANT array. Given the fact that dual interface clients don't use VARIANTs, it seems counterintuitive that the methods of a dual are also limited to VARIANT-compatible types. This limitation exists for two reasons. First, it is assumed that all methods of the dual interface are accessible from Invoke. Since Invoke can only receive parameters that are packed in a VARIANT array, this immediately presents a problem for VARIANT-incompatible types. </P>
<P>The second and most important limitation stems from the universal marshaler that is used to remote the methods of the dual interface. The universal marshaler uses the type information for the interface to dynamically translate between the call stack and the marshaling packet for use in standard marshaling. The advantage of this approach is that no user-supplied proxy/stub pair is needed to remote the interface. The limitation of this approach is that the universal marshaler is hard-wired to support VARIANT-compatible types only. The type library compiler is aware of this limitation, and will not allow you to create a dual interface that accepts VARIANT-incompatible types. </P>
<P>In spite of the previous explanation, there must be some technique that allows user-defined structures to be passed as method parameters. In fact, there are several. If you must remain in the world of dispatch and dual interfaces to maintain scripting compatibility, there are four viable options for passing structures as parameters:</P>
<P> </P>
<UL><LI>Pass each structure member as an individual method parameter.</LI><LI>Serialize the structure to an opaque array of bytes. </LI><LI>Serialize the structure to an array of VARIANTs, one array element per structure member.</LI><LI>Implement a dispatch/dual wrapper object that contains the structure and pass an interface to the wrapper object as a parameter.</LI></UL><P> </P>
<P>Each of these techniques is valid and has distinct advantages and drawbacks. </P>
<P>Before critiquing each approach, let's see an example of each applied to a simple structure—passing a RECT structure from a client to an object as a method parameter. In case you don't have a copy of Petzold handy, here's the definition of RECT from WINUSER.H:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct tagRECT {
  int left;
  int top;
  int right;
  int bottom;
} RECT;</PRE>
<P> </P>
<P>In Visual Basic, this would be written as:</P>
<P></P>
<P><BR></P>
<PRE> Private Type RECT
  left   as Long
  top    as Long
  right  as Long
  bottom as Long
End Type</PRE>
<P></P>
<P>Both type definitions yield a structure that contains four integers of four bytes each. Unfortunately, neither one is a legal parameter type for a dispatch or dual interface. To pass a rectangle through these interfaces, one of the four techniques listed above must be used. </P>
<P>The first technique requires the least explanation. To allow callers to pass a rectangle, you can simply break apart the structure into individual parameters, as is demonstrated by this interface:</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110023-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface INeedARect : IDispatch
{
  HRESULT GiveMeARect([in] long left, 
                      [in] long top,
                      [in] long right,
                      [in] long bottom);
}</PRE>
<P> </P>
<P>This passes a rectangle from Visual Basic:</P>
<P> </P>
<P><BR></P>
<PRE> Sub PassARect(nar as INeedARect, r as RECT)
  nar.GiveMeARect r.left, r.top, r.right, r.bottom
End Sub</PRE>
<P> </P>
<P>To pass a rectangle from C++, use this code:</P>
<P> </P>
<P><BR></P>
<PRE> void PassARect(INeedARect *pnar, const RECT&amp; r) {
  pnar-&gt;GiveMeARect(r.left, r.top, 
                    r.right, r.bottom);
}</PRE>
<P> </P>
<P>Reconstituting the RECT in the implementation is simple:</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT CoNeedARect::GiveMeARect(long left, long top,
                               long right, long bottom)
{
  RECT r = { left, top, right, bottom };
  m_rect = r;
  return S_OK;
}</PRE>
<P> </P>
<P>This technique is practical for simple structures that do not contain many elements. It is not so practical for complex structs, and is somewhat inconvenient and error-prone when the structure in question is commonly used as the native data representation by the client.</P>
<P>The second technique takes advantage of the fact that VARIANTs can be used to pass primitive types, pointers to single instances of primitive types, and self-describing arrays of primitive types. One of the supported primitive types is unsigned char, which for our purposes translates to byte. Instead of breaking apart the struct as in the previous example, this technique simply copies the structure into an array of  bytes and assumes that the method implementation treats the byte array appropriately. Unlike vanilla C and C++, when dual and dispatch interfaces use arrays, they must be accompanied by a description of the array's dimensions. This array descriptor is called a SAFEARRAY and describes the bounds for each array dimension as well as the individual element size.</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct  tagSAFEARRAYBOUND
{
    ULONG   cElements; // # of elems in dimension   
    LONG    lLbound;   // lower bound of dimension
} SAFEARRAYBOUND;
typedef struct tagSAFEARRAY 
{
    unsigned short  cDims;      // # of dimensions
    unsigned short  fFeatures;  // misc. flags
    unsigned long   cbElements; // element size
    unsigned long   cLocks;     // lock count
    void *          pvData;     // ptr to array
    SAFEARRAYBOUND  rgsabound[cDims]; // dimensions
} SAFEARRAY;</PRE>
<P> </P>
<P>The SAFEARRAY is simply a description of the array, not the array itself (see <B>Figure 3</B>). The actual array contents are stored in a separate block of memory referred to by the pvData member. The array descriptor also tracks the number of outstanding pointers to the array data,  ensuring that the actual memory is not freed while one or more concerned parties are relying on it remaining valid.</P>
<P><img src="oleqa3.gif"></P>
<P><B> Figure 3  SAFEARRAYs</B></P>
<P>SAFEARRAYs can be created and manipulated using API functions or through direct manipulation. The SafeArrayCreate API function creates a new array descriptor and allocates the space for the array contents. To access the array data, call the SafeArrayAccessData function, which returns a pointer to the base of the array after incrementing the lock count. Release the lock by calling SafeArrayUnaccessData.</P>
<P>The following code allocates a new array of 100 longs and initializes each element:</P>
<P> </P>
<P><BR></P>
<PRE> SAFEARRAY *CreateArray()
{
// one dimensional array with 100 elements and
// zero-based indexing
  SAFEARRAYBOUND rgb [] = { 100, 0 };
// allocate the memory for the descriptor
// and the array data
  SAFEARRAY *psa = SafeArrayCreate(VT_I4, 1, rgb);
  if (psa) {
// get ptr to array base
    long *rgelems;
    SafeArrayAccessData(psa, (void**)&amp;rgelems);
// initialize each element
    for (int c = 0; c &lt; 100; c++)
      rgelems[c] = c;
// release lock on array state
    SafeArrayUnaccessData(psa);
  }
  return psa;
}</PRE>
<P> </P>
<P>The SAFEARRAY API functions manage all memory for you. For simpler situations, or when performance is important, you can manage the memory for both the descriptor and the array by hand. To notify the system that the memory is user-managed, the fFeatures field supports the following flags:</P>
<P> </P>
<P><BR></P>
<PRE> #define        FADF_AUTO           ( 0x1 )
#define        FADF_STATIC         ( 0x2 )
#define        FADF_EMBEDDED       ( 0x4 )
#define        FADF_FIXEDSIZE      ( 0x10 )</PRE>
<P> </P>
<P>The AUTO, STATIC, and EMBEDDED flags indicate that the memory belongs to the user, not the system. The FIXEDSIZE flag indicates that the array cannot be redimensioned. The performance gains that can be achieved by manually managing the memory used in the array are fairly trivial if the object is out-of-process, but can be quite high (by factors of 10 or more) if the object is in-process.</P>
<P>Armed with the knowledge of SAFEARRAYs, we can now get back to the problem of passing structs through a dual interface. The type library compiler allows you to specify parameter types that are arrays by using the SAFEARRAY keyword.</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110024-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface INeedARectToo : IDispatch
{
  HRESULT GiveMeARect(
                [in] SAFEARRAY (unsigned char) parray);
}</PRE>
<P> </P>
<P>While the type library compiler accepts this description, both Visual Basic and MFC have severe problems dealing with this type of parameter (in fact, both prohibit it). Fortunately, both environments allow you to pass arrays indirectly as a VARIANT, with the following interface definition:</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110024-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface INeedARectAlso : IDispatch
{
  HRESULT GiveMeARect([in] VARIANT var);
}</PRE>
<P> </P>
<P>To pass a RECT through this parameter, the client must first create and initialize the array, then create and initialize a VARIANT that refers to the array. <B>Figure 4</B> shows the memory layout of this technique.<B> Figure 5</B> illustrates how to implement this in C++. If the client is Visual Basic, some additional work is required to invoke the method.</P>
<P><img src="oleqa4.gif"></P>
<P><B> Figure 4  Passing a RECT as a SAFEARRAY of Bytes</B></P>
<P> </P>
<P><BR></P>
<PRE> Rem VB can't convert from RECT to byte array, 
Rem so this intermediate type is needed to
Rem use LSet (the typecast operator of VB)
Type RectByteArray
  ba(16) as Byte
End Type
Sub PassARect(nar as INeedARectAlso, r as RECT)
  Dim rba as RectByteArray
  LSet rba = r
  nar.GiveMeARect rba.ba
End Sub</PRE>
<P><B> Figure 5  PassARect</B></P>
<P><BR></P>
<PRE> void PassARect(INeedARectAlso *pnar, const RECT&amp; r) 
{
// create a safearray descriptor, using the actual
// RECT as the byte array, avoiding redundant 
// memory copying
  SAFEARRAY sa = {
    1,                       // 1-dimensional
    FADF_AUTO|FADF_FIXEDSIZE,// my memory
    sizeof(char),            // elems are 1 byte
    0,                       // no locks
    (void*)&amp;r,               // here's the array!
    {
      sizeof(RECT),          // it has 16 elems
      0,                     // ALL arrays start at 0
    }
  }
// create a VARIANT that contains our safearray
  VARIANT arg; ZeroMemory(&amp;arg, sizeof(arg));
  arg.vt = VT_UI1 | VT_ARRAY;
  arg.parray = &amp;sa;
// call the function
  pnar-&gt;GiveMeARect(arg);

}</PRE>
<P>Fortunately, finding the RECT in the implementation is straightforward.</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT CoNeedARectAlso::GiveMeARect (VARIANT var)
{
  if (var.vt != (VT_UI1 | VT_ARRAY))
    return E_INVALIDARG;
  const RECT *pr;
  SafeArrayAccessData(var.parray, (void**)&amp;pr);
  m_rect = *pr;
  SafeArrayUnaccessData(var.parray);
  return S_OK;
}</PRE>
<P>This technique is practical for structures that contain simple primitive types that you can treat as byte arrays easily. The implementation shown above assumes that both the client and the object are executing on the same platform and does not address issues such as byte ordering, member alignment, and floating point formats. Additionally, for structures that contain more complex types, simply copying the memory that the structure occupies is not enough, as is the case with pointers. Moreover, if the structure contains COM interface pointers, you cannot use this technique at all. On the plus side, this technique performs extremely well, as virtually no processing or copying is required by the client or object implementations.</P>
<P>The third technique for passing structures is to serialize each struct member into an array of VARIANTs. This technique is similar to the previous approach, but it requires the client and object to individually pack each structure member into a variant, which allows the use of somewhat richer member types (interface pointers are legal). To use this technique, the interface description is the same as in the previous example.</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110025-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface INeedARectAsWell : IDispatch
{
  HRESULT GiveMeARect([in] VARIANT var);
}</PRE>
<P> </P>
<P>To pass a RECT through this parameter, the client must first create and initialize an array of VARIANTs based on the RECT's contents and then create and initialize an additional VARIANT that refers to the array. <B>Figure 6</B> shows the memory layout of this technique. <B>Figure 7</B> illustrates the required client C++ code. For Visual Basic clients, all that is needed is some simple linearization of the struct into a variant array:</P>
<P> </P>
<P><BR></P>
<PRE> Sub PassARect(nar as INeedARectAsWell, r as RECT)
Dim va(4) as Variant
  va(0) = r.left
  va(1) = r.top
  va(2) = r.right
  va(3) = r.bottom
  nar.GiveMeARect va
End Sub</PRE>
<P><img src="oleqa6.gif"></P>
<P><B> Figure 6  Passing a RECT as a SAFEARRAY of VARIANTs</B></P>
<P><B>Figure 7  Serializing Each Struct Member into an Array of VARIANTs</B></P>
<P><BR></P>
<PRE> void PassARect(INeedARectAsWell *pnar, const RECT&amp; r) 
{
// create and initialize an array of variants 
// that will hold each element of our struct
  VARIANT vars[4]; ZeroMemory(vars, sizeof(vars));
  vars[0].vt = VT_I4; vars[0].lVal = r.left;
  vars[1].vt = VT_I4; vars[1].lVal = r.top;
  vars[2].vt = VT_I4; vars[2].lVal = r.right;
  vars[3].vt = VT_I4; vars[3].lVal = r.bottom;
  
// create a safearray descriptor, using the array
// above
  SAFEARRAY sa = {
    1,                       // 1-dimensional
    FADF_VARIANT|FADF_AUTO|FADF_FIXEDSIZE,// my memory
    sizeof(VARIANT),         // elems are 16 bytes
    0,                       // no locks
    (void*)vars,             // here's the array!
    {
      4,                     // it has 4 elems
      0,                     // ALL arrays start at 0
    }
  }
// create a VARIANT that contains our safearray
  VARIANT arg; ZeroMemory(&amp;arg, sizeof(arg));
  arg.vt = VT_VARIANT | VT_ARRAY;
  arg.parray = &amp;sa;
// call the function
  pnar-&gt;GiveMeARect(arg);
}</PRE>
<P>To reconstruct the RECT, the implementation must extract each member by hand.</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT 
CoNeedARectAsWell::GiveMeARect(VARIANT var)
{
  if (var.vt != (VT_VARIANT | VT_ARRAY))
    return E_INVALIDARG;
  VARIANT *rgv;
  SafeArrayAccessData(var.parray,
                      (void**)&amp;rgv);
  RECT r = { rgv[0].lVal, rgv[1].lVal, 
             rgv[2].lVal, rgv[3].lVal };
  SafeArrayUnaccessData(var.parray);
  m_rect = r;
  return S_OK;
}</PRE>
<P> </P>
<P>This technique is somewhat less convenient than using byte arrays, but it works with structs that contain interface pointers. It also works when communicating with objects that are on machines with different byte-ordering or floating point formats than that of the client, as the interface marshaler will convert between the disparate data formats transparently. </P>
<P>The fourth technique for passing user-defined structs through dual and dispatch interfaces requires the most work from the object, but yields the best integration with Visual Basic. This technique requires that the structure be passed not by value as raw bytes, but instead as a COM object that exposes the structure members as properties that are accessible from either IDispatch or as a dual interface. This approach requires the definition of a second interface that maps structure members onto properties.</P>
<P><B>Figure 8</B> is an example mapping of the RECT struct mapped onto a dual interface. Figure 9 shows CoRect, an implementation of this interface that simply contains a RECT and implements the accessor and mutator functions as one would expect. Given the implementation of this RECT wrapper, our RECT-hungry interface would now look like this:</P>
<P> </P>
<P><BR></P>
<PRE> [ 
  uuid(00110026-0000-1111-2222-BABAABABBAAB),
  odl, dual
]
interface INeedARectSoBadItHurts : IDispatch
{
  HRESULT GiveMeARect([in] IRect *pRect);
}</PRE>
<P><B> Figure 8  Mapping the RECT Structure Onto a Dual Interface</B></P>
<P><BR></P>
<PRE> [ 
    uuid(7A52A801-860B-11cf-B1D2-0080C7BC7884),
    odl, dual
]
interface IRect : IDispatch
{
    [propget, id(1)] <BR>    HRESULT Left([out, retval] long *pVal);
    [propput, id(1)] <BR>    HRESULT Left([in] long val);
    [propget, id(2)] <BR>    HRESULT Top([out, retval] long *pVal);
    [propput, id(2)] <BR>    HRESULT Top([in] long val);
    [propget, id(3)] <BR>    HRESULT Right([out, retval] long *pVal);
    [propput, id(3)] 
    HRESULT Right([in] long val);
    [propget, id(4)] 
    HRESULT Bottom([out, retval] long *pVal);
    [propput, id(4)] 
    HRESULT Bottom([in] long val);
}</PRE>
<P><B> Figure 9  Dual Interface Wrapper for RECT</B></P>
<P></P>
<P>StructLib.od</P>
<P><BR></P>
<PRE> ///////////////////////////////////////////////////////////
//
// StructLib.odl - an implementation of a COM wrapper
//                 to a RECT that exposes the embedded
//                 struct via dual/dispatch properties

[
    uuid(7A52A800-860B-11cf-B1D2-0080C7BC7884),
    lcid(9),
    version(1.0),
    helpstring("A library desparately in need of structure support!")
]
library StructLib
{
    importlib("stdole32.tlb");

    [ 
        uuid(7A52A801-860B-11cf-B1D2-0080C7BC7884),
        odl,
        dual,
        oleautomation
    ]
    interface IRect : IDispatch
    {
        [propget, id(1)] HRESULT Left([out, retval] long *pVal);
        [propput, id(1)] HRESULT Left([in] long val);
        [propget, id(2)] HRESULT Top([out, retval] long *pVal);
        [propput, id(2)] HRESULT Top([in] long val);
        [propget, id(3)] HRESULT Right([out, retval] long *pVal);
        [propput, id(3)] HRESULT Right([in] long val);
        [propget, id(4)] HRESULT Bottom([out, retval] long *pVal);
        [propput, id(4)] HRESULT Bottom([in] long val);
    }        

    [
        uuid(7A52A803-860B-11cf-B1D2-0080C7BC7884)
    ]
    coclass CoRect
    {
        [default] interface IRect;
    }
}</PRE>
<P></P>
<P>CoRect.H</P>
<P><BR></P>
<PRE> ///////////////////////////////////////////////////////////
//
// CoRect.h - an implementation of a COM wrapper
//              to a RECT that exposes the embedded
//              struct via dual/dispatch properties

#ifndef _COSTRUCTS_H
#define _COSTRUCTS_H

#include "StructLib.h"

class CoRect : public IRect
{
// COM stuff
    LONG        m_cRef;
    ITypeInfo  *m_pTypeInfo;
// Domain-specific stuff
    RECT        m_rect;

// helper function to get safely access our type description
    ITypeInfo *GetTypeInfo(HRESULT &amp;hr);
public:
    CoRect();
    virtual ~CoRect();

// IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

// IDispatch methods
    STDMETHODIMP GetTypeInfoCount(unsigned int * pctInfo);
    STDMETHODIMP GetTypeInfo(unsigned int nInfo, LCID lcid, 
                             ITypeInfo **ppTypeInfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR **rgszNames,
                               unsigned int cNames, LCID lcid, 
                               DISPID * rgdispids);
    STDMETHODIMP Invoke(DISPID dispid, REFIID riid, LCID lcid,
                        WORD wFlags, DISPPARAMS *pdispparams,
                        VARIANT *pVarResult, EXCEPINFO *pei,
                        unsigned int *puArgError);

// IRect methods
    STDMETHODIMP get_Top(long *pVal);
    STDMETHODIMP put_Top(long val);
    STDMETHODIMP get_Left(long *pVal);
    STDMETHODIMP put_Left(long val);
    STDMETHODIMP get_Bottom(long *pVal);
    STDMETHODIMP put_Bottom(long val);
    STDMETHODIMP get_Right(long *pVal);
    STDMETHODIMP put_Right(long val);
};

#endif</PRE>
<P></P>
<P>CoRect.cpp</P>
<P><BR></P>
<PRE> ///////////////////////////////////////////////////////////
//
// CoRect.cpp - an implementation of a COM wrapper
//              to a RECT that exposes the embedded
//              struct via dual/dispatch properties

#include &lt;windows.h&gt;
#include &lt;TCHAR.h&gt;
#include &lt;initguid.h&gt;
#include "CoRect.h"

void SvcLock(void);    // standard server lock/unlock functions 
void SvcUnlock(void);  // that hold/release server in memory

CoRect::CoRect()
: m_cRef(0), m_pTypeInfo(0)
{
    SvcLock();
    ZeroMemory(&amp;m_rect, sizeof(m_rect));
}

CoRect::~CoRect()
{
    if (m_pTypeInfo)
        m_pTypeInfo-&gt;Release();
    SvcUnlock();
}

ITypeInfo *CoRect::GetTypeInfo(HRESULT &amp;hr)
{
    if (!m_pTypeInfo)
    {
        ITypeLib *pTypeLib = 0;
        hr = LoadRegTypeLib(LIBID_StructLib, 1, 0, 9, &amp;pTypeLib);
        if (FAILED(hr))
            hr = LoadTypeLib(OLESTR("StructLib.tlb"), &amp;pTypeLib);
        if (SUCCEEDED(result))
        {
            hr = pTypeLib-&gt;GetTypeInfoOfGuid(IID_IRect, m_pTypeInfo);
            pTypeLib-&gt;Release();
        }
        else
            m_pTypeInfo = 0;
    }
    else
        hr = S_OK;
    return m_pTypeInfo;
}

// IUnknown methods
STDMETHODIMP CoRect::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IRect || riid == IID_IDispatch || riid == IID_IUnknown)
        *ppv = (IRect*)this;
    else
        *ppv = 0;
    if (*ppv)
        ((IUnknown*)*ppv)-&gt;AddRef();
    return *ppv ? S_OK : E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CoRect::AddRef()
{
    InterlockedIncrement(&amp;m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CoRect::Release()
{
    if (InterlockedDecrement(&amp;m_cRef) != 0)
        return m_cRef;
    delete this;
    return 0;
}

// IDispatch methods
STDMETHODIMP CoRect::GetTypeInfoCount(unsigned int * pctInfo)
{
    HRESULT hr = S_OK;
    *pctInfo = (GetTypeInfo(hr) == 0) ? 0 : 1;
    return hr;
}

STDMETHODIMP CoRect::GetTypeInfo(unsigned int nInfo, LCID lcid, 
                                 ITypeInfo **ppTypeInfo)
{
    HRESULT hr = S_OK;
    if (*ppTypeInfo = GetTypeInfo(hr))
        (*ppTypeInfo)-&gt;AddRef();
    return hr;
}

STDMETHODIMP CoRect::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames,
                                   unsigned int cNames, LCID lcid, 
                                   DISPID * rgdispids)
{
    HRESULT hr = S_OK;
    ITypeInfo *pti = GetTypeInfo(hr);
    if (pti)
        hr = pti-&gt;GetIDsOfNames(rgszNames, cNames, rgdispids);
    return hr;
}

STDMETHODIMP CoRect::Invoke(DISPID dispid, REFIID riid, LCID lcid,
                            WORD wFlags, DISPPARAMS *pdispparams,
                            VARIANT *pVarResult, EXCEPINFO *pei,
                            unsigned int *puArgError)
{
    HRESULT hr = S_OK;
    ITypeInfo *pti = GetTypeInfo(hr);
    if (pti)
        hr = pti-&gt;Invoke((IRect*)this, dispid, wFlags, pdispparams,
        pVarResult,  pei, puArgError);
    return hr;
}

// IRect methods
STDMETHODIMP CoRect::get_Top(long *pVal)
{
    *pVal = m_rect.top;
    return S_OK;
}

STDMETHODIMP CoRect::put_Top(long val)
{
    m_rect.top = val;
    return S_OK;
}

STDMETHODIMP CoRect::get_Left(long *pVal)
{
    *pVal = m_rect.left;
    return S_OK;
}

STDMETHODIMP CoRect::put_Left(long val)
{
    m_rect.left = val;
    return S_OK;
}

STDMETHODIMP CoRect::get_Bottom(long *pVal)
{
    *pVal = m_rect.bottom;
    return S_OK;
}

STDMETHODIMP CoRect::put_Bottom(long val)
{
    m_rect.bottom = val;
    return S_OK;
}

STDMETHODIMP CoRect::get_Right(long *pVal)
{
    *pVal = m_rect.right;
    return S_OK;
}

STDMETHODIMP CoRect::put_Right(long val)
{
    m_rect.right = val;
    return S_OK;
}</PRE>
<P>Visual Basic clients must now create an instance of the wrapper object to pass to the method in question.</P>
<P> </P>
<P><BR></P>
<PRE> Sub PassARect(nar as INeedARectSoBadItHurts, 
              r as RECT)
  Dim rct as new CoRect
  rct.Left = r.left
  rct.Top = r.top
  rct.Right = r.right
  rct.Bottom = r.bottom
  nar.GiveMeARect rct
End Sub</PRE>
<P> </P>
<P>C++ clients do essentially the same thing but with a syntax that only a mother could love (see <B>Figure 10</B>).</P>
<P><B> Figure 10  Creating a Rect Wrapper</B></P>
<P><BR></P>
<PRE> void PassARect(INeedARectSoBadItHurts *pnar, const RECT&amp; r) 
{
// create and initialize an wrapper object
// that will hold each element of our struct
  IRect *pRect;
  HRESULT hr =  CoCreateInstance(CLSID_CoRect, 0, CLSCTX_ALL, IID_IRect, 
                                 (void**)&amp;pRect);
  
  if (FAILED(hr))
    throw "Couldn't create RECT wrapper";
  pRect-&gt;put_Left(r.left);
  pRect-&gt;put_Top(r.top);
  pRect-&gt;put_Right(r.right);
  pRect-&gt;put_Bottom(r.bottom);

// call the function
  pnar-&gt;GiveMeARect(pRect);
// release our wrapper
  pRect-&gt;Release();
}</PRE>
<P>On the implementation side, you must reconstruct the RECT by extracting each member from the wrapper using the propget functions.</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT 
CoNeedARectSoBadItHurts::GiveMeARect(IRect *pRect)
{
  RECT r;
  pRect-&gt;get_Left(&amp;r.left);
  pRect-&gt;get_Top(&amp;r.top);
  pRect-&gt;get_Right(&amp;r.right);
  pRect-&gt;get_Bottom(&amp;r.bottom);
  m_rect = r;
  return S_OK;
}</PRE>
<P> </P>
<P>This technique is extremely convenient and elegant for Visual Basic clients, and it's palatable for C++ clients. As with the previous approach (based on VARIANT arrays), the marshaling layer will hide any platform differences transparently.</P>
<P>One drawback of this approach is that the object designer must implement and support not only the primary objects and interfaces, but also any wrappers that are used to hide user-defined structures. A more serious drawback is that of performance. If the target object that will receive the wrapper is out-of-process, then the wrapper object is, by definition, in the wrong address space. If the wrapper object is implemented as an in-process server, then the client's PROPERTYPUT routines will execute relatively quickly, but the target object's PROPERTYGET routines will require communications back to the client's address space (see <B>Figure 11</B>). If the wrapper object is implemented as an out-of-process server that shares the process of the target object, then the target's PROPERTYGET routines will execute quickly, but the client's PROPERTYPUT routines will each require out-of-process communications (see <B>Figure 12</B>). Either way, using the wrapper object approach results in <I>n</I> additional round-trips where <I>n</I> is the number of exposed properties.</P>
<P><img src="oleqa11.gif"></P>
<P><B> Figure 11  In-process Struct-Wrapper</B></P>
<P><img src="oleqa12.gif"></P>
<P><B> Figure 12 Out-of-process Struct-Wrapper </B></P>
<P><B>Figure 13</B> enumerates the relative tradeoffs for each approach described above. It is important to note that the performance penalty of the fourth approach (based on COM wrappers to encapsulate structs) only worsens when using MFC version 4.<I>x</I> or earlier. At the time of this writing, MFC only supports dual interfaces if the developer is willing to implement most of the dual and all of the ODL manually, rendering the Class Wizard virtually useless. For many developers, this means the wrapper object will only export a plain dispatch-based interface. This slows things down considerably when compared to a dual interface.</P>
<P><B> Figure 13  Tradeoffs</B></P>
<P></P>

<TABLE COLS="5" BORDER="0"><COLGROUP><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="91pt" VALIGN="TOP"><COL WIDTH="95pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> </B></P></TD><TD VALIGN="TOP"><P><B>Pass structure members as individual parameters </B></P></TD><TD VALIGN="TOP"><P><B>Pass structure as SAFEARRAY of bytes</B></P></TD><TD VALIGN="TOP"><P><B>Pass structure as SAFEARRAY of Variants</B></P></TD><TD VALIGN="TOP"><P><B>Pass structure inside dual interface wrapper object</B></P></TD></TR><TR><TD VALIGN="TOP"><P> Platform Independent</P></TD><TD VALIGN="TOP"><P>Yes</P></TD><TD VALIGN="TOP"><P>No</P></TD><TD VALIGN="TOP"><P>Yes</P></TD><TD VALIGN="TOP"><P>Yes</P></TD></TR><TR><TD VALIGN="TOP"><P> Supports structs with interface pointer members</P></TD><TD VALIGN="TOP"><P>Yes</P></TD><TD VALIGN="TOP"><P>No</P></TD><TD VALIGN="TOP"><P>Yes</P></TD><TD VALIGN="TOP"><P>Yes</P></TD></TR><TR><TD VALIGN="TOP"><P> Ease of use from Visual Basic</P></TD><TD VALIGN="TOP"><P>Great if few members</P></TD><TD VALIGN="TOP"><P>Difficult</P></TD><TD VALIGN="TOP"><P>Good</P></TD><TD VALIGN="TOP"><P>Good</P></TD></TR><TR><TD VALIGN="TOP"><P> Ease of use from C++</P></TD><TD VALIGN="TOP"><P>Great if few members</P></TD><TD VALIGN="TOP"><P>Good, provided no members are pointers</P></TD><TD VALIGN="TOP"><P>Fair</P></TD><TD VALIGN="TOP"><P>Good</P></TD></TR><TR><TD VALIGN="TOP"><P> Type-safety</P></TD><TD VALIGN="TOP"><P>Good, provided struct members are VARIANT-compatible</P></TD><TD VALIGN="TOP"><P>None</P></TD><TD VALIGN="TOP"><P>None</P></TD><TD VALIGN="TOP"><P>Good, provided struct members are VARIANT-compatible</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>Calls per Second: </B></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P> </P></TD></TR><TR><TD VALIGN="TOP"><P> C++ Client/In-process Object</P></TD><TD VALIGN="TOP"><P>3,215,434</P></TD><TD VALIGN="TOP"><P>1,386,963</P></TD><TD VALIGN="TOP"><P>900,090</P></TD><TD VALIGN="TOP"><P>15,504</P></TD></TR><TR><TD VALIGN="TOP"><P> Visual Basic 4.0 Client/In-process Object</P></TD><TD VALIGN="TOP"><P>204,082</P></TD><TD VALIGN="TOP"><P>55,556</P></TD><TD VALIGN="TOP"><P>22,173</P></TD><TD VALIGN="TOP"><P>5,546</P></TD></TR><TR><TD VALIGN="TOP"><P> C++ Client/Out-of-Process Object</P></TD><TD VALIGN="TOP"><P>736</P></TD><TD VALIGN="TOP"><P>700</P></TD><TD VALIGN="TOP"><P>681</P></TD><TD VALIGN="TOP"><P>41</P></TD></TR><TR><TD VALIGN="TOP"><P> Visual Basic 4.0 Client/Out-of-Process Object</P></TD><TD VALIGN="TOP"><P>674</P></TD><TD VALIGN="TOP"><P>648</P></TD><TD VALIGN="TOP"><P>618</P></TD><TD VALIGN="TOP"><P>33</P></TD></TR><TR><TD COLSPAN="5" VALIGN="TOP"><P> All performance numbers based on passing a RECT from client to object. Higher numbers are better.</P>
<P>Results shown are for Windows NT<FONT FACE="Symbol">Ò</FONT> 4.0 Beta 1, 120 MHz Pentium, 40MB physical memory. </P>
<P></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>I intentionally skipped two other alternative techniques. One of these techniques is a variation on the struct-wrapper approach, but instead of exposing the embedded struct via a dispatch/dual interface, you would expose it via an IDataObject interface. This approach suffers all of the limitations of the byte-array technique (it is just passing raw bytes around via GetData) but does not offer the same performance benefits (the GetData method requires an additional round-trip, which severely impacts performance in the out-of-process case). It also cannot be used from Visual Basic, which limits its usefulness. Given that the byte-array technique is actually easier to implement and is available from Visual Basic, there is no reason to favor the IDataObject approach.</P>
<P>Another technique that was popular in the early days of IDispatch was to treat a BSTR as an opaque array of bytes. This approach ceases to work now that BSTRs are Unicode. The marshaler will perform byte-swapping when communicating with some remote hosts, and performs Unicode-to-ASCII conversion when communicating with 16-bit processes.</P>
<P>As you might have concluded by now, structs and IDispatch/dual interfaces are not a good match. All of the techniques described above are workable, but less than ideal. For small structures, breaking out the structure members as individual parameters is definitely the way to go. For large structures, the choice is not so obvious. If Visual Basic compatibility is important, then the struct-wrapper technique is elegant but inefficient. However, it is arguably less work to simply break out 20 structure members as parameters than to perform 20 PROPERTYPUT operations. Unless programmers will use your struct-wrappers as native data types in their Visual Basic-based applications, be prepared to see the performance of your library slow down considerably. </P>
<P>If optimal performance and elegance from C++ is important, perhaps the best approach is to leverage the key feature of COM, QueryInterface. Instead of forcing C++ clients to call through the dual interface, you could add support for a second custom interface that is not subject to the VARIANT-compatible restriction. By supporting both a dual and a custom interface from the same object, Visual Basic clients could still QueryInterface for the more restricted dual interface, while C++ clients should use the more flexible struct-friendly interface. This technique requires more work by the object implementor, but yields the best overall performance and is considerably more convenient for the object's client.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P></font></body></HTML>
