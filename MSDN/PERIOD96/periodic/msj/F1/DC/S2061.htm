<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Previewing the Common Controls DLL for Microsoft Internet Exlorer 4.0, Part II</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Previewing the Common Controls DLL for Microsoft Internet Exlorer 4.0, Part II</H1><P>Strohm Armstrong</P>
<P>Strohm Armstrong is a support engineer at Microsoft specializing in user and shell technologies.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4957">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the LISTVIEW project files.</A></P><P><OBJECT id=sample2 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4958">
</OBJECT><a href="javascript:sample2.Click()">
Click to open or copy the VLISTVW project files.</A></P><P>Inthefirstpartofthis series, I covered some of the new features of the common controls DLL that is part of Microsoft¨ Internet Explorer (IE) 4.0. I focused on the new features such as custom draw and the new controls such as the CoolBar and the Date/Time Picker.</P>
<P>This month I will talk about the enhancements to already existing controls. I will cover the enhanced ListView control, which can hold a seemingly infinite amount of items, the enhanced Header control, the enhanced Tab control, the enhanced ToolTip control, and the enhanced TrackBar control, to name a few. In addition, I will provide a couple of sample programs that show correct usage of the enhanced controls, and also use some of the brand new controls discussed in Part I.</P>
<P>Just as with the sample in Part I, you will need to get the new common controls DLL. (Just install IE 3.0 to get the IE 4.0 Common Controls DLL—yes, you read that right. The DLL is not redistributable, so downloading IE 3.0 is the only way to get it right now.)</P>
<H2><A NAME="sec0"></A>  Virtual ListView</H2><P>The ListView control now has a method called Virtual ListView that allows a large number of items to be contained in the control. The control is created like any other ListView, except you add the LVS_OWNERDATA style. </P>
<P>After you create the control, you tell it how many items will be in the control by sending it the LVM_SETITEMCOUNT message. When you send this message, you are telling the control how many items will appear to be in the control; you never actually insert any items into the control. This message takes an int for the wParam that is the number of items the control will contain. The lParam is zero or a combination of the flags that specify display options: LVSICF_NOINVALIDATEALL means the ListView control will not repaint unless affected items are currently in view and LVSICF_NOSCROLL means the ListView control will not change the scroll position when the item count changes.</P>
<P>From this point on, any item displayed in the ListView will do so on a callback basis. The control will send the LVN_GETDISPINFO notification for any item displayed. You process this notification just as you would a standard ListView control—by supplying the requested display information. The lParam for this notification is a pointer to an LV_DISPINFO structure. The mask member of this structure specifies the information the control is seeking. </P>
<P>Two notification messages are specific to the Virtual ListView. The first, LVN_ODFINDITEM, is sent when the control needs to find a particular item. Say, for instance, the user typed something while focus is in the control. The lParam for this notification is a pointer to an NMLVFINDITEM structure. This structure contains an NMHDR structure (hdr), an index at which to start the search (iStart), and an LVFINDINFO (formerly LV_FINDINFO) structure (lvfi). This information is supplied to enable you to find the requested item. You should return the index of the requested item, or –1 if the item was not found. </P>
<P>The second notification is LVN_ODCACHEHINT. This notification is sent when the ListView is about to ask for a range of items. The lParam for this notification is a pointer to an NMLVCACHEHINT structure. This structure contains an NMHDR structure (hdr), an int that indicates the beginning of the range (iFrom), and an int that indicates the end of the range of items (iTo). On this notification, you should load the specified items into your local cache if you are maintaining one. It is still possible to get an LVN_GET-DISPINFO for an uncached item, so your application must take this into account.</P>
<H2><A NAME="sec1"></A>  The VListVw Sample</H2><P>My next sample application demonstrates the Virtual ListView (see <B>Figures 1</B> and <B>2</B>). This application displays a list of 100,000,000 items in a ListView. (The code is available from the sources listed on page 5.) Keep in mind that users will line up by the millions at the local software store demanding a refund if you have the gall to present them with a list containing 100,000,000 items, but I digress.</P>
<P><img src="ie4_1.gif"></P>
<P><B> Figure 1  Vitual ListView Sample Application</B></P>
<P><B>Figure 2  VListVw.c</B></P>
<P><BR></P>
<PRE> /**************************************************************************

   File: VListVw.c
   
**************************************************************************/
·
·
·
/**************************************************************************
   Global Variables
**************************************************************************/

HANDLE   g_hInst;
TCHAR    g_szClassName[] = TEXT("VListVwClass");

#define ITEM_COUNT   100000000
#define IDC_LISTVIEW 2000

/******************************************************************************

   WinMain

******************************************************************************/

int PASCAL WinMain(  HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow)
{
MSG  msg;
INITCOMMONCONTROLSEX iccex;

//required to use the common controls
iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
iccex.dwICC = ICC_LISTVIEW_CLASSES;
InitCommonControlsEx(&amp;iccex);

g_hInst = hInstance;

if(!hPrevInstance)
   if(!InitApplication(hInstance))
      return FALSE;

/* Perform initializations that apply to a specific instance */
if (!InitInstance(hInstance, nCmdShow))
   return FALSE;

/* Acquire and dispatch messages until a WM_QUIT uMessage is received. */
while(GetMessage( &amp;msg, NULL, 0x00, 0x00))
   {
   TranslateMessage(&amp;msg);
   DispatchMessage(&amp;msg);
   }

return msg.wParam;
}
·
·
·
/******************************************************************************

   CreateListView

******************************************************************************/

HWND CreateListView(HINSTANCE hInstance, HWND hwndParent)
{
DWORD       dwStyle;
HWND        hwndListView;
HIMAGELIST  himlSmall;
HIMAGELIST  himlLarge;
BOOL        bSuccess = TRUE;

dwStyle =   WS_TABSTOP | 
            WS_CHILD | 
            WS_BORDER | 
            WS_VISIBLE |
            LVS_AUTOARRANGE |
            LVS_REPORT | 
            LVS_OWNERDATA;
            
hwndListView = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW, // class name defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 hwndParent,                // parent
                                 (HMENU)IDC_LISTVIEW,       // ID
                                 g_hInst,                   // instance
                                 NULL);                     // no extra data

if(!hwndListView)
   return NULL;

ResizeListView(hwndListView, hwndParent);

//set the image lists
himlSmall = ImageList_Create(16, 16, ILC_COLORDDB | ILC_MASK, 1, 0);
himlLarge = ImageList_Create(32, 32, ILC_COLORDDB | ILC_MASK, 1, 0);

if (himlSmall &amp;&amp; himlLarge)
   {
   HICON hIcon;

   //set up the small image list
   hIcon = LoadImage(g_hInst, MAKEINTRESOURCE(IDI_DISK), IMAGE_ICON, 16, 16,
                     LR_DEFAULTCOLOR);
   ImageList_AddIcon(himlSmall, hIcon);

   //set up the large image list
   hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_DISK));
   ImageList_AddIcon(himlLarge, hIcon);

   SendMessage(hwndListView, LVM_SETIMAGELIST, (WPARAM)LVSIL_SMALL,
               (LPARAM)himlSmall);
   SendMessage(hwndListView, LVM_SETIMAGELIST, (WPARAM)LVSIL_NORMAL,
               (LPARAM)himlLarge);
   }

return hwndListView;
}

/******************************************************************************

   ResizeListView

******************************************************************************/

void ResizeListView(HWND hwndListView, HWND hwndParent)
{
RECT  rc;

GetClientRect(hwndParent, &amp;rc);

MoveWindow( hwndListView, 
            rc.left,
            rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            TRUE);

}

/******************************************************************************

   InitListView

******************************************************************************/

BOOL InitListView(HWND hwndListView)
{
LV_COLUMN   lvColumn;
int         i;
TCHAR       szString[5][20] = {  TEXT("Main Column"), 
                                 TEXT("Column 1"), 
                                 TEXT("Column 2"), 
                                 TEXT("Column 3"), 
                                 TEXT("Column 4")};

//initialize the columns
lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
lvColumn.fmt = LVCFMT_LEFT;
lvColumn.cx = 120;
for(i = 0; i &lt; 5; i++)
   {
   lvColumn.pszText = szString[i];
   SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&amp;lvColumn);
   }

InsertListViewItems(hwndListView);

return TRUE;
}

/******************************************************************************

   InsertListViewItems

******************************************************************************/

BOOL InsertListViewItems(HWND hwndListView)
{
//empty the list
SendMessage(hwndListView, LVM_DELETEALLITEMS, 0, 0);

//set the number of items in the list
SendMessage(hwndListView, LVM_SETITEMCOUNT, (WPARAM)ITEM_COUNT,
            (LPARAM)LVSICF_NOINVALIDATEALL);

return TRUE;
}

/**************************************************************************

   ListViewNotify()

**************************************************************************/

LRESULT ListViewNotify(HWND hWnd, LPARAM lParam)
{
LPNMHDR  lpnmh = (LPNMHDR) lParam;
HWND     hwndListView = GetDlgItem(hWnd, IDC_LISTVIEW);

switch(lpnmh-&gt;code)
   {
   case LVN_GETDISPINFO:
      {
      LV_DISPINFO *lpdi = (LV_DISPINFO *)lParam;
      TCHAR szString[MAX_PATH];

      if(lpdi-&gt;item.iSubItem)
         {
         if(lpdi-&gt;item.mask &amp; LVIF_TEXT)
            {
            wsprintf(szString, TEXT("Item %d - Column %d"), lpdi-&gt;item.iItem + 1,
                     lpdi-&gt;item.iSubItem);
            lstrcpyn(lpdi-&gt;item.pszText, szString, lpdi-&gt;item.cchTextMax);
            }
         }
      else
         {
         if(lpdi-&gt;item.mask &amp; LVIF_TEXT)
            {
            wsprintf(szString, TEXT("Item %d"), lpdi-&gt;item.iItem + 1);
            lstrcpyn(lpdi-&gt;item.pszText, szString, lpdi-&gt;item.cchTextMax);
            }

         if(lpdi-&gt;item.mask &amp; LVIF_IMAGE)
            {
            lpdi-&gt;item.iImage = 0;
            }

         if(lpdi-&gt;item.mask &amp; LVIF_INDENT)
            {
            lpdi-&gt;item.iIndent = 0;
            }
         }
      }
      return 0;

   case LVN_ODCACHEHINT:
      {
      LPNMLVCACHEHINT   lpCacheHint = (LPNMLVCACHEHINT)lParam;
      /*
      This sample doesn't use this notification, but this is sent when the 
      ListView is about to ask for a range of items. On this notification, 
      you should load the specified items into your local cache. It is still 
      possible to get an LVN_GETDISPINFO for an item that has not been cached, 
      therefore, your application must take into account the chance of this 
      occurring.
      */
      }
      return 0;

   case LVN_ODFINDITEM:
      {
      LPNMLVFINDITEM lpFindItem = (LPNMLVFINDITEM)lParam;
      /*
      This sample doesn't use this notification, but this is sent when the 
      ListView needs a particular item. Return -1 if the item is not found.
      */
      }
      return 0;
   }

return 0;
}

/**************************************************************************

   SwitchView()

**************************************************************************/

void SwitchView(HWND hwndListView, DWORD dwView)
{
DWORD dwStyle = GetWindowLong(hwndListView, GWL_STYLE);

SetWindowLong(hwndListView, GWL_STYLE, (dwStyle &amp; ~LVS_TYPEMASK) | dwView);
ResizeListView(hwndListView, GetParent(hwndListView));
}
·
·
·
/**************************************************************************

   HandleContextMenu()

**************************************************************************/

BOOL HandleContextMenu( HWND hWnd, 
                        WPARAM wParam, 
                        LPARAM lParam)
{
HMENU hMenuLoad,
      hMenu;

if((HWND)wParam != GetDlgItem(hWnd, IDC_LISTVIEW))
   return FALSE;

hMenuLoad = LoadMenu(g_hInst, MAKEINTRESOURCE(IDM_CONTEXT_MENU));
hMenu = GetSubMenu(hMenuLoad, 0);

UpdateMenu(GetDlgItem(hWnd, IDC_LISTVIEW), hMenu);

TrackPopupMenu(   hMenu,
                  TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                  LOWORD(lParam),
                  HIWORD(lParam),
                  0,
                  hWnd,
                  NULL);

DestroyMenu(hMenuLoad);

return TRUE;
}
·
·
·
</PRE>
<P>During initialization, VListVw calls InitCommonControlsEx with dwICC of the INITCOMMONCONTROLSEX structure set to ICC_LISTVIEW_CLASSES to initialize the ListView class. In the CreateListView function, CreateWindowEx creates the ListView. Since I am creating a virtual ListView, the LVS_OWNERDATA style bit is added to the window styles for the control. The small and large image lists are then created and initialized using the Image List APIs. The image lists are assigned to the ListView by sending the control the LVM_SETIMAGELIST message once for the small icons and once for the large icons (as always, wParam indicates which size icon you are passing in). After the ListView is created, VListVw then calls InitListView, which sets up the column information using the LVM_INSERTCOLUMN message. InitListView then calls InsertListViewItems, which clears any items already in the list and then sends the LVM_SETITEMCOUNT message to the ListView to tell the control how many items it will contain.</P>
<P>When the user selects a different view, the application simply calls SwitchView with the desired view style. SwitchView uses GetWind-owLong with GWL_STYLE to retrieve the current style settings. The view bits are then cleared and the new view-style bit is set. SetWindowLong with GWL_STYLE is then used to set the new style in the control.</P>
<H2><A NAME="sec2"></A>  New ListView Features</H2><P>Items in a ListView can now be indented. Item indenting is only supported in report view. The LVITEM structure is the same as the previous LV_ITEM structure with the addition of an int member (iIndent) that specifies how much to indent an item. Just set iIndent to the number of indent units you wish. An indent unit is the width of one item image. The item will be indented by iIndent*&lt;image width&gt; pixels.</P>
<P>The ListView also supports extended styles. As with the ComboBoxEx control, these extended styles should not be confused with extended window styles. <B>Figure 3</B> lists the extended styles supported by the ListView. The extended styles are set by sending the LVM_SETEXTENDEDLISTVIEWSTYLES message to the control. The lParam for this message is a DWORD that contains the extended ListView styles to be set. To retrieve the extended ListView styles, send the control an LVM_GETEXTENDEDLISTVIEWSTYLES message. The return value of this message is a DWORD that contains the current extended ListView styles. All of the new ListView messages are explained in <B>Figure 4</B>.</P>
<P><B> Figure 3  ListView Extended Styles</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Style Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_CHECKBOXES</P></TD><TD VALIGN="TOP"><P>The control supplies check boxes for each item. You can retrieve the state of thecheck box by using the ListView_GetCheckState macro.</P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_FULLROWSELECT</P></TD><TD VALIGN="TOP"><P>When an item is selected, all of its subitems are also displayed as selected. Clicking on any subitem will select the entire row. This extended style is only effective in conjunction with the LVS_REPORT style.</P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_GRIDLINES</P></TD><TD VALIGN="TOP"><P>Dashed gridlines are displayed around all items and subitems. This extended style is only effective in conjunction with the LVS_REPORT style.</P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_HEADERDRAGDROP</P></TD><TD VALIGN="TOP"><P>Enables drag-and-drop re-ordering of the columns in the ListView. This extended style is only effective in conjunction with the LVS_REPORT style.</P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_SUBITEMIMAGES</P></TD><TD VALIGN="TOP"><P>Allows images to be displayed for subitems. This extended style is only effective in conjunction with the LVS_REPORT style.</P></TD></TR><TR><TD VALIGN="TOP"><P> LVS_EX_TRACKSELECT</P></TD><TD VALIGN="TOP"><P>Enables hot tracking of items in a ListView control. Hot Tracking, also known as Hover Selection, means that an item is automatically selected when the mouse pointer is over it for more than 1 second. This style applies to all styles of  the ListView control.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 4  New ListView Messages</B></P>

<TABLE COLS="5" BORDER="0"><COLGROUP><COL WIDTH="158pt" VALIGN="TOP"><COL WIDTH="108pt" VALIGN="TOP"><COL WIDTH="58pt" VALIGN="TOP"><COL WIDTH="116pt" VALIGN="TOP"><COL WIDTH="126pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Message</P></TD><TD VALIGN="TOP"><P>Description</P></TD><TD VALIGN="TOP"><P>wParam</P></TD><TD VALIGN="TOP"><P>lParam</P></TD><TD VALIGN="TOP"><P>Return Value</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_GETEXTENDEDLISTVIEWSTYLES</P></TD><TD VALIGN="TOP"><P>Retrieves the extended ListView styles.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A DWORD value which contains the extended style flags currently set in the control.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_SETEXTENDEDLISTVIEWSTYLES</P></TD><TD VALIGN="TOP"><P>Sets the extended ListView styles.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A DWORD value which contains the extended style flags to be set.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_GETCOLUMNORDERARRAY</P></TD><TD VALIGN="TOP"><P>Retrieves the current column-ordering information.</P></TD><TD VALIGN="TOP"><P>An integer value that indicates the number of columns in the control.</P></TD><TD VALIGN="TOP"><P>A pointer to an array of integers that receives the column-ordering information. The ordering information is given as the columns are displayed left-to-right. This array must be at least &lt;number of columns&gt; * sizeof(int).</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating the success or failure of the message.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_SETCOLUMNORDERARRAY</P></TD><TD VALIGN="TOP"><P>Sets the column-ordering information.</P></TD><TD VALIGN="TOP"><P>An integer value indicating the number of elements pointed to by the lParam.</P></TD><TD VALIGN="TOP"><P>A pointer to an array of integers that contains the new column-ordering information. The ordering information is given as the columns are displayed left-to-right.</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating the success or failure of the message.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_GETSUBITEMRECT</P></TD><TD VALIGN="TOP"><P>Retrieves the bounding rectangle of an item's subitem.</P></TD><TD VALIGN="TOP"><P>Index of the subitem's parent item.</P></TD><TD VALIGN="TOP"><P>Pointer to a RECT structure. Before sending the message, the one-based index of the subitem of interest is placed in the top member of the RECT structure and one of the following flags is placed in the left member of the RECT structure. After themessage is sent, the RECT structure will contain the desired information. <BR>LVIR_BOUNDS - Returns the bounding rectangle of the entire subitem, including the icon and label. <BR>LVIR_ICON - Returns the bounding rectangle of the subitem's icon. <BR>LVIR_LABEL - Returns the bounding rectangle of the subitem's label.</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating the success or failure of the message.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_SUBITEMHITTEST</P></TD><TD VALIGN="TOP"><P>Determines what item or subitem, if any, is at the given point.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Pointer to an LVHITTESTINFO structure.Before sending the message, the POINT member of the LVHITTESTINFO structure must contain the client coordinates of the point to be tested. After sending the message, if the hit test is successful and the point falls on an item, the iItem member of the LVHITTESTINFO structure will contain the index of the item on which the point falls. If the point falls on a subitem, the iSubItem member will contain the one-based index of the subitem on which the point falls andthe the iItem member will contain the subitem's parent index. </P></TD><TD VALIGN="TOP"><P>The index of the item or subitem if the hit test is successful. If the hit test fails, the subitem return value will be -1.</P></TD></TR><TR><TD VALIGN="TOP"><P>LVM_SETICONSPACING</P></TD><TD VALIGN="TOP"><P>Sets the icon spacing for a ListView which has the LVS_ICON style. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A DWORD value that contains the new horizontal spacing (cx) in the low word and the new vertical spacing (cy) in the high word. </P></TD><TD VALIGN="TOP"><P>A DWORD value that contains the previous icon spacing. The previous horizontal spacing (cx) is in the low word and the previous vertical spacing (cy) is in the high word.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H2><A NAME="sec3"></A>  The ListView Sample</H2><P>The ListView sample demonstrates the extended ListView styles and item indenting (see <B>Figures 5</B> and <B>6</B>). There is even a custom draw option for good measure. </P>
<P><img src="ie4_5.gif"></P>
<P><B> Figure 5  List View Sample Application</B></P>
<P><B>Figure 6  ListView.c</B></P>
<P><BR></P>
<PRE> /**************************************************************************

   File: ListView.c
   
**************************************************************************/
·
·
·
/**************************************************************************
   Global Variables
**************************************************************************/

HANDLE   g_hInst;
TCHAR    szClassName[] = TEXT("ListViewClass");
BOOL     g_bCustomDraw;

#define IDC_LISTVIEW 1000

/******************************************************************************

   WinMain

******************************************************************************/

int PASCAL WinMain(  HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow)
{
MSG  msg;
INITCOMMONCONTROLSEX iccex;

//required to use the common controls
iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
iccex.dwICC = ICC_LISTVIEW_CLASSES;
InitCommonControlsEx(&amp;iccex);

g_hInst = hInstance;

if(!hPrevInstance)
   if(!InitApplication(hInstance))
      return FALSE;

/* Perform initializations that apply to a specific instance */

if (!InitInstance(hInstance, nCmdShow))
   return FALSE;

/* Acquire and dispatch messages until a WM_QUIT uMessage is received. */

while(GetMessage(&amp;msg, NULL, 0x00, 0x00))
   {
   TranslateMessage(&amp;msg);
   DispatchMessage(&amp;msg);
   }

return msg.wParam;
}

·
·
·
/******************************************************************************

   MainWndProc

******************************************************************************/

LRESULT CALLBACK MainWndProc( HWND hWnd,
                              UINT uMessage,
                              WPARAM wParam,
                              LPARAM lParam)
{
switch (uMessage)
   {
   case WM_CREATE:
      {
      HWND  hwndListView;
      
      g_bCustomDraw = FALSE;
      
      // create the TreeView control
      hwndListView = CreateListView(g_hInst, hWnd);
      
      //initialize the TreeView control
      InitListView(hwndListView);
      }
      break;

   case WM_NOTIFY:
      return ListViewNotify(hWnd, lParam);
   
   case WM_SIZE:
      ResizeListView(GetDlgItem(hWnd, IDC_LISTVIEW), hWnd);
      break;

   case WM_INITMENUPOPUP:
      UpdateMenu(GetDlgItem(hWnd, IDC_LISTVIEW), GetMenu(hWnd));
      break;
   
   case WM_CONTEXTMENU:
      if(HandleContextMenu(hWnd, wParam, lParam))
         return FALSE;
      break;
   
   case WM_COMMAND:
      return HandleCommand(hWnd, wParam, lParam);

   case WM_DESTROY:
      PostQuitMessage(0);
      break;

   default:
      break;
   }
return DefWindowProc(hWnd, uMessage, wParam, lParam);
}


/******************************************************************************

   AboutDlgProc

******************************************************************************/

BOOL CALLBACK AboutDlgProc(   HWND hDlg, 
                              UINT uMessage, 
                              WPARAM wParam, 
                              LPARAM lParam)
{
switch (uMessage)
   {
   case WM_INITDIALOG:
      return TRUE;
      
   case WM_COMMAND:
      switch(wParam)
         {
         case IDOK:
            EndDialog(hDlg, IDOK);
            break;

         case IDCANCEL:
            EndDialog(hDlg, IDOK);
            break;
         }
      return TRUE;
    } 
    
return FALSE;
}

/******************************************************************************

   CreateListView

******************************************************************************/

HWND CreateListView(HINSTANCE hInstance, HWND hwndParent)
{
DWORD       dwStyle;
HWND        hwndListView;
HIMAGELIST  himlSmall;
HIMAGELIST  himlLarge;
SHFILEINFO  sfi;
BOOL        bSuccess = TRUE;

dwStyle =   WS_TABSTOP | 
            WS_CHILD | 
            WS_BORDER | 
            LVS_AUTOARRANGE |
            LVS_REPORT | 
            LVS_EDITLABELS |
            LVS_SHAREIMAGELISTS |
            WS_VISIBLE;
            
hwndListView = CreateWindowEx(   WS_EX_CLIENTEDGE,          // ex style
                                 WC_LISTVIEW,  // class name defined in commctrl.h
                                 NULL,                      // window text
                                 dwStyle,                   // style
                                 0,                         // x position
                                 0,                         // y position
                                 0,                         // width
                                 0,                         // height
                                 hwndParent,                // parent
                                 (HMENU)IDC_LISTVIEW,       // ID
                                 g_hInst,                   // instance
                                 NULL);                     // no extra data

if(!hwndListView)
   return NULL;

ResizeListView(hwndListView, hwndParent);

//set the large and small icon image lists
himlSmall = (HIMAGELIST)SHGetFileInfo( TEXT("C:\\"), 
                                       0,
                                       &amp;sfi, 
                                       sizeof(SHFILEINFO), 
                                       SHGFI_SYSICONINDEX | SHGFI_SMALLICON);

himlLarge = (HIMAGELIST)SHGetFileInfo( TEXT("C:\\"), 
                                       0,
                                       &amp;sfi, 
                                       sizeof(SHFILEINFO), 
                                       SHGFI_SYSICONINDEX | SHGFI_LARGEICON);

if (himlSmall &amp;&amp; himlLarge)
   {
   SendMessage(hwndListView, LVM_SETIMAGELIST, (WPARAM)LVSIL_SMALL,
               (LPARAM)himlSmall);
   SendMessage(hwndListView, LVM_SETIMAGELIST, (WPARAM)LVSIL_NORMAL,
               (LPARAM)himlLarge);
   }

return hwndListView;
}

/******************************************************************************

   ResizeListView

******************************************************************************/

void ResizeListView(HWND hwndListView, HWND hwndParent)
{
RECT  rc;

GetClientRect(hwndParent, &amp;rc);

MoveWindow( hwndListView, 
            rc.left,
            rc.top,
            rc.right - rc.left,
            rc.bottom - rc.top,
            TRUE);

}

/******************************************************************************

   InitListView

******************************************************************************/

BOOL InitListView(HWND hwndListView)
{
LV_COLUMN   lvColumn;
int         i;
TCHAR       szString[5][20] = {  TEXT("Image Number"), 
                                 TEXT("Left"), 
                                 TEXT("Top"), 
                                 TEXT("Right"), 
                                 TEXT("Bottom")};

//initialize the columns
lvColumn.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
lvColumn.fmt = LVCFMT_LEFT;
lvColumn.cx = 100;
for(i = 0; i &lt; 5; i++)
   {
   //make the secondary columns smaller
   if(i)
      lvColumn.cx = 50;

   lvColumn.pszText = szString[i];
   SendMessage(hwndListView, LVM_INSERTCOLUMN, (WPARAM)i, (LPARAM)&amp;lvColumn);
   }

InsertListViewItems(hwndListView);

return TRUE;
}

/******************************************************************************

   InsertListViewItems

******************************************************************************/

BOOL InsertListViewItems(HWND hwndListView)
{
LV_ITEM     lvItem;
int         i,
            nIndex,
            nImageCount;
TCHAR       szString[MAX_PATH];
HIMAGELIST  himl;
IMAGEINFO   ii;

SendMessage(hwndListView, WM_SETREDRAW, FALSE, 0);

//empty the list
SendMessage(hwndListView, LVM_DELETEALLITEMS, 0, 0);

//get the number of icons in the image list
himl = (HIMAGELIST)SendMessage(hwndListView, LVM_GETIMAGELIST,
                               (WPARAM)LVSIL_SMALL, 0);
nImageCount = ImageList_GetImageCount(himl);

for(i = 0; i &lt; nImageCount; i++)
   {
   wsprintf(szString, TEXT("Image #%d"), i);
   
   //fill in the LV_ITEM structure for the first item
   lvItem.mask = LVIF_TEXT | LVIF_IMAGE;
   lvItem.pszText = szString;
   lvItem.iImage = i;
   lvItem.iItem = SendMessage(hwndListView, LVM_GETITEMCOUNT, 0, 0);
   lvItem.iSubItem = 0;

   //add the item - get the index in case the ListView is sorted
   nIndex = SendMessage(hwndListView, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&amp;lvItem);

   //set the text and images for the sub-items
   ImageList_GetImageInfo(himl, i, &amp;ii);
   wsprintf(szString, TEXT("%d"), ii.rcImage.left);
   lvItem.iSubItem = 1;
   SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);

   wsprintf(szString, TEXT("%d"), ii.rcImage.top);
   lvItem.iSubItem = 2;
   SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);

   wsprintf(szString, TEXT("%d"), ii.rcImage.right);
   lvItem.iSubItem = 3;
   SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);

   wsprintf(szString, TEXT("%d"), ii.rcImage.bottom);
   lvItem.iSubItem = 4;
   SendMessage(hwndListView, LVM_SETITEM, 0, (LPARAM)&amp;lvItem);
   }

SendMessage(hwndListView, WM_SETREDRAW, TRUE, 0);
UpdateWindow(hwndListView);

return TRUE;
}

/**************************************************************************

   ListViewNotify()

**************************************************************************/

LRESULT ListViewNotify(HWND hWnd, LPARAM lParam)
{
LPNMHDR  lpnmh = (LPNMHDR) lParam;
HWND     hwndListView = GetDlgItem(hWnd, IDC_LISTVIEW);

switch(lpnmh-&gt;code)
   {
   case NM_CUSTOMDRAW:
      {
      LPNMLVCUSTOMDRAW  lplvcd = (LPNMLVCUSTOMDRAW)lParam;

      /*
      CDDS_PREPAINT is sent when the control is about to paint itself. You 
      implement custom draw by returning the proper value to this 
      notification.
      */
      if(lplvcd-&gt;nmcd.dwDrawStage == CDDS_PREPAINT)
         {
         if(g_bCustomDraw)
            {
            //tell the control we want pre-paint notifications for each item
            return CDRF_NOTIFYITEMDRAW;
            }
         //tell the control that we won't be doing any custom drawing
         return CDRF_DODEFAULT;
         }

      /*
      CDDS_ITEMPREPAINT is sent when the control is about to paint an item. 
      You will only get these if you returned CDRF_NOTIFYITEMDRAW in 
      response to CDDS_PREPAINT.
      */
      if(lplvcd-&gt;nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
         {
         LRESULT  lReturn = CDRF_DODEFAULT;
         /*
         For the ListView, the index of the item being drawn is stored in the 
         dwItemSpec member of the NMCUSTOMDRAW structure. In this example, only 
         the odd items will be drawn using the bold font.
         */
         if(lplvcd-&gt;nmcd.dwItemSpec &amp; 0x01)
            {
            HFONT    hFont;
            LOGFONT  lf;

            //get the existing font
            hFont = (HFONT)SendMessage(hwndListView, WM_GETFONT, 0, 0);

            //now get the font's information
            GetObject(hFont, sizeof(lf), &amp;lf);

            //make this font bold
            lf.lfWeight = FW_BOLD;

            //create the new font
            hFont = CreateFontIndirect(&amp;lf);

            /*
            To change the font, just select the desired font into the HDC 
            provided.
            */
            SelectObject(lplvcd-&gt;nmcd.hdc, hFont);

            /*
            To change the text and background colors in a ListView, set the 
            clrText and clrTextBk members of the NMLVCUSTOMDRAW structure to 
            the desired color. This is different than most other controls that 
            support custom draw. To change the text and background colors in 
            the others, you just call SetTextColor and SetBkColor on the HDC 
            provided. 
            */
            lplvcd-&gt;clrText = RGB(255, 0, 0);
            lplvcd-&gt;clrTextBk = RGB(255, 255, 255);

            /*
            If you change the font, return CDRF_NEWFONT so the control can 
            recalculate the extent of the text. Returning CDRF_NOTIFYPOSTPAINT 
            causes the control to send us notifications with CDDS_ITEMPOSTPAINT.
            */
            lReturn = CDRF_NEWFONT | CDRF_NOTIFYPOSTPAINT;
            }
         else
            {
            lplvcd-&gt;clrText = RGB(0, 0, 255);
            lplvcd-&gt;clrTextBk = RGB(255, 255, 255);
            }

         return lReturn;
         }

      if(lplvcd-&gt;nmcd.dwDrawStage == CDDS_ITEMPOSTPAINT)
         {
         HFONT hFont = GetStockObject(DEFAULT_GUI_FONT);

         //clean up stuff here
         hFont = SelectObject(lplvcd-&gt;nmcd.hdc, hFont);

         DeleteFont(hFont);
         
         return CDRF_DODEFAULT;
         }
      }
      return CDRF_DODEFAULT;
   
   }

return 0;
}

/**************************************************************************

   SwitchView()

**************************************************************************/

void SwitchView(HWND hwndListView, DWORD dwView)
{
DWORD dwStyle = GetWindowLong(hwndListView, GWL_STYLE);

SetWindowLong(hwndListView, GWL_STYLE, (dwStyle &amp; ~LVS_TYPEMASK) | dwView);
ResizeListView(hwndListView, GetParent(hwndListView));
}

/**************************************************************************

   AddExStyle()

**************************************************************************/

void AddExStyle(HWND hwndListView, DWORD dwNewStyle)
{
DWORD dwStyle = SendMessage(hwndListView, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
dwStyle |= dwNewStyle;
SendMessage(hwndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwStyle);
}

/**************************************************************************

   RemoveExStyle()

**************************************************************************/

void RemoveExStyle(HWND hwndListView, DWORD dwNewStyle)
{
DWORD dwStyle = SendMessage(hwndListView, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);
dwStyle &amp;= ~dwNewStyle;
SendMessage(hwndListView, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, dwStyle);
}

/**************************************************************************

   HandleCommand()

**************************************************************************/

LRESULT HandleCommand(  HWND hWnd, 
                        WPARAM wParam, 
                        LPARAM lParam)
{
switch (GET_WM_COMMAND_ID(wParam, lParam))
   {
   case IDM_LARGEICONS:
      SwitchView(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_ICON);
      break;
   
   case IDM_SMALLICONS:
      SwitchView(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_SMALLICON);
      break;
   
   case IDM_LIST:
      SwitchView(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_LIST);
      break;
   
   case IDM_REPORT:
      SwitchView(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_REPORT);
      break;
   
   case IDM_EXIT:
      DestroyWindow(hWnd);
      break;
   
   case IDM_ABOUT:
      DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUT), hWnd, AboutDlgProc);
      break;   

   case IDM_INDENT:
      {
      LV_ITEM  lvItem;
      int      i,
               nItemCount;

      ZeroMemory(&amp;lvItem, sizeof(lvItem));

      nItemCount = (int)SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_GETITEMCOUNT,
                                           0, 0);

      //run through the list, indenting the selected items
      for(i = 0; i &lt; nItemCount; i++)
         {
         lvItem.mask = LVIF_STATE | LVIF_INDENT;
         lvItem.iItem = i;
         lvItem.stateMask = LVIS_SELECTED;
         SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_GETITEM, 0, (LPARAM)&amp;lvItem);

         if(lvItem.state &amp; LVIS_SELECTED)
            {
            lvItem.mask = LVIF_INDENT;
            lvItem.iIndent++;
            SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_SETITEM, 0,
                               (LPARAM)&amp;lvItem);
            }
         }
      }
      break;
   
   case IDM_UNINDENT:
      {
      LV_ITEM  lvItem;
      int      i,
               nItemCount;

      ZeroMemory(&amp;lvItem, sizeof(lvItem));

      nItemCount = (int)SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_GETITEMCOUNT,
                                           0, 0);

      //run through the list, unindenting the selected items
      for(i = 0; i &lt; nItemCount; i++)
         {
         lvItem.mask = LVIF_STATE | LVIF_INDENT;
         lvItem.iItem = i;
         lvItem.stateMask = LVIS_SELECTED;
         SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_GETITEM, 0, (LPARAM)&amp;lvItem);

         if(lvItem.state &amp; LVIS_SELECTED)
            {
            lvItem.mask = LVIF_INDENT;
            if(lvItem.iIndent)
               {
               lvItem.iIndent--;
               SendDlgItemMessage(hWnd, IDC_LISTVIEW, LVM_SETITEM, 0,
                                  (LPARAM)&amp;lvItem);
               }
            }
         }
      }
      break;
   
   case IDM_CUSTOMDRAW:
      //toggle the custom draw flag
      g_bCustomDraw = !g_bCustomDraw;

      //force the control to redraw itself
      InvalidateRect(GetDlgItem(hWnd, IDC_LISTVIEW), NULL, TRUE);
      break;
   
   case IDM_CHECKBOXES:
      if(LVS_EX_CHECKBOXES &amp; 
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_CHECKBOXES);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_CHECKBOXES);
      break;

   case IDM_HOVERSELECT:
      if(LVS_EX_TRACKSELECT &amp; 
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_TRACKSELECT);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_TRACKSELECT);
      break;

   case IDM_GRIDLINES:
      if(LVS_EX_GRIDLINES &amp; 
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_GRIDLINES);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_GRIDLINES);
      break;

   case IDM_FULLROWSELECT:
      if(LVS_EX_FULLROWSELECT &amp;
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_FULLROWSELECT);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_FULLROWSELECT);
      break;

   case IDM_HEADERDRAGDROP:
      if(LVS_EX_HEADERDRAGDROP &amp;
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_HEADERDRAGDROP);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_HEADERDRAGDROP);
      break;

   case IDM_SUBITEMIMAGES:
      if(LVS_EX_SUBITEMIMAGES &amp; 
         (DWORD)SendDlgItemMessage(hWnd, IDC_LISTVIEW,
                                   LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0))
         RemoveExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_SUBITEMIMAGES);
      else
         AddExStyle(GetDlgItem(hWnd, IDC_LISTVIEW), LVS_EX_SUBITEMIMAGES);
      
      InvalidateRect(GetDlgItem(hWnd, IDC_LISTVIEW), NULL, TRUE);
      UpdateWindow(GetDlgItem(hWnd, IDC_LISTVIEW));
      break;

   }

return 0;
}

/**************************************************************************
   HandleContextMenu()
**************************************************************************/
BOOL HandleContextMenu( HWND hWnd, 
                        WPARAM wParam, 
                        LPARAM lParam)
{
HMENU hMenuLoad,
      hMenu;

if((HWND)wParam != GetDlgItem(hWnd, IDC_LISTVIEW))
   return FALSE;

hMenuLoad = LoadMenu(g_hInst, MAKEINTRESOURCE(IDM_CONTEXT_MENU));
hMenu = GetSubMenu(hMenuLoad, 0);

UpdateMenu(GetDlgItem(hWnd, IDC_LISTVIEW), hMenu);

TrackPopupMenu(   hMenu,
                  TPM_LEFTALIGN | TPM_RIGHTBUTTON,
                  LOWORD(lParam),
                  HIWORD(lParam),
                  0,
                  hWnd,
                  NULL);

DestroyMenu(hMenuLoad);

return TRUE;
}

/**************************************************************************

   UpdateMenu()

**************************************************************************/
void UpdateMenu(HWND hwndListView, HMENU hMenu)
{
UINT  uID;
DWORD dwStyle;

//uncheck all of these guys
CheckMenuItem(hMenu, IDM_LARGEICONS,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_SMALLICONS,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_LIST,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_REPORT,  MF_BYCOMMAND | MF_UNCHECKED);

CheckMenuItem(hMenu, IDM_CUSTOMDRAW,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_CHECKBOXES,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_HOVERSELECT,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_GRIDLINES,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_FULLROWSELECT,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_HEADERDRAGDROP,  MF_BYCOMMAND | MF_UNCHECKED);
CheckMenuItem(hMenu, IDM_SUBITEMIMAGES,  MF_BYCOMMAND | MF_UNCHECKED);

//check the appropriate view menu item
dwStyle = GetWindowLong(hwndListView, GWL_STYLE);
switch(dwStyle &amp; LVS_TYPEMASK)
   {
   case LVS_ICON:
      uID = IDM_LARGEICONS;
      break;
      
   case LVS_SMALLICON:
      uID = IDM_SMALLICONS;
      break;
      
   case LVS_LIST:
      uID = IDM_LIST;
      break;
   
   case LVS_REPORT:
      uID = IDM_REPORT;
      break;
   }
CheckMenuRadioItem(hMenu, IDM_LARGEICONS, IDM_REPORT, uID,  MF_BYCOMMAND |
                   MF_CHECKED);

//check the appropriate extended style items
dwStyle = (DWORD)SendMessage(hwndListView, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0);

//only update and enable grid lines, full row select, header drag drop, and 
//sub-item images items if in report view
if(uID == IDM_REPORT)
   {
   EnableMenuItem(hMenu, IDM_GRIDLINES, MF_BYCOMMAND | MF_ENABLED);
   EnableMenuItem(hMenu, IDM_FULLROWSELECT, MF_BYCOMMAND | MF_ENABLED);
   EnableMenuItem(hMenu, IDM_HEADERDRAGDROP, MF_BYCOMMAND | MF_ENABLED);
   EnableMenuItem(hMenu, IDM_SUBITEMIMAGES, MF_BYCOMMAND | MF_ENABLED);

   //can we indent or unindent?
   if(SendMessage(hwndListView, LVM_GETSELECTEDCOUNT, 0, 0))
      {
      EnableMenuItem(hMenu, IDM_INDENT, MF_BYCOMMAND | MF_ENABLED);
      EnableMenuItem(hMenu, IDM_UNINDENT, MF_BYCOMMAND | MF_ENABLED);
      }
   else
      {
      EnableMenuItem(hMenu, IDM_INDENT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
      EnableMenuItem(hMenu, IDM_UNINDENT, MF_BYCOMMAND | MF_DISABLED |
                     MF_GRAYED);
      }

   if(dwStyle &amp; LVS_EX_GRIDLINES)
      {
      CheckMenuItem(hMenu, IDM_GRIDLINES, MF_BYCOMMAND | MF_CHECKED);
      }

   if(dwStyle &amp; LVS_EX_FULLROWSELECT)
      {
      CheckMenuItem(hMenu, IDM_FULLROWSELECT, MF_BYCOMMAND | MF_CHECKED);
      }

   if(dwStyle &amp; LVS_EX_HEADERDRAGDROP)
      {
      CheckMenuItem(hMenu, IDM_HEADERDRAGDROP, MF_BYCOMMAND | MF_CHECKED);
      }

   if(dwStyle &amp; LVS_EX_SUBITEMIMAGES)
      {
      CheckMenuItem(hMenu, IDM_SUBITEMIMAGES, MF_BYCOMMAND | MF_CHECKED);
      }
   }
else
   {
   EnableMenuItem(hMenu, IDM_INDENT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
   EnableMenuItem(hMenu, IDM_UNINDENT, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
   EnableMenuItem(hMenu, IDM_GRIDLINES, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
   EnableMenuItem(hMenu, IDM_FULLROWSELECT, MF_BYCOMMAND | MF_DISABLED |
                  MF_GRAYED);
   EnableMenuItem(hMenu, IDM_HEADERDRAGDROP, MF_BYCOMMAND | MF_DISABLED |
                  MF_GRAYED);
   EnableMenuItem(hMenu, IDM_SUBITEMIMAGES, MF_BYCOMMAND | MF_DISABLED |
                  MF_GRAYED);
   }

//is custom drawing turned on?
if(g_bCustomDraw)
   {
   CheckMenuItem(hMenu, IDM_CUSTOMDRAW,  MF_BYCOMMAND | MF_CHECKED);
   }

//are checkboxes turned on?
if(dwStyle &amp; LVS_EX_CHECKBOXES)
   {
   CheckMenuItem(hMenu, IDM_CHECKBOXES,  MF_BYCOMMAND | MF_CHECKED);
   }

//is hover select turned on?
if(dwStyle &amp; LVS_EX_TRACKSELECT )
   {
   CheckMenuItem(hMenu, IDM_HOVERSELECT,  MF_BYCOMMAND | MF_CHECKED);
   }

}</PRE>
<P></P>
<P>During initialization, the ListView sample calls InitCommonControlsEx with dwICC of the INITCOMMONCONTROLSEX structure set to ICC_LISTVIEW_CLASSES, which initializes the ListView class. In the CreateListView function, CreateWindowEx creates the ListView. The small and large image lists are then obtained from the shell using the SHGetFileInfo API. The image lists are assigned to the ListView by sending the control the LVM_SETIMAGELIST function once for the small icons and once for the large icons. After the ListView is created, the sample calls InitListView, which sets up the column information. InitListView then calls InsertListViewItems, which clears any items already in the list and then inserts one item for each entry in the system image list.</P>
<P>When the user selects a different view from the menu, the application calls SwitchView with the desired view style. SwitchView uses GetWindowLong with GWL_STYLE to retrieve the current style settings. The view bits are then cleared and the new view-style bit is set via SetWindowLong. When the user selects Indent from the menu, the current indenting value for each selected item is retrieved with the LVM_GETITEM message. The indent value is then incremented and the new indent value is set with the LVM_SETITEM message. The same thing happens when Unindent is selected, except the indent value is decremented.</P>
<P>When the user selects an extended ListView style from the menu, the program checks to see if that style is already set. If not, the program calls AddExStyle to add that extended style. If the style is already set, the program calls RemoveExStyle to remove the extended style. AddExStyle retrieves the extended ListView style by sending the LVM_GETEXTENDEDLISTVIEWSTYLE message to the control. The new style is added to the style flags and then the new styles are set by sending the LVM_SETEXTENDEDLISTVIEWSTYLE message to the control.</P>
<P>All WM_NOTIFY messages are processed through the ListViewNotify function in my sample. When custom draw is enabled, ListViewNotify will return CDRF_NOTIFYITEMDRAW to NM_CUSTOMDRAW with dwDrawStage set to CDDS_PREPAINT. This causes the ListView to send NM_CUSTOMDRAW with dwDrawStage set to CDDS_ ITEMPREPAINT for each item that needs to be painted. When the CDDS_ITEMPREPAINT notification is received, the item index is checked. If the index is odd, then the function will create a bold version of the existing ListView font and select this font into the HDC provided in the NMLVCUSTOMDRAW structure. The text color for these items will be set to red and the text background color will be set to white. For those odd items, the return value is a combination of the CDRF_NEWFONT and CDRF_NOTIFYPOSTPAINT flags. Returning CDRF_NEWFONT tells the control that the font was changed, so it will recalculate the text extents. The CDRF_NOTIFYPOSTPAINT flag tells the control to notify you when it has completed painting this item. This notification will be sent with dwDrawStage equal to CDDS_ITEMPOSTPAINT. When you receive the CDDS_ITEMPOSTPAINT notification, you get the currently selected font and delete it. If the item index is even, then only the default font will be used, the text color will be set to blue, and the text background color will be set to white. This will cause all of the odd items to be drawn with a bold font with a red text color and a white background color. All of the even items will be drawn with the default font, with a blue text color and a white background color. When you run the sample, notice how the default selection colors override the colors you set during the custom draw cycle. Unfortunately, you are unable to alter the color of selected items unless you go full-blown ownerdraw.</P>
<H2><A NAME="sec4"></A>  Enhanced Header Control</H2><P>The Header control now has many enhancements. These include drag and drop manipulation, item ordering, hot tracking, image list support, callback items, and the ability to place text, bitmaps, and images in a header item.</P>
<P>To obtain drag and drop manipulation of the Header items, you only have to specify the HDS_DRAGDROP style bit when creating the control. When this style is specified, the user can rearrange the Header items by dragging and dropping them with the mouse. This works in conjunction with item ordering, which allows you to specify or retrieve the order of the Header items. </P>
<P>To obtain the item-ordering information, send the control an HDM_GETORDERARRAY message. This message takes a pointer to an array of integers as the lParam and the number of array elements pointed to by the lParam in the wParam. To allocate the array, you should obtain the number of items from the Header using the HDM_GETITEMCOUNT message and then allocate an array of <I>n</I> integers. After sending the message, the array will contain the order of the items in the Header control. The order of the items is given as shown from left to right. For example, if item two was the left item, item zero was the next item, and item one was on the right, the array would contain item two at index zero, item zero at index one, and item one at index two. </P>
<P>You can set the item ordering by sending the HDM_SETORDERARRAY message. This message takes the same parameters as the HDM_GETORDERARRAY message. Before sending the message, you place the item indexes in the array as you want them to appear from left to right.</P>
<P>To obtain hot tracking in a Header, you only have to add the HDS_HOTTRACK style bit to the window styles of the control when it is created. This causes the Header to highlight the item the mouse is hovering over.</P>
<P>To use an image list with the Header control, you first assign the image list. This is done by sending the HDM_SETIMAGELIST message to the control. The lParam for this message is the handle to the image list to be set for the control. You can get the handle to the image list by sending the control the HDM_GETIMAGELIST message. Returned from this message is the handle to the image list. The HDITEM structure, which replaces the HD_ITEM structure, includes two new int members, iImage and iOrder. iImage is used to specify an image index that will be displayed with the item. <B>Figure 7</B> shows details on the HDITEM structure.</P>
<P><B> Figure 7  HDITEM Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="167pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> UINT mask</P></TD><TD VALIGN="TOP"><P>Specifies which of the members contain valid information. Or, when retrieving information, which members are being requested. In addition to the mask values that are defined for the HD_ITEM structure, there are two new mask flags: HDI_IMAGE - The iImage member is valid and specifies the image to be displayed with the item. HDI_ORDER - The iOrder member is valid and specifies the order value for the item.</P></TD></TR><TR><TD VALIGN="TOP"><P> int cxy</P></TD><TD VALIGN="TOP"><P>Width or height of the item.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPTSTR pszText</P></TD><TD VALIGN="TOP"><P>Pointer to a zero-terminated string that specifies the text for the item. If this member is set to LPSTR_TEXTCALLBACK, the control will request text information for this item by using HDN_GETDISPINFO notification messages.</P></TD></TR><TR><TD VALIGN="TOP"><P> HBITMAP hbm</P></TD><TD VALIGN="TOP"><P>Handle to the bitmap that should be displayed with the item.</P></TD></TR><TR><TD VALIGN="TOP"><P> int cchTextMax</P></TD><TD VALIGN="TOP"><P>Length of the item text in characters.</P></TD></TR><TR><TD VALIGN="TOP"><P> int fmt</P></TD><TD VALIGN="TOP"><P>Set of bit flags that specify the item's format. These are the same as the format flags defined for the HD_ITEM structure.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPARAM lParam</P></TD><TD VALIGN="TOP"><P>32-bit application-defined value.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iImage</P></TD><TD VALIGN="TOP"><P>Zero-based index of an image within the image list. The specified image will be displayed with the header item, but does not take the place of the one specified in the hbm field. If iImage is set to I_IMAGECALLBACK, the control will request the image information for this item by using HDN_GETDISPINFO notification messages.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iOrder</P></TD><TD VALIGN="TOP"><P>Specifies the order in which the item appears within the header control, from left to right. That is, the value for the far left item is 0, the value for the next item to the right is 1, and so on.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>When adding items to a Header control, you can now specify that the text or image or both will be provided on a callback basis. When filling in the HDITEM structure, you can specify LPSTR_TEXTCALLBACK for the pszText member and I_IMAGECALLBACK for the iImage member. The control will then send HDN_GETDISPINFO notifications to request the display information. The lParam for this notification is a pointer to an NMHDDISPINFO structure (see <B>Figure 8</B>). </P>
<P><B> Figure 8  NMHDDISPINFO Stucture</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="279pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> NMHDR hdr</P></TD><TD VALIGN="TOP"><P>An NMHDR structure containing information about the notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iItem</P></TD><TD VALIGN="TOP"><P>The zero-based index of the item in the header control.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT mask</P></TD><TD VALIGN="TOP"><P>A set of bit flags specifying which members of the structure are being requested by the control. This value can be a combination of the following values:  </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>HDI_TEXT - The pszText member must be filled in.  </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>HDI_IMAGE - The iImage member must be filled in.  </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>HDI_LPARAM - The lParam member must be filled in. </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>HDI_DI_SETITEM - If you add this flag to the mask member before returning from the notification, this specifies that the header control should store the item information and not ask for it again.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPTSTR pszText</P></TD><TD VALIGN="TOP"><P>Pointer to a zero-terminated string that contains the text that will be displayed for the header item. When processing the notification, you should copy the string to this location, making sure not to copy more than cchTextMax characters into the buffer.</P></TD></TR><TR><TD VALIGN="TOP"><P> int cchTextMax</P></TD><TD VALIGN="TOP"><P>Size of the buffer pointed to by pszText.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iImage</P></TD><TD VALIGN="TOP"><P>Zero-based index of the image that should be displayed with the item.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPARAM lParam</P></TD><TD VALIGN="TOP"><P>32-bit application-defined data.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H2><A NAME="sec5"></A>  Progress Bar</H2><P>The Progress Bar now supports full 32-bit ranges. To set the 32-bit range, you send the Progress Bar a PBM_SETRANGE32 message. The wParam for this message is a DWORD that specifies the low end of the range and the lParam is a DWORD that specifies the high end. This message returns a DWORD value that contains the previous 16-bit low limit in the low word and the previous 16-bit high limit in the high word. If the previous ranges were 32-bit values, the return value consists of the low words of both 32-bit limits. To retrieve the entire high and low 32-bit range, use the PBM_GETRANGE message, which takes a BOOL as the wParam that specifies the return value of the message. If wParam is FALSE, then the message returns the 32-bit high range. If wParam is TRUE, the message returns the 32-bit low range. The lParam is a pointer to a PBRANGE structure that receives both 32-bit high and low-range values. The PBRANGE structure consists of two integers, iLow and iHigh. iLow designates the low end of the Progress Bar range and iHigh designates the high end. If you are only interested in the return value from this message, you can pass NULL for the lParam.</P>
<H2><A NAME="sec6"></A>  Tab Control</H2><P>The Tab control now allows you to place the tabs along any side of the control. The control also supports hot tracking by adding the TCS_HOTTRACK style bit to the window styles of the control when it is created. Hot tracking tabs highlight the tab the mouse cursor is hovering over.</P>
<P>By default, the tabs are placed along the top of the control. To place them on the bottom of the control, add the TCS_BOTTOM style bit when the control is created. To place the tabs on the left side of the control, add the TCS_VERTICAL style bit when the control is created. And if you want the tabs on the right, add both TCS_VERTICAL and TCS_RIGHT styles at create time.</P>
<P>The Tab control also has a new feature that causes the unused rows of tabs to be displayed on the opposite side of the control. This feature is obtained by adding the TCS_SCROLLOPPOSITE style bit when the control is created. <B>Figures 9</B> and <B>10</B> show how this style works.</P>
<P><img src="ie4_9.gif"></P>
<P><B> Figure 9  Regular Tabs</B></P>
<P><img src="ie4_10.gif"></P>
<P><B> Figure 10  New Tab Style</B></P>
<P>The TC_ITEM and TC_ITEMHEADER structures have been renamed to TCITEM and TCITEMHEADER to follow current naming conventions. To ensure backwards compatibility, the old structure names can still be used, but use TCITEM and TCITEMHEADER in your new projects.</P>
<H2><A NAME="sec7"></A>  TreeView</H2><P>Besides the support for custom draw explained in the previous article, only one enhancement has been made to the TreeView control: a TreeView parent item can now be partially expanded. This has the effect of expanding the item and displaying the children, but leaving the + symbol in the button next to the parent. This is accomplished by adding the TVIS_EXPANDPARTIAL item style to the parent item. To support partial expanding, the TVE_EXPANDPARTIAL action flag has been added for use with the TVM_EXPAND message. Specifying this flag will cause the item to be partially expanded. This is useful in situations where the items in a TreeView are being obtained from a source that could possibly encounter an error. For example, suppose that the items are being obtained from a database and an error occurs after only five items are obtained and added. The five items will be displayed, but the + symbol will still be displayed. This indicates to the user that more information is available. When the user clicks the + symbol again, you can attempt to perform the query again. You need to be careful here that you do not add duplicate items. You need to either clear the items belonging to this item or exclude the existing items from being duplicated.</P>
<H2><A NAME="sec8"></A>  Track Bar</H2><P>The Track Bar now supports up to two buddy windows and ToolTips. Track Bar buddy windows are sibling controls that the Track Bar will position for you. The Track Bar will automatically place the buddy windows centered around the control at the Track Bar's extents, but it will not make other modifications to these controls. </P>
<P>To set a buddy window, you send the Track Bar the TBM_SETBUDDY message. The wParam for this message is a BOOL indicating where to position the buddy window. If this value is FALSE, then the buddy window will be positioned to the right of the Track Bar if the Track Bar control uses the TBS_HORZ style. If the Track Bar uses the TBS_VERT style, the buddy will be positioned below the Track Bar control. If this value is TRUE, then the buddy window will be positioned to the left of the Track Bar if the Track Bar control uses the TBS_HORZ style. If the Track Bar uses the TBS_VERT style, the buddy will be positioned below the Track Bar control. </P>
<P>The lParam for this message is the window handle of the buddy window. To retrieve a buddy window handle, you send the Track Bar a TBM_GETBUDDY message. The wParam for this message is the same as that for the TBM_SETBUDDY message. The return value is the window handle of the desired buddy window. The message will return NULL if no buddy window has been set at the selected location.</P>
<P>To implement ToolTips in the Track Bar, add the TBS_TOOLTIPS style bit when creating the control. Alternatively, you can create your own ToolTip and assign it to the Track Bar by sending the Track Bar the TBM_SETTOOLTIPS message. This message takes the window handle of the ToolTip control as the wParam. To retrieve the ToolTip handle, send the Track Bar a TBM_GETTOOLTIPS message. This message returns the handle to the ToolTip control. By default, the ToolTip will display the current position of the Track Bar.</P>
<H2><A NAME="sec9"></A>  ToolBar</H2><P>The ToolBar has two new styles that provide different methods of displaying the ToolBars: TBSTYLE_FLAT and TBSTYLE_LIST. <B>Figure 11</B> shows a ToolBar with the TBSTYLE_FLAT style. <B>Figure 12</B> shows a ToolBar with the TBSTYLE_LIST style. The TBSTYLE_FLAT style also makes the ToolBar transparent, which causes the ToolBar buttons to be displayed on the client area of the window underneath the ToolBar. The ToolBar also supports hot tracking by default.</P>
<P><img src="ie4_11.gif"></P>
<P><B> Figure 11  ToolBar with TBSTYLE_FLAT</B></P>
<P><img src="ie4_12.gif"></P>
<P><B> Figure 12  ToolBar with TBSTYLE_LIST</B></P>
<P>A ToolBar's style can now be changed dynamically by sending the ToolBar a TB_SETSTYLE message. This message takes the new ToolBar style flags for the lParam. The return value from this message is not used. To retrieve the ToolBar styles, you can send the ToolBar a TB_ GETSTYLE message. This message returns the current ToolBar styles.</P>
<P>You can easily obtain the rectangle of a ToolBar item by sending the ToolBar a TB_GETRECT message. The wParam for this message is the item identifier, and the lParam is a pointer to a RECT structure. This message returns a Boolean value indicating the success or failure of the message.</P>
<P>The ToolBar now supports the use of image lists. There are three image lists that the ToolBar can use. The first is for displaying normal or default images on the ToolBar. This image list is set using the TB_SETIMAGELIST message. This message takes the HIMAGELIST of the new default image list as the lParam and returns the HIMAGELIST of the previous default image list or NULL if no previous image list was set. The default image list can be retrieved using the TB_GETIMAGELIST message. This message returns the HIMAGELIST of the current default image list, or NULL if no default image list is set. </P>
<P>The second image list is for displaying disabled images on the ToolBar. This image list is set using the TB_SETDISABLEDIMAGELIST message. This message takes the HIMAGELIST of the new disabled image list as the lParam and returns the HIMAGELIST of the previous disabled image list, or NULL if no previous image list was set. The disabled image list can be retrieved using the TB_GETDISABLEDIMAGELIST message. This message returns the HIMAGELIST of the current disabled image list or NULL if no disabled image list is set. </P>
<P>The third image list is for displaying hot-tracking images when the mouse cursor is over a ToolBar item or when the mouse button is pressed on a ToolBar item. This image list is set using the TB_SETHOIMAGELIST message. This message takes the HIMAGELIST of the new hot-tracking image list as the lParam and returns the HIMAGELIST of the previous hot-tracking image list or NULL if no previous image list was set. The hot-tracking image list can be retrieved through the TB_GETHOTIMAGELIST message. This message returns the HIMAGELIST of the current hot-tracking image list or NULL if no hot-tracking image list is set.</P>
<P>There is a new set of system-defined images that can be used with the ToolBar. These are IDB_HIST_SMALL_ COLOR and IDB_HIST_SMALL_COLOR. These image sets can be used exactly like the other system-defined image sets. See the TBADDBITMAP structure definition in the Win32 SDK documentation for details on how to use these image sets. The history image sets contain the following images: HIST_BACK, HIST_FORWARD, HIST_ FAVORITES, HIST_ADDTOFAVORITES, and HIST_VIEWTREE.</P>
<P>The TB_LOADIMAGES message was added to allow the programmer to load a bitmap into the ToolBar's image list. This message takes a bitmap resource identifier as the wParam and the HINSTANCE of the module that contains the bitmap resource for the lParam. The ToolBar's default image list must already have been set using the TB_SETIMAGELIST message for the TB_LOADIMAGES to have any effect. The system-defined image sets can also be used with this message by passing the image set constant (IDB_<I>XXX</I>) as the wParam and HINST_COMMCTRL as the lParam.</P>
<P>The ToolBar makes implementation of drop-down ToolBar buttons easier. To gain this effect, simply add the TBSTYLE_DROPDOWN style bit to the button's style. When you do this, a combo box-like drop-down arrow will be drawn next to the button and, when the button is pressed, the parent window will receive a WM_NOTIFY message with the code equal to TBN_DROPDOWN. During this notification, you can send the ToolBar the TB_GETRECT message to determine where to place the menu and then call TrackPopupMenu to display the menu.</P>
<P>The updated ToolBar supports extended item features. You now have more control over the size of the ToolBar items. You can set the minimum and maximum button widths by sending the ToolBar the TB_SETBUTTONWIDTH message. This message takes a DWORD value as the lParam, where the low WORD of the lParam indicates the minimum width of the buttons and the high WORD indicates the maximum width of the buttons. The current size of the ToolBar buttons can be obtained by sending the ToolBar a TB_GETBUTTONSIZE message. This message takes no parameters and returns a DWORD, where the low WORD contains the width of each ToolBar button and the high WORD contains the height of each ToolBar button.</P>
<P>ToolBar item text can now be wrapped and you can control the number of lines that will be displayed by sendingtheTB_SETMAX-TEXTROWS message. This message takes an integer as the wParam, which indicates the maximum number of text rows that can be displayed. To retrieve the number of text rows currently being displayed, send the ToolBar a TB_GETTEXTROWS message. This message returns an integer that contains the number of text rows currently displayed. If an item's text will not fit into the width provided in the TB_SETBUTTONWIDTH message and the maximum number of text rows is one, then the text will be displayed truncated with an ellipsis (...).</P>
<P>The starting point for all of the buttons can now be adjusted by sending the ToolBar a TB_SETINDENT message. This message takes the indent value as the wParam. The indent is the number of pixels that the first button will be indented.</P>
<H2><A NAME="sec10"></A>  ToolTip</H2><P>The ToolTip now allows the tip to track along with the mouse while the mouse is moving instead of just remaining in the same place. This is accomplished with a combination of the TTM_TRACKACTIVATE and TTM_TRACKPOSITION messages. The TTM_TRACKACTIVATE message takes a Boolean value that indicates if the tracking is being activated as the wParam and a pointer to a TOOLINFO structure as the lParam. If wParam is zero, then tracking for this tool is being disabled. If wParam is nonzero, then tracking for this tool is being enabled. The cbSize, hwnd, and uId members of the TOOLINFO must be filled out before sending the message. The ToolTip uses the hwnd and uId members to determine which tool is affected by this message. </P>
<P>To implement tracking ToolTips, you need to use the TTM_TRACKPOSITION message instead of TTM_RELAYEVENT to pass mouse messages to the ToolTip. The TTM_TRACKPOSITION message takes a DWORD that contains the <I>x</I> and <I>y</I> position, in screen coordinates, where the tracking ToolTip will be displayed as the lParam. The low word contains the <I>x</I> coordinate and the high word contains the <I>y</I> coordinate. ToolTip tracking is not supported for windows that the ToolTip subclasses. If you want to allow tracking for other windows, then you will have to subclass the windows yourself and send the TTM_ TRACKPOSITION messages when appropriate.</P>
<P>You now have more control over the appearance of the text within the ToolTip than ever before. In addition to being able to perform the custom draw techniques outlined in Part I of this article, you can set the margins used in the ToolTip, specify the maximum width of the ToolTip control, set the text color, and set the background color. </P>
<P>To set the margins, you send the ToolTip a TTM_SETMARGIN message. This message takes a pointer to a RECT structure that specifies the new margins as the lParam. The left member of the RECT structure specifies the distance between the left edge of the ToolTip window and the left edge of the text. The top member of the RECT structure specifies the distance between the top edge of the ToolTip window and the top edge of the text. The right member of the RECT structure specifies the distance between the right edge of the ToolTip window and the right edge of the text. The bottom member of the RECT structure specifies the distance between the bottom edge of the ToolTip window and the bottom edge of the text. All of these values are in pixels. To retrieve the current margins, you send the ToolTip a TTM_GETMARGIN message. This message takes a pointer to a RECT structure as the lParam. This RECT structure will contain the current margins after the message is sent.</P>
<P>The maximum width of the ToolTip is specified by sending the TTM_SETMAXTIPWIDTH message to the ToolTip. This message takes an integer that specifies the new maximum width of the ToolTip control as the lParam. If the length of the text exceeds this value, the text will be wrapped and left-justified to fit within the ToolTip. If the length of a single word is longer than the width of the ToolTip, then the ToolTip will be expanded to fit the widest word. The maximum width value is not changed, however. To obtain the current maximum width, you should send the ToolTip a TTM_GETMAXTIPWIDTH message. This message returns an integer value that indicates the maximum width setting.</P>
<P>To set the text and background colors displayed in a ToolTip, you send the control TTM_SETTIPTEXTCOLOR and TTM_SETTIPBKCOLOR messages. Both of these messages take a COLORREF that specifies the new color as the wParam. To obtain these colors, use the TTM_GETTIPTEXTCOLOR and TTM_GETTIPBKCOLOR messages. Both of these messages return a COLORREF that specifies the currently set color.</P>
<P>In Windows 95, you can set the ToolTip delay time by sending the ToolTip a TTM_SETDELAYTIME message. What was conspicuously missing was a message to retrieve the delay time. That has now been remedied with the addition of the TTM_GETDELAYTIME message. This message takes a constant identifier, which specifies which delay time is being requested for the wParam. It returns an integer value that indicates the requested delay time in milliseconds. The requested delay time can be TTDT_AUTOPOP, TTDT_INITIAL, or TTDT_RESHOW. These are the same flags, and have the same meaning, as those specified in the TTM_SETDELAYTIME topic in the Win32 SDK documentation.</P>
<P>The TTM_POP message has also been added to cause the ToolTip to no longer be displayed. This message takes no parameters. The ToolTip receiving the message will be the one that is no longer displayed. This message does not permanently disable the ToolTip, but is only in effect until the next time a ToolTip will be displayed. This message is useful in cases where you want the ToolTip to disappear at a time that it would not normally do so. As an example, if you wanted your application to control how long a ToolTip is displayed, you would send the ToolTip the TTM_POP message when you no longer wanted the ToolTip to be displayed.</P>
<H2><A NAME="sec11"></A>  Conclusion</H2><P>The common controls DLL was originally written to satisfy the needs of the Windows¨ 95 shell and not much more. Over the past year, lots of feedback on the controls have resulted in significant improvements to this DLL. Since many new applications from Microsoft are using these widgets, the natural evolution of the common controls DLL also follows along.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P><I>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</I></P>
<P></P></font></body></HTML>
