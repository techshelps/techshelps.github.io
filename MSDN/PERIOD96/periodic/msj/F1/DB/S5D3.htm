<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Previewing the New and Improved Common Controls DLL for Microsoft IE 4.0</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Previewing the New and Improved Common Controls DLL for Microsoft IE 4.0</H1><P>Strohm Armstrong</P>
<P>Strohm Armstrong is a support engineer at Microsoft specializing in user and shell technologies.</P>
<P>Microsoft¨ Internet Explorer 4.0 (codenamed Nashville; I'll call it IE 4.0 here) introduces three new common controls as well as enhancements to many  existing common controls. Many of the common controls now support a new technology called custom draw that allows you to customize the painting of a control without having to implement full-blown owner-draw. The three new controls are an extended ComboBox that provides image list support and indenting, a date and time selection control, and a tool container control (currently called a CoolBar) that lets you customize the layout of different groups of tools. The ListView control now has a method for allowing millions of items to be displayed in it almost instantly, as well as many new features for displaying items in report mode. The Tab control now allows the tabs to be displayed along the sides and bottom of the control, as well as along the top. The list goes on and on. In this article, I'll cover custom draw and the new controls. Next month I will cover the enhancements made to the existing common controls.</P>
<P>The sample code included here was built using Microsoft Developer Studio 4.1 with COMMCTRL.H and COMCTL32.LIB from the ActiveX SDK. The ActiveX SDK can be downloaded from http://www.microsoft.com. To run the samples, you will need to have the COMCTL32.DLL that ships with Microsoft Internet Explorer 3.0, beta 2 or greater, installed on your system. (<I>Confused? Here</I><I>'</I><I>s the skinny: even though these new common controls are not officially released and distributable, they are included with IE 3.0. For now, you have to install IE 3.0 to get them</I><I>—</I><I>Ed.</I>) Internet Explorer is also available free to download from Microsoft's Web site.</P>
<P>Because these controls are still under development, any detail is subject to change when the final product is released. This can include the addition/deletion of messages and styles, as well as modification to the structures.</P>
<P> </P>
<H2><A NAME="sec0"></A>  The Basics</H2><P>To make an application more efficient, and to support the new common controls, the InitCommonControlsEx function was added. To avoid having to register all of the common control classes, this function allows you to register only the classes your application will use. This function takes a pointer to an INITCOMMONCONTROLSEX structure, which needs to be filled in before the function is called. The dwSize member receives the size of the INITCOMMONCONTROLSEX structure. The dwICC member receives one or more flags that specify the controls your application needs to register (see <B>Figure 1</B>).</P>
<P><B> Figure 1  INITCOMMONCONTROLSEX dwICC Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_LISTVIEW_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the ListView and Header controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_TREEVIEW_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the TreeView and ToolTip controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_BAR_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the Toolbar, StatusBar, TrackBar, and ToolTip controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_TAB_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the Tab and ToolTip controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_UPDOWN_CLASS</P></TD><TD VALIGN="TOP"><P>Initializes the UpDown control.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_PROGRESS_CLASS</P></TD><TD VALIGN="TOP"><P>Initializes the Progress Bar control.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_HOTKEY_CLASS</P></TD><TD VALIGN="TOP"><P>Initializes the Hot Key control.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_ANIMATE_CLASS</P></TD><TD VALIGN="TOP"><P>Initializes the Animation control.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_WIN95_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the Animation, Header, HotKey, ListView, ProgressBar, StatusBar, Tab, ToolTip, ToolBar, TrackBar, TreeView, and UpDown controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_DATE_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the Date and Time Picker controls.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_USEREX_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the ComboBoxEx control.</P></TD></TR><TR><TD VALIGN="TOP"><P> ICC_COOL_CLASSES</P></TD><TD VALIGN="TOP"><P>Initializes the CoolBar control.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The InitCommonControls API can still be called to initialize the Windows¨ 95 common controls. If you're starting a new project, use the InitCommonControlsEx API.</P>
<P>Most common controls now support a new technology called hot tracking. With hot tracking, an item is displayed as being selected when the mouse cursor hovers over the item for about a second. This occurs without pressing any mouse buttons.</P>
<H2><A NAME="sec1"></A>  Custom Draw</H2><P>Have you ever wanted to be able to change the way some or all of the items in a common control are drawn? Maybe having some items drawn using a bold font or with a different color? IE 4.0 introduces a new method to control the drawing of items in certain controls called custom draw. The ListView, TreeView, ToolTip, Header, TrackBar, ToolBar, and CoolBar all support custom draw. </P>
<P>Custom draw starts with the control sending its owner an NM_CUSTOMDRAW notification with a pointer to an NMCUSTOMDRAW structure (see <B>Figure 2</B>). This message is sent via the WM_NOTIFY message. One of the members of this structure is dwDrawStage, a set of flags that indicates what stage in the drawing cycle the control is currently about to perform. <B>Figure 3</B> lists all of the drawing stages and when they are sent.</P>
<P><B> Figure 2  NMCUSTOMDRAW Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> NMHDR hdr</P></TD><TD VALIGN="TOP"><P>Standard NMHDR structure for all notification messages.</P></TD></TR><TR><TD VALIGN="TOP"><P> DWORD dwDrawStage</P></TD><TD VALIGN="TOP"><P>Specifies the current drawing stage.</P></TD></TR><TR><TD VALIGN="TOP"><P> HDC hdc</P></TD><TD VALIGN="TOP"><P>The HDC of the control. Use this HDC to perform any GDI functions.</P></TD></TR><TR><TD VALIGN="TOP"><P> RECT rc</P></TD><TD VALIGN="TOP"><P>The rectangle to be drawn in.</P></TD></TR><TR><TD VALIGN="TOP"><P> DWORD dwItemSpec</P></TD><TD VALIGN="TOP"><P>This is control-specific, but it's how to specify an item. Valid only when the CDDS_ITEM bit is set in dwDrawStage.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPARAM lItemlParam</P></TD><TD VALIGN="TOP"><P>The lParam of the item.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 3  Custom Draw Drawing Stages</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="171pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_PREPAINT</P></TD><TD VALIGN="TOP"><P>Received before any part of the control is about to be drawn.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_POSTPAINT</P></TD><TD VALIGN="TOP"><P>Received after the control has completed the painting cycle.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_PREERASE</P></TD><TD VALIGN="TOP"><P>Received before the control starts the erasing cycle. Currently only supported by the ToolBar control.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_POSTERASE</P></TD><TD VALIGN="TOP"><P>Received after the control completes the erasing cycle. Currently only supported by the ToolBar control.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_ITEMPREPAINT</P></TD><TD VALIGN="TOP"><P>Received before the item is drawn.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_ITEMPOSTPAINT</P></TD><TD VALIGN="TOP"><P>Received after the item has been drawn. </P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_ITEMPREERASE</P></TD><TD VALIGN="TOP"><P>Received when the item is about to be erased. Currently only supported by the ToolBar control.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDDS_ITEMPOSTERASE</P></TD><TD VALIGN="TOP"><P>Received after the item has been erased. Currently only supported by the ToolBar control.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>The drawing cycle begins when the control processes its WM_PAINT message. At the beginning of the drawing cycle, the control will send the NMCUSTOMDRAW notification with dwDrawStage set to CDDS_PREPAINT. You always get the CDDS_PREPAINT notification first. Other than the fact the CDDS_PRE<I>XXX</I> messages always come before CDDS_POST<I>XXX</I> messages, do not make any other assumptions about the order of these custom draw messages. If the owner returns CDRF_DODEFAULT (zero) to this notification, then custom draw is disabled for that drawing cycle and no more notifications will be sent until the next drawing cycle. If a nonzero value is returned, the control will send additional notifications. <B>Figure 4</B> outlines the valid return values and the results of each value.</P>
<P><B> Figure 4  Custom Draw Return Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="171pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Return Value</B></P></TD><TD VALIGN="TOP"><P><B>Response</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_DODEFAULT</P></TD><TD VALIGN="TOP"><P>Causes the control to use its default painting. If returned from CDDS_PREPAINT, no other custom draw messages will be sent.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_NOTIFYPOSTPAINT</P></TD><TD VALIGN="TOP"><P>Causes the control to send the NM_CUSTOMDRAW notification with dwDrawStage equal to CDDS_POSTPAINT after the control has been painted. If returning this value in response to CDDS_ITEMPREPAINT, you will receive the CDDS_ITEMPOSTPAINT notification.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_NOTIFYPOSTERASE</P></TD><TD VALIGN="TOP"><P>Causes the control to send the NM_CUSTOMDRAW notification with dwDrawStage equal to CDDS_POSTERASE after the control has been erased.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_NOTIFYITEMDRAW</P></TD><TD VALIGN="TOP"><P>Causes the control to send the NM_CUSTOMDRAW notification with dwDrawStage equal to CDDS_ITEMPREPAINT when an item is about to be drawn and dwDrawStage equal to CDDS_ITEMPOSTPAINT after the item is drawn.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_NOTIFYITEMERASE</P></TD><TD VALIGN="TOP"><P>Causes the control to send the NM_CUSTOMDRAW notification with dwDrawStage equal to CDDS_ITEMPREERASE when an item is about to be erased and dwDrawStage equal to CDDS_ITEMPOSTERASE after the control is erased.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_NEWFONT</P></TD><TD VALIGN="TOP"><P>Use this return value when you change the font while processing the CDDS_ITEMPREPAINT notification. This tells the control to recalculate text extents based on the new font.</P></TD></TR><TR><TD VALIGN="TOP"><P> CDRF_SKIPDEFAULT</P></TD><TD VALIGN="TOP"><P>Use this return value to tell the control not to do any drawing for this notification. This is normally used when you are doing all of the drawing yourself.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Let's say that you want to draw a particular item in a TreeView with a different font and in a different text color. When adding the items to the TreeView, you will need to provide enough information in each item's lParam to determine how the item should be drawn. After returning CDRF_NOTIFYITEMDRAW to the CDDS_PREPAINT notification, you will receive a separate NM_CUSTOMDRAW notification with dwDrawStage set to CDDS_ITEMPREPAINT for each item being drawn. When processing the CDDS_ITEMPREPAINT notification, you will check the item's lParam and determine if the item needs to be drawn differently. If it does need to be displayed differently, then you change the font by selecting the desired HFONT into the hdc member of the NMCUSTOMDRAW structure. Any time you change the font, your return value will need to have the CDRF_NEWFONT bit set. This causes the control to recalculate the extent of the text to be displayed based on the font now selected into the hdc. To change the text color, simply call SetTextColor using the hdc member of the NMCUSTOMDRAW structure. Similarly, to change the background color, call SetBkColor using the same hdc. Since changing the colors does not require the control to recalculate anything, any return value is acceptable. You cannot, however, override the colors for selected items. These will always be displayed using the user-selected settings.</P>
<P>If you want to perform all of the drawing for some or all of the items, perform the drawing when you receive the CDDS_ITEMPREPAINT notification. You then return CDRF_SKIPDEFAULT to tell the control not to perform any painting for this item. Since returning CDRF_SKIPDEFAULT causes no portion of the item to be drawn, you will also be required to draw the images for the items.</P>
<P>Custom draw has two special cases. The first is implementing custom draw in a ListView. Instead of the lParam of the WM_NOTIFY message pointing to an NMCUSTOMDRAW structure, it points to an NMLVCUSTOMDRAW structure (see <B>Figure 5</B>). The only difference here is that, for the ListView, you place the desired text and text background colors in the clrText and clrTextBk members of the NMLVCUSTOMDRAW structure instead of calling SetTextColor and SetBkColor.</P>
<P><B> Figure 5  NMLVCUSTOMDRAW Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="180pt" VALIGN="TOP"><COL WIDTH="261pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> NMCUSTOMDRAW nmcd</P></TD><TD VALIGN="TOP"><P>Standard custom draw notification structure.</P></TD></TR><TR><TD VALIGN="TOP"><P> COLORREF clrText</P></TD><TD VALIGN="TOP"><P>Receives the desired text color during the CDDS_ITEMPREPAINT notification. Do not change this value if the default text color is desired.</P></TD></TR><TR><TD VALIGN="TOP"><P> COLORREF clrTextBk</P></TD><TD VALIGN="TOP"><P>Receives the desired text background color during the CDDS_ITEMPREPAINT notification. Do not change this value if the default text background color is desired.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The second special case regards ToolTips. When the ToolTip sends the NM_CUSTOMDRAW notification, the lParam points to an NMTTCUSTOMDRAW structure (see <B>Figure 6</B>). This structure consists of an NMCUSTOMDRAW structure (nmcd) and a UINT that specifies drawing flags for the ToolTip (uDrawFlags). These drawing flags are the same drawing flags that can be passed to the DrawText API. Also, a ToolTip only uses the CDDS_PREPAINT drawing stage. The ToolTip will send the NM_CUSTOMDRAW notification twice. The first time will be to obtain the rectangle that the ToolTip should use. This notification is identified by the fact that the DT_CALCRECT bit is set in uDrawFlags. It is in this notification only that any adjustments to the rectangle should be made. The ToolTip will call DrawText with the value in uDrawFlags to calculate the desired rectangle. You should make any desired modifications to uDrawFlags at this time, but always make sure that the DT_CALCRECT bit is set. The second notification will not have DT_CALCRECT set. This is when the control is about to paint itself. You should not make any modifications to the rectangle now, but you should make all other modifications at this time, including changes to the HDC. Also, make sure that you place the exact same flags in uDrawFlags, except for the DT_CALCRECT flag. <B>Figure 7</B> shows a very basic example of processing NM_CUSTOMDRAW for a ToolTip. This example causes the ToolTip text to be wrapped so that one word is on each line (by specifying a one-pixel wide rectangle for DrawText) and the text will be centered in the rectangle.</P>
<P><B> Figure 6  NMTTCUSTOMDRAW Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> NMCUSTOMDRAW nmcd</P></TD><TD VALIGN="TOP"><P>Standard custom draw notification structure.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT uDrawFlags</P></TD><TD VALIGN="TOP"><P>DrawText flags.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 7  Implementing Custom Draw ToolTIps</B></P>
<P><BR></P>
<PRE> case NM_CUSTOMDRAW:
   {
   LPNMTTCUSTOMDRAW  lpttcd = (LPNMTTCUSTOMDRAW)lParam;

   if(lpttcd-&gt;nmcd.dwDrawStage == CDDS_PREPAINT)
      {
      UINT  uDrawFlags =   DT_WORDBREAK | DT_CENTER;

      /*
      If the DT_CALCRECT bit is set, then the ToolTip is asking us to 
      adjust the DrawText bits. After returning from this notification, 
      it will call DrawText with DT_CALCRECT to calculate the rectangle. 
      
      What this allows you to do is specify a maximum width for a 
      ToolTip. If the text is too big, then the ToolTip will wrap the 
      text for you.
      
      In this case, we just make the rectangle really small so that 
      DrawText will take into account the word wrapping. Make sure to 
      keep the DT_CALCRECT flag.
      */
      if(lpttcd-&gt;uDrawFlags &amp; DT_CALCRECT)
         {
         lpttcd-&gt;uDrawFlags = uDrawFlags | DT_CALCRECT;
                              
         /*
         We set these to 1 because, in this case, the ToolTip will be 
         asking DrawText to calculate the rectangle for us.
         */
         lpttcd-&gt;nmcd.rc.right = 1;
         lpttcd-&gt;nmcd.rc.bottom = 1;
         }
      else
         {
         /*
         Don't change the rectangle here. It was adjusted when 
         DT_CALCRECT was set.
         */
         lpttcd-&gt;uDrawFlags = uDrawFlags;
         }

      return CDRF_DODEFAULT;
      }
   }
   return CDRF_DODEFAULT;</PRE>
<P></P>
<P> </P>
<H2><A NAME="sec2"></A>  CoolBar</H2><P>The CoolBar is a new tool container control that can contain sets of tools in what are called bands. The bands can be arranged so that they take up an entire row or share a row. <B>Figure 8</B> shows a CoolBar that contains two bands, each in its own row. The top band contains an image from an image list, the text "ComboBox," and a ComboBox; the second band contains the text "Button" and a push button. Bands can also be on the same row, as shown in <B>Figure 9</B>. </P>
<P><img src="msie4_8.gif"></P>
<P><B> Figure 8  CoolBar in action: multiple bands in multiple rows.</B></P>
<P><img src="msie4_9.gif"></P>
<P><B> Figure 9  CoolBar in action: multiple bands in one row.</B></P>
<P>Before creating a CoolBar, you must call InitCommonControlsEx with ICC_<BR>COOL_CLASSES set in dwICC of the INITCOMMONCONTROLSEX structure. The CoolBar is created with the CreateWindow or CreateWindowEx function using REBARCLASSNAME as the class name. <B>Figure 10</B> details the CoolBar styles. The CoolBar also supports the standard common control styles (CCS_<I>XXX</I>).</P>
<P><B> Figure 10  CoolBar Styles</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Style Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> RBS_VARHEIGHT</P></TD><TD VALIGN="TOP"><P>With this style, each row may be a different height. Without this style, each row will be the height of the tallest band.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBS_BANDBORDERS</P></TD><TD VALIGN="TOP"><P>The control places a border around each band, which separates it from adjacent bands.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBS_FIXEDORDER</P></TD><TD VALIGN="TOP"><P>Prevents the user from re-ordering the bands. Without this style, the user can place any band in front of or on top of any other band. With this style, the user can only resize bands that are in the same row or place bands under each other in the same order that they are inserted.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Once you create the CoolBar control, you initialize the CoolBar by sending the RB_SETBARINFO message. This message takes a pointer to a REBARINFO structure as the lParam. The wParam is not used. <B>Figure 11</B> describes the REBARINFO structure. RB_SETBARINFO sets the image list that will be used by the CoolBar. If you do not wish to use an image list in your CoolBar, you don't need to send this message.</P>
<P><B> Figure 11  REBARINFO Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cbSize</P></TD><TD VALIGN="TOP"><P>The size of the REBARINFO structure, in bytes.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT fMask</P></TD><TD VALIGN="TOP"><P>Specifies which of the members contain valid information. At present, only the RBIM_IMAGELIST flag is used.</P></TD></TR><TR><TD VALIGN="TOP"><P> HIMAGELIST himl</P></TD><TD VALIGN="TOP"><P>An image list handle that the CoolBar will use to obtain images.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>You add bands to the CoolBar by sending it the RB_INSERTBAND message. This message takes an index number as the wParam and a pointer to a REBARBANDINFO structure (see <B>Figure 12</B>) as the lParam. The index number is the index at which you wish to have the band inserted. If the index number is higher than the number of bands already in the CoolBar, the band will be added at the end of the list. To ensure you are adding a band to the end of the list, pass (UINT)-1 as the band index. </P>
<P><B> Figure 12  REBARBANDINFO Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cbSize</P></TD><TD VALIGN="TOP"><P>The size of the REBARBANDINFO structure, in bytes.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT fMask</P></TD><TD VALIGN="TOP"><P>Specifies which of the members contain valid information. </P></TD></TR><TR><TD VALIGN="TOP"><P> UINT fStyle</P></TD><TD VALIGN="TOP"><P>One or more flags that indicate which members contain valid information or which members are being requested.</P></TD></TR><TR><TD VALIGN="TOP"><P> COLORREF clrFore</P></TD><TD VALIGN="TOP"><P>Specifies the foreground (text) color of the band.</P></TD></TR><TR><TD VALIGN="TOP"><P> COLORREF clrBack</P></TD><TD VALIGN="TOP"><P>Specifies the background color of the band.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPTSTR lpText</P></TD><TD VALIGN="TOP"><P>A pointer to a buffer that contains the display text for the band. If band information is being requested from the control, then this member needs to be initialized to point to a character buffer before sending the message.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cch</P></TD><TD VALIGN="TOP"><P>The size of the buffer pointed to by lpText. This member is only used when information is being requested from the control.</P></TD></TR><TR><TD VALIGN="TOP"><P> INT iImage</P></TD><TD VALIGN="TOP"><P>Zero-based index of the image that should be displayed in the band.</P></TD></TR><TR><TD VALIGN="TOP"><P> HWND hwndChild</P></TD><TD VALIGN="TOP"><P>Specifies the handle of the child window contained in the band.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cxMinChild</P></TD><TD VALIGN="TOP"><P>Specifies the minimum horizontal size of the child window. The band cannot be sized smaller than this value.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cyMinChild</P></TD><TD VALIGN="TOP"><P>Specifies the minimum vertical size of the child window. The band cannot be sized smaller than this value.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT cx</P></TD><TD VALIGN="TOP"><P>Specifies the initial size of the band. This value is only used if there is more than one band in a row and this value is greater than cxMinChild.</P></TD></TR><TR><TD VALIGN="TOP"><P> HBITMAP hbmBack</P></TD><TD VALIGN="TOP"><P>Specifies the bitmap that should be used to paint the background.</P></TD></TR><TR><TD VALIGN="TOP"><P> UINT wID</P></TD><TD VALIGN="TOP"><P>Specifies an optional band identifier. This is user-defined and should be unique among all bands.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>Most bands will contain a child window of some sort. Any window that can be a child can be inserted in a band. The most common use of bands will be to hold ToolBars, ComboBoxes and other controls. First, you create the control you want to put in the band, then place its window handle in the hwndChild member of the REBARBANDINFO structure and set the RBBIM_CHILD flag in fMask. If you want to ensure the band won't be sized too small, set the cxMinChild and cyMinChild members and set RBBIM_CHILDSIZE in fMask. If you want a bitmap to be used as the background of a band, set hbmBack to the bitmap handle of the desired bitmap and set RBBIM_BACKGROUND in fMask. The background bitmap will automatically be tiled to fill in the band. If you want all of the bands to appear as though they have the same background, give each band the same bitmap handle and set RBBS_FIXEDBMP in fStyle. <B>Figure 13</B> details the fMask flags and <B>Figure 14</B> describes the fStyle flags. <B>Figure 15</B> describes all of the CoolBar messages.</P>
<P><B> Figure 13  REBARBANDINFO Mask Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_STYLE</P></TD><TD VALIGN="TOP"><P>The fStyle member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_COLORS</P></TD><TD VALIGN="TOP"><P>The clrFore and clrBack members are valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_TEXT</P></TD><TD VALIGN="TOP"><P>The lpText member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_IMAGE</P></TD><TD VALIGN="TOP"><P>The iImage member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_CHILD</P></TD><TD VALIGN="TOP"><P>The hwndChild member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_CHILDSIZE</P></TD><TD VALIGN="TOP"><P>The cxMinChild and cyMinChild members are valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_SIZE</P></TD><TD VALIGN="TOP"><P>The cx member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_BACKGROUND</P></TD><TD VALIGN="TOP"><P>The hbmBack member is valid.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBIM_ID</P></TD><TD VALIGN="TOP"><P>The wID member is valid.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 14  REBARBANDINFO Style Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_BREAK</P></TD><TD VALIGN="TOP"><P>The band is on a new line.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_FIXEDSIZE</P></TD><TD VALIGN="TOP"><P>This band can't be sized. The sizing grip is not displayed on this band.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_CHILDEDGE</P></TD><TD VALIGN="TOP"><P>Draw an edge around the top and bottom of the child window.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_HIDDEN</P></TD><TD VALIGN="TOP"><P>Hide this band.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_NOVERT</P></TD><TD VALIGN="TOP"><P>Don't display this band when the CoolBar is vertical.</P></TD></TR><TR><TD VALIGN="TOP"><P> RBBS_FIXEDBMP</P></TD><TD VALIGN="TOP"><P>The background bitmap doesn't move when the band is resized. It is also displayed as being common (unbroken) through all of the bands.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 15  CoolBar Messages</B></P>

<TABLE COLS="5" BORDER="0"><COLGROUP><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"><COL WIDTH="88pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Message</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>wParam</B></P></TD><TD VALIGN="TOP"><P><B>lParam</B></P></TD><TD VALIGN="TOP"><P><B>Return Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P> RB_SETBARINFO</P></TD><TD VALIGN="TOP"><P>Sets the general information for the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Not used. </P></TD><TD VALIGN="TOP"><P>Pointer to a REBARINFO structure.</P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_GETBARINFO</P></TD><TD VALIGN="TOP"><P>Retrieves the general information for the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Not used. </P></TD><TD VALIGN="TOP"><P>Pointer to a REBARINFO structure.</P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_SETBANDINFO</P></TD><TD VALIGN="TOP"><P>Sets the information for an existing band in the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Index of the band to set this information for.</P></TD><TD VALIGN="TOP"><P>Pointer to a REBARBANDINFO structure.</P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_GETBANDINFO</P></TD><TD VALIGN="TOP"><P>Retrieves the information for a band in the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Index of the band to retrieve the information for. </P></TD><TD VALIGN="TOP"><P>Pointer to a REBARBANDINFO structure.</P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_INSERTBAND</P></TD><TD VALIGN="TOP"><P>Inserts a new band into the CoolBar control. </P></TD><TD VALIGN="TOP"><P>Indicates the position at which the band should be inserted. Pass -1 to add a new band.</P></TD><TD VALIGN="TOP"><P>Pointer to a REBARBANDINFO structure. </P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_DELETEBAND</P></TD><TD VALIGN="TOP"><P>Deletes a band from the CoolBar control. </P></TD><TD VALIGN="TOP"><P>Index of the band to be deleted. </P></TD><TD VALIGN="TOP"><P>Not used. </P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_GETBANDCOUNT</P></TD><TD VALIGN="TOP"><P>Retrieves the number of bands currently in the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The number of bands contained in the CoolBar.</P></TD></TR><TR><TD VALIGN="TOP"><P> RB_GETROWCOUNT</P></TD><TD VALIGN="TOP"><P>Retrieves the number of rows in the CoolBar control.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The number of rows in the CoolBar. </P></TD></TR><TR><TD VALIGN="TOP"><P> RB_GETROWHEIGHT</P></TD><TD VALIGN="TOP"><P>Retrieves the height of a row in the CoolBar control. </P></TD><TD VALIGN="TOP"><P>Zero-based index of the band in the row to get the height for.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The height of the row that contains the specified band in pixels. </P></TD></TR></TBODY></TABLE>
<P><BR></P><P>To delete a band, simply send the CoolBar the RB_DELETEBAND message with the band index in the lParam.</P>
<P>When the user exits your application, you will probably want to save the current layout of your CoolBar. To do this, obtain the number of bands by sending the CoolBar the RB_GETBANDCOUNT message. Then cycle through each of the bands, getting the information for each band by sending the CoolBar the RB_GETBANDINFO message. At a minimum, you will need to store the wID and the cx values from the REBARBANDINFO structure. The wID value tells you what order the bands are in so that they can be added in the same order again. Place the cx value in the REBARBANDINFO structure when you add the bands again so that the bands will have the same size as before. You will also need to store any other application-specific information, such as which image is being used and what the band text is. This will depend upon what options you allow users to change.</P>
<P>The CoolBar has only one notification message: RBN_HEIGHTCHANGE. This notification is sent to your app via WM_NOTIFY. The lParam for this notification is a pointer to a standard NMHDR structure. RBN_HEIGHTCHANGE is sent whenever the CoolBar is resized vertically, or horizontally if the CoolBar has the CCS_VERT style.</P>
<P>The CoolBar doesn't destroy its own image list, so before the control gets destroyed, you should get the handle to the image list by sending the control an RB_GETBARINFO message. You should then destroy the image list manually.</P>
<P> </P>
<H2><A NAME="sec3"></A>  The CoolBar Sample</H2><P>I have put together a sample application (see <B>Figure 16</B> and <B>Figure 17</B>) that demonstrates how to create a CoolBar and add bands to it. (To download the complete sample code, see page 5.) This sample also allows the user to set the position of the CoolBar to the top, left, right, or bottom of the parent window.</P>
<P><img src="msie4_16.gif"></P>
<P><B> Figure 16  CoolBar sample program.</B></P>
<P><B>Figure 17  CoolBar.c</B></P>
<P><BR></P>
<PRE> /**************************************************************************
   File:          CoolBar.c
**************************************************************************/
#define STRICT
//#define UNICODE

/**************************************************************************
   Include Files
**************************************************************************/
#include &lt;windows.h&gt;
#include &lt;windowsx.h&gt;
#include &lt;commctrl.h&gt;
#include "resource.h"

/**************************************************************************
   Local Function Prototypes
**************************************************************************/
int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int);
BOOL InitApplication(HINSTANCE);
BOOL InitInstance(HINSTANCE, int);
LRESULT CALLBACK MainWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT HandleCommand(HWND, WPARAM, LPARAM);
BOOL CALLBACK About(HWND, UINT, WPARAM, LPARAM);
HWND BuildCoolBar(HWND);
LRESULT HandleNotify(HWND, WPARAM, LPARAM);
void MoveCoolBar(HWND);
void UpdateMenu(HWND, HMENU);

/**************************************************************************
   Global Variables
**************************************************************************/
#define ID_COOLBAR   1000
#define ID_COMBOBOX  2000
#define ID_BUTTON    2001

#define TOP    0x00
#define LEFT   0x01
#define BOTTOM 0x02
#define RIGHT  0x03

HINSTANCE   g_hInst;
WORD        g_wSide;
TCHAR       g_szClassName[] = TEXT("CoolBarSampleClass");

/******************************************************************************
   WinMain
******************************************************************************/
int PASCAL WinMain(  HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR lpCmdLine,
                     int nCmdShow)
{
MSG      msg;
INITCOMMONCONTROLSEX iccex;

iccex.dwSize = sizeof(INITCOMMONCONTROLSEX);
iccex.dwICC = ICC_COOL_CLASSES;
InitCommonControlsEx(&amp;iccex);

if(!hPrevInstance)
   if(!InitApplication(hInstance))
      return FALSE;

if (!InitInstance(hInstance, nCmdShow))
   return FALSE;

while(GetMessage( &amp;msg, NULL, 0x00, 0x00))
   {
   TranslateMessage(&amp;msg);
   DispatchMessage(&amp;msg);
   }

return msg.wParam;
}

/*****************************************************************************
   InitApplication
*****************************************************************************/
BOOL InitApplication(HINSTANCE hInstance)
{
WNDCLASS  wc;

wc.style          = 0;
wc.lpfnWndProc    = (WNDPROC)MainWndProc;
wc.cbClsExtra     = 0;
wc.cbWndExtra     = 0;
wc.hInstance      = hInstance;
wc.hIcon          = LoadIcon(NULL, MAKEINTRESOURCE(IDI_MAINICON));
wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW+1);
wc.lpszMenuName   = MAKEINTRESOURCE(IDM_MAINMENU);
wc.lpszClassName  = g_szClassName;

return RegisterClass(&amp;wc);
}

/*****************************************************************************
   InitInstance
*****************************************************************************/
BOOL InitInstance(   HINSTANCE hInstance,
                     int nCmdShow)
{
HWND  hWnd;

g_hInst = hInstance;

hWnd = CreateWindowEx(  0,
                        g_szClassName,
                        TEXT("CoolBar Application"),
                        WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        CW_USEDEFAULT,
                        NULL,
                        NULL,
                        hInstance,
                        NULL);

if (!hWnd)
   return FALSE;

ShowWindow(hWnd, nCmdShow);
UpdateWindow(hWnd);

return TRUE;

}

/*****************************************************************************
   MainWndProc
*****************************************************************************/
LRESULT CALLBACK MainWndProc( HWND hWnd,
                              UINT uMessage,
                              WPARAM wParam,
                              LPARAM lParam)
{switch (uMessage)
   {      case WM_CREATE:  g_wSide = TOP;
                           BuildCoolBarBhWnd);
                           break;
          case WM_NOTIFY:  return HandleNotify(hWnd, wParam, lParam);
   case WM_INITMENUPOPUP:  UpdateMenu(hWnd, (HMENU)wParam);
                           break;
            case WM_SIZE:  MoveCoolB....arBhWnd);
                           break;
         case WM_DESTROY:  PostQuitMessage(0);
                           break;
         case WM_COMMAND:  return HandleCommand(hWnd, wParam, lParam);
   default:                break;
   }
return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

/*****************************************************************************

   HandleCommand

*****************************************************************************/

LRESULT HandleCommand(HWND hWnd, WPARAM wParam, LPARAM lParam)
{switch (wParam)
   {  case ID_BUTTON:  MessageBeep(MB_OK);
                       break;
    case ID_COMBOBOX:  MessageBeep(MB_OK);
                       break;
        case IDM_TOP: if(g_wSide != TOP)
            {
            DestroyWindow(GetDlgItem(hWnd, ID_COOLBAR)); //86 existing CoolBar                    
            g_wSide = TOP;  //change to the new side
            
            BuildCoolBar(hWnd);  //create the new CoolBar
            /* We have to do this because the CoolBar will recalculate its 
            rectangle after the first time it is sized. */
            MoveCoolBar(hWnd);
            }
            break;
     case IDM_BOTTOM: if(g_wSide != BOTTOM)
            {
            DestroyWindow(GetDlgItem(hWnd, ID_COOLBAR)); //86 existing CoolBar
         
            g_wSide = BOTTOM;
            
            BuildCoolBar(hWnd); //create the new CoolBar
            /* We have to do this because the CoolBar will recalculate its 
            rectangle after the first time it is sized. */
            MoveCoolBar(hWnd);
            }
            break;
       case IDM_LEFT: if(g_wSide != LEFT)
            {
            DestroyWindow(GetDlgItem(hWnd, ID_COOLBAR)); //86 existing CoolBar
            
            g_wSide = LEFT;
            
            BuildCoolBar(hWnd); //create the new CoolBar

            /* We have to do this because the CoolBar will recalculate its 
            rectangle after the first time it is sized. */
            MoveCoolBar(hWnd);
            }
            break;
      case IDM_RIGHT: if(g_wSide != RIGHT)
            {
            DestroyWindow(GetDlgItem(hWnd, ID_COOLBAR)); //86 existing CoolBar
            
            g_wSide = RIGHT;
            
            BuildCoolBar(hWnd);  //create the new CoolBar

            /* We have to do this because the CoolBar will recalculate its 
            rectangle after the first time it is sized. */
            MoveCoolBar(hWnd);
            }
            break;
       case IDM_EXIT: DestroyWindow(hWnd);
                      break;
      case IDM_ABOUT: DialogBox(g_hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd,
                                About);
                      break;   
         }
return 0;
}

/*****************************************************************************
   About
*****************************************************************************/
BOOL CALLBACK About( HWND hDlg, 
                     UINT uMessage, 
                     WPARAM wParam, 
                     LPARAM lParam)
{
switch (uMessage)
   {
   case WM_INITDIALOG:
      return TRUE;
      
   case WM_COMMAND:
      switch(wParam)
         {
         case IDOK:
            EndDialog(hDlg, IDOK);
            return TRUE;

         case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            return TRUE;
         }
      break;
    } 
    
return FALSE;
}

/*****************************************************************************
   BuildCoolBar
*****************************************************************************/
HWND BuildCoolBar(HWND hwndParent)
{
HWND     hwndCoolBar = NULL;
LRESULT  lResult;

hwndCoolBar = CreateWindowEx( WS_EX_TOOLWINDOW, 
                              REBARCLASSNAME, 
                              NULL,
                              WS_VISIBLE | WS_BORDER | WS_CHILD |
                              WS_CLIPCHILDREN | WS_CLIPSIBLINGS | 
                              RBS_TOOLTIPS | RBS_VARHEIGHT | RBS_BANDBORDERS |
                              CCS_NODIVIDER | CCS_NOPARENTALIGN |
                              ((g_wSide &amp; 0x01) ? CCS_VERT : 0),  
                              //g_wSide is odd if this is a vertical bar
                              0, 0, 200, 100, hwndParent, (HMENU)ID_COOLBAR, 
                              g_hInst, NULL);

if(hwndCoolBar)
   {
   REBARINFO      rbi;
   HIMAGELIST     himlCoolBar;
   HICON          hIcon;
   REBARBANDINFO  rbbi;
   HWND           hwndChild;
   RECT           rc;
   TCHAR          szString[64];

   //set up the CoolBar
   himlCoolBar = ImageList_Create(32, 32, ILC_COLORDDB | ILC_MASK, 1, 0);
   hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_MAINICON));

   ImageList_AddIcon(himlCoolbar, hIcon);

   rbi.cbSize  = sizeof(rbi);
   rbi.fMask   = RBIM_IMAGELIST;
   rbi.himl    = himlCoolBar;
   lResult = SendMessage(hwndCoolBar, RB_SETBARINFO, 0, (LPARAM)&amp;rbi);
   
   //add a band that contains a combobox
   hwndChild = CreateWindowEx(   0, 
                                 TEXT("combobox"), 
                                 NULL,
                                 WS_VISIBLE | WS_CHILD | WS_TABSTOP |
                                 WS_VSCROLL | WS_CLIPCHILDREN |
                                 WS_CLIPSIBLINGS | CBS_AUTOHSCROLL | 
                                 CBS_DROPDOWN,
                                 0, 0, 100, 200, hwndCoolBar,
                                 (HMENU)ID_COMBOBOX, g_hInst, NULL);

   //add some stuff to the combobox
   {
   int   i;

   for(i = 0; i &lt; 25; i++)
      {
      wsprintf(szString, TEXT("Item %d"), i + 1);
      SendMessage(hwndChild, CB_ADDSTRING, 0, (LPARAM)szString);
      }
   }
   
   GetWindowRect(hwndChild, &amp;rc);
   
   ZeroMemory(&amp;rbbi, sizeof(rbbi));
   rbbi.cbSize       = sizeof(REBARBANDINFO);
   rbbi.fMask        = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_ID | RBBIM_STYLE | 
                          RBBIM_COLORS | RBBIM_TEXT | RBBIM_BACKGROUND |
                          RBBIM_IMAGE;
   rbbi.cxMinChild   = rc.right - rc.left;
   rbbi.cyMinChild   = rc.bottom - rc.top;
   rbbi.clrFore      = GetSysColor(COLOR_BTNTEXT);
   rbbi.clrBack      = GetSysColor(COLOR_BTNFACE);
   rbbi.fStyle       = RBBS_CHILDEDGE | 
                        RBBS_FIXEDBMP;
   rbbi.wID          = ID_COMBOBOX;
   rbbi.hwndChild    = hwndChild;
   rbbi.lpText       = TEXT("ComboBox");
   rbbi.hbmBack      = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BACKGROUND));
   rbbi.iImage       = 0;

   lResult = SendMessage(hwndCoolBar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)(LPREBARBANDINFO)&amp;rbbi);

   //add a band that contains a button
   hwndChild = CreateWindowEx(   0, 
                                 TEXT("button"), 
                                 TEXT("Button"),
                                 WS_CHILD | 
                                    BS_PUSHBUTTON,
                                 0, 0, 100, 50, 
                                 hwndCoolbar, 
                                 (HMENU)ID_BUTTON, 
                                 g_hInst, 
                                 NULL);
   
   GetWindowRect(hwndChild, &amp;rc);
   
   ZeroMemory(&amp;rbbi, sizeof(rbbi));
   rbbi.cbSize       = sizeof(REBARBANDINFO);
   rbbi.fMask        =  RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_ID |
                           RBBIM_STYLE | RBBIM_COLORS | RBBIM_TEXT |
                           RBBIM_BACKGROUND;
   rbbi.cxMinChild   = rc.right - rc.left;
   rbbi.cyMinChild   = rc.bottom - rc.top;
   rbbi.clrFore      = GetSysColor(COLOR_BTNTEXT);
   rbbi.clrBack      = GetSysColor(COLOR_BTNFACE);
   rbbi.fStyle       = RBBS_CHILDEDGE | 
                        RBBS_FIXEDBMP;
   rbbi.wID          = ID_BUTTON;
   rbbi.hwndChild    = hwndChild;
   rbbi.lpText       = TEXT("Button");
   rbbi.hbmBack      = LoadBitmap(g_hInst, MAKEINTRESOURCE(IDB_BACKGROUND));

   lResult = SendMessage(hwndCoolBar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)(LPREBARBANDINFO)&amp;rbbi);
   }

MoveCoolBar(hwndParent);

return hwndCoolBar;
}

/*****************************************************************************
   HandleNotify
*****************************************************************************/
LRESULT HandleNotify(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
LPNMHDR  lpNM = (LPNMHDR)lParam;

switch(lpNM-&gt;code)
   {
   case RBN_HEIGHTCHANGE:
      break;
   }

return FALSE;
}

/**************************************************************************
   MoveCoolBar()
  
**************************************************************************/
void MoveCoolBar(HWND hWnd)
{
RECT  rc,
      rcCoolBar;
int   x, y,
      cx,cy;

GetClientRect(hWnd, &amp;rc);
GetWindowRect(GetDlgItem(hWnd, ID_COOLBAR), &amp;rcCoolBar);

switch(g_wSide)
   {
   default:
   case TOP:
      //align the CoolBar along the top of the window
      x = 0; y = 0;
      cx = rc.right - rc.left;
      cy = rc.bottom - rc.top;
      break;
   case LEFT:
      //align the CoolBar along the left side of the window
      x = 0;
      y = 0;
      cx = rcCoolBar.right - rcCoolBar.left;
      cy = rc.bottom - rc.top;
      break;
   case BOTTOM:
      //align the CoolBar along the bottom of the window
      x = 0;
      y = rc.bottom - (rcCoolBar.bottom - rcCoolBar.top);
      cx = rc.right - rc.left;
      cy = rcCoolBar.bottom - rcCoolBar.top;
      break;
   case RIGHT:
      //align the CoolBar along the right side of the window
      x = rc.right - (rcCoolBar.right - rcCoolBar.left);
      y = 0;
      cx = rcCoolBar.right - rcCoolBar.left;
      cy = rc.bottom - rc.top;
      break;
   }

MoveWindow( GetDlgItem(hWnd, ID_COOLBAR), 
            x, y, 
            cx,cy, 
            TRUE);
}

/**************************************************************************
  UpdateMenu()
**************************************************************************/
void UpdateMenu(HWND hWnd, HMENU hMenu)
{
UINT  uCheck;

switch(g_wSide)
   {
   default:
   case TOP:    uCheck = IDM_TOP;
      break;
   case LEFT:   uCheck = IDM_LEFT;
      break;
   case RIGHT:  uCheck = IDM_RIGHT;
      break;
   case BOTTOM: uCheck = IDM_BOTTOM;
      break;
   }

CheckMenuRadioItem(hMenu, IDM_TOP, IDM_BOTTOM, uCheck, MF_BYCOMMAND);
}</PRE>
<P></P>
<P>During the initialization of the application, I call InitCommonControlsEx with dwICC of the INITCOMMONCONTROLSEX structure set to ICC_COOL_CLASSES to initialize the CoolBar class. To create and initialize the CoolBar, I created the BuildCoolbar function. This function creates the CoolBar using CreateWindowEx. The function then initializes the CoolBar by filling out a REBARINFO structure and sending the CoolBar an RB_SETBARINFO message. Once the control is initialized, the function creates and initializes a ComboBox to place in a band. The REBARBANDINFO structure is filled out and then the ComboBox band is added by sending the CoolBar the RB_INSERTBAND message. This band includes text and an image. Then a button is created, the REBARBANDINFO structure is filled in, and the RB_INSERTBAND message is sent to add a second band. The button band includes text, but does not contain an image. </P>
<P>For this sample, I chose to create the CoolBar with the CCS_NOPARENTALIGN style and to reposition the control myself whenever the main window receives a WM_SIZE message. Another option is to not specify the CCS_NOPARENTALIGN style and let the CoolBar reposition itself. When you choose this method, you will need to forward the parent's WM_SIZE messages to the CoolBar so that it can realign itself with its parent.</P>
<P>All command and notification messages from the controls contained in the bands are forwarded to the parent window via WM_COMMAND or WM_NOTIFY messages.</P>
<H2><A NAME="sec4"></A>  ComboBoxEx</H2><P>The new ComboBoxEx control is basically a ComboBox that supports item images and indenting. This control is very similar to the ComboBox that you see in the Windows Explorer's ToolBar (see <B>Figure 18</B>). I won't rehash how to use a ComboBox here; I'll just explain the basics of creating and manipulating the ComboBoxEx control. All of the ComboBoxEx messages are outlined in <B>Figure 19</B>.</P>
<P><img src="msie4_18.gif"></P>
<P><B> Figure 18  ComboBoxEx</B></P>
<P><B>Figure 19  ComboBoxEx Messages</B></P>

<TABLE COLS="5" BORDER="0"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="103pt" VALIGN="TOP"><COL WIDTH="49pt" VALIGN="TOP"><COL WIDTH="94pt" VALIGN="TOP"><COL WIDTH="144pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Message</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>wParam</B></P></TD><TD VALIGN="TOP"><P><B>lParam</B></P></TD><TD VALIGN="TOP"><P><B>Return Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_DELETEITEM</P></TD><TD VALIGN="TOP"><P>Deletes an item from a ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>Index of the item to be deleted. </P></TD><TD VALIGN="TOP"><P>Not used. </P></TD><TD VALIGN="TOP"><P>The number of items remaining in the control after the item has been deleted.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_GETCOMBOCONTROL</P></TD><TD VALIGN="TOP"><P>Retrieves the window handle of the drop-down list box portion of the ComboBoxEx control.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Window handle of the drop-down list box. </P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_GETEDITCONTROL</P></TD><TD VALIGN="TOP"><P>Retrieves the window handle of the edit control portion of the ComboBoxEx control. This message is only applicable if the ComboBoxEx has the CBS_DROPDOWN style.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Window handle of the edit control.  </P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_GETEXSTYLE</P></TD><TD VALIGN="TOP"><P>Retrieves the extended styles for the ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A DWORD value representing the currently set ComboBoxEx extended style flags.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_SETEXSTYLE</P></TD><TD VALIGN="TOP"><P>Sets the extended styles for the ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>A DWORD value representing the ComboBoxEx extended style flags to set. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A DWORD value representing the previously set ComboBoxEx extended style flags. This return value may be zero if no flags were previously set.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_GETIMAGELIST</P></TD><TD VALIGN="TOP"><P>Retrieves the handle to the image list that the ComboBoxEx control is currently using.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>An HIMAGELIST that is the handle to the image list that is currently set in the ComboBoxEx control. </P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_GETITEM</P></TD><TD VALIGN="TOP"><P>Retrieves the information for a particular item in a ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A pointer to a COMBOBOXEXITEM structure. Before sending this message, the iItem member of this structure indicates the item to be retrieved and the mask  member indicates what attributes should be retrieved.</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating the success or failure of the message.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_SETITEM</P></TD><TD VALIGN="TOP"><P>Sets the specified attributes for an existing item in a ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A pointer to a COMBOBOXEXITEM structure. The iItem member of this structure indicates the item whose attributes should be set. The mask member indicates what members of  the structure contain valid information to be set.</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating the success or failure of the message.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_HASEDITCHANGED</P></TD><TD VALIGN="TOP"><P>Determines if the user has changed the contents of the edit control portion of the ComboBoxEx control. This  message is only valid if the  ComboBoxEx control has the CBS_DROPDOWN style.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A BOOL value indicating if the contents of the edit control have changed.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_INSERTITEM</P></TD><TD VALIGN="TOP"><P>Insert an item into a ComboBoxEx control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A pointer to a COMBOBOXEXITEM structure. The iItem member of this structure indicates the zero-based index at which to insert the item. Setting iItem  to -1 adds the item to the end of the list.</P></TD><TD VALIGN="TOP"><P>The index at which the item was inserted or -1 if the insertion failed. </P></TD></TR><TR><TD VALIGN="TOP"><P> CBEM_SETIMAGELIST</P></TD><TD VALIGN="TOP"><P>Sets the image list that ComboBoxEx control will use to draw item images. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The HIMAGELIST of the image list to be set. </P></TD><TD VALIGN="TOP"><P>The HIMAGELIST of the image list previously associated with the control. This message may return NULL if no image list was previously set.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Before creating a ComboBoxEx control, you must call InitCommonControlsEx with ICC_USEREX_CLASSES set in dwICC of the INITCOMMONCONTROLSEX structure. To create a ComboBoxEx, use the CreateWindow or CreateWindowEx function with the class name of WC_COMBOBOXEX. The ComboBoxEx control supports all of the standard ComboBox styles except for CBS_OWNERDRAWFIXED, CBS_OWNERDRAWVARIABLE, and CBS_HASSTRINGS. </P>
<P>The ComboBoxEx has its own set of extended styles (see <B>Figure 20</B>). These extended styles should not be confused with extended window styles as used in CreateWindowEx, SetWindowLong, or GetWindowLong. After creating the control, the extended styles are set by sending the control the CBEM_SETEXSTYLE message. This message takes a DWORD value for the wParam that contains all of the extended style flags to be set. The ComboBoxEx extended styles are retrieved by sending the control the CBEM_GETEXSTYLE message. The return value from this message is a DWORD that contains all of the extended style bits currently set in the control.</P>
<P><B> Figure 20  ComboBoxEx Extended Styles</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Style Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CBES_EX_NOEDITIMAGE</P></TD><TD VALIGN="TOP"><P>When set, the edit control portion of the ComboBoxEx will not display an image for selected items.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBES_EX_NOEDITIMAGEINDENT</P></TD><TD VALIGN="TOP"><P>When set, the edit control portion of the ComboBoxEx will not indent text to make room for an item image.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBES_EX_PATHWORDBREAKPROC</P></TD><TD VALIGN="TOP"><P>When set, the edit control portion of the ComboBoxEx will use the forward slash (/), back slash (\), and period (.) characters as word delimiters. This makes keyboard shortcuts for word-by-word cursor movement (Ctrl + arrow keys) effective in path names and URLs.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>To add or insert items into the ComboBoxEx control, you fill in a COMBOBOXEXITEM structure and send the control a CBEM_INSERTITEM message. This message takes a pointer to the COMBOBOXEXITEM structure (see <B>Figure 21</B>) as the lParam. To add an item to the end of the list, set iItem in the structure to (UINT)-1. </P>
<P>To delete an item from the ComboBoxEx control, send the control the CBEM_DELETEITEM message. The zero-based index of the item to be deleted is indicated in the wParam of this message.</P>
<P><B> Figure 21  COMBOBOXEXITEM Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="153pt" VALIGN="TOP"><COL WIDTH="288pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> UINT mask</P></TD><TD VALIGN="TOP"><P>Specifies which of the members contain valid information. Or, when retrieving information, which members are being requested. See Figure 23 for a list of the ComboBoxEx mask values.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iItem</P></TD><TD VALIGN="TOP"><P>Zero-based index of the item.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPTSTR pszText</P></TD><TD VALIGN="TOP"><P>Pointer to a zero-terminated character buffer that contains the display text for the item. If information is being requested from the control, then this member needs to be initialized to point to a character buffer before sending the message. When setting or inserting an item, setting this member to LPSTR_TEXTCALLBACK will cause the control to request the text by sending a CBEN_GETDISPINFO notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> int cchTextMax</P></TD><TD VALIGN="TOP"><P>The size of the buffer pointed to by pszText. This member is only used when information is being requested from the control.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iImage</P></TD><TD VALIGN="TOP"><P>Zero-based index of an image within the image list that the control will use to display the item when it is not selected. When setting or inserting an item, setting this member to I_IMAGECALLBACK will cause the control to request the image by sending a CBEN_GETDISPINFO notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iSelectedImage</P></TD><TD VALIGN="TOP"><P>Zero-based index of an image within the image list that the control will use to display the item when it is selected. When setting or inserting an item, setting this member to I_IMAGECALLBACK will cause the control to request the selected image by sending a CBEN_GETDISPINFO notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iOverlay</P></TD><TD VALIGN="TOP"><P>One-based index of an overlay image within the image list that the control will use to overlay the item's image. When setting or inserting an item, setting this member to I_IMAGECALLBACK will cause the control to request the overlay by sending a CBEN_GETDISPINFO notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iIndent</P></TD><TD VALIGN="TOP"><P>Number of indent spaces that this item should be indented. Each indent space is equal to 10 pixels. When setting or inserting an item, setting this member to I_INDENTCALLBACK will cause the control to request the indent value by sending a CBEN_GETDISPINFO notification message.</P></TD></TR><TR><TD VALIGN="TOP"><P> LPARAM lParam</P></TD><TD VALIGN="TOP"><P>A 32-bit user-defined value.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The ComboBoxEx control sends more than a few notifications (see <B>Figure 22</B>) using the WM_NOTIFY message. The NMCOMBOBOXEX structure consists of a NMHDR <BR>structure (hdr) followed by a COMBOBOXEXITEM structure (ceItem) which contains information about the item (see <B>Figure 23</B>). <B>Figure 24</B> describes the NMCBEEND-EDIT structure.</P>
<P><B> Figure 22  ComboBoxEx Notification Codes</B></P>

<TABLE COLS="4" BORDER="0"><COLGROUP><COL WIDTH="110pt" VALIGN="TOP"><COL WIDTH="110pt" VALIGN="TOP"><COL WIDTH="110pt" VALIGN="TOP"><COL WIDTH="110pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Notification Code</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>lParam</B></P></TD><TD VALIGN="TOP"><P><B>Return Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CBEN_BEGINEDIT</P></TD><TD VALIGN="TOP"><P>Sent by the control when the user activates the drop-down list or clicks the mouse in the edit portion of the ComboBoxEx control.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMHDR structure.</P></TD><TD VALIGN="TOP"><P>Ignored.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEN_DELETEITEM</P></TD><TD VALIGN="TOP"><P>Sent by the control when an item is about to be deleted.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMCOMBOBOXEX structure. The COMBOXEXITEM member of the NMCOMBOBOXEX structure contains information about the item being deleted.</P></TD><TD VALIGN="TOP"><P>Ignored.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEN_ENDEDIT</P></TD><TD VALIGN="TOP"><P>Sent by the control when the user has concluded an operation in the edit control or made a selection in the drop-down list portion of the ComboBoxEx control.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMCBEENDEDIT structure, which contains information about the edit event just completed.</P></TD><TD VALIGN="TOP"><P>Return FALSE to accept the new information. Return TRUE to abort the edit and reject the new information.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEN_GETDISPINFO</P></TD><TD VALIGN="TOP"><P>Sent by the control when information necessary to display a callback item is required</P></TD><TD VALIGN="TOP"><P>Pointer to an NMCOMBOBOXEX structure. The mask member of the COMBOBOXEXITEM member of the NMCOMBOBOXEX structure indicates which items are being requested.</P></TD><TD VALIGN="TOP"><P>Ignored.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEN_INSERTITEM</P></TD><TD VALIGN="TOP"><P>Sent by the control when an item is about to be inserted.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMCOMBOBOXEX structure. The COMBOXEXITEM member of the NMCOMBOBOXEX structure contains information about the item being inserted.</P></TD><TD VALIGN="TOP"><P>Ignored.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 23  COMBOBOXEXITEM Mask Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="279pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Value</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_TEXT</P></TD><TD VALIGN="TOP"><P>The pszText member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_IMAGE</P></TD><TD VALIGN="TOP"><P>The iImage member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_SELECTEDIMAGE</P></TD><TD VALIGN="TOP"><P>The iSelectedImage member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_OVERLAY</P></TD><TD VALIGN="TOP"><P>The iOverlay member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_INDENT</P></TD><TD VALIGN="TOP"><P>The iIndent member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_LPARAM</P></TD><TD VALIGN="TOP"><P>The lParam member is valid or needs to be filled in.</P></TD></TR><TR><TD VALIGN="TOP"><P> CBEIF_DI_SETITEM</P></TD><TD VALIGN="TOP"><P>The control should store the item data and not ask for it again. This flag is only used with the CBEN_GETDISPINFO notification message.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 24  NMCBEENDEDIT Structure</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Member</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> NMHDR hdr</P></TD><TD VALIGN="TOP"><P>Standard NMHDR structure.</P></TD></TR><TR><TD VALIGN="TOP"><P> BOOL fChanged</P></TD><TD VALIGN="TOP"><P>A BOOL indicating if the contents of the edit control have changed. Zero if the contents have not changed, nonzero if the contents have changed.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iNewSelection</P></TD><TD VALIGN="TOP"><P>Zero-based index of the item that will be selected after the edit is completed. This value may be CB_ERR if no item will be selected.</P></TD></TR><TR><TD VALIGN="TOP"><P> TCHAR szText[CBEMAXSTRLEN]</P></TD><TD VALIGN="TOP"><P>Zero-terminated string buffer that contains the text of the edit control.</P></TD></TR><TR><TD VALIGN="TOP"><P> int iWhy</P></TD><TD VALIGN="TOP"><P>Specifies the action that generated the notification. This can be one of the following values: </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>CBENF_KILLFOCUS - The edit box lost the keyboard focus.</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>CBENF_RETURN  - The user completed the edit operation by pressing the ENTER key. </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>CBENF_ESCAPE - The user pressed the ESCAPE key.</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>CBENF_DROPDOWN - The user activated the drop-down list.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Like the CoolBar, the ComboBoxEx doesn't destroy its own image list, so before the control gets destroyed, you should get the handle to the image list by sending the control a CBEM_GETIMAGELIST message. You should then destroy the image list manually.</P>
<P> </P>
<H2><A NAME="sec5"></A>  Date/Time Picker</H2><P>The Date/Time Picker is a customizable calendar and time control that allows the user to select a date or time in a dedicated field. As its name implies, the control can operate in two modes, date mode and time mode. The mode is controlled by the style bits of the control.</P>
<P>When in date mode, the control acts like a ComboBox. The user can edit the date right in the edit control or drop down a monthly calendar. The user can move to the previous or next month by pressing little buttons in the calendar. When the user selects a date in the drop-down calendar, the selected date is entered in the edit portion of the control and the drop-down calendar is destroyed. <B>Figure 25</B> shows an example of a Date Picker control.</P>
<P><img src="msie4_25.gif"></P>
<P><B> Figure 25  Date Picker control.</B></P>
<P>In time mode, the control acts more like a UpDown control (see <B>Figure 26</B>). The user can enter text directly into the control or use the up and down arrow buttons to adjust the separate elements of the time. In both modes, the control supports all of the format strings the GetDateFormat function supports. It also supports what are called callback fields in the format string. Callback fields will be explained in more detail shortly.</P>
<P><img src="msie4_26.gif"></P>
<P><B> Figure 26  Time Picker control.</B></P>
<P>Before creating a Date/Time Picker control, you must call InitCommonControlsEx with ICC_DATE_CLASSES set in dwICC of the INITCOMMONCONTROLSEX structure. To create a Date/Time Picker, use the CreateWindow or CreateWindowEx function with the class name of DATETIMEPICK_CLASS. In addition to the standard window styles, the Date/Time Picker control has its own set of styles (see <B>Figure 27</B>).</P>
<P><B> Figure 27  Date/Time Picker Styles</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="157pt" VALIGN="TOP"><COL WIDTH="284pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Style Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_TIMEFORMAT</P></TD><TD VALIGN="TOP"><P>Without this style, the control is in date mode. When this style is set, then the control is in time mode.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_UPDOWN</P></TD><TD VALIGN="TOP"><P>When in date mode, this causes the control to act like an UpDown control rather than a ComboBox. This style has no effect when the control is in time mode.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_SHOWNONE</P></TD><TD VALIGN="TOP"><P>This style allows the control to have no set date or time. When this style is specified, a checkbox will appear next to the date or time. The state of this checkbox determines if no date or time is selected. To obtain the state of the checkbox, examine the return value from the DTM_GETSYSTEMTIME message. If this value is GDT_NONE, then no date or time is currently selected in the control.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_SHORTDATEFORMAT</P></TD><TD VALIGN="TOP"><P>This is the default style when in date mode or when a format string has been specified. This style causes the control to display the date in the form "7/08/96", rather than "Monday, July 8, 1996". This style has no effect when in time mode.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_LONGDATEFORMAT</P></TD><TD VALIGN="TOP"><P>This style causes the control to display the date in the form "Monday, July 8, 1996", rather than "7/08/96". This style has no effect when in time mode. This style has no effect if a format string has been specified for the control.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_APPCANPARSE</P></TD><TD VALIGN="TOP"><P>Allows the application to parse text that the user enters. The application must respond to the DTN_USERSTRING notification.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTS_RIGHTALIGN</P></TD><TD VALIGN="TOP"><P>Causes the drop-down calendar to be right-aligned with the control rather than left-aligned, which is the default.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>After the control is created, it will automatically set itself to the current system time. If you want to set the control to a different date or time, you send the control a DTM_SETSYSTEMTIME message. This message takes a constant, GDT_VALID, for the wParam and a pointer to a SYSTEMTIME structure that contains the time to set the control to as the lParam. The wParam can also be GDT_NONE; I will discuss that shortly. To get the current date or time from the control, you send it the DTM_GETSYSTEMTIME message. The lParam for this message is a pointer to a SYSTEMTIME structure that will receive the control's date and time information.</P>
<P>By default, the control uses system colors for the drop-down calendar. You can customize the colors that the calendar uses by sending the control the DTM_SETMCCOLOR message. The wParam for this message is one of the values listed in <B>Figure 28</B>. The lParam is a COLORREF value that specifies the new color. To retrieve the currently set colors, send the control the DTM_GETMCCOLOR message. The return value from this message is a COLORREF value that represents the color.</P>
<P><B> Figure 28  DTM_SETMCCOLOR/DTM_GETMCCOLOR Constants</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> wParam</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_BACKGROUND</P></TD><TD VALIGN="TOP"><P>Specifies the background color displayed between months in the drop-down calendar.</P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_TEXT</P></TD><TD VALIGN="TOP"><P>Specifies the text color of the dates that are in the currently selected month in the drop-down calendar.</P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_TITLEBK </P></TD><TD VALIGN="TOP"><P>Specifies the background color of the title bar in the drop-down calendar.</P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_TITLETEXT </P></TD><TD VALIGN="TOP"><P>Specifies the text color of the title bar in the drop-down calendar.</P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_MONTHBK</P></TD><TD VALIGN="TOP"><P>Specifies the background color of the drop-down calendar.</P></TD></TR><TR><TD VALIGN="TOP"><P> MCSC_TRAILINGTEXT</P></TD><TD VALIGN="TOP"><P>Specifies the text color of the dates that are not in the currently selected month in the drop-down calendar.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>You may want to change the format string for the control. The format string controls how the control displays the date or time information. This is done by sending the control the DTM_SETFORMAT message. For this message, a pointer to the format string is given for the lParam. If you don't specifically set the format string, the control will use the default format string from the locale information. To reset the control to the default string, just send the control the DTM_SETFORMAT message with NULL for the string pointer. The control supports the same format strings as those described by GetTimeFormat and GetDateFormat. </P>
<P>The control also supports callback fields in the format string. You specify a callback field by placing one or more "X" characters in the format string. When the control parses the format string and sees a callback field, it will send a DTN_FORMATQUERY notification. The lParam for this notification is a pointer to an NMDATETIMEFORMATQUERY structure. This notification asks for the maximum allowable width of a string that can be displayed in that field. This value is placed in the szMax member of the structure. The control then sends the DTN_FORMAT notification. The lParam for this notification is a pointer to an NMDATETIMEFORMAT structure, which gives you the SYSTEMTIME structure that the control is currently set to. You place the formatted text in the szDisplay member of the structure.</P>
<P>All of the Date/Time Picker specific messages are detailed in <B>Figure 29</B>, and the Date/Time Picker-specific notification codes are detailed in <B>Figure 30</B>.</P>
<P><B> Figure 29  Date/Time Picker Messages</B></P>

<TABLE COLS="5" BORDER="0"><COLGROUP><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="130pt" VALIGN="TOP"><COL WIDTH="111pt" VALIGN="TOP"><COL WIDTH="79pt" VALIGN="TOP"><COL WIDTH="119pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Message</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>wParam</B></P></TD><TD VALIGN="TOP"><P><B>lParam</B></P></TD><TD VALIGN="TOP"><P><B>Return Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_GETMCCOLOR</P></TD><TD VALIGN="TOP"><P>Retrieves the colors used in the drop-down calendar portion of the control.</P></TD><TD VALIGN="TOP"><P>One of the color constants defined in Figure 28.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The COLORREF representing the specified color. </P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_SETMCCOLOR</P></TD><TD VALIGN="TOP"><P>Sets the colors used in the drop-down calendar portion of the control. </P></TD><TD VALIGN="TOP"><P>One of the color constants defined in Figure 28. </P></TD><TD VALIGN="TOP"><P>The COLORREF specifying the new color. </P></TD><TD VALIGN="TOP"><P>The previouslI selected color for the index specified by wParam.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_GETMONTHCAL</P></TD><TD VALIGN="TOP"><P>Retrieves the window handle of the drop-down calendar portion of the Date/Time Picker control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>The HWND of the calendar drop-down. The calendar drop-down is not static. The control creates and destroys this window as needed, so do not rely on this value.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_GETRANGE</P></TD><TD VALIGN="TOP"><P>Retrieves the allowable range of dates that the Date/Time Picker uses. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Pointer to a two-element array of SYSTEMTIME structures. </P></TD><TD VALIGN="TOP"><P>A DWORD that is a combination of the GDTR_MIN and GDTR_MAX flags. If GDTR_MIN is set, then the first element of the array contains the minimum allowable time. If GDTR_MAX is set, then the second element contains the maximum allowable time.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_SETRANGE</P></TD><TD VALIGN="TOP"><P>Sets the range of allowable dates for the Date/Time Picker control. </P></TD><TD VALIGN="TOP"><P>Any combination of the GDTR_MIN and GDTR_MAX flags. If GDTR_MIN is specified, the first element of the SYSTEMTIME array specifies the minimum allowable time. If GDTR_MAX is specified, the second element of the array specifies the maximum allowable time.</P></TD><TD VALIGN="TOP"><P>Pointer to a two-element array of SYSTEMTIME structures. </P></TD><TD VALIGN="TOP"><P>BOOL value indicating  success or failure.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_GETSYSTEMTIME</P></TD><TD VALIGN="TOP"><P>Retrieves the date and time currently set in the Date/Time Picker control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>A pointer to a SYSTEMTIME structure.</P></TD><TD VALIGN="TOP"><P>GDT_VALID if the time information was successfully placed in the given structure. GDT_NONE if the control has the DTS_SHOWNONE style and the control check box was unchecked. GDT_ERROR if an error occured.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_SETSYSTEMTIME</P></TD><TD VALIGN="TOP"><P>Sets the date and time in the Date/Time Picker control. </P></TD><TD VALIGN="TOP"><P>If set to GDT_VALID, sets the control according to the data within the structure that lParam points to. If set to GDT_NONE, sets the control to "no date" and clears its check box. The GDT_NONE flag only applies to controls that have the DTS_SHOWNONE style.</P></TD><TD VALIGN="TOP"><P>Pointer to a SYSTEMTIME structure that contains the desired time to set the control to. </P></TD><TD VALIGN="TOP"><P>BOOL value indicating success or failure. </P></TD></TR><TR><TD VALIGN="TOP"><P> DTM_SETFORMAT</P></TD><TD VALIGN="TOP"><P>Sets the format string for the Date/Time Picker control. </P></TD><TD VALIGN="TOP"><P>Not used.</P></TD><TD VALIGN="TOP"><P>Pointer to a zero-terminated string specifying the format string. If this is NULL, then the control will use the date or time format specified in the local settings.</P></TD><TD VALIGN="TOP"><P></P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 30  Date/Time Picker Notification Codes</B></P>

<TABLE COLS="4" BORDER="0"><COLGROUP><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="180pt" VALIGN="TOP"><COL WIDTH="117pt" VALIGN="TOP"><COL WIDTH="99pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Notification Code</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD><TD VALIGN="TOP"><P><B>lParam</B></P></TD><TD VALIGN="TOP"><P><B>Return Value</B></P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_CLOSEUP</P></TD><TD VALIGN="TOP"><P>Sent when the drop-down calendar portion of the control is about to be closed.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMHDR structure.</P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_DATETIMECHANGE</P></TD><TD VALIGN="TOP"><P>Sent by the control whenever the user changes the date or time in the control.  Notification is not sent if the control is  programmatically changed using the DTM_SETSYSTEMTIME message.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMDATETIMECHANGE structure. </P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_DROPDOWN</P></TD><TD VALIGN="TOP"><P>Sent when the drop-down calendar  portion of the control is about to be displayed.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMHDR structure.</P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_FORMAT</P></TD><TD VALIGN="TOP"><P>Sent when the control is requesting formatted text for a callback field. pszFormat contains the callback field substring. The application must place the formatted text in szDisplay or set pszDisplay to point to a zero- terminated string that contains the formatted text.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMDATETIMEFORMAT structure.</P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_FORMATQUERY</P></TD><TD VALIGN="TOP"><P>Sent when the control is requesting the maximum allowable size for a callback field. pszFormat contains the callback field substring. The application must  calculate the maximum possible width  of the formatted string, place that value in szMax, and return zero.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMDATETIMEFORMAT-QUERY structure. </P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_USERSTRING</P></TD><TD VALIGN="TOP"><P>Sent by the control after the user has finished editing text in the edit control. This notification is only sent by Date/Time Picker controls that have the DTS_CANPARSE style.</P></TD><TD VALIGN="TOP"><P>Pointer to an NMDATETIMESTRING structure.</P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR><TR><TD VALIGN="TOP"><P> DTN_WMKEYDOWN</P></TD><TD VALIGN="TOP"><P>Sent by the control when the user has provided keyboard input in a callback field. The NMDATETIMEWMKEYDOWN structure contains information about the  keyboard event, the affected format string, and the current date and time of the control.</P></TD><TD VALIGN="TOP"><P>The lParam points to an NMDATETIMEWMKEY-DOWN structure. </P></TD><TD VALIGN="TOP"><P>Must be zero.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H2><A NAME="sec6"></A>  Conclusion</H2><P>Custom draw is useful for applications that want to tweak the drawing process without having to fully implement owner draw controls. The CoolBar, ComboBoxEx, and the Date/Time Picker are all useful new controls that should help bring more consistency to the application's look and feel.</P>
<P>Next month I will cover the enhanced ListView, TreeView, Header, Progress Bar, and Toolbar controls. Some of the enhancements are minor, such as new flat-look style bits for the Toolbar, while others are major, such as the virtual mode of the ListView (which allows you to commit the GUI blunder of placing a zillion items in a listbox-style control).</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright </I>©<I> 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P><I>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</I></P>
<P></P></font></body></HTML>
