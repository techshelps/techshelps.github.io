<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Write a Simple HTTP-based Server Using MFC and Windows Sockets</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Write a Simple HTTP-based Server Using MFC and Windows Sockets</H1><P>David Cook</P>
<P>David Cook is an independent software vendor who consults for Microsoft as a program manager in the Personal Systems Division. He can be reached at davepc2@oz.net.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4571">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the WEBSTER project files.</A></P><P> Special thanks to Mike Ahern for his suggestions and encouragement in the writing of this article.</P>
<P>Everybody and anybody these days is navigating the vast reaches of the World WideWeb.Whenpeopleget excited about the Web, they usually think in terms of searching forinformationorbrowsinghome shopping catalogs. But what if instead of being a Web consumer, you want to be a provider?</P>
<P>You may be surprised how easy it is to write a Web server. While the server I'll present here, Webster, is without question a bare-bones "baby" server, you can nevertheless use it to present your very own personal home page that anyone on the Web can browse. You can use Webster to advertise your consulting services or your cousin's auto repair shop. More important, Webster illustrates some of the basic techniques of Internet programming. By the time you read this, you'll be a certified Webnerd, able to converse fluently about TCP/IP, HTTP, HTML, URLs, and UFOs (just kidding).</P>
<P> </P>
<H2><A NAME="sec0"></A>  How Does the Web Work?</H2><P>Before delving into Webster, let me give you a quick Web primer. Most of you have probably used a Web browser such as Netscape, NCSA Mosaic or the Microsoft Internet Explorer, which comes with the Windows 95 Plus! pack. You click here, click there, hopping from place to place to visit pages like the one in <B>Figure 1</B>. But what's going on behind the scenes to display those pages? Where does your computer get the page from? How does it arrive? What sort of information travels over the wire?</P>
<P><img src="SOCK1.gif"></P>
<P><B> Figure 1  Webster's home page.</B></P>
<P>The Web was designed as an easy visual interface for navigating the Internet. But this presents a communications problem, because as everyone knows, pictures require a lot more information than words. Even compressed, most imagestaketens,ifnothundreds of kilobytes. In the not-too-distant future, when everyone has their own ISDN line, bandwidth won't be a problem. But for now, many people are still surfing at 14.4 kbaud. So how do you get the pictures to the masses without making them wait until their hair turns gray?</P>
<P>To address this bandwidth problem, Web pages are not transmitted all at once, but are instead built from several transactions. The basic idea is to transmit the text portion of the page first, with information about what graphics go where and where to find them on the server. A browser can display the basic page quickly, then retrieve the graphics separately. Meanwhile, the user can read the page or jump to another one. If the user wants to visit another page before seeing all the images of the current page, the browser can simply forget about the graphics and go directly to the new page.</P>
<P>To see how this works in practice, let's step through a typical Web browsing session. When you crank up your Web browser and call up your favorite home page, your browser program initiates a transaction with another piece of software running on a computer somewhere on the Internet. For the purposes of this discussion, the browser program is the Web client and the software running on the other computer is the Web server. </P>
<P>The action begins when the client initiates a connection by attempting to contact the Web server on the host computer specified in the URL. URL stands for Uniform Resource Locator, which is a fancy name for an Internet address. You know, those names like http://msj.com/things.to.do/kill.barney.now. A URL is a string that fully identifies an information resource on the Internet. There are two basic elements to a URL: a scheme, followed by a "scheme-specific-part." The scheme identifies the method or service by which the scheme-specific-part is accessed. For Web pages, the scheme is HTTP—the message protocol that Web clients and servers use to talk to one another— which is why Web pages always have URLs that begins with"http:".OtherschemesincludeFTP, Wais, and Gopher. </P>
<P>The scheme-specific-part of the URL varies depending on the scheme. For HTTP, it normally contains a host HTTP server name and path to an HTML document on that server. Many Web servers support several schemes. Each of these information exchange schemes has its own protocols, but to provide "one stop shopping," many Internet sites run a single server that integrates all the services into one manageable facility. Each service on a multiservice server is assigned its own port number. By convention, HTTP clients connect on port 80. Any Web client seeking to contact a Web server on a given host system knows that this is the port number on which to make the connection. Other services use other ports; for example, Gopher uses port 70.</P>
<P>When the server acknowledges the connection, the client sends a request for information and waits for the server to reply. Typically, the client begins by requesting a home page on the server's host computer. Assuming everything goes smoothly, the server transmits the resource back to the client, then closes the connection. The transaction is complete. The server goes back to waiting for another connection request.</P>
<P>On the client side, things have just begun. Typically, the home page contains references to graphic images contained within the page. As the client processes the page, it may initiate more transactions with the server to get additional resources. For example, suppose your home page contains a bitmap image of your company logo. The Web browser will identify the reference to this element in the home page and understand that it needs to contact the server again to get the logo. The browser makes another request in the same manner, this time asking for the image file containing the logo. From the server's point of view, this is just another request for a file, no different from the first one. The server finds the file and transmits it back to the client browser, which draws the graphic in the appropriate location on the display. <B>Figure 2</B> illustrates how the page is assembled in this fashion.</P>
<P><img src="SOCK2.gif"></P>
<P><B> Figure 2  Assembling a Web Page Using Separate Transactions</B></P>
<P>The point is that the whole page isn't transmitted at once. A Web page may contain many graphics and other elements that consume hundreds of kilobytes, but the browser doesn't have to download the whole shebang to display something. Most Web browsers display the text of a Web page as soon as it arrives, then download additional elements as required. Meanwhile, you can read the page. And if you decide to jump somewhere else, you don't have to wait while the browser downloads 300KB. The browser can simply forget about the current page and start downloading a new one. That is, if it's a smart browser. Dumb browsers might make you wait. But either way, you can appreciate the clever scheme whereby Web pages are assembled using separate transactions with the server.</P>
<P> </P>
<H2><A NAME="sec1"></A>  HTML</H2><P>When the browser gets a home page with references to graphics instead of actual graphics, what does it actually get? What does the information look like that comes over the wire? What exactly are Web pages? </P>
<P>Simply put, a Web page is an HTML document. HTML (Hypertext Markup Language) is a special flavor of the more general SGML (Standard Generalized Markup Language), a generic document-description language that's been around since the 1980s. It's elegant in its simplicity, yet flexible enough to create powerful visual effects. Here's what the home page for <B>Figure 1</B> looks like in HTML.</P>
<P> </P>
<P><BR></P>
<PRE> &lt;html&gt;
&lt;head&gt;
&lt;title&gt;The Webster Server&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;body background="sky.jpg"&gt;
&lt;h1&gt;&lt;center&gt;Welcome to Webster's Home Page&lt;/center&gt;&lt;/h1&gt;
&lt;hr&gt;
&lt;h3&gt;
&lt;img src="uc.gif" alt="I'm under construction!" align="bottom"&gt;
Please contact the 
&lt;a href="mailto:msj-publ@mfi.com"&gt;Microsoft Systems Journal&lt;/a&gt;
 for more info...&lt;p&gt;
&lt;center&gt;&lt;i&gt;or&lt;/i&gt;&lt;/center&gt;&lt;br&gt;
You may visit the Microsoft Systems Journal 
&lt;a href=http://www.mfi.com/msj/msjtop.html&gt;Web Site&lt;/a&gt;!&lt;br&gt;
&lt;/h3&gt;
&lt;/body&gt;
&lt;/html&gt;</PRE>
<P> </P>
<P>Before I describe what it all means, look how small this file is: only 503 bytes! That's all the server has to transmit before the browser can display something. But despite its small size, this rather typical Web page illustrates some powerful HTML features. The line </P>
<P> </P>
<P><BR></P>
<PRE> &lt;body background="sky.jpg"&gt;</PRE>
<P> </P>
<P>tells the browser to use the file SKY.JPG (on the current server) to tile the background. When the browser sees this, it requests the file from the server, then tiles copies of it on the background of the document window. Of course, the browser doesn't have to do that. You could write a browser with a configurable option like "Display background textures?", which, if the user set to No, would tell the browser to ignore background images and just display a flat background using the default window color (that is, GetSysColor(COLOR_WINDOW)). A little further down, the line</P>
<P> </P>
<P><BR></P>
<PRE> &lt;imgsrc="uc.gif"alt="I'munderconstruction!"align="bottom"&gt;</PRE>
<P> </P>
<P>tells the browser to display the image UC.GIF bottom-aligned with the text that follows. The browser knows to initiate another server transaction to fetch the file UC.GIF. The alt= tag tells the browser to display the text "I'm under construction!"until the image arrives. Many browsers display a generic "image goes here" icon as a placeholder for images that haven't been retrieved yet.</P>
<P>The next two items of interest are references to other URLs. As you can see in <B>Figure 1</B>, the phrases "Microsoft Systems Journal" and "Web Site" have hotlinks. The first link</P>
<P> </P>
<P><BR></P>
<PRE> &lt;a href="mailto:msj-publ@mfi.com"&gt; </PRE>
<P> </P>
<P>refers to an email address. You can tell because the URL scheme is mailto, not HTTP. When the user clicks on "Microsoft Systems Journal," the browser knows to launch email with a new message to msj-publ@mfi.com. The second hotlink </P>
<P> </P>
<P><BR></P>
<PRE> &lt;a href=http://www.mfi.com/msj/msjtop.html&gt;</PRE>
<P> </P>
<P>refers to another HTML document at a completely different Web site. If the user clicks on "Web Site," the browser knows to initiate a transaction with the server www.mfi.com to request the file /msj/msjtop.html.</P>
<P>It's the browser's responsibility to underline or otherwise highlight the text associated with these references, detect when the user has clicked one of them, and take the appropriate action. HTML leaves room for browsers to interpret things. For example, the browser can use whatever font and attributes it wants to display both normal and highlighted text—or let the user choose.</P>
<P>I hope you can begin to see how powerful HTML is. You can create fairly sophisticated Web pages just using graphic images and hotlinks. The references can point to any kind of network resource, not just other HTML documents. There's a lot more I haven't shown you. HTML has tags for describing all kinds of binary data, data entry forms, and even techniques for executing applications independent of the Web server itself, capabilities that can be combined to yield some amazing results. I should warn you that HTML is a rapidly evolving standard. The current official version is 2.0; however, some Web browser and server manufacturers have proposed and implemented a number of draft extensions, which the Internet Engineering Task Force (IETF, the regulating body for HTML), is working to approve in version 3.0.</P>
<P> </P>
<H2><A NAME="sec2"></A>  HTTP</H2><P>Now that you understand the overall roles of Web clients and servers, and know a little about HTML files, let's delve deeper into the details of how Web clients and servers actually communicate. HTML describes what is exchanged; HTTP describes how it's exchanged. More precisely, HTTP describesthe format of client requests and server responses.</P>
<P>Let's start with the client's request. An HTTP server needs to know two essential items: what information the client wants and what action to take on it. The what part of the request is usually an HTML document or a graphic file; the action (or "method") tells the server what to do with it. The most common method is GET, which simply transmits the resource to the client. <B>Figure 3</B> shows some other methods. The resource name and method are the two most basic pieces of information in every HTTP request. A request that contains only these two items is sometimes called a simple HTTP request.</P>
<P> </P>
<P><BR></P>
<PRE> GET sky.jpg</PRE>
<P><B> Figure 3  HTTP Client Request Methods</B></P>
<P></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="351pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Method</B></P></TD><TD VALIGN="TOP"><P><B>Action</B></P></TD></TR><TR><TD VALIGN="TOP"><P> GET</P></TD><TD VALIGN="TOP"><P>Retrieve data specified in the URL</P></TD></TR><TR><TD VALIGN="TOP"><P> HEAD</P></TD><TD VALIGN="TOP"><P>Return HTTP server response header informationonly</P></TD></TR><TR><TD VALIGN="TOP"><P> POST</P></TD><TD VALIGN="TOP"><P>Send information to the HTTP server for further action</P></TD></TR><TR><TD VALIGN="TOP"><P> PUT</P></TD><TD VALIGN="TOP"><P>Send information to the HTTP server for storage</P></TD></TR><TR><TD VALIGN="TOP"><P> DELETE</P></TD><TD VALIGN="TOP"><P>Delete the resource specified in the URL</P></TD></TR><TR><TD VALIGN="TOP"><P> LINK</P></TD><TD VALIGN="TOP"><P>Establish one or more link relationships between specified URLs</P></TD></TR></TBODY></TABLE>
<P><BR></P><P> </P>
<P>In the old days of HTTP version 0.9, this is all you could do. Nowadays, almost everybody speaks HTTP 1.0, which lets clients supply additional information to tell the server more about the client's capabilities. Here's the full request that the Internet Explorer sends my Webster server to get the file SKY.JPG:</P>
<P><BR></P>
<PRE> GET sky.jpg HTTP/1.0
Accept: image/x-xbitmap, image/jpeg, image/gif
Accept-Language: en
User-Agent: Microsoft Internet Explorer/
   2.0beta [Windows 95]
Connection: Keep-Alive
Referer: http://dave95/
If-Modified-Since: Sun, 21 Oct 1995 19:25:23 GMT</PRE>
<P> </P>
<P>The first line looks like an old-style version 0.9 GET request, with the addition of HTTP/1.0 at the end, which is the server's cue that this is a version 1.0 request, and contains additional lines that follow. A double carriage return or linefeed pair indicates the end of a response header. In this particular example, the Internet Explorer tells Webster that it can handle X-Windows bitmaps, JPEG and GIF image files, that it's an English-based system, that it's the Internet Explorer running on Windows 95, and that the request was made from the client machine named "dave95." The last line tells the server that it should only GET the file if it was modified since the date and time given. Explorer has already downloaded this file, and doesn't need to get a new copy unless it's changed.</P>
<P>During the course of a connect session, the extra header fields vary from transaction to transaction, but the purpose is always the same: to give the server as much information about the client as possible. If the server knows, for example, that the client can't handle TIF images, it won't bother sending any.</P>
<P>Once the server gets a client request, its job is quite simple: locate the resource and do what the client asked (servers aim to please, that's why they're called servers). In the case of the simple GET request, this means get the file called SKY.JPG and transmit it to the client. Assuming the file exists and the client has permission to see it, here's how Webster responds to the Internet Explorer's GET request.</P>
<P> </P>
<P><BR></P>
<PRE> HTTP/1.0 200 OK
Date: Sunday Sun, 21 Oct 1995 19:38:46 GMT
Server: Webster/1.0
MIME-version: 1.0
Content-type: image/jpg
Last-modified: Sun, 21 Oct 1995 8:07:14 GMT
Content-length: 3150</PRE>
<P> </P>
<P>Following this reply header, Webster transmits the 3150 bytes of binary data (as indicated in the Content-length field) in the file SKY.JPG. As with the client request, the first response line contains the most important information: whether the request succeeded or not. The first element identifies the response as an HTTP version 1.0 format, and the second element is the response status code. Following that is a text description of the status code, in this case "OK." <B>Figure 4</B> shows some typical response codes and what they generally mean; <B>Figure 5</B> shows how the codes are grouped.</P>
<P><B> Figure 4  Some Common HTTP Response Codes</B></P>
<P></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="342pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Code</B></P></TD><TD VALIGN="TOP"><P><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP"><P> 200</P></TD><TD VALIGN="TOP"><P>URL located, transmission follows</P></TD></TR><TR><TD VALIGN="TOP"><P> 400</P></TD><TD VALIGN="TOP"><P>Unintelligible request</P></TD></TR><TR><TD VALIGN="TOP"><P> 404</P></TD><TD VALIGN="TOP"><P>Requested URL not found</P></TD></TR><TR><TD VALIGN="TOP"><P> 405</P></TD><TD VALIGN="TOP"><P>Server does not support requested method</P></TD></TR><TR><TD VALIGN="TOP"><P> 500</P></TD><TD VALIGN="TOP"><P>Unknown server error</P></TD></TR><TR><TD VALIGN="TOP"><P> 503</P></TD><TD VALIGN="TOP"><P>Server capacity reached</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 5  HTTP Response Code Groups</B></P>
<P></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="342pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Group</B></P></TD><TD VALIGN="TOP"><P><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP"><P> 200–299</P></TD><TD VALIGN="TOP"><P>Success</P></TD></TR><TR><TD VALIGN="TOP"><P> 300–399</P></TD><TD VALIGN="TOP"><P>Information</P></TD></TR><TR><TD VALIGN="TOP"><P> 400–499</P></TD><TD VALIGN="TOP"><P>Request error</P></TD></TR><TR><TD VALIGN="TOP"><P> 500–599</P></TD><TD VALIGN="TOP"><P>Server error</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The other lines in the reply header give additional information to help the client interpret the data. For example, the MIME-version and Content-type fields tell the client that data is of the MIME version 1.0 type "image/jpg" (a JPEG compressed image). The MIME (Multipurpose Internet Mail Extensions) standard defines a number of data types. RFC 1049 states that the Content-type should "describe the data contained in the body fully enough that the receiving user agent can pick an appropriate agent or mechanism to present the data to the user, or otherwise deal with the data in an appropriate manner." (Internet Request For Comment documents contain proposals for new standards (or the de facto standard), and your opinion is invited. You can access the RFCs at http://ds.internic.net/rfc/.) <B>Figure 6</B> shows some common MIME data types. The MIME Content-type contains both a major type and a subtype. In the example, the major type is "image," indicating that the data is a picture of some sort; the subtype is jpeg, indicatingit'sinJPEGformat. Describing the information in advance spares the client the trouble of examining the data to render it. This makes for faster browsers.</P>
<P><B> Figure 6  Sample MIME Data Types</B></P>
<P></P>

<TABLE COLS="3" BORDER="0"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="76pt" VALIGN="TOP"><COL WIDTH="288pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Object Type</B></P></TD><TD VALIGN="TOP"><P><B>Subtype</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> application</P></TD><TD VALIGN="TOP"><P>msword</P></TD><TD VALIGN="TOP"><P>Microsoft Word document</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>postscript</P></TD><TD VALIGN="TOP"><P>Postscript document</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>rtf</P></TD><TD VALIGN="TOP"><P>Rich Text Format document</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>zip</P></TD><TD VALIGN="TOP"><P>PKZIP compressed file</P></TD></TR><TR><TD VALIGN="TOP"><P> image</P></TD><TD VALIGN="TOP"><P>gif</P></TD><TD VALIGN="TOP"><P>CompuServe GIF format</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>jpeg</P></TD><TD VALIGN="TOP"><P>JPEG format</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>x-xbitmap</P></TD><TD VALIGN="TOP"><P>X Window bitmap format</P></TD></TR><TR><TD VALIGN="TOP"><P> message</P></TD><TD VALIGN="TOP"><P>RFC822</P></TD><TD VALIGN="TOP"><P>Mail message</P></TD></TR><TR><TD VALIGN="TOP"><P> text</P></TD><TD VALIGN="TOP"><P>html</P></TD><TD VALIGN="TOP"><P>HTML</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>plain</P></TD><TD VALIGN="TOP"><P>Unformatted text</P></TD></TR><TR><TD VALIGN="TOP"><P> video</P></TD><TD VALIGN="TOP"><P>mpeg</P></TD><TD VALIGN="TOP"><P>MotionPicturesExpertGroupformat</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>quicktime</P></TD><TD VALIGN="TOP"><P>Apple QuickTime format</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>x-msvideo</P></TD><TD VALIGN="TOP"><P>Microsoft Video format</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>avi</P></TD><TD VALIGN="TOP"><P>Microsoft AVI format</P></TD></TR><TR><TD VALIGN="TOP"><P> audio</P></TD><TD VALIGN="TOP"><P>basic</P></TD><TD VALIGN="TOP"><P>8-bit ISDN audio file</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>wav</P></TD><TD VALIGN="TOP"><P>Microsoft WAV format</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>The Last-modified field tells the client when the data was last changed, so it can decide whether to use information it might have cached locally, or wait to receive new data.</P>
<P>I've only described the GET method and some of the most common attributes found in Web requests and responses. Obviously, there's a lot more to HTTP than that. My purpose here is not to give a full treatment of HTTP, but only cut a swath deep and wide enough to write Webster. </P>
<P> </P>
<H2><A NAME="sec3"></A>  CGI, BGI, Java, LiveScript</H2><P>While it's beyond the scope of this article to discuss them fully, I should at least mention some of the current extensions to HTTP, if only to keep you abreast of the latest acronyms. By itself HTTP only specifies the way static information is requested and delivered. With the demand for ever more interactive Web applications, Web gurus have invented a number of extensions. Strictly speaking, these protocols fall outside the definition of HTTP.</P>
<P>CGI, Common Gateway Interface, was the first and most primitive way of providing "server-side support." The client sends a number of parameters like NAME="Dave Cook", CreditCardID=1234-5678-0000-0000, and so on. The server uses these to set environment variables on the host, then runs a custom-written program (often a shell script on UNIX systems) that looks for these environment variables and does something with them. Environment variables were chosen as the means for parameter-passing because most operating systems support them in some form. The downside of passing information this way is that it's inefficient and a bit arcane, as each program must be written to accept certain predefined environment variables, and the client must know a priori what they are.</P>
<P>BGI, Binary Gateway Interface, provides another way of invoking a server process. Instead of setting environment variables, the server calls a program or DLL directly on the client's behalf. On a Windows-based system, a BGI implementation might be a DLL with a predefined API. The server, upon receiving a request for a BGI transaction, loads the DLL and calls the requested function with arguments supplied by the client. The Microsoft Internet Information Server (codenamed The Internet Information Server) handles BGI this way (see page 50). This implementation of BGI is defined as the Internet Server Application Programming Interface (ISAPI). It's more efficient than CGI.</P>
<P>Java is a programming language from Sun Microsystems that provides a general means to download applications from the server and run them on the client computer. Java uses a p-code implementation where each client has an interpreter that can run Java programs.</P>
<P>Another programming language, Netscape's LiveScript, is similar to Java, without Java's static typing and strong type-checking. LiveScript supports most of Java's expression syntax and basic control flow constructs. In contrast to Java's compile-time system of classes built by declarations, LiveScript supports a run-time system based on a small number of primitive types.</P>
<P> </P>
<H2><A NAME="sec4"></A>  Webster</H2><P>Now I'll show you how I wrote Webster in MFC (see <B>Figure 7</B>). Webster is an outgrowth of my own research into the Web. As I was exploring HTML, HTTP, URLs and transactions, the basics seemed surprisingly straightforward. It didn't seem like it would be all that hard to write a Web server. After all, the only thing a server does is sit around waiting for the phone to ring, and when it does, it transmits a file or two over the line. (Browsers, on the other hand are more complex: they have to display text and images, manage hotlinks, parse HTML files, and so on.) </P>
<P><B> Figure 7  Webster Code Highlights</B></P>
<P></P>
<P>CCLIENT.H </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// CClient.h : interface of the CClient class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
#ifndef __CCLIENT_H__
#define __CCLIENT_H__

#include "logger.h"     // COMLOGREC

class CWebDoc;

class CClient : public CSocket {
   DECLARE_DYNAMIC(CClient);
private:
   CClient(const CClient&amp; rSrc); // no implementation
   void operator=(const CClient&amp; rSrc);   // no implementation

public:
   CClient(CWebDoc* m_pDoc);
   virtual ~CClient();

   // These are used for providing the HTTP service
   CWebDoc*       m_pDoc ;       // we use this quite a bit
   BOOL           m_bDone ;      // set when we're done
   CString        m_PeerIP ;     // requestor's IP address
   UINT           m_Port ;       // port we're connected to
   struct hostent*   m_pHE ;     // for resolving client name
   CString        m_PeerName ;   // resolved client name
   COMLOGREC      m_LogRec ;     // Common Log Format log record

   // These are used for servicing the request
   char           *m_buf ;       // current receive buffer
   DWORD          m_irx ;        // index into receive buffer
   CStringList    m_cList ;      // list of request strings
   BOOL           m_bHTTP10 ;    // HTTP 1.0 format?
   CString        m_cURI ;       // requested file name
   CString        m_cLocalFNA ;  // constructed (local) file name
   enum METHOD_TYPE              // the HTML request methods
   {
      METHOD_UNSUPPORTED = 0,
      METHOD_GET,
      METHOD_POST,
      METHOD_HEAD,
      METHOD_PUT,
      METHOD_DELETE,
      METHOD_LINK,
      METHOD_UNLINK
   } m_nMethod ;

   struct _tagMethodTable {
      enum METHOD_TYPE  id;
      char              *key;
   };
   CSocketFile*   m_pFile;    // socket file for reply

   // service handling operations
   BOOL ProcessPendingRead() ;
   void ParseReq() ;
   void ProcessReq() ;
   BOOL SendReplyHeader ( CFile&amp; cFile ) ;
   void SendTag() ;

   // service response
   BOOL SendFile ( CString&amp; SendFNA, CString&amp; BaseFNA,
                   BOOL bTagMsg = FALSE ) ;
   BOOL SendCGI ( CString&amp; SendFNA, CString&amp; BaseFNA ) ;

   // send-to-client
   BOOL SendRawData ( LPVOID lpszMessage, int count ) ;
   BOOL SendData ( LPCSTR lpszMessage ) ;
   BOOL SendData ( CString&amp; cMessage ) ;
   BOOL SendData ( CFile&amp; cFile ) ;

   // misc utilities
   BOOL ResolveClientName ( BOOL bUseDNS ) ;
   void SendCannedMsg ( int idErr, ... ) ;
   inline struct hostent* GetHostByAddr ( LPCSTR lpszIP ) {
      // translate dotted string format into integer
      int uPeer[4] ;
      sscanf ( lpszIP, "%d.%d.%d.%d",
             &amp;uPeer[0], &amp;uPeer[1], &amp;uPeer[2], &amp;uPeer[3] ) ;

      // move it into a char array for ::gethostbyaddr()
      char cPeer[4] ;
      cPeer[0] = uPeer[0] ;
      cPeer[1] = uPeer[1] ;
      cPeer[2] = uPeer[2] ;
      cPeer[3] = uPeer[3] ;
      return ( ::gethostbyaddr ( cPeer, 4, PF_INET ) ) ;
   }

protected:
   virtual void OnReceive(int nErrorCode);
#ifdef   _DEBUG
   virtual void OnSend(int nErrorCode);
   virtual void OnClose(int nErrorCode);
#endif
};

#endif // __CCLIENT_H__
</PRE>
<P>CCLIENT.CPP </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// CClient.cpp : implementation of the CClient class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
#include "stdafx.h"
#include "cclient.h"
#include "webdoc.h"
#include "resource.h"   // IDS_ id's
#include "webster.h" // CWebApp
#include "mainfrm.h" // CMainFrame

// CClient Construction

CClient::CClient(CWebDoc* m_pParentDoc)
{
   m_pDoc = m_pParentDoc ; // cache this for lots of use later
   m_bDone = FALSE ;
   m_irx = 0 ;
   m_buf = NULL ;
   m_bHTTP10 = FALSE ;     // assume HTTP 0.9
   m_nMethod = METHOD_UNSUPPORTED ;
   time_t tNow ;
   time ( &amp;tNow ) ;
   CTime cNow ( tNow ) ;
   m_LogRec.datetime = cNow ; // this is our birth date
   m_LogRec.client   = "" ;
   m_LogRec.inetd    = "-" ;
   m_LogRec.username = "-" ;
   m_LogRec.request  = "" ;
   m_LogRec.status   = 200 ;
   m_LogRec.bytes    = 0 ;
   m_pHE = NULL ;
}

CClient::~CClient()
{
   if ( m_buf ) {
      free ( m_buf ) ;
      m_buf = NULL ;
   }
}

// CSocket Implementation

IMPLEMENT_DYNAMIC(CClient, CSocket)

// CClient Overridable callbacks

void CClient::OnReceive(int nErrorCode)
{
   CSocket::OnReceive(nErrorCode);

   // If the read processing was successful, then we've done our job.
   // If not, the service request has not completed yet.
   // Caution: The bDone boolean is used elsewhere,
   //          don't try to tighten up this check.
   if ( ProcessPendingRead() )
   {
      AfxGetMainWnd()-&gt;PostMessage ( WM_NEW_CLIENT,
                              (WPARAM)0,
                              (LPARAM)this ) ;
      // send request off for processing
      ProcessReq() ; // process the request
      m_bDone = TRUE ;
      if ( theApp.m_bLogEnable )
      {
         m_pDoc-&gt;WriteLog ( m_LogRec ) ;
      }
      AfxGetMainWnd()-&gt;PostMessage ( WM_KILL_SOCKET,
                              (WPARAM)0,
                              (LPARAM)this ) ;
   }
}

#ifdef   _DEBUG
// This is called to notify a blocked sender that the socket is unblocked
// now. Not required for retail operation.
void CClient::OnSend(int nErrorCode)
{
   CSocket::OnSend(nErrorCode);

   if ( theApp.m_bDebugOutput ) {
      if ( m_cList.GetCount() == 0 ) {
         m_pDoc-&gt;DbgMessage ( "OnSend:: No request yet.\n" ) ;
         return ; // no request yet, keep reading
      }
      m_pDoc-&gt;DbgMessage ( "OnSend::Ready to send data.\n" ) ;
   }
}

// This is called when the client wants to abort the data download.
// Also not required for retail operation.
void CClient::OnClose(int nErrorCode)
{
   CSocket::OnClose(nErrorCode);
   m_pDoc-&gt;Message ( "OnClose::\n" ) ;
}
#endif   // _DEBUG

// This routine collects the request from the client
BOOL CClient::ProcessPendingRead()
{
// Not all clients can send a block at a time (e.g., telnet). What we're
// doing here is constructing a buffer until we get either a cr/lf pair, or
// until dwBytes to read is zero.
//
// Note that since we've been called from the OnReceive notification
// handler, then if dwBytes is zero, it must mean the client has closed the
// connection.

   DWORD dwBytes ;

   IOCtl ( FIONREAD, &amp;dwBytes ) ;      // anything to get?
   if ( dwBytes == 0 )
      return ( TRUE ) ; // we must be done!

   // allocate, or extend, our buffer - leave room for '\0' at end
   if ( m_irx == 0 ) // first time thru - malloc
      m_buf = (char *)malloc ( dwBytes+1 ) ;
   else           // otherwise - realloc
      m_buf = (char *)realloc ( m_buf, m_irx+dwBytes+1 ) ;
   // (so, like _when_ is C++ gonna support resizeable memory?)

   // get this chunk from the client
   if ( Receive ( &amp;m_buf[m_irx], dwBytes, 0 ) == SOCKET_ERROR ) {
      int err = GetLastError() ;
      if ( err == WSAECONNRESET ) { // remote has terminated (gracefully)
         m_pDoc-&gt;Message ( "WSAECONNERESET\n" ) ;
         return ( TRUE ) ; // must be done!
      }
   }
   m_irx += dwBytes ;   // this much was added to our accumulating buffer

   // This is our socket equivalent of gets()
   // If we return FALSE, it means we need more input
   if ( m_irx &lt; 2 )   // enough to parse?
      return ( FALSE ) ;
   if ( memcmp ( &amp;m_buf[m_irx-2], "\r\n", 2 ) != 0 )  // end of line?
      return ( FALSE ) ;

   // split this request up into the list of lines
   m_buf[m_irx] = '\0' ;   // Make this is an SZ string for parsing.
   char *pBOL = m_buf ;
   for ( char *pEOL = strpbrk ( pBOL, "\r" ) ;
         pEOL ;
         pEOL = strpbrk ( pBOL, "\r" ) ) {
      *pEOL = '\0' ; // make this chunk an SZ string
      m_cList.AddTail ( CString(pBOL,strlen(pBOL)) ) ; // add to list
      *pEOL++ ;      // skip '\0'
      *pEOL++ ;      // skip '\n'
      pBOL = pEOL ;  // point to next text
   }
   m_irx = 0 ;    // reset for next chunk from client
   free ( m_buf ) ;
   m_buf = NULL ;

   // are we in HTTP 1.0 mode yet?
   if ( ! m_bHTTP10 ) {
      if ( m_cList.GetHead().Find ( "HTTP/1.0" ) != -1 )
         m_bHTTP10 = TRUE ;   // we are now...
      else
         return ( TRUE ) ; // we must be done
   }

   // We are definitely in HTTP 1.0 mode now, so look for the terminating
   // empty line. Since we've already stripped off the cr/lf, the length
   // will be zero.
   return ( m_cList.GetTail().GetLength() == 0 ) ;
}  // ProcessPendingRead()

// This is a lookup table for translating the parsed method text string
// into a predefined token value. This token value will be used later
// to dispatch the request to an appropriate handler.
static struct CClient::_tagMethodTable MethodTable[] = {
   { CClient::METHOD_GET   , "GET"    },
   { CClient::METHOD_POST  , "POST"   },
   { CClient::METHOD_HEAD  , "HEAD"   },
   { CClient::METHOD_PUT   , "PUT"    },
   { CClient::METHOD_DELETE, "DELETE" },
   { CClient::METHOD_LINK  , "LINK"   },
   { CClient::METHOD_UNLINK, "UNLINK" },
} ;
static const int MethodTableLen = sizeof(MethodTable)/
                          sizeof(struct CClient::_tagMethodTable) ;

void CClient::ParseReq()
{
   CStringList cList ;  // list of parsed command tokens

   // save the request line for our log record
   if ( m_cList.IsEmpty() ) { // always check IsEmpty() first
      m_pDoc-&gt;DbgVMessage ( "Command list is empty!\nSending 400 error\n" ) ;
      SendCannedMsg ( 400 ) ;
      return ;
   }
   CString cReq = m_cList.GetHead() ;
   m_LogRec.request = cReq ;

   // parse the primary, and most important, request line

   // parse the request line into a list of tokens
   LPSTR tempmsg = new char[cReq.GetLength()+1] ;  // allow for EOS
   strcpy ( tempmsg, cReq ) ;
   char *pBOL = tempmsg ;
   for ( char *pEOL = strpbrk ( pBOL, " " ) ;
        pEOL ;
        pEOL = strpbrk ( pBOL, " " ) ) {
      *pEOL = '\0' ;
      CString tempToken ( pBOL, strlen(pBOL) ) ;
      *pEOL++ ;   // skip '\0'
      pBOL = pEOL ;
      cList.AddTail ( tempToken ) ;
   }
   // save whatever's left as the last token
   CString tempToken ( pBOL, strlen(pBOL) ) ;
   cList.AddTail ( tempToken ) ;
   delete tempmsg ;

   POSITION pos = cList.GetHeadPosition() ;  // prepare to scan the request

   // 1) parse the method
   if ( pos == NULL ) {
      m_pDoc-&gt;DbgVMessage ( "Null request method\nSending 400 error\n" ) ;
      SendCannedMsg ( 400 ) ;
      return ;    
   }
   m_cURI = cList.GetNext ( pos ) ; // pointing to METHOD now
   for ( int i = 0 ; i &lt; MethodTableLen ; i++ ) {
      if ( m_cURI.CompareNoCase ( MethodTable[i].key ) == 0 ) {
         m_nMethod = MethodTable[i].id ;
         break ;
      }
   }
   // 2) parse the URI
   if ( pos == NULL ) {
      m_pDoc-&gt;DbgVMessage ( "Null request URI\nSending 400 error\n" ) ;
      SendCannedMsg ( 400 ) ;
      return ;    
   }
   m_cURI = cList.GetNext ( pos ) ; // pointing to ENTITY now
   m_pDoc-&gt;VMessage ( "   Data request: %s\n", m_cURI ) ;

   // replace UNIX '/' with MS '\'
   for ( i = 0 ; i &lt; m_cURI.GetLength() ; i++ ) {
      if ( m_cURI[i] == '/' )
         m_cURI.SetAt ( i, '\\' ) ;
   }

   // add base path
   if ( m_cURI[0] != '\\' )
      m_cLocalFNA = theApp.m_HTMLPath + CString("\\") + m_cURI ;
   else
      m_cLocalFNA = theApp.m_HTMLPath + m_cURI ;

   // This is a real ugly little hack for MikeAh to use forms/GET
   // I just snarf the rest of the command line from the query
   // separator on...
   if ( ( i = m_cLocalFNA.Find ( '?' ) ) != -1 )
      m_cLocalFNA.GetBufferSetLength ( i ) ;

   // 3) parse the rest of the request lines
   if ( ! m_bHTTP10 )
      return ; // if HTTP 0.9, we're done!

   // parse the client's capabilities here...
   if ( theApp.m_bDebugOutput ) {
      POSITION pos = m_cList.GetHeadPosition() ;
      for ( int i = 0 ; i &lt; m_cList.GetCount() ; i++ ) {
         // For now, we'll just have a boo at them. Being such a simple
         // server, let's not get too concerned with details.
         m_pDoc-&gt;DbgVMessage ( "   %d&gt;%s\n", i+1, m_cList.GetNext ( pos ) ) ;
      }
   }
}  // ParseReq()

// dispatch service handler
void CClient::ProcessReq()
{
   // parse the request
   ParseReq() ;

   // can only handle GETs for now
   if ( m_nMethod != METHOD_GET ) {
      m_pDoc-&gt;VMessage ( "   Unknown method requested: %s\n", m_cURI ) ;
      SendCannedMsg ( 405, m_cURI ) ;
      return ;
   }

   // try to determine the send method based on the file type
   char *ext = strrchr ( m_cLocalFNA, '.' ) ;
   if (  m_cURI == "\\" )  {  // blind request?
      m_pDoc-&gt;DbgVMessage ( "   Blind request\n" ) ;
      if ( ! SendFile ( m_cLocalFNA, m_cURI ) )
         return ; // send failure!

   } else if ( ext ) {        // has an extension?
      *ext++ ; // point to start of file extension
      m_pDoc-&gt;DbgVMessage ( "   File extension: &lt;%s&gt;\n", ext ) ;
      if ( ! SendFile ( m_cLocalFNA, m_cURI ) )
         return ; // send failure!

   } else { // must be a CGI script specification
      m_pDoc-&gt;DbgVMessage ( "   CGI request: %s %s\n", m_cLocalFNA, m_cURI ) ;
      if ( ! SendCGI ( m_cLocalFNA, m_cURI ) ) {
         // ...insert CGI-implementation dependant actions here...
         return ;
      }
   }
   SendTag() ; // Done!!!
}  // ProcessReq()

// CClient Service Response Operations

// this is the built-in list of MIME types we automatically recognize
static struct _tagMIME_Table {
   char  *ext ;
   char  *type ;
} MIME_Table[] = {
   { ".gif" , "image/gif"  },
   { ".jpg" , "image/jpg"  },
   { ".htm" , "text/html"  },
   { ".html", "text/html"  },
   { ".txt" , "text/plain" }
} ;
static const int MIME_len = sizeof(MIME_Table)/sizeof(struct _tagMIME_Table);

BOOL CClient::SendReplyHeader ( CFile&amp; cFile )
{
   if ( ! m_bHTTP10 )   // if HTTP 0.9, response header not used
      return ( TRUE ) ;

   // Response header components:
   // 1 - HTTP 1.0 response header
   // 2 - Server time
   // 3 - Server version
   // 4 - MIME version
   // 5 - MIME type
   // 6 - Last-modified time
   // 7 - Content length
   // 8 - HTTP 1.0 End-of-header

   CString  tmp ;
   if ( ! SendData ( "HTTP/1.0 200 OK\r\n" ) )
      return ( FALSE ) ;   // skate from here...

   CTime rTime = CTime::GetCurrentTime() ;
   tmp.Format ( "Date: %s\r\n",
            rTime.FormatGmt("%a, %d %b %Y %H:%M:%S %Z") ) ;
   SendData ( tmp ) ;
   SendData ( "Server: Webster/1.0\r\n" ) ;
   SendData ( "MIME-version: 1.0\r\n" ) ;

   char ext[5] ;
   _splitpath ( cFile.GetFileName(), NULL, NULL, NULL, ext ) ;
   tmp = ext ;
   for ( int i = 0 ; i &lt; MIME_len ; i++ ) {
      if ( tmp.CompareNoCase ( MIME_Table[i].ext ) == 0 ) {
         SendData ( "Content-type: " ) ;
         SendData ( MIME_Table[i].type ) ;
         SendData ( "\r\n" ) ;
         break ;
      }
   }
   CFileStatus rStatus ;
   if ( cFile.GetStatus ( rStatus ) ) {
      tmp.Format ( "Last-modified: %s\r\n",
               rStatus.m_mtime.FormatGmt("%a, %d %b %Y %H:%M:%S %Z") ) ;
      SendData ( tmp ) ;
   }
   tmp.Format ( "Content-length: %d\r\n", cFile.GetLength() ) ;
   SendData ( tmp ) ;
   SendData ( "\r\n" ) ;   // end-of-header
   return ( TRUE ) ;
}  // SendReplyHeader()

void CClient::SendTag()
{
   // send our personalized message
   CString tagmsg ;
   BOOL ret = TRUE ;
   switch ( theApp.m_nTagType ) {
      case CWebApp::TAG_AUTO:
         tagmsg.LoadString ( IDS_TAGSTRING ) ;
         ret = SendData ( tagmsg ) ;
         m_pDoc-&gt;Message ( " Sent auto tag\n" ) ;
         break ;
      case CWebApp::TAG_FILE:
         tagmsg = theApp.m_HTMLPath + CString("\\") + theApp.m_HTMLTag ;
         ret = SendFile ( tagmsg, theApp.m_HTMLTag, TRUE ) ;
         break ;
      case CWebApp::TAG_NONE:
         m_pDoc-&gt;Message ( " No tag\n" ) ;
         break ;
   }
   tagmsg.LoadString ( IDS_TAGCOMMENT ) ;
   if ( ret )
      SendData ( tagmsg ) ;
}  // SendTag()

// URI file handler
BOOL CClient::SendFile(CString&amp; m_cLocalFNA, CString&amp; BaseFNA, BOOL bTagMsg)
{
   CFile cFile ;
   BOOL FoundIt ;

   // if our request isn't empty, then try to open the file specified
   if ( m_cLocalFNA != theApp.m_HTMLPath + CString("\\") ) {
      m_pDoc-&gt;DbgVMessage ( "Attempting to open: %s\n", m_cLocalFNA ) ;
      FoundIt = cFile.Open ( m_cLocalFNA,
                             CFile::modeRead | CFile::typeBinary ) ;

   } else { // otherwise, it was a blind access. send the default file
      m_pDoc-&gt;DbgMessage ( "Blank request, trying Default - " ) ;
      m_cLocalFNA = theApp.m_HTMLPath
                  + CString("\\")
                  + theApp.m_HTMLDefault ;
      FoundIt = cFile.Open ( m_cLocalFNA,
                        CFile::modeRead | CFile::typeBinary ) ;
      // if our configuration settings are hosed, use emergency plan 'B'
      if ( ! FoundIt ) {
         m_pDoc-&gt;DbgVMessage ( "Couldn't find: %s\nTrying Bogus - ",
                           m_cLocalFNA ) ;
         m_cLocalFNA = theApp.m_HTMLPath + CString("\\")
                     + theApp.m_HTMLBogus ;
         FoundIt = cFile.Open ( m_cLocalFNA,
                                CFile::modeRead | CFile::typeBinary ) ;
      }
   }
   if ( ! FoundIt ) {
      m_pDoc-&gt;DbgVMessage ( "Couldn't find: %s\nSending 404 error\n",
                        m_cLocalFNA ) ;
      SendCannedMsg ( 404, BaseFNA ) ;
      return ( TRUE ) ;;
   }
   m_pDoc-&gt;DbgMessage ( "\n" ) ; // make debug msg readable

   // we found a file, so send it already...
   m_pDoc-&gt;VMessage ( "   Sending: %s\n", m_cLocalFNA ) ;
   BOOL ret = TRUE ;
   if ( ! bTagMsg )  // if tag message, skip the response header
      ret = SendReplyHeader ( cFile ) ;
   if ( ret )
      ret = SendData ( cFile ) ;
   cFile.Close() ;
   return ( ret ) ;
}  // SendFile()

// CGI handler

BOOL CClient::SendCGI ( CString&amp; m_cLocalFNA, CString&amp; BaseFNA )
{
   // This is a hook for future development. Just send 404 error for now.
   SendCannedMsg ( 404, BaseFNA ) ;
   return ( TRUE ) ;
}

// Data transmission operations

// this is for sending our own info and messages to the client
BOOL CClient::SendRawData ( LPVOID lpMessage, int count )
{
   // Use a CSocketFile for pumping the message out
   CSocketFile sockFile ( this, FALSE ) ;
   TRY {
      sockFile.Write ( lpMessage, count ) ;
   } CATCH(CFileException, e) {
      m_pDoc-&gt;VMessage ( "Failed to write raw to client socket!\n" ) ;
      m_pDoc-&gt;VMessage ( "   &gt;&gt;&gt; %s\n", theApp.MapErrMsg(GetLastError()) ) ;
      return ( FALSE ) ;;
   } END_TRY
   sockFile.Flush() ;
   return ( TRUE ) ;
}

// this is for sending a CString message to the client
BOOL CClient::SendData ( CString&amp; cMessage )
{
   return ( SendData ( (LPCTSTR)cMessage ) ) ;
}

// this is for sending a LPSTR message to the client
BOOL CClient::SendData ( LPCSTR lpszMessage )
{
   m_pDoc-&gt;DbgVMessage ( "&gt;&gt;&gt;Sending client message: %s\n", lpszMessage ) ;
   return ( SendRawData ( (LPVOID)lpszMessage, strlen(lpszMessage) ) ) ;
}

// this is for sending file data to the client
#define  BUF_SIZE 4096  // same as default for CSocket as CArchive

BOOL CClient::SendData ( CFile&amp; cFile )
{
   char  buf[BUF_SIZE] ;
   int      nBytes ;

   // Use a CSocketFile for pumping the data out
   CSocketFile sockFile ( this, FALSE ) ;
   while ( ( nBytes = cFile.Read ( buf, BUF_SIZE ) ) &gt; 0 ) {
      TRY {
         sockFile.Write ( (LPVOID)buf, nBytes ) ;
         m_LogRec.bytes += nBytes ;
      } CATCH(CFileException, e) {
         m_pDoc-&gt;VMessage ( "Failed to write data to client socket!\n%s\n",
                              theApp.MapErrMsg(GetLastError()) ) ;
         return ( FALSE ) ;
      } END_TRY
   }
   sockFile.Flush() ;
   return ( TRUE ) ;
}

// CClient Utility Operations

BOOL CClient::ResolveClientName ( BOOL bUseDNS )
{
   if ( ! GetPeerName ( m_PeerIP, m_Port ) ) {
      m_pDoc-&gt;Message ( " Can't get client name\n" ) ;
      return ( FALSE ) ;
   }
   m_LogRec.client = m_PeerIP ;

   if ( bUseDNS ) {
      if ( m_PeerIP == "127.0.0.1" ) { // hey, it's me!!!
         m_LogRec.client = "Local loopback" ;
         m_pDoc-&gt;VMessage ( " Local loopback (%s)\n", m_PeerIP ) ;
      } else {
         if ( m_pHE = GetHostByAddr ( (LPCSTR)m_PeerIP ) ) {
            m_LogRec.client = m_pHE-&gt;h_name ;
            m_pDoc-&gt;VMessage ( " %s (%s)\n", m_pHE-&gt;h_name, m_PeerIP ) ;
         } else {
            int err = WSAGetLastError() ;
            m_pDoc-&gt;VMessage ( " Unable to get host name: %s. Err: %d\n",
                                 m_PeerIP, err ) ;
            return ( FALSE ) ;
         }
      }
   } else {
      m_pDoc-&gt;VMessage ( " %s\n", m_PeerIP ) ;
   }
   return ( TRUE ) ;
}

// table of canned messages that we can handle
static struct _tagMsgTable {
   int   id ;
   int   idStr ;
} MsgTable[] = {
   { 400, IDS_400_MESSAGE },
   { 404, IDS_404_MESSAGE },
   { 405, IDS_405_MESSAGE },
   { 503, IDS_503_MESSAGE }
} ;
static const int MsgTableSize = sizeof(MsgTable)/sizeof(struct _tagMsgTable);

void CClient::SendCannedMsg ( int idErr, ... )
{
   BOOL bGotIt = FALSE ;
   for ( int i = 0 ; i &lt; MsgTableSize ; i++ ) {
      if ( MsgTable[i].id == idErr ) {
         bGotIt = TRUE ;
         break ;
      }
   }
   CString fmt ;
   char  buf[200] ;
   if ( ! bGotIt ) { // idErr is a bogus code!
      fmt.LoadString ( IDS_500_MESSAGE ) ;
      wsprintf ( buf, fmt, idErr ) ;
   } else {
      fmt.LoadString ( MsgTable[i].idStr ) ;
      va_list  ptr ;
      va_start ( ptr, idErr ) ;
      wvsprintf ( buf, fmt, ptr ) ; 
   }
   Send ( buf, strlen(buf), 0 ) ;

   // write log record
   m_LogRec.status = idErr ;
   if ( theApp.m_bLogEnable )
      m_pDoc-&gt;WriteLog ( m_LogRec ) ;

   // write status message
   m_pDoc-&gt;DbgVMessage ( "   Sent %03d status message to client\n", idErr ) ;
}
</PRE>
<P>CLISTEN.H </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// CListen.h : interface of the CListen class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
#ifndef __CLISTEN_H__
#define __CLISTEN_H__

class CWebDoc; // fwd ref

class CListen : public CSocket {
   DECLARE_DYNAMIC(CListen);
private:
   CListen(const CListen&amp; rSrc);         // no implementation
   void operator=(const CListen&amp; rSrc);  // no implementation

public:
   CListen(CWebDoc* pDoc);
   virtual ~CListen();
   CWebDoc* m_pDoc;

protected:
   virtual void OnAccept(int nErrorCode);
};
#endif // __CLISTEN_H__</PRE>
<P></P>
<P>CLISTEN.CPP </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// CListen.cpp : implementation of the CListener class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
#include "stdafx.h"
#include "clisten.h"
#include "webdoc.h"

CListen::CListen(CWebDoc* pDoc)
{
   m_pDoc = pDoc ;   // save doc pointer for later use
}

void CListen::OnAccept(int nErrorCode)
{
   CSocket::OnAccept(nErrorCode);
   m_pDoc-&gt;OnAccept() ; // process this in the context of the document
}

CListen::~CListen()
{
}

IMPLEMENT_DYNAMIC(CListen, CSocket)</PRE>
<P></P>
<P>WEBDOC.H </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// WebDoc.h : interface of the CWebDoc class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
class CListen ;   // forward reference
class CClient ;   //...ditto...

#include "logger.h"     // ofstream

class CWebDoc : public CDocument {
public:
   CStringList m_strList ;    // Status text buffer
   CString     m_strInfo ;    // Current text construction buffer
   int         m_nLines ;     // # lines in the status text buffer
   int         m_nMaxLines ;  // size of status text buffer
private:
   CListen* m_pSocket ;       // doc's one and only listening socket
   CPtrList m_listConnects ;  // list of active connections
   ofstream m_fileLog ;       // log stream

public:
   virtual ~CWebDoc();
   // Server
   void OnAccept() ;
   void CheckIdleConnects() ;
   void KillSocket ( CClient* pSocket ) ;
   // Logging
   void OpenLogfile() ;
   void WriteLog ( COMLOGREC&amp; LogRec ) ;
   // Status
   void Message ( LPCTSTR lpszMessage ) ;
   void Message ( CString cMessage ) ;
   void VMessage ( LPCTSTR lpszFormat, ... ) ;
   void DbgMessage ( LPCTSTR lpszMessage ) ;
   void DbgMessage ( CString cMessage ) ;
   void DbgVMessage ( LPCTSTR lpszFormat, ... ) ;
   BOOL ActiveClients() { return ( ! m_listConnects.IsEmpty() ) ; }

   //{{AFX_VIRTUAL(CWebDoc)
   public:
   virtual BOOL OnNewDocument();
   virtual void Serialize(CArchive&amp; ar);
   virtual void OnCloseDocument();
   virtual void SetTitle(LPCTSTR lpszTitle);
   //}}AFX_VIRTUAL

protected:
   CWebDoc();
   DECLARE_DYNCREATE(CWebDoc)
   //{{AFX_MSG(CWebDoc)
   afx_msg void OnClearView();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};</PRE>
<P></P>
<P>WEBDOC.CPP </P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
// WebDoc.cpp : implementation of the CWebDoc class
//
// This is a part of the Webster HTTP Server application
// Copyright 1996 Microsoft Systems Journal.
//
#include "stdafx.h"
#include "Webster.h"
#include "WebDoc.h"
#include "WebView.h"
#include "clisten.h"
#include "cclient.h"

#if _MFC_VER &lt; 0x0400
// for CSocket "dead socket" race problem in MFC 3.0
#include "afxpriv.h" // WM_SOCKET_xxx
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CWebDoc, CDocument)

BEGIN_MESSAGE_MAP(CWebDoc, CDocument)
   //{{AFX_MSG_MAP(CWebDoc)
   ON_COMMAND(IDM_CLEAR_VIEW, OnClearView)
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CWebDoc::CWebDoc()
{
   m_nLines = 0 ;
   m_nMaxLines = 100 ;
   m_strInfo.Empty() ;  // make sure we start off clean
}

CWebDoc::~CWebDoc()
{
}

BOOL CWebDoc::OnNewDocument()
{
   if (!CDocument::OnNewDocument())
      return FALSE;

   CString msg ;  // we use this a lot for MessageBox() messages
   GetFocus() ;   // For MessageBox() - frame window not init'ed yet

   // open log file
   OpenLogfile() ;

   // Create our one and only listener socket.
   // OnCloseDocument() takes care of deleting m_pSocket.
   m_pSocket = new CListen ( this ) ;
   if ( ! m_pSocket ) {
      AfxMessageBox ( "Unable to allocate memory for listener socket!" ) ;
      return ( FALSE ) ;
   }

   if ( ! m_pSocket-&gt;Create ( theApp.m_wwwPort ) ) {
      DWORD dwErr = m_pSocket-&gt;GetLastError() ;
      switch ( dwErr ) {
         case WSAEADDRINUSE:  // example of expected error handler
            AfxMessageBox ( "The WWW port is already in use!" ) ;
            break ;
         default:             // example of generic error handler
            msg.Format ( "Listener socket Create failed: %s\n",
                       theApp.MapErrMsg(dwErr) ) ;
            AfxMessageBox ( msg ) ;
      }
      return ( FALSE ) ;
   }

   // start listening for requests and set running state
   BOOL ret = m_pSocket-&gt;Listen() ;
   if ( ret ) {
      theApp.m_State = CWebApp::ST_WAITING ;
      msg.Format ( "Port: %d", theApp.m_wwwPort ) ;
      SetTitle ( msg ) ;
   } else {
      DWORD dwErr = m_pSocket-&gt;GetLastError() ;
      msg.Format ( "Listener socket Listen failed: %s\n",
                theApp.MapErrMsg(dwErr) ) ;
      AfxMessageBox ( msg ) ;
   }
   return ( ret ) ;
}

void CWebDoc::Serialize(CArchive&amp; ar)
{
}

// Server handlers
//
void CWebDoc::OnAccept()
{
#if _MFC_VER &lt; 0x0400
   // In order to fix the 'dead socket' race problem on Win95, we need to
   // make sure that all sockets that have been closed are indeed dead
   // before requesting a new one. This prevents reallocating a socket that
   // hasn't fully run down yet.
   // This is a feature of MFC prior to 4.0 and is no longer necessary
   // in subsequent versions.
   MSG msg ;
   while ( ::PeekMessage ( &amp;msg, NULL,
                     WM_SOCKET_NOTIFY, WM_SOCKET_DEAD,
                     PM_REMOVE ) )  {
      ::DispatchMessage ( &amp;msg ) ;
   }
#endif
   time_t tNow ;  // add time tag for MikeAh
   time( &amp;tNow ) ;
   CTime cNow ( tNow ) ;
   Message ( cNow.Format ( "%m/%d/%y %H:%M:%S" ) ) ;
   Message ( " - Connection request:" ) ;

   // create a client object
   CClient *pClient = new CClient ( this ) ;
   if ( pClient == NULL ) {
      Message ( "&gt;&gt; Unable to create client socket! &lt;&lt;\n" ) ;
      return ;
   }

   if ( ! m_pSocket-&gt;Accept ( *pClient ) ) {
      Message ( "&gt;&gt; Unable to accept client connecton! &lt;&lt;\n" ) ;
      delete pClient ;
      return ;
   }
   pClient-&gt;ResolveClientName ( theApp.m_bResolveClientname ) ;

   // have we hit our resource limit?
   if ( m_listConnects.GetCount() &gt;= (int)theApp.m_nMaxConnects ) {
      // yes, send failure msg to client
      pClient-&gt;SendCannedMsg ( 503 ) ;
      delete pClient ;
      Message ( "  Connection rejected - MaxConnects\n" ) ;
      return ;
   }
   Message ( "  Connection accepted!!!\n" ) ;

   // add this client to our list
   m_listConnects.AddTail ( pClient ) ;

   // Service Agent has the 'tater now...
}  // OnAccept()

// This routine is called periodically from the MainFrame sanity timer
// handler. We're checking to see if any clients are loitering and, if so,
// clobber them.
void CWebDoc::CheckIdleConnects()
{
   // compute the age threshold
   time_t tNow ;
   time( &amp;tNow ) ;
   CTime cNow ( tNow ) ;
   CTimeSpan cTimeOut ( 0, 0, 0, theApp.m_nTimeOut ) ;
   cNow -= cTimeOut ;   // anyone created before this time will get zapped

   DbgMessage ( "--- Checking for idle connections ---\n" ) ;
   for ( POSITION pos = m_listConnects.GetHeadPosition() ; pos != NULL ; ) {
      CClient* pClient = (CClient*)m_listConnects.GetNext ( pos ) ;
      // anyone lanquishing in the list?
      if ( pClient-&gt;m_bDone ) {
         KillSocket ( pClient ) ;
      }
      // anyone timed out?
      else if ( pClient-&gt;m_LogRec.datetime &lt; cNow ) {
         char msg[80] ;
         wsprintf(msg,"&gt;&gt;&gt; Idle timeout on client: %s\n",pClient-&gt;m_PeerIP);
         Message ( msg ) ;
         KillSocket ( pClient ) ;
      }
   }
   // flush the log file buffer, while we're at it
   if ( theApp.m_bLogEnable &amp;&amp; m_fileLog.is_open() )
      m_fileLog.flush() ;
}  // CheckIdleConnects()

// This routine is called from the MainFrame when a client has notified the
// aforementioned that it is done. Since the document owns the client
// objects, the document is responsible for cleaning up after it.
void CWebDoc::KillSocket ( CClient* pSocket )
{
   BOOL bFoundIt = FALSE ;
   // remove this client from the connection list
   for ( POSITION pos = m_listConnects.GetHeadPosition() ; pos != NULL ; ) {
      POSITION temp = pos ;
      CClient* pSock = (CClient*)m_listConnects.GetNext ( pos ) ;
      if ( pSock == pSocket ) {
         bFoundIt = TRUE ;
         m_listConnects.RemoveAt ( temp ) ;
//(dec)...debug...
// looking for cause of accvio when client cancels transfer
// AsyncSelect causes accvio after Send has failed
         if ( pSocket-&gt;AsyncSelect(0) == 0 )
            DWORD err = GetLastError() ;
         pSocket-&gt;Close() ;   //...debug...
//(dec)...end of debug...
         delete pSocket ;  // destructor calls Close()
         pSocket = NULL ;  // make sure its no longer accessible
         Message ( "  Connection closed.\n" ) ;
         break ;
      }
   }
   if ( ! bFoundIt ) {
      DbgMessage("&gt;&gt; Uh oh! - Might have a sync problem.\n" ) ;
      DbgMessage("&gt;&gt; Couldn't find delete-pending socket in client list.\n");
   }
}  // KillSocket()


// Logging handlers
void CWebDoc::OpenLogfile()
{
   // we may have just turned logging off, so check this before m_bLogEnable
   if ( m_fileLog.is_open() )
      m_fileLog.close() ;
   if ( ! theApp.m_bLogEnable )
      return ;

   // now try to open/create the file
   m_fileLog.open ( theApp.m_LogPath, ios::ate, filebuf::sh_read ) ;
}

void CWebDoc::WriteLog ( COMLOGREC&amp; LogRec )
{
   if ( theApp.m_bLogEnable &amp;&amp; m_fileLog.is_open() ) {
      m_fileLog &lt;&lt; LogRec.client &lt;&lt; " "
                &lt;&lt; LogRec.inetd &lt;&lt; " "
                &lt;&lt; LogRec.username &lt;&lt; " ["
                &lt;&lt; LogRec.datetime.Format("%d/%b/%Y %H:%M:%S") &lt;&lt; "] \""
                &lt;&lt; LogRec.request &lt;&lt; "\" "
                &lt;&lt; LogRec.status &lt;&lt; " "
                &lt;&lt; LogRec.bytes &lt;&lt; "\n" ;
   }
}

// Status message handlers
void CWebDoc::Message ( LPCTSTR lpszMessage )
{
   if ( ! theApp.m_bShowStatus )
      return ;
   Message ( CString(lpszMessage) ) ;
}

void CWebDoc::Message ( CString cStr )
{
   if ( ! theApp.m_bShowStatus )
      return ;
   if ( cStr.GetLength() == 0 )
      return ;
   m_strInfo += cStr ;
   // This chunk of code unpacks the message string into individual lines.
   // The View window code is much simpler this way.
   BOOL bUpdate = FALSE ;
   int newline ;
   while ( ( newline = m_strInfo.Find ( "\n" ) ) &gt;= 0 ) {
      CString cTemp = m_strInfo.Left ( newline ) ;
      m_strInfo = m_strInfo.Right ( (m_strInfo.GetLength()-newline) - 1 ) ;

      // purge excess messages
      while ( m_strList.GetCount() &gt;= m_nMaxLines )
         m_strList.RemoveHead() ;

      m_strList.AddTail ( cTemp ) ;
      bUpdate = TRUE ;
   }
   if ( bUpdate ) // update views if any lines were added
      UpdateAllViews ( NULL ) ;
}

void CWebDoc::DbgMessage ( LPCTSTR lpszMessage )
{
   if ( theApp.m_bDebugOutput )
      Message ( lpszMessage ) ;
}

void CWebDoc::DbgMessage ( CString cStr )
{
   if ( theApp.m_bDebugOutput )
      Message ( cStr ) ;
}

// We could use the var_arg form of these functions exclusively,
// but it's a little more efficient to only use these when we
// really need them.
void CWebDoc::VMessage ( LPCTSTR lpszFormat, ... )
{
   va_list  ptr ;
   char  buf[200] ;
   va_start ( ptr, lpszFormat ) ;
   wvsprintf ( buf, lpszFormat, ptr ) ; 
   Message ( buf ) ;
}

void CWebDoc::DbgVMessage ( LPCTSTR lpszFormat, ... )
{
   va_list  ptr ;
   char  buf[200] ;
   va_start ( ptr, lpszFormat ) ;
   wvsprintf ( buf, lpszFormat, ptr ) ; 
   DbgMessage ( buf ) ;
}

// Class-Private handlers
void CWebDoc::SetTitle(LPCTSTR lpszTitle) 
{
   CString cTitle ;
   cTitle.Format ( "Listening on port: %d", theApp.m_wwwPort ) ;
   CDocument::SetTitle(cTitle);
}

// CWebDoc commands
void CWebDoc::OnCloseDocument() 
{
   // clobber everyone still connected
   for ( POSITION pos = m_listConnects.GetHeadPosition() ; pos != NULL ; ) {
      CClient* pClient = (CClient*)m_listConnects.GetNext ( pos ) ;
      KillSocket ( pClient ) ;
   }
   delete m_pSocket ;   // release the listening socket

   // tidy up the log file
   if ( theApp.m_bLogEnable &amp;&amp; m_fileLog.is_open() )
      m_fileLog.close() ;
   CDocument::OnCloseDocument();
}

void CWebDoc::OnClearView() 
{
   m_strList.RemoveAll() ;
   UpdateAllViews ( NULL, 0L, 0 ) ;
}</PRE>
<P>To be sure, Webster is the Yugo of Web servers. It offers only minimal HTTP support with no frills. Webster only handles GET requests, and it doesn't do anything with most of the extra client information it receives, like the If-Modified-Since field. But Webster does illustrate the basic features common to every Web server, including very powerful servers like Microsoft Internet Information Server. IIS supports not only HTTP, but FTP and Gopher as well. Among the many capabilities IIS provides (and Webster lacks) are support for CGI and BGI, integration with database systems through ODBC, and extremely robust, high-performance service. But Webster is good enough to present your very own real live Web home page, and it does run on both Windows 95 and Windows NT, unlike IIS, which only runs on Windows NT.</P>
<P>Before getting deep into the nitty-gritties, let's take a quick look at what Webster does. <B>Figure 8</B> shows the main Webster screen, which displays status information about client connections. Generally speaking, server applications don't require much in the way of a user interface. All Webster has to do to fulfill its mission is process client requests and keep a log of transactions. But I wanted to monitor Webster's activities, so I gave it a face. (I considered implementing Webster as a Windows NT-based service application, but then I wouldn't have been able to run it in Windows 95.)</P>
<P><img src="SOCK8.gif"></P>
<P><B> Figure 8  Webster</B></P>
<P>Let's go over its UI first. Since Webster doesn't support multiple documents (in fact, it doesn't really have any notion of documents at all), I wrote it as an SDI app. The main view is a scroll view with a splitter window to allow comparing messages in different areas of the list. Webster displays an icon in the Windows 95 system tray that indicates it's running, and whether there are currently any clients active.</P>
<P>A Configuration dialog lets the network administrator (that's me) set various options, such as the default home page, HTTP port number and maximum number of connections allowed, among other things (see <B>Figures 9</B> through <B>13</B>).</P>
<P><img src="SOCK9.gif"></P>
<P><B> Figure 9  Configuring Webster.</B></P>
<P><img src="SOCK10.gif"></P>
<P><B> Figure 10  Setting the default page.</B></P>
<P><img src="SOCK11.gif"></P>
<P><B> Figure 11  Enabling logging.</B></P>
<P><img src="SOCK12.gif"></P>
<P><B> Figure 12  Setting HTTP part number.</B></P>
<P><img src="SOCK13.gif"></P>
<P><B> Figure 13  Output status information.</B></P>
<P>While it's always nice to have a good UI, don't forget that as a service provider, Webster's priority is to get information quickly to clients. Recordkeeping comes second. The userinterface—thatis,thereal-time display of ongoing service transactions—is Webster's least important activity.</P>
<P> </P>
<H2><A NAME="sec5"></A>  Webster's MFC Classes</H2><P>When building apps with MFC, it sometimes takes a little imagination to figure out what the document is in the doc/viewmodel. Webster has no notion of documents the way a word processor, spreadsheet,or Scribble program does. It merely displays information about client transactions. The document in this case is the collection of clients connected at any given time; the view is a representation of what's going on with those connections. <B>Figure 14</B> shows the major C++ classes I used to implement Webster, and how they fit into MFC's application framework.</P>
<P><img src="SOCK14.gif"></P>
<P><B> Figure 14  Webster Architecture</B></P>
<P>CWebDoc manages a list of clients, a list of status messages, and writes information to the log file. Since Webster is a SDI app, there's only one CWebDoc.</P>
<P>CWebView displays the messages in CWebDoc's list. Derived from CScrollView, CWebView permits scrolling to previous messages.</P>
<P>CListen is a socket class (described below) that listens for new clients. It handles the initial connection request on port 80. When the document accepts the connection, it creates a new CClient object and adds it to the list of connected clients. CListen continues to listen for new clients.</P>
<P>CClient is a socket class that manages a client transaction. CClient parses the request, retrieves the file, and transmits it to the client. There's one CClient object for each transaction currently in process, and these objects live only for the duration of a single transaction.</P>
<P>CMainFrame is a standard CFrameWnd with toolbar, status bar, and a splitter window (CSplitterWnd). It also manages a "watchdog timer" that periodically checks for nonresponding clients. CMainFrame also runs the CWebProps dialog when a user invokes the Configuration command.</P>
<P>CWebProps is a CPropertySheet that implements the configuration dialog.</P>
<P>Not shown in <B>Figure 14</B> is CWebApp, the application class whose member functions read and write the configuration to the system registry when Webster starts up or shutsdown.</P>
<P>There's more code in Webster than I have space to describe fully in these pages, so I'll focus mainly on networking issues since that's what this article is all about. Most of the interesting stuff happens in CWebDoc, CListen, and CClient. I leave it to you to divine the rest from the source code, which you can download in toto from any of the sources listed on page 5.</P>
<P> </P>
<H2><A NAME="sec6"></A>  Sockets</H2><P>At the bottom of the software chain in any network program are the communication layers that ship bits and bytes through your modem or network card and out onto the net. Web technology was first developed on UNIX systems, where the normal way of accessing the network is through the Berkeley Sockets interface. Sockets provide a relatively high-levelAPI to TCP/IP, with functions like connect, accept, send, recv, and so on. Windows provides an equivalent interface in the form of Windows Sockets. WINSOCK is the DLL that implements Windows Sockets. WINSOCK 1.1 provides the same functions as Berkeley Sockets, plus additional extensions specific to Windows 95. For example, WINSOCK notifies applications of communications events by sending messages to your window proc, instead of using the UNIX signal mechanism.</P>
<P>While using sockets is a lot easier than programming your network card directly, it still requires a good bit of programming. This is where MFC comes to the rescue. Starting in version 3.0, MFC provides a couple of classes that make sockets a breeze (see <B>Figure 15</B>). CAsyncSocket is the base socket class. It hides most of the tedious and sometimes complex work of managing the WINSOCK interface. Instead of writing a window proc to handle messages from WINSOCK, you handle events by overriding virtual functions like OnConnect, OnReceive, OnClose, and so on. An even simpler derived class, CSocket, provides a synchronous implementation that's ideal for programs like Webster. CSocket uses blocking to perform synchronous transfers using CArchive and a CFile-derived class, CSocketFile, so you can use normal streaming operations to send and receive data over the net. The definitions for these classes appear in AFXSOCK.H, which AppWizard automatically #includes for you if you check "Windows Sockets" under "WOSA Support" when you run AppWizard.</P>
<P><B> Figure 15  MFC Socket Classes</B></P>

<TABLE COLS="3" BORDER="0"><COLGROUP><COL WIDTH="27pt" VALIGN="TOP"><COL WIDTH="112pt" VALIGN="TOP"><COL WIDTH="302pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="3" VALIGN="TOP"><P> <B>CObject Classes</B></P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P><B>CAsyncSocket</B></P></TD><TD VALIGN="TOP"><P>Asynchronous socket class thatencapsulates WINSOCK.  Base class for all socket classes</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P><B>CSocket</B></P></TD><TD VALIGN="TOP"><P>Synchronous easy-to-use socket class provides blocking to work with CArchive and CSocketFile.</P></TD></TR><TR><TD COLSPAN="3" VALIGN="TOP"><P> <B>CFile Class</B></P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P><B>CSocketFile</B></P></TD><TD VALIGN="TOP"><P>CFile-derived clas that works with CSocket and Carchive for streaming objects to/from sockets.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>I used the CHATSRVR sample program that comes with Visual C++ as a guide in designing my socket classes. While CHATSRVR uses CSocket differently than Webster, it does illustrate how to write your own CSocket-derived class. In Webster,therearetwo:CListenlistensfornewclientconnectionsandCClientmanagesclienttransactionsoncethey're accepted. There's only one CListen object, but there may be several CClient objects, one for each transaction in process.</P>
<P> </P>
<H2><A NAME="sec7"></A>  How Webster Works</H2><P>To see how the socket classes work in practice, let's step through a typical client request, the Internet Explorer's GET request for SKY.JPG. (In the excerpts that follow, I've omitted much of the code to highlight the important details.) When Webster starts up, MFC creates a new document per its usual mechanisms, and calls CWebDoc::OnNewDocument.</P>
<P> </P>
<P><BR></P>
<PRE> BOOL CWebDoc::OnNewDocument()
{
   if (!CDocument::OnNewDocument())
      return FALSE;
   OpenLogfile();

   // create one and only listener socket object
   m_pSocket = new CListen(this);
   if (!m_pSocket)
      return FALSE;

   // create socket on port m_wwwPort, default=80
   if (!m_pSocket-&gt;Create(GetMyApp()-&gt;m_wwwPort)) {

             .
             .  // (handle error)
             .
      return FALSE;
   }

   // start listening for requests
   BOOL ret = m_pSocket-&gt;Listen();
 
             .
             .  
             .
   return ret;
}</PRE>
<P> </P>
<P>As with CWnd objects, you create a socket by first creating the object with new, then calling CSocket::Create with the port number. Once you've created the socket, you can call CSocket::Listen, at which point the socket is ready for requests from clients. Pretty easy, huh?</P>
<P>When an HTTP client requests a connection to Webster on port 80, it arrives through the bowels of WINSOCK and CSocket to my virtual function CListen::OnAccept.</P>
<P> </P>
<P><BR></P>
<PRE> // CSocket virtual function override
void CListen::OnAccept(int nErrorCode)
{
   CSocket::OnAccept(nErrorCode);
   m_pDoc-&gt;OnAccept() ; // let doc process it
}</PRE>
<P> </P>
<P>CListen simply passes the job to CWebDoc, which creates a new CClient object, calls CSocket::Accept to accept the connection, and adds the new client to its list:</P>
<P> </P>
<P><BR></P>
<PRE> void CWebDoc::OnAccept()
{
             .
             .  
             .
  // create new client object
  CClient *pClient = new CClient(this);
  if (pClient==NULL) {
    Message("&gt;&gt; Unable to create client! &lt;&lt;\n");
    return;
  }

  // Accept the connection
  if (!m_pSocket-&gt;Accept(*pClient)) {
    Message("&gt;&gt; Unable to accept connecton! &lt;&lt;\n");
    delete pClient;
    return;
  }
            .
            .  
            .
  Message("Connection accepted!!!\n");
  m_listConnects.AddTail(pClient);
}</PRE>
<P> </P>
<P>Throughout the operation, CWebDoc calls its own member function CWebDoc::Message to append status messages to its list, which will be displayed by CWebView. At this point, CWebDoc has done its job, and goes back to waiting for either another connection request (from CListen), or notification that the transaction is complete. From this point on, CClient manages the transaction.</P>
<P>Once the connection is accepted (by calling CSocket::Accept), the client can transmit its GET request. When it does, the event percolates up through WINSOCK and CSocket to another virtual function override, CClient::OnReceive.</P>
<P> </P>
<P><BR></P>
<PRE> void CClient::OnReceive(int nErrorCode)
{
  CSocket::OnReceive(nErrorCode);

  if (ProcessPendingRead()) {
    ProcessReq() ; // process the request
    m_bDone = TRUE ;
    if (GetMyProps()-&gt;m_bLogEnable)
      m_pDoc-&gt;WriteLog(m_LogRec);
    m_pDoc-&gt;KillSocket(this);
  }
}</PRE>
<P> </P>
<P>CClient::OnReceive calls ProcessPendingRead to read the request. Since not all clients (such as Telnet—see below) transmit the whole request in one fell swoop, it may arrive piecemeal, as several OnReceive notifications. ProcessPendingRead accumulates incoming data into a buffer until the entire request arrives. When it does, CClient calls ProcessReq to process it.</P>
<P> </P>
<P><BR></P>
<PRE> void CClient::ProcessReq()
{
  ParseReq();          // parse it</PRE>
<P> </P>
<P><BR></P>
<PRE>   // can only handle GETs for now
  if ( m_nMethod != METHOD_GET ) {

             .
             .  // error
             .
    return;
  }

             .
             .  
             .
  SendFile(m_cLocalFNA, m_cURI);
      // (filename, directory)

             .
             .  
             .
  SendTag();    // Done!!!
}</PRE>
<P> </P>
<P>ProcessReq calls ParseReq to parse the request, that is, split it into its method and URL. ParseReq also stores additional header lines in a holding list, where they'll be used later to prepare the response. After parsing the request, ProcessReq checks for a valid URL and a supported method. Assuming the URL is valid and the method is GET, ProcessReq calls SendFile to transmit the file.</P>
<P> </P>
<P><BR></P>
<PRE> void CClient::SendFile(CString&amp; cLocalFNA, 
  CString&amp; BaseFNA)
{
  CFile cFile;

             .
             .  
             .
  cFile.Open(cLocalFNA,
    CFile::modeRead|CFile::typeBinary);

             .
             .  
             .
  m_pDoc-&gt;VMessage("   Sending: %s\n", cLocalFNA);
  SendReplyHeader(cFile);
  SendData(cFile);
  cFile.Close();
}</PRE>
<P> </P>
<P>SendFile opens the file using the normal MFC CFile class, and passes it to SendReplyHeader, which formats and transmits an HTTP 1.0 response header:</P>
<P> </P>
<P><BR></P>
<PRE> HTTP/1.0 200 OK
Date: Sunday Sun, 21 Oct 1995 19:38:46 GMT
Server: Webster/1.0
MIME-version: 1.0</PRE>
<P> </P>
<P>Following this, SendFile calls SendData to finally transmit the file. This is where the MFC classes really makes life easy.</P>
<P> </P>
<P><BR></P>
<PRE> void CClient::SendData(CFile&amp; file)
{
  char buf[BUF_SIZE];
  int nBytes;

  CSocketFile sockFile(this, FALSE);
  while ((nBytes=file.Read(buf,BUF_SIZE))&gt;0) {
    TRY {
      sockFile.Write((LPVOID)buf,nBytes);

    } CATCH(CFileException, e) {

             .
             .  
             .
    } END_TRY
  }
  sockFile.Flush();
}</PRE>
<P> </P>
<P>CSocketFile makes writing to a socket look like writing to an ordinary CFile. To transmit the bytes, I just read them from one file, and write them to another "file," which is actually the socket.</P>
<P>As control unwinds from the depths of the call stack, it eventually returns to ProcessReq, which calls SendTag to append an HTML tag that identifies "Dave Cook Consulting" as the sender (it always pays to advertise), and from there back to CClient::OnReceive, from whence the whole business started.</P>
<P>OnReceive calls m_pDoc-&gt;KillSocket to notify the document that the transaction is complete. CWebDoc::OnKillSocket removes the CClient object from its list and, with a mighty sigh of contentment for a job well done, deletes it. Whew!</P>
<P>As you can see, while developing Webster, I traveled to some of the farthest reaches of the MFC universe. One problem I came across initially was a mysterious assertion failure when I tried to create a new CClient object. The error only manifested itself on Windows 95. I was told by someone in the Microsoft Languages Product Support group that this was a race condition that's been corrected as of the MFC 4.0 release. However, as a precaution to those of you who might still be using version 3.x, and just to give you some idea of the complex shenanigans that go on behind the scenes in network programming, I thought I'd describe my workaround.</P>
<P>In brief, MFC maintains a map of "dead" sockets, those that were once open and now closed. If an application closes and opens sockets in the same thread, without yielding to give Windows a chance to process messages, it's possible an attempt will be made to close a socket that's already been closed, because the thread doesn't know it yet (it hasn't gotten the message). In version 3.x, MFC doesn't properly handle this because it can have only one entry in its dead sockets map. MFC dies asserting that there isn't already an entry in the map. The simple workaround is to include the following snippet of code in CWebDoc::OnAccept, just prior to creating the new CClient object. </P>
<P> </P>
<P><BR></P>
<PRE> // Just before creating a new CClient:
#if _MFC_VER &lt; 0x400  // problem fixed in MFC 4.0
#include "afxpriv.h"  // WM_SOCKET_xxx
  MSG msg ;
  while (::PeekMessage(&amp;msg, NULL,
    WM_SOCKET_NOTIFY, WM_SOCKET_DEAD, PM_REMOVE)) {
    ::DispatchMessage ( &amp;msg );
  }
  // Ok, any dead sockets pending destruction 
  // have been dealt with. It's safe to create
  // the new client socket now.
#endif  // _MFC_VER &lt; 0x0400</PRE>
<P> </P>
<P>I simply peek into the message queue to process any outstanding messages in the range from WM_SOCKET_NOTIFY to WM_SOCKET_DEAD, which is all socket messages (there are only two). This gives MFC a chance to clean up any dead sockets before I create a new one.</P>
<P> </P>
<H2><A NAME="sec8"></A>  Other Webster Features</H2><P>Back in the days when I wrote device drivers for a living, one of my mentors gave me a sage bit of advice: "Device drivers are perfect code." The implication is that driver code must be perfect, or else it may crash the system. While a Webster crash won't bring down Windows 95, it would be quite disconcerting to a client if Webster dies in the middle of a transaction, so it's important to make the code as robust as possible.</P>
<P>That said, I must confess with some chagrin that in the interest of building an educational tool that demonstrates basic HTTP and client/server transactions, there are many places where I simply punted on error checking and recovery. You have been warned!</P>
<P>While I didn't make Webster totally bulletproof, I did install an important feature I call the "watchdog timer." Because Webster relies on clients to behave properly, it can get trapped in an unusual state if they don't. For example, if a client makes a request, but fails to read the reply, Webster would hang waiting for CSocketFile::Write to complete. To prevent such mishap, I implemented the watchdog timer. CMainFrame creates an ordinary Windows timer to go off periodically. If a client goes idle too long, CMainFrame will detect it and simply delete the client socket, closing the connection. The timeout value is specified as part of the server configuration.</P>
<P>The status window provides real-time information about the activities of the server. A simple function, CWebDoc::Message, appends status messages to a list; to display them, I implemented my own simple buffered text view based on CScrollView. CWebView::OnDraw uses CDC::TextOut to draw the messages on the screen. The displaying of messages doesn't impede Webster's other activities, since Windows only sends a WM_PAINT message when there are no other messages in the queue. As an enhancement to CWebView, you might add a graphical display to show client activity intheformofahistogram.</P>
<P>In addition to real-time display, Webster also writes information about each transaction to a log file:</P>
<UL><LI>    Date and time of request</LI><LI>   Who made the request</LI><LI>   What was requested</LI><LI>   Result of the request</LI></UL><P>CWebDoc writes this information in the standard Common Log Format. It's tempting to include additional tidbits of information in the log file, but the purpose of the log is to store the minimum information necessary for accounting purposes. You don't want to burden your server with excessive logging requirements. Most facilities use utility programs to parse the log file and generate more useful statistics, such as activity mapped by time of day, most frequently requested files, and so on.</P>
<P>CClient accumulates log information as it processes the request. Before killing the client, CWebDoc extracts the log information, formats it, and writes it to a file WEBSTER.LOG.</P>
<P>Webster stores its configuration in the Windows system registry (see <B>Figure 16</B>). CWebApp provides member functions LoadProps and SaveProps to read and write the configuration. CWebApp::InitInstance contains the line</P>
<P> </P>
<P><BR></P>
<PRE> SetRegistryKey (IDS_REG_STRING)</PRE>
<P> </P>
<P>which tells MFC to use the registry, not WEBSTER.INI, when I call CWinApp::Get/WriteProfileInt and Get/WriteProfileString. IDS_REG_STRING is the resource ID of the string "Dave Cook Consulting." By convention, software settings are stored in the key HKEY_CURRENT_USER\Software\YourCompanyName.</P>
<P><img src="SOCK16.gif"></P>
<P><B> Figure 16  Saving Webster's configuration. </B></P>
<P>As mentioned earlier, to edit the configuration settings, I implemented a property sheet dialog with tabs for Server, HTML, Logging, Status, and Alert (see <B>Figures 9</B> through <B>13</B>). The implementation is a straightforward application of CPropertySheet and CPropertyPage, so I won't bore you with the details.</P>
<P> </P>
<H2><A NAME="sec9"></A>  RunningWebstertheFirstTime</H2><P>Once Webster is built and compiled, going live on the Internet is surely tempting, but unwise. You might blast away your connection and your reputation along with it. So the first thing you should do before running Webster is unplug your computer from the network. If you're using a dial-up connection, just unplug the phone line from your modem; if you have a dedicated line, unplug the cable from your network card.</P>
<P>With your system disconnected, it's safe to launch Webster. Assuming it comes up OK, the first thing you have to do is configure your system. The Configuration dialog contains several property pages that let you set various options. The most important one is the HTML page, which lets you set the default HTML file and directory. This is the file that Webster will send if the client doesn't know what your home page is called. For example, if I connect to http://www.microsoft.com with my Web browser, the HTTP server at that location must be configured to provide a default HTML file, since none was specified in the URL. This is called a blind request. The default HTML file provides a top-level page for the host system. Typically, it contains links to other resources on the host. Some HTTP servers make you use a hardwired name like default.htm, but Webster lets you use any name you want. Make sure you set it to a valid HTML file on your computer, or else clients will get the dreaded response "404 - Requested URL not found." You also need to set the home directory, which becomes the root directory for all file requests.</P>
<P>I leave you to explore the other property pages on your own. Most of it is self-explanatory. One item worthy of note is "Enable Client Name Lookup" in the Status page. This feature, if checked, enables translation of client IP addresses (such as 198.68.184.240) to more human-readable domain names (such as davepc2.oz.net). Because name translation incurs significant processing delays (it requires searching the local host name database and/or contacting a Domain Name Server system), this option is usually left disabled.</P>
<P>Once you've configured Webster, how do you test it without going live on the net? One of the really useful features of TCP/IP is the local loopback address, which lets your machine talk to itself as if it were both client and server. Every machine has something called a hosts file that lists the names and IP addresses of hosts on the local network. On Windows NT, the hosts file is in \winnt\system32\drivers\etc. On Windows 95, it's in the \windows directory. Apps use the hosts file to resolve TCP/IP domain names into IP addresses. Even if all you have is a standalone machine running Windows 95 with dial-up networking, you have a hosts file. And within every hosts file is a silly little entry that looks like this:</P>
<P> </P>
<P><BR></P>
<PRE> 127.0.0.1  localhost  loopback</PRE>
<P> </P>
<P>This entry is a special IP address that lets your machine talk to itself without a network. You can run a browser like the Microsoft Internet Explorer, request a connection to 127.0.0.1, and WINSOCK will convey the request to whatever server software is running on your machine, as if it came from a remote client. This is just the ticket for debugging network apps like Webster. Just launch Webster, then start the Internet Explorer, type 127.0.0.1 into the Address field at the top of the window and, with any luck, Webster will respond. If not, here are some things to check.</P>
<P>If Webster crashes or says it can't run, make sure you have TCP/IP installed as a network protocol. Run Network from the Control Panel and look for TCP/IP as one of the installed components (see <B>Figure 17</B>). If TCP/IP doesn't appear, click Add, and Windows will step you through the installation.</P>
<P><img src="SOCK17.gif"></P>
<P><B> Figure 17  Check for TCP/IP install.</B></P>
<P>Make sure you have the correct version of WINSOCK.DLL, the one that came with your version of Windows. Some commercial browsers install older versions of WINSOCK.DLL on your machine.</P>
<P>If you get "Error 404 - URL not found," make sure the default HTML file and directory are set correctly in the configuration dialog. You can check the validity of your HTML file by viewing with your Web browser. Most browsers let you view HTML files directly. The server provides access to all files from the default HTML directory and subdirectories. Because the server runs as a local app, with all the requisite permissions, no additional file permission or privilege settings are required to access these files. Keep in mind that any file in this directory or its subdirectories is potentially available to clients if they know what to ask for.</P>
<P>If you're still having trouble, enable debug messages in theConfiguration/Statuspropertypage.I'vesprinkled debug messages throughout the code; you can add more.</P>
<P> </P>
<H2><A NAME="sec10"></A>  Using Telnet</H2><P>Another useful debugging technique that deserves special mention is Telnet. Telnet is a character-oriented communications facility that comes with Windows 95 and Windows NT. Typically, it's used to log onto remote systems as a terminal emulator. You can use Telnet to type HTTP requests manually, and see what comes back from the server. Telnet doesn't operate like a trueWebbrowser.For one thing, it transmits a single character at a time, instead of a whole block. This makes Telnet pretty slow and clunky, but it's invaluable for debugging.</P>
<P>Just run TELNET.EXE, select "Connect Remote System" and type 127.0.0.1 as the host name and 80 as the port (see <B>Figure 18</B>). You also want to invoke "Terminal Preferences" and check Local Echo, otherwise you won't be able to see what you type. Once you've done all this, just type</P>
<P> </P>
<P><BR></P>
<PRE> GET / HTTP/1.0</PRE>
<P> </P>
<P>and press the return key twice (to indicate the end of the request). You should be able to see Webster's response, as in <B>Figure 19</B>. During my Web research, I used Telnet to snoop inside various servers. Just connect to your favorite Web site and type a request</P>
<P> </P>
<P><BR></P>
<PRE> GET somedoc.html HTTP/1.0</PRE>
<P> </P>
<P>and see what comes back.</P>
<P><img src="SOCK18.gif"></P>
<P><B> Figure 18  Host name and port.</B></P>
<P><img src="SOCK19.gif"></P>
<P><B> Figure 19  WEBSTER's response.</B></P>
<P> </P>
<H2><A NAME="sec11"></A>  Conclusion</H2><P>Assuming all the preceding steps check out OK with no cause for alarm, and you're able to issue a request with Telnet, it's time to take the big plunge and go live on the network—yikes! Just plug your cable or phone line in and run Webster. Of course, nothing particularly exciting will happen. Remember, Webster doesn't actually do anything until a client requests something.</P>
<P>I hope this brief exploration into the Web helps you appreciate the elegance and simplicity of what takes place when you connect to your favorite Web site. As HTTP and HTML continue to evolve, you may wish to try new capabilities by adding them to Webster. Among the many features I've considered adding to Webster are: multithreading, CGI and BGI support, "keepalive" connections, and cool graphics for the status display. I leave these exercises to you and your imagination. Happy Web serving! </P>
<H2><A NAME="sec12"></A>  Internet Information Server</H2><P>Webster works great for a bare-bones server. But what if you want to do something more sophisticated than put baby pictures of your son on the Web? Microsoft is currently beta testing its Internet Information Server (IIS) software, codenamed Gibraltar, which it plans to ship first quarter 1996. The Internet Information Server runs as a Windows NT Service on all Windows NT Server 3.51 hardware platforms (Intel, MIPS Alpha, and PowerPC). The Internet Information Server can turn you into a Webmaster, giving you full control over all aspects of a site's configuration. You can set virtual roots, which allow one machine to look like several different machines to clients. You get Secure Sockets Layer (SSL) support and the ability to grant/deny WWW access based on IP address. There are a number of logging features that you can choose from, such as the ability to log data directly to an ODBC data source like Microsoft SQL Server. You can also perform remote administration of a site, monitor performance through the Windows NT Performance Monitor application, and even support other protocols such as FTP and Gopher. The security accounts (and the tools to manage them) used by Internet Information Server are the same as those in Windows NT Server. In addition, Internet Information Server lets you extend your server's capabilities through a rich set of new programming interfaces including the Internet Server API (ISAPI) as well as older interfaces such as CGI (Common Gateway Interface).</P>
<P>Flat Web pages are on the way out. They'll be replaced with real-time services. Through ISAPI, your Web page can load a DLL extension when it starts up. If the DLL provides named functions HttpExtensionProc and GetExtensionVersion as common entry points, your HTTP server can load it using ISAPI. Unlike CGI, the current default standard for interactive Web services, ISAPI modules are DLL-based, so they're loaded directly into the HTTP server's address space, removing the need for the layer of environmental variables that CGI uses for communication. More importantly, ISAPI does not require that a new process be created for each new request. ISAPI is designed to be flexible for the content provider, so beyond the named export there is no limitation on what sort of information might be requested from it—data is passed as byte arrays. With ISAPI as the gateway, your Web server can request back office information and convert it from an unreadable format into the format the client can understand. </P>
<P>As just one example, your HTTP server might want to provide current temperatures for a city of the client's choosing. If the client chooses Chicago, HTTP would reference http://scripts/weather.dll?Chicago. The server in turn would load WEATHER.DLL and call its exported HttpExtensionProc, passing it a pointer to an ECB (Extension Control Block), a structure containing the context for this request, including the URL and other parameters passed from the client's browser. The ISAPI-compliant DLL will then have all the information it needs to proceed, retrieve the current temperature for Chicago from whatever data feed it knows about, and return the proper data by calling a function provided by the server.</P>
<P>IIS and ISAPI together will provide numerous possibilities for the corporate site. Right now, companies are tenuously testing out the Internet because they're unsure what benefits it really holds. Most current corporate Web sites are little more than online marketing brochures. Combine the flexibility of real-time data services with the C2-security provided by the Windows NT Access Control Lists, and you can go far beyond brochures. Internally, an "Enterprise-Wide Web" can act as a form of extended groupware. Users will be able to not only join in discussion pages and retrieve information on a need-to-know basis, but they'll be able to maintain sites that are instantly updatable via back office tools. </P>
<H2><A NAME="sec13"></A>  Acronym Stew</H2>
<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="77pt" VALIGN="TOP"><COL WIDTH="365pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> <B>BGI</B></P></TD><TD VALIGN="TOP"><P>Binary Gateway Interface; a way of calling a binary process on the server machine.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>CGI</B></P></TD><TD VALIGN="TOP"><P>Common Gateway Interface; a way of running programs on a server machine, passing in environment variables.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>FTP</B></P></TD><TD VALIGN="TOP"><P>File Transfer Protocol for shipping files from one Internet machine to another.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>GIF</B></P></TD><TD VALIGN="TOP"><P>Graphic Interchange Format used to tranfer graphic images</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>Gopher</B></P></TD><TD VALIGN="TOP"><P>A protocol for distributed document navigation.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>HTML</B></P></TD><TD VALIGN="TOP"><P>HyperText Markup Language is the document format used to describe Web pages.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>HTTP</B></P></TD><TD VALIGN="TOP"><P>HyperText Transfer Protocol is the message protocol that Web clients and servers use to talk to one another and exchange information.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>ISAPI</B></P></TD><TD VALIGN="TOP"><P>Internet Server API; binary gateway interface for Microsoft Internet Information Server.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>Java</B></P></TD><TD VALIGN="TOP"><P>A Web programming language. Java clients can download Java programs from the server and run them on the client machine.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>JPEG</B></P></TD><TD VALIGN="TOP"><P>Joint Picture Experts Group is a format for compressing graphic images.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>MIME</B></P></TD><TD VALIGN="TOP"><P>Multipurpose Internet Mail Extensions is a standard for describing different kinds of information that can be exchanged over the net.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>RFC</B></P></TD><TD VALIGN="TOP"><P>Request for Comment documents describe or propose new standards. Internet users are free to submit comments/suggestions/gripes.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>TCP/IP</B></P></TD><TD VALIGN="TOP"><P>Transmission Control Protcol/Internet Protocol is the basic communications protocol used by the Internet. Strictly speaking, TCP/IP is a suite of network protocols.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>URL</B></P></TD><TD VALIGN="TOP"><P>Universal Resource Locator is a way of addressing servers, files, Web sites and other "resources" on the Internet.</P></TD></TR><TR><TD VALIGN="TOP"><P> <B>WAIS</B></P></TD><TD VALIGN="TOP"><P>Wide Area Information Server is a standard for content indexing and information retrieval.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<H2><A NAME="sec14"></A>  Becoming a Web Site</H2><P>For many people, just getting connected to the Internet is a big enough hurdle, forget about becoming a Web site as well. There are so many service providers promoting easy access to the information highway that it can be quite confusing to newcomers. For browsing, most people use dial-up modems to connect to an Internet Service Provider (ISP) when they want to access the net. But to become a server (and use Webster), you need direct access to the Internet. That means your computer is communicating live on the Internet, using the TCP/IP protocol. If you're using a modem, this means that you have dialed your ISP number and are connected. </P>
<P>With a direct access connection, your computer has a unique 32-bit IP address in the standard Internet dotted format. For example, my IP address is 198.68.184.240. Your ISP will assign your IP address and help you get connected. Windows NT supports dial-up networking through an ISP with its Remote Access Service (RAS), which also comes with the Windows 95 Plus! package. If you go this route, I recommend you get a modem capable of transmitting at 28.8Kbps. You'll have some unhappy clients if you make them suffer while your modem struggles to ship JPEG files over the line at 1200 baud.</P>
<P>The other connection option is a dedicated line. You may be lucky enough to have a dedicated Internet connection at your job or university. If so, your network administrator can help you set up your IP address.</P>
<P>However you get it, your IP address goes into a giant distributed database called the DNS (Domain Name System) that resides on several servers throughout the Internet. Applications use this database to convert domain names like davepc2.oz.net to IP addresses like 198.68.184.240. It's surprising how much of the overall Internet activity is spent just looking up these names—around six percent of transactions.</P>
<P>Once you've established your presence on the Internet via a direct access connection, your computer can act as an Internet host. In addition to accessing other host computers, you can provide network services yourself. You can run the Webster HTTP server described in this article, or some other Web server, and anyone in the great World Wide Web can view your home page using their favorite browser.</P>
<P>What can you do if you want a home page, but don't have access to a direct Internet line, and don't want to leave your phone off the hook twenty-four hours a day? Most ISPs have a Web server running on their system, and will grant you a modest amount of disk space as part of your basic service package. You can simply give them your HTML files (over the net, of course), and let their server do the work.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
