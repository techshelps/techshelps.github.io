<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Get World-Class Noise and Total Joy from Your Games with DirectSound and DirectInput</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Get World-Class Noise and Total Joy from Your Games with DirectSound and DirectInput</H1><P>Dave Edson</P>
<P>Dave Edson is a member of the Microsoft Premier Developer Support team and has published two books, <I>Dave</I><I>'</I><I>s Book of Top Ten Lists for Great Windows Programming</I> (M&amp;T Books, 1994) and <I>Writing Windows Applications from Start to Finish</I> (M&amp;T Books, 1993).</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4572">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the WINDONUT project files.</A></P><P>Playing games on versions of Windows® prior to 3.1 often involved great leaps of imagination. If you had just blasted a bloody gaping hole in the head of a big evil alien, this line of code would be executed:</P>
<P> </P>
<P><BR></P>
<PRE> MessageBeep(0);</PRE>
<P> </P>
<P>If you had just caught that fly ball in center field in the bottom of the 9th inning:</P>
<P> </P>
<P><BR></P>
<PRE> MessageBeep(0);</PRE>
<P> </P>
<P>And if you stepped on the gas while racing your Formula 1 racing car:</P>
<P> </P>
<P><BR></P>
<PRE> for (x = 0; x &lt; 10; x++ ) MessageBeep(0);</PRE>
<P> </P>
<P>With Windows 3.1 and the glorious sndPlaySound API, you could finally play a wave file for the above mentioned events. Of course, there were some tiny drawbacks. There was this latency thing. Latency is the amount of time it takes for the wave file to actually start playing from the moment the call to sndPlaySound was made. Since the sndPlaySound API does not implement anything sophisticated like caching away the sound, or mixing two wave files together, your games sounded a bit like a cheezy radio show where the sound effects person is a little bit behind and can only do one sound at a time. In other words, they were still less than adequate.</P>
<P>Then Microsoft came out with WAVEMIX.DLL,anice,little, mainly-unheard-of technology used in the Arcade game pack. It mixed wave files, and it was available to developers for distribution. WAVEMIX never really caught on. Probably because DirectDrawª wasn't out yet, so game graphics were still not that great.</P>
<P>Well, games for Windows® 95 have come a long way, baby. In my first article in this series, "The Game SDK for Windows 95 Gives You Direct Hardware Control for Speedy Animation," MSJ November 1995, I wrote about DirectDraw, one of the four components of the Microsoft Games SDK for Windows 95. In this article, I'll examine DirectSound™, a new technology that deals your PC's sound card from the bottom of the deck to ensure that you'll get world-class noise spewing from your games. DirectSound takes advantage wherever possible of hardware features such as on-card memory and mixing sounds. Mixing sounds means playing them simultaneously. (For example, if you are writing a baseball game program, you want the sound of the crowd and the sound of the announcer to play simultaneously. The baseball game program would have two wave files: one for the crowd noise, and one for the announcer. You'd have the app "mix" these two wave files together to produce the desired sound effect.) I'll also cover DirectInput™, the third Direct feature of the Game SDK, which gives you control of the joystick.</P>
<P>Let's first take a look at how DirectSound fits into the Win32® system under Windows 95. <B>Figure 1</B> is one of those block diagrams Microsoft has grown so fond of. As you can see, regular Win32-based apps still use the sndPlaySound API to make their noise. The sndPlaySound API calls a function in the wave layer that in turn calls the Windows audio Device Driver Interface (DDI) (that's the sound driver to you and me), which then talks to the hardware card and produces sound. The specifications for these sound drivers (DDIs) only allow for one sound playing at a time. Prior to DirectSound, applications had to do their own mixing of wave files using things like WAVEMIX.DLL. Wave mixing tends to slow things down, is lower quality (you only get 8-bitaudio),lessreliable,andthelatencyproblemisevenworse.</P>
<P><img src="GAMES1.gif"></P>
<P><B> Figure 1  DirectSound</B></P>
<P>Unlike WAVEMIX.DLL, which can only mix up to eight waves (game programmer lingo for WAV files) and only reliably produce 8-bit output waveforms, DirectSound places no predefined limit on the number of waves that can be mixed. The output waveform can be at any of the current standard sampling rates. On sound cards that support hardware mixing, there is virtually no CPU hit for each combination of sounds. On sound cards that do not support hardware mixing, the impact of mixing is minimal; each mixed wave file consumes less than 1 percent of CPU time. </P>
<P>Anyway, if you're writing an app with sound, you'll have to choose between using sndPlaySound or DirectSound. These two beasties don't currently get along. If your app plays wave files, and doesn't really care about latency (perhaps an adventure game that spends a lot of time painting), go ahead and continue to use sndPlaySound. If you need low latency or sound mixing, then you have to use DirectSound and nothing but DirectSound. Once you release DirectSound (see "Cleanup" down near the end of this article), you can use sndPlaySound again. By the way, many applications can use DirectSound concurrently but only one of them (the foreground one) will make sound at a time. DirectSound switches the sound whenever the input focus changes. If you have two apps that both need to make DirectSound noise simultaneously, you'll have to figure out a way to get some interprocess communication going, so that only one app makes the noise for both.</P>
<P>DirectSound automatically takes advantage of accelerated sound hardware, including hardware mixing and hardware sound buffer memory. Applications do not need to query the hardware or program specifically for hardware acceleration; DirectSound takes care of everything. However, applications can query the hardware to determine the capabilities of the hardware in order to optimize hardware resource allocation specifically for that application.</P>
<P> </P>
<H2><A NAME="sec0"></A>  Anatomy of a Wave File</H2><P>Before I jump into playing all these wave files on DirectSound, let's take a quickie look at what a wave file is. For DirectSound, a wave file consists of a header and the actual digitized samples. A sample is a scalar value of the average amplitude recorded over a predefined interval on a wave, here a sound wave.</P>
<P> There are an infinite number of points along a genuine analog sound wave, each point's amplitude having a value from zero to n, with n being the maximum pressure the wave carrier (what the sound wave is traveling through) can withstand before breaking down.</P>
<P>Now, let's look at a digitized wave in <B>Figure 2</B>. In this wonderful world of digital, there are a finite amount of "points" along this wave, each point having a duration. These points are called samples, since they represent a sample of what the wave sounds like at that time. The duration is determined by the sampling frequency. A typical sampling rate is 22,050 times per second. This means each sample represents 1/22050th of a second of sound. The amplitude at each sample (illustrated in green in <B>Figure 2</B>) is played for the entire 1/22050th of a second. Obviously, the higher the sampling frequency, the smoother the digital wave sounds. And, of course, the more samples per second, the more memory required.</P>
<P><img src="GAMES2.gif"></P>
<P><B> Figure 2  Digitized Sound Wave</B></P>
<P>Now these wave samples can be represented using different file formats. This version of DirectSound requires the standard Windows WAV file format.</P>
<P>The header of the wave file is in the WAVEFORMATEX layout. For our WAV file, the wFormatTag is WAVE_FORMAT_PCM, which identifies the standard Windows WAV file format that DirectSound understands. This format assumes no compression, and therefore each sample is a fixed size. Check out the documentation for WAVEFORMATEX to see how these fields may vary for compressed file formats.</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct 
  {
  WORD  wFormatTag;        // Waveform Format
  WORD  nChannels;         // 1 = mono, 2 = stereo
  DWORD nSamplesPerSec;    // Samples per second
  DWORD nAvgBytesPerSec;   // Bytes per sec on playback
  WORD  nBlockAlign;       // Alignment of each sample
  WORD  wBitsPerSample;    // Size of each sample
  WORD  cbSize;            // Xtra bytes for Xtra info
  } 
WAVEFORMATEX;</PRE>
<P> </P>
<P>A WAV file is a tagged data file, so the first three DWORDs identify the format and size of the wave file. After that, you search through the file for four-byte sequences of the characters "fmt " (there is a space for the fourth character) to find the WAVEFORMATEX header, and "data" to find the samples.</P>
<P><B>Figure 3</B> contains WAVE.C, a file that I have put together from a bunch of different samples. The WAVEFILE structure declared at the top of the file is just my own way of keeping everything in one handy place. The functions allocate a chunk of memory to hold the WAV, and then fill out the WAVEFILE structure to indicate the positions of the header and data inside the chunk of memory. It is the responsibility of the caller of these functions to toss the memory when the program is finished with them.</P>
<P><B> Figure 3  WAVE.C</B></P>
<P><BR></P>
<PRE> #include "windonut.h"

/*=================================================================
 *
 *  File:       wave.c
 *  Content:    Routines for getting waves from files or resources
 *
 ******************************************************************/

#include &lt;windowsx.h&gt;
#include &lt;mmsystem.h&gt;

typedef struct tagWAVEFILE
  {
  DWORD           cbSize;                // Size of file
  LPWAVEFORMATEX  pwfxInfo;              // Wave Header
  LPBYTE          pbData;                // Wave Bits
  }
WAVEFILE, *LPWAVEFILE;

static const char c_szWAV[] = "WAV";

// Function Prototypes  
BOOL wave_ParseWaveMemory(void *pvRes, 
                          WAVEFORMATEX **ppWaveHeader, 
                          BYTE **ppbWaveData,
                          DWORD *pcbWaveSize);


/////////////////////////////////////////////////////////////////
//
// WAVE_LoadResource: Gets a wave file into the memory pointed 
//                    to by pWaveFile from a resource.
//
/////////////////////////////////////////////////////////////////

LPVOID WAVE_LoadResource
  (LPSTR         lpName,     // Filename to use
   HANDLE        hModule,    // hInst of app with WAVE
   LPWAVEFILE    pWaveFile)  // Points to the struct to fill
{
    HRSRC   hResInfo;
    HGLOBAL hResData;
    void    *pvRes;
    DWORD   dwSize;
    LPVOID  lpMemory;

    // Find the resource and load into memory
    if (((hResInfo = FindResource(hModule, lpName, c_szWAV)) != NULL) &amp;&amp;
        ((hResData = LoadResource(hModule, hResInfo)) != NULL) &amp;&amp;
        ((pvRes = LockResource(hResData)) != NULL))
        {
        // If we found it, copy the bits from the resource into
        // our own chunk of memory
        dwSize = GlobalSize(pvRes);
        lpMemory = MEMORY_New (dwSize);
        memcpy (lpMemory, pvRes, dwSize);
        UnlockResource(hResData);
        FreeResource(hResData);

        // Parse it out
        if (wave_ParseWaveMemory(lpMemory, 
                                 &amp;(pWaveFile-&gt;pwfxInfo), 
                                 &amp;(pWaveFile-&gt;pbData), 
                                 &amp;(pWaveFile-&gt;cbSize)))
          {
          return lpMemory;  // OK
          }
        }

    return NULL;
}
///////////////////////////////////////////////////////////////////////////////
//
// WAVE_LoaFile: Gets a wave file into the memory 
//               pointed to by pWaveFile from a file
//
///////////////////////////////////////////////////////////////////////////////

LPVOID WAVE_LoadFile    
  (LPSTR         szFileName,  // Filename to use
   LPWAVEFILE    pWaveFile)   // Points to the struct to fill
{
    HANDLE   hFile;
    OFSTRUCT of;
    LPVOID   lpMemory;
    DWORD    dwSize, dwSizeRead;

    // Open da file and read da bits
    hFile = (HANDLE)OpenFile ( szFileName, &amp;of, OF_READ );
    dwSize = _llseek ( (HFILE)hFile, 0, FILE_END );
    _llseek ( (HFILE)hFile, 0, FILE_BEGIN );
    lpMemory = MEMORY_New (dwSize);
    if (!ReadFile(hFile, lpMemory, dwSize, &amp;dwSizeRead, NULL ))
      MessageBox ( NULL, "Readfile failed", "", MB_OK );
    _lclose ( (HFILE)hFile );

    // Parse it out
    if (wave_ParseWaveMemory(lpMemory, 
                             &amp;(pWaveFile-&gt;pwfxInfo), 
                             &amp;(pWaveFile-&gt;pbData), 
                             &amp;(pWaveFile-&gt;cbSize)))
        {
        return lpMemory;  // OK
        }

    return NULL; // Failure
}

//////////////////////////////////////////////////////////////////
//
// wave_ParseWaveMemory
//   Parses a chunk of memory into the header and samples.
//   This is done by looking for the "fmt " and "data"
//   fields in the memory.
//
//////////////////////////////////////////////////////////////////

BOOL wave_ParseWaveMemory

  (LPVOID          lpChunkOfMemory, // Points to raw ram
   LPWAVEFORMATEX  *lplpWaveHeader, // Points to pointer to header
   LPBYTE          *lplpWaveSamples,// Points to pointer to samples
   LPDWORD         lpcbWaveSize)    // Points to size
{
    LPDWORD pdw;
    LPDWORD pdwEnd;
    DWORD   dwRiff;
    DWORD   dwType;
    DWORD   dwLength;

    // Set defaults to NULL or zero
    if (lplpWaveHeader)
        *lplpWaveHeader = NULL;

    if (lplpWaveSamples)
        *lplpWaveSamples = NULL;

    if (lpcbWaveSize)
        *lpcbWaveSize = 0;

    // Set up DWORD pointers to the start of the chunk
    // of memory.
    pdw = (DWORD *)lpChunkOfMemory;

    // Get the type and length of the chunk of memory
    dwRiff = *pdw++;
    dwLength = *pdw++;
    dwType = *pdw++;

    // Using the mmioFOURCC macro (part of Windows SDK), ensure
    // that this is a RIFF WAVE chunk of memory
    if (dwRiff != mmioFOURCC('R', 'I', 'F', 'F'))
      return FALSE;      // not even RIFF

    if (dwType != mmioFOURCC('W', 'A', 'V', 'E'))
      return FALSE;      // not a WAV

    // Find the pointer to the end of the chunk of memory
    pdwEnd = (DWORD *)((BYTE *)pdw + dwLength-4);

    // Run through the bytes looking for the tags
    while (pdw &lt; pdwEnd)
      {
      dwType   = *pdw++;
      dwLength = *pdw++;

      switch (dwType)
        {
        // Found the format part
        case mmioFOURCC('f', 'm', 't', ' '):

          if (lplpWaveHeader &amp;&amp; !*lplpWaveHeader)
            {
            if (dwLength &lt; sizeof(WAVEFORMAT))
              return FALSE; // something's wrong! Not a WAV

            // Set the lplpWaveHeader to point to this part of
            // the memory chunk
            *lplpWaveHeader = (LPWAVEFORMATEX)pdw;

            // Check to see if the other two items have been
            // filled out yet (the bits and the size of the
            // bits). If so, then this chunk of memory has
            // been parsed out and we can exit
            if ((!lplpWaveSamples || *lplpWaveSamples) &amp;&amp;
                (!lpcbWaveSize || *lpcbWaveSize))
              {
              return TRUE;
              }
            }
          break;

        // Found the samples
        case mmioFOURCC('d', 'a', 't', 'a'):

          if ((lplpWaveSamples &amp;&amp; !*lplpWaveSamples) ||
              (lpcbWaveSize &amp;&amp; !*lpcbWaveSize))
            {
            // Point the samples pointer to this part of the
            // chunk of memory.
            if (lplpWaveSamples) *lplpWaveSamples = (LPBYTE)pdw;

            // Set the size of the wave
            if (lpcbWaveSize)    *lpcbWaveSize = dwLength;

            // Make sure we have our header pointer set up.
            // If we do, we can exit
            if (!lplpWaveHeader || *lplpWaveHeader)
              return TRUE;
            }
          break;

        } // End case

      // Move the pointer through the chunk of memory
      pdw = (DWORD *)((BYTE *)pdw + ((dwLength+1)&amp;~1));
      }

  // Failed! If we made it here, we did not get all the peices
  // of the wave
  return FALSE;
}</PRE>
<P>Now that you know what a wave file is, and have some nice helper functions to get a wave file into a format readable by DirectSound, let's move on to making some noise!</P>
<P> </P>
<H2><A NAME="sec1"></A>  DirectSound Objects</H2><P>Like DirectDraw, DirectSound uses the COM programming model, and all of the APIs are exposed as COM style interfaces. All except two, DirectSoundCreate and DirectSoundEnumerate. DirectSoundEnumerate is used to see what DirectSound devices are available in the system. Usually, there will only be one device, but the Power User with Toys by the Zillions (PUTZ) may have more than one sound card in his machine or he may have some really bitchin' Camaro card that has two complete sound units on it. In this case, you would have a choice of devices to create your DirectSound object for. Getting back to Earth, let's assume you are writing games for the rest of us with only one sound card.</P>
<P>DirectSoundCreate does exactly what you would want it to do: it creates a pointer to IDirectSound that you can then use to access all of the interfaces.</P>
<P> </P>
<P><BR></P>
<PRE> if(DS_OK!=DirectSoundCreate(NULL,&amp;lpDirectSound,NULL))
  {
  MessageBox (hWnd, "Silent Bob sez no Direct Sound!", 
              "MSJ", MB_OK );
  }</PRE>
<P> </P>
<P>The first parameter is NULL if you want the default Windows sound device; otherwise it is a GUID representing the desired DirectSound driver that you picked from calling DirectSoundEnumerate. Once you have this DirectSound object, you can then set up a few characteristics and find out about your capabilities.</P>
<P>Just as in DirectDraw, you need to set the cooperative level before you can start to use any of the functionality. Unlike DirectDraw, you don't want to be Stalinist and take control of everything. You should set the cooperative level to DSSCL_NORMAL, which is a nice friendly mode that allows other apps on the system to live with DirectSound. (Note: DirectSound does allow multiple apps to use DirectSound simultaneously, unless DirectSound is using the Hardware Emulation Layer due to your totally lame card.) Why? Future versions of DirectSound will allow applications to play sounds that are audible even when the application does not have input focus. A typical call to SetCooperativeLevel would look like this:</P>
<P> </P>
<P><BR></P>
<PRE> if (DS_OK != lpDirectSound-&gt;lpVtbl-&gt;
    SetCooperativeLevel (lpDirectSound, ghWnd, 
                         DSSCL_NORMAL))
     {
     MessageBox(ghWnd,"SilentBobdon'twannacooperate!", 
                  "MSJ", MB_OK );
      }</PRE>
<P> </P>
<P>lpDirectSound is obtained from DirectSoundCreate, and ghWnd is the top level window of your application.</P>
<P>After you have done the two required operations above, you can set up the one and only option about the system: the speaker configuration. </P>
<P>Not so fast. The speaker configuration is something best left alone (since the only two features currently supported are stereo and mono). The SetSpeakerConfig API does let  you specify parameters to change the speaker configuration to indicate headphones, monophonic, stereophonic, quadraphonic, surround sound, or googolphonic. Read the docs for more information on this currently docile function.</P>
<P>In addition to the SetSpeakerConfig interface, there is a matching GetSpeakerConfig interface to tell your program what DirectSound knows about the current configuration.</P>
<P> </P>
<H2><A NAME="sec2"></A>  Building DirectSound Buffers</H2><P>Once you have created your DirectSound object, it is time to create DirectSound buffers. A buffer in DirectSound represents an audio stream (wave) that can be played back. There are two kinds of buffers: primary and secondary. The primary buffer is what is actually playing out the speakers. Secondary buffers are sounds that are ready to play. There is only one primary buffer, and your application should simply allow DirectSound to maintain it. Your program can access the primary buffer directly, but your application would then be responsible for real-time playback handling of the buffer at all times. Your application must respond in a very time-critical fashion, something a Ring 3 application cannot accomplish easily. Directly accessing primary buffers is beyond the scope of this article. </P>
<P>If you want to hear a sound in a secondary buffer, you simply "play it" into the primary buffer, a process I'll describe later. You can do basic and advanced operations with DirectSound buffers. The basics, such as creating, destroying, filling, and playing them, are required. The advanced operations involve tweaking attributes of the buffers to change things like frequency, balance, and volume. Let's take a look at these operations.</P>
<P> </P>
<H2><A NAME="sec3"></A>  Basic Operations on DirectSound Buffers</H2><P>By default  a primary buffer has already been created for you. To create the secondary buffer, you must perform these three steps:</P>
<UL><LI>    Set up a DSBUFFERDESC structure that defines the specific characteristics of the buffer.</LI><LI>   Call the CreateSoundBuffer interface off the DirectSound object. This will give you a pointer to a DirectSoundBuffer object.</LI><LI>   Copy the wave samples/bits into the buffer.</LI></UL><P>The DSBUFFERDESC structure has five fields:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct 
  {
  DWORD     dwSize;        // sizeof(DSBUFFERDESC)
  DWORD     dwFlags;       // Buffer attributes
  DWORD     dwBufferBytes; // Size of wave file
  DWORD     dwReserved;    // Must be zero!

  LPWAVEFORMATEX lpwfxFormat; // Points to WAVEFORMATEX
  } 
DSBUFFERDESC;</PRE>
<P> </P>
<P>The dwFlags field can have a combination of the values shown in <B>Figure 4</B>. I'll discuss these flags further below.</P>
<P><B> Figure 4  dwFlags in DSBUFFERDESC</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="162pt" VALIGN="TOP"><COL WIDTH="279pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Buffer Description Flags</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_PRIMARYBUFFER</P></TD><TD VALIGN="TOP"><P>Buffer is a primary sound buffer.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_STATIC</P></TD><TD VALIGN="TOP"><P>Indicates that the buffer will be used for static sound data. Typically used for buffers that are loaded once and played many times. These buffers are candidates for hardware (on-board) memory.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_LOCHARDWARE</P></TD><TD VALIGN="TOP"><P>Forces the buffer to use hardware mixing, even if DSBCAPS_STATIC is not specified. If this device does not support hardware mixing or the required hardware memory is not available, CreateSoundBuffer  will fail. Note that there is no guarantee that a mixing channel will be available for this buffer—the application must make sure of this.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_LOCSOFTWARE</P></TD><TD VALIGN="TOP"><P>Forces the buffer to be stored in software (main system) memory and use software mixing, even if DSBCAPS_STATIC is specified and hardware resources are available.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_CTRLALL</P></TD><TD VALIGN="TOP"><P>Buffer must have all control capabilities.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_CTRLDEFAULT</P></TD><TD VALIGN="TOP"><P>Buffer should have default control options. This is the same as specifying the Pan, Volume, and Frequency flags.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_CTRLFREQUENCY</P></TD><TD VALIGN="TOP"><P>Buffer must have frequency control capability.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_CTRLPAN</P></TD><TD VALIGN="TOP"><P>Buffer must have pan control capability.</P></TD></TR><TR><TD VALIGN="TOP"><P> DSBCAPS_CTRLVOLUME</P></TD><TD VALIGN="TOP"><P>Buffer must have volume control capability.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>As just mentioned, to create a secondary buffer, you must first fill out this DSBUFFERDESC structure. The WAVE.C file contains all of the information needed to create a buffer. So let's assume you are trying to create a sound buffer out of the "Tub Full of Tires.wav" file (see <B>Figure 5</B>). Once this code succeeds, lpDSB will point to a DirectSoundBuffer. At this point, you can copy blocks of sound data into the buffer, using the Lock and Unlock interfaces on the DirectSoundBuffer (see <B>Figure 6</B>).</P>
<P><B> Figure 5  Creating a Sound Buffer</B></P>
<P><BR></P>
<PRE>   // These variables are used in Steps 1 and 2
  LPVOID              lpWaveData;
  WAVEFILE            WaveFile;
  DSBUFFERDESC                      dsbd;
  LPDIRECTSOUNDBUFFER               lpDSB;
  
  // These variables are used in step 3, further down below
  BYTE              *pbData         = NULL;
  BYTE              *pbData2        = NULL;
  DWORD             dwLength;
  DWORD             dwLength2;


  lpWaveData = WAVE_LoadFile ( "Tub Full of Tires.wav", &amp;WaveFile );

  // Step 1: Set up the direct sound buffer. 
  memset(&amp;dsbd, 0, sizeof(DSBUFFERDESC));

  dsbd.dwSize                 = sizeof(DSBUFFERDESC);
  // We want a buffer that lives on the sound card's memory 
  // (DSBCAPS_STATIC) and can have the pan, volume, and 
  // frequency adjusted (DSBCAPS_CTRLDEFAULT)
  dsbd.dwFlags                = DSBCAPS_CTRLDEFAULT | DSBCAPS_STATIC ;

  // Set up the size and format
  dsbd.dwBufferBytes          = WaveFile.cbSize; 
  dsbd.lpwfxFormat            = WaveFile.pwfxInfo;  // Must be a PCM format!

  // Step 2: Create the buffer
  if (DS_OK != lpDirectSound-&gt;lpVtbl-&gt;
        CreateSoundBuffer(lpDirectSound, 
                          &amp;dsbd,
                          &amp;lpDSB),
                          NULL))
    {
    MessageBox (hWnd, 
                "Silent Bob sez CreateSoundBuffer failed", 
                "MSJ", 
                MB_OK );
    }</PRE>
<P><B> Figure 6  Copying Chunks of Data into a Buffer</B></P>
<P><BR></P>
<PRE>   // Lock down the DirectSound buffer
  if (DS_OK == lpDSB-&gt;lpVtbl-&gt;
        Lock(lpDSB,      // Points to DirectSoundBuffer
             0,          // Offset into buffer to start writing
             WaveFile.cbSize, // Size of wave file to copy in
             &amp;pbData,    // Points to first block of sound data
             &amp;dwLength,  // Length of first block of data
             &amp;pbData2,   // Points to second block of sound data
             &amp;dwLength2, // Length of second block of data
             0L))        // Flags
    {
    // Copy first chunk
    memcpy(pbData, WaveFile.pbData, dwLength);

    // Copy second chunk
    if (dwLength2) memcpy(pbData2, WaveFile.pbData+dwLength , dwLength2);

    // Free up the memory allocated in the WAVE_LoadFile function, since we
    // have copied it to the buffer
    MEMORY_Delete (lpWaveData);

    // Unlock the buffer
    if (DS_OK != lpDSB-&gt;lpVtbl-&gt;Unlock(pbData, dwLength, pbData2, dwLength2))
      {
      MessageBox (hWnd, "Silent Bob sez Unlock failed", "MSJ", MB_OK );
      }
    }
  else
    {
    MessageBox (hWnd, "Silent Bob sez Lock failed", "MSJ", MB_OK );
    }</PRE>
<P>Notice in <B>Figure 6</B> that the Lock and Unlock interfaces give you back two pointers, pbData and pbData2. This is due to the circular nature of sound buffers. If you provided an offset into the buffer during the Lock call, the first pointer would point to the chunk of memory starting at the offset and going to the end of the buffer (see <B>Figure 7</B>). The second pointer would point to the chunk of memory beginning at the start of the buffer and ending at the byte before the offset.</P>
<P><img src="GAMES7.gif"></P>
<P><B> Figure 7  Sound Buffer Offsets</B></P>
<P>Unlike the conventional Lock and Unlock-style Windows APIs you may be used to, the Lock and Unlock interfaces under DirectSound are actually wrappers around very device-specific code to get the bits of your wave file to the sound card. Some sound cards actually can make a chunk of their own memory available to the CPU's address space, while others cannot. You don't care how this is done, since DirectSound'sdriverswrap this up in the Lock/Unlock metaphor. The memory pointer returned by Lock actually points to a virtualized memory address. When you write into the memory pointed to by this address, the DirectSound driver catches the memory-write operation and gets the bits to their destination in a manner defined by the device driver.</P>
<P>This means that the pointer returned by Lock is a write-only pointer. You are allowed to copy bits to the "memory" pointed to by the address returned by Lock, but you cannot read bits from the "memory."</P>
<P>Once you have copied the bits of your wave file into a DirectSound buffer with the Lock/Unlock interfaces, you can then call other DirectSound interfaces to play the wave. Calling Play on a sound buffer actually mixes the bits of the buffer's wave with any bits currently residing in the primary sound buffer. "Looped" sound buffers are buffers that play their waves repeatedly.</P>
<P>If you play a buffer that is already playing, DirectSound will stop playing the buffer and restart it again at the point you specify in your call to the Play interface. Think of a CD player. If you are playing your favorite Beatles song and halfway through it you press the restart button, your Beatles tune starts over again. That's the same way a DirectSound buffer works.</P>
<P>If you have a sound that needs to be played multiple times, and possibly simultaneously (such as bullets or explosions), you need multiple buffers that contain the same wave. DirectSound provides a method to duplicate a sound buffer by creating a virtual copy of the original buffer. There is only one copy of the actual bits that compose the wave, but two different sound buffers point to it. Once you have this virtual copy of the buffer, you can play it independantly or simultaneously with the original buffer, whenever you like. I'll cover duplication of DirectSound buffers in a moment.</P>
<P>The code in <B>Figure 8</B> uses the CD player analogy to play a DirectSound buffer. The code first checks to see if the buffer is already playing. If the buffer is playing, the play pointer is reset to the start of the buffer (the beginning of the song). Since the buffer is already playing, the music starts over. If the buffer was not playing, then the Play interface on the DirectSound buffer is called to get it started.</P>
<P><B> Figure 8  Playing a Sound Buffer</B></P>
<P><BR></P>
<PRE> // Set position back to zero.  Works if buffer is stopped or playing.
lpDSB-&gt;lpVtbl-&gt;SetCurrentPosition( lpDSB, 0 );

// Play buffer from current position.  Has no effect on playing buffers,
// except if you specific new flags (last parameter), in which case the
// new flag value will replace the old flag value).
lpDSB-&gt;lpVtbl-&gt;Play( lpDSB, 0, 0, 0 );  

  // Get the status of the wave pointed to by lpDSB
  if (DS_OK == lpDSB-&gt;lpVtbl-&gt;
        GetStatus(lpDSB, &amp;dwStatus))
        {
        if (dwStatus &amp; DSBPLAY_PLAYING)
          {
          // Don't bother playing, just restart
          if (DS_OK != lpDSB-&gt;lpVtbl-&gt;
                SetCurrentPosition(lpDSB, 0))
            {
            MessageBox (hWnd, "Silent Bob sez SetCurrentPosition failed", 
                        "MSJ", MB_OK );
            }  // endif scp
          } // endif dwStatus
        else
          {
          if (DS_OK != lpDSB-&gt;lpVtbl-&gt;
                Play(lpDSB,   // Buffer to play
                     0,       // Reserved1 
                     0,       // Reserved2
                     0))      // Zero or DSBPLAY_LOOPING
             {
             MessageBox (hWnd, "Silent Bob sez Play failed", 
                         "MSJ", MB_OK );
             }
          }
        } // endif GetStatus
      else 
        {
        MessageBox (hWnd, "Silent Bob sez GetStatus failed", 
                    "MSJ", MB_OK );
        }</PRE>
<P>That's enough to get you started writing a noisy app! Except for the cleanup described down below, you can implement some fairly sophisticated sound in your game and you can start killing those baby seals and hear the pleasing sound of searing flesh from your ACM404-B Missile Launcher 95.</P>
<P> </P>
<H2><A NAME="sec4"></A>  Advanced Options on DirectSound Buffers</H2><P>Here's the gravy. Along with the pedestrian operations of creating and playing sounds, you can also dink around with the volume, balance, and frequency of the sound. For example, you could take a normally looping sound of a car engine, and you can tweak its frequency to make it sound like the engine is revving. Or you could move the sound of the racing car from the left to right speaker to match what's happening on the screen. Or you can lower the volume as your hot Porsche drives further away. Let's look at the six methods you can call on a DirectSoundBuffer for these three attributes:</P>
<P> </P>
<P><BR></P>
<PRE> GetFrequency (lpDS, LPDWORD lpdwFrequency)
SetFrequency (lpDS, DWORD   dwFrequency)
GetPan       (lpDS, LPDWORD lpdwPan)
SetPan       (lpDS, DWORD   dwPan)
GetVolume    (lpDS, LPDWORD lpdwVolume)
SetVolume    (lpDS, DWORD   dwVolume)</PRE>
<P> </P>
<P>For the frequency methods, dwFrequency indicates the number of samples getting played per second. Making this value higher increases the overall pitch of the sound; lowering this value decreases the overall pitch. Before you twiddle the frequency of a sound, you will want to call GetFrequency first to find out the current setting, because not all wave files use the same sampling rate. Some waves have 22,050 samples per second, others have 11,025 samples per second, and some others are 44,100 samples per second. Don't assume anything about the sampling rate (except that DirectSound currently only allows sampling rates up to 100,000 samples per second); always query the DirectSound buffer for the sampling rate. <B>Figure 9</B> contains some code to double the sampling rate of a DirectSound buffer. For the pan methods (balance), dwPan specifies how much to turn down one of the speakers, in hundredths of decibels. For example, if you want to move the balance 3dB left, you would turn the right speaker down 3dB. To move the balance left, use a negative number (here, –300). To move the balance right, use a positive number. The maximum amount you can specify is 100dB. Below is some sample code that pans a one-second wave file from left to right. It adjusts the pan volume in 3dB increments, which means it must cover a range of –10000 to 10000 in 67 steps (20000/300 = 66.6). To do this pan in one second, you need to wait 1/67th (0.0149) of a second between calls to SetPan. I used GetTickCount to get close to this number, but left out the very necessary DS_OK error-checking purely to make the code more readable.</P>
<P><BR></P>
<PRE> int idB;
int iTickCount;
// Start playing the buffer
lpDSB-&gt;lpVtbl-&gt;Play(lpDSB,   // Buffer to play
                    0,       // Reserved1 
                    0,       // Reserved2
                    0))      // Zero (not looping)
                    idB = -10000;
                // Right channel silent (sound on left)
while (iDB &lt; 10000)
  {
  // Set the pan rate
  lpDS-&gt;lpVtbl-&gt;SetPan(lpDSB, idB);

  // Add three decibels for the next time
  idB = min (10000, idB+300);  

  // Wait 0.0149 of a second
  iTickCount = GetTickCount();
  while ((GetTickCount() - iTickCount) &lt; 149);
  }</PRE>
<P> </P>
<P><B> Figure 9  Doubling the Sampling Rate</B></P>
<P><BR></P>
<PRE> // Find out the current sample rate
if (DS_OK == lpDS-&gt;lpVtbl-&gt;GetFrequency (lpDS, &amp;dwFrequency))
  {
  // Double it, keeping it under 100000
  dwFrequency = min (dwFrequency*2, 100000);
  // Set the new rate
  if (DS_OK != SetFrequency (lpDS, dwFrequency))
    {
    MessageBox (hWnd, "Silent Bob sez SetFrequency failed", "MSJ", MB_OK );
    }
  }
else 
  {
  // Frequency will fail if the DirectSound buffer
  // was not created with the DSBCAPS_CTRLFREQUENCY
  // flag (or DSBCAPS_CTRLDEFAULT).
  MessageBox (hWnd, "Silent Bob sez GetFrequency failed", "MSJ", MB_OK );
  }</PRE>
<P>And finally, the volume methods allow you to turn down the volume of a wave (the current version of DirectSound does not support amplification). A value of 0 leaves the wave at its original volume, and negative values indicate the number of decibels to turn down the wave. For example, if you wanted to play the wave at half its current volume (–10dB), you would use code like this:</P>
<P> </P>
<P><BR></P>
<PRE> // Find out the current volume
if (DS_OK == lpDS-&gt;lpVtbl-&gt;GetVolume (lpDS, &amp;dwVolume))
  {
  // Half it by lowering 10dB, unless it is 
  // essentially silent (-100dB)
  dwVolume = max (-10000, dwVolume - 100);
  // Set the new rate
  if (DS_OK != SetVolume (lpDS, dwVolume))
    { MessageBox (hWnd,"SilentBobsezSetVolumefailed", 
                  "MSJ", MB_OK );
     }
  }
else 
  {
  // Volume will fail if the DirectSound buffer
  // was not created with the DSBCAPS_CTRLVOLUME
  // flag (or DSBCAPS_CTRLDEFAULT).
  MessageBox (hWnd, "Silent Bob sez GetVolume failed", 
              "MSJ", MB_OK );
  }</PRE>
<P> </P>
<P>If you want to play more than one copy of a sound, you can use the DuplicateSoundBuffer method on DirectSound. It will return a new IDirectSoundBuffer interface that refers to the same sound buffer memory. The second virtual buffer may be played and stopped independently of the original; also, parameters such as volume and frequency can also be controlled independently. However, if you change the sound buffer memory by Locking and writing, it will affect all duplicated buffers as well. This function takes two parameters: the source and the duplicate buffer! Here's a function to duplicate a wave (assuming lpDirectSound is a global variable pointing to the DirectSound object):</P>
<P> </P>
<P><BR></P>
<PRE> LPDIRCTSOUNDBUFFER DuplicateBuffer (LPDIRCTSOUNDBUFFER<BR>                                    lpOriginal )
{
  LPDIRECTSOUNDBUFFER lpDuplicate;

  if (DS_OK == lpDirectSound-&gt;lpVtbl-&gt;
                 DuplicateSoundBuffer(lpDirectSound,
                                      lpOriginal,
                                      &amp;lpDuplicate) )
    {
    return lpDuplicate;
    }
  else
    { MessageBox (hWnd, 
          "Silent Bob sez DuplicateSoundBuffer failed", 
          "MSJ", MB_OK );
    return NULL;
    }
}</PRE>
<P> </P>
<H2><A NAME="sec5"></A>  Cleanup</H2><P>When you are finished using a DirectSound buffer, you can free up the memory associated with the buffer using the Release interface:</P>
<P> </P>
<P><BR></P>
<PRE> lpDSB-&gt;lpVtbl-&gt;Release(lpDSB);
lpDSB = NULL;</PRE>
<P> </P>
<P>Once you have released the buffer, lpDSB is invalid, so you should set it to NULL to prevent random crashes caused by pointer reusage. That way you will get an access violation fault instead of some weird COM error (in the case that the pointer was reused for some other COM object).</P>
<P>When you are all finished with the system, call the Release interface on the DirectSound object:</P>
<P> </P>
<P><BR></P>
<PRE> lpDirectSound-&gt;lpVtbl-&gt;Release(lpDirectSound);
lpDirectSound = NULL;</PRE>
<P> </P>
<P>At this point, you can safely call the Windows 95 sndPlaySound API again, since you have released the sound driver of its DirectSound monopoly.</P>
<P> </P>
<H2><A NAME="sec6"></A>  My Thin Code Wrapper</H2><P>I have written a thin little code wrapper to make things a little easier for you to jump right into DirectSound. My wrapper functions in DIRECTSOUND.C (see <B>Figure 10</B>) uses the WAVE.C helper functions. Also, keep in mind that this entire code wrapper is entirely my own personal implementation: it is not part of the Games SDK.</P>
<P><B> Figure 10  DirectSound Wrapper Functions</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="180pt" VALIGN="TOP"><COL WIDTH="261pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> DIRECTSOUND_Enable</P></TD><TD VALIGN="TOP"><P>Enables DirectSound</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_Disable</P></TD><TD VALIGN="TOP"><P>Disables DirectSound</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_LoadWave</P></TD><TD VALIGN="TOP"><P>Loads a WAV file into a buffer</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_UnLoad</P></TD><TD VALIGN="TOP"><P>Unloads and destroys a buffer</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_Play</P></TD><TD VALIGN="TOP"><P>Plays a buffer</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_Stop</P></TD><TD VALIGN="TOP"><P>Stops playing a buffer</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_IsPlaying</P></TD><TD VALIGN="TOP"><P>Checks to see if a buffer is playing</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_SetFrequency</P></TD><TD VALIGN="TOP"><P>Setsabuffer's frequency</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_SetBalance</P></TD><TD VALIGN="TOP"><P>Sets a buffer's left to right balance</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_SetVolume</P></TD><TD VALIGN="TOP"><P>Sets a buffer's volume</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_SetLooping</P></TD><TD VALIGN="TOP"><P>Sets a buffer's looping</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_GetFrequency</P></TD><TD VALIGN="TOP"><P>Gets a buffer's freuqnecy</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_GetBalance</P></TD><TD VALIGN="TOP"><P>Gets a buffer's balance</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_GetVolume</P></TD><TD VALIGN="TOP"><P>Gets a buffer's volume</P></TD></TR><TR><TD VALIGN="TOP"><P> DIRECTSOUND_GetLooping</P></TD><TD VALIGN="TOP"><P>Gets a buffer's looping status</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Let's take a look at the two structures defined in DIRECTSOUND.H:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct tagDIRECTSOUNDOBJECT
  {
  LPDIRECTSOUND         lpDirectSound;
  }
DIRECTSOUNDOBJECT, *LPDIRECTSOUNDOBJECT;

typedef struct tagDIRECTSOUNDWAVE
  {
  WAVEFILE WaveFile; // Standard WaveFile from WAVE.H
  LPDIRECTSOUNDBUFFER pDSB; // Ptr to dir. sound buffer
  DWORD dwFreq;    // Frequency
  DWORD dwPan;     // Panning info (L to R balance)
  DWORD dwVol;     // Volume
  BOOL  bLooped;   // Looped = TRUE (plays repeatedly)
  BOOL  bPlaying;  // Is this wave playing?
  } 
DIRECTSOUNDWAVE, *LPDIRECTSOUNDWAVE;</PRE>
<P> </P>
<P>The DIRECTSOUNDOBJECT structure is simply a wrapper around the LPDIRECTSOUND interface; I did this just to make it easier to port this wrapper to C++ if I desire. There are only one of these objects in my app. The DIRECTSOUND_Enable and DIRECTSOUND_Disable functions calltheDirectSoundCreateandlpDirectSound-&gt;lpVtbl-&gt;Release functions respectively.</P>
<P>The DIRECTSOUNDWAVE structure is a wrapper aroundaWAVEFILEstructure(fromWAVE.H)andanLPDIRECTSOUNDBUFFERinterfacepointer.The DIRECTSOUND_LoadWave function first calls the WAVE_LoadFile function to fill out the wave file portion of the structure. Then it calls lpDirectSound-&gt;lpVtbl-&gt;CreateSoundBuffer to create a DirectSound secondary buffer, and then it uses the pDSB-&gt;lpVtbl-&gt;Lock and pDSB-&gt;lpVtbl-&gt;Unlock interfaces to copy the bits from the WaveFile structure into the buffer. Finally, the memory in the WaveFile structure is released.</P>
<P>The dwFreq, dwPan, dwVol, bLooped, and bPlaying fields are cached values of the actual DirectSound buffer to avoid the extra COM calls. </P>
<P>The DIRECTSOUND_Play and DIRECTSOUND_Stop functions call the appropriate interfaces on the DirectSound buffer. The DIRECTSOUND_IsPlaying function returns the cached value that was set/cleared in one of the above Play or Stop functions.</P>
<P>The remaining Set/Get pairs from DIRECTSOUND.C also call the appropriate functions described above in the Advanced Options on DirectSound Buffers section. As you can see, this wrapper is rice-paper thin, even compared to the DirectDraw wrapper I wrote in the first article. That's because sounds basically just start and stop, while pictures require work to animate.</P>
<P>Let's look at how my WinDonut app has been modified to make lots of noise.</P>
<P> </P>
<H2><A NAME="sec7"></A>  Makin' WinDonut Noisy!</H2><P>The WinDonut sample app from my previous article had a little ship piloted by Ã (the Programmer Formerly Known as Brian) shooting little red donuts as they floated in space. Although in space no one can hear you scream, they can certainly hear Ã's ship flying around and shooting donuts. Just as the silent WinDonut loaded a bitmap file (WINDONUT.BMP) for its graphics, the noisy WinDonut loads fourwavefiles:THRUST.WAV,FIRE.WAV,BACKGROUND.WAV, and EXPLODE.WAV. The thrust wave is played repeatedly (looping) while the thrust key is held down, the background wave is played continuously, and the fire and explode waves are played when the user fires a shot or when a donut is destroyed. Let's look at the code injections into WinDonut.</P>
<P>I added some new global variables in WINDONUT.H:</P>
<P> </P>
<P><BR></P>
<PRE> GLOBAL      LPDIRECTSOUNDOBJECT     glpDirectSound;
GLOBAL      LPDIRECTSOUNDWAVE       glpSoundFire;
GLOBAL      LPDIRECTSOUNDWAVE       glpSoundExplosion;
GLOBAL      LPDIRECTSOUNDWAVE       glpSoundThrust;
GLOBAL      LPDIRECTSOUNDWAVE       glpSoundBackground;</PRE>
<P> </P>
<P>glpDirectSound points to the DIRECTSOUNDOBJECT structure discussed above; glpSoundFire, glpSoundExplosion, glpSoundThrust, and glpSoundBackground point to the four waves loaded from those four wave files. This block of code was added to WINDONUT_InitGame (in the file WINDONUT.C):</P>
<P> </P>
<P><BR></P>
<PRE> if (glpDirectSound = DIRECTSOUND_Enable())
 {
 glpSoundBackground=DIRECTSOUND_LoadWave(glpDirectSound, 
                                       "background.wav");
 glpSoundFire = DIRECTSOUND_LoadWave (glpDirectSound,
                                      "fire.wav" );
 glpSoundExplosion=DIRECTSOUND_LoadWave(glpDirectSound, 
                                         "explode.wav");
 glpSoundThrust = DIRECTSOUND_LoadWave (glpDirectSound,
                                        "thrust.wav" );
 glpSoundBackground-&gt;bLooped = TRUE;
 glpSoundThrust-&gt;bLooped = TRUE;

 DIRECTSOUND_Play (glpDirectSound, glpSoundBackground );
 }</PRE>
<P> </P>
<P>If DIRECTSOUND_Enable succeeds, the four wave files are loaded, the looping flag in the private structure is set to TRUE for the background and thrust waves, and the background "music" begins.</P>
<P>The FigureShipPosition function in WINDONUT.C is where the keyboard input is checked for ship movement. Thiscodeisexecutedwhenthethrustkeyishelddown:</P>
<P> </P>
<P><BR></P>
<PRE> if (glpSoundThrust)
   if (!(glpSoundThrust-&gt;bPlaying))
     DIRECTSOUND_Play (glpDirectSound, glpSoundThrust);</PRE>
<P> </P>
<P>And if the thrust key is released, this code is called:</P>
<P> </P>
<P><BR></P>
<PRE> if (glpSoundThrust)
   if (glpSoundThrust-&gt;bPlaying)
     DIRECTSOUND_Stop (glpDirectSound, glpSoundThrust);</PRE>
<P> </P>
<P>As you can see, these lines of code turn on and off the looping thrust sound for the ship.</P>
<P>In the FigureBulletPositions function in WINDONUT.C, this line of code is added when a bullet is created:</P>
<P> </P>
<P><BR></P>
<PRE> if (glpSoundFire)
   DIRECTSOUND_Play (glpDirectSound, glpSoundFire);</PRE>
<P> </P>
<P>And finally, when a donut is hit in the FigureCollisions function in WINDONUT.C, this line of code is called:</P>
<P> </P>
<P><BR></P>
<PRE> if (glpSoundExplosion)
  DIRECTSOUND_Play(glpDirectSound,glpSoundExplosion);</PRE>
<P> </P>
<P>Here's the new shutdown code in the WM_DESTROY section in WINDOWS.C:</P>
<P> </P>
<P><BR></P>
<PRE> if(glpSoundFire) DIRECTSOUND_UnLoad (glpDirectSound,  
                                      glpSoundFire);
if(glpSoundExplosion)DIRECTSOUND_UnLoad(glpDirectSound,
                                    glpSoundExplosion);
if(glpSoundThrust) DIRECTSOUND_UnLoad (glpDirectSound,
                                        glpSoundThrust);
if(glpSoundBackground)DIRECTSOUND_UnLoad(glpDirectSound,
                                   glpSoundBackground);
if(glpDirectSound)DIRECTSOUND_Disable(glpDirectSound );</PRE>
<P> </P>
<P>That's it! If you run WinDonut now, you will find that it makes lots and lots of noise, all mixed together wonderfully. Sure to provide plenty of yuk-yuks for all.</P>
<P> </P>
<H2><A NAME="sec8"></A>  The Future of DirectSound</H2><P>This first version of DirectSound is very powerful. Future versions of DirectSound will emulate 3D "positional" sound via software.</P>
<P>What's positional sound? Currently, each sound has a few attributes: volume, left to right pan, and frequency. If you want to make the sound bounce around a room, you have a huge chore ahead of you. DirectSound 3D will add more attributes to each wave: position, direction, and reflectivity. You will be able to make a sound seem to originate from behind the player and come at them in a downward, dive-bomber fashion. This will even be achievable on two-speaker systems; it is possible to modify waveforms so that listeners think a sound is behind them even though it emanated in front of them (the QSound recording format used by Pink Floyd on a couple of albums uses this sort of technology). This sound modulation is all done by DirectSound 3D or the sound card; all your app will need to do is say where the sound originated from.</P>
<P>Let's go over some stuff you can do right now to make it easy to harness this technology in the future. If you are designing a new game right now and you will want to implement DirectSound 3D in the future, try to maintain the information now that DirectSound 3D will want. Maintain your objects' positions in 3D space, and decide if you'll want your sounds to do things like echo and bounce off things. Here's a description of the 3D coordinate system that's planned for DirectSound 3D (although nothing is final yet):</P>
<UL><LI>    Three-dimensional space is represented by an xyz Cartesian coordinate system, measured in cm.</LI><LI>   Velocity is measured in cm/second.</LI><LI>   The orientation of the sound is a unit vector:  x<SUP>2</SUP>+ y<SUP>2</SUP>+ z<SUP>2</SUP>=1.</LI><LI>   Volume and sound energy are measured in hundredths of a decibel.</LI><LI>   Sound reflectivity (echo) is measure on an arbitrary scale where 0 is not reflective and 255 is completely reflective.</LI><LI>   Sound dissipation is measured in hundredths of dB per meter<SUP>2</SUP>.</LI></UL><P>Write your application so that these values can be computed later on. If you can maintain these values (or just put them in a table), porting your app to use DirectSound 3D will be a snap.</P>
<P>I won't go into any more detail on DirectSound 3D here, since it's subject to change. But you can rest assured that if you maintain the above information, you will have an easier time getting your app to make noises all over the room.</P>
<P> </P>
<H2><A NAME="sec9"></A>  DirectInput</H2><P>Unlike the other Direct features of the Games SDK, DirectInput comes with Windows 95 (by replacing MSJSTICK.DRV). It adds two new APIs (JoyGetPosEx and JoyGetDevCaps) that allow your program to find out information about the installed joystick. And only the joystick—this first incarnation of DirectInput is limited to supporting joystick-like devices. These would include the standard analog joysticks we have all come to hate, the new digital joysticks (such as Microsoft's Sidewinder Pro), and some of those new Nintendo-style controller pads. And I expect a rash of new input devices to swarm the game market over the next year.</P>
<P>First I will talk about the new features and advantages of DirectInput and discuss the placement of DirectInput amongst the New World Order of Windows 95 architecture. Second, I will talk about the calibration and testing of the new joysticks as well as support for multiple joysticks. After I explain how to read the joystick information, I'll modify WinDonut to allow play with the joystick.</P>
<P>DirectInput coupled with digital input devices gives two main benefits: performance and consistency. The analog joysticks we have been using for the past ten years require a tight noninterruptible polling loop to determine the values of the joystick's potentiometers. This polling takes up about ten percent of the entire CPU time for a game, and the results are not always that consistent. Digital joysticks use newer technology to determine the position of the joystick, requiring one poll to find out the position/status of the joystick controllers. The DirectInput joystick driver can just simply ask the joystick in one quick step for all of the information about its position. This means that a digital joystick and DirectInput can instantly add a ten percent performance improvement to your Windows-based game.</P>
<P>In addition to performance, you get consistency. DirectInput requires joystick manufacturers to write minidrivers that will bring some programming consistency to your game app. If a joystick has a throttle, you only need to look in one place to find it. Same goes for the point-of-view hats (for the uninitiated, that's a device on top of the joystick that lets you peek in a particular direction without committing yourself to a move) and extra buttons. And, since the interface with the joystick is handled by DirectInput, and since DirectInput is part of the operating system, players need to calibrate and test the joystick only once. After they have installed their joystick, the calibrations and capabilities of their joysticks are saved in the registry. No more writing those silly "Move yer stick to the upper left and fire, move to lower right, fire, move to center, fire" opening sequences.</P>
<P>And finally, DirectDraw offers a lot more flexibility. Lots-o-buttons, throttles, and up to 16 joysticks are supported in DirectInput. To hook up multiple digital joysticks, all you have to do is get a splitter cable (each joystick will assign itself a digital ID).</P>
<P>Let's take a look at where DirectInput sits in the Windows 95 operating system (see <B>Figure 11</B>). As you can see, the joystick driver model uses both 16- and 32-bit interfaces. VJOYD.VXD is the actual 32-bit Ring 0 driver that polls the joystick device. If your app is Win32-based, your polling of the joystick will be done with the joystick APIs, which live in WINMM.DLL. These APIs map directly down to the VJOYD.VXD device to give you blistering speed. For 16-bit apps, which use MMSYTEM.DLL, there is some thunking through MMSYTEM.DLL that eventually makes it to VJOYD.VXD.</P>
<P><img src="GAMES11.gif"></P>
<P><B> Figure 11  DirectInput Architecture</B></P>
<P>Nonpolling 16-and 32-bit functions, such as calibration and testing, map to the MMSYSTEM.DLL, which calls the driver-dependent code for this feature. What does this mean to you? You won't have to worry about managing different joystick models; all of the grunge work is taken care of by MMSYSTEM.DLL. All you have to do is use the new APIs, which I will explain in the next two sections.</P>
<P> </P>
<H2><A NAME="sec10"></A>  Calibration, Testing, and Multiple Joysticks</H2><P>All of the calibration and testing of the DirectInput joystick drivers (both analog and digital) are done through the Joystick Control Panel applet. If your application wishes to ask the user to test or calibrate the joystick, your code simply spawns the Control Panel applet.</P>
<P> </P>
<P><BR></P>
<PRE> WinExec("control joy.cpl", SW_NORMAL);</PRE>
<P> </P>
<P>As I mentioned earlier, DirectInput supports multiple joysticks. The Windows 3.1 joystick APIs gave you the constants JOYSTICKID1 or JOYSTICKID2. Now you have JOYSTICKID1 through JOYSTICKID16 (although the SDK casually forgets to define JOYSTICKID3 through JOYSTICKID16). To enumerate the list of joysticks, you simply call the joyGetCaps API for each joystick, and skip over the ones with a bad return value:</P>
<P> </P>
<P><BR></P>
<PRE> JOYCAPS JoyCaps;
int j;
char sz[24];</PRE>
<P> </P>
<P><BR></P>
<PRE> for ( j = JOYSTICKID1; j &lt; JOYSTICKID1+16; j++ )
  {
  if (JOYERR_NOERROR ==  
      joyGetDevCaps (j, &amp;JoyCaps, sizeof(JoyCaps)))
    {
    wsprintf (sz, "Joystick #%d", j- JOYSTICKID1+1 );
    MessageBox ( hWnd, JoyCaps.szPname, sz, MB_OK );
    }
  }</PRE>
<P> </P>
<P>Your program can, of course, put all of these in a list box and let the user decide which input device to use. And, since each input device has its own registry entries for calibration, your user can quickly jump between devices.</P>
<P> </P>
<H2><A NAME="sec11"></A>  Reading the Joystick Information</H2><P>Once your game has decided which joystick to use, it is time to play! With the multimedia APIs of Windows 3.1, you could use the joySetCapture API to capture the joystick input to a window. After calling the joySetCapture API, you could query the joystick or respond to some notifications. For example, if you pushed joystick button 1, the MM_JOY1BUTTONDOWN message would be sent to the window indicated in joySetCapture. For those five people who used it, joyGetPos and joySetCapture returned the x and y positions and two button settings for your joystick.</P>
<P>This model and API set holds true for DirectInput. If your game already uses these APIs and relevant messages, it will automatically gain the performance from DirectInput, especially if you are using a digital joystick. </P>
<P>There is one new API for reading the joystick, joyGetPosEx. This API uses the JOYSTICKIDx constant and the JOYINFOEX structure (see <B>Figure 12</B>), which accounts for the new controls found on the new joysticks. If you use joyGetPosEx, you do not need to set capture (just as you didn't need to if you used the old joyGetPos API).</P>
<P> </P>
<P><BR></P>
<PRE> MMRESULT joyGetPosEx(UINT IDDevice, LPJOYINFOEX lpJIEX)</PRE>
<P> </P>
<P><B> Figure 12  JOYINFOEX</B></P>
<P><BR></P>
<PRE> typedef struct joyinfoex_tag 
  {
  DWORD dwSize;  // Sizeof (JOYINFOEX)
  DWORD dwFlags; // See documentation
  DWORD dwXpos;  // X position
  DWORD dwYpos;  // Y position
  DWORD dwZpos;  // Z position
  DWORD dwRpos;  // Rudder position
  DWORD dwUpos;  // U position (5th axis, such as throttle)
  DWORD dwVpos;  // V position (6th axis)
  DWORD dwButtons; // Button states 
  DWORD dwButtonNumber;  // Number of the button depressed
  DWORD dwPOV;   // Point-of-view Hat (See Figure 13)
  DWORD dwReserved1; // Off-limits!
  DWORD dwReserved2; // Don't touch!
  }
JOYINFOEX;</PRE>
<P>Most of the fields of JOYINFOEX are straightforward. The axis values are from 0 to 65,535, with 32,768 indicating a centered axis. The dwFlags bit dictates which fields of the structure need filling out.</P>
<P>The button states are actually bitfields; if button 1 is pressed, the bitfield indicated by JOY_BUTTON1 is set, and so on up to JOY_BUTTON32. If your joystick has more than 32 buttons (!), you can use the dwButtonNumber to see if a particular button is pressed. Since this field is not a bitfield, you cannot check for multiple buttons pressed above button number 32. For the point of view hat, use the values shown in <B>Figure 13</B>. </P>
<P><B> Figure 13  Point of View Hat Values</B></P>
<P></P>

<TABLE COLS="3" BORDER="0"><COLGROUP><COL WIDTH="135pt" VALIGN="TOP"><COL WIDTH="90pt" VALIGN="TOP"><COL WIDTH="216pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> POV Flags</B></P></TD><TD VALIGN="TOP"><P><B>Defined Value</B></P></TD><TD VALIGN="TOP"><P><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP"><P> JOY_POVBACKWARD</P></TD><TD VALIGN="TOP"><P>18,000</P></TD><TD VALIGN="TOP"><P>POV Hat is being pressed backward.<BR>18,000 represents 180.00 degrees or back.</P></TD></TR><TR><TD VALIGN="TOP"><P> JOY_POVCENTERED</P></TD><TD VALIGN="TOP"><P>–1</P></TD><TD VALIGN="TOP"><P>POV Hat is in the neutral position. 1 means no angle.</P></TD></TR><TR><TD VALIGN="TOP"><P> JOY_POVFORWARD</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>POV Hat is being pressed forward. 0 represents 0.00 degrees or straight ahead.</P></TD></TR><TR><TD VALIGN="TOP"><P> JOY_POVLEFT</P></TD><TD VALIGN="TOP"><P>27,000</P></TD><TD VALIGN="TOP"><P>POV Hat is being pressed to the left. 27,000 represents 270.00 degrees or 90.00 to the left.</P></TD></TR><TR><TD VALIGN="TOP"><P> JOY_POVRIGHT</P></TD><TD VALIGN="TOP"><P>9,000</P></TD><TD VALIGN="TOP"><P>POV Hat is being pressed to the right. <BR>9,000 represents 90.00 degrees or right.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>So, how would you query the joystick? In the WinDonut game, I care about the x axis (left to right) for ship rotation, button 1 (fire) and button 2 (thrust). And since WinDonut does not care how far left or right you push the joystick, I'll convert the x axis range to a more manageable "right, left, or centered" value (see <B>Figure 14</B>). The code in <B>Figure 14</B> looks innocent enough, but be careful: if the user has an analog joystick, the call to joyGetPosEx can take up to eight milliseconds to do that horrid interrupt disabled polling thing. If they have a digital joystick, it will take just a few clock cycles.</P>
<P><B> Figure 14  Converting the x Axis Range</B></P>
<P><BR></P>
<PRE> enum 
  {
  JOYDIR_LEFT,
  JOYDIR_RIGHT,
  JOYDIR_CENTER
  };

JOYINFOEX JoyInfoEx;
int       iJoyPos;
BOOL      bButton1, bButton2;

JoyInfoEx.dwSize = sizeof(JoyInfoEx);
JoyInfoEx.dwFlags = JOY_RETURNX | JOY_RETURNBUTTONS;
joyGetPosEx ( JOYSTICKID1, &amp;JoyInfoEx );

if (JoyInfoEx.dwXpos &lt; 16384)
  iJoyPos = JOYDIR_LEFT;
else
  if (JoyInfoEx.dwXpos &gt; 65535-16384)
    iJoyPos = JOYDIR_RIGHT;
  else
    iJoyPos = JOYDIR_CENTER;

bButton1 = (BOOL)(JoyInfoEx.dwButtons &amp; JOY_BUTTON1);
bButton2 = (BOOL)(JoyInfoEx.dwButtons &amp; JOY_BUTTON2);</PRE>
<P> </P>
<H2><A NAME="sec12"></A>  WinDonut: Total Joy</H2><P>I jammed the code in <B>Figure 14</B> into WinDonut. (Updated code can be found on the usual MSJ sources; see page 5.) Since different users' inputs are checked in different functions, I have added a new function called ReadJoyStick called at the start of the WINDONUT_GameHeartBeat function. Since WinDonut does so few computations, I can get away with calling it on every heartbeat. In most games, you would not want to call this function for every game heartbeat, since you could use up a lot of time if the user has an analog joystick (72 times per second multiplied by 8 milliseconds means you could spend over half your time reading the joystick!).</P>
<P>The ReadJoyStick function in <B>Figure 15</B> fills out the giJoyPos and gbButton1 and gbButton2 globals, which are then checked in the FigureShipPosition and FigureBulletPositions functions. This way both the keyboard and the joystick work for WinDonut. It's very straightforward, and it works nicely!</P>
<P><B> Figure 15  ReadJoyStick</B></P>
<P><BR></P>
<PRE> void ReadJoyStick ( void )
{
  JOYINFOEX JoyInfoEx;

  // In case the call to joyGetPosEx fails (for reasons
  // such as the user doesn't have a joystick), set the 
  // defaults to benign values

  giJoyPos  = JOYDIR_CENTER;
  gbButton1 = FALSE;
  gbButton2 = FALSE;

  // Get the joystick's X-axis and buttons
  JoyInfoEx.dwSize = sizeof(JoyInfoEx);
  JoyInfoEx.dwFlags = JOY_RETURNX | JOY_RETURNBUTTONS;
  // We will always use Joystick #1
  if (JOYERR_NOERROR == joyGetPosEx ( JOYSTICKID1, &amp;JoyInfoEx ))
    {
    // Check for the ranges to be at least halfway left
    // or right and convert into our constants
    if (JoyInfoEx.dwXpos &lt; 16384)
      giJoyPos = JOYDIR_LEFT;
    else
      if (JoyInfoEx.dwXpos &gt; 65535-16384)
        giJoyPos = JOYDIR_RIGHT;

    // Read the buttons
    gbButton1 = (BOOL)(JoyInfoEx.dwButtons &amp; JOY_BUTTON1);
    gbButton2 = (BOOL)(JoyInfoEx.dwButtons &amp; JOY_BUTTON2);
    }
}</PRE>
<P> </P>
<H2><A NAME="sec13"></A>  Conclusion</H2><P>Three down, one to go. DirectDraw is great since it makes Windows video performance incredibly fast. DirectSound is great since it introduces a few new features such as mixing along with extremely low latency to provide a great sound setup. DirectInput and DirectPlay differ from the other Direct features in that they offer something sorely lacking from previous incarnations of Windows games: a standard. With DirectPlay and DirectInput, you can actually use an API set that handles the dirty work of connecting players together via modem and connecting players to their machines with nifty new input devices.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
