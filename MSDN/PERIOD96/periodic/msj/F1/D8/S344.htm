<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Talk to Any Database the COM Way Using the OLE DB Interface</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Talk to Any Database the COM Way Using the OLE DB Interface</H1><P>Stephen Rauch</P>
<P>Stephen Rauch is a development technical specialist at Reuters. He can be reached on CompuServe at 70313,1455.</P>
<P>Where do you keep your data? Well, that's a pretty broad question. If, in the context of databases, I asked about your personal data, you would probably tell me that it's in spreadsheets, documents, project plans, and flat-file databases on your PC. If I asked where you keep your group data, you would probably tell me that it's stored in Lotus Notes or Microsoft Exchange on a server somewhere. And don't forget about all that enterprise data kept in central databases as small as a SQL database like Oracle or as large as a data warehouse.</P>
<P>Obviously your data is spread all over the place. How do you query, access, and modify all that data? The problem is that every source of data has a different interface and query language for accessing its data, like SQL or DDE.</P>
<P>There have been several good initiatives to create a common method of accessing data. One of these, the Open Database Connectivity (ODBC) interface, allows applications to use SQL as a standard for accessing data in database management systems. ODBC permits maximum interoperability—a single application can access many different database management systems—but ODBC does not provide access to all data types.</P>
<P>Now, OLE DB gives you a new choice. OLE DB is the method for accessing all data via a standard COM interface, regardless of where and how data is stored. This includes storage media such as relational databases, documents, spreadsheets, files, and electronic mail. With OLE technology, the database as we know it today becomes a component called a data provider. In fact, any component that directly exposes functionality through an OLE DB interface over a native data format is an OLE DB data provider. This includes everything from a full SQL DBMS to an ISAM file to a text file or data stream (see <B>Figure 1</B>).</P>
<P><img src="oledb1.gif"></P>
<P><B> Figure 1  The OLE DB Architecture</B></P>
<P>Just as the Windows 95 Explorer lets you explore file systems, future Explorers will let you explore data. For example, Microsoft could build a data provider that knows how to access and manipulate data stored in Microsoft Excel spreadsheets. With this data provider in place, you could use the Explorer distributed with the operating system (one that consumes OLE DB interfaces) to explore the data stored in your spreadsheet.</P>
<P>Furthermore, individual OLE DB component objects can be built to implement more advanced features on top of simple data providers; such components are called service providers. Through service providers like query processors, specialized applications like report writers (which build and generate reports based on some subset of data) can take advantage of providers that interconnect and offer different combinations of data presented as tables. Reports can span across different data storage types without bringing data locallytoaclientasinthetypicalcaseofheterogeneousjoins.</P>
<P>Just as there are different types of data providers, there are different types of OLE DB data consumers. Data consumers may be custom programs written to one data provider or generic consumers written to work with a variety of data providers. Future versions of products like Word, Microsoft Excel, and Microsoft Project could become data consumers as well as data providers. In that case, Microsoft Word could directly access data in a Microsoft Excel spreadsheet, and Microsoft Excel could directly access data in a Microsoft Project file.</P>
<P>What about your investment in ODBC? That has not been forgotten; Microsoft is supplementing the ODBC Driver Manager you know today with an OLE DB provider (code named Kagera) to ODBC data. This component immediately provides OLE DB data consumers access to SQL data while at the same time broadening the class of applications accessing ODBC drivers.</P>
<P>This article, based on the M6.1 version of the OLE DB SDK, merely skims the surface of what the SDK has to offer. The OLE DB SDK contains sample code, libraries, include files, and most important of all, some very complete documentation. In particular, you must read the specification defining a set of common interfaces exposed by component objects for accessing and manipulating data regardless of where it is stored. As of press time, Microsoft plans to put the SDK on http://www.microsoft.com and on the MSDN Level II subscription CD.</P>
<P>I will introduce you to all of the objects and their interfaces, focusing mainly on the mandatory interfaces data and service providers must implement. From there I will move on to finding and locating data and service providers, then introduce some functionality you can add to data and service providers that makes them more robust. I have even included a sample data consumer application and data provider. OLE DB is large and very flexible, so it is impossible to cover all of the interfaces and functionality in detail.</P>
<P>I am going to assume that you have a good understanding of both OLE and database technologies. If you understand ODBC, SQL, and Microsoft's Data Access Objects (DAO), even better. You will find after reading this article and the OLE DB specification that the database concepts and objects are similar to ODBC and DAO.</P>
<P> </P>
<H2><A NAME="sec0"></A>  Objects and Interfaces</H2><P>The OLE DB specification introduces approximately 55 new interfaces. They are grouped into seven object types: DataSource, DBSession, Command, Rowset, Index, ErrorObject, and Transaction (see <B>Figure 2</B>). An object type is defined as a set of interfaces an object must expose and a set of interfaces it's encouraged to expose. For example, the Rowset object type is defined by a group of interfaces a data consumer may interact with to manipulate tabular data. To play the role of a Rowset, an object must implement the IRowset, IAccessor, IRowsetInfo, and IColumnsInfo interfaces. Optionally, a data or service provider can implement a host of other related interfaces, as seen in <B>Figure 2</B>.</P>
<P><B> Figure 2  Object Types</B></P>
<P>Data Sources</P>
<P><BR></P>
<PRE> cotype TDataSource {
[mandatory] interface IDBInfo;
[mandatory] interface IDBInitialize;
[mandatory] interface IDBCreateSession;
[optional]  interface IPersistFile; //for persistence, see OLE2
[optional]  interface IProperties; //for persistence, see OLE2
}

</PRE>
<P>DB Sessions</P>
<P><BR></P>
<PRE> cotype TDBSession {
[mandatory] interface IOpenRowset;
[optional]  interface IDBCreateCommand;  //mandatory if Commands are supported
[optional]  interface ITransactionLocal; //mandatory if transactions are
                                         //supported
[optional]  interface ITransactionObject;//optional if transactions are 
                                         //supported
[optional]  interface ITransactionJoin;  //mandatory if coordinated 
                                         //transactions
[optional]  interface ITableDefinition;  //mandatory if table creation is 
                                         //supported
[optional]  interface IIndexDefinition;  //mandatory if index creation is 
                                         //supported
[optional]  interface IDBSchemaRowset;   //mandatory if Schema are supported
}

</PRE>
<P>Commands</P>
<P><BR></P>
<PRE> cotype TCommand {
[mandatory] interface ICommand;
[mandatory] interface IAccessor;
[mandatory] interface IColumnsInfo;
[mandatory] interface ICommandProperties;
[mandatory] interface ICommandText;
[optional]  interface ICommandWithParameters; //mandatory if parameters 
                                              //supported
[optional]  interface ICommandPrepare; // mandatory
[optional]  interface IColumnsRowset;
}

</PRE>
<P>Rowsets</P>
<P><BR></P>
<PRE> cotype TRowset {
[mandatory] interface IAccessor;
[mandatory] interface IRowsetInfo;
[mandatory] interface IColumnsInfo;
[mandatory] interface IRowset;      //IRowset or a derivative is mandatory
[optional]  interface IColumnsRowset;
[optional]  interface IRowsetIdentity;
[optional]  interface IRowsetLocate;
[optional]  interface IRowsetScroll;
[optional]  interface IRowsetExactScroll;
[optional]  interface IRowsetChange;
[optional]  interface IRowsetDelete;
[optional]  interface IRowsetNewRow;
[optional]  interface IRowsetUpdate;
[optional]  interface IRowsetResynch;
[optional]  interface IRowsetLockRows;
[optional]  interface IRowsetWithParameters;
[optional]  interface IRowsetCopyRows;
[optional]  interface IConnectionPointContainer; //mandatory if notifications supported
[optional]  interface IProvideMoniker;
}

</PRE>
<P>Indexes</P>
<P><BR></P>
<PRE> cotype TIndex {
[mandatory] interface IRowset;
[mandatory] interface IRowsetIndex;
[mandatory] interface IAccessor;
[mandatory] interface IColumnsInfo;
[optional]  interface IRowsetDelete;
[optional]  interface IRowsetNewRow;
};

</PRE>
<P>Errors</P>
<P><BR></P>
<PRE> cotype TErrorObject {
[mandatory] interface IErrorInfo;
[mandatory] interface IErrorRecords;
};

</PRE>
<P>Transactions</P>
<P><BR></P>
<PRE> cotype TTransaction {
[mandatory] interface ITransaction;    
[mandatory] interface ITransactionOptions;
[mandatory] interface IConnectionPointContainer;
};</PRE>
<P>Don't be overwhelmed by the number of objects and interfaces. Providing a specification generic enough to access all types of data without compromising the functionality of the data provider is a monumental task. However, it's also obvious that a full SQL DBMS data provider is going to offer considerably more functionality than a data provider for a text file. Therefore, you don't have to implement all of these interfaces. In developing OLE DB, Microsoft looked at similarities between providers and produced a base level of interfaces.</P>
<P> </P>
<H2><A NAME="sec1"></A>  Base-Level Interfaces</H2><P>Base-level interfaces are the minimum set of objects and interfaces both data and service providers must support (see <B>Figure 3</B>). A simple data provider that doesn't support transactions or queries through Command objects may support only these required interfaces, while more sophisticated data and service providers will build on this foundation.</P>
<P><img src="oledb3.gif"></P>
<P><B> Figure 3  Base-level Interfaces</B></P>
<P>All data and service providers must support a Data Source Object (DSO). A DSO represents a connection to a data source through which you can operate on its data. The DSO is also the initial object instantiated by calling CoCreateInstance for a given OLE DB data or service provider's CLSID or by binding to a moniker. A DSO creates multiple sessions via DBSession objects within a single connection context. Once instantiated, a data consumer must always initialize a DSO with the IDBInitialize::Initialize member function. Attempting to use a DSO that lacks required scope or authentication information will return an error. Scope includes information such as the name and location of the data source and authentication information if the data is not in an authenticated security environment. This information is provided by a data consumer through the IDBInitialize::Initialize member function.</P>
<P>Because a generic consumer like a query processor (which is also a service provider) may potentially use your data provider without any knowledge of its implementation, it's important to provide information about the properties of your data provider and how to build and execute queries. A data consumer can obtain this information through the IDBInfo interface. The IDBInfo::GetPropertyInfo member function returns information about the data source. Such information includes—but is not limited to—DBMS name, version, supported syntax (outer joins and alter table), capabilities (bookmarks and retaining abilities), and maximum lengths or sizes.</P>
<P>IDBInfo::GetKeywords and IDBInfo::GetLiteralInfo let you build commands that extract data from data sources and providers. These functions provide the keywords that are unique to the provider and information about the literals used in text commands.</P>
<P>If a DSO supports the IPersistFile interface, you can persist its connection status, scope, and properties. You can optionally (based on properties) persist the authentication information to a file, although this may be dangerous since storing password information in a file invites hackers. Note, however, that when you persist a DSO you are not persisting any active sessions, Command objects, or Rowset objects (which I will discuss later); loading the persisted file yields a DSO in the same state as when the DSO was created.</P>
<P>As you will notice in the next few paragraphs, many interfaces either contain the word Rowset or return a Rowset. That's because they all revolve around the Rowset object. A Rowset object makes data available to a data consumer. With a Rowset object and its interfaces, a data consumer can navigate through rows of data and add, change, and delete data within a data source.</P>
<P>Calling IDBCreateSession::CreateSession, which is supported by the DSO, creates a DBSession object. You can access data from a table, create and execute queries, manage transactions, and create a table or index through this object. At a minimum, all DBSession objects must support an IOpenRowset interface. Through IOpenRowset::OpenRowset, a data consumer generates a Rowset, making available data from an individual table. A Rowset generated through the IOpenRowset interface creates a result set from the SQL query SELECT * FROM TABLENAME where TABLENAME is supplied by a data consumer.</P>
<P>Optionally, simple data providers can allow for definition of tables and indexes through two related interfaces, ITableDefinition and IIndexDefintion, which allow the provider to create a table or index without the overhead of supporting a data definition language. IOpenRowset, ITableDefinition, and IIndexDefinition can be used to create a simple data provider that exposes raw data to data consumers for browsing in a very simple and direct fashion.</P>
<P>If the IDBSchemaRowset interface is exposed by a data or service provider, data consumers can get information about the database without knowing its structure. For example, you might have a SQL Serverª database that organizes each database into a set of schemas with tables and queries for each schema or a Microsoft Access 2.0 database that has a container of tables and a container of queries. </P>
<P> </P>
<H2><A NAME="sec2"></A>  Reading a Table Sequentially</H2><P>There are many ways a data consumer can access data from a data provider, such as reading a table sequentially, direct positioning in a rowset, and scrolling. Support for these different methods of data navigation depends on the interfaces a data provider supports. All Rowset objects support a minimal set of mandatory interfaces to access data. That minimum set includes IAccessor, IColumnsInfo, IRowsetInfo, and IRowset.</P>
<P>Let's take a look at the steps required to read a table sequentially. Assume that you, the data consumer, already have a Rowset object. You created the Rowset object by using either IOpenRowset::OpenRowset exposed by the DBSession object or ICommand::Execute implemented by a Command object. IOpenRowset deals with the simpler case of retrieving all data from a table. ICommand gets a Rowset that meets a specific data definition or data-manipulation statement. Executing either of these functions returns a pointer to an IRowset interface, pIRowset, which is the most common interface used to read data sequentially.</P>
<P>First, you need to get some information about the column names and column types. You'll use this information to create bindings, which is the next step. With the IRowsetInfo::GetProperties member function, you can obtain information that describes the capabilities of the Rowset through properties supported by a Rowset: bookmarks, scrolling backwards, the maximum number of open rows that can be active at the same, and about 60 other properties. Individual Rowsets created by the same data or service provider may have different properties depending on how the Rowset was created and if it applies to the current circumstances. For example, a data provider's ability to support the property might be affected by the current transaction or the current query. This will become clearer when I discuss Command objects.</P>
<P>There are approximately 70 Rowset properties defined in the OLE DB specification. If you are building a data or service provider, you can add additional properties to describe special capabilities of your Rowsets. You can also retrieve other objects associated with the Rowset through the IRowsetInfo interface. IRowsetInfo::GetSpecification basically returns a pointer to the object that created the Rowset. This object is usually, but not necessarily, a Command object. Given a Command object, you can get the command text used to create the Rowset. If a DBSession object is returned, you can get schema information and transaction interfaces. IRowsetInfo::GetSpecification basically provides an additional method for a data consumer to gain additional information about the Rowset.</P>
<P>The IColumnsInfo interface provides the necessary methods for a data consumer to determine the metadata, or characteristics, of the columns in the Rowset. From either the metadata or the command specification that generated the Rowset (IRowsetInfo::GetSpecification), a data consumer can determine which columns it needs from the Rowset. IColumnsInfo::GetColumnInfo returns the most commonly used metadata (column ID, column name, ordinal number of column, data type, and so on). If you already know the name or property identifier for the columns you want to use, then calling the IColumnsInfo::MapColumnIDs member function will retrieve the column ordinals.</P>
<P> </P>
<H2><A NAME="sec3"></A>  Creating Bindings</H2><P>Now that you know something about the Rowset, you must create bindings. A binding associates a piece of memory in the data consumer's buffer with a column of data in a Rowset. It consists of matching some persistent name or identifier of the logical column to its physical ordering in the current Rowset. For example, if a SQL statement like</P>
<P> </P>
<P><BR></P>
<PRE> SELECTorderID,customerID,ShipnameFROMORDERSWHERE ...</PRE>
<P> </P>
<P>is executed to yield a Rowset, then you could bind to the second column to retrieve the customerID. For the lifetime of the Rowset, columns always have a fixed ordinal, which begins with 1 and represents the order in which the columns appear in an array returned from IColumnsInfo::GetColumnInfo.</P>
<P>The structure DBBINDING, which is defined in the OLE DB header file OLEDB.H, describes the relationship between a field in a data consumer's structured buffer and the value of a field in a Rowset (see <B>Figure 4</B>). Each binding must have at least one of the following parts: value, length, and status.</P>
<P><B> Figure 4  DBBINDING Structure</B></P>
<P><BR></P>
<PRE> typedef struct  tagDBBINDING
    {
    DBCOLUMNPART dwPart;            // Value | Length | Status
    DBPARAMIO eParamIO;             // How Accessor is used (Input/Output 
                                    // parameter)
    ULONG iColumn;                  // Row Column Ordinal
    ULONG dwType;                   // DBTYPE of Consumers Structure
    ITypeInfo __RPC_FAR *pTypeInfo; // COM abstract data type
    DBNUMERIC __RPC_FAR *pNum;      // Contains values for properties
    ULONG obValue;                  // Offset of value consumer's struct
    ULONG cbMaxLen;                 // Size of consumers field
    DBOBJECT *pObject;              // Information for binding to a OLE object
    ULONG obLength;                 // Offset of length consumers struct
    ULONG obStatus;                 // Offset of status consumers struct
    }    DBBINDING;</PRE>
<P></P>
<P></P>
<P>Value is specified by dwType, cbMaxLen, and obValue, which indicate what the data consumer's structure is expecting, how much space is available to hold it, and where in the data consumer's buffer the value should be placed. The dwType forms an implied coercion. The OLE DB specification says Accessors are only obligated to transfer data in the type exposed as the type of a column in the Rowset; additional coercions are optional.</P>
<P>Length indicates the true length of the data and is useful mainly on variable-length data types. On fixed-length data types it is set to the actual width on a read from a Rowset and ignored on a write. On variable-length data types, length reports the true, full length of the data on reads, and is taken as an override of the true size on write.</P>
<P>The status part of the binding lets a data consumer get status information when reading from or writing to a Rowset. Status can indicate whether the value is null upon a read, if the value suffered any change upon coercion, and any error state.</P>
<P><B>Figure 5</B> shows how to create bindings that map the data in each column of a rowset to locations in a data consumer's data buffer. Notice the use of the pColumnInfo argument in defining the binding information. Information contained in pColumnInfo is obtained by calling IColumnsInfo::GetColumnInfo.</P>
<P><B> Figure 5  Binding Creation</B></P>
<P><BR></P>
<PRE> //**********************************************************************
// SetupBindings
// 
// Purpose:
// 
//     Creates bindings that map the data in the rowset's columns to 
//     locations in the data consumer's data buffer.
// Parameters:
// 
//     ULONG ulCol                  - number of columns in rowset to bind
//     DBCOLUMNINFO*    pColumnInfo - pointer to column metadata
//     DBBINDING* rgBind_out        - out pointer through which to return
//                                    an array of binding structures, one
//                                    structure per column bound
//     ULONG* pcBind_out            - out pointer through which to return
//                                    the number of columns bound (number
//                                    of valid elements in rgBind_out)
//     ULONG* pcMaxRowSize_out      - out pointer through which to return
//                                    the buffer size necessary to hold
//                                    the largest row data
//**********************************************************************
HRESULT SetupBindings (ULONG cCol, DBCOLUMNINFO* pColumnInfo, 
                       DBBINDING* rgBind_out, ULONG* pcBind_out, 
                       ULONG* pcMaxRowSize_out)
{
    ULONG dwOffset = 0;

    for (UNLONG ulCol = 0; ulCol &lt; cCol; ulCol++)
    {
        rgBind_out[ulCol].dwPart    = DBCOLUMNPART_VALUE|DBCOLUMNPART_LENGTH|
                                      DBCOLUMNPART_STATUS;
        rgBind_out[ulCol].eParamIO  = DBPARAMIO_NOTPARAM;                              
        rgBind_out[ulCol].iColumn   = pColumnInfo[ulCol].iNumber;
        rgBind_out[ulCol].dwType    = DBTYPE_STR;
        rgBind_out[ulCol].pTypeInfo = NULL;
        rgBind_out[ulCol].pNum      = NULL;
        rgBind_out[ulCol].obValue   = dwOffset + offsetof(COLUMNDATA,bData);
        rgBind_out[ulCol].obLength  = dwOffset + offsetof(COLUMNDATA,
                                                          dwLength);
        rgBind_out[ulCol].obStatus  = dwOffset + offsetof(COLUMNDATA,
                                                          dwStatus);
        rgBind_out[ulCol].cbMaxLen  = pColumnInfo[ulCol].dwType == 
                                         DBTYPE_STR ?
                                         pColumnInfo[ulCol].cbMaxLength +
                                         sizeof(char) : DEFAULT_CBMAXLENGTH;
        rgBind_out[ulCol].pObject   = NULL;
        dwOffset += rgBind_out[ulCol].cbMaxLen + offsetof( COLUMNDATA, 
                                                          bData );
        dwOffset = ROUND_UP( dwOffset, COLUMN_ALIGNVAL );
    }  
    *pcBind_out       = ulCol;
    *pcMaxRowSize_out = dwOffset;

    return NOERROR;
}</PRE>
<P></P>
<P> </P>
<H2><A NAME="sec4"></A>  Creating Accessors</H2><P>Now that you have established the bindings, you need to gather them in an Accessor, which reads data from and optionally writes data to a data provider. Accessors contain information or code to pack and unpack rows held by the data provider. You use them like handles on the access members of a row, helping the row to "crack" its contents and deliver the columns you bound in the previous step.</P>
<P>You can create an Accessor at any time during the running of a Rowset although it must be created before getting data from a data or service provider. Remember, the columns fetched by the Rowset are determined by a query from a command or through the IOpenRowset::OpenRowset member function, not the Accessor.</P>
<P>An Accessor is created by a data consumer using IAccessor::CreateAccessor, which is prototyped as follows:</P>
<P> </P>
<P><BR></P>
<PRE> HRESULTCreateAccessor(DBACCESSORFLAGSdwAccessorFlags,
                       ULONG cBindings, 
                       const DBBINDING rgBindings[],
                       ULONG cbRowSize, 
                       ULONG* pulErrorBinding,
                       HACCESSOR *phAccessor);</PRE>
<P> </P>
<P>The parameters are explained in <B>Figure 6</B>. To create an Accessor based on the binding information described in <B>Figure 5</B>, a call to ::CreateAccessor would look like this:</P>
<P> </P>
<P><BR></P>
<PRE> HACCESSOR hAccessor;
hr = pIAccessor-&gt;CreateAccessor( DBACCESSOR_READ | 
                                 DBACCESSOR_ROWDATA,
                                 cBind, rgBind, 0,
                                 NULL, &amp;hAccessor );</PRE>
<P> </P>
<P><B> Figure 6  CreateAccessor Parameters</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="207pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> DBACCESSORFLAGS dwAccessorFlags [in]</P></TD><TD VALIGN="TOP"><P>A bitmask that describes the properties of the Accessor and how to use it (DBACCESSOR_READ, DBACCESSOR_READWRITE, and so on).</P></TD></TR><TR><TD VALIGN="TOP"><P> ULONG cBindings [in]</P></TD><TD VALIGN="TOP"><P>The number of bindings in the Accessor.</P></TD></TR><TR><TD VALIGN="TOP"><P> const DBBINDING rgBindings[] [in]</P></TD><TD VALIGN="TOP"><P>An array of DBBINDING structures.</P></TD></TR><TR><TD VALIGN="TOP"><P> ULONG cbRowSize [in]</P></TD><TD VALIGN="TOP"><P>The number of bytes applicable for a single row of data in a data consumer's buffer. </P></TD></TR><TR><TD VALIGN="TOP"><P> ULONG* pulErrorBinding [out]</P></TD><TD VALIGN="TOP"><P>If an error occurs in the binding, this index will call out which binding caused the problem. It begins with zero. If no error occurs this value is not touched. If the caller passes a null pointer, this parameter is ignored.</P></TD></TR><TR><TD VALIGN="TOP"><P> HACCESSOR *phAccessor [out]</P></TD><TD VALIGN="TOP"><P>A pointer to memory in which to return the handle, HACCESSOR, of the created Accessor.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>After creating and successfully obtaining a handle to an Accessor, the next step is to fetch rows. Fetching is the process in which a data consumer makes a request to a data provider to obtain (fetch) some number of rows from a data source. Rows are fetched with methods such as IRowset::GetNextRows, IRowsetLocate::GetRowsAt, IRowsetLocate::GetRowsByBookmarks, and IRowsetScroll::GetRowsAtRatio (these are defined in the OLE DB specification). Each method returns handles to the rows expressed as a handle HROW. <B>Figure 7</B> shows an example using the IRowset::GetNextRows method, which returns an array of HROWs in the last parameter, rghRows.</P>
<P><B> Figure 7  Getting Data from a Rowset</B></P>
<P><BR></P>
<PRE> // Read the rows;  160 rows at a time
// Approximately 16KB of data assuming 100 Byte records

while (SUCCEEDED(hr = pIRowset -&gt; GetNextRows (0, NULL, 0, 160, 
                                               &amp;cRowsObtained, 
                                               &amp;rghRows)) &amp;&amp; cRowsObtained)
{
    for (ULONG ulrow = 0; ulrow &lt; cRowsObtained; ulrow++)
    {
      pIRowset -&gt; GetData (rghRows(ulrow), hAccessor, rgData);

      // code to print the data
      PrintData (rgData);
    }
    pIRowset -&gt; ReleaseRows (cRowsObtained, rghRows, NULL, NULL);
    CoTaskMemoryFree(rghRows);
}

// release the Accessor and the Rowset
pIAccessor -&gt; ReleaseAccessor(hAccessor);
pIRowset -&gt; Release();</PRE>
<P></P>
<P>GetNextRows does not give you the data yet. Calling IRowset::GetData will actually get the data from rows that were returned to you from the prior call to IRowset::GetNextRows.</P>
<P>IRowset::GetData is prototyped as follows:</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT GetData (HROW hRow, HACCESSOR hAccessor, 
                 void *pData);
</PRE>
<P>HROW hRow [in] is the handle of the row from which you get the data, and HACCESSOR  hAccessor [in] is the handle of the Accessor you want to use. void *pData [out] represents a pointer to a buffer allocated by the data consumer in which to return the data.</P>
<P>A data provider uses the bindings in the Accessor to determine how to return the data. For each binding in the Accessor, GetData obtains the data for the specified column of the row indicated by hRow. Next, it coerces or translates the data according to the data type in the binding. Then it places the coerced data in the data consumer's structure at the offset specified in the binding, truncated if necessary to match the value of cbMaxLen in the column binding.</P>
<P>You can call GetData any number of times. In each call, you can pass the same values, a different Accessor, a different pointer to a buffer, or different values for both. This means you can get as many copies of the data as you want, and you can get them in different types if alternate coercions are provided by a data provider.</P>
<P> </P>
<H2><A NAME="sec5"></A>  Releasing Rows</H2><P>Rows are held and references are counted by a data provider until the data consumer releases the rows. You release rows with the IRowset::ReleaseRows member function. ReleaseRows decreases the reference count of the specified rows passed to the function; call ReleaseRows once for each time a row was retrieved. For example, if the row was retrieved three times, ReleaseRows must be called three times. When the reference count decreases to zero, the row is truly released.</P>
<P>Finally, when you are finished with the Rowset, you must release the Accessor. IAccessor::ReleaseAccessor releases the Accessor and all the resources associated with it. The data consumer must also release the Rowset with IRowset::Release after releasing the Accessor.</P>
<P> </P>
<H2><A NAME="sec6"></A>  Other Means of Reading Rowsets</H2><P>Now you know how to read a Rowset sequentially. There are other methods of accessing data from a Rowset, and all depend on the properties and interfaces supported by a data provider. These include IRowsetLocate and IRowsetScroll. IRowsetLocate moves to arbitrary rows of a Rowset. IRowsetScroll moves to exact or approximate positions in a moveable Rowset depending on properties of the Rowset. It is likely to be used heavily for support of visible scrolling lists. The IRowset interface also defines interfaces for adding, updating, and deleting Rowsets. I will cover these interfaces in the sample application.</P>
<P> </P>
<H2><A NAME="sec7"></A>  Finding and Instantiating a DSO</H2><P>I have defined the base-level interfaces and functionality; the next step is to add additional functionality. If you're building a data or service provider, you will want to expose some of these advanced features to build a more robust provider. Before I begin to define additional functionality, it is important to understand how a data consumer finds and instantiates a DSO. </P>
<P>Like all COM components, OLE DB data and service providers are found in the registration database. Information about OLE DB data and service providers is kept in the registration database using the standard OLE Component Categories structure, which allows OLE components to become members of arbitrary categories. It also permits OLE components to describe themselves in enough detail that they do not have to be instantiated. Instantiation may be expensive or may require connection to a remote machine, so it should be avoided if possible.</P>
<P>Utilizing this model, a data consumer can locate and directly instantiate a data or service provider's DSO—the data consumer can read information from the registry to determine the correct data provider to load for a given instance of data. The data consumer can also obtain a list of enumerators. An enumerator is a COM server that implements IDBEnumerateSources. Not all providers are enumerators, and not all enumerators are providers. Finally, a data consumer can obtain a list of service providers, which are COM servers that enhance a provider in some way. Typically, a service provider exposes a subset of OLE DB interfaces. For example, a query processor might query over several data providers.</P>
<P>In most cases, an application built to consume data from a specific data provider will locate and directly instantiate an OLE DB data provider or service provider. General data consumers will ordinarily use a standard enumerator, included as part of the SDK, that reads the enumerators out of the registry. Because each provider may support IDBEnumerateSources, there can be many enumerators. Thus, the standard enumerator forms the root of a hierarchy of IDBEnumerateSources. </P>
<P>How does an enumerator work? A general data consumer calls CoCreateInstance to instantiate the standard enumerator (see <B>Figure 8</B>). IDBEnumerateSources::Sources provides a Rowset that contains the name of the data source, a parse name, a description of the data source, and the properties of the data source. A DBSOURCE_ISENUMERATOR property means the data source supports IDBEnumerateSources. The DBSOURCE_ISPARENT property is set if the data source is parented to the data source that just called IDBEnumerateSources::Sources. This allows the client to go backwards through the enumeration. In a file-system model this is equivalent to "..". A data consumer can then navigate through data sources just like a file system.</P>
<P><img src="oledb8.gif"></P>
<P><B> Figure 8  OLE DB Enumerator in Action!</B></P>
<P>Once a data consumer locates the data source in the Rowset, it can extract the parse name string and, using IParseDisplayName, obtain the moniker associated with the data source. A general data consumer will use the moniker with the standard IMoniker::BindToObject member function to bind to the object with which it is identified.</P>
<P> </P>
<H2><A NAME="sec8"></A>  Building Commands with Command Objects</H2><P>By now you should be able to create a pretty good application that can find and retrieve data from a simple data provider, so let's look at some additional functionality that more sophisticated data providers may provide. If you're building a data provider, probably the first thing you will want to add is support for building commands. Commands are queries that are built and executed to retrieve data from a data source. A data provider that supports building and executing more sophisticated queries is certainly more robust than just opening a table, which is all the base-level interfaces and objects support. This is because a query enables a data consumer to ask for specific data versus sifting through the raw data.</P>
<P>Commands and their properties are encapsulated in Command objects, which are created through the IDBCreateCommand interface supported by the DBSession object (see <B>Figure 9</B>). At a minimum, a Command object supports the ICommand, IAccessor, ICommandText, IColumnsInfo, and ICommandProperties interfaces. Through these interfaces a data consumer builds and executes commands that result in a Rowset.</P>
<P><img src="oledb9.gif"></P>
<P><B> Figure 9  The IDBCreateCommand Interface on the DBSession Object</B></P>
<P>Before building a query, a data consumer must learn how to query a particular data provider. This is where the information from the IDBInfo interface supported by the DSO comes in. Remember that a data consumer can learn the supported syntax, capabilities, keywords, and literal information supported by a data provider. If you are developing a specialized data consumer that always accesses data from a specific data provider, you may know how to build a query that accesses data from the provider. The information on this should be provided by the data provider's development group in a specification. If you are building a generic data consumer that can query any data provider and want to take full advantage of the provider's capabilities, you will definitely use this interface to build queries. If you need to know column metadata, you can use the functions supported by the IColumnsInfo interface.</P>
<P>Assuming that the data consumer's programmer read the spec and that the consumer knows how to build the query, it creates a Command object through the DBSession object by invoking the member function IDBCreateCommand::CreateCommand, which returns a pointer to a Command object interface, in this case ICommandText.</P>
<P> </P>
<P><BR></P>
<PRE> ICommandText *pCommandText;
hr = pIDBCreateCommand::CreateCommand
      (NULL, IID_ICommandText, 
       (IUnknown **) &amp;pCommandText);
pIDBCreateCommand -&gt; Release ();</PRE>
<P> </P>
<P>The first parameter to IDBCreateCommand::CreateCommand, IUnknown* punkOuter, points to the controlling IUnknown interface if the new command is created as part of an aggregate. It is a null pointer if the command is not part of an aggregate.</P>
<P>Once the data consumer obtains a pointer to the ICommandText interface, it creates and sets a text command. A textual command is typically a SQL expression (for example, SELECT orderID, customerID, Shipname FROM ORDERS WHERE ...) that is set explicitly through the ICommandText interface by the method ICommandText::SetCommandText. Because there are many dialects of SQL and potentially other languages, textual command formulations require not only the actual text but also an indicator of the language and its dialect (for example, ANSI SQL-92, Access SQL, or T-SQL). Thus, the ICommandText::SetCommandText method has two parameters:</P>
<P> </P>
<P><BR></P>
<PRE> REFGUID rguidDialect 
const LPWSTR pwszCommand </PRE>
<P> </P>
<P>The pwszCommand parameter is the actual text of the command. The rguidDialect parameter is a GUID that specifies the language and dialect used by the text. For example, a call to ICommandText::SetCommandText might look like this:</P>
<P> </P>
<P><BR></P>
<PRE> pICommandText-&gt;SetCommandText (DBGUID_SQL92, 
              "SELECT * FROM CUSTOMERS ORDER BY CITY");</PRE>
<P> </P>
<P>There is a complete list of dialect GUIDs defined in the OLE DB specification. If you are a building a data provider, be aware that you can define GUIDs for your own dialects as well. Not all data providers will support all dialects; in fact, most data providers will support only one dialect.</P>
<P>Before you execute the command, you may want to register with the Command object the properties you want supported by the Rowsets returned by ICommand::Execute. By setting properties, a data consumer can ask for the exact functionality it wants. This affects how a Rowset is implemented by a data provider. It is also how a data consumer can get the functionality it wants with associated performance trade-offs. You can register with the ICommandProperties::SetProperties function.</P>
<P>Invoking ICommandText::Execute will generate a Rowset based on the command specified as an argument in the ICommandText::SetCommandText member function. ::Execute is prototyped as follows:</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT Execute (IUnknown *rgpUnkOuters[], 
           REFIID riid, DBPARAMS *pParams, 
           HCHAPTER *phChapter, BOOL fResume, 
           ULONG *pcRowsets,    
           IUnknown ***prgpRowsets, 
           WCHAR **ppRowsetNames);</PRE>
<P> </P>
<P><B>Figure 10</B> describes the parameters.</P>
<P><B> Figure 10  Execute()Parameters</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="144pt" VALIGN="TOP"><COL WIDTH="301pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Parameter</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> rgpUnkOuters [in]</P></TD><TD VALIGN="TOP"><P>An array of pointers to the controlling IUnknown interfaces if the Rowsets are created as parts of aggregates. If NULL, then no rowsets are parts of aggregates.</P></TD></TR><TR><TD VALIGN="TOP"><P> riid [in]</P></TD><TD VALIGN="TOP"><P>The requested interface's ID.</P></TD></TR><TR><TD VALIGN="TOP"><P> pParams [in/out]</P></TD><TD VALIGN="TOP"><P>The DBPARAMS structure specifies values for one or more parameters.</P></TD></TR><TR><TD VALIGN="TOP"><P> phChapter [out]</P></TD><TD VALIGN="TOP"><P>A pointer to memory in which to return a pointer to the results chapter. If none of the Rowsets returned supports IRowsetWithParameters, *phChapter is set to DB_INVALID_HCHAPTER.</P></TD></TR><TR><TD VALIGN="TOP"><P> fResults [in]</P></TD><TD VALIGN="TOP"><P>TRUE indicates resume a suspended execution. FALSE indicates execute the command.</P></TD></TR><TR><TD VALIGN="TOP"><P> pcRowsets [in/out]</P></TD><TD VALIGN="TOP"><P>A pointer to memory containing the count of Rowsets.</P></TD></TR><TR><TD VALIGN="TOP"><P> prgpRowsets [in/out]</P></TD><TD VALIGN="TOP"><P>An output array of Rowsets.</P></TD></TR><TR><TD VALIGN="TOP"><P> ppRowsetNames [out]</P></TD><TD VALIGN="TOP"><P>An output array of the string names of all hierarchy levels. Array index 0 will contain the pseudo-name DBROWSET_ROOT, a constant that is always associated with the root of the hierarchy. The caller MUST NOT free the name strings; they are owned by the command object.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>For your command, a call to ICommandText::Execute returning an IRowset interface pointer would look like this:</P>
<P> </P>
<P><BR></P>
<PRE> HRESULT hr;
ULONG ulRowsets = 0;
IRowset **rgpRowsets = NULL;

hr = pCommandTree-&gt;Execute (NULL, IID_IRowset, NULL, 
                            NULL, FALSE, &amp;ulRowsets,
                            (IUnknown ***)&amp;rgpRowsets);</PRE>
<P> </P>
<P>This gives you a Rowset interface and lets you manipulate the data using the Rowset cotypes.</P>
<P> </P>
<H2><A NAME="sec9"></A>  Command Trees</H2><P>Microsoft is investigating enhancements to commands for a future version of OLE DB. The major new innovation under design is the command tree, which is an alternative to a text command. Command trees represent DML and DDL statements in an algebraic tree in which each node contains either an operator, an operand, or both.</P>
<P>All nodes in all command trees have the same structure. The most important fields are the operator, the pointer to the first child, and the pointer to the next sibling. The latter two fields create a linked list for all children of the same node. In addition to these three fields, there are two status indicators set by a data provider to distinguish if the node's operator is acceptable (for example, a provider might not support a join or arithmetic operation) and if the operator in the node's current context is acceptable.</P>
<P>Operators are divided into two groups: data manipulation operators and data definition operators. Data manipulation operators are used for, well, manipulating data in a data source. This includes constants, identifiers, names and parameters used to define scalar constants, bookmarks, catalogs, schemas, columns, table names, and lots more. Data definition operators are used for altering, creating, and deleting attributes and properties of a data source, especially record layouts, field definitions, key fields, and file locations.</P>
<P>The shape of a tree for a SQL statement SELECT * FROM CUSTOMERS ORDER BY CITY is shown in <B>Figure 11</B>. Representing each node as a rectangle, the top portion represents an operator (SELECT, FROM, WHERE)<I>,</I> the bottom left portion of the rectangle is the FirstChild and the bottom right portion of the rectangle is the NextSibling<I>.</I></P>
<P><img src="oledb11.gif"></P>
<P><B> Figure 11  SQL Statement Tree</B></P>
<P>What is the advantage of commands represented as trees over commands represented as text? Unlike text commands, which must be built to a specific language and dialect, command trees are language-independent. Also, through the use of command trees, a data consumer can retrieve error information down to a node in the tree. Because the error may occur anywhere within a possibly long string, the error indication scheme for nodes in a command tree does not work well for text commands.</P>
<P> </P>
<H2><A NAME="sec10"></A>  Transactions</H2><P>OLE DB has defined a set of interfaces and an object to support simple, nested, and coordinated transactions. Any data that is read, added, changed, deleted, or updated can be transacted. Transaction support is provided through the ITransactionLocal interface supported by the DBSession object (see <B>Figure 12</B>). Any data provider that supports transactions must support this interface.</P>
<P><img src="oledb12.gif"></P>
<P><B> Figure 12  The ITransactionLocal Interface on the DBSession Object</B></P>
<P>Without transaction support, all work done under the scope of the DBSession object is immediately committed on each method call. When a DBSession object enters a local or coordinated transaction, all work done by the DBSession or the Command and Rowset objects associated with the DBSession is part of a transaction. A data consumer calls ITransactionLocal::StartTransaction to begin a transaction on the DBSession object. It is also through this interface that a data consumer commits or aborts the unit of work performed within a transaction's scope.</P>
<P>For those data providers that support nested transactions, calling ITransactionLocal::StartTransaction with an existing transaction active on the DBSession returns a new transaction nested within the active transaction. Changes made within the innermost transaction are completely invisible to its outer transaction until the inner transaction is committed or aborted.</P>
<P>Data providers that support extended transaction functionality implement a Transaction object. The Transaction object supports the ITransaction interface for committing or aborting a transaction directly, allowing a data consumer to commit or abort at a transaction level other than the current level of a nested transaction. Another feature of the Transaction object is event notification; IConnectionPointContainer may be supported as a notifications sink for the ITransactionOutcomeEvents interface implemented by a data consumer. ITransactionOutcomeEvents, an interface defined in the OLE Transactions specification, provides the capability for a data consumer to monitor the outcome of transaction events. When a commit or abort is processed, a data provider notifies each registered ITransactionOutcome interface of the transaction's outcome.</P>
<P>Finally, a data provider that supports the ITransactionJoin interface can participate in coordinated transactions. Calling the ITransactionJoin::JoinTransaction method enlists the DBSession into a coordinated transaction. Once a data consumer joins a coordinated transaction, it calls the transaction coordinator's ITransaction::Commit or ITransaction::Abort method to commit or abort the transaction.</P>
<P> </P>
<H2><A NAME="sec11"></A>  Index Objects</H2><P>The Index object supports several interfaces that abstract the functionality of a data provider if the provider gives fast access to its data via a file access method. At this time, OLE DB supports the file access methods based on ISAM and B+/-Trees.</P>
<P>Any data provider supporting the Index object must support the IAccessor, IRowset, IColumnsInfo, and IRowsetIndex interfaces. The IRowsetIndex interface contains the methods to position within an index and to define the range of contiguous keys scanned when a data consumer calls IRowset::GetNextRows. IRowsetIndex::SetRange restricts the set of row entries visible through a call to IRowset::GetNextRows. Calling IRowset–Index::Seek allows you to directly position at a key value within the current range established by calling IRowsetIndex::SetRange.</P>
<P>An index can have several properties associated with it, including DBPROP_INDEX_PRIMARYKEY, DBPROP_INDEX_UNIQUE, and DBPROP_INDEX_CLUSTERED. To determine the properties associated with a particular index, you can call IRowsetIndex::GetIndexInfo, which returns an array of DBPROPERTY structures where each structure describes a property supported by the index. Sample code in the OLE DB specification shows how to read a table through an index.</P>
<P> </P>
<H2><A NAME="sec12"></A>  ErrorObjects</H2><P>The last object and set of interfaces I want to introduce before moving to the sample application is the ErrorObject and its interfaces. ErrorObjects are optional; they don't have to be implemented by a data service provider.</P>
<P>ErrorObjects are an extension of the OLE automation error-handling interfaces, which include ICreateErrorInfo, IErrorInfo, and ISupportErrorInfo. Through these interfaces, an object can provide error-related information to a consumer of the object. This includes a text description of the error, the GUID for the interface that defined the error, help context ID, help file name, and the ProgID of the class or application that returned the error.</P>
<P>One of the shortcomings of the OLE automation error-handling interfaces is their inability to return multiple error records from a single call. For example, a data consumer might call into a query processor, which calls down into several data providers. If an error occurs in a data provider, how does the query processor add its own error information to the data provider's error before returning to the data consumer? To solve this problem, OLE DB extends the OLE automation error objects by adding the ability for an ErrorObject to contain multiple error objects (see <B>Figure 13</B>).</P>
<P><img src="oledb13.gif"></P>
<P><B> Figure 13  OLE DB ErrorObject</B></P>
<P>Records in OLE DB ErrorObjects are numbered starting at zero and new error records are added to the top of the list. When an error record is retrieved, it is extracted from the list in LIFO order. Therefore, consumers of the object can start with the highest level of error information and then retrieve increasingly detailed information.</P>
<P>Each error record is composed of three parts, an ERRORINFO structure, error parameters, and a pointer to a custom ErrorObject. The ERRORINFO structure returns most of the basic information associated with an error.</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct tagERRORINFO {
   HRESULT hrError;
   DWORD   dwMinor;  // A provider-specific error code
   CLSID   clsid;    // The class ID of the object that
                     // returned the error.
   IID     iid;      // The IID of the interface that
                     // generated the error
   DISPID  dispid;   // Indicates the method that 
                     // returned the error
} ERRORINFO;</PRE>
<P> </P>
<P>Error parameters, which are provider-specific values, are substituted into error messages by a provider-specific error lookup service through the member functions supported by IErrorInfo. For example, the provider might associate the error message</P>
<P> </P>
<P><BR></P>
<PRE> Cannot open table &lt;param1&gt;.</PRE>
<P> </P>
<P>with the dwMinor value relating to an error code in the data provider's specification. Error parameters supply the name of the table that could not be opened. </P>
<P>In addition to the ERRORINFO structure and parameters, a custom ErrorObject is associated with each error record. A custom ErrorObject is the mechanism by which OLE DB ErrorObjects are extensible, allowing you to create your own provider-specific ErrorObject. Your ErrorObject's interface pointer is stored in the record.</P>
<P>As you can see, this model is very extensible, giving a data consumer lots of error information that can be provided to the user. The IErrorInfo and IErrorRecords interfaces are self-explanatory and there is plenty of sample code in the OLE DB specification.</P>
<P> </P>
<H2><A NAME="sec13"></A>  CheckBook</H2><P>I picked the CheckBook sample from Visual C++¨ to demonstrate OLE DB. CheckBook illustrates how to implement a record-based document. It writes the data to an <BR>MS-DOS file with a CHKBOOK-specific file format and on a per-record basis rather than on a load/save basis. Written to the file is the check number (which is automatically assigned by the application), the date the check was written, who it was written to, a memo, and the amount. The application supports retrieving, editing, and adding records. Keeping the same functionality as the CheckBook sample, I modified the application so it uses OLE DB to access the data store, which in this case is a flat file. As you can see, you can access any data no matter how it is stored.</P>
<P>To convert the application into two components, a data consumer and simple data provider, I removed the file access functions (basically the CDocument CChkBookDoc class) and created a data provider from it. The data provider is an in-process server implementing the base-level interfaces described earlier.</P>
<P>The new CDocument-based class uses the OLE DB interfaces to consume data from the data provider (see <B>Figure 14</B>). When you open a document with OnOpenDocument, the application immediately calls CoCreateInstance to instantiate the data provider and initializes the data provider by providing the file name entered by the user.</P>
<P><B> Figure 14  CheckBook's CDocumentClass Rewritten to Use OLE DB</B></P>
<P><BR></P>
<PRE> /////////////////////////////////////////////////////////////////////////////
//
//    CHECKBOOKDOC.CPP
//
//////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"

#define     DBINITCONSTANTS
#include "oledb.h"
#include "viewhints.h"
#include "row.h"
#include "Checkbook.h"
#include "CheckbookDoc.h"
#include "checkview.h"
#include "ledgerview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCheckbookDoc

IMPLEMENT_DYNCREATE(CCheckbookDoc, CDocument)

BEGIN_MESSAGE_MAP(CCheckbookDoc, CDocument)
    //{{AFX_MSG_MAP(CCheckbookDoc)
    ON_COMMAND(ID_EDIT_NEW_CHECK, OnNewCheck)
    ON_COMMAND(ID_NEXT_CHECK, OnNextCheck)
    ON_UPDATE_COMMAND_UI(ID_NEXT_CHECK, OnUpdateNextCheck)
    ON_COMMAND(ID_PREV_CHECK, OnPrevCheck)
    ON_UPDATE_COMMAND_UI(ID_PREV_CHECK, OnUpdatePrevCheck)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CCheckbookDoc, CDocument)
    //{{AFX_DISPATCH_MAP(CCheckbookDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //      DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCheckbookDoc construction/destruction

CCheckbookDoc::CCheckbookDoc()
{
    // Initialize variables
    m_pIDBInitialize = NULL;
    m_pIRowset = NULL;
    m_pIAccessor = NULL;
    m_hAccessor = NULL;
    m_nActiveRecord = 0;
    m_cColumns = 0;
    m_pColumnInfo = NULL;
    m_ulMaxRowSize = 0;
}

CCheckbookDoc::~CCheckbookDoc()
{
    // Cleanup all of the interfaces and Rows
    CleanUp();
}

// Release all interfaces that may have been retrieved from the data
// provider and frees up memory that may have been allocated
// to hold Row data.
void CCheckbookDoc::CleanUp() 
{
    if (m_pColumnInfo != NULL)
    {
        CoTaskMemFree (m_pColumnInfo);
        m_pColumnInfo = NULL;
    }

    // Release the accessor
    if (m_pIAccessor != NULL)
    {
        if  (m_hAccessor != NULL)
        {
            m_pIAccessor-&gt;ReleaseAccessor(m_hAccessor);
            m_hAccessor = NULL;
        }
        m_pIAccessor-&gt;Release();
        m_pIAccessor = NULL;
    }

    // Take care of the ulIndexset interface and any rows that may
    // have been retrieved from the data provider.
    if (m_pIRowset != NULL)
    {
        CRow *pRow = NULL;
        POSITION pos = NULL;

        // Release all rows held by the data provider
        ReleaseRows();

        // Cleaup the memory that was used to hold the check
        // information in the CObList m_oblRows.
        while ((pos = m_oblRows.GetHeadPosition()) != NULL)
        {
            pRow = (CRow *)m_oblRows.GetAt(pos);
            m_oblRows.RemoveAt(pos);
            if (pRow != NULL)
                delete pRow;
        }

        // Release the rowset interface
        m_pIRowset-&gt;Release();
        m_pIRowset = NULL;
    }

    // Un-Initialize the DSO
    if (m_pIDBInitialize != NULL)
    {
        m_pIDBInitialize -&gt; Uninitialize();
        m_pIDBInitialize-&gt;Release();
        m_pIDBInitialize = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CCheckbookDoc diagnostics

#ifdef _DEBUG
void CCheckbookDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CCheckbookDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CCheckbookDoc commands

BOOL CCheckbookDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    HRESULT hr = S_OK;

    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;

    // We have the file name, lets get the CLSID for the Check Book Data
    // Provider so that an instance can be created.
    CLSID CLSID_OLEDBObject;
    if (CLSIDFromProgID(OLESTR("CHKBOOKDP.DSO.1"), &amp;CLSID_OLEDBObject) != S_OK)
        {
        // Can't get CLSID for OLEDB object ProgID
        AfxMessageBox (IDS_FAILED_CLSIDProgID);
        return FALSE;
        }

    // Create an instance of the DSO, obtaining the IDBInitialize interface.
    if (CoCreateInstance(CLSID_OLEDBObject, NULL, CLSCTX_SERVER,
                         IID_IDBInitialize, (LPVOID *)&amp;m_pIDBInitialize) !=S_OK)
        {
        // Could not instantiate the CheckBook DSO
        AfxMessageBox (IDS_FAILED_DSO_INSTANTIATE);
        return FALSE;
        }

    // The next step is to initialize the data provider.  During
    // initialization, the data provider will open or create
    // the checkbook file as necessary.
    if ((hr = InitializeDSO(lpszPathName)) == S_OK)
    {
        // Get a Rowset Interface from the data provider
        if ((hr = GetRowsetInterface()) == S_OK)
        {
            // Get column information used for the bindings
            if ((hr = GetColumnInfo()) == S_OK)
            {
                // Now that the data consumer has the column information,
                // set up the DBBINDING structure.
                if ((hr = SetupBindings()) == S_OK)
                {
                    // Create an Accessor for getting the check book
                    // data from the data provider.
                    if ((hr = CreateAccessor()) == S_OK)
                    {
                        // Fetch all of the data from the data provider
                        if ((hr = GetData ()) == S_OK)
                        {
                            // Update both the Check and Ledger views.
                            UpdateAllViews (NULL, VIEWHINT_GET_ALL_DATA);
                        }
                    }
                }
            }
        }
    }

    if (hr != S_OK)
    {
        // There was a failure, cleanup all interfaces and do not
        // create the document
        CleanUp();
        return FALSE;
    }
    
    return TRUE;
}

// initializes the Check Book data provider by
// providing the file name of the check book .chb file.
HRESULT CCheckbookDoc::InitializeDSO (LPCTSTR lpszPathName)
{
    HRESULT hr = S_OK;

    GUID rgOptionIDs[1];
    VARIANT rgOptionVals[1];
    VariantInit(&amp;rgOptionVals[0]);

    rgOptionIDs[0] = DBINIT_OPT_NAME;
    rgOptionVals[0].vt = VT_BSTR;
    CString strPathName = lpszPathName;
    rgOptionVals[0].bstrVal = strPathName.AllocSysString();

    hr = m_pIDBInitialize-&gt;Initialize (1, rgOptionIDs, rgOptionVals);
    if (hr != S_OK)
        AfxMessageBox(IDS_FAILED_DSO_INITIALIZE);

    return hr;
}

// Obtain a Rowset interface from the check book data provider.
// The ulIndexset interface is saved for future uses such as
// retrieving,updating and adding new checks.
HRESULT CCheckbookDoc::GetRowsetInterface ()
{
    HRESULT hr = S_OK;

    // Create a DSSession object
    IDBCreateSession *pIDBCreateSession = NULL;
    hr = m_pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession, 
                                          (void **)&amp;pIDBCreateSession);

    if (hr == S_OK)
    {
        // From the DBSession object, get the IOpenRowset interface
        IOpenRowset *pIOpenRowset = NULL;
        hr = pIDBCreateSession -&gt; CreateSession(NULL, IID_IOpenRowset,
                                                (IUnknown **)&amp;pIOpenRowset);
        pIDBCreateSession -&gt; Release();

        if (hr == S_OK)
        {
            hr = pIOpenRowset -&gt; OpenRowset(NULL, NULL, 0, NULL, IID_IRowset, 
                                            NULL, (IUnknown **)&amp;m_pIRowset);
            pIOpenRowset -&gt; Release();
        }
    }

    return hr;
}

// Retrieves an IAccessor interface and create an accessor that
// is used for reading and writing checks.
HRESULT CCheckbookDoc::CreateAccessor ()
{
    HRESULT hr = S_OK;
    
    hr = m_pIRowset -&gt; QueryInterface(IID_IAccessor, (void **)&amp;m_pIAccessor);
    if (hr == S_OK)
    {
        ULONG ulErrorBinding = (ULONG)-1L;
        hr = m_pIAccessor-&gt;CreateAccessor(DBACCESSOR_READWRITE |  
                                          DBACCESSOR_ROWDATA,
                                          m_ulBindings, m_prgBindings, 0, 
                                          &amp;ulErrorBinding, &amp;m_hAccessor);
    }
    return hr;
}

// Releases all of the HROWS from within the data provider.
HRESULT CCheckbookDoc::ReleaseRows()
{
    ASSERT (m_pIRowset);

    ULONG ulRows;
    HRESULT hr = S_OK;
    HROW *prghRows = NULL;

    ulRows = m_oblRows.GetCount();
    prghRows = (HROW *) CoTaskMemAlloc((sizeof (HROW *)) * ulRows);

    if (prghRows != NULL) 
    {
           HROW *pTempRow;
        pTempRow = prghRows;

        POSITION pos = NULL;
        CRow *pRow = NULL;
        for (ULONG ulIndex = 0; ulIndex &lt; ulRows; ulIndex++)
        {
            pos = m_oblRows.FindIndex (ulIndex);
            pRow = (CRow *)m_oblRows.GetAt(pos);
            *pTempRow++ = pRow -&gt; m_hRow;
        }

        hr = m_pIRowset -&gt; ReleaseRows(ulRows, prghRows, NULL, NULL);
        CoTaskMemFree(prghRows);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}


// Retrieves a specific check from the CObList and returns the check
// in a CRow.
BOOL CCheckbookDoc::GetRow (ULONG ulIndex, CRow **pRow)
{
    POSITION pos = NULL;

    pos = m_oblRows.FindIndex (ulIndex);
    if (pos != NULL)
    {
        *pRow = (CRow *)m_oblRows.GetAt(pos);
        return TRUE;
    }
    return FALSE;
}

// Retrieves check information based on the index into the "checkbook".
BOOL CCheckbookDoc::GetCheck (ULONG ulIndex, UINT&amp; nCheckNo, DWORD&amp; dwCents, 
                              CString&amp; strPayTo, CString&amp; strDate, 
                              CString&amp; strMemo)
{
    CRow *pRow;

    if (GetRow(ulIndex, &amp;pRow))
    {
        COLUMNDATA *pColumn;
    
        ASSERT (offsetof(COLUMNDATA, dwLength) == 0);

        for (ULONG ulIndex=0; ulIndex &lt; m_ulBindings; ulIndex++)
        {
            pColumn = (COLUMNDATA *) (pRow -&gt; m_pData + 
                                      m_prgBindings[ulIndex].obLength);

            switch (m_prgBindings[ulIndex].iColumn) 
            {
                case CB_CHECKNO_ORDINAL:
                    nCheckNo = *(unsigned int *) pColumn-&gt;bData; 
                    break;

                case CB_AMOUNT_ORDINAL:
                    dwCents = *(unsigned long *) pColumn-&gt;bData; 
                    break;

                case CB_PAYTO_ORDINAL:
                    strPayTo = (const TCHAR *) &amp;pColumn-&gt;bData;
                    break;

                case CB_DATE_ORDINAL:
                    strDate = (const TCHAR *) &amp;pColumn-&gt;bData;
                    break;

                case CB_MEMO_ORDINAL:
                    strMemo = (const TCHAR *) &amp;pColumn-&gt;bData;
                    break;
            }
        }
        return TRUE;
    }
    return FALSE;
}

// Updates the active check with the values passed into the member function
// by using the data providers ulIndexsetChange interface.
HRESULT CCheckbookDoc::UpdateData(CView* pSourceView, UINT nCheckNo,
                                  DWORD dwCents, LPCTSTR lpszPayTo, 
                                  LPCTSTR lpszDate, LPCTSTR lpszMemo)
{
    ASSERT (m_pIRowset);

    HRESULT hr = S_OK;

    IRowsetChange *pIRowsetChange = NULL;
    hr = m_pIRowset-&gt;QueryInterface(IID_IRowsetChange, 
                                    (void **)&amp;pIRowsetChange);
    if (hr == S_OK)
    {
        CRow *pRow;
        if (GetRow(m_nActiveRecord, &amp;pRow))
        {
            BYTE *pRowData = NULL;
            pRowData = (BYTE *) CoTaskMemAlloc (m_ulMaxRowSize);
            if (!pRowData)
                return E_OUTOFMEMORY;

            memcpy(pRowData, pRow -&gt; m_pData, sizeof(*pRowData));

            if (S_OK == (CopyCheckDataIntoBuffer (pRowData, nCheckNo,
                                                  dwCents, lpszPayTo, 
                                                  lpszDate, lpszMemo)))
            {
                if ((hr = pIRowsetChange -&gt; SetData (pRow -&gt; m_hRow, 
                                  m_hAccessor, (const void *)pRowData)) == S_OK)
                {
                    memcpy((BYTE *)pRow -&gt; m_pData, (BYTE *)pRowData,  
                           m_ulMaxRowSize);
                    UpdateAllViews(pSourceView, VIEWHINT_UPDATE_CHECK, NULL);
                }
            }
            CoTaskMemFree((void *) pRowData);
        }
    }

    pIRowsetChange -&gt; Release();
    return hr;
}

// Function creates a new record by using the ulIndexsetNewRow interface
// supported by the data provider.  The new row is added to the CObList
// and the views are updated accordingly.
HRESULT CCheckbookDoc::AddNewCheck()
{
    BYTE *pRowData = NULL;
    HROW *prghRows = NULL;
    HRESULT hr = S_OK;

    ASSERT (m_pIRowset);
    ASSERT (m_hAccessor);
    ASSERT (m_pColumnInfo);
    ASSERT (m_ulMaxRowSize != 0);
    
    pRowData = (BYTE *) CoTaskMemAlloc (m_ulMaxRowSize);
    if (!pRowData)
        return E_OUTOFMEMORY;

    IRowsetNewRow *pIRowsetNewRow = NULL;
    hr = m_pIRowset-&gt;QueryInterface(IID_IRowsetNewRow, 
                                    (void **)&amp;pIRowsetNewRow);
    if (hr == S_OK)
    {
        HROW phRow = NULL;

        if ((hr = pIRowsetNewRow -&gt; SetNewData (NULL, m_hAccessor, pRowData,  
                                                &amp;phRow)) == S_OK)
        {
            StoreRowData (phRow, pRowData);

            // Make this the active check and update the ledger view.
            m_nActiveRecord = m_oblRows.GetCount() - 1;
            UpdateAllViews(NULL, VIEWHINT_ADD_CHECK);
        }
        else
            CoTaskMemFree (pRowData);

        pIRowsetNewRow -&gt; Release();
    }

    return S_OK;
}

BOOL CCheckbookDoc::MaybeCommitDirtyCheck()
{
    CView *pView;
    POSITION pos = GetFirstViewPosition();
    while (pos != NULL)
    {
        pView = GetNextView(pos);
        CCheckView *pCheckView = DYNAMIC_DOWNCAST(CCheckView, pView);
        if (pCheckView != NULL)
            return pCheckView-&gt;MaybeCommitDirtyCheck();
    }
    return TRUE;
}

// When the user changes the check selection in the ledger view, this member
// function is called to update the check view.
void CCheckbookDoc::ChangeSelectionToCheck(CLedgerView *pLedgerView, 
                                           ULONG ulIndex)
{
    if (!MaybeCommitDirtyCheck())
        return;

    m_nActiveRecord = ulIndex;
    UpdateAllViews (pLedgerView, NULL);
}

// When the user uses the toolbar or menu items to move through the checks,
// this member function is called to update the view appropriately.
void CCheckbookDoc::ChangeSelectionNextCheckNo(BOOL bNext)
{
    if (bNext)
    {
        if (m_nActiveRecord &lt; (GetNumberOfRows() - 1))
        {
            if (!MaybeCommitDirtyCheck())
                return;
            ++m_nActiveRecord;
            UpdateAllViews(NULL, VIEWHINT_NEXT_CHECK, NULL);
        }
    }
    else
    {
        if (m_nActiveRecord &gt; 0)
        {
            if (!MaybeCommitDirtyCheck())
                return;
            --m_nActiveRecord;
            UpdateAllViews(NULL, VIEWHINT_NEXT_CHECK, NULL);
        }
    }
}

////////////////////////////////////////////////////////
// Commands

void CCheckbookDoc::OnNewCheck() 
{
    // Before creating a new record, which will become the new selection,
    // ask the user whether he or she wants to commit data entered in the
    // check view for the previously selected check.

    if (!MaybeCommitDirtyCheck())
        return;

    AddNewCheck();
}

void CCheckbookDoc::OnNextCheck() 
{
    ChangeSelectionNextCheckNo(TRUE);
}

void CCheckbookDoc::OnUpdateNextCheck(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_nActiveRecord &lt; (GetNumberOfRows() - 1));
}

void CCheckbookDoc::OnPrevCheck() 
{
    ChangeSelectionNextCheckNo(FALSE);
}

void CCheckbookDoc::OnUpdatePrevCheck(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;Enable(m_nActiveRecord &gt; 0);
}

// Function retieves column information from the data provider.
HRESULT CCheckbookDoc::GetColumnInfo ()
{
    ASSERT (m_pIRowset);

    ULONG pcColumns;
    HRESULT hr = S_OK;
    DBCOLUMNINFO *prgInfo = NULL;
    WCHAR *ppStringsBuffer = NULL;

    // Get an interface pointer to IColumnsInfo
    IColumnsInfo *pIColumnsInfo = NULL;
    hr = m_pIRowset -&gt; QueryInterface(IID_IColumnsInfo, 
                                      (void **)&amp;pIColumnsInfo);

    if (hr == S_OK)
    {
        // Get the Column Information
        hr = pIColumnsInfo -&gt; GetColumnInfo(&amp;pcColumns, 
                                            (DBCOLUMNINFO **)&amp;prgInfo, 
                                            (WCHAR **)&amp;ppStringsBuffer);
        pIColumnsInfo -&gt; Release();

        if (hr == S_OK)
        {
            m_cColumns = pcColumns;
            m_pColumnInfo = prgInfo;

            CoTaskMemFree (ppStringsBuffer);
            ppStringsBuffer = NULL;
        }
    }
    return hr;
}

// Function creates bindings that map the data in the rowset's columns
// to the check book data consumers buffer.
HRESULT CCheckbookDoc::SetupBindings ()
{
    ASSERT (m_pColumnInfo);

    UINT cBinding = 0;
    DWORD dwOffset = 0;

    // Since the check book data consumer displays all information
    // about a check, and that's all that the data provider provides,
    // get all of the data.
    for (ULONG ulIndex=0; ulIndex &lt; m_cColumns; ulIndex++)
    {
        m_prgBindings[cBinding].dwPart = DBCOLUMNPART_VALUE | 
                                      DBCOLUMNPART_LENGTH | DBCOLUMNPART_STATUS;
        m_prgBindings[cBinding].eParamIO = DBPARAMIO_NOTPARAM;                              
        m_prgBindings[cBinding].iColumn = m_pColumnInfo[ulIndex].iNumber;
        m_prgBindings[cBinding].dwType = m_pColumnInfo[ulIndex].dwType;
        m_prgBindings[cBinding].pTypeInfo = m_pColumnInfo[ulIndex].pTypeInfo;
        m_prgBindings[cBinding].pNum = NULL;
        m_prgBindings[cBinding].obValue = dwOffset + offsetof(COLUMNDATA,bData);
        m_prgBindings[cBinding].obLength = dwOffset + offsetof(COLUMNDATA,
                                                               dwLength);
        m_prgBindings[cBinding].obStatus = dwOffset + offsetof(COLUMNDATA,
                                                               dwStatus);
        m_prgBindings[cBinding].cbMaxLen = 
            m_pColumnInfo[ulIndex].dwType ==  
                DBTYPE_STR ? m_pColumnInfo[ulIndex].cbMaxLength + sizeof(char) :                                  m_pColumnInfo[ulIndex].cbMaxLength;
        m_prgBindings[cBinding].pObject.pUnkOuter = NULL;
        m_prgBindings[cBinding].pObject.iid = IID_NULL;
        m_prgBindings[cBinding].pObject.pbc = NULL;
        dwOffset += m_prgBindings[cBinding].cbMaxLen + offsetof (COLUMNDATA,
                                                                 bData);
        cBinding++;
    }  
    
    m_ulBindings = cBinding;
    m_ulMaxRowSize = dwOffset;

    return S_OK;
}

HRESULT CCheckbookDoc::GetData ()
{
    HRESULT hr = S_OK;
    HROW *prghRows = NULL;
    BYTE *pRowData = NULL;
    ULONG ulRowsObtained;

    ASSERT (m_pIRowset);
    ASSERT (m_hAccessor);
    ASSERT (m_pColumnInfo);
    
    while (TRUE)
    {
        hr = m_pIRowset-&gt;GetNextRows(0, 0, 20, &amp;ulRowsObtained, &amp;prghRows);
        if (FAILED(hr))
            return hr;

        // check to see the data provider returned any rows
        if (ulRowsObtained == 0)
            break;

        // For each row, get the checkbook data from the ata provider
        for (ULONG ulIndex = 0; ulIndex &lt; ulRowsObtained; ulIndex++ )
        {
            pRowData = (BYTE *) CoTaskMemAlloc(m_ulMaxRowSize);
            if (!pRowData)
                return E_OUTOFMEMORY;

            hr = m_pIRowset-&gt;GetData(prghRows[ulIndex], m_hAccessor, pRowData );
            if (FAILED(hr))
            {
                // Free the task memory allocated by the data provider
                CoTaskMemFree(prghRows);
                
                if (pRowData)
                    CoTaskMemFree(pRowData);
                return hr;
            }
            StoreRowData (prghRows[ulIndex], pRowData);
            m_nActiveRecord = m_oblRows.GetCount() - 1;
        }

        // Free the task memory allocated by the data provider
        CoTaskMemFree(prghRows);
        prghRows = NULL;
    }

    return S_OK;
}

HRESULT CCheckbookDoc::StoreRowData (HROW phRow, BYTE *pData)
{
    CRow *pRow = NULL;
    HRESULT hr = S_OK;
    COLUMNDATA*    pColumn;
    DWORD dwStatus, dwLength;
    
    ASSERT (offsetof(COLUMNDATA, dwLength) == 0);

    pRow = new CRow;
    if (pRow == NULL)
        return E_OUTOFMEMORY;

    // Do some coersion error checking first before storing the data
    for (ULONG ulIndex=0; ulIndex &lt; m_ulBindings; ulIndex++)
    {
        pColumn = (COLUMNDATA *) (pData + m_prgBindings[ulIndex].obLength);

        dwStatus = pColumn-&gt;dwStatus;
        dwLength = pColumn-&gt;dwLength;

        if (dwStatus == DBCOLUMNSTATUS_CANTCOERCE)
            // Have a problem, therefore return an error
            hr = E_UNEXPECTED;
        else
        {
            switch (m_prgBindings[ulIndex].dwType) 
            {
                case DBTYPE_UI8:
                    // Make sure this is the Amount Column
                    if (!m_prgBindings[ulIndex].iColumn == CB_AMOUNT_ORDINAL)
                        hr = E_UNEXPECTED;
                    break;

                case DBTYPE_UI4:
                    // Make sure this is the Check Number Column
                    if (!m_prgBindings[ulIndex].iColumn == CB_CHECKNO_ORDINAL)
                        hr = E_UNEXPECTED;
                    break;

                case DBTYPE_STR:
                    // Process the string related columns
                    if (!(m_prgBindings[ulIndex].iColumn == CB_PAYTO_ORDINAL ||
                        m_prgBindings[ulIndex].iColumn == CB_DATE_ORDINAL ||
                        m_prgBindings[ulIndex].iColumn == CB_MEMO_ORDINAL))
                        hr = E_UNEXPECTED;
                    break;

                default:
                    hr = E_UNEXPECTED;
                    break;
            }

            if (hr != S_OK)
                break;
        }
    }

    if (hr != S_OK)
        delete pRow;
    else
    {
        // Save the check information in a CObList
        pRow -&gt; m_hRow = phRow;
        pRow -&gt; m_pData = pData;
        m_oblRows.AddTail (pRow);
    }
    return hr;
}

HRESULT CCheckbookDoc::CopyCheckDataIntoBuffer (BYTE *pData, UINT nCheckNo,
                                                DWORD dwCents, LPCTSTR lpszPayTo, 
                                                LPCTSTR lpszDate, 
                                                LPCTSTR lpszMemo)
{
    HRESULT hr = S_OK;
    COLUMNDATA*    pColumn;
    DWORD dwStatus, dwLength;
    
    ASSERT (offsetof(COLUMNDATA, dwLength) == 0);

    for (ULONG ulIndex=0; ulIndex &lt; m_ulBindings; ulIndex++)
    {
        pColumn = (COLUMNDATA *) (pData + m_prgBindings[ulIndex].obLength);

        dwStatus = pColumn-&gt;dwStatus;
        dwLength = pColumn-&gt;dwLength;

        switch (m_prgBindings[ulIndex].dwType) 
        {
            case DBTYPE_UI8:
                if (m_prgBindings[ulIndex].iColumn == CB_AMOUNT_ORDINAL)
                    *(unsigned long *)pColumn-&gt;bData = dwCents;
                else
                    hr = E_UNEXPECTED;
                break;

            case DBTYPE_UI4:
                if (m_prgBindings[ulIndex].iColumn == CB_CHECKNO_ORDINAL)
                    *(unsigned int *)pColumn-&gt;bData = nCheckNo; 
                else
                    hr = E_UNEXPECTED;
                break;

            case DBTYPE_STR:
                if (m_prgBindings[ulIndex].iColumn == CB_PAYTO_ORDINAL)
                    _tcscpy((TCHAR *) &amp;pColumn-&gt;bData, lpszPayTo);
                else if (m_prgBindings[ulIndex].iColumn == CB_DATE_ORDINAL)
                    _tcscpy((TCHAR *) &amp;pColumn-&gt;bData, lpszDate);
                else if(m_prgBindings[ulIndex].iColumn == CB_MEMO_ORDINAL)
                    _tcscpy((TCHAR *) &amp;pColumn-&gt;bData, lpszMemo);
                else
                    hr = E_UNEXPECTED;
                break;

            default:
                hr = E_UNEXPECTED;
                break;
        }
        if (hr != S_OK)
            break;
        
    }
    return hr;
}</PRE>
<P></P>
<P>The original CheckBook application accessed all data from the flat file when the file is opened—no commands here—and displayed it in two views. This is exactly what the OLE DB CheckBook application does; after initializing the data provider, the CheckBook data consumer creates a DBSession and opens a Rowset using the IOpenRowset::OpenRowset member function. The data consumer then goes into a loop (see the CCheckbookDoc::GetNextRows member function), fetching and getting the data directly from the data provider and storing the check information in a CObList. </P>
<P>In this example I hold onto the HROWs so that I have the HROW for an individual check when the user updates it. I made this simplification since the example holds onto a relatively small number of rows at a time and the provider does not support bookmarks. General-purpose consumers should attempt to use bookmarks rather than hRows to hold onto a row whenever possible, since hRows require that the provider do some caching and are generally more heavyweight than bookmarks.</P>
<P>The OLE DB CheckBook application adds new rows, which are checks, at the end of the flat file by calling the IRowsetNewRow::SetNewData member function in CCheckbookDoc::AddNewCheck. Using an Accessor and a pointer to the new data values, the data consumer calls SetNewData, which returns an HROW of the newly added row. When I get the new HROW, I add it to my CObList just in case the user wants to change the check before closing the application.</P>
<P>By providing an Accessor and an HROW from an open Rowset, you can change the data associated with the HROW by using the IRowsetChange::-SetData member function. In CCheck-bookDoc::UpdateData, I use this interface to update changes made on the check.</P>
<P>How do you run the application? First you have to register CheckBook's data provider. The data provider is a self-registering in-process server and may also be registered using the REGSRV32.EXE tool.</P>
<P> </P>
<P><BR></P>
<PRE> REGSVR32 CHECKDP.DLL</PRE>
<P> </P>
<P>Create your own checkbook through the application, or use the MYCHECKBOOK.CHB file provided with the sample application and the source code to the data consumer. To start the application, run CHECKBOOK.EXE.</P>
<P> </P>
<H2><A NAME="sec14"></A>  Conclusion</H2><P>The goal of OLE DB is to give applications uniform access to data stored in DBMS and non-DBMS applications. Using OLE DB, applications can take advantage of the benefits of database technology without having to transfer data from its place of origin to a DBMS.</P>
<P>If you don't already have the OLE DB specification, get your hands on it. The openness of the specification and the promise of accessing any type of data—no matter where or how it is stored—is information at your fingertips.</P>
<H2><A NAME="sec15"></A>  DATABASE GLOSSARY</H2><P><B>Coercion</B> Converting the base medium of a column in a row of data to match the caller's requested format. For example, the caller may want a string representation of a value which is actually stored in the database as an integer.</P>
<P><B>Consumer</B> Any application that retrieves data from a data or service provider using OLE DB interfaces.</P>
<P><B>DDL</B> Data Definition Language.</P>
<P><B>DML</B> Data Manipulation Language. </P>
<P><B>Heterogenious Join</B> A join between local and remote tables in different DBMS. For example, you use a heterogenious join to join a table in a Microsoft Access database with another table in Microsoft FoxPro. Joining two or more tables is the process of comparing the data in specified columns and using the comparison results to form a new table from the rows that survived the comparison.</P>
<P><B>Join</B> A link between the rows in two or more tables done by comparing the values in columns specified within a statement of some query language.</P>
<P><B>Metadata</B> The data stored in a database that describes the tables and columns and their relationships. </P>
<P><B>Outer Joins</B> Most joins provide only matching rows (rows with values in the specified columns that satisfy the join condition) in the results; these join operations eliminate the information contained in rows that do not match. It is sometimes desirable to retain the nonmatching information by including nonmatching rows in the results of a join. To do this, you use an outer join.</P>
<P><B>Query Processor</B> Given a statement in some query language (that is, SQL), a query processor determines a query plan for a statement, executes the query plan, and returns a result set.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright </I>©<I> 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P><I>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</I></P>
<P></P></font></body></HTML>
