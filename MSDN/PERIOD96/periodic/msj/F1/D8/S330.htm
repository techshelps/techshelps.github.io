<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Under the Hood</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Under the Hood</H1><P>Matt Pietrek</P>
<P>Matt Pietrek is the author of <I>Windows 95 System Programming Secrets</I> (IDG Books, 1995). He works at Nu-Mega Technologies Inc., and can be reached at 71774.362@compuserve.com.</P>
<P>QI've written some 32-bit Delphi code and compiled it to an OBJ file. I'm trying to mix this Delphi code with C++ code compiled by Visual C++<FONT FACE="Symbol">"</FONT>. The problem is that I get unresolved symbol linker errors like this:</P>
<P> </P>
<P><BR></P>
<PRE> D2.OBJ : error LNK2001: unresolved external symbol "MessageBeep"</PRE>
<P> </P>
<P>The only functions that seem to have trouble are Windows<FONT FACE="Symbol">"</FONT> API functions. However, when I compile my code with Borland C++, all works well. What's the story here?</P>
<P></P>
<P>AAh, linker errors. A personal favorite of mine. I certainly spend my share of the work day resolving these time-sucking horrors. Luckily, I have an established routine for locating the source of "unresolved external" errors quickly, and it isn't hard to explain once you understand the basics.</P>
<P>Maybe it's just me, but it seems fashionable these days for programmers to wrap themselves in cozy development environments and not know how their high-level language code becomes executable machine code. Things like OBJ and LIB files are black boxes to most programmers. When things work well, you really don't need to know what happens between sending your compiler code and finding an executable file on disk. But when something breaks, those black boxes are often your only clue regarding what's wrong. </P>
<P>With that said, I'll get off my soapbox and tell you two fundamental truths about C/C++ programming. I've always returned to these truths and found an answer (at least when it came to "unresolved external" linker errors). The first truth is that, if you reference a symbol across compilation units, the symbol names the linker sees must match exactly. (OK, you can fudge this by telling the linker to be case-insensitive, but you get the point.)</P>
<P>To give a concrete example, let's say you have source for a function called Foo in the file A.C. Furthermore, in the OBJ file generated from A.C, the function appears with the name Foo. To use linker parlance, the name Foo is a public symbol residing in A.OBJ. Now, let's say you want to call function Foo from another creatively named source file like B.CPP. When you call Foo from B.CPP, the compiler doesn't know where the real code for Foo resides. In this situation the compiler emits a record in B.OBJ. This record tells the linker it needs to fix up the call to function Foo with Foo's real address. This record is called an external symbol definition since the location of Foo is external to the source module that called it. One of the linker's primary jobs is to match up or "resolve" external definitions (like B.OBJ has for the symbol Foo) with public symbols (like that contained in A.OBJ).</P>
<P>In this example, what's ultimately important to the linker is not what you call the function in your source files. Rather, the only thing that matters is that the names of the public and external names match exactly. If they don't match exactly, you get the dreaded "unresolved external" linker error.</P>
<P>The second fundamental truth is that compilers change symbol names behind your back. For example, C compilers prepend an underbar to the symbol name as it appears in the OBJ file. Thus, function Foo in A.C appears as the public symbol _Foo in A.OBJ. Another example is when you use C++; the compiler takes the function name and adds additional information about the function's parameters. In Visual C++, the function "void Foo(int i)" becomes "?Foo@@YAXH@Z". This renaming is called mangling or decorating, and allows the linker to differentiate between overloaded functions. (Overloaded functions are functions that have the same name, but different parameter lists. With this in mind, you can see how the linker deals with overloaded C++ functions.)</P>
<P>Now, our two truths state that public and external symbol names must match in the link phase, and compilers change symbol names. When you come across an "unresolved external" linker message, the immediate course of action should be obvious: find the public symbol name in the OBJ or LIB file, then compare that to the external symbol name the linker complained about. They're almost always different, and solving the error is a matter of getting the symbol names to match.</P>
<P>Returning to my previous example, let's say that in I have the following prototype for Foo in B.CPP:</P>
<P> </P>
<P><BR></P>
<PRE> void Foo(int i);</PRE>
<P> </P>
<P>If I try to link A.OBJ and B.OBJ I get a linker error. Why? Because Foo's public name is _Foo in A.OBJ, but the mangled function name is ?Foo@@YAXH@Z in B.OBJ (which came from B.CPP). This shows both truths clearly: the compiler changed the symbol name in both source modules, and the resulting symbol names didn't match.</P>
<P>In this case, you can resolve the error by using the extern "C" mechanism. That is, in B.CPP change the prototype to</P>
<P> </P>
<P><BR></P>
<PRE> extern "C" void Foo(int i);</PRE>
<P> </P>
<P>The extern "C" tells the compiler not to mangle Foo's name, but to treat it as a C compiler would (prepending "_" to make the function name _Foo in the OBJ file). This resolves the error by making both names match.</P>
<P>How can you figure out the public and external symbol names in OBJ files, thereby bringing bliss to your coding endeavors? Visual C++ comes with the DUMPBIN program, which displays the contents of OBJ and LIB files (among other things) created by Visual C++. If you run DUMPBIN, make sure to use the /symbols argument to see all the symbol names. Borland compilers come with a program called TDUMP, which works with Borland-produced OBJ and LIB files. For something a little easier to use than DUMPBIN or TDUMP, keep reading. I've provided my own utility later in this month's column.</P>
<P>How does all this apply to mixing Delphi-based code with Visual C++? As it turns out, nearly all Win32<FONT FACE="Symbol">"</FONT> functions are defined as __stdcall functions. Aside from dictating a parameter-passing convention, the names of __stdcall functions are modified by Visual C++ in a fashion that neither Delphi nor Borland C++ recognize. Specifically, Visual C++ adds "_" onto the beginning and "@xxx" onto the end of the __stdcall function. The xxx is actually the size of the stack arguments passed to the function. Thus, MessageBeep(UINT uType) becomes _MessageBeep@4. Likewise, GetMessageA, which takes 4 parameters, becomes _GetMessageA@16. Some programmers refer to this renaming as __stdcall mangling, but it's definitely different from C++ name mangling.</P>
<P>Visual C++ expects the names of __stdcall functions to be mangled, while Borland compilers don't. Thus, the Delphi-produced OBJ has an external reference to just MessageBeep. MessageBeep isn't in the USER32.LIB import library that Visual C++ uses, but the public symbol _MessageBeep@4 is. The Microsoft<FONT FACE="Symbol">"</FONT> linker can't match up these two names, so there's your linker error. For what it's worth, the same problem appears if you try to mix Borland C++ code with Microsoft Visual C++ code.</P>
<P>To make matters just a bit more confusing, Microsoft's mangling of __stdcall function names is undone when the symbol name appears in the export table of a DLL. That is, while the MessageBeep function is mangled to _MessageBeep@4 internally by Visual C++ in your OBJ files, the exported name in USER32.DLL (where MessageBeep's code resides) is just MessageBeep. This allows Borland-compiled code (which doesn't mangle __stdcall function names) to link properly with functions exported by the Win32 DLLs. Visual C++, on the other hand, effectively strips the preceding "_" and following "@xxx" when it puts the symbol name into a DLL's export table.</P>
<P>What can you do about mixing code from the two vendors? Unfortunately, not much. Your first reaction might be to cheat in the Delphi code and call a function called _MessageBeep@4. Unfortunately, the "@" character isn't valid in a Delphi (or C++) identifier, so the code won't compile. Until compiler vendors start singing from the same songbook, we're stuck with issues like this.</P>
<P>QFor some reason, I can't seem to mix and match OBJ or LIB files between the Microsoft and Borland 32-bit compilers. However, this worked fine with 16-bit compilers. What happened?</P>
<P></P>
<P>ALet me first address OBJs specifically, and then move on to LIB files later. From the dawn of the PC until the first Microsoft Win32 programming tools appeared, almost all compilers produced OBJ files in the Intel OMF format. OMF-format OBJ files are not the easiest things in the world to work with, so I won't even attempt a technical description here. The original Windows NT<FONT FACE="Symbol">"</FONT> team worked with an object module format known as Common Object File Format (COFF), which is the official machine-code format for UNIX System V. COFF is relatively easy to work with. COFF format OBJs also have the advantage of being much closer in format to Portable Executable files, the native executable format for Win32. A COFF-format linker should have much less work to create an EXE or DLL from a COFF file than from an Intel OMF-format file.</P>
<P>Just as there are OMF and COFF-format OBJs, there are also OMF and COFF-format LIB files. Mercifully, both LIB formats are just collections of the corresponding format OBJ files bundled together in a single file. Additional information in special records of the LIB file lets the linker quickly determine which OBJ files it needs to use from the LIB file.</P>
<P>The problem with mixing OBJs and LIBs from different compiler vendors is that not every vendor switched to COFF format for its 32-bit compilers. Borland and Symantec still use OMF-style OBJs and LIBs, while Microsoft's <BR>32-bit compilers produce COFF-format OBJs and LIBs. Adding to the confusion, MASM 6.11 produces OMF files <BR>by default, but the /coff switch tells MASM to emit COFF OBJs instead.</P>
<P>When it comes time to link files with different formats, it's anybody's guess what a linker will do. For example, the Visual C++ linker can convert an OMF-style OBJ into COFF if necessary, but it refuses to work with OMF-style LIB files. Borland's TLINK steadfastly refuses to work with COFF-format OBJ or LIB files, as is the case with Symantec C++ 7.2. Watcom 10.5 appears to prefer COFF. The result is that mixing files from different compilers often creates a mess. Cryptic error messages from the linkers don't help.</P>
<P>Even if you're not mixing OBJs from different compilers, you can still run into problems when mixing EXEs and DLLs produced by different compilers. The problem comes from differing import libraries, which are collections of very small OBJs that tell a linker that the code for a particular function resides in some DLL external to the EXE or DLL being linked. Different LIB file formats cause problems if you provide a DLL and you don't know which compiler the consumer of the DLL will be using. In most cases you have to supply two different import libraries, one in COFF format and the other in OMF format. The question is, how do you create these import libraries?</P>
<P>If you did any programming for Windows 3.x, you probably used a tool called IMPLIB that came with your compiler. IMPLIB accepts a DLL as input and emits an OMF-style import library. IMPLIB does it's magic by reading the exports section of the DLL it processes. Thus, if you use a compiler like Borland C++ or Symantec C++, you can run IMPLIB on any 32-bit DLL that you want to link and get back an appropriate format LIB file.</P>
<P>Alas, 32-bit versions of Visual C++ don't come with anything like IMPLIB. Why not? One very good reason is the __stdcall mangling that I mentioned at the beginning of this column. The exported names in a DLL don't contain any information on the number of arguments the function takes, so a hypothetical COFF-format IMPLIB won't know how to generate the proper __stdcall names (for example, _MessageBeep@4).</P>
<P>Luckily, there is a little-known trick you can use in some situations. It's a little messy and it only works with _cdecl functions, not with __stdcall functions. Create a DEF file for the DLL that you want to link with. In the DEF file, include an EXPORTS section that contains the names of the functions to be included in the library. Don't precede the names with "_" characters since they will be added automatically. After you create the DEF file, run the Microsoft 32-bit LIB utility with the /MACHINE and /DEF switches. For example, to create an import library for MYDLL.DLL, you'd make MYDLL.DEF and invoke</P>
<P> </P>
<P><BR></P>
<PRE> LIB /MACHINE:i386 /DEF:MYDLL.DEF</PRE>
<P> </P>
<P>If all goes well, this creates a COFF import library called MYDLL.LIB. </P>
<P></P>
<H2><A NAME="sec0"></A>  OBJHELP</H2><P>Since both questions answered in this month's column have involved OBJs, LIBs, and symbols within them, I wrote a nifty utility called OBJHELP. For any OBJ or LIB file, be it COFF or Intel-OMF based, OBJHELP displays the type of file. More importantly, OBJHELP shows you the exact names of all public and external symbols in the file. This can be very helpful when you're trying to track down those pesky "unresolved external" linker errors. For instance, you could run two instances of OBJHELP. In one, examine the OBJ with the unresolved external. In the other, display the library or OBJ that you believe the code should be in. If the names don't match, you'll probably have an unhappy linker.</P>
<P><B>Figure 1</B> shows OBJHELP in action. The edit control at the top left shows the name of the file currently being displayed. You can select a file in three ways: you can type the name of the file and hit Enter; you can browse for a file with the Browse button; or you can be cool and drag an OBJ or LIB file from someplace like Explorer and drop it on the OBJHELP window. (Hey, I had to learn drag and drop sometime!)</P>
<P><img src="hood1.gif"></P>
<P><B> Figure 1  OBJHELP</B></P>
<P>Whenever OBJHELP displays a file, the two list boxes are filled with information. The top list box shows all the public symbols in the file and the bottom list box shows all the external symbols. If some of the symbol names look like garbage, it's most likely because of C++ name mangling. I purposefully didn't unmangle them because I wanted you to see the same strings that the linker sees when trying to resolve things.</P>
<P>A couple of points are important to note about the external symbols you see. First, the same symbol may show up multiple times in the Externs list box if you're displaying a LIB file. This happens when the LIB file contains multiple OBJ files that have external references to the same function. Second, when dumping COFF import libraries, function names may be preceded by "__imp__" (for example, __imp__GetFocus@0). This is a byproduct of using __declspec(dllimport) with a function definition. I described how __declspec(dllimport) works in my November 1995 column, so I won't go over the gory details here.</P>
<P>When showing an OMF-style import library, OBJHELP precedes the symbol name with the name of the DLL from which the symbol comes (for instance, USER32.dll.GETFOCUS). I did this because Borland combines the import information from numerous system DLLs into a single library (IMPORT32.LIB). In contrast, Microsoft and Symantec have separate import libraries for each DLL (KERNEL32.LIB, USER32.LIB, and so on).</P>
<P>The OBJHELP code itself (see<B> </B><B>Figure 2</B>) can be split into two parts. The user interface code resides in OBJHELP.CPP. This is a fairly straightforward dialog-based user interface. The remaining files are for identifying the type of file specified and finding the public and external symbols within the file. I suspect the formats of OBJ and LIB files is of limited interest to most programmers, so I'll skip a blow-by-blow description. Those of you who are interested can read the code and figure out what I did (it's reasonably well commented).</P>
<P><B> Figure 2  OBJHELP</B></P>
<P>OBJHELP.CPP</P>
<P><BR></P>
<PRE> //==================================
// OBJHELP - Matt Pietrek 1996
// FILE: OBJHELP.CPP
//==================================
#include &lt;windows.h&gt;
#include &lt;shellapi.h&gt;
#include &lt;commdlg.h&gt;
#include &lt;stdarg.h&gt;
#pragma hdrstop
#include "OBJHELP.H"
#include "dumpobj.h"

// Helper functions
void Handle_WM_COMMAND(HWND hDlg, WPARAM wParam, LPARAM lParam);
void Handle_WM_INITDIALOG(HWND hDlg);
void Handle_WM_CLOSE( HWND hDlg );
void Handle_WM_DROPFILES( HWND hDlg, WPARAM wParam );
BOOL Handle_Browse( HWND hWndDlg );
BOOL CALLBACK ObjHelpDlgProc( HWND, UINT, WPARAM, LPARAM );
void GetSetPositionInfoFromRegistry( BOOL fSave, POINT *lppt );
void ProcessNewFile( void );

BOOL fProcessingLib = FALSE;
HWND g_hDlg = 0;
HWND g_hPublicsListBox = 0;
HWND g_hExternsListBox = 0;
unsigned g_cAveLBCharWidth = 0;
unsigned cbMaxPublics=0;        // longest string in publics listbox
unsigned cbMaxExterns=0;        // longest string in externs listbox

// ======================= String literals ===============================
char gszRegistryKey[] = "Software\\WheatyProductions\\ObjHelp";

char g_AboutMsgTxt[] =
"OBJHELP displays the public and external symbols in OBJ and LIB files."
"It works with both COFF and Intel OMF format files.\r\n\r\n"
"Files can be displayed via the Browse button, or by dragging a file onto "
"the program's window.\r\n\r\n"
"For more information about OBJHELP, refer to the July 1996 Microsoft "
"Systems Journal, or the Microsoft Developer Network CD.";

char g_AboutTitleTxt[] = "OBJHELP - Matt Pietrek 1996, for MSJ";

// ======================= Start of code ===============================

int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInstance,
                    PSTR lpszCmdLine, int nCmdShow )
{
    // Bring up the user interface (A dialog box?  What a surprise!)
    DialogBox(hInstance, "ObjHelpDlg", 0, (DLGPROC)ObjHelpDlgProc);
    return 0;
}

BOOL CALLBACK ObjHelpDlgProc(HWND hDlg,UINT msg,WPARAM wParam,LPARAM lParam)
{
    switch ( msg )
    {
        case WM_COMMAND:
            Handle_WM_COMMAND( hDlg, wParam, lParam ); return TRUE;
        case WM_INITDIALOG:
            Handle_WM_INITDIALOG( hDlg ); return TRUE;
        case WM_DROPFILES:
            Handle_WM_DROPFILES( hDlg, wParam ); return 0;
        case WM_CLOSE:
            Handle_WM_CLOSE( hDlg ); break;
        // let everything else fall through
    }
    return FALSE;
}

void Handle_WM_COMMAND( HWND hDlg, WPARAM wParam, LPARAM lParam )
{
    switch ( LOWORD(wParam) )
    {
        case IDC_BUTTON_BROWSE:
            if ( Handle_Browse( hDlg ) )
                ProcessNewFile();
            break;
        case IDC_BUTTON_HELP:
            MessageBox( hDlg, g_AboutMsgTxt, g_AboutTitleTxt, MB_OK );
            break;
        case IDOK:
            if ( GetFocus() == GetDlgItem(hDlg, IDC_EDIT_FILENAME) )
                ProcessNewFile();
            break;
    }
    
    return;
}

void Handle_WM_INITDIALOG(HWND hDlg)
{
    // Get the window coordinates where ObjHelp.EXE was last running,
    // and move the window to that spot.
    POINT pt;
    GetSetPositionInfoFromRegistry( FALSE, &amp;pt );
    SetWindowPos(hDlg, 0, pt.x, pt.y, 0, 0,
                 SWP_NOSIZE | SWP_NOREDRAW | SWP_NOZORDER | SWP_NOACTIVATE);

    // Set us up to accept dropped filenames
    DragAcceptFiles( hDlg, TRUE );

    g_hDlg = hDlg;      // Save off the hDlg in a global variable
    g_hPublicsListBox = GetDlgItem( hDlg, IDC_LIST_PUBLIC_SYMBOLS );
    g_hExternsListBox = GetDlgItem( hDlg, IDC_LIST_EXTERN_SYMBOLS );
    
    // Figure out how wide characters in the listboxes will be
    HDC hDCLB = GetDC( g_hPublicsListBox );
    if ( hDCLB )
    {
        TEXTMETRIC tm;
        if ( GetTextMetrics(hDCLB, &amp;tm) )
            g_cAveLBCharWidth = tm.tmAveCharWidth;
        ReleaseDC( g_hPublicsListBox, hDCLB );
    }
}

void Handle_WM_CLOSE( HWND hDlg )
{
    // Stop accepting dropped filenames
    DragAcceptFiles( hDlg, TRUE );

    // Save off the window's X,Y coordinates for next time
    RECT rect;
    GetWindowRect( hDlg, &amp;rect );
    GetSetPositionInfoFromRegistry( TRUE, (LPPOINT)&amp;rect );
    EndDialog(hDlg, 0);
}

void Handle_WM_DROPFILES( HWND hDlg, WPARAM wParam )
{
    char szFileName[MAX_PATH];
    UINT cbFileName;

    // Get the name of the file that was dropped on us, the release the HDROP
    cbFileName = DragQueryFile((HDROP)wParam,0,szFileName,sizeof(szFileName));
    DragFinish( (HDROP)wParam );
        
    if ( fProcessingLib )   // If we're already processing, don't bother
        return;

    SetDlgItemText( hDlg, IDC_EDIT_FILENAME, szFileName );
    
    ProcessNewFile();
}

BOOL Handle_Browse( HWND hDlg )
{
    OPENFILENAME ofn;
    char szFilename[512] = "";
    static char szFilter1[] = "OBJS (*.OBJ)\0*.OBJ\0LIBS (*.LIB)\0*.LIB\0";

    memset(&amp;ofn, 0, sizeof(OPENFILENAME));

    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFilter = szFilter1;
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = szFilename;
    ofn.nMaxFile = sizeof(szFilename);
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;

    if ( GetOpenFileName(&amp;ofn) )
    {
        SetDlgItemText( hDlg, IDC_EDIT_FILENAME, szFilename );
        return TRUE;
    }

    return FALSE;
}

void GetSetPositionInfoFromRegistry( BOOL fSave, POINT *lppt )
{
    HKEY hKey;
    DWORD dataSize, err, disposition;
    char szKeyName[] = "DlgCoordinates";
    
    if ( !fSave )               // In case the key's not there yet, we'll
        lppt-&gt;x = lppt-&gt;y = 0;  // return 0,0 for the coordinates

    // Open the registry key (or create it if the first time being used)
    err = RegCreateKeyEx( HKEY_CURRENT_USER, gszRegistryKey, 0, 0,
                         REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
                         0, &amp;hKey, &amp;disposition );
    if ( ERROR_SUCCESS != err )
        return;

    if ( fSave )            // Save out coordinates
    {
        RegSetValueEx( hKey, szKeyName, 0, REG_BINARY,
                       (PBYTE)lppt, sizeof(*lppt) );
    }
    else                    // read in coordinates
    {
        dataSize = sizeof(*lppt);
        RegQueryValueEx( hKey, szKeyName, 0, 0, (PBYTE)lppt, &amp;dataSize );
    }
}

#define PREFIX_SKIP 8   // Skip first 8 characters of output

int output( char *format, ... )
{
    va_list argptr;
    va_start( argptr, format );
    char szBuffer[1024];
    
    int result = wvsprintf(szBuffer, format, argptr);   // Format the string
    
    unsigned cbOutput = 0;
    if ( result &gt; PREFIX_SKIP)
        cbOutput = result - PREFIX_SKIP;
    
    // Decide which listbox this output is going to
    HWND hWndDest = 0;
    if ( 0 == strnicmp(szBuffer, "public: ", PREFIX_SKIP) )
    {
        hWndDest = g_hPublicsListBox;
        cbMaxPublics = (cbOutput &gt; cbMaxPublics) ? cbOutput : cbMaxPublics;
    }
    else if ( 0 == strnicmp(szBuffer, "extern: ", PREFIX_SKIP) )
    {
        hWndDest = g_hExternsListBox;
        cbMaxExterns = (cbOutput &gt; cbMaxExterns) ? cbOutput : cbMaxExterns;
    }
    
    // Add the string to the appropriate listbox
    if ( hWndDest )
        SendMessage(hWndDest, LB_ADDSTRING, 0, (LPARAM)(szBuffer+PREFIX_SKIP));

    va_end( argptr );
    return result;
}

void ProcessNewFile( void )
{
    char szFileName[MAX_PATH];

    fProcessingLib = TRUE;
    
    GetDlgItemText( g_hDlg, IDC_EDIT_FILENAME, szFileName,
                    sizeof(szFileName) );

    HCURSOR hOldCursor = SetCursor( LoadCursor(0,IDC_WAIT) );

    // Clear out the listboxes
    SendMessage( g_hPublicsListBox, LB_RESETCONTENT, 0, 0 );
    SendMessage( g_hExternsListBox, LB_RESETCONTENT, 0, 0 );

    // Turn off listbox updating
    SendMessage( g_hPublicsListBox, WM_SETREDRAW, 0, 0 );
    SendMessage( g_hExternsListBox, WM_SETREDRAW, 0, 0 );
        
    cbMaxPublics = cbMaxExterns = 0;
        
    // Fill with new information
    OBJ_FILE_TYPE fileType = DisplayObjectFile( szFileName );


    // Set the horizontal width of the listboxes so they scroll if necessary
    SendMessage( g_hPublicsListBox, LB_SETHORIZONTALEXTENT,
                    (g_cAveLBCharWidth * (cbMaxPublics+4)), 0 );
    SendMessage( g_hExternsListBox, LB_SETHORIZONTALEXTENT,
                    (g_cAveLBCharWidth * (cbMaxExterns+4)), 0 );
                
    // Turn listbox updating back on
    SendMessage( g_hPublicsListBox, WM_SETREDRAW, TRUE, 0 );
    SendMessage( g_hExternsListBox, WM_SETREDRAW, TRUE, 0 );
    
    PSTR pszFileType;
    
    switch ( fileType )
    {
        case OBJ_COFF_OBJ: pszFileType = "COFF OBJ"; break;
        case OBJ_COFF_LIB: pszFileType = "COFF LIB"; break;
        case OBJ_OMF_OBJ: pszFileType = "OMF OBJ"; break;
        case OBJ_OMF_LIB: pszFileType = "OMF LIB"; break;
        case OBJ_OMF_IMPLIB: pszFileType = "OMF IMPORT LIB"; break;
        default: pszFileType = "UNKNOWN FILE TYPE"; break;
    }
    
    SetDlgItemText( g_hDlg, IDC_STATIC_DESCRIPTION, pszFileType );
    
    SetCursor( hOldCursor );

    fProcessingLib = FALSE;
}
</PRE>
<P>DUMPOBJ.CPP</P>
<P><BR></P>
<PRE> //==================================
// OBJHELP - Matt Pietrek 1996
// FILE: DUMPOBJ.CPP
//==================================
#include &lt;windows.h&gt;
#pragma hdrstop
#include "dumpobj.h"
#include "memmapfl.h"

OBJ_FILE_TYPE DisplayObjectFile( PTSTR pszFileName )
{
    MEMORY_MAPPED_FILE mmf( pszFileName );
    
    PBYTE pFileBase = (PBYTE)mmf.GetPointerToMemory();
    if ( !pFileBase )
    {
        output( "Couldn't open mapping for %s\n", pszFileName );
        return OBJ_UNKNOWN;
    }

    if ( 0 == strncmp((PSTR)pFileBase, IMAGE_ARCHIVE_START,
                    IMAGE_ARCHIVE_START_SIZE) )
    {
        DumpCOFFLibFile( pFileBase );
        return OBJ_COFF_LIB;
    }
    else if ( IMAGE_FILE_MACHINE_I386 == *(PWORD)pFileBase )
    {
        DumpCOFFObjFile( pFileBase );
        return OBJ_COFF_OBJ;
    }
    else if ( (0xF0 == *(PBYTE)pFileBase) || (0x80 == *(PBYTE)pFileBase) )
        return DumpIntelOMFFile( pFileBase );
    else
        return OBJ_UNKNOWN;
}

#ifdef CMDLINE

int output( char *format, ... )
{
    va_list argptr;
    va_start( argptr, format );
    char szBuffer[1024];
    int result = wvsprintf(szBuffer, format, argptr);
    strcat( szBuffer, "\n" );   // Tack on a newline for the cmdline output
    WriteFile( GetStdHandle(STD_OUTPUT_HANDLE), szBuffer,
                result+1, (PDWORD)&amp;result, 0 ); //+1 for the newline we added
    va_end( argptr );
    return result;
}

int main( int argc, char * argv[] )
{
    output( "DUMPOBJ - Matt Pietrek 1996, for Microsoft Systems Journal" );
    if ( argc &lt;= 1 )
    {
        output( "syntax: DUMPOBJ &lt;filename&gt;\n" );
        return 1;
    }
    
    DisplayObjectFile( argv[1] );

    return 0;
}

#endif

</PRE>
<P>DUMPCOFF.CPP</P>
<P><BR></P>
<PRE> //==================================
// OBJHELP - Matt Pietrek 1996
// FILE: DUMPCOFF.CPP
//==================================
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#pragma hdrstop
#include "dumpobj.h"

// MakePtr is a macro that allows you to easily add to values (including
// pointers) together without dealing with C's pointer arithmetic.  It
// essentially treats the last two parameters as DWORDs.  The first
// parameter is used to typecast the result to the appropriate pointer type.
#define MakePtr( cast, ptr, addValue ) (cast)( (DWORD)(ptr) + (DWORD)(addValue))

void DumpCOFFObjFile( PBYTE pFileBase )
{
    PIMAGE_FILE_HEADER pFileHdr = (PIMAGE_FILE_HEADER)pFileBase;

    // Bail out if it's not an Intel OBJ.  Sorry...!
    if ( IMAGE_FILE_MACHINE_I386 != pFileHdr-&gt;Machine )
        return;
    
    PIMAGE_SYMBOL pSymbol = MakePtr( PIMAGE_SYMBOL,
                    pFileHdr, pFileHdr-&gt;PointerToSymbolTable );

    // Pointer math at work here!
    PIMAGE_SYMBOL pSymbolEnd = pSymbol + pFileHdr-&gt;NumberOfSymbols;

    // Point at the string table, which immediately follows the symbol table
    PSTR pStringTable = (PSTR)pSymbolEnd;
    
    while ( pSymbol &lt; pSymbolEnd )
    {
        // We only care about storage class "EXTERNAL"
        if ( IMAGE_SYM_CLASS_EXTERNAL == pSymbol-&gt;StorageClass )
        {
            // First, let's get a pointer to the name
            PSTR pszName;
            char szShortNameBuff[ sizeof(pSymbol-&gt;N) + 1 ];
            
            if ( pSymbol-&gt;N.Name.Short )
            {
                pszName = szShortNameBuff;
                memcpy( pszName, &amp;pSymbol-&gt;N, sizeof(pSymbol-&gt;N) );
                pszName[8] = 0;
            }
            else
                pszName = pStringTable + pSymbol-&gt;N.Name.Long;

            // strings starting with "??_" are string literals.  Ignore them
            if ( 0 == strncmp( pszName, "??_", 3 ) )
                goto next;

            if ( IMAGE_SYM_UNDEFINED == pSymbol-&gt;SectionNumber )
                output( "extern: %s", pszName );
            else
                output( "public: %s", pszName );
        }
        
        next:
        
        pSymbol += pSymbol-&gt;NumberOfAuxSymbols + 1; // Pointer math here!
    }
}

void DumpCOFFLibFile( PBYTE pFileBase )
{
    PIMAGE_ARCHIVE_MEMBER_HEADER pArchHdr;

    // Advance past the "!&lt;arch&gt;\n" that starts a COFF library  
    pArchHdr = (PIMAGE_ARCHIVE_MEMBER_HEADER)
                (pFileBase + IMAGE_ARCHIVE_START_SIZE);
    
    while( 1 )
    {
        if ( 0 == strncmp(  (PSTR)pArchHdr-&gt;Name,
                            IMAGE_ARCHIVE_LINKER_MEMBER, 16) )
        {
            ;   // Do nothing - it's a linker member (i.e., the dictionary)
        }
        else if ( 0 == strncmp( (PSTR)pArchHdr-&gt;Name,
                                IMAGE_ARCHIVE_LONGNAMES_MEMBER,16) )
        {
            ;   // Do nothing - it's the string pool
        }
        else
        {
            // output( "OBJ in LIB at %08X\n",
            //          (PBYTE)pArchHdr - (PBYTE)pFileBase );

            DumpCOFFObjFile( (PBYTE)(pArchHdr + 1));    // It's an OBJ file
        }

        // Calculate how big this member is (it's originally stored as 
        // as ASCII string.
        unsigned thisMemberSize = atoi((PSTR)pArchHdr-&gt;Size)
                                + IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR;

        thisMemberSize = (thisMemberSize+1) &amp; ~1;   // Round up

        // Get a pointer to the next archive member
        pArchHdr = MakePtr(PIMAGE_ARCHIVE_MEMBER_HEADER, pArchHdr,
                                thisMemberSize);

        // There's no good way to know if we hit the end of the file
        // (short of knowing how big the file is, and tracking how far
        // we're into it.)  Thus, we'll keep going until we see garbage.
        if ( IsBadReadPtr( pArchHdr, IMAGE_SIZEOF_ARCHIVE_MEMBER_HDR) )
            break;

        if ( strncmp((PSTR)pArchHdr-&gt;EndHeader, IMAGE_ARCHIVE_END, 2) )
            break;
    }
}

</PRE>
<P>DUMPCOFF.CPP</P>
<P><BR></P>
<PRE> //==================================
// OBJHELP - Matt Pietrek 1996
// FILE: DUMPCOFF.CPP
//==================================
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#pragma hdrstop
#include "dumpobj.h"

// MakePtr is a macro that allows you to easily add to values (including
// pointers) together without dealing with C's pointer arithmetic.  It
// essentially treats the last two parameters as DWORDs.  The first
// parameter is used to typecast the result to the appropriate pointer type.
#define MakePtr( cast, ptr, addValue ) (cast)( (DWORD)(ptr) + (DWORD)(addValue))

void DumpCOFFObjFile( PBYTE pFileBase )
{
    PIMAGE_FILE_HEADER pFileHdr = (PIMAGE_FILE_HEADER)pFileBase;

    // Bail out if it's not an Intel OBJ.  Sorry...!
    if ( IMAGE_FILE_MACHINE_I386 != pFileHdr-&gt;Machine )
        return;
    
    PIMAGE_SYMBOL pSymbol = MakePtr( PIMAGE_SYMBOL,
                    pFileHdr, pFileHdr-&gt;PointerToSymbolTable );

    // Pointer math at work here!
    PIMAGE_SYMBOL pSymbolEnd = pSymbol + pFileHdr-&gt;NumberOfSymbols;

    // Point at the string table, which immediately follows the symbol table
    PSTR pStringTable = (PSTR)pSymbolEnd;
    
    while ( pSymbol &lt; pSymbolEnd )
    {
        // We only care about storage class "EXTERNAL"
        if ( IMAGE_SYM_CLASS_EXTERNAL == pSymbol-&gt;StorageClass )
        {
            // First, let's get a pointer to the name
            PSTR pszName;
            char szShortNameBuff[ sizeof(pSymbol-&gt;N) + 1 ];
            
            if ( pSymbol-&gt;N.Name.Short )
            {
                pszName = szShortNameBuff;
                memcpy( pszName, &amp;pSymbol-&gt;N, sizeof(pSymbol-&gt;N) );
                pszName[8] = 0;
            }
            else
                pszName = pStringTable + pSymbol-&gt;N.Name.Long;

            // strings starting with "??_" are string literals.  Ignore them
            if ( 0 == strncmp( pszName, "??_", 3 ) )
                goto next;

            if ( IMAGE_SYM_UNDEFINED == pSymbol-&gt;SectionNumber )
                output( "extern: %s", pszName );
            else
                output( "public: %s", pszName );
        }

    comentFlags = 0;        // Don't know what this is yet.

    if ( m_commentClass != 0xA0 )   // Bail out if not an OMF extension
        return;
    if ( 0x1 != *p )                // Bail out if not an IMPDEF
        return;

    comentFlags |= OMF_COMENT_IMPDEF;           // It's an IMPDEF

    p += 2;                 // Blast past the subtype and ordinal fields
        
    // Copy the "internal" name to a buffer, then advance past it
    memcpy( szName, p+1, *p );
    szName[*p] = 0;
    p += (*p + 1);          // Advance past internal name

    // Copy the module name out of the record, then advance past it.
    memcpy( szModuleName, p+1, *p );
    szModuleName[*p] = 0;
    
    output( "public: %s.%s", szModuleName, szName );
}

OBJ_FILE_TYPE DumpIntelOMFFile( PBYTE pFileBase )
{
    POMF_RECORD pBaseRec = (POMF_RECORD)pFileBase;
    DWORD comentFlags;

    // Check to see if it's a library, and if so, grab the page align size
    BOOL fLib = (BOOL)(OMF_LIBHDR == pBaseRec-&gt;m_type);
    unsigned cbAlign = fLib ? (pBaseRec-&gt;m_length + 3): 0;  // Don't ask...
    
    BOOL fContinue = TRUE;
    while ( fContinue )
    {
        // output( "Record %02X at: %08X\n", pBaseRec-&gt;m_type,
        //      (PBYTE)pBaseRec - pFileBase );
            
        BOOL fPageAlign = FALSE;        // Round up record to next paragraph
        switch( pBaseRec-&gt;m_type )
        {
            case OMF_EXTDEF:
                ((POMF_EXTDEF_RECORD)pBaseRec)-&gt;Display();
                break;

            case OMF_PUBDEF:
            case OMF_PUBD32:
                ((POMF_PUBDEF_RECORD)pBaseRec)-&gt;Display();
                break;
                
            case OMF_COMENT:
                ((POMF_COMENT_RECORD)pBaseRec)-&gt;Display( comentFlags );
                break;
                
            case OMF_MODEND:
            case OMF_MODE32:
                if ( fLib )
                    fPageAlign = TRUE;
                else
                    fContinue = FALSE;  // Not a .LIB.  We're done dumping
                break;

            case OMF_LIBEND:
                fContinue = FALSE;
                break;

            default:
                if ( (pBaseRec-&gt;m_type &lt; OMF_THEADR) || // Check for bogus
                     (pBaseRec-&gt;m_type &gt; OMF_LIBEND) )  // OMF records
                    fContinue = FALSE;
                break;
        }

        // Point to the next record
        pBaseRec = (POMF_RECORD)((DWORD)pBaseRec + pBaseRec-&gt;m_length + 3);
    
        // If necessary, adjust up to the next paragraph (.LIB files need
        // this when you encounter a MODEND record).
        if ( fPageAlign )
        {
            // Write-only code to align to the next page-sized boundary
            DWORD temp = (DWORD)pBaseRec + (cbAlign-1);
            pBaseRec = (POMF_RECORD)(temp &amp; ~(cbAlign-1));
        }
    }
    
    if ( comentFlags &amp; OMF_COMENT_IMPDEF )
        return OBJ_OMF_IMPLIB;
    else if ( fLib )
        return OBJ_OMF_LIB;
    else
        return OBJ_OMF_OBJ;
}
</PRE>
<P></P>
<P>It is worth noting how I find the public and external symbols, however. In OMF files, I simply scan all the records and display only those names in PUBDEF, PUBD32, and EXTDEF records. For COFF OBJs and LIBs I use the symbol table that every OBJ contains. COFF LIBs have two records that list all the public symbols for quick lookup by the linker. I skip those records though, as the same information appears in the OBJ symbol tables. I have to read the symbol tables anyway to find the external symbols.</P>
<P>I didn't forget all you command-line tool types—I'm one myself. Specifying the HARDCORE=1 option when building OBJHELP.MS causes a program called DUMPOBJ to be built instead of OBJHELP. That is, "NMAKE HARDCORE=1 OBJHELP.MS" creates DUMPOBJ.EXE, which is a console-mode application. DUMPOBJ.EXE takes a single command-line argument (the name of the OBJ or LIB you want to display) and writes its output to stdout. This is nice for redirecting the output to a file.</P>
<P> </P>
<P><BR></P>
<PRE> DUMPOBJ.EXE d:\mstools\lib\comctl32.lib &gt; myfile</PRE>
<P> </P>
<P>In myfile, the output begins like this:</P>
<P> </P>
<P><BR></P>
<PRE> DUMPOBJ - Matt Pietrek 1996, for Microsoft Systems Journal
public: __IMPORT_DESCRIPTOR_COMCTL32
extern: __NULL_IMPORT_DESCRIPTOR
extern: COMCTL32_NULL_THUNK_DATA
public: __NULL_IMPORT_DESCRIPTOR
public: COMCTL32_NULL_THUNK_DATA
public: _AddMRUData@12
public: __imp__AddMRUData@12
extern: __IMPORT_DESCRIPTOR_COMCTL32
&lt;rest of file omitted&gt;</PRE>
<P> </P>
<P>In an ideal world, compilers and linkers would have a "Do what I mean" setting. Until then, we'll have to wrestle with issues like getting symbol names straight and figuring out what types of OBJ or LIB files you're dealing with.</P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P> Have a question about programming in Windows? You can mail it directly to Under the Hood, Microsoft Systems Journal, 825 Eighth Avenue, 18th Floor, New York, New York 10019, or send it to MSJ(re: Under the Hood) via:</P></TD></TR><TR><TD VALIGN="TOP"><P> <BR>Internet:</P></TD><TD VALIGN="TOP"><P>Matt Pietrek<BR>71774.362@compuserve.com</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>This article is reproduced from Microsoft Systems Journal. Copyright </I>©<I> 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P><I>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</I></P>
<P></P></font></body></HTML>
