<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C/C++ Q &amp; A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css">


</HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  C/C++ Q &amp; A</H1><P>Paul DiLascia</P>
<P>Paul DiLascia is a freelance software consultant and writer-at-large. He is the author of <I>Windows++: Writing Reusable Code in C++</I> (Addison-Wesley, 1992).</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4896">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the COMBOED project files.</A></P><P><OBJECT id=sample2 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4897">
</OBJECT><a href="javascript:sample2.Click()">
Click to open or copy the DLGICON project files.</A></P><P><font size="6" face="verdana,arial,helvetica">Q</font>I read your column about registering Window¨ classes in MFC (<I>MSJ</I>, Jan 1996). My app has several modeless dialog boxes, and I'd like each of them to have a distinct icon when it's minimized. I tried SetClassLong(GCL_HICON), but this changes the icon for all modeless dialogs in MFC. I tried overriding PreCreateWindow, but it never gets called. So how do I control the icons for these dialogs?</P>
<P><I>Tony Edwards</I></P>
<P>MicroPlanet, Inc.</P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>When is a window not a window? When it's a dialog, of course. One of the biggest quirks in Windows is the way dialogs behave differently from "normal" windows. First of all, they have a hardwired class name, the pointer 0x8002, which appears as "#32770" in spy programs and when you call GetClassName. There's the way you create dialogs with CreateDialog or DialogBox (or one of the Indirect variants) instead of with CreateWindow. Then there's WM_INITDIALOG, which only dialogs receive, and there's EndDialog, and.... In short, there are just lots of little things that work differently for dialogs.</P>
<P>MFC does its best to shield you from them—in Version 4.0, for example, all dialogs are really modeless, even "modal" ones, so now modal dialogs can handle PreTranslateMessage too—but there's only so much MFC can do. For example, since dialogs aren't created with a CREATESTRUCT, it makes no sense for MFC to call PreCreateWindow for dialogs.</P>
<P>Alas, the built-in dialog class for Windows doesn't have an icon, so only text appears in the window title and task bar button (see <B>Figure 1</B>). That's no fun; we want dialogs with icons! So how do you get them? Well, there is a way to use your own class for dialogs. First, you have to use the CLASS keyword in your resource file.</P>
<P><BR></P>
<PRE> 
IDD_MUMBLE DIALOG DISCARDABLE 34, 22, 165, 74
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Mumble Dialog"
CLASS "MyMumbleDlgClass"  /* &lt;= = = Use my class */
</PRE>
<P><img src="cqa1.gif"></P>
<P><B> Figure 1  My Dialog has no icon.</B></P>
<P></P>
<P>Then, you have to register the class in your program. The best thing to do is start with the WNDCLASS info from the standard dialog class and modify it for your own use.</P>
<P></P>
<P><BR></P>
<PRE> WNDCLASS wc;
::GetClassInfo(NULL, MAKEINTRESOURCE(0x8002), &amp;wc);
wc.lpszClassName = MYCLASS;
wc.hIcon = hMyIcon;
·
·
·
</PRE>
<P>You get the idea. I'm not going to bother showing any more details, because there's a much easier way to give your dialog an icon—provided you're using Windows® 95. There's a new message that does just what you want: WM_SETICON. (There's WM_GETICON too.) I wrote a tiny program, DLGICON, that shows how to use it. <B>Figure 2</B> shows the program. Here's the relevant snippet:</P>
<P><BR></P>
<PRE> 
BOOL CMyDialog::OnInitDialog()
{
   SetIcon(AfxGetApp()-&gt;LoadIcon(IDI_MYDIALOG_SM),
           FALSE);
   SetIcon(AfxGetApp()-&gt;LoadIcon(IDI_MYDIALOG_LG),
           TRUE);
   return CDialog::OnInitDialog();
}</PRE>
<P></P>
<P><B> Figure 2  DLGICON</B></P>
<P><BR></P>
<PRE> 
DLGICON.RC
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#define _AFX_NO_SPLITTER_RESOURCES\r\n"
    "#define _AFX_NO_OLE_RESOURCES\r\n"
    "#define _AFX_NO_TRACKER_RESOURCES\r\n"
    "#define _AFX_NO_PROPERTY_RESOURCES\r\n"
    "\r\n"
    "#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)\r\n"
    "#ifdef _WIN32\r\n"
    "LANGUAGE 9, 1\r\n"
    "#pragma code_page(1252)\r\n"
    "#endif\r\n"
    "#include ""res\\app.rc2""  //non-MicrosoftVisualC++ editedresources\r\n"
    "#include ""afxres.rc""     // Standard components\r\n"
    "#endif\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_MYDIALOG_SM         ICON    DISCARDABLE     "res\\dlgsm.ico"
IDI_MYDIALOG_LG         ICON    DISCARDABLE     "res\\dlglg.ico"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_MYDIALOG DIALOG DISCARDABLE  0, 0, 212, 95
STYLE DS_MODALFRAME | WS_MINIMIZEBOX | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "My Dialog"
FONT 8, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,147,41,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,147,67,50,14
    LTEXT           "This dialog is a test. It is only a test. Had this been a real dialog, it would do something useful.",
                    IDC_STATIC,7,12,190,20
    CONTROL         "Check here if it makes you happy.",IDC_CHECK1,"Button",
                    BS_AUTOCHECKBOX | WS_TABSTOP,7,41,119,10
END


#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "\0"
            VALUE "FileDescription", "DLGICON Application by Paul DiLascia\0"
            VALUE "FileVersion", "1, 0, 0, 1\0"
            VALUE "InternalName", "DLGICON\0"
            VALUE "LegalCopyright", "Copyright © 1996 Microsoft Systems Journal\0"
            VALUE "OriginalFilename", "DLGICON.EXE\0"
            VALUE "ProductName", "DLGICON\0"
            VALUE "ProductVersion", "1, 0, 0, 1\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // !_MAC


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)#ifdef _WIN32
LANGUAGE 9, 1
#pragma code_page(1252)
#endif
#include "res\app.rc2"  // non-Microsoft Visual C++ edited resources
#include "afxres.rc"         // Standard components
#endif
/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

DLGICON.CPP
////////////////////////////////////////////////////////////////
// DLGICON Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// DLGICON illustrates how to give your dialog an icon, which appears
// in the window caption and Windows 95 task bar 
// Compiles with VC++ 4.0 or later
//
#include "stdafx.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////
// A very minimal app indeed
//
class CMyApp : public CWinApp {
public:
   virtual BOOL InitInstance();
} theApp;

//////////////////
// Dialog that installs its own icon for title bar and minimized state
// 
class CMyDialog : public CDialog {
public:
   CMyDialog() : CDialog(IDD_MYDIALOG, NULL) { }
protected:
   virtual BOOL OnInitDialog();
};

//////////////////
// Start the app: display dialog then quit
//
BOOL CMyApp::InitInstance()
{
   CMyDialog().DoModal();  // run the dialog
   return FALSE;           // exit app
}

//////////////////
// Initialize my dialog: set the icon
//
BOOL CMyDialog::OnInitDialog()
{
   SetIcon(AfxGetApp()-&gt;LoadIcon(IDI_MYDIALOG_SM), FALSE);
   SetIcon(AfxGetApp()-&gt;LoadIcon(IDI_MYDIALOG_LG), TRUE);
   return CDialog::OnInitDialog();
}
</PRE>
<P>SetIcon is an MFC 4.0 wrapper for SendMessage(WM_SETICON...), and the Boolean argument is FALSE if you want to set the small (16<FONT FACE="Symbol">´</FONT>16) icon or TRUE if you want to set the big (32<FONT FACE="Symbol">´</FONT>32) one. According to the Win32® API documentation, the big icon is used when the window is minimized and the small one goes in the window title—but I'm here to say it ain't so! Windows 95 uses the small icon in both places, but it does use the large icon when you task-switch with Alt-TAB. <B>Figure 3 </B>shows DLGICON after the makeover.</P>
<P><img src="cqa3.gif"></P>
<P><B> Figure 3  Now My Dialog has its icons.</B></P>
<P>Be advised that WM_SETICON exists only in Windows 95, not in Windows 3.x, Windows NT<FONT FACE="Symbol">Ô</FONT>,or Win32s. For those operating systems, you have to either do the CLASS trick sketched above or else handle WM_PAINT messages.</P>
<P><BR></P>
<PRE> 
// Do this for Windows 3.x or Windows NT 3.51
void CMyDialog::OnPaint()
{
   if (IsIconic()) {
      CPaintDC dc(this);
      dc.DrawIcon(0, 0, 
               AfxGetApp()-&gt;LoadIcon(IDI_MYDIALOG_LG));
   } else
      Default();
}
</PRE>
<P>You also have to handle WM_QUERYDRAGICON so Windows will draw the proper icon while the user drags your minimized window around, and WM_ERASEBKGND so you don't end up with a white background for your icon.</P>
<P><BR></P>
<PRE> 
HCURSOR CMyDialog::OnQueryDragIcon()
{
   // return handle to drag state icon
   return (HCURSOR)m_hMyIcon; // cast is OK
}

BOOL CMyDialog::OnEraseBkgnd(CDC* pDC)
{
   return IsIconic() ? TRUE /* (Don't do anything) */
      : Default();
}
</PRE>
<P>The Visual C++ AppWizard generates similar code, including SetIcon calls, when you create a "Dialog-based" application. Note that Windows sends WM_ERASEBKGND if your window class has no icon, and WM_ICONERASEBKGND if it does. Whatever you do, don't attempt to handle WM_PAINTICON, as that message has gone the way of the Dodo. Nowadays, Windows only sends it for backward compatibility. Once Windows NT gets its UI face-lift, it will no doubt support WM_SETICON too.</P>
<P>To track down these various messages, I used a really useful resource I must tell you about: WIN32API.CSV. This file, which comes in the Visual C++ª LIB directory, is a comma-separated table of the entire Win32 API! You can open it with Microsoft® Excel or any other spreadsheet </P>
<P>or database that can read comma-separated files. WIN32API.CSV comes in handy any time you want a condensed picture of which flavor of Win32 supports which functions and messages. <B>Figure 4</B> shows a portion of this file  in Microsoft Excel. I found out about WIN32API.CSV from a Visual C++ "Tip of the Day." See, it pays to read that stuff!</P>
<P><img src="cqa4.gif"></P>
<P><B> Figure 4  WIN32API.CSV shows the Win32 API.</B></P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I'm having trouble designing my app to fit into the MFC document/view model. I'm writing the server side of a client/server application. The server responds to requests from clients and displays information about the system. I don't really have any notion of a "document" in my app, so I created a doc class that does nothing, just to make MFC happy. But now my entire app is implemented in the view. It works fine, but it seems like there should be a better way.</P>
<P><I>From many readers</I></P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>I hear this question again and again in different forms. There is one simple answer: you don't have to use the document/view model! Just because App Wizard generates a doc class and a view class for you doesn't mean you have to use them. You can move your entire implementation into the frame class if you like. So, for example, CMyView::OnLButtonDown becomes CMainFrame::OnLButtonDown. There are only a few things to worry about. First, instead of OnDraw, you must handle WM_PAINT directly. </P>
<P><BR></P>
<PRE> 
void CMainFrame::OnPaint()
{
   CPaintDC dc;
   // do whatever you would have done
   // in your view::OnDraw, with pDC=&amp;dc
}
</PRE>
<P>You might want to imitate CView and implement an OnDraw function that OnPaint calls, so you can use it for printing too. You may want to add your own CMainFrame::OnPrepareDC also, to fully mimic the way CView does things. </P>
<P>Instead of creating a document template in your application's InitInstance function, you'll have to load the frame directly.</P>
<P><BR></P>
<PRE> 
BOOL CMyApp::InitInstance() 
{
    // Don't create a doc template, just load the frame
    //
    CMainFrame* pMainFrame = new CMainFrame;
    if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
       return FALSE;
    pMainFrame-&gt;ShowWindow(m_nCmdShow);
    pMainFrame-&gt;UpdateWindow();
    m_pMainWnd = pMainFrame;
 }
</PRE>
<P>This is what document/view eventually does anyway, only it gets the resource ID from the doc template. Just don't forget to make your CMainFrame constructor public—App Wizard generates it protected by default.</P>
<P>Take care how you process command-line arguments. By default, App Wizard generates these lines:</P>
<P><BR></P>
<PRE> 
 // (In CYourApp::InitInstance)
 CCommandLineInfo cmdInfo; ParseCommandLine(cmdInfo);
 if (!ProcessShellCommand(cmdInfo)) 
    return FALSE; 
</PRE>
<P>As its name suggests, ProcessShellCommand processes command line arguments. If your app is invoked with a file name from the command-line, MFC calls OpenDocumentFile to open it; otherwise it calls OnFileNew. The default CWinApp implementations for these functions do document/view stuff, and will fail royally if you don't have any templates registered. So you have to either override OnFileNew and OnOpenDocumentFile or—what probably makes more sense—process your own command-line arguments instead of calling ProcessShellCommand. (If you don't have any notion of files, why would you support a filename on the command line?) You can still call ParseCommandLine to parse the command line, but you should process it yourself.</P>
<P>When you paint your window, be aware that the tool and status bars take space away from your client area, so the actual size of your viewport is the client area minus these and any other control bars, if they're displayed. In the document/view model, MFC automatically resizes the view when the user hides or shows control bars. If you implement everything in your frame, there's no child window to resize, so you must make your own provisions for this. For example, if the toolbar is displayed at the top of the window, you can't just go painting at coordinates (0,0), as you would for a view, or you'll paint right over the toolbar. If this is too much of a headache to deal with, the simplest thing to do is implement your "view" as a child window. Just derive from CWnd instead of CView.</P>
<P><BR></P>
<PRE> 
class CMyWnd : public CWnd {
·
·
·

};
</PRE>
<P>Then include an instance in your main frame and create it as a child when the main frame is created (see <B>Figure 5</B>).</P>
<P><B> Figure 5  Creating a Child Window "View"</B></P>
<P><BR></P>
<PRE> class CMainFrame : public CFrameWnd {
    CMyWnd m_myWnd;   // where all the action is
·
·
·

}; 

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
       return -1;

     if (!m_myWnd.Create(...AFX_IDW_PANE_FIRST...)) {
       TRACE("Failed to create child window\n");
       return -1;      // fail to create
    }
·
·
·

    return 0;
 }

</PRE>
<P>Make sure to use AFX_IDW_PANE_FIRST as the child ID because then CFrameWnd will automatically resize your child window properly. If you go the child window route, the only other thing you need to do is hook the child window up to the message-routing mechanism so it can handle commands through message maps.</P>
<P><BR></P>
<PRE> 
BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode,
        void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo)
 {
    if (m_myWnd.OnCmdMsg(nID,nCode, pExtra,             
                         pHandlerInfo))
       return TRUE;   // handled by child window

     return CFrameWnd::OnCmdMsg(nID, nCode, pExtra,
                                pHandlerInfo);
 }
</PRE>
<P>For more information on message routing, see my article, "Meandering Through the Maze of MFC Message and Command Routing," in the July 1995 issue of MSJ. For an example of a program that uses this technique, see the TRACEWIN program described in my October 1995 column.</P>
<P>If this still isn't what you want—if you need CScrollView or CFormView—you could try deriving your child window from one of these view classes so that it would in fact be a view. Then you'd call CFrameWnd::SetActiveView to make it the active view, in which case there'd be no need to route commands with OnCmdMsg since MFC automatically routes commands to the active view. Personally, I have never tried this—manually creating a view without a document—so I don't know if it will work. The only question is how many places MFC expects the view to have a bona fide document. If this fails, then you're right back where you started: implementing a "dummy" document to satisfy the framework. So, what's wrong with that? Nothing.</P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I'm trying to trap keyboard messages sent to the edit control within a CComboBox. Specifically, I want to trap WM_CHAR messages, but these don't seem to get sent to the CComboBox. The context in which I am using this is to trap the TAB key to move to the next control in my window. I don't get this for free, because the parent window is my own window class, not a dialog box. I've managed to get this working with edit controls, regular combo boxes, lists, and buttons, but not in combo boxes with edit controls.</P>
<P>This seems like a reasonable function to want, but I have tried several approaches without success. If you have any suggestions I would greatly appreciate it.</P>
<P><I>Brett Morrison</I></P>
<P>Scopus Technology, Inc.</P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>First of all, if all you want to do is trap the TAB key to do NEXT and PREVIOUS in a home-grown dialog (that is, a window that contains several child controls but is not actually a dialog), there's no need to go to the extreme of trapping TAB with WM_CHAR in every kind of control. A simpler approach is to implement it at the frame level using a command, ID_NEXT_CONTROL, that moves the focus to the next control, and bind it to TAB with an accelerator. Presumably, you'll also have ID_PREV_CONTROL bound to Shift-TAB.</P>
<P>That aside, your question is still valid; there are times when it's desirable to trap keyboard input to the edit control in a combo box. For example, you might want to disallow certain characters. In general, you might want to subclass the edit control just like any other edit control—say to play Beethoven's Fifth Symphony if the user double-clicks the mouse and the control contains "Da-da-da-Dum." So, the question remains: how?</P>
<P>Fortunately, it's pretty easy. All you have to do is know the child window ID of the edit control inside the combo box, which you can find using your favorite spy tool. As it turns out, the ID is 1001. While this is officially undocumented and therefore theoretically subject to change, it's highly unlikely Microsoft would ever do so. </P>
<P>Armed with this insider information, you can subclass the edit control like you would any other dialog control, remembering that the edit control is a child of the combo box, not the dialog. I wrote a little program, COMBOED, that does it (see <B>Figure 6</B>). COMBOED displays the dialog in <B>Figure 7</B>. The combo box lets you enter numbers, +, -, and e (for exponent), but if you type any other characters, it beeps at you. To implement COMBOED, I derived two new classes: CComboNumber and CEditNumber. The place where the edit control gets subclassed is in CComboNumber::SubclassDlgItem. </P>
<P><BR></P>
<PRE> 
// ID of edit control
#define ID_COMBOEDIT 1001 

BOOL CComboNumber::SubclassDlgItem(UINT nID, 
                                   CWnd* pParent)
{
   return CComboBox::SubclassDlgItem(nID, pParent) &amp;&amp;
          m_edit.SubclassDlgItem(ID_COMBOEDIT, this);
}</PRE>
<P><B> Figure 6  COMBOED</B></P>
<P><BR></P>
<PRE> 
COMBOED.RC
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""res\\app.rc2""  // non-App Studio edited resources\r\n"
    "\r\n"
    "#include ""afxres.rc""  \t// Standard components\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON    DISCARDABLE     "RES\\APP.ICO"

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_DIALOG1 DIALOG DISCARDABLE  0, 0, 198, 122
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "COMBOED"
FONT 8, "MS Sans Serif"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,13,9,18,20
    LTEXT           "The following combo box has a subclassed edit control that restricts typing to numbers.",
                    IDC_STATIC,41,9,140,20
    LTEXT           "Enter a number, or select one from the drop-down list.",
                    IDC_STATIC,13,32,167,12
    COMBOBOX        IDC_COMBO1,13,50,109,68,CBS_DROPDOWN | WS_VSCROLL | 
                    WS_TABSTOP
    DEFPUSHBUTTON   "&amp;Do it",IDOK,139,50,42,14
    PUSHBUTTON      "&amp;Syonara",IDCANCEL,139,77,42,14
END


/////////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO DISCARDABLE 
BEGIN
    IDD_DIALOG1, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 191
        TOPMARGIN, 7
        BOTTOMMARGIN, 115
    END
END
#endif    // APSTUDIO_INVOKED

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "res\app.rc2"  // non-App Studio edited resources

#include "afxres.rc"      // Standard components

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED

RESOURCE.H
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Comboed.rc
//
#define IDR_MAINFRAME                   2
#define IDD_ABOUTBOX                    100
#define IDD_DIALOG1                     102
#define IDC_COMBO1                      1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

COMBOED.CPP
////////////////////////////////////////////////////////////////
// COMBOED Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// COMBOED illustrates how to subclass the edit control within a
// combo box.

#include "stdafx.h"
#include "resource.h"

//////////////////
// Normal MFC app class
//
class CMyApp : public CWinApp {
public:
   virtual BOOL InitInstance();
};

//////////////////
// Edit control that only lets user type numbers
//
class CEditNumber : public CEdit {
public:
   afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
   DECLARE_MESSAGE_MAP()
};

//////////////////
// Combo box that only lets users type numbers.
//
class CComboNumber : public CComboBox {
   CEditNumber m_edit;  // subclassed edit control
public:
   BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
};

//////////////////
// Dialog that lets the user enter a number using CComboNumber
//
class CNumberDlg : public CDialog {
protected:
   CComboNumber m_combo;   // the combo box
   double       m_number;  // the number entered
   virtual BOOL OnInitDialog();
   virtual void DoDataExchange(CDataExchange* pDX);
   virtual void OnOK();    // override
public:
   CNumberDlg(CWnd* pParent = NULL);
   ~CNumberDlg();
};

////////////////////////////////////////////////////////////////
// CMyApp

CMyApp NEAR theApp;

BOOL CMyApp::InitInstance()
{
   CNumberDlg().DoModal(); // run dialog
   return FALSE;           // quit app when dialog is over
}

////////////////////////////////////////////////////////////////
// CNumberDlg

CNumberDlg::CNumberDlg(CWnd* pParent) : CDialog(IDD_DIALOG1, pParent)
{
}

CNumberDlg::~CNumberDlg()
{
}

/////////////////
// When dialog is initialized, subclass the combo box
//
BOOL CNumberDlg::OnInitDialog()
{
   if (!m_combo.SubclassDlgItem(IDC_COMBO1, this))
      return FALSE;

   LPCSTR SomeNumbers[] = { 
      "3.141592654",
      "2.718281828459045",
      "1.414213562",
      "6.0221367e23",
      "0.5772156649",
      NULL
   };

   m_combo.ResetContent();
   for (int i=0; SomeNumbers[i]; i++)
      m_combo.AddString(SomeNumbers[i]);

   return TRUE;
}

//////////////////
// Standard AppWiz DDX
//
void CNumberDlg::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   DDX_Text(pDX, IDC_COMBO1, m_number);
}

//////////////////
// Override OK to display the number and keep running 
// instead of doing EndDialog.
//
void CNumberDlg::OnOK()
{
   UpdateData(TRUE);       // get user data 
   char temp[128];
   sprintf(temp,"m_number = %1.10e", m_number);
   MessageBox(temp,"CNumberDlg",MB_OK);
}

////////////////////////////////////////////////////////////////
// CComboNumber

//////////////////
// Subclass the combo box. The combo box also subclasses its own edit 
// control, which is the control with id 1001. This is technically 
// undocumented, but it ain't gonna change any time soon, I guarantee.
//
#define ID_COMBOEDIT 1001
BOOL CComboNumber::SubclassDlgItem(UINT nID, CWnd* pParent)
{
   return CComboBox::SubclassDlgItem(nID, pParent) &amp;&amp;
      m_edit.SubclassDlgItem(ID_COMBOEDIT, this);
}

////////////////////////////////////////////////////////////////
// CEditNumber

BEGIN_MESSAGE_MAP(CEditNumber, CEdit)
   ON_WM_CHAR()
END_MESSAGE_MAP()

//////////////////
// Handle WM_CHAR: Only allow digits, e (exponent), +/ and backspace.
// Anything else beeps.
//
void CEditNumber::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
   if (!strchr("0123456789e.+-", nChar)) {
      MessageBeep(0);
      return;  
   }
   CEdit::OnChar(nChar, nRepCnt, nFlags);
}</PRE>
<P><img src="cqa7.gif"></P>
<P><B> Figure 7  The COMBOED dialog.</B></P>
<P></P>
<P>This override (note that SubclassDlgItem is NOT virtual) for CComboNumber first subclasses itself the normal way by calling the base class CComboBox::SubclassDlgItem. Then, assuming this succeeds, subclasses the edit control to its m_edit member, a CEditNumber. CEditNumber handles WM_CHAR in the usual manner to restrict user input.</P>
<P>You can use this technique to subclass any control within a compound control—all you need to know is the ID. Generally, it will be some fixed value like 1001, but if you want to be really safe, you can always search all the child windows looking for a control whose class is "Edit" (or "Button" or whatever), and then use whatever ID you find.</P>

<TABLE COLS="3" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="220pt" VALIGN="TOP"><COL WIDTH="0pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P> Have a question about programming in C or C++?  You can mail it directly to C/C++ Q&amp;A, Microsoft Systems Journal, 825 Eighth Avenue, 18th, New York, New York 10019, or send it to <I>MSJ </I>(re: C/C++ Q&amp;A) via:</P></TD></TR><TR><TD VALIGN="TOP"><P> <BR>Internet:</P>
<P><BR>Internet:</P></TD><TD COLSPAN="2" VALIGN="TOP"><P>Paul DiLascia<BR>72400.2702@compuserve.com<BR>Eric Maffei<BR>ericm@microsoft.com</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P></font></body></HTML>
