<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The DAO of Databases: Using Data Access Objects and the Jet Engine in C++</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  The DAO of Databases: Using Data Access Objects and the Jet Engine in C++</H1><P>Michael Mee, Peter Tucker, and John McCullough</P>
<P>Michael Mee is the program manager for DAO at Microsoft. Peter Tucker is the test lead for DAO and John McCullough wrote much of the code that comprises the DAO SDK.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4563">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the DAOSAMP project files.</A></P><P>The growing success of Microsoft® Access has made its MDB file format a standard way to store and manipulate data on the desktop. More and more institutions are building database apps based on Microsoft Access, and increasing numbers of programmers are using Microsoft Access, Visual Basic®, and even Microsoft Excel to write custom MDB-based apps. But C/C++ programmers have been left out in the cold. The only way to access MDB files from C/C++ is to use the ODBC driver for the Jet engine, and using ODBC to access the Jet engine is a little like trying to suck cake through a straw. ODBC is geared more for SQL-based client/server type databases; it doesn't expose the ISAM operations fundamental to Jet operation, such as Set Index and Seek. Ironically, when it comes to writing MDB apps, Microsoft Access 95, Visual Basic 4.0, and Microsoft Excel 95 offer more programming ease and power than C++. Until now, that is. Starting in version 4.0, Visual C++ ships with an OLE automation server called DAO that gives C/C++ programmers full access to the Microsoft Jet engine. </P>
<P>In this article we introduce you to the features that DAO provides and demonstrate their use in the sample app that ships with the DAO SDK. We assume you're familiar with databases (and C++) but haven't necessarily used a Microsoft database product.</P>
<P>DAO (Data Access Objects) is a set of OLE objects that simplifies database programming. There's a Database object to represent—what else—the database, which contains a collection of Tabledef (table definition) objects, each of which in turn contains a collection of Field objects. Each object has properties and methods that expose pertinent functionality. <B>Figure 1</B> shows the object hierarchy.</P>
<P><img src="DAO1.gif"></P>
<P><B> Figure 1  DAO Object Hierarchy</B></P>
<P>DAO uses a set of DLLs called the Jet engine (see <B>Figure 2</B>). Together these DLLs provide access not only to MDB files, but also to other database formats including Xbase formats such as dBase and FoxPro®, the Paradox DB format, spreadsheet data from Microsoft Excel and Lotus 1-2-3, and common text file formats such as fixed-width and comma-separated text. Jet even provides a route to ODBC sources.</P>
<P><img src="DAO2.gif"></P>
<P><B> Figure 2  Overview of DAO and Jet</B></P>
<P>Jet includes a powerful query processor that makes complex operations easy. For example, you can query an MDB table joined to a SQL Server table and update the resulting view. The ability to create stored queries (equivalent to a SQL view) that in turn reference other queries, all of which are still updatable, is quite powerful. It removes much of the application development burden: you can change your app simply by modifying your queries, without editing a single line of code! It's beyond the scope of this article to describe Jet in its entirety, so take a good look at the Microsoft Access documentation. We cannot stress too highly how much coding and design time you will save if you have a solid understanding of database techniques in general and Jet in particular.</P>
<H2><A NAME="sec0"></A>  DAO and OLE Automation</H2><P>Data Access Objects are implemented as OLE automation dual interfaces (see the sidebar, "OLE Automation"). The DAO DLL, DAO3032.DLL, implements an in-process 32-bit OLE automation server that in turn calls the private DLL entry points found in the Jet engine, MSJT3032.DLL. The same DLL supplied with Visual C++ª is used to provide all programmatic access to data in Microsoft Access 95, Visual Basic 4.0, and Microsoft Excel 95. The DAO DLL includes a type library that describes all the interfaces it contains. Both ANSI and Unicode versions of the interfaces are supplied; external support such as MFCANS32.DLL is no longer required. The DAO OLE automation server provides one of the first examples of a complex OLE automation component. Indeed, much of the upgraded OLE automation functionality first found in Windows NT™ 3.51 and now in Windows® 95 was prompted in part by the parallel development of DAO.</P>
<P>The DAO interfaces exposed by the type library are defined in the header file DBDAOINT.H. <B>Figure 3</B> shows a fragment of the top-level DBEngine object definition. DBEngine has five properties: Version, IniPath, DefaultUser, DefaultPassword, and LoginTimeout. IniPath and LoginTimeout can be set as well as retrieved. Four methods are also shown: CompactDatabase, OpenDatabase, CreateWorkspace, and CreateDatabase. The declarations in <B>Figure 3</B> look simple enough; you can probably guess what most of the functions do. But there's a lot of behind-the-scenes plumbing required to use them. For example, since _DAODBEngine is an OLE automation dual interface, you must AddRef and Release it, just like any other OLE interface. And DAO uses OLE BSTRs instead of native C/C++ character pointers or MFC CStrings. (A BSTR is a character string with the length stored in the first DWORD and no /0 at the end.) Furthermore, many parameters are passed as VARIANTs, especially optional ones. Fortunately, MFC 4.0 provides some new classes to help smooth the way.</P>
<P><B> Figure 3  DBDAOINT.H Excerpt</B></P>
<P><BR></P>
<PRE> DECLARE_INTERFACE_(_DAODBEngine, _DAO)
{
  STDMETHOD(get_Version)         (THIS_ BSTR FAR* pbstr) PURE;
  STDMETHOD(get_IniPath)         (THIS_ BSTR FAR* pbstr) PURE;
  STDMETHOD(put_IniPath)         (THIS_ BSTR path) PURE;
  STDMETHOD(put_DefaultUser)     (THIS_ BSTR user) PURE;
  STDMETHOD(put_DefaultPassword) (THIS_ BSTR pw) PURE;
  STDMETHOD(get_LoginTimeout)    (THIS_ short FAR* ps) PURE;
  STDMETHOD(put_LoginTimeout)    (THIS_ short Timeout) PURE;
  STDMETHOD(get_Workspaces)      (THIS_ DAOWorkspaces FAR* FAR* ppworks) PURE;
  STDMETHOD(get_Errors)          (THIS_ DAOErrors FAR* FAR* pperrs) PURE;
  STDMETHOD(CompactDatabase)     (THIS_ BSTR SrcName, BSTR DstName,
     VARIANT DstConnect, VARIANT Options, VARIANT SrcConnect) PURE;
  STDMETHOD(CreateWorkspace)     (THIS_ BSTR Name, BSTR UserName, 
     BSTR Password, DAOWorkspace FAR* FAR* ppwrk) PURE;
  STDMETHOD(OpenDatabase)        (THIS_ BSTR Name, VARIANT Exclusive, 
     VARIANT ReadOnly, VARIANT Connect, DAODatabase FAR* FAR* ppdb) PURE;
  STDMETHOD(CreateDatabase)      (THIS_ BSTR Name, BSTR Connect, 
     VARIANT Option, DAODatabase FAR* FAR* ppdb) PURE;
};</PRE>
<P></P>
<H2><A NAME="sec1"></A>  Programming DAO in C++</H2><P>There are three ways you can program DAO from C++:</P>
<UL><LI>    Invoke the OLE automation dual interfaces directly</LI><LI>   Use the MFC CDao classes</LI><LI>   Use the DAO SDK classes</LI></UL><P>Naturally, each of these methods has advantages and disadvantages. Since programming directly through automation is fairly tedious, most people opt for either the MFC or DAO SDK classes. The MFC classes (CDaoXxx) are designed to have the same look and feel as the MFC ODBC classes (CDatabase), with some notable improvements such as the ability to specify field names at run time. If you're already familiar with CDatabase, CRecordset and the rest, the MFC DAO classes may be the quickest way to climb the DAO learning curve, since they're similar in name and operation to the ODBC classes.</P>
<P>If you're already using CDatabase and CRecordset to access MDB files or some other ISAM format, it's a simple exercise to convert your code to CDaoDatabase, CDaoRecordset, and so on. Your code will run faster and—with a little extra work—you can take advantage of new features like the ability to bind field names at run time, which has long been an annoying deficiency in the MFC ODBC classes.</P>
<P>Another set of classes, often referred to as the DAO SDK classes, comes with the DAO SDK, which ships with Visual C++ 4.0—though you must install it manually by running the SETUP program in the DAOSDK directory on your CD-ROM. The DAO SDK classes expose even more Jet functionality, and are designed to make programming DAO from C++ just like programming it from Basic. In particular, the DAO SDK classes make heavy use of C++ operator overloading (in violation of MFC's approach). More important, the DAO SDK classes map directly to the underlying automation objects.</P>
<P>The singular DAO SDK names represent  single objects; the plural form is the corresponding collection. Thus, for example, CdbError represents a single error; whereas CdbErrors is the total collection of errors, in case there are many. You also get support classes like CdbBookmark, CdbLastOLEError, and CdbException, which don't map directly to any OLE object, but which make programming easier. As you can see, the DAO SDK offers many more classes than MFC. That's because DAO exposes areas of functionality such as security and complex table definition as well as Jet features like user-defined properties. (Jet lets you create your own properties for most of its objects.)</P>
<P>Freed from the backward compatibility constraints that the MFC classes face, the DAO SDK classes expose all the functionality provided by DAO. They have a distinctly different style, though, one that may seem unfamiliar if not strange to MFC programmers. For example, to retrieve property values with MFC, you call GetXxxInfo to fill a struct with information about an object, then examine the particular property you want. To retrieve the names of queries, you'd write:</P>
<P> </P>
<P><BR></P>
<PRE> // With MFC, you get all the properties (info)<BR>// at once, then look at the one you want.<BR>CDaoQueryDefInfo queryinfo;<BR>int nQueries = pDB-&gt;GetQueryDefCount( );<BR>for ( int i = 0; i &lt; nQueries; i++ ) {<BR>    GetQueryDefInfo( i, queryinfo );<BR>    printf("query name is: %s\n", queryinfo.m_strName);<BR>}</PRE>
<P> </P>
<P>Using DAO SDK classes, it would go like this:</P>
<P> </P>
<P><BR></P>
<PRE> // With the DAO SDK classes, you retrieve<BR>// individual properties one at a time<BR>CdbDatabase DB;<BR>for (long i = 0; i &lt; DB.Querydefs.getCount(); i++)<BR>  printf("query name is: %s\n",<BR>         DB.Querydefs[i].GetName());</PRE>
<P> </P>
<P>Which classes you use is up to you. You can even mix classes within a single app. You might use the MFC classes for routine forms and viewing, saving the DAO SDK classes for more specialized features like user-defined properties. Except where DAO is required for advanced features, the choice is more a matter of personal taste and experience than any technical merit, although in general the DAO SDK classes are more efficient since they map directly to the underlying objects and methods; whereas a single MFC call might translate into many DAO interface calls. For example, while the GetQueryDefInfo call in the above example may look better because you get all the properties at once, internally GetQueryDefInfo must get each property one-by-one, which is a waste if all you want is the name. (To be fair, MFC provides an optional flag you can set to retrieve partial information such as the query name only—but that's a little hokey.)</P>
<P>In this article, we'll focus on the DAO SDK classes, since they're more interesting and probably less familiar to you. But many of the concepts presented apply regardless of which classes you choose for your app. <B>Figure 4</B> shows the relationship among the MFC ODBC, MFC DAO, and DAO SDK classes.</P>
<P><img src="DAO4.gif"></P>
<P><B> Figure 4  How Classes Use Jet</B></P>
<H2><A NAME="sec2"></A>  Hello Data</H2><P>It seems that every database tool in the universe has an employee application, and DAO is no exception. The DAO SDK comes with a sample EMPLOYEE app that lets you add, modify, and delete rows in a single table in an MDB database. <B>Figure 5</B> shows EMPLOYEE in action. The full source code lives in \msdev\daosdk\samples\employee, created when you install the DAO SDK. EMPLOYEE is an MFC SDI app that uses the DAO SDK classes, though it could easily have been written using the MFC classes. EMPLOYEE uses MFC's CFormView and the DDX (Dialog Data Exchange) mechanism to implement a form-based view of employee records. It also uses two classes that are new in MFC 4.0: COleDateTime, which formats the date, and COleVariant, which handles OLE automation VARIANT data types (see sidebar).</P>
<P><img src="DAO5.gif"></P>
<P><B> Figure 5  EMPLOYEE</B></P>
<P>The standard user interface model for MFC apps is the document/view model. You open a document (file), then view it. Unfortunately, this model doesn't always fit database applications that well. Usually, there's no identifiable document, but rather a collection of records culled from some collection of tables that may span several physical files—or none at all, in the case of talking to a remote server process. In database apps, the recordset plays the role of document. For some apps, it may be expedient to dispense with doc/view and simply embed the recordset directly in the frame window—but then you lose the ability to maintain multiple views of the same data.</P>
<P>MFC provides a convenient solution in the form of CRecordView and CDaoRecordView, which let you create views directly connected to an ODBC or DAO recordset. AppWizard even knows how to generate such apps. These classes integrate database operations into the MFC user interface framework. Unfortunately, the one thing lacking in the DAO SDK classes is tight integration with MFC. In particular, there's no DAO SDK equivalent to CDaoRecordView.</P>
<P>Instead, EMPLOYEE implements a document class CDAOEMPDoc (see <B>Figure 6</B>), which is really no more than a place to hold the database connection and recordset. As mentioned earlier, one of the advantages of using a document (instead of embedding the recordset directly in the frame) is that it makes writing multiple-view apps easier. Whenever a record is modified, all you have to do is call CDocument::UpdateAllViews and MFC will automatically repaint all the affected views.</P>
<P><B> Figure 6  CDAOEMPDoc</B></P>
<P><BR></P>
<PRE> class CDAOEMPDoc : public COleDocument {
protected:
   CDAOEMPDoc();
   DECLARE_DYNCREATE(CDAOEMPDoc)

   CdbDBEngine    m_cDBEngine;
   CdbDatabase    m_cEmpDatabase;
   CdbBookmark    m_cLastGoodRecord;

public:
   CdbRecordset   m_cEmpRecordSet;
   BOOL           m_bConnected;
   BOOL ConnectToDatabase(); //Opens a database 

   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CDAOEMPDoc)
   public:
   virtual BOOL OnNewDocument();
   //}}AFX_VIRTUAL

public:
   virtual ~CDAOEMPDoc();
   virtual void Serialize(CArchive&amp; ar);   // overridden for document i/o
   BOOL OKToMove();

   void UpdateEmpRec(long m_nEmpNum, LPCTSTR lpszFirstName, 
                     LPCTSTR lpszHomePhone, LPCTSTR lpszLastName, 
                     LPCTSTR lpszNotes, DATE HireDate);

protected:
   //{{AFX_MSG(CDAOEMPDoc)
   afx_msg void OnEditNext();
   afx_msg void OnEditPrevious();
   afx_msg void OnEditAdd();
   afx_msg void OnEditDelete();
   afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};</PRE>
<P></P>
<P> </P>
<H2><A NAME="sec3"></A>  Opening the Database</H2><P>When EMPLOYEE starts up, the first thing it does is create a new document, just like a normal MFC SDI app. The similarity ends there. OnNewDocument calls a helper function called CDAOEMPDoc::ConnectToDatabase to open the database (see <B>Figure 7</B>). The first thing ConnectToDatabase does is display a File Open common dialog to get the database file name from the user. Once ConnectToDatabase has the file name, it opens the database.</P>
<P> </P>
<P><BR></P>
<PRE> m_cEmpDatabase =<BR>     m_cDBEngine.Workspaces[0L].OpenDatabase(lpstrFile);</PRE>
<P> </P>
<P><B> Figure 7  CDAOEMPDoc::ConnectToDatabase</B></P>
<P><BR></P>
<PRE> //////////////////
// Create new document
//
BOOL CDAOEMPDoc::OnNewDocument()
{
   if (!COleDocument::OnNewDocument())
      return FALSE;
   
   if (!ConnectToDatabase()) {
      m_bConnected = FALSE;
      return FALSE;
   }
   m_bConnected = TRUE;
   return TRUE;
}

////////////////
// When the document is created, connect to the database and open the
// Employee recordset.
//
BOOL CDAOEMPDoc::ConnectToDatabase()
{
   // Ask the user for the name of the EMPLOYEE database
   CFileDialog cOpenFile( TRUE,
                    _T("MDB"), 
                    _T("employee.mdb"), OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, 
                    (_T("Access Files (*.mdb) | *.mdb ||")));

   // Get the location of the database (assume it's the Employee example)
   cOpenFile.DoModal();

   //Open the database and the recordset
   try {
      // NOTE: Using default collection rather than Workspaces.Items
      m_cEmpDatabase = m_cDBEngine.OpenDatabase(cOpenFile.m_ofn.lpstrFile);
      m_cEmpRecordSet = m_cEmpDatabase.OpenRecordset(_T("Employees"), dbOpenTable);

   } catch (CdbException e) {
      CdbLastOLEError exError;
      TCHAR szBuf[256];

      wsprintf(szBuf, _T("Error %d : %s\n"), DBERR(e.m_hr), 
               (LPCTSTR) exError.GetDescription());
      AfxMessageBox(szBuf);
      return (FALSE);
   }
   return TRUE;;
}</PRE>
<P>Because the DAO SDK classes all have default collections defined, you can often omit explicit references to collection members. The following lines would accomplish the same thing with less typing.</P>
<P> </P>
<P><BR></P>
<PRE> m_cEmpDatabase = <BR>               m_cDBEngine[0L].OpenDatabase(lpstrFile);</PRE>
<P> </P>
<P>In other words, Workspaces is the default collection for CdbDBEngine. In C++ terms, CdbDBEngine.operator invokes CdbDBEngine.Workspaces(0).operator. Those of you familiar with DAO will recognize the following as also valid:</P>
<P> </P>
<P><BR></P>
<PRE> m_cEmpDatabase = m_cDBEngine.OpenDatabase(lpstrFile);</PRE>
<P> </P>
<P>OpenDatabase accepts optional parameters for an ODBC connection, read-only and exclusive flags, but EMPLOYEE doesn't use these.</P>
<P>Since the Employee database has only one table (the Employee table), CDAOEMPDoc opens the recordset at the same time as the database and leaves it open for the lifetime of the document.</P>
<P> </P>
<P><BR></P>
<PRE> m_cEmpRecordSet =<BR>  m_cEmpDatabase.OpenRecordset(_T("Employees"),<BR>                               dbOpenTable);</PRE>
<P> </P>
<P>The most efficient way to open any recordset is as a table-type recordset (described later), so EMPLOYEE explicitly requests that type. This is not strictly necessary, since DAO would have chosen dbOpenTable by default as the most efficient form available.</P>
<H2><A NAME="sec4"></A>  To Err is Human</H2><P>What happens if something goes wrong in OpenDatabase or OpenRecordset? The DAO SDK classes use C++ exceptions to signal errors. It's your responsibility to handle them using standard C++ try/catch blocks. <B>Figure 7</B> shows the gory details. You can see CdbException and CdbLastOLEError in action. To keep overhead as low as possible, CdbException contains only the HRESULT that triggered the error. HRESULTs are an OLE phenomenon: a LONG composed of several bit fields, one of which contains the DAO error number. You can use the DBERR macro to extract it. CdbLastOLEError retrieves the last system OLE error that was pushed. One of its more useful member functions is GetDescription, which returns a text description of the error. EMPLOYEE isn't too bright when it comes to handling errors: ConnectToDatabase displays a message, OnNewDocument returns FALSE, and the application terminates. In real life, you'd do something more friendly.</P>
<P>You can also retrieve error information from DAO's Errors collection. The error-handling code in <B>Figure 7</B> could be rewritten as</P>
<P> </P>
<P><BR></P>
<PRE> wsprintf(szBuf, _T("Error %d : %s\n"),<BR>         m_cDBEngine.Errors[0].GetNumber(), <BR>     (LPCTSTR) m_cDBEngine.Errors[0].GetDescription());</PRE>
<P> </P>
<P>Usually, there's just one error, but sometimes there are more because multiple errors occur trying to execute a complex operation. This often happens with ODBC data sources. In the event of multiple errors, DAO pushes the most general error (such as "operation failed") as the OLE error, and stores the full list in the Errors collection, which you must analyze to determine what went wrong. DBDAOERR.H defines symbols you can use to test for specific conditions.</P>
<P> </P>
<P><BR></P>
<PRE> if (e.m_hr == E_DAO_DatabaseNotFound)<BR>  // try again</PRE>
<P> </P>
<P>The E_DAO_Xxx symbols are #defined as HRESULTs so you can use them if you're programming directly to the DAO OLE automation interfaces. The #define statements use the same DAO error numbers that Basic users see.</P>
<P> </P>
<P><BR></P>
<PRE> #define E_DAO_DatabaseNotFound DBDAOERR(3004)</PRE>
<P> </P>
<P>This makes debugging easier if you're prototyping in Basic. If you'd rather work directly with DAO error numbers instead of #define symbols, you can always use DBERR to extract the error number—but experienced C++ programmers will probably laugh at your code:</P>
<P> </P>
<P><BR></P>
<PRE> if (DBERR(e.m_hr) == 3004) {   // DB not found<BR>  // try again...<BR>}</PRE>
<P> </P>
<H2><A NAME="sec5"></A>  Displaying a Form</H2><P>To display records, EMPLOYEE uses a CFormView-derived view with members for each Employee table field.</P>
<P> </P>
<P><BR></P>
<PRE> class CDAOEMPView : public CFormView {<BR>  long         m_nEmpNum;<BR>  CString      m_strFirstName;<BR>  CString      m_strHomePhone;<BR>  CString      m_strLastName;<BR>  CString      m_strNotes;<BR>  COleDateTime m_HireDate;<BR>
           .
           .
           .
};</PRE>
<P> </P>
<P>These members are mapped via the standard MFC DDX mechanism to the actual table fields. But DDX requires that the data be in MFC-native formats such as long, CString, and COleDateTime. Since DAO retrieves field values as VARIANTs (see sidebar), the view must convert them to MFC types before invoking DDX, when the view is first created, and whenever the user navigates to a new record. This is pretty straightforward, if cumbersome. A couple of macros and a helper function ease the chore.</P>
<P> </P>
<P><BR></P>
<PRE> // Convert a variant to a string<BR>// (only if it's a string variant)<BR>inline void VarToCStr(CString *c, COleVariant *v)<BR>{<BR>  if(v-&gt;vt==VT_BSTR)<BR>    *c = (LPCTSTR)v-&gt;bstrVal;<BR>  else<BR>    *c = _T("");<BR>}</PRE>
<P> </P>
<P><BR></P>
<PRE> #define VTOLONG(v) \<BR>  ((v).vt==VT_I4 ? (LONG)(v).iVal:0L)<BR>#define VTODATE(v) \<BR>  ((v).vt==VT_DATE ? (CTime)(v).iVal:0L)</PRE>
<P> </P>
<P>Don't be tempted to blindly copy from the bstrVal tag of the variant union! It's perfectly legal for a string field to have a variant type of VT_NULL, assuming the underlying database column allows null values, as most do. </P>
<P>When the view gets an update message, it copies the new record data into its members (see <B>Figure 8</B>). The view uses the new MFC 4.0 COleDateTime class to convert the OLE variant to a date—that's one of the neat new features of MFC 4.0. The table fields are referenced through the #define symbols EMP_LAST_NAME, EMP_HIRE_DATE, and so on. These can be numeric indexes or the text name of the field. For example, EMP_HIRE_DATE could be #defined as 5 or as "HireDate." In general, most DAO collection members can be referenced by name or number. Numbers are of course marginally faster, but strings are less errorprone and easier to maintain, so EMPLOYEE uses them. The names must be Unicode or ANSI strings, as defined by your project settings. If you're building a Unicode app, use Unicode strings; if it's an ANSI app, use ANSI strings. The Windows _T macro makes your strings Unicode/ANSI-independent.</P>
<P><B> Figure 8  CDAOEMPView::OnUpdate</B></P>
<P><BR></P>
<PRE> void CDAOEMPView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
   CDAOEMPDoc* pDoc = GetDocument();
   ASSERT_VALID(pDoc);

   try {
              // Employee number/ID
      m_nEmpNum = 
         VTOLONG(pDoc-&gt;m_cEmpRecordSet.Fields[EMP_EMPLOYEE_ID].GetValue());
      
      // Convert the variant strings into CStrings
      VarToCStr(&amp;m_strFirstName, 
                &amp;pDoc-&gt;m_cEmpRecordSet.Fields[EMP_FIRST_NAME].GetValue());
      VarToCStr(&amp;m_strHomePhone, 
                &amp;pDoc-&gt;m_cEmpRecordSet.Fields[EMP_HOME_PHONE].GetValue());
      VarToCStr(&amp;m_strLastName,  
                &amp;pDoc-&gt;m_cEmpRecordSet.Fields[EMP_LAST_NAME].GetValue());
      VarToCStr(&amp;m_strNotes,     
                &amp;pDoc-&gt;m_cEmpRecordSet.Fields[EMP_NOTES].GetValue());

      // Hire date is a COleDateTime 
      m_HireDate = pDoc-&gt;m_cEmpRecordSet.Fields[EMP_HIRE_DATE].GetValue();

   } catch (CdbException e) {
      CdbLastOLEError exError;
      TCHAR szBuf[256];

      wsprintf(szBuf, _T("Error %d : %s\n"), 
               DBERR(e.m_hr), (LPCTSTR) exError.GetDescription());
      AfxMessageBox(szBuf);
   }
   UpdateData(FALSE);   // Invoke DDX (copy member data to form controls)
   Invalidate();        // Tell Windows to repaint
}</PRE>
<P></P>
<P>When the user presses the Next or Previous buttons, the document gets the command.</P>
<P> </P>
<P><BR></P>
<PRE> void CDAOEMPDoc::OnEditNext() <BR>{<BR>  if(!OKToMove())<BR>    return;<BR>  m_cEmpRecordSet.MoveNext();<BR>  if(m_cEmpRecordSet.GetEOF()) {<BR>    MessageBeep(0);<BR>    m_cEmpRecordSet.MovePrevious();<BR>  } else<BR>    UpdateAllViews(NULL);<BR>}</PRE>
<P> </P>
<P>CDAOEMPDoc first checks to see if the current record is dirty—that is, needs updating. Assuming it's OK to move, CdbRecordset::MoveNext does the work. CDAOEMPDoc checks the EOF property to see if an attempt was made to move past the last record. A more elegant implementation would gray the Next command button when there are no more records, but it's not always easy to determine when the last record is reached (for example, when moving through a forward-only recordset as described later).</P>
<P> </P>
<H2><A NAME="sec6"></A>  Updating Records</H2><P>If the current record is dirty, EMPLOYEE asks the user to confirm the update—and now I'm talking about updating the data records, not updating the screen as CDAOEMPView::OnUpdate does. If the user confirms, CDAOEMPView calls CDAOEMPDoc::UpdateEmpRec to update the recordset (see <B>Figure 9</B>). Since DAO doesn't support the MFC field exchange mechanism, you have to update the fields manually. Don't worry, it's no big deal. Most of the work is wrapping the C++ objects back into COleVariants for DAO.</P>
<P><B> Figure 9  CDAOEMPDoc::UpdateEmpRec</B></P>
<P><BR></P>
<PRE> ////////////////
// Update the current record
//
void CDAOEMPDoc::UpdateEmpRec(long m_nEmpNum, LPCTSTR lpszFirstName, 
                              LPCTSTR lpszHomePhone, LPCTSTR lpszLastName, 
                              LPCTSTR lpszNotes, DATE HireDate)
{
   // Convert the date to a dbVariant
   COleVariant cdbHireDate;
   cdbHireDate.date = HireDate;
   cdbHireDate.vt = VT_DATE;

   try {
      // The recordset must be in edit mode
      if(m_cEmpRecordSet.GetEditMode() == dbEditNone)
         m_cEmpRecordSet.Edit();

      m_cEmpRecordSet.SetField(EMP_FIRST_NAME, 
                               COleVariant(lpszFirstName, VT_BSTRT));
      m_cEmpRecordSet.SetField(EMP_HOME_PHONE, 
                               COleVariant(lpszHomePhone, VT_BSTRT));
      m_cEmpRecordSet.SetField(EMP_LAST_NAME, 
                               COleVariant(lpszLastName, VT_BSTRT));
      m_cEmpRecordSet.SetField(EMP_NOTES, 
                               COleVariant(lpszNotes, VT_BSTRT));
      m_cEmpRecordSet.SetField(EMP_HIRE_DATE, cdbHireDate);

      // Commit the changes
      m_cEmpRecordSet.Update();

      // Return to the edited record
      CdbBookmark cBookmark = m_cEmpRecordSet.GetLastModified();
      m_cEmpRecordSet.SetBookmark(cBookmark);

   } catch (CdbException e) {
      CdbLastOLEError exError;
      TCHAR szBuf[256];

      wsprintf(szBuf, _T("Error 0x%lx : %s\n"), e.m_hr, 
               (LPCTSTR)exError.GetDescription());
      AfxMessageBox(szBuf);
   }
}</PRE>
<P></P>
<P>To perform an update, the recordset must be in either Add or Edit mode, so UpdateEmpRec puts the recordset in Edit mode if it hasn't been previously set by Add. There's only one bit of subterfuge that requires explanation. UpdateEmpRec concludes by creating a bookmark to the last modified record and making that the current record.</P>
<P> </P>
<P><BR></P>
<PRE> CdbBookmark cBookmark = <BR>                     m_cEmpRecordSet.GetLastModified();<BR>m_cEmpRecordSet.SetBookmark(cBookmark);
</PRE>
<P>This is necessary because the goal is to end up with the modified record as the current record. In the case of an Edit operation, the bookmark is unnecessary because DAO would leave the edited record as the current record anyway; but in the case of an Add operation, DAO positions the recordset on the record that was current before the new record was added—which is not what you want. In EMPLOYEE, when a new record is added, you want it to remain the current record. Hence the bookmark.</P>
<P> </P>
<H2><A NAME="sec7"></A>  Speeding it Up</H2><P>EMPLOYEE is a typical form-based application where interactive browsing and updating are the normal operations. When coded against an MDB or other ISAM file, EMPLOYEE is fast and efficient. But if the same code is used against an ODBC database, it won't perform as well. Reading and writing files is fast, even over a network, but talking to another process is fundamentally slower and requires special optimizations.</P>
<P>I'll describe three different kinds of recordsets you can use to speed things up: table-type, dynaset, and snapshot recordsets. The sample program DAOREAD (see <B>Figure 10</B>) that comes with the DAO SDK reads data using each of these methods and displays timing statistics. <B>Figure 11</B> shows the function CDAOReadDlg::OnExecute, which does the work.</P>
<P><img src="DAO10.gif"></P>
<P><B> Figure 10  DAOREAD</B></P>
<P><B>Figure 11  DAORDDLG.CPP</B></P>
<P><BR></P>
<PRE> ////////////////
// When the Execute button is pressed, run through the selected methods 
// and perform each, reporting an approximate execution time and listing
// the first field returned (only if it's a string or numeric)
//
void CDAOReadDlg::OnExecute() 
{
       DWORD             dwStart, dwEnd;
       DWORD             dwDuration;
       LONG              lIndex;
       COleVariant       dbVar;
       CListBox          *pList = ((CListBox *)(GetDlgItem(IDC_ROWSLIST)));

       // Update the parameters
       if (!UpdateData(TRUE))
              return;

       // This could take a while, 
       CWaitCursor wait;

       // Clear the list
       pList-&gt;ResetContent();


       // Following is a series of database table retrieves using variations
       // on the Recordset object. This isn't a great programming example,
       // but it shows each method clearly.
       
       // Execute each the requested read methods, recording a time for each
       try {
           // Open the database
           (GetDlgItem(IDC_DATABASENAME))-&gt;GetWindowText(m_strDatabase);
           m_dbDatabase = m_dbEngine.OpenDatabase( m_strDatabase, m_bExclusive,             
                                                   m_bReadOnly, m_strConnect);

           // Run through the selected methods, recording each time
           if (m_bOpenRecordset) {
              // Recordset as a Table
              if (m_bTable) {
                 CdbRecordset RSetTable; 
                 pList-&gt;AddString(_T("Recordset/Table"));
                 pList-&gt;AddString(_T("=========================="));

                 dwStart = timeGetTime();
              
                 // Open recordset on a table
                 try {
                     RSetTable = m_dbDatabase. OpenRecordset(m_strTableQuery, 
                                                             dbOpenTable);
                     } catch(CdbException dbError) {

                     // If the object was not found, assume it was something 
                     // not openable as a "table"
                     //
                     if (dbError.m_hr != E_DAO_ObjectNotFound)
                        throw dbError;
                        }
                        // Check that recordset was created
                        if (RSetTable.Exists()) {
                           // Get requested number of records
                           for (lIndex = 0L;
                                !RSetTable.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows;          
                                lIndex++) {
                                // Get the first returned column
                                dbVar = RSetTable.GetField(0L);
                                AddFieldToList(lIndex, &amp;dbVar);
                                RSetTable.MoveNext();
                                }
       
                           // Report the estimated execute time (in milliseconds)
                           dwEnd = timeGetTime();
                           dwDuration = dwEnd - dwStart;
                           DisplayQueryTime(IDC_TABLETIME, IDC_UNITTABLE,   
                                            dwDuration);
                       } else {
                           (GetDlgItem(IDC_TABLETIME))-         
                                       &gt;SetWindowText(_T("ERROR"));}
                     }

                     // Recordset as a Dynaset
                 if (m_bDynaSet) {
                    CdbRecordset RSetDyna; 
                    pList-&gt;AddString(_T("Recordset/Dynaset"));
                    pList-&gt;AddString(_T("=========================="));

                    dwStart = timeGetTime();
              
                    // Open recordset on as a Dynaset
                    RSetDyna = m_dbDatabase.OpenRecordset(m_strTableQuery, 
                                                          dbOpenDynaset);

                    // Check that recordset was created
                    if (RSetDyna.Exists()) {

                       // Get requested number of records
                       for (lIndex = 0L; 
                            !RSetDyna.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows; lIndex++) {

                            // Get the first returned column
                            dbVar = RSetDyna.GetField(0L);
                            AddFieldToList(lIndex, &amp;dbVar);
                            RSetDyna.MoveNext();
                            }
       
                       // Report the estimated execution time (in milliseconds)
                       dwEnd = timeGetTime();
                       dwDuration = dwEnd - dwStart;
                       DisplayQueryTime(IDC_DYNASETTIME,IDC_UNITDYNA,dwDuration);

                    } else {
                       (GetDlgItem(IDC_DYNASETTIME))-&gt;SetWindowText(_T("ERROR"));
                       }
                 }

                 // Recordset as a Dynaset with caching
                 if (m_bDynaSet &amp;&amp; m_bDynaSetCache) {
                    CdbRecordset       RSetDynaCache; 
                    CdbBookmark              DynaSetBookmark;

                    pList-&gt;AddString(_T("Recordset/Dynaset cached"));
                    pList-&gt;AddString(_T("=========================="));

                    dwStart = timeGetTime();
              
                    // Open recordset on as a Dynaset
                    RSetDynaCache = 
                      m_dbDatabase.OpenRecordset(m_strTableQuery, dbOpenDynaset);
                            
                    // Check that recordset was created
                    if (RSetDynaCache.Exists()) {

                       // Setthecachesizetovaluesuppliedbyuser.
                       RSetDynaCache.SetCacheSize(m_lCacheSize);
                       RSetDynaCache.FillCache(); 
                                   
                       // Get requested number of records
                       for (lIndex = 0L; 
                       !RSetDynaCache.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows; lIndex++) {

                           // Get the first returned column
                           dbVar = RSetDynaCache.GetField(0L);
                           AddFieldToList(lIndex, &amp;dbVar);
                           RSetDynaCache.MoveNext();

                           //Watch for cache run-out
                           if (lIndex % m_lCacheSize) {       
                              DynaSetBookmark = RSetDynaCache.GetBookmark();
                              RSetDynaCache.SetCacheStart(DynaSetBookmark);
                              RSetDynaCache.FillCache(); 
                            }
                        }
       
                        // Report the estimated execute time (in milliseconds)
                        dwEnd = timeGetTime();
                        dwDuration = dwEnd - dwStart;
                        DisplayQueryTime(IDC_CACHETIME,IDC_UNITCACHE,dwDuration);
                    } else {
                        (GetDlgItem(IDC_CACHETIME))-&gt;SetWindowText(_T("ERROR"));
                        }
                     }                     

                     // Recordset as a Snapshot
                     if (m_bSnapshot) {
                        // Bidirectional Snapshot
                        CdbRecordset RSetSnap; 
                        pList-&gt;AddString(_T("Recordset/Snapshot"));
                        pList-&gt;AddString(_T("=========================="));

                        dwStart = timeGetTime();
              
                        // Open recordset on as a Snapshot
                        RSetSnap =
                            m_dbDatabase.OpenRecordset(m_strTableQuery,        
                                                       dbOpenSnapshot);

                        // Check that recordset was created
                        if (RSetSnap.Exists()) {

                           // Get requested number of records
                           for (lIndex = 0L; 
                               !RSetSnap.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows;         
                               lIndex++) {
                               // Get the first returned column
                               dbVar = RSetSnap.GetField(0L);
                               AddFieldToList(lIndex, &amp;dbVar);
                               RSetSnap.MoveNext();
                               }
       
                           // Report the estimated execute time (in milliseconds)
                           dwEnd = timeGetTime();
                           dwDuration = dwEnd - dwStart;
                           DisplayQueryTime(IDC_SNAPSHOTTIME, IDC_UNITSNAP, 
                                            dwDuration);

                        } else {
                             (GetDlgItem(IDC_SNAPSHOTTIME))-           
                                         &gt;SetWindowText(_T("ERROR"));
                             }

                        // Forward Only snapshot
                        CdbRecordset RSetSnapForward; 
                        pList-&gt;AddString(_T("Recordset/Snapshot forward only"));
                        pList-&gt;AddString(_T("=========================="));

                        dwStart = timeGetTime();
              
                        // Open recordset on as a Forward only Snapshot
                        RSetSnapForward =  
                            m_dbDatabase.OpenRecordset(m_strTableQuery, 
                                                  dbOpenSnapshot, dbForwardOnly);

                        // Check that recordset was created
                        if (RSetSnapForward.Exists()) {
                           // Get requested number of records
                           for (lIndex = 0L; 
                                !RSetSnapForward.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows; 
                                lIndex++){

                                // Get the first returned column
                                dbVar = RSetSnapForward.GetField(0L);
                                AddFieldToList(lIndex, &amp;dbVar);
                                RSetSnapForward.MoveNext();
                                }
       
                           // Report the estimated execute time (in milliseconds)
                           dwEnd = timeGetTime();
                           dwDuration = dwEnd - dwStart;
                           DisplayQueryTime(IDC_FORWARDTIME, IDC_UNITSNAPF, 
                                            dwDuration);
                        } else {
                            (GetDlgItem(IDC_FORWARDTIME))-
                            &gt;SetWindowText(_T("ERROR"));
                            }

                        }

                     // Getrows
                     if (m_bGetRows) {
                        CdbRecordset     RSetGetRows; 
                        COleVariant      cRows; // Returned rows (in SafeArray)
                        LONG             lActual;
                      LONG         lGetRowsIndex[2];

                      pList-&gt;AddString(_T("GetRows"));
                      pList-&gt;AddString(_T("=========================="));

                      dwStart = timeGetTime();
              
                      // Open recordset on as a Forward only Snapshot
                      RSetGetRows = m_dbDatabase.OpenRecordset(m_strTableQuery, 
                                                 dbOpenSnapshot, dbForwardOnly);

                      // Check that recordset was created
                      if (RSetGetRows.Exists()) {
                         cRows = RSetGetRows.GetRows(m_lNumRows); 
                                                          // get requested rows
                         // Find out how many records were actually retrieved
                         SafeArrayGetUBound(cRows.parray, 1, &amp;lActual);
                         if (lActual &gt; m_lNumRows)
                            lActual = m_lNumRows;

                         lGetRowsIndex[0] = 0L;

                         for (lGetRowsIndex[1] = 0; 
                             lGetRowsIndex[1] &lt; lActual; lGetRowsIndex[1]++) {
                     
                             // Use OLE safe array function to access fields
                             SafeArrayGetElement(cRows.parray,
                                                 &amp;lGetRowsIndex[0],&amp;dbVar);
                             AddFieldToList(lGetRowsIndex[1], &amp;dbVar);
                             }
       
                         // Report the estimated execute time (in millisecs)
                         dwEnd = timeGetTime();
                         dwDuration = dwEnd - dwStart;
                         DisplayQueryTime(IDC_GETROWSTIME, IDC_UNITGETROWS, 
                                          dwDuration);

                      } else {
                           (GetDlgItem(IDC_GETROWSTIME))-
                                       &gt;SetWindowText(_T("ERROR"));
                            }
                       }                                                 
                   }

              // Disconnect the database

              } catch (CdbException dbError) {
                  CdbLastOLEError exError;
                  TCHAR szBuf[256];

                  wsprintf(szBuf, _T("Error %d : %s\n"), DBERR(dbError.m_hr), 
                           (LPCTSTR) exError.GetDescription());
                  AfxMessageBox(szBuf);
                  }
 }</PRE>
<P></P>
<P>If you know you're dealing with a real table (as opposed to a view or query), you can use a table-type recordset. Just specify dbOpenTable as the second argument to OpenRecordset.</P>
<P> </P>
<P><BR></P>
<PRE> RSetTable = <BR>             m_dbDatabase.OpenRecordset(m_strTableQuery,<BR>                                       dbOpenTable);</PRE>
<P> </P>
<P>You can only open actual tables native to the database. Any of the non-ODBC data formats will support this mode, as long as you open them first as a database and then with dbOpenTable. Trying to open a recordset on names of QueryDefs or attached TableDefs will fail. Data in a table-type recordset is writable as well as readable. To retrieve the data in the recordset, the DAOREAD sample program calls CdbRecordset::GetField and stores the value in a COleVariant. To navigate the records, DAOREAD calls MoveNext and GetEOF to determine when there are no more records to fetch (see <B>Figure 12</B>).</P>
<P><B> Figure 12  Using Table-type Recordsets</B></P>
<P><BR></P>
<PRE> // Open recordset on a table<BR>CdbRecordset RSetTable;
                       .
                       .
                       .
try {<BR>  RSetTable = m_dbDatabase.<BR>    OpenRecordset(m_strTableQuery, dbOpenTable);<BR>} catch(CdbException dbError) {<BR>  // If the object was not found, assume it<BR>  // was something not openable as a "table"<BR>  if(dbError.m_hr != E_DAO_ObjectNotFound)<BR>    throw dbError;<BR>}<BR>// Check that recordset was created<BR>if (RSetTable.Exists()) {<BR>  // Get requested number of records<BR>  for (lIndex = 0L; <BR>    !RSetTable.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows;<BR>    lIndex++) {<BR>    // Get the first returned column<BR>    dbVar = RSetTable.GetField(0L);<BR>    AddFieldToList(lIndex, &amp;dbVar);<BR>    RSetTable.MoveNext();<BR>  }<BR>}</PRE>
<P>So far, this isn't much different from the way EMPLOYEE does it. The next method uses a dynaset-type recordset, which you get by specifying dbOpenDynaset when you open the recordset. You can open a dynaset on base tables, attached tables, QueryDefs, and even row-returning SQL statements. Like table-type recordsets, dynasets are read/write. The only major change to DAOREAD is the use of SetCacheStart and SetCacheSize, which are specific to ODBC. They set up an internal data cache for fast retrieval and cursor movement within a range of records. You give SetCacheStart a bookmark indicating the start of the range; SetCacheSize gets the number of records you want to cache. The cache is created and filled as you navigate the records, so subsequent reads in that range of records are fast. Dynasets are especially useful for reading data into the grid-type controls found in spreadsheets, as well as in other situations where you need to display several records at once. You must explicitly reposition the cache when you move outside its range (see <B>Figure 13</B>).</P>
<P><B> Figure 13  Using Dynaset Recordsets</B></P>
<P><BR></P>
<PRE> // Open recordset on as a Dynaset<BR>CdbRecordset RSetDyna;
                      .
                      .
                      .
RSetDyna = m_dbDatabase.<BR>  OpenRecordset(m_strTableQuery, dbOpenDynaset);<BR><BR>// Check that recordset was created<BR>if (RSetDyna.Exists()) {<BR>  // Get requested number of records<BR>  for (lIndex = 0L; <BR>    !RSetDyna.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows;<BR>    lIndex++) {<BR>    // Get the first returned column<BR>    dbVar = RSetDyna.GetField(0L);<BR>    AddFieldToList(lIndex, &amp;dbVar);<BR>    RSetDyna.MoveNext();<BR>  }<BR>}</PRE>
<P></P>
<P>The third and final optimization uses a snapshot-type recordset (dbOpenSnapshot). You can open a snapshot-type recordset on a base table, attached table, QueryDef, or row-returning SQL statement, but a snapshot recordset is just that: a snapshot. The data cannot be modified, and if another process or thread modifies it after you've created your snapshot, the changes are not reflected.</P>
<P>Actually, DAOREAD uses a forward-only scrolling snapshot as well as a normal snapshot. <B>Figure 14</B> shows the forward-scrolling version. As the name implies, you can navigate this kind of recordset in a forward direction only; attempting to move backwards triggers an error. Forward-only recordsets are typically faster than bidirectional recordsets, especially with ODBC data, because they eliminate the extra overhead required to support backward scrolling.</P>
<P><B> Figure 14  Using Forward-only Snapshots</B></P>
<P><BR></P>
<PRE> // Open recordset on as a Forward-only Snapshot<BR>CdbRecordset RSetSnapForward;
                          .
                          .
                          .
RSetSnapForward = m_dbDatabase.<BR>  OpenRecordset(m_strTableQuery, dbOpenSnapshot,<BR>    dbForwardOnly);<BR><BR>// Check that recordset was created
if (RSetSnapForward.Exists()) {
  // Get requested number of records<BR>  for (lIndex = 0L;<BR>    !RSetSnapForward.GetEOF() &amp;&amp; lIndex &lt; m_lNumRows;<BR>    lIndex++) {<BR>    // Get the first returned column<BR>    dbVar = RSetSnapForward.GetField(0L);<BR>    AddFieldToList(lIndex, &amp;dbVar);<BR>    RSetSnapForward.MoveNext();<BR>  }<BR>}</PRE>
<P> </P>
<H2><A NAME="sec8"></A>  Getting Gobs of Data</H2><P>Browsing records one at a time is the sort of thing humans like to do, but programs often need to retrieve a whole bunch of data in one fell swoop. For example, you might want to visit every employee record to compute aggregate information like average age or salary. In such a scenario, accessing fields individually through the recordset is too slow. What you really want is bulk record retrieval.</P>
<P>By far the fastest way to retrieve large amounts of data is with CdbRecordset::GetRows or its more advanced cousin GetRowsEx. Both functions fetch multiple records into your program's buffers and, in the case of remote data, both use SetCacheStart and SetCacheSize internally for added speed. GetRows and GetRowsEx return the number of rows actually fetched, which may be less than what you requested: if you ask for ten records and there are only six, GetRows will fetch them all and return six.</P>
<P>If an error occurs retrieving data, GetRows will not usually throw an error. Instead, it returns with however many rows it was able to read before the error occurred, and leaves the recordset pointing at the row that caused the error. GetRows works this way for a couple of reasons. First, it's hard to provide rich error information through a single OLE HRESULT. Second, signaling an error when partial data has been fetched complicates error handling; memory may have been allocated that must now be freed. If GetRows returns an error, you're guaranteed that no memory was allocated that you need to free; if no error occurs, then you're responsible for freeing memory GetRows may have allocated on your behalf.</P>
<P>The bottom line is, it's up to you to examine the number of rows actually fetched and do the right thing. If GetRows fetched fewer rows than you requested, you've either run out of records or an error occurred fetching what is now the current row. You can call GetEOF to see if you reached the end of the recordset. If not, an error must have occurred, in which case you can either examine the Errors collection or retrieve each field in the current row and check the error that results.</P>
<P>GetRows takes only one argument: the number of rows to fetch. It returns all fields in the recordset as a single COleVariant object containing a two-dimensional "safe array" indexed by Field and Record. It's up to you to parse this array using the standard safe array functions. <B>Figure 15</B> shows a fragment from CGetRowsDlg::DoGetRows in the GETROWS sample program that comes with the DAO SDK. GETROWS uses SafeArrayGetUBound to get the number of records actually fetched, and SafeArrayGetElement to get each value from the COleVariant. Be careful using SafeArrayGetUBound: the dimension requested and the value returned in lNumRecords is 1-based, unlike most C/C++ functions, which are 0-based. The upper bound returned in lNumRecords is the upper index bound, not the count—so you must either increment the count by one, or loop using &lt;= instead of the usual &lt;. There's great potential for off-by-one errors here, as we discovered the hard way.</P>
<P><B> Figure 15  CGetRowsDlg::DoGetRows</B></P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// (From DAO GETROWS sample)
// Perform standard GetRows against the Employee table
//
void CGetRowsDlg::DoGetRows() 
{
   COleVariant    cRows;
   COleVariant    varField;
   CString        strLBRow;
   TCHAR          szId[16];
   LONG           lNumRecords;
   LONG           lIndex[2];
   HRESULT        hResult;
   CListBox       *pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLIST);

   // Perform GetRows on Employee table
   // This GetRows uses VARIANTS
   // Arbitrarily get MAX_EMP_REC rows
   cRows = m_cEmpRecordSet.GetRows(MAX_EMP_REC); 

   // Find out how many records were actually retrieved
   // (NOTE: SafeArrays are 1-based)
   //
   SafeArrayGetUBound(cRows.parray, 2, &amp;lNumRecords);

   // Clear the listbox
   pListBox-&gt;ResetContent();
   
   for (lIndex[1] = 0; lIndex[1] &lt;= lNumRecords; lIndex[1]++) {
      strLBRow.Empty();    // Clear the string

      lIndex[0] = EMP_ID;  // Employee ID
         
      // Use OLE safe array function to access fields
      hResult = SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);

      // Watch out for bum variants
      if(FAILED(hResult))
         break;

      if(varField.vt == VT_I4) {    // Gotta be a long 
         wsprintf(szId, _T("%d,  "), varField.iVal);
      } else {
         lstrcpy(szId, _T("Unexpected Data Type"));
      }

      strLBRow += (LPCTSTR)szId;

      // Get last name
      lIndex[0] = EMP_LNAME;
      SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);
      strLBRow += (LPCTSTR)varField.bstrVal;

      // Get first name
      strLBRow += _T(", ");
      lIndex[0] = EMP_FNAME;
      SafeArrayGetElement(cRows.parray, &amp;lIndex[0], &amp;varField);
      strLBRow += (LPCTSTR)varField.bstrVal;

      pListBox-&gt;AddString(strLBRow);
   }
}</PRE>
<P></P>
<H2><A NAME="sec9"></A>  The Ultimate Record-Fetching Function</H2><P>GetRowsEx works just like GetRows, but it's much more powerful and consequently a little harder to use (but not much). Unlike GetRows, which always fetches all the fields in the recordset, GetRowsEx lets you specify which fields to fetch. In addition, GetRowsEx can read data into your own custom C struct, instead of returning it as one big array. GetRowsEx even converts to native C types automatically! <B>Figure 16</B> shows the CGetRowsDlg::DoGetRowsEx function from GETROWS.</P>
<P><B> Figure 16  CGetRowsDlg::DoGetRowsEx</B></P>
<P><BR></P>
<PRE> ////////////////
// Perform C++ GetRowsEx against the Employee table
//
void CGetRowsDlg::DoGetRowsEx() 
{
   LPEMP       pEmpRows = new EMP[MAX_EMP_REC];
   CListBox    *pListBox = (CListBox *)GetDlgItem(IDD_GETROWSLISTEX);
   CString     strLBRow;
   TCHAR       szId[16];
   LONG        lNumRecords;
   LONG        lCount;
   TCHAR       pBuf[MAX_EMP_REC * 15];    // allow average of 15 chars/name

   // Perform GetRows on Employee table
   // This GetRows uses a specific C++ structure
   try {
      lNumRecords = m_cEmpRecordSet.GetRowsEx(pEmpRows, sizeof(EMP),
                       &amp;Bindings[0], sizeof(Bindings) / sizeof(DAORSETBINDING),
                       pBuf, sizeof(pBuf),
                       MAX_EMP_REC); //arbitrarily get MAX_EMP_REC rows

   } catch (CdbException e) {
      // Differentiate between GetRowsEx Errors and other CdbExceptions
      // see defines in DAOGETRW.H
      if( e.m_hr == E_ROWTOOSHORT ||
          e.m_hr == E_BADBINDINFO ||         
          e.m_hr == E_COLUMNUNAVAILABLE ) {
         AfxMessageBox(_T("Error in GetRowsEx call."));
      } else {
         AfxMessageBox(_T("General CdbException"));
      }
      delete [] pEmpRows;
      return;
   }

   // Step through the returned rows 
   for (lCount = 0; lCount &lt; lNumRecords; lCount++) {
      strLBRow.Empty();
      wsprintf(szId, _T("%d,  "), pEmpRows[lCount].lEmpId);
      strLBRow += szId;
      strLBRow += pEmpRows[lCount].strLastName;
      strLBRow += _T(", ");
      strLBRow += (LPCTSTR) pEmpRows[lCount].strFirstName;
      pListBox-&gt;AddString(strLBRow);
   }
   delete [] pEmpRows;
}</PRE>
<P></P>
<P>To use GetRowsEx, you first define a struct you want to receive data, and then a "binding structure" that tells GetRowsEx which table fields go where in your struct (see <B>Figure 17</B>). These paired declarations could go in a header file for inclusion throughout your app. You might even use several different structs for each table to minimize fetching of fields you don't always need. Once the structures are defined, all that remains is to call GetRowsEx.</P>
<P> </P>
<P><BR></P>
<PRE> LPEMP pEmpRows = new EMP[MAX_EMP_REC];<BR>LONG  lNumRecords;<BR>TCHAR pBuf[MAX_EMP_REC * 15];<BR><BR>lNumRecords = m_cEmpRecordSet.GetRowsEx(<BR>              pEmpRows, sizeof(EMP),<BR>              &amp;Bindings[0], <BR>              sizeof(Bindings)/sizeof(DAORSETBINDING),<BR>              pBuf, sizeof(pBuf),<BR>              MAX_EMP_REC);</PRE>
<P> </P>
<P><B> Figure 17  Using GetRowsEx</B></P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// (From MSDEV\DAOSDK\SAMPLES\GETROWS)
// Structure for GetRowsEx
//
// structure to receive one row of data<BR>typedef struct {<BR>  LONG   lEmpId;<BR>  TCHAR  *strLastName;<BR>  TCHAR  strFirstName[20];<BR>} EMP, *LPEMP;
// Binding maps table fields to C struct members<BR>DAORSETBINDING Bindings[] =<BR>{<BR>  // { Index Type,  Column,   Type,<BR>  //   Offset,  Size }<BR>  {dbBindIndexINT,  EMP_ID,   dbBindI4,<BR>    offsetof(EMP,lEmpId), sizeof(LONG)},<BR>  {dbBindIndexINT,  EMP_LNAME,dbBindLPSTRING,<BR>    offsetof(EMP,strLastName), sizeof(TCHAR *)},<BR>  {dbBindIndexINT,  EMP_FNAME,dbBindSTRING,<BR>    offsetof(EMP,strFirstName), sizeof(TCHAR)*20 }<BR>};</PRE>
<P></P>
<P>This code fetches Employee ID, Last Name, and First Name from the Employees table, and loads the data into the pEmpRows array of EMP structures. From there, manipulating the data is much easier, since it's already converted to native C types. <B>Figure 16</B> shows the complete source, with error handling and everything else.</P>
<P>There's just one trick that deserves further explanation. Reading variable-length fields is often a pain—how much space do you allocate for each field? You might allocate an array of char[MAXNAMELEN]s to hold a name like "Howard Beaureguard Fitzsimmons Elsemerath III"—but then you'll have a lot of wasted space for names like "Po Li." You can always specify dbBindVariant as the bind type in your binding structure: GetRowsEx will retrieve a VT_BSTR or VT_NULL into your struct. But that's no fun! It fragments memory, and you have to free the Variant yourself when you're finished using it. What you really want is one big buffer to hold all the variable-length strings, nicely packed end-to-end so there's no wasted space. Well, GetRowsEx lets you do exactly that!</P>
<P>The pvVarBuffer parameter to GetRowsEx lets you pass a chunk of memory for holding variable-length data. If you bind a field with dbBindLPSTRING, GetRowsEx fills your buffer with variable-length data as it's loaded and sets the pointers in your data structure array to point to the start of each zero-terminated string in the buffer. <B>Figure 18</B> shows how it works. The same trick works for binary data, but you must bind with dbBindBlob as the bind type and you must allocate two elements in your data structure, a ULONG to hold the length and an LPVOID to hold a pointer to the actual data itself.</P>
<P><img src="DAO18.gif"></P>
<P><B> Figure 18  Variable-length String Allocation</B></P>
<H2><A NAME="sec10"></A>  Putting It All Together</H2><P>We've covered a lot of topics and discussed some wonderful DAO details that should help you build good fast functional database apps. You could easily stop here and run to your keyboard to try everything out—but don't! Design your database first.</P>
<P>We can't emphasize this enough—before cranking up your favorite C++ compiler, build a prototype! Not a prototype of your application, but a prototype of your data. Before you write a single line of code, start by designing your database. Mock up the tables you'll need. Define the relationships between them, and the dependencies that will save code—like referential integrity constraints and cascading deletes and updates. Once you've done all that, build thequeriesyouthinkyou'llneedtoretrieveandupdatedata.</P>
<P>When you have a working database, load some data and run your queries. And not just a few records, but as many as you expect the final system to manage. That way, there won't be any surprises. All too often developers discover the hard way that what works well with 10MB can grind to a crawl at 100MB. If necessary, write a short program to generate gobs of artificial data. The effort will be well spent.</P>
<P>There are lots of good products you can use to build prototypes without writing any code. Since DAO works with many data formats, you're not restricted to Microsoft Access. For performance testing, however, you should use whatever format you intend to use for the real system. If you use Access Basic to test performance, you can be confident that the results you get from C++ will be as good or better. Another benefit to using Microsoft Access is that instead of doing queries the old way, by embedding SQL commands in your code, you can create your queries in Microsoft Access and invoke them by name from C++. It's a lot easier that way. The queries will execute slightly faster too, because they're already compiled. And if you ever need to change a query, you can do it without recompiling your code!</P>
<P>Since DAO is exposed in both C++ and Basic, you can use Basic as a rapid prototyping language. Just type your DAO code and go. No compilation, no linking required. It's a lot easier to explore DAO from Basic before you make the grand plunge to C++. You can also use Basic for debugging: if something doesn't work right in C++, you can run Microsoft Access to see how the equivalent Basic code behaves.</P>
<P>As a closing illustration of how the DAO SDK classes facilitate this development approach, <B>Figures 19</B> and <B>20</B> show a simple Basic program and its C++ equivalent. The program combines many of the concepts discussed in this article: variants with date handling, error handling, bookmarks, and even some features we didn't mention, like FindFirst.</P>
<P><B> Figure 19  SAMP.BAS</B></P>
<P><BR></P>
<PRE> Sub SetDate()
       dim db as database, rs as Recordset
   dim vBkmk as variant
   on error goto lblErrorHndlr
   set db = OpenDatabase("employees.mdb")
   set rs = db.OpenRecordset("employees", dbOpenDynaset)
   vBkmk = rs.bookmark
   rs.FindFirst "[Hire Date] &lt; #10/10/1990#"
   do while rs.nomatch = False
     rs.edit
     rs![Hire Date] = #10/10/1990#
     rs.update
     rs.FindFirst "[Hire Date] &lt; #10/10/1990#"
   loop
   rs.bookmark = vBkmk
   rs.Close
   db.Close
lblQuit:
   exit sub
lblErrorHndlr:
   if (dbengine.errors.count &lt;&gt; 0) then
     msgbox dbengine.Errors(0).Description
   else
     msgbox "Unexpected Error"
   endif
   resume lblQuit
end sub</PRE>
<P></P>
<P><B> Figure 20  SAMP.CPP</B></P>
<P><BR></P>
<PRE> void SetDate(void)
{
       CdbDBEngine dben;
       CdbDatabase db;
       CdbRecordset rs;
       CdbBookmark bk;
       COleDateTime dt;
       try {
              db = dben[0L].OpenDatabase(_T("employees.mdb"));
              rs = db.OpenRecordset(_T("employees"));
              bk = rs.GetBookmark();
              rs.FindFirst(_T("[Hire Date] &lt; #10/10/1990#"));
              while (rs.GetNoMatch() == FALSE) {
                     rs.Edit();
                     rs.SetValue(_T("[Hire Date]"), COleDateTime(1990, 10, 10, 
                                                                 0, 0, 0));
                     rs.Update();
                     rs.FindFirst(_T("[Hire Date] &lt; #10/10/1990#"));
              }
              rs.SetBookmark(bk);
              rs.Close();
              db.Close();

       } catch(CdbException e) {
              if (dben.Errors.GetCount() != 0)
                     MessageBox(NULL, dben.Errors[0L].GetDescription(), NULL, 
                                0);
              else
                     MessageBox(NULL, _T("Unexpected Error"), NULL, 0);
       }
}</PRE>
<P></P>
<H2><A NAME="sec11"></A>  Conclusion</H2><P>We've explored several key features of DAO. To get to know DAO, you should read the documentation and explore the sample programs that come with the SDK—though we will remind you that the place to begin is with a thorough understanding of database principles. Once you have that, DAO is guaranteed to keep your database in spiritual harmony with C++! </P>
<H2><A NAME="sec12"></A>  OLE Automation</H2><P>Unless you really have your head in the sand, you've probably heard of OLE automation by now, which—contrary to popular belief—has nothing to do with drag-and-drop, in-place editing, linking, embedding, or any of the other buzzwords usually associated with OLE. Rather, automation is a way to invoke code that lives within other COM (Component Object Model) objects that exist on your system.</P>
<P>You can think of OLE automation objects as typesafe DLLs. Just as a DLL exposes dynamically bindable entry points, so does an OLE automation object. The difference is that automation objects are self-describing. They provide a type library, or typelib, that describes all the entry points, parameters, and return types. Some programming tools such as Visual Basic use the typelib exclusively; other languages like C/C++ rely on a header file that's automatically generated by the typelib compiler, MKTYPLIB. The header file describes interfaces that are wrapped by the DAO SDK classes.</P>
<P>If you already know something about automation, you're probably thinking, "I know, automation is IDispatch and IDispatch is sloooow." Indeed, when automation was first introduced, IDispatch was the only way to invoke functions. But there have been some useful improvements recently, which you may not be aware of. Starting in Windows NT 3.51 and now in Windows 95, there's a new automation interface type called a dual interface. A dual interface supports both IDispatch and a normal vtable interface. The first seven functions in a dual interface are the normal IDispatch functions; the rest can be whatever you want, as long as the arguments are official automation types. Dual interfaces provide both the flexibility of run-time IDispatch binding and the speed of compile-time vtable binding. C/C++ clients and Visual Basic clients can call dual interfaces directly through the vtable, while still using late-bound IDispatch calls if need be. For a detailed look at dual interfaces, see Don Box's OLE Q&amp;A in the December 1995 MSJ. Also, the section "Exposing OLE Automation Objects" in the latest Win32 SDK reference contains more information about dual interfaces, and Kraig Brockschmidt's article "Design Considerations for Implementing a Simple OLE Automation Controller" (MSJ, May 1995) provides helpful information about building an OLE automation server.</P>
<P>Much of the terminology associated with OLE automation derives from its Basic heritage. Here's a brief jargon primer for the uninitiated.</P>
<P><B>Methods</B> As in C++, a method is just a function associated with a particular class of object. A method takes zero or more arguments and may or may not return a value. A methodthathasnoreturnvaluebehaveslikeasubroutine in Basic. Methods are only valid as rvalues in expressions.</P>
<P><B>Properties</B> A property is an attribute of an object that can be retrieved or set. Unlike methods, properties don't have arguments, and they can act as lvalues as well as rvalues. That is, you can set as well as get them. For example, in Basic you can write</P>
<P> </P>
<P><BR></P>
<PRE> Elephant.Name = "Fred"<BR>Name$ = Elephant.Name</PRE>
<P> </P>
<P>where Name is a property of Elephant objects. Properties are by convention implemented in C++ as a pair of methods: one to get and one to set the property. For example, the DAO Name property is implemented as two methods:</P>
<P> </P>
<P><BR></P>
<PRE> char* get_Name();<BR>void put_Name(char *);</PRE>
<P> </P>
<P>Of course, this is a simplification. The actual declarations from DBDAOINT.H contain a lot of OLE macro gobbledygook.</P>
<P> </P>
<P><BR></P>
<PRE> STDMETHOD(get_Name) (THIS_ BSTR FAR* pbstr) PURE;<BR>STDMETHOD(put_Name) (THIS_ BSTR Name) PURE;</PRE>
<P> </P>
<P><B>Collections</B> A collection is a group of like objects gathered together for ease of reference. Collections provide generic group operations to retrieve individual objects by ordinal or name, get the count of objects, add and remove objects from the collection (often with the side effect of creating or deleting the object itself), and so on. OLE automation recognizes collections from the existence of a _NewEnum property. The value of this property, if it exists, is an IEnumVARIANT interface, which has methods to enumerate the objects in the collection.</P>
<P><B>Variants</B> OLE automation defines a data type VARIANT, which is a tagged union of most common C types along with more complex types such as DATE, CURRENCY, and BSTR. <B>Figure A</B> shows the definition from OAIDL.H. Variants have several purposes. First, they provide a safe type to pass between OLE automation client and server with less chance of crashing due to bad pointers, especially for strings and arrays. Second, variants can be remoted across processes using standard remote procedure call mechanisms, thus avoiding the need to write custom proxy code for every interface. Thus, even though it was written as an inproc OLE automation server, DAO can be remoted not only across processes within a single machine, but also across processes on different machines. Variants take care of machine-dependent conversions for byte order, alignment, size, and so on—automatically. Last but not least, variants provide useful database semantics such as null values. In C/C++, it isn't possible to return NULL for a nonpointer type such as int or long, because in C, NULL is indistinguishable from zero; whereas database apps typically must distinguish between the legal value zero and the notion of "no value." Variants provide a special data type,VT_NULL,tohandlethis.Convertingfromvariants to native C/C++ types can be a nuisance, but MFC 4.0 hasanewclasscalledCOleVariantwithderivativesCOleDateTimeandCOleCurrencythatsmooththeprocess.</P>
<P><B> Figure A  VARIANT Definition</B></P>
<P><BR></P>
<PRE> /*
 * Definition of VARIANT, from OAIDL.H
 */

typedef unsigned short VARTYPE;
typedef struct tagVARIANT VARIANT;

struct tagVARIANT {
   VARTYPE vt;
   WORD wReserved1;
   WORD wReserved2;
   WORD wReserved3;
   union {
      long          lVal;           /* VT_I4                */
      unsigned char bVal;           /* VT_UI1               */
      short         iVal;           /* VT_I2                */
      float         fltVal;         /* VT_R4                */
      double        dblVal;         /* VT_R8                */
      VARIANT_BOOL  bool;           /* VT_BOOL              */
      SCODE         scode;          /* VT_ERROR             */
      CY            cyVal;          /* VT_CY                */
      DATE          date;           /* VT_DATE              */
      BSTR          bstrVal;        /* VT_BSTR              */
      IUnknown      *punkVal;       /* VT_UNKNOWN           */
      IDispatch     *pdispVal;      /* VT_DISPATCH          */
      SAFEARRAY     *parray;        /* VT_ARRAY|*           */
      unsigned char *pbVal;         /* VT_BYREF|VT_UI1      */
      short         *piVal;         /* VT_BYREF|VT_I2       */
      long          *plVal;         /* VT_BYREF|VT_I4       */
      float         *pfltVal;       /* VT_BYREF|VT_R4       */
      double        *pdblVal;       /* VT_BYREF|VT_R8       */
      VARIANT_BOOL  *pbool;         /* VT_BYREF|VT_BOOL     */
      SCODE         *pscode;        /* VT_BYREF|VT_ERROR    */
      CY            *pcyVal;        /* VT_BYREF|VT_CY       */
      DATE          *pdate;         /* VT_BYREF|VT_DATE     */
      BSTR          *pbstrVal;      /* VT_BYREF|VT_BSTR     */
      IUnknown      **ppunkVal;     /* VT_BYREF|VT_UNKNOWN  */
      IDispatch     **ppdispVal;    /* VT_BYREF|VT_DISPATCH */
      SAFEARRAY     **pparray;      /* VT_BYREF|VT_ARRAY|*  */
      VARIANT       *pvarVal;       /* VT_BYREF|VT_VARIANT  */
      void          *byref;         /* Generic Bytes        */
   } u;
};</PRE>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
