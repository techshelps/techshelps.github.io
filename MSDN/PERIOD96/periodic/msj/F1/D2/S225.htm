<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Automatically Configure Your Devices by Exploiting Plug and Play VxD Services</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Automatically Configure Your Devices by Exploiting Plug and Play VxD Services</H1><P>Walter Oney</P>
<P>Walter Oney is a freelance developer and software consultant based in Boston, MA. He is currently writing a book on systems programming in Windows 95 to be published in spring of 1996 by Microsoft Press. He can be reached on CompuServe at 73730,553.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4564">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the PLUGPLAY project files.</A></P><P>ThePlugandPlaysubsystems of Windows® 95 are designed to simplify the lives of end users and ten-thumbed programmers faced with new or conflicting hardware. In my previous article I summarized the hardware features that allow Windows 95 and other operating systems (MS-DOS®) to determine what hardware populates a PC, and I described the role of the Configuration Manager VxD. Now I'll examine how Configuration Manager arbitrates the competing demands of hardware for resources such as I/O port addresses and interrupt request assignments. I'll show how a VxD learns what resources it's supposed to use. Finally, I'll describe how you can extend the functionality of the Windows 95 Device Manager by supplying a custom property page provider that works with your device driver.</P>
<H2><A NAME="sec0"></A>  Loading Drivers</H2><P>Because this material is so dense, let me sum up the previous article before moving on to new concepts. Configuration Manager uses VxDs known as bus enumerators to determine what hardware is physically present. An internal root enumerator uses registry entries created by the Windows Setup program to count the "legacy" devices on the system. The legacy devices include all the devices detected by Setup and one top-level hardware bus. Each bus has a driver that enumerates the attached hardware (which may include other buses) to create device nodes (DEVNODEs for short) in a hierarchical hardware tree. Drivers for devices like SCSI controllers that contain other devices can augment the hardware tree by registering as enumerators and creating further DEVNODEs.</P>
<P>Two keys in the system registry describe each hardware device. The hardware key occupies a branch of HKLM\Enum. (HKLM is an abbreviation for the top-level HKEY_LOCAL_MACHINE branch of the registry.) The hardware key points to the software key for the device. The software key lies within a branch of HKLM\System\CurrentControlSet\Services\Class named for the class to which the device belongs. For example, the hardware key for my COM1 port is HKLM\Enum\Root\*PNP0500\0000, while the software key is HKLM\System\CurrentControlSet\Services\Class\ports\0000.</P>
<P>Configuration Manager initially locates the hardware key for a device when an enumerator creates a DEVNODE. The DEVNODE has an identifier that also names the hardware key. Configuration Manager uses the Driver named value within the hardware key in the Registry to find the software key. Using COM1 as an example again, Configuration Manager would find the name "ports\0000" in the driver value for COM1. Rather than now directly load a device driver, Configuration Manager obtains the name of a device loader from the DevLoader value in the software key. It then asks the device loader to dynamically load the device driver.</P>
<P>Configuration Manager's initial communication with a Plug and Play VxD uses the Directed_Sys_Control service of the Virtual Machine Manager to send a PNP_New_Devnode system control message to the driver's control procedure. Along with the message code, Configuration Manager sends the address of the DEVNODE for the device in question as well as a reason code explaining what the called driver is supposed to do. The code DLVXD_LOAD_ENUMERATOR means that Configuration Manager wants the driver to use the CM_Register_Enumerator service to register an enumeration procedure for the DEVNODE, which presumably describes a bus or controller to which other devices are attached. The DLVXD_ LOAD_DRIVER code asks the driver to call CM_ Register_Device_Driver to register as the driver. Finally, DLVXD_LOAD_DEVLOADER indicates that the called driver should locate and dynamically load the requisite driver VxD, which will thereupon receive its own PNP_New_Devnode(DLVXD_LOAD_DRIVER) call in order to register itself as the driver.</P>
<P>Plug and Play drivers often break the rules about handling PNP_New_Devnode. In the previous article, I showed a sample enumerator for the fictional School Bus. This enumerator follows the same pattern as Microsoft bus enumerators. That is, Configuration Manager calls it initially because of a DevLoader entry in a registry key and asks it to be the device loader for the bus. Ignoring this injunction, the School Bus enumerator registers itself as both an enumerator and driver for the bus. It doesn't actually load any other drivers at this point! The sample driver for an equally fictional Telepathic Input Device illustrated the same technique for a driver that masquerades as a device loader in order to be able to register itself with Configuration Manager as the device driver.</P>
<P>A Plug and Play device driver is really nothing more than a dynamically loadable VxD that contains a configuration function in addition to its normal I/O programming. The configuration function can be relatively complicated, but doesn't have to be. I'll talk about this function in detail later on. For now, I'll just mention that its basic purpose is to retrieve I/O resource assignments from Configuration Manager and to initialize the device and the driver's own logic based on those assignments. If a device uses an interrupt request line, for example, the driver's configuration function would determine which IRQ to use by asking Configuration Manager. If it's possible to program the hardware to use the assigned IRQ, the driver would do that from within its configuration function. (If it's impossible to program the IRQ, Configuration Manager assigns the one and only IRQ the hardware wants to use. The software driver would still work as I'm describing it.) The driver would then use VPICD_Virtualize_IRQ in the normal way to hook the hardware interrupt. In effect, the configuration function subsumes much of the initialization that Windows 3.1 VxDs used to do during Device_Init. Furthermore, Configuration Manager VxD services replace previous methods—such as INI file settings, a priori assumptions, or communication with real-mode drivers—of learning about resource assignments.</P>
<P>In this article, I'll be mentioning many of the services Configuration Manager provides to VxD callers (see <B>Figure 1</B>). (Note that when you call these functions you must place the CM_ prefix in front of the name listed in <B>Figure 1</B>.) </P>
<P><B> Figure 1  Configuration Manager Services</B></P>
<P></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="171pt" VALIGN="TOP"><COL WIDTH="270pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Service (CM_Xxx)</B></P></TD><TD VALIGN="TOP"><P><B> Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> Add_Empty_Log_Conf</P></TD><TD VALIGN="TOP"><P>Creates an empty logical configuration for a given DEVNODE. First step in defining resource requirements for a device.</P></TD></TR><TR><TD VALIGN="TOP"><P> Add_ID</P></TD><TD VALIGN="TOP"><P>Used during CONFIG_SETUP to add a hardware ID or compatible ID to a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Add_Range</P></TD><TD VALIGN="TOP"><P>Expand a memory range list by adding one more range description.</P></TD></TR><TR><TD VALIGN="TOP"><P> Add_Res_Des</P></TD><TD VALIGN="TOP"><P>Add a resource descriptor to a growing logical configuration.</P></TD></TR><TR><TD VALIGN="TOP"><P> Call_At_Appy_Time</P></TD><TD VALIGN="TOP"><P>Arrange an application time callback.</P></TD></TR><TR><TD VALIGN="TOP"><P> Call_Enumerator_Function</P></TD><TD VALIGN="TOP"><P>Call the enumerator for a given DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> CallBack_Device_Driver</P></TD><TD VALIGN="TOP"><P>Call a device driver once for each device it manages, passing CONFIG_CALLBACK as the function code.</P></TD></TR><TR><TD VALIGN="TOP"><P> CallBack_Enumerator</P></TD><TD VALIGN="TOP"><P>Call an enumerator function once for each device it enumerates, passing CONFIG_CALLBACK as the function code. This makes calls for each bus or controller rather than for each attached device.</P></TD></TR><TR><TD VALIGN="TOP"><P> Create_DevNode</P></TD><TD VALIGN="TOP"><P>Create a new DEVNODE. This is the basic function for enumerators to use in expanding the hardware tree.</P></TD></TR><TR><TD VALIGN="TOP"><P> Create_Range_List</P></TD><TD VALIGN="TOP"><P>Create an empty memory range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Delete_Range</P></TD><TD VALIGN="TOP"><P>Remove a single memory range description from a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Deregister_Arbitrator</P></TD><TD VALIGN="TOP"><P>Deregister a resource arbitrator.</P></TD></TR><TR><TD VALIGN="TOP"><P> Disable_DevNode</P></TD><TD VALIGN="TOP"><P>Disable a device. That is, stop using it.</P></TD></TR><TR><TD VALIGN="TOP"><P> Dump_Range_List</P></TD><TD VALIGN="TOP"><P>Dump a range list for debugging.</P></TD></TR><TR><TD VALIGN="TOP"><P> Dup_Range_List</P></TD><TD VALIGN="TOP"><P>Create a copy of a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Enable_DevNode</P></TD><TD VALIGN="TOP"><P>Reverse the effect of a Disable_DevNode call.</P></TD></TR><TR><TD VALIGN="TOP"><P> Fail_Change_Config</P></TD><TD VALIGN="TOP"><P>Used by the Plug and Play BIOS enumerator to cancel a previously planned docking or undocking.</P></TD></TR><TR><TD VALIGN="TOP"><P> First_Range</P></TD><TD VALIGN="TOP"><P>Retrieve the first range element in a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Free_Log_Conf</P></TD><TD VALIGN="TOP"><P>Release the memory used by a logical configuration.</P></TD></TR><TR><TD VALIGN="TOP"><P> Free_Range_List</P></TD><TD VALIGN="TOP"><P>Release the memory used by a memory range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Free_Res_Des</P></TD><TD VALIGN="TOP"><P>Release the memory used by a single resource descriptor.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Alloc_Log_Conf</P></TD><TD VALIGN="TOP"><P>Get the resources actually allocated for a device. This is the main service used by a device driver to learn what resources it may use.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Bus_Info</P></TD><TD VALIGN="TOP"><P>Retrieve the bus information installed by Set_Bus_Info.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Child</P></TD><TD VALIGN="TOP"><P>Get a pointer to the first child of a given DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_CRC_CheckSum</P></TD><TD VALIGN="TOP"><P>Calculate a cyclic redundancy check for a given byte string.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_DDBs</P></TD><TD VALIGN="TOP"><P>Locate the device descriptor block(s) for drivers associated with a DEVNODE. This allows the caller to do Directed_Sys_Control calls to those drivers.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Depth</P></TD><TD VALIGN="TOP"><P>Determine how deep a DEVNODE is in the hardware tree.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Device_Driver_Private_DWord</P></TD><TD VALIGN="TOP"><P>Retrieve the private value stored in the DEVNODE by Set_Device_Driver_Private_Dword.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Device_ID</P></TD><TD VALIGN="TOP"><P>Retrieve the ASCII device ID for a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Device_ID_Size</P></TD><TD VALIGN="TOP"><P>Get the byte length of the device ID. This allows the caller to allocate memory for a call to Get_Device_ID.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_DevNode_Key</P></TD><TD VALIGN="TOP"><P>Retrieve the ASCII name of the hardware or software registry key for a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_DevNode_Key_Size</P></TD><TD VALIGN="TOP"><P>Get the byte length of a registry pathname. This allows the caller to allocate memory for a call to Get_DevNode_Key.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_DevNode_Status</P></TD><TD VALIGN="TOP"><P>Retrieve the current status of a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_First_Log_Conf</P></TD><TD VALIGN="TOP"><P>Get a handle to the first logical configuration for a DEVNODE. This is how the caller starts a loop over configurations.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Hardware_Profile_Info</P></TD><TD VALIGN="TOP"><P>Retrieve information about a hardware profile.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_HW_Prof_Flags</P></TD><TD VALIGN="TOP"><P>Get configuration-specific flags for a single DEVNODE in a particular hardware profile.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Next_Log_Conf</P></TD><TD VALIGN="TOP"><P>Get a handle for the next logical configuration in a list of configurations.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Next_Res_Des</P></TD><TD VALIGN="TOP"><P>Get a handle for the first or next resource descriptor in a logical configuration.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Parent</P></TD><TD VALIGN="TOP"><P>Get a pointer to the parent of a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Performance_Info</P></TD><TD VALIGN="TOP"><P>Retrieve performance information for debugging purposes.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Private_DWord</P></TD><TD VALIGN="TOP"><P>Retrieve the private DWORD that a driver stored about one DEVNODE in some other DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Res_Des_Data</P></TD><TD VALIGN="TOP"><P>Copy a resource descriptor given its handle. Used only by Ring 3 callers.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Res_Des_Data_Size</P></TD><TD VALIGN="TOP"><P>Get the byte length of resource data. This allows a Ring 3 caller to allocate memory for a call to Get_Res_Des_Data.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Sibling</P></TD><TD VALIGN="TOP"><P>Get the next sibling of a DEVNODE. Used during a loop over children of a given node.</P></TD></TR><TR><TD VALIGN="TOP"><P> Get_Version</P></TD><TD VALIGN="TOP"><P>Get the version number (that is, 0x0400) of the CONFIGMG device driver.</P></TD></TR><TR><TD VALIGN="TOP"><P> Intersect_Range_List</P></TD><TD VALIGN="TOP"><P>Create the intersection of two range lists.</P></TD></TR><TR><TD VALIGN="TOP"><P> Invert_Range_List</P></TD><TD VALIGN="TOP"><P>Create the inversion of a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> ISAPNP_To_CM</P></TD><TD VALIGN="TOP"><P>Convert a device's resource requirements from the format specified in the ISA Plug and Play specification to Configuration Manager's internal resource descriptor format.</P></TD></TR><TR><TD VALIGN="TOP"><P> Load_DLVxDs</P></TD><TD VALIGN="TOP"><P>Dynamically load one or more VxDs.</P></TD></TR><TR><TD VALIGN="TOP"><P> Locate_DevNode</P></TD><TD VALIGN="TOP"><P>Find a DEVNODE given its ASCII ID.</P></TD></TR><TR><TD VALIGN="TOP"><P> Merge_Range_List</P></TD><TD VALIGN="TOP"><P>Create the union of two range lists.</P></TD></TR><TR><TD VALIGN="TOP"><P> Modify_Res_Des</P></TD><TD VALIGN="TOP"><P>Modify a resource descriptor. Used only by Ring 3 callers.</P></TD></TR><TR><TD VALIGN="TOP"><P> Move_DevNode</P></TD><TD VALIGN="TOP"><P>Used by Device Installer to eliminate duplicate DEVNODEs.</P></TD></TR><TR><TD VALIGN="TOP"><P> Next_Range</P></TD><TD VALIGN="TOP"><P>Get the next range descriptor in a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Query_Arbitrator_Free_Data</P></TD><TD VALIGN="TOP"><P>Determine which resources managed by a resource arbitrator are free.</P></TD></TR><TR><TD VALIGN="TOP"><P> Query_Arbitrator_Free_Size</P></TD><TD VALIGN="TOP"><P>Determine the byte length of an arbitrator's free data structure. This allows the caller to allocate memory for a call to Query_Abitrator_Free_Data.</P></TD></TR><TR><TD VALIGN="TOP"><P> Query_Change_Config</P></TD><TD VALIGN="TOP"><P>Determine if it's okay to change from one hardware profile to another.</P></TD></TR><TR><TD VALIGN="TOP"><P> Query_Remove_SubTree</P></TD><TD VALIGN="TOP"><P>Determine if it's okay to remove a DEVNODE and all of its children.</P></TD></TR><TR><TD VALIGN="TOP"><P> Read_Registry_Log_Confs</P></TD><TD VALIGN="TOP"><P>Convert a logical configuration in the registry into Configuration Manager's internal form. Used by the Root Enumerator to configure legacy devices.</P></TD></TR><TR><TD VALIGN="TOP"><P> Read_Registry_Value</P></TD><TD VALIGN="TOP"><P>Read a value from the registry. Used by all sorts of Plug and Play drivers to obtain information beyond normal configuration data.</P></TD></TR><TR><TD VALIGN="TOP"><P> Recompute_HW_Prof</P></TD><TD VALIGN="TOP"><P>Used by the Plug and Play BIOS enumerator after a docking station change.</P></TD></TR><TR><TD VALIGN="TOP"><P> Reenumerate_DevNode</P></TD><TD VALIGN="TOP"><P>Force Configuration Manager to enumerate a DEVNODE. Used, for example, when a bus or controller detects a hot hardware change.</P></TD></TR><TR><TD VALIGN="TOP"><P> Register_Arbitrator</P></TD><TD VALIGN="TOP"><P>Register a function as a resource arbitrator.</P></TD></TR><TR><TD VALIGN="TOP"><P> Register_Device_Driver</P></TD><TD VALIGN="TOP"><P>Register a device driver for a DEVNODE. Every device driver makes this call.</P></TD></TR><TR><TD VALIGN="TOP"><P> Register_DevLoader</P></TD><TD VALIGN="TOP"><P>Indicates that a static VxD that earlier received a PNP_New_DevNode (DEVLOADER) message and returned CR_DEVLOADER_NOT_READY is now ready to be a Device Loader and wants to get the message a second time. Few device loaders make this call.</P></TD></TR><TR><TD VALIGN="TOP"><P> Register_Enumerator</P></TD><TD VALIGN="TOP"><P>Register an enumeration function. Every bus or controller enumerator makes this call.</P></TD></TR><TR><TD VALIGN="TOP"><P> Remove_SubTree</P></TD><TD VALIGN="TOP"><P>Removes a DEVNODE and its children from the hardware tree. This is part of removing a device from the system.</P></TD></TR><TR><TD VALIGN="TOP"><P> Remove_Unmarked_Children</P></TD><TD VALIGN="TOP"><P>Removes DEVNODEs whose preservation marks were cleared by Reset_Children_Marks. </P></TD></TR><TR><TD VALIGN="TOP"><P> Reset_Children_Marks</P></TD><TD VALIGN="TOP"><P>Clears the preservation mark for the children of a given DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Run_Detection</P></TD><TD VALIGN="TOP"><P>Spawns the (Ring 3) detection DLL following insertion of a legacy card.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_Bus_Info</P></TD><TD VALIGN="TOP"><P>Record information about a hardware bus represented by a given DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_Device_Driver_Private_DWord</P></TD><TD VALIGN="TOP"><P>Set the private value in a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_HW_Prof</P></TD><TD VALIGN="TOP"><P>Used by Control Panel to change the current hardware profile.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_HW_Prof_Flags</P></TD><TD VALIGN="TOP"><P>Set the profile-specific flags for a DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_Private_DWord</P></TD><TD VALIGN="TOP"><P>Record a private value about one DEVNODE in some other DEVNODE.</P></TD></TR><TR><TD VALIGN="TOP"><P> Set_Private_Problem</P></TD><TD VALIGN="TOP"><P>Record a "problem" in a DEVNODE so the class installer can diagnose it for the user.</P></TD></TR><TR><TD VALIGN="TOP"><P> Setup_DevNode</P></TD><TD VALIGN="TOP"><P>Send a CONFIG_SETUP or CONFIG_READY to a DEVNODE's enumerator.</P></TD></TR><TR><TD VALIGN="TOP"><P> Sort_NodeList</P></TD><TD VALIGN="TOP"><P>Used by a resource arbitrator to sort a list of logical configurations according to how easy their requirements will be to satisfy.</P></TD></TR><TR><TD VALIGN="TOP"><P> Test_Range_Available</P></TD><TD VALIGN="TOP"><P>Determine if a memory range is available given reservations recorded in a range list.</P></TD></TR><TR><TD VALIGN="TOP"><P> Write_Registry_Value</P></TD><TD VALIGN="TOP"><P>Set a value in the registry.</P></TD></TR><TR><TD VALIGN="TOP"><P> Yield</P></TD><TD VALIGN="TOP"><P>Yield control until a time-out expires. Used to satisfy hardware timing requirements.</P></TD></TR></TBODY></TABLE>
<P><BR></P><H2><A NAME="sec1"></A>  Hardware Resources</H2><P>Now, let's learn how Configuration Manager learns what resources areneeded by the complete collection of hardware, allocates those resources among the competing devices, and notifies the device drivers of the finished allocation. The resources are simply interrupt request line (IRQ) assignments, I/O port addresses, DMA channel numbers, and memory addresses. The architecture of Configuration Manager allows hardware makers to invent their own resource types, as I'll show later on.</P>
<P>Configuration Manager represents a device's resource requirements by a list of resource descriptor structures, one for each resource that the device needs. A collection of several resource descriptors forms a "logical configuration." Theoretically, a device might have several logical configurations, some of which are better for performance or end-user convenience than others. The priority of the logical configuration (see <B>Figure 2</B>) encodes this assessment.</P>
<P><B> Figure 2  Priority Values for Logical Configurations</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="149pt" VALIGN="TOP"><COL WIDTH="293pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Priority</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_FORCECONFIG</P></TD><TD VALIGN="TOP"><P>Configuration manually selected by the user</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_BOOTCONFIG</P></TD><TD VALIGN="TOP"><P>Configuration established at boot-time by BIOS or card</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_DESIRED</P></TD><TD VALIGN="TOP"><P>Preferred configuration giving better performance</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_NORMAL</P></TD><TD VALIGN="TOP"><P>Configuration giving acceptable performance</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_SUBOPTIMAL</P></TD><TD VALIGN="TOP"><P>Workable configuration giving poor performance</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_RESTART</P></TD><TD VALIGN="TOP"><P>Configuration will require restarting Windows</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_REBOOT</P></TD><TD VALIGN="TOP"><P>Configuration will require soft reboot of computer</P></TD></TR><TR><TD VALIGN="TOP"><P> LCPRI_POWEROFF</P></TD><TD VALIGN="TOP"><P>Configuration will require hard reboot of computer</P></TD></TR><TR><TD VALIGN="TOP"><P> LPCRI_HARDRECONFIG</P></TD><TD VALIGN="TOP"><P>Configuration will require user to change a jumper</P></TD></TR><TR><TD VALIGN="TOP"><P> LPCRI_HARDWIRED</P></TD><TD VALIGN="TOP"><P>Only possible configuration</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The ability to have more than one logical configuration anticipates advances in hardware design. Eventually, you may see hardware that can operate in more than one mode depending on the availability of resources. For example, a video capture card might work best with mapped memory but might still operate (albeit more slowly) via DMA transfers. Such a device would have a DESIRED configuration that demands memory and a NORMAL or SUBOPTIMAL configuration that asks for a DMA channel in lieu of memory.</P>
<P>The enumerator that creates a DEVNODE should ordinarily also create the logical configuration(s) for the associated device. To continue along with the example I started last month, the School Bus enumerator might know that an attached Telepathic Input Device needs an IRQ in the range 0–7. It would tell Configuration Manager about this requirement by creating a logical configuration using code like that in <B>Figure 3</B>. CM_Create_DevNode creates a device node representing an attached Telepathic Input Device and stores the resulting DEVNODE address in the local device variable. CM_Add_Empty_Log_Conf creates a new (empty) logical configuration for the designated DEVNODE. Calls to CM_Add_Res_Des add resource descriptors to the logical configuration. This example indicates that the device needs an IRQ resource that can be satisfied by any of the IRQs described by the bit mask 0x00FF. That is, the device can use any IRQ in the range 0 through 7. You'll probably notice that I left out error checking after calls to CM_ADD_EMPLOY_LOG_CONF and CM_ADD_RES_DES. I originally did that because I thought the example was clearer without it. It turns out that a failure in either of these calls will leave the DEVNODE marked as having an out-of memory "problem."</P>
<P><B> Figure 3  Creating a Logical Configuration</B></P>
<P><BR></P>
<PRE> CONFIGRET CM_HANDLER OnEnumerate(CONFIGFUNC cf,
    SUBCONFIGFUNC scf, DEVNODE tonode, DEVNODE aboutnode,
    ULONG flags)
    {                           // OnEnumerate
    CONFIGRET code;

    switch (cf)
        {                       // select on function code

    case CONFIG_ENUMERATE:      // cf == 5
        {                       // CONFIG_ENUMERATE
        DEVNODE device;         // DEVNODE for device
        LOG_CONF logconf;       // logical configuration
        RES_DES resource;       // resource descriptor handle
        static IRQ_DES irq = {{0, 0, 0x00FF, 0}};

        code = CM_Create_DevNode(&amp;device, "SCHOOL\\WCO1234\\0000",tonode, 0);
        if (code == CR_ALREADY_SUCH_DEVNODE)
            return CR_SUCCESS;

        CM_Add_Empty_Log_Conf(&amp;logconf, device,
                              LCPRI_NORMAL,
                              BASIC_LOG_CONF | PRIORITY_EQUAL_LAST);
        CM_Add_Res_Des(&amp;resource, logconf, ResType_IRQ, &amp;irq, sizeof(irq), 0);

        return CR_SUCCESS;
        }                       // CONFIG_ENUMERATE

    default:
        return CR_DEFAULT;
        }                       // select on function code
    }                           // OnEnumerate</PRE>
<P></P>
<H2><A NAME="sec2"></A>  Building Resource Descriptors</H2><P><B>Figure 3</B> shows how an enumerator could create a logical configuration when the programmer knows at compile-time what resources the device requires. This would be a fairly unusual situation. Configuration requirements for legacy device normally appear in the LogConfig subkey of the device's hardware registry key. Windows Setup or the Device Installer puts them there based on configuration data in an INF file. The root enumerator uses the CM_Read_Registry_Log_Confs function to read them and convert them to Configuration Manager's internal format.</P>
<P><BR></P>
<PRE> CONFIGRET code = CM_Read_Registry_Log_Confs(devnode,0);
</PRE>
<P> </P>
<P>The ISA Plug and Play enumerator can read resource requirements directly from the Plug and Play cards. It then uses CM_ISAPNP_To_CM to convert the compressed data read from the cards into Configuration Manager's internal format. The EISA and PCI enumerators also have hardware-oriented methods to learn how the user has already configured cards attached to those buses.</P>
<P>Another situation worth mentioning is when the programmer decides to develop configuration information within the device driver. You might do this if you need to create the initial list requirements at run time. It turns out that Configuration Manager regards the configuration expressed in an INF file as immutable and doesn't allow it to be filtered at run time. To provide for dynamic changes to the requirements, therefore, you build logical configurations in the PNP_New_Devnode handler before you register your configuration function:</P>
<P> </P>
<P><BR></P>
<PRE> CM_Add_Empty_Log_Conf(...);
CM_Add_Res_Des(...);
                    .
                    .
                    .
CM_Register_Device_Driver(...);</PRE>
<P> </P>
<P>You must make these calls in this particular order because Configuration Manager may configure the device during the CM_Register_Device_Driver call.</P>
<P>Now I'll describe the format of the four standard resource descriptors. It's important to know that the descriptors are bidirectional in a sense. You tell Configuration Manager what resources you need by filling out a descriptor and attaching it to a logical configuration. Configuration Manager works internally with its own copies of descriptors in exactly the same format. You can later retrieve a pointer to one of Configuration Manager's internal resource descriptors by calling CM_Get_Next_Res_Des. </P>
<P>AnIRQ_DES structure describes a single IRQ:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct IRQ_DES_s
    {
    WORD  IRQD_Flags;      // 00 shared/unshared flags
    WORD  IRQD_Alloc_Num;  // 02 IRQ actually allocated
    WORD  IRQD_Req_Mask;   // 04 maskofacceptableIRQs
    WORD  IRQD_Reserved;   // 06 (reserved)
    } IRQ_DES;             // 08</PRE>
<P> </P>
<P>IRQD_Flags can have a value of fIRQD_Share to indicate that the device shares an IRQ or zero to indicate that the device needs an exclusive IRQ. IRQ_Req_Mask is a bit mask in which bit n is 1 if the device supports the use of IRQ n. A device that can handle any IRQ would use 0xFFFF for this parameter; a device that needs either IRQ 3 or IRQ 4 would use 0x0018. The IRQ_Alloc_Num field in one of Configuration Manager's internal IRQ descriptors eventually holds the IRQ actually assigned to the device.</P>
<P>A memory resource descriptor employs a MEM_DES structure immediately followed in memory by one or more MEM_RANGE structures:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct Mem_Des_s
    {
    WORD  MD_Count;      // 00 numberofMEM_RANGEs
    WORD  MD_Type;       // 02 alwaysequaltoMTypeRange
    ULONG MD_Alloc_Base; // 04 base of allocated memory
    ULONG MD_Alloc_End;  // 08 end of allocated memory
    WORD  MD_Flags;      // 0C flags
    WORD  MD_Reserved;   // 0E (reserved)
    } MEM_DES;           // 10

typedef struct Mem_Range_s
    {
    ULONG  MR_Align;     // 00 mask for base alignment
    ULONG  MR_nBytes;    // 04 byte count
    ULONG  MR_Min;       // 08 minimum address
    ULONG  MR_Max;       // 0C maximum address
    WORD   MR_Flags;     // 10 flags (same as MD_Flags)
    WORD   MR_Reserved;  // 12 (reserved)
    } MEM_RANGE;         // 14</PRE>
<P> </P>
<P>MD_Count is the number of MEM_RANGE structures that follow the MEM_DES structure in memory. MD_Type currently holds MTypeRange, which is just the size of a MEM_RANGE structure. MD_Flags can include one of fMD_ROM or fMD_RAM plus one of fMD_24 or fMD_32. Within each MEM_RANGE structure, MR_Align specifies how the allocated memory must be aligned. For example, 0xFFFFF000 denotes page (4096-byte boundary) alignment. MR_nBytes contains the byte length of the required memory area. MR_Min and MR_Max indicate bounds on the base address. To insist that the allocated memory be in the adapter region of memory between A000:0 and the start of the BIOS, for example, specify 0x000A0000 and 0x000EFFFF for the minimum and maximum values. MR_Flags and MR_Reserved should both be zero.</P>
<P>The MD_Alloc_Base and MD_Alloc_End fields in one of Configuration Manager's internal memory descriptors will eventually hold the starting and ending addresses of the assigned block.</P>
<P>The resource descriptor for I/O port addresses, like that for memory, uses a header structure followed by an array of range structures:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct IO_Des_s
    {
    WORD IOD_Count;       // 00 numberofIO_RANGEs
    WORD IOD_Type;        // 02 always IOType_Range
    WORD IOD_Alloc_Base;  // 04 allocated base address
    WORD IOD_Alloc_End;   // 06 allocated end of range
    WORD IOD_DesFlags;    // 08 flags
    BYTE IOD_Alloc_Alias; // 0A allocated alias offset
    BYTE IOD_Alloc_Decode;// 0B allocated decode mask
    } IO_DES;             // 0C</PRE>
<P> </P>
<P><BR></P>
<PRE> typedef struct IO_Range_s
    {
    WORD IOR_Align;       // 00 mask for base alignment
    WORD IOR_nPorts;      // 02number of ports needed
    WORD IOR_Min;         // 04lowestallowableaddress
    WORD IOR_Max;         // 06highestallowableaddress
    WORD IOR_RangeFlags;  // 08flags
    BYTE IOR_Alias;       // 0Aalias offset
    BYTE IOR_Decode;      // 0Balias decode mask
    } IO_RANGE;           // 0C</PRE>
<P> </P>
<P>The meaning of most of these fields is analogous to the similar fields in memory resource descriptors. For example, an ISA card needing 16 ports starting on a 16-byte boundary would specify the following:</P>
<P> </P>
<P><BR></P>
<PRE> IOR_Align = 0xFFF0;
IOR_nPorts = 16;
IOR_Min = 0x0100;
IOR_Max = 0x03FF;</PRE>
<P> </P>
<P>The Min and Max values follow from the fact that the standard ISA bus provides for only 10 bits of I/O port addressing and reserves address 00-FFH.</P>
<P>The DDK gives a confusing description of how to use the Alias and Decode fields to do a couple of different things. One use for these fields is to describe how many bits of I/O port address the card decodes. A standard ISA card, for example, decodes only the low-order 10 bits, meaning that addresses 3F8H, 7F8H, BF8H, and so on, are all equivalent ways of addressing the same physical hardware port. Other cards may use multiple addresses that happen to differ by 400H, 800H, or some other value larger than 1024 (210). This scheme is so complex that Microsoft is planning to change itforthesequelto Windows 95. The only settings you should use for these fields are those shown in <B>Figure 4</B>.</P>
<P><B> Figure 4  Possible Alias/Decode Settings for an I/O Resource</B></P>

<TABLE COLS="3" BORDER="0"><COLGROUP><COL WIDTH="63pt" VALIGN="TOP"><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="283pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Alias</B></P></TD><TD VALIGN="TOP"><P><B>Decode</B></P></TD><TD VALIGN="TOP"><P><B>Meaning</B></P></TD></TR><TR><TD VALIGN="TOP"><P> 0</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Card decodes all 16 bits of I/O address</P></TD></TR><TR><TD VALIGN="TOP"><P> 4</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Card decodes 10 bits of I/O address</P></TD></TR><TR><TD VALIGN="TOP"><P> 16</P></TD><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>Card decodes 12 bits of I/O address</P></TD></TR><TR><TD VALIGN="TOP"><P> 255</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>Card is a PCI card that can use ports that would otherwise be reserved as 10-bit synonyms for ISA card ports</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>One setting (Alias = 255, Decode = 0) requires special explanation. Normally, the I/O arbitrator automatically reserves all the 10-bit synonyms of any port address in recognition of the way ISA cards decode addresses. That is, if a card receives ports 3F8–3FFH, the arbitrator will normally not give any other card addresses like 7F8H–7FFH or BF8H–BFFH whose 10 low-order bits are the same. In a system with both a PCI and an ISA bus, the primary bus is the PCI bus, and the ISA bus is attached via a bridge. The ISA bus never sees I/O addresses bigger than 3FFH, which means that PCI cards can use the 10-bit synonym addresses with impunity. The special Alias/Decode setting of 255/0 tells the I/O arbitrator to assign port addresses without concern over 10-bit synonyms in order to take advantage of this feature of the PCI bus.</P>
<P>Finally, you indicate a DMA resource with a DMA_RES structure:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct DMA_Des_s
    {
    BYTE DD_Flags;          // 00 flags
    BYTE DD_Alloc_Chan;     // 01 allocated channel
    BYTE DD_Req_Mask;       // 02 mask for supported                            
                            // channels
    BYTE DD_Reserved;       // 03 (reserved)
    } DMA_RES;              // 04</PRE>
<P> </P>
<P>DD_Flags indicates the width of the required channel: fDD_BYTE, fDD_WORD, or fDD_DWORD. DD_Req_Mask indicates which channels can be used. For example, 0x60 indicates the ability to use channel 5 or 6. The number of the eventual channel assignment will appear in the DD_Alloc_Chan field of a Configuration Manager internal DMA descriptor.</P>
<P> </P>
<H2><A NAME="sec3"></A>  Resource Arbitrators</H2><P>Resource arbitration is the process by which Configuration Manager assigns resources to all of the devices that need them. Components known as "resource arbitrators" implement more-or-less elaborate algorithms for examining each device's needs and capabilities and for harmonizing those needs as far as possible. Microsoft provides arbitrators for the four standard resources (IRQ, DMA, port, and memory), and it exposes a great many APIs that are primarily useful to arbitrators. In fact, fifteen of the 81 Configuration Manager services listed in <B>Figure 1</B> are used only by resource arbitrators. These include eleven functions for manipulating range list objects that can be used to describe port or memory address ranges for the port and memory arbitrators.</P>
<P>Configuration Manager is extensible to other resource types beyond the standard four, too. To illustrate how this works, suppose the Telepathic Input Device needed a special Telepathic Channel, of which only a limited number are available on any system. As a responsible hardware vendor, I ask Microsoft to assign a 10-bit OEM identifier number to use in forming a resource identifier. Suppose that number were 0x10 (0 through 0x0F being reserved by Microsoft). I combine this number with a 5-bit index denoting a particular resource. If this were the sixth resource I ever defined (prolific, aren't I?), I'd end up with a resource identifier like this:</P>
<P> </P>
<P><BR></P>
<PRE> #define ResType_Telepath ((0x10 &lt;&lt; 5) | 5)</PRE>
<P> </P>
<P>Bit 15 of a resource identifier (0x8000) is ResType_Ignored_Bit and means that the resource so identified has no arbitrator. Bits 16–31 of a DWORD aren't used in resource identifiers. Microsoft doesn't believe very many vendors will ever be defining private resources, so the scheme I just outlined ought to provide sufficient flexibility.</P>
<P>I put the arbitrator for the Telepathic Channel resource into SCHOOL.VXD (see <B>Figure 5</B>) because it was convenient. During the initialization of this bus driver, the arbitrator is registered with Configuration Manager:</P>
<P> </P>
<P><BR></P>
<PRE> BOOL OnSysDynamicDeviceInit()
    {                         // OnSysDynamicDeviceInit
    CM_Register_Arbitrator(&amp;arbid, ResType_Telepath,
                           OnArbitrateTelepath, 0,
                           NULL, ARB_GLOBAL);
    return TRUE;
    }                         // OnSysDynamicDeviceInit</PRE>
<P> </P>
<P><B> Figure 5  SCHOOL.VXD</B></P>
<P></P>
<P>SCHOOL.MAK</P>
<P><BR></P>
<PRE> all: school.vxd telepath.vxd<BR><BR>.asm.obj:<BR>   ml -coff -DBLD_COFF -DIS_32 -W2 -Zd -c -Cx -DMASM6 -Zi \<BR>      -DDEBUG $*.asm<BR><BR>.c.obj:<BR>   cl -c -Gs -Zdpl -Od -D_X86_ -YX -W3 -DDEBLEVEL=1 \<BR>      -DBLD_COFF -DDEBUG -DIS_32 $*.c<BR><BR>school.vxd : s_ctl.obj $*.obj $*.def $*.res<BR>   link @&lt;&lt;<BR>-machine:i386 -def:$*.def -out:$@<BR>-debug -debugtype:map<BR>-map:$*.map -vxd vxdwraps.clb -nodefaultlib<BR>s_ctl.obj $*.obj<BR>&lt;&lt;<BR><BR>telepath.vxd: t_ctl.obj $*.obj $*.def<BR>   link @&lt;&lt;<BR>-machine:i386 -def:$*.def -out:$@<BR>-debug -debugtype:map<BR>-map:$*.map -vxd vxdwraps.clb -nodefaultlib<BR>t_ctl.obj $*.obj<BR>&lt;&lt;</PRE>
<P></P>
<P>SCHOOL.DEF</P>
<P><BR></P>
<PRE> VXD SCHOOL DYNAMIC<BR><BR>DESCRIPTION 'Sample Device'<BR><BR>SEGMENTS<BR>    _LPTEXT CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _LTEXT  CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _LDATA  CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _TEXT   CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _DATA   CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    CONST   CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _TLS    CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _BSS    CLASS 'LCODE'   PRELOAD NONDISCARDABLE<BR>    _MSGTABLE CLASS 'MCODE'   PRELOAD NONDISCARDABLE IOPL<BR>    _MSGDATA  CLASS 'MCODE'   PRELOAD NONDISCARDABLE IOPL<BR>    _IMSGTABLE CLASS 'MCODE'   PRELOAD DISCARDABLE IOPL<BR>    _IMSGDATA CLASS 'MCODE'   PRELOAD DISCARDABLE IOPL<BR>    _ITEXT    CLASS 'ICODE'   DISCARDABLE<BR>    _IDATA    LASS 'ICODE'   DISCARDABLE<BR>    _PTEXT    CLASS 'PCODE'   NONDISCARDABLE<BR>    _PDATA    CLASS 'PDATA'   NONDISCARDABLE SHARED<BR>    _STEXT    CLASS 'SCODE'   RESIDENT<BR>    _SDATA    CLASS 'SCODE'   RESIDENT<BR>    _DBOSTART CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING<BR>    _DBOCODE  CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING<BR>     DBODATA CLASS 'DBOCODE' PRELOAD NONDISCARDABLE CONFORMING<BR>    _16ICODE CLASS '16ICODE' PRELOAD DISCARDABLE<BR>    _RCODE   CLASS 'RCODE'<BR>EXPORTS<BR>        SCHOOL_DDB @1</PRE>
<P></P>
<P>S_CTL.ASM</P>
<P><BR></P>
<PRE>          .386p<BR>         include vmm.inc<BR>         include debug.inc<BR><BR>Declare_Virtual_Device SCHOOL, 1, 0, SCHOOL_Control, \<BR>        Undefined_Device_ID, Undefined_Init_Order<BR><BR>Begin_Control_Dispatch SCHOOL<BR><BR>    Control_Dispatch Sys_Dynamic_Device_Init,         \<BR>        _OnSysDynamicDeviceInit, cCall<BR>    Control_Dispatch Sys_Dynamic_Device_Exit,         \<BR>        _OnSysDynamicDeviceExit, cCall<BR>    Control_Dispatch PNP_New_Devnode, _OnPnpNewDevnode, \<BR>        cCall, &lt;ebx, edx&gt;<BR><BR>End_Control_Dispatch SCHOOL<BR><BR>         end</PRE>
<P></P>
<P>SCHOOL.C</P>
<P><BR></P>
<PRE> #define WANTVXDWRAPS<BR>#include &lt;basedef.h&gt;<BR>#include &lt;vmm.h&gt;<BR>#include &lt;debug.h&gt;<BR>#include &lt;vmmreg.h&gt;<BR>#include &lt;vwin32.h&gt;<BR>#include &lt;vxdwraps.h&gt;<BR>#include &lt;configmg.h&gt;<BR>#include &lt;regstr.h&gt;<BR><BR>#ifdef DEBUG<BR>    #define ASSERT(e) if(!(e))\<BR>        {Debug_Printf("Assertion failure in " __FILE__ \<BR>                      ", line %d: " #e "\r\n", __LINE__);\<BR>        _asm int 1\<BR>        }<BR>#else<BR>    #define ASSERT(e)<BR>#endif<BR><BR>#define ResType_Telepath ((0x10 &lt;&lt; 5) | 5)<BR><BR>typedef struct<BR>    {<BR>    int allocated;   // index of allocated channel (-1 =&gt; none)<BR>    ULONG requested; // mask for requested channels<BR>    } TELEPATH_RESOURCE;<BR><BR>#pragma CM_PAGEABLE_DATA<BR>#pragma CM_PAGEABLE_CODE<BR><BR>CONFIGRET CM_HANDLER OnEnumerate(CONFIGFUNC cf, CONFIGFUNC scf, DEVNODE tonode,
                                 DEVNODE aboutnode, ULONG flags);<BR>CONFIGRET CM_HANDLER OnArbitrateTelepath(ARBFUNC af, ULONG refdata,
                                         DEVNODE devnode, NODELIST_HEADER h);<BR><BR>REGISTERID arbid;<BR><BR>BOOL OnSysDynamicDeviceInit()<BR>    {                           // OnSysDynamicDeviceInit<BR>    CM_Register_Arbitrator(&amp;arbid, ResType_Telepath, OnArbitrateTelepath, 0,
                           NULL, ARB_GLOBAL);<BR>    return TRUE;<BR>    }                           // OnSysDynamicDeviceInit<BR><BR>BOOL OnSysDynamicDeviceExit()<BR>    {                           // OnSysDynamicDeviceExit<BR>    if (arbid)<BR>        CM_Deregister_Arbitrator(arbid, 0);<BR>    return TRUE;<BR>    }                           // OnSysDynamicDeviceExit<BR><BR>CONFIGRET OnPnpNewDevnode(DEVNODE devnode, DWORD loadtype)<BR>    {                           // OnPnpNewDevnode<BR>    CONFIGRET code;<BR>    switch (loadtype)<BR>        {                       // select function to perform<BR><BR>    case DLVXD_LOAD_DEVLOADER:  // loadtype == 1<BR>        code = CM_Register_Enumerator(devnode, OnEnumerate,
                                      CM_REGISTER_ENUMERATOR_HARDWARE);<BR>        if (code != CR_SUCCESS)<BR>            return code;<BR>        return CM_Register_Device_Driver(devnode, NULL, 0,<BR>                                         CM_REGISTER_DEVICE_DRIVER_REMOVABLE);<BR><BR>        }                       // select function to perform<BR><BR>    return CR_DEFAULT;<BR>    }                           // OnPnpNewDevnode<BR><BR>CONFIGRET CM_HANDLER OnEnumerate(CONFIGFUNC cf, SUBCONFIGFUNC scf, 
                                 DEVNODE tonode, DEVNODE aboutnode,<BR>    ULONG flags)<BR>    {                           // OnEnumerate<BR>    CONFIGRET code;<BR><BR>#ifdef DEBUG<BR>    char toid[MAX_DEVICE_ID_LEN], aboutid[MAX_DEVICE_ID_LEN];<BR>    DEBUG_CONFIG_NAMES<BR>    char *subfunc = "";<BR>    static char *substart[] = {"DYNAMIC_START", "FIRST_START"};<BR>    static char *substop[] = {"DYNAMIC_STOP", "HAS_PROBLEM"};<BR>    static char *subremove[] = {"DYNAMIC", "SHUTDOWN", "REBOOT"};<BR>    static char *subtest[] = {"CAN_STOP", "CAN_REMOVE"};<BR>    static char *subapm[] = {"TEST_STANDBY", "TEST_SUSPEND",
                             "TEST_STANDBY_FAILED", "TEST_SUSPEND_FAILED",<BR>                             "TEST_STANDBY_SUCCEEDED","TEST_SUSPEND_SUCCEEDED",<BR>                             "RESUME_STANDBY", "RESUME_SUSPEND",
                             "RESUME_CRITICAL", "UI_ALLOWED"};<BR><BR>    CM_Get_Device_ID(tonode, toid, sizeof(toid), 0);<BR>    CM_Get_Device_ID(aboutnode, aboutid, sizeof(aboutid), 0);<BR>    switch (cf)<BR>        {                       // get subfunction name<BR>    case CONFIG_START:<BR>        subfunc = substart[scf];<BR>        break;<BR>    case CONFIG_STOP:<BR>        subfunc = substop[scf];<BR>        break;<BR>    case CONFIG_REMOVE:<BR>        subfunc = subremove[scf];<BR>        break;<BR>    case CONFIG_TEST:<BR>        subfunc = subtest[scf];<BR>        break;<BR>    case CONFIG_APM:<BR>        subfunc = subapm[scf];<BR>        break;<BR>        }                       // get subfunction name<BR>    if (cf &lt; NUM_CONFIG_COMMANDS)<BR>        Debug_Printf("SCHOOL ENUMERATOR: %s(%s), to %s, about %s\r\n",<BR>                     lpszConfigName[cf], subfunc, toid, aboutid);<BR>    else<BR>        Debug_Printf("SCHOOL ENUMERATOR: %X(%X), to %s, about %s\r\n",<BR>                     cf, toid, aboutid);<BR>#endif<BR><BR>    switch (cf)<BR>        {                       // select on function code<BR><BR>case CONFIG_SETUP:<BR>        {                       // CONFIG_SETUP<BR>        ULONG length;           // length of class name<BR>        char class[64];         // device class<BR><BR>        length = sizeof(class);<BR>        code = CM_Read_Registry_Value(aboutnode, NULL, "Class", REG_SZ, class,
                                      &amp;length, CM_REGISTRY_HARDWARE);<BR>        if (code == CR_NO_SUCH_VALUE)<BR>            {                   // new device<BR>            CM_Write_Registry_Value(aboutnode, NULL, "Class", REG_SZ, "System",
                                    6, CM_REGISTRY_HARDWARE);<BR>            CM_Write_Registry_Value(aboutnode, NULL, "HardwareID", REG_SZ,
                                    "WCO1234", 6, CM_REGISTRY_HARDWARE);<BR>            }                   // new device<BR>        return CR_SUCCESS;<BR>        }                       // CONFIG_SETUP<BR><BR>    case CONFIG_ENUMERATE:      // cf == 5<BR>        {                       // CONFIG_ENUMERATE<BR>        DEVNODE device;         // DEVNODE for device<BR>        ULONG length;           // length of class name<BR>        char class[64];         // device class<BR>        LOG_CONF logconf;       // logical configuration<BR>        RES_DES resource;       // resource descriptor handle<BR><BR>        static IRQ_RESOURCE irq = {{0, 0, 0xFFFF, 0}};<BR>        static TELEPATH_RESOURCE telepath = {-1, 0xFF};<BR><BR>        code = CM_Create_DevNode(&amp;device, "SCHOOL\\WCO1234\\0000", tonode, 0);<BR>        if (code == CR_ALREADY_SUCH_DEVNODE)<BR>            return CR_SUCCESS;<BR><BR>        CM_Add_Empty_Log_Conf(&amp;logconf, device, LCPRI_NORMAL,<BR>            BASIC_LOG_CONF | PRIORITY_EQUAL_LAST);<BR>        CM_Add_Res_Des(&amp;resource, logconf, ResType_IRQ, &amp;irq, sizeof(irq), 0);<BR>        CM_Add_Res_Des(&amp;resource, logconf, ResType_Telepath, &amp;telepath,
                       sizeof(telepath), 0);<BR><BR>        return CR_SUCCESS;<BR>        }                       // CONFIG_ENUMERATE<BR><BR>    default:<BR>        return CR_DEFAULT;<BR>        }                       // select on function code<BR>    }                           // OnEnumerate<BR><BR>///////////////////////////////////////////////////////////////
// Telepathic I/O channel resource arbitrator<BR>typedef struct nodelistheader_s *NODELISTHEADER;<BR>typedef struct nodelist_s *PNODE;<BR><BR>typedef struct<BR>    {                           // allocation placeholder<BR>    PNODE node;                 // current node<BR>    TELEPATH_RESOURCE* pres;    // current resource descriptor<BR>    } ALLOCPLACE, *PALLOCPLACE; // allocation placeholder<BR><BR>int bitcount(ULONG mask)<BR>    {                           // bitcount<BR>    int nbits = 0;<BR>    while (mask)<BR>        {                       // count bits<BR>        if (mask &amp; 1)<BR>            ++nbits;<BR>        mask &gt;&gt;= 1;<BR>        }                       // count bits<BR>    return nbits;<BR>    }                           // bitcount<BR><BR>void sortnodes(NODELISTHEADER h)<BR>    {                           // sortnodes<BR>    PNODE node = h-&gt;nlh_Head;<BR>    while (node)<BR>        {                       // for each node<BR>        RES_DES hres = (RES_DES) node-&gt;nl_Test_Req;<BR>        #define pres ((TELEPATH_RESOURCE *) hres)<BR><BR>        node-&gt;nl_ulSortDWord = 0;<BR>        while (CM_Get_Next_Res_Des(&amp;hres, hres, ResType_Telepath, NULL, 0) ==
                                                                     CR_SUCCESS)<BR>            node-&gt;nl_ulSortDWord += bitcount(pres-&gt;requested);<BR>        node = node-&gt;nl_Next;<BR><BR>        #undef pres<BR>        }                       // for each node<BR>    CM_Sort_NodeList((NODELIST_HEADER) h, 0);<BR>    }                           // sortnodes<BR><BR>void release(NODELISTHEADER h, PULONG pmap)<BR>    {                           // release<BR>    PNODE node = h-&gt;nlh_Head;<BR>    while (node)<BR>        {                       // for each node<BR>        LOG_CONF logconf;<BR><BR>        if (CM_Get_First_Log_Conf(&amp;logconf,(DEVNODE) node-&gt;nl_ItsDevNode,
                                  ALLOC_LOG_CONF)== CR_SUCCESS)<BR>            {                   // release channel(s)<BR>            RES_DES hres = (RES_DES) logconf;<BR>            #define pres ((TELEPATH_RESOURCE *) hres)<BR>            while (CM_Get_Next_Res_Des(&amp;hres, hres, ResType_Telepath, NULL, 0)
                                                                 == CR_SUCCESS)<BR>                if (pres-&gt;allocated &gt;= 0)<BR>                    *pmap |= 1 &lt;&lt; pres-&gt;allocated; <BR>            #undef pres<BR>            }                   // release channel(s)<BR>        node = node-&gt;nl_Next;<BR>        }                       // for each node<BR>    }                           // release<BR><BR>BOOL nextres(PALLOCPLACE p)<BR>    {                           // nextres<BR>    ASSERT(p-&gt;node &amp;&amp; p-&gt;node-&gt;nl_Test_Req);<BR>    if (!p-&gt;pres)<BR>        p-&gt;pres = (TELEPATH_RESOURCE *) p-&gt;node-&gt;nl_Test_Req;<BR>    while (CM_Get_Next_Res_Des((RES_DES*) &amp;p-&gt;pres, (RES_DES) p-&gt;pres,
           ResType_Telepath, NULL, 0) != CR_SUCCESS)<BR>        {                       // no more of our resource<BR>        if (!(p-&gt;node = p-&gt;node-&gt;nl_Next))<BR>            return FALSE;       // no more nodes in the list<BR>        p-&gt;pres = (TELEPATH_RESOURCE *) p-&gt;node-&gt;nl_Test_Req;<BR>        }                       // no more of our resource<BR>    return TRUE;<BR>    }                           // nextres<BR><BR>BOOL allocate(PALLOCPLACE p, PULONG pmap)<BR>    {                           // allocate<BR>    int channel;<BR><BR>    if (!nextres(p))<BR>        return TRUE;<BR><BR>    for (p-&gt;pres-&gt;allocated = -1, channel = 0; channel &lt; 32; ++channel)<BR>        {                       // try to allocate a channel<BR>        ALLOCPLACE place = *p;<BR>        ULONG mask = 1 &lt;&lt; channel;<BR>        ULONG tempmap = *pmap;<BR>        if ( !(tempmap &amp; mask)  ||  !(place.pres-&gt;requested &amp; mask) )<BR>            continue;<BR>        tempmap &amp;= ~mask;       // do trial allocation<BR>        if (allocate(&amp;place, &amp;tempmap))<BR>            {                   // successful allocation<BR>            *pmap = tempmap;<BR>            p-&gt;pres-&gt;allocated = channel;<BR>            return TRUE;<BR>            }                   // successful allocation<BR>        }                       // try to allocate a channel<BR>    }                           // allocate<BR><BR>BOOL reallocate(NODELISTHEADER h, PULONG pmap, BOOL forced)<BR>    {                           // reallocate<BR>    PNODE node = h-&gt;nlh_Head;<BR>    <BR>    while (node)<BR>        {                       // for each node<BR>        RES_DES hres = (RES_DES) node-&gt;nl_Test_Req;<BR>        #define pres ((TELEPATH_RESOURCE *) hres)<BR><BR>        while (CM_Get_Next_Res_Des(&amp;hres, hres,ResType_Telepath, NULL, 0) ==
                                                                     CR_SUCCESS)<BR>            {                   // requires our resource<BR>            ULONG mask;<BR><BR>            ASSERT(pres-&gt;allocated &gt;= 0);<BR>            mask = 1 &lt;&lt; pres-&gt;allocated;<BR>            if ((*pmap &amp; mask) &amp;&amp; !forced)<BR>                return FALSE;    // one or more still in use<BR>            *pmap &amp;= ~mask;<BR>            }                   // requires our resource<BR>        node = node-&gt;nl_Next;<BR><BR>        #undef pres<BR>        }                       // for each node<BR>    return TRUE;<BR>    }                           // reallocate<BR><BR>CONFIGRET CM_HANDLER OnArbitrateTelepath(ARBFUNC af, ULONG refdata,
                                         DEVNODE devnode, NODELIST_HEADER h)<BR>    {                           // OnArbitrateTelepath<BR>    static ULONG free_map = 0xFF; // real allocation map<BR>    static ULONG free_copy = 0xDEADBEEF; // copy of map<BR><BR>    switch (af)<BR>        {                       // select on function<BR><BR>    case ARB_TEST_ALLOC:        // af == 0<BR>        {                       // ARB_TEST_ALLOC<BR>        ALLOCPLACE place = {((NODELISTHEADER)h)-&gt;nlh_Head, NULL};<BR>        sortnodes((NODELISTHEADER) h);<BR>        free_copy = free_map;<BR>        release((NODELISTHEADER) h, &amp;free_copy);<BR><BR>        if (allocate(&amp;place, &amp;free_copy))<BR>            return CR_SUCCESS;<BR>        else<BR>            return CR_FAILURE;<BR>        }                       // ARB_TEST_ALLOC<BR><BR>    case ARB_RETEST_ALLOC:      // af == 1<BR>    case ARB_FORCE_ALLOC:       // af == 6<BR>        free_copy = free_map;<BR>        release((NODELISTHEADER) h, &amp;free_copy);<BR><BR>        if (reallocate((NODELISTHEADER) h, &amp;free_copy, af == ARB_FORCE_ALLOC))<BR>            return CR_SUCCESS;<BR>        else<BR>            return CR_FAILURE;<BR><BR>    case ARB_SET_ALLOC:         // af == 2<BR>        ASSERT(free_copy != 0xDEADBEEF);<BR>        free_map = free_copy;<BR>        free_copy = 0xDEADBEEF;<BR>        return CR_SUCCESS;<BR><BR>    case ARB_RELEASE_ALLOC:     // af == 3<BR>        free_copy = 0xDEADBEEF;<BR>        return CR_SUCCESS;<BR><BR>    case ARB_QUERY_FREE:        // af == 4<BR>        {                       // ARB_QUERY_FREE<BR>        struct arbitfree_s *p = (struct arbitfree_s *) h;<BR>        p-&gt;af_SizeOfInfo = sizeof(ULONG);<BR>        p-&gt;af_PointerToInfo = (PVOID*) &amp;free_map;<BR>        return CR_SUCCESS;<BR>        }                       // ARB_QUERY_FREE<BR><BR>    case ARB_REMOVE:            // af == 5<BR>        return CR_SUCCESS;<BR><BR>    default:<BR>        return CR_DEFAULT;<BR>        }                       // select on function<BR>    }                           // OnArbitrateTelepath</PRE>
<P></P>
<P>TELEPATH.DEF</P>
<P></P>
<P>T_CTL.ASM</P>
<P> These two files are essentially the same as SCHOOL.DEF and S_CTL.ASM, respectively. SCHOOL.MAK also builds TELEPATH.VXD.</P>
<P></P>
<P>TELEPATH.C</P>
<P><BR></P>
<PRE> #define WANTVXDWRAPS<BR>#include &lt;basedef.h&gt;<BR>#include &lt;vmm.h&gt;<BR>#include &lt;debug.h&gt;<BR>#include &lt;vmmreg.h&gt;<BR>#include &lt;vxdwraps.h&gt;<BR>#include &lt;configmg.h&gt;<BR>#include &lt;regstr.h&gt;<BR><BR>static BYTE irq;            // allocated IRQ<BR><BR>CONFIGRET OnConfigure(CONFIGFUNC cf, SUBCONFIGFUNC scf, DEVNODE devnode,
                      DWORD refdata, ULONG flags);<BR><BR>BOOL OnSysDynamicDeviceInit()<BR>    {                           // OnSysDynamicDeviceInit<BR>    return TRUE;<BR>    }                           // OnSysDynamicDeviceInit<BR><BR>BOOL OnSysDynamicDeviceExit()<BR>    {                           // OnSysDynamicDeviceExit<BR>    return TRUE;<BR>    }                           // OnSysDynamicDeviceExit<BR><BR>CONFIGRET OnPnpNewDevnode(DEVNODE devnode, DWORD loadtype)<BR>    {                           // OnPnpNewDevnode<BR>    switch (loadtype)<BR>        {                       // select function to perform<BR><BR>    case DLVXD_LOAD_DEVLOADER:      // loadtype == 2<BR>        return CM_Register_Device_Driver(devnode, OnConfigure, 0,<BR>                                         (CM_REGISTER_DEVICE_DRIVER_REMOVABLE |
                                          CM_REGISTER_DEVICE_DRIVER_DISABLEABLE));<BR>        }                       // select function to perform<BR><BR>    return CR_DEFAULT;<BR>    }                           // OnPnpNewDevnode<BR><BR>CONFIGRET OnConfigure(CONFIGFUNC cf, SUBCONFIGFUNC scf, DEVNODE devnode,
                      DWORD refdata, ULONG flags)<BR>    {                           // OnConfigure<BR><BR>#ifdef DEBUG<BR>    char id[MAX_DEVICE_ID_LEN];<BR>    DEBUG_CONFIG_NAMES<BR>    char *subfunc = "";<BR>    static char *substart[] = {"DYNAMIC_START", "FIRST_START"};<BR>    static char *substop[] = {"DYNAMIC_STOP", "HAS_PROBLEM"};<BR>    static char *subremove[] = {"DYNAMIC", "SHUTDOWN",<BR>        "REBOOT"};<BR>    static char *subtest[] = {"CAN_STOP", "CAN_REMOVE"};<BR>    static char *subapm[] ={"TEST_STANDBY", "TEST_SUSPEND",
                            "TEST_STANDBY_FAILED", "TEST_SUSPEND_FAILED",<BR>                            "TEST_STANDBY_SUCCEEDED", "TEST_SUSPEND_SUCCEEDED",<BR>                            "RESUME_STANDBY", "RESUME_SUSPEND",
                            "RESUME_CRITICAL", "UI_ALLOWED"};<BR><BR>    switch (cf)<BR>        {                       // get subfunction name<BR>    case CONFIG_START:<BR>        subfunc = substart[scf];<BR>        break;<BR>    case CONFIG_STOP:<BR>        subfunc = substop[scf];<BR>        break;<BR>    case CONFIG_REMOVE:<BR>        subfunc = subremove[scf];<BR>        break;<BR>    case CONFIG_TEST:<BR>        subfunc = subtest[scf];<BR>        break;<BR>    case CONFIG_APM:<BR>        subfunc = subapm[scf];<BR>        break;<BR>        }                       // get subfunction name<BR><BR>    CM_Get_Device_ID(devnode, id, sizeof(id), 0);<BR>    if (cf &lt; NUM_CONFIG_COMMANDS)<BR>        Debug_Printf("TELEPATH DRIVER: %s(%s), %s\r\n", lpszConfigName[cf],
                     subfunc, id);<BR>    else<BR>        Debug_Printf("TELEPATH DRIVER: %X(%X), %s\r\n", cf, scf, id);<BR>#endif<BR><BR>    switch (cf)<BR>        {                       // select on function code<BR><BR>    case CONFIG_START:          // cf == 1<BR>        {                       // CONFIG_START<BR><BR>        CMCONFIG config;<BR>        CM_Get_Alloc_Log_Conf(&amp;config, devnode, CM_GET_ALLOC_LOG_CONF_ALLOC);<BR>        irq = config.bIRQRegisters[0];<BR><BR>        {<BR>        #define ResType_Telepath ((0x10 &lt;&lt; 5) | 5)<BR><BR>        typedef struct<BR>            {                    // telepath resource<BR>            ULONG allocated;     // mask for allocated channel<BR>            ULONG requested;     // mask for requested channels<BR>            } TELEPATH_RESOURCE; // telepath resource<BR><BR>        LOG_CONF logconf;<BR>        RES_DES hres;<BR>        #define pres ((TELEPATH_RESOURCE*) hres)<BR><BR>        CM_Get_First_Log_Conf(&amp;logconf, devnode, ALLOC_LOG_CONF);<BR>        if (CM_Get_Next_Res_Des(&amp;hres, (RES_DES) logconf, ResType_Telepath,
                                                        NULL, 0) == CR_SUCCESS)<BR>            {                       // has telepath channel<BR>            // do something with pres-&gt;allocated<BR>            }                       // has telepath channel<BR><BR>        #undef pres<BR>        }<BR><BR>        // Here we would initialize the device, doing things<BR>        // like VPICD_Virtualize_IRQ, etc.<BR><BR>        return CR_SUCCESS;<BR>        }                       // CONFIG_START<BR><BR>    case CONFIG_REMOVE:         // cf == 4<BR>    case CONFIG_STOP:           // cf == 2<BR>        <BR>        irq = 255;<BR>        return CR_SUCCESS;<BR><BR>    default:<BR>        return CR_DEFAULT;<BR>        }                       // select on function code<BR>    }                           // OnConfigure
</PRE>
<P></P>
<P>This registers OnArbitrateTelepath as the resource arbitration function for the resource and saves an arbitrator identifier in the REGISTERID variable named arbid. This identifier is used as the driver is unloaded to deregister the arbitrator:</P>
<P> </P>
<P><BR></P>
<PRE> BOOL OnSysDynamicDeviceExit()
    {                         // OnSysDynamicDeviceExit
    if (arbid)
        CM_Deregister_Arbitrator(arbid, 0);
    return TRUE;
    }                         // OnSysDynamicDeviceExit</PRE>
<P> </P>
<P>The previous code fragment registers a global arbitrator for a resource that might be used by many different devices. In most cases where you define private resources, you will probably register a local arbitrator for a resource that's specific to a bus or other single DEVNODE. To do this, use ARB_LOCAL as the last argument to CM_Register_Arbitrator and supply the DEVNODE address as the next-to-last argument. One advantage of using a local arbitrator is that Configuration Manager will automatically deregister the arbitration function if it removes the DEVNODE, thereby saving you the trouble of remembering to do so.</P>
<P>An arbitration function looks something like this:</P>
<P> </P>
<P><BR></P>
<PRE> CONFIGRETOnArbitrateTelepath(ARBFUNC af,ULONGrefdata,
                             DEVNODE devnode, 
                             NODELIST_HEADER h)
    {                           // OnArbitrateTelepath
    switch (af)
        {                       // select on function</PRE>
<P> .</P>
<P>.</P>
<P>.</P>
<P><BR></P>
<PRE>         }                       // select on function
    }                           // OnArbitrateTelepath</PRE>
<P> </P>
<P>The af arbitration function is one of those listed in <B>Figure 6</B>, refdata is whatever reference data was supplied as the fourth argument to Register_Arbitrator (zero in the example), devnode is whatever DEVNODE was the fifth argument to Register_Arbitrator, and h is a pointer to a struct nodelistheader_s that in turn points to the head and tail of a list describing the device nodes needing configuration (see <B>Figure 7</B>). Each node in the list points to a DEVNODE and to a logical configuration. The logical configuration in turn contains resource descriptors, some of which may be for the resource you're arbitrating. The function should return CR_SUCCESS for all of the standard function codes unless there's really an error, but should return CR_DEFAULT for any unknown function code. Configuration Manager can use the CR_DEFAULT return to test version compatibility in future releases of Windows.</P>
<P><B> Figure 6  Arbitrator Function Codes</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="131pt" VALIGN="TOP"><COL WIDTH="311pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Function Code</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_TEST_ALLOC</P></TD><TD VALIGN="TOP"><P>Perform trial allocation of resource</P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_RETEST_ALLOC</P></TD><TD VALIGN="TOP"><P>Verify previous trial allocation</P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_FORCE_ALLOC</P></TD><TD VALIGN="TOP"><P>Retest but don't fail previous trial allocation</P></TD></TR><TR><TD VALIGN="TOP"><P> ARG_SET_ALLOC</P></TD><TD VALIGN="TOP"><P>Commit previous trial allocation</P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_RELEASE_ALLOC</P></TD><TD VALIGN="TOP"><P>Discard previous trial allocation</P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_QUERY_FREE</P></TD><TD VALIGN="TOP"><P>Return information about free resources</P></TD></TR><TR><TD VALIGN="TOP"><P> ARB_REMOVE</P></TD><TD VALIGN="TOP"><P>Prepare for removal of arbitrator</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B> Figure 7  nodelistheader_s and nodelist_s Structures</B></P>
<P><BR></P>
<PRE> struct nodelistheader_s
    {                               // node list header
    struct nodelist_s* nlh_Head;    // 00 head of list
    struct nodelist_s* nlh_Tail;    // 04 tail of list
    };                              // 08 node list header

struct nodelist_s
    {                                // node list element
    struct nodelist_s* nl_Next;      // 00 chain to next element
    struct nodelist_s* nl_Prev;      // 04 chain to previous element
    struct devnode_s* nl_ItsDevNode; // 08 a device node that needs resources
    struct Log_Conf* nl_Test_Req;    // 0C a logical configuration for that 
                                     // DEVNODE
    ULONG nl_ulSortDWord;            // 10 sort order for CM_Sort_NodeList
    };                               // 14 node list element</PRE>
<P>The basic resource assignment algorithm uses the TEST function to perform trial allocations for a list of logical configurations. Once all arbitrators have generated a working set of assignments, Configuration Manager performs a SET function to make the trial allocations permanent. I can best explain how to implement the TEST function by describing the sample:</P>
<P> </P>
<P><BR></P>
<PRE> case ARB_TEST_ALLOC:        // af == 0
    {                       // ARB_TEST_ALLOC
    ALLOCPLACE place = {((NODELISTHEADER)h)-&gt;nlh_Head,
                         NULL};
    sortnodes((NODELISTHEADER) h);
    free_copy = free_map;
    release((NODELISTHEADER) h, &amp;free_copy);</PRE>
<P> </P>
<P><BR></P>
<PRE>     if (allocate(&amp;place, &amp;free_copy))
        return CR_SUCCESS;
    else
        return CR_FAILURE;
    }                       // ARB_TEST_ALLOC</PRE>
<P> </P>
<P>The ALLOCPLACE structure is one I defined so my "nextres" helper function can keep track of which resource descriptor is currently under consideration. That function steps from one telepathic resource descriptor to the next within a given DEVNODE's trial logical configuration and from one DEVNODE to the next.</P>
<P>The sortnodes helper function sorts the linked list of NODELIST elements. This is not as hard as it sounds because Configuration Manager exports a service function to do most of the work. The arbitrator walks the node list and sets the nl_ulSortDWord fields to an ordinal value indicating how easy or hard it will be to satisfy the demands of the device represented by the node. In this simple example, it's reasonable to use a sorting ordinal equal to the number of different channels the device is able to use. Fussier devices end up with lower ordinals than more flexible devices. Then the arbitrator calls CM_SortNodeList to sort the list based on the ordinals.</P>
<P>The release helper function releases the telepath resources currently used by the devices in the node list. This function should work with the allocated logical configuration (if any) belonging to each of the DEVNODEs in the node list. Since I'm performing a trial allocation, I actually operate on a copy of whatever data structure describes the current (real) allocation. A simple bit map indicating which of 32 possible channels is currently free suffices for this resource. Therefore, making a copy of the current allocation amounts to a simple assignment statement.</P>
<P>The allocate helper function walks through the node list in an attempt to simultaneously satisfy the demands of all devices. These demands are stated in one or more of the resource descriptors attached to a logical configuration for the devices. Configuration Manager can, in general, call the arbitrator once for each permutation of logical configurations for all devices. I used an algorithm that selects the next possible channel for a given resource descriptor and then recursively calls allocate to attempt to satisfy all remaining resource demands. In a perfect world, allocate will always succeed and return TRUE. Configuration Manager will then issue an SET request to commit the trial allocation:</P>
<P> </P>
<P><BR></P>
<PRE> case ARB_SET_ALLOC:         // af == 2
    free_map = free_copy;
    free_copy = 0xDEADBEEF;
    return CR_SUCCESS;</PRE>
<P> </P>
<P>The mildly odoriferous constant 0xDEADBEEF is traditionally used in Configuration Manager programming to indicate an uninitialized variable.</P>
<P>In the imperfect real world, it won't always be possible to satisfy every device. You might have two devices that can only use channel number zero. In such a case, allocate will return FALSE and the arbitrator will fail the test allocation by returning CR_FAILURE. Configuration Manager will issue a RELEASE request to allow the arbitrator to discard the now-useless trial allocation, and it will then attempt trial allocations using any alternative logical configurations that may exist. If no allocation is possible, Configuration Manager will disable one of the devices. Device Manager will report the conflict so the user understands why the disabled device can't be used.</P>
<P>There are two other arbitration functions that result in trial allocations: RETEST and FORCE. To implement RETEST, the arbitrator loops over all the resource descriptors just as it would for a TEST function. These descriptors are left over from boot-time assignment or from some previous TEST function, however, so they should record a resource assignment. RETEST therefore checks to see if the assigned resource is free in the trial allocation map and, if so, reassigns it. The most common use of RETEST is to record the configuration with which the device booted and find out whether the boot configuration contains inherent conflicts. Another use is to return to a suboptimal configuration that Configuration Manager found but bypassed in a failed attempt to find a better one. Configuration Manager also sends RETEST and SET requests with no trial logical configurations just to release the currently allocated resources.</P>
<P>FORCE works the same way as RETEST but must not fail. An arbitrator receives a FORCE request when the end user forces a particular resource choice through the Control Panel. The end user is in charge and may force you to assign resources in a particular way even though doing so doesn't make obvious sense. The ability to force a configuration provides an important safety valve in a potentially rigid automated environment, but can also allow a naive user to make mistakes.</P>
<P>Since neither RETEST nor FORCE examines any alternative assignments, there's no point in sorting the node list.</P>
<H2><A NAME="sec4"></A>  The Configuration Function</H2><P>Once Configuration Manager has figured out how to assign resources to the hardware, the device drivers' configuration functions come into their own. It's this function that differentiates well-behaved Windows 95 device drivers from drivers in earlier versions of Windows. The main purpose of the function is to initialize the driver and the hardware to use newly assigned resources. Configuration Manager also calls the configuration function to handle a variety of other events (see <B>Figure 8</B>). </P>
<P><B> Figure 8  Configuration Functions for Device Drivers</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="167pt" VALIGN="TOP"><COL WIDTH="275pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Function</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_APM</P></TD><TD VALIGN="TOP"><P>Power management event is occurring</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_CALLBACK</P></TD><TD VALIGN="TOP"><P>Someone did a CM_CallBack_-Device_Driver</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_FILTER</P></TD><TD VALIGN="TOP"><P>Filter (restrict) logical configurations</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_PREREMOVE</P></TD><TD VALIGN="TOP"><P>Prepare for removal of device</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_PREREMOVE2</P></TD><TD VALIGN="TOP"><P>Prepare for removal of device</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_PRESHUTDOWN</P></TD><TD VALIGN="TOP"><P>System is about to shut down</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_REMOVE</P></TD><TD VALIGN="TOP"><P>Device is being removed from the system</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_SHUTDOWN</P></TD><TD VALIGN="TOP"><P>System is shutting down</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_START</P></TD><TD VALIGN="TOP"><P>Start using the allocated configuration</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_STOP</P></TD><TD VALIGN="TOP"><P>Stop using the current configuration</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_TEST</P></TD><TD VALIGN="TOP"><P>Can you stop using configuration, or can you be removed?</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_TEST_FAILED</P></TD><TD VALIGN="TOP"><P>Previous CONFIG_TEST failed</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_TEST_SUCCEEDED</P></TD><TD VALIGN="TOP"><P>Previous CONFIG_TEST succeeded</P></TD></TR><TR><TD VALIGN="TOP"><P> CONFIG_VERIFY_DEVICE</P></TD><TD VALIGN="TOP"><P>Is your legacy card present?</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The CONFIG_START event is where all the action is. Configuration Manager calls the configuration function to process this event after assigning resources. The first job of the function is to determine which resources it now owns. If the device only uses the standard four resources, one function call will suffice (see <B>Figure 9</B>). In <B>Figure 9</B>, CM_Get_Alloc_Log_Conf retrieves information about the allocated logical configuration into a CMCONFIG structure (see <B>Figure 10</B>). This structure records up to nine memory base addresses and lengths, up to twenty I/O base addresses and counts, up to seven IRQ numbers and flags, and up to seven DMA channel numbers and attributes. In the example, the TELEPATH driver extracts its IRQ assignment from the expected first element of the bIRQRegisters array.</P>
<P><B> Figure 9  Getting a Device's Configuration</B></P>
<P><BR></P>
<PRE> CONFIGRET OnConfigure(CONFIGFUNC cf, SUBCONFIGFUNC scf,
    DEVNODE devnode, DWORD refdata, ULONG flags)
    {                           // OnConfigure
    switch (cf)
        {                       // select on function code

    case CONFIG_START:          // cf == 1
        {                       // CONFIG_START
        CMCONFIG config;
        CM_Get_Alloc_Log_Conf(&amp;config, devnode,
                              CM_GET_ALLOC_LOG_CONF_ALLOC);
        irq = config.bIRQRegisters[0]; // for example
        // [virtualize IRQ and do other initialization]
        return CR_SUCCESS;
        }                       // CONFIG_START
    
    default:
        return CR_DEFAULT;
        }                       // select on function code
    }                           // OnConfigure</PRE>
<P></P>
<P><B> Figure 10  CMCONFIG Structure</B></P>
<P><BR></P>
<PRE> typedef struct Config_Buff_s {
WORD    wNumMemWindows;                 // 00 Num memory windows
DWORD   dMemBase[MAX_MEM_REGISTERS];    // 02 Memory window base [9]
DWORD   dMemLength[MAX_MEM_REGISTERS];  // 26 Memory window length [9]
WORD    wMemAttrib[MAX_MEM_REGISTERS];  // 4A Memory window Attrib [9]
WORD    wNumIOPorts;                    // 5C Num IO ports
WORD    wIOPortBase[MAX_IO_PORTS];      // 5E I/O port base [20]
WORD    wIOPortLength[MAX_IO_PORTS];    // 86 I/O port length [20]
WORD    wNumIRQs;                       // AE Num IRQ info
BYTE    bIRQRegisters[MAX_IRQS];        // B0 IRQ list [7]
BYTE    bIRQAttrib[MAX_IRQS];           // B7 IRQ Attrib list [7]
WORD    wNumDMAs;                       // BE Num DMA channels
BYTE    bDMALst[MAX_DMA_CHANNELS];      // C0 DMA list [7]
WORD    wDMAAttrib[MAX_DMA_CHANNELS];   // C7 DMA Attrib list [7]
BYTE    bReserved1[3];                  // D5 Reserved
} CMCONFIG;                             // D8</PRE>
<P>In previous versions of Windows, a primary purpose for writing a VxD was to virtualize hardware so that Windows DRV drivers and multiple MS-DOS®-based applications could share it transparently. For instance, Ring 3 drivers running in virtual machines hooked interrupt 9 and performed port I/O operations just as if they were talking to a real keyboard, but the Virtual Keyboard Device (VKD) driver multiplexed this activity so that keystrokes went where the user intended.</P>
<P>Virtualization is still important in Windows 95 for compatibility. MS-DOS-based applications continue to operate in their traditional egocentric ways. Moreover, many hardware vendors have been unable as yet to provide fully 32-bit VxD drivers and must continue to rely on real-mode solutions crafted for previous versions of the MS-DOS and Windows operating systems. Newer drivers typically provide a private API for applications to use in accessing devices, however. These drivers handle all physical I/O operations entirely within 32-bit protected mode. As I discuss the various CMCONFIG structure elements, I'll give a sketch of how a VxD goes about virtualizing or directly using the standard resources.</P>
<H2><A NAME="sec5"></A>  Memory Assignments</H2><P>The CMCONFIG structure in <B>Figure 10</B> records up to nine memory block assignments. The wNumMemWindows member indicates how many memory blocks were assigned, and entries in dMemBase record their base addresses. The dMemLength vector entries give the lengths of the memory blocks, and wMemAttrib elements specify block attributes. The base addresses are physical addresses and may, in general, occupy any location in the 32-bit address space. Most often, devices use memory in the adapter region of the first megabyte—that is, addresses in the range 000A0000 through 000FFFFF. The attributes word indicates the location of the assigned memory and can contain either fMD_ROM or fMD_RAM and either fMD_24 or fMD_32.</P>
<P>Virtualizing a device, such as the standard video display, that uses memory-mapped I/O requires the VxD to provide physically separate memory for each virtual machine. In addition, the VxD needs to swap each VM's private copy in and out of the physical device memory to swap ownership of the device. At a conceptual level, for example, the Virtual Display Device swaps virtual and real video buffers each time the user switches to a new full-screen MS-DOS session. The SHELL VxD drives the process of the state swapping by sending Set_Device_Focus system control messages as the user's focus changes.</P>
<P>Accessing physical memory directly from a VxD is not possible, since all addresses are subject to page translation. The normal way to access memory in the first megabyte is to add the virtual address to the CB_High_Linear value for the virtual machine in question. This gives a 32-bit address that unambiguously refers to the memory belonging to a single virtual machine. </P>
<P>Accessing physical device memory outside the first megabyte is a bit more complicated. In Windows 3.1, you use _MapPhysToLinear to obtain a virtual address describing a specified physical address. That service, which still works in Windows 95, modifies the system page tables as necessary to make the physical memory accessible. Unfortunately, the modification to the page tables is permanent, and you can't reclaim the virtual addresses if the physical memory moves later. If you start and stop the device several times during one Windows session at different physical addresses, you therefore run the risk of exhausting the page table. To solve this problem, you use _page Reserve to reserve a block of linear address space, _PageCommitPhys to commit the physical device memory to that block of linear addresses, and _LinPageLock to lock the page tables that map the memory so you can access the memory at interrupt time. When the device stops, you reverse these steps by calling _LinPageUnLock, _PageDecommit, and _PageFree. (Note: the DDK documentation for _PageCommitPhys incorrectly says the _LinPageLock won't allow you to access the memory at interrupt time. In fact, you can access the memory at interrupt time if you've locked the memory.)</P>
<H2><A NAME="sec6"></A>  I/O Port Assignments</H2><P>The CMCONFIG structure records up to 20 I/O base addresses. The wNumIOPorts field indicates how many blocks of port addresses have been assigned to the device. Each assignment includes a base address (wIOPortBase element) and a port count (wIOPortLength element).</P>
<P>Virtualizing a device accessed through I/O ports often requires the VxD to trap the ports by calling Install_IO_Handler. Port trapping relies on the I/O permission mask attached to the one and only task state segment Windows uses. Setting a bit in the mask to 1 prevents virtual machine software from accessing the corresponding port directly. IN and OUT instructions instead cause GP faults that the VMM routes to the installed I/O handler, which can then simulate the operations or manage contention for unshareable devices.</P>
<P>Since VxDs run in the most privileged Ring 0, they can perform I/O operations to any port no matter how the I/O permission mask happens to be set.</P>
<H2><A NAME="sec7"></A>  IRQ Assignments</H2><P>The CMCONFIG structure records up to seven IRQ assignments. The wNumIRQs field indicates how many IRQs have been assigned to the device, and entries in bIRQRegisters indicate which ones. The bIRQAttrib array records attributes for each IRQ; the only current attribute is the fIRQD_Share flag, which indicates that the IRQ is shared with other devices.</P>
<P>In real-mode under MS-DOS, you hook a hardware interrupt in two steps. First, you install the address of a service routine in the interrupt vector table at 0:0. For example, IRQ 10 interrupts on INT 72H in a standard PC. Second, you unmask the IRQ by writing to the Programmable Interrupt Controller's (PICs) interrupt mask register (IMR). Since there are two PICs on a standard PC, there are two IMRs at port addresses 21H and A1H. These are 8-bit ports in which a 1 bit indicates the masked state that prevents interrupt signals on the associated request line from actually reaching the central processor.</P>
<P>You must perform the same two steps in a VxD to hook a hardware interrupt in Windows 3.x or Windows 95, but you don't do so directly. The VPICD (Virtual PIC Device) driver virtualizes the interrupt controller for the entire system, and it exports services that other VxDs use for interrupt handling. VPICD_Virtualize_IRQ takes the place of an explicit interrupt vector replacement, and VPICD_Physically_Unmask performs the necessary operations with the mask register. VxDs always use these services instead of directly modifying the protected-mode interrupt descriptor table or directly performing I/O to the mask register.</P>
<P>When you virtualize an IRQ, you supply a function pointer table. One of the functions is a hardware interrupt procedure that VPICD calls shortly after fielding a hardware interrupt. Modern device drivers will handle the interrupt entirely in 32-bit protected mode and will therefore eventually call VPICD_Phys_EOI to mark the end of the interrupt. In previous versions of Windows, hardware interrupt handlers were often very short procedures whose only purpose was to reflect the interrupt to a real-mode handler previously installed by CONFIG.SYS.</P>
<H2><A NAME="sec8"></A>  DMA Assignments</H2><P>The CMCONFIG structure records up to seven DMA channel assignments. The wNumDMAs field indicates how many channels have been assigned to the device, and the bDMALst array contains their numbers. The wDMAAttrib array indicates the width of the assigned channels as fDD_BYTE, fDD_WORD, or fDD_DWORD.</P>
<P>Devices that use DMA channels don't normally need to provide specially for virtualizing DMA transfers. That's the responsibility of the VDMAD driver, which traps the DMA controller ports for real-mode applications. VDMAD also translates virtual addresses to locked physical addresses and handles physically discontiguous transfers. Protected-mode applications that wish to do DMA transfers use the VirtualDMAServices API to communicate with VDMAD.</P>
<P>A VxD that wants to initiate a DMA transfer must use VDMAD services instead of directly programming the DMA channel. It might, for example, use VDMAD_Lock_DMA_Region,VDMAD_Set_Region_Info,VDMAD_Set_Phys_State, andVDMAD_Phys_Unmask_Channel to initiate transfers.</P>
<H2><A NAME="sec9"></A>  Other Configuration Issues</H2><P>Since Configuration Manager allows hardware vendors to define their own I/O resource types, it also gives driver writers a way to determine private resource assignments. This isn't as easy as with the four standard resource types, because it requires the driver to explicitly loop over resource descriptors. In general, the driver would contain code like the following:</P>
<P><BR></P>
<PRE> LOG_CONF logconf;
RES_DES hres;
CM_Get_First_Log_Conf(&amp;logconf devnode,ALLOC_LOG_CONF);
hres = (RES_DES) logconf;
while (CM_Get_Next_Res_Des(&amp;hres, hres, restype,
                           NULL, 0) == CR_SUCCESS)
    { // for each restype resource
      // [extract assignment from  "hres-&gt;" structure]
    } // for each restype resource</PRE>
<P> </P>
<P>Here restype denotes the private resource type index. This could also be one of the standard resource types like ResType_IRQ, but there's not much point in writing this sort of elaborate code to determine which IRQ has been assigned when CM_Get_Alloc_Log_Conf is so much more convenient. CM_Get_First_Log_Conf here retrieves the one and only allocated logical configuration for the device. CM_Get_Next_Res_Des loops over all the restype resource descriptors. You start the loop by giving it a logical configuration handle; thereafter, you give it a resource descriptor handle, and it returns the next one. The resource handles this function returns are just the Ring 0 flat addresses of the resource descriptor structures in whatever format the resource arbitrator happens to use. For example, the handle to an IRQ resource descriptor is simply the address of an IRQ_DES structure.</P>
<P>Configuration Manager can send a variety of other events to a device's configuration function. Besides START, the FILTER, REMOVE, and STOP events are particularly important. FILTER allows a driver to examine and modify the resource descriptors in its logical configurations before resources are actually assigned. You might want to handle this event, for example, if your parent DEVNODE's enumerator is too optimistic about which IRQs your device can actually handle. REMOVE means that your device is being logically removed from the system. You should respond by terminating your use of the assigned I/O resources. In addition to not performing any more I/O operations, you should call the inverses of the services you used earlier, such as _PageFree and VPICD_Force_Default_Behavior. STOP asks you to stop using your configuration as well; in practice, I see REMOVE requests even in situations (like disabling the device from Device Manager) where I'd expect to see STOP instead. In the sample TELEPATH driver, therefore, I treat STOP and REMOVE the same way.</P>
<H2><A NAME="sec10"></A>  Working with the End User</H2><P>Everything I've said in these two articles until this point concerns VxD-level programming. There's one additional aspect of Plug and Play that relates to application-level programming that I'll talk about here: how you can extend Device Manager's device property sheet with custom information.</P>
<P>From within the Windows 95 Control Panel, you can launch the System applet and then select the Windows 95 Device Manager (see <B>Figure 11</B>). Selecting a particular device and clicking on the Properties button brings up a property sheet that describes that device (see <B>Figure 12</B>). The standard property sheet contains pages labeled General, Driver, and Resources. If your device has additional information to report to the user, you can write a custom property sheet provider to display it. I'll show you one simple way to report which telepathic channel belongs to a Telepathic Input Device (see <B>Figure 13</B>).</P>
<P><img src="PLUG11.gif"></P>
<P><B> Figure 11  Device Manager</B></P>
<P><img src="PLUG12.gif"></P>
<P><B> Figure 12  Device Property Sheet</B></P>
<P><img src="PLUG13.gif"></P>
<P><B> Figure 13  Simple Custom Property Page</B></P>
<P>To create custom property pages for Device Manager, you'll create a small 16-bit (more on this later) DLL that exports an EnumPropPages function. This function should create one or more standard Windows 95 property pages. Your DLL should also contain the resources that define the layout of your custom pages and the dialog functions that manage the pages at run time. Finally, you arrange to add an EnumPropPages named value to the software key for your device driver.</P>
<P><B>Figure 14</B> shows SCHOOLUI.DLL, which is the custom property page provider for Telepath devices. SCHOOLUI.C is the only source program in this DLL, and it contains only two functions: EnumPropPages and StatusDlgProc. The purpose of EnumPropPages is to define the custom property page for the device. StatusDlgProc is the dialog procedure for that page, and it uses Configuration Manager calls to determine which telepathic channel gets assigned to the device.</P>
<P><B> Figure 14  SCHOOLUI.DLL</B></P>
<P></P>
<P>SCHOOLUI.DEF</P>
<P><BR></P>
<PRE> LIBRARY   SCHOOLUI<BR>EXETYPE   WINDOWS<BR>CODE      PRELOAD MOVEABLE DISCARDABLE<BR>DATA      PRELOAD MOVEABLE SINGLE<BR>HEAPSIZE  1024<BR>EXPORTS<BR>          WEP PRIVATE<BR>              EnumPropPages @1</PRE>
<P></P>
<P>SCHOOLUI.RC</P>
<P><BR></P>
<PRE> //Microsoft App Studio generated resource script.<BR>//<BR>#include "resource.h"<BR><BR>#define APSTUDIO_READONLY_SYMBOLS<BR>///////////////////////////////////////////////////////////////<BR>//<BR>// Generated from the TEXTINCLUDE 2 resource.<BR>//<BR>#include "afxres.h"<BR><BR>///////////////////////////////////////////////////////////////<BR>#undef APSTUDIO_READONLY_SYMBOLS<BR><BR><BR>///////////////////////////////////////////////////////////////<BR>//<BR>// Dialog<BR>//<BR><BR>IDD_STATUS DIALOG DISCARDABLE  0, 0, 142, 106<BR>STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | <BR>    WS_SYSMENU<BR>CAPTION "Status"<BR>FONT 8, "MS Sans Serif"<BR>BEGIN<BR>    LTEXT           "Telepathic Channel:",IDC_STATIC,3,9,74,8<BR>    LTEXT           "(None)",IDC_CHANNEL,93,9,35,7<BR>END<BR><BR>#ifdef APSTUDIO_INVOKED<BR>///////////////////////////////////////////////////////////////<BR>//<BR>// TEXTINCLUDE<BR>//<BR><BR>1 TEXTINCLUDE DISCARDABLE <BR>BEGIN<BR>    "resource.h\0"<BR>END<BR><BR>2 TEXTINCLUDE DISCARDABLE <BR>BEGIN<BR>    "#include ""afxres.h""\r\n"<BR>    "\0"<BR>END<BR><BR>3 TEXTINCLUDE DISCARDABLE <BR>BEGIN<BR>    "\r\n"<BR>    "\0"<BR>END<BR><BR>///////////////////////////////////////////////////////////////<BR>#endif    // APSTUDIO_INVOKED<BR><BR><BR>#ifndef APSTUDIO_INVOKED<BR>///////////////////////////////////////////////////////////////<BR>//<BR>// Generated from the TEXTINCLUDE 3 resource.<BR>//<BR><BR><BR>///////////////////////////////////////////////////////////////<BR>#endif    // not APSTUDIO_INVOKED</PRE>
<P></P>
<P>RESOURCE.H</P>
<P><BR></P>
<PRE> //{{NO_DEPENDENCIES}}<BR>// App Studio generated include file.<BR>// Used by SCHOOLUI.RC<BR>//<BR>#define SCHOOL                          101<BR>#define IDD_STATUS                      103<BR>#define IDC_CHANNEL                     1000<BR>#define IDC_STATIC                      -1<BR><BR>// Next default values for new objects<BR>// <BR>#ifdef APSTUDIO_INVOKED<BR>#ifndef APSTUDIO_READONLY_SYMBOLS<BR><BR>#define _APS_NEXT_RESOURCE_VALUE        105<BR>#define _APS_NEXT_COMMAND_VALUE         40001<BR>#define _APS_NEXT_CONTROL_VALUE         1001<BR>#define _APS_NEXT_SYMED_VALUE           101<BR>#endif<BR>#endif</PRE>
<P></P>
<P>SCHOOLUI.C</P>
<P><BR></P>
<PRE> #include &lt;windows.h&gt;<BR>#include &lt;commctrl.h&gt;<BR>#include &lt;setupx.h&gt;<BR><BR>#define EXPORT __export<BR><BR>#define Not_VxD   // to get ring-3 dcls<BR>#include &lt;vmm.h&gt;<BR>#define MIDL_PASS  // suppress 32-bit only #pragma pack(push)<BR>#include &lt;configmg.h&gt;<BR><BR>#include "resource.h"<BR><BR>BOOL WINAPI EXPORT StatusDlgProc(HWND, UINT, WPARAM, LPARAM);<BR><BR>///////////////////////////////////////////////////////////////<BR><BR>BOOL WINAPI EXPORT EnumPropPages(LPDEVICE_INFO pdi,<BR>    LPFNADDPROPSHEETPAGE AddPage, LPARAM lParam)<BR>    {    // EnumPropPages<BR>    PROPSHEETPAGE status; // status property page<BR>    HPROPSHEETPAGE hstatus;<BR><BR>    status.dwSize = sizeof(PROPSHEETPAGE);<BR>    status.dwFlags = PSP_USETITLE;<BR>    _asm mov status.hInstance, ds<BR>    status.pszTemplate = MAKEINTRESOURCE(IDD_STATUS);<BR>    status.hIcon = NULL;<BR>    status.pszTitle = "Status";<BR>    status.pfnDlgProc = StatusDlgProc;<BR>    status.lParam = (LPARAM) pdi-&gt;dnDevnode;<BR>    status.pfnCallback = NULL;<BR><BR>    hstatus = CreatePropertySheetPage(&amp;status);<BR>    if (!hstatus)<BR>    return TRUE;<BR><BR><BR>    if (!AddPage(hstatus, lParam))<BR>        DestroyPropertySheetPage(hstatus);<BR>    return TRUE;<BR>    }                           // EnumPropPages<BR><BR>///////////////////////////////////////////////////////////////<BR><BR>BOOL WINAPI EXPORT StatusDlgProc(HWND hdlg, UINT msg,<BR>    WPARAM wParam, LPARAM lParam)<BR>    {                           // StatusDlgProc<BR>    switch (msg)<BR>        {                       // process message<BR><BR>    case WM_INITDIALOG:<BR>        {                       // WM_INITDIALOG<BR>    <BR>        #define ResType_Telepath ((0x10 &lt;&lt; 5) | 5)<BR>        <BR>        typedef struct<BR>            {                   // telepath resource<BR>            ULONG allocated;    // mask for allocated channel<BR>            ULONG requested;    // mask for requested channels<BR>            } TELEPATH_RESOURCE;// telepath resource<BR>            <BR>        LOG_CONF logconf;<BR>        RES_DES hres;<BR>        DEVNODE devnode = (DEVNODE) ((LPPROPSHEETPAGE) lParam)-&gt;lParam;<BR>            <BR>        if (CM_Get_First_Log_Conf(&amp;logconf, devnode, ALLOC_LOG_CONF)== CR_SUCCESS<BR>            &amp;&amp; CM_Get_Next_Res_Des(&amp;hres, (RES_DES) logconf,<BR>            ResType_Telepath, NULL, 0) == CR_SUCCESS)<BR>            {                   // has telepath channel<BR>            TELEPATH_RESOURCE res;<BR><BR>            CM_Get_Res_Des_Data(hres, &amp;res, sizeof(res), 0);<BR>            if (res.allocated &gt;= 0)<BR>                SetDlgItemInt(hdlg, IDC_CHANNEL, res.allocated, FALSE);<BR>            }                   // has telepath channel<BR>        }                       // WM_INITDIALOG<BR>        <BR>        }                       // process message<BR>    return FALSE;<BR>    }                           // StatusDlgProc</PRE>
<P></P>
<P>I want to explain the unusual aspects of SCHOOLUI.DLL. Even though Windows 95 provides great support for Win32®-based applications, this DLL is a 16-bit program. This is partly because Device Manager itself is a 16-bit applet and because SCHOOLUI needs to make calls to CONFIGMG.VXD's protected-mode API, which is only available to 16-bit callers. SCHOOLUI.C includes some header files that come from the Windows 95 DDK. In fact, the DDK includes a complete set of 16-bit Windows header files, including WINDOWS.H and COMMCTRL.H, in addition to the 32-bit headers normally used by VxDs. SCHOOLUI includes SETUPX.H, which is primarily devoted to declarations used by custom installation programs but has some declarations needed here; SETUPX.H also includes the 16-bit version of the standard Windows 95 PRSHT.H header, which defines property sheet structures. SCHOOLUI also contains the following statements that include VxD header files:</P>
<P><BR></P>
<PRE> #define Not_VxD 
#include &lt;vmm.h&gt;
#define MIDL_PASS
#include &lt;configmg.h&gt;</PRE>
<P> </P>
<P>The #define statements give you just the declarations from VMM.H and CONFIGMG.H that are useful to 16-bit Windows-based programs. You end up with declarations that let you call Configuration Manager functions using source code that's almost identical to what you would use in a VxD.</P>
<P>The EnumPropPages function creates a property page using the regular CreatePropertySheetPage function. The only part of this operation that's out of the ordinary is this statement:</P>
<P> </P>
<P><BR></P>
<PRE> status.lParam = (LPARAM) 
                pdi-&gt;dnDevnode;</PRE>
<P> </P>
<P>The pdi variable is a function argument that points to a DEVICE_INFO structure (defined in SETUPX.H). The only member of that structure I'm interested in here is dnDevnode, which is the Ring 0 flat address of the DEVNODE whose properties are going to be reported. The indicated statement saves this DEVNODE address in the lParam member of the property page descriptor, from whence it can later be extracted by the dialog procedure.</P>
<P>You're probably wondering what use a 16-bit, Ring 3 DLL has for a Ring 0 flat pointer to an undocumented data structure. The WM_INITDIALOG handler in the StatusDlgProc shows how to use this pointer to discover information about the device. The lParam parameter for WM_INITDIALOG is the address of a copy of the PROPSHEETPAGE structure originally used to define the property page, and the lParam member of that structure is the DEVNODE address you originally put there. So, the following statement retrieves the (flat) DEVNODE address:</P>
<P> </P>
<P><BR></P>
<PRE> DEVNODE devnode = (DEVNODE) 
((LPPROPSHEETPAGE) lParam)-&gt;lParam;</PRE>
<P> </P>
<P>You can pass this address as an argument to Configuration Manager functions in what looks like the normal way for a VxD. For example, you can get a copy of the telepathic resource structure for your device as follows:</P>
<P> </P>
<P><BR></P>
<PRE> CM_Get_First_Log_Conf(&amp;logconf, devnode, 
                      ALLOC_LOG_CONF);
CM_Get_Next_Res_Des(&amp;hres, (RES_DES) logconf,
                    ResType_Telepath, NULL, 0);
CM_Get_Res_Des_Data(hres, &amp;res, sizeof(res), 0);</PRE>
<P> </P>
<P>This is a Ring 3 DLL, not a VxD, so how can it call Configuration Manager? When Not_VxD is defined, CONFIGMG.H defines all of the CM_XXX APIs as inline functions that use Configuration Manager's protected-mode API entry point (the one you discover using the standard INT 2FH, Function 1684H interface). The API entry in turn calls service functions within Configuration Manager. The only thing you have to do differently from a VxD is use CM_Get_Res_Des_Data to get the data pointed to by the resource handle (which is another Ring 0 flat pointer you can't use directly).</P>
<P>You have to do one more thing to create your custom property page, and that is to update the registry. When Device Manager wants to display a device's property sheet, it looks in the device's software key for an EnumPropPages entry. This named value designates a DLL and, optionally, the name of a function within that DLL that will create custom pages for the property sheet. By default, the function name is EnumPropPages. So, to create this custom page, I put an entry into my INF file that added the right entry to the registry. The resulting software key is shown in <B>Figure 15</B>.</P>
<P><img src="PLUG15.gif"></P>
<P><B> Figure 15  EnumPropPages entry in a Registry key.</B></P>
<P>I showed you an especially trivial example of a custom property page. You're obviously only limited by your imagination and the requirements of your device in what you could put into a custom page. You can also replace the standard General and Resources pages if you wish. To do this, define and add your replacement page as usual and set either (or both) of the DI_GENERALPAGE_ADDED or DI_RESOURCEPAGE_ADDED flags in the Flags member of the DEVICE_INFO structure passed to EnumPropPages as an argument. The right place to report the telepathic channel assignment, for example, would be in the Resource Settings list box that forms part of the Resources page (see <B>Figure 16</B>). Unfortunately, if you want to replace this relatively complicated page, you must duplicate all of its functionality, including presenting conflict information, responding to requests to change resource assignments, and so on. This is probably too much work, especially since the resulting code has to be maintained forever as Device Manager evolves.</P>
<P><img src="PLUG16.gif"></P>
<P><B> Figure 16  Resources Property Page</B></P>
<H2><A NAME="sec11"></A>  Errata</H2><P>There's a few things I'd like to correct from the first article. First of all, the listing for S_CTL.ASM won't assemble as shown—it's missing a couple backslashes. The one that appears in this article is correct and applies to both articles. The listing for TELEPATH.C has duplicate OnConfigure functions. Ignore the first one—it's empty. Once again, rely on the listing in this article. (You needn't worry about having retrieved the wrong source code from an MSJ bulletin board, since the correct version was uploaded, and is the same for both articles.)</P>
<P>The statement last month on page 38 that Configuration Manager is "able to respond to dynamic events like power-on or undocking" by virtue of being continuously present during your Windows session is misleading. Rather, being present allows Configuration Manager to handle docking and undocking events and other "hot" changes in hardware that happen without first powering down.</P>
<P>I learned after the article had gone to press that CONFIG$ isn't the actual agent that reads the Windows 95 registry during MS-DOS startup. IO.SYS does that and gives the information to CONFIG$ for relay to CONFIGMG.VXD. Furthermore, CONFIGMG doesn't need to rescan the registry to try to reinterpret the friendly name of a hardware profile because CONFIG$ supplies the numeric identifier as well as the name. Both of these factoids are pretty much meaningless to most programmers, but it's good to have the record straight.</P>
<H2><A NAME="sec12"></A>  Where To Go Next</H2><P>In these two articles, I've described the basics of Plug and Play, starting with a discussion of how hardware identifies itself to operating systems like Windows 95. I showed examples of the major VxD components that work with Configuration Manager to detect and configure hardware and the corresponding drivers: a bus enumerator, a device loader, a device driver, and a resource arbitrator. For more information, consult the relevant bus specifications and the PNP.DOC file that comes with the Windows 95 DDK; then build and test your own sample programs. I hope you'll find those other resources more accessible after reading this and my previous article. </P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
