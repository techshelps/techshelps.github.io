<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C/C++ Q &amp; A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  C/C++ Q &amp; A</H1><P>Paul DiLascia</P>
<P>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is the author of <I>Windows++: Writing Reusable Code in C++</I> (Addison-Wesley, 1992).</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4568">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the DCLIKBAR project files.</A></P><P><OBJECT id=sample2 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4569">
</OBJECT><a href="javascript:sample2.Click()">
Click to open or copy the TWINUPDT project files.</A></P><P><font size="6" face="verdana,arial,helvetica">Q</font>A problem I encountered in designing and using a simple class hierarchy has annoyed me sufficiently to ask your advice. Since I have only been using C++ for a short while, I would be interested to know if I am missing something obvious. I have an abstract base class with the following member operator function: </P>
<P> </P>
<P><BR></P>
<PRE> virtual ostream&amp; operator&lt;&lt;( ostream&amp; ) const = 0;</PRE>
<P> </P>
<P>My intention was to iterate through all objects derived from this base class and, using a base class pointer p, make all the objects print themselves. But if I write</P>
<P> </P>
<P><BR></P>
<PRE> cout &lt;&lt; *p;</PRE>
<P> </P>
<P>it doesn't work because this is interpreted as</P>
<P> </P>
<P><BR></P>
<PRE> cout.operator&lt;&lt;(*p);</PRE>
<P> </P>
<P>which is undefined, instead of</P>
<P> </P>
<P><BR></P>
<PRE> *p.operator&lt;&lt;( cout );</PRE>
<P> </P>
<P>If I write</P>
<P> </P>
<P><BR></P>
<PRE> *p &lt;&lt; cout;</PRE>
<P> </P>
<P>my code works, but this doesn't look right because the arrows are pointing the wrong way. I can make it work by writing an operator&gt;&gt; instead:</P>
<P> </P>
<P><BR></P>
<PRE> virtual ostream&amp; operator&gt;&gt;( ostream&amp; ) const = 0;</PRE>
<P> </P>
<P>That is, use what is normally regarded as an input operator for the output operator. If I do that, then I can write</P>
<P> </P>
<P><BR></P>
<PRE> *p &gt;&gt; cout;</PRE>
<P> </P>
<P>which the compiler interprets as</P>
<P> </P>
<P><BR></P>
<PRE> *p.operator&gt;&gt;( cout );</PRE>
<P> </P>
<P>which works fine (and looks more sensible). But it doesn't seem right, and in any event it doesn't let me write</P>
<P> </P>
<P><BR></P>
<PRE> a &gt;&gt; b &gt;&gt; c &gt;&gt; cout; </PRE>
<P> </P>
<P>A friend function won't work, either, because friend functions can't be virtual. So, my question is: is there a way of using operator&lt;&lt; that has escaped me, or is it the case that member operator functions like operator&lt;&lt; can't be made virtual and used in the way I intended?</P>
<P><I>Peter Edgley</I></P>
<P> </P>
<P><font size="6" face="verdana,arial,helvetica">A</font>Well, you certainly have a good understanding of C++ for a beginner! But C++ can be a confusing beast sometimes, especially when it comes to operator overloading (among other things). In C++, you can write an operator in one of two ways: as a member function or as a nonmember function. The member function will always take one fewer argument than the nonmember function because the left-hand side of the operator is implicitly an object of the class the function belongs to. For example, if you have a String class, you can write operator+ as a nonmember function</P>
<P> </P>
<P><BR></P>
<PRE> String operator+ (const String&amp; s1, const String&amp; s2)
{
   // do it
}</PRE>
<P> </P>
<P>or as a member function:</P>
<P> </P>
<P><BR></P>
<PRE> String String::operator+ (const String&amp; s) const
{
   // do it
}</PRE>
<P> </P>
<P>Whether to use a member or nonmember function is an important design decision. There's no simple answer I can give you; it all depends on what you want to do. (For a full discussion on member vs. nonmember operators, see C++ Primer by Stanley Lippman, Section 6.3, published by Addison-Wesley, 1991). In the case of Strings, the nonmember operator+ is probably better because it offers more opportunities for conversion. You can write expressions like</P>
<P><BR></P>
<PRE> s = s1 + s2;      // operator+(s1,s2)
s = s1 + "foo";   // operator+(s1,String("foo"))
s = "foo" + s1;   // operator+(String("foo"),s1)</PRE>
<P>If you write a member function String::operator+, the last of these expressions won't work because the left-hand side is not a String object. </P>
<P>But you didn't ask about Strings, you asked about operator&lt;&lt;. Since you want to write</P>
<P> </P>
<P><BR></P>
<PRE> cout &lt;&lt; obj;</PRE>
<P> </P>
<P>you have no choice: the left-hand side is an ostream, which automatically rules out implementing operator&lt;&lt; as a member function. (It would have to be a member function of class ostream, which you are not free to modify.) If you have two choices, and one is no good, that leaves one choice: operator&lt;&lt; has to be a nonmember function. But then it can't be virtual. Does that mean you're hosed? Of course not! Remember, there's always a way!</P>
<P>All you have to do is write one nonmember operator&lt;&lt; for your base class, and have it call a virtual print member function to actually do the work. I wrote a simple program, VIRTOP.CPP (see <B>Figure 1</B>), that shows how to do it. This program has a dopey class hierarchy: a base Fruit class and two derived classes for Apple and Orange. Fruit declares a friend function operator&lt;&lt;, implemented like so:</P>
<P><BR></P>
<PRE> inline ostream&amp; operator&lt;&lt; (ostream&amp; os, 
                            const Fruit&amp; fruit)
{
   fruit.print(os);  // call virtual function
   return os;
}</PRE>
<P> </P>
<P>operator&lt;&lt; is declared as a friend so it can call Fruit::print, which is protected. The print function is protected because it's considered part of the implementation of Fruit, not a public function for anyone to call. Now each derived class implements its own print function to print itself however it pleases. Most important, you can now write</P>
<P> </P>
<P><BR></P>
<PRE> Fruit *pFruit;       // ptr to some fruit
cout &lt;&lt; *pFruit;     // calls the right print function</PRE>
<P> </P>
<P>and the correct print function is invoked, depending on what kind of fruit pFruit actually points to. Since operator&lt;&lt; is inline, there's no extra function call. And since operator&lt;&lt; returns a reference to the ostream, you can concatenate operators.</P>
<P> </P>
<P><BR></P>
<PRE> cout &lt;&lt; a &lt;&lt; b &lt;&lt; ... &lt;&lt; z;</PRE>
<P> </P>
<P>Theoperatorsareevaluatedlefttoright: "cout &lt;&lt; a" returns cout, which is then used to call "cout &lt;&lt; b", and so on. </P>
<P><B> Figure 1  VIRTOP.CPP</B></P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// VIRTOP Copyright 1995 Microsoft Systems Journal. 
// Simple program to demonstrate "virtual" operator&lt;&lt;.
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// To compile, type
//
//    cl virtop.cpp (Microsoft)
//    bcc virtop.cpp (Borland)
// at the DOS prompt.

#include &lt;iostream.h&gt;

//////////////////
// Base class has friend operator and virtual protected print function.
//
class Fruit {
protected:
   virtual void print(ostream&amp; os) const = 0;
public:
   friend ostream&amp; operator&lt;&lt; (ostream&amp; os, const Fruit&amp; fruit);
};

//////////////////
// Derived classes implement their own print functions
//
class Apple : public Fruit {
protected:
   virtual void print(ostream&amp; os) const { os &lt;&lt; "apple"; }
};
   
class Orange : public Fruit {
protected:
   virtual void print(ostream&amp; os) const { os &lt;&lt; "orange"; }
};

////////////////
// There's just one operator&lt;&lt;
// It calls the virtual print function to do the work.
//
inline ostream&amp; operator&lt;&lt; (ostream&amp; os, const Fruit&amp; fruit)
{
   fruit.print(os);
   return os;
}

////////////////
// Main program entry
//
int main()
{
   Apple  a;
   Orange o;
   Fruit* array[2] = { &amp;a, &amp;o };

       // print the fruits using operator&lt;&lt;
   for (int i=0; i&lt;2; i++)
      cout &lt;&lt; "Fruit #" &lt;&lt; i &lt;&lt; " is a " &lt;&lt; *array[i] &lt;&lt; "\n";

   return 0;
}</PRE>
<P>To sum up, your problem is not that operators can't be virtual (they can), but that you need to use a nonmember function to get the arguments in the right order: ostream on the left, object on the right. The solution I've shown is a standard C++ gimmick you can use to "virtualize" any nonmember function. You should add it to your bag of tricks. Of course, if you want to compare apples and oranges, you'll have to write a bunch more operators.</P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I've noticed that any app that's written with MFC has a window name that begins with "Afx:" followed by a bunch of numbers. You can see this by looking at the window with a tool like Spy. Is there some easy way to change the name of the window? I'd like to make the name something more descriptive, like "AlphaWare1.0," and I don't want anyone to know my app was developed with MFC.</P>
<P><I>Name withheld upon request</I></P>
<P></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>My February 1994 column answers a similar question (how to change the background color of the main window), but that was almost two years ago, and this question comes up so frequently I thought it would be a good time to revisit this issue—especially since things have changed in release 4.0 of MFC. The machinations MFC goes through to register window classes are a bit convoluted.</P>
<P>Fortunately, changing the window class name is fairly easy. All you have to do is register your own window class with the name you want and use it. The only tricky part is figuring out where and when to register the window class, and how to get MFC to use it instead of doing its own thing. I wrote a program DCLIKBAR (see <B>Figures 2</B> and <B>3</B>) that shows how to do it. The basic idea is to change the window class name in your frame window's PreCreateWindow function.</P>
<P> </P>
<P><BR></P>
<PRE> BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
   if (!CFrameWnd::PreCreateWindow(cs))
      return FALSE;
   cs.lpszClass = "MyMainFrame"; // use my class name
   return TRUE;
}</PRE>
<P> </P>
<P><img src="CQA2.gif"></P>
<P><B> Figure 2  DCLIKBAR</B></P>
<P><B>Figure 3  DCLIKBAR</B></P>
<P></P>
<P>DCLIKBAR.DEF</P>
<P><BR></P>
<PRE> ; dclikbar.def : Declares the module parameters for the application.

NAME         DCLIKBAR
DESCRIPTION  'DCLIKBAR Windows Application'
EXETYPE      WINDOWS

CODE         PRELOAD MOVEABLE DISCARDABLE
DATA         PRELOAD MOVEABLE MULTIPLE

HEAPSIZE     1024   ; initial heap size
; Stack size is passed as argument to linker's /STACK option</PRE>
<P></P>
<P>DCLIKBAR.RC</P>
<P><BR></P>
<PRE> //Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "afxres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""res\\app.rc2""  // non-App Studio edited resources\r\n"
    "\r\n"
    "#include ""afxres.rc""  \011// Standard components\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

IDR_MAINFRAME           ICON    DISCARDABLE     "RES\\APP.ICO"
IDR_DOCTYPE             ICON    DISCARDABLE     "RES\\DOC.ICO"

/////////////////////////////////////////////////////////////////////////////
//
// Bitmap
//

IDR_MAINFRAME           BITMAP  MOVEABLE PURE   "RES\\TOOLBAR.BMP"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINFRAME MENU PRELOAD DISCARDABLE 
BEGIN
    POPUP "&amp;File"
    BEGIN
        MENUITEM "&amp;New\tCtrl+N",                ID_FILE_NEW
        MENUITEM "E&amp;xit",                       ID_APP_EXIT
    END
    POPUP "&amp;View"
    BEGIN
        MENUITEM "&amp;Toolbar",                    ID_VIEW_TOOLBAR
        MENUITEM "&amp;Status Bar",                 ID_VIEW_STATUS_BAR
    END
    POPUP "&amp;Help"
    BEGIN
        MENUITEM "&amp;About DCLIKBAR...",          ID_APP_ABOUT
    END
END

IDR_DOCTYPE MENU PRELOAD DISCARDABLE 
BEGIN
    POPUP "&amp;File"
    BEGIN
        MENUITEM "&amp;New\tCtrl+N",                ID_FILE_NEW
        MENUITEM "&amp;Close",                      ID_FILE_CLOSE
        MENUITEM "E&amp;xit",                       ID_APP_EXIT
    END
    POPUP "&amp;View"
    BEGIN
        MENUITEM "&amp;Toolbar",                    ID_VIEW_TOOLBAR
        MENUITEM "&amp;Status Bar",                 ID_VIEW_STATUS_BAR
    END
    POPUP "&amp;Window"
    BEGIN
        MENUITEM "&amp;New Window",                 ID_WINDOW_NEW
        MENUITEM "&amp;Cascade",                    ID_WINDOW_CASCADE
        MENUITEM "&amp;Tile",                       ID_WINDOW_TILE_HORZ
        MENUITEM "&amp;Arrange Icons",              ID_WINDOW_ARRANGE
    END
    POPUP "&amp;Help"
    BEGIN
        MENUITEM "&amp;About DCLIKBAR...",          ID_APP_ABOUT
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_MAINFRAME ACCELERATORS PRELOAD MOVEABLE PURE 
BEGIN
    "N",            ID_FILE_NEW,            VIRTKEY, CONTROL
    "O",            ID_FILE_OPEN,           VIRTKEY, CONTROL
    "S",            ID_FILE_SAVE,           VIRTKEY, CONTROL
    "Z",            ID_EDIT_UNDO,           VIRTKEY, CONTROL
    "X",            ID_EDIT_CUT,            VIRTKEY, CONTROL
    "C",            ID_EDIT_COPY,           VIRTKEY, CONTROL
    "V",            ID_EDIT_PASTE,          VIRTKEY, CONTROL
    VK_BACK,        ID_EDIT_UNDO,           VIRTKEY, ALT
    VK_DELETE,      ID_EDIT_CUT,            VIRTKEY, SHIFT
    VK_INSERT,      ID_EDIT_COPY,           VIRTKEY, CONTROL
    VK_INSERT,      ID_EDIT_PASTE,          VIRTKEY, SHIFT
    VK_F6,          ID_NEXT_PANE,           VIRTKEY 
    VK_F6,          ID_PREV_PANE,           VIRTKEY, SHIFT
END


/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOG DISCARDABLE  34, 22, 165, 74
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "About DCLIKBAR"
FONT 8, "MS Sans Serif"
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,11,10,18,20
    LTEXT           "DCLIKBAR Copyright 1995 Microsoft Systems Journal",
                    IDC_STATIC,45,10,93,18
    LTEXT           "Written by Paul DiLascia",IDC_STATIC,45,30,87,12
    DEFPUSHBUTTON   "OK",IDOK,45,49,32,14,WS_GROUP
END


/////////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    IDR_MAINFRAME           "DCLIKBAR Windows Application"
    IDR_DOCTYPE             "\nDCLIKBAR\n\n\n\n\n"
END

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    AFX_IDS_APP_TITLE       "DCLIKBAR Windows Application"
    AFX_IDS_IDLEMESSAGE     "Ready"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_INDICATOR_EXT        "EXT"
    ID_INDICATOR_CAPS       "CAP"
    ID_INDICATOR_NUM        "NUM"
    ID_INDICATOR_SCRL       "SCRL"
    ID_INDICATOR_OVR        "OVR"
    ID_INDICATOR_REC        "REC"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_FILE_NEW             "Create a new document"
    ID_FILE_OPEN            "Open an existing document"
    ID_FILE_CLOSE           "Close the active document"
    ID_FILE_SAVE            "Save the active document"
    ID_FILE_SAVE_AS         "Save the active document with a new name"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_APP_ABOUT            "Display program information, version number and
                             copyright"
    ID_APP_EXIT             "Quit the application; prompts to save documents"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_FILE_MRU_FILE1       "Open this document"
    ID_FILE_MRU_FILE2       "Open this document"
    ID_FILE_MRU_FILE3       "Open this document"
    ID_FILE_MRU_FILE4       "Open this document"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_NEXT_PANE            "Switch to the next window pane"
    ID_PREV_PANE            "Switch back to the previous window pane"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_WINDOW_NEW           "Open another window for the active document"
    ID_WINDOW_ARRANGE       "Arrange icons at the bottom of the window"
    ID_WINDOW_CASCADE       "Arrange windows so they overlap"
    ID_WINDOW_TILE_HORZ     "Arrange windows as non-overlapping tiles"
    ID_WINDOW_TILE_VERT     "Arrange windows as non-overlapping tiles"
    ID_WINDOW_SPLIT         "Split the active window into panes"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_EDIT_CLEAR           "Erase the selection"
    ID_EDIT_CLEAR_ALL       "Erase everything"
    ID_EDIT_COPY            "Copy the selection and put it on the Clipboard"
    ID_EDIT_CUT             "Cut the selection and put it on the Clipboard"
    ID_EDIT_FIND            "Find the specified text"
    ID_EDIT_PASTE           "Insert Clipboard contents"
    ID_EDIT_REPEAT          "Repeat the last action"
    ID_EDIT_REPLACE         "Replace specific text with different text"
    ID_EDIT_SELECT_ALL      "Select the entire document"
    ID_EDIT_UNDO            "Undo the last action"
    ID_EDIT_REDO            "Redo the previously undone action"
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_VIEW_TOOLBAR         "Show or hide the toolbar"
    ID_VIEW_STATUS_BAR      "Show or hide the status bar"
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCSIZE          "Change the window size"
    AFX_IDS_SCMOVE          "Change the window position"
    AFX_IDS_SCMINIMIZE      "Reduce the window to an icon"
    AFX_IDS_SCMAXIMIZE      "Enlarge the window to full size"
    AFX_IDS_SCNEXTWINDOW    "Switch to the next document window"
    AFX_IDS_SCPREVWINDOW    "Switch to the previous document window"
    AFX_IDS_SCCLOSE         "Close the active window and prompts to save the 
                             documents"
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCRESTORE       "Restore the window to normal size"
    AFX_IDS_SCTASKLIST      "Activate Task List"
    AFX_IDS_MDICHILD        "Activate this window"
END


#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#include "res\app.rc2"  // non-App Studio edited resources

#include "afxres.rc"         // Standard components

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED</PRE>
<P></P>
<P>DCLIKBAR.H</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// DCLIKBAR Copyright 1995 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// See DCLIKBAR.CPP for Description of program.

#include "resource.h"

class CDclikbarApp : public CWinApp {
public:
       CDclikbarApp();
       virtual BOOL InitInstance();

       //{{AFX_MSG(CDclikbarApp)
       afx_msg void OnAppAbout();
       //}}AFX_MSG
       DECLARE_MESSAGE_MAP()
};</PRE>
<P></P>
<P>DCLIKBAR.CPP</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// DCLIKBAR Copyright 1995 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// DCLIKBAR shows how to change the window class name of your application's
// main windows, and also how to implement a control bar that allows 
// double-clicking.
//
// All the interesting code is in MAINFRM.CPP
// Makefiles: DCLIK152.MAK for VC++ 1.52
//            DCLIKB22.MAK for VC++ 2.2
//            DCLIKB40.MAK for VC++ 4.0

#include "stdafx.h"
#include "dclikbar.h"
#include "mainfrm.h"
#include "doc.h"
#include "view.h"

CDclikbarApp NEAR theApp;

BEGIN_MESSAGE_MAP(CDclikbarApp, CWinApp)
        //{{AFX_MSG_MAP(CDclikbarApp)
        ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        //}}AFX_MSG_MAP
        ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
        ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

CDclikbarApp::CDclikbarApp()
{
}

BOOL CDclikbarApp::InitInstance()
{
        SetDialogBkColor();        // Set dialog background color to gray

        CMultiDocTemplate* pDocTemplate;
        pDocTemplate = new CMultiDocTemplate(
                IDR_DOCTYPE,
                RUNTIME_CLASS(CMyDoc),
                RUNTIME_CLASS(CMyChildFrame),
                RUNTIME_CLASS(CMyView));
        AddDocTemplate(pDocTemplate);

        // create main MDI Frame window
        CMainFrame* pMainFrame = new CMainFrame;
        if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
                return FALSE;
        m_pMainWnd = pMainFrame;

        pMainFrame-&gt;ShowWindow(m_nCmdShow);
        pMainFrame-&gt;UpdateWindow();

        OnFileNew();

        return TRUE;
}

class CAboutDlg : public CDialog {
public:
        CAboutDlg() : CDialog(IDD_ABOUTBOX) { }
};

void CDclikbarApp::OnAppAbout()
{
        CAboutDlg aboutDlg;
        aboutDlg.DoModal();
}</PRE>
<P></P>
<P>MAINFRM.H</P>
<P><BR></P>
<PRE> //////////////////
// Derived toolbar class to handle double-clicks.
//
class CMyToolBar : public CToolBar {
       static LPCSTR s_winClassName;
       DECLARE_DYNAMIC(CMyToolBar)
protected:
#if _MFC_VER &lt; 0x0400
       virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
#endif
       //{{AFX_MSG(CMyToolBar)
       afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
       afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
       //}}AFX_MSG
       DECLARE_MESSAGE_MAP()
};

//////////////////
// Standard main frame. 
// Overrides PreCreateWindow to change window class name.
//
class CMainFrame : public CMDIFrameWnd {
       static LPCSTR s_winClassName;
       DECLARE_DYNAMIC(CMainFrame)
public:
       CMainFrame();
       virtual ~CMainFrame();
protected:

#if _MSC_VER &lt; 0x0400
       // Not required for MFC 4.0 and later.
       virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
#endif

       CStatusBar  m_wndStatusBar;
       CMyToolBar  m_wndToolBar;

       //{{AFX_MSG(CMainFrame)
       afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
       //}}AFX_MSG
       DECLARE_MESSAGE_MAP()
};

//////////////////
// Derived child frame overrides PreCreateWindow
// to change the window class name.
//
class CMyChildFrame : public CMDIChildWnd {
       static LPCSTR s_winClassName;
       DECLARE_DYNCREATE(CMyChildFrame)
public:
       CMyChildFrame();
       virtual ~CMyChildFrame();
protected:
       virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
       //{{AFX_MSG(CMyChildFrame)
       //}}AFX_MSG
       DECLARE_MESSAGE_MAP()
};</PRE>
<P></P>
<P>MAINFRM.CPP</P>
<P><BR></P>
<PRE> #include "stdafx.h"
#include "dclikbar.h"
#include "mainfrm.h"

#ifndef AfxRegisterClass
// AfxRegisterClass is only defined in 32-bit versions of MFC
#define AfxRegisterClass ::RegisterClass
#endif

IMPLEMENT_DYNAMIC(CMainFrame, CMDIFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CMDIFrameWnd)
       //{{AFX_MSG_MAP(CMainFrame)
       ON_WM_CREATE()
       //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Static class member holds window class name
// (NULL if not registered yet).
// 
LPCSTR CMainFrame::s_winClassName = NULL;

static UINT BASED_CODE buttons[] = {
       ID_FILE_NEW, 
       ID_SEPARATOR, 
       ID_APP_ABOUT
};

static UINT BASED_CODE indicators[] = {
       ID_SEPARATOR,
       ID_INDICATOR_CAPS,
       ID_INDICATOR_NUM,
       ID_INDICATOR_SCRL,
};

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
       if (CMDIFrameWnd::OnCreate(lpCreateStruct) == -1)
              return -1;

       if (!m_wndToolBar.Create(this) ||
              !m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
              !m_wndToolBar.SetButtons(buttons,
                sizeof(buttons)/sizeof(UINT)) )
       {
              TRACE("Failed to create toolbar\n");
              return -1;      // fail to create
       }
       if (!m_wndStatusBar.Create(this) ||
              !m_wndStatusBar.SetIndicators(indicators,
                sizeof(indicators)/sizeof(UINT)))
       {
              TRACE("Failed to create status bar\n");
              return -1;      // fail to create
       }
       return 0;
}

//////////////////
// Helper function to register a new window class based on an already
// existing window class, but with a different name and icon. 
// Returns new name if successful; otherwise NULL.
//
static LPCSTR RegisterSimilarClass(LPCSTR lpszNewClassName,
       LPCSTR lpszOldClassName, UINT nIDResource)
{
       // Get class info for old class.
       //
       HINSTANCE hInst = AfxGetInstanceHandle();
       WNDCLASS wc;
       if (!::GetClassInfo(hInst, lpszOldClassName, &amp;wc)) {
              TRACE("Can't find window class %s\n", lpszOldClassName);
              return NULL;
       }

       // Register new class with same info, but different name and icon.
       //
       wc.lpszClassName = lpszNewClassName;
       wc.hIcon = ::LoadIcon(hInst, MAKEINTRESOURCE(nIDResource));
       if (!AfxRegisterClass(&amp;wc)) {
              TRACE("Unable to register window class%s\n", lpszNewClassName);
              return NULL;
       }
       return lpszNewClassName;
}

//////////////////
// Override to register the different class and change window class name.
//
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
       if (!CFrameWnd::PreCreateWindow(cs))
              return FALSE;

       if (s_winClassName==NULL) {       
              // One-time initialization: register the class
              //
              s_winClassName = RegisterSimilarClass("MyMainFrame", 
                     cs.lpszClass, IDR_MAINFRAME);
              if (!s_winClassName)
                     return FALSE;
       }
       cs.lpszClass = s_winClassName;
       return TRUE;
}

////////////////////////////////////////////////////////////////
// CMyChildFrame implementation
//
IMPLEMENT_DYNCREATE(CMyChildFrame, CMDIChildWnd)

BEGIN_MESSAGE_MAP(CMyChildFrame, CMDIChildWnd)
       //{{AFX_MSG_MAP(CMyChildFrame)
       //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// Static class member holds window class name
// (NULL if not registered yet).
// 
LPCSTR CMyChildFrame::s_winClassName = NULL;

CMyChildFrame::CMyChildFrame()
{
}

CMyChildFrame::~CMyChildFrame()
{
}

//////////////////
// Override to register the different class and change window class name.
//
BOOL CMyChildFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
       if (!CMDIChildWnd::PreCreateWindow(cs))
              return FALSE;

       if (s_winClassName==NULL) {
              // One-time initialization: register the class
              //
              s_winClassName = RegisterSimilarClass("MyChildFrame", 
                     cs.lpszClass, IDR_DOCTYPE);
              if (!s_winClassName)
                     return FALSE;
       }
       cs.lpszClass = s_winClassName;
       return TRUE;
}

////////////////////////////////////////////////////////////////
// CMyToolBar implementation. 
//

IMPLEMENT_DYNAMIC(CMyToolBar, CToolBar)

BEGIN_MESSAGE_MAP(CMyToolBar, CToolBar)
       //{{AFX_MSG_MAP(CMyToolBar)
       ON_WM_LBUTTONDBLCLK()
       //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////
// Handle double-click
//
void CMyToolBar::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
       MessageBox("OK, I got the double-click. Now what?");
}

// Static class member holds window class name
// (NULL if not registered yet).
// 
LPCSTR CMyToolBar::s_winClassName = NULL;

//////////////////
// Override this function to register the different class
// Required for pre-4.0 MFC ONLY! MFC version 4.0 and later uses 
// real Win32 toolbar control, which accepts double-clicks, 
// so there's no need to register a new class.
//
#if _MFC_VER &lt; 0x0400

BOOL CMyToolBar::PreCreateWindow(CREATESTRUCT&amp; cs)
{
       if (!CToolBar::PreCreateWindow(cs))
              return FALSE;

       if (s_winClassName==NULL) {       

              // One-time initialization: register new class with same info, 
              // but different name and style.
              //
              WNDCLASS wc;
              HINSTANCE hInst = AfxGetInstanceHandle();

              // Get data for AfxControlBar
              if (!::GetClassInfo(hInst, cs.lpszClass, &amp;wc)) {
                    TRACE("Can't find window class \"%s\"\n", cs.lpszClass);
                     return FALSE;
              }

              // Change name and style to allow double-clicks
              wc.lpszClassName = "MyControlBar";
              wc.style |= CS_DBLCLKS;
              if (!AfxRegisterClass(&amp;wc)) {
                     TRACE("Unable to register window class MyControlBar\n");
                     return FALSE;
              }
              s_winClassName = wc.lpszClassName;
       }
       cs.lpszClass = s_winClassName;
       return TRUE;
}

#endif // _MFC_VER</PRE>
<P>The only problem is, you can't just create a window with any old class name unless you first register the class with Windows®. So you have to write a few more lines of code. Sorry.</P>
<P> </P>
<P><BR></P>
<PRE> // static data member to hold window class name
LPCSTR CMainFrame::s_winClassName = NULL; 

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
  if (!CFrameWnd::PreCreateWindow(cs))
    return FALSE;

  if (s_winClassName==NULL) {
   // One-time initialization: register the class
   //
   s_winClassName = RegisterSimilarClass("MyMainFrame", 
                     cs.lpszClass, IDR_MAINFRAME);
   if (!s_winClassName)
      return FALSE;
  }
  cs.lpszClass = s_winClassName;
  return TRUE;
}</PRE>
<P> </P>
<P>The first time this code runs, s_winClassName is NULL, so the if clause executes. CREATESTRUCT contains the window class name, which is "AfxFrameOrView". In a normal MFC program, this name would get changed to "Afx:x:y:z:w" where x, y, z, and w are hex values for the window style, cursor, background color, and icon. This is just MFC's way of generating a unique name for the window class. In DCLIKBAR, I call the helper function RegisterSimilarClass to register a new class with the name MyMainFrame. RegisterSimilarClass copies the window class information (WNDCLASS) from the already registered AfxFrameOrView, modifies the class name and icon, and registers a new class. Doing it this way guarantees that your main frame has all the same class properties as a normal main frame, except for the name. By the way, if you wanted to change the cursor or background color or any other class property, this would be the place to do it.</P>
<P>Since DCLIKBAR is an MDI app, I implemented my own child frame to change its class name too. <B>Figure 4</B> is a Spy++ screen capture that shows the window class names for a vanilla DCLIKBAR program (one without the code to modify the class names); the main frame's class name is Afx:b:14ae:6:3e8f. <B>Figure 5</B> shows the modified version with the new window class names: MyMainFrame, MyChildFrame, and MyControlBar (described in the next question). As you can see, there's still AfxControlBar for the status line and AfxFrameOrView for the view. If you really want to hide the fact that you're using MFC, you'll have to derive newclassesforthesewindowclassestoo,usingthetechnique described. If you're using MFC 4.0 or later, you don't need to do it for toolbars or status bars (see the next question). </P>
<P><img src="CQA4.gif"></P>
<P><B> Figure 4  Vanilla window class names.</B></P>
<P><img src="CQA5.gif"></P>
<P><B> Figure 5  Modified window class names.</B></P>
<P>While you're hiding all evidence of MFC, don't forget to link with the static library instead of the DLL! Requiring MFC30.DLL to run your app is a dead giveaway. There are other clues, too, like "Afx" strings embedded in your EXE file. I suspect it's impossible to totally hide the fact that your app was built with MFC, if someone knows where to look. What are you doing, anyway? Writing code for IBM?</P>
<P></P>
<P>QUsing Visual C++ª 2.2, I have created a CToolBar-derived class that I would like to handle double clicks. Using Spy++, I found that WM_LBUTTONDBLCLK messages are not getting sent to my toolbar window. This is due to the fact that CToolBar::Create calls CWnd::Create and specifies _afxWndControlBar (that is, AfxControlBar) as the window class. The AfxControlBar window class is registered in APPINIT.CPP without including the CS_DBLCLKS flag in the style bits of the WNDCLASS structure. Is there anything I can do (short of editing and recompiling MFC source) to make double clicks get sent to my toolbar window?</P>
<P><I>Brian P. Donaldson</I></P>
<P></P>
<P>AWell, the simplest thing would be to use ::SetClassLong to modify the window class style for control bars, perhaps in your control bar's OnCreate handler.</P>
<P><BR></P>
<PRE> DWORD dwStyle = ::GetClassLong(m_hWnd, GCL_STYLE);
dwStyle |= CS_DBLCLKS;
::SetClassLong(m_hWnd, GCL_STYLE, dwStyle);</PRE>
<P>The main drawback with this approach is that it modifies the class for all instances of AfxControlBar in your app. For example, the status bar will get the same double-clicks-allowed property, since it's a control bar too. This may or may not be what you want. A better way that requires only slightly more work is to create a new control bar class that has the desired style. I wrote a program called DCLIKBAR (see <B>Figures 2</B> and <B>3</B>) that does it. It's the same program described in the previous question. (I just love it when I can kill two questions with one app!)</P>
<P>As you discovered, MFC registers a special window class for control bars, AfxControlBar. This window class is registered without CS_DBLCLKS. To get a control bar that accepts double clicks, you have to register your own window class with CS_DBLCLKS turned on. To make sure your window class has the same style as MFC's, you can start by getting the WNDCLASS info for AfxControlBar, then modify the style, change the name, and register a new class. Just don't forget to use the new name when you create the control bar (see <B>Figure 6</B>). That wasn't so bad, was it? </P>
<P><B> Figure 6  Creating a Toolbar that Handles Double Clicks</B></P>
<P><BR></P>
<PRE> LPCSTR CMyToolBar::s_winClassName = NULL;

BOOL CMyToolBar::PreCreateWindow(CREATESTRUCT&amp; cs)
{
  if (!CToolBar::PreCreateWindow(cs))
    return FALSE;

  if (s_winClassName==NULL) {   
    // One-time initialization: register new class
    // with same info, but different name and style.

    // Get data for AfxControlBar
    WNDCLASS wc;
    VERIFY(::GetClassInfo(AfxGetInstanceHandle(), 
      cs.lpszClass, &amp;wc));

    // Change name and style to allow double-clicks
    wc.lpszClassName = "MyControlBar";
    wc.style |= CS_DBLCLKS;
    VERIFY(AfxRegisterClass(&amp;wc));
    s_winClassName = wc.lpszClassName;
  }
  cs.lpszClass = s_winClassName;
  return TRUE;
}</PRE>
<P>If you're using MFC 4.0 or later, things are even easier: you don't have to do anything. Starting with version 4.0, MFC uses the real Windows common toolbar control, ToolbarWindow32, which—lucky you!—allows double clicks. Since we're on the subject, I should point out that all the built-in window class names are different in MFC 4.0. <B>Figure 7</B> is a Spy++ screen capture that shows how the names have changed with version 4.0. The toolbar and status line now use real Windows common controls (ToolbarWindow32 and msctls.statusbar32 and—don't you love the consistent naming conventions), and AfxFrameOrView is changed to AfxFrameOrView40sd. You can probably guess what 40 stands for; the sd indicates that this instance of DCLIKBAR was compiled with MFC as a static link library, with _DEBUG turned on. (Of course, you have no reason on earth to care about these names—just use whatever name comes to you in cs.lpszClass in PreCreateWindow.) </P>
<P><img src="CQA7.gif"></P>
<P><B> Figure 7  MFC 4.0 window class names.</B></P>
<P>For those of you who need to worry about such things, I must also point out that MFC 4.0 has a totally different way of registering its built-in window classes. Instead of doing it all in APPINIT.CPP, each C++ class that uses one of the built-in window classes now registers it on an as-needed basis, using a new internal function (actually, it's a macro) called AfxDeferRegisterClass. This macro takes a flag that identifieswhich kind of window to register: a normal window, a frame/view, a common control, or something else. Warning: if you have code that mucks around this part of the framework, it might break in MFC version 4.0.</P>
<H2><A NAME="sec0"></A>  Update</H2><P>I'd like to deliver a brief update on the TRACEWIN program I described in the October 1995 issue. If you recall, TRACEWIN is an applet that displays MFC TRACE diagnostic messages even when you don't run your app under the debugger. It works by sending strings from the application to the TRACEWIN window. In the October column, I showed you how to send the strings as global atoms to avoid using the Clipboard or OLE data transfer.</P>
<P>A few readers pointed out that a better way of doing it is to use WM_COPYDATA. With my brain firmly anchored (should I say mired?) in the past, I missed WM_COPYDATA. (It's true, I don't read the API manuals the minute a new operating system comes out!) WM_COPYDATA is new for Win32, and it's exactly what TRACEWIN needs: a simple and easy way to send a string of text from one application toanother.WM_COPYDATAtakestwoparameters:WPARAM is the window handle of the sending window; LPARAM is a pointer to a COPYDATASTRUCT, which looks like this.</P>
<P> </P>
<P><BR></P>
<PRE> // (defined in WINUSER.H)
struct COPYDATASTRUCT {
   DWORD dwData;     // whatever you want
   DWORD cbData;     // length of data
   PVOID lpData;     // ptr to data
};</PRE>
<P> </P>
<P>This is pretty self-explanatory. dwData is just any DWORD you want to send. You can use it to identify different kinds of data you might send with WM_COPYDATA. For TRACEWIN, I send a special value, ID_COPYDATA_TRACEMSG, that TRACEWIN looks for: if the incoming COPYDATASTRUCT doesn't have this value, TRACEWIN ignores it. <B>Figure 8</B> shows the modified Write function in TRACEWIN.H, which is the file you must include in your app to use TRACEWIN; <B>Figure 9</B> shows the modified TRACEWIN code, from the file MAINFRM.CPP. The new, improved TRACEWIN is available from the usual MSJ sources.</P>
<P><B> Figure 8  New Write Function for TRACEWIN</B></P>
<P><BR></P>
<PRE> // Modified Write function from TRACEWIN.H
//
void CMfxTrace::Write(const void* lpBuf, UINT nCount)
{
       if (!afxTraceEnabled)
              return;

       CWnd *pTraceWnd = CWnd::FindWindow(TRACEWND_CLASSNAME, NULL);
       if (pTraceWnd) {
              // Found Trace window: send string with WM_COPYDATA
              //
              COPYDATASTRUCT cds;
              cds.dwData = ID_COPYDATA_TRACEMSG;
              cds.cbData = nCount;
              cds.lpData = (void*)lpBuf;
              pTraceWnd-&gt;SendMessage(WM_COPYDATA, 
                     (WPARAM)AfxGetApp()-&gt;m_pMainWnd-&gt;GetSafeHwnd(), 
                     (LPARAM)&amp;cds);

       } else {
              // No trace window: do normal debug thing
              //
              ::OutputDebugString((LPCSTR)lpBuf);       
       }
}</PRE>
<P><B> Figure 9  Modified MAINFRM.CPP from TRACEWIN</B></P>
<P><BR></P>
<PRE> // (From modified TRACEWIN source, mainfrm.cpp)
//

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
       //{{AFX_MSG_MAP(CMainFrame)
       ON_MESSAGE(WM_COPYDATA, OnTraceMsg)
       .
       .
       .
       //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////
// Someone sent me a WM_COPYDATA message: display it.
//
LRESULT CMainFrame::OnTraceMsg(WPARAM wParam, LPARAM lParam)
{
       COPYDATASTRUCT* pcds = (COPYDATASTRUCT*)lParam;
       if (m_nOutputWhere==ID_OUTPUT_OFF || pcds-&gt;dwData!=ID_COPYDATA_TRACEMSG)
              return 0;

       const char* lpText = (const char*)pcds-&gt;lpData;
       DWORD len = pcds-&gt;cbData;

       if (m_nOutputWhere==ID_OUTPUT_TO_WINDOW) {
              // Convert \n to \n\r for Windows brain-damaged edit control
              // It's 1995, and I'm still writing code like this!
              //
              const char* src = lpText;
              const char* endsrc = lpText + len;

              char buf[1024];
              char* dst = buf;
              char* endbuf = buf + sizeof(buf) - 1;

              while (src &lt; endsrc &amp;&amp; dst &lt; endbuf) {
                     if (*src == '\n')
                            *dst++ = '\r';
                     *dst++ = *src++;
              }
              *dst = 0;

              // Append string to contents of trace buffer
              m_wndBuffer.SetSel(-1, -1);               // end of edit text
              m_wndBuffer.ReplaceSel(buf);              // append string..
              m_wndBuffer.SendMessage(EM_SCROLLCARET);  // ..and show caret

       } else if (m_nOutputWhere==ID_OUTPUT_TO_FILE) {
              m_file.Write(lpText, len);

       }

       return 0;
}</PRE>
<P></P>
<P>WM_COPYDATA is a truly wonderful message—so simple and useful that I can't understand why it got added. Someone over there must be slipping.</P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P> Have a question about programming in C or C++? You can mail it directly to C/C++ Q&amp;A, Microsoft Systems Journal, 825 Eighth Avenue, 18th Floor, New York, New York 10019, or send it to MSJ (re: C/C++ Q&amp;A) via:</P></TD></TR><TR><TD VALIGN="TOP"><P> <BR>CompuServe:</P>
<P><BR>Internet:</P></TD><TD VALIGN="TOP"><P>Paul DiLascia<BR>72400,2702</P>
<P>Eric Maffei<BR>ericm@microsoft.com</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
