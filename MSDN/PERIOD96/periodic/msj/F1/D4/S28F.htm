<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The Visual Programmer Fingers WinSock Functions from Visual Basic</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  The Visual Programmer Fingers WinSock Functions from Visual Basic</H1><P>Joshua Trupin</P>
<P>Joshua Trupin is a software developer specializing in C/C++ and Visual Basic apps for Windows. He can be reached at 75120.0657@compuserve.com or geeknet@ix.netcom.com.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4594">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the VISPRG project files.</A></P><P></P>
<P>Everyone wants to be on the Internet nowadays. This includes grizzled veterans like me who remember when it was the ARPANet. I'm not saying this just to sound more knowledgeable about the subject. It's just thatÉwell, I guess I am just trying to sound more knowledgeable. Anyway, this tidal wave of interest has done a lot for programming. First, it's created a viable market for client programs such as mail readers and Web browsers. Second, it's made programmers like me, who have avoided network protocols and programming with all the ferocity of an Ultimate Fighting match participant, realize that we'd better figure out just what TCP/IP is. (In case you've had your head in the sand for the past year, TCP/IP stands for Transmission Control Protocol/Internet Protocol.)</P>
<P>TCP/IP is simply a suite of protocols. The TCP part describes how two machines set up a reliable connection to each other and transfer data chunks. IP primarily deals with how to get a message routed across the Internet. Each connected machine site has a unique IP address that allows others to figure out a path to any machine around the world. Each machine with an IP address supports numbered ports, each dedicated to a particular service. For instance, you use TCP to send mail via Simple Mail Transfer Protocol (SMTP) using port 21. You retrieve mail with Post Office Protocol (POP) on port 110. These port numbers have been chosen by convention. So a machine needs to run both TCP and IP together (a protocol stack) to communicate with the outside world.</P>
<P>Since the Internet is built on TCP/IP connections, Internet-enabled client programs have to use TCP/IP to connect with remote machines and transfer data in various formats. Fortunately there's a standard API used to write to TCP/IP stacks—sockets. Sockets was originally developed for Unix; Windows Sockets, or WinSock for short, was later developed for Windows®-based programs (for more information, see "Plug into Serious Network Programming with the Windows Sockets API" by J. Allard, Keith Moore, and David Treadwell, <I>MSJ</I>, July 1993). Here, I'll develop a small OCX that provides selected WinSock functions, then write a 32-bit Visual Basic® program that issues a "finger" command, querying a remote machine for information about a specific user.</P>
<P>First, a bit of background on WinSock. When a communications program is WinSock compliant, it usually means that after it dials up and connects with a remote service provider, it provides sockets for your client programs to plug into. Each communications program that implements these TCP/IP services publishes its own implementation of WINSOCK.DLL. These DLLs are almost always incompatible with one another at the server level, although they provide the same external services to clients wishing to connect with them. Therefore, if you overwrite another communication program's WINSOCK.DLL, that program won't work correctly, but a client program such as my finger program (discussed later) will work the same way with any communication package's WINSOCK.DLL. If that seems confusing to you, you've had more luck in avoiding these sorts of problems than many others have had.</P>
<P>The other thing to know is that a program can provide a 16-bit or a 32-bit WinSock implementation. If your communications program is 16-bit, you can't run a 32-bit WinSock client with it. However, if you have a 32-bit comm program or dialer (such as the Windows 95 Dial-Up Networking), you can use both 16- and 32-bit clients with it. While developing this month's programs, I used my account on Netcom, a popular service provider. Netcom provides only a 16-bit dialer, NetCruiser, but by setting up the Windows 95 dialer instead, I was easily able to start connecting through a more reliable 32-bit connection.</P>
<P>One of the biggest concerns in developing a WinSock program is that not all data requests are fulfilled immediately. If you're awaiting a return or an acknowledgment from a distant machine, it can take several seconds or even minutes before the messages make their way back across the Internet. For this reason, WinSock functions are divided into two groups, synchronous (returning data immediately) or asynchronous (you might have to wait for a return message). Synchronous messages include those that don't need to go across the network for return data, such as network-to-client byte-order conversion calls. Asynchronous calls include calls like remote connections, where you won't know whether it worked right away. </P>
<P>If your program sends a message to a machine halfway around the world and sits there waiting for a reply, it might appear to be hung. You should write your own handler to process other Windows messages during the wait time, or you'll risk freezing everyone's program while your selfish little app waits for incoming data (in 16-bit Windows, anyway), a problem often known as the WinCIM Syndrome.</P>
<P>When you have to make a WinSock call that requires asynchronous operations, the call itself handles it for you. Last month in my Visual Programmer column, I discussed that many callback functions in Windows 95 are designed to expect a window handle and message ID. Asynchronous WinSock calls use this mechanism. If you're expecting to receive some data from halfway around the world, you can call the WSAAsyncSelect function, and pass it a window handle, message ID, and a flag indicating you want to wait for data:</P>
<P> </P>
<P><BR></P>
<PRE> WSAAsyncSelect(socketID, hWnd, WM_USERDEFINED, FD_READ)</PRE>
<P> </P>
<P>When the data actually arrives from somewhere on the network and hits your TCP/IP stack, your window's message handling procedure is notified. Meanwhile, your interface doesn't freeze and you can go do other processing.</P>
<P>Now suppose you want to do this all in Visual Basic. Since you can't use Visual Basic to capture user-defined messages within a Visual Basic form's code, you need to give it a bit of help. You need a WinSock OLE control that can handle these asynchronous calls and trigger events in Visual Basic when something happens.</P>
<P> </P>
<H2><A NAME="sec0"></A>  Flipper</H2><P>To demonstrate how easy it can be to get started with WinSock programming, I've developed Flipper: The MSJ Finger Program. I chose to write a finger program because it's one of the simplest things you can do on the Internet. It doesn't require you to maintain a connection to a remote machine the way an FTP (file transfer protocol) session would. All you have to do is find a remote site's unique numeric IP address, send a string containing a user's name to the finger port at this IP address, and wait for return data. When your machine gets data back from that IP address, your program is notified that it has received data, and you retrieve it and display it (see <B>Figure 1</B>).</P>
<P><img src="VISPRG1.gif"></P>
<P><B> Figure 1  Fingering a Remote User Through WinSock</B></P>
<P>Perhaps I should define just what a finger program is. It's a simple query sent to a remote node to retrieve information about a user or users on the system. Some Internet services, like file browsing and transfer (FTP) and remote terminal access (Telnet) need a full-blown connection, with signon procedures and a persistent connection. Finger, however, doesn't need anything that fancy. When you send a CR/LF-terminated user name as a message to a site's designated finger port, it sends back a block of text about that user. This data is defined by the individual machine; it can contain connection information, real-life names, the amount of mail a user has waiting, or even display user-defined information (commonly known as a .plan file). After this information is returned, you're under no further obligation. (Just write CANCEL on the bill and you owe nothing!)</P>
<P>So let's go over the steps needed to implement a finger program. First, you have to connect to the TCP/IP stack and receive a socket handle to use. You then have to retrieve the address of the remote site, connect to it, send it the username you're interested in, wait for it to return finger information, and disconnect. </P>
<P>To start with, I created an MSJSock control with the Microsoft Developer Studio (AKA Visual C++® 4.0). To get the finger command working correctly, the control needs fivemethods:CreateSocket,gethostbyname,getservbyname, AsyncSelect, and Connect. Technically, some of these WinSock calls can be made from Visual Basic itself, but putting them in an MSJSock OCX makes some operations easier. For instance, if you don't know which standard port to use for a particular service, you can use the getservbyname socket API function. If you call </P>
<P> </P>
<P><BR></P>
<PRE> getservbyname("finger", "tcp")</PRE>
<P> </P>
<P>you're returned information about the TCP finger protocol, but it's returned as a structure with nasty contents such as pointers to pointers. It's easier to deal with this information in C/C++, because Visual Basic doesn't handle pointer values very well. In Windows 3.1, you could potentially have called hmemcpy, a memory access API function exported by KERNEL.DLL. Sadly, this function is no longer exported by KERNEL32.DLL, so you either have to export your own equivalent method or create a call that returns a particular member of a structure. I've chosen the second path, which is less extensible but leads to easier Visual Basic code. Similarly, when you need to call an asynchronous WinSock function, the OLE control will provide the message trap for you, and will fire an event into the Visual Basic project when network data arrives. Clearly, the OCX and Visual Basic project need each other to function correctly, although the control will not be bound to one particular hunk of Visual Basic code.</P>
<P> </P>
<H2><A NAME="sec1"></A>  Implementation</H2><P>A client only needs two pieces of information to perform a finger—a user ID and a site name. Therefore, the Flipper Visual Basic program can be completed with a fairly bare bones implementation. I've added two edit boxes (one for each piece of info), a text box to display results, a button that starts a finger request, and an MSJSock control. When the edit boxes are filled with a username and remote site name, the button is enabled. When it's clicked, the program swings into action. It calls the MSJSock control's CreateSocket method, which in turn calls the WinSock socket function. (MSJSock code may be found in <B>Figure 2</B>; the Flipper project is shown in <B>Figure 3</B>.) socket returns a unique socket ID immediately, so you have a handle to pass data to perform the finger task.</P>
<P><B> Figure 2  MSJSock</B></P>
<P></P>
<P>MSJSOCK.CPP (excerpts)</P>
<P><BR></P>
<PRE> // MSJSock.cpp : Implementation of CMSJSockApp and DLL registration.

#include "stdafx.h"
#include "MSJSock.h"

////////////////////////////////////////////////////////////
// CMSJSockApp::InitInstance - DLL initialization

BOOL CMSJSockApp::InitInstance()
{
    BOOL bInit = COleControlModule::InitInstance();

    // Normally we'd call WSAStartup, but AfxSocketInit
    // wraps the call for us and takes care of some of the
    // version checking automatically.

    if (bInit)
    {
        if (!AfxSocketInit(&amp;m_wsa))
        {
            AfxMessageBox(IDP_SOCKETS_INIT_FAILED);
            return FALSE;
        }
    }

    return bInit;
}


////////////////////////////////////////////////////////////
// CMSJSockApp::ExitInstance - DLL termination

int CMSJSockApp::ExitInstance()
{
    AfxSocketTerm();
    return COleControlModule::ExitInstance();
}</PRE>
<P></P>
<P>MSJSOCK.H (excerpts)</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////
// CMSJSockApp : See MSJSock.cpp for implementation.

class CMSJSockApp : public COleControlModule
{
public:
    BOOL InitInstance();
    int ExitInstance();

    LPWSADATA Sock() { return &amp;m_wsa; };

protected:
    WSADATA m_wsa; // Windows socket info - filled on startup
};</PRE>
<P></P>
<P>MSJSOCKCtTL.CPP (excerpts)</P>
<P><BR></P>
<PRE> // MSJSockCtl.cpp : Implementation of the CMSJSockCtrl OLE control class.

                                     .
                                     .
                                     .

extern CMSJSockApp theApp;
LPBYTE pm_szBuf;


/////////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CMSJSockCtrl, COleControl)
    //{{AFX_MSG_MAP(CMSJSockCtrl)
    // NOTE - ClassWizard will add and remove message map entries
    //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
    ON_MESSAGE(WSCB_GETHOST, OnGetHostCB)
    ON_MESSAGE(WSCB_ASELECT, OnASelectCB)
    ON_OLEVERB(AFX_IDS_VERB_EDIT, OnEdit)
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CMSJSockCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CMSJSockCtrl)
    DISP_PROPERTY_EX(CMSJSockCtrl, "Version", GetVersion, SetVersion, VT_I2)
    DISP_PROPERTY_EX(CMSJSockCtrl,"SystemStatus",GetSystemStatus,SetSystemStatus,<BR>                 VT_BSTR)
    DISP_PROPERTY_EX(CMSJSockCtrl,"MaxSockets",GetMaxSockets,SetMaxSockets,VT_I2)
    DISP_PROPERTY_EX(CMSJSockCtrl,"HiVersion",GetHiVersion,SetHiVersion,VT_I2)
    DISP_PROPERTY_EX(CMSJSockCtrl,"Description",GetDescription,SetDescription, 
                     VT_BSTR)
    DISP_FUNCTION(CMSJSockCtrl, "CreateSocket", CreateSocket, VT_I4, VTS_NONE)
    DISP_FUNCTION(CMSJSockCtrl,"gethostbyname",gethostbyname,VT_HANDLE,VTS_BSTR)
    DISP_FUNCTION(CMSJSockCtrl, "getservbyname", getservbyname, VT_I2, VTS_BSTR)
    DISP_FUNCTION(CMSJSockCtrl,"AsyncSelect",AsyncSelect,VT_I4, VTS_I4 VTS_I4)
    DISP_FUNCTION(CMSJSockCtrl,"connect",connect,VT_HANDLE,VTS_I4 VTS_I2<BR>                  VTS_HANDLE)
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION_ID(CMSJSockCtrl, "AboutBox", DISPID_ABOUTBOX, AboutBox,        
                     VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()


/////////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CMSJSockCtrl, COleControl)
    //{{AFX_EVENT_MAP(CMSJSockCtrl)
    EVENT_CUSTOM("Connect", FireConnect, VTS_HANDLE)
    EVENT_CUSTOM("RecvData", FireRecvData, VTS_HANDLE  VTS_BSTR)
    EVENT_CUSTOM("SockError", FireSockError, VTS_HANDLE  VTS_I2)
    EVENT_CUSTOM("GotHost", FireGotHost, VTS_HANDLE)
    //}}AFX_EVENT_MAP
END_EVENT_MAP()

                                     .
                                     .
                                     .


/////////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DMSJSock =
   { 0x9e638961, 0x2c21, 0x11cf, { 0xa0, 0x18, 0x44, 0x45, 0x53, 0x54, 0, 0 } };
const IID BASED_CODE IID_DMSJSockEvents =
   { 0x9e638962, 0x2c21, 0x11cf, { 0xa0, 0x18, 0x44, 0x45, 0x53, 0x54, 0, 0 } };


/////////////////////////////////////////////////////////////////////////////
// Control type information

// Important: make sure OLEMISC_INVISIBLEATRUNTIME is not included.
//    This would cause the control not to have an hWnd at runtime;
//    we want one, but we want it hidden.

static const DWORD BASED_CODE _dwMSJSockOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE |
    OLEMISC_SETCLIENTSITEFIRST |
    OLEMISC_INSIDEOUT |
    OLEMISC_CANTLINKINSIDE |
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CMSJSockCtrl, IDS_MSJSOCK, _dwMSJSockOleMisc)

                                      .
                                      .
                                      .

/////////////////////////////////////////////////////////////////////////////
// CMSJSockCtrl::OnDraw - Drawing function

void CMSJSockCtrl::OnDraw(
            CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
    // Hide the control at runtime

    if (m_hWnd != NULL)
        ShowWindow(SW_HIDE);
    else
    {
        // Draw something at design-time
        pdc-&gt;FillRect(rcBounds, CBrush::FromHandle((HBRUSH)GetStockObject(WHITE_BRUSH)));
        pdc-&gt;Ellipse(rcBounds);
    }
}

                                     .
                                     .
                                     .

/////////////////////////////////////////////////////////////////////////////
// CMSJSockCtrl message handlers

// Get the current Windows Sockets version from the info returned at startup

short CMSJSockCtrl::GetVersion() 
{
    return theApp.Sock()-&gt;wVersion;
}

void CMSJSockCtrl::SetVersion(short nNewValue) 
{
    // Read/only property, so do nothing.
}

// Get the current system status from the info returned at startup

BSTR CMSJSockCtrl::GetSystemStatus() 
{
    CString s;
    s = theApp.Sock()-&gt;szSystemStatus;
    return s.AllocSysString();
}

void CMSJSockCtrl::SetSystemStatus(LPCTSTR lpszNewValue) 
{
    // Read/only property, so do nothing.
}

// Get the maximum sockets allowed on this control

short CMSJSockCtrl::GetMaxSockets() 
{
    return theApp.Sock()-&gt;iMaxSockets;
}

void CMSJSockCtrl::SetMaxSockets(short nNewValue) 
{
    // Read/only property, so do nothing.
}

// Get the highest allowed version from the info returned at startup

short CMSJSockCtrl::GetHiVersion() 
{
    return theApp.Sock()-&gt;wHighVersion;
}

void CMSJSockCtrl::SetHiVersion(short nNewValue) 
{
    // Read/only property, so do nothing.
}

// Get the Windows Sockets description from the startup info

BSTR CMSJSockCtrl::GetDescription() 
{
    CString s;

    s = theApp.Sock()-&gt;szDescription;
    return s.AllocSysString();
}

void CMSJSockCtrl::SetDescription(LPCTSTR lpszNewValue) 
{
    // Read/only property, so do nothing.
}

// Create a socket - wrap the socket() API call

long CMSJSockCtrl::CreateSocket() 
{
    SOCKET hSock;

    hSock = ::socket(AF_INET, SOCK_STREAM, 0);

    if (hSock &lt;= 0)
        return -1;
    else
        return hSock;
}

// Convert a host string to its IP address

OLE_HANDLE CMSJSockCtrl::gethostbyname(LPCTSTR host) 
{
    pm_szBuf = (LPBYTE) GlobalAllocPtr(GHND, 2048);

    HANDLE hTask = WSAAsyncGetHostByName(m_hWnd, WSCB_GETHOST, host, 
                                         (char FAR *) pm_szBuf, 2048);

    return (OLE_HANDLE) hTask;
}

// Wait for the GetHostByName to return info. This maps WSCB_GETHOST
// into the OnGetHostCB message handler.

afx_msg LONG CMSJSockCtrl::OnGetHostCB(UINT wParam, LONG lParam)
{
    HANDLE hTask = (HANDLE) wParam;
    UINT   wserr = HIWORD(lParam);
    UINT   uCode = LOWORD(lParam);

    LPVOID lphe;

    u_long addr;
    hostent he;
    sockaddr_in ca;

    // If the call didn't return an error, call GotHost in the
    // container program.

    if (wserr == WSANOERROR)
    {
        lphe = (LPVOID) GlobalAllocPtr(GHND, sizeof(hostent));

        memcpy(lphe, (LPVOID) pm_szBuf, sizeof(hostent));
        FireGotHost((OLE_HANDLE) lphe);
           
        return TRUE;
    }
    else // call SockError in the container
        FireSockError((OLE_HANDLE) hTask, wserr);

    return TRUE;
}

// Handle all messages requested by a WSAAsyncSelect call

afx_msg LONG CMSJSockCtrl::OnASelectCB(UINT wParam, LONG lParam)
{
    HANDLE hTask = (HANDLE) wParam;
    UINT   wserr = HIWORD(lParam);
    UINT   uCode = LOWORD(lParam);

    u_long addr;
    hostent he;
    sockaddr_in ca;

    switch (uCode)
    {
        // If a connect message comes back, fire the Connect event
        case FD_CONNECT:
              if (wserr != WSANOERROR)
                FireSockError((OLE_HANDLE) hTask, wserr);
            else
            {
                FireConnect((OLE_HANDLE) hTask);
            }
            break;

        // Not yet handling a close message
        case FD_CLOSE:
            break;

        // When data is incoming, call the RecvData event
        case FD_READ:
        {
            FireRecvData((OLE_HANDLE) hTask, NULL);
            break;
        }

        // Not yet handling a ready to write message
        case FD_WRITE:
            break;

        // Not yet handling an out of band data message
        case FD_OOB:
            break;

        // Not yet handling an accept message
        case FD_ACCEPT:
            break;

        default:
            break;
    }

    return TRUE;
}

// Wrap the getservbyname function - returning a port ID when
// given a service like "finger." This only handles tcp now, not
// udp.

short CMSJSockCtrl::getservbyname(LPCTSTR service) 
{
    short port;
    LPSERVENT servent;

    servent = ::getservbyname(service, "tcp");
    port = servent-&gt;s_port;

    // Convert the port from network byte order to host
    // machine byte order and return.
    return ntohs(port);
}

// Wrap the WSAAsyncSelect call for the container's sake. This
// automatically routes incoming messages to this control's
// window.

long CMSJSockCtrl::AsyncSelect(long socket, long msg) 
{
    return WSAAsyncSelect(socket, m_hWnd, WSCB_ASELECT, msg);
}

// Wrap the functions needed to perform a connect to a port/host.

OLE_HANDLE CMSJSockCtrl::connect(long socket, short port, OLE_HANDLE phostent) 
{
    hostent he;
    u_long addr;
    sockaddr_in ca;

    // Copy the hostent data handle from the container to a real
    // hostent structure.

    memcpy((LPVOID) &amp;he, (LPVOID) phostent, sizeof(hostent));

    // Get the IP address from the hostent.

    addr = (*(u_long FAR *) he.h_addr_list[0]);

    // Fill in the sockaddr_structure so we can connect to
    // the specific port and IP address
    ca.sin_family      = AF_INET;
    ca.sin_port        = htons(port); // Convert from our format to net format
    ca.sin_addr.s_addr = addr;
               
    // Make the control watch for connections
    WSAAsyncSelect(socket, m_hWnd, WSCB_ASELECT, FD_CONNECT);

    // Call the API connect() function, returning immediately.
    // The container will get a Connect event when the
    // connection is complete.

    return ::connect(socket, (LPSOCKADDR) &amp;ca, sizeof(sockaddr_in));
}</PRE>
<P></P>
<P><B> Figure 3  FLIPPER</B></P>
<P></P>
<P>FLIPPER.FRM (procedures)</P>
<P><BR></P>
<PRE> '-----------------------------------------------------
' Flipper.FRM
'   This is the form definition for Flipper: The MSJ
'   Finger program.


'-----------------------------------------------------
' When the "Finger" button is clicked, Flipper should
' perform three tasks: create a socket, get the finger
' service port, and get the remote host's IP address
' given its name.

Private Sub btnFinger_Click()
    Dim rc
    sock = MSJSockCtrl.CreateSocket
    fingport = MSJSockCtrl.getservbyname("finger")
    rc = MSJSockCtrl.gethostbyname(edtSite.Text)
End Sub

'-----------------------------------------------------
' When a user types in the site or userid edit boxes,
' the "Finger" button is enabled or disabled depending
' on whether both boxes have data.

Private Sub edtSite_Change()
    If Len(edtUser) = 0 Or Len(edtSite) = 0 Then
        btnFinger.Enabled = False
    Else
        btnFinger.Enabled = True
    End If
End Sub

Private Sub edtUser_Change()
    If Len(edtUser) = 0 Or Len(edtSite) = 0 Then
        btnFinger.Enabled = False
    Else
        btnFinger.Enabled = True
    End If
End Sub

'-----------------------------------------------------
' When the form is loaded, disable the Finger
' button until both userid and site are filled in.

Private Sub Form_Load()
    btnFinger.Enabled = False
End Sub


'-----------------------------------------------------
' MSJSockCtrl_connect is an event called by the MSJSock
' OLE control when a successful connection has been made.
' If you want, you can track a particular task by its handle
' (given here as hTask)

Private Sub MSJSockCtrl_connect(ByVal hTask As Long)
    Dim rcl As Long, rc As Integer
    
    ' TellMSJSockcntrltowatchfor"readytoread,""readyformorewriting,"
    ' and "connection closed" events.
    rcl = MSJSockCtrl.AsyncSelect(sock, FD_READ + FD_WRITE + FD_CLOSE)
    
    ' send() is a direct WINSOCK API call. It sends the indicated
    ' text to the socket specified. In this case, we're just sending
    ' a username to the finger port...
    rc = send(sock, edtUser.Text, Len(edtUser.Text), 0)
    
    ' ...and appending a CR-LF pair.
    rc = send(sock, Chr$(13) &amp; Chr$(10), 2, 0)
End Sub

'-----------------------------------------------------
' When we called gethostbyname when the Finger button is
' clicked, it had to go off and find the host's IP address. When
' the OLE control gets that data back, it returns it by calling
' the GotHost event.

Private Sub MSJSockCtrl_GotHost(ByVal hostent As Long)
    ' Now that we have a pointer to the host's address (in hostent),
    ' we can take the socket we created earlier and connect it to
    ' the appropriate host and its finger port.
    Call MSJSockCtrl.Connect(sock, fingport, hostent)
End Sub

'-----------------------------------------------------
' Whenever our TCP/IP stack receives data from the network,
' it notifies the MSJSock control. In turn, if the control is
' expecting some data, it informs the VB container program
' that data needs to be read by calling the RecvData event.

Private Sub MSJSockCtrl_RecvData(ByVal hTask As Long, ByVal Data As String)
    Dim msg As String
    Dim rc As String
    
    ' Initialize the variable-length string with 1024 blanks - enough room to
    ' read in data.
    msg = Space(1024)
    
    ' recv() is part of WINSOCK.DLL. Since we've just been notified that
    ' there's data to receive, Flipper calls it to receive the data.
    rc = recv(sock, msg, 1024, 0)
    
    ' Trim the network input and display it in the output text box.
    lblOutput = Trim(msg)
End Sub

'-----------------------------------------------------
' If the MSJSock control returns a WinSock error, filter it through our 
' WSERROR.BAS and display it for the user.

Private Sub MSJSockCtrl_SockError(ByVal hTask As Long, ByVal ENum As Integer)
    MsgBox "WinSock error " &amp; ENum &amp; "(" &amp; WSErrStr(ENum) &amp; ")", vbOKOnly,_  
    "WinSock Error"
End Function</PRE>
<P></P>
<P>WINSOCK.BAS </P>
<P><BR></P>
<PRE> '--------------------------------------------------------
' WINSOCK.BAS
'   This file contains Declares for some of the more
'   popular Windows Socket functions.

Global sock As Long ' Our own personal socket!
Global fingport As Integer

' Constants for use with the WSAAsyncSelect call

Global Const FD_READ = &amp;H1
Global Const FD_WRITE = &amp;H2
Global Const FD_OOB = &amp;H4
Global Const FD_ACCEPT = &amp;H8
Global Const FD_CONNECT = &amp;H10
Global Const FD_CLOSE = &amp;H20


' These are some of the standard Windows Socket calls we need in
' Flipper, defined for both 16- and 32-bit versions of the DLL.

#If Win16 Then
Declare Function oBind Lib "winsock.dll" Alias "bind" (ByVal s As Integer,_ <BR>Addr As sockaddr_in, ByVal namelen As Integer) As Integer
Declare Function htonl Lib "winsock.dll" (ByVal a As Long) As Long
Declare Function inet_addr Lib "winsock.dll" (ByVal s As String) As Long
Declare Function inet_ntoa Lib "winsock.dll" (ByVal inn As Long) As Long
Declare Function ntohl Lib "winsock.dll" (ByVal a As Long) As Long
Declare Function oSocket Lib "winsock.dll" Alias "socket" (ByVal af As_ <BR>Integer, ByVal typesock As Integer, ByVal protocol As Integer) As Integer
Declare Function htons Lib "winsock.dll" (ByVal a As Integer) As Integer
Declare Function ntohs Lib "winsock.dll" (ByVal a As Integer) As Integer
Declare Function oConnect Lib "winsock.dll" Alias "connect" (ByVal sock As_ <BR>Integer, sockstruct As sockaddr_in, ByVal structlen As Integer) As Integer
Declare Function send Lib "winsock.dll" (ByVal sock As Integer, ByVal msg As_ <BR>String, ByVal msglen As Integer, ByVal flag As Integer) As Integer
Declare Function recv Lib "winsock.dll" (ByVal sock As Integer, ByVal msg As_ <BR>String, ByVal msglen As Integer, ByVal flag As Integer) As Integer
Declare Function getsockname Lib "winsock.dll" (ByVal s As Integer, Addr As_ <BR>Any, ByVal namelen As Integer) As Integer
Declare Function getservbyname Lib "winsock.dll" (ByVal nm As String, ByVal_ proto As String) As Long

Declare Function WSAStartup Lib "winsock.dll" (ByVal a As Integer, b As_ WSAdata_type) As Integer
Declare Function WSACleanup Lib "winsock.dll" () As Integer
Declare Function WSAGetLastError Lib "winsock.dll" () As Integer

Declare Function lstrcpyn Lib "kernel" (ByVal lpszString1 As Any, ByVal_ <BR>lpszString2 As Long, ByVal cChars As Integer) As String
Declare Sub hmemcpy Lib "kernel" (hpvDest As Any, hpvSource As Any, ByVal_ cbCopy As Long)

#Else
Declare Function htonl Lib "wsock32.dll" (ByVal a As Long) As Long
Declare Function inet_addr Lib "wsock32.dll" (ByVal s As String) As Long
Declare Function inet_ntoa Lib "wsock32.dll" (ByVal inn As Long) As Long
Declare Function ntohl Lib "wsock32.dll" (ByVal a As Long) As Long
Declare Function oSocket Lib "wsock32.dll" Alias "socket" (ByVal af As_ <BR>Integer, ByVal typesock As Integer, ByVal protocol As Integer) As Integer
Declare Function htons Lib "wsock32.dll" (ByVal a As Integer) As Integer
Declare Function ntohs Lib "wsock32.dll" (ByVal a As Integer) As Integer
Declare Function send Lib "wsock32.dll" (ByVal sock As Integer, ByVal msg As_ <BR>String, ByVal msglen As Integer, ByVal flag As Integer) As Integer
Declare Function recv Lib "wsock32.dll" (ByVal sock As Integer, ByVal msg As_ <BR>String, ByVal msglen As Integer, ByVal flag As Integer) As Integer

Declare Function ogetservbyname Lib "wsock32.dll" Alias "getservbyname"_ 
(ByVal nm As String, ByVal proto As String) As Long
Declare Function gethostname Lib "wsock32.dll" (ByVal s As String, ByVal l As_ <BR>Integer) As Integer
Declare Function gethostbyname Lib "wsock32.dll" (ByVal s As String) As Long

Declare Function WSACleanup Lib "wsock32.dll" () As Integer
Declare Function WSAGetLastError Lib "wsock32.dll" () As Integer
Declare Function WSAAsyncGetHostByName Lib "wsock32.dll" (ByVal hWnd As_ <BR>Integer, ByVal wMsg As Integer, ByVal name As String, ByVal buf As String,_ <BR>ByVal buflen As Integer) As Integer

Declare Function lstrcpyn Lib "kernel32" Alias "lstrcpynA" (ByVal lpString1_ <BR>As Any, ByVal lpString2 As Long, ByVal iMaxLength As Long) As Long
Declare Sub hmemcpy Lib "kernel32" (hpvDest As Any, hpvSource As Any, ByVal_ cbCopy As Long)

#End If</PRE>
<P></P>
<P>When you write a WinSock-compliant program, the first thing your app needs to do is initialize socket services for its instance with a WSAStartup call. WSAStartup fills in a structure with some light information like the current WinSock version and a description string such as "Running Under Windows 95." Since I'm using my MSJSock OCX to make some of the structure-passing calls easier, I've put the WSAStartup call in MSJSock's InitInstance function.</P>
<P>Next, the Visual Basic program calls the control's getservbyname method to get the correct port ID for the finger command. As I mentioned earlier, a site can support more than one function—for instance, one server can provide both finger and FTP services. This is done through dedicated port numbers. It is understood that when a user sends a message to the finger port (usually number 79), they're sending a finger command. However, on the off chance that a server has a nonstandard implementation, or you're using a specialized service, or you just want to make sure your local server supports a particular interface, WinSock provides getservbyname so you can be confident there's no funny business going on.</P>
<P>Now you have to look up the IP address for the site you're fingering. To keep track of all sites in a uniform manner, each is assigned a long integer address when it is founded. Service providers (such as MSN) know how to translate a string address such as "ftp.microsoft.com" into the matching long integer. Sometimes this number is broken up into four bytes, so that ftp.microsoft.com is reachable at 32008646, but is commonly known as 198.105.232.1 (198 + 105 x 256 + 232 x 256<SUP>2</SUP> + 1 x 256<SUP>3</SUP>). You'll be pleased to know, by the way, that when the current stock of long integers is exhausted in a few years, IP addresses will become longer, breaking everyone's software even worse than the changeover to the 21st century that is going to nuke all those two-digit year fields so popular on mainframe programs.</P>
<P>Retrieving a host by name is an asynchronous function. When you call the control's gethostbyname method, it sends the request off and returns immediately. MSJSock has a separate message—handling function that will be called by WinSock when the information is ready. This function (OnGetHostCB) calls the GotHost event in Visual Basic. The Visual Basic program is free to do whatever it pleases until MSJSock_GotHost is invoked. When MSJSock_GotHost is called, the OLE control passes Visual Basic a long integer called hostent, which is really a pointer to a structure describing the host address. You don't need to dereference this; you just need to pass it back when you connect to the host site.</P>
<P>To get an actual connection, you need three shards of information: the socket handle retrieved earlier, the port ID for fingering, and the hostent structure containing the site's IP address. The connection to the remote host can be initiated by calling the Connect method of the MSJSock control. MSJSock.Connect does two things. First, it calls WSAAsyncSelect. WinSock uses this function to determine where to send asynchronous notification messages for a particular socket. The caller chooses what sort of data to watch for. Here, you pass the FD_CONNECT flag to WSAAsyncSelect; this tells WinSock to let the control know when a connect action has completed. The control can then check the error code—if it's 0, it fires the MSJSock1_Connect event in Visual Basic. Otherwise, it calls MSJSock1_SockError to indicate an error occurred. I've set up a Select Case block in WINSOCK.BAS that will match known WinSock error codes with their names, so the program can pop up a MsgBox.</P>
<P>You're more than halfway there now: determining addresses and connections is the hardest part of WinSock programming. When MSJSock_Connect is triggered inside Flipper, it means you've connected correctly to the remote site's finger port. All that's left to finger a node is to send it a user name terminated with a CR-LF pair. In the control, I've exposed an AsyncSelect method that wraps the WSAAsyncSelect function. This time you want to trap a message any time WinSock tells you there's data from the remote site to be read, so pass it FD_READ. You can now call the WinSock send function directly from Visual Basic, specifying the socket ID and string. Since the earlier Connect call linked the specific remote site and port to the socket received, you don't have to tell WinSock where to route the data again.</P>
<P>The send call isn't really asynchronous, because it doesn't guarantee that data will be coming back. However, the remote host usually does something in response—in the case of finger, it sends back user information and status. When the MSJSock control captures an FD_READ notification from WinSock, it generates a RecvData event in Flipper. This only tells the Visual Basic program that data is available for retrieval, so it's that program's job to call the WinSock recv function in response. recv takes three parameters: the socket ID, an empty string where the data will be stuck, and the maximum length of this string. Instead of declaring a fixed-length string in Visual Basic, I've declared a variable length string, then initialized it with blanks: </P>
<P> </P>
<P><BR></P>
<PRE> strg$ = Space(1024)</PRE>
<P> </P>
<P>After this string is passed to recv, it can be trimmed (with the Trim function), then displayed in the text box I added to the program for just such a purpose. If all goes well, the Flipper program is complete (see <B>Figure 4</B>). Even if something goes wrong, it will display an error code.</P>
<P><img src="VISPRG4.gif"></P>
<P><B> Figure 4  Flipper</B></P>
<P>OK, so calling finger is sort of cinchy compared with other Internet protocols. It doesn't maintain a connection and doesn't make you learn a batch of commands to work properly. Unfortunately, describing each and every available service would make a book or two in itself—or a whole shelf of books, if you check out your local bookstore. There's no reason to let this scare you away from the job, however. There's a big need out there for commercial-quality 32-bit news readers, Telnet programs, and just about anything you might be interested in developing.</P>
<P>The various service protocols are described in documents called RFCs (Request For Comments) and STDs (standards). The first thing you should do is determine what type of program you're writing, then grab the documentation on it so you know what commands a server supports (see <B>Figure 5</B>). There's nearly 2000 Internet, TCP/IP, and sockets RFCs currently available, stretching all the way back to 1969. There are a few sources for RFCs. If you have Internet software, you can ftp anonymously to ds.internic.net, then retrieve files from the /rfc directory. An excellent book, <I>Developing for the Internet with Winsock</I> by Dave Roberts (Coriolis Group Books, 1995), comes with a CD-ROM with every piece of Internet and sockets documentation you'll ever find. <B>Figure 5</B> shows the most common Internet services and the matching RFCs.</P>
<P><B> Figure 5  Common Internet Services</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="135pt" VALIGN="TOP"><COL WIDTH="306pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Internet Service</B></P></TD><TD VALIGN="TOP"><P><B>Info location</B></P></TD></TR><TR><TD VALIGN="TOP"><P> Mail (send)</P></TD><TD VALIGN="TOP"><P>STD 010, SMTP-Simple Mail Transfer Protocol</P></TD></TR><TR><TD VALIGN="TOP"><P> Mail (receive)</P></TD><TD VALIGN="TOP"><P>RFC1460, POP3-PostOfficeProtocol</P></TD></TR><TR><TD VALIGN="TOP"><P> Usenet</P></TD><TD VALIGN="TOP"><P>RFC 0977, Network News Transmission Protocol</P></TD></TR><TR><TD VALIGN="TOP"><P> World Wide Web (HTML)</P></TD><TD VALIGN="TOP"><P>RFC 1866, "Hypertext Markup Language - 2.0"</P></TD></TR><TR><TD VALIGN="TOP"><P> WWW (HTTP)</P></TD><TD VALIGN="TOP"><P>ftp://info.cern.ch/pub/www/doc/http.txt</P></TD></TR><TR><TD VALIGN="TOP"><P> Gopher </P></TD><TD VALIGN="TOP"><P>RFC 1436, "The Internet Gopher Protocol (a distributed document search and retrieval protocol)"</P></TD></TR><TR><TD VALIGN="TOP"><P> Telnet </P></TD><TD VALIGN="TOP"><P>RFC 0854, "Telnet Protocol specification"</P></TD></TR><TR><TD VALIGN="TOP"><P> Chat </P></TD><TD VALIGN="TOP"><P>RFC 1459, "Internet Relay Chat Protocol"</P></TD></TR><TR><TD VALIGN="TOP"><P> Finger</P></TD><TD VALIGN="TOP"><P>RFC 1288</P></TD></TR><TR><TD VALIGN="TOP"><P> Internet Phone</P></TD><TD VALIGN="TOP"><P>RFC 1789, "INETPhone: Telephone Services and Servers on Internet"</P></TD></TR><TR><TD VALIGN="TOP"><P> FTP</P></TD><TD VALIGN="TOP"><P>RFC 1350, "The TFTP Protocol (revision 2)" STD 009</P></TD></TR></TBODY></TABLE>
<P><BR></P><H2><A NAME="sec2"></A>  Simple Sockets</H2><P>To assist you in debugging your socket-based program, I've developed a small program called Simple Sockets. It's an interactive dialog that lets you send commands to a server and see what gets returned from it. The entire transaction is displayed in a Windows 95 RichText edit box, tagged by color so you can easily see what's up.</P>
<P>As an example, I've downloaded RFC 0977 (the Usenet NNTP news protocol) and now I want to see just how it works. As you may or may not know, Usenet is the name for a network of servers that trade user-posted articles on every topic ever imagined (about 16,000 in all at press time). Using a newsreader, you can browse articles by title or number, post followups, or save and print especially useful tidbits. It's a distributed system with no single home, so you'll be sure to see many fruitless efforts by bureaucrats to legislate its content over the next few years.</P>
<P>But anyway. I need two things to connect: the name of my news server (nntp.ix.netcom.com) and the NNTP port (119 is standard; this is given in the RFC). I enter the two values and click connect, and Windows 95 either performs an auto-login with the Dial-Up Adapter for me or connects me to a running instance of WinSock. Non-text-returning actions like this are displayed as informational messages in blue. When the program indicates "Connected to host," I can start sending my commands, which show up in green. Whenever my program receives something from the host, it's appended to the RichText edit in red, and should a WinSock error occur (a bad server name, for instance), the message will show up in black (see <B>Figure 6</B>).</P>
<P><img src="VISPRG6.gif"></P>
<P><B> Figure 6  MSJ Simple Sockets</B></P>
<P>On my server, I have to sign on with the AUTHINFO command, providing my username and password. I enter it in the edit field provided, then click the Send button or hit enter. After a couple of seconds, I receive back an informational message from nntp.ix.netcom.com: "501 user Name|pass Password." Looking up a message code 501 in the RFC, I'm told that my command had a syntax error. I'm not upset, because it seems to work anyway.</P>
<P>Without going into too much detail, an NNTP server will provide a list of all available newsgroups with the LIST command. Be sparing with it, though—it returns the names of all 16,000 groups, plus or minus. Once you get this list downloaded once, you can use the NEWGROUPS command to see all additions from a certain date.</P>
<P><B>Figure 6</B> shows some other NNTP commands in action. I've decided to check out the action on alt.fan.surak. (And I don't need any editorial comment from you either.) The GROUP command returns an informational code (211, which means it's a reply to a GROUP command, as documented in the RFC). It also tells you the number of articles available, the first and last articles available, and the group name. Instead of doing this for 16,000 groups every time a user starts a program, news readers usually have a local "subscribe" option, which really only makes an internal list of which groups it should check for content automatically.</P>
<P>After selecting a group with GROUP, it is implicitly assumed that you're operating on it with further commands. For instance, I've issued an ARTICLE command to receive a particular numbered article (along with a couple of bad commands just to show what they might output). Article 2615 is returned to my program, headers, text and all. I'm now just a little bit more caught up with the world of Surak fandom. I know, it's too good to be true. Anyway, MSJ Simple Sockets source code is shown in <B>Figure 7</B>.</P>
<P><B> Figure 7  Simple Sockets.FRM</B></P>
<P><BR></P>
<PRE> VERSION 4.00
Begin VB.Form frmSimple 
   Caption         =   "MSJ Simple Sockets"
   ClientHeight    =   6705
   ClientLeft      =   1215
   ClientTop       =   1545
   ClientWidth     =   8445
   Height          =   7125
   Left            =   1155
   LinkTopic       =   "Form1"
   ScaleHeight     =   6705
   ScaleWidth      =   8445
   Top             =   1185
   Width           =   8565
   Begin VB.CommandButton btnSend 
      Caption         =   "&amp;Send"
      Height          =   375
      Left            =   7440
      TabIndex        =   8
      Top             =   1080
      Width           =   855
   End
   Begin VB.TextBox edtOutput 
      Height          =   285
      Left            =   120
      TabIndex        =   7
      Top             =   1200
      Width           =   7215
   End
   Begin VB.TextBox edtPort 
      Height          =   285
      Left            =   840
      TabIndex        =   4
      Text            =   "119"
      Top             =   480
      Width           =   2895
   End
   Begin VB.TextBox edtSite 
      Height          =   285
      Left            =   840
      TabIndex        =   1
      Text            =   "nntp.ix.netcom.com"
      Top             =   120
      Width           =   2895
   End
   Begin VB.CommandButton btnConnect 
      Caption         =   "Connect"
      Height          =   375
      Left            =   3840
      TabIndex        =   0
      Top             =   120
      Width           =   1215
   End
   Begin VB.Label Label5 
      BackStyle       =   0  'Transparent
      BorderStyle     =   1  'Fixed Single
      Caption         =   "Outbound"
      ForeColor       =   &amp;H00008000&amp;
      Height          =   255
      Left            =   5520
      TabIndex        =   12
      Top             =   120
      Width           =   1215
   End
   Begin VB.Label Label4 
      BackStyle       =   0  'Transparent
      BorderStyle     =   1  'Fixed Single
      Caption         =   "Inbound"
      ForeColor       =   &amp;H000000FF&amp;
      Height          =   255
      Left            =   6840
      TabIndex        =   11
      Top             =   480
      Width           =   1455
   End
   Begin VB.Label Label3 
      BackStyle       =   0  'Transparent
      BorderStyle     =   1  'Fixed Single
      Caption         =   "WinSock Errors"
      Height          =   255
      Left            =   5520
      TabIndex        =   10
      Top             =   480
      Width           =   1215
   End
   Begin VB.Label Label2 
      BackStyle       =   0  'Transparent
      BorderStyle     =   1  'Fixed Single
      Caption         =   "Info"
      ForeColor       =   &amp;H00FF0000&amp;
      Height          =   255
      Left            =   6840
      TabIndex        =   9
      Top             =   120
      Width           =   1455
   End
   Begin RichtextLib.RichTextBox redInOut 
      Height          =   5055
      Left            =   120
      TabIndex        =   6
      Top             =   1560
      Width           =   8175
      _Version        =   65536
      _ExtentX        =   14420
      _ExtentY        =   8916
      _StockProps     =   69
      BackColor       =   -2147483643
      ScrollBars      =   2
      TextRTF         =   $"Simple Sockets.frx":0000
   End
   Begin VB.Label Label1 
      Alignment       =   1  'Right Justify
      Caption         =   "Port:"
      Height          =   255
      Left            =   120
      TabIndex        =   5
      Top             =   480
      Width           =   615
   End
   Begin VB.Label lblSite 
      Alignment       =   1  'Right Justify
      Caption         =   "Server:"
      Height          =   255
      Left            =   120
      TabIndex        =   3
      Top             =   120
      Width           =   615
   End
   Begin MSJSOCKLib.MSJSock MSJSockCtrl 
      Height          =   375
      Left            =   120
      TabIndex        =   2
      Top             =   120
      Width           =   375
      _Version        =   65536
      _ExtentX        =   661
      _ExtentY        =   661
      _StockProps     =   0
   End
End
Attribute VB_Name = "frmSimple"
Attribute VB_Creatable = False
Attribute VB_Exposed = False


' SIMPLE SOCKETS.FRM -
'   This is the main (and only) form for the MSJ Simple Sockets program.
'   It connects to a user-supplied server and port, and allows the user to 
'   interactively type commands to the server. Results are shown in a jaunty,
'   multicolored rich text edit box.


'--------------------------------------------------------------------------

Private Sub btnConnect_Click()
    ' Using the MSJSock control, create a socket
    sock = MSJSockCtrl.CreateSocket

    ' Get the port the user typed in, as an integer
    port = CInt(edtPort.Text)

    ' Look up the user-supplied host name. This will come back as a
    ' GotHost event later on, at which point the connection will continue.
    host = MSJSockCtrl.gethostbyname(edtSite.Text)

    ' Add informational text to the output RTE (rich text edit), colored blue
    Call DebugToList("Connecting to host " &amp; edtSite.Text &amp; " port " _
                     &amp; port &amp; Chr$(13) &amp; Chr$(10), RGB(0, 0, 255))
End Sub

'--------------------------------------------------------------------------

Private Sub btnSend_Click()
    ' When the user clicks the send button, send their current typed-in
    ' command, with a CR-LF appended
    rc = WSSend(sock, edtOutput.Text &amp; Chr$(13) &amp; Chr$(10))
End Sub

'--------------------------------------------------------------------------

Private Sub edtOutput_KeyPress(KeyAscii As Integer)
    ' If the user hits &lt;enter&gt;, treat it just as if they'd clicked the
    ' Send button.
    If KeyAscii = 13 Or KeyAscii = 10 Then
        btnSend_Click
    End If
End Sub

'--------------------------------------------------------------------------

Private Sub MSJSockCtrl_connect(ByVal hTask As Long)
    Dim rcl As Long
    
    ' When the host connects, print an informational message to the RTE
    Call DebugToList("Connected to host." &amp; Chr$(13) &amp; Chr$(10), RGB(0, 0, 255))
    
    ' Now that you're connected, have the MSJSock control capture read and
    ' write messages
    rcl = MSJSockCtrl.AsyncSelect(sock, FD_READ + FD_WRITE + FD_CLOSE)
End Sub

'--------------------------------------------------------------------------

Private Sub MSJSockCtrl_GotHost(ByVal hostent As Long)
    Dim rcl As Long

    ' Once you've found the host, tell the MSJSock control to form a
    ' connection to it using the current socket and user-indicated port.
    rcl = MSJSockCtrl.Connect(sock, port, hostent)
End Sub

'--------------------------------------------------------------------------

Private Sub MSJSockCtrl_RecvData(ByVal hTask As Long, ByVal Data As String)
    Dim msg As String
    
    ' When the MSJSock control receives incoming data, call the WinSock
    ' recv API function to retrieve it 10k at a time.
    msg = Space(10240)
    rc = recv(sock, msg, 10240, 0)

    msg = Trim(msg)

    ' Put the received information into the RTE box using red text, so you
    ' can tell it from other messages.
    DebugToList msg, RGB(127, 0, 0)
End Sub

'--------------------------------------------------------------------------

Private Sub MSJSockCtrl_SockError(ByVal hTask As Long, ByVal ENum As Integer)
    ' Print WinSock errors to the RTE using black.
    DebugToList "WinSock error " &amp; ENum &amp; ": " &amp; WSErrStr(ENum) &amp; Chr$(13) &amp; <BR>Chr$(10), RGB(0, 0, 0)
End Sub

'--------------------------------------------------------------------------

Sub DebugToList(dbgtxt As String, clr As Long)
    Dim prvlen As Long
    
    ' DebugToList appends colored text to a rich text edit (RTE) box. Since
    ' you can't just do Ctrl.Text = Ctrl.Text + newtext (you'd overwrite all
    ' the old formatting, you have to move the insertion point to the end
    ' and insert new text.

    ' Find the location the new text will start (at the end of the old text)
    prvlen = Len(redInOut.Text)

    ' Move the insertion point to the end of the RTE box
    redInOut.SelStart = Len(redInOut.Text) + 1

    ' Replace the selection (which is nothing right now) with the new
    ' text, appending it without changing the previous formatting.
    redInOut.SelText = dbgtxt

    ' Now select the entire inserted text
    redInOut.SelStart = prvlen
    redInOut.SelLength = Len(dbgtxt)

    ' Change the selected (newly inserted) text to the requested color
    redInOut.SelColor = clr


    ' Move the insertion point back to the end of the RTE
    redInOut.SelStart = Len(redInOut.Text) + 1
End Sub

'--------------------------------------------------------------------------

Sub HandleWSError(rc As Integer)
    ' Check for an unhandled WinSock error. If there is one, handle it
    ' just like an error coming in from the MSJSock control.
    If (rc = SOCKET_ERROR) Then
        WSErrorN = WSAGetLastError()
        Call MSJSockCtrl_SockError(-1, WSErrorN)
    End If
End Sub

'--------------------------------------------------------------------------

Function WSSend(wsock As Long, strg As String) As Integer
    Dim rc As Integer

    ' As the user sends data, send it to the RTE in green.
    DebugToList strg, RGB(0, 127, 0)

    ' Call the WinSock API send function to send the data.
    rc = send(wsock, strg, Len(strg), 0)
    
    DoEvents

    ' Check to see if send returned an error. If so, it will be handled
    ' by HandleWSError
    HandleWSError rc
    WSSend = rc
End Function</PRE>
<P></P>
<P>Naturally, there's a lot of tracking work to be done for a full-blown news reader. However, with MSJ Simple Sockets, you can see what's actually going on behind the scenes with NNTP, or any other protocol you'd like to test out.</P>
<P> </P>
<H2><A NAME="sec3"></A>  Summary</H2><P>Windows Sockets programming is currently the only pathway to every protocol and function provided on the Internet. However, up till now it's been seen as just beyond the reach of Visual Basic programmers. I've provided two components to change this—the MSJSock OLE control and the MSJ Simple Sockets Visual Basic application. With surprisingly little code, you can write a real Internet-enabled program in Visual Basic. If you get something on the market, all I ask is that you send me a couple of shares of your Internet company stock. </P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
