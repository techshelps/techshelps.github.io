<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extend the Windows 95 Shell with Application Desktop Toolbars</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Extend the Windows 95 Shell with Application Desktop Toolbars</H1><P>Jeffrey Richter</P>
<P>Jeffrey Richter wrote <I>Advanced Windows</I> (Microsoft Press, 1995) and <I>Windows 95: A Developer</I><I>'</I><I>s Guide</I> (M&amp;T Books, 1995). Jeff is a consultant and teaches Win32-based programming seminars. He can be reached at v-jeffrr@microsoft.com.</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4595">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the TOOLBARS project files.</A></P><P></P>
<P>The Windows® 95 shell is more than just a pretty face. It's easy to customize, unlike the old Program Manager. The Programmer's Guide to Microsoft Windows 95 (Microsoft Press, 1995) will give you an idea of the many ways in which the shell can be extended,  but I've found the documentation to be scanty and sometimes incorrect. Here, I'm going to throw some light on the subject by examining one kind of shell extension, application desktop toolbars.</P>
<P>But first, let's go over exactly what I'm referring to with the "shell." After the system boots, the system creates the desktop window, the parent of all top-level windows that you create.  The window procedure for the desktop window is inside USER.EXE and is responsible for displaying the user's selected wallpaper.</P>
<P>One of the last things that Windows 95 does when it boots is look in the SYSTEM.INI file. This file has an entry that looks like this:</P>
<P> </P>
<P><BR></P>
<PRE> [Windows]
Shell=Explorer.exe</PRE>
<P> </P>
<P>This tells Windows 95 to execute the Explorer.exe application (you can change this entry if you prefer to have a different application run as your shell).  Explorer.exe is the Windows 95 shell. When Explorer.exe is invoked, it creates a TaskBar window which, by default, is positioned at the bottom of your screen. Explorer.exe also creates a child window that fills the entire workarea but still displays the Desktop window's wallpaper (the term workarea will be covered later in this article). This child window is actually one of the new ListView common controls that always shows its contents using the Large Icon style.  This ListView control is what we usually think of as the New Windows 95 Shell.  Because this control covers the entire workarea, double-clicking the mouse over the ListView does NOT bring up the Task Manager because the mouse messages are not being received by the desktop window anymore.</P>
<P> </P>
<H2><A NAME="sec0"></A>  Application Desktop Toolbars</H2><P>An application desktop toolbar (or an appbar for short) is a window that attaches itself to an edge of your screen. An application can have more than one appbar—the program decides how many. The shell's taskbar window is a well-known example of an appbar. It is nothing more than a window that contains several child windows: the Start button, a notification window (which contains a clock), and a SysTabControl32 common control. What makes an appbar different from other windows is that it is always accessible to the user. This means the user always has the ability to start applications, find files, request help, shut down the system, and so on.</P>
<P>Currently, very few products offer appbars. In fact, the only software I'm aware of that ships with its own appbar is Microsoft® Office for Windows 95. Included in this suite is an app called MSOFFICE.EXE that creates an appbar window. <B>Figure 1</B> shows the shell's taskbar and the Microsoft Office shortcut bar.</P>
<P><img src="SHELL1.gif"></P>
<P><B> Figure 1  Taskbar and shortcut bar.</B></P>
<P>I expect many applications to offer application desktop toolbars eventually. Imagine a stock ticker application bar that constantly displays the current trading activity. The user could easily dock the appbar on an edge of the screen, and the information would always be visible.</P>
<P>Here are some other possibilities for application desktop toolbars:</P>
<UL><LI>    To constantly display system statistics such as CPU usage, available memory, available resources, paging file size, and so on.</LI><LI>   To report scores of sporting events (connecting to an online service provider).</LI><LI>   For quickly launching applications like the Microsoft Office shortcut bar.</LI><LI>   For real-time net chatting. The appbar window could have messages that come to you in a read-only edit control; messages that you send could be entered in a read/write edit control.</LI><LI>   A calculator.</LI><LI>   To display the time and location of your next meeting.</LI><LI>   As a phone dialer</LI></UL><P> </P>
<H2><A NAME="sec1"></A>  Properties of Appbars</H2><P>Though appbars are usually docked on an edge of the user's screen, they also can float. To make room for an appbar that's docked, the Windows 95 shell shrinks the size of the screen's workarea. The workarea is a new concept in Windows; it's the portion of the screen that is not occupied by any appbars. You query the system for the rectangle that bounds the current workarea by calling the SystemParametersInfo function:</P>
<P> </P>
<P><BR></P>
<PRE> RECT rc;<BR>SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rc, 0);<BR>// rc now contains the workarea in screen coordinates</PRE>
<P> </P>
<P>Whenever the user maximizes a window, the system ensures that the window fills the workarea, not the full screen. If an appbar is docked on the edge of the screen, moved from one edge of the screen to another, or removed from an edge of the screen, the system automatically resizes and repositions any maximized windows so that they always fill the workarea completely. In addition, when the upper-left corner of the workarea changes, the system shifts all the application windows on the screen so that they always maintain their relative distance from that corner.</P>
<P>Although the system ensures that maximized windows are restricted to the workarea, the system does allow nonmaximized windows to overlap appbar windows. When overlapped, the windows follow the normal z-order rules. But both the shell's taskbar and the Office for Windows 95 shortcut bar offer an "Always on top" feature, and so can your appbar.</P>
<P>Because screen real estate is always at a premium, appbars also offer a feature called "autohide." When this is enabled, the appbar is almost completely off the screen when not in use. The appbar positions itself so that the bulk of its window is clipped off the screen: only a border a few pixels wide is visible. To use the appbar, the user positions the mouse over the border. When the appbar detects the mouse move message, it slides itself out onto the screen. When the mouse is moved away, the appbar slides itself back off the edge of the screen.</P>
<P>To freeze an appbar into place so it won't slither away, you click on it, which activates it and gives it the focus. To unfreeze the appbar, you merely activate another window.</P>
<P>Personally, I love the autohide feature of appbars and always set this feature on for the shell's taskbar. There is one important thing to note: the shell allows only one autohide appbar per edge of the screen (see <B>Figure 2</B>). The shell enforces this rule because two autohide appbars on the same edge would overlap each other completely. This would prevent the user from activating one of the appbars. You can perform the following experiment to see the shell enforce this rule: first dock the taskbar at the bottom of your screen, then dock the Office for Windows 95 shortcut bar on the top of your screen; finally, turn the autohide feature on for both of these appbars. Now, drag the Office 95 shortcut bar to the bottom edge of your screen where the taskbar is located. The message box shown in <B>Figure 2</B> will appear and the shortcut bar will automatically turn off the autohide feature for itself.</P>
<P><img src="SHELL2.gif"></P>
<P><B> Figure 2  </B></P>
<P>An appbar can be moved by grabbing the appbar's client area and dragging. To determine which edge the appbar should be docked to, imagine that an X is drawn in the workareaasshownin<B>Figure3</B>.Theappbarisdockeddependingonwherethemouseisreleasedinrelationto the X.</P>
<P><img src="SHELL3.gif"></P>
<P><B> Figure 3  Docking appbars.</B></P>
<P>Appbars can be resized by the user if the programmer has allowed for it. For example, the shell's taskbar allows itself to be resized. But when the taskbar is docked on the top or bottom of the screen, only its height can be adjusted; when it is docked on the left or right of the screen, only its width can be adjusted. The Office for Windows 95 shortcut bar allows itself to be resized only when it is floating.</P>
<P> </P>
<H2><A NAME="sec2"></A>  Implementing an Appbar</H2><P>Idecidedto create an MFC class, which I call CAppBar, that would package all of the features of application toolbars together so that it would be easy to create any type of appbar. My CAppBar class is derived from CDialog so that you can easily construct an appbar from a dialog box template.</P>
<P>Since the documentation on appbars is poor (actually, describing it as horrendous is paying it too much of a compliment), I will now properly explain the entire application desktop toolbar API. I'll show how to use my CAppBar class for your own appbars later in this article.</P>
<P>Working with appbars requires just one function:</P>
<P> </P>
<P><BR></P>
<PRE> UINTSHAppBarMessage(DWORDdwMessage,  <BR>                  PAPPBARDATApabd);</PRE>
<P> </P>
<P>dwMessage tells the shell why you are calling it. You can pass any of the 10 ABM_xxx identifiers (discussed shortly) for this parameter. The pabd parameter is a pointer to an APPBARDATA structure that contains additional information:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct _AppBarData {<BR>   DWORD  cbSize;<BR>   HWND   hWnd;<BR>   UINT   uCallbackMessage;<BR>   UINT   uEdge;<BR>   RECT   rc;<BR>   LPARAM lParam;<BR>} APPBARDATA, *PAPPBARDATA;</PRE>
<P> </P>
<P>When initializing this structure, you must set the cbSize member to the size of APPBARDATA. The remaining members may or may not need to be initialized depending on the value of dwMessage.</P>
<P>The shell maintains a list of data structures that it uses to manage appbars. (Microsoft expects that appbars will be enhanced in future versions of Windows; therefore some of this information will change.)</P>
<P> </P>
<P><BR></P>
<PRE> struct INTERNALAPPBARDATA {<BR>   HWND hWnd;<BR>   UINT uCallbackMessage;<BR>   UINT uEdge;<BR>   RECT rc;<BR>};</PRE>
<P> </P>
<P>There is one structure in the list for each appbar window. If you want a window to be an appbar, you must register it with the shell by initializing an APPBARDATA structure and calling SHAppBarMessage as follows:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowToRegister;<BR>abd.uCallbackMessage = WM_USER + 100;<BR>// Ignored members: uEdge, rc, lParam<BR>SHAppBarMessage(ABM_NEW, &amp;abd);</PRE>
<P> </P>
<P>The ABM_NEW message tells the shell to add a data structure to its internal list. The internal data structure's hWnd and uCallbackMessage members are initialized with the values passed in the APPBARDATA structure but no position information is retained at this point. If the window handle you pass is already registered with the shell, SHAppBarMessage does nothing and simply returns FALSE.</P>
<P>When your window is being destroyed, unregister it with the shell like so:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowToUnregister;<BR>// Ignored members: uCallbackMessage, uEdge, rc, lParam<BR>SHAppBarMessage(ABM_REMOVE, &amp;abd);</PRE>
<P> </P>
<P>The ABM_REMOVE message tells the shell to remove a data structure from its internal list. The APPBARDATA's hWnd member indicates which window to remove. Just before SHAppBarMessage returns, it sends out an ABN_POSCHANGED notification to all the remaining appbars so that they can reposition themselves. For example, an appbar might be able to move closer to the edge of the screen if an appbar that was on the edge of the screen is unregistered. Appbar notifications are discussed later in this article.</P>
<P>Now, how do you tell the shell where you want the appbar to be positioned onscreen? It's not as simple and straightforward as you might like, because you want to ensure that your appbar does not overlap any others. First call SHAppBarMessage requesting a screen edge and a rectangle (in screen coordinates) for the window:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowToPosition;<BR>abd.uEdge = uEdgeToDockOn;<BR>SetRect(&amp;abd.rc, 0, 0, GetSystemMetrics(SM_CXSCREEN),<BR>        GetSystemMetrics(SM_CYSCREEN));<BR>// Ignored members: uCallbackMessage, lParam<BR>SHAppBarMessage(ABM_QUERYPOS, &amp;abd);</PRE>
<P> </P>
<P>Sending an ABM_QUERYPOS message causes SHAppBarMessage to compare your requested rectangle with the list of registered appbars. If your request interferes with any existing appbars, SHAppBarMessage alters the coordinates of the rectangle. Notice I always pass a rectangle that represents the full screen—this makes things easier. As SHAppBarMessage cycles through the registered appbars, it reduces the size of the rectangle. When SHAppBarMessage returns, abd.rc.left has the leftmost pixel at which my window can be, assuming that I want to dock on the left,abd.rc.top has the topmost pixel at which my window can be, assuming that I want to dock on the top, and so on.</P>
<P>Once you know where you can position the appbar, calculate its size.</P>
<P> </P>
<P><BR></P>
<PRE> switch (abd.uEdge) {<BR>   case ABE_LEFT:<BR>     abd.rc.right = abd.rc.left + uWidthWhenDockedOnLeft;<BR>     break;<BR><BR>    case ABE_TOP:<BR>     abd.rc.bottom = abd.rc.top + uHeightWhenDockedOnTop;<BR>     break;<BR><BR>   case ABE_RIGHT:<BR>     abd.rc.left = abd.rc.right-uWidthWhenDockedOnRight;<BR>     break;<BR><BR>   case ABE_BOTTOM:<BR>     abd.rc.top=abd.rc.bottom-uWidthWhenDockedOnBottom;<BR>     break;<BR>}</PRE>
<P> </P>
<P>Once you have the final rectangle coordinates for the appbar, call SHAppBarMessage again:</P>
<P> </P>
<P><BR></P>
<PRE> // Leave all the members as they were when<BR>// the ABM_QUERYPOS message was sent<BR>// Ignored members: uCallbackMessage, lParam<BR>SHAppBarMessage(ABM_SETPOS, &amp;abd);</PRE>
<P> </P>
<P>This time, the ABM_SETPOS message tells the shell where you really want to position your appbar. When you send an ABM_SETPOS message, SHAppBarMessage recursively calls itself (only once, mind you) with an ABM_QUERYPOS message. This is because Windows 95 is a preemptive multitasking system. While you were calculating the size of your rectangle, another thread could have been registering or unregistering another appbar window with the shell, possibly where you want yours.</P>
<P>After the shell has determined where you can go, it records your edge and rectangle in your appbar's internal data structure and then an ABN_POSCHANGED notification isbroadcasttoalltheotherregisteredappbar windows.</P>
<P>When SHAppBarMessage finishes processing the ABM_SETPOS message, you'll want to call SetWindowPos so that your appbar moves to the correct location:</P>
<P> </P>
<P><BR></P>
<PRE> SetWindowPos(abd.hWnd, NULL, abd.rc.left, abd.rc.top,<BR>     abd.rc.right-abd.rc.left,abd.rc.bottom-abd.rc.top,<BR>     SWP_NOZORDER | SWP_NOACTIVATE);</PRE>
<P> </P>
<P>It's your responsibility to reposition your window; SHAppBarMessage never moves nor sizes any appbar windows.</P>
<P> </P>
<H2><A NAME="sec3"></A>  Making It Autohide</H2><P>The shell gives very little support for autohide appbars. For example, it would be very nice if the shell implemented the code to detect when an appbar window needs to slide on or off the screen, and it would also be nice if the shell did the work to slide the appbar window on and off the screen. But it doesn't, so you have to implement all this code yourself. All the shell does is keep an internal list of the autohide windows. It does this by maintaining a data structure that associates HWNDs with screen edges. Each HWND identifies the handle of an autohide window that is on an edge.</P>
<P>Here's how to set your appbar window as the autohide window for a particular edge:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowToMakeAutohide;<BR>abd.uEdge = uEdgeToAutoHideOn;<BR>abd.lParam = TRUE;      // Make us autohide<BR>// Ignored members: uCallbackMessage, rc<BR>SHAppBarMessage(ABM_SETAUTOHIDEBAR, &amp;abd);</PRE>
<P> </P>
<P>When you send the ABM_SETAUTOHIDEBAR message to SHAppBarMessage, the shell first checks to see if there is already a valid window handle set for the edge you specified in the APPBARDATA's uEdge member. If the edge doesn't have a valid window handle associated with it, the shell sets your appbar window as the autohide window and returns TRUE. If another window is set as the autohide window, SHAppBarMessage does nothing and returns FALSE. Your code should check this return value. If your appbar can't be set as autohide, you'll want to display a message box to the user like the one in <B>Figure 2</B>.</P>
<P>When you want to turn off autohide on your appbar window do the following:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowToMakeNotAutohide;<BR>abd.uEdge = uEdgeToAutohideOn;<BR>abd.lParam = FALSE;    // Make us NOT autohide<BR>// Ignored members: uCallbackMessage, rc<BR>SHAppBarMessage(ABM_SETAUTOHIDEBAR, &amp;abd);</PRE>
<P> </P>
<P>The only thing different in this call is that the APPBARDATA's lParam member is FALSE. This tells the shell to stop treating the specified  appbar as an autohide appbar for that edge. When unregistering an autohide appbar window, SHAppBarMessage always returns TRUE.</P>
<P>Be aware that the shell does not use its two internal lists together, making more work for you. Let's say that you register an appbar window by sending an ABM_NEW message and register it as autohide by sending ABM_SETAUTOHIDEBAR. SHAppBarMessage should then resize the workarea portion of the screen—but this does not happen. When another appbar sends ABM_QUERYPOS or ABM_SETPOS messages, SHAppBarMessage should see that your window is autohide and should not consider your appbar's rectangle when determining the location of the appbar sending the message. Again, this does not happen.</P>
<P>So, you need to do additional work. To make your registered appbar autohide you have two choices.</P>
<P>First you can unregister it as a regular appbar by sending ABM_REMOVE. Since you will now be removed from the shell's internal list, your appbar window and its dimensions will no longer be considered when determining the workarea's rectangle and you will no longer have an effect on the position of other appbar windows.</P>
<P>Your other choice is to keep yourself registered but change your registered rectangle dimensions so that the shell thinks that your window is 0 pixels wide by 0 pixels high. This is what I did in my CAppBar class. In my SetState function, you'll see the following lines of code:</P>
<P> </P>
<P><BR></P>
<PRE> if (IsBarAutoHidden()) {<BR>   SHAppBarMessage(ABM_SETPOS, ABE_LEFT,<BR>                   FALSE, &amp;CRect(0, 0, 0, 0));
                      .
                      .
                      .</PRE>
<P> </P>
<P>At times, you may want to query the shell and ask it which window is autohide on a particular edge:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndofOurAppBar;
abd.uEdge = uEdgeToCheck;<BR>// Ignored members: uCallbackMessage, rc, lParam<BR>HWND hwndAutohide = (HWND)<BR>   SHAppBarMessage(ABM_GETAUTOHIDEBAR, &amp;abd);</PRE>
<P> </P>
<P>You have to cast SHAppBarMessage's return value to an HWND. The return value is NULL if no window is registered as an autohide window on the specified edge. (The Programmer's Guide to Microsoft Windows 95 states that you must initialize the hWnd member of the APPBARDATA structure before sending the ABM_GETAUTOHIDEBAR messages. Currently, the SHAppBarMessage function ignores the hWnd member when processing an ABM_GETAUTOHIDEBAR message. However, I was told that future versions of the shell will require this member. So heed the documentation and always initialize the hWnd member correctly when you send an ABM_GETAUTOHIDEBAR message.)</P>
<P>Now and then, you might want to query the shell about its taskbar. For example, you can find out if the taskbar is always-on-top or autohide by executing the following:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>// Ignored members: hwnd, uCallbackMessage, uEdge, rc, 
// lParam<BR>BOOL fTaskBarIsAlwaysOnTop = <BR>   SHAppBarMessage(ABM_GETSTATE, &amp;abd) &amp; ABS_ALWAYSONTOP;<BR>BOOL fTaskBarIsAutohide = <BR>   SHAppBarMessage(ABM_GETSTATE, &amp;abd) &amp; ABS_AUTOHIDE;</PRE>
<P> </P>
<P>You can also get the position of the shell's taskbar by doing this:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>// Ignored members: hwnd, uCallbackMessage, uEdge, rc, 
// lParam<BR>SHAppBarMessage(ABM_GETTASKBARPOS, &amp;abd);<BR>// abd.rc contains the rectangular location<BR>// of the taskbar in screen coordinates.</PRE>
<P> </P>
<H2><A NAME="sec4"></A>  Z-order</H2><P>It's now time to look at the z-ordering of appbars. Whenever an appbar window receives a WM_ACTIVATE message, the appbar should notify the shell by executing the following code:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowBeingActivated;<BR>// Ignored members: uCallbackMessage, uEdge, rc, lParam<BR>SHAppBarMessage(ABM_ACTIVATE, &amp;abd);</PRE>
<P> </P>
<P>The ABM_ACTIVATE message tells the shell to move any autohide appbar on the appbar's edge to the foreground. Why? Imagine you have two appbars docked on the bottom of your screen. Both are in the topmost z-order but only one is autohide. Now, if the user works with the non-autohide appbar, the system activates this window and forces it to cover up the autohide appbar. Because the autohide appbar is completely obscured by the non-autohide appbar, the user has no way to access it. Avoid this situation by sending the ABM_ACTIVATE message to SHAppBarMessage. When this message is sent, the shell always forces autohide appbars to be on top of the non-autohide appbars.</P>
<P>To make sure that autohide appbars are always on top of non-autohide appbars, your appbar must also monitor WM_WINDOWPOSCHANGED messages. When one is received, you must notify the shell:</P>
<P> </P>
<P><BR></P>
<PRE> APPBARDATA abd;<BR>abd.cbSize = sizeof(abd);<BR>abd.hWnd = hwndOfWindowJustPositioned;<BR>// Ignored members: uCallbackMessage,  // uEdge, rc, lParam<BR>SHAppBarMessage(ABM_WINDOWPOSCHANGED,  <BR>                &amp;abd);</PRE>
<P> </P>
<H2><A NAME="sec5"></A>  Appbar Notifications</H2><P>Periodically, the shell needs to send notifications to all the appbars. When you add your appbar to the shell's internal list by sending the ABM_NEW message, you specify a window message callback value. When the shell notifies your appbar of something, it sends your appbar the callback message you specified. When the appbar receives this message, the wParam parameter will be one the appbar notification codes: ABN_FULLSCREENAPP, ABN_POSCHANGED, ABN_STATECHANGE, or ABN_WINDOWARRANGE.</P>
<P>The ABN_FULLSCREENAPP notification is sent when a fullscreen application window is opened or closed. A window is fullscreen when its client area occupies the entire screen. Always-on-top appbars should take themselves out of the topmost z-order so that they do not cover the fullscreen window. lParam contains TRUE if a fullscreen window is opening and FALSE if one is closing. </P>
<P>Unfortunately, there is a serious bug in the shell's handling of the ABN_FULLSCREENAPP notification: appbars receive this notification only if the shell's taskbar is an always-on-top window and if it is not autohide. If the taskbar is not always-on-top or is autohide, your appbar will not get the proper set of ABN_FULLSCREENAPP notifications. Obviously, your appbar should receive these notifications regardless of the taskbar's settings. Microsoft tells me this bug is fixed in future versions of Windows.</P>
<P>The ABN_POSCHANGED notification is sent when any appbar alters its size by sending the ABM_SETPOS message to SHAppBarMessage. This notification is also sent when an appbar is removed by sending the ABM_REMOVE message, and when the taskbar is in autohide mode and the user causes it to slide on or off the screen. You should use this notification to force your appbar to reposition itself by sending an ABM_SETPOS message. Remember that the shell does not send an ABN_POSCHANGED notification to the same appbar that sends an ABM_SETPOS message. The lParam parameter is undefined for this notification.</P>
<P>ABN_STATECHANGE indicates that the user changed the taskbar's state. Using this notification, it is possible to implement your appbar so that its state mimics that of the shell'staskbar,sowhentheuser changes the taskbar's always-on-top and autohide states, your appbar follows suit.</P>
<P>Unfortunately, the implementation of the ABN_STATECHANGE notification exposes another bug in the system. When the user changes the taskbar's state, you should get a single ABN_STATECHANGE notification; you actually get notified once for each state supported by the taskbar. Since the taskbar supports two states (always-on-top and autohide), you get this notification twice even if the user only changes one of the taskbar's states. Microsoft claims this bug is fixed after the first beta of Windows NT™ 4.0 and in future versions of Windows 95.</P>
<P>This can make you run into problems. Imagine that the taskbar and your appbar are both docked at the bottom of the screen. The taskbar is autohide. The user opens the Taskbar Properties dialog (see <B>Figure 4</B>) and turns off both the always-on-top and autohide features. Internally, the shell first turns off the always-on-top feature and immediately broadcasts the ABN_STATECHANGE notification. Because you want your appbar to mimic the state of the taskbar, your appbar responds to this notification by sending an ABM_GETSTATE message. The result of this message indicates that always-on-top is off. Since the shell has not yet had a chance to change the autohide feature of the taskbar, your appbar will think that autohide is on and will try to make itself autohide as well. Since you can't have two autohide appbars docked on the same edge, a message box like the one shown in <B>Figure 2</B> will appear. A user will be a bit confused when you display this message box in response to the user just turning autohide off!</P>
<P><img src="SHELL4.gif"></P>
<P><B> Figure 4  Taskbar properties.</B></P>
<P>My CAppBar class solves this problem by remembering the current state of the taskbar and comparing the current state with the new state returned by sending an ABM_GETSTATE message. Then, for my appbar, I only change the states that have also changed on the taskbar. I implemented my CAppBar class this way so that it will function properly on future versions of Windows.</P>
<P>The last notification, ABN_WINDOWARRANGE, is sent when the user chooses either the cascade, tile horizontally, or tile vertically options from the shell's taskbar. Actually, this notification is sent to each appbar twice. Immediately after the user chooses one of these options, the shell sends this notification with the lParam set to TRUE, indicating that it's about to reposition all the windows. After each appbar processes this notification, the shell repositions all the windows and sends another ABN_WINDOWARRANGE notification. This time, the lParam parameter is set to FALSE to indicate that all the windows have been moved. The taskbar uses the first notification to save the state of all the existing windows before they are moved. This allows the taskbar to offer an Undo option so that the windows can be put back to their original positions.</P>
<P> </P>
<H2><A NAME="sec6"></A>  The CAppBar Class</H2><P>My CAppBar class encapsulates all of the idiosyncrasies of the new application desktop toolbars. This class was definitely one of the most difficult and challenging projects I've worked on in quite a while. When you examine the source code, you'll see that I have been extremely liberal with comments. The full source code is too long to reprint here, but you can get it electronically from any of the sources listed on page 5. <B>Figure 5</B> does show the AppBar.h header file, which contains the CAppBar class description. Now I'll describe how this class is implemented.</P>
<P><B> Figure 5  AppBar</B></P>
<P> </P>
<P>APPBAR.H</P>
<P><BR></P>
<PRE> ******************************************************************************
/
Module name: AppBar.h
Written by:  Jeffrey Richter
Purpose:     AppBar base class description file.
******************************************************************************/


// An AppBar can be in one of 6 states shown in the table below: 
// State          Description
// -----------    -----------------------------------------------------
// ABE_UNKNOWN    The Appbar is in an unknown state 
//                (usually during construction/destruction)
// ABE_FLOAT      The AppBar is floating on the screen
// ABE_LEFT       The Appbar is docked on the left   edge of the screen
// ABE_TOP        The Appbar is docked on the top    edge of the screen
// ABE_RIGHT      The Appbar is docked on the right  edge of the screen
// ABE_BOTTOM     The Appbar is docked on the bottom edge of the screen

// The ABE_edge state macros are defined in SHELLAPI.H as follows:
// #define ABE_LEFT        0
// #define ABE_TOP         1
// #define ABE_RIGHT       2
// #define ABE_BOTTOM      3

// The ABE_UNKNOWN and ABE_FLOAT macros are defined here as follows:
#define ABE_UNKNOWN           ((UINT) -1)
#define ABE_FLOAT             ((UINT) -2)


//////////////////////////////////////////////////////////////////////////////

// An AppBar can have several behavior flags as shown below: 
// Flag                        Description
// -----------                 -----------------------------------------------
// ABF_ALLOWLEFTRIGHT          Allow dock on left/right of screen
// ABF_ALLOWTOPBOTTOM          Allow dock on top/bottom of screen
// ABF_ALLOWANYEDGE            Allow dock on any edge of screen
// ABF_ALLOWFLOAT              Allow float in the middle of screen
// ABF_ALLOWANYWHERE           Allow dock and float
// ABF_MIMICTASKBARAUTOHIDE    Follow Autohide state of TaskBar
// ABF_MIMICTASKBARALWAYSONTOP Follow AlwaysOnTop state of TaskBar


#define ABF_ALLOWLEFTRIGHT          0x00000001
#define ABF_ALLOWTOPBOTTOM          0x00000002
#define ABF_ALLOWANYEDGE            (ABF_ALLOWLEFTRIGHT | ABF_ALLOWTOPBOTTOM)
#define ABF_ALLOWFLOAT              0x00000004
#define ABF_ALLOWANYWHERE           (ABF_ALLOWANYEDGE | ABF_ALLOWFLOAT)
#define ABF_MIMICTASKBARAUTOHIDE    0x00000010
#define ABF_MIMICTASKBARALWAYSONTOP 0x00000020


//////////////////////////////////////////////////////////////////////////////

class CAppBar : public CDialog {

public:  // Static, AppBar-specific helper functions
   // Returns TRUE if uEdge is ABE_LEFT or ABE_RIGHT, else FALSE is returned
   static BOOL IsEdgeLeftOrRight (UINT uEdge);

   // Returns TRUE if uEdge is ABE_TOP or ABE_BOTTOM, else FALSE is returned
   static BOOL IsEdgeTopOrBottom (UINT uEdge);

   // Forces the shell to update its AppBar list and the workspace area
   static void ResetSystemKnowledge (void);

   // Returns a proposed edge or ABE_FLOAT based on ABF_* flags and a 
   // point specified in screen coordinates).
   static UINT GetEdgeFromPoint (DWORD fdwFlags, CPoint pt);


protected:  // Internal implementation state variables
   // Registered window message for the AppBar's callback notifications
   static UINT s_uAppBarNotifyMsg;

   // AppBar's class-specific constants
   enum { AUTOHIDETIMERID = 1, AUTOHIDETIMERINTERVAL = 400 };

   // See the OnAppBarCallbackMsg function for usage.
   DWORD m_fdwTaskBarState;

   // The structure below contains all of the AppBar settings that
   // can be saved/loaded in/from the Registry.
   typedef struct {
      DWORD m_cbSize;         // Size of this structure
      UINT  m_uState;         // ABE_UNKNOWN, ABE_FLOAT, or ABE_edge
      BOOL  m_fAutohide;      // Should AppBar be auto-hidden when docked?
      BOOL  m_fAlwaysOnTop;   // Should AppBar always be on top?
      UINT  m_auDimsDock[4];  // Width/height for docked bar on 4 edges
      CRect m_rcFloat;        // Floating rectangle (in screen coordinates)
   } APPBARSTATE, *PAPPBARSTATE;
   APPBARSTATE m_abs;         // This AppBar's state info

   DWORD m_fdwFlags;          // See the ABF_* flags above
   CSize m_szSizeInc;         // Descrete width/height size increments

   // We need a member variable which tracks the proposed state of the
   // AppBar while the user is moving it, deciding where to position it.
   // While not moving, this member must contain ABE_UNKNOWN so that 
   // GetState() returns the current state contained in m_ps.m_uState.
   // While moving the AppBar, m_uStateProposedPrev contains the 
   // proposed state based on the position of the AppBar.  The proposed 
   // state becomes the new state when the user stops moving the AppBar.
   UINT m_uStateProposedPrev;

   // We need a member variable which tracks whether a full screen 
   // application window is open
   BOOL m_fFullScreenAppOpen;

   // We need a member variable which tracks whether our autohide window 
   // is visible or not
   BOOL m_fAutoHideIsVisible;

   
public:  // Public member functions
   // Constructs an AppBar
   CAppBar (UINT nIDTemplate, CWnd* pParent = NULL);

   // Returns which edge we're autohidden on or ABE_NONE
   UINT GetAutohideEdge (void);

   // Sets Autohide &amp; AlwaysOnTop to match a specified state
   void MimicState (DWORD fdwStateChangedMask, DWORD fdwState);

   // Forces the appbar's visual appearance to match it's internal state
   void SetState (void);

   // Changes the AppBar's state to ABE_UNKNOWN, ABE_FLOAT or an ABE_edge
   void SetState (UINT uState);

   // Changes the AppBar's window to reflect the persistent state info
   void SetState (APPBARSTATE&amp; abs);

   // Retrieves the AppBar's state.  If the AppBar is being positioned, its
   // proposed state is returned instead.
   UINT GetState (void);

   // Retrieves the AppBar's entire state.  To change many state variables,
   // call this function, change the variables, and then call SetState.
   void GetState (APPBARSTATE* pabs);

   // Gets the AppBar's Autohide state
   BOOL IsBarAutohide (void);

   // Gets the AppBar's always-on-top state
   BOOL IsBarAlwaysOnTop (void);

   // Gets the AppBar's floating rectangle
   void GetFloatRect (CRect* prc);

   // Gets the AppBar's docked width/height dimension
   int  GetDockedDim (UINT uEdge);


protected:  // Internal implementation functions
   // This function simplifies calling the shell's SHAppBarMessage function
   UINT SHAppBarMessage (DWORD dwMessage, UINT uEdge = ABE_UNKNOWN, 
      LPARAM lParam = 0, CRect *rc = NULL);

   // Get a state (ABE_FLOAT or ABE_edge) from a point (screen coordinates)
   UINT CalcProposedState (const CPoint&amp; pt);

   // Get a retangle position (screen coordinates) from a proposed state
   void GetRect (UINT uStateProposed, CRect* prcProposed);

   // Adjust the AppBar's location to account for autohide
   // Returns TRUE if rectangle was adjusted.
   BOOL AdjustLocationForAutohide (BOOL fShow, CRect* prc);

   // If AppBar is Autohide and docked, show/hide the AppBar.
   void ShowHiddenAppBar (BOOL fShow = TRUE);

   // When Autohide AppBar is shown/hidden, slide in/out of view
   void SlideWindow (const CRect&amp; rc);


protected:  // Overridable functions
   // Called when the AppBar's proposed state changes.
   virtual void OnAppBarStateChange(BOOL fProposed, UINT uStateProposed);

   // Called if user attempts to dock an Autohide AppBar on
   // an edge that already contains an Autohide AppBar
   virtual void OnAppBarForcedToDocked(void);

   // Called when AppBar gets an ABN_FULLSCREENAPP notification
   virtual void OnABNFullScreenApp (BOOL fOpen);

   // Called when AppBar gets an ABN_POSCHANGED notification
   virtual void OnABNPosChanged (void);

   // Called when AppBar gets an ABN_STATECHANGE notification
   virtual void OnABNStateChange (DWORD fdwStateChangedMask, DWORD fdwState);

   // Called when AppBar gets an ABN_WINDOWARRANGE notification
   virtual void OnABNWindowArrange (BOOL fBeginning);

// Dialog Data
   //{{AFX_DATA(CAppBar)
   enum { IDD = 0 };
      // NOTE: the ClassWizard will add data members here
   //}}AFX_DATA


// Overrides
   // ClassWizard generated virtual function overrides
   //{{AFX_VIRTUAL(CAppBar)
   protected:
   virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
   //}}AFX_VIRTUAL

// Implementation
protected:
   // Generated message map functions
   //{{AFX_MSG(CAppBar)
   afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
   afx_msg void OnDestroy();
   afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
   afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
   afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
   afx_msg UINT OnNcHitTest(CPoint point);
   afx_msg void OnTimer(UINT nIDEvent);
    //}}AFX_MSG
   afx_msg LRESULT OnAppBarCallbackMsg(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnEnterSizeMove(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnExitSizeMove(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnSizing(WPARAM wParam, LPARAM lParam);
   afx_msg LRESULT OnMoving(WPARAM wParam, LPARAM lParam);
   DECLARE_MESSAGE_MAP()
};


///////////////////////////////////////////////////////////////////////////////
// Inline functions.  See above for descriptions


inline BOOL CAppBar::IsEdgeLeftOrRight (UINT uEdge) { 
   return((uEdge == ABE_LEFT) || (uEdge == ABE_RIGHT)); 
}

inline BOOL CAppBar::IsEdgeTopOrBottom (UINT uEdge) { 
   return((uEdge == ABE_TOP) || (uEdge == ABE_BOTTOM)); 
}

inline void CAppBar::SetState (void) {
   SetState(GetState());
}

inline UINT CAppBar::GetState (void) { 
   return((m_uStateProposedPrev != ABE_UNKNOWN) 
      ? m_uStateProposedPrev : m_abs.m_uState); 
}

inline void CAppBar::GetState (APPBARSTATE* pabs) {
   DWORD dwSizeCaller = pabs-&gt;m_cbSize;
    CopyMemory(pabs, &amp;m_abs, pabs-&gt;m_cbSize);
   pabs-&gt;m_cbSize = dwSizeCaller;
}

inline BOOL CAppBar::IsBarAutohide (void) {
   return(m_abs.m_fAutohide); 
}

inline BOOL CAppBar::IsBarAlwaysOnTop (void) { 
   return(m_abs.m_fAlwaysOnTop); 
}

inline void CAppBar::GetFloatRect (CRect* prc) {
   *prc = m_abs.m_rcFloat; 
}

inline int CAppBar::GetDockedDim (UINT uEdge) {
   return(m_abs.m_auDimsDock[uEdge]);
}

inline int AbsoluteValue(int n) { 
   return((n &lt; 0) ? -n : n); 
}


//////////////////////////////// End of File //////////////////////////////////</PRE>
<P></P>
<P>APPBAR.CPP</P>
<P><BR></P>
<PRE> /******************************************************************************
Module name: AppBar.cpp
Written by:  Jeffrey Richter
Purpose:     AppBar base class implementation file.
******************************************************************************/


#include "stdafx.h"
#include &lt;WinReg.h&gt;
#include "AppBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// Static, AppBar-specific helper functions


void CAppBar::ResetSystemKnowledge (void) {

#ifdef _DEBUG
   // Only do this for debug builds.
   APPBARDATA abd;
   abd.cbSize = sizeof(abd);
   abd.hWnd = NULL;
   ::SHAppBarMessage(ABM_REMOVE, &amp;abd);
#endif
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::GetEdgeFromPoint (DWORD fdwFlags, CPoint pt) {

   // At least one edge or floating must be allowed.
   ASSERT((fdwFlags &amp; ABF_ALLOWANYWHERE) != 0);

   UINT uState = ABE_FLOAT;   // Assume that the AppBar is floating

   // Let's get floating out of the way first
   if ((fdwFlags &amp; ABF_ALLOWFLOAT) != 0) {

      // Get the rectangle that bounds the size of the screen
      // minus any docked (but not-autohidden) AppBars.
      CRect rc;
      ::SystemParametersInfo(SPI_GETWORKAREA, 0, &amp;rc, 0);

      // Leave a 1/2 width/height-of-a-scrollbar gutter around the workarea
      rc.InflateRect(-GetSystemMetrics(SM_CXVSCROLL), -GetSystemMetrics(SM_CYHSCROLL));

      if (rc.PtInRect(pt) || ((fdwFlags &amp; ABF_ALLOWANYEDGE) == 0)) {
         // If the point is in the adjusted workarea
         // OR no edges are allowed.
         return(uState);      // The AppBar should float
      }
   }

   // If we get here, the AppBar should be docked; determine the proper edge

   // Get the dimensions of the screen
   int cxScreen = GetSystemMetrics(SM_CXSCREEN);
   int cyScreen = GetSystemMetrics(SM_CYSCREEN);

   // Find the center of the screen
   CPoint ptCenter(cxScreen / 2, cyScreen / 2);

   // Find the distance from the point to the center
   CPoint ptOffset = pt - ptCenter;

   // Determine if the point is farther from the left/right or top/bottom
   BOOL fIsLeftOrRight = (AbsoluteValue(ptOffset.y) * cxScreen) &lt;=
      (AbsoluteValue(ptOffset.x) * cyScreen);

   // If (it should be left/right, AND we allow left/right) 
   // OR we don't allow top/bottom
   if ((fIsLeftOrRight &amp;&amp; ((fdwFlags &amp; ABF_ALLOWLEFTRIGHT) != 0)) ||
       ((fdwFlags &amp; ABF_ALLOWTOPBOTTOM) == 0)) {

      uState = (0 &lt;= ptOffset.x) ? ABE_RIGHT : ABE_LEFT;
   } else {

      uState = (0 &lt;= ptOffset.y) ? ABE_BOTTOM : ABE_TOP;
   }
   
   return(uState);   // Return calculated edge
}


/////////////////////////////////////////////////////////////////////////////
// Public member functions


CAppBar::CAppBar (UINT nIDTemplate, CWnd* pParent /*=NULL*/)
   : CDialog(nIDTemplate, pParent) {
   //{{AFX_DATA_INIT(CAppBar)
      // NOTE: the ClassWizard will add member initialization here
   //}}AFX_DATA_INIT
      // Setup the default width/height for the AppBar

   // Force the shell to update its list of AppBars and the workarea.
   // This is a precaution and is very useful when debugging.  If you create
   // an AppBar and then just terminate the application, the shell still 
   // thinks that the AppBar exists and the user's workarea is smaller than
   // it should be.  When a new AppBar is created, calling this function 
   // fixes the user's workarea.
   ResetSystemKnowledge();

   // Set default state of AppBar to docked on bottom with no width &amp; height
   ZeroMemory(&amp;m_abs, sizeof(m_abs));
   m_abs.m_cbSize                 = sizeof(m_abs);
   m_abs.m_uState                 = ABE_BOTTOM;
   m_abs.m_fAutohide              = FALSE;
   m_abs.m_fAlwaysOnTop           = FALSE;
   m_abs.m_auDimsDock[ABE_LEFT]   = 0;
   m_abs.m_auDimsDock[ABE_TOP]    = 0;
   m_abs.m_auDimsDock[ABE_RIGHT]  = 0;
   m_abs.m_auDimsDock[ABE_BOTTOM] = 0;
   m_abs.m_rcFloat.SetRectEmpty();

   m_fdwTaskBarState             = SHAppBarMessage(ABM_GETSTATE);
   m_fdwFlags                    = 0;
   m_szSizeInc                   = CSize(0, 0); // Don't allow re-sizing
   m_uStateProposedPrev          = ABE_UNKNOWN;
   m_fFullScreenAppOpen          = FALSE;
   m_fAutoHideIsVisible          = FALSE;
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::GetAutohideEdge (void) {

   for (UINT uEdge = ABE_LEFT; uEdge &lt;= ABE_BOTTOM; uEdge++) {
      if (m_hWnd == (HWND) SHAppBarMessage(ABM_GETAUTOHIDEBAR, uEdge)) {
         // We are an auto-hide AppBar and we found our edge.
         return(uEdge);
      }
   }

   // NOTE: If AppBar is docked but not auto-hidden, we return ABE_UNKNOWN
   return(ABE_UNKNOWN);   
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::MimicState (DWORD fdwStateChangedMask, DWORD fdwState) {

   BOOL fAnyChange = FALSE;   // Assume that nothing changes

   // If the autohide state changed AND our style allows 
   // us to mimic the Autohide state
   if (((fdwStateChangedMask &amp; ABS_AUTOHIDE) != 0) &amp;&amp; 
       ((m_fdwFlags &amp; ABF_MIMICTASKBARAUTOHIDE) != 0)) {

      BOOL fIsAutohide = (ABS_AUTOHIDE &amp; fdwState) != 0;

      // If our state doesn't match, change our state
      if (IsBarAutohide() != fIsAutohide) {
         m_abs.m_fAutohide = fIsAutohide;
         fAnyChange = TRUE;
      }
   }

   // If the AlwaysOnTop state changed AND our style allows 
   // us to mimic the AlwaysOnTop state/
   if (((fdwStateChangedMask &amp; ABS_ALWAYSONTOP) != 0) &amp;&amp; 
       ((m_fdwFlags &amp; ABF_MIMICTASKBARALWAYSONTOP) != 0)) {

      // If our state doesn't match, change our state
      m_abs.m_fAlwaysOnTop = (ABS_ALWAYSONTOP &amp; fdwState) != 0;
      fAnyChange = TRUE;
   }
   if (fAnyChange) {
      SetState();
      ShowHiddenAppBar(FALSE);
   }
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SetState (UINT uState) {

   // If the AppBar is registered as auto-hide, unregister it.
   UINT uEdge = GetAutohideEdge();
   if (uEdge != ABE_UNKNOWN) {
      // Our AppBar is auto-hidden, unregister it.
      SHAppBarMessage(ABM_SETAUTOHIDEBAR, uEdge, FALSE);
   }

   // Save the new requested state
   m_abs.m_uState = uState;

   switch (uState) {
      case ABE_UNKNOWN:
         // We are being completely unregisterred.
         // Probably, the AppBar window is being destroyed.
         // If the AppBar is registered as NOT auto-hide, unregister it.
         SHAppBarMessage(ABM_REMOVE);
         break;

      case ABE_FLOAT:
         // We are floating and therefore are just a regular window.
         // Tell the shell that the docked AppBar should be of 0x0 dimensions
         // so that the workspace is not affected by the AppBar.
         SHAppBarMessage(ABM_SETPOS, uState, FALSE, &amp;CRect(0, 0, 0, 0));
                   SetWindowPos(NULL, m_abs.m_rcFloat.left,                                       m_abs.m_rcFloat.top, m_abs.m_rcFloat.Width(),                                       m_abs.m_rcFloat.Height(),SWP_NOZORDER|SWP_NOACTIVATE);
         break;

      default:
         if (IsBarAutohide() &amp;&amp; !SHAppBarMessage(ABM_SETAUTOHIDEBAR, GetState(), <BR>                                                 TRUE)) {
            // We couldn't set the AppBar on a new edge, let's dock it instead.
            m_abs.m_fAutohide = FALSE;
            // Call a virtual function to let derived classes knowthattheAppBar
            // changed from auto-hide to docked.
            OnAppBarForcedToDocked();
         }
         CRect rc;
         GetRect(GetState(), &amp;rc);
         if (IsBarAutohide()) {
            SHAppBarMessage(ABM_SETPOS, ABE_LEFT, FALSE, &amp;CRect(0, 0, 0, 0));
         } else {
            // Tell the shell where the AppBar is.
            SHAppBarMessage(ABM_SETPOS, uState, FALSE, &amp;rc);
         }
         AdjustLocationForAutohide(m_fAutoHideIsVisible, &amp;rc);
         // Slide window in from or out to the edge
         SlideWindow(rc);
         break;
   }

     // Set the AppBar's z-order appropriately
     const CWnd* pwnd = &amp;wndNoTopMost;     // Assume normal Z-Order
     if (m_abs.m_fAlwaysOnTop) {     
      // If we are supposed to be always-on-top, put us there.
      pwnd = &amp;wndTopMost;

          if (m_fFullScreenAppOpen) {
         // But, if a full-screen window is opened, put ourself at the bottom
         // of the z-order so that we don't cover the full-screen window
         pwnd = &amp;wndBottom;
      }
     }
        SetWindowPos(pwnd, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE|SWP_NOACTIVATE);

   // Make sure that any auto-hide appabrs stay on top of us after we move
   // even though our activation state has not changed.
   SHAppBarMessage(ABM_ACTIVATE);

   // Tell our derived class that there is a state change
   OnAppBarStateChange(FALSE, uState);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SetState (APPBARSTATE&amp; abs) {

   // The AppBar window doesn't exist, just update the state variables
   CopyMemory(&amp;m_abs, &amp;abs, min(abs.m_cbSize, sizeof(m_abs)));
    m_abs.m_cbSize = sizeof(m_abs);  // In case caller used an old version
   if (IsWindow(m_hWnd)) SetState();
}


/////////////////////////////////////////////////////////////////////////////
// Internal implementation functions


UINT CAppBar::SHAppBarMessage (DWORD dwMessage, UINT uEdge /*= ABE_FLOAT*/, 
   LPARAM lParam /*= 0*/, CRect *rc /*= NULL*/) {

   // Initialize an APPBARDATA structure.
   APPBARDATA abd;
   abd.cbSize           = sizeof(abd);
   abd.hWnd             = m_hWnd;
   abd.uCallbackMessage = s_uAppBarNotifyMsg;
   abd.uEdge            = uEdge;
   abd.rc               = (rc == NULL) ? CRect(0, 0, 0, 0) : *rc;
   abd.lParam           = lParam;
   UINT uRetVal         = ::SHAppBarMessage(dwMessage, &amp;abd);

   // If the caller passed a rectangle, return the updated rectangle.
   if (rc != NULL) *rc = abd.rc;
   return(uRetVal);
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::CalcProposedState (const CPoint&amp; pt) {

   // Force the AppBar to float if the user is holding down the Ctrl key
   // and the AppBar's style allows floating.
   BOOL fForceFloat = ((GetKeyState(VK_CONTROL) &amp; 0x8000) != 0) 
      &amp;&amp; ((m_fdwFlags &amp; ABF_ALLOWFLOAT) != 0);
   return(fForceFloat ? ABE_FLOAT : GetEdgeFromPoint(m_fdwFlags, pt));
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::GetRect (UINT uStateProposed, CRect* prcProposed) {

   // This function finds the x, y, cx, cy of the AppBar window
   if (ABE_FLOAT == uStateProposed) {

      // The AppBar is floating, the proposed rectangle is correct
   } else {

      // The AppBar is docked or auto-hide

      // Set dimensions to full screen.
      *prcProposed = CRect(0,0,
         GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));

      // Subtract off what we want from the full screen dimensions
      if (!IsBarAutohide()) {
         // Ask the shell where we can dock.
         SHAppBarMessage(ABM_QUERYPOS, uStateProposed, FALSE, prcProposed);
      }

      switch (uStateProposed) {
         case ABE_LEFT:    
            prcProposed-&gt;right = 
               prcProposed-&gt;left + m_abs.m_auDimsDock[uStateProposed];
            break;

         case ABE_TOP:
            prcProposed-&gt;bottom = 
               prcProposed-&gt;top + m_abs.m_auDimsDock[uStateProposed]; 
            break;

         case ABE_RIGHT:   
            prcProposed-&gt;left = 
               prcProposed-&gt;right - m_abs.m_auDimsDock[uStateProposed]; 
            break;

         case ABE_BOTTOM:  
            prcProposed-&gt;top = 
               prcProposed-&gt;bottom - m_abs.m_auDimsDock[uStateProposed]; 
            break;
      }
   }
}


/////////////////////////////////////////////////////////////////////////////


BOOL CAppBar::AdjustLocationForAutohide (BOOL fShow, CRect* prc) {

   if ((GetState() == ABE_UNKNOWN) || (GetState() == ABE_FLOAT) || 
      !IsBarAutohide()) {

      // If we are not docked on an edge OR we are not auto-hidden, there is
      // nothing for us to do; just return.
      return(FALSE);
   }

   // Showing/hiding doesn't change our size; only our position.
   int x = 0, y = 0;    // Assume a position of (0, 0)

   if (fShow) {

      // If we are on the right or bottom, calculate our visible position
      switch (GetState()) {
         case ABE_RIGHT:
            x = GetSystemMetrics(SM_CXSCREEN) - prc-&gt;Width();
            break;

         case ABE_BOTTOM:
            y = GetSystemMetrics(SM_CYSCREEN) - prc-&gt;Height();
            break;
      }
   } else {

      // Keep a part of the AppBar visible at all times
      const int cxVisibleBorder = 2 * GetSystemMetrics(SM_CXBORDER);
      const int cyVisibleBorder = 2 * GetSystemMetrics(SM_CYBORDER);

      // Calculate our x or y coordinate so that only the border is visible
      switch (GetState()) {
         case ABE_LEFT:   
            x = -(prc-&gt;Width() - cxVisibleBorder); 
            break;

         case ABE_RIGHT:  
            x = GetSystemMetrics(SM_CXSCREEN) - cxVisibleBorder; 
            break;

         case ABE_TOP:
            y = -(prc-&gt;Height() - cyVisibleBorder); 
            break;

         case ABE_BOTTOM:
            y = GetSystemMetrics(SM_CYSCREEN) - cyVisibleBorder; 
            break;
      }
   }
   *prc = CRect(x, y, x + prc-&gt;Width(), y + prc-&gt;Height());
   return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::ShowHiddenAppBar (BOOL fShow /*= TRUE*/) {

   // Get our window location in screen coordinates.
   CRect rc;
   GetWindowRect(&amp;rc);

   m_fAutoHideIsVisible = TRUE; // Assume  that we are visible
   if (AdjustLocationForAutohide(fShow, &amp;rc)) {
      // the rectangle was adjusted, we are an autohide bar
      // Rememebr whether we are visible or not.
      m_fAutoHideIsVisible = fShow;

      // Slide window in from or out to the edge
      SlideWindow(rc);
   }
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::SlideWindow (const CRect&amp; rcEnd) {

   BOOL fFullDragOn;

   // Only slide the window if the user has FullDrag turned on
   ::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &amp;fFullDragOn, 0);

   // Get the current window position
   CRect rcStart;
   GetWindowRect(&amp;rcStart);   

   if (fFullDragOn &amp;&amp; (rcStart != rcEnd)) {

      // Get our starting and ending time.
      DWORD dwTimeStart = GetTickCount();
      DWORD dwTimeEnd = dwTimeStart + AUTOHIDETIMERINTERVAL;
      DWORD dwTime;

      while ((dwTime = ::GetTickCount()) &lt; dwTimeEnd) {

         // While we are still sliding, calculate our new position
         int x = rcStart.left - (rcStart.left - rcEnd.left) 
            * (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

         int y = rcStart.top  - (rcStart.top  - rcEnd.top)  
            * (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

         int nWidth  = rcStart.Width()  - (rcStart.Width()  - rcEnd.Width())  
            * (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

         int nHeight = rcStart.Height() - (rcStart.Height() - rcEnd.Height()) 
            * (int) (dwTime - dwTimeStart) / AUTOHIDETIMERINTERVAL;

         // Show the window at its changed position
         SetWindowPos(NULL, x, y, nWidth, nHeight, 
            SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME);
         UpdateWindow();
      }
   }

   // Make sure that the window is at its final position
   SetWindowPos(NULL, rcEnd.left, rcEnd.top, rcEnd.Width(), rcEnd.Height(),
      SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME);
    UpdateWindow();
}


/////////////////////////////////////////////////////////////////////////////
// Overridable functions


void CAppBar::OnAppBarStateChange (BOOL fProposed, UINT uStateProposed) {

   // This function intentionally left blank.
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnAppBarForcedToDocked (void) {

   // Display the ppBar's caption text as the message box caption text.
   CString sz;
   GetWindowText(sz);

   ::MessageBox(NULL, 
      __TEXT("There is already an auto hidden window on this edge.\n")
      __TEXT("Only one auto hidden window is allowed on each edge."),
      sz, MB_OK | MB_ICONSTOP);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNFullScreenApp (BOOL fOpen) {

   // This function is called when a FullScreen window is openning or 
   // closing. A FullScreen window is a top-level window that has its caption 
   // above the top of the screen allowing the entire screen to be occupied 
   // by the window's client area.  
   
   // If the AppBar is a topmost window when a FullScreen windiw is activated, 
   // we need to change our window to a non-topmost window so that the AppBar 
   // doesn't cover the FullScreen window's client area.

   // If the FullScreen window is closing, we need to set the AppBar's 
   // Z-Order back to when the user wants it to be.
     m_fFullScreenAppOpen = fOpen;
     SetState();
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNPosChanged (void) {

   // The TaskBar or another AppBar has changed its size or position. 
   if ((GetState() != ABE_FLOAT) &amp;&amp; !IsBarAutohide()) {

      // If we're not floating and we're not auto-hidden, we have to 
      // reposition our window.
      SetState();
   }
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNStateChange (DWORD fdwStateChangedMask, DWORD fdwState) {

   // Make our state mimic the taskbar's state.
   MimicState(fdwStateChangedMask, fdwState);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnABNWindowArrange (BOOL fBeginning) {

   // This function intentionally left blank.
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::DoDataExchange(CDataExchange* pDX) {
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(CAppBar)
      // NOTE: the ClassWizard will add DDX and DDV calls here
   //}}AFX_DATA_MAP
}


/////////////////////////////////////////////////////////////////////////////


// Register a window message for the AppBar's callback notifications
UINT CAppBar::s_uAppBarNotifyMsg = 
   RegisterWindowMessage(__TEXT("AppBarNotify"));


/////////////////////////////////////////////////////////////////////////////


// Called when the AppBar recieves a g_uAppBarNotifyMsg window message
LRESULT CAppBar::OnAppBarCallbackMsg (WPARAM uNotifyMsg, LPARAM lParam) {

   switch (uNotifyMsg) {

      case ABN_FULLSCREENAPP: 
         OnABNFullScreenApp((BOOL) lParam); 
         break;

      case ABN_POSCHANGED:
         OnABNPosChanged(); 
         break;

      case ABN_WINDOWARRANGE:
         OnABNWindowArrange((BOOL) lParam); 
         break;

      case ABN_STATECHANGE:
         // The shell sends ABN_STATECHANGE notifications at inappropriate 
         // times.  So, we remember the TaskBar's current state and set
         // a mask indicating which states have actually changed. This mask
         // and the state information is passed to the derived class.

         // Get the state of the Taskbar
         DWORD fdwTaskBarState = SHAppBarMessage(ABM_GETSTATE);

         // Prepare a mask indicating which states have changed. The code in
         // the derived class should only act on the states that have changed.
         DWORD fdwStateChangedMask = 0;
         if ((fdwTaskBarState &amp; ABS_ALWAYSONTOP) != 
             (m_fdwTaskBarState &amp; ABS_ALWAYSONTOP)) {
            fdwStateChangedMask |= ABS_ALWAYSONTOP;
         }
         if ((fdwTaskBarState &amp; ABS_AUTOHIDE) != 
             (m_fdwTaskBarState &amp; ABS_AUTOHIDE)) {
            fdwStateChangedMask |= ABS_AUTOHIDE;
         }

         // Call the derived class
         OnABNStateChange(fdwStateChangedMask, fdwTaskBarState);

         // Save the TaskBar's state so that we can see exactly which states
         // change the next time be get an ABN_STATECHANGE notification.
         m_fdwTaskBarState = fdwTaskBarState;
         break;
   }

   return(0);
}


/////////////////////////////////////////////////////////////////////////////


BEGIN_MESSAGE_MAP(CAppBar, CDialog)
   ON_REGISTERED_MESSAGE(s_uAppBarNotifyMsg, OnAppBarCallbackMsg)
   ON_MESSAGE(WM_ENTERSIZEMOVE, OnEnterSizeMove)
   ON_MESSAGE(WM_SIZING, OnSizing)
   ON_MESSAGE(WM_MOVING, OnMoving)
   ON_MESSAGE(WM_EXITSIZEMOVE, OnExitSizeMove)
   //{{AFX_MSG_MAP(CAppBar)
   ON_WM_CREATE()
   ON_WM_DESTROY()
   ON_WM_WINDOWPOSCHANGED()
   ON_WM_ACTIVATE()
   ON_WM_NCMOUSEMOVE()
   ON_WM_NCHITTEST()
   ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAppBar message handlers


int CAppBar::OnCreate(LPCREATESTRUCT lpCreateStruct) {

   if (CDialog::OnCreate(lpCreateStruct) == -1)
      return(-1);

   // Associate a timer with the AppBar.  The timer is used to determine
   // when a visible, inactive, auto-hide AppBar should be re-hidden.
   SetTimer(AUTOHIDETIMERID, AUTOHIDETIMERINTERVAL, NULL);

   // Register our AppBar window with the Shell
   SHAppBarMessage(ABM_NEW);

   // Force the AppBar to mimic the state of the TaskBar
   // Assume that all states have changed
   MimicState(ABS_ALWAYSONTOP | ABS_AUTOHIDE, m_fdwTaskBarState);

   return(0);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnDestroy() {

   CDialog::OnDestroy();

   // Kill the Autohide timer 
   KillTimer(AUTOHIDETIMERID);

   // Unregister our AppBar window with the Shell
   SetState(ABE_UNKNOWN);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos) {

   CDialog::OnWindowPosChanged(lpwndpos);

   // When our window changes position, tell the Shell so that any 
   // auto-hidden AppBar on our edge stays on top of our window making it 
   // always accessible to the user.
   SHAppBarMessage(ABM_WINDOWPOSCHANGED);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized) {

   CDialog::OnActivate(nState, pWndOther, bMinimized);

   if (nState == WA_INACTIVE) {
      // Hide the AppBar if we are docked and auto-hidden
      ShowHiddenAppBar(FALSE);
   }

   // When our window changes position, tell the Shell so that any 
   // auto-hidden AppBar on our edge stays on top of our window making it 
   // always accessible to the user.
   SHAppBarMessage(ABM_ACTIVATE);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnTimer(UINT nIDEvent) {

   if (GetActiveWindow() != this) {

      // Possibly hide the AppBar if we are not the active window 
      
      // Get the position of the mouse and the AppBar's position
      // Everything must be in screen coordinates.
      CPoint pt(::GetMessagePos());
      CRect rc;
      GetWindowRect(&amp;rc);

      // Add a little margin around the AppBar
      rc.InflateRect(2 * GetSystemMetrics(SM_CXDOUBLECLK), 
         2 * GetSystemMetrics(SM_CYDOUBLECLK));

      if (!rc.PtInRect(pt)) {
         // If the mouse is NOT over the AppBar, hide the AppBar
         ShowHiddenAppBar(FALSE);
      }
   }

   CDialog::OnTimer(nIDEvent);
}


/////////////////////////////////////////////////////////////////////////////


void CAppBar::OnNcMouseMove(UINT nHitTest, CPoint point) {

   // If we are a docked, auto-hidden AppBar, shown us
   // when the user moves over our non-client area
   ShowHiddenAppBar(TRUE);

   CDialog::OnNcMouseMove(nHitTest, point);
}


/////////////////////////////////////////////////////////////////////////////


UINT CAppBar::OnNcHitTest(CPoint point) {

   // Find out what the system thinks is the hit test code
   UINT u = CDialog::OnNcHitTest(point);

   // NOTE: If the user presses the secondary mouse button, pretend that the
   // user clicked on the client area so that we get WM_CONTEXTMENU messages
   BOOL fPrimaryMouseBtnDown = 
      (GetAsyncKeyState(GetSystemMetrics(SM_SWAPBUTTON) 
         ? VK_RBUTTON : VK_LBUTTON) &amp; 0x8000) != 0;

   if ((u == HTCLIENT) &amp;&amp; fPrimaryMouseBtnDown) {

      // User clicked in client area, allow AppBar to move.  We get this 
      // behavior by pretending that the user clicked on the caption area.
      u = HTCAPTION;
   }

   // When the AppBar is docked, the user can resize only one edge.
   // This next section determines which edge the user can resize.
   // To allow resizing, the AppBar window must have the WS_THICKFRAME style.

   // If the AppBar is docked and the hittest code is a resize code...
   if ((GetState() != ABE_FLOAT) &amp;&amp; (GetState() != ABE_UNKNOWN) &amp;&amp; 
       (HTSIZEFIRST &lt;= u) &amp;&amp; (u &lt;= HTSIZELAST)) {

      if (0 == (IsEdgeLeftOrRight(GetState()) ? 
         m_szSizeInc.cx : m_szSizeInc.cy)) {

         // If the width/height size increment is zero, then resizing is NOT 
         // allowed for the edge that the AppBar is docked on.
         u = HTBORDER;  // Pretend that the mouse is not on a resize border
      } else {

         // Resizing IS allowed for the edge that the AppBar is docked on.
         // Get the location of the appbar's client area in screen coordinates.
         CRect rcClient;
         GetClientRect(&amp;rcClient);
         ClientToScreen(rcClient);
         u = HTBORDER;  // Assume that we can't resize

         switch (GetState()) {
            case ABE_LEFT:
               if (point.x &gt; rcClient.right) u = HTRIGHT;
               break;

            case ABE_TOP:
               if (point.y &gt; rcClient.bottom) u = HTBOTTOM;
               break;

            case ABE_RIGHT:
               if (point.x &lt; rcClient.left) u = HTLEFT;
               break;

            case ABE_BOTTOM:
               if (point.y &lt; rcClient.top) u = HTTOP;
               break;
         }
      }
   }

   return(u);  // Return the hittest code
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnEnterSizeMove(WPARAM wParam, LPARAM lParam) {

   // The user started moving/resizing the AppBar, save its current state.
   m_uStateProposedPrev = GetState();
   return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnExitSizeMove(WPARAM wParam, LPARAM lParam) {

   // The user stopped moving/resizing the AppBar, set the new state.

   // Save the new proposed state of the AppBar.
   UINT uStateProposedPrev = m_uStateProposedPrev;

   // Set the proposed state back to unknown.  This causes GetState
   // to return the current state rather than the proposed state.
   m_uStateProposedPrev = ABE_UNKNOWN;

   // Get the location of the window in screen coordinates
   CRect rc;
   GetWindowRect(&amp;rc);

   // If the AppBar's state has changed...
   if (GetState() == uStateProposedPrev) {

      switch (GetState()) {
         case ABE_UNKNOWN:
            break;

         case ABE_LEFT: 
         case ABE_RIGHT:
            // Save the new width of the docked AppBar
            m_abs.m_auDimsDock[m_abs.m_uState] = rc.Width(); 
            break;

         case ABE_TOP: 
         case ABE_BOTTOM:
            // Save the new height of the docked AppBar
            m_abs.m_auDimsDock[m_abs.m_uState] = rc.Height(); 
            break;
      }
   }

   // Always save the new position of the floating AppBar
   if (uStateProposedPrev == ABE_FLOAT)
      m_abs.m_rcFloat = rc; 

   // After setting the dimensions, set the AppBar to the proposed state
   SetState(uStateProposedPrev);
   return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnMoving(WPARAM wParam, LPARAM lParam) {

   // We control the moving of the AppBar.  For example, if the mouse moves 
   // close to an edge, we want to dock the AppBar.

   // The lParam contains the window's position proposed by the system
   CRect* prc = (CRect *) lParam;

   // Get the location of the mouse cursor
   CPoint pt(::GetMessagePos());

   // Where should the AppBar be based on the mouse position?
   UINT uStateProposed = CalcProposedState(pt);

   if ((m_uStateProposedPrev != ABE_FLOAT) &amp;&amp; (uStateProposed == ABE_FLOAT)) {
      // While moving, the user took us from a docked/autohidden state to 
      // the float state.  We have to calculate a rectangle location so that
      // the mouse cursor stays inside the window.
      GetFloatRect(prc);
      *prc = CRect(pt.x - prc-&gt;Width() / 2, pt.y, 
         (pt.x - prc-&gt;Width() / 2) + prc-&gt;Width(), pt.y + prc-&gt;Height());
   }

   // Remember the most-recently proposed state
   m_uStateProposedPrev = uStateProposed;

   // Tell the system where to move the window based on the proposed state
   GetRect(uStateProposed, prc);

   // Tell our derived class that there is a proposed state change
   OnAppBarStateChange(TRUE, uStateProposed);

   return(0);
}


/////////////////////////////////////////////////////////////////////////////


LRESULT CAppBar::OnSizing(WPARAM wParam, LPARAM lParam) {

   // We control the sizing of the AppBar.  For example, if the user re-sizes 
   // an edge, we want to change the size in descrete increments.

   // The lParam contains the window's position proposed by the system
   CRect* prc = (CRect *) lParam;

   // Get the minimum size of the window assuming it has no client area.
   // This is the width/height of the window that must always be present
   CRect rcBorder(0, 0, 0, 0);
   AdjustWindowRectEx(&amp;rcBorder, GetStyle(), FALSE, GetExStyle());

   // We force the window to resize in discrete units set by the m_szSizeInc 
   // member.  From the new, proposed window dimensions passed to us, round 
   // the width/height to the nearest discrete unit.
   int nWidthNew  = ((prc-&gt;Width()  - rcBorder.Width())  + m_szSizeInc.cx / 2) / 
                             m_szSizeInc.cx * m_szSizeInc.cx + rcBorder.Width();
   int nHeightNew = ((prc-&gt;Height() - rcBorder.Height()) + m_szSizeInc.cy / 2) / 
                            m_szSizeInc.cy * m_szSizeInc.cy + rcBorder.Height();

   // Adjust the rectangle's dimensions
   switch (wParam) {
      case WMSZ_LEFT:    
         prc-&gt;left   = prc-&gt;right  - nWidthNew;  
         break;

      case WMSZ_TOP:     
         prc-&gt;top    = prc-&gt;bottom - nHeightNew; 
         break;

      case WMSZ_RIGHT:   
         prc-&gt;right  = prc-&gt;left   + nWidthNew;  
         break;

      case WMSZ_BOTTOM:  
         prc-&gt;bottom = prc-&gt;top    + nHeightNew; 
         break;

      case WMSZ_BOTTOMLEFT:
         prc-&gt;bottom = prc-&gt;top    + nHeightNew; 
         prc-&gt;left   = prc-&gt;right  - nWidthNew;  
         break;

      case WMSZ_BOTTOMRIGHT:
         prc-&gt;bottom = prc-&gt;top    + nHeightNew; 
         prc-&gt;right  = prc-&gt;left   + nWidthNew;  
         break;

      case WMSZ_TOPLEFT:
         prc-&gt;left   = prc-&gt;right  - nWidthNew;
         prc-&gt;top    = prc-&gt;bottom - nHeightNew;
         break;

      case WMSZ_TOPRIGHT:
         prc-&gt;top    = prc-&gt;bottom - nHeightNew;
         prc-&gt;right  = prc-&gt;left   + nWidthNew;  
         break;
   }
   return(0);
}


//////////////////////////////// End of File /////////////////////////////////</PRE>
<P>At the top of the class definition is a public section that specifiesfourstatichelperfunctions.Thesefunctionsarespecific to appbars, but you do not have to have an instance of aCAppBarcreatedtocallthem. Thefirst twofunctions, IsEdgeLeftOrRight and IsEdgeTopOrBottom, are just convenience functions that check if an edge is left/right or top/bottom.</P>
<P>ResetSystemKnowledge is an interesting function that makes it easier to debug a CAppBar-derived class. The CAppBar constructor calls this function but because this function is static, it can be called at any time. ResetSystemKnowledge forces the shell to send ABN_POSCHANGED notifications to all of the registered appbars in the system so that they will reposition themselves properly.</P>
<P> </P>
<P><BR></P>
<PRE> void CAppBar::ResetSystemKnowledge (void) {
   #ifdef _DEBUG
   // Only do this for debug builds.
   APPBARDATA abd;
   abd.cbSize = sizeof(abd);
   abd.hWnd = NULL;
   ::SHAppBarMessage(ABM_REMOVE, &amp;abd);
   #endif
 }</PRE>
<P> </P>
<P>As you can see, this function just tells the shell to remove a window whose handle is NULL. There will never be a window with a handle of NULL but the shell does broadcast ABN_POSCHANGED notifications to the registered appbars anyway. So why bother? Suppose you are debugging your CAppBar-derived class and its window is docked on the edge of your screen. If you stop debugging, the window will be destroyed but an ABM_REMOVE message is not sent to the shell. The shell still thinks that your window is taking up screen real estate. This causes a blank rectangle to appear on your screen and keeps your workarea smaller than it should be. The next time you run/debug your application, ResetSystemKnowledge is called and your workarea will be configured properly.</P>
<P>The last static helper function is GetEdgeFromPoint. This function takes a set of ABF_XXX flags (defined in AppBar.h) and a point (in screen coordinates). The function compares the point with the rectangle bounding the workarea to determine if the point is closest to the left, top, right or bottom. Then GetEdgeFromPoint checks the flags passed to determine which edges are allowed and whether the appbar should float instead. The function returns ABE_LEFT, ABE_TOP, ABE_RIGHT, ABE_BOTTOM, or ABE_FLOAT.</P>
<P>The CAppBar class has a protected section that defines the internal implementation state variables. In general, a derived class should not alter any of these variables directly with the exception of m_fdwFlags. This member variable allows you to finetune the behavior of a CAppBar. Initialize this variable with a combination of the flags shown in <B>Figure 6</B>. Most CAppBar-derived classes will set this member to ABF_ALLOWANYWHERE and not use any of the other flags. You must specify at least one of the ABF_ALLOWLEFTRIGHT, ABF_ALLOWTOPBOTTOM, or ABF_ALLOWFLOAT flags or your appbar will not work correctly because you are telling the CAppBar class that the appbar cannot appear anywhere!</P>
<P><B> Figure 6  M_fdwFlags Values</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="189pt" VALIGN="TOP"><COL WIDTH="252pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Flag</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_ALLOWLEFTRIGHT</P></TD><TD VALIGN="TOP"><P>Allow the appbar to dock on the left or right edge of the screen.</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_ALLOWTOPBOTTOM</P></TD><TD VALIGN="TOP"><P>Allow the appbar to dock on the top or bottom of the screen.</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_ALLOWANYEDGE</P></TD><TD VALIGN="TOP"><P>Same as (ABF_ALLOWLEFTRIGHT | ABF_ALLOWTOPBOTTOM).</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_ALLOWFLOAT</P></TD><TD VALIGN="TOP"><P>Allow the appbar to float in the middle of the screen.</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_ALLOWANYWHERE</P></TD><TD VALIGN="TOP"><P>(ABF_ALLOWANYEDGE | ABF_ALLOWFLOAT)</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_MIMICTASKBARAUTOHIDE</P></TD><TD VALIGN="TOP"><P>The appbar should monitor ABN_STATECHANGE notifications and be autohide if the taskbar is autohide.</P></TD></TR><TR><TD VALIGN="TOP"><P> ABF_MIMICTASKBARALWAYSONTOP</P></TD><TD VALIGN="TOP"><P>The appbar should monitor ABN_STATECHANGE notifications and be always-on-top if the taskbar is always-on-top.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The CAppBar class also defines a protected data structure APPBARSTATE, and a member variable m_abs as an instance of this structure:</P>
<P> </P>
<P><BR></P>
<PRE> typedef struct {<BR>   DWORD m_cbSize;         // Size of this structure<BR>   UINT  m_uState;         // ABE_UNKNOWN, ABE_FLOAT, or 
                           // ABE_edge<BR>   BOOL  m_fAutoHide;      // Should AppBar be autohide 
                           // when docked?<BR>   BOOL  m_fAlwaysOnTop;   // Should AppBar always be on
                           // top?<BR>   UINT  m_auDimsDock[4];  // Width/height for docked bar
                           // on 4 edges<BR>   CRect m_rcFloat;        // Floating rectangle (in
                           // screen coordinates)<BR>} APPBARSTATE, *PAPPBARSTATE;<BR>APPBARSTATE m_abs;         // This AppBar's state info</PRE>
<P> </P>
<P>This structure is the driving force behind the CAppBar implementation. It is used by derived classes, but derived classes should never touch the m_abs variable directly—member functions (contained in the public section following this section) exist that allow a derived class to access and alter the m_abs variable. In fact, almost all of the member functions alter the contents of this variable in one way or another. During its initialization, a derived class should allocate an APPBARSTATE structure for itself, initialize all of the members, and then call the base class's SetState member function:</P>
<P> </P>
<P><BR></P>
<PRE> void SetState (APPBARSTATE&amp; abs);</PRE>
<P> </P>
<P>This function initializes CAppBar's internal m_abs variable. SetState also notifies the shell of the appbar's location, adjusts the size of the appbar, docks or floats the appbar, autohides the appbar, or adjusts its z-order. In other words, this function does a lot of work.</P>
<P>A derived class acquires the current state of the m_abs variable by calling GetState.</P>
<P> </P>
<P><BR></P>
<PRE> void GetState (APPBARSTATE* pabs);</PRE>
<P> </P>
<P>There are additional overloaded forms of the SetState and GetState functions as well as other functions that are provided for convenience—all of them manipulate the internal m_abs variable.</P>
<P>The CAppBar class has a protected section in the header file marked "Internal implementation functions." As you can guess, the functions in this section exist for the internal implementation of the CAppBar class. You might find these functions useful, but you probably won't need them.</P>
<P>The SHAppBarMessage function is a wrapper around Win32® SHAppBarMessage. It exists purely as a convenience, which is why it has so many default parameters. It simply allocates an APPBARDATA structure, initializes it, and calls the Win32 SHAppBarMessage function.</P>
<P>CalcProposedState calls GetEdgeFromPoint passing the CAppBar's m_fdwFlags member and the point. This function also checks to see if the user is holding down the Control key forcing the appbar to float rather than dock. This feature allows the user to float an appbar even if the appbar is moved very close to an edge of the screen.</P>
<P>The GetRect function is used heavily throughout the CAppBar class's implementation. This function is passed a proposed state and a proposed rectangle identifying where the appbar should be on the screen. The function then examines the proposed state, sends the shell an ABM_QUERYPOS message and determines where the appbar can really be located. The rectangle pointed to by the prcProposed parameter is updated with the valid rectangle.</P>
<P>The ShowHiddenAppBar and SlideWindow functions are used together. ShowHiddenAppBar shows or hides the appbar if it is an autohide appbar. If the appbar is not autohide, the function just returns. If the appbar is autohide, the function determines the new location of the appbar and then calls the SlideWindow function, which slides the window on or off the screen. The SlideWindow function is not specific to appbars. You can easily steal this function and incorporate it into some other application if you want to be able to slide a window from one location to another.</P>
<P>The CAppBar class also has several protected virtual functions. A CAppBar-derived class will probably want to override some of these functions to get notifications of what's going on inside the base class.</P>
<P>The first overridable function, OnAppBarStateChange, notifies the derived class that the appbar has just changed its state. A derived class might use this notification to add a caption to the window when it is floating or take the caption away when the appbar is docked. The base class's implementation of this function does nothing.</P>
<P>The OnAppBarForcedToDocked function notifies a derived class that the appbar is autohide and that it tried to dock on an edge which already contains an autohide appbar. The derived class usually will not implement this function because the implementation in the base class displays a message box as shown in <B>Figure 2</B>. When the base class displays this message box, it first grabs the window's caption text and uses this text for the caption of the message box. You'll always want to give your appbar caption text, even if that caption is not normally displayed as part of the appbar's window.</P>
<P>The last four overridable functions are called when the appbar receives one of the four ABN_XXX notifications. Usually, the derived class will not implement these functions and will just use the base class's implementation.</P>
<P>When OnABNFullScreenApp is called, the base class's implementation keeps track of whether a full screen window is up and adjusts the z-order of the appbar accordingly.</P>
<P>When OnABNPosChanged is called, the base class's implementation adjusts the appbar's window location.</P>
<P>When OnABNStateChanged is called, it is passed a bit mask indicating which of the taskbar's states have changed and what the new states are. The base class's implementation of this function simply calls the MimicState function passing this same information,which has the effect of setting your appbar's state to reflect the taskbar's state depending on whether the ABF_MIMICTASKBARAUTOHIDE or ABF_MIMICTASKBARALWAYSONTOP flagsareset.TheCAppBarclass carefully examines only the states that have changed.</P>
<P>When OnABNWindowArrange is called, the base class's implementation does nothing. Most derived classes will not care about this notification and will not need to supply animplementation for this function.</P>
<P>CAppBar's remaining member functions are all window message handlers (see <B>Figure 7</B>).</P>
<P><B> Figure 7  CAppBar Member Functions</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="126pt" VALIGN="TOP"><COL WIDTH="315pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B> Message Handler</B></P></TD><TD VALIGN="TOP"><P><B>Description</B></P></TD></TR><TR><TD VALIGN="TOP"><P> OnCreate</P></TD><TD VALIGN="TOP"><P>Sets a timer used to determine when to slide an autohide window.<BR>Registers the appbar by sending an ABM_NEW message.<BR>Calls MimicState.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnDestroy</P></TD><TD VALIGN="TOP"><P>Kills the timer.</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>Unregisters the appbar by sending an ABM_REMOVE message.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnWindowPosChanged</P></TD><TD VALIGN="TOP"><P>Brings autohide appbars to the top by sending an ABM_WINDOWPOSCHANGED message.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnActivate</P></TD><TD VALIGN="TOP"><P>On de-activation, slides the appbar out if it's autohide.</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>Brings autohide appbars to the top by sending an ABM_ACTIVATE message.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnTimer</P></TD><TD VALIGN="TOP"><P>Slides the appbar (if autohide) off the screen if it's not activated and the mouse is not over it.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnNcMouseMove</P></TD><TD VALIGN="TOP"><P>Slides the appbar (if autohide) on to the screen.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnNcHitTest</P></TD><TD VALIGN="TOP"><P>If the mouse is in the client area, return HTCAPTION so that the appbar can be moved.</P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>Returns a value indicting whether the cursor is over an area of the window where resizing is allowed.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnEnterSizeMove</P></TD><TD VALIGN="TOP"><P>Saves the current state of the appbar.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnExitSizeMove</P></TD><TD VALIGN="TOP"><P>Saves the new state of the appbar and repositions it on the screen.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnMoving</P></TD><TD VALIGN="TOP"><P>From the mouse position, CalcProposedState is called to get the proposed state of the appbar, then GetRect is called to get the location of the window in this state, then </P></TD></TR><TR><TD VALIGN="TOP"><P> </P></TD><TD VALIGN="TOP"><P>OnAppBarStateChange is called to let the derived class know what the proposed state change is.</P></TD></TR><TR><TD VALIGN="TOP"><P> OnSizing</P></TD><TD VALIGN="TOP"><P>Ensures that the window's width or height always change in discrete increments.</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P> </P>
<H2><A NAME="sec7"></A>  The CSRBar Class</H2><P>To test my CAppBar class, I wrote a sample app called SHELLRUN.EXE, which is an MFC version 4.0 dialog-based app. (To obtain complete source code listings, see page 5.) The application main dialog box is not derived directly from CDialog; it's derived instead  from my CAppBar class. When you invoke the application, it creates an appbar and docks it by default on the top of your screen (see <B>Figure 8</B>).</P>
<P><img src="SHELL8.gif"></P>
<P><B> Figure 8</B></P>
<P>This appbar contains just two controls, an Execute button and an Edit control. In the edit control, you can enter any shell command that you'd like. Pressing Enter or Execute causes the appbar to parse the command and call the Win32 ShellExecute function to invoke it. For shell commands, you can enter program names like Notepad or Calc, drive letters or full paths to open Explorer windows, or you can enter document files and the application will be spawned automatically. You can even enter a web address (as shown in <B>Figure 8</B>) and the Internet Explorer will execute.</P>
<P>Because ShellRun is an appbar, you can, of course, dock the window on any edge of the screen; you can even make it float by dropping it in the middle of your screen. To move the appbar, you must click the mouse on the client area of the main window; you cannot click on any of the child windows. When the appbar is floating, it automatically adds a window caption as shown in <B>Figure 9</B>. When you design the dialog box template for your appbar, you'll want to make sure that the WS_EX_TOOLWINDOW style is turned on and that the WS_EX_APPWINDOW style is turned off. Tool windows never show up as buttons in the taskbar but application windows always do. By the way, when the system changes the screen's workarea, the system does not reposition any windows that have the WS_EX_TOOLWINDOW style. That's another reason for giving your appbar the WS_EX_TOOLWINDOW style.</P>
<P><img src="SHELL9.gif"></P>
<P><B> Figure 9</B></P>
<P>The ShellRun appbar tests some additional features too. When you right-click on the client area of the main window, a context menu appears as shown in <B>Figure 10</B>. This menu allows you to change the always-on-top and autohide features of the appbar. You can also display an About box and terminate the application.</P>
<P><img src="SHELL10.gif"></P>
<P><B> Figure 10</B></P>
<P>Other features of the ShellRun application demonstrate resizing an appbar in discrete increments. You can test this while the appbar is docked, autohide, or floating. The CAppBar base class ensures that the appbar always resizes in discrete increments and your derived class receives WM_SIZE messages as this happens. Of course, you'll want to reorganize the child controls in your dialog box.</P>
<P>It is obvious that Microsoft's software engineers have spent a lot of time and energy on the new system shell. It's also obvious that the shell has gone through some major changes (probably due to usability testing) while Windows 95 was in beta test. Many of these changes have resulted in APIs that are not well-documented. But, with a little (OK, maybe a lot) of patience and perseverance, adding shell enhancements to your own apps can give them a very professional and polished feel. </P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
