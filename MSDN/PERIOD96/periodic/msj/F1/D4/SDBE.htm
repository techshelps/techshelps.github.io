<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C/C++ Q &amp; A</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  C/C++ Q &amp; A</H1><P>Paul DiLascia</P>
<P>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is the author of <I>Windows++: Writing Reusable Code in C++</I> (Addison-Wesley, 1992).</P>
<P><OBJECT id=sample1 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4599">
</OBJECT><a href="javascript:sample1.Click()">

Click to open or copy the TRAYTEST project files.</A></P><P><OBJECT id=sample2 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Backgrounders Samples">
<PARAM name="Item2" value="4600">
</OBJECT><a href="javascript:sample2.Click()">
Click to open or copy the TRACEWIN project files.</A></P><P><OBJECT id=sample3 type="application/x-oleobject"
classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11"
width=0 height=0 hspace=0>
<PARAM name="Command" value="Sample">
<PARAM name="Item1" value="Periodicals Samples">
<PARAM name="Item2" value="4601">
</OBJECT><a href="javascript:sample3.Click()">
Click to open or copy the UPDTENMD project files.</A></P><P></P>
<P><font size="6" face="verdana,arial,helvetica">Q</font>I noticed that some programs install an icon in the Windows® 95 task bar, on the right edge near the clock. For example, the System Agent that comes with the Windows 95 Plus! pack installs an icon. Does MFC have a class that will let me add my own icon to the task bar?</P>
<P><I>Bruce Eddington</I></P>
<P><font size="6" face="verdana,arial,helvetica">A</font>No, but it's easy to write your own. Putting your own icon in the Windows 95 "system tray" is pretty straightforward. (In fact, you can do it from Visual Basic, as Josh Trupin detailed in last month's Visual Programmer column.) I'll teach you C++ folks how to do it this go-round. One function, Shell_NotifyIcon, is all you need. Shell_NotifyIcon is pretty simple. The first argument is a code (NIM_ADD, NIM_MODIFY, or NIM_DELETE) that says whether you want to add, modify, or delete an icon from the tray. The second and only other argument is a pointer to a NOTIFYICONDATA struct.</P>
<P> </P>
<P><BR></P>
<PRE> // (From SHELLAPI.H)<BR>typedef struct _NOTIFYICONDATA {<BR>  DWORD cbSize;           // sizeofstruct,youmustset<BR>  HWND hWnd;              // HWND sending notification<BR>  UINT uID;               // IDoficon(callbackWPARAM)<BR>  UINT uFlags;            // see below<BR>  UINT uCallbackMessage;  // sent to your wndproc<BR>  HICON hIcon;            // handle of icon<BR>  CHAR szTip[64];         // tip text<BR>} NOTIFYICONDATA;<BR><BR>// uFlags<BR>#define NIF_MESSAGE 0x1   // uCallbackMessage is valid<BR>#define NIF_ICON    0x2   // hIcon is valid<BR>#define NIF_TIP     0x4   // szTip is valid</PRE>
<P> </P>
<P>hWnd is a handle to your window that "owns" the icon. uID can be any ID you like that identifies your tray icon (in case you have more than one). Typically, you'll use its resource ID. hIcon can be a handle to any icon, including predefined system icons like IDI_HAND, IDI_QUESTION, IDI_EXCLAMATION, or IDI_WINLOGO, the Windows logo.</P>
<P>Displaying icons is nice, but what's really fun are events. To receive notification when the user moves the mouse over or clicks on your tray icon, you can set uCallbackMessage to your very own message ID, and set the NIF_MESSAGE flag. When the user moves or clicks the mouse over the icon, Windows will call your window proc with hWnd equal to your window handle, specified in hWnd; messageID is the value you specified in uCallbackMessage; wParam is the value you specified as uID; and lParam is a mouse event (such as WM_LBUTTONDOWN).</P>
<P>Shell_NotifyIcon is short, simple, and sweet. But like most Windows API functions, it's a little clunky and assemblerish. So I encapsulated it in a C++ class, CTrayIcon (see <B>Figure 1</B>). CTrayIcon hides NOTIFYICONDATA, message codes, flags, and all that rot. It presents a more programmer-friendly interface to tray icons. But CTrayIcon is more than just a wrapper for Shell_NotifyIcon—it's a miniframework. It enforces the correct user interface behavior for tray icons, as per the Windows Interface Guidelines for Software (available on MSDN). Here's the executive sumary:</P>
<UL><LI>    Tray icons should have tooltips.</LI><LI>   Right-click should display a popup menu with commands that bring up property sheets or other windows related to the icon.</LI><LI>   Left-double-click should execute the default command in this menu.</LI><LI>   Left-click should display further information or controls for the object represented by the tray icon. (For example, the volume control when you left-click the sound icon.) If there's no information or control that applies, don't do anything.</LI></UL><P><B> Figure 1  CTrayIcon</B></P>
<P></P>
<P>TRAYTEST.H</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////<BR>// TRAYTEST 1996 Microsoft Systems Journal. <BR>// See TRAYTEST.CPP for description of program.<BR>// <BR>#include "resource.h"<BR><BR>class CMyApp : public CWinApp {<BR>public:<BR>   virtual BOOL InitInstance();<BR>   //{{AFX_MSG(CMyApp)<BR>   afx_msg void OnAppAbout();<BR>   //}}AFX_MSG<BR>   DECLARE_MESSAGE_MAP()<BR>};</PRE>
<P></P>
<P>TRAYTEST.CPP</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////<BR>// TRAYTEST 1996 Microsoft Systems Journal. <BR>// If this program works, it was written by Paul DiLascia.<BR>// If not, I don't know who wrote it.<BR>//<BR>// TRAYTEST illustrates how to use CTrayIcon. <BR>// All the activity takes place in MainFrm.cpp.<BR><BR>#include "stdafx.h"<BR>#include "TrayTest.h"<BR>#include "mainfrm.h"<BR><BR>CMyApp theApp;<BR><BR>BEGIN_MESSAGE_MAP(CMyApp, CWinApp)<BR>   //{{AFX_MSG_MAP(CMyApp)<BR>   ON_COMMAND(ID_APP_ABOUT, OnAppAbout)<BR>   //}}AFX_MSG_MAP<BR>END_MESSAGE_MAP()<BR><BR>BOOL CMyApp::InitInstance()<BR>{<BR>   // Create main frame window (don't use doc/view stuff)<BR>   // <BR>   CMainFrame* pMainFrame = new CMainFrame;<BR>   if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))<BR>      return FALSE;<BR>   pMainFrame-&gt;ShowWindow(SW_HIDE);<BR>   pMainFrame-&gt;UpdateWindow();<BR>   m_pMainWnd = pMainFrame;<BR>   OnAppAbout();<BR>   return TRUE;<BR>}<BR><BR>void CMyApp::OnAppAbout()<BR>{<BR>   CDialog(IDD_ABOUTBOX).DoModal();<BR>}</PRE>
<P></P>
<P>MAINFRM.H</P>
<P><BR></P>
<PRE> #include "trayicon.h"<BR><BR>//////////////////<BR>// Main frame for TRAYTEST.<BR>//<BR>class CMainFrame : public CFrameWnd {<BR>public:<BR>   CMainFrame();<BR>   virtual ~CMainFrame();<BR>protected:<BR>   DECLARE_DYNAMIC(CMainFrame)<BR>   CStatusBar  m_wndStatusBar;<BR><BR>   CTrayIcon   m_trayIcon;    // my tray icon<BR>   CEdit       m_wndEdit;     // to display tray notifications<BR>   int         m_iWhichIcon;  // 0/1 which HICON to use<BR>   BOOL        m_bShutdown;   // OK to terminate TRAYTEST<BR>   BOOL        m_bShowTrayNotifications;  // display info in main window<BR><BR>   //{{AFX_MSG(CMainFrame)<BR>   afx_msg LRESULT OnTrayNotification(WPARAM wp, LPARAM lp);<BR>   afx_msg int  OnCreate(LPCREATESTRUCT lpCreateStruct);<BR>   afx_msg void OnToggleIcon();<BR>   afx_msg void OnViewClear();<BR>   afx_msg void OnViewNotifications();<BR>   afx_msg void OnUpdateViewClear(CCmdUI* pCmdUI);<BR>   afx_msg void OnUpdateViewNotifications(CCmdUI* pCmdUI);<BR>   afx_msg void OnClose();<BR>   afx_msg void OnAppOpen();<BR>   afx_msg void OnAppSuspend();<BR>   //}}AFX_MSG<BR>   DECLARE_MESSAGE_MAP()<BR>};</PRE>
<P></P>
<P>MAINFRM.CPP</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////<BR>// Main frame window implementation<BR>//<BR>#include "stdafx.h"<BR>#include "TrayTest.h"<BR>#include "mainfrm.h"<BR><BR>// Message ID used for tray notifications<BR>#define WM_MY_TRAY_NOTIFICATION WM_USER+0<BR><BR>IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)<BR><BR>BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)<BR>   //{{AFX_MSG_MAP(CMainFrame)<BR>   ON_MESSAGE(WM_MY_TRAY_NOTIFICATION, OnTrayNotification)<BR>   ON_WM_CREATE()<BR>   ON_COMMAND(ID_VIEW_CLEAR,           OnViewClear)<BR>   ON_COMMAND(ID_TOGGLE_ICON,          OnToggleIcon)<BR>   ON_COMMAND(ID_VIEW_NOTIFICATIONS,   OnViewNotifications)<BR>   ON_UPDATE_COMMAND_UI(ID_VIEW_CLEAR, OnUpdateViewClear)<BR>   ON_UPDATE_COMMAND_UI(ID_VIEW_NOTIFICATIONS, OnUpdateViewNotifications)<BR>   ON_WM_CLOSE()<BR>   ON_COMMAND(ID_APP_OPEN, OnAppOpen)<BR>   ON_COMMAND(ID_APP_SUSPEND, OnAppSuspend)<BR>   //}}AFX_MSG_MAP<BR>END_MESSAGE_MAP()<BR><BR>static UINT BASED_CODE indicators[] = {<BR>   ID_SEPARATOR,           // status line indicator<BR>};<BR><BR>CMainFrame::CMainFrame() : m_trayIcon(IDR_TRAYICON)<BR>{<BR>   m_bShowTrayNotifications = TRUE;<BR>   m_bShutdown = FALSE;<BR>}<BR><BR>CMainFrame::~CMainFrame()<BR>{<BR>}<BR><BR>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)<BR>{<BR>   if (CFrameWnd::OnCreate(lpCreateStruct) == -1)<BR>      return -1;<BR><BR>   if (!m_wndStatusBar.Create(this) ||<BR>      !m_wndStatusBar.SetIndicators(indicators, <BR>      sizeof(indicators)/sizeof(UINT))) <BR>      return -1;      // fail to create<BR><BR>   // Create child edit control for displaying messages<BR>   CRect rc;<BR>   if (!m_wndEdit.Create(<BR>      WS_VISIBLE|WS_CHILD|WS_VSCROLL|ES_MULTILINE|ES_READONLY, rc, this, <BR>      AFX_IDW_PANE_FIRST))<BR><BR>      return -1;<BR><BR>   // Set up tray icon<BR>   m_trayIcon.SetNotificationWnd(this, WM_MY_TRAY_NOTIFICATION);<BR>   m_iWhichIcon = 1;<BR>   m_trayIcon.SetIcon(IDI_MYICON);<BR><BR>   return 0;<BR>}<BR><BR>//////////////////<BR>// Close window. Unless we are shutting down, just hide it.<BR>//<BR>void CMainFrame::OnClose() <BR>{<BR>   if (m_bShutdown)<BR>      CFrameWnd::OnClose();<BR>   else<BR>      ShowWindow(SW_HIDE);<BR>}<BR><BR>//////////////////<BR>// Handle notification from tray icon: display a message.<BR>//<BR>LRESULT CMainFrame::OnTrayNotification(WPARAM uID, LPARAM lEvent)<BR>{<BR>   if (m_bShowTrayNotifications) {<BR>      static LPCSTR MouseMessages[] = { "WM_MOUSEMOVE",<BR>         "WM_LBUTTONDOWN", "WM_LBUTTONUP", "WM_LBUTTONDBLCLK",<BR>         "WM_RBUTTONDOWN", "WM_RBUTTONUP", "WM_RBUTTONDBLCLK",<BR>         "WM_MBUTTONDOWN", "WM_MBUTTONUP", "WM_MBUTTONDBLCLK" };<BR><BR>      CString s;<BR>      s.Format("Tray notification: ID=%d, lEvent=0x%04x %s\r\n", <BR>         uID, lEvent, WM_MOUSEFIRST&lt;=lEvent &amp;&amp; lEvent&lt;=WM_MOUSELAST ? <BR>         MouseMessages[lEvent-WM_MOUSEFIRST] : "(Unknown)");<BR><BR>      m_wndEdit.SetSel(-1, -1);     // end of edit text<BR>      m_wndEdit.ReplaceSel(s);      // append string..<BR>      m_wndEdit.SendMessage(EM_SCROLLCARET); // ..and make visible<BR>   }<BR><BR>   // let tray icon do default stuff<BR>   return m_trayIcon.OnTrayNotification(uID, lEvent);<BR>}<BR><BR>////////////////////////////////////////////////////////////////<BR>// Command handlers below.<BR>//<BR>void CMainFrame::OnViewClear() <BR>{<BR>   m_wndEdit.SetWindowText("");  <BR>}<BR><BR>void CMainFrame::OnUpdateViewClear(CCmdUI* pCmdUI) <BR>{<BR>   pCmdUI-&gt;Enable(m_wndEdit.GetLineCount() &gt; 1 || m_wndEdit.LineLength() &gt; 0);<BR>}<BR><BR>void CMainFrame::OnToggleIcon() <BR>{<BR>   m_iWhichIcon=!m_iWhichIcon;<BR>   m_trayIcon.SetIcon(m_iWhichIcon ? IDI_MYICON : IDI_MYICON2);<BR>}<BR><BR>void CMainFrame::OnViewNotifications() <BR>{<BR>   m_bShowTrayNotifications = !m_bShowTrayNotifications;<BR>}<BR><BR>void CMainFrame::OnUpdateViewNotifications(CCmdUI* pCmdUI) <BR>{<BR>   pCmdUI-&gt;SetCheck(m_bShowTrayNotifications);<BR>}<BR><BR>void CMainFrame::OnAppOpen() <BR>{<BR>   ShowWindow(SW_NORMAL);  <BR>   SetForegroundWindow();<BR>}<BR><BR>void CMainFrame::OnAppSuspend() <BR>{<BR>   m_bShutdown = TRUE;     // really exit<BR>   SendMessage(WM_CLOSE);  <BR>}
</PRE>
<P>TRAYICON.H</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////<BR>// CTrayIcon Copyright 1996 Microsoft Systems Journal.<BR>//<BR>// If this code works, it was written by Paul DiLascia.<BR>// If not, I don't know who wrote it.<BR><BR>#ifndef _TRAYICON_H<BR>#define _TRAYICON_H<BR><BR>////////////////<BR>// CTrayIcon manages an icon in the Windows 95 system tray. <BR>// <BR>class CTrayIcon : public CCmdTarget {<BR>protected:<BR>   DECLARE_DYNAMIC(CTrayIcon)<BR>   NOTIFYICONDATA m_nid;         // struct for Shell_NotifyIcon args<BR><BR>public:<BR>   CTrayIcon(UINT uID);<BR>   ~CTrayIcon();<BR><BR>   // Call this to receive tray notifications<BR>   void SetNotificationWnd(CWnd* pNotifyWnd, UINT uCbMsg);<BR><BR>   // SetIcon functions. To remove icon, call SetIcon(0)<BR>   //<BR>   BOOL SetIcon(UINT uID); // main variant you want to use<BR>   BOOL SetIcon(HICON hicon, LPCSTR lpTip);<BR>   BOOL SetIcon(LPCTSTR lpResName, LPCSTR lpTip)<BR>      { return SetIcon(lpResName ? <BR>         AfxGetApp()-&gt;LoadIcon(lpResName) : NULL, lpTip); }<BR>   BOOL SetStandardIcon(LPCTSTR lpszIconName, LPCSTR lpTip)<BR>      { return SetIcon(::LoadIcon(NULL, lpszIconName), lpTip); }<BR><BR>   virtual LRESULT OnTrayNotification(WPARAM uID, LPARAM lEvent);<BR>};<BR><BR>#endif</PRE>
<P></P>
<P>TRAYICON.CPP</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////<BR>// CTrayIcon Copyright 1996 Microsoft Systems Journal.<BR>//<BR>// If this code works, it was written by Paul DiLascia.<BR>// If not, I don't know who wrote it.<BR><BR>#include "stdafx.h"<BR>#include "trayicon.h"<BR>#include &lt;afxpriv.h&gt;    // for AfxLoadString<BR><BR>IMPLEMENT_DYNAMIC(CTrayIcon, CCmdTarget)<BR><BR>CTrayIcon::CTrayIcon(UINT uID)<BR>{<BR>   // Initialize NOTIFYICONDATA<BR>   memset(&amp;m_nid, 0 , sizeof(m_nid));<BR>   m_nid.cbSize = sizeof(m_nid);<BR>   m_nid.uID = uID;  // never changes after construction<BR><BR>   // Use resource string as tip if there is one<BR>   AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip));<BR>}<BR><BR>CTrayIcon::~CTrayIcon()<BR>{<BR>   SetIcon(0); // remove icon from system tray<BR>}<BR><BR>//////////////////<BR>// Set notification window. It must created already.<BR>//<BR>void CTrayIcon::SetNotificationWnd(CWnd* pNotifyWnd, UINT uCbMsg)<BR>{<BR>   // If the following assert fails, you're probably<BR>   // calling me before you created your window. Oops.<BR>   ASSERT(pNotifyWnd==NULL || ::IsWindow(pNotifyWnd-&gt;GetSafeHwnd()));<BR>   m_nid.hWnd = pNotifyWnd-&gt;GetSafeHwnd();<BR><BR>   ASSERT(uCbMsg==0 || uCbMsg&gt;=WM_USER);<BR>   m_nid.uCallbackMessage = uCbMsg;<BR>}<BR><BR>//////////////////<BR>// This is the main variant for setting the icon.<BR>// Sets both the icon and tooltip from resource ID<BR>// To remove the icon, call SetIcon(0)<BR>//<BR>BOOL CTrayIcon::SetIcon(UINT uID)<BR>{ <BR>   HICON hicon=NULL;<BR>   if (uID) {<BR>      AfxLoadString(uID, m_nid.szTip, sizeof(m_nid.szTip));<BR>      hicon = AfxGetApp()-&gt;LoadIcon(uID);<BR>   }<BR>   return SetIcon(hicon, NULL);<BR>}<BR><BR>//////////////////<BR>// Common SetIcon for all overloads. <BR>//<BR>BOOL CTrayIcon::SetIcon(HICON hicon, LPCSTR lpTip) <BR>{<BR>   UINT msg;<BR>   m_nid.uFlags = 0;<BR><BR>   // Set the icon<BR>   if (hicon) {<BR>      // Add or replace icon in system tray<BR>      msg = m_nid.hIcon ? NIM_MODIFY : NIM_ADD;<BR>      m_nid.hIcon = hicon;<BR>      m_nid.uFlags |= NIF_ICON;<BR>   } else { // remove icon from tray<BR>      if (m_nid.hIcon==NULL)<BR>         return TRUE;      // already deleted<BR>      msg = NIM_DELETE;<BR>   }<BR><BR>   // Use the tip, if any<BR>   if (lpTip)<BR>      strncpy(m_nid.szTip, lpTip, sizeof(m_nid.szTip));<BR>   if (m_nid.szTip[0])<BR>      m_nid.uFlags |= NIF_TIP;<BR><BR>   // Use callback if any<BR>   if (m_nid.uCallbackMessage &amp;&amp; m_nid.hWnd)<BR>      m_nid.uFlags |= NIF_MESSAGE;<BR><BR>   // Do it<BR>   BOOL bRet = Shell_NotifyIcon(msg, &amp;m_nid);<BR>   if (msg==NIM_DELETE || !bRet)<BR>      m_nid.hIcon = NULL;  // failed<BR>   return bRet;<BR>}<BR><BR>/////////////////<BR>// Default event handler handles right-menu and doubleclick.<BR>// Call this function from your own notification handler.<BR>//<BR>LRESULT CTrayIcon::OnTrayNotification(WPARAM wID, LPARAM lEvent)<BR>{<BR>   if (wID!=m_nid.uID ||<BR>      (lEvent!=WM_RBUTTONUP &amp;&amp; lEvent!=WM_LBUTTONDBLCLK))<BR>      return 0;<BR><BR>   // If there's a resource menu with the same ID as the icon, use it as <BR>   // the right-button popup menu. CTrayIcon will interprets the first<BR>   // item in the menu as the default command for WM_LBUTTONDBLCLK<BR>   // <BR>   CMenu menu;<BR>   if (!menu.LoadMenu(m_nid.uID))<BR>      return 0;<BR>   CMenu* pSubMenu = menu.GetSubMenu(0);<BR>   if (!pSubMenu) <BR>      return 0;<BR><BR>   if (lEvent==WM_RBUTTONUP) {<BR><BR>      // Make first menu item the default (bold font)<BR>      ::SetMenuDefaultItem(pSubMenu-&gt;m_hMenu, 0, TRUE);<BR><BR>      // Display the menu at the current mouse location. There's a "bug"<BR>      // (Microsoft calls it a feature) in Windows 95 that requires calling<BR>      // SetForegroundWindow. To find out more, search for Q135788 in MSDN.<BR>      //<BR>      CPoint mouse;<BR>      GetCursorPos(&amp;mouse);<BR>      ::SetForegroundWindow(m_nid.hWnd);  <BR>      ::TrackPopupMenu(pSubMenu-&gt;m_hMenu, 0, mouse.x, mouse.y, 0,<BR>         m_nid.hWnd, NULL);<BR><BR>   } else  // double click: execute first menu item<BR>      ::SendMessage(m_nid.hWnd, WM_COMMAND, pSubMenu-&gt;GetMenuItemID(0), 0);<BR><BR>   return 1; // handled<BR>}</PRE>
<P> </P>
<P>CTrayIcon encapsulates all but the last of these rules. To show how it works, I wrote a little program. When you run TRAYTEST, it displays the dialog in <B>Figure 2</B>, then installs an icon in the system tray and goes into hiding. If you double-click the tray icon, TRAYTEST appears with a window that displays tray notifications as you move or click the mouse in the tray icon (see <B>Figure 3</B>).</P>
<P><img src="CQA2.gif"></P>
<P><B> Figure 2  TRAYTEST</B></P>
<P><img src="CQA3.gif"></P>
<P><B> Figure 3  TRAYTEST</B></P>
<P>To use CTrayIcon, the first thing you have to do is instantiate a CTrayIcon someplace where it'll live for the lifetime of the icon. TRAYTEST does it in its frame window.</P>
<P> </P>
<P><BR></P>
<PRE> class CMainFrame : public CFrameWnd {<BR>protected:<BR>  CTrayIcon m_trayIcon;  <BR>                  // my tray icon
                     .
                     .
                     .
};</PRE>
<P> </P>
<P>When you instantiate a CTrayIcon, you must supply an ID. This is the one-and-only ID used for the lifetime of the icon, even if you later change the actual icon displayed. This ID is the one you'll get when mouse events happen. It need not be the resource ID of the icon; for TRAYTEST, it's IDR_TRAYICON, initialized by the CMainFrame constructor.</P>
<P> </P>
<P><BR></P>
<PRE> CMainFrame::CMainFrame() : m_trayIcon(IDR_TRAYICON)<BR>{
                     .
                     .
                     .
}</PRE>
<P> </P>
<P>To add the icon, call one of the overloaded SetIcon functions:</P>
<P> </P>
<P><BR></P>
<PRE> m_trayIcon.SetIcon(IDI_MYICON);         //resource ID<BR>m_trayIcon.SetIcon("myicon");           //resourcename<BR>m_trayIcon.SetIcon(hicon);              //HICON<BR>m_trayIcon.SetStandardIcon(IDI_WINLOGO);//system icon</PRE>
<P> </P>
<P>All these functions take an optional LPCSTR argument to use as the tip text, except for SetIcon(UINT uID) which looks for a string resource with the same uID as the tip. For example, TRAYTEST contains the line,</P>
<P> </P>
<P><BR></P>
<PRE> // (In mainframe.cpp)<BR>m_trayIcon.SetIcon(IDI_MYICON);</PRE>
<P> </P>
<P>which also sets the tip, because TRAYTEST has a string with the same ID:</P>
<P> </P>
<P><BR></P>
<PRE> // (In TRAYTEST.RC)<BR>STRINGTABLE PRELOAD DISCARDABLE <BR>BEGIN<BR> IDI_MYICON"Double-clickthebananatoactivateTRAYTEST."<BR>END</PRE>
<P> </P>
<P>If you want to change the icon, you can call one of the SetIcon functions again with a different ID or HICON. CTrayTest will know to do NIM_MODIFY instead of NIM_ADD. The same function even works to remove the icon:</P>
<P> </P>
<P><BR></P>
<PRE> m_trayIcon.SetIcon(0);//removeicon</PRE>
<P> </P>
<P>CTrayIcon will translate this into NIM_DELETE. All those codes, all those flags replaced with a single overloaded function: isn't C++ great? Now, what about notifications and all that UI stuff I mentioned? To handle tray notifications, call CTrayIcon::SetNotificationWnd sometime before you set the icon, but after your window is created. The perfect place is in your OnCreate handler, which is where TRAYTEST does it.</P>
<P> </P>
<P><BR></P>
<PRE> // Private message used for tray notifications<BR>#define WM_MY_TRAY_NOTIFICATION WM_USER+0<BR>int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)<BR>{
                       .
                       .
                       .
  // Notify me, please
  m_trayIcon.SetNotificationWnd(this,<BR>                        WM_MY_TRAY_NOTIFICATION);<BR>                           m_trayIcon.SetIcon(IDI_MYICON);<BR>  return 0;<BR>}</PRE>
<P> </P>
<P>Once you've registered yourself, you handle tray notifications in the normal message map manner.</P>
<P> </P>
<P><BR></P>
<PRE> BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)<BR>  ON_MESSAGE(WM_MY_TRAY_NOTIFICATION,<BR>             OnTrayNotification)<BR>             // (or ON_REGISTERED_MESSAGE)<BR>END_MESSAGE_MAP()<BR><BR>LRESULT <BR>CMainFrame::OnTrayNotification(WPARAM wp, LPARAM lp)<BR>{                    
       .
       . // display message
       .
return m_trayIcon.OnTrayNotification(wp, lp);
}</PRE>
<P> </P>
<P>When your handler gets control, WPARAM is the ID you specified when you constructed the CTrayIcon; LPARAM is the mouse event (for example, WM_LBUTTONDOWN). You can do whatever you like when you get the notification; TRAYTEST displays information about the notification (see <B>Figure 1</B>, in MAINFRM.CPP, for details). When you're finished, call CTrayIcon::OnTrayNotification to perform default processing. This virtual (so you can override it) function implements the default UI behavior I mentioned earlier. In particular, it handles WM_LBUTTONDBLCLK and WM_RBUTTONUP. CTrayIcon looks for a menu with the same ID as the icon (for example, IDR_TRAYICON). If a menu with this ID exists, CTrayIcon displays it when the user right-clicks the icon; when the user double-clicks, CTrayIcon executes the first command in the menu. Only two things require further explanation.</P>
<P>Before displaying the menu, CTrayIcon makes the first item the default, so it appears bold. But how do you make a menu item bold? After several minutes of grep'ing in \MSDEV\INCLUDE\*.H, I discovered Get/SetMenuDefaultItem. There are no CMenu wrappers for these (as of MFC 4.0), so I had to call them directly.</P>
<P> </P>
<P><BR></P>
<PRE> // Make first menu item the default (bold font)<BR>::SetMenuDefaultItem(pSubMenu-&gt;m_hMenu, 0, TRUE);</PRE>
<P> </P>
<P>Here 0 identifies the first menu item, and the TRUE specifies that the item ID is by position, not ID. How come there's no MFC wrapper for Get/SetMenuDefaultItem? The folks in Redmond explained that it's because these functions (and several others, like ::Get/SetMenuItemInfo, ::LoadImage, and so on) are not yet implemented in Windows NT(asof3.51).As soon as Windows NT gets its facelift, wrappers will be added to MFC. </P>
<P>The second item of interest in CTrayIcon::OnTrayNotification is what it does to display the context menu:</P>
<P> </P>
<P><BR></P>
<PRE> ::SetForegroundWindow(m_nid.hWnd);  <BR>::TrackPopupMenu(pSubMenu-&gt;m_hMenu, ...);</PRE>
<P> </P>
<P>To make TrackPopupMenu work properly in the context of a tray, you must first call SetForegroundWindow on the window that owns the popup. Otherwise, the menu will not disappear when the user presses Escape or clicks the mouse outside the menu. This totally obscure behavior caused me hours of grief until I finally uncovered a problem report about it on MSDN. To find out more, search for Q135788 in MSDN. What I love most is that after describing the problem and workaround at great length, the PRB concludes by stating "This behavior is by design."</P>
<P>As you can see, CTrayIcon makes tray icons almost trivial. All TRAYTEST does to make its tray menu work are implement a notification handler that calls CTrayIcon::OnTrayNotification, and provide a menu with the same ID as the CTrayIcon.</P>
<P> </P>
<P><BR></P>
<PRE> // (In TRAYTEST.RC)<BR>IDR_TRAYICON MENU DISCARDABLE <BR>BEGIN<BR>  POPUP "&amp;Tray"<BR>  BEGIN<BR>    MENUITEM "&amp;Open",             ID_APP_OPEN<BR>    MENUITEM "&amp;About TRAYTEST...",ID_APP_ABOUT<BR>    MENUITEM SEPARATOR<BR>    MENUITEM "&amp;Suspend TRAYTEST", ID_APP_SUSPEND<BR>    END<BR>END</PRE>
<P> </P>
<P>When the user right-clicks the tray icon, CTrayIcon displays this menu (see <B>Figure 4</B>). And if the user double-clicks, CTrayIcon executes the first item: Open, which activates TRAYTEST (normally, it's hidden). To terminate TRAYTEST, you must select Suspend TRAYTEST from the tray menu. If you do File Exit or close the TRAYTEST main window, TRAYTEST doesn't really close, it merely hides itself.TRAYTESToverrides CMainframe::OnClose to provide this behavior (see <B>Figure 1</B> MAINFRM.CPP).</P>
<P><img src="CQA4.gif"></P>
<P><B> Figure 4  TRAYTEST menu.</B></P>
<P>Before leaving you with CTrayIcon, some words of advice. I was almost afraid to answer this question, because I know everyone is going to run out and implement a tray icon as soon as they find out how. (I did.) It's just one of those things about being a programmer: as soon as there's some new little graphic gizmo, you have to try it out. Go ahead, do it. Add a tray icon to your app, stare at it, feel good, show it to your friends, have a party. Then take it out. Because most apps have no need for them. Unless you're writing some sort of system add-in like a replacement shell or improved print spooler or fontware DLL that loads invisibly, all tray icons will do is contribute to screen pollution. <B>Figure 5</B> shows my nightmare vision of tray icons gone amok.</P>
<P><img src="CQA5.gif"></P>
<P><B> Figure 5  Tray icon abbundanza.</B></P>
<P> </P>
<H2><A NAME="sec0"></A>  Update</H2><P>A few issues back (December 1995), someone wrote asking how to save and restore the position of an MDI child window in a document. The answer I gave focused primarily on the mechanics of changing the frame window position at the appropriate time during loading. I showed how to override CDocTemplate::InitialUpdateFrame to get the saved position from the document, and then move the frame. As far as the actual moving was concerned, I did the obvious thing: GetWindowRect to get the position of the window for saving it, and MoveWindow to restore the saved position.</P>
<P>I recently noticed a problem with my TRACEWIN program (October 1995), which also uses GetWindowRect/MoveWindow to save and restore the window position across user sessions. Sometimes, when I ran TRACEWIN, it would come up invisible. TRACEWIN would appear in the Windows 95 task bar, but when I clicked to activate it, there was no window anywhere I could see. Moreover, I'd noticed the same behavior with a commercial app I have, but it wasn't reproducible so I ignored it.</P>
<P>A little investigation revealed what was going on. When I looked at the registry entries for my saved window position, the top left corner was at (x,y) coordinates (3000,3000). On an 800 x 600 display, that's somewhere roughly near Saturn. Likewise with my commercial app: the window was at (3000, 3000). How were these windows getting moved to outer space?</P>
<P>Well! As anyone knows who's ever used it, Windows 95 doesn't minimize windows the same way Windows 3.1 did. Instead, Windows 95 moves your window off the screen. When I shut down my computer while TRACEWIN was minimized, TRACEWIN saved these bogus coordinates and restored them the next time it ran. Once I figured out what was going on, I was able to consistently reproduce the bug by minimizing TRACEWIN, then closing it from the task bar without restoring it first. Sure enough, the next time I ran TRACEWIN, it came up in outer space.</P>
<P>I thought, OK, I won't save the position if the window is minimized. But I quickly realized that wouldn't do: what if the user changed the window size before minimizing it? The new size wouldn't get saved. So what was I supposed to do, save the window position every time the user minimized or maximized the window? Sheesh. And if this remember-the-position feature was really what it claimed to be, TRACEWIN should come up minimized if that's how it was the last time it was used. Suddenly I was contemplating several lines of code just to save the measly window position.</P>
<P>At this point I let out a long groan, because I suddenly remembered how you're supposed to do this stuff. There's a pair of little-known but really useful Windows API functions whose only roles in life are to manage the saving and restoring of window positions: GetWindowPlacement and SetWindowPlacement. Placement refers to the size and position of the window when it's in restored state (neither minimized nor maximized), whether it's minimized or not, and whether activating it should go to maximized state instead of restored state. This last situation arises when the user maximizes a window, then minimizes it. Activating the window should restore it to maximized state, not restored state—but the window should still remember its restored position in case the user clicks the restore button in the title bar. It's all very complicated, but GetSetWindowPlacement make a molehill out of the mountain. All you have to do is call GetWindowPlacement to get the placement, then call SetWindowPlacement to restore it.</P>
<P>GetWindowPlacement returns everything you could ever want to know about your window's placement in a struct called WINDOWPLACEMENT. You can save this information in the registry, then read it back when your program starts up, and call SetWindowPlacement to restore the window to the exact same placement as before, including all the bizarre minimize/maximize/restore semantics. It all works just like it should. The only thing Get/SetWindowPlacement doesn't do is read and write the information to your app's profile (registry key or INI file). Since that seems like such a natural thing to do, I wrote a little class that does it.</P>
<P><B>Figure 6 </B>shows how I implemented CWindowPlacement, and <B>Figure 7</B> shows how I modified TRACEWIN to use it. The implementation is brainless—the hardest part was thinking up registry key names for the items in WINDOWPLACEMENT. I could've used the MFC functions Get/WriteProfileBinary to save the whole struct in one fell swoop, but I wanted something more readable than hex, so if something ever goes wrong, I can always manually edit my profile with REGEDIT (see <B>Figure 8</B>). The only thing CWindowPlacement does that could be considered remotely clever is check that the restored position is in fact visible before restoring it, in case the user changes display resolution from something like 1024x68 to SVGA's lowly 800x600 (which is what I use, so I'll be laughing when I'm old and all my programmer friends have gone alexic from staring at too many tiny pixels).</P>
<P><B> Figure 6  CWindowPlacement</B></P>
<P></P>
<P>WINPLACE.H</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// CWindowPlacement 1996 Microsoft Systems Journal.
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.

////////////////
// CWindowPlacement reads and writes WINDOWPLACEMENT 
// from/to application profile and CArchive.
//
struct CWindowPlacement : public WINDOWPLACEMENT {
   CWindowPlacement();
   ~CWindowPlacement();
   
   // Read/write to app profile
   void GetProfileWP(LPCSTR lpKeyName);
   void WriteProfileWP(LPCSTR lpKeyName);

   // Save/restore window pos (from app profile)
   void Save(LPCSTR lpKeyName, CWnd* pWnd);
   BOOL Restore(LPCSTR lpKeyName, CWnd* pWnd);

   // Save/restore from archive
   friend CArchive&amp; operator&lt;&lt;(CArchive&amp; ar, const CWindowPlacement&amp; wp);
   friend CArchive&amp; operator&gt;&gt;(CArchive&amp; ar, CWindowPlacement&amp; wp);
};</PRE>
<P></P>
<P>WINPLACE.CPP</P>
<P><BR></P>
<PRE> ////////////////////////////////////////////////////////////////
// CWindowPlacement 1996 Microsoft Systems Journal.
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
#include "stdafx.h"
#include "winplace.h"

CWindowPlacement::CWindowPlacement()
{
   // Note: "length" is inherited from WINDOWPLACEMENT
   length = sizeof(WINDOWPLACEMENT);
}

CWindowPlacement::~CWindowPlacement()
{
}

//////////////////
// Restore window placement from profile key
BOOL CWindowPlacement::Restore(LPCSTR lpKeyName, CWnd* pWnd)
{
   GetProfileWP(lpKeyName);

   // Only restore if window intersets the screen.
   //
   CRect rcTemp, rcScreen(0,0,GetSystemMetrics(SM_CXSCREEN),
      GetSystemMetrics(SM_CYSCREEN));
   if (!::IntersectRect(&amp;rcTemp, &amp;rcNormalPosition, &amp;rcScreen))
      return FALSE;

   pWnd-&gt;SetWindowPlacement(this);  // set placement
   return TRUE;
}

//////////////////
// Get window placement from profile.
void CWindowPlacement::GetProfileWP(LPCSTR lpKeyName)
{
   CWinApp *pApp = AfxGetApp();
   ASSERT_VALID(pApp);

   showCmd = pApp-&gt;GetProfileInt(lpKeyName, "wp.showCmd", showCmd);
   flags   = pApp-&gt;GetProfileInt(lpKeyName, "wp.flags", flags);

ptMinPosition.x = pApp-&gt;GetProfileInt(lpKeyName, "wp.ptMinPosition.x", 
      ptMinPosition.x);
ptMinPosition.y = pApp-&gt;GetProfileInt(lpKeyName, "wp.ptMinPosition.y",
      ptMinPosition.y);
ptMaxPosition.x = pApp-&gt;GetProfileInt(lpKeyName, "wp.ptMaxPosition.x", 
      ptMaxPosition.x);
ptMaxPosition.y = pApp-&gt;GetProfileInt(lpKeyName, "wp.ptMaxPosition.y",
      ptMaxPosition.y);

   RECT&amp; rc = rcNormalPosition;  // because I hate typing
   rc.left  = pApp-&gt;GetProfileInt(lpKeyName, "wp.left",   rc.left);
   rc.right = pApp-&gt;GetProfileInt(lpKeyName, "wp.right",  rc.right);
   rc.top   = pApp-&gt;GetProfileInt(lpKeyName, "wp.top",    rc.top);
   rc.bottom= pApp-&gt;GetProfileInt(lpKeyName, "wp.bottom", rc.bottom);
}

////////////////
// Save window placement in app profile
void CWindowPlacement::Save(LPCSTR lpKeyName, CWnd* pWnd)
{
   pWnd-&gt;GetWindowPlacement(this);
   WriteProfileWP(lpKeyName);
}

//////////////////
// Write window placement to app profile
void CWindowPlacement::WriteProfileWP(LPCSTR lpKeyName)
{
   CWinApp *pApp = AfxGetApp();
   ASSERT_VALID(pApp);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.showCmd",         showCmd);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.flags",           flags);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.ptMinPosition.x", ptMinPosition.x);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.ptMinPosition.y", ptMinPosition.y);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.ptMaxPosition.x", ptMaxPosition.x);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.ptMaxPosition.y", ptMaxPosition.y);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.left",  rcNormalPosition.left);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.right", rcNormalPosition.right);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.top",   rcNormalPosition.top);
   pApp-&gt;WriteProfileInt(lpKeyName, "wp.bottom",rcNormalPosition.bottom);
}

// The ugly casts are required to help the VC++ 3.0 compiler decide which
// operator&lt;&lt; or operator&gt;&gt; to use. If you're using VC++ 4.0 or later, you 
// can delete this stuff.
//
#if (_MSC_VER &lt; 1000)      // 1000 = VC++ 4.0
#define UINT_CAST (LONG)
#define UINT_CASTREF (LONG&amp;)
#else
#define UINT_CAST
#define UINT_CASTREF
#endif

//////////////////
// Write window placement to archive
// WARNING: archiving functions are untested.
CArchive&amp; operator&lt;&lt;(CArchive&amp; ar, const CWindowPlacement&amp; wp)
{
   ar &lt;&lt; UINT_CAST wp.length;
   ar &lt;&lt; UINT_CAST wp.flags;
   ar &lt;&lt; UINT_CAST wp.showCmd;
   ar &lt;&lt; wp.ptMinPosition;
   ar &lt;&lt; wp.ptMaxPosition;
   ar &lt;&lt; wp.rcNormalPosition;
   return ar;
}

//////////////////
// Read window placement from archive
// WARNING: archiving functions are untested.
CArchive&amp; operator&gt;&gt;(CArchive&amp; ar, CWindowPlacement&amp; wp)
{
   ar &gt;&gt; UINT_CASTREF wp.length;
   ar &gt;&gt; UINT_CASTREF wp.flags;
   ar &gt;&gt; UINT_CASTREF wp.showCmd;
   ar &gt;&gt; wp.ptMinPosition;
   ar &gt;&gt; wp.ptMaxPosition;
   ar &gt;&gt; wp.rcNormalPosition;
   return ar;
}</PRE>
<P><B> Figure 7  TWMOD.CPP</B></P>
<P><BR></P>
<PRE> ///////////////////////////////////////////////////////////////////////////
// Changes to TRACEWIN that implement saving/restoring the window position.

// (From MainFrm.h)
class CMainFrame : public CFrameWnd {
public:
   static const char* REGKEY; // registry key for saved settings
                                     .
                                     .
                                     .
};

// (From MainFrm.cpp, TRACEWIN's main window)
const char* CMainFrame::REGKEY = "Settings";
void CMainFrame::OnClose() 
{
   // Save current settings in registry
   CWindowPlacement wp;
   wp.Save(REGKEY, this);
                                     .
                                     . (Save other stuff too)
                                     .
CFrameWnd::OnClose();
}

// (From App.cpp, TRACEWIN's app object)
BOOL CApp::InitInstance()
{
   // Save settings in registry, not INI file
   SetRegistryKey("MSJ");
                                     .
                                     . Create main window
                                     .
// Load window placement from profile
   CWindowPlacement wp;
   if (!wp.Restore(CMainFrame::REGKEY, pMainFrame))
      pMainFrame-&gt;ShowWindow(m_nCmdShow);
                                     .
                                     .
                                     .
   return TRUE;
}</PRE>
<P><img src="CQA8.gif"></P>
<P><B> Figure 8  Manually editing profiles with REGEDIT.</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD COLSPAN="2" VALIGN="TOP"><P> Have a question about programming in C or C++? You can mail it directly to C/C++ Q&amp;A, Microsoft Systems Journal, 825 Eighth Avenue, 18th Floor, New York, New York 10019, or send it to MSJ (re: C/C++ Q&amp;A) via:</P></TD></TR><TR><TD VALIGN="TOP"><P> <BR>Internet:</P>
<P><BR>Internet:</P></TD><TD VALIGN="TOP"><P>Paul DiLascia<BR>72400.2702@compuserve.com</P>
<P>Eric Maffei<BR>ericm@microsoft.com</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><I>This article is reproduced from Microsoft Systems Journal. Copyright © 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</P>
<P></P></font></body></HTML>
