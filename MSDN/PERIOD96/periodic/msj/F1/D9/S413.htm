<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Poking Around Under the Hood:  A Programmer's View of Windows NT 4.0</TITLE>
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>  Poking Around Under the Hood:  A Programmer's View of Windows NT 4.0</H1><P>Matt Pietrek</P>
<P>Matt Pietrek is the author of <I>Windows 95 System Programming Secrets</I> (IDG Books, 1995). He works at Nu-Mega Technologies Inc., and can be reached at 71774.362@compuserve.com.</P>
<P><img src="poke.gif"></P>
<P><B> This article assumes you're familiar with Win32</B></P>
<P>Windows NT¨ 4.0 (also known as the Shell Update Release) has been garnering much attention for its new usability and performance improvements. But there's much more to Windows NT 4.0 than just the pretty Windows¨ 95 user interface. In fact, many of the features originally slated for Cairo, the next major revision of Windows NT, have made their way into Windows NT 4.0. From a programming standpoint, Windows NT 4.0 offers a slew of new APIs and COM interfaces, as well as the APIs and interfaces that originated with Windows 95. In addition, the basic architecture of the Win32¨ subsystem (essentially USER32 and GDI32) has been changed. While this shouldn't affect the average programmer, take a look at the "How'd They Speed It Up Like That?" sidebar if you're interested in how the architecture improves performance. With all its new features and improved performance, Windows NT 4.0 should be a no-brainer upgrade. I believe the existing Windows NT user base will move to this new version relatively quickly, just as the migration from Windows NT 3.1 to 3.5 didn't take long at all.</P>
<P>In this article, I'll give a programmer's perspective of what's new and exciting in Windows NT 4.0 relative to Windows NT 3.51 and Windows 95. I'll describe some new architectural additions to Windows NT 4.0. I'll also describe new functionality in the core system DLLs (such as KERNEL32, USER32, OLE32, and so on) and several new DLLs. I'll finish up by talking about my pet topic, getting at system information, and some cool new Win32 SDK tools. There's so much that's new in Windows NT 4.0 that I can't hope to cover every subject in detail. Rather, I'll attempt to give the big picture view and leave the details to other articles and the Win32 documentation. </P>
<P>This article was written based on information from the beta 2 version of the Windows NT 4.0 SDK, so some things may have changed by the time you read this. </P>
<P> </P>
<H2><A NAME="sec0"></A>  Programming For the New Shell</H2><P>The good news about the new Windows NT 4.0 shell and user interface (EXPLORER.EXE) is that they're not a radical departure from Windows 95. In perusing through the most recent help files, it appears that all of the Windows 95 OLE interfaces for the shell are now supported in Windows NT 4.0. Thus, if you've written code specific to the Windows 95 shell (such as shell extensions), this code should work unmodified in Windows NT 4.0. Windows NT 4.0 supports these interfaces from SHLOBJ.HS: IContextMenu, ICopyHook, IEnumIDList, IExtractIcon, IFileViewer, IFileViewerSite, IShellExtInit, IShellFolder, IShellLink, and IShellPropSheetExt. In addition to the standard shell interfaces, Windows NT 4.0 also includes the Windows 95 Briefcase interfaces from RECONCIL.H, including INotifyReplica (briefcase), IReconcilableObject (briefcase), andIReconcileInitiator (briefcase). Later on, I'll touch on the namespace extensions. For now, the important thing to know is that you can write common shell code for both Windows 95 and Windows NT 4.0.</P>
<P>Of course, if you've never programmed for the Windows 95 user interface or written shell extensions, there's much to learn. To get you up to speed, I'd suggest reading Jeff Prosise's March 1995 <I>MSJ</I> article, "Integrate Your Applications with the Windows 95 User Interface Using Shell Extensions."</P>
<P>Any similarity between the Windows 95 and Windows NT 4.0 user interfaces shouldn't be too surprising. An examination of the Windows 95 and Windows NT 4.0 EXPLORER.EXE files shows that they use the same basic set of Win32 functions, have very similar resources, and therefore most likely use the same code base. Obviously, the Windows NT Explorer will use a few more functions because of the security and administrative needs of Windows NT. Also, while the Windows 95 Explorer uses the ANSI Win32 functions, the Windows NT 4.0 Explorer uses the equivalent Unicode versions.</P>
<P> </P>
<H2><A NAME="sec1"></A>  Additions to the Core Architecture </H2><P>Windows NT 4.0 has numerous additions and refinements to its basic architecture. If you consider only those elements that programmers can use directly, the list is small but significant. </P>
<P>Perhaps the most publicized architectural feature in Windows NT 4.0 is Distributed COM (DCOM). DCOM extends COM so that COM objects and their clients can reside on different machines on a network. Thus, a server machine can serve up COM objects to clients running on other machines. The beauty of DCOM is that you really have to do very little to support it. Let's say you already have your COM/OLE setup working across processes with proxy and stub interfaces. There's very little difference between communicating with an object in another process on the same machine and communicating with a process on another machine entirely. The proxies and stubs make these differences transparent to application code. For more in-depth information on DCOM, see Don Box's May 1996 <I>MSJ</I> article, "Introducing Distributed COM and the New OLE Features in Windows NT 4.0."</P>
<P>Another big addition to Windows NT 4.0 is DirectXª support: Direct Drawª, Direct Soundª, and Direct Playª. If you go to the \WINNT\SYSTEM32 directory in Windows NT 4.0, you'll see DDRAW.DLL, DSOUND.DLL, and DPLAY.DLL. Their inclusion is interesting because DirectX allows programs to access hardware devices directly. Many programmers, myself included, consider accessing the hardware directly verboten because of stability concerns. The fact that Windows NT 4.0 includes DirectX support is ample evidence that Microsoft sees Windows NT 4.0 as much more of a mass market operating system than prior versions of Windows NT. </P>
<P>Fibers are a new architectural addition on the KERNEL32 side of things. To be completely accurate, fibers were introduced with the Windows NT 3.51 service pack 3, but Windows NT 4.0 is the first major release that includes them. Fibers are lightweight threads that need to be scheduled manually. I'll talk more about them later when I go through the new KERNEL32 functions.</P>
<P>If you've done multithreaded programming with Win32 before, you're probably familiar with the four basic synchronization methods: critical sections, events, semaphores, and mutexes. Windows NT 4.0 adds a fifth synchronization object, waitable timers, that has handles that you pass to functions such as WaitForMultipleObjects. After the specified time elapses, the timer object is set to the signaled state and an optional callback routine is invoked. </P>
<P>The final architectural addition I'll mention here is something that you don't access programatically. Rather, it's new functionality built into the Windows NT 4.0 loader. In WINNT.H, three new bits  can be set in a Win32 EXE or DLL image (you only care about these defines if you are writing a linker or file browser):</P>
<P> </P>
<P><BR></P>
<PRE> #define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP  0x0400
#define IMAGE_FILE_NET_RUN_FROM_SWAP        0x0800 
#define IMAGE_FILE_UP_SYSTEM_ONLY           0x4000 </PRE>
<P> </P>
<P>How do you set these bits? Linkers will be updated with new options to set these bits. For Microsoft¨ LINK, the options will be /swaprun:cd, /swaprun:net, and /driver:up, respectively.</P>
<P>If an EXE or DLL has the IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP bit set, the loader copies the disk image to the swapfile and builds the in-memory representation out of the swap file when it loads the module. Why would you want this? One very good reason is for programs such as uninstallers that need to delete their own EXE files. This was difficult to do in the past because the operating system would put a lock on any running executable file. IMAGE_FILE_NET_RUN_FROM_SWAP does the same thing, but it's for situations where the executable is on a network rather than a disk on the local machine. The remaining new flag, IMAGE_FILE_UP_SYSTEM_ONLY, tells the loader that this executable can be run on a single processor system only. </P>
<P> </P>
<H2><A NAME="sec2"></A>  Into the Trenches</H2><P>Having described in general terms what's new with Windows NT 4.0, let's now drop down a level and look at some new DLLs and some new functions in existing DLLs. </P>
<P>For the most part, Windows NT 4.0 implements the Windows 95 functions that didn't make it into Windows NT 3.51 due to time constraints. In the interest of keeping this article focused, I won't dwell on these functions. But keep in mind that just because Windows NT now has the same major version number as Windows 95 doesn't mean the Windows NT 4.0 API is identical to the Windows 95 API. For example, there are still some groups of functions—such as the Image Color Matching and TOOLHELP32 routines—that are in Windows 95 but not in Windows NT 4.0 (at least as of beta 2).</P>
<P>Many of the new APIs are related to data integrity and security. For instance, there's the new Cryptography API, new security-related functions in OLE, and even a DLL to help you verify the authenticity of files. See Mary Kirtland's article, "Safe Web Surfing With the Internet Component Download Service," in the July 1996<I> MSJ</I> for more about code signing and digital signatures. This emphasis on security is mostly due to the Internet.</P>
<P>One issue with portability of these new functions between Windows NT and Windows 95 is a #define in the system header files. All of the new goodies I'll describe below are only defined if the preprocessor symbol _WIN32_WINNT is greater than 0x0400. In the header files, information that is guarded by</P>
<P>    </P>
<P><BR></P>
<PRE>  #if _WIN32_WINNT &gt;= 0x0400</PRE>
<P> </P>
<P>is implemented only in Windows NT version 4.0 and later, not in Windows 95. This allows you to do compile-time checking for platform differences.</P>
<P>The value of _WIN32_WINNT is set in win32.mak depending on the platform you chose to target. When building for Windows NT 3.51–Japanese version, _WIN32_WINNT is defined to be 0x0351.  When building for Windows NT 4.0, _WIN32_WINNT is defined to be 0x0400. If you are building an application to run on Windows 95 and you want compile-time notification of compatibility issues that you will need to code around, do not define _WIN32_WINNT.</P>
<P>If you do not include win32.mak in your makefile, you will need to define _WIN32_WINNT to get some of the new Windows NT 4.0-specific material from the header files.</P>
<P> </P>
<H2><A NAME="sec3"></A>  New KERNEL32 Features</H2><P>Memory management is the bedrock of any operating system. In this category, KERNEL32 has two new functions: VirtualAllocEx and VirtualFreeEx. The "Ex," as with other virtual memory management functions, means that these functions can operate on processes other than your own.</P>
<P>Why allocate memory in another process? When combined with the SetThreadContext and WriteProcessMemory functions, you can force another process to do your bidding. For example, you can allocate some memory in another process, write whatever code and data you want into it, then change the instruction pointer of the other process to point at your new code. If Nashville also has these Virtual<I>XXX</I>Ex functions, there will be a relatively easy way to do things such as injecting a DLL into another process in a portable manner. You might be thinking that a function like VirtualAllocEx would compromise the security of a process, but that isn't the case. A system with properly set up access rights won't allow a rogue process to get a handle to other processes in the first place.</P>
<P>Windows NT 4.0 has several new highly extended file system routines in both ANSI and Unicode. The CopyFileEx function is a superset of CopyFile, and provides a way of getting called back as the file copy occurs. In the callback function, you're passed information such as the number of bytes copied, the total number of bytes to be copied, and file handles for the source and destination files.</P>
<P>The FindFirstFileEx function provides much more flexibility when searching for a file or directory. An info level parameter gives you control over how much information the function returns when it finds a matching file. A search op parameter lets you limit the search to just directory or device names. A related function, GetFileAttributesEx, reports the attributes on a specified file while giving you control over how much it reports.</P>
<P>The GetDiskFreeSpaceEx function deviates a fair amount from its predecessor. Instead of returning information in units of sectors, clusters, and bytes per sector, it just returns the total and free sizes of the disk in bytes. On the other hand, it returns this information in 64-bit unsigned integers, which can be a problem for some of us bit-challenged programmers with only 32 bits to play with. The function also differentiates between free space on disk and the space the caller would be allowed to use; a program wouldn't be allowed to use all of the remaining disk space if the system administrator set up disk usage quotas.</P>
<H2><A NAME="sec4"></A>  Fiber Makes Your Code Go</H2><P>Turning now to execution-related functions, the big addition to Windows NT 4.0 is fibers. While I could attempt to describe what a fiber is myself, the Windows NT 3.51 service pack documentation does such a good job that I'll defer to it here: </P>
<P>"A fiber is a lightweight thread that an application must manually schedule. Fibers run in the context of the threads that schedule them. Each thread can schedule multiple fibers. In general, fibers do not provide advantages over a well-designed multithreaded application. However, using fibers can make it easier to port applications that were designed to schedule their own threads.</P>
<P>"From a system standpoint, a fiber assumes the identity of the thread that created it. For example, if a fiber accesses thread local storage (TLS), it is accessing the thread local storage of the thread that created it. In addition, if a fiber calls the ExitThread function, the thread that created it exits. However, a fiber does not have all the same state information associated with it as that associated with a thread. The only state information maintained for a fiber is its stack, a subset of its registers, and the fiber data provided during fiber creation. The saved registers are the set of registers typically preserved across a function call."</P>
<P>Fibers are like threads stripped of their ability to be scheduled automatically by the thread scheduler. If you've used co-routines on other platforms, fibers should be second nature to you. A thread can create as many fibers as it wants, but each fiber isn't a separate thread in and of itself. Each fiber that a thread creates will share thread resources with other fibers created by the thread. Just as every thread shares its process's resources (such as memory and file handles), fibers share their thread's resources (such as the last error value retrieved by calling GetLastError). Fibers aren't something that you want to use if you're writing brand-new code that's only intended to run on Win32 platforms. Fibers are a way <BR>of getting applications written for other platforms onto Windows NT.</P>
<P>If you do forge ahead and use fibers, the CreateFiber routine creates a new fiber. This is somewhat like calling CreateThread with the CREATE_SUSPENDED flag. Once you have fibers, you can switch from one fiber to another by specifying its address. By itself, a fiber isn't going anywhere; you must goad it into action by calling SwitchToFiber.</P>
<P>Making things a little more interesting, only a fiber can switch to another fiber. How do you become a fiber if you're a thread? This is where the ConvertThreadToFiber function comes in handy. Typically, you'll create whatever fibers you need, then convert the initial thread to a fiber. When you're all finished with your threads, you need to clean up their memory by calling DeleteFiber.</P>
<P>How does this tie into the overall multithreading in Windows NT? The key point to remember is that fibers share a thread's resources, including its CPU timeslices. Thus, a thread that owns fibers should be scheduled just like any other thread. When a thread that has created fibers is executing, only one of the fibers within the thread will execute. The fiber will execute until it switches to another fiber or the thread scheduler ends the owning thread's timeslice.</P>
<P> </P>
<H2><A NAME="sec5"></A>  Other Thread Improvements</H2><P>Aside from fibers, there are other changes in store for threads. If you paid attention to early architectural discussions about Windows NT, you might recall something called priority boosting. That is, when the scheduler takes a thread out of a waiting state and lets it run, it juices up the thread's priority just a bit to make the system more responsive. In Windows NT 4.0, the SetProcessPriorityBoost and SetThreadPriorityBoost functions let you disable this priority boosting on a single thread or all threads in a process. The corresponding functions, GetProcessPriorityBoost and GetThreadPriorityBoost, are for returning the boost flag.</P>
<P>The big news on the thread synchronization front is waitable timers, which have handles and names, and act like other synchronization objects (such as events).You can pass a waitable timer handle to functions like WaitForMultipleObjects. To get a handle to a waitable timer, you can either create a timer via CreateWaitableTimer or you can get the handle of an existing timer by calling OpenWaitableTimer. You call SetWaitableTimer with the handle to use the timer. SetWaitableTimer takes parameters that specify the period of the timer, whether it will be triggered just once or repeatedly, and an optional pointer to a callback function that's invoked when the timer is made active. To deactivate a timer, use the CancelWaitableTimer function. When you're all done with the timer, you should pass the timer handle to CloseHandle as you do with other handle-based objects.</P>
<P>Have you ever been in a multithreading situation involving critical sections and wished that you could try to acquire a critical section but not block if some other thread owned it? Windows NT 4.0 has just the answer for that. A new function, TryEnterCriticalSection, acts very much like EnterCriticalSection. The difference is that it will return FALSE if some other thread already owns the critical section. This lets you do something else while some other thread owns the critical section.</P>
<P>The final two synchronization functions are relatively obscure. InterlockedCompareExchange and InterlockedExchangeAdd have been added to the other Interlocked Win32 functions, which ensure safe access to memory variables on multiprocessor machines. What's significant is that these new functions are implemented through native 486 instructions. The somewhat startling conclusion here is that the Intel version of Windows NT 4.0 requires at least a 486 to run.</P>
<P>There are a few other new KERNEL32 functions worth mentioning. GetCurrentHwProfile is for the limited Plug-and-Play support in Windows NT 4.0. ObjectDeleteAuditAlarm and DuplicateTokenEx are new security-related functions. In the area of digital signatures and Internet security, there are three new functions: WinSubmitCertificate, WinLoadTrustProvider, and WinVerifyTrust.</P>
<P> </P>
<H2><A NAME="sec6"></A>  New USER32 Features</H2><P>Compared to the frenetic additions to KERNEL32, USER32 is relatively sedate in its new functions. Other than adding in support for Windows 95 functions like MessageBoxIndirect, there are only a handful of truly new functions in Windows NT 4.0's user.</P>
<P>MsgWaitForMultipleObjectsEx (as its name implies) extends the capability of MsgWaitForMultipleObjects, which is a form of WaitForMultipleObjects that also returns if a window message is received. The basic MsgWaitForMultipleObjects function has one parameter that specifies whether just one or all of the waiting handles have to be signaled before it returns. In MsgWaitForMultipleObjectsEx, this single-or-all flag has been replaced with a bit flags parameter that encompasses the old functionality and also lets the function return if an asynchronous procedure call (APC) has been queued for the waiting thread.</P>
<P>Finally, the Windows NT USER32 introduces two new resource types. The RT_ANICURSOR and RT_ANIICON resources (animated cursors and animated icons) will be joining other illustrious resources such as menus, bitmaps, and string tables in an RC file near you. The binary format for a resource file is the same as for Windows 95.</P>
<P> </P>
<H2><A NAME="sec7"></A>  New GDI32 Features</H2><P>Like USER32, there's not much that's terribly new in the Windows NT 4.0 GDI32 component. In fact, comparing the exports of the Windows NT 3.51 GDI32.DLL to the Windows NT 4.0 beta 2 version shows that some DCI functions, such as GdiDciCreateOffscreenSurface, have been removed. DCI, you might recall, was an early standard for giving applications direct access to the video display hardware for increased performance. DCI has been supplanted these days by the DirectDraw API.</P>
<P>There are eight new OpenGL functions in Windows NT 4.0: wglCreateLayerContext, wglDescribeLayerPlane, wglSetLayerPaletteEntries, wglGetLayerPaletteEntries, wglRealizeLayerPalette, wglSwapLayerBuffers, wglCopyContext, and GetEnhMetaFilePixelFormat. Most of these functions deal with layer planes. Video boards often break up the color contents of a given pixel into layers (for example, a red plane, a green plane, and a blue plane). In Windows NT 4.0, these new OpenGL functions let you read and write the video layers directly. </P>
<P> </P>
<H2><A NAME="sec8"></A>  Tales from the Crypt</H2><P>The big news in ADVAPI32.DLL is the addition of the Cryptography (or Crypto) API. Once Windows NT made its way into mission-critical applications at places such as financial institutions, it needed to acquire additional security mechanisms. A large part of this comes in the form of the cryptographic functions. </P>
<P>The Crypto APIs were also introduced because of the Internet. On the Internet, people access data and programs that may have been tampered with. Cryptography is a way of ensuring that you get what you want. One form of cryptography, public key encryption, is especially good for use with the Internet, as one of the keys to decode the data can be made public with no loss in security.</P>
<P>One of the core concepts of the Crypto API is the Cryptographic Service Provider (CSP), a plug-in module (a DLL) that provides functions for encryption and decryption. Think of a CSP as being like a printer driver; a CSP must export a standard set of functions that is called by the operating system. How it implements those functions is up to the individual CSP.</P>
<P>Each CSP is responsible for performing whatever verification is needed to ensure that the user is allowed to use its facilities. This verification can range from nothing to a scan of the corneas in your eyeballs (the documentation refers to this as "biometric"). The point is, organizations using the Crypto APIs can provide their own CSP with whatever level of security they require. Microsoft provides a default CSP called RSABASE.DLL so that everybody will have at least a basic level of cryptographic functionality. RSA is a widely used public-key cipher (named after its developers, Ron Rivest, Adi Shamir, and Leonard Adleman). Not surprisingly, the exported functions in RSABASE.DLL match up nearly identically with the Win32 Crypto APIs.</P>
<P>Let's take a quick tour of the Crypto API. As I mentioned earlier, the cryptography functions (shown in <B>Figure 1</B>) are implemented in ADVAPI32.DLL. However, unlike KERNEL32.DLL or USER32.DLL, ADVAPI32.DLL has never really had its own distinct header file that encompasses all of its functions. Thus, the cryptography functions come from a new header file, WINCRYPT.H. To link to them, you'll use ADVAPI32.LIB. Also, a nice feature of the Crypto API is that the functions are consistently named—they all start with "Crypt."</P>
<P><B> Figure 1  Windows NT 4.0 Cryptography Functions</B></P>
<P><B>Context Functions</B></P>
<P>CryptAcquireContextA/W<BR>CryptReleaseContext <BR>CryptSetProvParam <BR>CryptGetProvParam <BR>CryptSetProviderA/W</P>
<P><B>Key Generation Functions </B></P>
<P>CryptGenKey <BR>CryptDeriveKey </P>
<P><B>Data Encryption Functions </B></P>
<P>CryptEncrypt <BR>CryptDecrypt </P>
<P><B>Key Exchange Functions </B></P>
<P>CryptDestroyKey <BR>CryptSetKeyParam <BR>CryptGetKeyParam <BR>CryptExportKey <BR>CryptImportKey <BR>CryptGenRandom <BR>CryptGetUserKey </P>
<P><B>Hashing and Signature Functions </B></P>
<P>CryptSetHashParam <BR>CryptGetHashParam <BR>CryptCreateHash <BR>CryptHashData <BR>CryptHashSessionKey <BR>CryptGetHashValue <BR>CryptDestroyHash <BR>CryptSignHashA/W <BR>CryptVerifySignatureA/W </P>
<P>The context functions are the first functions used when working with the Crypto API. To start with, you'll need an HCRYPTPROV (handle to cryptography provider), which you acquire through CryptAcquireContext. When acquiring an HCRYPTPROV, you can either request a specific CSP or use a default CSP. Applications can set the default CSP with the CryptSetProvider function. After using a CSP, clean up by calling CryptReleaseContext.</P>
<P>After hooking up to a CSP, the next step is to generate the keys used to encrypt and decrypt the data. CryptGenKey creates random keys, and CryptDeriveKey creates keys based on data that you supply. When creating a key, one of the parameters that must be specified is the encryption algorithm. The algorithms available depend on the CSP in service at the moment. It's important to note that these functions don't let you access the actual key data. Rather, both functions return handles to the keys, known as HCRYPTKEYs. After generating your HCRYPTKEYs, you can get down to the business of making your data indecipherable (perhaps hiding those Beavis and Butthead WAV files from your boss). The CryptEncrypt function takes an HCRYPTKEY and a buffer to encrypt. The corresponding function, CryptDecrypt, reverses the process. Pretty straightforward stuff.</P>
<P>Up to this point, I haven't mentioned anything about the actual key data itself. At some point it becomes necessary to get at the key data (known as a blob). For example, you may be working with public key encryption and need to retrieve the public key data to make it available to others. (It would be kind of pointless if you didn't!) The CryptExportKey function takes an HCRYPTKEY as input and spits out a key blob. The program that wants to decrypt something passes the blob to CryptImportKey, which adds the key to its CSP and returns an HCRYPTKEY. These importing and exporting functions, along with a handful of other functions, make up the key exchange functions. Key exchanging is the act of importing and exporting keys between the secure environment of the CSP and your application's address space.</P>
<P>The final set of functions in the Crypto API are the hashing and digital signature functions. Unlike encryption, hashing data involves a loss of information. The result of hashing any amount of data is a hash value that's a fixed length (typically 16 or 20 bytes). Given just a hash value, there's no way to get back to the original data. Hashing data is the basis of digital signatures. The hashing functions <BR>in the Crypto API are where things like passwords come into play.</P>
<P>Digital signatures let you provide assurance that your data wasn't altered before it reached the recipient. To sign something, you hash your data (for instance, an email message), and then attach the hash value to the data. The hash value is known as a message digest in the Crypto API. To verify that the message wasn't altered, the recipient can rehash the message and compare it to the message digest that was sent along with the data. How does the recipient know that the original data wasn't replaced by different data and a corresponding message digest? Public key encryption is applied to the message digest before it's sent. That is, the message digest is encrypted so the recipient can verify that the digest came from you. If the digest is known to be good, it can be assumed to be trustworthy for rehashing the message and verifying its source.</P>
<P> </P>
<H2><A NAME="sec9"></A>  New Shell Features </H2><P>Something as heavily used and complex as a user interface is always subject to changes and extensions, and Windows NT 4.0 is no exception. <B>Figure 2</B> shows the new Windows NT 4.0 shell interfaces defined in SHLOBJ.H. </P>
<P><B> Figure 2  New Windows NT 4.0 Shell Interfaces</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="221pt" VALIGN="TOP"><COL WIDTH="221pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> IExtractIconA/W </P></TD><TD VALIGN="TOP"><P>ICommDlgBrowser</P></TD></TR><TR><TD VALIGN="TOP"><P> IShellLinkA/W </P></TD><TD VALIGN="TOP"><P>IContextMenu2</P></TD></TR><TR><TD VALIGN="TOP"><P> ICopyHookA/W </P></TD><TD VALIGN="TOP"><P>IPersistFolder</P></TD></TR><TR><TD VALIGN="TOP"><P> IFileViewerA/W </P></TD><TD VALIGN="TOP"><P>IShellIcon</P></TD></TR><TR><TD VALIGN="TOP"><P> IShellView</P></TD><TD VALIGN="TOP"><P>IShellExecuteHookA/W </P></TD></TR><TR><TD VALIGN="TOP"><P> IShellView2 </P></TD><TD VALIGN="TOP"><P>INewShortcutHookA/W </P></TD></TR><TR><TD VALIGN="TOP"><P> IShellBrowser</P></TD><TD VALIGN="TOP"><P></P></TD></TR></TBODY></TABLE>
<P><BR></P><P>Some of the new interfaces in this list are just ANSI and Unicode versions of earlier shell interfaces. When the Windows 95 shell team defined the interfaces, they apparently defined only one interface that implicitly used ANSI strings. In Windows NT 4.0, this issue is cleaned up by separating the interfaces into ANSI and Unicode versions. For backwards compatibility, the ANSI versions use the same IIDs (interface IDs) as the original interfaces.</P>
<P>Among the new interfaces, the two most worth checking out are IShellBrowser and IShellView. You don't implement IShellBrowser yourself, it's implemented by Explorer and represents the outermost window of an Explorer window. (See David Campbell's article, "Extending the Windows Explorer With Name Space Extensions," in the July 1996 <I>MSJ.</I>) By implementing IShellView, you can create your own custom views in the Explorer. Your IShellView implementation calls out to IShellBrowser to have it perform actions such as setting up toolbars and adding menu items. By implementing an IShellView interface and a handful of other interfaces, you can create your own name spaces in Explorer and use Explorer to browse objects specific to your application. </P>
<P>Another new interface, IShellExecuteHook, appears to have been added to let the Start/Run dialog work with items defined in your name space. It's a safe bet that these new extensions to the shell are all part of integrating the Internet seamlessly into the Windows user interface.</P>
<P> </P>
<H2><A NAME="sec10"></A>  A Richer RichEdit 2.0</H2><P>Windows NT 4.0 has two versions of the RichEdit control. There's RICHEDIT.DLL, as in Windows 95, but there's also a RICHED20.DLL, which implements RichEdit 2.0 windows. While the only documentation currently available for the RichEdit 2.0 specification is the header files, several nifty new features are discernible.</P>
<P>In the new RICHEDIT.H, the presence of window messages like EM_SETUNDOLIMIT and EM_REDO imply that RichEdit 2.0 windows have undo and redo support. Another set of window messages, EM_SETLANGOPTIONS and EM_GETLANGOPTIONS, indicate that international issues like keyboard layouts and fonts will be customizable. Also worth noting is that there's a new window class name for RichEdit controls, RichEdit20A. If you want these new features in your existing RichEdit-enabled code, you'll have to go back and modify the class names where you've specified a RichEdit window.</P>
<P> </P>
<H2><A NAME="sec11"></A>  New OLE Features</H2><P>Any discussion of OLE in Windows NT 4.0 has to start with DCOM. The new COM/OLE functionality falls into four categories. First are extensions required to use objects on remote machines. Second are new functions and APIs relating to security. (Once you get machines communicating data back and forth, security becomes a much bigger issue than on a single machine.) Third, OLE now supports free threading; any object can be serviced by any thread, as opposed to the slower (but easier to program) apartment model. The last new category is property storage and property sets.</P>
<P>Any OLE program needs to call CoInitialize or OleInitialize to set up the OLE system before it can be used. In Windows NT 4.0, a new function, CoInitializeEx, gives the programmer more flexibility over how OLE will work. These new flags can be passed to CoInitializeEx: </P>
<P> </P>
<P><BR></P>
<PRE> typedef enum tagCOINIT
{
COINIT_MULTITHREADED   = 0x0,     // OLE calls objects
                                  // on any thread.
COINIT_APARTMENTTHREADED = 0x2,   // Apartment model
COINIT_DISABLE_OLE1DDE  = 0x4,    // Don't use DDE for
                                  // Ole1 support.
COINIT_SPEED_OVER_MEMORY = 0x8,   // Trade memory for
                                  // speed. 
} COINIT;</PRE>
<P> </P>
<P>Note the flag that specifies apartment model threading instead of free threading. One way to instantiate a new instance of a class is to get a class factory interface pointer by calling CoGetClassObject, then invoke QueryInterface on the class factory. The second parameter to CoGetClassObject, dwClsCtx, indicates whether the object needs to be in-process or can be in another process. To support DCOM, Windows NT 4.0 accepts a new flag for this parameter, CLSCTX_REMOTE_SERVER. If other CLSCTX flags are specified in this parameter, OLE will try to use the least expensive method available because COM calls over a network will almost always be slower than in-process local server calls.</P>
<P>A more direct way to create a new class instance is to use CoCreateInstance. One performance problem with OLE is that you often need to obtain multiple interface pointers and this can take time, especially if the object is in another process or on another machine. To remedy this problem, Windows NT 4.0 has the CoCreateInstanceEx function, which has two advantages over its CoCreateInstance predecessor. First, it lets you fill an array with pointers to interface IIDs. CoCreateInstanceEx then calls ::QueryInterface for each of the IIDs passed to it. This lets you get multiple interface pointers with a single call. The other new capability in CoCreateInstanceEx is that you can specify a source location for instantiating the new object (for instance, on a specific machine on a network).</P>
<P>Regarding the new security features in OLE, the first new function you'll come to is CoInitializeSecurity. As its name implies, this function initializes the security layer. Its primary parameters are two Access Control Lists (ACLs). The ACLs define who is allowed to use OLE services in the process that called CoInitializeSecurity, and who is denied from using OLE services.</P>
<P>Beyond initialization, OLE security has both client and server object support. On the client side is a new interface, IClientSecurity. The IClientSecurity::QueryBlanket method allows the client to obtain information that authenticates the server. A regular API function, CoQueryProxyBlanket, serves the same purpose. Another interface method, IClientSecurity::SetBlanket, lets the client specify how the server object will be authenticated. This method is functionally similar to the new CoSetProxyBlanket function.</P>
<P>On the server side of OLE security is a new interface, IServerSecurity. The QueryBlanket method lets the server object identify the client that invoked it. This method corresponds to the new CoQueryClientBlanket API. The IServerSecurity interface has the ImpersonateClient method, which makes the server object execute with the same privilege level as the calling client. After the server object impersonates the client, it returns to its normal security parameters via the RevertToSelf method. Both of these methods have regular API equivalents, CoImpersonateClient and CoRevertToSelf.</P>
<P> </P>
<H2><A NAME="sec12"></A>  Native Winsock 2.0 Support </H2><P>In the area of networking, Windows NT 4.0 will be the first operating system with native support of the Winsock 2.0 specification. I'll be honest and confess that I've done only minimal work with sockets. I'm pretty confident that if you're using Winsock now, you're already much more aware of all the things that Winsock 2.0 offers than I could hope to be. However, I'm duty bound to at least mention at a cursory level what's new.</P>
<P>The primary additions to the Winsock 2.0 specification are access to protocols other than TCP/IP, overlapped I/O, and the ability to query and request specific qualities of service. In the sockets sense, quality of service refers to things such as how quickly data can be piped over a connection and how long you may have to wait for data to flow (latency).</P>
<P>In the new system header files, WINSOCK.H remains for backwards compatibility. A new header file, WINSOCK2.H, has been added as a superset of WINSOCK.H. In addition, you'll need to switch to the WS2_32.LIB import library to use the Winsock 2.0 functions. This import library corresponds to WS2_32.DLL, which is the system DLL that implements Winsock 2.0.</P>
<P>Since WS2_32.DLL provides a superset of the functions in WSOCK32.DLL, you might think that WS2_32.DLL contains just the new Winsock 2.0 functions and passes along 1.<I>x</I> functions to WSOCK32.DLL. Just the opposite is true; through the magic of forwarders, many of the functions in WSOCK32.DLL are really implemented in WS2_32.DLL. Forwarders are a barely documented features of Portable Executable files. When exporting a function from a DLL, it's possible to indicate to the Win32 loader that the function's code really resides in some other DLL. Unfortunately, the linker switches for forwarding aren't described anywhere. I am investigating forwarding and may do a future <I>MSJ </I>column on this subject. In any event, <B>Figure 3</B> shows the Winsock 1.<I>x</I> functions that are forwarded to other DLLs in Windows NT 4.0.</P>
<P><B> Figure 3  WSOCK32.DLL Forwarded Routines</B></P>
<P><B>Forwarded to WS2_32.DLL</B></P>
<P>accept <BR>bind <BR>closesocket <BR>getpeername <BR>getsockname <BR>htonl <BR>htons<BR>ioctlsocket <BR>listen <BR>ntohl <BR>ntohs <BR>recv <BR>recvfrom <BR>select <BR>send <BR>sendto <BR>shutdown <BR>WSAAsyncSelect <BR>WSAGetLastError <BR>WSASetLastError <BR>__WSAFDIsSet </P>
<P><B>Forwarded to MSWSOCK32.DLL</B></P>
<P>TransmitFile<BR>AcceptEx<BR>GetAcceptExSockaddrs </P>
<P> Notice that the Microsoft extensions to Winsock have been moved out into their own separate DLL. In prior Win32 implementations, the three Microsoft-specific functions were part of WSOCK32.DLL. In Windows NT 4.0, a new DLL named MSWSOCK32.DLL implements these functions and WINSOCK.DLL contains forwarders to these routines.</P>
<H2><A NAME="sec13"></A>  Internet Support</H2><P>There's currently a lot of interest in integrating the Internet into apps and operations systems, and Windows NT 4.0 is certainly on the cutting edge. All of the ActiveXª functionality that was the topic of the Microsoft Internet Professional Developer's Conference in San Francisco can be found in Windows NT 4.0.</P>
<P>A large part of Microsoft's Internet support on the client side is in a DLL called WININET.DLL. This DLL supports the HTTP, FTP, and Gopher protocols, and makes it fairly easy to write Internet client applications without knowing anything about TCP/IP, Winsock, and so on. If you're curious, WinInet is built on the Winsock functions, which I mentioned earlier.</P>
<P>The WinInet functions divide up nicely into four categories: general purpose functions that apply to all protocols, HTTP, FTP, and Gopher functions (see <B>Figure 4</B>). For a more in-depth description, see Jeffrey Richter's article, "Microsoft's Internet Extensions for Win32" in the Spring 1996 <I>Microsoft Interactive Developer</I>.</P>
<P><B> Figure 4  WinInet Functions</B></P>
<P><B>General-purpose WinInet Functions</B></P>
<P>InternetOpen <BR>InternetConnect<BR>InternetOpenUrl <BR>InternetReadFile<BR>InternetCloseHandle<BR>InternetSetStatusCallback <BR>InternetQueryOption <BR>InternetSetOption <BR>InternetFindNextFile (FTP and Gopher) </P>
<P><B>WinInet HTTP Functions </B></P>
<P>HttpOpenRequest <BR>HttpAddRequestHeaders <BR>HttpSendRequest <BR>HttpQueryInfo </P>
<P><B>WinInet FTP Functions </B></P>
<P>FtpFindFirstFile <BR>FtpGetFile <BR>FtpPutFile <BR>FtpDeleteFile <BR>FtpRenameFile <BR>FtpOpenFile <BR>InternetWriteFile <BR>FtpCreateDirectory<BR>FtpRemoveDirectory <BR>FtpSetCurrentDirectory <BR>FtpGetCurrentDirectory <BR>FtpCommand <BR>InternetGetLastResponseInfo </P>
<P><B>WinInet Gopher Functions </B></P>
<P>GopherFindFirstFile<BR>GopherOpenFile <BR>GopherCreateLocator <BR>GopherGetAttribute </P>
<P>Most of the WinInet functions work with or return HINTERNETs (handles to Internet). While your code sees all HINTERNETs as the same type, one HINTERNET can mean something completely different from another. This makes the WinInet functions a bit confusing at first. The first type of HINTERNET that you obtain comes when you initialize WININET.DLL by calling InternetOpen. This is the first of 13 possible subtypes of HINTERNETs. <B>Figure 5</B> shows all 13 varieties of HINTERNETs. You can query the subtype of a particular handle by calling InternetQueryOption and sending it the HINTERNET with the INTERNET_OPTION_HANDLE_TYPE parameter.</P>
<P><B> Figure 5  HINTERNET Subtypes</B></P>

<TABLE COLS="2" BORDER="0"><COLGROUP><COL WIDTH="261pt" VALIGN="TOP"><COL WIDTH="180pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_INTERNET</P></TD><TD VALIGN="TOP"><P>1</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_CONNECT_FTP</P></TD><TD VALIGN="TOP"><P>2</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_CONNECT_GOPHER</P></TD><TD VALIGN="TOP"><P>3</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_CONNECT_HTTP</P></TD><TD VALIGN="TOP"><P>4</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_FTP_FIND</P></TD><TD VALIGN="TOP"><P>5</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_FTP_FIND_HTML</P></TD><TD VALIGN="TOP"><P>6</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_FTP_FILE </P></TD><TD VALIGN="TOP"><P>7</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_FTP_FILE_HTML</P></TD><TD VALIGN="TOP"><P>8</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_GOPHER_FIND</P></TD><TD VALIGN="TOP"><P>9</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_GOPHER_FIND_HTML </P></TD><TD VALIGN="TOP"><P>10</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_GOPHER_FILE</P></TD><TD VALIGN="TOP"><P>11</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_GOPHER_FILE_HTML</P></TD><TD VALIGN="TOP"><P>12</P></TD></TR><TR><TD VALIGN="TOP"><P> INTERNET_HANDLE_TYPE_HTTP_REQUEST</P></TD><TD VALIGN="TOP"><P>13</P></TD></TR></TBODY></TABLE>
<P><BR></P><P></P>
<P>After setting up WININET.DLL, the initial HINTERNET is usually passed to InternetConnect, which takes a parameter that indicates the type of connecting server (HTTP, FTP, or Gopher). InternetConnect returns another subtype of HINTERNET, which is then passed to the appropriate HTTP, FTP, or Gopher functions. An alternative to calling InternetConnect is to call InternetOpenUrl. This function parses the URL passed to it and connects to the appropriate type of server automatically.</P>
<P>After connecting to the desired server, you turn to the protocol-specific functions, which I'll describe momentarily. Regardless of what you connect to or how you connect to it, you'll probably want to read data from the server. The InternetReadFile function works with HINTERNETs for any of the three supported protocols. Before exiting the program, all of the HINTERNETs should be closed by calling InternetCloseHandle.</P>
<P>A nice feature of the WinInet functions is that they can be set up to act synchronously or asynchronously. The default is synchronous operation; when you call a WinInet function, your thread blocks until the function succeeds or fails. To get asynchronous operation, call InternetSetStatusCallback. A callback function will be installed, and you'll be kept informed of the status of your request. More importantly, the original WinInet call won't block until the operation completes.</P>
<P>There are just a few HTTP functions in WinInet. You open an HTTP request (which returns yet another type of HINTERNET), add any HTTP style headers, then call HttpSendRequest. The InternetReadFile function retrieves the data from the request. Remember, the HTTP request will probably return raw HTML. It's up to you to parse it as appropriate for your application.</P>
<P>Of all the protocols supported by WinInet, FTP is the lowest level, so there are quite a few FTP functions. All of the basics of interacting with an FTP server are provided, including commands to read, write, rename, delete, and enumerate files. You can also create and delete directories and change the current working directory. In short, WinInet has just about everything you'd need to write your own version of the venerable FTP program.</P>
<P>Finally, there are the WinInet Gopher functions. GopherFindFirstFile and InternetFindNextFile enumerate through the available files. To retrieve a file, you open it with GopherOpenFile (which returns yet another type of HINTERNET), and pass that HINTERNET to InternetReadFile.</P>
<P> </P>
<H2><A NAME="sec14"></A>  The Licensing API</H2><P>A new set of functions in Windows NT 4.0 that hasn't garnered much attention (at least not yet) is the License Service API (LSAPI), which was developed by Microsoft in cooperation with other companies. The seven LSAPI functions provide basic software-metering capabilities. For example, let's say you wanted to sell a site license for 50 copies of your product to some other company. The LSAPI functions would let your program ensure that no more than 50 instances run at a single time. An LSAPI-enabled application differs from other applications that use licensing in that it's not tied to a single proprietary license server. Your application can work with any license server that supports LSAPI.</P>
<P>The functions in the LSAPI are located in LSAPI.DLL. These are LSEnumProviders, LSFreeHandle, LSGetMessage, LSQuery, LSRelease, LSRequest, and LSUpdate. To use LSAPI functions, include LSAPI.H in your code and link to the LSAPI32.LIB import library.</P>
<P>LSEnumProviders lets you enumerate through all installed LSAPI servers and returns a unique string for each server. Once you've found a suitable server, you pass that string (along with a boatload of other parameters) to LSRequest. Alternatively, you can let LSRequest try to find a license server for you. Either way, LSRequest will either return an LS_HANDLE, meaning your application can continue executing, or failure. If LSRequest fails, error codes tell you why. When your application is finished, it calls LSRelease to indicate that it's done.</P>
<P>Of course, a determined hacker can bypass something as simple as I've described above. Thus, LSAPI supports multiple "challenge" protocols to determine if your code has been tampered with. There's even an interesting section in the LSAPI documentation that describes steps your code should take to ensure that it's not being hacked. Not surprisingly, these steps are applicable to many scenarios (such as game passwords), not just application licensing.</P>
<P> </P>
<H2><A NAME="sec15"></A>  IMAGEHLP</H2><P>A new feature in Windows NT 4.0 that I'm particularly happy with is the addition of IMAGEHLP.DLL to the base operating system. IMAGEHLP isn't really a new DLL. Rather, it used to be buried in the Win32 SDK. However, it was an integral part of tools like REBASE and BIND, and the SDK even included the source for the Windows NT 3.51 version. In Windows NT 4.0, IMAGEHLP has been shined up and extended quite a bit. Unfortunately, newer Win32 SDKs no longer include source for IMAGEHLP.DLL.</P>
<P>The "image" part of IMAGEHLP comes from the fact that EXEs and DLLs are called images by the handful of people who actually work on their inner guts. The fundamental purpose of IMAGEHLP is to remove some of this complexity from working with EXEs and DLLs to provide a library of commonly used functions for low-level hackers (like yours truly).</P>
<P>The real reason for including IMAGEHLP.DLL in the base operating system is the new image integrity functions. Other IMAGEHLP functions let you modify images, extract useful nuggets of information from images, access debug information, and perform debugger-like tasks such as walking a call stack. <B>Figure 6</B> shows the IMAGEHLP functions broken down by categories.</P>
<P><B> Figure 6  IMAGEHLP Functions</B></P>
<P><B>Image integrity functions </B></P>
<P>ImageGetDigestStream <BR>ImageAddCertificate <BR>ImageRemoveCertificate <BR>ImageEnumerateCertificates <BR>ImageGetCertificateData <BR>ImageGetCertificateHeader</P>
<P><B>Image modification functions </B></P>
<P>BindImage <BR>BindImageEx <BR>CheckSumMappedFile <BR>MapFileAndCheckSum <BR>ReBaseImage <BR>RemovePrivateCvSymbolic <BR>RemoveRelocations <BR>SplitSymbols <BR>UpdateDebugInfoFile <BR>UpdateDebugInfoFileEx <BR>TouchFileTimes </P>
<P><B>Image access functions </B></P>
<P>ImageLoad <BR>ImageUnload <BR>ImageNtHeader <BR>ImageDirectoryEntryToData <BR>ImageRvaToSection <BR>ImageRvaToVa <BR>MapAndLoad <BR>GetImageConfigInformation <BR>GetImageUnusedHeaderBytes <BR>SetImageConfigInformation <BR>UnMapAndLoad <BR>FindExecutableImage <BR>GetTimestampForLoadedLibrary </P>
<P><B>Symbol table functions </B></P>
<P>SymSetOptions <BR>SymGetOptions <BR>SymCleanup <BR>SymEnumerateModules <BR>SymEnumerateSymbols <BR>EnumerateLoadedModules <BR>SymFunctionTableAccess <BR>SymGetModuleInfo <BR>SymGetModuleBase <BR>SymGetSymFromAddr <BR>SymGetSymFromName <BR>SymGetSymNext <BR>SymGetSymPrev <BR>SymInitialize <BR>SymGetSearchPath <BR>SymSetSearchPath <BR>SymLoadModule <BR>SymUnloadModule <BR>SymUnDName <BR>SymRegisterCallback </P>
<P><B>Debugger helper functions</B></P>
<P>StackWalk <BR>FindDebugInfoFile<BR>FindExecutableImage<BR>MapDebugInformation<BR>UnmapDebugInformation<BR>UnDecorateSymbolName</P>
<P><B>Miscellaneous functions </B></P>
<P>ImagehlpApiVersion <BR>ImagehlpApiVersionEx <BR>SearchTreeForFile <BR>MakeSureDirectoryPathExists </P>
<P>The image integrity functions in IMAGEHLP work with what's known as a certificate. A certificate is a relatively small blob of bytes created by processing all of the data in a file to effectively create a multiple-byte checksum. Certificates put a personal imprint on a file (as in digital signatures). Applications can use the certificate data to verify that an executable file came from the correct source and that it hasn't been modified. The image integrity functions provided by IMAGEHLP are for working with the WIN_CERTIFICATE structure, a security related structure also used by the WinSubmitCertificate function.</P>
<P>The important IMAGEHLP image modification functions center around basing and binding of images. Basing an image sets its preferred load address; if the loader is able to load the file at that address, it doesn't have to do any base fixups. Binding an image effectively does the work that the Win32 loader does at load time to look up the address of each imported function. Like basing an image properly, binding it causes less work for the Win32 loader at load time, so the EXE or DLL loads faster. A top-notch install program would base and bind the EXEs and DLLs it installs. If you look closely (using any file dumper), all of the images that ship with Windows NT are based and bound. There are also functions to strip off symbol table information and compute image checksums, both things that the typical programmer doesn't need to worry about. </P>
<P>The image access functions in IMAGEHLP primarily give access to information in files without having them loaded into memory by the Win32 loader. For example, the ImageLoad function will map the specified file into memory and return a pointer to a structure containing informational flags, how much memory the image would take if loaded by the Win32 loader, and so on. Once the file is mapped into memory by ImageLoad, functions like ImageNtHeader and ImageDirectoryEntryToData provide even more information about the image. These functions are primarily intended for use by developers of programming tools such as debuggers and file dumpers. </P>
<P>The IMAGEHLP symbol table functions will be meaningless to nearly everybody except debugger writers. Of course, anybody who has to deal with symbol tables will be overjoyed that there's one set of routines to access symbol names. In theory, these routines will be kept up to date as Microsoft evolves and changes their debug formats. Currently, CodeView¨ (also known as PDB) and COFF formats are supported. </P>
<P>One of the symbol-table functions that's useful to a wider audience is StackWalk. As it name implies, this routine walks the stack of the specified thread. One scenario where this could be useful is if you installed a try/catch handler within your WinMain function to catch all program faults yourself, rather than letting the operating system throw up its ugly fault dialog box. </P>
<P>Another function that you may find useful is UnDecorateSymbolName. All you C++ programmers have no doubt seen those horribly long decorated functions names (such as "?bar@foo@@AAEXH@Z") that look like complete garbage. UnDecorateSymbolName turns those symbols into something readable by mere mortals. </P>
<P> </P>
<H2><A NAME="sec16"></A>  Process And Thread Information </H2><P>Although there were hints of it in the Windows NT 3.5 SDK, PSAPI.DLL has been relatively unknown until now. PSAPI.DLL is a convenient way to get system information such as process lists without reading in and parsing the Windows NT performance data in all of its convoluted glory. From PSAPI.DLL you can get a list of processes and list every module within the process. PSAPI.DLL also has functions for enumerating running device drivers. Finally, PSAPI.DLL has functions for learning about the working set of a process by querying demand load page faults. For moreinformationon PSAPI.DLL, see this month's "Under the Hood" column. </P>
<P> </P>
<H2><A NAME="sec17"></A>  New SDK Tools</H2><P>With the tour of new functions, interfaces, and DLLs out of the way, I'll finish up with a quick overview of some new tools from the Win32 SDK. Some of these will no doubt end up in some future version of Visual C++¨. The first thing you'll notice is that there are quite a few new programs in the BIN directory of the SDK. A good number of them are programs from the TAPI and MAPI SDKs that have finally been bundled into the Win32 SDK, so I won't mention them further.</P>
<P>If you're curious what exported functions a program calls, the APIMON program could be just what you're looking for. For a given run of a program, APIMON shows which functions were called, how many times they were called, and how much time was spent in the function. For instance, running CLOCK.EXE briefly showed that it called GetDC 28 times, and spent a total of 1.092 seconds in the GetDC code. It optionally shows each API call and the first four parameters on the stack. APIMON is flexible in letting you decide what modules to monitor calls from. APIMON works on any Win32 EXE, and doesn't require any modifications to the program to monitor it. </P>
<P>The WPERF program is a companion to PERFMON. It displays information such the number of page faults per second or the current thread count, but provides a smaller selection of system metrics. However, each statistic WPERF displays gets its own separate chart area, rather than showing all the charts in the same window like PERFMON does. Also, WPERF gets its data directly out of NTDLL.DLL, rather than querying the registry performance data. </P>
<P>The MEMSNAP program provides a convenient way to do before-and-after comparisons of process resources. Each time you run MEMSNAP, it writes out a log file with columns of statistics about each running process. For each process you get the process name, process ID, paged and nonpaged pool sizes, amount of memory reserved in the pagefile, and total committed bytes. In addition, MEMSNAP reports the number of handles and threads each process is using. By comparing MEMSNAP snapshots, you can tell if a particular process is leaking memory or other resources.</P>
<P>UCONVERT is a new tool for converting files from ANSI, OEM, or other code pages into Unicode. The program has a rudimentary dialog-based user interface where you specify the source file and any conversion options. UCONVERT can also accept text from the clipboard and emit its converted text back to the clipboard.</P>
<P>Without any documentation, it's hard to say exactly what WINOBJ is, but it's way cool, regardless. I think it's a browser for Windows NT's objects. If you've read Helen Custer's <I>Inside Windows NT </I>(Microsoft Press 1993), you'll recognize most of them as Windows NT Executive objects. The two exceptions are the desktop and WindowStation objects, which are Win32 objects. WINOBJ shows the objects in a hierarchy using TreeView controls (see <B>Figure 7</B>). For certain types of object instances (such as SymbolicLinks), you can double click to get details for the specific object.</P>
<P><img src="poke7.gif"></P>
<P><B> Figure 7  WINOBJ</B></P>
<P>The last cool tool isn't even an SDK program, it's the Windows NT task manager, which is the first task manager in Windows worthy of the name. You start TASKMGR.EXE either by the Ctrl-Alt-Delete sequence or by right clicking on the system tray. TASKMGR is a three-tabbed dialog. The first tab, Applications, is the traditional "Top Level Windows only" view of the system that you've come to know and hate. The middle tab, Processes, is much more interesting (see <B>Figure 8</B>). It's a true process list, and it includes useful statistics such as memory usage for each process. The third tab, Performance, provides charts and statistical information on CPU and memory usage, the number of processes, threads, and handles, and other assorted information. Whenever it's running, TASKMGR puts a small CPU usage bar chart in the icon area of the tray.</P>
<P><img src="poke8.gif"></P>
<P><B> Figure 8  Task Manager Process List</B></P>
<P> </P>
<H2><A NAME="sec18"></A>  Summary</H2><P>Calling Windows NT 4.0 the Shell Update Release just doesn't do it justice. While the new shell is nice (especially if you've been working with Windows 95), improvements that aren't immediately visible should make Windows NT 4.0 a mass-market operating system. Microsoft has addressed several areas that were problems in the past: the performance of the GUI and hardware compatibility. It's also nice to see that with Windows NT 4.0 you'll get the long awaited DCOM and Internet extensions. In addition, the Windows NT 4.0 team wasn't content to focus solely on new APIs. New functions like CopyFileEx prove that they're still tuning and tweaking even the most basic areas of the operating system. Finally, as a tool developer, I'm especially happy to see DLLs like IMAGEHLP and PSAPI become part of the base operating system. My opinion on Windows NT 4.0 is summed up by a single fact: I haven't booted any other operating system since I've installed it. </P>
<H2><A NAME="sec19"></A>  HOW'D THEY SPEED IT UP LIKE THAT?</H2><P>If you're a fan of Windows NT, you've probably heard that Windows NT 4.0 is faster than previous versions (and Windows NT 3.51 was pretty well tuned). If you're really an operating system nut (like me), you've probably also heard that USER and GDI have been moved into the kernel. While the USER and GDI components work differently in Windows NT 4.0, this is an overly simplified description. Although what I'll describe here won't directly affect most programmers, it's interesting to see what's really going on. </P>
<P>Page 124 of Helen Custer's <I>Inside Windows NT</I> describes how USER and GDI were implemented in Windows NT 3.1 (and subsequently in Windows NT 3.5 and 3.51). What we think of as USER and GDI in Windows NT is really a protected subsystem. "Each protected subsystem runs in a process with a private address space. For an application to gain access to a subsystem, it must send a message. The server receives the message, validates all parameters, executes the required functions, and returns the results to the caller."</P>
<P>Custer then goes on to describe some performance concerns with this approach, and has this to say: "For the server to get the message and execute it, a context switch must occur—that is, the Windows NT executive must perform the following sequence: </P>
<OL><LI> Save the client thread's context (volatile machine state).</LI><LI>Select a server thread for execution and load the server thread's context.</LI><LI>Execute the Win32 API routine using the server's thread.</LI><LI>Save the server thread's context.</LI><LI>Reload the client thread's context and process the results of the API routine."</LI></OL><P>As you might imagine, these operations in real life can be on the order of thousands of clock cycles for a single call to the Win32 subsystem (USER and GDI). If you've ever seen the program CSRSS.EXE and wondered what it was, there's your answer: it's the EXE that the Win32 subsystem process is created from.</P>
<P>At this point, it's helpful to dig into some details. Note that I'm using Intel-specific terminology in the following discussion. For example, when I say Ring 0, I mean "kernel mode" as defined by Windows NT. Let's see how a KERNEL32 call such as PulseEvent works without using any client-server calls. In KERNEL32.DLL, the code for PulseEvent begins like this:</P>
<P> </P>
<P><BR></P>
<PRE> PulseEvent proc
PUSH    00
PUSH    DWORD PTR [ESP+08]
CALL    DWORD PTR [NtPulseEvent]</PRE>
<P> </P>
<P>All KERNEL32.DLL does is grab the single parameter off the stack and pass it as a parameter to an NTDLL.DLL function. In NTDLL.DLL, the code for NtPulseEvent looks like this:</P>
<P> </P>
<P><BR></P>
<PRE> NtPulseEvent proc
MOV     EAX,0000005C
LEA     EDX,[ESP+04]
INT     2E
RET     0008</PRE>
<P> </P>
<P>All that NTDLL.DLL does is load EAX with a dispatch number (0x5C in this case) and EDX with a pointer to the parameters on the stack, then invoke an INT 2Eh. Keep in mind that everything I've described so far happened at Ring 3. On Intel 80<I>x</I>86 processors, any INT instruction causes the CPU to transition to Ring 0 before jumping to the address corresponding to the interrupt number in the Interrupt Descriptor Table (IDT). It's also worth noting here that in the transition from Ring 3 to Ring 0, the CPU also switches the stack to whatever Ring 0 stack is specified in the TSS.</P>
<P>Now, let's take a look at Ring 0, or kernel mode. At Ring 0, the INT 2Eh handler is called _KiSystemService, which is located in NTOSKRNL.EXE. _KiSystemService takes the dispatch number (placed in EAX by NTDLL.DLL) and uses it as an index into a dispatch table that each thread has a pointer to. Just before jumping to the designated handling code, _KiSystemService copies the parameters from the Ring 3 stack (which EDX points to) onto the Ring 0 stack. Altogether, this takes about 60 instructions to accomplish, which is significantly less than the overhead imposed by the two thread context switches that USER and GDI go through with the Win32 subsystem process.</P>
<P>In Windows NT 4.0, the mechanism for getting from Ring 3 to Ring 0 for NTDLL.DLL functions was extended to include USER and GDI functions. Windows NT 4.0 essentially dispenses with the original vision for a client-server architecture in exchange for increased performance.</P>
<P>The new method for USER and GDI to transition to Ring 0 is nearly identical to what NTDLL.DLL does. That is, the code sets up EAX and EDX appropriately before invoking an INT 2Eh. The only difference is that the bit value 0x00001000 is set in the dispatch code for USER and GDI functions. Put another way, dispatch codes less than 0x1000 come from Ring 3 kernel-type code like that  provided by NTDLL.DLL. Dispatch codes greater than 0x1000 are for the Win32 subsystem (USER and GDI). </P>
<P>Consider the following GDI32.DLL implementation of GetTextCharsetInfo in Windows NT 4.0:</P>
<P> </P>
<P><BR></P>
<PRE> GetTextCharsetInfo proc
MOV       EAX,0000106E
LEA       EDX,[ESP+04]
INT       2E
RET       000C</PRE>
<P> </P>
<P>Inside _KiSystemService, the code checks the 0x00001000 bit in the dispatch code and uses it to select one of two dispatch tables. Dispatch codes less than 0x1000 are handled by a table that routes nearly everything to code elsewhere in NTOSKRNL.EXE. Dispatch codes greater than 0x1000 use a table that sends nearly everything to routines in WIN32K.SYS.</P>
<P>What's WIN32K.SYS? In Windows NT 4.0, it's the Ring 0 device driver implementation of the Win32 subsystem. In some ways, WIN32K.SYS is the replacement for WINSRV.DLL, which was the core of the Win32 subsystem in Windows NT 3.<I>x</I>. A quick glance at the file sizes bears this out. The Windows NT 3.51 version of WINSRV.DLL is nearly 1.4MB, while in Windows NT 4.0 beta 2 it's shrunk down to around 160KB. In its place is WIN32K.SYS, which weighs in at over 1.2MB. The key difference is that WINSRV.DLL ran at Ring 3, while WIN32K.SYS runs at Ring 0. By running at Ring 0, the Win32 subsystem can avoid the overhead of thread context switches.</P>
<P>One side effect of moving the Win32 subsystem to kernel mode (Ring 0) may not be obvious immediately. GDI calls are now implemented at Ring 0, and GDI communicates to your output devices (for example, the display and printers) through device drivers. If you guessed that graphics drivers need to be ported to kernel mode code, your guess is correct.</P>
<P>To test the new Win32 subsystem architecture, I wrote the SETCURS program (see <B>Figure A</B>). SETCURS calls the SetCursor function 5000 times in a loop and uses the QueryPerformanceCounter to time it. I selected SetCursor because under Windows NT 4.0 the function almost immediately invokes an INT 2Eh. Under Windows NT 3.51, SetCursor takes a much longer code path involving thread switching to the Win32 subsystem. In an informal test, I found that Windows NT 4.0 beta 1 was about three times as fast as Windows NT 3.51. It's unlikely that the internals of the SetCursor function changed much between 3.51 and 4.0, so the speed-up is almost certainly due to implementing SetCursor in kernel mode, thereby avoiding thread switches.</P>
<P><B> Figure A  SETCURS.CPP</B></P>
<P><BR></P>
<PRE> //======================================================
// SETCURS.EXE - Matt Pietrek 1996
// Microsoft Systems Journal, August 1996
// FILE: SETCURS.CPP
// To compile: CL SETCURS.CPP USER32.LIB
//======================================================
#define WIN32_LEAN_AND_MEAN
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define ITERATIONS 5000

int PASCAL WinMain( HANDLE hInstance, HANDLE hPrevInstance,
                    PSTR lpszCmdLine, int nCmdShow )
{
    HCURSOR hCursor;
    
    hCursor = GetCursor();

    // Bump up the thread's priority temporarily so that we don't get
    // randomly interrupted.
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_TIME_CRITICAL );

    // We're going to cheat here, and use the support of 64 bit integers.
    // With some typecasting, we can fool the compiler into believe that
    // they're really LARGE_INTEGER structs.
    unsigned __int64 beginTime64, endTime64, ticksPerSecond;

    // Get the initial tick count
    QueryPerformanceCounter( (LARGE_INTEGER *)&amp;beginTime64 );

    // The purpose of this program...
    for ( unsigned i = 0; i &lt; ITERATIONS; i++ )
    {
        SetCursor( hCursor );
    }

    // Get the final tick count
    QueryPerformanceCounter( (LARGE_INTEGER *)&amp;endTime64 );
    
    // Be a good Win32 citizen and put the priority back.
    SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL );

    DWORD ticks = (DWORD)(endTime64 - beginTime64) ;

    // Find out how many ticks occur per second
    QueryPerformanceFrequency( (LARGE_INTEGER *)&amp;ticksPerSecond );
    
    char szOutText[128];

    // Spit out how many calls would be made in one second
    wsprintf( szOutText, "%u calls/sec\n",
              (DWORD)((ticksPerSecond / ticks) * ITERATIONS) );

    MessageBox( 0, szOutText, "SETCURS", MB_OK );
        
    return 0;</PRE>
<P></P>
<P>Some people have raised concerns about stability and the shifting of the Win32 subsystem into Ring 0 kernel code. Yes, a buggy video driver that overwrites other kernel data structures can crash the system. On the other hand, a buggy video driver would kill the Win32 subsystem process in prior versions of Windows NT, so the net effect is the same. Regardless of the architecture, robust video and printer drivers are essential.</P>
<P>As for buggy applications overwriting USER or GDI data, there's no need to worry. All of the Ring 0 code executes out of reach of normal application code and uses a different stack. Besides, if it's been good enough for NTDLL.DLL for all these years, it's good enough for USER and GDI code. </P>
<H2><A NAME="sec20"></A>  USING FIBERS</H2><P>Since fibers aren't exactly intuitive when you first encounter them, I wrote a small sample application, FIBER (see <B>Figure B</B>). Within main(), the code creates three fibers by calling CreateFiber. Each fiber is created with the same start address, specifically the FiberRoutine function. As each fiber is created, the code store the fiber's address into a global variable.</P>
<P><B> Figure B  FIBER.CPP</B></P>
<P><BR></P>
<PRE> //======================================================
// FIBER.EXE - Matt Pietrek 1996
// Microsoft Systems Journal, August 1996
// FILE: FIBER.CPP
// To compile: CL FIBER.CPP (must have NT 4.0 Win32 SDK)
//======================================================
#define WIN32_LEAN_AND_MEAN
#define _WIN32_WINNT 0x0400
#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

LPVOID lpFiber1;        // Addresses of each fiber that's created
LPVOID lpFiber2;
LPVOID lpFiber3;
LPVOID lpFiberMain;

void WINAPI FiberRoutine( LPVOID param )
{
    printf( "In fiber %u\n", param ); // Tell the world who we are
    
    if ( 1 == (DWORD)param )
        SwitchToFiber( lpFiber2 );      // fiber1 -&gt; fiber2
    else if ( 2 == (DWORD)param )
        SwitchToFiber( lpFiber3 );      // fiber2 -&gt; fiber3
    else if ( 3 == (DWORD)param )
        SwitchToFiber( lpFiberMain );   // fiber3-&gt;main fiber (original
                                        // thread)
}

int main()
{
    // Create 3 fibers, with starting addresses of the above routine
    lpFiber1 = CreateFiber( 16384, FiberRoutine, (PVOID)1 );
    lpFiber2 = CreateFiber( 16384, FiberRoutine, (PVOID)2 );
    lpFiber3 = CreateFiber( 16384, FiberRoutine, (PVOID)3 );

    if ( !lpFiber1 || !lpFiber2 || !lpFiber3 )  // Make sure the fibers were
        return 0;                               // created
    
    // Make this thread a fiber, so that it can force the other fibers to run
    lpFiberMain = ConvertThreadToFiber( 0 );

    // Sleep for 1 second, just to prove that the other
    printf( "Sleeping for 1 second\n" );
    Sleep( 1000 );
    
    printf( "Switching to first fiber\n" );
    SwitchToFiber( lpFiber1 );                  // Switch to fiber1
    printf( "Returning from SwitchToFiber\n" );

    DeleteFiber( lpFiber1 );    // Clean up the 3 fibers we created earlier
    DeleteFiber( lpFiber2 );
    DeleteFiber( lpFiber3 );
        
    return 0;
}</PRE>
<P>At this point, FIBER.CPP has its original thread and three fibers. To make any of the fibers execute, main() calls ConvertThreadToFiber, thereby making a fourth fiber. Just to prove that fibers can't be run without direct intervention, the original thread sleeps for one second. The idea is that none of the three created fibers executes during this time period. After the Sleep function returns, the fiber created using the ConvertThreadToFiber is still running and will continue to run until it calls SwitchToFiber to let some other fiber execute. The fiber that main() selects is the first fiber it created (Fiber1). Fiber1 begins execution at the beginning of FiberRoutine and emits a message indicating which fiber it is.</P>
<P>After displaying its "In Fiber <I>n</I>" message, Fiber1 calls SwitchToFiber. This suspends Fiber1 and executes Fiber2. Since Fiber2's start address is also at the beginning of the FiberRoutine code, it prints out a similar message. This process repeats when Fiber2 switches to Fiber3.</P>
<P>The last thing Fiber3 does is call SwitchToFiber, specifying the address of the fiber created from the original thread. This causes execution to resume in main() where the first SwitchToFiber call occurred. main() cleans up by calling DeleteFiber on the three fibers it created and exits. <B>Figure C</B> shows the end results of a run of FIBER.EXE.</P>
<P><img src="pokec.gif"></P>
<P><B> Figure C  FIBER</B></P>
<H2><A NAME="sec21"></A>  VERSIONITIS, OR "WHAT VERSION AM I?"</H2><P>One of the problems inherent with having mostly compatible operating systems (Windows NT, Windows 95, and Win32s¨ under Windows 3.1) is in making a single program work on all platforms. In some cases, this involves determining which operating system you're running on and invoking code specific to that operating system. Sometimes the hardest part is just figuring out what system you're running on. As you might imagine, Windows NT 4.0 adds its own twist to the story.</P>
<P>Back when there was just Windows NT and Win32s, a program could call GetVersion and check the high bit (bit 31) of the returned version DWORD. If the bit was set, the system was Win32s, otherwise you were on Windows NT. When Windows 95 arrived on the scene, the value it returned from GetVersion also had the high bit set. To differentiate between Win32s and Windows 95, you had to look at the version number in the lower bits of the GetVersion return value. If it was 4.0 or greater, you could assume Windows 95, otherwise it was Win32s. I always thought this a bit cheesy, as version numbers are subject to change. In my September 1994 <I>MSJ</I> article, "Investigating the Hybrid Windowing and Messaging Architecture of Chicago," I pointed out that the second highest bit (bit 30) was set for Windows 95 and not for Win32s. All Microsoft documentation, however, suggested relying on the major version number field rather than on bit 30.</P>
<P>As you might imagine, many programmers got their version-checking code wrong and simply checked for the operating system major version number in the low WORD. Until Windows NT 4.0, these programs got away with it because the Windows NT major version number was 3. With Windows NT 4.0, though, both Windows 95 and Windows NT report the same major version number (4). Much to my surprise, the lead story in the March/April 1996 <I>Microsoft Developer Network News</I> suggested that bit 30 could be used to tell the difference between Windows 95 and Win32s. I guess what's old is new again.</P>
<P>Of course, the real solution to this versioning problem is the GetVersionEx function. It returns explicit bitfields that indicate which platform you're running on. The problem with GetVersionEx is that it's not available on Windows 3.<I>x</I> or in Windows NT 3.1. Thus, if you call it directly from within your code, your programs won't run on those platforms.</P>
<P>Another related problem is the expected Windows version number that the linker puts in EXEs and DLLs. Over time, the meaning of the major version number in Win32 has essentially come to indicate which version of the shell is running. That is, major version 3 means the old ProgMan user interface, while major version 4 is the new Explorer interface. Because the meaning of the version number was contorted beyond its originally intended meaning, strange idiosyncrasies popped up. For instance, Windows NT 3.51 is able to run Windows 95-based applications marked as requiring version 4.0, but it doesn't give these applications the new Windows 95 look. With the release of Windows NT 4.0, these issues should be behind us.</P>
<P><I>This article is reproduced from Microsoft Systems Journal. Copyright </I>©<I> 1995 by Miller Freeman, Inc. All rights are reserved. No part of this article may be reproduced in any fashion (except in brief quotations used in critical articles and reviews) without the prior consent of Miller Freeman.</I></P>
<P><I>To contact Miller Freeman regarding subscription information, call (800) 666-1084 in the U.S., or (303) 447-9330 in all other countries. For other inquiries, call (415) 358-9500.</I></P></font></body></HTML>
