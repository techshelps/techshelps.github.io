<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Thin Client Three-tier Architecture</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<h2>Thin Client Three-tier Architecture</h2>

<p>The litmus test just created effectively defines a new
application architecture for the Internet. This model, which I
call the thin client three-tier architecture, can be
differentiated from the traditional three-tier client/server
approach in two ways. First of all, in the thin client model, all
the application-specific logic is running on the server. The
logic could be distributed on the server side over many machines,
but the approach is inherently server-side. Secondly, in the thin
client model, only state changes are exchanged between the client
and the server. In the traditional three-tier model the
communication between the client and the server is based on
remote procedure calls (RPCs). Implementing an application with
RPCs requires application-specific logic on the client.
Application partitioning is typically left to the developer. The
problem with the traditional three-tier architecture with respect
to the Internet is that it exhibits many fat client
characteristics. It is important to note that a thin client
approach allows objects to be accessed by multiple clients
simultaneously and in real time. </p>

<p>Traditional client/server approaches, allowing only a single
client to access a server process, were OK for the single-user
desktop application, but inadequate and too inflexible given the
multiclient access capabilities of the Web. Traditionally,
multiuser access to data was limited to the multiuser
capabilities of the database engine. The thin client approach
enables multiuser control of data and services of application
objects. The traditional client/server approach controls data and
services at the level of the database engine where the context of
the data with respect to its associated logic is limited or
nonexistent. </p>

<p>Let&#146;s take a look at the implementation of the thin
client three-tier architecture. Client, server, and database
pieces can be interchangeable. The Java AWT toolkit provides the
API for the user interface of an application. The presentation
layer (the thin client) can actually be an applet downloaded from
the server and run within an Internet browser. The applet
contains user-interface widgets such as scroll bars and buttons
and enough embedded network communication machinery to respond to
and initiate state changes between the client and the server. </p>

<p>A client-side visual element is associated with a specific
server-side object. For example, an AWT edit box on the client
can be &#147;connected&#148; to a data member of a C++ object
running on the server. When a value is typed into the edit box on
the client-side applet, a data state change message is sent to
the server. In this example, an edit box is a Java applet with a
&#147;network&#148; line connected to a server-side object&#146;s
data member. Any other clients viewing that data member through
their interfaces will also update automatically to reflect the
object&#146;s new state. </p>

<p>Although the client is small, it is also smart enough to know
the kind of C++ objects running on the server to which it is
connected. The client sends network messages when the user
interacts with the AWT control, and receives state changes
initiated by the server (for example, when the application logic
changes the data member). The generated presentation layer then
becomes a client to the server-side C++ objects. The entire
client can be generated so that, by default, the developer
isn&#146;t required to write any code (see Figure 6). </p>

<p><img src="thin6.gif" width="594" height="298"> </p>

<p><b>Figure 6 Thin Client Three-tier Architecture</b> </p>

<p>C++ objects are executed on the server. The client download
initiates a connection to server objects through an object
framework-based protocol. Clients can attach to an already
running C++ application on the server or start a unique C++
process upon client-applet startup. Any database accessible
through C++ can be accessed by the objects in the server-side
application. </p>
</font></body>
</html>
