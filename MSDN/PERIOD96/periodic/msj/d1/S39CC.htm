<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>C++ Q &amp; A</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>C++ Q &amp; A</H1><P>Paul DiLascia</P>
<P><I>Paul DiLascia is a freelance software consultant specializing in training and software development in C++ and Windows. He is the author of Windows++: Writing Reusable Code in C++ (Addison-Wesley, 1992).</I></P>
<P><font size="6" face="verdana,arial,helvetica">Q</font> I'm writing a Single Document Interface (SDI) application using MFC. I realize Microsoft is pushing a document-centric world, but there are still people who run the application and then pick which document they want to open (silly people!).</P>
<P>The problem I have is that, whenever the application starts up, MFC automatically does a File New operation to create a blank document. In my case, File New is fairly expensive; it takes a lot of time, may have to connect to a Web site, and requires the user to pick a document template to use. I want to avoid going through the File New process unless the user actually wants a new document. What would be a reasonable way to do this? Keep in mind that I still want to let Windows 95¨ users do New XYZ Document from many places such as the desktop (right button popup menu) and Windows Explorer (File New command).</P>
<P><I>Ed Silky</I></P>
<P>Calico Technology</P>
<P><font size="6" face="verdana,arial,helvetica">A</font>In case you're experiencing a sense of <I>d</I><I>Ž</I><I>j</I><I>ˆ</I><I> vu</I> all over again, it's not because you've slipped into a wrinkle in the time-space continuum that warped you backward a month. This is indeed the same question that appeared in last month's column. Am I so desperate for questions that I have to recycle old ones?</P>
<P>No. Ed's question appears again because last month I only answered half of it. In November, I showed you how to create an SDI app that starts out with an empty, uninitialized document—a view that paints an empty frame, with all document commands disabled until the user explicitly invokes File New. This simulates a no-document condition but keeps MFC happy by giving it the CDocument object it so desperately needs. The cost of initializing the document is deferred until the user explicitly invokes File New from the menu.</P>
<P>This month, I'll answer the second part of Ed's question: how do you deal with File New operations that come from the shell? Just so everyone knows what we're talking about here, Windows 95 lets you create new documents in several places. For example, you can right-click from your desktop or any folder to get the menu in Figure 1. Or you can choose File New from the Windows Explorer (see Figure 2). In both figures, Scribble Drawing is selected. Scribble is the drawing program that comes with the MFC tutorial that I modified last month to implement the first part of Ed's question. How does Windows 95 know to list Scribble Drawing in its File New menu?</P>
<P><img src="20577.gif"></P>
<P><B>Figure 1  Shell New menu</B></P>
<P><img src="20578.gif"></P>
<P><B>Figure 2  File New from Windows Explorer</B></P>
<P>Do the words "system registry" mean anything to you? Figure 3 shows the registry key for .SCB (Scribble) files with the special subkey HKEY_CLASSES_ROOT\.SCB\ShellNew, which has a string value NullFile set to "" (the empty string). When Windows sees that, it adds Scribble Drawing to its File New menu, and when the user selects Scribble Drawing, Windows launches the program in HKEY_CLASSES_ROOT\Scribble.Document\shell\open\command, which is something like "C:\fumble\mumble\bumble \scribble.exe %1". The name Scribble Drawing comes from the entry HKEY_CLASSES_ROOT\Scribble.Document, whose value is "Scribble Drawing". Windows 95 knows to look at Scribble.Document because that's the value of HKEY_CLASSES_ROOT\.SCB. Got it?</P>
<P><img src="20579.gif"></P>
<P><B>Figure 3  Scribble registry key entries</B></P>
<P>If you're wondering how all this stuff got in your registry, MFC put it there. One of the functions Scribble calls from CScribbleApp::InitInstance is RegisterShellFileTypes, a CWinApp function that adds a bunch of junk to your registry. (Figure 4 shows the whole kit and caboodle.) MFC gets the names from the string resource associated with the document template. When you create a document template you give it an ID like IDR_MAINFRAME or IDR_MYDOCTYPE, and the ID identifies a bunch of resources, including a string. In SCRIBBLE.RC, it looks like this:</P>
<P><BR></P>
<PRE>STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
  IDR_MAINFRAME "Scribble\nuntitled\nScribbble\n"
                "Scribble Files (*.scb)\n.SCB\n"
                "Scribble.Document\nScribble Drawing"
END
</PRE>
<P>Whew! This unwieldy string comprises seven substrings, separated by newlines (\n). </P>
<P><B>Figure 4  Scribble.reg</B></P>
<P><BR></P>
<PRE>[HKEY_CLASSES_ROOT\.SCB]
@="Scribble.Document"

[HKEY_CLASSES_ROOT\.SCB\ShellNew]
"NullFile"=""

[HKEY_CLASSES_ROOT\Scribble.Document]
@="Scribble Drawing"

[HKEY_CLASSES_ROOT\Scribble.Document\DefaultIcon]
@="C:\\Mumble\\Bumble\\Fumble\\SCRIBBLE.EXE,0"

[HKEY_CLASSES_ROOT\Scribble.Document\shell]

[HKEY_CLASSES_ROOT\Scribble.Document\shell\open]

[HKEY_CLASSES_ROOT\Scribble.Document\shell\open\command]
@="C:\\Mumble\\Bumble\\Fumble\\SCRIBBLE.EXE \"%1\""

[HKEY_CLASSES_ROOT\Scribble.Document\shell\print]

[HKEY_CLASSES_ROOT\Scribble.Document\shell\print\command]
@="C:\\Mumble\\Bumble\\Fumble\\SCRIBBLE.EXE /p \"%1\""

[HKEY_CLASSES_ROOT\Scribble.Document\shell\printto]

[HKEY_CLASSES_ROOT\Scribble.Document\shell\printto\command]
@="C:\\Mumble\\Bumble\\Fumble\\SCRIBBLE.EXE /pt \"%1\" \"%2\" \"%3\" \"%4\""</PRE>
<P></P>
<P>Figure 5 shows how MFC uses all the different pieces. Notice in particular the last two substrings, "Scribble.Document" and "Scribble Drawing". These are the substrings MFC uses for the registry. When you call RegisterShellFileTypes, MFC loops over all of your document templates, extracts the substrings for each one, and creates the registry entries that resemble Figure 4. If you call RegisterShellFileTypes with TRUE as the argument (to signify that you're a Windows 95-based app), MFC adds some other stuff, including the ShellNew key with NullFile="".</P>
<P><img src="20580.gif"></P>
<P><B>Figure 5  Components of MFC doc string</B></P>
<P>So to add your app to the Windows File New menu, all you have to do is call RegisterShellFileTypes from your app's InitInstance function. But now you can see that I have a little problem. Last month I modified the Scribble program to start up empty instead of creating a new document. This is fine standalone, but if the user has invoked a command called File New from the desktop, Explorer, or a shell folder, then presumably he or she really wants to create a new file and Scribble should do just that—not make the user invoke File New again, this time from the Scribble menu.</P>
<P>What you need is a way to distinguish between when a user invokes Scribble from the Start menu or MS-DOS¨ command line (yes, some of us still use it), and the situation where Windows 95 invokes it on behalf of a user trying to create a new document from the shell.</P>
<P>In fact, there is a way—I mentioned the NullFile value. There are others. For example,</P>
<P><BR></P>
<PRE>HKEY_CLASSES_ROOT\.SCB\ShellNew
  FileName="foo.scb"
</PRE>
<P>tells Windows 95, "to create a new Scribble doc, open the file foo.scb," which it does by running "scribble.exe foo.scb." You then have to install foo.scb in the appropriate directory, which is \windows\shellnew, one of the many secret (read: hidden) directories Windows 95 keeps around for just such purposes. </P>
<P>So one way to solve Ed's problem is to create a new, empty document and use the FileName value. Another way is to give Windows an explicit command to use:</P>
<P><BR></P>
<PRE>HKEY_CLASSES_ROOT\.SCB\ShellNew
  Command="SCRIBBLE.EXE /ReallyCreateANewDoc"
</PRE>
<P>Now Windows 95 will run "SCRIBBLE.EXE /ReallyCreateANewDoc" to create a new Scribble Drawing. Pretty neat. There's even a Data value that lets you put the file right in the registry as binary data (not very useful, unless you have teeny-weeny documents and a brain that thinks in hex). Figure 6 summarizes these values. Windows 95 searches for NullFile, FileName, Command, and Data in that order, and uses the first one it finds. So if you want to use FileName, you have to delete NullFile, and if you want to use Command, you have to delete NullFile and FileName.</P>
<P><B>Figure 6  Recognized Values for ShellNew</B></P>
<P><B>HKEY_CLASSES_ROOT\.ext\ShellNew\</B></P>
<P><B>  Value Name = Value        </B></P>
<P>NullFile    ""    Runs app with no command </P>
<P>        line arguments</P>
<P>FileName    pathname    Runs app, passing pathname </P>
<P>        as FileName argument</P>
<P>Command    command    Executes the command</P>
<P>Data    binary data    Creates a new file containing</P>
<P>        the binary data</P>
<P>Windows searches for values in the above order; for example, if you want to use Command, you must remove NullFile and FileName.</P>
<P>For Scribble, the Command approach seems like the best bet. I invented a new Scribble option, /ShellNew, then modified InitInstance to register "Scrible.exe /ShellNew" as the value for Command. CSCribbleApp::InitInstance calls a new function, MaybeRegisterFileTypes, which first checks to see if Scribble is registered and, if it isn't, prompts the user to register it with the dialog in Figure 7. Only if the user responds OK does MaybeRegisterFileTypes go on to register Scribble, calling OnInstall, which calls the infamous RegisterShellFileTypes (see Figure 8). OnInstall then undoes some of MFC's work, removing the NullFile=="" value, and replacing it with Command="SCRIBBLE.EXE /ShellNew".</P>
<P><img src="20581.gif"></P>
<P><B>Figure 7  Ask the user</B></P>
<P><B>Figure 8  Scribble</B></P>
<P><BR></P>
<PRE>SCRIBBLE.CPP
////////////////////////////////////////////////////////////////
// Modified SCRIBBLE Copyright 1996 Microsoft Systems Journal. 
// Portions Copyright (C) 1992-1995 Microsoft Corporation
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// This program is based on the SCRIBBLE program that comes with
// Microsoft Visual C++, as part of the MFC tutorial.
//
// This modified SCRIBBLE shows
//
// -how to write an SDI app that starts with an empty frame instead
//  of a new document;
//
// -how to setup the systemp registry to call your app with a 
//  special switch when the user does "File New" from the 
//  Windows 95 shell;
//
// -how to parse the switch in your InitInstance function;
//
// -how to write an exception handler to handle any uncaught 
//  exception that occurs while the app is running.
// 
#include "stdafx.h"
#include "Scribble.h"
#include "MainFrm.h"
#include "ScribDoc.h"
#include "ScribVw.h"
#include &lt;eh.h&gt;         // set_terminate
#include "TraceWin.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////
// CScribbleApp

BEGIN_MESSAGE_MAP(CScribbleApp, CWinApp)
   //{{AFX_MSG_MAP(CScribbleApp)
   ON_COMMAND(ID_APP_ABOUT,    OnAppAbout)
   ON_COMMAND(ID_EX_USER,      OnExUser)
   ON_COMMAND(ID_EX_MEMORY,    OnExMemory)
   ON_COMMAND(ID_EX_RESOURCE,  OnExResource)
   ON_COMMAND(ID_INSTALL,      OnInstall)
   ON_COMMAND(ID_REMOVE,       OnRemove)
   //}}AFX_MSG_MAP
   ON_COMMAND(ID_FILE_NEW,     OnMyFileNew)
   ON_COMMAND(ID_FILE_OPEN,    CWinApp::OnFileOpen)
   ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

CScribbleApp theApp;

typedef void (*TERMINATE_FN)();
TERMINATE_FN old_terminate = NULL;

////////////////
// Custom terminate handler just displays message
//
void my_terminate()
{
   MessageBox(NULL, "Help me, I'm dying.", "Terminate", MB_OK);
   if (old_terminate)
      old_terminate();
}

//////////////////
// Custom class to parse command line switches.
// To parse your own switches, just override 
// CCommandLineInfo::ParseParam.
class CMyCmdLineInfo : public CCommandLineInfo {
public:
   virtual void ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast);
   enum { ShellNew=100 };
};

//////////////////
// Custom override to parse my own switches.
// Recognizes /ShellNew
//
void CMyCmdLineInfo::ParseParam(const char* pszParam, BOOL bFlag, BOOL bLast)
{
   TRACE("CMyCmdLineInfo::ParseParam(%s)\n",pszParam);
   if (bFlag &amp;&amp; stricmp(pszParam, "ShellNew")=&nbsp;=0)
      (UINT&amp;)m_nShellCommand = ShellNew;
   else 
      CCommandLineInfo::ParseParam(pszParam, bFlag, bLast);
}

CScribbleApp::CScribbleApp()
{
   MfxTraceInit();         // initialize TRACEWIN tracing
   old_terminate = set_terminate(my_terminate);
   m_bRemoveProfile = FALSE;
}

CScribbleApp::~CScribbleApp()
{
   set_terminate(old_terminate);
}

//////////////////
// Initialize app
//
BOOL CScribbleApp::InitInstance()
{
   SetRegistryKey("MSJ");     // Use HKEY_CURRENT_USER\Software\MSJ for INI
   LoadStdProfileSettings();  // Load INI file options (including MRU file)

   // create doc template
   CDocTemplate* pDocTemplate;
   pDocTemplate = new CSingleDocTemplate(
      IDR_MAINFRAME,
      RUNTIME_CLASS(CScribbleDoc),
      RUNTIME_CLASS(CMainFrame),
      RUNTIME_CLASS(CScribbleView));
   AddDocTemplate(pDocTemplate);

   if (!MaybeRegisterFileTypes())   // Maybe register shell stuff
      return FALSE;

   // Parse command line. Use my own custom class.
   CMyCmdLineInfo cmdInfo;
   ParseCommandLine(cmdInfo);
   if (!ProcessShellCommand(cmdInfo)) // dispatch command
      return FALSE;
      
   return TRUE;
}

//////////////////
// Quit SCRIBBLE. If the user chose to remove the installation,
// delete the profile settings. This must happen now since other
// functions update the profile as the app is shutting down, recreating
// the profile entry if it's gone. This will remove it for good
//
int CScribbleApp::ExitInstance()
{
   int nRet = CWinApp::ExitInstance();
   if (m_bRemoveProfile)
      RegDeleteKey(HKEY_CURRENT_USER,"Software\\MSJ\\Scribble");
   return nRet;
}

//////////////////
// Override to handle /ShellNew option
//
BOOL CScribbleApp::ProcessShellCommand(CCommandLineInfo&amp; cmdInfo)
{
   TRACE("CScribbleApp::ProcessShellCommand(%d)\n",cmdInfo.m_nShellCommand);
   if (cmdInfo.m_nShellCommand=&nbsp;=CMyCmdLineInfo::ShellNew) {
      OnMyFileNew();
      return TRUE;
   }
   return CWinApp::ProcessShellCommand(cmdInfo);  // let MFC do it
}

//////////////////
// REALLY create new document: that is, initialize the empty doc object.
//
void CScribbleApp::OnMyFileNew()
{
   OnFileNew(); // do normal thing to create new doc
                // (in case this is an open doc, reuse it)

   CFrameWnd* pFrame = (CFrameWnd*)m_pMainWnd;
   ASSERT_KINDOF(CFrameWnd, pFrame);
   CScribbleView* pView = (CScribbleView*)pFrame-&gt;GetActiveView();
   ASSERT_KINDOF(CScribbleView, pView);
   pView-&gt;GetDocument()-&gt;Initialize(); // initialize new doc
}

void CScribbleApp::OnAppAbout()
{
   CDialog(IDD_ABOUTBOX).DoModal();
}

//////////////////
// Commands to throw various kinds of exceptions.
//
void CScribbleApp::OnExUser()     { AfxThrowUserException();     }
void CScribbleApp::OnExMemory()   { AfxThrowMemoryException();   }
void CScribbleApp::OnExResource() { AfxThrowResourceException(); }

//////////////////
// Exception handler of last resort displays message box describing
// exception, then tries to save all files.
//
LRESULT CScribbleApp::ProcessWndProcException(CException* e, const MSG* pMsg)
{
   CString s = "An unhandled error occurred in your program.\n\n";
   CString m;
   m.Format("type\t%s\n", e-&gt;GetRuntimeClass()-&gt;m_lpszClassName);
   s += m;
   m.Format("HWND\t0x%04x\nmsg\t0x%04x\nwParam\t0x%08x\nlParam\t0x%08x",
      pMsg-&gt;hwnd, pMsg-&gt;message, pMsg-&gt;wParam, pMsg-&gt;lParam);
   s += m;
   s += "\n\nSelect:\nAbort \tto terminate the program;\n";
   s += "Retry \tto let MFC handle the error; or\n";
   s += "Ignore \tto do nothing.\n\n";
   s += "After this dialog, you'll have a chance to save modified documents.";
   int nRes = MessageBox(m_pMainWnd-&gt;GetSafeHwnd(), s, "Error!", 
      MB_ABORTRETRYIGNORE);

   // Save any modified docs
   SaveAllModified();

   if (nRes=&nbsp;=IDABORT)
      THROW_LAST();        // will call terminate()
   else if (nRes=&nbsp;=IDRETRY)
      return CWinApp::ProcessWndProcException(e, pMsg); // do MFC Thing

   return 0; // IDIGNORE
}

//////////////////
// Dialog asks user whether to register scribble file types
//
class CRegisterConfirmDialog : public CDialog {
public:
   CRegisterConfirmDialog() : CDialog (IDD_REGISTER) { }
   DECLARE_MESSAGE_MAP()
   afx_msg BOOL OnButton(UINT id) { EndDialog(id); return TRUE; }
};

BEGIN_MESSAGE_MAP(CRegisterConfirmDialog, CDialog)
   ON_COMMAND_EX(IDYES, OnButton)
   ON_COMMAND_EX(IDNO,  OnButton)
END_MESSAGE_MAP()

//////////////////
// Check for proper registration, and maybe prompt user to register.
// Better to do it this way than blithely clobber the registry.
//
BOOL CScribbleApp::MaybeRegisterFileTypes()
{
   HKEY hkey;
   if (RegOpenKey(HKEY_CLASSES_ROOT, ".SCB\\ShellNew", &amp;hkey)=&nbsp;=ERROR_SUCCESS)
      // if ShellNew key exists, assume already registered.
      // Theoretically, should check for proper values of all keys
      return TRUE;

   switch (CRegisterConfirmDialog().DoModal()) {
   case IDCANCEL:
      return FALSE; // abort
   case IDNO:
      return TRUE;  // continue, but don't register
   }
   
   // User selected OK, so do the installation
   OnInstall();

   return TRUE;
}

//////////////////
// "Install" scribble (register file types)
//
void CScribbleApp::OnInstall()
{
// EnableShellOpen();            // Only use to support File Manager
   RegisterShellFileTypes(TRUE); // TRUE for Win 95

   // MFC has set HKEY_CLASSES_ROOT\.SCB\ShellNew\NullFile = ""
   // So we must remove and replace with Command =
   //
   HKEY hkey;
   if (RegOpenKey(HKEY_CLASSES_ROOT,".SCB\\ShellNew",&amp;hkey)=&nbsp;=ERROR_SUCCESS) {
      RegDeleteValue(hkey, "NullFile");
      CString s = "SCRIBBLE.EXE /ShellNew";
      DWORD len = s.GetLength() + 1;
      RegSetValueEx(hkey, "Command", 0, REG_SZ, (BYTE*)(LPCSTR)s, len);
      RegCloseKey(hkey);
   } else {
      ASSERT(FALSE);
   }
}

//////////////////
// De-install SCRIBBLE app
// Remove registry keys. Profile must be deferred since shutdown code
// will write stuff like MRU files to the profile, recreating it.
//
void CScribbleApp::OnRemove()
{
   RegDeleteKey(HKEY_CLASSES_ROOT,".SCB");
   RegDeleteKey(HKEY_CLASSES_ROOT,"Scribble.Document");
   m_bRemoveProfile = TRUE;
}


SCRIBBLE.H
////////////////////////////////////////////////////////////////
// Modified SCRIBBLE Copyright 1996 Microsoft Systems Journal. 
// Portions Copyright (C) 1992-1995 Microsoft Corporation.
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// See SCRIBBLE.CPP for Description of program.
//
#ifndef __AFXWIN_H__
   #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

class CScribbleApp : public CWinApp {
private:
   BOOL  m_bRemoveProfile;         // delete profile on exit?
   BOOL  MaybeRegisterFileTypes(); // helper

public:
   CScribbleApp();
   ~CScribbleApp();
   virtual BOOL InitInstance();
   virtual int ExitInstance();

   // Note: non-virtual override
   BOOL ProcessShellCommand(CCommandLineInfo&amp; rCmdInfo);

   virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);

   //{{AFX_MSG(CScribbleApp)
   afx_msg void OnAppAbout();
   afx_msg void OnMyFileNew();
   afx_msg void OnExUser();
   afx_msg void OnExMemory();
   afx_msg void OnExResource();
   afx_msg void OnInstall();
   afx_msg void OnRemove();
   //}}AFX_MSG
   DECLARE_MESSAGE_MAP()
};
</PRE>
<P>Using a confirmation dialog is somewhat unorthodox, but I really dislike apps that blithely install themselves and overwrite the registry as they please. It's quite distressing when I've customized my shell in some particular way, only to have some boneheaded app clobber my entries. A good app always prompts before munging the registry. After all, how do you know .SCB isn't the extension for some other app, say a SCaB file in a labor-union tracking program, or a file from Sally's Cook Book? You laugh now, but the original extension for Scribble files was .SCR; Microsoft had to change it because screen savers also use .SCR. Even if you don't clobber anything, you'll contribute to registry clutter, the moral equivalent of littering. Things have gotten so bad there's a market for registry-cleanup tools, like Matt Pietrek's REGCLEAN utility in the September 1996 <I>MSJ</I>. No doubt one reason for all the registry junk is AppWizard-generated programs that call RegisterShellFileTypes.</P>
<P>Shielding users from installation arcana is all well and good, but there are two rules you absolutely must follow to be a good registry citizen. First, never clobber anything silently behind the scenes without telling the user (adding your own profile settings is OK). Second, always provide a way to remove anything you've added. The best place to do all this is in your setup program. Since Scribble is just a demo app, I'm not going to write a setup program for it. Instead, I added two commands: Register Install and Register Remove, to add and remove the registry entries for Scribble (see Figure 9). Figure 8 shows the OnInstall and OnRemove handlers for these commands.</P>
<P><img src="20582.gif"></P>
<P><B>Figure 9  Register menu</B></P>
<P>So much for registry etiquette. Once the ShellNew\Command value is set up, the only thing remaining to finish Scribble is to actually parse the command-line option. In the old days you had to parse argv/argc manually, but now MFC makes it easy. The standard AppWizard-generated app contains the following lines in InitInstance.</P>
<P><BR></P>
<PRE>CCommandLineInfo cmdInfo;
ParseCommandLine(cmdInfo);
if (!ProcessShellCommand)
   return FALSE;
</PRE>
<P>CCommandLineInfo is a little object that holds information about the command line; CWinApp::ParseCommandLine parses the command line, converting text options like /Embedding to code like cmdInfo.m_bRunEmbedded = TRUE; and CWinApp::ProcessShellCommand takes appropriate action. CWinApp::ParseCommandLine parses individual command-line tokens and then calls the virtual function CCommandLineInfo::ParseParam for each one. For example, if the command line was "SCRIBBLE.EXE <BR>/foo /bar myfile.scr", CWinApp would call ParseParam three times with "foo", "bar", and "myfile.scr". CWinApp strips the leading / or - from flags (so you don't have to check for it), and passes a BOOL argument bFlag that tells ParseParam whether the token is a flag or not.</P>
<P>Since CCommandLineInfo::ParseParam is virtual (in fact, it's the only virtual function CCommandLineInfo has), you can override it. In other words, parsing the /ShellNew flag for Scribble is as easy as deriving a new class from CCommandLineInfo and overriding one virtual function, ParseParam.</P>
<P><BR></P>
<PRE>class CMyCmdLineInfo : public CCommandLineInfo {
public:
   virtual void 
     ParseParam(LPCSTR* pszParam, 
                BOOL bFlag, BOOL bLast);
   enum { ShellNew=100 };
};
</PRE>
<P>The implementation is practically trivial:</P>
<P><BR></P>
<PRE>void CMyCmdLineInfo::ParseParam
  (LPCSTR* pszParam, BOOL bFlag, BOOL bLast)
{
   if (bFlag &amp;&amp; stricmp(pszParam, "ShellNew")=&nbsp;=0)
      (UINT&amp;)m_nShellCommand = ShellNew;
   else 
      CCommandLineInfo::ParseParam (pszParam, bFlag, bLast);
}
</PRE>
<P>The nice thing about ParseParam is you don't have to actually parse anything. MFC feeds you the flags one by one; all you have to do is note them and check for ShellNew. I pulled a minor hack here, which is to (re)use CCommandLine::m_nShellCommand by faking out the compiler:</P>
<P><BR></P>
<PRE>(UINT&amp;)m_nShellCommand = ShellNew;
</PRE>
<P>Since m_nShellCommand is declared enum inside CCommandLineInfo, C++ will only let you set it to one of the symbols declared in the enum. By casting to UINT&amp; (reference to int), I overcome the compiler's natural instinct to keep me honest. This is the sort of thing that would make a C++ professor groan and give you a B in the course, but it works just fine in real life as long as my enum values never clash with CCommandLineInfo's. (That's why I set CMyCmdLineInfo::ShellNew= 100; I don't think MFC will ever support 100 built-in command-line options, and if it does, I'll have long since escaped to the Caymans.) The USDA approved way of doing this would be to introduce a new member, such as m_nMyCommand&nbsp;or m_bShellNew.</P>
<P>Once you implement CMyCommandLineInfo (or CYourCommandLineInfo), you have to use it instead of CCommandLineInfo:</P>
<P><BR></P>
<PRE>CMyCommandLineInfo cmdInfo; // use your derived class
</PRE>
<P>The next and final step is to override CWinApp::ProcessShellCommand. This function isn't virtual, but it doesn't need to be since you call it directly from InitInstance. You can override ProcessShellCommand and the compiler will generate a call to your version because it's nearest in scope. Remember, the virtualness of virtual functions is relevant only when invoking the function through a pointer to a base class object, and you want to call the function for whichever derived class the object really is—but that's not what's going on here. My implementation of ProcessShellCommand is straightforward.</P>
<P><BR></P>
<PRE>if (cmdInfo.m_nShellCommand=&nbsp;=CMyCmdLineInfo::ShellNew) {
   OnMyFileNew();  // the REAL file new (from last month)
   return TRUE;
}
return CWinApp::ProcessShellCommand(cmdInfo);  // let MFC
                                               // do it
</PRE>
<P>If the command is ShellNew, ProcessShellCommand calls OnMyFileNew, the function I wrote last month that initializes the document and handles the File New command in Scribble. This is different from OnFileNew, which is what MFC calls when starting up with no command line options.</P>
<P>Just in case you're lost, here's what happens when the user invokes File New Scribble Drawing from the shell: Windows sees the value Command="SCRIBBLE.EXE /ShellNew" in the registry under \HKEY_CLASSES_ ROOT\.SCB\ShellNew, so it runs that command. Scribble starts up and control flows to InitInstance, which instantiates a CMyCommandLineInfo and passes it to CWinApp::ParseCommandLine. ParseCommandLine parses the tokens (there's only one) and calls CCommandLineInfo::ParseParam, which is virtual, so control flows to CMyCmdLineInfo::ParseParam. CMyCmdLineInfo::ParseParam recognizes "ShellNew" and sets m_nShellCommand= CMyCmdLineInfo::ShellNew (100). When control returns, InitInstance calls CScribbleApp::ProcessShellCommand, which detects CMyCmdLineInfo::ShellNew and calls ScribbleApp::OnMyNewFile to really create the file. <I>Voil</I><I>ˆ</I>. All this is different from the situation where the user picks Scribble from the Windows 95 Start menu. In that case, Scribble starts up with no command-line arguments, ParseParam never sees ShellNew, so m_nShellCommand defaults to CCommandLineInfo::FileNew and CWinApp:: ProcessShellCommand calls OnFileNew, just as it does in a plain vanilla MFC app—only CScribbleApp::OnFileNew doesn't really create the document (see last month's column). Whew!</P>
<P><B>Q </B>I just read your reply to the question regarding removing the title from an app (in the August and November 1995 issues of <I>MSJ</I>). I've been trying to achieve the opposite: I want to create an app that has only a title bar and no client area. No matter what I do, I can't remove all of the client window. I always end up with a very small window, maybe three or four pixels high, underneath the title. What's going on and how can I fix this? I enclose my last attempt at achieving this.</P>
<P><I>Poor mainframe programmer </I></P>
<P>who plays with C++</P>
<P><B>A </B>I just love this never-ending title bar saga. First I get a reader who wants an app with no title bar because he doesn't want the user to move the window (August 1995). I show him how to prevent the sizing, but humbly suggest it's really a good idea to keep the title bar. A few months later (November 1995), another reader writes to complain that I didn't answer the first guy's question and he hates the way title bars look, so would I please tell him how to get rid of them. So I show this second guy how to create a window with no title bar. Now a third reader comes along to ask how to get rid of everything BUT the title bar! Sheesh.</P>
<P>As a general rule of thumb, it's almost always the case that in Windows you can do anything you want. The only catch is it may require writing a gazillion lines of code (more than forty), or learning obscure Windows voodoo. This particular case falls into the latter category. I'm about to visit some of the most arcane Windows minutiae this column has yet descended to, so now's a good time for the anti-emetic pills.</P>
<P>But first, let me describe the program included with the question. MONITOR is a miniapp that displays information about available system memory in its title bar (see Figure 10). I modifed MONITOR to paint the client area red so you can see the problem more easily: the mysterious two-pixel high (on my system) client area, clearly visible in Figure 10. This despite the fact that CMonitorWindow requests a window size that should result in a client area of zero height.</P>
<P><img src="20583.gif"></P>
<P><B>Figure 10  A buggy title bar</B></P>
<P>So what's going on? To find out, I threw some TRACE statements into MONITOR to display the requested and actual window sizes, and some of the relevant system metrics (see Figure 11). On my system, MONITOR requested a window 22 pixels high, but got one 27 pixels high. Why? The problem is that Windows has a minimum window height, which you can obtain by calling GetSystemMetrics(SM_CYMIN). On my system, this value is 27. Since the caption height (GetSystemMetrics(SM_CYCAPTION)) is 19, that means the window is 8 pixels taller than the caption. The borders account for only 6 pixels—three pixels each—which leaves two extra pixels that, sure enough, get allocated to the client area. Figure 12 shows a full accounting of pixels in the buggy version of MONITOR. (These and all values are taken from my system.)</P>
<P><img src="20584.gif"></P>
<P><B>Figure 11  TRACE output of buggy title bar</B></P>
<P><B>Figure 12  Pixel Problems</B></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="95pt" VALIGN="TOP"><COL WIDTH="26pt" VALIGN="TOP"><COL WIDTH="155pt" VALIGN="TOP"><COL WIDTH="165pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Top border</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>SM_CYFIXEDFRAME</P></TD></TR><TR><TD VALIGN="TOP"><P>Caption</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>SM_CYCAPTION</P></TD></TR><TR><TD VALIGN="TOP"><P>Bottom border</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>SM_CYFIXEDFRAME</P></TD></TR><TR><TD VALIGN="TOP"><P>TOTAL</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>     25              (Desired height)</P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P></P></TD></TR><TR><TD VALIGN="TOP"><P>Min window height</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>27</P></TD><TD VALIGN="TOP"><P>SM_CYMIN</P></TD></TR><TR><TD VALIGN="TOP"><P>Client</P></TD><TD VALIGN="TOP"><P>=</P></TD><TD VALIGN="TOP"><P>  2</P></TD><TD VALIGN="TOP"><P>Extra pixels</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>The problem is that MONITOR should ideally have a window 25 pixels high, but Windows won't let it create a window less than 27 pixels high. Where, one might wonder, does Windows come up with the value 27? Therein lies the solution to the whole problem. The minimum window height is calculated by assuming a size zero client area:</P>
<P><BR></P>
<PRE>minimum window height =     height of top border +
    height of caption    + 
      height of bottom border
</PRE>
<P>This calculation is made for a window with borders that are sizable; that is, the borders you get when you specify WS_THICKFRAME, which is the default for a main window. But you don't want to let users size your window (or have min/max boxes), so you create CMonitorWindow with WS_BORDER (nonsizeable border) instead of WS_THICKFRAME (sizeable border). This results in a slightly thinner frame—three pixels versus four—and accounts for the two extra pixels in the client area.</P>
<P>What to do? One possible solution is to paint the client area the same color as the caption. You can get the caption color by calling GetSystemColor(COLOR_ACTIVECAPTION). Of course, you have to remember to paint it using the inactive color (COLOR_INACTIVECAPTION) when your window is inactive. This would work except for one slight problem. If you look at Figure 10, you can see that Windows paints a thin gray line below the caption. This is part of its new 3D face lift. Getting rid of that line is virtually impossible, even if you handle your own WM_NCPAINT messages (believe me, I tried). Getting rid of the thin gray line falls into category A of Windows alteration, the gazillion lines of code category.</P>
<P>Since requiring users to choose gray as their caption color is not an option, it's time to take a different approach. The whole problem comes from using WS_BORDER to prevent sizing instead of the normal WS_THICKFRAME. Is there some other way to prevent sizing? In fact, there is.</P>
<P>How does Windows know to display that little size arrow cursor when the user moves the mouse into the frame of a sizable window? By sending the window a special message, WM_NCHITTEST. The window returns a code indicating which area of the window the mouse is in. HTCAPTION says the mouse is in the caption; HTMINBUTTON says it's in the minimize button, and so on (<I>see </I><I>"</I><I>Dave</I><I>'</I><I>s Top Ten List of Tricks, Hints, and Techniques for Programming in Windows,</I><I>"</I><I> </I>MSJ<I> October 1992, for more information on WM_NCHITTEST</I><I>—</I><I>Ed.</I>). Of special relevance now are the hit test codes HTLEFT, HTRIGHT, HTTOP, HTTOPLEFT, HTTOPRIGHT, HTBOTTOM, HTBOTTOMLEFT, and HTBOTTOMRIGHT. As the names suggest, these codes indicate that the mouse is in some part of the window frame where sizing is allowed. For example, HTBOTTOMRIGHT tells Windows the mouse is in the bottom, right corner of the frame. When your window proc returns HTBOTTOMRIGHT, Windows displays the northwest/southeast arrow cursor to cue the user that he can size the window by dragging. Likewise, if you return HTLEFT or HTRIGHT, Windows displays the east-west arrow to indicate that the window can be sized horizontally. The Windows default window procedure, DefWindowProc, which is where MFC routes all unhandled messages, figures out where the mouse is and returns the appropriate HT<I>xxx</I> code. If the window doesn't allow sizing—that is, if it has WS_BORDER instead of WS_THICKFRAME as its border style—then DefWindowProc returns another code, HTBORDER, that tells Windows the mouse is in the border but sizing is not allowed. In that case, Windows displays its normal arrow cursor and sizing is not allowed.</P>
<P>Suppose you had a WS_THICKFRAME border but implemented your own handler for WM_NCHITTEST that always returns HTBORDER when the mouse is in the border? That's exactly what I did to fix MONITOR (see Figure 13). The CMonitorWindow constructor creates the window with the WS_THICKFRAME border style to give it the thick sizeable frame. This eliminates the problem with the two-pixel high client area. But then, to prevent the user from sizing the window, I implemented my own WM_ONNCHITTEST handler. CMonitorWindow::OnNcHitTest first calls the base class CFrameWnd::OnNcHitTest to get the hit test code DefWindowProc would normally return, then CMonitorWindow mungs it. If the normal response would be HTTOP or HTBOTTOM, CMonitorWindow returns HTBORDER instead. This has exactly the same effect as a nonsizeable border. What's even cooler is that if CFrameWnd::OnNcHitTest returns HTLEFT, HTTOPLEFT or HTBOTTOMLEFT (any of the LEFT codes), CMonitorWindow returns HTLEFT, and if CFrameWnd returns HTRIGHT, HTTOPRIGHT, or HTBOTTOMRIGHT, CMonitorWindow returns HTRIGHT. The result is that the user can still size the window horizontally, which makes sense for a window that's only a title bar. If the user moves the mouse into one of the corners, Windows displays an east-west size arrow cursor, not a diagonal one. Pretty neat. If you don't want this feature, you can just return HTBORDER in all cases.</P>
<P><B>Figure 13  Fixing the Buggy Title Bar</B></P>
<P><BR></P>
<PRE>////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// This program compiles with Visual C++ 4.1 on Windows 95
//
// MONITOR shows how to create a main window that is only a title bar,
// and how to prevent Windows from drawing size cursors in up/down or
// left/right directions
//
#include "StdAfx.h"
#include "TraceWin.h"

////////////////
// Remove this comment to see the original bug
//
//#define BUG

//////////////////
// Standard application class
//
class CMonitorApp : public CWinApp {
public:
   CMonitorApp() : CWinApp() { }
   virtual BOOL InitInstance();
};

//////////////////
// Monitor window is main frame
//
class CMonitorWindow : public CFrameWnd {
public:
   CMonitorWindow();
   afx_msg void OnTimer(UINT nIdEvent);
   afx_msg void OnPaint();
   afx_msg UINT OnNcHitTest(CPoint point);
   DECLARE_MESSAGE_MAP()   
};          

CMonitorApp theApp;

//////////////////
// Initialize app: create main window
//
BOOL CMonitorApp::InitInstance()
{
   MfxTraceInit();
   m_pMainWnd = new CMonitorWindow;
   m_pMainWnd-&gt;ShowWindow(m_nCmdShow);
   m_pMainWnd-&gt;UpdateWindow();
   return TRUE;
}   

BEGIN_MESSAGE_MAP(CMonitorWindow, CFrameWnd)
   ON_WM_TIMER()
   ON_WM_PAINT()
   ON_WM_NCHITTEST()
END_MESSAGE_MAP() 

//////////////////
// Create monitor window. Constructor actually creates window too.
//
CMonitorWindow::CMonitorWindow()
{
   // Compute size of window: smallest to display text
   CString s = _T("Memory: 100%% used [Phys:999999K total/999999K free]");
   CWindowDC dc(NULL);                            // screen DC
   CSize sz = dc.GetTextExtent(s, s.GetLength()); // size of text
   sz.cx += 2*GetSystemMetrics(SM_CXSMICON) +     // plus icon, close box,
      2*GetSystemMetrics(SM_CXSIZEFRAME);         // and sizable frame
   sz.cy += 2*GetSystemMetrics(SM_CYFIXEDFRAME);  // should be SIZEFRAME, but
                                                  // it doesn't matter
   CreateEx(WS_EX_TOPMOST, NULL, NULL,
#ifdef BUG
      // The buggy version uses WS_BORDER to disallow sizing,
      // resulting in a frame that's too narrow.
      WS_BORDER 
#else
      // The fix uses WS_THICKFRAME to get the fat border, but
      // disallows sizing by trapping WM_NCHITTEST
      WS_THICKFRAME
#endif
      | WS_CAPTION | WS_SYSMENU,
      CW_USEDEFAULT,
      CW_USEDEFAULT,
      sz.cx,
      sz.cy,
      NULL, 0);

   TRACE("Desired size = %d x %d\n", sz.cx, sz.cy);
   CRect rc;
   GetWindowRect(&amp;rc);
   TRACE("Actual size  = %d x %d\n", rc.Width(), rc.Height());
   GetClientRect(&amp;rc);
   TRACE("Client size  = %d x %d\n", rc.Width(), rc.Height());

   TRACE("Minimum window height = %d\n",  GetSystemMetrics(SM_CYMIN));
   TRACE("Caption height = %d\n",         GetSystemMetrics(SM_CYCAPTION));
   TRACE("Sizable border height   = %d\n",GetSystemMetrics(SM_CYSIZEFRAME));
   TRACE("Non-sizable border height = %d\n",
      GetSystemMetrics(SM_CYFIXEDFRAME));

   SetTimer((UINT) 1, (UINT) 7500, NULL);
   OnTimer(1); // first update immediately
}

//////////////////
// Update the window caption by getting new memory stats
//
void CMonitorWindow::OnTimer(UINT nIdEvent)
{ 
   MEMORYSTATUS ms;
   ms.dwLength = sizeof(MEMORYSTATUS);
   GlobalMemoryStatus(&amp;ms);
   CString s;
   s.Format(_T("Memory: %2ld%% used [Phys:%ldK total/%ldK free]"),
      ms.dwMemoryLoad,
      ms.dwTotalPhys&gt;&gt;10,
      ms.dwAvailPhys&gt;&gt;10);
   SetWindowText(s);
}

//////////////////
// Handle WM_NCCHITTEST:
// Re-map top/bottom to HTBORDER, and corners to HTLEFT or HTRIGHT
//
UINT CMonitorWindow::OnNcHitTest(CPoint point)
{
   UINT nRet = CFrameWnd::OnNcHitTest(point);
#ifndef BUG
   switch (nRet) {
   case HTTOP:
   case HTBOTTOM:
      return HTBORDER;
   case HTTOPLEFT:
   case HTBOTTOMLEFT:
      return HTLEFT;
   case HTTOPRIGHT:
   case HTBOTTOMRIGHT:
      return HTRIGHT;
   }
#endif
   return nRet;
}

//////////////////
// Paint client red to make it contrast more with frame/caption
//
void CMonitorWindow::OnPaint()
{
   CPaintDC dc(this);
   CRect rc;
   GetClientRect(&amp;rc);
   CBrush b(RGB(255,0,0)); // red
   CBrush* pOldBrush = dc.SelectObject(&amp;b);
   dc.PatBlt(rc.left, rc.top, rc.Width(), rc.Height(), PATCOPY);
   dc.SelectObject(pOldBrush);
}</PRE>
<P></P>
<P>Figure 14 shows the improved MONITOR <I>sans</I> racing stripes, and the TRACE output in Figure 15 confirms that CMonitorWindow in fact has a client area zero pixels high. The only drawback to my solution is that the border is thicker. What can I say? A fatty frame seems like a small price to pay for an easy solution to a thorny problem.</P>
<P><img src="20585.gif"></P>
<P><B>Figure 14  Nice title-bar monitor app</B></P>
<P><img src="20586.gif"></P>
<P><B>Figure 15  Non-buggy TRACE output</B></P>
<P><B>Q </B>I have a main window that shows a list of database items the user can select. Since the database field is a fixed length, my window has a fixed width, so I don't let the user size the window horizontally, only vertically. I handle WM_GETMINMAXINFO to prevent changing the width of the window, but Windows still displays the left/right size arrows when the user moves the mouse over the left and right borders. This seems wrong since the window can't be sized horizontally, and users may think it's a bug when they try to size and nothing happens. Is there some way to turn off the left/right cursor but keep the up/down one?</P>
<P><I>Alan Cardulo</I></P>
<P><B>A</B><B> </B>Yes, just handle WM_NCHITTEST as described in the answer to the previous question. If CFrameWnd::OnNcHitTest returns HTLEFT or HTRIGHT, your handler should return HTBORDER instead. Likewise, you should remap all the HT<I>xxx</I>TOP codes to HTTOP and all the HT<I>xxx</I>BOTTOM codes to HTBOTTOM.</P>
<P><I>To obtain complete source code listings, see page 5.</I></P>
<P>Have a question about programming in C or C++? Send it to Paul DiLascia at 72400.2702@compuserve.com</P></font></body></HTML>
