<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Thinner is Better</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<h2>Thinner is Better</h2>

<p>Thinner is better. No, this isn&#146;t an infomercial for the
Thighmaster. When it comes to Internet clients, thin is
definitely in. The interesting thing about the Internet is that
most of the data and logic that users want to access is not on
their machines. What do you send down to the client machine to
successfully access and deploy an application? Here, less is
more. Why? Let&#146;s review the fat client problem. </p>

<p>Practically all of the work done with Java to date uses a fat
client model. That is, the application logic, not just the
presentation layer, is downloaded to the client machine for
execution. Why is this a bad approach? First of all, by
downloading the application logic to the client, the logic is
displaced from the content the user is trying to access. This
violates the basic object-oriented model of data/logic
encapsulation. The application has to be split, code has to be
sent down to the client, and a network protocol has to be created
and maintained by the developer. The whole process involves
creating a distributed application, greatly increasing the
complexity of writing an application simply to move it to the
Internet. </p>

<p>Another problem with fat clients is the burden that the
application places on the client. If too much of the processing
burden takes place on the client machine or device, fewer types
of client applications and platforms will be able to access and
run that application. This will become a problem when Internet
appliances become popular. Cramming a large application into a
narrow-bandwidth pipe and into a limited-performance client
device inhibits your ability to move your application to the net.
The fat client approach is not appropriate when you cannot rely
on the power or capability of the client. So, if you&#146;ve got
visions of being able to access your Visual C++ application on a
Sega Genesis machine, a cellular phone, or a PDA device,
remember: the thinner the client, the fewer restrictions on
deploying your application. </p>

<p>Fat clients also suffer because of the bandwidth limitations
of the Internet. Since the application logic is on the client in
a fat client approach, large amounts of data must be moved to the
client machine before the application is able to process it for
the user. This movement of data puts an unnecessary bandwidth
burden on the network connection. This is problematic because the
Internet is largely a low-bandwidth, high-latency environment not
conducive to large amounts of network traffic. </p>

<p>Finally, the fat client inhibits collaboration. It becomes a
burden to replicate a common state across multiple machines when
the application object state is controlled in a distributed
fashion. In other words, if the client contains logic that
changes a shared object&#146;s state, that state must somehow be
updated on other clients currently looking at or interacting with
that object. This becomes a tremendous burden on the developer.
The problem can be remedied somewhat through an RPC or object
proxy solution, where multiple clients are accessing centralized
data at the server. But client synchronization and data access
control are typically left to the developer, since RPC-like
mechanisms don&#146;t deal with the replication issues associated
with collaborative applications. </p>

<p>RPC approaches also include the burden of deciding where to
split the application between the client and the server. The
developer must write a distributed application where some of the
code is Java, JavaScript, or VBScript and the rest is a server
object written in C++. Doesn&#146;t sound like a very scalable
development solution, does it? Besides having to decide which
parts of the application are where, the developer has to make
coding decisions about what data is changed, whether it is shared
or not, and so on. Some technologies attempt to abstract the
distributed nature of the application, often requiring the use of
a proprietary language, generally resulting in a loss of control
over performance issues. </p>

<p>When it comes to deploying applications with the Internet
architecture, thinner is better because it allows you to
distribute the presentation, not the application. Rapid
application access is possible since you do not have to download
the entire application. A minimal burden is placed on client
resources (or smaller dependency on hardware configuration), and
development complexity is reduced because you don&#146;t have to
write a distributed application. So the litmus test includes a
check for thin client Internet application deployment. </p>
</font></body>
</html>
