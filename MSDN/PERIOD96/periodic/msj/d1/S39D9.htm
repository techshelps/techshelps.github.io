<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Forms</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Forms</H2><P>A form provides a surface on which an object can initialize or display its own attributes. This notion of attributes isn't well understood, so let's start there. An attribute is an essential characteristic of a class of objects—something that distinguishes that class from other classes. For example, a name is an essential attribute of a person—all people have names. A salary distinguishes a particular subclass of persons (employees) from other persons, so it is an attribute of the Employee subclass.</P>
<P>An attribute is not a field of any class. In some cases, there might be a one-to-one mapping from an attribute to a field—a Name attribute might be stored internally in a single Text object called Name—but that's just an implementation detail. You should never expose that field as part of the public interface because you want to be able to change the way the attribute is stored internally without affecting the users of a class. The attributes should always be modified by sending a message to the object or by calling a member function. There might not even be an obvious mapping from an attribute to a set of fields; the attribute could be synthesized from information in several fields, and changing an attribute might modify all of these fields. Moreover, the attributes don't necessarily represent state information in an object. One of the main attributes of any class is the set of public member functions: the public interface exposed by the class. The state-related attributes (a window's color or an Employee's salary, for example) are just as much a part of the class's "contract" as the public-member function definitions. In other words, it's reasonable to know that all windows have a color associated with them. It's unreasonable to know how the color is represented inside the window.</P>
<P>So how does all this relate to forms? It's perfectly reasonable to ask an object to represent a particular attribute on a given form, but it's not acceptable to ask an object to represent one of its fields on the form because the field's type could change during maintenance. The attributes of a class are external knowledge—they're part of the fundamental definition of the class. The fields are not; the way that the attributes are represented is (or should be) immaterial. The main difficulty, then, is to separate the attribute from the internal representation. I've done this in the code by naming the attributes (with a String) and asking the objects for proxies that represent the attribute whose name is represented in the String. The attribute names are part of the public definition of the object. The object itself creates the proxy and decides how the proxy looks and behaves, but all proxies have a common interface which is—surprise—a User_interface.</P>
<P>Getting back to the notion that a Form is a surface on which an object's attributes are placed, imagine that you need to initialize an Employee whose Name attribute was stored internally in a Text field. The Text object, when passed an "interact" message, causes an edit control to pop up; any data typed into that edit control goes straight to the underlying Text object. If the Name attribute is stored internally as Text, you load the Employee's Name attribute essentially by telling the Employee to put the user interface associated with the Name directly on the surface of some form. In this example, the Text object serves as a proxy for the Name attribute—it represents the name attribute to the user. (A Proxy class will be used for this purpose in the actual implementation. Proxies will be discussed in more detail later.) The form literally provides nothing but a place for an Employee object to put this proxy. Information typed by the user goes directly from the user's fingers into the proxy—the Employee's Name string—with no intermediaries involved.</P>
<P>This is a very different architecture from your run-of-the-mill MFC CDialog. A CDialog might hook up a CEdit object to a CString member of the CDialog derivative, but you'd have to get the data from that CString into an Employee somehow. Here, the data goes directly from the person typing into the Employee object.</P>
<P>The Form, on the other hand, knows nothing about the objects displayed on it other than the names of the attributes that need to be displayed or modified and where the proxies should be placed on the window. The proxy itself is provided by the object that's using the Form (the Employee) and all proxies have exactly the same interface. Since the Form is completely decoupled from the object, you can make massive changes to the way that the attributes are represented inside the object without affecting the Form one bit. Similarly, the objects don't know where on the Form their attributes are being displayed (or even which attributes will be displayed), so changes to the Form don't affect the objects either. The only time you'll need to change a Form is <BR>when the set of attributes for a given class&nbsp;changes,&nbsp;which shouldn't be very often if you came up with the design before you started madly typing away.</P></font></body></HTML>
