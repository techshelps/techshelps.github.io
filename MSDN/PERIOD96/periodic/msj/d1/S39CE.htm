<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Why Multithread?</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Why Multithread?</H2><P>If you've programmed without using multiple threads for all this time, why should you complicate your life with multithreading now? Threads can improve the responsiveness, structure, and efficiency of your code. In addition, some programs containing concurrent threads may run significantly faster on multiprocessor computers under multiprocessor operating systems like Windows NT¨ since each thread could get full use of its own respective CPU. </P>
<P>Consider an application that monitors the performance and available capacity of a network file server. When the server is heavily loaded, it may take several minutes to get utilization measurements from a critical disk drive. A single-threaded application loop that checks the usage of network links, disk drives, CPU, and memory in sequence would be unable to display any data for minutes at a time. A multithreaded application, on the other hand, with one thread dispatched to measure each device and another thread to display the results, would be able to work around the overloaded drive and promptly update the figures for any devices that were able to report their status in a timely fashion. The result is that the total elapsed time until a set of tasks is accomplished can be the maximum of the individual task times rather than their sum, which can result in significant performance improvements. In cases like this, where partial results are meaningful and complete results may be difficult to obtain, multithreading can mean the difference between a useful application and a useless one.</P>
<P>Figure 1 illustrates the performance improvement that multithreading can provide in a situation where two lengthy disk queries must be performed.</P>
<P><img src="20587.gif"></P>
<P><B>Figure 1  Multithreading and Performance</B></P>
<P>Threads can also improve application responsiveness by managing the priorities of background tasks (a thread's priority can be changed while it is executing, incidentally). A spreadsheet function could, for instance, create a low-priority thread to recalculate in the background without affecting the speed of scrolling or data entry.</P>
<P>Multithreading provides a framework for managing the asynchronous activities in an application. Each thread can focus on the activities specific to that thread. Powerful synchronization mechanisms, like those provided with MFC, allow the coordination of these separate activities.</P>
<P>On the other hand, it's not wise to use threads indiscriminately. Each thread entails a certain amount of system overhead, so it's a good idea to use them only when they significantly improve your program.</P></font></body></HTML>
