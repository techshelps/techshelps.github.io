<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Additional Design Issues</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Additional Design Issues</H2><P>When designing an object-oriented application that uses multiple threads, several issues should be considered. You must decide where to localize control and visibility of each thread. Control of a thread means the ability to stop it, start it, synchronize it, and modify its behavior. Visibility concerns which objects can see the thread and its properties. If you're writing object-oriented code, you will want to localize thread control and visibility within a class as much as possible, and that is the approach I'll take in the code that follows. This allows you to hide some complexity and keep the fact that your object is multithreaded within the object. On the other hand, there are sure to be cases when threads need to be visible or controlled at the global level. These could be handled with a more traditional approach.</P>
<P>There are a number of design questions to answer regarding the construction of an object with an embedded thread. Will the thread be timer or event driven? How will you implement that? If the thread is timer driven, will the first execution be when the thread is started or after one delay cycle? What size stack does the thread need? Once you've made those decisions, you are ready to start designing your thread.</P>
<P>Care must be taken to ensure that an embedded thread is properly terminated when the containing object's destructor is called. This means that the thread must unblock, free up any resources that it is holding, and end before the destructor's code is completed. If the thread unblocks after the object is destroyed, a GP fault will likely occur.</P>
<P>You must also provide a means by which objects can control embedded threads. When one thread needs to change the behavior of another thread, it must do so in a clean fashion. This can include stopping or starting the second thread, or changing its priority or timer interval. </P></font></body></HTML>
