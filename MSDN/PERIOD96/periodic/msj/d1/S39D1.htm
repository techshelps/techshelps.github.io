<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How to Synchronize</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>How to Synchronize</H2><P>It's ironic that the word "synchronization" is used when discussing multithreading to mean almost exactly the opposite of what it means in everyday usage. Ordinarily, when two events (or two streams of media data, like sound and images) are synchronized, they are meant to occur, as nearly as possible, simultaneously. In a multi–threading context, synchronization is still about coordinating events  even though its purpose is often to avoid simultaneous use of shared resources.</P>
<P>Win32 provides a set of synchronization mechanisms. MFC wraps each of them into a parallel set of synchronization classes (see Figure 3). Their purpose is resource protection and interthread communication. All synchronization classes are derived from CSyncObject.</P>
<P><B>Figure 3  Synchronization Objects</B></P>
<P></P>
<P><BR></P>
<PRE>MFC Synchronization Object    Win32 Synchronization Mechanism    Purpose    Scope    Comments<BR></PRE>
<P>CCriticalSection    CRITICAL_SECTION    Resource    Within a    Usually the simplest, most</P>
<P>    data structure along    protection    process    efficient way to protect</P>
<P>    with EnterCritical-     via mutual        resources from simultaneous</P>
<P>    Section and related    exclusion.        access attempts. Lowest </P>
<P>    calls.            overhead mutual-exclusion </P>
<P>                mechanism.</P>
<P>                </P>
<P>CMutex    CreateMutex    Resource     Across     Use when you need to</P>
<P>        protection     processes    protect resources across</P>
<P>        via mutual         processes; for example, to </P>
<P>        exclusion.        grant exclusive access to</P>
<P>                global resources in a DLL (or</P>
<P>                 local COM component) shared</P>
<P>                by different apps.</P>
<P>                </P>
<P>CSemaphore    CreateSemaphore    Resource     Across    Keeps a count of the</P>
<P>        protection via     processes    number of threads with a </P>
<P>        "metered"         lock on a resource and</P>
<P>        access. Often         refuses additional locks</P>
<P>        used to limit         once the specified limit</P>
<P>        access to a small         is reached.</P>
<P>        set of system         </P>
<P>        resources for         </P>
<P>        performance or         </P>
<P>        other purposes.        </P>
<P>                </P>
<P>CEvent    CreateEvent    Wake-up calls to     Across    Examples include error-</P>
<P>        a thread waiting     processes    logging and processing input</P>
<P>        for work to be         from distributed sources.</P>
<P>        completed or         </P>
<P>        new input to         </P>
<P>        process.        </P>
<P></P>
<P>The synchronization classes are used in conjunction with classes that lock resources or wait for events. In MFC, a thread will call the Lock member of either a CSingleLock or CMultiLock object with a synchronization object as an argument. If the lock succeeds, then the thread continues. If the lock fails, the system suspends the thread until either the lock can succeed or a timeout period (specified as a parameter in the Lock call) has elapsed. At that point, the thread continues and proceeds in accordance with the result of the lock.</P>
<P>In Win32, most synchronization is accomplished with calls to WaitForSingleObject or WaitForMultipleObjects, using handles of mutexes, semaphores, or events as arguments. Alternatively, you can create a CRITICAL_SECTION data structure and use calls to InitializeCriticalSection, EnterCriticalSection, and LeaveCriticalSection to protect resources from simultaneous access. One handy example is the ReadFile function, which can obtain data from a disk, COM port, or pipe. ReadFile takes a structure containing an event handle as an argument. If you use a WaitForSingleObject call to block on that event, ReadFile will call SetEvent to notify your routine when data is available. WriteFile works in a similar fashion.</P>
<P>Threads can come into conflict if they attempt to simultaneously modify a virtualized physical resource, such as a file, an I/O port, or a CWnd. They can also conflict if they attempt to simultaneously modify a global or class data resource, such as a class static variable. The best solution is to wrap all shared resources in appropriate objects so that they become threadsafe. A threadsafe resource object is <BR>one that takes care of the details of synchronization internally, allowing threads with a need to access the resource to do so as if they were in a single-threaded environment (see Figure 4). </P>
<P><B>Figure 4  Synchronizing Paintballs</B></P>
<P><BR></P>
<PRE>class CThreadSafeWnd
{
public:
        CThreadSafeWnd() {}
        ~CThreadSafeWnd() {}
        void SetWindow(CWnd* pwnd) {m_pCWnd = pwnd;}
        void PaintBall(COLORREF color, CRect&amp; rc);
private:
        CWnd* m_pCWnd;
        CCriticalSection m_CSect;
};

void CThreadSafeWnd::PaintBall(COLORREF color, CRect&amp; rc)
{
        CSingleLock csl(&amp;m_CSect);
        if (csl.Lock());
        {
                // not necessary
                //AFX_MANAGE_STATE(AfxGetStaticModuleState( )); 
                CDC* pdc = m_pCWnd-&gt;GetDC();
                CBrush brush(color);
                CBrush* oldbrush = pdc-&gt;SelectObject(&amp;brush);
                pdc-&gt;Ellipse(rc);
                pdc-&gt;SelectObject(oldbrush);
                GdiFlush();   // don't wait to update the display
        }
}</PRE>
<P></P>
<P>Figure 4 is adapted from the Visual C++ sample application MTGDI. MTGDI uses Win32 calls to achieve synchronization, while my adaptation shows the same functionality using the MFC wrapper classes. In this application, multiple balls bounce around the screen (see Figure 5). Each ball is controlled and displayed by its own thread, which means that all threads need access to a common CWnd. To implement this, I created a new class, CThreadSafeWnd, which contains a pointer to the CWnd and a CCriticalSection object as private members. Threads draw their balls in the CWnd by calling the PaintBall member.</P>
<P><img src="20588.gif"></P>
<P><B>Figure 5  Each ball is a single thread</B></P>
<P>The first statement in CThreadSafeWnd–::PaintBall creates a CSingleLock object <BR>named csl, and associates the CCriticalSec–tion member with it via the constructor parameter.</P>
<P><BR></P>
<PRE>CSingleLock csl(&amp;m_CSect);
</PRE>
<P>The next statement tries to achieve a lock on csl.</P>
<P><BR></P>
<PRE>if (csl.Lock())
.
.
.
</PRE>
<P>If the csl object is locked by one thread, all other threads will be prevented from proceeding into the display update code until the lock is released (which happens automatically when control passes out of the PaintBall member and csl <BR>is destroyed).</P>
<P>Because csl.Lock is called without a parameter, the function will wait forever (or until it is stopped by external control) until it gets a lock. I could have provided a timeout parameter (in milliseconds) that would cause csl.Lock to return FALSE if a lock could not be obtained in that time. A thread with a strict time budget might need to do this. <BR>In systems that are not heavily loaded, though, the only reason a thread will wait a long time is because of a bug (or a deadlock situation, which is, after all, a type of bug).</P>
<P>You'll note in my example the following commented-out line:</P>
<P><BR></P>
<PRE>//AFX_MANAGE_STATE(AfxGetStaticModuleState( )); 
</PRE>
<P>CWinThread and MFC automatically create separate instances of MFC internal shared data. In certain cases, such as exported functions in a DLL, member functions of OLE/COM interfaces, and window procedures, it may be necessary to invoke this macro to ensure that state data is handled correctly.</P></font></body></HTML>
