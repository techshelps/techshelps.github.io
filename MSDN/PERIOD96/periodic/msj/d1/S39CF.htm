<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Where They're Useful</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Where They're Useful</H2><P>Certain applications seem made for multithreading. Monitoring applications are practically archetypes. In fact, necessity being the mother of invention, a surgical monitoring system for anesthesiologists that I helped develop for a client inspired this article. The system consists of a LAN-attached PC equipped with a sensor card and a touch-sensitive screen for data entry. Its main job is to present a number of graphs showing patient vital signs, types and quantities of drugs administered, and volumes of input and output fluids. It also displays the status of the network connection, which it uses to back up data. Most displayed items are read automatically from the sensor card, although information about drugs administered is entered by an assistant at a touchscreen or keyboard. </P>
<P>Classes given their own threads were designed to:</P>
<UL><LI>Graph current and historical data on the screen</LI><LI>Acquire data from the sensor card and filter, format, and write it to disk</LI><LI>Collect critical measurements every two sec-onds and display them numerically</LI><LI>Check on network availability and monitor the power to the sensor card</LI><LI>Back up data to the network</LI><LI>Log errors encountered by the other threads to disk</LI></UL><P>These threads were encapsulated in objects like CMultiThread to localize the details of managing multiple threads (see Figure 2 for a simplified example). The multithreading used in this application enabled all these activities to proceed roughly in parallel, allowed the system to be responsive to changes and user input, and resulted in good overall performance.</P>
<P><B>Figure 2  A CMultiThread Class Usage</B></P>
<P><BR></P>
<PRE>//////////////////////////////////////////////////////////////////


class CMultiThread: CWinThread 
{
public:
        CMultiThread();
        virtual ~CMultiThread();
protected:
        virtual void DoWork(){}        // override to do work on
                                       // 2nd thread
}</PRE>
<P>Client/server applications using distributed server data are also ideally suited for multithreading. A query of a distributed database can dispatch threads to each of the file servers containing a piece of the database, and another thread can display the unsorted results of the query to the user as they come in. This enables the user to start thinking about the results early, which can be quite useful—especially if the user is the person monitoring the EKG machine! For instance, if a flood of unexpected records is returned, the user can cancel the query at an early stage. Meanwhile, another thread can wait for all the query threads to complete to begin sorting the results. It's easy to see how this generalizes to Internet queries as well. This can be accomplished with low processor overhead, because thread execution can easily be suspended (blocked) until certain events cause the system to wake them up again. The thread does not have to periodically check to see whether it's time to run again.</P>
<P>Generalizing these examples, there are at least four types of activities where multithreading makes sense and can deliver performance benefits: </P>
<UL><LI>Scheduled (timer-driven) activities. Like the data-acquisition thread in my surgical information system, timer-driven activities are blocked until the system determines that the timeout period is up. Minimum times can be set with millisecond precision in Win32¨. </LI><LI>Event-driven activities. The threads may be triggered by signals from other threads. In the surgical monitoring system, the error-logging thread is inactive until one of the other threads alerts it to an error condition.</LI><LI>Distributed activities. When data must be collected from (or distributed to) several computers, it makes sense to create a thread for each request so that these naturally asynchronous tasks can proceed in parallel, as in the example of a query of distributed server data. </LI><LI>Prioritized activities. To improve a program's responsiveness, it's sometimes useful to divide its work into a high-priority thread for the user interface and a lower-priority thread for background work. In the surgical information system, the user-interface thread that enables the surgical assistant to enter information about administered drugs is a high-priority thread to preserve its responsiveness, while the network-backup thread has a lower priority.</LI></UL></font></body></HTML>
