<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Hide your Data and Make Objects Responsible for Their Own User Interfaces, Part II</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H1>Hide your Data and Make Objects Responsible for Their Own User Interfaces, Part II</H1><P>Allen Holub</P>
<P><I>Allen Holub is a programmer, consultant, and trainer specializing in C++, object-oriented design, and Microsoft operating systems. He can be reached at allen@holub.com or http://www.holub.com.</I></P>
<P>The central idea of object-oriented (OO) design is data hiding—the contents of one class should be unknown to all other classes. How can you initialize, modify, or display an object if you have no idea what's inside it? An MFC CDialog, for example, violates the data-hiding rule right and left because, by nature, the CDialog must export data to a separate object. The main problem is maintenance. Changes to one class definition shouldn't ripple to other class definitions. A change should be localized; it should be possible to make radical changes to a class definition, and as long as the public interface is unaffected, the rest of the program should be unaffected. Designing a public interface that works in this manner is difficult, I might add, but is the central theme of all OO design methodologies.</P>
<P>This article is the second of a three-part series that began with "Hide your Data and Make Objects Responsible for Their Own User Interface" (<I>MSJ,</I> August 1996). That article discussed the problems of using CDialog derivatives to display an Employee object's attributes. Changes to the Employee class affect every CDialog derivative that's used to transfer information from the user to an Employee or vice versa, and there could easily be twenty or thirty such CDialog derivatives with definitions scattered all over the program. Moreover, these same CDialog derivatives might also be used to initialize or display more than one high-level object, and there might be complex interactions between the high-level objects. (An HR_Department object might be used to validate the data in the Employee object, for example.) Consequently, a change to the original Employee could easily affect all the other objects that are indirectly coupled to it via the shared CDialog. When you consider all the coupled classes, the dust blown up by making a seemingly simple change to the Employee class could take weeks to settle. The technical term that describes this architecture is Unmaintainable Mess.</P>
<P>The solution is to give each object control over its own user interface. You shouldn't get data from somewhere (like a CDialog) and then put it somewhere else (like an Employee); rather, you should tell the Employee to initialize itself interactively from the user or to display itself on the screen. A very simple object, such as the Text class I developed in Part I, can have an interface just that simple because the Text class has only one attribute to display or load. An Employee class is another matter, though. The problem, of course, is that an object with several attributes such as an Employee might need to be displayed in different ways at different times, and the information that comprises an Employee might not be available all at once on a single input screen.</P>
<P>Though the simple Text class interface from Part I doesn't solve the general problem, it does provide a basic building block for the general solution. Text implemented a generic user interface by deriving from an abstract User_interface class. User_interface defined three pure virtual methods: hide, display, and interact. The latter two are passed a pointer to a window on which to display themselves and a rectangle that specifies the position inside the window. (The position was defined by simple pixel-level—MM_TEXT—coordinates, but that's easy enough to change.) A User_interface object, when passed a "display" message, just displays itself on the screen. An "interact" message causes it to display itself in a way that permits the user to input directly to the object. A Text object, for example, creates an edit control and automatically transfers all characters typed into the edit control directly to the Text object's internal buffer as they are typed. Finally, the "hide" message causes the object to temporarily disappear. (The actual Windows¨ UI objects that display the User_<BR>interface object are probably destroyed as a side effect of a hide request, but they could just as well be hidden without being destroyed.)</P>
<P>The point of abstracting the three methods just described into a base class, rather than just implementing them in the Text class itself, is that pretty much any class that has only one externally visible attribute can be handled using that same simple interface. The actual UI can get quite elaborate. The interact method for the Date object, for example, might draw an entire calendar and let you pick a date by clicking on the face of the calendar. Derivation can also be used to provide several different display methodologies. A simple Date might use a simple edit control-based UI, while a Calendar class that derives from Date could override the display and interact virtual methods to use the more elaborate calendar-style interface.</P>
<P>An abstract User_interface base class sets things up so that you can write general-purpose functions that can display (or initialize) any object that implements a User_interface without having to know exactly what sort of object that you're dealing with. You could, for example, define a Form object that could display any number of fields—objects that implemented a User_interface—without having to know anything about the actual types of the fields. A simple Form could just keep a linked list of such objects and display them in sequence, for example. This is exactly where I'm headed in this part of the series. I'll use a more real-world architecture than a simple linked list, however.</P></font></body></HTML>
