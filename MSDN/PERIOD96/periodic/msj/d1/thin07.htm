<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>State Change-based Client/Server Connection </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<h2>State Change-based Client/Server Connection </h2>

<p>Available bandwidth has always been a limiting factor for
effective deployment of applications over the network, so the
litmus test should include an examination of the bandwidth
impact. </p>

<p>Where do you divide an application to ensure that the minimum
amount of presentation logic is sent to the client and that the
application runs optimally over the net? The division
shouldn&#146;t take place at the event level, since many more
events occur on the client than are necessary to maintain an
application object&#146;s state. Passing events from one side to
the other causes the application to create many data round trips
before users see the results of their interaction on the screen. </p>

<p>For example, many events happen with a scroll bar interactor,
but the important piece of information is the thumb position
produced through user interaction. If the scroll bar controls the
value of a numeric data member of a C++ object, then only the
final scroll bar thumb position value needs to be sent across the
network to update the server-side object. This transfer of state
information is the minimum information exchange necessary to
maintain synchronized application state over a network. To
minimize state-transfer bandwidth, you need to send only that
part of an application object&#146;s semantic state that is
currently relevant to the presentation. A core question of GUI
research over the last decade has been how best to implement the
state transfer. </p>

<p>A model is needed that utilizes the state-based nature
intrinsic to object-oriented development. Such a model is
essential for optimal communication between the server
application and the many clients that can simultaneously access
that application. Ideally, the implementation of C++ objects need
not be involved directly with this state-change notification
scheme. Object state management would then remain external to the
application object in the same way a client would access the
services of an object without the object being concerned with the
details of how it is being used. This approach is appealing
because it is not cluttered with unnecessary dependencies such as
how the object is used, deployed, accessed, and so on. </p>
</font></body>
</html>
