<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Runtime Binding</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<h2>Runtime Binding</h2>

<p>Data change notification is not quite enough. Suppose that
clients want to modify the object during program execution
without generating code. Code generation complicates the task of
attaching multiple heterogeneous clients to server objects. For
maximum flexibility in attaching collaborative clients to an
object over the Web, a runtime binding mechanism can be added to
C++ object access. C++ runtime binding doesn&#146;t degrade the
general performance of the running object itself. Remember the
advantages of having meta data information available to describe
the structure of classes? Well, it can also help automate the
runtime binding of compiled C++ classes. The meta data of each
class that is to be accessible over the Internet can be used to
generate a C structure that enables lookup and access to data
members of an object by name (for flexibility) and by index (for
speed). Of course, the name can be resolved to an offset index at
runtime as an optimization. </p>

<p>In Figure 7 the class represents color, which contains red,
green, and blue components. Runtime binding access on member
functions is also possible, which can further separate the client
presentation from the structure of the object. The runtime
binding approach allows you to preserve the performance
capability of the C++ object itself while allowing remote dynamic
access to the object. All this is possible without introducing
appreciable complexity for the class implementor (since the
runtime binding structure can be automatically generated using
the meta data of the class). This lets you focus on the business
logic without concern for the details of making the object&#146;s
state externally viewable. </p>

<dl>
    <dt><b>Figure 7 Using Meta Data with Runtime Binding</b></dt>
    <dd><pre><span>class Color {
public:
 Color(int r, int g, int b) : red(r), green(g), blue(b) {}
 int getRed() { return red; }
 int getGreen() { return green; }
 int getBlue() { return blue; }
 void setRed(int r) { red = r; }
 void setGreen(int g) { green = g; }
 void setBlue(int b) { blue = b; }

private:
 // &#145;callback enabled” data members
 IntData red;
 IntData green;
 IntData blue;
};</span></pre>
    </dd>
</dl>
</font></body>
</html>
