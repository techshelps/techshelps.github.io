<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Callbacks</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">

<h2>Callbacks</h2>

<p>Callbacks are functions called when data changes. C++ provides
hooks for allowing functions to be called when data changes in a
way that is transparent to the implementor of a class. Suppose
the following class represents a way to store and manipulate an <i>x</i>,
<i>y</i> position: </p>

<pre><span>class Point {
public:
 Point(int x, int y) : xPos(x), yPos(y) { }
 void offset(int x, int y) { xPos += x; yPos += y; }
 void setXPos(int x) { xPos = x; }
 void setYPos(int y) { yPos = y; }
 int getXPos() { return xPos; }
 int getYPos() { return yPos; }
 
private:
 int xPos;
 int yPos;
};</span></pre>

<p>The xPos and yPos data members represent the actual
information of the Point class. These data members can have
&#145;guarded” or write barrier access (an Eiffel language term)
or they can be &#145;computed fields” (as in Smalltalk). Each of
these implementations fires a callback when data changes. Another
technique, C++ operator overloading, allows code to be executed
whenever an explicit assignment to the data member is performed. </p>

<p>Let&#146;s first introduce a new class and then modify the
Point class shown above to include write barrier capability. The
following IntData class represents a partial encapsulation of the
int type: </p>

<pre><span>class IntData {
public:
 Int(int d) { data = d; }
 int operator () { return data; }
 operator = (IntData &amp;d) {}
 operator = (int d) { }
 
 addCallback(void f(int));
 removeCallback(void f(int));
protected:
 dataChanged()
private:
 int data;
};
</span></pre>

<p>Now, let&#146;s modify the Point class to have
callback-enabled data members: </p>

<pre><span>class Point {
public:
 Point(int x, int y) : xPos(x), yPos(y) { }
 void offset(int x, int y) { xPos += x; yPos += y; }
 void setXPos(int x) { xPos = x; }
 void setYPos(int y) { yPos = y; }
 int getXPos() { return xPos; }
 int getYPos() { return yPos; }
 
private:
 IntData xPos;  // CHANGED
 IntData yPos;  // CHANGED
};
</span></pre>

<p>Notice that the only code in the class that needed to change
(as indicated with comments) is the declaration representation of
the Point data members, using IntData as the type. Using this
mechanism, when a Point object&#146;s state changes, clients
external to the class can be notified. You&#146;ll see a little
later that client access to data members can be reasonably
restricted to a limited set of clients, for example, clients that
visually represent the object remotely. Not just anyone can
access the internal state of an object. </p>

<p>This capability allows callbacks to be associated with the
state of objects. For brevity, many of the details of
encapsulated access have been left out. This method can be
applied to C++ object pointers, arrays, reference-counted
objects, and so on. This approach to data change notifi≠cation
contributes to a dramatic reduction in the complexity associated
with connecting a remote thin client user interface to the object
itself. Data members, then, use a &#147;plug and socket&#148;
access approach that allows the representation of the object to
be external to the implementation of the class. </p>
</font></body>
</html>
