<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Fill 'er Up</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Fill 'er Up</H2><P>A Form that's populated with Fields is only that—a Form. To display it you must first fill it in by attaching proxies for the attributes to the Form. Again, think of the Form as a surface on which objects can display themselves.</P>
<P>The process of attaching Fields in the Form to actual runtime objects (and then activating them) is shown in Figure 2. (I didn't use a diagram like this one in Part I because the model was so simple that an extra diagram wasn't necessary. Here it adds some clarity, though.) This diagram shows you three scenarios that demonstrate the interaction between objects in the runtime system while certain tasks are being performed. (The tasks are sometimes called use cases.) I've used a Booch-style message-trace diagram for the scenarios. The vertical lines represent actual runtime objects (not classes, which are compile-time things). The horizontal arrows represent messages being passed between objects. The message-trace diagram shows you what's actually happening in the system at runtime in temporal order. Time gets later as you move downward, so the "put yourself on this form" message is sent before the "put me on you" message. The vertical lines widen to become boxes to indicate that the object is active. This is a little different from simply indicating that you're in a function body, though it means that too. For example, the Element's put_yourself_on_this_form method sends a put_me_on_you message to the associated Form. The initialization process is not complete until the Form sends one or more give_me_ a_proxy_for(id) messages back to the Element, so the Element stays active until these messages are processed.</P>
<P><img src="20600.gif"></P>
<P><B>Figure 2  The Dynamic Model</B></P>
<P>So here you are at runtime with a Form of some sort and a bunch of objects that need to use the Form to interact with a user. You start populating the Form with proxies by asking the Form to display various Form::Element objects, using the Form::put_me_on_you message (which is passed a pointer to the element and a string holding the class name). For example, you could cause an Employee to attach itself to the Form created earlier and then activate the Form like this:</P>
<P><BR></P>
<PRE>class Employee : public Form::Element {/*...*/};

Employee homer;
the_form-&gt;put_me_on_you("Employee", homer);
the_form-&gt;interact();
</PRE>
<P>All objects that want to use a form for I/O must derive from Form::Element. The Form now asks its Fields whether they represent an attribute of that class by passing them an if_in_class_return_id message. The message handler returns a reference to a String that contains the attribute ID if the field indeed represents an attribute of the indicated class, otherwise it returns NULL. Note that the message takes the form "if you are a member of this class, do something," not "give me your class name so I can decide what to do." This organization is another example of what I mean by a class hiding the representation details.</P>
<P>If a Field indicates that it's associated with the requesting Element, the Form turns around and asks the Element for a Form::Proxy to use for the Field. The user interacts directly with this Proxy; the Field just provides a place for the Proxy to live. The Proxy class is an example of what's known in the OO world as the Decorator pattern—a class that extends the functionality of another class using containment rather than derivation. A Proxy is essentially a User_interface object that also implements the release message (discussed below). I didn't want to implement a Proxy by deriving from User_interface because I wanted any generic User_interface object to be useable as a Proxy. I didn't want to require the user of my forms package to derive from Proxy rather than directly from User_interface just so the interface object could be used on a Form. The Proxy then eats a User_interface object and exposes all the contained-object's functionality by exposing a member function for each public member function of the contained User_interface object. The need to provide a container function for every public containee function is one of the main disadvantages to the Decorator pattern (as anybody who's implemented an OLE object knows—OLE uses the Decorator as a poor substitute for true derivation). The overhead of relaying the messages is also a problem; the decorator's versions of the functions can't be inline because they're virtual overrides.</P>
<P>Since I also want a Proxy to behave as a User_interface, I've derived it from User_interface and provided virtual overrides of the User_interface virtual members that do nothing but call the equivalent functions in the contained User_interface object. This way a Proxy can effectively be used just as if it had derived from User_interface, even though the user of the forms package doesn't need to derive from Proxy.</P>
<P>A Proxy is manufactured by the Element using new because it will usually be destroyed by the Field, not the Element. The Proxy constructor (referring back up to Figure 1) is passed an object that implements a User_interface and either a pointer to the Element that created the Proxy or NULL. This last parameter solves a potentially nasty memory-management problem. The problem is that a Proxy could reference an actual Field in an object, or it could reference an object that the Element creates solely for display on the Form. For example, the Employee's Name attribute can be represented internally by a simple Text object, which implements a User_interface. If the Employee object just passes a pointer to its name field to the Proxy constructor, the user will effectively be typing a name directly into the associated Field of the Employee. The User_interface object can also be created by the Form when it manufactures the Proxy, however. For example, the Proxy used for entering the name might be a single string, but the name might be stored in the Employee object as first_name, middle_name, and last_name fields. The Employee can handle this situation by manufacturing a single Text object for data-entry purposes, passing it to the Proxy, and once the user finishes with it, parsing the Text into the three fields that actually represent the attribute internally.</P>
<P>There are two problems. First, how does the Form notify the Element that it's time to parse the Proxy? Second, <BR>how should the Proxy's destructor work? If you're dealing with a synthesized attribute that was being used for some sort of display purpose, no interaction with the Element is required when the Form shuts down, and it would be convenient if the Proxy just passed the User_interface object to delete. On the other hand, the Proxy couldn't very well do this if the User_interface object was actually a field in the Element whose address was passed to the Proxy constructor.</P>
<P>The problem is solve with the notify_me_rather_<BR>than_destroy_proxy argument to the Proxy constructor. If the argument is NULL, the Proxy deletes its User_interface object when the Proxy is released by the Field. If the argument isn't NULL, the Proxy calls the original Element's release_proxy function, passing a pointer to itself as an argument. Here's the sequence from the "release proxies" scenario in Figure 2. You either pass a release_proxies message to a Form or the Form goes out of scope or is passed to delete. (The Form's destructor calls release_proxies.) The Form then sends a release_proxy message to each of its Fields, which in turn send release messages to their proxies. This message does one of two things: if the Proxy constructor was originally passed a NULL notify_me_rather_than_destroy_proxy argument, the Proxy object first passes its User_interface pointer to delete, and then calls</P>
<P><BR></P>
<PRE>delete this;
</PRE>
<P>effectively freeing the Proxy too; if the argument wasn't NULL, Proxy::release passes a release_proxy(this) message to the Element that originally created the Proxy. The Element can then decide what to do with the Proxy and its contained User_interface object. In the case of the Employee object passing the address of one of its Fields to the original Proxy constructor, the Employee would just pass the Proxy to delete in response to receiving a release_proxy message. The Proxy destructor doesn't do anything, so that's all that needs doing.</P>
<P>Just in case the Element wants to derive a class from Proxy to do something complicated, I've made the Proxy's pointer to the User_interface object a protected, rather than private, member of the class. I usually think that protected-member data isn't a great idea, but in the current case, the Proxy gets the User_interface object from the same class that would be creating the derived class, so the maintenance problems are relatively minor.</P>
<P>Getting back to the Form-loading process in Figure 2, the Element passes the Proxy back to the Form when asked, and the Form attaches the Proxy to the associated Field. The other objects that use the same Form for I/O are then attached to the Form in the same way as the first such object, by calling put_yourself_on_this_form.</P>
<P>Now it's time either to display the Form or to use it for user input. Looking back at Figure 1, you'll notice that the Form itself implements a User_interface (it derives from User_interface), so you make the Form visible on the screen just as you would any other User_interface object—by passing it a display or interact message. The Window and Rect arguments to display and interact can specify a window on which to draw the Form (and the window size). You can also pass a NULL window pointer, in which case a pop-up window is created to hold the Form and the window's size is exactly large enough to hold all the Fields. The rect argument will be ignored in this case. Once the parent window is created, the Form relays the display or interact message all the way down to the User_interface elements associated with the Proxies. The User_interfaces then display themselves as subwindows to the Form's window. Since the Field's size is implicit, the Field's implementation of the display and interact handlers ignores the Rect argument.</P>
<P>There are two more loose ends. First, since a Form implements a User_interface, it can be encapsulated in a Proxy. That is, an Element on a Form can use another Form to represent itself. Second, it's never an error to ask a Form to display itself, even if Proxies are not attached to all the Fields. The Fields without proxies are just not displayed. This lets you do things like have two different objects display themselves at the same position on the same Form, provided that only one of them attaches itself to the Proxy at any given moment. The Element::remove_me_from_you message is provided to make this behavior possible—it works essentially like put_me_on_you except that it releases all Proxies.</P></font></body></HTML>
