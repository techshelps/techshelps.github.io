<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Derived Classes</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF"><FORM NAME="x"><OBJECT CLASSID="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016" NAME="iv"></OBJECT></FORM>
<font face="verdana,arial,helvetica" size="2">
<H2>Derived Classes</H2><P>Figure 9 demonstrates how CMultiThread hides the messy multithreading details in classes derived from CMultiThread. I've derived CAsynchGarbageCollector, a class to collect garbage, from CMultiThread. When another object calls the CollectGarbage member, CAsynchGarbageCollector adds the buffer pointed to by pBuf to the garbage list, using a CCriticalSection to synchronize access to m_BuffList. Then, if there are enough items in the garbage list to exceed the value specified by the variable CleanTime, it sets CMultiThread's work event, which lets DoWork collect the garbage (an example of DoWork execution on demand rather than timed execution). CollectGarbage runs in the thread of the calling object, while DoWork runs asynchronously in the embedded thread.</P>
<P>Figure 9  A Derived CMultiThread Class</P>
<P><BR></P>
<PRE>// Asynch.h : header file
//

/////////////////////////////////////////////////////////////////////////////

class CGarbageObject : public CObject
{
public:
        void* m_pGarbage;
};


/////////////////////////////////////////////////////////////////////////////
const int CleanTime = 5;                        // garbage cleanup limit

class CAsynchGarbageCollector : public CMultiThread
public:
        CAsynchGarbageCollector();
        virtual ~CAsynchGarbageCollector() {};

        void CollectGarbage(void* pBuf);        // get the garbage

protected:
        CObList m_BuffList;                     // garbage list
        CCriticalSection m_CritSect;            // arbitrator for garbage list
        virtual void DoWork();                  // release garbage here
};


// Asynch.cpp : implementation file
//

#include "stdafx.h"
#include "multithrd.h"
#include "asynch.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////

CAsynchGarbageCollector::CAsynchGarbageCollector()
{
        CreateThread();
}

void CAsynchGarbageCollector::CollectGarbage(void* pBuf)
{        
        CGarbageObject* pObj = new CGarbageObject;
        ASSERT(pObj);
        pObj-&gt;m_pGarbage = pBuf;                // create fresh garbage object

        CSingleLock csl(&amp;m_CritSect);           // be safe
        csl.Lock();                             // when accessing garbage list

        m_BuffList.AddTail(pObj);               // add the garbage to the list
        int count = m_BuffList.GetCount();
        csl.Unlock();                                                        

        // if it's time, release the garbage on the other thread
        if (count &gt;= CleanTime)
                GetEvent()-&gt;SetEvent();
}


void CAsynchGarbageCollector::DoWork()
{
        if (!m_BuffList.IsEmpty())
        {
                CSingleLock csl(&amp;m_CritSect);   // be safe
                csl.Lock();                     // when accessing garbage list

                while (!m_BuffList.IsEmpty())
                {
                        // We could check the buffers before release
                        // Now remove the garbage
                        delete 
                          (static_cast&lt;CGarbageObject*&gt; 
                           (m_BuffList.GetHead()))-&gt;m_pGarbage;
                        delete m_BuffList.RemoveHead();// and the list entry
                }

                csl.Unlock();                                                        
        }
        // Now we could defragment the released buffers
}</PRE></font></body></HTML>
