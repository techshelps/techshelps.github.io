<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>InitializeSecurityContext</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_initializesecuritycontext"></a>InitializeSecurityContext</h1>
<p>
The <b>InitializeSecurityContext</b> function initiates the outbound security context from a credential handle. The function establishes a security context between the client application and a remote peer. <b>InitializeSecurityContext</b> returns a token that the client must pass to the remote peer, which in turn submits it to the local security implementation through the <a href="issp_2i2c.htm"><b>AcceptSecurityContext</b></a> call. The token generated should be considered opaque by all callers.</p>
<pre><code><b>SECURITY_STATUS InitializeSecurityContext(
  PCredHandle</b><i> phCredential</i><b>,  </b>// handle to the credentials
<b>  PCtxtHandle</b><i> phContext</i><b>, </b>// handle of partially formed context
<b>  SEC_CHAR *</b><i> pszTargetName</i><b>,  </b>// name of the target of the context
<b>  ULONG</b><i> fContextReq</i><b>,     </b>// required context attributes
<b>  ULONG</b><i> Reserved1</i><b>,       </b>// reserved; must be zero
<b>  ULONG</b><i> TargetDataRep</i><b>,   </b>// data representation on the target
<b>  PSecBufferDesc</b><i> pInput</i><b>, </b>// pointer to the input buffers
<b>  ULONG</b><i> Reserved2</i><b>,       </b>// reserved; must be zero
<b>  PCtxtHandle</b><i> phNewContext</i><b>,  </b>// receives the new context handle
<b>  PSecBufferDesc</b><i> pOutput</i><b>,  </b>// pointer to the output buffers
<b>  PULONG</b><i> pfContextAttr</i><b>,  </b>// receives the context attributes
<b>  PTimeStamp</b><i> ptsExpiry   </i>// receives the life span of the security 
                         // context
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>phCredential</i></dt>
<dd>
Handle to the credentials to use to create the context. The client retrieves this handle by calling the <b>AcquireCredentialsHandle</b> function.</dd>
<dt>
<i>phContext</i></dt>
<dd>
Pointer to a <b>CtxtHandle</b> structure. On the first call to <b>InitializeSecurityContext</b>, this pointer is NULL. On the second call, this parameter is the handle to the partially formed context returned in the <i>phNewContext</i> parameter by the first call.</dd>
<dt>
<i>pszTargetName</i></dt>
<dd>
Pointer to a null-terminated string that indicates the target of the context. The name is security-package specific. </dd>
<dt>
<i>fContextReq</i></dt>
<dd>
A set of bit flags that indicate the requirements of the context. Not all packages can support all requirements. For a description of the various attributes, see <a href="issp_2bcj.htm">Context Requirements</a>. This parameter can include any of the following values:
<p>
ISC_REQ_DELEGATE<br>
ISC_REQ_MUTUAL_AUTH<br>
ISC_REQ_REPLAY_DETECT<br>
ISC_REQ_SEQUENCE_DETECT<br>
ISC_REQ_CONFIDENTIALITY<br>
ISC_REQ_USE_SESSION_KEY<br>
ISC_REQ_PROMPT_FOR_CREDS<br>
ISC_REQ_USE_SUPPLIED_CREDS<br>
ISC_REQ_ALLOCATE_MEMORY<br>
ISC_REQ_USE_DCE_STYLE<br>
ISC_REQ_DATAGRAM<br>
ISC_REQ_CONNECTION<br>
ISC_REQ_CALL_LEVEL<br>
ISC_REQ_EXTENDED_ERROR<br>
ISC_REQ_STREAM<br>
ISC_REQ_INTEGRITY

</dd>
<dt>
<i>Reserved1</i></dt>
<dd>
Reserved value; must be zero. </dd>
<dt>
<i>TargetDataRep</i></dt>
<dd>
Indicates the data representation (byte ordering, and so on) on the target. The constant SECURITY_NATIVE_DREP may be supplied by the transport application, indicating that the native format is in use.</dd>
<dt>
<i>pInput</i></dt>
<dd>
Pointer to a <a href="issp_9mar.htm"><b>SecBufferDesc</b></a> structure that contains pointers to the buffers supplied as input to the package. The transport application should provide as much input as possible, although some packages may not be interested in the nonsecurity portions. This parameter is optional, particularly on the first call to <b>InitializeSecurityContext</b>.</dd>
<dt>
<i>Reserved2</i></dt>
<dd>
Reserved value; must be zero. </dd>
<dt>
<i>phNewContext</i></dt>
<dd>
Pointer to a <b>CtxtHandle</b> structure. On the first call to <b>InitializeSecurityContext</b>, this pointer receives the new context handle. On the second call, this can be the same as the handle specified in the <i>phContext</i> parameter.</dd>
<dt>
<i>pOutput</i></dt>
<dd>
Pointer to a <b>SecBufferDesc</b> structure that contains pointers to the buffers that receive the output data. If a buffer was typed as READWRITE in the input, it will be there on output. The system will allocate a buffer for the security token if requested (through ISC_REQ_ALLOCATE_MEMORY), and fill in the address in the buffer descriptor for the security token.</dd>
<dt>
<i>pfContextAttributes</i></dt>
<dd>
Pointer to a variable that receives a set of bit flags indicating the attributes of the established context. For a description of the various attributes, see <a href="issp_2bcj.htm">Context Requirements</a>. This value can include any of the following flags.
<p>
ISC_RET_DELEGATE<br>
ISC_RET_MUTUAL_AUTH<br>
ISC_RET_REPLAY_DETECT<br>
ISC_RET_SEQUENCE_DETECT<br>
ISC_RET_CONFIDENTIALITY<br>
ISC_RET_USE_SESSION_KEY<br>
ISC_RET_USED_COLLECTED_CREDS<br>
ISC_RET_USED_SUPPLIED_CREDS<br>
ISC_RET_ALLOCATED_MEMORY<br>
ISC_RET_USED_DCE_STYLE<br>
ISC_RET_DATAGRAM<br>
ISC_RET_CONNECTION<br>
ISC_RET_INTERMEDIATE_RETURN<br>
ISC_RET_CALL_LEVEL<br>
ISC_RET_EXTENDED_ERROR<br>
ISC_RET_STREAM<br>
ISC_RET_INTEGRITY
</dd>
<dt>
<i>ptsExpiry</i></dt>
<dd>
Pointer to a <b>TimeStamp </b>variable that receives the expiration time of the context. The security provider should always return this value in local time. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is one of the following success codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=52%>Value</th>
<th align=left width=48%>Meaning</th>
</tr>
<tr valign=top>
<td width=52%>SEC_E_OK</td>
<td width=48%>The security context was successfully initialized. There is no need for another <b>InitializeSecurityContext</b> call, and no response from the server is expected. </td>
</tr>
<tr valign=top>
<td width=52%>SEC_I_CONTINUE_NEEDED</td>
<td width=48%>The client must send the output token to the server, and then pass the token returned by the server in a second call to <b>InitializeSecurityContext</b>. </td>
</tr>
<tr valign=top>
<td width=52%>SEC_I_COMPLETE_NEEDED</td>
<td width=48%>The client must finish building the message, and then call the <b>CompleteAuthToken</b> function.</td>
</tr>
<tr valign=top>
<td width=52%>SEC_I_COMPLETE_AND_CONTINUE</td>
<td width=48%>The client must call <b>CompleteAuthToken</b>, then pass the output to the server, and finally make a second call to <b>InitializeSecurityContext</b>. </td>
</tr>
</table><br>
<p>
If the function fails, the return value is one of the following error codes.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Value</th>
<th align=left width=51%>Meaning</th>
</tr>
<tr valign=top>
<td width=49%>SEC_E_INVALID_HANDLE</td>
<td width=51%>The handle passed to the function is invalid.</td>
</tr>
<tr valign=top>
<td width=49%>SEC_E_TARGET_UNKNOWN</td>
<td width=51%>The target was not recognized.</td>
</tr>
<tr valign=top>
<td width=49%>SEC_E_LOGON_DENIED</td>
<td width=51%>The logon failed.</td>
</tr>
<tr valign=top>
<td width=49%>SEC_E_INTERNAL_ERROR</td>
<td width=51%>The Local Security Authority cannot be contacted.</td>
</tr>
<tr valign=top>
<td width=49%>SEC_E_NO_CREDENTIALS</td>
<td width=51%>No credentials are available in the security package.</td>
</tr>
<tr valign=top>
<td width=49%>SEC_E_NO_AUTHENTICATING_AUTHORITY</td>
<td width=51%>No authority could be contacted for authentication.</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
The <b>InitializeSecurityContext</b> function is used by a client to initialize an outbound context. </p>
<p>
For a two-leg security package, the calling sequence is as follows: 
<ol>
<li>
The client calls the function with <i>phContext</i> set to NULL and fills in the buffer descriptor with the input message. </li>
<li>
The security package examines the parameters and constructs an opaque token, placing it in the TOKEN element in the buffer array. If the <i>fContextReq</i> parameter includes the ISC_REQ_ALLOCATE_MEMORY flag, the security package allocates the memory and returns the pointer in the TOKEN element.</li>
<li>
The client sends the token returned in the <i>pOutput</i> buffer to the target server. The server then passes the token as an <i>input argument</i> in a call to the <a href="issp_2i2c.htm"><b>AcceptSecurityContext</b></a> function. </li>
<li>
AcceptSecurityContext may return a token, which the server sends to the client for a second call to <b>InitializeSecurityContext</b>.</li>
</ol>
<p>
For a three-leg (mutual authentication) security package, the calling sequence is as follows: 
<ol>
<li>
The client calls the function as described earlier, but the package will return the SEC_I_CONTINUE_NEEDED success code. </li>
<li>
The client then sends the output token to the server and waits for the server's reply. </li>
<li>
Upon receipt of the server's response, the client calls <b>InitializeSecurityContext</b> again, with <i>phContext</i> set to the handle that was returned from the first call. The token received from the server is supplied in the <i>pInput </i>parameter. If the server has successfully responded, then the security package will respond with success, otherwise, it will invalidate the context.</li>
</ol>
<p>
To initialize a security context, more than one call to this function may be required, depending on the underlying authentication mechanism as well as the "choices" specified in the <i>fContextReq </i>parameter<i>.</i> </p>
<p>
The <i>fContextReq and pfContextAttributes </i>are bit masks representing various context attributes. For a description of the various attributes, see <a href="issp_2bcj.htm">Context Requirements</a>. The <i>pfContextAttributes</i> parameter is valid on any successful return, but only on the final successful return should you examine the flags pertaining to security aspects of the context. Intermediate returns can set, for example, the ISC_RET_ALLOCATED_MEMORY flag. </p>
<p>
The caller is responsible for determining whether the final context attributes are sufficient; if, for example, confidentiality was requested, but could not be established, some applications may choose to shut down the connection immediately.</p>
<p>
When the ISC_REQ_PROMPT_FOR_CREDS flag is set, the security package attempts to prompt the user for the credentials to use for the connection. If the caller is not an interactive user (for example, a noninteractive service), this flag is ignored. During the prompt, the package may inquire if the supplied credentials should be retained; if so, the package can store them away for future use, relieving the user of having to enter credentials later. This behavior, if supported, should be configurable for environments in which the credentials cannot or should not be stored away.</p>
<p>
If the ISC_REQ_USE_SUPPLIED_CREDS flag is set, the security package should look for a SECBUFFER_PKG_PARAMS buffer type in the <i>pInput</i> input buffer. This is not a generic solution, but it allows for a strong pairing of security package and application when appropriate.</p>
<p>
If the ISC_REQ_ALLOCATE_MEMORY was specified, the caller must free the memory by calling the <a href="issp_2y42.htm"><b>FreeContextBuffer</b></a> function.</p>
<p>
For example, the input token could be the challenge from a LAN Manager or Windows NT file server. In this case, the output token would be the NTLM encrypted response to the challenge. </p>
<p>
The action the client takes depends on the return code from this function. If the return code is SEC_E_OK, there will be no second <b>InitializeSecurityContext</b> call, and no response from the server is expected. If the return code is SEC_I_CONTINUE_NEEDED, the client expects a token in response from the server, and passes it in a second call to <b>InitializeSecurityContext</b>. The SEC_I_COMPLETE_NEEDED return code indicates that the client must finish building the message, and call the <b>CompleteAuthToken</b> function. The SEC_I_COMPLETE_AND_CONTINUE code, of course, incorporates both of these actions.</p>
<p>
If the connection is rejected by the server, the client must call the <b>DeleteSecurityContext</b> function at that time to free any resources.</p>
<h4>See Also</h4>
<p>
<a href="issp_2i2c.htm"><b>AcceptSecurityContext</b></a>, <a href="issp_87qm.htm"><b>CompleteAuthToken</b></a>, <a href="issp_5svo.htm"><b>DeleteSecurityContext</b></a>, <a href="issp_2y42.htm"><b>FreeContextBuffer</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
