<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Client Initialization</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_client_initialization"></a>Client Initialization</h3>
<p>
The example in this topic shows the initialization code to add to the client of a transport application to connect using NTLMSSP authentication. </p>
<p>
The initialization when the client starts is similar to that described for the server in <a href="issp_6566.htm">Server Initialization</a>. The client calls the <b>InitSecurityInterface</b> function. As with the server, if the client is binding directly to SECURITY.DLL, it can discard the returned function table; otherwise, it must use the function table to make subsequent calls to the security provider functions. The client must also call the <b>QuerySecurityPackageInfo</b> function to get the maximum security buffer size. </p>
<p>
When the client is ready to make a connection, it calls the <b>AcquireCredentialsHandle</b> function. The client must save the client credential handle for use when calling the <b>InitializeSecurityContext</b> function, but it can discard the other parameters after the call to <b>AcquireCredentialsHandle</b>.</p>
<p>
If the client program needs to use additional credentials instead of the logon credentials (the user name, domain name, and password the user logged on with), it must provide them in the <b>AcquireCredentialsHandle</b> call. Note that the <b>SEC_WINNT_AUTH_IDENTITY</b> structure used to specify additional credentials in the following example is a package-specific structure defined in RPCDCE.H.</p>
<pre><code>SEC_WINNT_AUTH_IDENTITY AdditionalCredentials;
BOOL SupplyCredentials;
CredHand ClientCredentials;
TimeStamp Expiration;

//
// If there are additional credentials stored in UserName, 
// DomainName, and Password, fill them in here
//

#ifdef UNICODE
AdditionalCredentials.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE
#else
AdditionalCredentials.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI
#endif

//
// Set the flag indicating that we are supplying credentials to 
// FALSE. We will set this to TRUE if a user name, domain name, or 
// password has been supplied. If this is FALSE when we call
// AcquireCredentialsHandle, we will pass in NULL for the pAuthData 
// parameter.
//

SupplyCredentials = FALSE;

if (UserName != NULL) 
{
    AdditionalCredentials.User = UserName;
    AdditionalCredentials.UserLength = strlen(UserName);
    //
    // Set the flag to indicate that we are supplying credentials.
    //
    SupplyCredentials = TRUE;
}

//
// Do the same thing for the password and domain name.
//

SecStatus = AcquireCredentialsHandle(
    NULL,                       // no principal name
    TEXT("NTLM"),               // package name
    SECPKG_CRED_OUTBOUND,       // credential use flag
    NULL,                       // no logon identifier
    SupplyCredentials ?         // If we are supplying credentials,
      &amp;AdditionalCredentials :  // pass in the additional credentials.
      NULL,                     
    NULL,                       // no GetKey function
    NULL,                       // no GetKey function argument
    &amp;ClientCredential,          // receives the new credential
    &amp;Expiration                 // receives the expiration time of 
                                // the credential
    );
 </code></pre>
<p>
The credential handle does not expire, so the client can ignore the expiration time for this security package.</p>
<p>
Next, the client calls the <b>InitializeSecurityContext</b> function to start setting up the security context. </p>
<pre><code>CtxtHandle ClientContext;
TimeStamp Expiration;
SecBufferDesc OutputBufferDescriptor;
SecBuffer OutputSecurityToken;
ULONG ContextRequirements;
ULONG ContextAttributes;

//
// Build the output buffer descriptor.
//

OutputBufferDescriptor.cBuffers = 1
OutputBufferDescriptor.pBuffers = &amp;OutputSecurityToken;
OutputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

OutputSecurityToken.BufferType = SECBUFFER_TOKEN;
OutputSecurityToken.cbBuffer = PackageInfo-&gt;cbMaxToken;
OutputSecurityToken.pvBuffer = 
    LocalAlloc(0, OutputSecurityToken.cbBuffer);

//
// Check for memory allocation failure here.
//

//
// Compute context requirements.
// If you want message integrity, ask for 
//     replay or sequence detection.
// If you want message encryption, ask for confidentiality.
//

ContextRequirements = ISC_REQ_REPLAY_DETECT;

//
// Assume that TargetName is the name of the target server, or NULL.
// Make the call to InitializeSecurityContext.
//

SecStatus = InitializeSecurityContext(
      &amp;ClientCredential
      NULL,                     // no context handle yet
      TargetName,               // target name, if available
      ContextRequirements,
      0,                        // reserved parameter
      SECURITY_NATIVE_DREP,     // target data representation
      NULL,                     // no input buffer
      0,                        // reserved parameter
      &amp;ClientContext,           // receives new context handle
      &amp;ContextAttributes,       // receives context attributes
      &amp;OutputBufferDescriptor,  // receives output security token
      &amp;Expiration               // receives context expiration time
      );
 </code></pre>
<p>
This<b> <a href="issp_93ec.htm">InitializeSecurityContext</a></b> call returns SEC_I_CONTINUE_NEEDED on success, or an error code on failure. If the function is successful, the client transmits the token buffer to the server. The token buffer is stored in the <b>pvBuffer</b> member of the <i>OutputSecurityToken</i> structure. The <b>cbBuffer</b> member of the structure specifies the length of the buffer.</p>
<p>
To finish creating the security token, the server must call the <a href="issp_2i2c.htm"><b>AcceptSecurityContext</b></a> function and send the output back to the client. The client calls <b>InitializeSecurityContext</b> again, followed by another call by the server to <b>AcceptSecurityContext</b>. <a href="issp_5yjy.htm">Server Authentication</a> describes this sequence of calls. </p>
<p>&nbsp;</p></body>
</HTML>
