<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using a Security Context</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_using_a_security_context"></a>Using a Security Context</h3>
<p>
Both the client side and the server side of a transport application can use the <a href="issp_2b51.htm"><b>MakeSignature</b></a> function to generate a signed message to send to the other side. The receiving side then uses the <a href="issp_0t45.htm"><b>VerifySignature</b></a> function to verify that a signature matches the received message. If the application wants to generate signed messages, the client must have specified the ISC_REQ_REPLAY_DETECT or ISC_REQ_SEQUENCE_DETECT flag in its first call to the <a href="issp_93ec.htm"><b>InitializeSecurityContext</b></a> function. </p>
<p>
When the client calls <b>MakeSignature</b> or <b>VerifySignature</b>, it uses the <i>ClientContext</i> handle it obtained from its first call to the <b>InitializeSecurityContext</b> function. When the server calls these functions, it uses the <i>ServerContext</i> handle it obtained from its call to the <b>AcceptSecurityContext</b> function. </p>
<p>
The following example shows the client side generating a signed message to send to the server. Before calling <a href="issp_2b51.htm"><b>MakeSignature</b></a>, the client calls the <b>QueryContextAttributes</b> function with a <a href="issp_6blf.htm"><b>SecPkgContext_Sizes</b></a> structure to determine the length of the buffer needed to hold the message signature. If the <b>cbMaxSignature</b> member is zero, the security package does not support signing messages; otherwise, this member indicates the size of the buffer to allocate to receive the signature.</p>
<pre><code>SecPkgContext_Sizes ContextSizes;

SecStatus = QueryContextAttributes(
    &amp;ClientContext,
    SECPKG_ATTR_SIZES,
    &amp;ContextSizes
    );

//
// Now, assume that the message is in the variable MessageBuffer, and 
// its length is in MessageBufferSize. Build up the buffer descriptors 
// to pass to the MakeSignature call.
//

SecBufferDesc InputBufferDescriptor;
SecBuffer InputSecurityToken[2];

//
// Build the input buffer descriptor.
//

InputBufferDescriptor.cBuffers = 2
InputBufferDescriptor.pBuffers = InputSecurityToken;
InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

//
// Build a security buffer for the message itself. If we added
// the SECBUFFER_READONLY attribute, this buffer would not get
// signed.
//

InputSecurityToken[0].BufferType = SECBUFFER_DATA;
InputSecurityToken[0].cbBuffer = MessageBufferSize;
InputSecurityToken[0].pvBuffer = MessageBuffer;

//
// Allocate and build a security buffer for the message
// signature.
//

InputSecurityToken[1].BufferType = SECBUFFER_TOKEN;
InputSecurityToken[1].cbBuffer = ContextSizes.cbMaxSignature;
InputSecurityToken[1].pvBuffer = 
        LocalAlloc(0, ContextSizes.cbMaxSignature);

//
// Check for memory allocation failure here
//

//
// Call MakeSignature now. 
// You need not specify the sequence number because NTLM will 
// provide one.
// The quality of service is ignored.
//

SecStatus = MakeSignature(
    &amp;ClientContext,
    0,                       // no quality of service
    &amp;InputBufferDescriptor,  // input message descriptor
    0                        // no sequence number
    );
 </code></pre>
<p>
The <a href="issp_2b51.htm"><b>MakeSignature</b></a> function returns successfully if the context was set up to allow signing messages and the input buffer descriptor is correctly formatted. If the function is successful, the client sends the message buffer and its size, along with the signature buffer and its size, to the server. </p>
<p>
The server calls the the <a href="issp_12cz.htm"><b>QueryContextAttributes</b></a> function with a <a href="issp_6blf.htm"><b>SecPkgContext_Sizes</b></a> structure to determine whether the client wants messages to be signed and verified. A nonzero value for the <b>cbMaxSignature</b> member indicates that messages need to be verified.</p>
<p>
The following example shows the server code to verify a signed message. The example is built on the assumption that the signature buffer and size are in <i>SignatureBuffer</i> and <i>SignatureBufferSize</i>, and the message buffer and size are in <i>MessageBuffer</i> and <i>MessageBufferSize</i>.</p>
<pre><code>SecBufferDesc InputBufferDescriptor;
SecBuffer InputSecurityToken[2];
ULONG fQOP;

//
// Build the input buffer descriptor.
//

IputBufferDescriptor.cBuffers = 2
InputBufferDescriptor.pBuffers = InputSecurityToken;
InputBufferDescriptor.ulVersion = SECBUFFER_VERSION;

//
// Build a security buffer for the message itself. If we added
// the SECBUFFER_READONLY attribute, this buffer would not get
// signed.
//

InputSecurityToken[0].BufferType = SECBUFFER_DATA;
InputSecurityToken[0].cbBuffer = MessageBufferSize;
InputSecurityToken[0].pvBuffer = MessageBuffer;

//
// Allocate and build a security buffer for the message
// signature.
//

InputSecurityToken[1].BufferType = SECBUFFER_TOKEN;
InputSecurityToken[1].cbBuffer = SignatureBufferSize;
InputSecurityToken[1].pvBuffer = SignatureBuffer;

//
// Call VerifySignature now. 
// You need not specify the sequence number because NTLM will
// provide one. 
// The quality of service is ignored.
//

SecStatus = VerifySignature(
      &amp;ServerContext,
      &amp;InputBufferDescriptor,  // input message descriptor
      0,                       // no sequence number
      &amp;fQOP                    // Quality of protection
      );
 </code></pre>
<p>
NTLMSSP does not fill in the <i>fQOP</i> parameter, so it should be ignored. If the messages have been received in the correct order and have not been modified, the <b>VerifySignature</b> function returns SEC_E_OK. Otherwise, <b>VerifySignature</b> may return SEC_E_OUT_OF_SEQUENCE or SEC_E_MESSAGE_ALTERED.</p>
<p>
To delete the security contexts after the client and server have finished communicating, both sides can call the <a href="issp_5svo.htm"><b>DeleteSecurityContext</b></a> function with their respective context handles. The client should also call the <a href="issp_710l.htm"><b>FreeCredentialsHandle</b></a> function when it has finished communicating with any server or has finished using the additional credentials passed to the <a href="issp_9azp.htm"><b>AcquireCredentialsHandle</b></a> function. The server should call <a href="issp_5svo.htm"><b>DeleteSecurityContext</b></a> when it is ready to shut down, but before unloading the DLL.</p>
<p>&nbsp;</p></body>
</HTML>
