<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SignalObjectAndWait</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_signalobjectandwait"></a>SignalObjectAndWait</h1>
<p>
The <b>SignalObjectAndWait</b> function allows the caller to atomically signal an object and wait on another object.</p>
<pre><code><b>DWORD SignalObjectAndWait(
  HANDLE</b><i> hObjectToSignal</i><b>,  </b>// handle to object to signal
<b>  HANDLE</b><i> hObjectToWaitOn</i><b>,  </b>// handle to object to wait for
<b>  DWORD</b><i> dwMilliseconds</i><b>,    </b>// time-out interval in milliseconds
<b>  BOOL</b><i> bAlertable          </i>// alertable flag
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hObjectToSignal</i></dt>
<dd>
Specifies the handle to the object to signal. This object can be a semaphore, a mutex, or an event. 
<p>
<b>Windows NT:</b> If the handle is a semaphore, SEMAPHORE_MODIFY_STATE access is required. If the handle is an event, EVENT_MODIFY_STATE access is required. If the handle is a mutex, SYNCHRONIZE access is assumed, because only the owner of a mutex may release it. For more information, see <a href="accctrl_6gdv.htm">Standard Access Rights</a>. 
</dd>
<dt>
<i>hObjectToWaitOn</i></dt>
<dd>
Specifies the handle to the object to wait for. For a list of the object types whose handles you can specify, see the Remarks section.</dd>
<dt>
<i>dwMilliseconds</i></dt>
<dd>
Specifies the time-out interval, in milliseconds. The function returns if the interval elapses, even if the object's state is nonsignaled and no completion or asynchronous procedure call (APC) objects are queued. If <i>dwMilliseconds</i> is zero, the function tests the object's state, checks for queued completion routines or APCs, and returns immediately. If <i>dwMilliseconds</i> is INFINITE, the function's time-out interval never elapses. </dd>
<dt>
<i>bAlertable</i></dt>
<dd>
Specifies whether the function returns when the system queues an I/O completion routine or an APC for the calling thread. If TRUE, the function returns and the thread calls the completion routine or APC function. If FALSE, the function does not return, and the thread does not call the completion routine or APC function.
<p>
A completion routine is queued when the <a href="filesio_0660.htm"><b>ReadFileEx</b></a> or <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> function in which it was specified has completed. The wait function returns and the completion routine is called only if <i>bAlertable</i> is TRUE, and the calling thread is the thread that initiated the read or write operation. An APC is queued when you call <a href="synchro_3dk3.htm"><b>QueueUserAPC</b></a>. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value indicates the event that caused the function to return. This value can be one of the following: </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=42%>Value</th>
<th align=left width=58%>Meaning</th>
</tr>
<tr valign=top>
<td width=42%>WAIT_ABANDONED</td>
<td width=58%>The specified object is a mutex object that was not released by the thread that owned the mutex object before the owning thread terminated. Ownership of the mutex object is granted to the calling thread, and the mutex is set to nonsignaled.</td>
</tr>
<tr valign=top>
<td width=42%>WAIT_IO_COMPLETION</td>
<td width=58%>One or more I/O completion routines or user-mode APCs are queued for execution.</td>
</tr>
<tr valign=top>
<td width=42%>WAIT_OBJECT_0</td>
<td width=58%>The state of the specified object is signaled.</td>
</tr>
<tr valign=top>
<td width=42%>WAIT_TIMEOUT</td>
<td width=58%>The time-out interval elapsed, and the object's state is nonsignaled.</td>
</tr>
</table><br>
<p>
If the function fails, the return value is 0xFFFFFFFF. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>.</p>
<h4>Remarks</h4>
<p>
A completion routine is queued for execution when the <a href="filesio_0660.htm"><b>ReadFileEx</b></a> or <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> function in which it was specified has been completed. The wait function returns and the completion routine is executed only if <i>bAlertable</i> is TRUE, and the calling thread is the thread that initiated the read or write operation.</p>
<p>
The <b>SignalObjectAndWait</b> function can wait for the following objects:
<ul>
<li>
Change notification</li>
<li>
Console input</li>
<li>
Event</li>
<li>
Job</li>
<li>
Mutex</li>
<li>
Process</li>
<li>
Semaphore</li>
<li>
Thread</li>
<li>
Waitable timer</li>
</ul>
<p>
For more information, see <a href="synchro_5gqb.htm">Synchronization Objects</a>.</p>
<p>
Use caution when using the wait functions and code that directly or indirectly creates windows. If a thread creates any windows, it must process messages. Message broadcasts are sent to all windows in the system. A thread that uses a wait function with no time-out interval may cause the system to become deadlocked. Two examples of code that indirectly creates windows are DDE and COM <b>CoInitialize</b>. Therefore, if you have a thread that creates windows, use <a href="synchro_2esz.htm"><b>MsgWaitForMultipleObjects</b></a> or <a href="synchro_6lh4.htm"><b>MsgWaitForMultipleObjectsEx</b></a>, rather than <b>SignalObjectAndWait</b>.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 4.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="synchro_4q3y.htm">Synchronization Overview</a>, <a href="synchro_08z7.htm">Synchronization Functions</a>, <a href="synchro_9kj6.htm"><b>CancelWaitableTimer</b></a>,<b> <a href="synchro_8ub8.htm">CreateEvent</a></b>,<b> <a href="synchro_1a2g.htm">CreateMutex</a></b>,<b> <a href="prothred_9dpv.htm">CreateProcess</a></b>,<b> <a href="prothred_4084.htm">CreateThread</a></b>,<b> <a href="prothred_8b38.htm">CreateRemoteThread</a></b>,<b> <a href="synchro_9zol.htm">CreateSemaphore</a></b>,<b> <a href="synchro_51o2.htm">CreateWaitableTimer</a></b>, <a href="filesio_9hgu.htm"><b>FindFirstChangeNotification</b></a>,<b> <a href="synchro_2esz.htm">MsgWaitForMultipleObjects</a></b>, <a href="synchro_6lh4.htm"><b>MsgWaitForMultipleObjectsEx</b></a>, <a href="synchro_5myc.htm"><b>OpenEvent</b></a>,<b> <a href="synchro_82pk.htm">OpenMutex</a></b>,<b> <a href="prothred_478z.htm">OpenProcess</a></b>,<b> <a href="synchro_3y3p.htm">OpenSemaphore</a></b>,<b> <a href="synchro_0lv6.htm">OpenWaitableTimer</a></b>, <a href="synchro_1ylw.htm"><b>PulseEvent</b></a>, <a href="synchro_3dk3.htm"><b>QueueUserAPC</b></a>, <a href="filesio_0660.htm"><b>ReadFileEx</b></a>, <a href="synchro_4f78.htm"><b>ResetEvent</b></a>, <a href="synchro_8ut0.htm"><b>SetEvent</b></a>, <a href="synchro_6f1u.htm"><b>SetWaitableTimer</b></a>, <a href="filesio_8r08.htm"><b>WriteFileEx</b></a></p>
<p>&nbsp;</p></body>
</HTML>
