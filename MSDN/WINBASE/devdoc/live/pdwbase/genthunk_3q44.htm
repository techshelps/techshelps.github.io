<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Translating 16:16 Pointers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_translating_16_16_pointers_pt"></a>Translating 16:16 Pointers</h2>
<p>
You may occasionally need to translate 16:16 pointers to 32-bit pointers. The <a href="genthunk_9oms.htm"><b>GetVDMPointer32W</b></a> and <a href="genthunk_1to4.htm"><b>WOWGetVDMPointer</b></a> functions accomplish this. Call <b>GetVDMPointer32W</b> from 16-bit code and <b>WOWGetVDMPointer</b> from 32-bit code to translate 16:16 pointers to 32-bit pointers. In addition, <b>GlobalFix</b>, <b>GlobalUnfix</b>, <b>GlobalWire</b>, and <b>GlobalUnwire</b> must be called from 16-bit code. For more information about these functions, see the 16-bit Windows SDK documentation. </p>
<p>
<b>Windows 95 and Windows 98: </b></p>
<p class=indent1>
If you use <a href="genthunk_9oms.htm"><b>GetVDMPointer32W</b></a> or <a href="genthunk_1to4.htm"><b>WOWGetVDMPointer</b></a> and the affected 16:16 pointer represents a movable global memory manager block, it is important that you first call the <b>GlobalFix</b> or <b>GlobalWire</b> function on the segment portion of the pointer. If you do not, the 16-bit global memory manager can move the block while your process is executing 32-bit code. If this happens, the linear address returned by <b>GetVDMPointer32W</b> or <b>WOWGetVDMPointer</b> will become invalid. The debugging version of the system generates warnings about calls to <b>GetVDMPointer32W</b> on unfixed segments. </p>
<p class=indent1>
The <a href="genthunk_4ghg.htm"><b>WOWGetVDMPointerFix</b></a> function is similar to <b>WOWGetVDMPointer</b>, but ensures that the memory pointed to will not be moved by the global memory compacter until the <a href="genthunk_3px0.htm"><b>WOWGetVDMPointerUnfix</b></a> function has been called. <b>WOWGetVDMPointerFix</b> performs an implicit <b>GlobalFix</b> operation on the selector, if necessary. If the selector is allocated as a fixed block or if it is not from the global memory manager, no special action is taken. You should use this function instead of calling <b>GlobalFix</b> separately, because it is easier to use and is faster than calling both <b>GlobalFix</b> and <b>WOWGetVDMPointer</b>. </p>
<p class=indent1>
<b>WOWGetVDMPointerUnfix</b> takes a 16:16 address and undoes the effect of <b>WOWGetVDMPointerFix</b> on the segment (the offset portion is ignored). This function should be called once the linear address is no longer needed to avoid fragmentation. It is faster than the <b>GlobalUnfix</b> function and correctly handles (that is, ignores) selectors that are not from the 16-bit global memory manager.</p>
<p>
<b>Windows NT:</b></p>
<p class=indent1>
While you are executing 32-bit code called through a generic thunk, the 16-bit side of the thunk is completely blocked until you return or yield. Therefore, in most cases, you do not need to fix or wire the memory. Therefore, <a href="genthunk_4ghg.htm"><b>WOWGetVDMPointerFix</b></a> is identical to <a href="genthunk_1to4.htm"><b>WOWGetVDMPointer</b></a> (it does not call <b>GlobalFix</b>) and <a href="genthunk_3px0.htm"><b>WOWGetVDMPointerUnfix</b></a> has no effect under Windows NT. </p>
<p class=indent1>
If you are targeting only Windows NT and your 32-bit code yields the message system (by calling functions such as <b>SendMessage</b>, <b>BroadcastSystemMessage</b>, <b>GetMessage</b>, <b>PeekMessage</b>, <b>MessageBox</b>, or <b>DialogBox</b>), you should either call <b>GlobalFix</b> or <b>GlobalWire</b> ahead of time on the 16-bit side or refresh your 32-bit pointers after the yielding function call has completed by calling <b>WOWGetVDMPointer</b>. </p>
<p>
If you are targeting Windows NT, Windows 95, and Windows 98, there are two approaches that you can use. The easiest approach is to have the 16-bit side of the thunk first fix all of the segments in memory using <b>GlobalFix</b> or <b>GlobalWire</b>. In the 32-bit code, use <b>WOWGetVDMPointer</b>, rather than <b>WOWGetVDMPointerFix</b>, because the segments are already fixed in memory. After the 32-bit code returns, call <b>GlobalFix</b> or <b>GlobalUnwire</b> in the 16-bit code. This guarantees that your 32-bit pointers remain valid, regardless of the platform, even if the 16-bit global memory manager compacts the global heap. The drawback to this approach is that many segments can be left fixed in memory for extended periods of time, potentially causing out-of-memory conditions due to memory fragmentation. </p>
<p>
The most efficient approach that still works on both platforms requires that you use <a href="genthunk_4ghg.htm"><b>WOWGetVDMPointerFix</b></a> and <a href="genthunk_3px0.htm"><b>WOWGetVDMPointerUnfix</b></a>. On Windows NT, the 32-bit pointers can still be affected by 16-bit memory movement if the 32-bit code yields the message system. After each call that might yield the messaging system, discard your 32-bit pointers using <b>WOWGetVDMPointerUnfix</b>. If you continue to use the pointer, repeat the original call to <b>WOWGetVDMPointerFix</b> to refresh the pointer. The drawback to this approach is that it cannot be used if the called function that yields the messaging system uses 32-bit pointers that you provide after yielding the messaging system. If you cannot determine if this will be a problem, the first approach would be a safer choice. </p>
<p>&nbsp;</p></body>
</HTML>
