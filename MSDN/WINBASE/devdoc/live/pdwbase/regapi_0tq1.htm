<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the Registry</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_using_the_registry"></a>Using the Registry</h1>
<p>
The following example demonstrates the use of the <a href="regapi_5xkp.htm"><b>RegQueryInfoKey</b></a>, <a href="regapi_1juh.htm"><b>RegEnumKey</b></a>, and <a href="regapi_65yd.htm"><b>RegEnumValue</b></a> functions. The <i>hKey</i> parameter passed to each function is a handle to an open key. This key must be opened before the function call and closed afterward. </p>
<pre><code>// QueryKey - enumerates the subkeys of a given key and the associated 
//    values and then copies the information about the keys and values 
//    into a pair of edit controls and list boxes. 
// hDlg - dialog box that contains the edit controls and list boxes 
// hKey - key whose subkeys and values are to be enumerated 
 
VOID QueryKey(HWND hDlg, HANDLE hKey) 
{ 
    CHAR     achKey[MAX_PATH]; 
    CHAR     achClass[MAX_PATH] = "";  // buffer for class name 
    DWORD    cchClassName = MAX_PATH;  // length of class string 
    DWORD    cSubKeys;                 // number of subkeys 
    DWORD    cbMaxSubKey;              // longest subkey size 
    DWORD    cchMaxClass;              // longest class string 
    DWORD    cValues;              // number of values for key 
    DWORD    cchMaxValue;          // longest value name 
    DWORD    cbMaxValueData;       // longest value data 
    DWORD    cbSecurityDescriptor; // size of security descriptor 
    FILETIME ftLastWriteTime;      // last write time 
 
    DWORD i, j; 
    DWORD retCode, retValue; 
 
    CHAR  achValue[MAX_VALUE_NAME]; 
    DWORD cchValue = MAX_VALUE_NAME; 
    CHAR  achBuff[80]; 
 
    // Get the class name and the value count. 
    RegQueryInfoKey(hKey,        // key handle 
        achClass,                // buffer for class name 
        &amp;cchClassName,           // length of class string 
        NULL,                    // reserved 
        &amp;cSubKeys,               // number of subkeys 
        &amp;cbMaxSubKey,            // longest subkey size 
        &amp;cchMaxClass,            // longest class string 
        &amp;cValues,                // number of values for this key 
        &amp;cchMaxValue,            // longest value name 
        &amp;cbMaxValueData,         // longest value data 
        &amp;cbSecurityDescriptor,   // security descriptor 
        &amp;ftLastWriteTime);       // last write time 
 
    SetDlgItemText(hDlg, IDE_CLASS, achClass); 
    SetDlgItemInt(hDlg, IDE_CVALUES, cValues, FALSE); 
 
    SendMessage(GetDlgItem(hDlg, IDL_LISTBOX), 
        LB_ADDSTRING, 0, (LONG) ".."); 
 
    // Enumerate the child keys, looping until RegEnumKey fails. Then 
    // get the name of each child key and copy it into the list box. 

    SetCursor(LoadCursor(NULL, IDC_WAIT)); 
    for (i = 0, retCode = ERROR_SUCCESS; 
            retCode == ERROR_SUCCESS; i++) 
    { 
        retCode = RegEnumKey(hKey, i, achKey, MAX_PATH); 
        if (retCode == (DWORD)ERROR_SUCCESS) 
        {
            SendMessage(GetDlgItem(hDlg, IDL_LISTBOX), 
                LB_ADDSTRING, 0, (LONG) achKey); 
        }
    } 
    SetCursor(LoadCursor (NULL, IDC_ARROW)); 
 
    // Enumerate the key values. 
    SetCursor(LoadCursor(NULL, IDC_WAIT)); 
 
    if (cValues) 
    {
        for (j = 0, retValue = ERROR_SUCCESS; 
                j &lt; cValues; j++) 
        { 
            cchValue = MAX_VALUE_NAME; 
            achValue[0] = '\0'; 
            retValue = RegEnumValue(hKey, j, achValue, 
                &amp;cchValue, 
                NULL, 
                NULL,    // &amp;dwType, 
                NULL,    // &amp;bData, 
                NULL);   // &amp;bcData 
 
            if (retValue != (DWORD) ERROR_SUCCESS &amp;&amp; 
                    retValue != ERROR_INSUFFICIENT_BUFFER) 
            { 
                wsprintf (achBuff, 
                    "Line:%d 0 based index = %d, retValue = %d, " 
                     "ValueLen = %d", 
                     __LINE__, j, retValue, cchValue); 
                MessageBox (hDlg, achBuff, "Debug", MB_OK); 
            } 
 
            achBuff[0] = '\0'; 
 
            // Add each value to a list box. 
            if (!lstrlen(achValue)) 
                lstrcpy(achValue, "&lt;NO NAME&gt;"); 
            wsprintf(achBuff, "%d) %s ", j, achValue); 
            SendMessage(GetDlgItem(hDlg,IDL_LISTBOX2), 
                LB_ADDSTRING, 0, (LONG) achBuff); 
        } 
 
    SetCursor(LoadCursor(NULL, IDC_ARROW)); 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
