<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Win32 Function Prototypes</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_win32_function_prototypes"></a>Win32 Function Prototypes</h3>
<p>
Win32 function prototypes are provided in generic, ANSI, and Unicode versions, as shown following. The generic function prototype is provided in the documentation. For example, the following is the generic prototype for the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_setwindowtext">
</object><a href=JavaScript:alink_1.Click()><b>SetWindowText</b></a> function. </p>
<p>
<b>Generic Prototype:</b></p>
<pre><code>BOOL SetWindowText( 
  HWND hwnd, 
  LPCTSTR lpText 
); 
 </code></pre>
<p>
The header file provides the generic function name implemented as a macro. </p>
<pre><code>#ifdef UNICODE
#define SetWindowText SetWindowTextW
#else
#define SetWindowText SetWindowTextA
#endif // !UNICODE
</code></pre>
<p>
The preprocessor expands the macro into either the ANSI or Unicode function names, depending on whether UNICODE is defined. The letter <i>A</i> (ANSI) or <i>W</i> (wide) is added at the end of the generic function name, as appropriate. The header file then provides ANSI and Unicode function prototypes, as shown in the following examples. </p>
<p>
<b>ANSI Prototype:</b></p>
<pre><code>BOOL 
WINAPI
SetWindowTextA( 
    HWND hwnd, 
    LPCSTR lpText ); 
 </code></pre>
<p>
<b>Unicode Prototype:</b></p>
<pre><code>BOOL 
WINAPI
SetWindowTextW( 
    HWND hwnd, 
    LPCWSTR lpText ); 
 </code></pre>
<p>
Note that the generic function prototype uses the generic <b>LPCTSTR</b> for the text parameter, but the ANSI prototype uses <b>LPCSTR</b> and the Unicode prototype uses <b>LPCWSTR</b>. </p>
<p>
You can call the generic function in your application, then define UNICODE when you compile the code to use the Unicode function. To default to the ANSI function, do not define UNICODE. You can mix function calls by using the explicit function names ending with <i>A</i> and <i>W</i>. </p>
<p>
This approach applies to all functions with text arguments. Always use a generic function prototype with the generic string and character types. All function names that end with an uppercase <i>W</i> take wide-character arguments. Some functions exist only in wide-character versions and can be used only with the appropriate data types. </p>
<p>
The QuickInfo section in the documentation for each function provides information on the function versions implemented by the system. The QuickInfo section indicates whether a function has both a Unicode and an ANSI version, or whether the function accepts only Unicode strings. </p>
<p>
<b>Note</b>&nbsp;&nbsp;Whenever a function has a length parameter for a character string, the length should be documented as a count of <b>TCHAR</b> values in the string. However, functions that require or return pointers to untyped memory blocks, such as the <a href="memman_66qr.htm"><b>GlobalAlloc</b></a> function, are exceptions. </p>
<p>&nbsp;</p></body>
</HTML>
