<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RegQueryValueEx</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_regqueryvalueex"></a>RegQueryValueEx</h1>
<p>
The <b>RegQueryValueEx</b> function retrieves the type and data for a specified value name associated with an open registry key. </p>
<pre><code><b>LONG RegQueryValueEx(
  HKEY</b><i> hKey</i><b>,           </b>// handle to key to query
<b>  LPTSTR</b><i> lpValueName</i><b>,  </b>// address of name of value to query
<b>  LPDWORD</b><i> lpReserved</i><b>,  </b>// reserved
<b>  LPDWORD</b><i> lpType</i><b>,      </b>// address of buffer for value type
<b>  LPBYTE</b><i> lpData</i><b>,       </b>// address of data buffer
<b>  LPDWORD</b><i> lpcbData</i>     // address of data buffer size
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hKey</i></dt>
<dd>
Handle to a currently open key or any of the following predefined reserved handle values: 
<p>
<b>HKEY_CLASSES_ROOT</b><br>
<b>HKEY_CURRENT_CONFIG</b><br>
<b>HKEY_CURRENT_USER</b><br>
<b>HKEY_LOCAL_MACHINE</b><br>
<b>HKEY_USERS<br>
Windows NT:</b> <b>HKEY_PERFORMANCE_DATA</b> <br>
<b>Windows 95 and Windows 98:</b> <b>HKEY_DYN_DATA</b> 
</dd>
<dt>
<i>lpValueName</i></dt>
<dd>
Pointer to a null-terminated string containing the name of the value to query.
<p>
If <i>lpValueName</i> is NULL or an empty string, "", the function retrieves the type and data for the key's unnamed or default value, if any. 

<p>
<b>Windows 95 and Windows 98: </b>Every key has a default value that initially does not contain data. On Windows 95, the default value type is always REG_SZ. On Windows 98, the type of a key's default value is initially REG_SZ, but <b>RegSetValueEx</b> can specify a default value with a different type.

<p>
<b>Windows NT:</b> Keys do not automatically have an unnamed or default value. Unnamed values can be of any type. 
</dd>
<dt>
<i>lpReserved</i></dt>
<dd>
Reserved; must be NULL. </dd>
<dt>
<i>lpType</i></dt>
<dd>
Pointer to a variable that receives the type of data associated with the specified value. The value returned through this parameter will be one of the following: 
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=49%>Value</th>
<th align=left width=51%>Meaning</th>
</tr>
<tr valign=top>
<td width=49%>REG_BINARY</td>
<td width=51%>Binary data in any form.</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD</td>
<td width=51%>A 32-bit number.</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD_LITTLE_ENDIAN</td>
<td width=51%>A 32-bit number in little-endian format. This is equivalent to REG_DWORD.<p>
In little-endian format, a multi-byte value is stored in memory from the lowest byte (the "little end") to the highest byte. For example, the value 0x12345678 is stored as (0x78 0x56 0x34 0x12) in little-endian format.</p>
<p>
Windows NT, Windows 95, and Windows 98 are designed to run on little-endian computer architectures. A user may connect to computers that have big-endian architectures, such as some UNIX systems. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>REG_DWORD_BIG_ENDIAN</td>
<td width=51%>A 32-bit number in big-endian format. <p>
In big-endian format, a multi-byte value is stored in memory from the highest byte (the "big end") to the lowest byte. For example, the value 0x12345678 is stored as (0x12 0x34 0x56 0x78) in big-endian format.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>REG_EXPAND_SZ</td>
<td width=51%>A null-terminated string that contains unexpanded references to environment variables (for example, "%PATH%"). It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions. To expand the environment variable references, use the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_expandenvironmentstrings">
</object><a href=JavaScript:alink_1.Click()><b>ExpandEnvironmentStrings</b></a> function.</td>
</tr>
<tr valign=top>
<td width=49%>REG_LINK</td>
<td width=51%>A Unicode symbolic link.</td>
</tr>
<tr valign=top>
<td width=49%>REG_MULTI_SZ</td>
<td width=51%>An array of null-terminated strings, terminated by two null characters.</td>
</tr>
<tr valign=top>
<td width=49%>REG_NONE</td>
<td width=51%>No defined value type.</td>
</tr>
<tr valign=top>
<td width=49%>REG_RESOURCE_LIST</td>
<td width=51%>A device-driver resource list.</td>
</tr>
<tr valign=top>
<td width=49%>REG_SZ</td>
<td width=51%>A null-terminated string. It will be a Unicode or ANSI string depending on whether you use the Unicode or ANSI functions.</td>
</tr>
</table><br>


<p>
The <i>lpType</i> parameter can be NULL if the type is not required. 
</dd>
<dt>
<i>lpData</i></dt>
<dd>
Pointer to a buffer that receives the value's data. This parameter can be NULL if the data is not required. </dd>
<dt>
<i>lpcbData</i></dt>
<dd>
Pointer to a variable that specifies the size, in bytes, of the buffer pointed to by the <i>lpData</i> parameter. When the function returns, this variable contains the size of the data copied to <i>lpData</i>. 
<p>
If the data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, then <i>lpcbData</i> will also include the size of the terminating null character. 

<p>
The <i>lpcbData</i> parameter can be NULL only if <i>lpData</i> is NULL.

<p>
If the buffer specified by <i>lpData</i> parameter is not large enough to hold the data, the function returns the value ERROR_MORE_DATA, and stores the required buffer size, in bytes, into the variable pointed to by <i>lpcbData</i>. 

<p>
If <i>lpData</i> is NULL, and <i>lpcbData</i> is non-NULL, the function returns ERROR_SUCCESS, and stores the size of the data, in bytes, in the variable pointed to by <i>lpcbData</i>. This lets an application determine the best way to allocate a buffer for the value's data. 

<p>
<b>Window NT:</b> If <i>hKey</i> specifies <b>HKEY_PERFORMANCE_DATA</b> and the <i>lpData</i> buffer is too small, <b>RegQueryValueEx</b> returns ERROR_MORE_DATA but <i>lpcbData</i> does not return the required buffer size. This is because the size of the performance data can change from one call to the next. In this case, you must increase the buffer size and call <b>RegQueryValueEx</b> again passing the updated buffer size in the <i>lpcbData</i> parameter. Repeat this until the function succeeds. You need to maintain a separate variable to keep track of the buffer size, because the value returned by <i>lpcbData</i> is unpredictable. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is ERROR_SUCCESS.</p>
<p>
If the function fails, the return value is a nonzero error code defined in WINERROR.H. You can use the <a href="strings_0sdh.htm"><b>FormatMessage</b></a> function with the FORMAT_MESSAGE_FROM_SYSTEM flag to get a generic description of the error.</p>
<h4>Remarks</h4>
<p>
The key identified by <i>hKey</i> must have been opened with KEY_QUERY_VALUE access. To open the key, use the <a href="regapi_1woo.htm"><b>RegCreateKeyEx</b></a> or <a href="regapi_7yns.htm"><b>RegOpenKeyEx</b></a> function. </p>
<p>
If the value data has the REG_SZ, REG_MULTI_SZ or REG_EXPAND_SZ type, and the ANSI version of this function is used (either by explicitly calling <b>RegQueryValueExA</b> or by not defining UNICODE before including the WINDOWS.H file), this function converts the stored Unicode string to an ANSI string before copying it to the buffer pointed to by <i>lpData</i>. </p>
<p>
<b>Window NT:</b> When calling the <b>RegQueryValueEx</b> function with <i>hKey</i> set to the HKEY_PERFORMANCE_DATA handle and a value string of a specified object, the returned data structure sometimes has unrequested objects. Don't be surprised; this is normal behavior. When calling the <b>RegQueryValueEx</b> function, you should always expect to walk the returned data structure to look for the requested object. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winreg.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use advapi32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Implemented as Unicode and ANSI versions on Windows NT.</p>
<h4>See Also</h4>
<p>
<a href="regapi_9bzt.htm">Registry Overview</a>, <a href="regapi_59mb.htm">Registry Functions</a>, <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_expandenvironmentstrings">
</object><a href=JavaScript:alink_2.Click()><b>ExpandEnvironmentStrings</b></a>, <a href="regapi_1woo.htm"><b>RegCreateKeyEx</b></a>, <a href="regapi_1juh.htm"><b>RegEnumKey</b></a>, <a href="regapi_4854.htm"><b>RegEnumKeyEx</b></a>, <a href="regapi_65yd.htm"><b>RegEnumValue</b></a>, <a href="regapi_7yns.htm"><b>RegOpenKeyEx</b></a>, <a href="regapi_5xkp.htm"><b>RegQueryInfoKey</b></a>, <a href="regapi_05np.htm"><b>RegQueryValue</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
