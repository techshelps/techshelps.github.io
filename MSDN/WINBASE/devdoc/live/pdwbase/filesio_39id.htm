<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ReadFile</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_readfile"></a>ReadFile</h1>
<p>
The <b>ReadFile</b> function reads data from a file, starting at the position indicated by the file pointer. After the read operation has been completed, the file pointer is adjusted by the number of bytes actually read, unless the file handle is created with the overlapped attribute. If the file handle is created for overlapped input and output (I/O), the application must adjust the position of the file pointer after the read operation. </p>
<pre><code><b>BOOL ReadFile(
  HANDLE</b><i> hFile</i><b>,                </b>// handle of file to read
<b>  LPVOID</b><i> lpBuffer</i><b>,             </b>// pointer to buffer that receives data
<b>  DWORD</b><i> nNumberOfBytesToRead</i><b>,  </b>// number of bytes to read
<b>  LPDWORD</b><i> lpNumberOfBytesRead</i><b>, </b>// pointer to number of bytes read
<b>  LPOVERLAPPED</b><i> lpOverlapped</i>    // pointer to structure for data
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hFile</i></dt>
<dd>
Handle to the file to be read. The file handle must have been created with GENERIC_READ access to the file. 
<dl>
<dt>
<b>Windows NT:</b></dt>
<dd>
For asynchronous read operations, <i>hFile</i> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <a href="filesio_7wmd.htm"><b>CreateFile</b></a> function, or a socket handle returned by the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_socket_2">
</object><a href=JavaScript:alink_1.Click()><b>socket</b></a> or <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_accept_2">
</object><a href=JavaScript:alink_2.Click()><b>accept</b></a> functions.</dd>
<dt>
<b>Windows 95:</b></dt>
<dd>
For asynchronous read operations, <i>hFile</i> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <b>CreateFile</b>, or a socket handle returned by the <b>socket</b> or <b>accept</b> functions. Windows 95 does not support asynchronous read operations on disk files.</dd>
</dl>
</dd>
<dt>
<i>lpBuffer</i></dt>
<dd>
Pointer to the buffer that receives the data read from the file. </dd>
<dt>
<i>nNumberOfBytesToRead</i></dt>
<dd>
Number of bytes to be read from the file. </dd>
<dt>
<i>lpNumberOfBytesRead</i></dt>
<dd>
Pointer to the number of bytes read. <b>ReadFile</b> sets this value to zero before doing any work or error checking. If this parameter is zero when <b>ReadFile</b> returns TRUE on a named pipe, the other end of the message-mode pipe called the <a href="filesio_3kkl.htm"><b>WriteFile</b></a> function with <i>nNumberOfBytesToWrite</i> set to zero. 
<p>
<b>Windows NT:</b> If <i>lpOverlapped</i> is NULL, <i>lpNumberOfBytesRead</i> cannot be NULL.

<p>
<b>Windows NT:</b> If <i>lpOverlapped</i> is not NULL, <i>lpNumberOfBytesRead</i> can be NULL. If this is an overlapped read operation, you can get the number of bytes read by calling <a href="synchro_75v8.htm"><b>GetOverlappedResult</b></a>. If <i>hFile</i> is associated with an I/O completion port, you can get the number of bytes read by calling <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a>.

<p>
<b>Windows 95 and Windows 98:</b> This parameter cannot be NULL.
</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
Pointer to an <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> structure. This structure is required if <i>hFile</i> was created with FILE_FLAG_OVERLAPPED.
<p>
If <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED, the <i>lpOverlapped</i> parameter must not be NULL. It must point to a valid <b>OVERLAPPED</b> structure. If <i>hFile</i> was created with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is NULL, the function can incorrectly report that the read operation is complete. 

<p>
If <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not NULL, the read operation starts at the offset specified in the <b>OVERLAPPED</b> structure and <b>ReadFile</b> may return before the read operation has been completed. In this case, <b>ReadFile</b> returns FALSE and the <b>GetLastError</b> function returns ERROR_IO_PENDING. This allows the calling process to continue while the read operation finishes. The event specified in the <b>OVERLAPPED</b> structure is set to the signaled state upon completion of the read operation. 

<p>
If <i>hFile</i> was not opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is NULL, the read operation starts at the current file position and <b>ReadFile</b> does not return until the operation has been completed.

<p>
If <i>hFile</i> is not opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not NULL, the read operation starts at the offset specified in the <b>OVERLAPPED</b> structure. <b>ReadFile</b> does not return until the read operation has been completed. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
The <b>ReadFile</b> function returns when one of the following is true: a write operation completes on the write end of the pipe, the number of bytes requested has been read, or an error occurs. </p>
<p>
If the function succeeds, the return value is nonzero. </p>
<p>
If the return value is nonzero and the number of bytes read is zero, the file pointer was beyond the current end of the file at the time of the read operation. However, if the file was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not NULL, the return value is FALSE and <a href="errors_3uwi.htm"><b>GetLastError</b></a> returns ERROR_HANDLE_EOF when the file pointer goes beyond the current end of file.</p>
<p>
If the function fails, the return value is zero. To get extended error information, call <b>GetLastError</b>. </p>
<h4>Remarks</h4>
<p>
If part of the file is locked by another process and the read operation overlaps the locked portion, this function fails. </p>
<p>
An application must meet certain requirements when working with files opened with FILE_FLAG_NO_BUFFERING:
<ul>
<li>
File access must begin at byte offsets within the file that are integer multiples of the volume's sector size. To determine a volume's sector size, call the <a href="filesio_2pt1.htm"><b>GetDiskFreeSpace</b></a> function. </li>
<li>
File access must be for numbers of bytes that are integer multiples of the volume's sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, or 2048 bytes, but not of 335, 981, or 7171 bytes. </li>
<li>
Buffer addresses for read and write operations must be sector aligned (aligned on addresses in memory that are integer multiples of the volume's sector size). One way to sector align buffers is to use the <a href="memman_3elf.htm"><b>VirtualAlloc</b></a> function to allocate the buffers. This function allocates memory that is aligned on addresses that are integer multiples of the system's page size. Because both page and volume sector sizes are powers of 2, memory aligned by multiples of the system's page size is also aligned by multiples of the volume's sector size. </li>
</ul>
<p>
Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read operation is using until the read operation completes.</p>
<p>
Characters can be read from the console input buffer by using <b>ReadFile</b> with a handle to console input. The console mode determines the exact behavior of the <b>ReadFile</b> function. </p>
<p>
If a named pipe is being read in message mode and the next message is longer than the <i>nNumberOfBytesToRead</i> parameter specifies, <b>ReadFile</b> returns FALSE and <a href="errors_3uwi.htm"><b>GetLastError</b></a> returns ERROR_MORE_DATA. The remainder of the message may be read by a subsequent call to the <b>ReadFile</b> or <a href="pipes_7bad.htm"><b>PeekNamedPipe</b></a> function. </p>
<p>
When reading from a communications device, the behavior of <b>ReadFile</b> is governed by the current communication time-outs as set and retrieved using the <a href="commun_8ub7.htm"><b>SetCommTimeouts</b></a> and <a href="commun_3cdv.htm"><b>GetCommTimeouts</b></a> functions. Unpredictable results can occur if you fail to set the time-out values. For more information about communication time-outs, see <a href="commun_9tgy.htm"><b>COMMTIMEOUTS</b></a>.</p>
<p>
If <b>ReadFile</b> attempts to read from a mailslot whose buffer is too small, the function returns FALSE and <b>GetLastError</b> returns ERROR_INSUFFICIENT_BUFFER. </p>
<p>
If the anonymous write pipe handle has been closed and <b>ReadFile</b> attempts to read using the corresponding anonymous read pipe handle, the function returns FALSE and <b>GetLastError</b> returns ERROR_BROKEN_PIPE. </p>
<p>
The <b>ReadFile</b> function may fail and return ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever there are too many outstanding asynchronous I/O requests. </p>
<p>
The <b>ReadFile </b>code to check for the end-of-file condition (eof) differs for synchronous and asynchronous read operations.</p>
<p>
When a synchronous read operation reaches the end of a file, <b>ReadFile </b>returns TRUE and sets *<i>lpNumberOfBytesRead</i> to zero. The following sample code tests for end-of-file for a synchronous read operation:</p>
<pre><code>// Attempt a synchronous read operation. 
bResult = ReadFile(hFile, &amp;inBuffer, nBytesToRead, &amp;nBytesRead, NULL) ; 
// Check for end of file. 
if (bResult &amp;&amp;  nBytesRead == 0, ) 
{ 
    // we're at the end of the file 
} 
 </code></pre>
<p>
An asynchronous read operation can encounter the end of a file during the initiating call to <b>ReadFile</b>, or during subsequent asynchronous operation. </p>
<p>
If EOF is detected at <b>ReadFile</b> time for an asynchronous read operation, <b>ReadFile</b> returns FALSE and <b>GetLastError</b> returns ERROR_HANDLE_EOF.</p>
<p>
If EOF is detected during subsequent asynchronous operation, the call to <b>GetOverlappedResult</b> to obtain the results of that operation returns FALSE and <b>GetLastError </b>returns ERROR_HANDLE_EOF.</p>
<p>
To cancel all pending asynchronous I/O operations, use the <a href="filesio_06gf.htm"><b>CancelIo</b></a> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </p>
<p>
If you are attempting to read from a floppy drive that does not have a floppy disk, the system displays a message box prompting the user to retry the operation. To prevent the system from displaying this message box, call the <a href="errors_38px.htm"><b>SetErrorMode</b></a> function with SEM_NOOPENFILEERRORBOX. </p>
<p>
The following sample code illustrates testing for end-of-file for an asynchronous read operation:</p>
<pre><code>// set up overlapped structure fields 
// to simplify this sample, we'll eschew an event handle 
gOverLapped.Offset     = 0; 
gOverLapped.OffsetHigh = 0; 
gOverLapped.hEvent     = NULL; 
 
// attempt an asynchronous read operation 
bResult = ReadFile(hFile, &amp;inBuffer, nBytesToRead, &amp;nBytesRead, 
    &amp;gOverlapped) ; 
 
// if there was a problem, or the async. operation's still pending ... 
if (!bResult) 
{ 
    // deal with the error code 
    switch (dwError = GetLastError()) 
    { 
        case ERROR_HANDLE_EOF: 
        { 
            // we're reached the end of the file 
            // during the call to ReadFile 
 
            // code to handle that 
        } 
 
        case ERROR_IO_PENDING: 
        { 
            // asynchronous i/o is still in progress 
 
            // do something else for a while 
            GoDoSomethingElse() ; 
 
            // check on the results of the asynchronous read 
            bResult = GetOverlappedResult(hFile, &amp;gOverlapped, 
                &amp;nBytesRead, FALSE) ; 
 
            // if there was a problem ... 
            if (!bResult) 
            { 
                // deal with the error code 
                switch (dwError = GetLastError()) 
                { 
                    case ERROR_HANDLE_EOF: 
                    { 
                        // we're reached the end of the file 
                        //during asynchronous operation 
                    } 
 
                    // deal with other error cases 
                } 
            } 
        } // end case 
 
        // deal with other error cases 
 
    } // end switch 
} // end if 
 </code></pre>
<p>
<b>Windows CE:</b> The <i>lpOverlapped</i> parameter must be set to NULL. Windows CE does not allow files to be created with the overlapped attribute.</p>
<p>
Windows CE does not support asynchronous read operations on files.</p>
<p>
The <i>hFile</i>.parameter cannot be a socket handle. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="filesio_2xm7.htm">File I/O Overview</a>, <a href="filesio_3n5f.htm">File Functions</a>, <a href="filesio_06gf.htm"><b>CancelIo</b></a>, <a href="filesio_7wmd.htm"><b>CreateFile</b></a>, <a href="commun_3cdv.htm"><b>GetCommTimeouts</b></a>, <a href="synchro_75v8.htm"><b>GetOverlappedResult</b></a>, <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a>, <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a>, <a href="pipes_7bad.htm"><b>PeekNamedPipe</b></a>, <a href="filesio_0660.htm"><b>ReadFileEx</b></a>, <a href="commun_8ub7.htm"><b>SetCommTimeouts</b></a>, <a href="errors_38px.htm"><b>SetErrorMode</b></a>, <a href="filesio_3kkl.htm"><b>WriteFile</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
