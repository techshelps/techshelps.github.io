<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using the High-Level Input and Output Functions</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_using_the_high_level_input_and_output_functions"></a>Using the High-Level Input and Output Functions</h2>
<p>
The following example uses the high-level console I/O functions for console I/O. For more information about the high-level console I/O functions, see <a href="conchar_8k33.htm">High-Level Console I/O</a>. </p>
<p>
The example assumes that the default I/O modes are in effect initially for the first calls to the <a href="filesio_39id.htm"><b>ReadFile</b></a> and <a href="filesio_3kkl.htm"><b>WriteFile</b></a> functions. Then the input mode is changed to turn off line input mode and echo input mode for the second calls to <b>ReadFile</b> and <b>WriteFile</b>. The <a href="conchar_2tid.htm"><b>SetConsoleTextAttribute</b></a> function is used to set the colors in which subsequently written text will be displayed. Before exiting, the program restores the original console input mode and color attributes. </p>
<p>
The example's NewLine function is used when line input mode is disabled. It handles carriage returns by moving the cursor position to the first cell of the next row. If the cursor is already in the last row of the screen buffer, the contents of the screen buffer are scrolled up one line. For an example that illustrates the use of the <a href="conchar_6mr6.htm"><b>ScrollConsoleScreenBuffer</b></a> function to scroll a screen buffer, see <a href="conchar_11ir.htm">Scrolling a Screen Buffer's Contents</a>. </p>
<pre><code>#include &lt;windows.h&gt; 
 
void NewLine(void); 
void ScrollScreenBuffer(HANDLE, INT); 
 
HANDLE hStdout, hStdin; 
CONSOLE_SCREEN_BUFFER_INFO csbiInfo; 
 
void main(void) 
{ 
    LPSTR lpszPrompt1 = "Type something and press Enter:\n"; 
    LPSTR lpszPrompt2 = "Type any key: "; 
    CHAR chBuffer[256]; 
    DWORD cRead, cWritten, fdwMode, fdwOldMode; 
    WORD wOldColorAttrs; 

    // Get handles to STDIN and STDOUT. 

    hStdin = GetStdHandle(STD_INPUT_HANDLE); 
    hStdout = GetStdHandle(STD_OUTPUT_HANDLE); 
    if (hStdin == INVALID_HANDLE_VALUE || 
        hStdout == INVALID_HANDLE_VALUE) 
    {
        MyErrorExit("GetStdHandle"); 
    }

    // Save the current text colors. 

    if (! GetConsoleScreenBufferInfo(hStdout, &amp;csbiInfo)) 
        MyErrorExit("GetConsoleScreenBufferInfo"); 

    wOldColorAttrs = csbiInfo.wAttributes; 

    // Set the text attr. to draw red text on black background. 

    if (! SetConsoleTextAttribute(hStdout, FOREGROUND_RED)) 
        MyErrorExit("SetConsoleTextAttribute"); 

    // Write to STDOUT and read from STDIN by using the default 
    // modes. Input is echoed automatically, and ReadFile 
    // does not return until a carriage return is typed. 
    // 
    // The default input modes are line, processed, and echo. 
    // The default output modes are processed and wrap at EOL. 

    while (1) 
    { 
        if (! WriteFile( 
            hStdout,              // output handle 
            lpszPrompt1,          // prompt string 
            lstrlen(lpszPrompt1), // string length 
            &amp;cWritten,            // bytes written 
            NULL) )               // not overlapped 
        break; 
        if (! ReadFile( 
            hStdin,    // input handle 
            chBuffer,  // buffer to read into 
            255,       // size of buffer 
            &amp;cRead,    // actual bytes read 
            NULL) )    // not overlapped 
        break; 
        if (chBuffer[0] == 'q') break; 
    } 

    // Turn off the line input mode, and echo the input mode. 

    if (! GetConsoleMode(hStdin, &amp;fdwOldMode)) 
        MyErrorExit("GetConsoleMode"); 

    fdwMode = fdwOldMode &amp; 
        ~(ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT); 
    if (! SetConsoleMode(hStdin, fdwMode)) 
        MyErrorExit("SetConsoleMode"); 

    // Prompt for input. 

    if (! WriteFile( 
        hStdout,              // output handle 
        lpszPrompt2,          // prompt string 
        lstrlen(lpszPrompt2), // string length 
        &amp;cWritten,            // bytes written 
        NULL) )               // not overlapped 
    MyErrorExit("WriteFile"); 

    // Without line and echo input modes, ReadFile returns 
    // when any input is available. Carriage returns must 
    // be handled, and WriteFile is used to echo input. 

    while (1) 
    { 
        if (! ReadFile(hStdin, chBuffer, 1, &amp;cRead, NULL)) 
            break; 
        if (chBuffer[0] == '\r') 
            NewLine(); 
        else if (! WriteFile(hStdout, chBuffer, cRead, 
            &amp;cWritten, NULL)) break; 
        if (chBuffer[0] == 'q') break; 
    } 

    // Restore the original console mode. 

    if (! SetConsoleMode(hStdin, fdwOldMode)) 
        MyErrorExit("SetConsoleMode"); 

    // Restore the original text colors. 

    if (! SetConsoleTextAttribute(hStdout, wOldColorAttrs)) 
        MyErrorExit("SetConsoleTextAttribute"); 
}

// The NewLine function handles carriage returns when the processed 
// input mode is disabled. It gets the current cursor position 
// and resets it to the first cell of the next row. 
 
void NewLine(void) 
{ 
    if (! GetConsoleScreenBufferInfo(hStdout, &amp;csbiInfo)) 
        MyErrorExit("GetConsoleScreenBufferInfo"); 
    csbiInfo.dwCursorPosition.X = 0; 

    // If it is the last line in the screen buffer, scroll 
    // the buffer up. 

    if ((csbiInfo.dwSize.Y-1) == csbiInfo.dwCursorPosition.Y) 
    { 
        ScrollScreenBuffer(hStdout, 1); 
    } 

    // Otherwise, advance the cursor to the next line. 

    else csbiInfo.dwCursorPosition.Y += 1; 
 
    if (! SetConsoleCursorPosition(hStdout, 
        csbiInfo.dwCursorPosition)) 
    {
        MyErrorExit("SetConsoleCursorPosition"); 
    }
} 
</code></pre>
<p>&nbsp;</p></body>
</HTML>
