<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IsBadStringPtr</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_isbadstringptr"></a>IsBadStringPtr</h1>
<p>
The <b>IsBadStringPtr</b> function verifies that the calling process has read access to a range of memory pointed to by a string pointer. </p>
<pre><code><b>BOOL IsBadStringPtr(
  LPCTSTR</b><i> lpsz</i><b>,  </b>// address of string
<b>  UINT</b><i> ucchMax</i>   // maximum size of string
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpsz</i></dt>
<dd>
Pointer to a null-terminated string, either Unicode or ASCII. </dd>
<dt>
<i>ucchMax</i></dt>
<dd>
Specifies the maximum size, in characters, of the string. The function checks for read access in all bytes up to the string's terminating null character or up to the number of bytes specified by this parameter, whichever is smaller. If this parameter is zero, the return value is zero. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the calling process has read access to all bytes up to the string's terminating null character or up to the number of bytes specified by <i>ucchMax</i>, the return value is zero.</p>
<p>
If the calling process does not have read access to all bytes up to the string's terminating null character or up to the number of bytes specified by <i>ucchMax</i>, the return value is nonzero. To get extended error information, call <b>GetLastError</b></p>
<p>
If the application is compiled as a debugging version, and the process does not have read access to all bytes in the specified memory range, the function causes an assertion and breaks into the debugger. Leaving the debugger, the function continues as usual, and returns a nonzero value This behavior is by design, as a debugging aid. </p>
<h4>Remarks</h4>
<p>
If the calling process has read access to some, but not all, of the bytes in the specified memory range, the return value is nonzero. </p>
<p>
In a preemptive multitasking environment, it is possible for some other thread to change the process's access to the memory being tested. Even when the function indicates that the process has read access to the specified memory, you should use structured exception handling when attempting to access the memory. Use of structured exception handling enables the system to notify the process if an access violation exception occurs, giving the process an opportunity to handle the exception. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Implemented as Unicode and ANSI versions on Windows NT.</p>
<h4>See Also</h4>
<p>
<a href="memman_6oz8.htm">Memory Management Overview</a>, <a href="memman_60kz.htm">Memory Management Functions</a>, <a href="memman_4bxu.htm"><b>IsBadCodePtr</b></a>, <a href="memman_2ynm.htm"><b>IsBadReadPtr</b></a>, <a href="memman_3f1u.htm"><b>IsBadWritePtr</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
