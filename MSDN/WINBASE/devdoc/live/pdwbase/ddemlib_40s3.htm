<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Multiple Conversations</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_multiple_conversations"></a>Multiple Conversations</h3>
<p>
A client application can use the <a href="ddemlib_052s.htm"><b>DdeConnectList</b></a> function to determine whether any servers of interest are available in the system. A client specifies a service name and topic name when it calls <b>DdeConnectList</b>, causing the DDEML to broadcast the <a href="ddemlib_5390.htm">XTYP_WILDCONNECT</a> transaction to the DDE callback functions of all servers that match the service name (except those that filter the transaction). A server's callback function should return a data handle that identifies a null-terminated array of <a href="dde_2icy.htm"><b>HSZPAIR</b></a> structures. The array should contain one structure for each service name and topic name pair that matches the pair specified by the client. The DDEML establishes a conversation for each <b>HSZPAIR</b> structure filled by the server and returns a conversation list handle to the client. The server receives the conversation handle by way of the <a href="ddemlib_5xh0.htm">XTYP_CONNECT</a>_CONFIRM transaction (unless the server filters this transaction). </p>
<p>
A client can specify NULL for the service name, topic name, or both when it calls <b>DdeConnectList</b>. If the service name is NULL, all servers in the system that support the specified topic name respond. A conversation is established with each responding server, including multiple instances of the same server. If the topic name is NULL, a conversation is established on each topic recognized by each server that matches the service name. </p>
<p>
A client can use the <a href="ddemlib_5i2a.htm"><b>DdeQueryNextServer</b></a> and <a href="ddemlib_2j1r.htm"><b>DdeQueryConvInfo</b></a> functions to identify the servers that respond to <b>DdeConnectList</b>. <b>DdeQueryNextServer</b> returns the next conversation handle in a conversation list, and <b>DdeQueryConvInfo</b> fills a <a href="ddemlib_2y9e.htm"><b>CONVINFO</b></a> structure with information about the conversation. The client can keep the conversation handles that it needs and discard the rest from the conversation list. </p>
<p>
The following example uses <b>DdeConnectList</b> to establish conversations with all servers that support the System topic and then uses the <b>DdeQueryNextServer</b> and <b>DdeQueryConvInfo</b> functions to obtain the servers' service name string handles and store them in a buffer. </p>
<pre><code>HCONVLIST hconvList; // conversation list 
DWORD idInst;        // instance identifier 
HSZ hszSystem;       // System topic 
HCONV hconv = NULL;  // conversation handle 
CONVINFO ci;         // holds conversation data 
UINT cConv = 0;      // count of conv. handles 
HSZ *pHsz, *aHsz;    // point to string handles 
 
// Connect to all servers that support the System topic. 
 
hconvList = DdeConnectList(idInst, NULL, hszSystem, NULL, NULL); 
 
// Count the number of handles in the conversation list. 
 
while ((hconv = DdeQueryNextServer(hconvList, hconv)) != NULL) 
    cConv++; 
 
// Allocate a buffer for the string handles. 
 
hconv = NULL; 
aHsz = (HSZ *) LocalAlloc(LMEM_FIXED, cConv * sizeof(HSZ)); 
 
// Copy the string handles to the buffer. 
 
pHsz = aHsz; 
while ((hconv = DdeQueryNextServer(hconvList, hconv)) != NULL) 
{ 
    DdeQueryConvInfo(hconv, QID_SYNC, (PCONVINFO) &amp;ci); 
    DdeKeepStringHandle(idInst, ci.hszSvcPartner); 
    *pHsz++ = ci.hszSvcPartner; 
} 
 
// Use the handles; converse with the servers. 
 
// Free the memory and terminate the conversations. 
 
LocalFree((HANDLE) aHsz); 
DdeDisconnectList(hconvList); 
 </code></pre>
<p>
An application can terminate an individual conversation in a conversation list by calling the <a href="ddemlib_72yc.htm"><b>DdeDisconnect</b></a> function. An application can terminate all conversations in a conversation list by calling the <a href="ddemlib_3vzo.htm"><b>DdeDisconnectList</b></a> function. Both functions cause the DDEML to send <a href="ddemlib_60tw.htm">XTYP_DISCONNECT</a> transactions to each partner's DDE callback function. <b>DdeDisconnectList</b> sends an XTYP_DISCONNECT transaction for each conversation handle in the list. </p>
<p>
A client can retrieve a list of the conversation handles in a conversation list by passing an existing conversation list handle to <a href="ddemlib_052s.htm"><b>DdeConnectList</b></a>. The enumeration process removes the handles of terminated conversations from the list, and nonduplicate conversations that fit the specified service name and topic name are added. </p>
<p>
If <b>DdeConnectList</b> specifies an existing conversation list handle, the function creates a new conversation list that contains the handles of any new conversations and the handles from the existing list. </p>
<p>
If duplicate conversations exist, <b>DdeConnectList</b> attempts to prevent duplicate conversation handles in the conversation list. A duplicate conversation is a second conversation with the same server on the same service name and topic name. Two such conversations would have different handles, yet they would identify the same conversation. </p>
<p>&nbsp;</p></body>
</HTML>
