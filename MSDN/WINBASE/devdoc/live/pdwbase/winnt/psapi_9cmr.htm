<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumerating All Processes</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_enumerating_all_processes"></a>Enumerating All Processes</h2>
<p>
Task Manager is an example of a program that enumerates all running processes on Windows NT. It is implemented using data from the performance registry. The following sample code uses the <a href="psapi_5kqb.htm"><b>EnumProcesses</b></a> function to enumerate the current processes in the system. This method is easier than using the performance registry. </p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include "psapi.h"

void PrintProcessNameAndID( DWORD processID )
{
    char szProcessName[MAX_PATH] = "unknown";

    // Get a handle to the process.

    HANDLE hProcess = OpenProcess( PROCESS_QUERY_INFORMATION |
                                   PROCESS_VM_READ,
                                   FALSE, processID );

    // Get the process name.

    if ( hProcess )
    {
        HMODULE hMod;
        DWORD cbNeeded;

        if ( EnumProcessModules( hProcess, &amp;hMod, sizeof(hMod), 
             &amp;cbNeeded) )
        {
            GetModuleBaseName( hProcess, hMod, szProcessName, 
                               sizeof(szProcessName) );
        }
    }

    // Print the process name and identifier.

    printf( "%s (Process ID: %u)\n", szProcessName, processID );

    CloseHandle( hProcess );
}

void main( )
{
    // Get the list of process identifiers.

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &amp;cbNeeded ) )
        return;

    // Calculate how many process identifiers were returned.

    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name and process identifier for each process.

    for ( i = 0; i &lt; cProcesses; i++ )
        PrintProcessNameAndID( aProcesses[i] );
}
</code></pre>
<p>
The main function obtains a list of processes by using the <a href="psapi_5kqb.htm"><b>EnumProcesses</b></a> function. For each process, main calls the PrintProcessNameAndID function, passing it the process identifier. PrintProcessNameAndID in turn calls the <a href="../prothred_478z.htm"><b>OpenProcess</b></a> function to obtain the process handle. If <b>OpenProcess</b> fails, the output shows only the process identifier. For example, <b>OpenProcess</b> fails for the Idle and CSRSS processes because their access restrictions prevent user-level code from opening them. Next, PrintProcessNameAndID calls the <a href="psapi_1wz7.htm"><b>EnumProcessModules</b></a> function to obtain the module handles. Finally, PrintProcessNameAndID calls the <a href="psapi_3ajp.htm"><b>GetModuleBaseName</b></a> function to obtain the name of the executable file. </p>
<p>&nbsp;</p></body>
</HTML>
