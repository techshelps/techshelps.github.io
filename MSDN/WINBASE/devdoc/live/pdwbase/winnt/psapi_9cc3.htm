<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Enumerating All Modules For a Process</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_enumerating_all_modules_for_a_process"></a>Enumerating All Modules For a Process</h2>
<p>
To determine which processes have loaded a particular DLL, you must enumerate the modules for each process. The following sample code uses the <a href="psapi_1wz7.htm"><b>EnumProcessModules</b></a> function to enumerate the modules of current processes in the system. </p>
<pre><code>#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include "psapi.h"

void PrintModules( DWORD processID )
{
    HMODULE hMods[1024];
    HANDLE hProcess;
    DWORD cbNeeded;
    unsigned int i;

    // Print the process identifier.

    printf( "\nProcess ID: %u\n", processID );

    // Get a list of all the modules in this process.

    hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION |
                                    PROCESS_VM_READ,
                                    FALSE, processID );

    if( EnumProcessModules(hProcess, hMods, sizeof(hMods), &amp;cbNeeded))
    {
        for ( i = 0; i &lt; (cbNeeded / sizeof(HMODULE)); i++ )
        {
            char szModName[MAX_PATH];

            // Get the full path to the module's file.

            if ( GetModuleFileNameEx( hProcess, hMods[i], szModName,
                                      sizeof(szModName)))
            {
                // Print the module name and handle value.

                printf("\t%s (0x%08X)\n", szModName, hMods[i] );
            }
        }
    }

    CloseHandle( hProcess );
}

void main( )
{
    // Get the list of process identifiers.

    DWORD aProcesses[1024], cbNeeded, cProcesses;
    unsigned int i;

    if ( !EnumProcesses( aProcesses, sizeof(aProcesses), &amp;cbNeeded ) )
        return;

    // Calculate how many process identifiers were returned.

    cProcesses = cbNeeded / sizeof(DWORD);

    // Print the name of the modules for each process.

    for ( i = 0; i &lt; cProcesses; i++ )
        PrintModules( aProcesses[i] );
}
</code></pre>
<p>
The main function obtains a list of processes by using the <a href="psapi_5kqb.htm"><b>EnumProcesses</b></a> function. For each process, the main function calls the PrintModules function, passing it the process identifier. PrintModules in turn calls the <a href="../prothred_478z.htm"><b>OpenProcess</b></a> function to obtain the process handle. If <b>OpenProcess</b> fails, the output shows only the process identifier. For example, <b>OpenProcess</b> fails for the Idle and CSRSS processes because their access restrictions prevent user-level code from opening them. Next, PrintModules calls the <a href="psapi_1wz7.htm"><b>EnumProcessModules</b></a> function to obtain the module handles function. Finally, PrintModules calls the <a href="psapi_8x88.htm"><b>GetModuleFileNameEx</b></a> function, once for each module, to obtain the module names. </p>
<p>&nbsp;</p></body>
</HTML>
