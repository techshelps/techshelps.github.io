<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DllMain</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_dllmain"></a>DllMain</h1>
<p>
The <b>DllMain</b> function is an optional method of entry into a dynamic-link library (DLL). If the function is used, it is called by the system when processes and threads are initialized and terminated, or upon calls to the <a href="dll_1o8p.htm"><b>LoadLibrary</b></a> and <a href="dll_3cs9.htm"><b>FreeLibrary</b></a> functions. </p>
<p>
<b>DllMain</b> is a placeholder for the library-defined function name. Earlier versions of the SDK documentation used <b>DllEntryPoint</b> as the entry-point function name. You must specify the actual name you use when you build your DLL. For more information, see the documentation included with your development tools. </p>
<pre><code><b>BOOL WINAPI DllMain(
  HINSTANCE</b><i> hinstDLL</i><b>,  </b>// handle to DLL module
<b>  DWORD</b><i> fdwReason</i><b>,     </b>// reason for calling function
<b>  LPVOID</b><i> lpvReserved</i>   // reserved
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hinstDLL</i></dt>
<dd>
A handle to the DLL. The value is the base address of the DLL. The HINSTANCE of a DLL is the same as the HMODULE of the DLL, so <i>hinstDLL</i> can be used in subsequent calls to the <a href="dll_0ysl.htm"><b>GetModuleFileName</b></a> function and other functions that require a module handle. </dd>
<dt>
<i>fdwReason</i></dt>
<dd>
Specifies a flag indicating why the DLL entry-point function is being called. This parameter can be one of the following values: 
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=38%>Value</th>
<th align=left width=62%>Meaning</th>
</tr>
<tr valign=top>
<td width=38%></td>
<td width=62%></td>
</tr>
<tr valign=top>
<td width=38%>DLL_PROCESS_ATTACH</td>
<td width=62%>Indicates that the DLL is being loaded into the virtual address space of the current process as a result of the process starting up or as a result of a call to <b>LoadLibrary</b>. DLLs can use this opportunity to initialize any instance data or to use the <a href="prothred_986b.htm"><b>TlsAlloc</b></a> function to allocate a thread local storage (TLS) index.</td>
</tr>
<tr valign=top>
<td width=38%>DLL_THREAD_ATTACH</td>
<td width=62%>Indicates that the current process is creating a new thread. When this occurs, the system calls the entry-point function of all DLLs currently attached to the process. The call is made in the context of the new thread. DLLs can use this opportunity to initialize a TLS slot for the thread. A thread calling the DLL entry-point function with DLL_PROCESS_ATTACH does not call the DLL entry-point function with DLL_THREAD_ATTACH. <p>
Note that a DLL's entry-point function is called with this value only by threads created after the DLL is loaded by the process. When a DLL is loaded using <a href="dll_1o8p.htm"><b>LoadLibrary</b></a>, existing threads do not call the entry-point function of the newly loaded DLL.</p>
</td>
</tr>
<tr valign=top>
<td width=38%>DLL_THREAD_DETACH</td>
<td width=62%>Indicates that a thread is exiting cleanly. If the DLL has stored a pointer to allocated memory in a TLS slot, it uses this opportunity to free the memory. The system calls the entry-point function of all currently loaded DLLs with this value. The call is made in the context of the exiting thread. </td>
</tr>
<tr valign=top>
<td width=38%>DLL_PROCESS_DETACH</td>
<td width=62%>Indicates that the DLL is being unloaded from the virtual address space of the calling process as a result of either a process exit or a call to <a href="dll_3cs9.htm"><b>FreeLibrary</b></a>. The DLL can use this opportunity to call the <a href="prothred_7ns5.htm"><b>TlsFree</b></a> function to free any TLS indices allocated by using <b>TlsAlloc</b> and to free any thread local data. </td>
</tr>
</table><br>

</dd>
<dt>
<i>lpvReserved</i></dt>
<dd>
Specifies further aspects of DLL initialization and cleanup. 
<p>
If <i>fdwReason</i> is DLL_PROCESS_ATTACH, <i>lpvReserved</i> is NULL for dynamic loads and non-NULL for static loads. 

<p>
If <i>fdwReason</i> is DLL_PROCESS_DETACH, <i>lpvReserved</i> is NULL if <b>DllMain</b> has been called by using <b>FreeLibrary</b> and non-NULL if <b>DllMain</b> has been called during process termination. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
When the system calls the <b>DllMain</b> function with the DLL_PROCESS_ATTACH value, the function returns TRUE if it succeeds or FALSE if initialization fails. If the return value is FALSE when <b>DllMain</b> is called because the process uses the <b>LoadLibrary</b> function, <b>LoadLibrary</b> returns NULL. If the return value is FALSE when <b>DllMain</b> is called during process initialization, the process terminates with an error. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<p>
When the system calls the <b>DllMain</b> function with any value other than DLL_PROCESS_ATTACH, the return value is ignored. </p>
<h4>Remarks</h4>
<p>
During initial process startup or after a call to <a href="dll_1o8p.htm"><b>LoadLibrary</b></a>, the system scans the list of loaded DLLs for the process. For each DLL that has not already been called with the DLL_PROCESS_ATTACH value, the system calls the DLL's entry-point function. This call is made in the context of the thread that caused the process address space to change, such as the primary thread of the process or the thread that called <b>LoadLibrary</b>.</p>
<p>
There are cases in which the entry-point function is called for a terminating thread even if the DLL never attached to the thread — for example, the entry-point function was never called with the DLL_THREAD_ATTACH value in the context of the thread in either of these two situations:
<ul>
<li>
The thread was the initial thread in the process, so the system called the entry-point function with the DLL_PROCESS_ATTACH value. </li>
<li>
The thread was already running when a call to the <b>LoadLibrary</b> function was made, so the system never called the entry-point function for it. </li>
</ul>
<p>
When a DLL is unloaded from a process as a result of process termination or as a result of a call to <a href="dll_3cs9.htm"><b>FreeLibrary</b></a>, the system does not call the DLL's entry-point function with the DLL_THREAD_DETACH value for the individual threads of the process. The DLL is only given DLL_PROCESS_DETACH notification. DLLs can take this opportunity to clean up all resources for all threads known to the DLL.</p>
<p>
<b>Warning</b>&nbsp;&nbsp;On attach, the body of your DLL entry-point function should perform only simple initialization tasks, such as setting up thread local storage (TLS), creating synchronization objects, and opening files. You must not call <a href="dll_1o8p.htm"><b>LoadLibrary</b></a> in the entry-point function, because you may create dependency loops in the DLL load order. This can result in a DLL being used before the system has executed its initialization code. Similarly, you must not call the <a href="dll_3cs9.htm"><b>FreeLibrary</b></a> function in the entry-point function on detach, because this can result in a DLL being used after the system has executed its termination code. </p>
<p>
Calling Win32 functions other than TLS, synchronization, and file functions may result in problems that are difficult to diagnose. For example, calling User, Shell, COM, RPC, and Windows Sockets functions (or any functions that call these functions) can cause access violation errors, because their DLLs call <b>LoadLibrary</b> to load other system components. </p>
<p>
To provide more complex initialization, create an initialization routine for the DLL. You can require applications to call the initialization routine before calling any other routines in the DLL. Otherwise, you can have the initialization routine create a named mutex, and have each routine in the DLL call the initialization routine if the mutex does not exist. </p>
<h4>See Also</h4>
<p>
<a href="dll_512r.htm">Dynamic-Link Libraries Overview</a>, <a href="dll_0qr7.htm">Dynamic-Link Library Functions</a>, <a href="dll_9z5a.htm">Dynamic-Link Library Entry-Point Function</a>, <a href="dll_3cs9.htm"><b>FreeLibrary</b></a>, <a href="dll_0ysl.htm"><b>GetModuleFileName</b></a>, <a href="dll_1o8p.htm"><b>LoadLibrary</b></a>, <a href="prothred_986b.htm"><b>TlsAlloc</b></a>, <a href="prothred_7ns5.htm"><b>TlsFree</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
