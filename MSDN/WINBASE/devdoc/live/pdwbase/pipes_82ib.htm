<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Named Pipe Server Using Completion Routines</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_named_pipe_server_using_completion_routines"></a>Named Pipe Server Using Completion Routines</h2>
<p>
Like the previous example, the following example is a single-threaded pipe server that creates a message-type pipe and uses overlapped operations. The pipe servers differ, in that this example uses the extended functions <a href="filesio_0660.htm"><b>ReadFileEx</b></a> and <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> to perform overlapped I/O. Unlike the overlapped <a href="filesio_39id.htm"><b>ReadFile</b></a> and <a href="filesio_3kkl.htm"><b>WriteFile</b></a> functions, which signal an event object when completed, the extended functions specify a completion routine, which is queued for execution when the operation is finished. The pipe server uses the <a href="synchro_5yrc.htm"><b>WaitForSingleObjectEx</b></a> function, which performs an alertable wait operationthat returns when a completion routine is ready to execute. The wait function also returns when an event object is signaled, which in this example indicates that the overlapped <a href="pipes_3885.htm"><b>ConnectNamedPipe</b></a> operation has finished (a new client has connected). </p>
<p>
Initially, the pipe server creates a single instance of the pipe and starts an overlapped <b>ConnectNamedPipe</b> operation. When a client connects, the server allocates a structure to provide storage for that pipe instance and then calls the <b>ReadFileEx</b> function to start a sequence of I/O operations to handle communications with the client. Each operation specifies a completion routine that performs the next operation in the sequence. The sequence terminates when the client is disconnected and the pipe instance closed. After starting the sequence of operations for the new client, the server creates another pipe instance and waits for the next client to connect. </p>
<p>
The parameters of the <a href="filesio_0660.htm"><b>ReadFileEx</b></a> and <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> functions specify a completion routine and a pointer to an <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> structure. This pointer is passed to the completion routine in its <i>lpOverLap</i> parameter. Because the <b>OVERLAPPED</b> structure points to the first member in the structure allocated for each pipe instance, the completion routine can use its <i>lpOverLap</i> parameter to access the structure for the pipe instance. </p>
<p>
To avoid duplication, the listing for the ConnectToNewClient subroutine is not shown; it is identical to the one used by the overlapped pipe server in the previous example. </p>
<pre><code>#include &lt;windows.h&gt; 
 
typedef struct 
{ 
   OVERLAPPED oOverlap; 
   HANDLE hPipeInst; 
   CHAR chBuf[BUFSIZE]; 
   DWORD cbToWrite; 
} PIPEINST, *LPPIPEINST; 
 
BOOL CreateAndConnectInstance(); 
BOOL ConnectToNewClient(HANDLE, LPOVERLAPPED); 
VOID GetDataToWriteToClient(LPPIPEINST); 
VOID DisconnectAndClose(LPPIPEINST); 
VOID WINAPI CompletedWriteRoutine(DWORD, DWORD, LPOVERLAPPED); 
VOID WINAPI CompletedReadRoutine(DWORD, DWORD, LPOVERLAPPED); 
 
HANDLE hPipe; 
 
DWORD main(VOID) 
{ 
   HANDLE hConnectEvent; 
   OVERLAPPED oConnect; 
   LPPIPEINST lpPipeInst; 
   DWORD dwWait, cbBytes; 
   BOOL fSuccess, fPendingIO; 
 
// Create one event object for the connect operation. 
 
   hConnectEvent = CreateEvent( 
      NULL,    // no security attribute
      TRUE,    // manual reset event 
      TRUE,    // initial state = signaled 
      NULL);   // unnamed event object 

  if (hConnectEvent == NULL) 
      MyErrExit("CreateEvent"); 
 
   oConnect.hEvent = hConnectEvent; 
 
// Call a subroutine to create one instance, and wait for 
// the client to connect. 
 
   fPendingIO = CreateAndConnectInstance(&amp;oConnect); 
 
   while (1) 
   { 
   // Wait for a client to connect, or for a read or write 
   // operation to be completed, which causes a completion 
   // routine to be queued for execution. 
 
      dwWait = WaitForSingleObjectEx( 
         hConnectEvent,  // event object to wait for 
         INFINITE,       // waits indefinitely 
         TRUE);          // alertable wait enabled 
 
      switch (dwWait) 
      { 
      // The wait conditions are satisfied by a completed connect 
      // operation. 
         case 0: 
         // If an operation is pending, get the result of the 
         // connect operation. 
 
         if (fPendingIO) 
         { 
            fSuccess = GetOverlappedResult( 
               hPipe,     // pipe handle 
               &amp;oConnect, // OVERLAPPED structure 
               &amp;cbBytes,  // bytes transferred 
               FALSE);    // does not wait 
            if (!fSuccess) 
               MyErrExit("ConnectNamedPipe"); 
         } 
 
         // Allocate storage for this instance. 
 
            lpPipeInst = (LPPIPEINST) GlobalAlloc( 
               GPTR, sizeof(PIPEINST)); 
            if (lpPipeInst == NULL) 
               MyErrExit("GlobalAlloc lpPipeInst"); 
 
            lpPipeInst-&gt;hPipeInst = hPipe; 
 
         // Start the read operation for this client. 
         // Note that this same routine is later used as a 
         // completion routine after a write operation. 
 
            lpPipeInst-&gt;cbToWrite = 0; 
            CompletedWriteRoutine(0, 0, (LPOVERLAPPED) lpPipeInst); 
 
         // Create new pipe instance for the next client. 
 
            fPendingIO = CreateAndConnectInstance( 
               &amp;oConnect); 
            break; 
 
      // The wait is satisfied by a completed read or write 
      // operation. This allows the system to execute the 
      // completion routine. 
 
         case WAIT_IO_COMPLETION: 
            break; 
 
      // An error occurred in the wait function. 
 
         default: 
            MyErrExit("WaitForSingleObjectEx"); 
      } 
   } 
   return 0; 
} 
 
// CompletedWriteRoutine(DWORD, DWORD, LPOVERLAPPED) 
// This routine is called as a completion routine after writing to 
// the pipe, or when a new client has connected to a pipe instance. It 
// starts another read operation. 
 
VOID WINAPI CompletedWriteRoutine(DWORD dwErr, DWORD cbWritten, 
   LPOVERLAPPED lpOverLap) 
{ 
   LPPIPEINST lpPipeInst; 
   BOOL fRead = FALSE; 
 
// lpOverlap points to storage for this instance. 
 
   lpPipeInst = (LPPIPEINST) lpOverLap; 
 
// The write operation has finished, so read the next request (if 
// there is no error). 
 
   if ((dwErr == 0) &amp;&amp; (cbWritten == lpPipeInst-&gt;cbToWrite)) 
      fRead = ReadFileEx( 
         lpPipeInst-&gt;hPipeInst, 
         lpPipeInst-&gt;chBuf, 
         BUFSIZE, 
         (LPOVERLAPPED) lpPipeInst, 
         (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedReadRoutine); 
 
// Disconnect if an error occurred. 
 
   if (! fRead) 
      DisconnectAndClose(lpPipeInst); 
} 
 
// CompletedReadRoutine(DWORD, DWORD, LPOVERLAPPED) 
// This routine is called as an I/O completion routine after reading a 
// request from the client. It gets data and writes it to the pipe. 
 
VOID WINAPI CompletedReadRoutine(DWORD dwErr, DWORD cbBytesRead, 
    LPOVERLAPPED lpOverLap) 
{ 
   LPPIPEINST lpPipeInst; 
   BOOL fWrite = FALSE; 
 
// lpOverlap points to storage for this instance. 
 
   lpPipeInst = (LPPIPEINST) lpOverLap; 
 
// The read operation has finished, so write a response (if no 
// error occurred). 
 
   if ((dwErr == 0) &amp;&amp; (cbBytesRead != 0)) 
   { 
      GetDataToWriteToClient(lpPipeInst); 
 
      fWrite = WriteFileEx( 
         lpPipeInst-&gt;hPipeInst, 
         lpPipeInst-&gt;chBuf, 
         lpPipeInst-&gt;cbToWrite, 
         (LPOVERLAPPED) lpPipeInst, 
         (LPOVERLAPPED_COMPLETION_ROUTINE) CompletedWriteRoutine); 
   } 
 
// Disconnect if an error occurred. 
 
   if (! fWrite) 
      DisconnectAndClose(lpPipeInst); 
} 
 
// DisconnectAndClose(LPPIPEINST) 
// This routine is called when an error occurs or the client closes 
// its handle to the pipe. 
 
VOID DisconnectAndClose(LPPIPEINST lpPipeInst) 
{ 
// Disconnect the pipe instance. 
 
   if (! DisconnectNamedPipe(lpPipeInst-&gt;hPipeInst) ) 
      MyErrExit("DisconnectNamedPipe"); 
 
// Close the handle to the pipe instance. 
 
   CloseHandle(lpPipeInst-&gt;hPipeInst); 
 
// Release the storage for the pipe instance. 
 
   if (lpPipeInst != NULL) 
      GlobalFree(lpPipeInst); 
} 
 
// CreateAndConnectInstance(LPOVERLAPPED) 
// This function creates a pipe instance and connects to the client. 
// It returns TRUE if the connect operation is pending, and FALSE if 
// the connection has been completed. 
 
BOOL CreateAndConnectInstance(LPOVERLAPPED lpoOverlap) 
{ 
   LPTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; 
 
   hPipe = CreateNamedPipe( 
      lpszPipename,             // pipe name 
      PIPE_ACCESS_DUPLEX |      // read/write access 
      FILE_FLAG_OVERLAPPED,     // overlapped mode 
      PIPE_TYPE_MESSAGE |       // message-type pipe 
      PIPE_READMODE_MESSAGE |   // message read mode 
      PIPE_WAIT,                // blocking mode 
      PIPE_UNLIMITED_INSTANCES, // unlimited instances 
      BUFSIZE,                  // output buffer size 
      BUFSIZE,                  // input buffer size 
      PIPE_TIMEOUT,             // client time-out 
      NULL);                    // no security attributes
  if (hPipe == INVALID_HANDLE_VALUE) 
      MyErrExit("CreatePipe"); 
 
// Call a subroutine to connect to the new client. 
 
   return ConnectToNewClient(hPipe, lpoOverlap); 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
