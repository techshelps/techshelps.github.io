<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HeapValidate</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_heapvalidate"></a>HeapValidate</h1>
<p>
The <b>HeapValidate</b> function attempts to validate a specified heap. The function scans all the memory blocks in the heap, and verifies that the heap control structures maintained by the heap manager are in a consistent state. You can also use the <b>HeapValidate</b> function to validate a single memory block within a specified heap, without checking the validity of the entire heap.</p>
<pre><code><b>BOOL HeapValidate(
  HANDLE</b><i> hHeap</i><b>,  </b>// handle to the heap of interest
<b>  DWORD</b><i> dwFlags</i><b>, </b>// bit flags that control heap access during 
                 // function operation
<b>  LPCVOID</b><i> lpMem</i>  // optional pointer to individual memory block to 
                 // validate
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hHeap</i></dt>
<dd>
Handle to the heap of interest. The <b>HeapValidate </b>function attempts to validate this heap, or a single memory block within this heap.</dd>
<dt>
<i>dwFlags</i></dt>
<dd>
A set of bit flags that control heap access during function operation. The following bit flag has meaning:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=47%>Value</th>
<th align=left width=53%>Meaning</th>
</tr>
<tr valign=top>
<td width=47%>HEAP_NO_SERIALIZE</td>
<td width=53%>Specifies that mutual exclusion is not used while the <b>HeapValidate</b> function accesses the heap. </td>
</tr>
</table><br>

</dd>
<dt>
<i>lpMem</i></dt>
<dd>
Pointer to a memory block within the specified heap. This parameter may be NULL.
<p>
If this parameter is NULL, the function attempts to validate the entire heap specified by <i>hHeap</i>.

<p>
If this parameter is not NULL, the function attempts to validate the memory block pointed to by <i>lpMem</i>. It does not attempt to validate the rest of the heap. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the specified heap or memory block is valid, the return value is nonzero.</p>
<p>
If the specified heap or memory block is invalid, the return value is zero. On a system set up for debugging, the <b>HeapValidate </b>function then displays debugging messages that describe the part of the heap or memory block that is invalid, and stops at a hard-coded breakpoint so that you can examine the system to determine the source of the invalidity. The <b>HeapValidate </b>function does not set the thread's last error value. There is no extended error information for this function; do not call <b>GetLastError</b>.</p>
<h4>Remarks</h4>
<p>
There are heap control structures for each memory block in a heap, and for the heap as a whole. When you use the <b>HeapValidate</b> function to validate a complete heap, it checks all of these control structures for consistency. </p>
<p>
When you use <b>HeapValidate</b> to validate a single memory block within a heap, it checks only the control structures pertaining to that element. <b>HeapValidate</b> can only validate allocated memory blocks. Calling <b>HeapValidate</b> on a freed memory block will return FALSE because there are no control structures to validate. </p>
<p>
If you want to validate the heap elements enumerated by the <b>HeapWalk</b> function, you should only call <b>HeapValidate</b> on the elements that have the PROCESS_HEAP_ENTRY_BUSY bit flag in the <b>wFlags</b> member of the <b>PROCESS_HEAP_ENTRY</b> structure. <b>HeapValidate</b> returns FALSE for all heap elements that do not have this bit set. </p>
<p>
Serialization ensures mutual exclusion when two or more threads attempt to simultaneously allocate or free blocks from the same heap. There is a small performance cost to serialization, but it must be used whenever multiple threads allocate and free memory from the same heap. Setting the HEAP_NO_SERIALIZE flag eliminates mutual exclusion on the heap. Without serialization, two or more threads that use the same heap handle might attempt to allocate or free memory simultaneously, likely causing corruption in the heap. The HEAP_NO_SERIALIZE flag can, therefore, be safely used only in the following situations: 
<ul>
<li>
The process has only one thread. </li>
<li>
The process has multiple threads, but only one thread calls the heap functions for a specific heap. </li>
<li>
The process has multiple threads, and the application provides its own mechanism for mutual exclusion to a specific heap. </li>
</ul>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.5 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="memman_6oz8.htm">Memory Management Overview</a>, <a href="memman_60kz.htm">Memory Management Functions</a>, <a href="memman_5z6t.htm"><b>HeapCreate</b></a>, <a href="memman_1ca3.htm"><b>HeapWalk</b></a>, <a href="memman_8iya.htm"><b>PROCESS_HEAP_ENTRY</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
