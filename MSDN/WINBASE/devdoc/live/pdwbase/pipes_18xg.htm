<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Named Pipe Client</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_named_pipe_client"></a>Named Pipe Client</h2>
<p>
A named pipe client uses the <a href="filesio_7wmd.htm"><b>CreateFile</b></a> function to open a handle to a named pipe. If the pipe exists but all of its instances are busy, <b>CreateFile</b> returns zero and the <a href="errors_3uwi.htm"><b>GetLastError</b></a> function returns ERROR_PIPE_BUSY. When this happens, the named pipe client uses the <a href="pipes_7z6t.htm"><b>WaitNamedPipe</b></a> function to wait for an instance of the named pipe to become available. </p>
<p>
The <b>CreateFile</b> function fails if the access specified is incompatible with the access specified (duplex, outbound, or inbound) when the server created the pipe. For a duplex pipe, the client can specify read, write, or read/write access; for an outbound pipe (write-only server), the client must specify read-only access; and for an inbound pipe (read-only server), the client must specify write-only access. </p>
<p>
The handle returned by <b>CreateFile</b> defaults to byte-read mode, blocking-wait mode, overlapped mode disabled, and write-through mode disabled. The pipe client can use <b>CreateFile</b> to enable overlapped mode by specifying FILE_FLAG_OVERLAPPED or to enable write-through mode by specifying FILE_FLAG_WRITE_THROUGH. The client can use the <a href="pipes_81r9.htm"><b>SetNamedPipeHandleState</b></a> function to enable nonblocking mode by specifying PIPE_WAIT or to enable message-read mode by specifying PIPE_READMODE_MESSAGE. </p>
<p>
The following example shows a pipe client that opens a named pipe, sets the pipe handle to message-read mode, uses the <a href="filesio_3kkl.htm"><b>WriteFile</b></a> function to send a request to the server, and uses the <a href="filesio_39id.htm"><b>ReadFile</b></a> function to read the server's reply. This pipe client can be used with any of the message-type servers shown in the previous examples. With a byte-type server, however, this pipe client fails when it calls <b>SetNamedPipeHandleState</b> to change to message-read mode. Because the client is reading from the pipe in message-read mode, it is possible for the <b>ReadFile</b> operation to return zero after reading a partial message. This happens when the message is larger than the read buffer. In this situation, <b>GetLastError</b> returns ERROR_MORE_DATA, and the client can read the remainder of the message using additional calls to <b>ReadFile</b>. </p>
<pre><code>#include &lt;windows.h&gt; 
 
DWORD main(int argc, char *argv[]) 
{ 
   HANDLE hPipe; 
   LPVOID lpvMessage; 
   CHAR chBuf[512]; 
   BOOL fSuccess; 
   DWORD cbRead, cbWritten, dwMode; 
   LPTSTR lpszPipename = "\\\\.\\pipe\\mynamedpipe"; 
 
// Try to open a named pipe; wait for it, if necessary. 
 
   while (1) 
   { 
      hPipe = CreateFile( 
         lpszPipename,   // pipe name 
         GENERIC_READ |  // read and write access 
         GENERIC_WRITE, 
         0,              // no sharing 
         NULL,           // no security attributes
         OPEN_EXISTING,  // opens existing pipe 
         0,              // default attributes 
         NULL);          // no template file 
 
   // Break if the pipe handle is valid. 
 
      if (hPipe != INVALID_HANDLE_VALUE) 
         break; 
 
      // Exit if an error other than ERROR_PIPE_BUSY occurs. 
 
      if (GetLastError() != ERROR_PIPE_BUSY) 
         MyErrExit("Could not open pipe"); 
 
      // All pipe instances are busy, so wait for 20 seconds. 
 
      if (! WaitNamedPipe(lpszPipename, 20000) ) 
         MyErrExit("Could not open pipe"); 
   } 
 
// The pipe connected; change to message-read mode. 
 
   dwMode = PIPE_READMODE_MESSAGE; 
   fSuccess = SetNamedPipeHandleState( 
      hPipe,    // pipe handle 
      &amp;dwMode,  // new pipe mode 
      NULL,     // don't set maximum bytes 
      NULL);    // don't set maximum time 
   if (!fSuccess) 
      MyErrExit("SetNamedPipeHandleState"); 
 
// Send a message to the pipe server. 
 
   lpvMessage = (argc &gt; 1) ? argv[1] : "default message"; 
 
   fSuccess = WriteFile( 
      hPipe,                  // pipe handle 
      lpvMessage,             // message 
      strlen(lpvMessage) + 1, // message length 
      &amp;cbWritten,             // bytes written 
      NULL);                  // not overlapped 
   if (! fSuccess) 
      MyErrExit("WriteFile"); 
 
   do 
   { 
   // Read from the pipe. 
 
      fSuccess = ReadFile( 
         hPipe,    // pipe handle 
         chBuf,    // buffer to receive reply 
         512,      // size of buffer 
         &amp;cbRead,  // number of bytes read 
         NULL);    // not overlapped 
 
      if (! fSuccess &amp;&amp; GetLastError() != ERROR_MORE_DATA) 
         break; 
 
      // Reply from the pipe is written to STDOUT. 
 
      if (! WriteFile(GetStdHandle(STD_OUTPUT_HANDLE), 
         chBuf, cbRead, &amp;cbWritten, NULL)) 
      {
         break; 
      }
 
   } while (! fSuccess);  // repeat loop if ERROR_MORE_DATA 
 
   CloseHandle(hPipe); 
 
   return 0; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
