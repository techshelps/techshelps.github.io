<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WriteFile</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_writefile"></a>WriteFile</h1>
<p>
The <b>WriteFile</b> function writes data to a file and is designed for both synchronous and asynchronous operation. The function starts writing data to the file at the position indicated by the file pointer. After the write operation has been completed, the file pointer is adjusted by the number of bytes actually written, except when the file is opened with FILE_FLAG_OVERLAPPED. If the file handle was created for overlapped input and output (I/O), the application must adjust the position of the file pointer after the write operation is finished. </p>
<pre><code><b>BOOL WriteFile(
  HANDLE</b><i> hFile</i><b>,                    </b>// handle to file to write to
<b>  LPCVOID</b><i> lpBuffer</i><b>,                </b>// pointer to data to write to file
<b>  DWORD</b><i> nNumberOfBytesToWrite</i><b>,     </b>// number of bytes to write
<b>  LPDWORD</b><i> lpNumberOfBytesWritten</i><b>,  </b>// pointer to number of bytes written
<b>  LPOVERLAPPED</b><i> lpOverlapped</i>        // pointer to structure for overlapped I/O
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hFile</i></dt>
<dd>
Handle to the file to be written to. The file handle must have been created with GENERIC_WRITE access to the file. 
<dl>
<dt>
<b>Windows NT:</b></dt>
<dd>
For asynchronous write operations, <i>hFile</i> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <a href="filesio_7wmd.htm"><b>CreateFile</b></a> function, or a socket handle returned by the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_socket_2">
</object><a href=JavaScript:alink_1.Click()><b>socket</b></a> or <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_accept_2">
</object><a href=JavaScript:alink_2.Click()><b>accept</b></a> functions.</dd>
<dt>
<b>Windows 95:</b></dt>
<dd>
For asynchronous write operations, <i>hFile</i> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <b>CreateFile</b>, or a socket handle returned by the <b>socket</b> or <b>accept</b> functions. Windows 95 does not support asynchronous write operations on disk files.</dd>
</dl>
</dd>
<dt>
<i>lpBuffer</i></dt>
<dd>
Pointer to the buffer containing the data to be written to the file. </dd>
<dt>
<i>nNumberOfBytesToWrite</i></dt>
<dd>
Number of bytes to write to the file. 
<p>
A value of zero specifies a null write operation. A null write operation does not write any bytes but does cause the time stamp to change. 

<p>
Named pipe write operations across a network are limited to 65,535 bytes.
</dd>
<dt>
<i>lpNumberOfBytesWritten</i></dt>
<dd>
Pointer to the number of bytes written by this function call. <b>WriteFile</b> sets this value to zero before doing any work or error checking. 
<p>
<b>Windows NT:</b> If <i>lpOverlapped</i> is NULL, <i>lpNumberOfBytesWritten</i> cannot be NULL.

<p>
<b>Windows NT:</b> If <i>lpOverlapped</i> is not NULL, <i>lpNumberOfBytesWritten</i> can be NULL. If this is an overlapped write operation, you can get the number of bytes written by calling <a href="synchro_75v8.htm"><b>GetOverlappedResult</b></a>. If <i>hFile</i> is associated with an I/O completion port, you can get the number of bytes written by calling <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a>.

<p>
<b>Windows 95 and Windows 98:</b> This parameter cannot be NULL.
</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
Pointer to an <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> structure. This structure is required if <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED.
<p>
If <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED, the <i>lpOverlapped</i> parameter must not be NULL. It must point to a valid <b>OVERLAPPED</b> structure. If <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is NULL, the function can incorrectly report that the write operation is complete.

<p>
If <i>hFile</i> was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not NULL, the write operation starts at the offset specified in the <b>OVERLAPPED</b> structure and <b>WriteFile</b> may return before the write operation has been completed. In this case, <b>WriteFile</b> returns FALSE and the <b>GetLastError</b> function returns ERROR_IO_PENDING. This allows the calling process to continue processing while the write operation is being completed. The event specified in the <b>OVERLAPPED</b> structure is set to the signaled state upon completion of the write operation. 

<p>
If <i>hFile</i> was not opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is NULL, the write operation starts at the current file position and <b>WriteFile</b> does not return until the operation has been completed. 

<p>
If <i>hFile</i> was not opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is not NULL, the write operation starts at the offset specified in the <b>OVERLAPPED</b> structure and <b>WriteFile</b> does not return until the write operation has been completed. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is nonzero.</p>
<p>
If the function fails, the return value is zero. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<h4>Remarks</h4>
<p>
An application must meet certain requirements when working with files opened with FILE_FLAG_NO_BUFFERING:
<ul>
<li>
File access must begin at byte offsets within the file that are integer multiples of the volume's sector size. To determine a volume's sector size, call the <a href="filesio_2pt1.htm"><b>GetDiskFreeSpace</b></a> function. </li>
<li>
File access must be for numbers of bytes that are integer multiples of the volume's sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, or 2048 bytes, but not of 335, 981, or 7171 bytes. </li>
<li>
Buffer addresses for read and write operations must be sector aligned (aligned on addresses in memory that are integer multiples of the volume's sector size). One way to sector align buffers is to use the <a href="memman_3elf.htm"><b>VirtualAlloc</b></a> function to allocate the buffers. This function allocates memory that is aligned on addresses that are integer multiples of the system's page size. Because both page and volume sector sizes are powers of 2, memory aligned by multiples of the system's page size is also aligned by multiples of the volume's sector size. </li>
</ul>
<p>
If part of the file is locked by another process and the write operation overlaps the locked portion, this function fails. </p>
<p>
Accessing the output buffer while a write operation is using the buffer may lead to corruption of the data written from that buffer. Applications must not read from, write to, reallocate, or free the output buffer that a write operation is using until the write operation completes.</p>
<p>
Characters can be written to the screen buffer using <b>WriteFile</b> with a handle to console output. The exact behavior of the function is determined by the console mode. The data is written to the current cursor position. The cursor position is updated after the write operation. </p>
<p>
The system interprets zero bytes to write as specifying a null write operation and <b>WriteFile</b> does not truncate or extend the file. To truncate or extend a file, use the <b>SetEndOfFile</b> function. </p>
<p>
When writing to a nonblocking, byte-mode pipe handle with insufficient buffer space, <b>WriteFile</b> returns TRUE with <i>*lpNumberOfBytesWritten</i> &lt; <i>nNumberOfBytesToWrite</i>. </p>
<p>
When an application uses the <b>WriteFile</b> function to write to a pipe, the write operation may not finish if the pipe buffer is full. The write operation is completed when a read operation (using the <b>ReadFile</b> function) makes more buffer space available. </p>
<p>
If the anonymous read pipe handle has been closed and <b>WriteFile</b> attempts to write using the corresponding anonymous write pipe handle, the function returns FALSE and <a href="errors_3uwi.htm"><b>GetLastError</b></a> returns ERROR_BROKEN_PIPE. </p>
<p>
The <b>WriteFile</b> function may fail with ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY whenever there are too many outstanding asynchronous I/O requests. </p>
<p>
To cancel all pending asynchronous I/O operations, use the <a href="filesio_06gf.htm"><b>CancelIo</b></a> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </p>
<p>
If you are attempting to write to a floppy drive that does not have a floppy disk, the system displays a message box prompting the user to retry the operation. To prevent the system from displaying this message box, call the <a href="errors_38px.htm"><b>SetErrorMode</b></a> function with SEM_NOOPENFILEERRORBOX. </p>
<p>
<b>Windows CE:</b> Windows CE does not support asynchronous write operations. The <i>lpOverlapped</i> parameter is ignored and should be set to NULL before calling <b>WriteFile</b>.</p>
<p>
Unlike the MS-DOS operating system, Windows CE interprets zero bytes to write as specifying a null write operation and <b>WriteFile</b> does not truncate or extend the file. To truncate or extend a file, use the <b>SetEndOfFile</b> function. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="filesio_2xm7.htm">File I/O Overview</a>, <a href="filesio_3n5f.htm">File Functions</a>, <a href="filesio_06gf.htm"><b>CancelIo</b></a>, <a href="filesio_7wmd.htm"><b>CreateFile</b></a>, <a href="errors_3uwi.htm"><b>GetLastError</b></a>, <a href="synchro_75v8.htm"><b>GetOverlappedResult</b></a>, <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a>, <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a>, <a href="filesio_39id.htm"><b>ReadFile</b></a>, <a href="filesio_18bp.htm"><b>SetEndOfFile</b></a>, <a href="errors_38px.htm"><b>SetErrorMode</b></a>, <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
