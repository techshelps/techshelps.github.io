<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SetFilePointer</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_setfilepointer"></a>SetFilePointer</h1>
<p>
The <b>SetFilePointer</b> function moves the file pointer of an open file. </p>
<pre><code><b>DWORD SetFilePointer(
  HANDLE</b><i> hFile</i><b>,          </b>// handle of file
<b>  LONG</b><i> lDistanceToMove</i><b>,  </b>// number of bytes to move file pointer
<b>  PLONG</b><i> lpDistanceToMoveHigh</i><b>,</b>
<b>                         </b>// pointer to high-order DWORD of 
                         // distance to move
<b>  DWORD</b><i> dwMoveMethod</i>     // how to move
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hFile</i></dt>
<dd>
Handle to the file whose file pointer is to be moved. The file handle must have been created with GENERIC_READ or GENERIC_WRITE access to the file. </dd>
<dt>
<i>lDistanceToMove</i></dt>
<dd>
Low-order 32 bits of a signed value that specifies the number of bytes to move the file pointer. If <i>lpDistanceToMoveHigh</i> is not NULL, <i>lpDistanceToMoveHigh</i> and <i>lDistanceToMove</i> form a single 64-bit signed value that specifies the distance to move. If <i>lpDistanceToMoveHigh</i> is NULL, <i>lDistanceToMove</i> is a 32-bit signed value. A positive value for <i>lDistanceToMove </i>moves the file pointer forward in the file, and a negative value moves the file pointer backward.</dd>
<dt>
<i>lpDistanceToMoveHigh</i></dt>
<dd>
Pointer to the high-order 32 bits of the signed 64-bit distance to move. If you do not need the high-order 32 bits, this pointer may be NULL. When non-NULL, this parameter also receives the high-order <b>DWORD</b> of the new value of the file pointer. For more information, see the Remarks section later in this topic.</dd>
<dt>
<i>dwMoveMethod</i></dt>
<dd>
Starting point for the file pointer move. This parameter can be one of the following values. 
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=29%>Value</th>
<th align=left width=71%>Meaning</th>
</tr>
<tr valign=top>
<td width=29%>FILE_BEGIN</td>
<td width=71%>The starting point is zero or the beginning of the file.</td>
</tr>
<tr valign=top>
<td width=29%>FILE_CURRENT</td>
<td width=71%>The starting point is the current value of the file pointer.</td>
</tr>
<tr valign=top>
<td width=29%>FILE_END</td>
<td width=71%>The starting point is the current end-of-file position.</td>
</tr>
</table><br>

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the <b>SetFilePointer</b> function succeeds and <i>lpDistanceToMoveHigh</i> is NULL, the return value is the low-order <b>DWORD</b> of the new file pointer. If <i>lpDistanceToMoveHigh</i> is not NULL, the function returns the low order <b>DWORD</b> of the new file pointer, and puts the high-order <b>DWORD</b> of the new file pointer into the <b>LONG</b> pointed to by that parameter. </p>
<p>
If the function fails and <i>lpDistanceToMoveHigh</i> is NULL, the return value is 0xFFFFFFFF. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<p>
If the function fails, and <i>lpDistanceToMoveHigh</i> is non-NULL, the return value is 0xFFFFFFFF. However, because 0xFFFFFFFF is a valid value for the low-order <b>DWORD</b> of the new file pointer, you must check <b>GetLastError</b> to determine whether an error occurred. If an error occurred, <b>GetLastError</b> returns a value other than NO_ERROR. For a code example that illustrates this point, see the Remarks section later in this topic.</p>
<p>
If the new file pointer would have been a negative value, the function fails, the file pointer is not moved, and the code returned by <b>GetLastError</b> is ERROR_NEGATIVE_SEEK.</p>
<h4>Remarks</h4>
<p>
You cannot use the <b>SetFilePointer</b> function with a handle to a nonseeking device, such as a pipe or a communications device. To determine the file type for <i>hFile</i>, use the <a href="filesio_75ut.htm"><b>GetFileType</b></a> function.</p>
<p>
To determine the present position of a file pointer, see <a href="filesio_3vhu.htm">Retrieving a File Pointer</a>.</p>
<p>
You should be careful when setting the file pointer in a multithreaded application. For example, an application whose threads share a file handle, update the file pointer, and read from the file must protect this sequence by using a critical section object or mutex object. For more information about these objects, see <a href="synchro_2a2b.htm">Critical Section Objects</a> and <a href="synchro_7t9v.htm">Mutex Objects</a>.</p>
<p>
If the <i>hFile</i> file handle was opened with the FILE_FLAG_NO_BUFFERING flag set, an application can move the file pointer only to sector-aligned positions. A <i>sector-aligned position </i>is a position that is a whole number multiple of the volume's sector size. An application can obtain a volume's sector size by calling the <a href="filesio_2pt1.htm"><b>GetDiskFreeSpace</b></a> function. If an application calls <b>SetFilePointer</b> with distance-to-move values that result in a position that is not sector-aligned and a handle that was opened with FILE_FLAG_NO_BUFFERING, the function fails, and <b>GetLastError</b> returns ERROR_INVALID_PARAMETER.</p>
<p>
Note that it is not an error to set the file pointer to a position beyond the end of the file. The size of the file does not increase until you call the <a href="filesio_18bp.htm"><b>SetEndOfFile</b></a>, <a href="filesio_3kkl.htm"><b>WriteFile</b></a>, or <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> function. A write operation increases the size of the file to the file pointer position plus the size of the buffer written, leaving the intervening bytes uninitialized. </p>
<p>
If the return value is 0xFFFFFFFF and if <i>lpDistanceToMoveHigh</i> is non-NULL, an application must call <b>GetLastError</b> to determine whether the function has succeeded or failed. The following sample code illustrates this point: </p>
<pre><code>// 
// Case One: calling the function with lpDistanceToMoveHigh == NULL 
 
// Try to move hFile's file pointer some distance 
dwPtr = SetFilePointer (hFile, lDistance, NULL, FILE_BEGIN) ; 
 
if (dwPtr == 0xFFFFFFFF) // Test for failure
{ 
    // Obtain the error code 
    dwError = GetLastError() ; 
 
    // Deal with failure 
    // . . . 
 
} // End of error handler 


// 
// Case Two: calling the function with lpDistanceToMoveHigh != NULL 
 
// Try to move hFile's file pointer some huge distance 
dwPtrLow = SetFilePointer (hFile, lDistLow, &amp; lDistHigh, FILE_BEGIN) ; 
 
// Test for failure
if (dwPtrLow == 0xFFFFFFFF &amp;&amp; (dwError = GetLastError()) != NO_ERROR )
{ 
    // Deal with failure 
    // . . . 

} // End of error handler 
 </code></pre>
<p>
The parameter <i>lpDistanceToMoveHigh</i> is used to manipulate huge files. If it is set to NULL, then <i>lDistanceToMove</i> has a maximum value of 2^31–2, or 2 gigabytes less two. This is because all file pointer values are signed values. Therefore if there is even a small change that the file will grow to that size, you should treat the file as a huge file and work with 64-bit file pointers. With <a href="fsys_99ny.htm">file compression</a> on NTFS, and <a href="fsys_141f.htm">sparse files</a>, it is possible to have files that large even if the underlying volume is not that large.</p>
<p>
If <i>lpDistanceToMoveHigh </i>is not NULL, then <i>lpDistanceToMoveHigh </i>and <i>lDistanceToMove </i>form a single 64-bit signed value. The <i>lDistanceToMove </i>parameter is treated as the low-order 32 bits of the value, and <i>lpDistanceToMoveHigh </i>as the upper 32 bits. Thus, <i>lpDistanceToMoveHigh </i>is a sign extension of <i>lDistanceToMove.</i></p>
<p>
To move the file pointer from zero to 2 gigabytes, <i>lpDistanceToMoveHigh </i>can be either NULL or a sign extension of <i>lDistanceToMove.</i> To move the pointer more than 2 gigabytes, use <i>lpDistanceToMoveHigh </i>and <i>lDistanceToMove </i>as a single 64-bit quantity. For example, to move in the range from 2 gigabytes to 4 gigabytes set the contents of <i>lpDistanceToMoveHigh </i>to zero, or to –1 for a negative sign extension of <i>lDistanceToMove.</i></p>
<p>
To work with 64-bit file pointers, you can declare a <b>LONG</b>, treat it as the upper half of the 64-bit file pointer, and pass its address in <i>lpDistanceToMoveHigh.</i> This means you have to treat two different variables as a logical unit, which is error-prone. The problems can be ameliorated by using the <b>LARGE_INTEGER </b>structure to create a 64-bit value and passing the two 32-bit values by means of the appropriate elements of the union.</p>
<p>
It is conceptually simpler and better design to use a function to hide the interface to <b>SetFilePointer</b>. To do so, use something like this:</p>
<pre><code>__int64 myFileSeek (HANDLE hf, __int64 distance, DWORD MoveMethod)
{
   LARGE_INTEGER li;

   li.QuadPart = distance;

   li.LowPart = SetFilePointer (hf, li.LowPart, &amp;li.HighPart, MoveMethod);

   if (li.LowPart == 0xFFFFFFFF &amp;&amp; GetLastError() != NO_ERROR)
   {
      li.QuadPart = -1;
   }

   return li.QuadPart;
}
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;You can use <b>SetFilePointer</b> to determine the length of a file. To do this, use FILE_END for <i>dwMoveMethod </i>and seek to location zero. The file offset returned is the length of the file. However, this practice can have unintended side effects, such as failure to save the current file pointer so that the program can return to that location. It is simpler and safer to use <a href="filesio_05id.htm"><b>GetFileSize</b></a> instead.</p>
<p>
You can also use the <a href="#_win32_setfilepointer"><b>SetFilePointer</b></a> function to query the current file pointer position. To do this, specify a move method of FILE_CURRENT and a distance of zero. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="filesio_2xm7.htm">File I/O Overview</a>, <a href="filesio_3n5f.htm">File Functions</a>, <a href="filesio_2pt1.htm"><b>GetDiskFreeSpace</b></a>, <a href="filesio_05id.htm"><b>GetFileSize</b></a>, <a href="filesio_75ut.htm"><b>GetFileType</b></a>, <a href="filesio_39id.htm"><b>ReadFile</b></a>, <a href="filesio_0660.htm"><b>ReadFileEx</b></a>, <b>ReadFileVlm,</b> <a href="filesio_3kkl.htm"><b>WriteFile</b></a>, <a href="filesio_8r08.htm"><b>WriteFileEx</b></a>, <b>WriteFileVlm</b></p>
<p>&nbsp;</p></body>
</HTML>
