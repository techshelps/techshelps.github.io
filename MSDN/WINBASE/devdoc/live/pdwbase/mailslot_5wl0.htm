<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reading from a Mailslot</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_reading_from_a_mailslot"></a>Reading from a Mailslot</h2>
<p>
The process that creates a mailslot can read messages from it by using the mailslot handle in a call to the <a href="filesio_39id.htm"><b>ReadFile</b></a> function. The code in the following example calls the <a href="mailslot_4n3j.htm"><b>GetMailslotInfo</b></a> function to determine whether there are messages in the mailslot. If messages are waiting, each is displayed in a message box along with the number of messages remaining to be read. </p>
<pre><code>BOOL WINAPI Readslot(HWND hwnd, HDC hdc) 
{ 
    DWORD cbMessage, cMessage, cbRead; 
    BOOL fResult; 
    LPSTR lpszBuffer; 
    CHAR achID[80]; 
        DWORD cAllMessages; 
 
    cbMessage = cMessage = cbRead = 0; 
 
    // Mailslot handle "hSlot1" is declared globally. 
 
    fResult = GetMailslotInfo(hSlot1, // mailslot handle 
        (LPDWORD) NULL,               // no maximum message size 
        &amp;cbMessage,                   // size of next message 
        &amp;cMessage,                    // number of messages 
        (LPDWORD) NULL);              // no read time-out 
 
    if (!fResult) 
    { 
        ErrorHandler(hwnd, "GetMailslotInfo"); 
        return FALSE; 
    } 
 
    if (cbMessage == MAILSLOT_NO_MESSAGE) 
    { 
        TextOut(hdc, 10, 10, "No waiting messages.", 20); 
        return TRUE; 
    } 
 
    cAllMessages = cMessage; 
 
    while (cMessage != 0)  // retrieve all messages
    { 
        // Create a message-number string. 
 
        wsprintf((LPSTR) achID, 
            "\nMessage #%d of %d\n", cAllMessages - cMessage + 1, 
            cAllMessages); 
 
        // Allocate memory for the message. 
 
        lpszBuffer = (LPSTR) GlobalAlloc(GPTR, 
            lstrlen((LPSTR) achID) + cbMessage); 
 
        lpszBuffer[0] = '\0'; 
 
        fResult = ReadFile(hSlot1, 
            lpszBuffer, 
            cbMessage, 
            &amp;cbRead, 
            (LPOVERLAPPED) NULL); 
 
        if (!fResult) 
        { 
            ErrorHandler(hwnd, "ReadFile"); 
            GlobalFree((HGLOBAL) lpszBuffer); 
            return FALSE; 
        } 
 
        // Concatenate the message and the message-number string. 
 
        lstrcat(lpszBuffer, (LPSTR) achID); 
 
        // Display the message. 
 
        MessageBox(hwnd, 
            lpszBuffer, 
            "Contents of Mailslot", 
            MB_OK); 
 
        GlobalFree((HGLOBAL) lpszBuffer); 
 
        fResult = GetMailslotInfo(hSlot1, // mailslot handle 
            (LPDWORD) NULL,               // no maximum message size 
            &amp;cbMessage,                   // size of next message 
            &amp;cMessage,                    // number of messages 
            (LPDWORD) NULL);              // no read time-out 
 
        if (!fResult) 
        { 
            ErrorHandler(hwnd, "GetMailslotInfo"); 
            return FALSE; 
        } 
    } 
    return TRUE; 
} 
 </code></pre>
<p>
A mailslot exists until the <a href="handobj_289x.htm"><b>CloseHandle</b></a> function is called for all open server handles or until all server processes that own a mailslot handle exit. In both cases, any unread messages are deleted from the mailslot, all client handles to the mailslot are closed, and the mailslot itself is deleted from memory. </p>
<p>&nbsp;</p></body>
</HTML>
