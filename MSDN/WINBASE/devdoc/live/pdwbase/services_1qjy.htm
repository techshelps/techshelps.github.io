<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Writing a ServiceMain Function</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_writing_a_servicemain_function"></a>Writing a ServiceMain Function</h2>
<p>
The <code>MyServiceStart</code> function in the following example is the entry point for the service. <code>MyServiceStart</code> has access to the command-line arguments, in the way that the <code>main</code> function of a console application does. The first parameter contains the number of arguments being passed to the service. There will always be at least one argument. The second parameter is a pointer to an array of string pointers. The first item in the array always points to the service name. </p>
<p>
The <code>MyServiceStart</code> function first fills in the <a href="services_9s36.htm"><b>SERVICE_STATUS</b></a> structure including the control codes that it accepts. Although this service accepts SERVICE_CONTROL_PAUSE and SERVICE_CONTROL_CONTINUE, it does nothing significant when told to pause. The flags SERVICE_ACCEPT_PAUSE_CONTINUE was included for illustration purposes only; if pausing does not add value to your service, do not support it. </p>
<p>
The <code>MyServiceStart</code> function then calls the <a href="services_7t0y.htm"><b>RegisterServiceCtrlHandler</b></a> function to register <code>MyService</code> as the service's <a href="services_18oi.htm"><b>Handler</b></a> function and begin initialization. The following sample initialization function, <code>MyServiceInitialization</code>, is included for illustration purposes; it does not perform any initialization tasks such as creating additional threads. If your service's initialization performs tasks that are expected to take longer than one second, your code must call the <a href="services_90oj.htm"><b>SetServiceStatus</b></a> function periodically to send out wait hints and check points indicating that progress is being made. </p>
<p>
When initialization has completed successfully, the example calls <b>SetServiceStatus</b> with a status of SERVICE_RUNNING and the service continues with its work. If an error has occurred in initialization, <code>MyServiceStart</code> reports SERVICE_STOPPED with the <b>SetServiceStatus</b> function and returns.</p>
<p>
Because this sample service does not complete any real tasks, <code>MyServiceStart</code> simply returns control to the caller. However, your service should use this thread to complete whatever tasks it was designed to do. If a service does not need a thread to do its work (such as a service that only processes RPC requests), its <a href="services_61pq.htm"><b>ServiceMain</b></a> function should return control to the caller. It is important for the function to return, rather than call the <a href="prothred_531g.htm"><b>ExitThread</b></a> function, because returning allows for cleanup of the memory allocated for the arguments.</p>
<p>
To output debugging information, <code>MyServiceStart</code> calls <code>SvcDebugOut</code>. The source code for <code>SvcDebugOut</code> is given in <a href="services_0hm6.htm">Writing a Service Program's main Function</a>.</p>
<pre><code>void MyServiceStart (DWORD argc, LPTSTR *argv) 
{ 
    DWORD status; 
    DWORD specificError; 
 
    MyServiceStatus.dwServiceType        = SERVICE_WIN32; 
    MyServiceStatus.dwCurrentState       = SERVICE_START_PENDING; 
    MyServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | 
        SERVICE_ACCEPT_PAUSE_CONTINUE; 
    MyServiceStatus.dwWin32ExitCode      = 0; 
    MyServiceStatus.dwServiceSpecificExitCode = 0; 
    MyServiceStatus.dwCheckPoint         = 0; 
    MyServiceStatus.dwWaitHint           = 0; 
 
    MyServiceStatusHandle = RegisterServiceCtrlHandler( 
        TEXT("MyService"), 
        MyServiceCtrlHandler); 
 
    if (MyServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) 
    { 
        SvcDebugOut(" [MY_SERVICE] RegisterServiceCtrlHandler 
            failed %d\n", GetLastError()); 
        return; 
    } 
 
    // Initialization code goes here. 
    status = MyServiceInitialization(argc,argv, &amp;specificError); 
 
    // Handle error condition 
    if (status != NO_ERROR) 
    { 
        MyServiceStatus.dwCurrentState       = SERVICE_STOPPED; 
        MyServiceStatus.dwCheckPoint         = 0; 
        MyServiceStatus.dwWaitHint           = 0; 
        MyServiceStatus.dwWin32ExitCode      = status; 
        MyServiceStatus.dwServiceSpecificExitCode = specificError; 
 
        SetServiceStatus (MyServiceStatusHandle, &amp;MyServiceStatus); 
        return; 
    } 
 
    // Initialization complete - report running status. 
    MyServiceStatus.dwCurrentState       = SERVICE_RUNNING; 
    MyServiceStatus.dwCheckPoint         = 0; 
    MyServiceStatus.dwWaitHint           = 0; 
 
    if (!SetServiceStatus (MyServiceStatusHandle, &amp;MyServiceStatus)) 
    { 
        status = GetLastError(); 
        SvcDebugOut(" [MY_SERVICE] SetServiceStatus error
            %ld\n",status); 
    } 
 
    // This is where the service does its work. 
    SvcDebugOut(" [MY_SERVICE] Returning the Main Thread \n",0); 
 
    return; 
} 
 
// Stub initialization function. 
DWORD MyServiceInitialization(DWORD   argc, LPTSTR  *argv, 
    DWORD *specificError) 
{ 
    argv; 
    argc; 
    specificError; 
    return(0); 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
