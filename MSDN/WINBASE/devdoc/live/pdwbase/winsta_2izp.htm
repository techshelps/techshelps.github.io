<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interacting with the User by a Win32 Service</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_interacting_with_the_user_by_a_win32_service"></a>Interacting with the User by a Win32 Service</h2>
<p>
For a noninteractive Win32 service to interact with the user, it must open the user's window station ("WinSta0") and desktop ("Default"). By default, only the logged-on user and Win 32 services running in the LocalSystem account are granted access to the user's window station and desktop. This means that services running in other accounts must either impersonate the user when opening the interactive window station and desktop, or have access granted to those accounts by the user.</p>
<p>
For compatibility with versions of Windows NT that support multiple users and/or multiple desktops per user, the user's window station and desktop names should not be hard-coded. Client applications should pass the names of their window station and desktop to the service as part of the request to the service.</p>
<p>
This code sample displays a message on the user's desktop in response to an RPC request from one of the user's applications. Note that a global variable <i>dwGuiThreadId</i> in this example is also used in the <a href="winsta_11f7.htm">logoff handling example</a>. If the thread that displays the message box terminates after it is done with the message box, it is not necessary to save and restore the thread's desktop. It is necessary to restore the process's window station.</p>
<pre><code>DWORD dwGuiThreadId = 0; 
 
int 
UserMessageBox( 
    RPC_BINDING_HANDLE h, 
    LPSTR lpszWindowStation, 
    LPSTR lpszDesktop, 
    LPSTR lpszText, 
    LPSTR lpszTitle, 
    UINT fuStyle) 
{ 
    DWORD dwThreadId; 
    HWINSTA hwinstaSave; 
    HDESK hdeskSave; 
    HWINSTA hwinstaUser; 
    HDESK hdeskUser; 
    int result; 
 
    // Ensure connection to service window station and desktop, and 
    // save their handles. 

    GetDesktopWindow(); 
    hwinstaSave = GetProcessWindowStation(); 
    dwThreadId = GetCurrentThreadId(); 
    hdeskSave = GetThreadDesktop(dwThreadId); 
 
    // Impersonate the client and connect to the User's 
    // window station and desktop. 

    RpcImpersonateClient(h); 
    hwinstaUser = OpenWindowStation(lpszWindowStation, FALSE, MAXIMUM_ALLOWED); 
    if (hwinstaUser == NULL) 
    { 
        RpcRevertToSelf(); 
        return 0; 
    } 
    SetProcessWindowStation(hwinstaUser); 
    hdeskUser = OpenDesktop(lpszDesktop, 0, FALSE, MAXIMUM_ALLOWED); 
    RpcRevertToSelf(); 
    if (hdeskUser == NULL) 
    { 
        SetProcessWindowStation(hwinstaSave); 
        CloseWindowStation(hwinstaUser); 
        return 0; 
    } 
    SetThreadDesktop(hdeskUser); 
 
    // Display message box. 

    dwGuiThreadId = dwThreadId; 
    result = MessageBox(NULL, lpszText, lpszTitle, fuStyle); 
    dwGuiThreadId = 0; 
 
    // Restore window station and desktop. 

    SetThreadDesktop(hdeskSave); 
    SetProcessWindowStation(hwinstaSave); 
    CloseDesktop(hdeskUser); 
    CloseWindowStation(hwinstaUser); 
 
    return result; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
