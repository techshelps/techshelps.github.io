<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VirtualLock</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_virtuallock"></a>VirtualLock</h1>
<p>
The <b>VirtualLock</b> function locks the specified region of the process's virtual address space into memory, ensuring that subsequent access to the region will not incur a page fault. </p>
<pre><code><b>BOOL VirtualLock(
  LPVOID</b><i> lpAddress</i><b>,  </b>// address of first byte of range to lock
<b>  DWORD</b><i> dwSize</i>       // number of bytes in range to lock
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpAddress</i></dt>
<dd>
Pointer to the base address of the region of pages to be locked. </dd>
<dt>
<i>dwSize</i></dt>
<dd>
Specifies the size, in bytes, of the region to be locked. The region of affected pages includes all pages that contain one or more bytes in the range from the <i>lpAddress</i> parameter to (<i>lpAddress</i>+<i>dwSize</i>). This means that a 2-byte range straddling a page boundary causes both pages to be locked. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is nonzero.</p>
<p>
If the function fails, the return value is zero. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<h4>Remarks</h4>
<p>
All pages in the specified region must be committed. Memory protected with the PAGE_NOACCESS flag cannot be locked. </p>
<p>
Locking pages into memory may degrade the performance of the system by reducing the available RAM and forcing the system to swap out other critical pages to the paging file. By default, a process can lock a maximum of 30 pages. The default limit is intentionally small to avoid severe performance degradation. Applications that need to lock larger numbers of pages must first call the <a href="prothred_07l1.htm"><b>SetProcessWorkingSetSize</b></a> function to increase their minimum and maximum working set sizes. The maximum number of pages that a process can lock is equal to the number of pages in its minimum working set minus a small overhead.</p>
<p>
Pages that a process has locked remain resident even when the process is idle for extended periods.</p>
<p>
To unlock a region of locked pages, use the <b>VirtualUnlock</b> function. Locked pages are automatically unlocked when the process terminates. </p>
<p>
This function is not like the <b>GlobalLock</b> or <b>LocalLock</b> function in that it does not increment a lock count and translate a handle into a pointer. There is no lock count for virtual pages, so multiple calls to the <b>VirtualUnlock</b> function are never required to unlock a region of pages. 
<dl>
<dt>
<b>Windows 95:</b> The <b>VirtualLock</b> function is implemented as a stub that has no effect and always returns a nonzero value.</dt>
</dl>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="memman_6oz8.htm">Memory Management Overview</a>, <a href="memman_60kz.htm">Memory Management Functions</a>, <a href="memman_6omj.htm"><b>GlobalLock</b></a>, <a href="memman_5j57.htm"><b>LocalLock</b></a>, <a href="prothred_07l1.htm"><b>SetProcessWorkingSetSize</b></a>, <a href="memman_7esr.htm"><b>VirtualUnlock</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
