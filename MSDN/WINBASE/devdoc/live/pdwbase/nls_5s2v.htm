<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LCMapString</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_lcmapstring"></a>LCMapString</h1>
<p>
The <b>LCMapString</b> function maps one character string to another, performing a specified locale-dependent transformation. The function can also be used to generate a sort key for the input string.</p>
<pre><code><b>int LCMapString(
  LCID</b><i> Locale</i><b>,       </b>// locale identifier
<b>  DWORD</b><i> dwMapFlags</i><b>,  </b>// mapping transformation type
<b>  LPCTSTR</b><i> lpSrcStr</i><b>,  </b>// address of source string
<b>  int</b><i> cchSrc</i><b>,        </b>// number of characters in source string
<b>  LPTSTR</b><i> lpDestStr</i><b>,  </b>// address of destination buffer
<b>  int</b><i> cchDest</i>        // size of destination buffer
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>Locale</i></dt>
<dd>
Specifies a locale identifier. The locale provides a context for the string mapping or sort key generation. An application can use the <a href="nls_7qck.htm"><b>MAKELCID</b></a> macro to create a locale identifier.</dd>
<dt>
<i>dwMapFlags</i></dt>
<dd>
A set of flags that indicate the type of transformation to be used during string mapping or sort key generation. An application can specify more than one of these options on a single transformation, although some combinations are invalid. The following mapping options are defined; restrictions are noted following the table:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>Option</th>
<th align=left width=52%>Meaning</th>
</tr>
<tr valign=top>
<td width=48%>LCMAP_BYTEREV</td>
<td width=52%><b>Windows NT:</b> Use byte reversal. For example, if you pass in 0x3450 0x4822 the result is 0x5034 0x2248. </td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_FULLWIDTH</td>
<td width=52%>Wide characters (where applicable).</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_HALFWIDTH</td>
<td width=52%>Narrow characters (where applicable).</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_HIRAGANA</td>
<td width=52%>Hiragana.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_KATAKANA</td>
<td width=52%>Katakana.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_LINGUISTIC_CASING</td>
<td width=52%>Use linguistic rules for casing, rather than file system rules (the default). Valid with LCMAP_LOWERCASE or LCMAP_UPPERCASE only.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_LOWERCASE</td>
<td width=52%>Use lowercase.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_SIMPLIFIED_CHINESE</td>
<td width=52%>Map simplified Chinese characters to traditional Chinese characters.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_SORTKEY</td>
<td width=52%>Produce a normalized wide-character sort key.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_TRADITIONAL_CHINESE</td>
<td width=52%>Map traditional Chinese characters to simplified Chinese characters.</td>
</tr>
<tr valign=top>
<td width=48%>LCMAP_UPPERCASE</td>
<td width=52%>Use uppercase.</td>
</tr>
<tr valign=top>
<td width=48%>NORM_IGNORECASE</td>
<td width=52%>Ignore case.</td>
</tr>
<tr valign=top>
<td width=48%>NORM_IGNOREKANATYPE</td>
<td width=52%>Do not differentiate between Hiragana and Katakana characters. Corresponding Hiragana and Katakana will compare as equal.</td>
</tr>
<tr valign=top>
<td width=48%>NORM_IGNORENONSPACE</td>
<td width=52%>Ignore nonspacing. This flag also removes Japanese accent characters.</td>
</tr>
<tr valign=top>
<td width=48%>NORM_IGNORESYMBOLS</td>
<td width=52%>Ignore symbols. </td>
</tr>
<tr valign=top>
<td width=48%>NORM_IGNOREWIDTH</td>
<td width=52%>Do not differentiate between a single-byte character and the same character as a double-byte character.</td>
</tr>
<tr valign=top>
<td width=48%>SORT_STRINGSORT</td>
<td width=52%>Treat punctuation the same as symbols.</td>
</tr>
</table><br>


<p>
If the<b> </b>LCMAP_SORTKEY flag <b>is not</b> specified, the <b>LCMapString</b> function performs string mapping. In this case the following restrictions apply:

<ul>
<li>
LCMAP_LOWERCASE and LCMAP_UPPERCASE are mutually exclusive.</li>
<li>
LCMAP_HIRAGANA and LCMAP_KATAKANA are mutually exclusive.</li>
<li>
LCMAP_HALFWIDTH and LCMAP_FULLWIDTH are mutually exclusive.</li>
<li>
SORT_STRINGSORT, NORM_IGNOREKANATYPE, NORM_IGNOREWIDTH, and NORM_IGNORECASE are not valid.</li>
<li>
LCMAP_TRADITIONAL_CHINESE and LCMAP_SIMPLIFIED_CHINESE are mutually exclusive. </li>
<li>
LCMAP_LOWERCASE and LCMAP_UPPERCASE are not valid in combination with any of the following flags: LCMAP_HIRAGANA, LCMAP_KATAKANA, LCMAP_HALFWIDTH, and LCMAP_FULLWIDTH.</li>
</ul>

<p>
When the LCMAP_SORTKEY flag <b>is</b> specified, the <b>LCMapString</b> function generates a sort key. In this case the following restriction applies:

<ul>
<li>
LCMAP_SORTKEY is mutually exclusive with all other LCMAP_* flags, with the sole exception of LCMAP_BYTEREV. </li>
</ul>
</dd>
<dt>
<i>lpSrcStr</i></dt>
<dd>
Pointer to a source string that the function maps or uses for sort key generation.</dd>
<dt>
<i>cchSrc</i></dt>
<dd>
Specifies the number of bytes (ANSI version) or characters (Unicode version) in the string pointed to by the <i>lpSrcStr</i> parameter. 
<p>
This count can include the NULL terminator, or not include it. If the NULL terminator is included in the character count, it does not greatly affect the mapping behavior. That is because NULL is considered to be unsortable, and always maps to itself.

<p>
A <i>cchSrc</i> value of –1 specifies that the string pointed to by <i>lpSrcStr</i> is null-terminated. If this is the case, and <b>LCMapString</b> is being used in its string-mapping mode, the function calculates the string's length itself, and null-terminates the mapped string stored into *<i>lpDestStr</i>.
</dd>
<dt>
<i>lpDestStr</i></dt>
<dd>
Pointer to a buffer into which the function stores the mapped string or sort key.
<p>
If LCMAP_SORTKEY is specified, <b>LCMapString </b>stores a sort key into the buffer. The sort key is stored as an array of byte values in the following format:

<pre><code>[all Unicode sort weights] 0x01 [all Diacritic weights] 0x01 [all Case weights] 0x01 [all Special weights] 0x00 
 </code></pre>

<p>
Note that the sort key is null-terminated. This is true regardless of the value of <i>cchSrc</i>. Also note that, even if some of the sort weights are absent from the sort key, due to the presence of one or more ignore flags in <i>dwMapFlags</i>, the 0x01 separators and the 0x00 terminator are still present.
</dd>
<dt>
<i>cchDest</i></dt>
<dd>
Specifies the size in bytes (ANSI version) or characters (Unicode version) of the buffer pointed to by <i>lpDestStr</i>. 
<p>
If the function is being used for string mapping, the size is a character count. If space for a NULL terminator is included in <i>cchSrc</i>, then <i>cchDest</i> must also include space for a NULL terminator.

<p>
If the function is being used to generate a sort key, the size is a byte count. This byte count must include space for the sort key 0x00 terminator.

<p>
If <i>cchDest</i> is zero, the function's return value is the number of characters, or bytes if LCMAP_SORTKEY is specified, required to hold the mapped string or sort key. In this case, the buffer pointed to by <i>lpDestStr</i> is not used. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, and the value of <i>cchDest</i> is nonzero, the return value is the number of characters, or bytes if LCMAP_SORTKEY is specified, written to the buffer. This count includes room for a NULL terminator.</p>
<p>
If the function succeeds, and the value of <i>cchDest</i> is zero, the return value is the size of the buffer in characters, or bytes if LCMAP_SORTKEY is specified, required to receive the translated string or sort key. This size includes room for a NULL terminator.</p>
<p>
If the function fails, the return value is 0. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. <b>GetLastError</b> may return one of the following error codes:</p>
<p>
ERROR_INSUFFICIENT_BUFFER<br>
ERROR_INVALID_FLAGS<br>
ERROR_INVALID_PARAMETER</p>
<h4>Remarks</h4>
<p>
The mapped string is null terminated if the source string is null terminated. </p>
<p>
The <b>A</b> version of this function maps strings to and from Unicode based on the specified LCID's default ANSI code page.</p>
<p>
If the LCMAP_HIRAGANA flag is specified to map Katakana characters to Hiragana characters, and LCMAP_FULLWIDTH is not specified, the function only maps full-width characters to Hiragana. In this case, any half-width Katakana characters are placed as-is in the output string, with no mapping to Hiragana. An application must specify LCMAP_FULLWIDTH if it wants half-width Katakana characters mapped to Hiragana.</p>
<p>
The <i>lpSrcStr</i> and <i>lpDestStr</i> pointers must not be the same. If they are the same, the function fails, and <b>GetLastError</b> returns ERROR_INVALID_PARAMETER. </p>
<p>
Even if the wide-character Unicode version of this function is called, the output string is only in <b>WCHAR</b> or <b>CHAR</b> format if the string mapping mode of <b>LCMapString </b>is used. If the sort key generation mode is used, specified by LCMAP_SORTKEY, the output is an array of byte values. An application can compare sort keys by using a byte-by-byte comparison.</p>
<p>
An application can call the function with the NORM_IGNORENONSPACE and NORM_IGNORESYMBOLS flags set, and all other options flags cleared, in order to simply strip characters from the input string. If this is done with an input string that is not null-terminated, it is possible for <b>LCMapString</b> to return an empty string and not return an error.</p>
<p>
The <b>LCMapString</b> function ignores the Arabic Kashida. If an application calls the function to create a sort key for a string containing an Arabic Kashida, there will be no sort key value for the Kashida.</p>
<p>
The function treats the hyphen and apostrophe a bit differently than other punctuation symbols, so that words like coop and co-op stay together in a list. All punctuation symbols other than the hyphen and apostrophe sort before the alphanumeric characters. An application can change this behavior by setting the SORT_STRINGSORT flag. See <a href="strings_8lif.htm"><b>CompareString</b></a><b> </b>for a more detailed discussion of this issue. </p>
<p>
When <b>LCMapString</b> is used to generate a sort key, by setting the LC_MAPSORTKEY flag, the sort key stored into *<i>lpDestStr</i> may contain an odd number of bytes. The LCMAP_BYTEREV option only reverses an even number of bytes. If both options are chosen, the last (odd-positioned) byte in the sort key is not reversed. If the terminating 0x00 byte is an odd-positioned byte, then it remains the last byte in the sort key. If the terminating 0x00 byte is an even-positioned byte, it exchanges positions with the byte that precedes it.</p>
<p>
<b>Windows CE:</b> The following <i>dwMapFlags</i> values are not supported:</p>
<p class=indent1>
LCMAP_LINGUISTIC_CASING</p>
<p class=indent1>
LCMAP_SIMPLIFIED_CHINESE</p>
<p class=indent1>
LCMAP_TRADITIONAL_CHINESE</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winnls.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Implemented as Unicode and ANSI versions on Windows NT.</p>
<h4>See Also</h4>
<p>
<a href="nls_19f8.htm">National Language Support Overview</a>, <a href="nls_8d0z.htm">National Language Support Functions</a>, <a href="strings_8lif.htm"><b>CompareString</b></a>, <a href="strings_3rdz.htm"><b>FoldString</b></a>, <a href="nls_7qck.htm"><b>MAKELCID</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
