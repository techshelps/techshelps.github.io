<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>wsprintf</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_wsprintf"></a>wsprintf</h1>
<p>
The <b>wsprintf</b> function formats and stores a series of characters and values in a buffer. Any arguments are converted and copied to the output buffer according to the corresponding format specification in the format string. The function appends a terminating null character to the characters it writes, but the return value does not include the terminating null character in its character count. </p>
<pre><code><b>int wsprintf(
  LPTSTR</b><i> lpOut</i><b>,    </b>// pointer to buffer for output
<b>  LPCTSTR</b><i> lpFmt</i><b>,</b>   // pointer to format-control string
<b> </b><i> ...              </i>// optional arguments
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>lpOut</i></dt>
<dd>
Pointer to a buffer to receive the formatted output. The maximum size of the buffer is 1024 bytes.</dd>
<dt>
<i>lpFmt</i></dt>
<dd>
Pointer to a null-terminated string that contains the format-control specifications. In addition to ordinary ASCII characters, a format specification for each argument appears in this string. For more information about the format specification, see the Remarks section. </dd>
<dt>
...</dt>
<dd>
Specifies one or more optional arguments. The number and type of argument parameters depend on the corresponding format-control specifications in the <i>lpFmt</i> parameter. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is the number of characters stored in the output buffer, not counting the terminating null character. </p>
<p>
If the function fails, the return value is less than the length of the format-control string. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<h4>Remarks</h4>
<p>
The format-control string contains format specifications that determine the output format for the arguments following the <i>lpFmt</i> parameter. Format specifications, discussed below, always begin with a percent sign (%). If a percent sign is followed by a character that has no meaning as a format field, the character is not formatted (for example, %% produces a single percent-sign character). </p>
<p>
The format-control string is read from left to right. When the first format specification (if any) is encountered, it causes the value of the first argument after the format-control string to be converted and copied to the output buffer according to the format specification. The second format specification causes the second argument to be converted and copied, and so on. If there are more arguments than format specifications, the extra arguments are ignored. If there are not enough arguments for all of the format specifications, the results are undefined. </p>
<p>
A format specification has the following form: </p>
<p>
<b>%</b>[<b>-</b>][<b>#</b>][<b>0</b>][<i>width</i>][<b>.</b><i>precision</i>]<i>type</i></p>
<p>
Each field is a single character or a number signifying a particular format option. The <i>type</i> characters that appear after the last optional format field determine whether the associated argument is interpreted as a character, a string, or a number. The simplest format specification contains only the percent sign and a type character (for example, <b>%s</b>). The optional fields control other aspects of the formatting. Following are the optional and required fields and their meanings: </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=17%>Field</th>
<th align=left width=83%>Meaning</th>
</tr>
<tr valign=top>
<td width=17%><b>–</b></td>
<td width=83%>Pad the output with blanks or zeros to the right to fill the field width, justifying output to the left. If this field is omitted, the output is padded to the left, justifying it to the right.</td>
</tr>
<tr valign=top>
<td width=17%><b>#</b></td>
<td width=83%>Prefix hexadecimal values with 0x (lowercase) or 0X (uppercase).</td>
</tr>
<tr valign=top>
<td width=17%><b>0</b></td>
<td width=83%>Pad the output value with zeros to fill the field width. If this field is omitted, the output value is padded with blank spaces.</td>
</tr>
<tr valign=top>
<td width=17%><i>width</i></td>
<td width=83%>Copy the specified minimum number of characters to the output buffer. The <i>width</i> field is a nonnegative integer. The width specification never causes a value to be truncated; if the number of characters in the output value is greater than the specified width, or if the <i>width</i> field is not present, all characters of the value are printed, subject to the precision specification.</td>
</tr>
<tr valign=top>
<td width=17%><b>.</b><i>precision</i></td>
<td width=83%>For numbers, copy the specified minimum number of digits to the output buffer. If the number of digits in the argument is less than the specified precision, the output value is padded on the left with zeros. The value is not truncated when the number of digits exceeds the specified precision. If the specified precision is 0 or omitted entirely, or if the period (<b>.</b>) appears without a number following it, the precision is set to 1.</td>
</tr>
<tr valign=top>
<td width=17%></td>
<td width=83%>For strings, copy the specified maximum number of characters to the output buffer.</td>
</tr>
<tr valign=top>
<td width=17%><i>type</i></td>
<td width=83%>Output the corresponding argument as a character, a string, or a number. This field can be any of the following character sequences:</td>
</tr>
</table><br>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=19%>Sequence</th>
<th align=left width=81%>Insert</th>
</tr>
<tr valign=top>
<td width=19%><b>c</b></td>
<td width=81%>A single character. This sequence is interpreted as type <b>WCHAR</b> when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag and as type <b>CHAR</b> otherwise.</td>
</tr>
<tr valign=top>
<td width=19%><b>C</b></td>
<td width=81%>A single character. This sequence is interpreted as type <b>CHAR</b> when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag and as type <b>WCHAR</b> otherwise.</td>
</tr>
<tr valign=top>
<td width=19%><b>d</b></td>
<td width=81%>A signed decimal integer argument. This sequence is equivalent to the <b>i</b> sequence.</td>
</tr>
<tr valign=top>
<td width=19%><b>hc</b>, <b>hC</b></td>
<td width=81%>A single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This sequence is always interpreted as type <b>CHAR</b>, even when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag.</td>
</tr>
<tr valign=top>
<td width=19%><b>hd</b></td>
<td width=81%>A signed short integer argument.</td>
</tr>
<tr valign=top>
<td width=19%><b>hs</b>, <b>hS</b></td>
<td width=81%>A string. This sequence is always interpreted as type <b>LPSTR</b>, even when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag.</td>
</tr>
<tr valign=top>
<td width=19%><b>hu</b></td>
<td width=81%>An unsigned short integer argument.</td>
</tr>
<tr valign=top>
<td width=19%><b>i</b></td>
<td width=81%>A signed decimal integer. This sequence is equivalent to the <b>d</b> sequence.</td>
</tr>
<tr valign=top>
<td width=19%><b>lc</b>, <b>lC</b></td>
<td width=81%>A single character. The <b>wsprintf</b> function ignores character arguments with a numeric value of zero. This sequence is always interpreted as type <b>WCHAR</b>, even when the calling application does not use the <b>#define</b> <b>UNICODE</b> compile flag.</td>
</tr>
<tr valign=top>
<td width=19%><b>ld</b></td>
<td width=81%>A long signed decimal integer. This sequence is equivalent to the <b>li</b> sequence.</td>
</tr>
<tr valign=top>
<td width=19%><b>li</b></td>
<td width=81%>A long signed decimal integer. This sequence is equivalent to the <b>ld</b> sequence.</td>
</tr>
<tr valign=top>
<td width=19%><b>ls</b>, <b>lS</b></td>
<td width=81%>A string. This sequence is always interpreted as type <b>LPWSTR</b>, even when the calling application does not use the <b>#define</b> <b>UNICODE</b> compile flag. This sequence is equivalent to the <b>ws</b> sequence.</td>
</tr>
<tr valign=top>
<td width=19%><b>lu</b></td>
<td width=81%>A long unsigned integer.</td>
</tr>
<tr valign=top>
<td width=19%><b>lx</b>, <b>lX</b></td>
<td width=81%>A long unsigned hexadecimal integer in lowercase or uppercase.</td>
</tr>
<tr valign=top>
<td width=19%><b>s</b></td>
<td width=81%>A string. This sequence is interpreted as type <b>LPWSTR</b> when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag and as type <b>LPSTR</b> otherwise.</td>
</tr>
<tr valign=top>
<td width=19%><b>S</b></td>
<td width=81%>A string. This sequence is interpreted as type <b>LPSTR</b> when the calling application uses the <b>#define</b> <b>UNICODE</b> compile flag and as type <b>LPWSTR</b> otherwise.</td>
</tr>
<tr valign=top>
<td width=19%><b>u</b></td>
<td width=81%>An unsigned integer argument.</td>
</tr>
<tr valign=top>
<td width=19%><b>x</b>, <b>X</b></td>
<td width=81%>An unsigned hexadecimal integer in lowercase or uppercase.</td>
</tr>
</table><br>
<p>
<b>Note</b>&nbsp;&nbsp;Unlike other Win32 functions, <b>wsprintf</b> uses the C calling convention (<b>_cdecl</b>), rather than the Pascal calling convention. As a result, it is the responsibility of the calling process to pop arguments off the stack, and arguments are pushed on the stack from right to left. In C-language modules, the C compiler performs this task. </p>
<p>
<b>Windows CE:</b> Windows CE supports only the Unicode version of <b>wsprintf</b>. </p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Requires version 1.0 or later.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winuser.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use user32.lib.<br>
<b>&nbsp;&nbsp;Unicode: </b>Implemented as Unicode and ANSI versions on Windows NT.</p>
<h4>See Also</h4>
<p>
<a href="strings_70ry.htm">String Manipulation Overview</a>, <a href="strings_97n7.htm">String Manipulation Functions</a>, <a href="strings_92hy.htm"><b>wvsprintf</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
