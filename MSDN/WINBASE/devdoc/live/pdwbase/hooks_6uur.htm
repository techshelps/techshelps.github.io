<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Installing and Releasing Hook Procedures</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_installing_and_releasing_hook_procedures"></a>Installing and Releasing Hook Procedures</h2>
<p>
You can install a hook procedure by calling the <a href="hooks_7vaw.htm"><b>SetWindowsHookEx</b></a> function and specifying the type of hook calling the procedure, whether the procedure should be associated with all threads or with a particular thread, and a pointer to a procedure entry point. </p>
<p>
You must place a global hook procedure in a DLL separate from the application installing the hook procedure. The installing application must have the handle to the DLL module before it can install the hook procedure. The <a href="dll_1o8p.htm"><b>LoadLibrary</b></a> function, when given the name of the DLL, returns the handle to the DLL module. After you have the handle, you can call the <a href="dll_0f8z.htm"><b>GetProcAddress</b></a> function to retrieve the address of the hook procedure. Finally, you use <b>SetWindowsHookEx</b> to install the hook procedure address in the appropriate hook chain. <b>SetWindowsHookEx</b> passes the module handle, a pointer to the hook-procedure entry point, and 0 for the thread identifier, indicating that the hook procedure should be associated with all threads in the system. This sequence is shown in the following example. </p>
<pre><code>HOOKPROC hkprcSysMsg; 
static HINSTANCE hinstDLL; 
static HHOOK hhookSysMsg; 
 
hinstDLL = LoadLibrary((LPCTSTR) "c:\\windows\\sysmsg.dll"); 
hkprcSysMsg = (HOOKPROC)GetProcAddress(hinstDLL, "SysMessageProc"); 
hhookSysMsg = SetWindowsHookEx(WH_SYSMSGFILTER, 
    hkprcSysMsg, hinstDLL, 0); 
 </code></pre>
<p>
You can release a thread-specific hook procedure (remove its address from the hook chain) by calling the <a href="hooks_6fy0.htm"><b>UnhookWindowsHookEx</b></a> function, specifying the handle to the hook procedure to release. Release a hook procedure as soon as your application no longer needs it. </p>
<p>
You can release a global hook procedure by using <b>UnhookWindowsHookEx</b>, but this function does not free the DLL containing the hook procedure. This is because global hook procedures are called in the process context of every application in the system, causing an implicit call to the <a href="dll_1o8p.htm"><b>LoadLibrary</b></a> function for all of those processes. Because a call to the <a href="dll_3cs9.htm"><b>FreeLibrary</b></a> function cannot be made for another process, there is then no way to free the DLL. The system eventually frees the DLL after all processes explicitly linked to the DLL have either terminated or called <b>FreeLibrary</b> and all processes that called the hook procedure have resumed processing outside the DLL. </p>
<p>
An alternative method for installing a global hook procedure is to provide an installation function in the DLL, along with the hook procedure. With this method, the installing application does not need the handle to the DLL module. By linking with the DLL, the application gains access to the installation function. The installation function can supply the DLL module handle and other details in the call to <a href="hooks_7vaw.htm"><b>SetWindowsHookEx</b></a>. The DLL can also contain a function that releases the global hook procedure; the application can call this hook-releasing function when terminating. </p>
<p>&nbsp;</p></body>
</HTML>
