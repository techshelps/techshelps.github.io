<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Event Objects</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_using_event_objects"></a>Using Event Objects</h2>
<p>
Win32-based applications use event objects in a number of situations to notify a waiting thread of the occurrence of an event. For example, overlapped I/O operations on files, named pipes, and communications devices use an event object to signal their completion. For more information about the use of event objects in overlapped I/O operations, see <a href="synchro_4ur8.htm">Synchronization and Overlapped Input and Output</a>.</p>
<p>
In the following example, an application uses event objects to prevent several threads from reading from a shared memory buffer while a master thread is writing to that buffer. First, the master thread uses the <a href="synchro_8ub8.htm"><b>CreateEvent</b></a> function to create a manual-reset event object. The master thread sets the event object to nonsignaled when it is writing to the buffer and then resets the object to signaled when it has finished writing. Then it creates several reader threads and an auto-reset event object for each thread. Each reader thread sets its event object to signaled when it is not reading from the buffer. </p>
<pre><code>#define NUMTHREADS 4 

HANDLE hGlobalWriteEvent; 

void CreateEventsAndThreads(void) 
{
    HANDLE hReadEvents[NUMTHREADS], hThread; 
    DWORD i, IDThread; 

    // Create a manual-reset event object. The master thread sets 
    // this to nonsignaled when it writes to the shared buffer. 

    hGlobalWriteEvent = CreateEvent( 
        NULL,         // no security attributes
        TRUE,         // manual-reset event
        TRUE,         // initial state is signaled
        "WriteEvent"  // object name
        ); 

    if (hGlobalWriteEvent == NULL) { 
        // error exit
    }

    // Create multiple threads and an auto-reset event object 
    // for each thread. Each thread sets its event object to 
    // signaled when it is not reading from the shared buffer. 

    for(i = 1; i &lt;= NUMTHREADS; i++) 
    {
        // Create the auto-reset event.
        hReadEvents[i] = CreateEvent( 
            NULL,     // no security attributes
            FALSE,    // auto-reset event
            TRUE,     // initial state is signaled
            NULL);    // object not named

        if (hReadEvents[i] == NULL) 
        {
            // Error exit.
        }

        hThread = CreateThread(NULL, 0, 
            (LPTHREAD_START_ROUTINE) ThreadFunction, 
            &amp;hReadEvents[i],  // pass event handle
            0, &amp;IDThread); 
        if (hThread == NULL) 
        {
            // Error exit.
        }
    }
}
 </code></pre>
<p>
Before the master thread writes to the shared buffer, it uses the <a href="synchro_4f78.htm"><b>ResetEvent</b></a> function to set the state of <code>hGlobalWriteEvent</code> (an application-defined global variable) to nonsignaled. This blocks the reader threads from starting a read operation. The master then uses the <a href="synchro_9xbn.htm"><b>WaitForMultipleObjects</b></a> function to wait for all reader threads to finish any current read operations. When <b>WaitForMultipleObjects</b> returns, the master thread can safely write to the buffer. After it has finished, it sets <code>hGlobalWriteEvent</code> and all the reader-thread events to signaled, enabling the reader threads to resume their read operations. </p>
<pre><code>VOID WriteToBuffer(VOID) 
{
    DWORD dwWaitResult, i; 

    // Reset hGlobalWriteEvent to nonsignaled, to block readers.
 
    if (! ResetEvent(hGlobalWriteEvent) ) 
    { 
        // Error exit.
    } 

    // Wait for all reading threads to finish reading.

    dwWaitResult = WaitForMultipleObjects( 
        NUMTHREADS,   // number of handles in array
        hReadEvents,  // array of read-event handles
        TRUE,         // wait until all are signaled
        INFINITE);    // indefinite wait

    switch (dwWaitResult) 
    {
        // All read-event objects were signaled.
        case WAIT_OBJECT_0: 
            // Write to the shared buffer.
            break;

        // An error occurred.
        default: 
            printf("Wait error: %d\n", GetLastError()); 
            ExitProcess(0); 
    } 

    // Set hGlobalWriteEvent to signaled.

    if (! SetEvent(hGlobalWriteEvent) ) 
    {
        // Error exit.
    }

    // Set all read events to signaled.
    for(i = 1; i &lt;= NUMTHREADS; i++) 
        if (! SetEvent(hReadEvents[i]) ) { 
            // Error exit.
        } 
}
 </code></pre>
<p>
Before starting a read operation, each reader thread uses <a href="synchro_9xbn.htm"><b>WaitForMultipleObjects</b></a> to wait for the application-defined global variable <code>hGlobalWriteEvent</code> and its own read event to be signaled. When <b>WaitForMultipleObjects</b> returns, the reader thread's auto-reset event has been reset to nonsignaled. This blocks the master thread from writing to the buffer until the reader thread uses the <a href="synchro_8ut0.htm"><b>SetEvent</b></a> function to set the event's state back to signaled. </p>
<pre><code>VOID ThreadFunction(LPVOID lpParam) 
{
    DWORD dwWaitResult, i;
    HANDLE hEvents[2]; 

    hEvents[0] = (HANDLE) *lpParam;  // thread's read event
    hEvents[1] = hGlobalWriteEvent; 

    dwWaitResult = WaitForMultipleObjects( 
        2,            // number of handles in array
        hEvents,      // array of event handles
        TRUE,         // wait till all are signaled
        INFINITE);    // indefinite wait

    switch (dwWaitResult) 
    {

        // Both event objects were signaled.
        case WAIT_OBJECT_0: 
            // Read from the shared buffer.
            break; 

        // An error occurred.
        default: 
            printf("Wait error: %d\n", GetLastError()); 
            ExitThread(0); 
    }

    // Set the read event to signaled.

    if (! SetEvent(hEvents[0]) ) 
    { 
        // Error exit.
    } 
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
