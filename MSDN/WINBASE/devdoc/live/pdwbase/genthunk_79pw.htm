<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CallProcEx32W</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_callprocex32w_pt"></a>CallProcEx32W</h1>
<p>
Use the <b>CallProcEx32W</b> function in 16-bit code to call an entry-point function in a 32-bit DLL. <b>CallProcEx32W</b> is similar to <a href="genthunk_61h0.htm"><b>CallProc32W</b></a>, but it uses the C calling convention to allow a variable number of arguments. </p>
<pre><code><b>DWORD FAR CallProcEx32W(
  DWORD</b><i> nParams</i><b>,          </b>// number of parameters passed
<b>  DWORD</b><i> fAddressConvert</i><b>,  </b>// bit mask
<b>  DWORD</b><i> lpProcAddress</i><b>,    </b>// the DLL function to be called
<b>  DWORD</b><i> param1            </i>// parameter for DLL function
<b> </b><i> ...                     </i>// up to 32 parameters for DLL function
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>nParams</i></dt>
<dd>
Number of <b>DWORD</b> parameters to be passed to the DLL function (<i>param1</i> through <i>paramN</i>). For functions that take no parameters, this parameter will be zero. You can also specify the calling convention by using the OR operator to combine this value with one of the following constants:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=42%>Value</th>
<th align=left width=58%>Meaning</th>
</tr>
<tr valign=top>
<td width=42%>CPEX_DEST_STDCALL</td>
<td width=58%>The function uses the standard-call calling convention. This is the default.</td>
</tr>
<tr valign=top>
<td width=42%>CPEX_DEST_CDECL</td>
<td width=58%>The function uses the C calling convention.</td>
</tr>
</table><br>

</dd>
<dt>
<i>fAddressConvert</i></dt>
<dd>
Bit mask representing which parameters will be treated as 16:16 pointers and translated into flat linear pointers before being passed to the 32-bit procedure. The lowest bit in the mask represents the first parameter specified (<i>param1</i>), the second lowest bit represents the second to the last parameter specified (<i>param2</i>), and so on, so that the highest bit in the mask represents <i>paramN</i>. </dd>
<dt>
<i>lpProcAddress</i></dt>
<dd>
A value corresponding to the procedure to be called, which is returned by the <a href="genthunk_9qwk.htm"><b>GetProcAddress32W</b></a> function.</dd>
<dt>
<i>param1</i> through <i>param32</i></dt>
<dd>
Parameters for the 32-bit procedure represented by <i>lpProcAddress</i>
</dd>
</dl>
<h4>Return Values</h4>
<p>
Returns the return value from the 32-bit entry-point function represented by <i>lpProcAddress. </i>The return value can also be zero under the following conditions: 
<ul>
<li>
<i>lpProcAddress</i> is zero </li>
<li>
<i>nParams</i> is greater than 32 </li>
<li>
<i>lpProcAddress</i> returns zero</li>
</ul>
<h4>Remarks</h4>
<p>
<b>CallProc32W</b> and <b>CallProcEx32W</b> do not automatically fix global memory handles that are translated to 0:32 pointers. Therefore, you must call the <b>GlobalFix</b> or <b>GlobalWire</b> function on the handle first and <b>GlobalUnfix</b> and <b>GlobalUnwire</b> afterward. </p>
<p class=indent1>
<b>Windows 95 and Windows 98:</b> Global compaction can move memory blocks at any time while the current thread is executing 32-bit code. Because of this, not fixing segments before calling the target function works in Windows NT, but may cause race conditions in Windows 95 or Windows 98.</p>
<h4>See Also</h4>
<p>
<a href="genthunk_61h0.htm"><b>CallProc32W</b></a>, <a href="genthunk_9qwk.htm"><b>GetProcAddress32W</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
