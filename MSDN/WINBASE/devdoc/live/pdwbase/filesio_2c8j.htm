<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using I/O Completion Ports</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_using_i_o_completion_ports"></a>Using I/O Completion Ports</h3>
<p>
I/O completion ports are used with asynchronous I/O. The <a href="filesio_4k1g.htm"><b>CreateIoCompletionPort</b></a> function associates an I/O completion port with one or more file handles. When an asynchronous I/O operation started on a file handle associated with an I/O completion port is completed, an I/O completion packet is queued to the port. This can be used to combine the synchronization point for multiple file handles into a single object.</p>
<p>
A thread uses the <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a> function to wait for an I/O completion packet to be queued to the I/O completion port, rather than waiting directly for the asynchronous I/O to complete. Threads that block their execution on an I/O completion port are released in last-in-first-out (LIFO) order. This means that when an I/O completion packet is queued to the I/O completion port, the system releases the last thread to block its execution on the port.</p>
<p>
The most important property of an I/O completion port is the concurrency value. The concurrency value of an I/O completion port is specified when the I/O completion port is created. This value limits the number of runnable threads associated with the I/O completion port. When the total number of runnable threads associated with the I/O completion port reaches the concurrency value, the system blocks the execution of the threads until the number of runnable threads associated with the I/O completion port drops below the concurrency value. The most efficient scenario occurs when there are I/O completion packets waiting in the queue, but no waits can be satisfied because the port has reached its concurrency limit. In this case, when a running thread calls <b>GetQueuedCompletionStatus</b>, it will immediately pick up the queued I/O completion packet. No context switches will occur, because the running thread is continually picking up I/O completion packets and the other threads are unable to run.</p>
<p>
The best value to pick for the concurrency value is the number of CPUs on the machine. If your transaction required a lengthy computation, a larger concurrency value will allow more threads to run. Each transaction will take longer to complete, but more transactions will be processed at the same time. It is easy to experiment with the concurrency value to achieve the best effect for your application.</p>
<p>
The <a href="filesio_33g3.htm"><b>PostQueuedCompletionStatus</b></a> function allows an application to queue its own special-purpose I/O completion packets to the I/O completion port without starting an asynchronous I/O operation. This is useful for notifying worker threads of external events.</p>
<p>
The I/O completion port is freed when there are no more references to it. The port handle and every file handle associated with the I/O completion port reference the I/O completion port. All the handles must be closed to free the I/O completion port. To close the port handle, call the <a href="handobj_289x.htm"><b>CloseHandle</b></a> function. </p>
<p>&nbsp;</p></body>
</HTML>
