<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Checking A Client's Access</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_checking_a_client_s_access"></a>Checking A Client's Access</h2>
<p>
The following example shows how a server could check the access rights that a security descriptor allows for a client. The example uses the <a href="accclsrv_8450.htm"><b>ImpersonateNamedPipeClient</b></a> function, but it would work the same if you used any of the other impersonation functions. After impersonating the client, the example calls the <a href="accctrl_8bam.htm"><b>OpenThreadToken</b></a> function to get the impersonation token. It calls the <a href="accclsrv_8757.htm"><b>MapGenericMask</b></a> function to convert any generic access rights to the corresponding specific and standard rights according to the mapping specified in the <a href="accclsrv_29rm.htm"><b>GENERIC_MAPPING</b></a> structure. </p>
<p>
The <a href="accclsrv_5jjf.htm"><b>AccessCheck</b></a> function checks the requested access rights against the rights allowed for the client in the DACL of the security descriptor. To check access and generate an entry in the security event log, use the <a href="accclsrv_5ze5.htm"><b>AccessCheckAndAuditAlarm</b></a> function.</p>
<pre><code>BOOL ImpersonateAndCheckAccess(
  HANDLE hNamedPipe,               // handle of pipe to impersonate
  PSECURITY_DESCRIPTOR pSD,        // security descriptor to check
  DWORD dwAccessDesired,           // access rights to check
  PGENERIC_MAPPING pGeneric,       // generic mapping for object
  PDWORD pdwAccessAllowed          // returns allowed access rights
) {

HANDLE hToken;
PRIVILEGE_SET PrivilegeSet;
DWORD dwPrivSetSize = sizeof( PRIVILEGE_SET );
BOOL fAccessGranted=FALSE;

// Impersonate the client.

if (! ImpersonateNamedPipeClient(hNamedPipe) ) 
    return FALSE;

// Get an impersonation token with the client's security context.

if (! OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS,
                TRUE, &amp;hToken ) )
    goto Cleanup;

// Use the GENERIC_MAPPING structure to convert any 
// generic access rights to object-specific access rights.

MapGenericMask( &amp;dwAccessDesired, pGeneric );

// Check the client's access rights.

if( !AccessCheck( 
    pSD,                 // security descriptor to check
    hToken,              // impersonation token
    dwAccessDesired,     // requested access rights
    pGeneric,            // pointer to GENERIC_MAPPING
    &amp;PrivilegeSet,       // receives privileges used in check
    &amp;dwPrivSetSize,      // size of PrivilegeSet buffer
    pdwAccessAllowed,    // receives mask of allowed access rights
    &amp;fAccessGranted )    // receives results of access check
)
    goto Cleanup;

Cleanup:

RevertToSelf();

if (hToken != INVALID_HANDLE_VALUE)
    CloseHandle(hToken);  

return fAccessGranted;

}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
