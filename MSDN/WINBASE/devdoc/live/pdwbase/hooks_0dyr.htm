<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WH_MSGFILTER and WH_SYSMSGFILTER Hooks</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_win32_wh_msgfilter_and_wh_sysmsgfilter_hooks"></a>WH_MSGFILTER and WH_SYSMSGFILTER Hooks</h3>
<p>
The WH_MSGFILTER and WH_SYSMSGFILTER hooks enable you to monitor messages about to be processed by a menu, scroll bar, message box, or dialog box, and to detect when a different window is about to be activated as a result of the user's pressing the alt+tab or alt+esc key combination. The WH_MSGFILTER hook can only monitor messages passed to a menu, scroll bar, message box, or dialog box created by the application that installed the hook procedure. The WH_SYSMSGFILTER hook monitors such messages for all applications. </p>
<p>
The WH_MSGFILTER and WH_SYSMSGFILTER hooks enable you to perform message filtering during modal loops that is equivalent to the filtering done in the main message loop. For example, an application often examines a new message in the main loop between the time it retrieves the message from the queue and the time it dispatches the message, performing special processing as appropriate. However, during a modal loop, the system retrieves and dispatches messages without allowing an application the chance to filter the messages in its main message loop. If an application installs a WH_MSGFILTER or WH_SYSMSGFILTER hook procedure, the system calls the procedure during the modal loop. </p>
<p>
An application can call the WH_MSGFILTER hook directly by calling the <a href="hooks_1wdu.htm"><b>CallMsgFilter</b></a> function. By using this function, the application can use the same code to filter messages during modal loops as it uses in the main message loop. To do so, encapsulate the filtering operations in a WH_MSGFILTER hook procedure and call <b>CallMsgFilter</b> between the calls to the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_getmessage">
</object><a href=JavaScript:alink_1.Click()><b>GetMessage</b></a> and <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_dispatchmessage">
</object><a href=JavaScript:alink_2.Click()><b>DispatchMessage</b></a> functions. </p>
<pre><code>while (GetMessage(&amp;msg, (HWND) NULL, 0, 0)) 
{ 
    if (!CallMsgFilter(&amp;qmsg, 0)) 
        DispatchMessage(&amp;qmsg); 
} 
 </code></pre>
<p>
The last argument of <a href="hooks_1wdu.htm"><b>CallMsgFilter</b></a> is simply passed to the hook procedure; you can enter any value. The hook procedure, by defining a constant such as MSGF_MAINLOOP, can use this value to determine where the procedure was called from. </p>
<p>
For more information, see the <a href="hooks_852b.htm"><b>MessageProc</b></a> and <a href="hooks_4zab.htm"><b>SysMsgProc</b></a> functions. </p>
<p>&nbsp;</p></body>
</HTML>
