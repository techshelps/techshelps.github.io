<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reserving and Committing Memory</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_reserving_and_committing_memory"></a>Reserving and Committing Memory</h2>
<p>
The following example illustrates the use of the <a href="memman_3elf.htm"><b>VirtualAlloc</b></a> and <a href="memman_0dr9.htm"><b>VirtualFree</b></a> functions in reserving and committing memory as needed for a dynamic array. First, <b>VirtualAlloc</b> is called to reserve a block of pages with NULL specified as the base address parameter, forcing the system to determine the location of the block. Later, <b>VirtualAlloc</b> is called whenever it is necessary to commit a page from this reserved region, and the base address of the next page to be committed is specified. </p>
<p>
The example uses <b>try</b>-<b>except</b> structured exception-handling syntax to commit pages from the reserved region. Whenever a page fault exception occurs during the execution of the <b>try</b> block, the filter function in the expression preceding the <b>except</b> block is executed. If the filter function can allocate another page, execution continues in the <b>try</b> block at the point where the exception occurred. Otherwise, the exception handler in the <b>except</b> block is executed. For more information, see <a href="structex_03xj.htm">Structured Exception Handling</a>. </p>
<p>
As an alternative to dynamic allocation, the process can simply commit the entire region instead of only reserving it. However, committing the region consumes physical storage that might not be needed, making it unavailable for use by other processes. </p>
<p>
The example uses <b>VirtualFree</b> to free the reserved and committed pages when it is finished with them. The function is called twice: first to decommit the committed pages and again to release the entire region of reserved pages. </p>
<pre><code>#define PAGELIMIT 80 
#define PAGESIZE 0x1000 
 
INT PageFaultExceptionFilter(DWORD); 
VOID MyErrorExit(LPTSTR); 
 
LPTSTR lpNxtPage; 
DWORD dwPages = 0; 
 
VOID UseDynamicVirtualAlloc(VOID) 
{ 
    LPVOID lpvBase; 
    LPTSTR lpPtr; 
    BOOL bSuccess; 
    DWORD i; 
 
    // Reserve pages in the process's virtual address space. 
 
    lpvBase = VirtualAlloc( 
        NULL,               // system selects address 
        PAGELIMIT*PAGESIZE, // size of allocation 
        MEM_RESERVE,        // allocates reserved pages 
        PAGE_NOACCESS);     // protection = no access 
    if (lpvBase == NULL ) 
        MyErrorExit("VirtualAlloc reserve"); 
 
    lpPtr = lpNxtPage = (LPTSTR) lpvBase; 
 
    // Use try-except structured exception handling when 
    // accessing the pages. If a page fault occurs, the 
    // exception filter is executed to commit another page 
    // from the reserved block of pages. 
 
    for (i=0; i &lt; PAGELIMIT*PAGESIZE; i++) 
    { 
        try 
        { 
            // Write to memory. 
 
            lpPtr[i] = 'a'; 
        } 
 
        // If there's a page fault, commit another page and try again. 
 
        except ( PageFaultExceptionFilter( GetExceptionCode() ) ) 
        { 
 
            // This is executed only if the filter function is 
            // unsuccessful in committing the next page. 
 
          ExitProcess( GetLastError() ); 
 
      } 
 
  } 
 
    // Release the block of pages when you are finished using them. 
 
    // First, decommit the committed pages. 
 
    bSuccess = VirtualFree( 
            lpvBase,          // base address of block 
            dwPages*PAGESIZE, // bytes of committed pages 
            MEM_DECOMMIT);    // decommit the pages 
 
    // Release the entire block. 
 
    if (bSuccess) 
    {
        bSuccess = VirtualFree( 
            lpvBase,        // base address of block 
            0,              // releases the entire block 
            MEM_RELEASE);   // releases the pages 
    }
} 
 
INT PageFaultExceptionFilter(DWORD dwCode) 
{ 
    LPVOID lpvResult; 
 
    // If the exception is not a page fault, exit. 
 
    if (dwCode != EXCEPTION_ACCESS_VIOLATION) 
    { 
        printf("exception code = %d\n", dwCode); 
        return EXCEPTION_EXECUTE_HANDLER; 
    } 
 
    printf("page fault\n"); 
 
    // If the reserved pages are used up, exit. 
 
    if (dwPages &gt;= PAGELIMIT) 
    { 
        printf("out of pages\n"); 
        return EXCEPTION_EXECUTE_HANDLER; 
    } 
 
    // Otherwise, commit another page. 
 
    lpvResult = VirtualAlloc( 
        (LPVOID) lpNxtPage, // next page to commit 
        PAGESIZE,           // page size, in bytes 
        MEM_COMMIT,         // alloc committed page 
        PAGE_READWRITE);    // read-write access 
    if (lpvResult == NULL ) 
    { 
        printf("VirtualAlloc failed\n"); 
        return EXCEPTION_EXECUTE_HANDLER; 
    } 
 
    // Increment the page count, and advance lpNxtPage 
    // to the next page. 
 
    dwPages++; 
    lpNxtPage += PAGESIZE; 
 
    // Continue execution where the page fault occurred. 
 
    return EXCEPTION_CONTINUE_EXECUTION; 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
