<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ReadFileEx</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_readfileex"></a>ReadFileEx</h1>
<p>
The <b>ReadFileEx</b> function reads data from a file asynchronously. It is designed solely for asynchronous operation, unlike the <a href="filesio_39id.htm"><b>ReadFile</b></a> function, which is designed for both synchronous and asynchronous operation. <b>ReadFileEx</b> lets an application perform other processing during a file read operation.</p>
<p>
The <b>ReadFileEx</b> function reports its completion status asynchronously, calling a specified completion routine when reading is completed or canceled and the calling thread is in an alertable wait state.</p>
<pre><code><b>BOOL ReadFileEx(
  HANDLE</b> <i>hFile</i><b>,</b>                // handle of file to read 
<b>  LPVOID</b> <i>lpBuffer</i><b>,</b>             // pointer to buffer 
<b>  DWORD</b> <i>nNumberOfBytesToRead</i><b>,</b>  // number of bytes to read 
<b>  LPOVERLAPPED</b> <i>lpOverlapped</i><b>,</b>   // pointer to offset 
<b>  LPOVERLAPPED_COMPLETION_ROUTINE</b> <i>lpCompletionRoutine</i> 
                               // pointer to completion routine 
<b>);</b>
<b> </b></code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hFile</i></dt>
<dd>
Open handle that specifies the file entity to be read from. This file handle must have been created with the FILE_FLAG_OVERLAPPED flag and must have GENERIC_READ access to the file. 
<dl>
<dt>
<b>Windows NT:</b> </dt>
<dd>
<i>hFile</i> can be any handle opened with the FILE_FLAG_OVERLAPPED flag by the <a href="filesio_7wmd.htm"><b>CreateFile</b></a> function, or a socket handle returned by the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_socket_2">
</object><a href=JavaScript:alink_1.Click()><b>socket</b></a> or <object id=alink_2 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_accept_2">
</object><a href=JavaScript:alink_2.Click()><b>accept</b></a> functions. </dd>
<dt>
<b>Windows 95:</b> </dt>
<dd>
<i>hFile</i> can be a communications resource, mailslot, or named pipe handle opened with the FILE_FLAG_OVERLAPPED flag by <b>CreateFile</b>, or a socket handle returned by the <b>socket</b> or <b>accept</b> functions. Windows 95 does not support asynchronous operations on disk files. </dd>
</dl>
</dd>
<dt>
<i>lpBuffer</i></dt>
<dd>
Pointer to a buffer that receives the data read from the file. 
<p>
This buffer must remain valid for the duration of the read operation. The application should not use this buffer until the read operation is completed.
</dd>
<dt>
<i>nNumberOfBytesToRead</i></dt>
<dd>
Number of bytes to be read from the file. </dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
Pointer to an <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> data structure that supplies data to be used during the asynchronous (overlapped) file read operation.
<p>
If the file specified by <i>hFile</i> supports the concept of byte offsets, the caller of <b>ReadFileEx</b> must specify a byte offset within the file at which reading should begin. The caller specifies the byte offset by setting the <b>OVERLAPPED</b> structure's <b>Offset</b> and <b>OffsetHigh</b> members. 

<p>
The <b>ReadFileEx</b> function ignores the <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> structure's <b>hEvent</b> member. An application is free to use that member for its own purposes in the context of a <b>ReadFileEx</b> call. <b>ReadFileEx</b> signals completion of its read operation by calling, or queuing a call to, the completion routine pointed to by <i>lpCompletionRoutine</i>, so it does not need an event handle.

<p>
The <b>ReadFileEx</b> function does use the <b>OVERLAPPED</b> structure's <b>Internal</b> and <b>InternalHigh</b> members. An application should not set these members.

<p>
The <b>OVERLAPPED</b> data structure pointed to by <i>lpOverlapped</i> must remain valid for the duration of the read operation. It should not be a variable that can go out of scope while the file read operation is in progress.
</dd>
<dt>
<i>lpCompletionRoutine</i></dt>
<dd>
Pointer to the completion routine to be called when the read operation is complete and the calling thread is in an alertable wait state. For more information about the completion routine, see <a href="filesio_1v1h.htm"><b>FileIOCompletionRoutine</b></a>. 
</dd>
</dl>
<h4>Return Values</h4>
<p>
If the function succeeds, the return value is nonzero.</p>
<p>
If the function fails, the return value is zero. To get extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<p>
If the function succeeds, the calling thread has an asynchronous input/output (I/O) operation pending: the overlapped read operation from the file. When this I/O operation completes, and the calling thread is blocked in an alertable wait state, the system calls the function pointed to by <i>lpCompletionRoutine</i>, and the wait state completes with a return code of WAIT_IO_COMPLETION. </p>
<p>
If the function succeeds, and the file reading operation completes, but the calling thread is not in an alertable wait state, the system queues the completion routine call, holding the call until the calling thread enters an alertable wait state. For information about alertable waits and overlapped input/output operations, see <a href="synchro_4ur8.htm">Synchronization and Overlapped Input and Output</a>. </p>
<p>
If <b>ReadFileEx</b> attempts to read past the end of the file, the function returns zero, and <b>GetLastError</b> returns ERROR_HANDLE_EOF. </p>
<h4>Remarks</h4>
<p>
An application must meet certain requirements when working with files opened with FILE_FLAG_NO_BUFFERING:
<ul>
<li>
File access must begin at byte offsets within the file that are integer multiples of the volume's sector size. To determine a volume's sector size, call the <a href="filesio_2pt1.htm"><b>GetDiskFreeSpace</b></a> function. </li>
<li>
File access must be for numbers of bytes that are integer multiples of the volume's sector size. For example, if the sector size is 512 bytes, an application can request reads and writes of 512, 1024, or 2048 bytes, but not of 335, 981, or 7171 bytes. </li>
<li>
Buffer addresses for read and write operations must be sector aligned (aligned on addresses in memory that are integer multiples of the volume's sector size). One way to sector align buffers is to use the <a href="memman_3elf.htm"><b>VirtualAlloc</b></a> function to allocate the buffers. This function allocates memory that is aligned on addresses that are integer multiples of the system's page size. Because both page and volume sector sizes are powers of 2, memory aligned by multiples of the system's page size is also aligned by multiples of the volume's sector size. </li>
</ul>
<p>
If a portion of the file specified by <i>hFile</i> is locked by another process, and the read operation specified in a call to <b>ReadFileEx </b>overlaps the locked portion, the call to <b>ReadFileEx</b> fails. </p>
<p>
If <b>ReadFileEx</b> attempts to read data from a mailslot whose buffer is too small, the function returns FALSE, and <b>GetLastError</b> returns ERROR_INSUFFICIENT_BUFFER. </p>
<p>
Accessing the input buffer while a read operation is using the buffer may lead to corruption of the data read into that buffer. Applications must not read from, write to, reallocate, or free the input buffer that a read operation is using until the read operation completes.</p>
<p>
The <b>ReadFileEx</b> function may fail if there are too many outstanding asynchronous I/O requests. In the event of such a failure, <b>GetLastError</b> can return ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY. </p>
<p>
To cancel all pending asynchronous I/O operations, use the <a href="filesio_06gf.htm"><b>CancelIo</b></a> function. This function only cancels operations issued by the calling thread for the specified file handle. I/O operations that are canceled complete with the error ERROR_OPERATION_ABORTED. </p>
<p>
If you are attempting to read from a floppy drive that does not have a floppy disk, the system displays a message box prompting the user to retry the operation. To prevent the system from displaying this message box, call the <a href="errors_38px.htm"><b>SetErrorMode</b></a> function with SEM_NOOPENFILEERRORBOX. </p>
<p>
An application uses the <b>MsgWaitForMultipleObjectsEx</b>, <b>WaitForSingleObjectEx</b>, <b>WaitForMultipleObjectsEx</b>, and <b>SleepEx</b> functions to enter an alertable wait state. For more information about alertable waits and overlapped input/output, refer to those functions' reference and <a href="synchro_4q3y.htm">Synchronization</a>.</p>
<p>
<b>Windows 95:</b> On this platform, neither <b>ReadFileEx</b> nor <b>WriteFileEx</b> can be used by the comm ports to communicate. However, you can use <b>ReadFile</b> and <b>WriteFile</b> to perform asynchronous communication.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 3.1 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Requires Windows 95 or later.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winbase.h.<br>
<b>&nbsp;&nbsp;Import Library: </b>Use kernel32.lib.</p>
<h4>See Also</h4>
<p>
<a href="filesio_2xm7.htm">File I/O Overview</a>, <a href="filesio_3n5f.htm">File Functions</a>, <a href="filesio_06gf.htm"><b>CancelIo</b></a>, <a href="filesio_7wmd.htm"><b>CreateFile</b></a>, <a href="filesio_1v1h.htm"><b>FileIOCompletionRoutine</b></a>, <a href="synchro_6lh4.htm"><b>MsgWaitForMultipleObjectsEx</b></a>, <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a>, <a href="filesio_39id.htm"><b>ReadFile</b></a>, <a href="errors_38px.htm"><b>SetErrorMode</b></a>, <a href="prothred_0o8o.htm"><b>SleepEx</b></a>, <a href="synchro_5lbs.htm"><b>WaitForMultipleObjectsEx</b></a>, <a href="synchro_5yrc.htm"><b>WaitForSingleObjectEx</b></a>, <a href="filesio_8r08.htm"><b>WriteFileEx</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
