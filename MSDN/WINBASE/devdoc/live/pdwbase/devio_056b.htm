<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FSCTL_QUERY_ALLOCATED_RANGES</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_fsctl_query_allocated_ranges"></a>FSCTL_QUERY_ALLOCATED_RANGES</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>FSCTL_QUERY_ALLOCATED_RANGES</b> operation scans a file looking for ranges that <i>may </i>contain nonzero data. Only compressed or sparse files can have zeroed ranges known to the operating system. For other files, the output buffer will contain only a single entry that contains the starting point and the length requested. </p>
<p>
To perform this operation, call the <a href="devio_9quk.htm"><b>DeviceIoControl</b></a><b> </b>function with the following parameters.</p>
<pre><code><b>BOOL DeviceIoControl(
</b>  (<b>HANDLE</b>) <i>hDevice</i>,        // handle to a file
  <i>FSCTL_QUERY_ALLOCATED_RANGES</i>,    // <i>dwIoControlCode, </i>control code of
                           // operation to perform
  (<b>LPVOID</b>) <i>lpInBuffer</i>,     // pointer to an input buffer
  (<b>DWORD</b>) <i>nInBufferSize</i>,   // size, in bytes, of <i>lpInBuffer</i>
  (<b>LPVOID</b>) <i>lpOutBuffer</i>,    // pointer to an output buffer
  (<b>DWORD</b>) <i>nOutBufferSize</i>,  // size, in bytes, of <i>lpOutBuffer</i>
  (<b>LPDWORD</b>)<i> lpBytesReturned</i>,   // pointer to variable to receive
                           // output byte count
  (<b>LPOVERLAPPED</b>) <i>lpOverlapped</i>  // pointer to an <b>OVERLAPPED</b> structure
                           // for asynchronous operation
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hDevice</i></dt>
<dd>
Handle to the file on which the operation is to be performed. Call the <a href="filesio_7wmd.htm"><b>CreateFile</b></a> function to obtain a handle. This operation cannot be called with a directory or volume handle.</dd>
<dt>
<i>dwIoControlCode</i></dt>
<dd>
Control code for the operation. This value identifies the specific operation to be performed and the type of device on which the operation is to be performed. Use <b>FSCTL_QUERY_ALLOCATED_RANGES</b> for this operation.</dd>
<dt>
<i>lpInBuffer</i></dt>
<dd>
Pointer to a <a href="devio_2waa.htm"><b>FILE_ALLOCATED_RANGE_BUFFER</b></a> structure that indicates the portion of the file to search for allocated ranges. The <b>FileOffset</b> member indicates the offset, in bytes, to the first byte of the range to search, and the <b>Length</b> member indicates its size, in bytes.</dd>
<dt>
<i>nInBufferSize</i></dt>
<dd>
Size, in bytes, of the <i>lpInBuffer</i> buffer.</dd>
<dt>
<i>lpOutBuffer</i></dt>
<dd>
Pointer to a buffer that receives an array of <b>FILE_ALLOCATED_RANGE_BUFFER</b> structures. Each structure in the array provides information about an allocated range within the file. The <b>FileOffset</b> member of each structure indicates the beginning of a range, and the <b>Length</b> member indicates its size, in bytes.
<p>
Ranges returned are always at least partially within the range specified in the <i>lpInBuffer</i> buffer.
</dd>
<dt>
<i>nOutBufferSize</i></dt>
<dd>
Size, in bytes, of the <i>lpOutBuffer</i> buffer.</dd>
<dt>
<i>lpBytesReturned</i> </dt>
<dd>
Pointer to a <b>DWORD</b> variable that receives the size, in bytes, of output data returned. If the <i>lpOutBuffer</i> buffer is too small, <i>lpBytesReturned</i> receives the required buffer size.
<p>
If <i>lpOverlapped</i> is NULL, <i>lpBytesReturned</i> cannot be NULL.

<p>
If <i>lpOverlapped</i> is not NULL, <i>lpBytesReturned</i> can be NULL. If this is an overlapped operation, you can get the number of bytes returned by calling the <a href="synchro_75v8.htm"><b>GetOverlappedResult</b></a> function. If <i>hDevice</i> is associated with an I/O completion port, you can get the number of bytes returned by calling the <a href="filesio_071v.htm"><b>GetQueuedCompletionStatus</b></a> function. 
</dd>
<dt>
<i>lpOverlapped</i></dt>
<dd>
Pointer to an <a href="synchro_8tf6.htm"><b>OVERLAPPED</b></a> structure. 
<p>
If <i>hDevice</i> was opened with the FILE_FLAG_OVERLAPPED flag, this parameter must point to a valid <b>OVERLAPPED</b> structure. In this case, <a href="devio_9quk.htm"><b>DeviceIoControl</b></a> is performed as an overlapped (asynchronous) operation. If the device was opened with FILE_FLAG_OVERLAPPED and <i>lpOverlapped</i> is NULL, the function fails in unpredictable ways.

<p>
If <i>hDevice</i> was opened without specifying the FILE_FLAG_OVERLAPPED flag, this parameter is ignored and the <b>DeviceIoControl</b> function does not return until the operation has been completed, or an error occurs. 

</dd>
</dl>
<h4>Return Values</h4>
<p>
If the operation succeeds, <a href="devio_9quk.htm"><b>DeviceIoControl</b></a> returns a nonzero value, and the output buffer pointed to by <i>lpOutBuffer</i> contains an array of valid <a href="devio_2waa.htm"><b>FILE_ALLOCATED_RANGE_BUFFER</b></a> structures.</p>
<p>
If the operation fails, <b>DeviceIoControl</b> returns zero. The contents of the output buffer pointed to by <i>lpOutBuffer</i> are meaningless. For extended error information, call <a href="errors_3uwi.htm"><b>GetLastError</b></a>. </p>
<h4>Remarks</h4>
<p>
See the Remarks section of the <a href="devio_9quk.htm"><b>DeviceIoControl</b></a> topic for the implications of overlapped I/O on this operation.</p>
<p>
NTFS rounds the input file offset down to a convenient boundary and the length up to a convenient boundary and then begins to walk through the file.</p>
<p>
The operating system does not track every piece of zero or nonzero data. Because zero is often a perfectly legal datum, it would be misleading. Instead, the system tracks ranges where disk space is allocated. Where no disk space is allocated, all data are assumed to be zero. Allocated storage can contain zero or nonzero data. So all this operation does is return information about parts of the file where nonzero data <i>may</i> be located. It is up to the application to scan these parts of the file in accordance with the application's data conventions.</p>
<p>
Each entry in the output array contains an offset and a length that indicates a range in the file that <i>may</i> contain nonzero data. The actual nonzero data, if any, is somewhere within this range, and the calling program must scan further within the range to locate it and determine if it really is valid data. Multiple instances of valid data may exist within the range.</p>
<h4>QuickInfo</h4>
<p>
<b>&nbsp;&nbsp;Windows NT: </b>Requires version 5.0 or later.<br>
<b>&nbsp;&nbsp;Windows: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Windows CE: </b>Unsupported.<br>
<b>&nbsp;&nbsp;Header: </b>Declared in winioctl.h.</p>
<h4>See Also</h4>
<p>
<a href="devio_23ec.htm">Device Input and Output Overview</a>, <a href="devio_5gqb.htm">Device Input and Output Operations</a>, <a href="devio_9quk.htm"><b>DeviceIoControl</b></a>, <a href="devio_2waa.htm"><b>FILE_ALLOCATED_RANGE_BUFFER</b></a>, <a href="devio_5351.htm"><b>FSCTL_SET_SPARSE</b></a>, <a href="devio_9wbl.htm"><b>FSCTL_SET_ZERO_DATA</b></a> </p>
<p>&nbsp;</p></body>
</HTML>
