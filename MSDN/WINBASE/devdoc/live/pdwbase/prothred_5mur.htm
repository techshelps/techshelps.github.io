<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Fibers</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_fibers"></a>Fibers</h2>
<p>
A <i>fiber</i> is a unit of execution that must be manually scheduled by the application. Fibers run in the context of the threads that schedule them. Each thread can schedule multiple fibers. In general, fibers do not provide advantages over a well-designed multithreaded application. However, using fibers can make it easier to port applications that were designed to schedule their own threads.</p>
<p>
From a system standpoint, a fiber assumes the identity of the thread that created it. For example, if a fiber accesses thread local storage (TLS), it is accessing the thread local storage of the thread that created it. In addition, if a fiber calls the <a href="prothred_531g.htm"><b>ExitThread</b></a> function, the thread that created it exits. However, a fiber does not have all the same state information associated with it as that associated with a thread. The only state information maintained for a fiber is its stack, a subset of its registers, and the fiber data provided during fiber creation. The saved registers are the set of registers typically preserved across a function call.</p>
<p>
Fibers are not preemptively scheduled. You schedule a fiber by switching to it from another fiber. The system still schedules threads to run. When a thread running fibers is preempted, its currently running fiber is preempted. The fiber runs when its thread runs.</p>
<p>
Before scheduling the first fiber, call the <a href="prothred_522a.htm"><b>ConvertThreadToFiber</b></a> function to create an area in which to save fiber state information. The calling thread is now the currently executing fiber. The stored state information for this fiber includes the fiber data passed as an argument to <b>ConvertThreadToFiber</b>. </p>
<p>
The <a href="prothred_548i.htm"><b>CreateFiber</b></a> function is used to create a new fiber from an existing fiber; the call requires the stack size, the starting address, and the fiber data. The starting address is typically a user-supplied function, called the fiber function, that takes one parameter (the fiber data) and does not return a value. If your fiber function returns, the thread running the fiber exits. To execute any fiber created with <b>CreateFiber, </b>call the <a href="prothred_2wxe.htm"><b>SwitchToFiber</b></a><b> </b>function. You can call <b>SwitchToFiber</b> with the address of a fiber created by a different thread. To do this, you must have the address returned to the other thread when it called <b>CreateFiber</b> and you must use proper synchronization. </p>
<p>
A fiber can retrieve the fiber data by calling the <a href="prothred_15nl.htm"><b>GetFiberData</b></a> function. A fiber can retrieve the fiber address at any time by calling the <a href="prothred_6a7m.htm"><b>GetCurrentFiber</b></a><b> </b>function.</p>
<p>
To clean up the data associated with a fiber, call the <a href="prothred_0fqq.htm"><b>DeleteFiber</b></a><b> </b>function. You must take care when calling <b>DeleteFiber</b>. If you call <b>DeleteFiber</b> for a fiber created by another thread, you can cause the other thread to terminate abnormally. If <b>DeleteFiber</b> is called from the currently running fiber, its thread calls <a href="prothred_531g.htm"><b>ExitThread</b></a>. </p>
<p>&nbsp;</p></body>
</HTML>
