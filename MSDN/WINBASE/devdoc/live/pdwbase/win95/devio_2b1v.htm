<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using VWIN32 to Carry Out MS-DOS Functions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win95_using_vwin32_to_carry_out_ms_dos_functions"></a>Using VWIN32 to Carry Out MS-DOS Functions</h2>
<p>
Windows 95 provides a VxD named VWIN32.VXD that supports a set of control codes that Win32-based applications can use to carry out selected MS-DOS system functions. These system-defined control codes consist of the following values. </p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=53%>Control code (value) </th>
<th align=left width=47%>Meaning </th>
</tr>
<tr valign=top>
<td width=53%>VWIN32_DIOC_DOS_DRIVEINFO (6) </td>
<td width=47%>Performs Interrupt 21h Function 730X commands. This value is supported in Windows 95 OEM Service Release 2 and later. </td>
</tr>
<tr valign=top>
<td width=53%>VWIN32_DIOC_DOS_INT13 (4) </td>
<td width=47%>Performs Interrupt 13h commands </td>
</tr>
<tr valign=top>
<td width=53%>VWIN32_DIOC_DOS_INT25 (2) </td>
<td width=47%>Performs the Absolute Disk Read command (Interrupt 25h) </td>
</tr>
<tr valign=top>
<td width=53%>VWIN32_DIOC_DOS_INT26 (3) </td>
<td width=47%>Performs the Absolute Disk Write command (Interrupt 25h) </td>
</tr>
<tr valign=top>
<td width=53%>VWIN32_DIOC_DOS_IOCTL (1) </td>
<td width=47%>Performs the specified MS-DOS device I/O control function (Interrupt 21h Function 4400h through 4411h) </td>
</tr>
</table><br>
<p>
When an application calls the <a href="../devio_9quk.htm"><b>DeviceIoControl</b></a> function with the <i>dwIoControlCode</i> parameter set to one of the predefined control codes, the <i>lpvInBuffer</i> and <i>lpvOutBuffer</i> parameters must specify the addresses of <a href="95str_9vxu.htm"><b>DIOC_REGISTERS</b></a> structures. The <b>DIOC_REGISTERS</b> structure specified by <i>lpvInBuffer</i> contains a set of register values that specify a command for the VxD to execute and any data that the VxD needs to execute the command. After completing the command, the VxD fills the <b>DIOC_REGISTERS</b> structure specified by <i>lpvOutBuffer</i> with the register values that resulted from executing the command. The meaning of the register values depends on the specified command. Many of the MS-DOS and BIOS functions require segment:offset register pairs for pointers. However, because 32-bit code does not have segments, the <b>DIOC_REGISTERS</b> structure does not contain members for segment registers. Place the full pointer that would go into a real-mode segment:offset register pair into the structure member that corresponds to the offset of the register pair. For example, use the <b>reg_EDI</b> member for the pointer that would go into the ES:DI registers. When an application uses the <b>DeviceIoControl</b> function to send commands to a VxD other than VWIN32.VXD, the meaning of the function's parameters are defined by the VxD. The system does not validate the parameters. The system VxD, VWIN32.VXD, supports the IOCTL functions originally provided by MS-DOS Interrupt 21h. The following example shows how to call Get Media ID (Interrupt 21h Function 440Dh Minor Code 66h) from a Win32-based application. </p>
<pre><code>#define VWIN32_DIOC_DOS_IOCTL 1

typedef struct _DIOC_REGISTERS {
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 
typedef struct _MID {
    WORD  midInfoLevel;
    DWORD midSerialNum;
    BYTE  midVolLabel[11];
    BYTE  midFileSysType[8];
} MID, *PMID;
#pragma pack()

HANDLE hDevice;
DIOC_REGISTERS reg;
MID mid;
BOOL fResult;
DWORD cb;
int nDrive = 3;  // Drive C:

hDevice = CreateFile("\\\\.\\vwin32",
    0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

reg.reg_EAX = 0x440D;       // IOCTL for block devices 
reg.reg_EBX = nDrive;       // zero-based drive identifier 
reg.reg_ECX = 0x4866;       // Get Media ID command 
reg.reg_EDX = (DWORD) &amp;mid; // receives media identifier information 
reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

fResult = DeviceIoControl(hDevice, 
    VWIN32_DIOC_DOS_IOCTL,
    &amp;reg, sizeof(reg), 
    &amp;reg, sizeof(reg), 
    &amp;cb, 0);

if (!fResult || (reg.reg_Flags &amp; 0x0001))
    ; // error if carry flag is set 

CloseHandle(hDevice);
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
