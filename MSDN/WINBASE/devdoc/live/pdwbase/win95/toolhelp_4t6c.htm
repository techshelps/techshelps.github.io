<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Traversing the Module List</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_traversing_the_module_list"></a>Traversing the Module List</h2>
<p>
The following example obtains a list of modules for the specified process. First, the <code>GetProcessModule</code> function takes a snapshot of the system using the <a href="toolhelp_5450.htm"><b>CreateToolhelp32Snapshot</b></a> function, then it walks through the list recorded in the snapshot, using the <a href="toolhelp_09tg.htm"><b>Module32First</b></a> and <a href="toolhelp_02us.htm"><b>Module32Next</b></a> functions. The parameters for <code>GetProcessModule</code> are as follows: 
<dl>
<dt>
<i>dwPID</i> </dt>
<dd>
Identifier of the process that owns the module whose information will be retrieved. </dd>
<dt>
<i>dwModuleID</i> </dt>
<dd>
Tool help identifier of the process module. </dd>
<dt>
<i>lpMe32</i> </dt>
<dd>
Structure that receives data about the module. </dd>
<dt>
<i>cbMe32</i> </dt>
<dd>
Size of the buffer pointed to by the <i>lpMe32</i> parameter.
</dd>
</dl>
<pre><code>#include &lt;windows.h&gt;
#include &lt;tlhelp32.h&gt;

BOOL GetProcessModule (DWORD dwPID, DWORD dwModuleID, 
     LPMODULEENTRY32 lpMe32, DWORD cbMe32) 
{ 
    BOOL          bRet        = FALSE; 
    BOOL          bFound      = FALSE; 
    HANDLE        hModuleSnap = NULL; 
    MODULEENTRY32 me32        = {0}; 
 
    // Take a snapshot of all modules in the specified process. 

    hModuleSnap = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); 
    if (hModuleSnap == (HANDLE)-1) 
        return (FALSE); 
 
    // Fill the size of the structure before using it. 

    me32.dwSize = sizeof(MODULEENTRY32); 
 
    // Walk the module list of the process, and find the module of 
    // interest. Then copy the information to the buffer pointed 
    // to by lpMe32 so that it can be returned to the caller. 

    if (Module32First(hModuleSnap, &amp;me32)) 
    { 
        do 
        { 
            if (me32.th32ModuleID == dwModuleID) 
            { 
                CopyMemory (lpMe32, &amp;me32, cbMe32); 
                bFound = TRUE; 
            } 
        } 
        while (!bFound &amp;&amp; Module32Next(hModuleSnap, &amp;me32)); 
 
        bRet = bFound;   // if this sets bRet to FALSE, dwModuleID 
                         // no longer exists in specified process 
    } 
    else 
        bRet = FALSE;           // could not walk module list 
 
    // Do not forget to clean up the snapshot object. 

    CloseHandle (hModuleSnap); 
 
    return (bRet); 
} 
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
