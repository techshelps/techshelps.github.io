<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Testing the Thunk</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win95_testing_the_thunk"></a>Testing the Thunk</h2>
<p>
After you complete the preliminary checklist provided in the previous topic, build your thunk DLLs and try to run them. If they run, continue with further testing to make sure they work as expected. If the DLLs do not run, use the following troubleshooting guide to determine and fix the cause of the problem. </p>
<p>
If <b>XXX_ThunkConnect16</b> or <b>XXX_ThunkConnect32</b> fails, perform the following tasks:
<ol>
<li>
Run the debugging versions of the system DLLs. The debugging versions of KERNEL32.DLL and KRNL386.EXE contain many diagnostic messages to indicate why the thunk did not initialize. To run the debugging versions of the system DLLs, use the <b>Switch to Debug DLLs</b> icon in the SDK program group. Use <b>Switch to Non-debugging DLLs</b> to switch back to the retail version.</li>
<li>
Verify that the 16-bit DLL has a call to <b>XXX_ThunkConnect16</b> and that the Win32-based DLL has a corresponding call to <b>XXX_ThunkConnect32</b>. If one of these is missing, the other will fail, and the thunk DLLs will fail to load.</li>
<li>
Put breakpoints in your Win32 DLL's <b>DllMain</b>, and in your 16-bit DLL's <b>DllMain</b> and <b>LibMain</b> functions to see which DLLs are not loading.</li>
</ol>
<p>
If your <b>XXX_ThunkConnect16</b> and <b>XXX_ThunkConnect32</b> calls are working properly, but the thunk still does not work, it is time to simplify your thunk. You can do this by removing parameters from the thunk one by one, recompiling, and testing. If you determine that a parameter is causing the failure, make sure it is the right type and that the function is declared and defined with the same number and types of parameters in both DLLs and the in the thunk script. Alternatively, you can create a simple thunk that works, and build it up until it fails by following these steps:
<ol>
<li>
Create a simple thunk and execute it just to make sure the thunk mechanism is set up correctly. A good choice for a simple thunk is a function with no return value and no parameters. If even the simple thunk does not work, run through the preliminary checklist in the previous topic to make sure the thunk is set up correctly. Then proceed with step 2.</li>
<li>
Check to make sure the target DLL and any DLLs it relies on can be found and loaded. If one is missing, or the loader cannot find it, the thunk will not work.</li>
<li>
Make sure your target DLL is not trying to do something that it cannot do in the context of a thunk. For more information, see <a href="tc_9zn7.htm">Behavior of Win32 Functions Inside 16-Bit Processes</a>. </li>
</ol>
<p>
After you have a simplified thunk that works, but the original thunk still does not work, check for the following symptoms: 
<ol>
<li>
If your target DLL is a 16-bit DLL and it cannot access its global or static data, make sure you have exported the function correctly. If you use the <b>/GD</b> option with Visual C++, you must declare and define the function with the __export keyword in the 16-bit DLL's source code. Just listing the function's name in the DLL's module definition (.DEF) file is not enough. The compiler does not process the .DEF file, so it will not generate the prolog and epilog code that exported functions require.</li>
<li>
If calls to <a href="../memman_2fxf.htm"><b>LocalAlloc</b></a> in your target 16-bit DLL cause general protection (GP) faults, make sure your function is exported as described in step 1.</li>
<li>
If you get a GP fault in KERNEL32 just after your target 16-bit function returns, make sure the target function is declared and defined as PASCAL. You can not use the C calling convention. Although uncommon in C or C++ code, make sure the target function did not modify the DS, ES, FS, SS, EBP, EBX, ESI, or EDI registers. C or C++ code should not cause the registers to be modified, but check assembly-language code carefully. </li>
<li>
If you get a GP fault in your 32-bit thunk DLL or KERNEL32 immediately after your Win32-based target function returns, make sure the target function is declared with WINAPI and that it didn't modify the DS, ES, FS, SS, EBP, EBX, ESI, or EDI registers. C or C++ code should not cause the registers to be modified, but check assembly-language code carefully.</li>
<li>
If your 16-bit target function returns to an invalid location, make sure it is declared and defined as FAR. This is especially important for small-model DLLs; functions in medium- and large-model DLLs are FAR by default.</li>
<li>
If you experience a GP fault in a 16-bit function when you access more than 64K of data from a pointer passed as a parameter (that is, a translated pointer), you need to allocate an array of tiled selectors. This is described in the following article in the Microsoft Knowledge Base: <p>
ARTICLE-ID: Q132005<br>
TITLE: AllocSelector &amp; FreeSelector Documentation Incomplete
<p>
On the 16-bit side, thunked pointers always consist of a single selector with a limit of 64K, which means you cannot use them as huge pointers. The entire original range of data that the pointer addresses is accessible to the 16-bit target DLL. However, this is true only if the DLL creates an array of tiled selectors to reference it, and if it uses huge pointer variables to access the data.
</li>
</ol>
<p>
The following are additional debugging tips: 
<ol>
<li>
Make sure you use only a translated pointer in the context of the thunk. Selectors allocated by the thunk compiler for use by 16-bit targets are freed as soon as the thunk returns.</li>
<li>
Put breakpoints at the beginning of your target functions to make sure they are being executed. If they are, and you have debugged the target side independently of the thunk, and the error is caused inside the target DLL, it is possible that the target is doing something that cannot be done in a thunk, or referencing memory that does not exist. See steps 7 and 8.</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
