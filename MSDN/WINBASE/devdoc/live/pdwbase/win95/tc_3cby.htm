<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>16- to 32-Bit Thunks and Preemption</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win95_16_to_32_bit_thunks_and_preemption"></a>16- to 32-Bit Thunks and Preemption</h2>
<p>
Because 16-bit processes multitask cooperatively with respect to each other, 16-bit code is often written with the assumption that it will not be interrupted by another process until it explicitly yields inside the 16-bit scheduler (typically as a result of calling the <object id=alink_1 type="application/x-oleobject"
	classid="clsid:adb880a6-d8ff-11cf-9377-00aa003b7a11">
<PARAM name="Command" value="ALink,MENU">
<PARAM name="DefaultTopic" value="../../../notopic_0pk4.htm">
<PARAM name="Item1" value="">
<PARAM name="Item2" value="_win32_getmessage">
</object><a href=JavaScript:alink_1.Click()><b>GetMessage</b></a> function). In contrast, 32-bit code is written with the expectation that it can be preempted and blocked at any time. A 32-bit application can wait for a synchronization object to be set to the signaled state without impeding the progress of another process. If you mix code written under these different assumptions, you should take care to avoid deadlocks or errors due to unexpected reentrancy.</p>
<p>
While a process is executing 32-bit code, it is possible for other processes to enter 16-bit code, possibly reentering the 16-bit code that performed the thunk. That is, entering a 16-bit to 32-bit thunk releases the 16-bit subsystem for use by other processes (under certain conditions noted in the following paragraph). Therefore, you should not use 16-bit to 32-bit thunks if your code cannot be reentered while the thunk code is executing. In addition, you should not use 16-bit to 32-bit thunks inside callback functions passed to a third-party DLL, unless the documentation indicates that the code calling the callback function is reentrant. </p>
<p>
If the process executing the thunk is a 32-bit process, any other process can reenter 16-bit code inside a 16-bit to 32-bit thunk. On the other hand, if the process executing the thunk is a 16-bit process, only 32-bit processes can reenter 16-bit code, because 16-bit processes are cooperatively multitasked. Therefore, if your 16-bit code is used only by 16-bit processes, the reentrancy requirement can be relaxed, because other 16-bit processes can be scheduled only if your 16-bit process yields. </p>
<p>&nbsp;</p></body>
</HTML>
