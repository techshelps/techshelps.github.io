<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a 16-bit Thunk DLL</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win95_creating_a_16_bit_thunk_dll"></a>Creating a 16-bit Thunk DLL</h2>
<p>
After you compile the thunk script to create the 16-bit code for the thunk, you must create the 16-bit thunk DLL. To implement the 16-bit thunk DLL, use the following steps. </p>
<h5><img src="../../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To implement the 16-bit thunk DLL</h5>
<ol>
<li>
Add a function named DllMain to your 16-bit DLL. This function should have the following structure: <pre><code>BOOL FAR PASCAL __export DllMain(DWORD dwReason, WORD hInst, 
        WORD wDS, WORD wHeapSize, DWORD dwReserved1, 
        WORD wReserved2) 
{ 
    if( !(XXX_ThunkConnect16( "DLL16.DLL",  // name of 16-bit DLL 
        "DLL32.DLL",                        // name of 32-bit DLL 
        hInst, dwReason)) ) 
    { 
        return FALSE; 
    } 
    return TRUE; 
} 
 </code></pre>
<p>
Note that DllMain calls the following function, which was generated by the thunk compiler: 
<pre><code>BOOL FAR PASCAL __export XXX_ThunkConnect16(LPSTR pszDll16, 
    LPSTR pszDll32, WORD hInst, DWORD dwReason); 
 </code></pre>
<p>
In this example, XXX is the base name — that is, the name of the thunk script file, not including the path and filename extension. If you used the <b>/t</b> option with the thunk compiler to specify a different base name when you compiled the thunk script, use that base name here. 
</li>
<li>
Add the following statements to your 16-bit DLL's module definition (.DEF) file, choosing ordinals appropriate for your DLL. <pre><code>EXPORTS
DllMain             @1 RESIDENTNAME
XXX_ThunkData16     @2 RESIDENTNAME

IMPORTS
C16ThkSL01     = KERNEL.631
ThunkConnect16 = KERNEL.651
 </code></pre>
</li>
<li>
Build the DLL. Be sure to link with the 16-bit .OBJ file created from the thunk script. This file contains the code for XXX_ThunkData16, which is a table of function calls the thunk compiler uses to implement the thunks. </li>
<li>
Mark the DLL with version 4.0, using the 16-bit resource compiler included with the Platform SDK.<pre><code>rc -40 <i>DLL_Name</i></code></pre>
</li>
</ol>
<p>
To ensure that your application works correctly, it is important that you use the following rules when implementing your thunks: 
<ul>
<li>
The 16-bit <a href="../dll_8asu.htm"><b>DllMain</b></a> function is called each time the module's usage count is incremented or decremented. The <i>dwReason</i> parameter is 1 when the usage count is incremented and zero when it is decremented.</li>
<li>
Because the system calls the <b>DllMain</b> function while loading is under way, the value returned by the <b>GetModuleUsage</b> function is not reliable if you call it inside your <b>DllMain</b> function.</li>
<li>
Do not call thunks inside the <b>DllMain</b> routines. Do not perform operations that reenter the 16-bit loader, yield the 16-bit scheduler, or release the 16-bit subsystem. These actions could cause unpredictable results and are not guaranteed to work in future versions of the thunk compiler.</li>
<li>
You can have multiple <b>ThunkConnect</b> calls, as long as they connect to the same DLL. In fact, this is the only way to get both 32- to 16-bit and 16-bit to 32-bit thunks from one set of thunk DLLs. The way to do this is to have a thunk script for each direction and link both into each DLL. Then each entry-point function will have two <b>ThunkConnect</b> calls.</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
