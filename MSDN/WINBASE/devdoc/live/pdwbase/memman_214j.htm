<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Guard Pages</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_win32_creating_guard_pages"></a>Creating Guard Pages</h2>
<p>
A <i>guard page</i> provides a one-shot alarm for memory page access. This can be useful for an application that needs to monitor the growth of large dynamic data structures. For example, there are operating systems that use guard pages to implement automatic stack checking.</p>
<p>
To create a guard page, set the PAGE_GUARD page protection modifier flag for the page. This flag can be specified, along with other page protection flags, in the functions <a href="memman_3elf.htm"><b>VirtualAlloc</b></a>, <a href="memman_30l0.htm"><b>VirtualProtect</b></a>, and <a href="memman_4iew.htm"><b>VirtualProtectEx</b></a>. The PAGE_GUARD flag can be used with any other page protection flag, except for the NO_ACCESS flag. </p>
<p>
If a program attempts to access an address within a guard page, the system raises a STATUS_GUARD_PAGE (0x80000001) exception. The system also clears the PAGE_GUARD flag, removing the memory page's guard page status. The system will not stop the next attempt to access the memory page with a STATUS_GUARD_PAGE exception.</p>
<p>
If a guard page exception occurs during a system service, the service fails and typically returns some failure status indicator. Since the system also removes the relevant memory page's guard page status, the next invocation of the same system service won't fail due to a STATUS_GUARD_PAGE exception (unless, of course, someone reestablishes the guard page).</p>
<p>
The following short program illustrates the one-shot behavior of guard page protection, and how it can cause a system service to fail:</p>
<pre><code>#include &lt;windows.h&gt; 
#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
 
int main() 
{ 
    LPVOID lpvAddr; 
    DWORD cbSize; 
    BOOL vLock; 
    LPVOID commit; 
 
    // Amount of memory to allocate.
    cbSize = 512; 
 
    // Try to allocate some memory. 
    lpvAddr = VirtualAlloc(NULL,cbSize,MEM_RESERVE,PAGE_NOACCESS); 
 
    if(lpvAddr == NULL) 
    {
        fprintf(stdout,"VirtualAlloc failed on RESERVE with %ld\n", 
            GetLastError()); 
    }
 
    // Try to commit the allocated memory. 
    commit = 
    VirtualAlloc(NULL,cbSize,MEM_COMMIT,PAGE_READONLY|PAGE_GUARD); 
 
    if(commit == NULL) 
    {
        fprintf(stderr,"VirtualAlloc failed on COMMIT with %ld\n", 
            GetLastError()); 
    }
 
    else 
    {
        fprintf(stderr,"Committed %lu bytes at address %lp\n", 
        cbSize,commit); 
    }
 
    // Try to lock the committed memory. 
    vLock = VirtualLock(commit,cbSize); 
 
    if(!vLock) 
    {
        fprintf(stderr,"Cannot lock at %lp, error = %lu\n", 
            commit,GetLastError()); 
    }
    else fprintf(stderr,"Lock Achieved at %lp\n",commit); 
 
    // Try to lock the committed memory again. 
    vLock = VirtualLock(commit,cbSize); 
 
    if(!vLock) 
    {
        fprintf(stderr,"Cannot get 2nd lock at %lp, error = %lu\n", 
            commit,GetLastError()); 
    }
    else fprintf(stderr,"2nd Lock Achieved at %lp\n",commit); 
 
} 
 </code></pre>
<p>
The output of this program looks like this:</p>
<pre><code>Committed 512 bytes at address 003F0000 
Cannot lock at 003F0000, error = 0x80000001 
2nd Lock Achieved at 003F0000 
</code></pre>
<p>
<b>Note</b>&nbsp;&nbsp;The first attempt to lock the memory block fails, raising a STATUS_GUARD_PAGE exception. The second attempt succeeds, because the memory block's guard page protection has been toggled off by the first attempt.</p>
<p>&nbsp;</p></body>
</HTML>
