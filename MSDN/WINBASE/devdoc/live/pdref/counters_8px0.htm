<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Memory Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_win32_memory_object"></a>Memory Object</h1>
<p>
The Memory performance object consists of counters that describe the behavior of physical and virtual memory on the computer. Physical memory is the amount of random access memory on the computer. Virtual memory consists of space in physical memory and on disk. Many of the memory counters monitor paging, which is the movement of pages of code and data between disk and physical memory. Excessive paging, a symptom of a memory shortage, can cause delays which interfere will all system processes. </p>
<p>
<b>Available Bytes</b></p>
<p>
Available Bytes is the amount of physical memory available to processes running on the computer, in bytes. It is calculated by summing space on the Zeroed, Free, and Standby memory lists. Free memory is ready for use; Zeroed memory is pages of memory filled with zeros to prevent later processes from seeing data used by a previous process. Standby memory is memory removed from a process's working set (its physical memory) on route to disk, but is still available to be recalled. </p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Committed Bytes</b></p>
<p>
Committed Bytes is the amount of committed virtual memory, in bytes. (Committed memory is physical memory for which space has been reserved on the disk paging file in case it needs to be written back to disk.) </p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Commit Limit</b></p>
<p>
Commit Limit is the amount of virtual memory that can be committed without having to extend the paging file(s). It is measured in bytes. (Committed memory is physical memory for which space has been reserved on the disk paging files. There can be one paging file on each physical drive.)If the paging file(s) are be expanded, this limit increases accordingly. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Page Faults/sec</b></p>
<p>
Page Faults/sec is overall rate at which of faulted pages are handled by the processor. It is measured in numbers of pages faulted. A page fault occurs when a process requires code or data that is not in its working set (its space in physical memory) in main memory. This counter includes both hard faults (those that require disk access) and soft faults (where the faulted page is found elsewhere in physical memory.) Most processors can handle large numbers of soft faults without consequence. However, hard faults can cause significant delays. </p>
<p>
Detail Level: Novice<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Write Copies/sec</b></p>
<p>
Write Copies/sec is the number of page faults caused by attempts to write that have been satisfied by coping of the page from elsewhere in physical memory. This is an economical way of sharing data since pages are only copied when they are written to; otherwise, the page is shared. This counter counts the number of copies, without regard for the number of pages copied in each operation. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Transition Faults/sec</b></p>
<p>
Transition Faults/sec is the number of page faults resolved by recovering pages that were on the modified page list, on the standby list, or being written to disk at the time of the page fault. The pages were recovered without additional disk activity. Transition faults are counted in numbers of faults, without regard for the number of pages faulted in each operation. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Cache Faults/sec</b></p>
<p>
Cache Faults/sec is the number of faults which occur when a page sought in the file system cache is not found there and must be retrieved from elsewhere in memory (a soft fault) or from disk (a hard fault). The file system cache is an area of physical memory that stores recently used pages of data for applications. Cache activity is a reliable indicator of most application I/O operations. This counter counts the number of faults, without regard for the number of pages faulted in each operation. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Demand Zero Faults/sec</b></p>
<p>
Demand Zero Faults/sec is the number of page faults that require a zeroed page to satisfy the fault. Zeroed pages, pages emptied of previously stored data and filled with zeros, are a security feature of Windows NT. They prevent processes from seeing data stored by earlier processes that used the memory space. Windows NT maintains a list of zeroed pages to accelerate this process. This counter counts numbers of faults, without regard to the numbers of pages retrieved to satisfy the fault. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Pages/sec</b></p>
<p>
Pages/sec is the number of pages read from or written to disk to resolve hard page faults. (Hard page faults occur when a process requires code or data that is not in its working set or elsewhere in physical memory, and must be retrieved from disk.) This counter was designed as a primary indicator of the kinds of faults that cause system-wide delays. It is the sum of Memory: Pages Input/sec and Memory: Pages Output/sec. It is counted in numbers of pages, so it can be compared to other counts of pages, such as Memory: Page Faults/sec, without conversion. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) non-cached mapped memory files. </p>
<p>
Detail Level: Novice<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Pages Input/sec</b></p>
<p>
Pages Input/sec is the number of pages read from disk to resolve hard page faults. (Hard page faults occur when a process requires code or data that is not in its working set or elsewhere in physical memory, and must be retrieved from disk.) This counter was designed as a primary indicator of the kinds of faults that cause system-wide delays. It includes pages retrieved to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. This counter counts numbers of pages, and can be compared to other counts of pages, such as Memory: Page Faults/sec, without conversion. </p>
<p>
Detail Level: Novice<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Page Reads/sec</b></p>
<p>
Page Reads/sec is the number of times the disk was read to resolve hard page faults. (Hard page faults occur when a process requires code or data that is not in its working set or elsewhere in physical memory, and must be retrieved from disk.) This counter was designed as a primary indicator of the kinds of faults that cause system-wide delays. It includes reads to satisfy faults in the file system cache (usually requested by applications) and in non-cached mapped memory files. This counter counts numbers of read operations, without regard to the numbers of pages retrieved by each operation. </p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Pages Output/sec</b></p>
<p>
Pages Output/sec is the number of pages written to disk to free up space in physical memory. Pages are written back to disk only if they are changed in physical memory, so they are likely to hold data, not code. A high rate of pages output might indicate a memory shortage. Windows NT writes more pages back to disk to free up space when physical memory is in short supply. This counter counts numbers of pages, and can be compared to other counts of pages, without conversion. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Page Writes/sec</b></p>
<p>
Page Writes/sec is the number of times pages were written to disk to free up space in physical memory. Pages are written to disk only if they are changed while in physical memory, so they are likely to hold data, not code. This counter counts write operations, without regard to the number of pages written in each operation. </p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_COUNTER_COUNTER</p>
<p>
<b>Pool Paged Bytes</b></p>
<p>
Pool Paged Bytes is the number of bytes in the paged pool, an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Memory: Pool Paged Bytes is calculated differently than Process: Pool Paged Bytes, so it might not equal Process: Pool Paged Bytes: _Total. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Pool Nonpaged Bytes</b></p>
<p>
Pool Nonpaged Bytes is the number of bytes in the nonpaged pool, an area of  system memory (physical memory used by the operating system) for objects that cannot be written to disk, but must remain in physical memory as long as they are allocated. Memory: Pool Nonpaged Bytes is calculated differently than Process: Pool Nonpaged Bytes, so it might not equal Process: Pool Nonpaged Bytes: _Total. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Pool Paged Allocs</b></p>
<p>
Pool Paged Allocs is the number of calls to allocate space in the paged pool. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Pool Nonpaged Allocs</b></p>
<p>
Pool Nonpaged Allocs is the number of calls to allocate space in the nonpaged pool.  The nonpaged pool is an area of system memory area for objects that cannot be written to disk, and must remain in physical memory as long as they are allocated. It is measured in numbers of calls to allocate space, regardless of the amount of space allocated in each call. </p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Free System Page Table Entries</b></p>
<p>
The number of Page Table Entries not currently in use by the system.</p>
<p>
Detail Level: Wizard<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Cache Bytes</b></p>
<p>
Cache Bytes is the number of bytes currently being used by the file system cache. The file system cache is an area of physical memory that stores recently used pages of data for applications. Windows NT continually adjusts the size of the cache, making it as large as it can while still preserving the minimum required number of available bytes for processes. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Cache Bytes Peak</b></p>
<p>
Cache Bytes Peak is the maximum number of bytes used by the file system cache since the system was last restarted. This might be larger than the current size of the cache. Cache. The file system cache is an area of physical memory that stores recently used pages of data for applications. Windows NT continually adjusts the size of the cache, making it as large as it can while still preserving the minimum required number of available bytes for processes. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>Pool Paged Resident Bytes</b></p>
<p>
Pool Paged Resident Bytes is the current size of paged pool in bytes. The paged pool is an area of system memory (physical memory used by the operating system) for objects that can be written to disk when they are not being used. Space used by the paged and nonpaged pools are taken from physical memory, so a pool that is too large denies memory space to processes. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>System Code Total Bytes</b></p>
<p>
System Code Total Bytes is the number of bytes of pageable operating system code currently in virtual memory. It is a measure of the amount of physical memory being used by the operating system that can be written to disk when not in use. This value is calculated by summing the bytes in Ntoskrnl.exe, Hal.dll, the boot drivers, and file systems loaded by Ntldr/osloader. This counter does not include code that must remain in physical memory and cannot be written to disk. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>System Code Resident Bytes</b></p>
<p>
System Code Resident Bytes is the number of bytes of operating system code currently in physical memory that can be written to disk when not in use. This value is a component of System Code Total Bytes, which also includes operating system code on disk. System Code Resident Bytes (and System Code Total Bytes) does not include code that must remain in physical memory and cannot be written to disk. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>System Driver Total Bytes</b></p>
<p>
System Driver Total Bytes is the number of bytes of pageable virtual memory currently being used by device drivers. (Pageable memory can be written to disk when it is not being used.) It includes physical memory (Memory: System Driver Resident Bytes) and code and data written to disk. It is a component of Memory: System Code Total Bytes. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>System Driver Resident Bytes</b></p>
<p>
System Driver Resident Bytes is the number of bytes of pageable physical memory being used by device drivers. It is the working set (physical memory area) of the drivers. This value is a component of Memory: System Driver Total Bytes, which also includes driver memory that has been written to disk. Neither System Driver Resident Bytes nor System Driver Total Bytes includes memory that cannot be written to disk.</p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>System Cache Resident Bytes</b></p>
<p>
System Cache Resident Bytes is the number of bytes of pageable operating system code in the file system cache. This value is a component of Memory: System Code Resident Bytes which represents all pageable operating system code that is currently in physical memory. </p>
<p>
Detail Level: Advanced<br>
Counter Type: PERF_COUNTER_RAWCOUNT</p>
<p>
<b>% Committed Bytes In Use</b></p>
<p>
% Committed Bytes In Use is the ratio of Memory: Committed Bytes to the Memory: Commit Limit. (Committed memory is physical memory in use for which space has been reserved in the paging file should it need to be written to disk. The commit limit is determined by the size of the paging file. If the paging file is enlarged, the commit limit increases, and the ratio is reduced.) </p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_RAW_FRACTION</p>
<p>
<b>% Committed Bytes In Use</b></p>
<p>
% Committed Bytes In Use is the ratio of the Committed Bytes to the Commit Limit. This represents the amount of available virtual memory in use. Note that the Commit Limit might change if the paging file is extended. This is an instantaneous value, not an average.</p>
<p>
Detail Level: Expert<br>
Counter Type: PERF_RAW_BASE</p>
<p>&nbsp;</p></body>
</HTML>
