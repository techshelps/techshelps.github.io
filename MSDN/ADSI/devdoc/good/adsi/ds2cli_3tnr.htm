<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using IDirectorySearch for Querying</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_ds_using_idirectorysearch_for_querying"></a>Using IDirectorySearch for Querying</h3>
<p>
In addition to the search capabilities supported by the ADSI OLE DB provider, ADSI supplies the <a href="ds2_if_5qco.htm"><b>IDirectorySearch</b></a> interface to query directly directory services for non-Automation clients. <b>IDirectorySearch</b> requires almost the same search information as the methods of the OLE DB interfaces, but reduces the programming overhead. Use <b>IDirectorySearch</b> when you just want to specify a query and get the results back without any of the richer navigation features supplied when using OLE DB queries. </p>
<p>
When implemented by a provider, <b>IDirectorySearch</b> is supported on every ADSI object. For information on which providers support this interface, see <a href="ds2_pref_08hf.htm"><b>ADSI System Providers</b></a>. </p>
<p>
Use <a href="ds2_if_3lwl.htm"><b>IDirectorySearch::SetSearchPreference</b></a> to set the preferred settings for your query. Once your preferences are created, use <b>ExecuteSearch</b> to initiate the query. Query results are exposed in the form of a table. Each row is one entry of the result. Each column within the row represents an attribute or property. The following figure shows a simplified representation of how the query process works. </p>
<p>
<img src="images/ds2simps.gif" border=0></p>
<p>
Use <b>GetNextRow </b>to advance the search handle shown in the preceding figure row by row, and <b>GetNextColumnName </b>with <b>GetColumn </b>to retrieve results from the columns. With each row you step through the columns of interest looking for the attributes that match. This process continues until there are no more rowsets in the query results.</p>

<p>
<a name="_ds_idirectorysearch_example"></a>The following ADSI example shows a simple command-prompt program that uses the <b>IDirectorySearch</b> interface to query a directory service. This sample has been edited, primarily by removing error checking, to simplify the flow. The complete example code is included in the ADSI SDK in the samples/activeds/sampapp/cxx/dssrch directory.</p>
<pre><code>
Usage: dssrch /b &lt;baseObject&gt; /f &lt;search_filter&gt; [/f &lt;attrlist&gt;] [/p &lt;preference&gt;=value&gt;]  [/u &lt;UserName&gt; &lt;Password&gt;] [/t &lt;flagName&gt;=&lt;value&gt; 
 
   where:
   baseObject     = ADsPath of the base of the search
   search_filter  = search filter string in LDAP format
   attrlist       = list of the attributes to display
   preference could be one of:
   Asynchronous, AttrTypesOnly, DerefAliases, SizeLimit, TimeLimit,
   TimeOut, PageSize, SearchScope
   flagName could be one of:
   SecureAuth or UseEncrypt
   value is yes/no for a Boolean and the respective integer for integers
   scope is one of "Base", "OneLevel", or "Subtree"
 
For Example: dssrch /b NDS://ntmarst/ms /f "(object Class=Group)"  /a  "ADsPath, name, description" /p searchScope=onelevel
 
//------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//-------------------------------------------------------------------
#define INC_OLE2
#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;limits.h&gt;
#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#define BAIL_ON_NULL(p) if (!(p)) {goto error;}
#define BAIL_ON_FAILURE(hr) if (FAILED(hr)) {goto error;}
 
#include "activeds.h"
#include "main.hxx"
// Globals representing parameters on IDirectorySearch
LPWSTR pszSearchBase, pszSearchFilter, pszAttrNames[10], pszAttrList;
DWORD dwNumberAttributes = -1;
// Preference Values
BOOL fASynchronous=FALSE, fDerefAliases=FALSE, fAttrsOnly=FALSE;
DWORD fSizeLimit, fTimeLimit, dwTimeOut, dwPageSize, dwSearchScope;
 
ADS_SEARCHPREF_INFO pSearchPref[10];
DWORD dwCurrPref = 0;
 
LPWSTR pszUserName=NULL, pszPassword=NULL;
DWORD dwAuthFlags=0;
DWORD cErr=0;
 
char *prefNameLookup[] = 
    {
    "ADS_SEARCHPREF_ASYNCHRONOUS", 
    "ADS_SEARCHPREF_DEREF_ALIASES",   
    "ADS_SEARCHPREF_SIZE_LIMIT",      
    "ADS_SEARCHPREF_TIME_LIMIT",      
    "ADS_SEARCHPREF_ATTRIBTYPES_ONLY",
    "ADS_SEARCHPREF_SEARCH_SCOPE",    
    "ADS_SEARCHPREF_TIMEOUT",         
    "ADS_SEARCHPREF_PAGESIZE",         
    "ADS_SEARCHPREF_PAGED_TIME_LIMIT",
    "ADS_SEARCHPREF_CHASE_REFERRALS"
    };
 
 
//+-----------------------------------------------------------------
//  Function:   main
//------------------------------------------------------------------
INT _CRTAPI1
main(int argc, char * argv[])
{
 
    hr = CoInitialize(NULL);
    hr = ADsOpenObject(
        pszSearchBase,
        pszUserName,
        pszPassword,
        dwAuthFlags,
        IID_IDirectorySearch,
        (void **)&amp;pDSSearch
        );
 
    if (dwCurrPref) {
        hr = pDSSearch-&gt;SetSearchPreference(
                 pSearchPref,
                 dwCurrPref
                 );
        BAIL_ON_FAILURE(hr);
        }
 
    hr = pDSSearch-&gt;ExecuteSearch(
             pszSearchFilter,
             pszAttrNames,
             dwNumberAttributes,
             &amp;hSearchHandle
              );      BAIL_ON_FAILURE(hr);
 
    hr = pDSSearch-&gt;GetNextRow(
             hSearchHandle
             );     BAIL_ON_FAILURE(hr);
 
    while (hr != S_ADS_NOMORE_ROWS) {
        nRows++;
 
        if (dwNumberAttributes == -1) {
            hr = pDSSearch-&gt;GetNextColumnName(
                     hSearchHandle,
                     &amp;pszColumnName
                     );             BAIL_ON_FAILURE(hr);
    
            while (hr != S_ADS_NOMORE_COLUMNS) {
                hr = pDSSearch-&gt;GetColumn(
                         hSearchHandle,
                         pszColumnName,
                         &amp;Column
                         );
    
                if (FAILED(hr)  &amp;&amp; hr != E_ADS_COLUMN_NOT_SET) 
                    goto error;
    
                if (SUCCEEDED(hr)) {
                    PrintColumn(&amp;Column, pszColumnName);
                    pDSSearch-&gt;FreeColumn(&amp;Column);
                }
 
             if (pszColumnName)
             free(pszColumnName);
                hr = pDSSearch-&gt;GetNextColumnName(
                         hSearchHandle,
                         &amp;pszColumnName
                         );      BAIL_ON_FAILURE(hr);
            }
            printf("\n");
        }                                  
        else {
            for (unsigned int i=0; i&lt;dwNumberAttributes; i++) {
                hr = pDSSearch-&gt;GetColumn(
                         hSearchHandle,
                         pszAttrNames[i],
                         &amp;Column
                         );
    
                if (hr == E_ADS_COLUMN_NOT_SET) 
                    continue;
    
                BAIL_ON_FAILURE(hr);
    
                PrintColumn(&amp;Column, pszAttrNames[i]);
    
                pDSSearch-&gt;FreeColumn(&amp;Column);
            }                                  
        printf("\n");
        }
 
        hr = pDSSearch-&gt;GetNextRow(
                 hSearchHandle
                 );
        BAIL_ON_FAILURE(hr);
    }
 
    wprintf (L"Total Rows: %d\n", nRows);
 
    if (cErr) {
        wprintf (L"%d warning(s) ignored", cErr);
    }
 
    if (hSearchHandle)
        pDSSearch-&gt;CloseSearchHandle(hSearchHandle);
 
    FREE_INTERFACE(pDSSearch);
 
    FREE_UNICODE_STRING(pszSearchBase) ;
    FREE_UNICODE_STRING(pszSearchFilter) ;
    FREE_UNICODE_STRING(pszAttrList) ;
 
    CoUninitialize();
 
    return(0) ;
 
error:
//  Error handling 
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
