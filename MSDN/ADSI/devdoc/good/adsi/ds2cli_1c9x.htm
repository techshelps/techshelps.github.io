<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADSI OLE DB Example</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_ds_adsi_ole_db_example"></a>ADSI OLE DB Example</h3>

<p>
<a name="_ds_query_a_directory_service"></a>This following ADSI example shows a simple command-prompt program that uses the OLE DB interfaces to query a directory service. The beginning comment section describes which functions were removed to simplify the example. The complete example code is included in the ADSI SDK in the samples/activeds/sampapp/cxx/adsqry directory.</p>
<pre><code>//--------------------------------------------------------------
//  Microsoft Active Directory 2.0 Sample Code
//  Copyright (C) Microsoft Corporation, 1997
//  File:       main.cxx
//  Contents:   Main for adsqry
//--------------------------------------------------------------
// ... global declarations, free memory calls, and error handling 
//        print routines, mapping input arguments to 
//        search arguments etc. omitted for brevity
 
#include "main.hxx"
 
int __cdecl
main( int argc, char ** argv)
{
 //  Load up a DBPropSet for DB data
 //    and a CmdPropSet for Command data
    hr = ProcessArgs(argc, argv);
    hr = CoInitialize(NULL);
    //
    // Instantiate a data source object for LDAP provider
    //
    hr = CoCreateInstance(
         CLSID_ADsDSOObject,
             0,
             CLSCTX_INPROC_SERVER,
             IID_IDBInitialize,
             (void **)&amp;pIDBInit
             );
 // Initialize the Data Source
     hr = pIDBInit-&gt;Initialize();
    if (cDBPropSet) {
        pIDBInit-&gt;QueryInterface(
            IID_IDBProperties,
            (void**) &amp;pIDBProperties);
        hr = pIDBProperties-&gt;SetProperties(
                 cDBPropSet,
                 rgDBPropSet);
 
    }
 // Get the interface to create a session
    pIDBInit-&gt;QueryInterface(
        IID_IDBCreateSession,
        (void**) &amp;pIDBCS);
 
 // Create a session returning a pointer to its CreateCommand interface
    hr = pIDBCS-&gt;CreateSession(
             NULL,
             IID_IDBCreateCommand,
             (LPUNKNOWN*) &amp;pIDBCreateCommand
             );
 // Create a command from the session object
    hr = pIDBCreateCommand-&gt;CreateCommand(
             NULL,
             IID_ICommandText,
             (LPUNKNOWN*) &amp;pICommandText
             );
 // Set the CommandText for the Query
    hr = pICommandText-&gt;SetCommandText(
             rguidDialect,
             pszCommandText
             );
// Set the properties on the Command Object 
    if (cCmdPropSet) {
        hr = pICommandText-&gt;QueryInterface(
                 IID_ICommandProperties,
                 (void**) &amp;pICommandProperties);
        hr = pICommandProperties-&gt;SetProperties(
                 cCmdPropSet,
                 rgCmdPropSet);
    }
 
    hr = pICommandText-&gt;QueryInterface(
             IID_ICommand,
             (void**) &amp;pICommand);

 // Do the Query and get back a rowset
    hr = pICommand-&gt;Execute(
             NULL,
             IID_IRowset,
             NULL,
             NULL,
             (LPUNKNOWN *)&amp;pIRowset
             );
    hr = pIRowset-&gt;QueryInterface(
             IID_IColumnsInfo,
             (void**) &amp;pIColsInfo
             );
    hr = pIColsInfo-&gt;GetColumnInfo(
             &amp;cCol,
             &amp;prgColInfo,
             &amp;szColNames
             );
 // The no. of attributes is one less than the no. of columns because of
 //  the Bookmark column
    nAttrs = cCol - 1;
    pMyStatus = (DBBINDSTATUS *) LocalAlloc(
                                     LPTR,
                                     sizeof(DBBINDSTATUS) * nAttrs
                                     );
    hr = CreateAccessorHelper(
             pIRowset,
             nAttrs,
             prgColInfo,
             &amp;myAccessor,
             pMyStatus
             );
    pMyData = (Data *) LocalAlloc(
                           LPTR,
                           sizeof(Data) * nAttrs
                           );
    //  Get the rows; 256 at a time
    phRows = NULL;
    hr = pIRowset-&gt;GetNextRows(
             NULL,
             0,
             256,
             &amp;cRowsObtained,
             &amp;phRows
             );
    j = cRowsObtained;
    while (cRowsObtained) {
        for (i = 0; i &lt; cRowsObtained; i++) {
 // Get the data from each row
            hr = pIRowset-&gt;GetData(
                     phRows[i],
                     myAccessor,
                     (void*)pMyData
                     );
           PrintData(pMyData, nAttrs, prgColInfo);
        }
        pIRowset-&gt;ReleaseRows(
                      cRowsObtained, 
                      phRows,
                      NULL,
                      NULL,
                      NULL
                      );
 // Get the next 256 rows
        hr = pIRowset-&gt;GetNextRows(
                 NULL,
                 0,
                 256,
                 &amp;cRowsObtained,
                 &amp;phRows
                 );
        j+=cRowsObtained;
    }
    printf("Rows printed = %d\n", j);
    exit(0);
 
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
