<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PARSE.CPP</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_ds_parse.cpp"></a>PARSE.CPP</h2>
<p>
In the example provider component, an example of the directory service path name parser is in parse.cpp. The path name parser is a key component in ADs provider components. It checks the syntactic validity of an ADs path name passed in to this provider. If the syntax is valid, an OBJECTINFO structure is constructed, which contains a componentized version of the ADs pathname for this object.</p>
<p>
Note that all that is being done is a syntax check. Rather than special-case every nuance new to path names, all path checking must conform to the grammar rules laid out by the parser.</p>
<p>
Called from <b>GetObjectW</b> in getobj.cpp.
<dl>
<dt>
<b>ADsObject</b></dt>
<dd>
Parses the ADs pathname passed to it. This function follows the following grammar rules:
<p>
&lt;ADsObject&gt; -&gt; &lt;ProviderName&gt; &lt;SampleDSObject&gt;

</dd>
<dt>
<b>SampleDSObject</b></dt>
<dd>
Parses the following grammar rules:
<p>
&lt;SampleDSObject&gt; -&gt; "\\" &lt;identifier&gt; "\" &lt;SampleDSObject&gt;

</dd>
<dt>
<b>ProviderName</b></dt>
<dd>
Adds in the syntactically correct provider name if not there.</dd>
<dt>
<b>DsPathName</b></dt>
<dd>
Parses the following grammar rules:
<p>
&lt;Pathname&gt; -&gt; &lt;Component&gt; "\\" &lt;Pathname&gt;  OR  

<p>
&lt;Pathname&gt; -&gt; &lt;Component&gt;

</dd>
<dt>
<b>Component</b></dt>
<dd>
Parses the following grammar rules:
<p>
&lt;Identifier&gt; OR  

<p>
&lt;Identifier&gt; "=" &lt;Identifier&gt;

</dd>
<dt>
<b>CLexer::CLexer</b></dt>
<dd>
Standard constructor.</dd>
<dt>
<b>CLexer::~CLexer</b></dt>
<dd>
Standard destructor.</dd>
<dt>
<b>CLexer::GetNextToken</b></dt>
<dd>
Tokenizer.</dd>
<dt>
<b>CLexer::NextChar</b></dt>
<dd>
Retrieves next single character.</dd>
<dt>
<b>CLexer::PushBackToken</b></dt>
<dd>
Backs up to beginning of last token.</dd>
<dt>
<b>CLexer::PushbackChar</b></dt>
<dd>
Backs up one character.</dd>
<dt>
<b>CLexer::IsKeyword</b></dt>
<dd>
Checks keyword list (defined in globals.h).</dd>
<dt>
<b>CLexer::AddComponent</b></dt>
<dd>
Adds this component to the component array.</dd>
<dt>
<b>AddProviderName</b></dt>
<dd>
Adds a syntactically correct provider name into the string to be parsed.</dd>
<dt>
<b>AddRootRDN</b></dt>
<dd>
Adds the syntactically correct root relative distinguished name (RDN) <i>]</i>name into the string to be parsed
</dd>
</dl>
<p>&nbsp;</p></body>
</HTML>
