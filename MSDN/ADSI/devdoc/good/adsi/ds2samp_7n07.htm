<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Code Overview</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_ds_code_overview"></a>Code Overview</h1>
<p>
The following figure is a conceptual representation of the blocks of code necessary to implement the ADSI example provider component. Each section is described below. Knowledgeable COM programmers may find this is all they need for an overview of the example provider component. For more details, each code file is detailed in <a href="ds2samp_0ttf.htm"><b>Code Details</b></a>.</p>
<p>
<img src="images/dssmco.gif" border=0></p>
<p>
<b>ADSI Example Provider Component Source Code Description</b>
<ol>
<li>
Loading the DLL (libmain.cpp, guid.cpp). The entry point for the DLL. Class factory static object definitions for the two provider objects: Guid.cpp contains the CLSID definitions for the implementations of the various Example provider component objects.</li>
<li>
Provider object class factory and creation code (cprovcf.cpp, cprov.cpp, stdfact.cpp). The provider object is the object that supports IParseDisplayName during the moniker binding operations as discussed in Finding and Binding in the Example Provider Component. </li>
<li>
Binding to an object (getobj.cpp). This code calls the parser to check that the given ADsPath is syntactically correct, and then performs any necessary mapping from the ADsPath to the native directory service path for the item being created as an Active Directory object. It looks up the schema definition for this type of object and fills in the mandatory properties. After creating the Active Directory object, an interface pointer to IUnknown is retrieved for the caller. </li>
<li>
Parser for the provider's namespace (parse.cpp). This is the code invoked by the step above. The parser simply checks that the ADsPath string passed in is syntactically correct for its own namespace.</li>
<li>
Class factory, creation, and enumeration for the namespace object (cnamcf.cpp, cnamesp.cpp, cenumns.cpp). The namespace object is a container object that can be enumerated to find all the root node objects for this namespace.</li>
<li>
Class factory and creation code for a generic Active Directory object, and class factory, creation and enumeration code for a generic ADs container object (cgenobj.cpp, cenumobj.cpp, common.cpp, core.cpp). This code is executed whenever an Active Directory object is created. </li>
<li>
Filtering and enumerating VARIANTs (cenumvar.cpp, object.cpp). When a collection of VARIANT elements of a single type are managed in within ADSI, this code is used.</li>
<li>
Globals (globals.cpp). Namespace keywords, syntax mapping structures from native data formats to the ADs Automation VARIANT type are all defined here.</li>
<li>
Marshaling/unmarshaling data (pack.cpp, property.cpp, smpoper.cpp). Conversion from native data formats to the supported set of Automation VARIANT types occurs when properties of an object are loaded into the property cache. Other special handling for data must be performed when structures with pointers are copied, deleted, or moved in memory.</li>
<li>
Property cache (cprops.cpp). Caching properties is a feature of the ADSI environment. The <a href="ds2_if_2a5r.htm"><b>IADs::GetInfo</b></a>, <a href="ds2_if_83aw.htm"><b>IADs::GetInfoEx</b></a>, and <a href="ds2_if_4tf3.htm"><b>IADs::SetInfo</b></a> methods act on the property cache.</li>
<li>
Memory management (memory.cpp). Using one set of memory functions to allocate and free memory allows the example provider component to track memory use and ensure there are no memory leaks.</li>
<li>
Schema objects and management (cschobj.cpp, cprpobj.cpp, cclsobj.cpp, cenumsch.cpp). This includes routines to create, manage, and enumerate the schema objects. This includes schema class objects, property objects, and syntax objects, in addition to being able to enumerate the schema class container object.</li>
<li>
Operating-system specific calls (RegDSAPI.cpp). This includes all calls that reference the native operating system. Among other functions, they include functions opening, closing, reading, and modifying objects as well as those accessing the schema and property data. The example provider component happened to simulate a directory hierarchy by using the registry. Only function names should be of much interest to a provider writer.</li>
<li>
<b>IDispatch</b> implementation (cdispmgr.cpp). This code accesses the type library information to allow interface methods to be invoked in an Automation-compatible way.</li>
</ol>
<p>&nbsp;</p></body>
</HTML>
