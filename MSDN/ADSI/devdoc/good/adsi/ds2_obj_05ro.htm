<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ADSI Enumerator Object</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_ds_adsi_enumerator_object"></a>ADSI Enumerator Object</h2>
<p>
An <b>ADSI Enumerator Object</b> is a dependent COM object in Active Directory that enumerates its Active Directory host object. <a href="ds2_obj_9i5w.htm"><b>ADSI Container Objects</b></a>, <a href="ds2_obj_7ctw.htm"><b>ADSI Members Objects</b></a>, and <a href="ds2_obj_9ygk.htm"><b>ADSI Collection Objects</b></a> host enumerator objects. This object supports the Automation <b>IEnumVARIANT </b>interface, which is retrieved by the <b>get__NewEnum</b> ( _NewEnum) method supported by <a href="ds2_if_325u.htm"><b>IADsContainer</b></a>, <a href="ds2_if_4703.htm"><b>IADsMembers</b></a>, and <a href="ds2_if_2zzi.htm"><b>IADsCollection</b></a>. By convention, all items managed by an enumerator object are of the same Automation data type. An enumeration should not retrieve some items as VARIANTs of type VT_I4 and others as VARIANTs of type VT_BSTR. Active Directory objects interfaces are represented by the VT_UNKNOWN type.</p>
<h4>When to Implement</h4>
<p>
Implement <b>ADSI Enumerator Object</b> only when you are providing Active Directory enumeration functionality for your directory service implementation.</p>
<p>
Follow one of three models for caching collections during enumeration. The caching model affects the behavior of Active Directory when an object in a collection is deleted from the underlying directory service "outside" of Active Directory.
<ol>
<li>
Collections are cached. The collection of object instances is retrieved from the underlying directory in its entirety when <b>get_NewEnum </b>(<b>_NewEnum)</b> is called to create a new enumerator object. If the source object for an Active Directory object instance in the retrieved collection is deleted from the underlying directory, you do not become aware of the deletion until an <a href="ds2_if_2a5r.htm"><b>IADs::GetInfo</b></a> or <a href="ds2_if_4tf3.htm"><b>IADs::SetInfo</b></a> attempts to access the source instance. </li>
<li>
Collections are incrementally cached. The collection is retrieved from the underlying directory one object at a time when <b>IEnumVARIANT::Next</b> is called. <b>Reset</b> returns to the beginning of the collection in the cache and <b>Next</b> will return cached objects until the end of the cache is reached, at which point new objects are added from the underlying store. Once an Active Directory object instance is in the cache, you do not become aware of its deletion from the underlying directory until an <b>IADs::GetInfo</b> or <b>IADs::SetInfo</b> attempts to access the source instance. </li>
<li>
Collections are not cached. The collection is retrieved from the underlying directory one object at a time when <b>IEnumVARIANT::Next</b> is called. <b>Reset</b> returns to the beginning of the collection in the underlying store. <b>Next</b> and <b>Reset</b> operations cannot retrieve deleted objects, since the objects are fetched on-demand from the underlying directory. Only the "current" object is cached. If the current object is deleted, you do not become aware of its deletion from the underlying directory until an <b>IADs::GetInfo</b> or <b>IADs::SetInfo</b> attempts to access the source instance. </li>
</ol>
<p>
<b>ADSI Container Object</b> or <b>ADSI Members Object </b>enumerations yield one or more Active Directory interfaces. Cache the retrieved pointers for any Active Directory objects you intend to manipulate to avoid the overhead of obtaining a new interface pointer. For example, a Visual Basic program that enumerates a container and populates a listbox with names can cache the interface pointers associated with the names for later use. This approach provides greater performance than populating the listbox during enumeration and obtaining a new interface pointer when the user makes a selection.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=42%>Interfaces on ADSI Enumerator Object</th>
<th align=left width=58%>Description</th>
</tr>
<tr valign=top>
<td width=42%><b>IUnknown</b></td>
<td width=58%>Universal COM object management and interface query methods.</td>
</tr>
<tr valign=top>
<td width=42%><b>IDispatch</b></td>
<td width=58%>Automation methods for late-bound access to an object's methods and properties</td>
</tr>
<tr valign=top>
<td width=42%><b>IEnumVARIANT</b></td>
<td width=58%>Iteration methods for stepping through the items in a container. </td>
</tr>
</table><br>
<h4>QuickInfo</h4>
<p>
&nbsp;&nbsp;<b>Windows NT:</b>  Use version 4.0 and later. </p>
<h4>See Also</h4>
<p>
<a href="ds2_func_7jjm.htm"><b>ADsBuildEnumerator</b></a>, <a href="ds2_func_9dro.htm"><b>ADsEnumerateNext</b></a>, <a href="ds2_func_8q42.htm"><b>ADsFreeEnumerator</b></a> </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
