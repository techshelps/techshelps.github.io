<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Attachment H: WMI/CIM and Win32 Extensions Instrumentation Details</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana, arial, helvetica" size="2"><h1>
Attachment H: WMI/CIM and Win32 Extensions Instrumentation Details</h1>
<p>
The WMI/CIM required schema is a set of base classes that provide the minimal set of information supported by Net PC platforms deployed with WMI instrumented operating system. The minimal set of classes and associations are listed here and must be deployed on all Net PCs designed for shipment with WMI-instrumented and WBEM-instrumented operating systems.</p>
<p>
Over time, the set of base classes can be extended to accommodate additional requirements. CIM incorporates an extension process whereby additional classes, properties, and associations can be introduced. These will initially be introduced as non-standard extensions, typically subclasses of a standard class or new classes associated with a standard class. Over time, the model is intended to evolve as new extensions become widely used and accepted (clearly, the better the design, the better the chance of an extension being accepted). </p>
<p>
It is the intention of the standard set defined here to establish a baseline for Net PC management, not a comprehensive solution to all possible management scenarios. Individual OEMs can extend the schema as required to accommodate special capabilities. If these extensions are made under the class structure defined here, management applications can be expected to benefit from them without any changes being required. </p>
<p>
The class structure defined here is a subset of the overall CIM schema. Any extensions are required to be consistent with this broader schema. Extensions outside the logical framework of the CIM schema will require changes to management applications to take full advantage of them. As these extensions are standardized, management applications can be expected to accommodate the new capabilities with any required changes to associated algorithms and interfaces. Generic browsers, of course, can always display a new class or property without requiring any specialized extensions.</p>
<p>
Management applications can be expected to take advantage of the CIM schema to provide, for example, different views of a system (a physical component view, a services and drivers view, a running processes view, and so on.) </p>
<p>
An example of the extension of a standard class is the addition of a new type of service as an extension of the standard service class. Any management application that uses the standard service class will pick up instances of the new service class (as a result of inheritance), even though it will not be aware of the extension. If someone adds a new class that is not a subclass of the standard service class, yet the instances of the new class are services, then management applications will not be aware of the new class without some exception handling. The management application will have to be specially coded to go and look for the class and to present it along with the other information about services.</p>
<p>
A similar but more complex argument applies to the use of associations.</p>
<p>
The individual elements that make up a system can be enumerated using a number of different strategies. There are several key classes and associations involved; most are present in the diagram that follows. The strategies available for enumerating the components of a system provide a view of the schema from the perspective of a system considered as an aggregation hierarchy (as opposed to the schema as a classification hierarchy). </p>
<p>
A function that lists the components of a system will start with a system object. The system components association relates the system to its components. The listing function must select the components to be listed based on the type of picture of the system to be presented. There is any number of alternative views depending on the circumstances at hand: 
<ul>
<li>
If a list of the physical components is required, the function will list all the components that are physical elements. <br><br></li>
<li>
If the top-most physical elements are required, the function will list the physical elements that are not contained in anything. <br><br></li>
<li>
If a configuration view is required, the objects representing the physical configuration of the system will be accessed. Its dependency and context associations will be traversed to obtain the physical configuration. <br><br></li>
<li>
If the logical components of the system are required, the components of type logical element will be selected. <br><br></li>
<li>
Selecting logical elements that have nothing dependent on them would return top-level logical objects. <br><br></li>
<li>
Low-level elements &mdash; typically, a device-level view &mdash; could be constructed by selecting logical elements that either have no realization or have a physical element realization. <br><br></li>
<li>
Dependency or configuration trees could be constructed by pursuing suitable associations. </li>
</ul>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=104pt><b>Name</b></td>
<td width=110pt><b>SuperClass</b></td>
<td width=227pt><b>Description</b></td>
</tr>
<tr valign=top>
<td width=104pt>ManagedSystemElement</td>
<td width=110pt></td>
<td width=227pt>The base class for all system component objects. Any managed object that is a component of a system is a descendent of this class. These objects include: software components, such as files; devices, such as disk drives and controllers; and physical components, such as chips and cards.</td>
</tr>
<tr valign=top>
<td width=104pt>PhysicalElement</td>
<td width=110pt>ManagedSystemElement</td>
<td width=227pt>Any component of a system that has a distinct physical identity and that can be defined in terms of labels that can be physically attached to the object is a member of this class. All processes, files, records, and devices are considered not to be physical elements. For example, it is not possible to attach a label to a modem. It is only possible to attach a label to the card that implements the modem. The same card could also implement a LAN adapter. These are tangible managed system elements&mdash;usually actual hardware items&mdash;that have a physical manifestation of some sort. A managed system element is not necessarily a discrete component. For example, it is possible for a single card&mdash;which is a type of physical element&mdash;to host more than one logical device. The card would be represented by a single physical element associated with multiple logical devices.</td>
</tr>
<tr valign=top>
<td width=104pt>LogicalElement</td>
<td width=110pt>ManagedSystemElement</td>
<td width=227pt>A base class for all the components of the system that represent abstract system components, such as profiles, processes, or system capabilities in the form of logical devices.</td>
</tr>
<tr valign=top>
<td width=104pt>System</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>A grouping of other logical elements. Because systems are logical elements, a system can be composed of other systems.</td>
</tr>
<tr valign=top>
<td width=104pt>Protocol</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>Represents a protocol, which is a set of rules and algorithms that govern the interaction between two or among more than two interfaces.</td>
</tr>
<tr valign=top>
<td width=104pt>SoftwareComponent</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>Represents any software component, which can be either an individual file, such as an executable, or a collection of files, such as packages or operating systems. Software components can have additional associated information, such as the installation date.</td>
</tr>
<tr valign=top>
<td width=104pt>Process</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>A sequence of states defined by the interaction of one or more processors or interpreters, some executable code and a set of inputs.</td>
</tr>
<tr valign=top>
<td width=104pt>Thread</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>Represents a thread, which is a unit of execution; that is, an address space. Threads are owned by processes.</td>
</tr>
<tr valign=top>
<td width=104pt>SystemService</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>Represents a system service, which is a definition of a process owned by the system; rather than some specific user that provides an interface to some aspect of the functionality supported by the system.</td>
</tr>
<tr valign=top>
<td width=104pt>Job</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>Represents a unit of work, such as a print job.</td>
</tr>
<tr valign=top>
<td width=104pt>JobDestination</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>A process or service able to process one or more jobs.</td>
</tr>
<tr valign=top>
<td width=104pt>FileSystem</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>This object represents a set of conventions used for arranging data on a storage medium.</td>
</tr>
<tr valign=top>
<td width=104pt>DiskPartition</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>A structure used to manage the physical surface of a physical disk. There may be a level of indirection between the physical disk and the actual hardware as, for example, in the case of RAID devices.</td>
</tr>
<tr valign=top>
<td width=104pt>Device</td>
<td width=110pt>LogicalElement</td>
<td width=227pt>A unit of functionality associated with providing the basic capabilities of a system such as input, output, or storage management. Devices may be directly expressed by a physical component as, for example, in the case of a keyboard. However, almost any device can be virtualized either by simulation (for example, simulating a modem using main CPU cycles), by allocation of a single device to multiple physical components, or by allocation of more than one device to a single physical unit. For example, a modem and LAN adapter may share the same PCMCIA card. </td>
</tr>
<tr valign=top>
<td width=104pt>StorageDevice</td>
<td width=110pt>Device</td>
<td width=227pt>A source or destination for a file. Processors and end users typically see data in the system in terms of files, which in turn are allocated to data sources. The data source is a named unit of storage that may correspond to a variety of implementations, including memory, CDROM, and network.</td>
</tr>
<tr valign=top>
<td width=104pt>Modem</td>
<td width=110pt>Device</td>
<td width=227pt>A device that translates binary data into wave modulations &mdash; typically, sound for transmission over telephone lines.</td>
</tr>
<tr valign=top>
<td width=104pt>Processor</td>
<td width=110pt>Device</td>
<td width=227pt>A device capable of interpreting a sequence of machine instructions. Typically, the processor has a close correspondence to a physical chip, but it may be provided by an interpreter that is itself a process running on a processor of some kind.</td>
</tr>
<tr valign=top>
<td width=104pt>Keyboard</td>
<td width=110pt>Device</td>
<td width=227pt>A device for entering data through keystrokes.</td>
</tr>
<tr valign=top>
<td width=104pt>LogicalConnector</td>
<td width=110pt>Device</td>
<td width=227pt>A device capable of connecting two or more other devices.</td>
</tr>
<tr valign=top>
<td width=104pt>InterfaceDevice</td>
<td width=110pt>Device</td>
<td width=227pt>Represents an interface device; any interface device is a descendant of this class. These are devices that act as an interface between a device and the rest of the system &mdash; for example, disk controllers, serial ports, parallel ports, and so on. </td>
</tr>
<tr valign=top>
<td width=104pt>Display</td>
<td width=110pt>Device</td>
<td width=227pt>The device used to visually display output from the system. </td>
</tr>
<tr valign=top>
<td width=104pt>MemoryModule</td>
<td width=110pt>Device</td>
<td width=227pt>A device capable of storing information for fast retrieval.</td>
</tr>
<tr valign=top>
<td width=104pt>PointingDevice</td>
<td width=110pt>Device</td>
<td width=227pt>A device used to point to regions on the display.</td>
</tr>
<tr valign=top>
<td width=104pt>Printer</td>
<td width=110pt>Device</td>
<td width=227pt>A device capable of reproducing a visual image on a medium of some kind, usually paper. Printers are a common example of a device that is also a system. The system aspect of the printer must be represented in this model as a discrete object that is a descendent of the system class.</td>
</tr>
<tr valign=top>
<td width=104pt>ActualStorageDevice</td>
<td width=110pt>Device</td>
<td width=227pt>A device that is primarily intended to describe the organization of a physical unit used to store data. </td>
</tr>
<tr valign=top>
<td width=104pt>Bus</td>
<td width=110pt>Device</td>
<td width=227pt>A device that provides high-bandwidth communication between different components of the system.</td>
</tr>
<tr valign=top>
<td width=104pt>SCSIIInterface</td>
<td width=110pt>InterfaceDevice</td>
<td width=227pt>Represents a SCSII Interface device and its properties.</td>
</tr>
<tr valign=top>
<td width=104pt>NetworkDrive</td>
<td width=110pt>StorageDevice</td>
<td width=227pt>Represents a logical drive that has been mapped to a network resource.</td>
</tr>
<tr valign=top>
<td width=104pt>LogicalDiskDrive</td>
<td width=110pt>StorageDevice</td>
<td width=227pt>A data source that resolves to a local ActualStorageDevice.</td>
</tr>
<tr valign=top>
<td width=104pt>Driver</td>
<td width=110pt>SoftwareComponent</td>
<td width=227pt>Represents an executable or set of executables that provide an interface either to another driver or to a logical device.</td>
</tr>
<tr valign=top>
<td width=104pt>OperatingSystem</td>
<td width=110pt>SoftwareComponent</td>
<td width=227pt>Describes general information about operating systems installed on this system.</td>
</tr>
<tr valign=top>
<td width=104pt>NetworkProtocol</td>
<td width=110pt>Protocol</td>
<td width=227pt>Provides information about a protocol that has been installed on the system.</td>
</tr>
<tr valign=top>
<td width=104pt>ComputerSystem</td>
<td width=110pt>System</td>
<td width=227pt>A system that is capable of running programs, processing inputs, and displaying or otherwise returning outputs.</td>
</tr>
<tr valign=top>
<td width=104pt>PhysicalPackage</td>
<td width=110pt>PhysicalElement</td>
<td width=227pt>Defines the characteristics of system components that physically contain other system components, such as the system enclosure, which would be a type of cabinet.</td>
</tr>
<tr valign=top>
<td width=104pt>PhysicalLink</td>
<td width=110pt>PhysicalElement</td>
<td width=227pt>Contains any physical object used to link other objects together, which can include wires, wireless connections (radio frequencies and infrared), and so on.</td>
</tr>
<tr valign=top>
<td width=104pt>PhysicalConnector</td>
<td width=110pt>PhysicalElement</td>
<td width=227pt>A physical element that is used to connect other Physical Elements, such as slots and plugs. This object has properties, such as the type (male or female) and the number of pins.</td>
</tr>
<tr valign=top>
<td width=104pt>Slot</td>
<td width=110pt>PhysicalConnector</td>
<td width=227pt>Defines the attributes for the different expansion slots supported by this system.</td>
</tr>
<tr valign=top>
<td width=104pt>PortConnector</td>
<td width=110pt>PhysicalConnector</td>
<td width=227pt>Defines the network connection points provided by the system.</td>
</tr>
<tr valign=top>
<td width=104pt>Card</td>
<td width=110pt>PhysicalPackage</td>
<td width=227pt>A type of physical container that can be plugged into another card or board.</td>
</tr>
<tr valign=top>
<td width=104pt>ElementSetting</td>
<td width=110pt></td>
<td width=227pt>ElementSetting are operational parameters that vary from time to time.</td>
</tr>
<tr valign=top>
<td width=104pt>PartitionConfiguration</td>
<td width=110pt>ElementSetting</td>
<td width=227pt>An arrangement of partitions used to provide a basis for one or more logical disks.</td>
</tr>
<tr valign=top>
<td width=104pt>Dependency</td>
<td width=110pt></td>
<td width=227pt>An association class that is the base class for all associations that define any dependency between managed system elements.</td>
</tr>
<tr valign=top>
<td width=104pt>Component</td>
<td width=110pt></td>
<td width=227pt>Descendents of this association class define part of the relationships between managed system elements. For example, the system components association defines the parts of a system.</td>
</tr>
<tr valign=top>
<td width=104pt>Location</td>
<td width=110pt></td>
<td width=227pt>The base class for all location objects.</td>
</tr>
<tr valign=top>
<td width=104pt>ElementSettings</td>
<td width=110pt></td>
<td width=227pt>Relates an ElementSetting object to the system element it provides settings for.</td>
</tr>
</table><br>

</font></BODY>
</HTML>
