<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Attachment D: Preboot API Parameter Structure and Type Definitions</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana, arial, helvetica" size="2"><h1>
Attachment D: Preboot API Parameter Structure and Type Definitions</h1>
<p>
<b>Important:</b> The code provided in this attachment is provided for informational purposes only. </p>
<pre><code>/*
 *
* Copyright(c) 1997 by Intel Corporation.  All Rights Reserved.
 *
 */

#ifndef _PXENV_API_H
#define_PXENV_API_H

/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/*Parameter structure and type definitions for PXENV API version 2.x
 *
 *PXENV.H needs to be #included before this file.
 *
 *None of the PXENV API services are available after the stack
 *has been unloaded.
 */

#include "bootp.h"/* Defines BOOTPLAYER */


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* Format of PXENV entry point structure.
 */
typedef struct s_PXENV_ENTRY {
UINT8 signature[6];/* 'PXENV+' */
UINT16 version;/* MSB=major, LSB=minor */
UINT8 length;/* sizeof(struct s_PXENV_ENTRY) */
UINT8 checksum;/* 8-bit checksum off structure, */
/* including this bytes should */
/* be 0. */
UINT16 rm_entry_off;/* 16-bit real-mode offset and */
UINT16 rm_entry_seg;/* segment of the PXENV API entry */
/* point. */
UINT16 pm_entry_off;/* 16-bit protected-mode offset */
UINT32 pm_entry_seg;/* and segment base address of */
/* the PXENV API entry point. */
UINT16 stack_sel;/* PROM stack segment.  Will be set */
UINT16 stack_size;/* to 0 when removed from memory. */

UINT16 base_cs_sel;/* Base code segment.  Will be set */
UINT16 base_cs_size;/* to 0 when removed from memory. */

UINT16 base_ds_sel;/* Base data segment.  Will be set */
UINT16 base_ds_size;/* to 0 when removed from memory. */

/* The MLID code and data segment selectors are always required */
/* when running the boot PROM in protected mode. */

UINT16 mlid_ds_sel;/* MLID data segment. */
UINT16 mlid_ds_size;

UINT16 mlid_cs_sel;/* MLID code segment. */
UINT16 mlid_cs_size;

} t_PXENV_ENTRY;

#definePXENV_ENTRY_SIG"PXENV+"


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* One of the following command op-codes needs to be loaded into the
 * op-code register (BX) before making a call a PXENV API service.
 */
#define PXENV_UNLOAD_STACK0x70
#define PXENV_GET_BINL_INFO0x71
#definePXENV_RESTART_DHCP0x72
#definePXENV_RESTART_TFTP0x73
#definePXENV_MODE_SWITCH0x74


/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
/* PXENV API parameter structure typedefs.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_UNLOAD_STACK {
UINT16 status;/* Out: See PXENV_STATUS_xxx */
/*      constants. */
UINT16 rm_entry_off;/* Out: 16-bit real-mode segment and */
UINT16 rm_entry_seg;/*      offset of PXENV Entry Point */
/*      structure. */
UINT16 pm_entry_off;/* Out: 16-bit protected-mode offset */
UINT32 pm_entry_base;/*      and segment base address of */
/*      PXENV Entry Point structure. */
} t_PXENV_UNLOAD_STACK;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Packet types that can be requested in the s_PXENV_GET_BINL_INFO structure. */
#define PXENV_PACKET_TYPE_DHCP_DISCOVER  1
#define PXENV_PACKET_TYPE_DHCP_ACK       2
#define PXENV_PACKET_TYPE_BINL_REPLY     3

/* Three packets are preserved and available through this interface: 1) The
 * DHCP Discover packet sent by the client, 2) the DHCP acknowledgement
 * packet returned by the DHCP server, and 3) the reply packet from the BINL
 * server.  If the DHCP server provided the image bootfile name, the
 * DHCP_ACK and BINL_REPLY packets will identical.
 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_GET_BINL_INFO {
UINT16 status;/* Out: See PXENV_STATUS_xxx */
/*      constants. */
UINT16 packet_type;/* In: See PXENV_PACKET_TYPE_xxx */
/*     constants */
UINT16 buffer_size;/* In: Size of the buffer in */
/*     bytes.  Specifies the maximum */
/*     amount of data that will be */
/*     copied by the service.  A size */
/*     of zero is valid. */
/* Out: Amount of BINL data, in */
/*      bytes, that was copied into */
/*      the buffer.  For an input */
/*      size of zero, no data will be */
/*      copied and buffer_size will */
/*      be set to the maximum amount */
/*      of data available to be */
/*      copied. */
UINT16 buffer_offset;/* In: 16-bit offset and segment */
UINT16 buffer_segment;/*     selector of a buffer where the */
/*     requested packet will be */
/*     copied. */
/*Out: If buffer_size, buffer_offset and */
/*     buffer_segment are all zero;  */
/*     buffer_offset and buffer_segment */
/*     will be changed to point at the */
/*     packet buffers in the base code. */
} t_PXENV_GET_BINL_INFO;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
typedef struct s_PXENV_RESTART_DHCP {
UINT16 status;/* Out: See PXENV_STATUS_xxx */
/*      constants. */
} t_PXENV_RESTART_DHCP;


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
#defines_PXENV_RESTART_TFTPs_PXENV_TFTP_READ_FILE
#definet_PXENV_RESTART_TFTPt_PXENV_TFTP_READ_FILE


typedef struct s_PXENV_MODE_SWITCH {
UINT16 status;/* Out: See PXENV_STATUS_xxx constants*/
UINT16 pxenv_entry_off;   /* In: Offset of PXENV entry point */
                              /*     structure. */
    UINT16 pxenv_entry_seg;   /* In: Real-mode segment or protected- */
                              /*     mode selector of the PXENV */
                              /*     entry point structure. */

/* Protected-mode status call-back API is documented below. */

    UINT16 pmode_status_off;      /* In: Offset of 16-bit protected */
                                  /*     mode status call-back. */
    UINT16 pmode_status_sel;      /* In: Selector of 16-bit protected */
                                  /*     mode status call-back. */
} t_PXENV_MODE_SWITCH;

/*
 * The protected-mode call back will be used by the base code when the 
 * client PC is in protected-mode and pmode_status_sel is non-zero.
 *
 * The base code will call the status call-back 
 * with the following registers:
 *      AX = 0 (Inside a time-out loop.)
 *      AX = 1 - n (Packet number of received TFTP packet.)
 *      All other registers and flags are undefined.
 *
 * The call-back will return a continue/cancel flag 
 * in the following registers:
 *      AX = 0 (continue)
 *      AX = 1 (cancel)
 * All other AX values are undefined, and will be treated as cancel.
 * All other registers and flags must be unchanged.
 */} t_PXENV_MODE_SWITCH;

#endif /* _PXENV_API_H */

/* EOF - $Workfile:   pxe_api.h  $ */


</code></pre>
</font></BODY>
</HTML>
