<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Node IDs when no IEEE 802 network card is available</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana, arial, helvetica" size="2"><h1>
Node IDs when no IEEE 802 network card is available</h1>
<p>
If a system wants to generate UUIDs but has no IEE 802 compliant network card or other source of IEEE 802 addresses, then this section describes how to generate one.</p>
<p>
The ideal solution is to obtain a 47 bit cryptographic quality random number, and use it as the low 47 bits of the node ID, with the most significant bit of the first octet of the node ID set to 1. This bit is the unicast/multicast bit, which will never be set in IEEE 802 addresses obtained from network cards; hence, there can never be a conflict between UUIDs generated by machines with and without network cards. </p>
<p>
If a system does not have a primitive to generate cryptographic quality random numbers, then in most systems there are usually a fairly large number of sources of randomness available from which one can be generated. Such sources are system specific, but often include:
<ul>
<li>
The percent of memory in use <br><br></li>
<li>
The size of main memory in bytes<br><br></li>
<li>
The amount of free main memory in bytes<br><br></li>
<li>
The size of the paging or swap file in bytes<br><br></li>
<li>
Free bytes of paging or swap file<br><br></li>
<li>
The total size of user virtual address space in bytes<br><br></li>
<li>
The total available user address space bytes <br><br></li>
<li>
The size of boot disk drive in bytes<br><br></li>
<li>
The free disk space on boot drive in bytes<br><br></li>
<li>
The current time<br><br></li>
<li>
The amount of time since the system booted<br><br></li>
<li>
The individual sizes of files in various system directories<br><br></li>
<li>
The creation, last read, and modification times of files in various system directories<br><br></li>
<li>
The utilization factors of various system resources (heap, etc.)<br><br></li>
<li>
Current mouse cursor position<br><br></li>
<li>
Current caret position<br><br></li>
<li>
Current number of running processes, threads<br><br></li>
<li>
Handles or IDs of the desktop window and the active window<br><br></li>
<li>
The value of stack pointer of the caller<br><br></li>
<li>
The process and thread ID of caller<br><br></li>
<li>
Various processor architecture specific performance counters (instructions executed, cache misses, TLB misses)<p>
(Note that it precisely the above kinds of sources of randomness that are used to seed cryptographic quality random number generators on systems without special hardware for their construction.)
<p>
In addition, items such as the computer&rsquo&rsquo;s name and the name of the operating system, while not strictly speaking random, will help differentiate the results from those obtained by other systems.
<p>
The exact algorithm to generate a node ID using these data is system specific, because both the data available and the functions to obtain them are often very system specific. However, assuming that one can concatenate all the values from the randomness sources into a buffer, and that a cryptographic hash function such as MD5 [3] is available, the following code will compute a node ID:
<pre><code>#include &lt;md5.h&gt;
#define HASHLEN 16

void GenNodeID(
unsigned char * pDataBuf,// concatenated "randomness values"
long cData,// size of randomness values
unsigned char NodeID[6]// node ID
)
{
  int i, j, k;
  unsigned char Hash[HASHLEN];
  MD_CTX context;

  MDInit (&amp;context);
  MDUpdate (&amp;context, pDataBuf, cData);
  MDFinal (Hash, &amp;context);

  for (j = 0; j&lt;6; j++) NodeId[j]=0;
  for (i = 0,j = 0; i &lt; HASHLEN; i++) {
    NodeID[j++] ^= Hash[i];
    if (j == 6) j = 0;
};
NodeID[0] |= 0x80;// set the multicast bit
};
</code></pre>
<p>
Other hash functions, such as SHA-1 [4], can also be used (in which case HASHLEN will be 20). The only requirement is that the result be suitably random &ndash; in the sense that the outputs from a set uniformly distributed inputs are themselves uniformly distributed, and that a single bit change in the input can be expected to cause half of the output bits to change.
</li>
</ul>
</font></BODY>
</HTML>
