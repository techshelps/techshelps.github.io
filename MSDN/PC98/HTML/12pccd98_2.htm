<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PC Card Socket Controller Requirements</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1><a name="pccardsocketcontrollerrequirements"></a>PC&nbsp;Card Socket Controller Requirements</h1>
<p>
This section summarizes PC&nbsp;98 requirements and standards for socket controllers.</p>
<p>
<b>3. Controller supports industry-standard ExCA register set</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
The built-in software supporting PC Card 16 cards in Windows includes drivers&nbsp;for the industry-standard Exchangeable Card Architecture-compatible (ExCA-compatible) socket controllers. To be compatible with these drivers, socket-controller implementations must support the industry-standard ExCA base&nbsp;register set.</p>
<p>
Notice that some controllers do not fully implement the register set and therefore are incompatible. Also, some controllers implement extended registers or enhancements. The built-in Windows drivers do not exploit these features, even though the controller might be compatible.</p>
<p>
<b>4. System maintains mapping of IRQ Routing Register bits to system interrupt vectors</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
The system design must maintain the mapping of the PC Card controller’s IRQ Routing Register bits to system interrupt vectors. This means that when an interrupt is programmed in the controller to occur on the IRQ<i>x</i> pin, the system’s IRQ routing causes the interrupt controller to generate the interrupt vector for IRQ<i>x</i> and no other IRQ.</p>
<p>
<b>5. IRQ connections can be determined by using the 0805 register</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
Windows uses the 0805 register on both PC Card 16-only controllers and on CardBus controllers to determine which ISA IRQs are connected to the controller. This register must engage (that is, drive low) the corresponding ISA IRQ when programmed with a value. It must disengage the IRQ (that is, float high) when programmed at zero (0).</p>
<p>
<b>6. CardBus controllers support both ISA and PCI interrupts</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
PC Card software dynamically configures the bridge to use ISA interrupts for PC&nbsp;Card 16 cards and to use PCI interrupts for CardBus cards. As defined in the “IRQ connections can be determined by using the 0805 register” and “System maintains mapping of IRQ Routing Register bits to system interrupt vectors” requirements earlier in this section, CardBus controllers must maintain mapping of IRQ routing. Also, notice that systems implementing CardBus controllers must fully support PCI 2.1 as well as additional PCI requirements for IRQ routing as described in the “PCI” chapter in Part&nbsp;3 of this guide.</p>
<p>
<b>7. System supports industry-standard definition for CardBus bridges</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
If the system supports CardBus, it must support the definition in <i>PCI to PCMCIA CardBus Bridge Register Description</i> (Yenta specification) for CardBus controllers (PCI-to-CardBus bridges). This definition includes a common PCI Configuration Space header assigned the Header Type field value of 82h.</p>
<p>
Although this requirement is not yet incorporated into the PCI standard, Windows supports it. Any controller features that are not part of the Yenta specification will&nbsp;not be used in standard drivers. The BIOS is responsible for any hardware initialization or setup required to make the controller comply with the Yenta specification or other requirements listed in this chapter.</p>
<p>
Because CardBus host controllers are PCI bus bridges, they will be supported (enumerated and configured) by the PCI software in Windows in the same manner as other PCI bus bridges. For more information, see the “PCI” chapter in Part&nbsp;3 of this guide.</p>
<p>
<b>8. BIOS initializes CardBus controller in 82365-compatible mode and supports backward compatibility</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Recommended</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
CardBus controllers are enumerated and configured in Windows in the same way as other PCI bus bridges. The PCI bus bridge support in Windows&nbsp;98 is based on&nbsp;new requirements for PCI interrupt routing and bridge-window configuration. Because of this, full compliance with the latest PCI specifications is a requirement for CardBus support.</p>
<p>
There are steps the BIOS can take to achieve backward compatibility with Windows. Specifically, the BIOS can initialize the CardBus controller in Intel&nbsp;82365-compatible mode and report it as device “PNP0E03, Intel 82365-compatible CardBus controller.” The requirements are as follows for BIOS POST time (CardBus controller ConfigSpace initialization):
<ul>
<li>
Command register (that is, offset 0x04) set to 0x07 (that is, IOSpaceEnable, MemSpaceEnable, BusMasterEnable).<br><br></li>
<li>
RegisterBaseAddress (that is, offset 0x10) set to 0. If support for other environments is needed (such as Windows&nbsp;3.1 or MS-DOS®), some other value may be set.<br><br></li>
<li>
All memory and I/O windows (that is, offset 0x1c–0x38) set to 0.<br><br></li>
<li>
Interrupt Line register (that is, offset 0x3c) set to 0xff (no IRQ assigned). If support for other environments is needed (such as Windows 3.1 or MS-DOS), an assigned IRQ line can be set. Notice, however, that this register must be set&nbsp;to 0xff at the time that the device is disabled by the operating system, and then&nbsp;set into CardBus mode. More information about BIOS enumeration is presented later in this requirement.<br><br></li>
<li>
Other controller-specific initialization as required to put the controller in legacy mode.</li></ul>
<p>
This puts the CardBus controller into legacy mode where the Windows Socket Services driver can access it as an Intel PC&nbsp;Card I/O card–compatible (PCIC-compatible) controller at an I/O address (for example, 0x3e0).</p>
<p>
Notice that the BIOS must be at least PCI 2.1-compliant and must support the $PIR Interrupt Routing Table. The $PIR table must return the necessary PCI IRQ routing information, including the routing information for the CardBus controller. In general, if the CardBus controller is on the system board, there must be a slot routing entry for it in the table. If the CardBus controller is a PCI add-on card, there must be routing information entries for each PCI slot in the system.</p>
<p>
During Plug and Play BIOS enumeration, the BIOS should report the CardBus controller as *pnp0e03 with a compatible ID of *pnp0e00 and the I/O resource of&nbsp;two ports (for example, 0x3e0–0x3e1).</p>
<p>
For more information, see the white paper on CardBus host controllers and Windows compatibility at http://www.microsoft.com/hwdev/busbios/.</p>
<p>
<b>9. CardBus controllers do not share writable PCI Configuration Space bits</b>
</p>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
CardBus controllers are multifunction PCI devices, and Windows treats each function as an independent device. As such, there can be no sharing between functions of writable PCI Configuration Space bits (such as the Command register).</p>
<p>
Notice that the PC Card 16-bit interface legacy-mode BAR (offset 44h in the Type 2 PCI header) is the only exception to this requirement. This BAR must be&nbsp;shared between the two functions, since they must share the same BARs in order to be compatible with the ExCA programming model.</p>
<p>
<b>10. Each PC Card 16 memory window in CardBus controller has it own page&nbsp;register</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
For complete flexibility and support of typical configurations, CardBus controllers must support the independent location of R2 memory windows anywhere in the full system address space as recommended in the Yenta specification.</p>
<p>
Controllers that share a single page register among all PC Card 16 memory windows require that all PC Card 16 memory windows must be located within the&nbsp;same 16-MB block. Often, this is not possible with typical (16&nbsp;MB) DRAM and bridge (positive-decode) configurations. The result is disabled cards.</p>
</font></BODY>
</HTML>
