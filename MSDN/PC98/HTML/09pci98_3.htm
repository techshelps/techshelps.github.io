<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text-html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Plug and Play for PCI Controllers and Peripherals</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>
<BODY BGCOLOR=#FFFFFF TEXT=#000000>

<font face="verdana,arial,helvetica" size="2"><form name=x><object name=iv classid="clsid:9c2ac687-ceef-11cf-96d9-00a0c903b016">
</object></form>
<h1><a name="plugplayforpcicontrollersperipherals"></a>Plug and Play for PCI Controllers and Peripherals</h1>
<p>
This section summarizes the Plug and Play requirements for PCI devices.</p>
<p>
<b>10. Devices use PCI 2.1 Configuration Space register for Plug and Play device&nbsp;ID</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
The PCI 2.1 specification describes the Configuration Space register used by&nbsp;the&nbsp;system to identify and configure each device attached to the bus. The Configuration Space register is made up of a 256-byte field for each device and&nbsp;contains sufficient information for the system to identify the capabilities of&nbsp;the device. Configuration of the device is also controlled from this register.</p>
<p>
The Configuration Space register is made up of a header region and a device-dependent region. Each Configuration Space register must have a 64-byte header at offset&nbsp;0. All the device registers that the device circuit uses for initialization, configuration, and catastrophic error handling must fit in the space between byte&nbsp;64 and byte 255.</p>
<p>
All other registers that the device uses during normal operation must be located in&nbsp;normal I/O or memory space. Unimplemented registers or reads to reserved registers must complete normally and return zero (0). Writes to reserved registers must complete normally, and the data must be discarded.</p>
<p>
<b>11. Device IDs include PCI 2.1 Subsystem IDs</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
The following diagram shows the two registers added to the Configuration Space header for PCI 2.1. Although these registers are only recommended in PCI&nbsp;2.1, they are mandatory for PC 98. Support for these registers requires non-zero values to be populated for both the Subsystem ID and Subsystem Vendor&nbsp;ID.</p>
<p>
<b>New registers in Configuration Space header for PCI 2.1</h1>
<table border=1 cols=5 frame=box rules=all>
<tr valign=top>
<td width=118>31</td>
<td width=41>16</td>
<td width=111>15</td>
<td width=40>0</td>
<td width=72></td>
</tr>
<tr valign=top>
<td colspan=2 width=158>Subsystem ID</td>
<td colspan=2 width=151>Subsystem Vendor ID</td>
<td width=72>2Ch</td>
</tr>
</table><br>
<p>
These fields are necessary for the correct enumeration of a device. When the Subsystem ID fields are populated correctly for the adapter, Windows can differentiate between adapters based on the same PCI chip.</p>
<p>
The Subsystem ID also allows Windows to load system miniports for system-board devices. Thus, Subsystem IDs are also a requirement on system-board devices. The exceptions to this requirement are PCI-to-PCI bridges and core chip&nbsp;sets.</p>
<p>
Two methods can be used to implement a Subsystem Vendor ID:
<ul>
<li>
Load the value by hardware methods—for example, pin strappings at RST, an&nbsp;attached parallel or serial ROM, and so on.<br><br></li>
<li>
Program the Subsystem Vendor ID using BIOS. Two designs using the BIOS method meet PC&nbsp;98 requirements:<br><br></li>
<li>
Make a copy of the Subsystem Vendor ID in PCI user-defined space. Any&nbsp;writes to this location will change both the copy and the Subsystem Vendor ID field. Any writes to the Subsystem Vendor ID are discarded.<br><br></li>
<li>
Make a write-enable bit in the PCI user-defined space. The BIOS can turn this bit on, change the Subsystem Vendor ID, and then turn it off.</li>
</ul>
<p>
For more information, see the article titled “IDs and Serial Numbers for Plug and Play” on the web site at http://www.microsoft.com/hwdev/busbios/.</p>
<p>
<b>Important: </b>Multiple-monitor support allows display class devices to be initialized independently of the system initialization process. For this reason, system-board and add-on display devices cannot use the VGA BIOS POST routine to populate the Subsystem Vendor ID because the device’s POST code might not be executed until later in the process, after device enumeration occurs. For system-board devices, the system BIOS should populate the Subsystem Vendor ID at power on. Add-on display adapters should provide a method for populating the Subsystem Vendor ID at the point when power is applied and the device is initialized to the state that it is ready for POST.</p>
<p>
<b>12. Configuration Space is correctly populated</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
Windows places extra constraints on a few configuration registers and has uncovered some problem usage of other registers. Microsoft provides a program named Pci.exe to help debug the use of the Configuration Space. This program is available on the Microsoft FTP server, as described in the “PCI References” section at the end of this chapter.</p>
<p>
The following items are specific requirements for the Configuration Space:
<ul>
<li>
Populate the class code register (09h) for all devices.</li></ul><p>
Follow the base class, sub-class, and programming interface values outlined in&nbsp;PCI&nbsp;2.1.</P>
<ul><li>
Devices must not fill BARs with random values.</li></ul>
<p>
See PCI 2.1 for correct usage of these registers. Notice that BARs (10, 14, 18, 1C, 20, and 24h) should return zero if they are not used, indicating that no memory or I/O space is needed.</P>

<p>
Also, for performance reasons, it is recommended that run-time registers for PCI devices should not be placed in the Configuration Space.</p>
<p>
<b>13. Interrupt routing supported using ACPI</b></p>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
The system must provide interrupt routing information using a _PRT object, as defined in Section 6.2.3 of the <i>Advanced Configuration and Power Interface Specification, Revision 1.0</i> or higher.</p>
<p>
<b>14. BIOS does not configure I/O systems to share PCI interrupts</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Recommended</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
This applies to boot devices configured by the BIOS on systems based on Intel&nbsp;Architecture processors. The operating system should configure all other devices. For systems that will run the Windows operating system, OEMs should design the&nbsp;BIOS so that it does not configure the I/O systems in the PC to share PCI interrupts for boot devices. An exception exists for legacy audio devices following the configuration guidelines outlined in the white paper titled <i>Implementing Legacy Audio Devices on the PCI Bus</i>, available on the web site at&nbsp;http://www.intel.com/pc-supp/platform/ac97/wp/leg_pci.htm.</p>
<p>
Windows does not support sharing an IRQ between real-mode and protected-mode code within the I/O subsystem. An example of this is an NDIS 2.0 driver (real mode) and a SCSI miniport driver (protected mode) for two PCI devices that&nbsp;share the same IRQ. The problem is that the IRQ needs to be reflected to real&nbsp;mode for the NDIS 2.0 driver to work.</p>
<p>
However, if the IRQ is reflected to real mode, the real-mode SCSI driver (which usually is not called because Windows takes over in protected mode) might touch the hardware, which would cause the SCSI miniport to be confused. Windows resolves this problem either by switching everything to protected mode or by falling back to real mode.</p>
<p>
<b>15. BIOS configures boot device IRQ and writes to the interrupt line register</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
This requirement applies to boot devices configured by the BIOS on systems based on Intel Architecture processors. Windows should configure all other devices because, after an IRQ is assigned by the system BIOS, Windows cannot change the IRQ, even if necessary. If the BIOS assigns the IRQ and Windows needs it for another device, a sharing problem occurs.</p>
<p>
The BIOS must configure the boot device IRQ to a PCI-based IRQ and must write the IRQ into the interrupt line register 3Ch, even if the BIOS does not enable the device. This way, the operating system can still enable the device with the known IRQ at configuration time, if possible.</p>
<p>
<b>16. Hot swapping for any PCI device uses ACPI-based methods</h1>
<table border=1 cols=3 frame=void rules=rows>
<tr valign=top>
<td width=30%><b>Required</b></td>
<td width=30%></td>
<td width=30%></td>
</tr>
</table><br>
<p>
Windows&nbsp;98 and Windows NT 5.0 support dynamic enumeration, installation, and&nbsp;removal of PCI devices only if there is a supported hardware insert/remove notification mechanism.</p>
<p>
The appropriate notification mechanism is supported as a bus standard for CardBus bus controllers. For other solutions, such as those required for docking stations or other devices, the hardware insert/remove notification mechanism must&nbsp;be implemented as defined in Section 5.6.3 of the ACPI 1.0 specification. To&nbsp;properly function with the native support in the operating system, developing industry standards, such as those referred to as PCI Hot Plug and Compact PCI, must use ACPI-based methods for supporting hardware insertion and removal as defined in the ACPI 1.0 specification.</p>
</font></BODY>
</HTML>
