<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPDND.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context352"></a>SIMPDND.CPP</h2>
<pre><code>//********************************************************************** <br>// File name: Simple.cpp <br>// <br>//      Main source file for the Simple OLE 2.0 object container <br>// <br>// Functions: <br>// <br>//      WinMain         - Program entry point <br>//      MainWndProc     - Processes messages for the frame window <br>//      About           - Processes messages for the about dialog <br>//      DocWndProc      - Processes messages for the doc window <br>// <br>// Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#include "pre.h" <br>#include "iocs.h" <br>#include "ias.h" <br>#include "app.h" <br>#include "site.h" <br>#include "doc.h" <br> <br>// This line is needed for the debug utilities in OLESTD <br>extern "C" { <br>        OLEDBGDATA_MAIN("SIMPDND") <br>} <br> <br>CSimpleApp FAR * lpCSimpleApp; <br> <br>//********************************************************************** <br>// <br>// WinMain <br>// <br>// Purpose: <br>// <br>//      Program entry point <br>// <br>// Parameters: <br>// <br>//      HANDLE hInstance        - Instance handle for this instance <br>// <br>//      HANDLE hPrevInstance    - Instance handle for the last instance <br>// <br>//      LPSTR lpCmdLine         - Pointer to the command line <br>// <br>//      int nCmdShow            - Window State <br>// <br>// Return Value: <br>// <br>//      msg.wParam <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      CSimpleApp::CSimpleApp          APP.CPP <br>//      CSimpleApp::fInitApplication    APP.CPP <br>//      CSimpleApp::fInitInstance       APP.CPP <br>//      CSimpleApp::HandleAccelerators  APP.CPP <br>//      CSimpleApp::~CSimpleApp         APP.CPP <br>//      OleUIInitialize                 OLESTD <br>//      OleUIUninitialize               OLESTD <br>//      GetMessage                      Windows API <br>//      TranslateMessage                Windows API <br>//      DispatchMessage                 Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>int PASCAL WinMain(HINSTANCE hInstance,HINSTANCE hPrevInstance,LPSTR lpCmdLine,int nCmdShow) <br> <br>{ <br>        MSG msg; <br> <br>        // needed for LRPC to work properly... <br>        SetMessageQueue(96); <br> <br>        lpCSimpleApp = new CSimpleApp; <br> <br>        // we will add one ref count on our App. later when we want to destroy <br>        // the App object we will release this  ref count. when the App's ref <br>        // count goes to 0, it will be deleted. <br>        lpCSimpleApp-&gt;AddRef(); <br> <br>        // app initialization <br>        if (!hPrevInstance) <br>                if (!lpCSimpleApp-&gt;fInitApplication(hInstance)) <br>                        return (FALSE); <br> <br>        // instance initialization <br>        if (!lpCSimpleApp-&gt;fInitInstance(hInstance, nCmdShow)) <br>                return (FALSE); <br> <br>        /* Initialization required for OLE 2 UI library.  This call is <br>        **    needed ONLY if we are using the static link version of the UI <br>        **    library. If we are using the DLL version, we should NOT call <br>        **    this function in our application. <br>        */ <br>#if 0 <br>        if (!OleUIInitialize(hInstance, hPrevInstance)) <br>                { <br>                OleDbgOut("Could not initialize OLEUI library\n"); <br>                return FALSE; <br>                } <br>#endif <br>        // message loop <br>        while (GetMessage(&amp;msg, NULL, NULL, NULL)) <br>                if (!lpCSimpleApp-&gt;HandleAccelerators(&amp;msg)) <br>                        { <br>                        TranslateMessage(&amp;msg);    /* Translates virtual key codes */ <br>                        DispatchMessage(&amp;msg);     /* Dispatches message to window */ <br>                        } <br> <br>        // De-initialization for UI libraries.  Just like OleUIInitialize, this <br>        // funciton is needed ONLY if we are using the static link version of the <br>        // OLE UI library. <br>#if 0 <br>        OleUIUninitialize(); <br>#endif <br> <br>        // Release the ref count added on the App above. this will make <br>        // the App's ref count go to 0, and the App object will be deleted. <br>        lpCSimpleApp-&gt;Release(); <br> <br>        return (msg.wParam);          /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br>//********************************************************************** <br>// <br>// MainWndProc <br>// <br>// Purpose: <br>// <br>//      Processes messages for the frame window <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       - Window handle for frame window <br>// <br>//      UINT message    - Message value <br>// <br>//      WPARAM wParam   - Message info <br>// <br>//      LPARAM lParam   - Message info <br>// <br>// Return Value: <br>// <br>//      long <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      CSimpleApp::lCommandHandler     APP.CPP <br>//      CSimpleApp::DestroyDocs         APP.CPP <br>//      CSimpleApp::lCreateDoc          APP.CPP <br>//      CSimpleApp::lSizeHandler        APP.CPP <br>//      CSimpleDoc::lAddVerbs           DOC.CPP <br>//      PostQuitMessage                 Windows API <br>//      DefWindowProc                   Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>//@@WTK WIN32, UNICODE <br>//long FAR PASCAL _export MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>long FAR PASCAL EXPORT MainWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br> <br>{ <br> <br>        switch (message) <br>                { <br>                case WM_COMMAND:           // message: command from application menu <br>                        return lpCSimpleApp-&gt;lCommandHandler(hWnd, message, wParam, lParam); <br>                        break; <br> <br>                case WM_CREATE: <br>                        return lpCSimpleApp-&gt;lCreateDoc(hWnd, message, wParam, lParam); <br>                        break; <br> <br>                case WM_DESTROY:                  // message: window being destroyed <br>                        lpCSimpleApp-&gt;DestroyDocs();  // need to destroy the doc... <br>                        PostQuitMessage(0); <br>                        break; <br> <br>                case WM_INITMENUPOPUP: <br>                        // is this the edit menu? <br>                        if ( LOWORD(lParam) == 1) <br>                                return lpCSimpleApp-&gt;m_lpDoc-&gt;lAddVerbs(); <br> <br>                        break; <br> <br>                case WM_SIZE: <br>                        return lpCSimpleApp-&gt;lSizeHandler(hWnd, message, wParam, lParam); <br> <br>                default:                          // Passes it on if unproccessed <br>                        return (DefWindowProc(hWnd, message, wParam, lParam)); <br>                } <br>                return (NULL); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// About <br>// <br>// Purpose: <br>// <br>//      Processes dialog box messages <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       - Window handle for dialog box <br>// <br>//      UINT message    - Message value <br>// <br>//      WPARAM wParam   - Message info <br>// <br>//      LPARAM lParam   - Message info <br>// <br>// Return Value: <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      EndDialog                   Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>//@@WTK WIN32, UNICODE <br>//BOOL FAR PASCAL _export About(HWND hDlg,unsigned message,WORD wParam,LONG lParam) <br>BOOL FAR PASCAL EXPORT About(HWND hDlg,UINT message,WPARAM wParam,LPARAM lParam) <br> <br>{ <br>        switch (message) { <br>        case WM_INITDIALOG:                /* message: initialize dialog box */ <br>                return (TRUE); <br> <br>        case WM_COMMAND:                      /* message: received a command */ <br>                //@@WTK WIN32, UNICODE <br>                //if (wParam == IDOK                /* "OK" box selected?          */ <br>                if (LOWORD(wParam) == IDOK                /* "OK" box selected?          */ <br>                //@@WTK WIN32, UNICODE <br>                //|| wParam == IDCANCEL) {      /* System menu close command? */ <br>                || LOWORD(wParam) == IDCANCEL) {      /* System menu close command? */ <br>                EndDialog(hDlg, TRUE);        /* Exits the dialog box        */ <br>                return (TRUE); <br>                } <br>                break; <br>        } <br>        return (FALSE);                           /* Didn't process a message    */ <br>} <br> <br>//********************************************************************** <br>// <br>// DocWndProc <br>// <br>// Purpose: <br>// <br>//      Processes dialog box messages <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       - Window handle for doc window <br>// <br>//      UINT message    - Message value <br>// <br>//      WPARAM wParam   - Message info <br>// <br>//      LPARAM lParam   - Message info <br>// <br>// Return Value: <br>// <br>// Function Calls: <br>//      Function                            Location <br>// <br>//      CSimpleApp::PaintApp                APP.CPP <br>//      BeginPaint                          Windows API <br>//      EndPaint                            Windows API <br>//      DefWindowProc                       Windows API <br>//      IOleObject::QueryInterface          Object <br>//      IOleObject::DoVerb                  Object <br>//      CSimpleSite::GetObjRect             SITE.CPP <br>//      CSimpleDoc::QueryDrag               DOC.CPP <br>//      CSimpleDoc::DoDragDrop              DOC.CPP <br>//      SetTimer                            Windows API <br>//      KillTimer                           Windows API <br>//      SetCapture                          Windows API <br>//      ReleaseCapture                      Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>//@@WTK WIN32, UNICODE <br>//long FAR PASCAL _export DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>long FAR PASCAL EXPORT DocWndProc(HWND hWnd,UINT message,WPARAM wParam,LPARAM lParam) <br>{ <br>        HDC hDC; <br>        PAINTSTRUCT ps; <br> <br>        switch (message) { <br>                case WM_PAINT: <br> <br>                        hDC = BeginPaint(hWnd, &amp;ps); <br> <br>                        if (lpCSimpleApp) <br>                                lpCSimpleApp-&gt;PaintApp (hDC); <br> <br>                        EndPaint(hWnd, &amp;ps); <br>                        break; <br> <br>                case WM_LBUTTONDBLCLK: <br>                        { <br>                        POINT pt; <br> <br>                        pt.x = (int)(short)LOWORD (lParam ); <br>                        pt.y = (int)(short)HIWORD (lParam ); <br> <br>                        if (lpCSimpleApp-&gt;m_lpDoc-&gt;m_lpSite &amp;&amp; <br>                                lpCSimpleApp-&gt;m_lpDoc-&gt;m_lpSite-&gt;m_lpOleObject) <br>                                { <br>                                RECT rect; <br> <br>                                lpCSimpleApp-&gt;m_lpDoc-&gt;m_lpSite-&gt;GetObjRect(&amp;rect); <br> <br>                                if ( PtInRect(&amp;rect, pt) ) <br>                                        { <br>                                        // Execute object's default verb <br>                                        lpCSimpleApp-&gt;m_lpDoc-&gt;m_lpSite-&gt;m_lpOleObject-&gt;DoVerb( <br>                                                        OLEIVERB_PRIMARY, (LPMSG)&amp;message, <br>                                                        &amp;lpCSimpleApp-&gt;m_lpDoc-&gt;m_lpSite-&gt;m_OleClientSite, <br>                                                        -1, hWnd, &amp;rect); <br>                                        } <br>                                } <br>                        } <br>                        break; <br> <br>                case WM_LBUTTONDOWN: <br>                        { <br>                        POINT pt; <br> <br>                        pt.x = (int)(short)LOWORD (lParam ); <br>                        pt.y = (int)(short)HIWORD (lParam ); <br> <br>                        /* OLE2NOTE: check if this is a button down on the region <br>                        **    that is a handle to start a drag operation. for us, <br>                        **    this this is any where in the window. we <br>                        **    do NOT want to start a drag immediately; we want to <br>                        **    wait until the mouse moves a certain threshold. or a <br>                        **    certain amount of time has elapsed. if <br>                        **    LButtonUp comes before the drag is started, then <br>                        **    the fPendingDrag state is cleared. we must capture <br>                        **    the mouse to ensure the modal state is handled <br>                        **    properly. <br>                        */ <br>                        if (lpCSimpleApp-&gt;m_lpDoc-&gt;QueryDrag(pt) ) <br>                                { <br>                                lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag = TRUE; <br>                                lpCSimpleApp-&gt;m_lpDoc-&gt;m_ptButDown = pt; <br>                                SetTimer(hWnd, 1, lpCSimpleApp-&gt;m_nDragDelay, NULL); <br>                                SetCapture(hWnd); <br>                                } <br>                        break; <br>                        } <br> <br>                case WM_LBUTTONUP: <br> <br>                        if (lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag) <br>                                { <br>                                /* ButtonUP came BEFORE distance/time threshholds were <br>                                **    exceeded. clear fPendingDrag state. <br>                                */ <br>                                ReleaseCapture(); <br>                                KillTimer(hWnd, 1); <br>                                lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag = FALSE; <br>                                } <br>                        break; <br> <br>                case WM_MOUSEMOVE: <br>                        { <br>                        if (lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag) <br>                                { <br>                                int  x = (int)(short)LOWORD (lParam ); <br>                                int  y = (int)(short)HIWORD (lParam ); <br>                                POINT pt = lpCSimpleApp-&gt;m_lpDoc-&gt;m_ptButDown; <br>                                int nDragMinDist = lpCSimpleApp-&gt;m_nDragMinDist; <br> <br>                                if (! ( ((pt.x - nDragMinDist) &lt;= x) <br>                                                &amp;&amp; (x &lt;= (pt.x + nDragMinDist)) <br>                                                &amp;&amp; ((pt.y - nDragMinDist) &lt;= y) <br>                                                &amp;&amp; (y &lt;= (pt.y + nDragMinDist)) ) ) <br>                                        { <br>                                        // mouse moved beyond threshhold to start drag <br>                                        ReleaseCapture(); <br>                                        KillTimer(hWnd, 1); <br>                                        lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag = FALSE; <br> <br>                                        // perform the modal drag/drop operation. <br>                                        lpCSimpleApp-&gt;m_lpDoc-&gt;DoDragDrop( ); <br>                                        } <br>                                } <br>                        break; <br>                        } <br> <br>                case WM_TIMER: <br>                        { <br>                        // drag time delay threshhold exceeded -- start drag <br>                        ReleaseCapture(); <br>                        KillTimer(hWnd, 1); <br>                        lpCSimpleApp-&gt;m_lpDoc-&gt;m_fPendingDrag = FALSE; <br> <br>                        // perform the modal drag/drop operation. <br>                        lpCSimpleApp-&gt;m_lpDoc-&gt;DoDragDrop( ); <br>                        break; <br>                        } <br> <br>                default:                          /* Passes it on if unproccessed */ <br>                        return (DefWindowProc(hWnd, message, wParam, lParam)); <br>        } <br>        return (NULL); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
