<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SITE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context354"></a>SITE.CPP</h2>
<pre><code>//********************************************************************** <br>// File name: SITE.CPP <br>// <br>//      Implementation file for CSimpleSite <br>// <br>// Functions: <br>// <br>//      See SITE.H for class definition <br>// <br>// Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#include "pre.h" <br>#include "iocs.h" <br>#include "ias.h" <br>#include "app.h" <br>#include "site.h" <br>#include "doc.h" <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::Create <br>// <br>// Purpose: <br>// <br>//      Creation routine for CSimpleSite <br>// <br>// Parameters: <br>// <br>//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      IStorage::CreateStorage     OLE API <br>//      assert                      C Runtime <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>CSimpleSite FAR * CSimpleSite::Create(CSimpleDoc FAR *lpDoc) <br>{ <br>CSimpleSite FAR * lpTemp = new CSimpleSite(lpDoc); <br> <br>if (!lpTemp) <br>return NULL; <br> <br>// create a sub-storage for the object <br>//@@WTK WIN32, UNICODE <br>//HRESULT hErr = lpDoc-&gt;m_lpStorage-&gt;CreateStorage( "Object", <br>HRESULT hErr = lpDoc-&gt;m_lpStorage-&gt;CreateStorage( OLESTR("Object"), <br>STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE, <br>0, <br>0, <br>&amp;lpTemp-&gt;m_lpObjStorage); <br> <br>assert(hErr == NOERROR); <br> <br>if (hErr != NOERROR) <br>{ <br>delete lpTemp; <br>return NULL; <br>} <br> <br>// we will add one ref count on our Site. later when we want to destroy <br>// the Site object we will release this  ref count. when the Site's ref <br>// count goes to 0, it will be deleted. <br>lpTemp-&gt;AddRef(); <br> <br>return lpTemp; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::CSimpleSite <br>// <br>// Purpose: <br>// <br>//      Constructor for CSimpleSite <br>// <br>// Parameters: <br>// <br>//      CSimpleDoc FAR *lpDoc   - Pointer to CSimpleDoc <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>// Comments: <br>// <br>//******************************************************************** <br>#pragma warning(disable : 4355)  // turn off this warning.  This warning <br>// tells us that we are passing this in <br>// an initializer, before "this" is through <br>// initializing.  This is ok, because <br>// we just store the ptr in the other <br>// constructors <br> <br>CSimpleSite::CSimpleSite (CSimpleDoc FAR *lpDoc) : m_OleClientSite(this), <br> m_AdviseSink(this) <br>#pragma warning (default : 4355)  // Turn the warning back on <br>{ <br>// remember the pointer to the doc <br>m_lpDoc = lpDoc; <br> <br>// clear the reference count <br>m_nCount = 0; <br> <br>m_dwDrawAspect = DVASPECT_CONTENT; <br>m_lpOleObject = NULL; <br>m_fObjectOpen = FALSE; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::~CSimpleSite <br>// <br>// Purpose: <br>// <br>//      Destructor for CSimpleSite <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      OutputDebugString                       Windows API <br>//      IOleObject::Release                     Object <br>//      IStorage::Release                       OLE API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>CSimpleSite::~CSimpleSite () <br>{ <br>OutputDebugString ("In CSimpleSite's Destructor \r\n"); <br> <br>if (m_lpOleObject) <br>   m_lpOleObject-&gt;Release(); <br> <br>if (m_lpObjStorage) <br>   m_lpObjStorage-&gt;Release(); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::CloseOleObject <br>// <br>// Purpose: <br>// <br>//      Call IOleObject::Close on the object of the CSimpleSite <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      OutputDebugString                       Windows API <br>//      IOleObject::Close                       Object <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleSite::CloseOleObject (void) <br>{ <br>LPVIEWOBJECT lpViewObject = NULL; <br> <br>OutputDebugString ("In CSimpleSite::CloseOleObject \r\n"); <br> <br>if (m_lpOleObject) <br>   { <br>   m_lpOleObject-&gt;Close(OLECLOSE_NOSAVE); <br>   } <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::UnloadOleObject <br>// <br>// Purpose: <br>// <br>//      Close and release all pointers to the object of the CSimpleSite <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      OutputDebugString                       Windows API <br>//      CSimpleSite::CloseOleObject             SITE.CPP <br>//      IOleObject::QueryInterface              Object <br>//      IViewObject::SetAdvise                  Object <br>//      IViewObject::Release                    Object <br>//      IStorage::Release                       OLE API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleSite::UnloadOleObject (void) <br>{ <br>OutputDebugString ("In CSimpleSite::UnloadOleObject \r\n"); <br> <br>if (m_lpOleObject) <br>   { <br>   LPVIEWOBJECT lpViewObject; <br>   CloseOleObject();    // ensure object is closed; NOP if already closed <br> <br>   m_lpOleObject-&gt;QueryInterface(IID_IViewObject, (LPVOID FAR *)&amp;lpViewObject); <br> <br>   if (lpViewObject) <br>   { <br>   // Remove the view advise <br>   lpViewObject-&gt;SetAdvise(m_dwDrawAspect, 0, NULL); <br>   lpViewObject-&gt;Release(); <br>   } <br> <br>   m_lpOleObject-&gt;Release(); <br>   m_lpOleObject = NULL; <br>   } <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::QueryInterface <br>// <br>// Purpose: <br>// <br>//      Used for interface negotiation of the container Site. <br>// <br>// Parameters: <br>// <br>//      REFIID riid         -   A reference to the interface that is <br>//                              being queried. <br>// <br>//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to <br>//                              the interface. <br>// <br>// Return Value: <br>// <br>//      S_OK    -   The interface is supported. <br>//      S_FALSE -   The interface is not supported <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      IsEqualIID                  OLE API <br>//                   OLE API <br>//      CSimpleSite::AddRef          OBJ.CPP <br>//      COleClientSite::AddRef      IOCS.CPP <br>//      CAdviseSink::AddRef         IAS.CPP <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CSimpleSite::QueryInterface(REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>OutputDebugString("In CSimpleSite::QueryInterface\r\n"); <br> <br>*ppvObj = NULL;     // must set out pointer parameters to NULL <br> <br>if ( riid == IID_IUnknown) <br>{ <br>AddRef(); <br>*ppvObj = this; <br>return S_OK; <br>} <br> <br>if ( riid == IID_IOleClientSite) <br>{ <br>m_OleClientSite.AddRef(); <br>*ppvObj = &amp;m_OleClientSite; <br>return S_OK; <br>} <br> <br>if ( riid == IID_IAdviseSink) <br>{ <br>m_AdviseSink.AddRef(); <br>*ppvObj = &amp;m_AdviseSink; <br>return S_OK; <br>} <br> <br>// Not a supported interface <br>return E_NOINTERFACE; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::AddRef <br>// <br>// Purpose: <br>// <br>//      Increments the reference count of the container Site. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the site. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpleSite::AddRef() <br>{ <br>OutputDebugString("In CSimpleSite::AddRef\r\n"); <br> <br>return ++m_nCount; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::Release <br>// <br>// Purpose: <br>// <br>//      Decrements the reference count of the container Site <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the Site. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpleSite::Release() <br>{ <br>OutputDebugString("In CSimpleSite::Release\r\n"); <br> <br>if (--m_nCount == 0) { <br>delete this; <br>return 0; <br>} <br>return m_nCount; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::InitObject <br>// <br>// Purpose: <br>// <br>//      Used to initialize a newly create object (can't be done in the <br>//      constructor). <br>// <br>// Parameters: <br>// <br>//      BOOL fCreateNew -   TRUE if insert NEW object <br>//                          FALSE if create object FROM FILE <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      IOleObject::SetHostNames        Object <br>//      IOleObject::QueryInterface      Object <br>//      IViewObject2::GetExtent         Object <br>//      IOleObject::DoVerb              Object <br>//      IViewObject::SetAdvise          Object <br>//      IViewObject::Release            Object <br>//      GetClientRect                   Windows API <br>//      OleSetContainedObject           OLE API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleSite::InitObject(BOOL fCreateNew) <br>{ <br>LPVIEWOBJECT2 lpViewObject2; <br>RECT rect; <br> <br>// Set a View Advise <br>m_lpOleObject-&gt;QueryInterface(IID_IViewObject2,(LPVOID FAR *)&amp;lpViewObject2); <br>lpViewObject2-&gt;SetAdvise(m_dwDrawAspect, ADVF_PRIMEFIRST, &amp;m_AdviseSink); <br> <br>// get the initial size of the object <br>lpViewObject2-&gt;GetExtent(m_dwDrawAspect, -1 /*lindex*/, NULL /*ptd*/, &amp;m_sizel); <br>GetObjRect(&amp;rect);  // get the rectangle of the object in pixels <br>lpViewObject2-&gt;Release(); <br> <br>// give the object the name of the container app/document <br>//@@WTK WIN32, UNICODE <br>//m_lpOleObject-&gt;SetHostNames("Simple Application", "Simple OLE 2.0 Drag/Drop Container"); <br>m_lpOleObject-&gt;SetHostNames(OLESTR("Simple Application"), OLESTR("Simple OLE 2.0 Drag/Drop Container")); <br> <br>// inform object handler/DLL object that it is used in the embedding container's context <br>OleSetContainedObject(m_lpOleObject, TRUE); <br> <br>if (fCreateNew) { <br>   // force new object to save to guarantee valid object in our storage. <br>   // OLE 1.0 objects may close w/o saving. this is NOT necessary if the <br>   // object is created FROM FILE; its data in storage is already valid. <br>   m_OleClientSite.SaveObject(); <br> <br>   // we only want to DoVerb(SHOW) if this is an InsertNew object. <br>   // we should NOT DoVerb(SHOW) if the object is created FromFile. <br>   m_lpOleObject-&gt;DoVerb( <br>   OLEIVERB_SHOW, <br>   NULL, <br>   &amp;m_OleClientSite, <br>   -1, <br>   m_lpDoc-&gt;m_hDocWnd, <br>   &amp;rect); <br>} <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::PaintObj <br>// <br>// Purpose: <br>// <br>//      Paints the object <br>// <br>// Parameters: <br>// <br>//      HDC hDC     - Device context of the document window <br>// <br>// Return Value: <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      IOleObject::QueryInterface      Object <br>//      IViewObject::GetColorSet        Object <br>//      IViewObject::Release            Object <br>//      SetMapMode                      Windows API <br>//      LPtoDP                          Windows API <br>//      CreateHatchBrush                Windows API <br>//      SelectObject                    Windows API <br>//      DeleteObject                    Windows API <br>//      CreatePalette                   Windows API <br>//      SelectPalette                   Windows API <br>//      RealizePalette                  Windows API <br>//      OleStdFree                      OUTLUI Function <br>//      OleDraw                         OLE API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleSite::PaintObj(HDC hDC) <br>{ <br>RECT rect; <br> <br>// need to check to make sure there is a valid object <br>// available.  This is needed if there is a paint msg <br>// between the time that CSimpleSite is instantiated <br>// and OleUIInsertObject returns. <br>if (!m_lpOleObject) <br>return; <br> <br>// convert it to pixels <br>GetObjRect(&amp;rect); <br> <br>LPLOGPALETTE pColorSet = NULL; <br>LPVIEWOBJECT lpView = NULL; <br> <br>// get a pointer to IViewObject <br>m_lpOleObject-&gt;QueryInterface(IID_IViewObject,(LPVOID FAR *) &amp;lpView); <br> <br>// if the QI succeeds, get the LOGPALETTE for the object <br>if (lpView) <br>lpView-&gt;GetColorSet(m_dwDrawAspect, -1, NULL, NULL, NULL, &amp;pColorSet); <br> <br>HPALETTE hPal=NULL; <br>HPALETTE hOldPal=NULL; <br> <br>// if a LOGPALETTE was returned (not guarateed), create the palette and <br>// realize it.  NOTE: A smarter application would want to get the LOGPALETTE <br>// for each of its visible objects, and try to create a palette that <br>// satisfies all of the visible objects.  ALSO: OleStdFree() is use to <br>// free the returned LOGPALETTE. <br>if ((pColorSet)) <br>{ <br>hPal = CreatePalette((const LPLOGPALETTE) pColorSet); <br>hOldPal = SelectPalette(hDC, hPal, FALSE); <br>RealizePalette(hDC); <br>OleStdFree(pColorSet); <br>} <br> <br>// draw the object <br>OleDraw(m_lpOleObject, m_dwDrawAspect, hDC, &amp;rect); <br> <br>// if the object is open, draw a hatch rect. <br>if (m_fObjectOpen) <br>{ <br>HBRUSH hBrush = CreateHatchBrush ( HS_BDIAGONAL, RGB(0,0,0) ); <br>HBRUSH hOldBrush = (HBRUSH) SelectObject (hDC, hBrush); <br>SetROP2(hDC, R2_MASKPEN); <br>Rectangle (hDC, rect.left, rect.top, rect.right, rect.bottom); <br>SelectObject(hDC, hOldBrush); <br>DeleteObject(hBrush); <br>} <br> <br>// if we created a palette, restore the old one, and destroy <br>// the object. <br>if (hPal) <br>{ <br>SelectPalette(hDC,hOldPal,FALSE); <br>DeleteObject(hPal); <br>} <br> <br>// if a view pointer was successfully returned, it needs to be released. <br>if (lpView) <br>lpView-&gt;Release(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleSite::GetObjRect <br>// <br>// Purpose: <br>// <br>//      Retrieves the rect of the object in pixels <br>// <br>// Parameters: <br>// <br>//      LPRECT lpRect - Rect structure filled with object's rect in pixels <br>// <br>// Return Value: <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      XformWidthInHimetricToPixels    OUTLUI Function <br>//      XformHeightInHimetricToPixels   OUTLUI Function <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleSite::GetObjRect(LPRECT lpRect) <br>{ <br>// convert it to pixels <br>lpRect-&gt;left = lpRect-&gt;top = 0; <br>lpRect-&gt;right = XformWidthInHimetricToPixels(NULL,(int)m_sizel.cx); <br>lpRect-&gt;bottom = XformHeightInHimetricToPixels(NULL,(int)m_sizel.cy); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
