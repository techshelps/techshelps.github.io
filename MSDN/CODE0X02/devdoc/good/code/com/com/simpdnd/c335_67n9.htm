<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context345"></a>IDT.CPP</h2>
<pre><code>//********************************************************************** <br>// File name: IDT.CPP <br>// <br>//      Implementation file for CDropTarget <br>// <br>// Functions: <br>// <br>//      See IDT.H for class definition <br>// <br>// Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#include "pre.h" <br>#include "iocs.h" <br>#include "ias.h" <br>#include "app.h" <br>#include "site.h" <br>#include "doc.h" <br>#include "idt.h" <br> <br>extern CLIPFORMAT g_cfObjectDescriptor; <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::QueryDrop <br>// <br>// Purpose: <br>// <br>//      Check if the desired drop operation (identified by the given key <br>//      state) is possible at the current mouse position (pointl). <br>// <br>// Parameters: <br>// <br>//      DWORD grfKeyState       - current key state <br>//      POINTL pointl           - position of mouse <br>//      BOOL fDragScroll        - TRUE if drag scrolling cursor should <br>//                                be shown. <br>//      LPDWORD pdwEffect       - (OUT) drag effect that should occur <br>// <br>// Return Value: <br>// <br>//      BOOL                    - TRUE if drop could take place, <br>//                                else FALSE <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OleStdGetDropEffect         OLESTD API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>BOOL CDropTarget::QueryDrop ( <br>        DWORD           grfKeyState, <br>        POINTL          pointl, <br>        BOOL            fDragScroll, <br>        LPDWORD         pdwEffect <br>) <br>{ <br>        DWORD      dwScrollEffect = 0L; <br>        DWORD      dwOKEffects = *pdwEffect; <br> <br>        /* check if the cursor is in the active scroll area, if so need the <br>        **    special scroll cursor. <br>        */ <br>        if (fDragScroll) <br>                dwScrollEffect = DROPEFFECT_SCROLL; <br> <br>        /* if we have already determined that the source does NOT have any <br>        **    acceptable data for us, the return NO-DROP <br>        */ <br>        if (! m_fCanDropCopy &amp;&amp; ! m_fCanDropLink) <br>                goto dropeffect_none; <br> <br>        /* OLE2NOTE: determine what type of drop should be performed given <br>        **    the current modifier key state. we rely on the standard <br>        **    interpretation of the modifier keys: <br>        **          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src <br>        **          SHIFT       -- DROPEFFECT_MOVE <br>        **          CTRL        -- DROPEFFECT_COPY <br>        **          CTRL-SHIFT  -- DROPEFFECT_LINK <br>        */ <br> <br>        *pdwEffect = OleStdGetDropEffect(grfKeyState); <br>        if (*pdwEffect == 0) { <br>                // No modifier keys given. Try in order MOVE, COPY, LINK. <br>                if ((DROPEFFECT_MOVE &amp; dwOKEffects) &amp;&amp; m_fCanDropCopy) <br>                        *pdwEffect = DROPEFFECT_MOVE; <br>                else if ((DROPEFFECT_COPY &amp; dwOKEffects) &amp;&amp; m_fCanDropCopy) <br>                        *pdwEffect = DROPEFFECT_COPY; <br>                else if ((DROPEFFECT_LINK &amp; dwOKEffects) &amp;&amp; m_fCanDropLink) <br>                        *pdwEffect = DROPEFFECT_LINK; <br>                else <br>                        goto dropeffect_none; <br>        } else { <br>                /* OLE2NOTE: we should check if the drag source application allows <br>                **    the desired drop effect. <br>                */ <br>                if (!(*pdwEffect &amp; dwOKEffects)) <br>                        goto dropeffect_none; <br> <br>                if ((*pdwEffect == DROPEFFECT_COPY || *pdwEffect == DROPEFFECT_MOVE) <br>                                &amp;&amp; ! m_fCanDropCopy) <br>                        goto dropeffect_none; <br> <br>                if (*pdwEffect == DROPEFFECT_LINK &amp;&amp; ! m_fCanDropLink) <br>                        goto dropeffect_none; <br>        } <br> <br>        *pdwEffect |= dwScrollEffect; <br>        return TRUE; <br> <br>dropeffect_none: <br> <br>        *pdwEffect = DROPEFFECT_NONE; <br>        return FALSE; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::QueryDrop <br>// <br>// Purpose: <br>// <br>//     Check to see if Drag scroll operation should be initiated. <br>// <br>// Parameters: <br>// <br>//      POINTL pointl           - position of mouse <br>// <br>// Return Value: <br>// <br>//      BOOL                    - TRUE if scroll cursor should be given <br>//                                else FALSE <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      ScreenToClient              WINDOWS API <br>//      GetClientRect               WINDOWS API <br>// <br>// Comments: <br>//     A Drag scroll operation should be initiated when the mouse has <br>//     remained in the active scroll area (11 pixels frame around border <br>//     of window) for a specified amount of time (50ms). <br>// <br>//******************************************************************** <br> <br>BOOL CDropTarget::DoDragScroll (POINTL pointl) <br>{ <br>        DWORD dwScrollDir = SCROLLDIR_NULL; <br>        DWORD dwTime = GetCurrentTime(); <br>        int nScrollInset = m_pDoc-&gt;m_lpApp-&gt;m_nScrollInset; <br>        int nScrollDelay = m_pDoc-&gt;m_lpApp-&gt;m_nScrollDelay; <br>        int nScrollInterval = m_pDoc-&gt;m_lpApp-&gt;m_nScrollInterval; <br>        POINT point; <br>        RECT rect; <br> <br>        point.x = (int)pointl.x; <br>        point.y = (int)pointl.y; <br> <br>        ScreenToClient( m_pDoc-&gt;m_hDocWnd, &amp;point); <br>        GetClientRect ( m_pDoc-&gt;m_hDocWnd, (LPRECT) &amp;rect ); <br> <br>        if (rect.top &lt;= point.y &amp;&amp; point.y&lt;=(rect.top+nScrollInset)) <br>                dwScrollDir = SCROLLDIR_UP; <br>        else if ((rect.bottom-nScrollInset) &lt;= point.y &amp;&amp; point.y &lt;= rect.bottom) <br>                dwScrollDir = SCROLLDIR_DOWN; <br>        else if (rect.left &lt;= point.x &amp;&amp; point.x &lt;= (rect.left+nScrollInset)) <br>                dwScrollDir = SCROLLDIR_LEFT; <br>        else if ((rect.right-nScrollInset) &lt;= point.x &amp;&amp; point.x &lt;= rect.right) <br>                dwScrollDir = SCROLLDIR_RIGHT; <br> <br>        if (m_dwTimeEnterScrollArea) { <br> <br>                /* cursor was already in Scroll Area */ <br> <br>                if (! dwScrollDir) { <br>                        /* cusor moved OUT of scroll area. <br>                        **      clear "EnterScrollArea" time. <br>                        */ <br>                        m_dwTimeEnterScrollArea = 0L; <br>                        m_dwNextScrollTime = 0L; <br>                        m_dwLastScrollDir = SCROLLDIR_NULL; <br> <br>                } else if (dwScrollDir != m_dwLastScrollDir) { <br>                        /* cusor moved into a different direction scroll area. <br>                        **      reset "EnterScrollArea" time to start a new 50ms delay. <br>                        */ <br>                        m_dwTimeEnterScrollArea = dwTime; <br>                        m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay; <br>                        m_dwLastScrollDir = dwScrollDir; <br> <br>                } else if (dwTime &amp;&amp; dwTime &gt;= m_dwNextScrollTime) { <br>                        m_pDoc-&gt;Scroll ( dwScrollDir );    // Scroll document now <br>                        m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval; <br>                } <br>        } else { <br>                if (dwScrollDir) { <br>                        /* cusor moved INTO a scroll area. <br>                        **      reset "EnterScrollArea" time to start a new 50ms delay. <br>                        */ <br>                        m_dwTimeEnterScrollArea = dwTime; <br>                        m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay; <br>                        m_dwLastScrollDir = dwScrollDir; <br>                } <br>        } <br> <br>        return (dwScrollDir ? TRUE : FALSE); <br>} <br> <br> <br>// Support functions/macros <br>#define SetTopLeft(rc, pt)      \ <br>        ((rc)-&gt;top = (pt)-&gt;y,(rc)-&gt;left = (pt)-&gt;x) <br>#define SetBottomRight(rc, pt)      \ <br>        ((rc)-&gt;bottom = (pt)-&gt;y,(rc)-&gt;right = (pt)-&gt;x) <br>#define OffsetPoint(pt, dx, dy)     \ <br>        ((pt)-&gt;x += dx, (pt)-&gt;y += dy) <br> <br> <br>/* HighlightRect <br>** ------------- <br>**    Invert rectangle on screen. used for drop target feedback. <br>*/ <br> <br>static int HighlightRect(HWND hwnd, HDC hdc, LPRECT rc) <br>{ <br>        POINT pt1, pt2; <br>        int old = SetROP2(hdc, R2_NOT); <br>        HPEN hpen; <br>        HGDIOBJ hold; <br> <br>        pt1.x = rc-&gt;left; <br>        pt1.y = rc-&gt;top; <br>        pt2.x = rc-&gt;right; <br>        pt2.y = rc-&gt;bottom; <br> <br>        ScreenToClient(hwnd, &amp;pt1); <br>        ScreenToClient(hwnd, &amp;pt2); <br> <br>        hold = SelectObject(hdc, GetStockObject(HOLLOW_BRUSH)); <br>        hpen = (HPEN) SelectObject(hdc, CreatePen(PS_SOLID, 2, <br>                                                  GetSysColor(COLOR_ACTIVEBORDER))); <br> <br>        Rectangle(hdc, pt1.x, pt1.y, pt2.x, pt2.y); <br> <br>        SetROP2(hdc, old); <br> <br>        hold = SelectObject(hdc, hold); <br>        hpen = (HPEN) SelectObject(hdc, hpen); <br> <br>        DeleteObject(hpen); <br> <br>  return 0; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::InitDragFeedback <br>// <br>// Purpose: <br>// <br>//      Initialize data used to draw drop target feedback. <br>//      As feedback we draw a rectangle the size of the object. <br>// <br>// Parameters: <br>// <br>//      LPDATAOBJECT pDataObj   - IDataObject from Drop source <br>//      POINTL pointl           - position of mouse <br>// <br>// Return Value: <br>// <br>//      none. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      IDataObject::GetData        Object <br>//      XformSizeInHimetricToPixels OLESTD Library <br>//      GlobalLock                  WINDOWS API <br>//      GlobalUnlock                WINDOWS API <br>//      ReleaseStgMedium            OLE2 API <br>//      OffsetPoint                 IDT.CPP <br>//      SetTopLeft                  IDT.CPP <br>//      SetBottomRight              IDT.CPP <br>// <br>// Comments: <br>//      In order to known the size of the object before the object <br>//      is actually dropped, we render CF_OBJECTDESCRIPTOR format. <br>//      this data format tells us both the size of the object as <br>//      well as which aspect is the object is displayed as in the <br>//      source. if the object is currently displayed as DVASPECT_ICON <br>//      then we want to create the object also as DVASPECT_ICON. <br>// <br>//******************************************************************** <br> <br>void CDropTarget::InitDragFeedback(LPDATAOBJECT pDataObj, POINTL pointl) <br>{ <br>        FORMATETC fmtetc; <br>        STGMEDIUM stgmed; <br>        POINT pt; <br>        int height, width; <br>        HRESULT hrErr; <br> <br>        height = width = 100; // some default values <br>        pt.x = (int)pointl.x; <br>        pt.y = (int)pointl.y; <br> <br>        // do a GetData for CF_OBJECTDESCRIPTOR format to get the size of the <br>        // object as displayed in the source. using this size, initialize the <br>        // size for the drag feedback rectangle. <br>        fmtetc.cfFormat = g_cfObjectDescriptor; <br>        fmtetc.ptd = NULL; <br>        fmtetc.lindex = -1; <br>        fmtetc.dwAspect = DVASPECT_CONTENT; <br>        fmtetc.tymed = TYMED_HGLOBAL; <br> <br>        hrErr = pDataObj-&gt;GetData(&amp;fmtetc, &amp;stgmed); <br>        if (hrErr == NOERROR) { <br>                LPOBJECTDESCRIPTOR pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stgmed.hGlobal); <br>                if (pOD != NULL) { <br>                        XformSizeInHimetricToPixels(NULL, &amp;pOD-&gt;sizel, &amp;pOD-&gt;sizel); <br> <br>                        width = (int)pOD-&gt;sizel.cx; <br>                        height = (int)pOD-&gt;sizel.cy; <br>                        m_dwSrcAspect = pOD-&gt;dwDrawAspect; <br>                } <br> <br>                GlobalUnlock(stgmed.hGlobal); <br>                ReleaseStgMedium(&amp;stgmed); <br>        } <br> <br>        m_ptLast = pt; <br>        m_fDragFeedbackDrawn = FALSE; <br> <br>        OffsetPoint(&amp;pt, -(width/2), -(height/2)); <br>        SetTopLeft(&amp;m_rcDragRect, &amp;pt); <br> <br>        OffsetPoint(&amp;pt, width, height); <br>        SetBottomRight(&amp;m_rcDragRect, &amp;pt); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::UndrawDragFeedback <br>// <br>// Purpose: <br>// <br>//      Erase any drop target feedback. <br>//      As feedback we draw a rectangle the size of the object. <br>// <br>// Parameters: <br>// <br>//      none. <br>// <br>// Return Value: <br>// <br>//      none. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      GetDC                       WINDOWS API <br>//      ReleaseDC                   WINDOWS API <br>//      GlobalUnlock                WINDOWS API <br>//      HighlightRect               IDT.CPP <br>// <br>// Comments: <br>//      In order to known the size of the object before the object <br>//      is actually dropped, we render CF_OBJECTDESCRIPTOR format. <br>//      this data format tells us both the size of the object as <br>//      well as which aspect is the object is displayed as in the <br>//      source. if the object is currently displayed as DVASPECT_ICON <br>//      then we want to create the object also as DVASPECT_ICON. <br>// <br>//******************************************************************** <br> <br>void CDropTarget::UndrawDragFeedback( void ) <br>{ <br>        if (m_fDragFeedbackDrawn) { <br>                m_fDragFeedbackDrawn = FALSE; <br>                HDC hDC = GetDC(m_pDoc-&gt;m_hDocWnd); <br>                HighlightRect(m_pDoc-&gt;m_hDocWnd, hDC, &amp;m_rcDragRect); <br>                ReleaseDC(m_pDoc-&gt;m_hDocWnd, hDC); <br>        } <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::DrawDragFeedback <br>// <br>// Purpose: <br>// <br>//      Compute new position of drop target feedback rectangle and <br>//      erase old rectangle and draw new rectangle. <br>//      As feedback we draw a rectangle the size of the object. <br>// <br>// Parameters: <br>// <br>//      POINTL pointl           - position of mouse <br>// <br>// Return Value: <br>// <br>//      none. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OffsetPoint                 IDT.CPP <br>//      HighlightRect               IDT.CPP <br>//      GetDC                       WINDOWS API <br>//      ReleaseDC                   WINDOWS API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CDropTarget::DrawDragFeedback( POINTL pointl ) <br>{ <br>        POINT ptDiff; <br> <br>        ptDiff.x = (int)pointl.x - m_ptLast.x; <br>        ptDiff.y = (int)pointl.y - m_ptLast.y; <br> <br>        if (m_fDragFeedbackDrawn &amp;&amp; (ptDiff.x == 0 &amp;&amp; ptDiff.y == 0)) <br>                return;     // mouse did not move; leave rectangle as drawn <br> <br>        HDC hDC = GetDC(m_pDoc-&gt;m_hDocWnd); <br>        if (m_fDragFeedbackDrawn) { <br>                m_fDragFeedbackDrawn = FALSE; <br>                HighlightRect(m_pDoc-&gt;m_hDocWnd, hDC, &amp;m_rcDragRect); <br>        } <br> <br>        OffsetRect(&amp;m_rcDragRect, ptDiff.x, ptDiff.y); <br>        HighlightRect(m_pDoc-&gt;m_hDocWnd, hDC, &amp;m_rcDragRect); <br>        m_fDragFeedbackDrawn = TRUE; <br>        m_ptLast.x = (int)pointl.x; <br>        m_ptLast.y = (int)pointl.y; <br>        ReleaseDC(m_pDoc-&gt;m_hDocWnd, hDC); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::QueryInterface <br>// <br>// Purpose: <br>// <br>//      Return a pointer to a requested interface <br>// <br>// Parameters: <br>// <br>//      REFIID riid         -   ID of interface to be returned <br>//      LPVOID FAR* ppvObj  -   Location to return the interface <br>// <br>// Return Value: <br>// <br>//      S_OK                -   Interface supported <br>//      E_NOINTERFACE       -   Interface NOT supported <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      CSimpleDoc::QueryInterface  DOC.CPP <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CDropTarget::QueryInterface(REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>        OutputDebugString("In IDT::QueryInterface\r\n"); <br> <br>        // delegate to the document <br>        return m_pDoc-&gt;QueryInterface(riid, ppvObj); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::AddRef <br>// <br>// Purpose: <br>// <br>//      Increments the reference count on this interface <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      The current reference count on this interface. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      CSimpleDoc::AddReff         DOC.CPP <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//      This function adds one to the ref count of the interface, <br>//      and calls then calls CSimpleObj to increment its ref. <br>//      count. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CDropTarget::AddRef() <br>{ <br>        OutputDebugString("In IDT::AddRef\r\n"); <br> <br>        // increment the interface reference count (for debugging only) <br>        ++m_nCount; <br> <br>        // delegate to the document Object <br>        return m_pDoc-&gt;AddRef(); <br>} <br> <br>//********************************************************************** <br>// <br>// CDropTarget::Release <br>// <br>// Purpose: <br>// <br>//      Decrements the reference count on this interface <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      The current reference count on this interface. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      CSimpleDoc::Release         DOC.CPP <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//      This function subtracts one from the ref count of the interface, <br>//      and calls then calls CSimpleDoc to decrement its ref. <br>//      count. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CDropTarget::Release() <br>{ <br>        OutputDebugString("In IDT::Release\r\n"); <br> <br>        // decrement the interface reference count (for debugging only) <br>        --m_nCount; <br> <br>        // delegate to the document object <br>        return m_pDoc-&gt;Release(); <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::DragEnter <br>// <br>// Purpose: <br>// <br>//      Called when the mouse first enters our DropTarget window <br>// <br>// Parameters: <br>// <br>//      LPDATAOBJECT pDataObj   - IDataObject from Drop source <br>//      DWORD grfKeyState       - current key state <br>//      POINTL pointl           - position of mouse <br>//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur <br>//                                ON INPUT, this is dwOKEffects that source <br>//                                passed to DoDragDrop API. <br>//                                ON OUTPUT, this is the effect that we <br>//                                want to take effect (used to determine <br>//                                cursor feedback). <br>// <br>// Return Value: <br>// <br>//      S_OK <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      OleQueryCreateFromData      OLE2 API <br>//      DoDragScroll                IDT.CPP <br>//      QueryDrop                   IDT.CPP <br>//      InitDragFeedback            IDT.CPP <br>//      DrawDragFeedback            IDT.CPP <br>//      UndrawDragFeedback          IDT.CPP <br>// <br>// Comments: <br>//      Callee should honor the dwEffects as passed in to determine <br>//      if the caller allows DROPEFFECT_MOVE. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CDropTarget::DragEnter (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect) <br>{ <br>        OutputDebugString("In IDT::DragEnter\r\n"); <br> <br>        /* Determine if the drag source data object offers a data format <br>        **  that we understand. we accept only creating embedded objects. <br>        */ <br>        m_fCanDropCopy = ((OleQueryCreateFromData(pDataObj) == NOERROR) ? <br>                        TRUE : FALSE); <br>        m_fCanDropLink = FALSE; // linking NOT supported in this simple sample <br> <br>        if (m_fCanDropCopy || m_fCanDropLink) <br>                InitDragFeedback(pDataObj, pointl); <br> <br>        BOOL fDragScroll = DoDragScroll ( pointl ); <br> <br>        if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect)) <br>                DrawDragFeedback( pointl ); <br> <br>        return NOERROR; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::DragOver <br>// <br>// Purpose: <br>// <br>//      Called when the mouse moves, key state changes, or a time <br>//      interval passes while the mouse is still within our DropTarget <br>//      window. <br>// <br>// Parameters: <br>// <br>//      DWORD grfKeyState       - current key state <br>//      POINTL pointl           - position of mouse <br>//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur <br>//                                ON INPUT, this is dwOKEffects that source <br>//                                passed to DoDragDrop API. <br>//                                ON OUTPUT, this is the effect that we <br>//                                want to take effect (used to determine <br>//                                cursor feedback). <br>// <br>// Return Value: <br>// <br>//      S_OK <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      DoDragScroll                IDT.CPP <br>//      QueryDrop                   IDT.CPP <br>//      DrawDragFeedback            IDT.CPP <br>//      UndrawDragFeedback          IDT.CPP <br>// <br>// Comments: <br>//      Callee should honor the dwEffects as passed in to determine <br>//      if the caller allows DROPEFFECT_MOVE. OLE pulses the DragOver <br>//      calls in order that the DropTarget can implement drag scrolling <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CDropTarget::DragOver  (DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect) <br>{ <br>        OutputDebugString("In IDT::DragOver\r\n"); <br> <br>        BOOL fDragScroll = DoDragScroll ( pointl ); <br> <br>        if (QueryDrop(grfKeyState,pointl,fDragScroll,pdwEffect)) <br>                DrawDragFeedback( pointl ); <br>        else <br>                UndrawDragFeedback(); <br> <br>        return NOERROR; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::DragLeave <br>// <br>// Purpose: <br>// <br>//      Called when the mouse leaves our DropTarget window <br>// <br>// Parameters: <br>// <br>//      none. <br>// <br>// Return Value: <br>// <br>//      S_OK <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      UndrawDragFeedback          IDT.CPP <br>//                   OLE2 API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CDropTarget::DragLeave () <br>{ <br>        OutputDebugString("In IDT::DragLeave\r\n"); <br> <br>        UndrawDragFeedback(); <br> <br>        return S_OK; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CDropTarget::Drop <br>// <br>// Purpose: <br>// <br>//      Called when a Drop operation should take place. <br>// <br>// Parameters: <br>// <br>//      LPDATAOBJECT pDataObj   - IDataObject from Drop source <br>//      DWORD grfKeyState       - current key state <br>//      POINTL pointl           - position of mouse <br>//      LPDWORD pdwEffect       - (IN-OUT) drag effect that should occur <br>//                                ON INPUT, this is dwOKEffects that source <br>//                                passed to DoDragDrop API. <br>//                                ON OUTPUT, this is the effect that we <br>//                                want to take effect (used to determine <br>//                                cursor feedback). <br>// <br>// Return Value: <br>// <br>//      S_OK <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      CSimpleSite::Create         SITE.CPP <br>//      CSimpleSite::InitObject     SITE.CPP <br>//      OleCreateFromData           OLE2 API <br>//      DoDragScroll                IDT.CPP <br>//      QueryDrop                   IDT.CPP <br>//      InitDragFeedback            IDT.CPP <br>//      DrawDragFeedback            IDT.CPP <br>//      UndrawDragFeedback          IDT.CPP <br>//                          OLE2 API <br>//                   OLE2 API <br>// <br>// Comments: <br>//      Callee should honor the dwEffects as passed in to determine <br>//      if the caller allows DROPEFFECT_MOVE. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CDropTarget::Drop (LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pointl, LPDWORD pdwEffect) <br>{ <br>        FORMATETC fmtetc; <br>        SCODE sc = S_OK; <br> <br>        OutputDebugString("In IDT::Drop\r\n"); <br> <br>        UndrawDragFeedback(); <br> <br>        if (pDataObj &amp;&amp; QueryDrop(grfKeyState,pointl,FALSE,pdwEffect)) <br>                { <br>                m_pDoc-&gt;m_lpSite = CSimpleSite::Create(m_pDoc); <br>                // keep same aspect as drop source <br>                m_pDoc-&gt;m_lpSite-&gt;m_dwDrawAspect = m_dwSrcAspect; <br> <br>                // in order to specify a particular drawing Aspect we must <br>                // pass a FORMATETC* to OleCreateFromData <br>                fmtetc.cfFormat = NULL;             // use whatever for drawing <br>                fmtetc.ptd = NULL; <br>                fmtetc.lindex = -1; <br>                fmtetc.dwAspect = m_dwSrcAspect;    // desired drawing aspect <br>                fmtetc.tymed = TYMED_NULL; <br> <br>                HRESULT hrErr = OleCreateFromData ( <br>                                                        pDataObj, <br>                                                        IID_IOleObject, <br>                                                        OLERENDER_DRAW, <br>                                                        &amp;fmtetc, <br>                                                        &amp;m_pDoc-&gt;m_lpSite-&gt;m_OleClientSite, <br>                                                        m_pDoc-&gt;m_lpSite-&gt;m_lpObjStorage, <br>                                                        (LPVOID FAR *)&amp;m_pDoc-&gt;m_lpSite-&gt;m_lpOleObject); <br> <br>                if (hrErr == NOERROR) <br>                        { <br>                        m_pDoc-&gt;m_lpSite-&gt;InitObject(FALSE /* fCreateNew */); <br>                        m_pDoc-&gt;DisableInsertObject(); <br>                        } <br>                else <br>                        sc = hrErr; <br>                } <br> <br>        return sc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
