<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context374"></a>OBJ.CPP</h2>
<pre><code>//********************************************************************** <br>// File name: obj.cpp <br>// <br>//    Implementation file for the CSimpSvrApp Class <br>// <br>// Functions: <br>// <br>//    See obj.h for a list of member functions. <br>// <br>// Copyright 1993 - 1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#include "pre.h" <br>#include "obj.h" <br>#include "ioo.h" <br>#include "ido.h" <br>#include "ips.h" <br>#include "icf.h" <br>#include "ioipao.h" <br>#include "ioipo.h" <br>#include "app.h" <br>#include "doc.h" <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::QueryInterface <br>// <br>// Purpose: <br>// <br>//      Used for interface negotiation at the "Object" level. <br>// <br>// Parameters: <br>// <br>//      REFIID riid         -   A reference to the interface that is <br>//                              being queried. <br>// <br>//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to <br>//                              the interface. <br>// <br>// Return Value: <br>// <br>//      S_OK          -   The interface is supported. <br>//      E_NOINTERFACE -   The interface is not supported <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//                   OLE API <br>//      IUnknown::AddRef            OBJ.CPP, IOO.CPP, IDO.CPP, IPS.CPP <br>//                                  IOIPO.CPP, IOIPAO.CPP <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CSimpSvrObj::QueryInterface ( REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>        OutputDebugString("In CSimpSvrObj::QueryInterface\r\n"); <br> <br>        SCODE sc = S_OK; <br> <br>        if (riid == IID_IUnknown) <br>                *ppvObj = this; <br>        else if (riid == IID_IOleObject) <br>                *ppvObj = &amp;m_OleObject; <br>        else if (riid == IID_IDataObject) <br>                *ppvObj = &amp;m_DataObject; <br>        else if ( (riid == IID_IPersistStorage) || (riid == IID_IPersist) ) <br>                *ppvObj = &amp;m_PersistStorage; <br>        else if (riid == IID_IOleInPlaceObject) <br>                *ppvObj = &amp;m_OleInPlaceObject; <br>        else if (riid == IID_IOleInPlaceActiveObject) <br>                *ppvObj = &amp;m_OleInPlaceActiveObject; <br>        else if (riid == IID_IExternalConnection) <br>                 *ppvObj = &amp;m_ExternalConnection; <br>        else <br>                { <br>                *ppvObj = NULL; <br>                sc = E_NOINTERFACE; <br>                } <br> <br>        if (*ppvObj) <br>                ((LPUNKNOWN)*ppvObj)-&gt;AddRef(); <br> <br>        return  sc ; <br>}; <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::AddRef <br>// <br>// Purpose: <br>// <br>//      Adds to the reference count at the Object level. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the Object. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//      Due to the reference counting model that is used in this <br>//      implementation, this reference count is the sum of the <br>//      reference counts on all interfaces <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpSvrObj::AddRef () <br>{ <br>        OutputDebugString("In CSimpSvrObj::AddRef\r\n"); <br> <br>        m_lpDoc-&gt;AddRef(); <br> <br>        return ++m_nCount; <br>}; <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::Release <br>// <br>// Purpose: <br>// <br>//      Decrements the reference count at this level <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the object. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//      Due to the reference counting model that is used in this <br>//      implementation, this reference count is the sum of the <br>//      reference counts on all interfaces <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpSvrObj::Release () <br>{ <br>        OutputDebugString("In CSimpSvrObj::Release\r\n"); <br> <br>        m_lpDoc-&gt;Release(); <br> <br>        if (--m_nCount == 0) { <br>                delete this; <br>        return 0; <br>    } <br> <br>        return m_nCount; <br>}; <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::CSimpSvrObj <br>// <br>// Purpose: <br>// <br>//      Constructor for CSimpSvrObj <br>// <br>// Parameters: <br>// <br>//      CSimpSvrDoc FAR * lpSimpSvrDoc - ptr to the doc object <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br>#pragma warning (disable : 4355) // "this" used in base initializer list warning.  This <br>                                                                 // can be disabled because we are not using "this" in <br>                                                                 // the constructor for these objects, rather we are <br>                                                                 // just storing it for future use... <br>CSimpSvrObj::CSimpSvrObj(CSimpSvrDoc FAR * lpSimpSvrDoc) : m_OleObject(this), <br>                                                                                                                   m_DataObject(this), <br>                                                                                                                   m_PersistStorage(this), <br>                                                                                                                   m_OleInPlaceActiveObject(this), <br>                                                                                                                   m_OleInPlaceObject(this), <br>                                                                                                                   m_ExternalConnection(this) <br>#pragma warning (default : 4355) // Turn the warning back on <br> <br>{ <br>        m_lpDoc = lpSimpSvrDoc; <br>        m_nCount = 0; <br>        m_fInPlaceActive = FALSE; <br>        m_fInPlaceVisible = FALSE; <br>        m_fUIActive = FALSE; <br>        m_hmenuShared = NULL; <br>        m_hOleMenu = NULL; <br> <br>        m_dwRegister = 0; <br> <br>        m_lpFrame = NULL; <br>        m_lpCntrDoc = NULL; <br> <br>        m_lpStorage = NULL; <br>        m_lpColorStm = NULL; <br>        m_lpSizeStm = NULL; <br>        m_lpOleClientSite = NULL; <br>        m_lpOleAdviseHolder = NULL; <br>        m_lpDataAdviseHolder = NULL; <br>        m_lpIPSite = NULL; <br> <br>        m_red = 128; <br>        m_green = 0; <br>        m_blue = 0; <br> <br>        m_size.x = 100; <br>        m_size.y = 100; <br> <br>        m_xOffset = 0; <br>        m_yOffset = 0; <br> <br>        m_scale = (float) 1.0; <br> <br>        m_fSaveWithSameAsLoad = FALSE; <br>        m_fNoScribbleMode = FALSE; <br> <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::~CSimpSvrObj <br>// <br>// Purpose: <br>// <br>//      Destructor for CSimpSvrObj <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>// <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      PostMessage                 Windows API <br>//      CSimpSvrDoc::GetApp         DOC.H <br>//      CSimpSvrDoc::GethAppWnd     DOC.H <br>//      CSimpSvrDoc::ClearObj       DOC.H <br>//      CSimpSvrApp::IsStartedByOle APP.CPP <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>CSimpSvrObj::~CSimpSvrObj() <br>{ <br>        OutputDebugString("In CSimpSvrObj's Destructor \r\n"); <br> <br>        // if we were started by ole, post ourselves a close message <br>        if (m_lpDoc-&gt;GetApp()-&gt;IsStartedByOle()) <br>                PostMessage(m_lpDoc-&gt;GethAppWnd(), WM_SYSCOMMAND, SC_CLOSE, 0L); <br> <br>        // clear the OBJ ptr in the doc class <br>        m_lpDoc-&gt;ClearObj(); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::Draw <br>// <br>// Purpose: <br>// <br>//      Draws the object into an arbitrary DC <br>// <br>// Parameters: <br>// <br>//      HDC hDC - DC to draw into <br>// <br>// Return Value: <br>// <br>//      NONE <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      CreateBrushIndirect         Windows API <br>//      SelectObject                Windows API <br>//      Rectangle                   Windows API <br>//      DeleteObject                Windows API <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::Draw (HDC hDC, BOOL m_fMeta) <br>{ <br>        LOGBRUSH lb; <br> <br>        OutputDebugString("In CSimpSvrObj::Draw\r\n"); <br> <br>        char szBuffer[255]; <br>        wsprintf(szBuffer,"Drawing Scale %3d\r\n",m_scale); <br>        OutputDebugString(szBuffer); <br> <br>        if (!m_fMeta) <br>                { <br>                SetMapMode(hDC, MM_ANISOTROPIC); <br>                //@@WTK WIN32, UNICODE <br>                //SetWindowOrg(hDC, (int)(m_xOffset/m_scale), (int)(m_yOffset/m_scale)); <br>                SetWindowOrgEx(hDC, (int)(m_xOffset/m_scale), <br>                        (int)(m_yOffset/m_scale), NULL); <br>                //@@WTK WIN32, UNICODE <br>                //SetWindowExt(hDC, m_size.x, m_size.y); <br>                SetWindowExtEx(hDC, m_size.x, m_size.y, NULL); <br>                //@@WTK WIN32, UNICODE <br>                //SetViewportExt(hDC, (int)(m_size.x*m_scale), (int)(m_size.y*m_scale)); <br>                SetViewportExtEx(hDC, (int)(m_size.x*m_scale), <br>                        (int)(m_size.y*m_scale), NULL); <br>                } <br> <br>        // fill out a LOGBRUSH <br>        lb.lbStyle = BS_SOLID; <br>        lb.lbColor = RGB(m_red, m_green, m_blue); <br>        lb.lbHatch = 0; <br> <br>        // create the brush <br>        HBRUSH hBrush = CreateBrushIndirect(&amp;lb); <br> <br>        // select the brush <br>        HBRUSH hOldBrush = (HBRUSH) SelectObject(hDC, hBrush); <br>        HPEN hPen = CreatePen(PS_INSIDEFRAME, 6, RGB(0, 0, 0)); <br> <br>        HPEN hOldPen = (HPEN) SelectObject(hDC, hPen); <br> <br>        // draw the rectangle <br>        Rectangle (hDC, 0, 0, m_size.x, m_size.y); <br> <br>        // restore the pen <br>        hPen = (HPEN) SelectObject(hDC, hOldPen); <br> <br>        // free the pen <br>        DeleteObject(hPen); <br> <br>        // restore the old brush <br>        hBrush = (HBRUSH) SelectObject(hDC, hOldBrush); <br> <br>        // free the brush <br>        DeleteObject(hBrush); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::GetMetaFilePict <br>// <br>// Purpose: <br>// <br>//      Returns a handle to a metafile representation of the object. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      Handle to the metafile. <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      OutputDebugString               Windows API <br>//      GlobalAlloc                     Windows API <br>//      GlobalLock                      Windows API <br>//      SetWindowOrg                    Windows API <br>//      SetWindowExt                    Windows API <br>//      CreateMetaFile                  Windows API <br>//      CloseMetaFile                   Windows API <br>//      GlobalUnlock                    Windows API <br>//      XformWidthInPixelsToHimetric    OLESTD <br>//      XformHeightInPixelsToHimetric   OLESTD <br>//      CSimpSvrObj::Draw               OBJ.CPP <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>HANDLE CSimpSvrObj::GetMetaFilePict() <br>{ <br>        HANDLE hMFP; <br>        METAFILEPICT FAR * lpMFP; <br>        POINT pt; <br> <br>        OutputDebugString("In CSimpSvrObj::GetMetaFilePict\r\n"); <br> <br>        // allocate the memory for the METAFILEPICT structure <br>        hMFP = GlobalAlloc (GMEM_SHARE | GHND, sizeof (METAFILEPICT) ); <br>        lpMFP = (METAFILEPICT FAR*) GlobalLock(hMFP); <br> <br>        // get the size of the object in HIMETRIC <br>        pt.x = XformWidthInPixelsToHimetric(NULL, m_size.x); <br>        pt.y = XformHeightInPixelsToHimetric(NULL, m_size.y); <br> <br>        // fill out the METAFILEPICT structure <br>        lpMFP-&gt;mm = MM_ANISOTROPIC; <br>        lpMFP-&gt;xExt = pt.x; <br>        lpMFP-&gt;yExt = pt.y; <br> <br>        // Create the metafile <br>        HDC hDC = CreateMetaFile(NULL); <br> <br>        //@@WTK WIN32, UNICODE <br>        //SetWindowOrg (hDC, 0, 0); <br>        SetWindowOrgEx (hDC, 0, 0, NULL); <br>        //@@WTK WIN32, UNICODE <br>        //SetWindowExt (hDC, m_size.x, <br>        SetWindowExtEx (hDC, m_size.x, <br>                                           m_size.y, NULL); <br> <br>        Draw(hDC); <br> <br>        lpMFP-&gt;hMF = CloseMetaFile(hDC); <br> <br>        // unlock the metafilepict <br>        GlobalUnlock(hMFP); <br> <br>        return hMFP; <br>} <br> <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::SaveToStorage <br>// <br>// Purpose: <br>// <br>//      Saves the object to the passed storage <br>// <br>// Parameters: <br>// <br>//      LPSTORAGE lpStg - Storage in which to save the object <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      IStorage::CreateStream      OLE <br>//      IStream::Write              OLE <br>//      IStream::Release            OLE <br>// <br>// Comments: <br>// <br>//      A real app will want to do better error checking / returning <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::SaveToStorage (LPSTORAGE lpStg, BOOL fSameAsLoad) <br>{ <br>        OutputDebugString("In CSimpSvrObj::SaveToStorage\r\n"); <br> <br>        LPSTREAM lpTempColor, lpTempSize; <br> <br>        if (!fSameAsLoad) <br>                m_PersistStorage.CreateStreams( lpStg, &amp;lpTempColor, &amp;lpTempSize); <br>        else <br>                { <br>                lpTempColor = m_lpColorStm; <br>                lpTempColor-&gt;AddRef(); <br>                lpTempSize = m_lpSizeStm; <br>                lpTempSize-&gt;AddRef(); <br>                } <br> <br>        ULARGE_INTEGER uli; <br> <br>        uli.LowPart = 0; <br>        uli.HighPart = 0; <br> <br>        lpTempColor-&gt;SetSize(uli); <br>        lpTempSize-&gt;SetSize(uli); <br> <br>        LARGE_INTEGER li; <br> <br>        li.LowPart = 0; <br>        li.HighPart = 0; <br> <br>        lpTempColor-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br>        lpTempSize-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br> <br>        // write the colors to the stream <br>        lpTempColor-&gt;Write(&amp;m_red, sizeof(m_red), NULL); <br>        lpTempColor-&gt;Write(&amp;m_green, sizeof(m_green), NULL); <br>        lpTempColor-&gt;Write(&amp;m_blue, sizeof(m_blue), NULL); <br> <br>        // write the size to the stream <br>        lpTempSize-&gt;Write(&amp;m_size, sizeof(m_size), NULL); <br> <br>        lpTempColor-&gt;Release(); <br>        lpTempSize-&gt;Release(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::LoadFromStorage <br>// <br>// Purpose: <br>// <br>//      Loads the object from the passed storage <br>// <br>// Parameters: <br>// <br>//      LPSTORAGE lpStg     - Storage in which to load the object from <br>// <br>// Return Value: <br>// <br>//      None. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      IStorage::OpenStream        OLE <br>//      IStream::Read               OLE <br>//      IStream::Release            OLE <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::LoadFromStorage () <br>{ <br>        OutputDebugString("In CSimpSvrObj::LoadFromStorage\r\n"); <br> <br>        // Read the colors <br>        m_lpColorStm-&gt;Read(&amp;m_red, sizeof(m_red), NULL); <br>        m_lpColorStm-&gt;Read(&amp;m_green, sizeof(m_green), NULL); <br>        m_lpColorStm-&gt;Read(&amp;m_blue, sizeof(m_blue), NULL); <br> <br>        // read the size <br>        m_lpSizeStm-&gt;Read(&amp;m_size, sizeof(m_size), NULL); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::DoInPlaceActivate <br>// <br>// Purpose: <br>// <br>//      Does the inplace activation for the object <br>// <br>// Parameters: <br>// <br>//      LONG lVerb  - Verb that caused this function to be called <br>// <br>// Return Value: <br>// <br>//      TRUE/FALSE depending on success or failure. <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      IOleClientSite::QueryInterface          Container <br>//      IOleClientSite::ShowObject              Container <br>//      IOleInPlaceSite::CanInPlaceActivate     Container <br>//      IOleInPlaceSite::Release                Container <br>//      IOleInPlaceSite::OnInPlaceActivate      Container <br>//      IOleInPlaceSite::GetWindow              Container <br>//      IOleInPlaceSite::GetWindowContext       Container <br>//      IOleInPlaceSite::OnUIActivate           Container <br>//      IOleInPlaceSite::Release                Container <br>//      IOleInPlaceFrame::SetActiveObject       Container <br>//      IOleInPlaceUIWindow::SetActiveObject    Container <br>//      OutputDebugString                       Windows API <br>//      ShowWindow                              Windows API <br>//      SetParent                               Windows API <br>//      IntersectRect                           Windows API <br>//      OffsetRect                              Windows API <br>//      MoveWindow                              Windows API <br>//      CopyRect                                Windows API <br>//      SetFocus                                Windows API <br>//      SetHatchWindowSize                      OLE2UI <br>//      CSimpSvrObj::AssembleMenus              OBJ.CPP <br>//      CSimpSvrObj::AddFrameLevelUI            OBJ.CPP <br>// <br>// <br>// Comments: <br>// <br>//      Be sure to read TECHNOTES.WRI included with the OLE SDK <br>//      for details on implementing inplace activation. <br>// <br>//******************************************************************** <br> <br>BOOL CSimpSvrObj::DoInPlaceActivate (LONG lVerb) <br>{ <br>        BOOL retval = FALSE; <br>        RECT posRect, clipRect; <br> <br> <br>        OutputDebugString("In CSimpSvrObj::DoInPlaceActivate\r\n"); <br> <br>        // if not currently in place active <br>        if (!m_fInPlaceActive) <br>                { <br>                // get the inplace site <br>                if (m_lpOleClientSite-&gt;QueryInterface(IID_IOleInPlaceSite, <br>                                                                                          (LPVOID FAR *)&amp;m_lpIPSite) != NOERROR) <br>                        goto error; <br> <br> <br>                // if the inplace site could not be obtained, or refuses to inplace <br>                // activate then goto error. <br>                if (m_lpIPSite == NULL || m_lpIPSite-&gt;CanInPlaceActivate() != NOERROR) <br>                        { <br>                        if (m_lpIPSite) <br>                                m_lpIPSite-&gt;Release(); <br>                        m_lpIPSite == NULL; <br>                        goto error; <br>                        } <br> <br>                // tell the site that we are activating. <br>                m_lpIPSite-&gt;OnInPlaceActivate(); <br>                m_fInPlaceActive = TRUE; <br>                } <br> <br>        // if not currently inplace visibl <br>        if (!m_fInPlaceVisible) <br>                { <br>                m_fInPlaceVisible = TRUE; <br> <br>                // get the window handle of the site <br>                m_lpIPSite-&gt;GetWindow(&amp;m_hWndParent); <br> <br>                // get window context from the container <br>                m_lpIPSite-&gt;GetWindowContext ( &amp;m_lpFrame, <br>                                                                         &amp;m_lpCntrDoc, <br>                                                                         &amp;posRect, <br>                                                                         &amp;clipRect, <br>                                                                         &amp;m_FrameInfo); <br> <br>                // show the hatch window <br>                m_lpDoc-&gt;ShowHatchWnd(); <br> <br>                // Set the parenting <br>                SetParent (m_lpDoc-&gt;GethHatchWnd(), m_hWndParent); <br>                SetParent (m_lpDoc-&gt;GethDocWnd(), m_lpDoc-&gt;GethHatchWnd()); <br> <br>                // tell the client site to show the object <br>                m_lpOleClientSite-&gt;ShowObject(); <br> <br>                RECT resRect; <br> <br>                // figure out the "real" size of the object <br>                IntersectRect(&amp;resRect, &amp;posRect, &amp;clipRect); <br>                CopyRect(&amp;m_posRect, &amp;posRect); <br> <br>                POINT pt; <br> <br>                // adjust our hatch window size <br>                SetHatchWindowSize ( m_lpDoc-&gt;GethHatchWnd(), <br>                                                         &amp;resRect, <br>                                                         &amp;posRect, <br>                                                         &amp;pt); <br> <br>                // calculate the actual object rect inside the hatchwnd. <br>                OffsetRect (&amp;resRect, pt.x, pt.y); <br> <br>                // move the object window <br>                MoveWindow(m_lpDoc-&gt;GethDocWnd(), <br>                                   resRect.left, <br>                                   resRect.top, <br>                                   resRect.right - resRect.left, <br>                                   resRect.bottom - resRect.top, <br>                                   FALSE); <br> <br>                // create the combined window <br>                AssembleMenus(); <br>                } <br> <br>        // if not UIActive <br>        if (!m_fUIActive) <br>                { <br>                m_fUIActive = TRUE; <br> <br>                // tell the inplace site that we are activating <br>                m_lpIPSite-&gt;OnUIActivate(); <br> <br>                // set the focus to our object window <br>                SetFocus(m_lpDoc-&gt;GethDocWnd()); <br> <br>                // set the active object on the frame <br>                //@@WTK WIN32, UNICODE <br>                //m_lpFrame-&gt;SetActiveObject(&amp;m_OleInPlaceActiveObject, "Simple OLE 2.0 Server"); <br>                m_lpFrame-&gt;SetActiveObject(&amp;m_OleInPlaceActiveObject, OLESTR("Simple OLE 2.0 Server")); <br> <br>                // set the active object on the Doc, if available. <br>                if (m_lpCntrDoc) <br>                        //@@WTK WIN32, UNICODE <br>                        //m_lpCntrDoc-&gt;SetActiveObject(&amp;m_OleInPlaceActiveObject, "Simple OLE 2.0 Server"); <br>                        m_lpCntrDoc-&gt;SetActiveObject(&amp;m_OleInPlaceActiveObject, OLESTR("Simple OLE 2.0 Server")); <br> <br>                // add the frame level UI. <br>                AddFrameLevelUI(); <br>                } <br> <br>        retval = TRUE; <br>error: <br>        return retval; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::AssembleMenus <br>// <br>// Purpose: <br>// <br>//      Creates the combined menus used during inplace activation. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      OutputDebugString               Windows API <br>//      CreateMenu                      Windows API <br>//      IOleInPlaceFrame::InsertMenus   Container <br>//      InsertMenu                      Windows API <br>//      DestroyMenu                     Windows API <br>//      OleCreateMenuDescriptor         OLE API <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::AssembleMenus() <br>{ <br>        OutputDebugString("In CSimpSvrObj::AssembleMenus\r\n"); <br>        OLEMENUGROUPWIDTHS menugroupwidths; <br> <br>        m_hmenuShared = NULL; <br> <br>        //  Create the menu resource <br>        m_hmenuShared = CreateMenu(); <br> <br>        // have the contaner insert its menus <br>        if (m_lpFrame-&gt;InsertMenus (m_hmenuShared, &amp;menugroupwidths) == NOERROR) <br>                { <br>                int nFirstGroup = (int) menugroupwidths.width[0]; <br> <br>                // insert the server menus <br>                //@@WTK WIN32, UNICODE <br>                //InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP, m_lpDoc-&gt;GetApp()-&gt;GetColorMenu(), "&amp;Color"); <br>                InsertMenu( m_hmenuShared, nFirstGroup, MF_BYPOSITION | MF_POPUP, <br>                        (UINT)m_lpDoc-&gt;GetApp()-&gt;GetColorMenu(), "&amp;Color"); <br>                menugroupwidths.width[1] = 1; <br>                menugroupwidths.width[3] = 0; <br>                menugroupwidths.width[5] = 0; <br>                } <br>        else <br>                { <br>                // Destroy the menu resource <br>                DestroyMenu(m_hmenuShared); <br>                m_hmenuShared = NULL; <br>                } <br> <br>        // tell OLE to create the menu descriptor <br>        m_hOleMenu = OleCreateMenuDescriptor(m_hmenuShared, &amp;menugroupwidths); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::AddFrameLevelUI <br>// <br>// Purpose: <br>// <br>//      Adds the Frame level user interface <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString                   Windows API <br>//      IOleInPlaceFrame::SetMenu           Container <br>//      IOleInPlaceFrame::SetBorderSpace    Container <br>//      IOleInPlaceUIWindow::SetBorderSpace Container <br>//      CSimpSvrDoc::GethDocWnd             DOC.H <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::AddFrameLevelUI() <br>{ <br>        OutputDebugString("In CSimpSvrObj::AddFrameLevelUI\r\n"); <br> <br>        // add the combined menu <br>        m_lpFrame-&gt;SetMenu(m_hmenuShared, m_hOleMenu, m_lpDoc-&gt;GethDocWnd()); <br> <br>        // do hatched border <br>        SetParent (m_lpDoc-&gt;GethHatchWnd(), m_hWndParent); <br>        SetParent (m_lpDoc-&gt;GethDocWnd(), m_lpDoc-&gt;GethHatchWnd()); <br> <br>        // set the border space.  Normally we would negotiate for toolbar <br>        // space at this point.  Since this server doesn't have a toolbar, <br>        // this isn't needed... <br>        if (m_lpFrame) <br>                m_lpFrame-&gt;SetBorderSpace(NULL); <br> <br>        if (m_lpCntrDoc) <br>                m_lpCntrDoc-&gt;SetBorderSpace(NULL); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::DoInPlaceHide <br>// <br>// Purpose: <br>// <br>//      Hides the object while inplace actvie <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                        Location <br>// <br>//      OutputDebugString               Windows API <br>//      SetParent                       Windows API <br>//      CSimpSvrDoc::GethDocWnd         DOC.H <br>//      CSimpSvrDoc::GethAppWnd         DOC.H <br>//      CSimpSvrDoc::GethHatchWnd       DOC.H <br>//      CSimpSvrObj::DisassembleMenus   OBJ.CPP <br>//      IOleInPlaceFrame::Release       Container <br>//      IOleInPlaceUIWindow::Release    Container <br>// <br>// <br>// Comments: <br>// <br>//      Be sure to read TECHNOTES.WRI included with the OLE SDK <br>//      for details on implementing inplace activation. <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::DoInPlaceHide() <br>{ <br>        OutputDebugString("In CSimpSvrObj::DoInPlaceHide\r\n"); <br> <br>        // if we aren't inplace visible, then this routine is a NOP, <br>        if (!m_fInPlaceVisible) <br>                return; <br> <br>        m_fInPlaceVisible = FALSE; <br> <br>        // change the parenting <br>        SetParent (m_lpDoc-&gt;GethDocWnd(), m_lpDoc-&gt;GethAppWnd()); <br>        SetParent (m_lpDoc-&gt;GethHatchWnd(),m_lpDoc-&gt;GethDocWnd()); <br> <br>        // rip down the combined menus <br>        DisassembleMenus(); <br> <br>        // release the inplace frame <br>        m_lpFrame-&gt;Release(); <br> <br>        m_lpFrame = NULL;  // only holding one ref. to frame. <br> <br>        // release the UIWindow if it is there. <br>        if (m_lpCntrDoc) <br>                m_lpCntrDoc-&gt;Release(); <br> <br>        m_lpCntrDoc = NULL; <br> <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::DisassembleMenus <br>// <br>// Purpose: <br>// <br>//      Disassembles the combined menus used in inplace activation <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString               Windows API <br>//      OleDestroyMenuDescriptor        OLE API <br>//      RemoveMenu                      Windows API <br>//      IOleInPlaceFrame::RemoveMenus   Container <br>//      DestroyMenu                     Windows API <br>// <br>// Comments: <br>// <br>//      Be sure to read TECHNOTES.WRI included with the OLE SDK <br>//      for details on implementing inplace activation. <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::DisassembleMenus() <br>{ <br>        // destroy the menu descriptor <br>        OleDestroyMenuDescriptor(m_hOleMenu); <br> <br>        if (m_hmenuShared) <br>                { <br>                // remove the menus that we added <br>                RemoveMenu( m_hmenuShared, 1, MF_BYPOSITION); <br> <br>                // have the container remove its menus </code></pre>
<p>
</p>
<pre><code>m_lpFrame-&gt;RemoveMenus(m_hmenuShared); <br> <br>                // Destroy the menu resource <br>                DestroyMenu(m_hmenuShared); <br> <br>                m_hmenuShared = NULL; <br>                } <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::SendOnDataChange <br>// <br>// Purpose: <br>// <br>//      Uses the data advise holder to send a data change, then updates <br>//      the ROT to note the time of change. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      IDataAdviseHolder::SendOnDataChange     OLE API <br>//      GetRunningObjectTable                   OLE API <br>//      CoFileTimeNow                           OLE API <br>//      IRunningObjectTable::NoteChangeTime     OLE API <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::SendOnDataChange() <br>{ <br>        if (m_lpDataAdviseHolder) <br>                m_lpDataAdviseHolder-&gt;SendOnDataChange( (LPDATAOBJECT)&amp;m_DataObject, 0, 0); <br> <br>        LPRUNNINGOBJECTTABLE lpRot; <br> <br>        GetRunningObjectTable(0, &amp;lpRot); <br> <br>        if ( lpRot &amp;&amp; m_dwRegister) <br>                { <br>                FILETIME ft; <br>                CoFileTimeNow(&amp;ft); <br> <br>                lpRot-&gt;NoteChangeTime(m_dwRegister, &amp;ft); <br>                lpRot-&gt;Release(); <br>                } <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpSvrObj::DeactivateUI <br>// <br>// Purpose: <br>// <br>//      Breaks down the inplace ui <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                Location <br>// <br>//      SetParent                               Windows API <br>//      IOleInPlaceUIWindow::SetActiveObject    Container <br>//      IOleInPlaceFrame::SetActiveObject       Container <br>//      IOleInPlaceSite::UIDeactivate           Container <br>// <br>// Comments: <br>// <br>// <br>//******************************************************************** <br> <br>void CSimpSvrObj::DeactivateUI() <br>{ <br>        // if not UI active, or no pointer to IOleInPlaceFrame, then <br>        // return NOERROR <br>        if (!(m_fUIActive || m_lpFrame)) <br>                return; <br>        else <br>                { <br>                m_fUIActive = FALSE; <br> <br>                // remove hatching <br>                SetParent (m_lpDoc-&gt;GethDocWnd(), m_lpDoc-&gt;GethAppWnd()); <br>                SetParent (m_lpDoc-&gt;GethHatchWnd(),m_lpDoc-&gt;GethDocWnd()); <br> <br>                // if in an MDI container, call SetActiveObject on the DOC. <br>                if (m_lpCntrDoc) <br>                        m_lpCntrDoc-&gt;SetActiveObject(NULL, NULL); <br> <br>                m_lpFrame-&gt;SetActiveObject(NULL, NULL); <br> <br>                // tell the container that our UI is going away. <br>                if (m_lpIPSite) <br>                        m_lpIPSite-&gt;OnUIDeactivate(FALSE); <br>                } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
