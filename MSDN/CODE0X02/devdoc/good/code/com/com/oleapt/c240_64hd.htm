<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEAPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context241"></a>OLEAPT.CPP</h2>
<pre><code>// =========================================================================== <br>// File: O L E A P T . C P P <br>//  <br>//  Demonstrates OLE Apartment model threading. "Apartment" is essentially <br>// just a way of describing a thread with a message queue that supports OLE/COM <br>// objects. Objects within an apartment are reentrant in only the traditional <br>// Windows sense, identically to single-threaded OLE. That is to say that <br>// operations which yield to the message queue can cause further messages to <br>// be sent to any objects within the apartment. Apartment model threading simply <br>// allows there to be more than one "apartment" where previously there was <br>// only one: the main application thread. <br>//  <br>//  This program is both a client and an server. It launches as a client <br>// by default, registering its executable as a server and creating another <br>// instance of itself to be the server. <br>//  <br>//  The client does nothing interesting and is always shown as a minimized <br>// window. It simply creates an instance of its worker COM object in the <br>// server. When it shuts down, it releases its reference to the object, <br>// which is reflected in the server's UI. <br>//  <br>//  The server registers a class-factory on the main application thread and <br>// also spawns several worker threads. When requests arrive from clients to <br>// create instances of the class, the server class-factory picks a worker <br>// thread for the object (simply allocating them round-robin to the workers) <br>// and then goes through the process of having the object created within the <br>// thread and properly marshalled from the worker thread back to the class- <br>// factory where it can be returned to the caller. Note that this marshalling <br>// to the main thread is fairly transient, it lasts for creation only: <br>// subsequent calls from the client to the object go straight from the client's <br>// process into the worker apartment. <br>//  <br>//  The only mechanisms used here above-and-beyond NT 3.5 are: <br>//   * Ability to call CoInitialize() in multiple threads <br>//   * The use of the new marshalling flag, MSHCTX_INPROC, to marshall <br>//     pointers between threads <br>// <br>//  This sample may be compiled as UNICODE for the NT 3.51 beta, or as Ansi <br>// (listed here) to run on both the NT 3.51 beta and the Windows 95 M8 Beta. <br>//  <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;stdio.h&gt; <br> <br>// %%Constants: -------------------------------------------------------------- <br>#define cServerThreads  5 <br>#define szWindowClass   TEXT("OLEAPT_CLASS") <br>#define szTitleServer   TEXT("SERVER: OLE Apartment Sample") <br>#define szTitleClient   TEXT("CLIENT: OLE Apartment Sample") <br>#define szCloseQuery    TEXT("Client references still exist. Are you sure you want to close?") <br>#define COINIT_APARTMENTTHREADED    2 <br>const LARGE_INTEGER     bZero = {0,0}; <br> <br>// %%Guids: ------------------------------------------------------------------ <br>DEFINE_GUID(CLSID_CObject, 0x5c06abc0, 0x2dcd, 0x11ce, 0x84, 0x17, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71); <br> <br>// %%Classes: ---------------------------------------------------------------- <br>// the class-factory object exists in the main application apartment/thread <br>// and is used to create instances of the worker objects on worker threads. <br>class CClassFactory : public IClassFactory <br>    { <br>  // IClassFactory <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return mcRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void)   { if (--mcRef == 0) { delete this; return 0; } return mcRef; } <br>    STDMETHODIMP            CreateInstance(LPUNKNOWN punkOuter, REFIID iid, LPVOID FAR *ppv); <br>    STDMETHODIMP            LockServer(BOOL fLock); <br> <br>  // data members <br>    ULONG   mcRef; <br> <br>  // constructors/destructors <br>  public: <br>    CClassFactory() { mcRef = 1; } <br>    }; <br> <br>// this worker object is simple: it simply supports IUnknown. more interesting <br>// interfaces can be readily added here and implemented for the worker. <br>class CObject : public IUnknown <br>    { <br>  // IUnknown <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return mcRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void); <br> <br>  // data members <br>    ULONG   mcRef; <br> <br>  // constructors/destructors <br>  public: <br>    CObject() { mcRef = 1; } <br>    }; <br> <br>// %%Globals: ---------------------------------------------------------------- <br>BOOL        vfServer;                       // is this instance a server or client? <br>HANDLE      vrghThread[cServerThreads];     // worker thread handles <br>DWORD       vrgtid[cServerThreads];         // worker thread id's <br>HANDLE      vrghEvent[cServerThreads];      // creation event for each worker <br>INT         vrgcObjects[cServerThreads];    // # of objects created on each thread <br>HANDLE      vhEventServer;                  // creation-complete event for class-factory <br>CClassFactory   vclassfactory; <br>UINT        viNextThread;                   // next worker to create an object on <br>LPUNKNOWN   vpunkService;                   // client's x-process reference to its <br>                                            //  worker object in the server <br>HWND        vhwndMain; <br>LPSTREAM    vpstmMarshalling;               // scratch stream used for cross-apt marshalling <br>HRESULT     vhrThreadStatus;                // signals status to class-factory <br> <br>// %%Prototypes: ------------------------------------------------------------- <br>LRESULT CALLBACK    MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>LRESULT             ServerThreadProc(LPARAM lParam); <br>BOOL                FAutoRegister(HINSTANCE hinst); <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: MainWndProc <br>//  Window procedure for both client and server versions of the sample. Clients <br>// display nothing, server displays statistics about <br>// --------------------------------------------------------------------------- <br> LRESULT CALLBACK <br>MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    LRESULT lresult = TRUE; <br> <br>    switch (message) <br>        { <br>        case WM_QUERYOPEN: <br>            // clients must stay minimized <br>            return vfServer; <br> <br>        case WM_PAINT: <br>            { <br>            HDC hdc; <br>            PAINTSTRUCT ps; <br>            int i; <br> <br>            if ((hdc = BeginPaint(hwnd, &amp;ps)) != NULL) <br>                { <br>                if (vfServer) <br>                    { <br>                    for (i=0; i&lt;cServerThreads; i++) <br>                        { <br>                        TCHAR    rgch[200]; <br> <br>                        wsprintf(rgch, TEXT("Thread #%d: %d objects"), i, vrgcObjects[i]); <br>                        TextOut(hdc, 20, 10+(i*25), rgch, lstrlen(rgch)); <br>                        } <br>                    } <br>                } <br>            EndPaint(hwnd, &amp;ps); <br>            } <br>            break; <br> <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_CLOSE: <br>            // check for clients and prompt in the UI. <br>            if (vfServer) <br>                { <br>                for (int i=0; i&lt;cServerThreads; i++) <br>                    { <br>                    if (vrgcObjects[i] &gt; 0) <br>                        { <br>                        if (MessageBox(hwnd, szCloseQuery, <br>                                szTitleServer, MB_YESNO) == IDNO) <br>                            return FALSE; <br>                        else <br>                            break; <br>                        } <br>                    } <br>                } <br> <br>        default: <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br>        } <br> <br>    return lresult; <br>}  // MainWndProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: WinMain <br>//  Initialization, main message-pump for clients and servers. <br>// --------------------------------------------------------------------------- <br> int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    WNDCLASS wndclass; <br>    HRESULT hr; <br>    int     i; <br>    DWORD   dwRegister = 0; <br>    MSG     msg; <br> <br>    // parse the command-line <br>    if (szCmdLine) <br>        { <br>        LPSTR   sz = strtok(szCmdLine, " \t"); <br> <br>        vfServer = (sz &amp;&amp; !strcmpi(sz, "-Embedding")); <br>        } <br>  <br>    // initialize COM <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) <br>        { <br>        MessageBeep(0); <br>        return hr; <br>        } <br> <br>    // register the CObject class in the registry so <br>    // that the client can create instances of the server <br>    if (!FAutoRegister(hinst)) <br>        { <br>        hr = GetLastError(); <br>        goto LCleanup; <br>        } <br> <br>    if (vfServer) <br>        { <br>        // create the threads and synchronization events <br>        // which the server will need <br>        for (i=0; i&lt;cServerThreads; i++) <br>            { <br>            TCHAR    rgch[32]; <br> <br>            // create the thread suspended so its event can be <br>            // created using its thread-id and it will be able to <br>            // use it as soon as it runs <br>            vrghThread[i] = CreateThread(NULL, <br>                0, <br>                (LPTHREAD_START_ROUTINE)&amp;ServerThreadProc, <br>                0, <br>                CREATE_SUSPENDED, <br>                &amp;vrgtid[i]); <br>            if (vrghThread[i] == NULL) <br>                { <br>                hr = GetLastError(); <br>                goto LCleanup; <br>                } <br> <br>            // a thread can use its thread-id to OpenEvent this existing <br>            // event at any time. it can also look for its thread-id in <br>            // vrgtid[] to determine its index for use with vrghEvent. <br>            // this event signals to a worker thread to create a new CObject <br>            wsprintf(rgch, TEXT("Thread_%d"), vrgtid[i]); <br>            vrghEvent[i] = CreateEvent(NULL, FALSE, FALSE, rgch); <br>            if (vrghEvent[i] == NULL) <br>                { <br>                hr = GetLastError(); <br>                goto LCleanup; <br>                } <br> <br>            // now that the event is available, let the thread run <br>            ResumeThread(vrghThread[i]); <br>            } <br> <br>        // this signals the status of a worker threads creation after <br>        // receiving its create signal via vrghEvent[i] <br>        vhEventServer = CreateEvent(NULL, FALSE, FALSE, TEXT("Server")); <br>        if (vhEventServer == NULL) <br>            { <br>            hr = GetLastError(); <br>            goto LCleanup; <br>            } <br> <br>        // register the class-factory with COM <br>        hr = CoRegisterClassObject(CLSID_CObject, <br>            (IUnknown *)&amp;vclassfactory, <br>            CLSCTX_LOCAL_SERVER, <br>            REGCLS_MULTIPLEUSE, <br>            &amp;dwRegister); <br>        if (FAILED(hr)) <br>            goto LCleanup; <br> <br>        // create an IStream to be used for marshalling new objects between <br>        // the worker and the CClassFactory <br>        hr = CreateStreamOnHGlobal(NULL, TRUE, &amp;vpstmMarshalling); <br>        if (FAILED(hr)) <br>            goto LCleanup; <br>        } <br>    else <br>        { <br>        // this is the client case: create an instance of the service object <br>        // in the server <br>        hr = CoCreateInstance(CLSID_CObject, <br>            NULL, <br>            CLSCTX_LOCAL_SERVER, <br>            IID_IUnknown, <br>            (void**)&amp;vpunkService); <br>        if (FAILED(hr)) <br>            goto LCleanup; <br>        } <br> <br>    // create the client and server UI <br>    memset(&amp;wndclass, 0, sizeof(wndclass)); <br>    wndclass.lpszClassName = szWindowClass; <br>    wndclass.style = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc = MainWndProc; <br>    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); <br>    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wndclass.hInstance = hinst; <br> <br>    if (!RegisterClass(&amp;wndclass) || <br>        (vhwndMain = CreateWindow(szWindowClass, <br>            vfServer ? szTitleServer : szTitleClient, <br>            WS_OVERLAPPEDWINDOW, <br>            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>            HWND_DESKTOP, NULL, hinst, NULL)) == NULL) <br>        { <br>        hr = GetLastError(); <br>        goto LCleanup; <br>        } <br> <br>    // display clients as minimized, server as a normal window <br>    ShowWindow(vhwndMain, vfServer ? nCmdShow : SW_SHOWMINNOACTIVE); <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>        } <br>    hr = msg.wParam; <br> <br>LCleanup: <br>    if (hr != S_OK) <br>        MessageBeep(0); <br>    if (vfServer) <br>        { <br>        // we explicitly don't clean up threads and events <br>        if (dwRegister != 0) <br>            CoRevokeClassObject(dwRegister); <br>        if (vpstmMarshalling != NULL) <br>            vpstmMarshalling-&gt;Release(); <br>        } <br>    else <br>        { <br>        // this is the client case: make sure to release the service <br>        if (vpunkService != NULL) <br>            vpunkService-&gt;Release(); <br>        } <br> <br>    CoUninitialize(); <br>    return hr; <br>}  // WinMain <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: FAutoRegister <br>//  Registers the CObject class in the registry. <br>// --------------------------------------------------------------------------- <br> BOOL <br>FAutoRegister(HINSTANCE hinst) <br>{ <br>    static TCHAR szClassDesc[] = TEXT("Ole Apartments Sample"); <br>    static TCHAR szCLSIDEntry[] = TEXT("CLSID\\{5c06abc0-2dcd-11ce-8417-00aa00389b71}"); <br>    TCHAR       szBuf[512]; <br>    TCHAR       szPath[512]; <br>    HKEY        hkeyT = NULL; <br> <br>    // install the OLEPerf OLE1/OLE2 compatibility sections <br>    if ((RegSetValue(HKEY_CLASSES_ROOT, szCLSIDEntry, REG_SZ, szClassDesc, <br>            lstrlen(szClassDesc)) != ERROR_SUCCESS) || <br>        (RegCreateKey(HKEY_CLASSES_ROOT, szCLSIDEntry, &amp;hkeyT) <br>            != ERROR_SUCCESS) || <br>        !GetModuleFileName(hinst, szBuf, sizeof(szBuf))) <br>        return FALSE; <br>    lstrcpy(szPath, szBuf); <br>    if (RegSetValue(hkeyT, TEXT("LocalServer32"), REG_SZ, szBuf, lstrlen(szBuf)) <br>            != ERROR_SUCCESS) <br>        goto LErrExit; <br>    RegCloseKey(hkeyT); <br>    return TRUE; <br>LErrExit: <br>    RegCloseKey(hkeyT); <br>    return FALSE; <br>}  // FAutoRegister <br> <br>// =========================================================================== <br>//                          C C L A S S F A C T O R Y <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CClassFactory. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IClassFactory || iid == IID_IUnknown) <br>        { <br>        *ppv = (IClassFactory *)this; <br>        } <br>    if (*ppv != NULL) <br>        { <br>        AddRef(); <br>        return S_OK; <br>        } <br>    return E_NOINTERFACE; <br>}  // CClassFactory::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::CreateInstance <br>//  Creates a new instance of a CObject on the next worker thread. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv) <br>{ <br>    LPUNKNOWN   punk; <br>    HRESULT     hr; <br> <br>    *ppv = NULL; <br>    if (punkOuter != NULL) <br>        return CLASS_E_NOAGGREGATION; <br> <br>    // trigger the worker thread that we want to create an object <br>    SetEvent(vrghEvent[viNextThread]); <br> <br>    // now wait for the object to signal its completion <br>    WaitForSingleObject(vhEventServer, INFINITE); <br> <br>    // once the worker thread signals completion, vhrThreadStatus <br>    // lets us know if the creation process was successful, and if <br>    // vpstmMarshalling creates a marshalled interface pointer <br>    if (FAILED(vhrThreadStatus)) <br>        return vhrThreadStatus; <br> <br>    // unmarshal an IUnknown from the scratch stream. if unmarshaling <br>    // fails, it takes care of releasing the object inside the marshal-data <br>    hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>    if (FAILED(hr)) <br>        return hr; <br>    hr = CoUnmarshalInterface(vpstmMarshalling, IID_IUnknown, (void **)&amp;punk); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    // get a reference to the interface asked for <br>    hr = punk-&gt;QueryInterface(iid, ppv); <br>    punk-&gt;Release(); <br> <br>    viNextThread++; <br>    viNextThread %= cServerThreads; <br> <br>    return hr; <br>}  // CClassFactory::CreateInstance <br> <br> STDMETHODIMP <br>CClassFactory::LockServer(BOOL fLock) <br>{ <br>    // there's no need to support this for this sample <br>    return E_FAIL; <br>}  // CClassFactory::LockServer <br> <br> <br>// =========================================================================== <br>//                               C O B J E C T <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ServerThreadProc <br>//  The worker thread function. Handles messages for objects of its thread/apt <br>// and creates new objects. <br>// --------------------------------------------------------------------------- <br> LRESULT <br>ServerThreadProc(LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    MSG     msg; <br>    int     iThread; <br> <br>    // figure out which thread this is: it needs its synchronization event <br>    for (iThread=0; iThread&lt;cServerThreads; iThread++) <br>        { <br>        if (vrgtid[iThread] == GetCurrentThreadId()) <br>            break; <br>        } <br>    if (iThread==cServerThreads) <br>        return E_UNEXPECTED; <br> <br>    // initialize COM <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) <br>        { <br>        MessageBeep(0); <br>        return hr; <br>        } <br> <br>    // apartment message/event loop <br>    // (see SDK documentation for MsgWaitForMultipleObjects) <br>    // here worker message loops last forever. in situations without a <br>    // static number of worker threads, the loop could easily be terminated by <br>    // WM_QUITs sent from the main thread which might manage the worker thread <br>    // pool more carefully. <br>    while (TRUE) <br>        { <br>        DWORD dwWaitResult; <br> <br>        // wait for any message sent or posted to this queue <br>        // or for one of the passed handles to become signaled <br>        dwWaitResult = MsgWaitForMultipleObjects(1, &amp;vrghEvent[iThread], <br>            FALSE, INFINITE, QS_ALLINPUT); <br> <br>        // result tells us the type of event we have: <br>        // a message or a signaled handle <br> <br>        // if there are one or more messages in the queue ... <br>        if (dwWaitResult == (WAIT_OBJECT_0 + 1)) <br>            { <br>            // dispatch all of the messages in this next loop <br>            // (here is where we'd check for WM_QUITs to end this <br>            // worker thread if we wanted to) <br>            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>                DispatchMessage(&amp;msg); <br>            } <br>        else <br>            { <br>            // this thread was signaled to create a new object <br>            try <br>                { <br>                LPUNKNOWN   punk; <br> <br>                // create a new CObject <br>                punk = (IUnknown *)new CObject; <br>                if (punk == NULL) <br>                    throw E_OUTOFMEMORY; <br> <br>                hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>                if (FAILED(hr)) <br>                    throw hr; <br>                hr = CoMarshalInterface(vpstmMarshalling, <br>                    IID_IUnknown, <br>                    punk, <br>                    MSHCTX_INPROC, <br>                    NULL, <br>                    MSHLFLAGS_NORMAL); <br>                if (FAILED(hr)) <br>                    throw hr; <br> <br>                // punk is now referenced by its marshal-data in vpstmMarshalling. <br>                // we release our local reference here so the unmarshaller will <br>                // have the sole reference. a common mistake is to forget this <br>                // release and end up with orphaned objects in the server. <br>                punk-&gt;Release(); <br> <br>                // modify the global state -- the # of objects/thread -- which is <br>                // displayed in the server UI <br>                vrgcObjects[iThread]++; <br>                InvalidateRect(vhwndMain, NULL, TRUE); <br> <br>                vhrThreadStatus = S_OK; <br>                } <br>            catch (HRESULT hr) <br>                { <br>                vhrThreadStatus = hr; <br>                } <br>            SetEvent(vhEventServer); <br>            } <br> <br>        } <br> <br>    CoUninitialize(); <br>    return msg.wParam; <br>}  // ServerThreadProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CObject::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CObject. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CObject::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IUnknown) <br>        { <br>        *ppv = (IUnknown *)this; <br>        } <br>    if (*ppv != NULL) <br>        { <br>        AddRef(); <br>        return S_OK; <br>        } <br>    return E_NOINTERFACE; <br>}  // CObject::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CObject::Release <br>//  Handles releases of references to a CObject. Purpose here is to have code <br>// which alters the global state which is displayed in the servers UI. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP_(ULONG) <br>CObject::Release(void) <br>{ <br>    if (--mcRef == 0) <br>        { <br>        // change the global server state -- the # of objects/thread -- <br>        // reflected in the server UI <br>        for (int i=0; i&lt;cServerThreads; i++) <br>            { <br>            if (vrgtid[i] == GetCurrentThreadId()) <br>                { <br>                vrgcObjects[i]--; <br>                InvalidateRect(vhwndMain, NULL, TRUE); <br>                break; <br>                } <br>            } <br> <br>        delete this; <br>        return 0; <br>        } <br>    return mcRef; <br>}  // CObject::Release <br> <br>// EOF ======================================================================= <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
