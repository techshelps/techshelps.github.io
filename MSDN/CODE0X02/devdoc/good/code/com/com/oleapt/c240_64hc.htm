<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context240"></a>README.TXT</h2>
<pre><code>OLE Apartment Model Threading <br> <br> <br>SUMMARY <br>======= <br> <br>The OLEAPT sample demonstrates OLE apartment model threading. The term  <br>"apartment" describes a thread with a message queue that supports OLE/COM  <br>objects. Objects within an apartment are reentrant in only the traditional  <br>Windows sense, similar to single-threaded OLE. Therefore, operations that  <br>yield to the message queue can cause further messages to be sent to any  <br>objects within the apartment. Apartment model threading allows there to be  <br>more than one "apartment" where previously there was only one: the main  <br>application thread. <br> <br>MORE INFORMATION <br>================ <br> <br>This program is both a client and a server. It starts as a client by  <br>default, registering its executable as a server and creating another  <br>instance of itself to be the server. <br> <br>The client does nothing interesting and is always shown as a minimized  <br>window. It simply creates an instance of its worker COM object in the  <br>server. When it shuts down, it releases its reference to the object. <br> <br>The server registers a class-factory on the main application thread and also  <br>creates several worker threads. When requests arrive from clients to create  <br>instances of the class, the server class-factory picks a worker thread for  <br>the object (simply allocating them round-robin to the workers) and then goes  <br>through the process of having the object created within the thread and  <br>marshaled from the worker thread back to the class-factory, where it can be  <br>returned to the caller. Note that this marshaling to the main thread happens <br>during creation only; subsequent calls from the client to the object go  <br>straight from the client's process into the worker apartment. <br> <br>The only mechanisms used here above-and-beyond Windows NT 3.5 are: <br> <br>  - Ability to call CoInitialize in multiple threads <br>  - The use of the new marshaling flag, MSHCTX_INPROC, to marshall pointers <br>    between threads <br> <br>This sample can be compiled as UNICODE or ANSI, so that it can run on both  <br>Windows NT 3.51 and Windows 95. </code></pre>
<p>&nbsp;</p></body>
</HTML>
