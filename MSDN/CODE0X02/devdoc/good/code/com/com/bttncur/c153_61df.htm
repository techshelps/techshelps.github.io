<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BTTNCUR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context153"></a>BTTNCUR.C</h2>
<pre><code>/* <br> * BTTNCUR.C <br> * Buttons &amp; Cursors Version 1.1, March 1993 <br> * <br> * Public functions to generate different states of toolbar buttons from <br> * a single bitmap.  States are normal, pressed, checked, and disabled. <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Rights Reserved, <br> * as applied to redistribution of this source code in source form <br> * License is granted to use of compiled code in shipped binaries. <br> */ <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;memory.h&gt; <br>#include "bttncur.h" <br>#include "bttncuri.h" <br> <br> <br> <br>//Display sensitive information <br>TOOLDISPLAYDATA     tdd; <br> <br>//Library instance <br>HINSTANCE           ghInst; <br>/* <br>23/1/94 (kerenm) <br>Add intance count for 32bit dll <br>*/ <br>int                 cInstances = 0; <br> <br>//Cache GDI objects to speed drawing. <br>HDC     hDCGlyphs    = NULL; <br>HDC     hDCMono      = NULL; <br>HBRUSH  hBrushDither = NULL; <br> <br>//Standard images to use in case caller doesn't provide them <br>HBITMAP rghBmpStandardImages[3]; <br> <br>//Standard button colors. <br>const COLORREF crStandard[4]={ RGB(0, 0, 0)          //STDCOLOR_BLACK <br>                      , RGB(128, 128, 128)    //STDCOLOR_DKGRAY <br>                      , RGB(192, 192, 192)    //STDCOLOR_LTGRAY <br>                      , RGB(255, 255, 255)};  //STDCOLOR_WHITE <br> <br> <br>/* <br> * Mapping from image identifier to button type (command/attribute). <br> * Version 1.00 of this DLL has no attribute images defined, so <br> * the code will only support three states for each command <br> * button.  Any state is, however, valid for an application <br> * defined image. <br> */ <br> <br>UINT mpButtonType[TOOLIMAGE_MAX-TOOLIMAGE_MIN+1]= <br>      { <br>      BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, <br>      BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, <br>      BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND <br>      }; <br> <br> <br> <br> <br>/* <br> * LibMain <br> * <br> * Purpose: <br> *  DLL-specific entry point called from LibEntry.  Initializes <br> *  global variables and loads standard image bitmaps. <br> * <br> * Parameters: <br> *  hInstance       HANDLE instance of the DLL. <br> *  wDataSeg        WORD segment selector of the DLL's data segment. <br> *  wHeapSize       WORD byte count of the heap. <br> *  lpCmdLine       LPSTR to command line used to start the module. <br> * <br> * Return Value: <br> *  HANDLE          Instance handle of the DLL. <br> */ <br> <br>BOOL xxxLibMain(HINSTANCE hInstance) <br>   { <br>    int i; <br> <br>/* <br>23/1/94 (kerenm) <br>For WIN32S - should done only once. On NT ghInst is instance dataso it will <br>always be zero. <br>*/ <br>#ifdef WIN32 <br>   if (ghInst) { <br>      return(TRUE); <br>   } <br>#endif <br>   ghInst=hInstance; <br> <br>    tdd.uDPI     =96; <br>   tdd.cyBar    =CYBUTTONBAR96; <br>   tdd.cxButton =TOOLBUTTON_STD96WIDTH; <br>   tdd.cyButton =TOOLBUTTON_STD96HEIGHT; <br>   tdd.cxImage  =TOOLBUTTON_STD96IMAGEWIDTH; <br>   tdd.cyImage  =TOOLBUTTON_STD96IMAGEHEIGHT; <br>   tdd.uIDImages=IDB_STANDARDIMAGES96; <br> <br>   for (i=0; i &lt; 3; i++) <br>      { <br>      rghBmpStandardImages[i]=LoadBitmap(hInstance <br>         , MAKEINTRESOURCE(IDB_STANDARDIMAGESMIN+i)); <br> <br>      if (NULL==rghBmpStandardImages[i]) <br>         return FALSE; <br>      } <br> <br> <br>   //Perform global initialization. <br>   if (ToolButtonInit()) <br>      { <br>      CursorsCache(hInstance); <br> <br> <br>      return TRUE; <br>      } <br> <br>   return FALSE; <br> <br>   } <br> <br>#ifdef WIN32 <br> <br>void FAR PASCAL WEP(int); <br> <br>BOOL WINAPI DllMain <br>( <br>   HINSTANCE hInstance, <br>   ULONG     Reason, <br>   PCONTEXT  Context <br>) <br>{ <br>   OutputDebugString("bttncur LibMain:  bttncur.dll loaded\r\n"); <br> <br>   UNREFERENCED_PARAMETER(Context); <br> <br>   if (Reason == DLL_PROCESS_DETACH) { <br> <br>#ifdef WIN32 <br>     if (!--cInstances) { <br>        WEP(0); <br>     } <br>#else <br>      WEP(0); <br>#endif <br>      return TRUE; <br>   } <br>   else if (Reason != DLL_PROCESS_ATTACH) <br>      return TRUE; <br> <br>/* 1/23/94   */ <br>#ifdef WIN32 <br>   cInstances++; <br>#endif <br>   return xxxLibMain(hInstance); <br> <br>} <br> <br>#else <br> <br>HANDLE FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg <br>                    , WORD cbHeapSize, LPSTR lpCmdLine) <br>   { <br> <br>    //Perform global initialization. <br>   if (xxxLibMain(hInstance)) <br>      if (0!=cbHeapSize) <br>         UnlockData(0); <br> <br>   return hInstance; <br> <br>   } <br> <br>#endif <br> <br> <br>/* <br> * WEP <br> * <br> * Purpose: <br> *  Required DLL Exit function.  Does nothing. <br> * <br> * Parameters: <br> *  bSystemExit     BOOL indicating if the system is being shut <br> *                  down or the DLL has just been unloaded. <br> * <br> * Return Value: <br> *  void <br> * <br> */ <br> <br>void FAR PASCAL WEP(int bSystemExit) <br>   { <br>   /* <br>    * **Developers:  Note that WEP is called AFTER Windows does any <br>    *                automatic task cleanup.  You may see warnings for <br>    *                that two DCs, a bitmap, and a brush, were not <br>    *                deleted before task termination.  THIS IS NOT A <br>    *                PROBLEM WITH THIS CODE AND IT IS NOT A BUG.  This <br>    *                WEP function is properly called and performs the <br>    *                cleanup as appropriate.  The fact that Windows is <br>    *                calling WEP after checking task cleanup is not <br>    *                something we can control.  Just to prove it, the <br>    *                OutputDebugStrings in this and ToolButtonFree <br>    *                show that the code is exercised. <br>    */ <br> <br>#ifdef DEBUG <br>   OutputDebugString ("BttnCur WEP Entry\r\n"); <br>#endif <br>   CursorsFree(); <br>   ToolButtonFree(); <br>#ifdef DEBUG <br>   OutputDebugString ("BttnCur WEP Exit\r\n"); <br>#endif <br>   return; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * UIToolConfigureForDisplay <br> * Public API <br> * <br> * Purpose: <br> *  Initializes the library to scale button images for the display type. <br> *  Without calling this function the library defaults to 96 DPI (VGA). <br> *  By calling this function an application acknowledges that it must <br> *  use the data returned from this function to configure itself for <br> *  the display. <br> * <br> * Parameters: <br> *  lpDD            LPTOOLDISPLAYDATA to fill with the display-sensitive <br> *                  size values. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the sizes were obtained, FALSE otherwise. <br> */ <br> <br>BOOL WINAPI UIToolConfigureForDisplay(LPTOOLDISPLAYDATA lpDD) <br>   { <br>   int         cy; <br>   HDC         hDC; <br> <br> <br>   if (NULL==lpDD || IsBadWritePtr(lpDD, sizeof(TOOLDISPLAYDATA))) <br>      return FALSE; <br> <br>   /* <br>    * Determine the aspect ratio of the display we're currently <br>    * running on and calculate the necessary information. <br>    * <br>    * By retrieving the logical Y extent of the display driver, you <br>    * only have limited possibilities: <br>    *      LOGPIXELSY      Display <br>    *      ---------------------------------------- <br>    *         48             CGA    (unsupported) <br>    *         72             EGA <br>    *         96             VGA <br>    *        120             8514/a (i.e. HiRes VGA) <br>    */ <br> <br>   hDC=GetDC(NULL); <br> <br>   if (NULL==hDC) <br>      return FALSE; <br> <br>   cy=GetDeviceCaps(hDC, LOGPIXELSY); <br>   ReleaseDC(NULL, hDC); <br> <br>   /* <br>    * Instead of single comparisons, check ranges instead, so in case <br>    * we get something funky, we'll act reasonable. <br>    */ <br>   if (72 &gt;=cy) <br>      { <br>      lpDD-&gt;uDPI     =72; <br>      lpDD-&gt;cyBar    =CYBUTTONBAR72; <br>      lpDD-&gt;cxButton =TOOLBUTTON_STD72WIDTH; <br>      lpDD-&gt;cyButton =TOOLBUTTON_STD72HEIGHT; <br>      lpDD-&gt;cxImage  =TOOLBUTTON_STD72IMAGEWIDTH; <br>      lpDD-&gt;cyImage  =TOOLBUTTON_STD72IMAGEHEIGHT; <br>      lpDD-&gt;uIDImages=IDB_STANDARDIMAGES72; <br>      } <br>   else <br>      { <br>      if (72 &lt; cy &amp;&amp; 120 &gt; cy) <br>         { <br>         lpDD-&gt;uDPI     =96; <br>         lpDD-&gt;cyBar    =CYBUTTONBAR96; <br>         lpDD-&gt;cxButton =TOOLBUTTON_STD96WIDTH; <br>         lpDD-&gt;cyButton =TOOLBUTTON_STD96HEIGHT; <br>         lpDD-&gt;cxImage  =TOOLBUTTON_STD96IMAGEWIDTH; <br>         lpDD-&gt;cyImage  =TOOLBUTTON_STD96IMAGEHEIGHT; <br>         lpDD-&gt;uIDImages=IDB_STANDARDIMAGES96; <br>         } <br>      else <br>         { <br>         lpDD-&gt;uDPI     =120; <br>         lpDD-&gt;cyBar    =CYBUTTONBAR120; <br>         lpDD-&gt;cxButton =TOOLBUTTON_STD120WIDTH; <br>         lpDD-&gt;cyButton =TOOLBUTTON_STD120HEIGHT; <br>         lpDD-&gt;cxImage  =TOOLBUTTON_STD120IMAGEWIDTH; <br>         lpDD-&gt;cyImage  =TOOLBUTTON_STD120IMAGEHEIGHT; <br>         lpDD-&gt;uIDImages=IDB_STANDARDIMAGES120; <br>         } <br>      } <br> <br>   return TRUE; <br>   } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * ToolButtonInit <br> * Internal <br> * <br> * Purpose: <br> *  Initializes GDI objects for drawing images through UIToolButtonDraw. <br> *  If the function fails, the function has already performed proper <br> *  cleanup. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded.  FALSE otherwise. <br> */ <br> <br>static BOOL ToolButtonInit(void) <br>   { <br>   COLORREF        rgbHi; <br> <br>   //DC for BitBltting the image (the glyph) <br>   hDCGlyphs=CreateCompatibleDC(NULL); <br> <br>   //Create a monochrome DC and a brush for doing pattern dithering. <br>   hDCMono=CreateCompatibleDC(NULL); <br> <br>   //Windows 3.0 doesn't support COLOR_BTNHIGHLIGHT, so leave it white. <br>   if (0x0300 &lt; (UINT)GetVersion()) <br>      rgbHi=GetSysColor(COLOR_BTNHIGHLIGHT); <br>   else <br>      rgbHi=crStandard[STDCOLOR_WHITE]; <br> <br>   hBrushDither=HBrushDitherCreate(GetSysColor(COLOR_BTNFACE), rgbHi); <br> <br>   if (NULL==hDCGlyphs || NULL==hDCMono || NULL==hBrushDither) <br>      { <br>      //On failure, cleanup whatever might have been allocated. <br>      ToolButtonFree(); <br>      return FALSE; <br>      } <br> <br>   return TRUE; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * ToolButtonFree <br> * Internal <br> * <br> * Purpose: <br> *  Free all GDI allocations made during initialization.  Note that the <br> *  DEBUG output included here shows that WEP is called and cleanup actually <br> *  occurs.  However, if you watch debug output in DBWIN or on a terminal, <br> *  the debugging version of Windows does automatic app cleanup before WEP <br> *  is called, leading some to believe that this code is buggy.  The <br> *  debug output below shows that we do perform all necessary cleanup. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>static void ToolButtonFree(void) <br>   { <br>   UINT        i; <br> <br>   if (NULL!=hDCMono) <br>      DeleteDC(hDCMono); <br>   hDCMono=NULL; <br> <br> <br>   if (NULL!=hDCGlyphs) <br>      DeleteDC(hDCGlyphs); <br>   hDCGlyphs=NULL; <br> <br>   if (NULL!=hBrushDither) <br>      DeleteObject(hBrushDither); <br>   hBrushDither=NULL; <br> <br>   for (i=0; i &lt; 3; i++) <br>      { <br>      if (NULL!=rghBmpStandardImages[i]) <br>         DeleteObject(rghBmpStandardImages[i]); <br>      rghBmpStandardImages[i]=NULL; <br>      } <br> <br>   return; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * HBrushDitherCreate <br> * Internal <br> * <br> * Purpose: <br> *  Creates and returns a handle to a pattern brush created from <br> *  an 8*8 monochrome pattern bitmap.  We use the button face and <br> *  highlight colors to indicate the resulting colors of a PatBlt <br> *  using this brush. <br> * <br> * Parameters: <br> *  rgbFace         COLORREF of the button face color. <br> *  rgbHilight      COLORREF of the button highlight color. <br> * <br> * Return Value: <br> *  HBITMAP         Handle to the dither bitmap. <br> */ <br> <br>static HBRUSH HBrushDitherCreate(COLORREF rgbFace, COLORREF rgbHilight) <br>   { <br>   struct  //BITMAPINFO with 16 colors <br>      { <br>      BITMAPINFOHEADER    bmiHeader; <br>      RGBQUAD             bmiColors[16]; <br>      } bmi; <br> <br>   HBRUSH          hBrush=NULL; <br>   DWORD           patGray[8]; <br>   HDC             hDC; <br>   HBITMAP         hBmp; <br>   static COLORREF rgbFaceOld   =0xFFFFFFFF;  //Initially an impossible color <br>   static COLORREF rgbHilightOld=0xFFFFFFFF;  //so at first we always create <br> <br>   /* <br>    * If the colors haven't changed from last time, just return the <br>    * existing brush. <br>    */ <br>   if (rgbFace==rgbFaceOld &amp;&amp; rgbHilight==rgbHilightOld) <br>      return hBrushDither; <br> <br>   rgbFaceOld=rgbFace; <br>   rgbHilightOld=rgbHilight; <br> <br>   /* <br>    * We're going to create an 8*8 brush for PatBlt using the <br>    * button face color and button highlight color.  We use this <br>    * brush to affect the pressed state and the disabled state. <br>    */ <br>   bmi.bmiHeader.biSize         = sizeof(BITMAPINFOHEADER); <br>   bmi.bmiHeader.biWidth        = 8; <br>   bmi.bmiHeader.biHeight       = 8; <br>   bmi.bmiHeader.biPlanes       = 1; <br>   bmi.bmiHeader.biBitCount     = 1; <br>   bmi.bmiHeader.biCompression  = BI_RGB; <br>   bmi.bmiHeader.biSizeImage    = 0; <br>   bmi.bmiHeader.biXPelsPerMeter= 0; <br>   bmi.bmiHeader.biYPelsPerMeter= 0; <br>   bmi.bmiHeader.biClrUsed      = 0; <br>   bmi.bmiHeader.biClrImportant = 0; <br> <br>   bmi.bmiColors[0].rgbBlue     = GetBValue(rgbFace); <br>   bmi.bmiColors[0].rgbGreen    = GetGValue(rgbFace); <br>   bmi.bmiColors[0].rgbRed      = GetRValue(rgbFace); <br>   bmi.bmiColors[0].rgbReserved = 0; <br> <br>   bmi.bmiColors[1].rgbBlue     = GetBValue(rgbHilight); <br>   bmi.bmiColors[1].rgbGreen    = GetGValue(rgbHilight); <br>   bmi.bmiColors[1].rgbRed      = GetRValue(rgbHilight); <br>   bmi.bmiColors[1].rgbReserved = 0; <br> <br>   //Create the byte array for CreateDIBitmap. <br>   patGray[6]=patGray[4]=patGray[2]=patGray[0]=0x5555AAAAL; <br>   patGray[7]=patGray[5]=patGray[3]=patGray[1]=0xAAAA5555L; <br> <br>   //Create the bitmap <br>   hDC=GetDC(NULL); <br>   hBmp=CreateDIBitmap(hDC, &amp;bmi.bmiHeader, CBM_INIT, patGray <br>                  , (LPBITMAPINFO)&amp;bmi, DIB_RGB_COLORS); <br>   ReleaseDC(NULL, hDC); <br> <br>   //Create the brush from the bitmap <br>   if (NULL!=hBmp) <br>      { <br>      hBrush=CreatePatternBrush(hBmp); <br>      DeleteObject(hBmp); <br>      } <br> <br>   /* <br>    * If we could recreate a brush, clean up and make it the current <br>    * pattern.  Otherwise the best we can do it return the old one, <br>    * which will be colored wrong, but at least it works. <br>    */ <br>   if (NULL!=hBrush) <br>      { <br>      if (NULL!=hBrushDither) <br>         DeleteObject(hBrushDither); <br> <br>      hBrushDither=hBrush; <br>      } <br> <br>   return hBrushDither; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * UIToolButtonDraw <br> * Public API <br> * <br> * Purpose: <br> *  Draws the complete image of a toolbar-style button with a given <br> *  image in the center and in a specific state.  The button is drawn <br> *  on a specified hDC at a given location, so this function is useful <br> *  on standard owner-draw buttons as well as on toolbar controls that <br> *  have only one window but show images of multiple buttons. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> *  x, y            int coordinates at which to draw. <br> *  dx, dy          int dimensions of the *button*, not necessarily the image. <br> *  hBmp            HBITMAP from which to draw the image. <br> *  bmx, bmy        int dimensions of each bitmap in hBmp.  If hBmp is NULL <br> *                  then these are forced to the standard sizes. <br> *  iImage          int index to the image to draw in the button <br> *  uStateIn        UINT containing the state index for the button and the <br> *                  color control bits. <br> * <br> * Return Value: <br> *  BOOL            TRUE if drawing succeeded, FALSE otherwise meaning that <br> *                  hDC is NULL or hBmp is NULL and iImage is not a valid <br> *                  index for a standard image. <br> */ <br> <br>BOOL WINAPI UIToolButtonDraw(HDC hDC, int x, int y, int dx, int dy <br>   , HBITMAP hBmp, int bmx, int bmy, int iImage, UINT uStateIn) <br>   { <br>   return UIToolButtonDrawTDD(hDC, x, y, dx, dy, hBmp, bmx, bmy, iImage <br>      , uStateIn, &amp;tdd); <br>   } <br> <br> <br> <br> <br> <br> <br>/* <br> * UIToolButtonDrawTDD <br> * Public API <br> * <br> * Purpose: <br> *  Draws the complete image of a toolbar-style button with a given <br> *  image in the center and in a specific state.  The button is drawn <br> *  on a specified hDC at a given location, so this function is useful <br> *  on standard owner-draw buttons as well as on toolbar controls that <br> *  have only one window but show images of multiple buttons. <br> * <br> *  This is the same as UIToolButtonDraw but adds the pTDD configuration <br> *  structure.  UIToolButtonDraw calls us with that pointing to the <br> *  default 96dpi structure. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> *  x, y            int coordinates at which to draw. <br> *  dx, dy          int dimensions of the *button*, not necessarily the image. <br> *  hBmp            HBITMAP from which to draw the image. <br> *  bmx, bmy        int dimensions of each bitmap in hBmp.  If hBmp is NULL <br> *                  then these are forced to the standard sizes. <br> *  iImage          int index to the image to draw in the button <br> *  uStateIn        UINT containing the state index for the button and the <br> *                  color control bits. <br> *  pTDD            LPTOOLDISPLAYDATA containing display configuration. <br> *                  Can be NULL if hBmp is non-NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if drawing succeeded, FALSE otherwise meaning that <br> *                  hDC is NULL or hBmp is NULL and iImage is not a valid <br> *                  index for a standard image. <br> */ <br> <br>BOOL WINAPI UIToolButtonDrawTDD(HDC hDC, int x, int y, int dx, int dy <br>   , HBITMAP hBmp, int bmx, int bmy, int iImage, UINT uStateIn <br>   , LPTOOLDISPLAYDATA pTDD) <br>   { <br>   static COLORREF crSys[5];  //Avoid stack arrays in DLLs: use static <br>   UINT            uState=(UINT)LOBYTE((WORD)uStateIn); <br>   UINT            uColors=(UINT)HIBYTE((WORD)uStateIn &amp; PRESERVE_ALL); <br>   int             xOffsetGlyph, yOffsetGlyph; <br>   int             i, iSaveDC; <br>   HDC             hMemDC; <br>   HGDIOBJ         hObj; <br>   HBRUSH          hBR; <br>   HBITMAP         hBmpT; <br>   HBITMAP         hBmpMono; <br>   HBITMAP         hBmpMonoOrg; <br>   HBITMAP         hBmpSave=NULL; <br> <br>   if (NULL==hDC) <br>      return FALSE; <br> <br>   /* <br>    * If we're given no image bitmap, then use the standard and validate the <br>    * image index.  We also enforce the standard bitmap size and the size of <br>    * the button (as requested by User Interface designers). <br>    */ <br>   if (NULL==hBmp &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>      { <br>      hBmp=rghBmpStandardImages[pTDD-&gt;uIDImages-IDB_STANDARDIMAGESMIN]; <br> <br>      bmx=pTDD-&gt;cxImage;            //Force bitmap dimensions <br>      bmy=pTDD-&gt;cyImage; <br> <br>      dx=pTDD-&gt;cxButton;            //Force button dimensions <br>      dy=pTDD-&gt;cyButton; <br> <br>      if (iImage &gt; TOOLIMAGE_MAX) <br>         return FALSE; <br> <br>      /* <br>       * If we are using a standard command button, verify that the state <br>       * does not contain the LIGHTFACE group which only applies to <br>       * attribute buttons. <br>       */ <br>      if (BUTTONTYPE_COMMAND==mpButtonType[iImage] <br>         &amp;&amp; (uState &amp; BUTTONGROUP_LIGHTFACE)) <br>         return FALSE; <br>      } <br> <br>   //Create a dithered bitmap. <br>   hBmpMono=CreateBitmap(dx-2, dy-2, 1, 1, NULL); <br> <br>   if (NULL==hBmpMono) <br>      return FALSE; <br> <br>   hBmpMonoOrg=(HBITMAP)SelectObject(hDCMono,  hBmpMono); <br> <br> <br>   //Save the DC state before we munge on it. <br>   iSaveDC=SaveDC(hDC); <br> <br>   /* <br>    * Draw a button sans image.  This also fills crSys with the system <br>    * colors for us which has space for five colors.  We don't use the <br>    * fifth, the frame color, in this function. <br>    */ <br>   DrawBlankButton(hDC, x, y, dx, dy, (BOOL)(uState &amp; BUTTONGROUP_DOWN), crSys); <br> <br>   //Shift coordinates to account for the button's border <br>   x++; <br>   y++; <br>   dx-=2; <br>   dy-=2; <br> <br>   /* <br>    * Determine the offset necessary to center the image but also reflect <br>    * the pushed-in state, which means just adding 1 to the up state. <br>    */ <br>   i=(uState &amp; BUTTONGROUP_DOWN) ? 1 : 0; <br>   xOffsetGlyph=((dx-bmx) &gt;&gt; 1)+i; <br>   yOffsetGlyph=((dy-bmy) &gt;&gt; 1)+i; <br> <br> <br>   //Select the given image bitmap into the glyph DC before calling MaskCreate <br>   if (NULL!=hBmp) <br>      hBmpSave=(HBITMAP)SelectObject(hDCGlyphs, hBmp); <br> <br> <br>   /* <br>    * Draw the face on the button.  If we have an up or [mouse]down <br>    * button then we can just draw it as-is.  For indeterminate, <br>    * disabled, or down disabled we have to gray the image and possibly <br>    * add a white shadow to it (disabled/down disabled). <br>    * <br>    * Also note that for the intermediate state we first draw the normal <br>    * up state, then proceed to add disabling looking highlights. <br>    */ <br> <br>   //Up, mouse down, down, indeterminate <br>   if ((uState &amp; BUTTONGROUP_ACTIVE) &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>      { <br>      BOOL            fColorsSame=TRUE; <br> <br>      /* <br>       * In here we pay close attention to the system colors.  Where <br>       * the source image is black, we paint COLOR_BTNTEXT.  Where <br>       * light gray, we paint COLOR_BTNFACE.  Where dark gray we paint <br>       * COLOR_BTNSHADOW, and where white we paint COLOR_BTNHILIGHT. <br>       * <br>       * The uColors variable contains flags to prevent color <br>       * conversion.  To do a little optimization, we just do a <br>       * single BitBlt if we're preserving all colors or if no colors <br>       * are different than the standards, which is by far the most <br>       * common case.  Otherwise, cycle through the four colors we can <br>       * convert and do a BitBlt that converts it to the system color. <br>       */ <br> <br>      //See what colors are different. <br>      for (i=STDCOLOR_BLACK; i&lt;=STDCOLOR_WHITE; i++) <br>         fColorsSame &amp;= (crSys[i]==crStandard[i]); <br> <br>      if (PRESERVE_ALL==uColors || fColorsSame) <br>         { <br>         BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, bmx, bmy <br>               , hDCGlyphs, iImage*bmx, 0, SRCCOPY); <br>         } <br>      else <br>         { <br>         /* <br>          * Cycle through hard-coded colors and create a mask that has all <br>          * regions of that color in white and all other regions black. <br>          * Then we select a pattern brush of the color to convert to: <br>          * if we aren't converting the color then we use a brush of <br>          * the standard hard-coded color, otherwise we use the actual <br>          * system color.  The ROP_DSPDxax means that anything that's <br>          * 1's in the mask get the pattern, anything that's 0 is unchanged <br>          * in the destination. <br>          * <br>          * To prevent too many Blts to the screen, we use an intermediate <br>          * bitmap and DC. <br>          */ <br> <br>         hMemDC=CreateCompatibleDC(hDC); <br> <br>         //Make sure conversion of monochrome to color stays B&amp;W <br>         SetTextColor(hMemDC, 0L);                     //0's in mono -&gt; 0 <br>         SetBkColor(hMemDC, (COLORREF)0x00FFFFFF);     //1's in mono -&gt; 1 <br> <br>         hBmpT=CreateCompatibleBitmap(hDC, bmx, bmy); <br>         SelectObject(hMemDC, hBmpT); <br> <br>         //Copy the unmodified bitmap to the temporary bitmap <br>         BitBlt(hMemDC, 0, 0, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY); <br> <br>         for (i=STDCOLOR_BLACK; i&lt;=STDCOLOR_WHITE; i++) <br>            { <br>            //Convert pixels of the color to convert to 1's in the mask <br>            SetBkColor(hDCGlyphs, crStandard[i]); <br>            BitBlt(hDCMono, 0, 0, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY); <br> <br>            //Preserve or modify the color depending on the flag. <br>            hBR=CreateSolidBrush((uColors &amp; (1 &lt;&lt; i)) <br>                            ? crStandard[i] : crSys[i]); <br> <br>            if (NULL!=hBR) <br>               { <br>               hObj=SelectObject(hMemDC, hBR); <br> <br>               if (NULL!=hObj) <br>                  { <br>                  BitBlt(hMemDC, 0, 0, dx-1, dy-1, hDCMono, 0, 0, ROP_DSPDxax); <br>                  SelectObject(hMemDC, hObj); <br>                  } <br> <br>               DeleteObject(hBR); <br>               } <br>            } <br> <br>         //Now put the final version on the display and clean up <br>         BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, dx-1, dy-1 <br>               , hMemDC, 0, 0, SRCCOPY); <br> <br>         DeleteDC(hMemDC); <br>         DeleteObject(hBmpT); <br> <br>         } <br>      } <br> <br> <br>   //Disabled and indeterminate states (unless we're blank) <br>   if ((uState &amp; BUTTONGROUP_DISABLED || ATTRIBUTEBUTTON_INDETERMINATE==uState) <br>      &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>      { <br>      //Grayed state (up or down, no difference) <br>      MaskCreate(iImage, dx, dy, bmx, bmy, xOffsetGlyph, yOffsetGlyph, 0); <br> <br>      //Make sure conversion of monochrome to color stays B&amp;W <br>      SetTextColor(hDC, 0L);                     //0's in mono -&gt; 0 <br>      SetBkColor(hDC, (COLORREF)0x00FFFFFF);     //1's in mono -&gt; 1 <br> <br>      //If we're disabled, up or down, draw the highlighted shadow. <br>      if (uState &amp; BUTTONGROUP_DISABLED) <br>         { <br>         hBR=CreateSolidBrush(crSys[SYSCOLOR_HILIGHT]); <br> <br>         if (NULL!=hBR) <br>            { <br>            hObj=SelectObject(hDC, hBR); <br> <br>            if (NULL!=hObj) <br>               { <br>               //Draw hilight color where we have 0's in the mask <br>               BitBlt(hDC, x+1, y+1, dx-2, dy-2, hDCMono, 0, 0, ROP_PSDPxax); <br>               SelectObject(hDC, hObj); <br>               } <br>            DeleteObject(hBR); <br>            } <br>         } <br> <br>      //Draw the gray image. <br>      hBR=CreateSolidBrush(crSys[SYSCOLOR_SHADOW]); <br> <br>      if (NULL!=hBR) <br>         { <br>         hObj=SelectObject(hDC, hBR); <br> <br>         if (NULL!=hObj) <br>            { <br>            //Draw the shadow color where we have 0's in the mask <br>            BitBlt(hDC, x, y, dx-2, dy-2, hDCMono, 0, 0, ROP_PSDPxax); <br>            SelectObject(hDC, hObj); <br>            } <br> <br>         DeleteObject(hBR); <br>         } <br>      } <br> <br>   //If the button is selected do the dither brush avoiding the glyph <br>   if (uState &amp; BUTTONGROUP_LIGHTFACE) <br>      { <br>      HBRUSH      hBRDither; <br> <br>      /* <br>       * Get the dither brush.  This function will recreate it if <br>       * necessary or return the global one if the colors already match. <br>       */ <br>      hBRDither=HBrushDitherCreate(crSys[SYSCOLOR_FACE], crSys[SYSCOLOR_HILIGHT]); <br>      hObj=SelectObject(hDC, hBRDither); <br> <br>      if (NULL!=hObj) <br>         { <br>         /* <br>          * The mask we create now determines where the dithering <br>          * ends up.  In the down disabled state, we have to preserve <br>          * the highlighted shadow, so the mask we create must have <br>          * two masks of the original glyph, one of them offset by <br>          * one pixel in both x &amp; y.  For the indeterminate state, <br>          * we have to mask all highlighted areas.  The state passed <br>          * to MaskCreate matters here (we've used zero before). <br>          */ <br>         MaskCreate(iImage, dx, dy, bmx, bmy <br>                  , xOffsetGlyph-1, yOffsetGlyph-1, uState); <br> <br>         //Convert monochrome masks to B&amp;W color bitmap in the BitBlt. <br>         SetTextColor(hDC, 0L); <br>         SetBkColor(hDC, (COLORREF)0x00FFFFFF); <br> <br>         /* <br>          * Only draw the dither brush where the mask is 1's.  For <br>          * the indeterminate state we have to not overdraw the <br>          * shadow highlight so we use dx-3, dy-3 instead of dx-1 <br>          * and dy-1.  We do this whether or not we're blank. <br>          */ <br>         i=(ATTRIBUTEBUTTON_INDETERMINATE==uState <br>            || BLANKBUTTON_INDETERMINATE==uState) ? 3 : 1; <br> <br>         BitBlt(hDC, x+1, y+1, dx-i, dy-i, hDCMono, 0, 0, ROP_DSPDxax); <br>         SelectObject(hDC, hObj); <br>         } <br> <br>      //DO NOT delete hBRDither!  It's a reference to a shared global. <br>      } <br> <br>   //Cleanup hDCGlyphs:  Must do AFTER calling MaskCreate <br>   if (NULL!=hBmpSave) <br>      SelectObject(hDCGlyphs, hBmpSave); <br> <br>   SelectObject(hDCMono,   hBmpMonoOrg); <br>   DeleteObject(hBmpMono); <br> <br>   //Restore everything in the DC. <br>   RestoreDC(hDC, iSaveDC); <br>   return TRUE; <br>   } <br> <br> <br> <br> <br> <br> <br>/* <br> * DrawBlankButton <br> * <br> * Purpose: <br> *  Draws a button with no face using the current system colors in either <br> *  an up or down state. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw <br> *  x, y            int coordinates where we start drawing <br> *  dx,dy           int size of the button <br> *  fDown           BOOL indicating the up or down state of the button <br> *  pcr             COLORREF FAR * to five colors in which we store text, <br> *                  shadow, face, highlight, and frame colors.  This is <br> *                  a matter of convenience for the caller, since we have <br> *                  to load these colors anyway we might as well send them <br> *                  back. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>static void DrawBlankButton(HDC hDC, int x, int y, int dx, int dy <br>   , BOOL fDown, COLORREF FAR *pcr) <br>   { <br>   //Get the current system colors for buttons. <br>   pcr[0]=GetSysColor(COLOR_BTNTEXT); <br>   pcr[1]=GetSysColor(COLOR_BTNSHADOW); <br>   pcr[2]=GetSysColor(COLOR_BTNFACE); <br> <br>   //Windows 3.0 doesn't support COLOR_BTNHIGHLIGHT, so leave it white. <br>   if (0x0300 &lt; (UINT)GetVersion()) <br>      pcr[3]=GetSysColor(COLOR_BTNHIGHLIGHT); <br>   else <br>      pcr[3]=crStandard[STDCOLOR_WHITE]; <br> <br>   pcr[4]=GetSysColor(COLOR_WINDOWFRAME); <br> <br>   //Draw the border around the button. <br>   PatB(hDC, x+1,    y,      dx-2, 1,    pcr[4]); <br>   PatB(hDC, x+1,    y+dy-1, dx-2, 1,    pcr[4]); <br>   PatB(hDC, x,      y+1,    1,    dy-2, pcr[4]); <br>   PatB(hDC, x+dx-1, y+1,    1,    dy-2, pcr[4]); <br> <br>   //Shift coordinates to account for the border we just drew <br>   x++; <br>   y++; <br>   dx-=2; <br>   dy-=2; <br> <br>   //Paint the interior grey as a default. <br>   PatB(hDC, x, y, dx, dy, pcr[2]); <br> <br>   /* <br>    * Draw shadows and highlights.  The DOWN grouping that contains <br>    * down, mouse down, and down disabled are drawn depressed.  Up, <br>    * indeterminate, and disabled are drawn up. <br>    */ <br> <br>   if (fDown) <br>      { <br>      PatB(hDC, x, y, 1,  dy, pcr[1]); <br>      PatB(hDC, x, y, dx, 1,  pcr[1]); </code></pre>
<p>
</p>
<pre><code>} <br>   else <br>      { <br>      //Normal button look. <br>      PatB(hDC, x, y, 1,    dy-1, pcr[3]); <br>      PatB(hDC, x, y, dx-1, 1,    pcr[3]); <br> <br>      PatB(hDC, x+dx-1, y,      1,  dy, pcr[1]); <br>      PatB(hDC, x,      y+dy-1, dx, 1,  pcr[1]); <br> <br>      PatB(hDC, x+1+dx-3, y+1,    1,    dy-2, pcr[1]); <br>      PatB(hDC, x+1,      y+dy-2, dx-2, 1,    pcr[1]); <br>      } <br> <br>   return; <br>   } <br> <br> <br> <br> <br> <br> <br>/* <br> * PatB <br> * Internal <br> * <br> * Purpose: <br> *  A more convenient PatBlt operation for drawing button borders and <br> *  highlights. <br> * <br> * Parameters: <br> *  hDC             HDC on which to paint. <br> *  x, y            int coordinates at which to paint. <br> *  dx, dy          int dimensions of rectangle to paint. <br> *  rgb             COLORREF to use as the background color. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>static void PatB(HDC hDC, int x, int y, int dx, int dy, COLORREF rgb) <br>   { <br>   RECT        rc; <br> <br>   SetBkColor(hDC, rgb); <br>   SetRect(&amp;rc, x, y, x+dx, y+dy); <br>   ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, NULL, 0, NULL); <br>   } <br> <br> <br> <br> <br>/* <br> * MaskCreate <br> * Internal <br> * <br> * Purpose: <br> *  Creates a monochrome mask bitmap of the given image at the given offset <br> *  in the global hDCMono.  Anywhere in the image that you have the light <br> *  gray (STDCOLOR_LTGRAY) or the white highlight (STDCOLOR_WHITE) you get <br> *  get 1's.  All other pixels are 0's <br> * <br> * Parameters: <br> *  iImage          UINT index of the image for which to create a mask. <br> *  dx, dy          int dimensions of the button. <br> *  bmx, bmy        int dimensions of the bitmap to use. <br> *  xOffset         int offset for x inside hDCMono where we paint. <br> *  yOffset         int offset for y inside hDCMono where we paint. <br> *  uState          UINT state of the image.  Special cases are made <br> *                  for ATTRIBUTEBUTTON_DOWNDISABLED and <br> *                  ATTRIBUTEBUTTON_INDETERMINATE.  In any case where you <br> *                  do not want a special case, pass zero here, regardless <br> *                  of the true button state. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>static void MaskCreate(UINT iImage, int dx, int dy, int bmx, int bmy <br>   ,int xOffset, int yOffset, UINT uState) <br>   { <br>   //Initalize whole area with zeros <br>   PatBlt(hDCMono, 0, 0, dx, dy, WHITENESS); <br> <br>   if (uState &amp; BUTTONGROUP_BLANK) <br>      return; <br> <br>   //Convert face colored pixels to 1's. all others to black. <br>   SetBkColor(hDCGlyphs, crStandard[STDCOLOR_LTGRAY]); <br>   BitBlt(hDCMono, xOffset, yOffset, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY); <br> <br>   //In the indeterminate state, don't turn highlight's to 1's. Leave black. <br>   if (ATTRIBUTEBUTTON_INDETERMINATE!=uState) <br>      { <br>      //Convert highlight colored pixels to 1's and OR them with the previous. <br>      SetBkColor(hDCGlyphs, crStandard[STDCOLOR_WHITE]); <br>      BitBlt(hDCMono, xOffset, yOffset, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCPAINT); <br>      } <br> <br>   /* <br>    * For the down disabled state, AND this same mask with itself at an <br>    * offset of 1, which accounts for the highlight shadow. <br>    */ <br>   if (ATTRIBUTEBUTTON_DOWNDISABLED==uState) <br>      BitBlt(hDCMono, 1, 1, dx-1, dy-1, hDCMono,  0, 0, SRCAND); <br> <br>   return; <br>   } </code></pre>
<p>&nbsp;</p></body>
</HTML>
