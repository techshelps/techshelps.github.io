<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CURSORS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context155"></a>CURSORS.C</h2>
<pre><code>/* <br> * CURSORS.C <br> * Buttons &amp; Cursors Version 1.1, March 1993 <br> * <br> * Public functions to retrieve new cursors from the BTTNCUR DLL based <br> * on ordinal to prevent applications from necessarily calling LoadCursor <br> * directly on the DLL. <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Rights Reserved, <br> * as applied to redistribution of this source code in source form <br> * License is granted to use of compiled code in shipped binaries. <br> */ <br> <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include "bttncur.h" <br>#include "bttncuri.h" <br> <br> <br>/* <br> * The +1 is because MAX is the highest allowable number and MIN is not <br> * necessarily zero. <br> */ <br>HCURSOR rgHCursors[IDC_NEWUICURSORMAX-IDC_NEWUICURSORMIN+1]; <br> <br> <br> <br>/* <br> * CursorsCache <br> * Internal <br> * <br> * Purpose: <br> *  Loads all the cursors available through NewUICursorLoad into <br> *  a global array.  This way we can clean up all the cursors without <br> *  placing the burden on the application. <br> * <br> * Parameters: <br> *  hInst           HANDLE of the DLL instance. <br> * <br> * Return Value: <br> *  None.  If any of the LoadCursor calls fail, then the corresponding <br> *  array entry is NULL and NewUICursorLoad will fail.  Better to fail <br> *  an app getting a cursor than failing to load the app just for that <br> *  reason; and app can attempt to load the cursor on startup if it's <br> *  that important, and fail itself. <br> */ <br> <br>void CursorsCache(HINSTANCE hInst) <br>        { <br>        UINT            i; <br> <br>        for (i=IDC_NEWUICURSORMIN; i&lt;=IDC_NEWUICURSORMAX; i++) <br>                rgHCursors[i-IDC_NEWUICURSORMIN]=LoadCursor(hInst, MAKEINTRESOURCE(i)); <br> <br>        return; <br>        } <br> <br> <br> <br> <br>/* <br> * CursorsFree <br> * Internal <br> * <br> * Purpose: <br> *  Frees all the cursors previously loaded through CursorsCache. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CursorsFree(void) <br>        { <br>        /* <br>         * Note that since cursors are discardable resources and should <br>         * not be used with DestroyCursor, there's nothing to do here. <br>         * We still provide this API for compatibility and to maintain <br>         * symmetry. <br>         */ <br>        return; <br>        } <br> <br> <br> <br> <br> <br>/* <br> * UICursorLoad <br> * Public API <br> * <br> * Purpose: <br> *  Loads and returns a handle to one of the new standard UI cursors <br> *  contained in UITOOLS.DLL.  The application must not call DestroyCursor <br> *  on this cursor as it is managed by the DLL. <br> * <br> * Parameters: <br> *  iCursor         UINT index to the cursor to load which must be one <br> *                  of the following values: <br> * <br> *                      IDC_RIGHTARROW    Right pointing standard arrow <br> *                      IDC_CONTEXTHELP   Arrow with a ? (context help) <br> *                      IDC_MAGNIFY       Magnifying glass for zooming <br> *                      IDC_NODROP        Circle with a slash <br> *                      IDC_TABLETOP      Small arrow pointing down <br> * <br> *                      IDC_SMALLARROWS   Thin four-headed arrow <br> *                      IDC_LARGEARROWS   Wide four-headed arrow <br> *                      IDC_HARROWS       Horizontal two-headed arrow <br> *                      IDC_VARROWS       Vertical two-headed arrow <br> *                      IDC_NESWARROWS    Two-headed arrow pointing NE&lt;-&gt;SW <br> *                      IDC_NWSEHARROWS   Two-headed arrow pointing NW&lt;-&gt;SE <br> * <br> *                      IDC_HSIZEBAR      Horizontal two-headed arrow with <br> *                                        a single vertical bar down the <br> *                                        middle <br> * <br> *                      IDC_VSIZEBAR      Vertical two-headed arrow with a <br> *                                        single horizontal bar down the <br> *                                        middle <br> * <br> *                      IDC_HSPLITBAR     Horizontal two-headed arrow with <br> *                                        split double vertical bars down the <br> *                                        middle <br> * <br> *                      IDC_VSPLITBAR     Vertical two-headed arrow with split <br> *                                        double horizontal bars down the <br> *                                        middle <br> * <br> * Return Value: <br> *  HCURSOR         Handle to the loaded cursor if successful, NULL <br> *                  if iCursor is out of range or the function could not <br> *                  load the cursor. <br> */ <br> <br>HCURSOR WINAPI UICursorLoad(UINT iCursor) <br>        { <br>        HCURSOR     hCur=NULL; <br> <br>        if ((iCursor &gt;= IDC_NEWUICURSORMIN) &amp;&amp; (iCursor &lt;= IDC_NEWUICURSORMAX)) <br>                hCur=rgHCursors[iCursor-IDC_NEWUICURSORMIN]; <br> <br>        return hCur; <br>        } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
