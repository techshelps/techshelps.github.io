<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context328"></a>APP.CPP</h2>
<pre><code>//********************************************************************** <br>// File name: app.cpp <br>// <br>//    Implementation file for the CSimpleApp Class <br>// <br>// Functions: <br>// <br>//    See app.h for a list of member functions. <br>// <br>// Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>//********************************************************************** <br> <br>#include "pre.h" <br>#include "iocs.h" <br>#include "ias.h" <br>#include "ioipf.h" <br>#include "ioips.h" <br>#include "app.h" <br>#include "site.h" <br>#include "doc.h" <br>#include "stdpal.h" <br> <br>#define cpeAppPal 256  // number of colors in our apps palette <br>typedef struct <br>   { <br>   WORD wVersion; <br>   WORD cpe; <br>   PALETTEENTRY rgpe[cpeAppPal]; <br>   } LOGPAL; <br> <br> <br>//********************************************************************** <br>// <br>// CreateStandardPalette <br>// <br>// Purpose: <br>// <br>//      Creates a standard Apps palette. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>//******************************************************************** <br>HPALETTE CreateStandardPalette(void) <br>   { <br>   HDC hdc; <br>   HPALETTE hpal; <br> <br>   hpal = (HPALETTE) NULL; <br>   hdc = GetDC(NULL); <br>   if (hdc != NULL &amp;&amp; GetDeviceCaps(hdc, RASTERCAPS) &amp; RC_PALETTE) <br>      { <br>      int cpeSysPal; <br>      int cpeReserved; <br> <br>      cpeSysPal = GetDeviceCaps(hdc, SIZEPALETTE); <br>      cpeReserved = GetDeviceCaps(hdc, NUMRESERVED); <br>      if (cpeSysPal &gt; cpeReserved) <br>         { <br>         int cpeReserved2; <br>         unsigned char FAR* lpb; <br>         PALETTEENTRY FAR* ppe; <br>         PALETTEENTRY FAR* ppeMac; <br>         LOGPAL logpal; <br> <br>         cpeReserved2 = cpeReserved/2; <br> <br>         // Get the system palette entries at the beginning and end. <br>         GetSystemPaletteEntries(hdc, 0, cpeReserved2, logpal.rgpe); <br>         GetSystemPaletteEntries(hdc, cpeSysPal - cpeReserved2, cpeReserved2, <br>            &amp;logpal.rgpe[cpeAppPal-cpeReserved2]); <br> <br>         logpal.cpe = cpeAppPal; <br>         logpal.wVersion = 0x300; <br> <br>         lpb = (BYTE FAR *) &amp;palSVGA[10]; <br>         ppe = (PALETTEENTRY FAR*)&amp;logpal.rgpe[cpeReserved2]; <br>         ppeMac = (PALETTEENTRY FAR*)&amp;logpal.rgpe[cpeAppPal-cpeReserved2]; <br>         while (ppe &lt; ppeMac) <br>            { <br>            ppe-&gt;peFlags = PC_NOCOLLAPSE; <br>            ppe-&gt;peRed   = *lpb++; <br>            ppe-&gt;peGreen = *lpb++; <br>            ppe-&gt;peBlue  = *lpb++; <br>            ppe++; <br>            } <br>         hpal = CreatePalette((LOGPALETTE FAR *)&amp;logpal); <br>         } <br>      } <br>   ReleaseDC(NULL, hdc); <br>   return hpal; <br>   } <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::CSimpleApp() <br>// <br>// Purpose: <br>// <br>//      Constructor for CSimpleApp <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      SetRectEmpty                Windows API <br>// <br>// Comments: <br>// <br>//      CSimpleApp has a contained COleInPlaceFrame.  On construction <br>//      of CSimpleApp, we explicitly call the constructor of this <br>//      contained class and pass a copy of the this pointer, so that <br>//      COleInPlaceFrame can refer back to this class <br>// <br>//******************************************************************** <br>#pragma warning(disable : 4355)  // turn off this warning.  This warning <br>                                                                // tells us that we are passing this in <br>                                                                // an initializer, before "this" is through <br>                                                                // initializing.  This is ok, because <br>                                                                // we just store the ptr in the other <br>                                                                // constructor <br> <br>CSimpleApp::CSimpleApp() : m_OleInPlaceFrame(this) <br>#pragma warning (default : 4355)  // Turn the warning back on <br>{ <br>        OutputDebugString("In CSimpleApp's Constructor \r\n"); <br> <br>        // clear members <br>        m_hAppWnd = NULL; <br>        m_hInst = NULL; <br>        m_lpDoc = NULL; <br>    m_hwndUIActiveObj = NULL; <br> <br>        // clear flags <br>        m_fInitialized = FALSE; <br>        m_fCSHMode = FALSE; <br>        m_fMenuMode = FALSE; <br> <br>        // used for inplace <br>        SetRectEmpty(&amp;nullRect); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::~CSimpleApp() <br>// <br>// Purpose: <br>// <br>//      Destructor for CSimpleApp Class. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      OleUninitialize             OLE API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>CSimpleApp::~CSimpleApp() <br>{ <br>        OutputDebugString("In CSimpleApp's Destructor\r\n"); <br> <br>        if (m_hStdPal) <br>                DeleteObject(m_hStdPal); <br> <br>        // need to uninit the library... <br>        if (m_fInitialized) <br>                OleUninitialize(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::DestroyDocs() <br>// <br>// Purpose: <br>// <br>//      Destroys all of the open documents in the application (Only one <br>//      since this is an SDI app, but could easily be modified to <br>//      support MDI). <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>void CSimpleApp::DestroyDocs() <br>{ <br>        CStabilize stabilize(this); <br>        m_lpDoc-&gt;Close();   // we have only 1 document <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::QueryInterface <br>// <br>// Purpose: <br>// <br>//      Used for interface negotiation at the Frame level. <br>// <br>// Parameters: <br>// <br>//      REFIID riid         -   A reference to the interface that is <br>//                              being queried. <br>// <br>//      LPVOID FAR* ppvObj  -   An out parameter to return a pointer to <br>//                              the interface. <br>// <br>// Return Value: <br>// <br>//      S_OK    -   The interface is supported. <br>//      S_FALSE -   The interface is not supported <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>//      IsEqualIID                  OLE API <br>//                   OLE API <br>//      COleInPlaceFrame::AddRef    IOIPF.CPP <br>// <br>// Comments: <br>// <br>//      Note that this QueryInterface is associated with the frame. <br>//      Since the application could potentially have multiple documents <br>//      and multiple objects, a lot of the interfaces are ambiguous. <br>//      (ie. which IOleObject is returned?).  For this reason, only <br>//      pointers to interfaces associated with the frame are returned. <br>//      In this implementation, Only IOleInPlaceFrame (or one of the <br>//      interfaces it is derived from) can be returned. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP CSimpleApp::QueryInterface(REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>        OutputDebugString("In CSimpleApp::QueryInterface\r\n"); <br> <br>        *ppvObj = NULL;     // must set out pointer parameters to NULL <br> <br>        // looking for IUnknown <br>        if ( riid == IID_IUnknown) <br>                { <br>                AddRef(); <br>                *ppvObj = this; <br>                return S_OK; <br>                } <br> <br>        // looking for IOleWindow <br>        if ( riid == IID_IOleWindow) <br>                { <br>                m_OleInPlaceFrame.AddRef(); <br>                *ppvObj=&amp;m_OleInPlaceFrame; <br>                return S_OK; <br>                } <br> <br>        // looking for IOleInPlaceUIWindow <br>        if ( riid == IID_IOleInPlaceUIWindow) <br>                { <br>                m_OleInPlaceFrame.AddRef(); <br>                *ppvObj=&amp;m_OleInPlaceFrame; <br>                return S_OK; <br>                } <br> <br>        // looking for IOleInPlaceFrame <br>        if ( riid == IID_IOleInPlaceFrame) <br>                { <br>                m_OleInPlaceFrame.AddRef(); <br>                *ppvObj=&amp;m_OleInPlaceFrame; <br>                return S_OK; <br>                } <br> <br>        // Not a supported interface <br>        return E_NOINTERFACE; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::AddRef <br>// <br>// Purpose: <br>// <br>//      Adds to the reference count at the Application level. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the application. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//      Due to the reference counting model that is used in this <br>//      implementation, this reference count is the sum of the <br>//      reference counts on all interfaces of all objects open <br>//      in the application. <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpleApp::AddRef() <br>{ <br>        OutputDebugString("In CSimpleApp::AddRef\r\n"); <br>        return SafeAddRef(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::Release <br>// <br>// Purpose: <br>// <br>//      Decrements the reference count at this level <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      ULONG   -   The new reference count of the application. <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      OutputDebugString           Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>STDMETHODIMP_(ULONG) CSimpleApp::Release() <br>{ <br>        OutputDebugString("In CSimpleApp::Release\r\n"); <br> <br>        return SafeRelease(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::fInitApplication <br>// <br>// Purpose: <br>// <br>//      Initializes the application <br>// <br>// Parameters: <br>// <br>//      HANDLE hInstance    -   Instance handle of the application. <br>// <br>// Return Value: <br>// <br>//      TRUE    -   Application was successfully initialized. <br>//      FALSE   -   Application could not be initialized <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      LoadIcon                    Windows API <br>//      LoadCursor                  Windows API <br>//      GetStockObject              Windows API <br>//      RegisterClass               Windows API <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>BOOL CSimpleApp::fInitApplication(HANDLE hInstance) <br>{ <br>        WNDCLASS  wc; <br> <br>        // Fill in window class structure with parameters that describe the <br>        // main window. <br> <br>        wc.style = NULL;                    // Class style(s). <br>        wc.lpfnWndProc = MainWndProc;       // Function to retrieve messages for <br>                                                                                // windows of this class. <br>        wc.cbClsExtra = 0;                  // No per-class extra data. <br>        wc.cbWndExtra = 0;                  // No per-window extra data. <br>        wc.hInstance = (HINSTANCE) hInstance; // Application that owns the class. <br>        wc.hIcon = LoadIcon((HINSTANCE) hInstance, "SimpCntr"); <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); <br>        wc.lpszMenuName =  "SIMPLEMENU";    // Name of menu resource in .RC file. <br>        wc.lpszClassName = "SimpCntrAppWClass";  // Name used in CreateWindow call <br> <br>        if (!RegisterClass(&amp;wc)) <br>                return FALSE; <br> <br>        wc.style = CS_DBLCLKS;              // Class style(s). allow DBLCLK's <br>        wc.lpfnWndProc = DocWndProc;        // Function to retrieve messages for <br>                                                                                // windows of this class. <br>        wc.cbClsExtra = 0;                  // No per-class extra data. <br>        wc.cbWndExtra = 0;                  // No per-window extra data. <br>        wc.hInstance = (HINSTANCE) hInstance;           // Application that owns the class. <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH) GetStockObject(WHITE_BRUSH); <br>        wc.lpszMenuName =  NULL; <br>        wc.lpszClassName = "SimpCntrDocWClass"; // Name used in CreateWindow call. <br> <br>        // Register the window class and return success/failure code. <br> <br>        return (RegisterClass(&amp;wc)); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::fInitInstance <br>// <br>// Purpose: <br>// <br>//      Instance initialization. <br>// <br>// Parameters: <br>// <br>//      HANDLE hInstance    -   App. Instance Handle. <br>// <br>//      int nCmdShow        -   Show parameter from WinMain <br>// <br>// Return Value: <br>// <br>//      TRUE    -   Initialization Successful <br>//      FALSE   -   Initialization Failed. <br>// <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      CreateWindow                Windows API <br>//      ShowWindow                  Windows API <br>//      UpdateWindow                Windows API <br>//      OleBuildVersion             OLE API <br>//      OleInitialize               OLE API <br>// <br>// Comments: <br>// <br>//      Note that successful Initalization of the OLE libraries <br>//      is remembered so the UnInit is only called if needed. <br>// <br>//******************************************************************** <br> <br>BOOL CSimpleApp::fInitInstance (HANDLE hInstance, int nCmdShow) <br>{ <br>        DWORD dwVer = OleBuildVersion(); <br>        LPMALLOC lpMalloc = NULL; <br> <br>        // check to see if we are compatible with this version of the libraries <br>        if (HIWORD(dwVer) != rmm || LOWORD(dwVer) &lt; rup) { <br>#ifdef _DEBUG <br>                OutputDebugString("WARNING: Incompatible OLE library version\r\n"); <br>#else <br>                return FALSE; <br>#endif <br>        } <br> <br>        if (SUCCEEDED(OleInitialize(lpMalloc))) <br>        { <br>                m_fInitialized = TRUE; <br>        } <br>        else <br>        { <br>            // Replacing the standard allocator may not be legal. <br>            // Try again using the default allocator. <br>            if (SUCCEEDED(OleInitialize(NULL))) <br>            { <br>                m_fInitialized = TRUE; <br>            } <br>        } <br> <br>        m_hInst = (HINSTANCE) hInstance; <br> <br>        // Create the "application" windows <br>        m_hAppWnd = CreateWindow ("SimpCntrAppWClass", <br>                                                          "Simple OLE 2.0 In-Place Container", <br>                                                          WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>                                                          CW_USEDEFAULT, <br>                                                          CW_USEDEFAULT, <br>                                                          CW_USEDEFAULT, <br>                                                          CW_USEDEFAULT, <br>                                                          NULL, <br>                                                          NULL, <br>                                                          (HINSTANCE) hInstance, <br>                                                          NULL); <br> <br>        if (!m_hAppWnd) <br>                return FALSE; <br> <br>        m_hStdPal = CreateStandardPalette(); <br> <br>        ShowWindow (m_hAppWnd, nCmdShow); <br>        UpdateWindow (m_hAppWnd); <br> <br>        return m_fInitialized; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::lCommandHandler <br>// <br>// Purpose: <br>// <br>//      Handles the processing of WM_COMMAND. <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       -   Handle to the application Window <br>// <br>//      UINT message    -   message (always WM_COMMAND) <br>// <br>//      WPARAM wParam   -   Same as passed to the WndProc <br>// <br>//      LPARAM lParam   -   Same as passed to the WndProc <br>// <br>// Return Value: <br>// <br>//      NULL <br>// <br>// Function Calls: <br>//      Function                                    Location <br>// <br>//      IOleInPlaceActiveObject::QueryInterface     Object <br>//      IOleInPlaceObject::ContextSensitiveHelp     Object <br>//      IOleInPlaceObject::Release                  Object <br>//      IOleObject::DoVerb                          Object <br>//      GetClientRect                               Windows API <br>//      MessageBox                                  Windows API <br>//      DialogBox                                   Windows API <br>//      MakeProcInstance                            Windows API <br>//      FreeProcInstance                            Windows API <br>//      SendMessage                                 Windows API <br>//      DefWindowProc                               Windows API <br>//      CSimpleDoc::InsertObject                    DOC.CPP <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>long CSimpleApp::lCommandHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>        CStabilize stabilize(this); <br>        RECT rect; <br> <br>        // context sensitive help... <br>        if (m_fMenuMode || m_fCSHMode) <br>                { <br>                if (m_fCSHMode) <br>                        { <br>                        // clear context sensitive help flag <br>                        m_fCSHMode = FALSE; <br> <br>                        // if there is an InPlace active object, call its context sensitive help <br>                        // method with the FALSE parameter to bring the object out of the <br>                        // csh state.  See the technotes for details. <br>                        if (m_lpDoc-&gt;m_lpActiveObject) <br>                                { <br>                                LPOLEINPLACEOBJECT lpInPlaceObject; <br>                                m_lpDoc-&gt;m_lpActiveObject-&gt;QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&amp;lpInPlaceObject); <br>                                lpInPlaceObject-&gt;ContextSensitiveHelp(FALSE); <br>                                lpInPlaceObject-&gt;Release(); <br>                                } <br>                        } <br> <br>                // see the technotes for details on implementing context sensitive <br>                // help <br>                if (m_fMenuMode) <br>                        { <br>                        m_fMenuMode = FALSE; <br> <br>                        if (m_lpDoc-&gt;m_lpActiveObject) <br>                                m_lpDoc-&gt;m_lpActiveObject-&gt;ContextSensitiveHelp(FALSE); <br>                        } <br>                // if we provided help, we would do it here... <br>                MessageBox (hWnd, "Help", "Help", MB_OK); <br> <br>                return NULL; <br>                } <br> <br>        // see if the command is a verb selections <br>        //@@WTK WIN32, UNICODE <br>        //if (wParam &gt;= IDM_VERB0) <br>        if (LOWORD(wParam) &gt;= IDM_VERB0) <br>                { <br>                // get the rectangle of the object <br>                m_lpDoc-&gt;m_lpSite-&gt;GetObjRect(&amp;rect); <br> <br>                //@@WTK WIN32, UNICODE <br>                //m_lpDoc-&gt;m_lpSite-&gt;m_lpOleObject-&gt;DoVerb(wParam - IDM_VERB0, NULL, &amp;m_lpDoc-&gt;m_lpSite-&gt;m_OleClientSite, -1, m_lpDoc-&gt;m_hDocWnd, &amp;rect); <br>                m_lpDoc-&gt;m_lpSite-&gt;m_lpOleObject-&gt;DoVerb(LOWORD(wParam) - IDM_VERB0, NULL, <br>                                &amp;m_lpDoc-&gt;m_lpSite-&gt;m_OleClientSite, -1, m_lpDoc-&gt;m_hDocWnd, &amp;rect); <br>                } <br>        else <br>                { <br>                //@@WTK WIN32, UNICODE <br>                //switch (wParam) { <br>                switch (LOWORD(wParam)) { <br>                        // bring up the About box <br>                        case IDM_ABOUT: <br>                                { <br> <br>                                DialogBox(m_hInst,               // current instance <br>                                        "AboutBox",                  // resource to use <br>                                        m_hAppWnd,                   // parent handle <br>                                        (DLGPROC) About);                // About() instance address <br> <br>                                break; <br>                                } <br> <br>                        // bring up the InsertObject Dialog <br>                        case IDM_INSERTOBJECT: <br>                                m_lpDoc-&gt;InsertObject(); <br>                                break; <br> <br>                        // exit the application <br>                        case IDM_EXIT: <br>                                SendMessage(hWnd, WM_SYSCOMMAND, SC_CLOSE, 0L); <br>                                break; <br> <br>                        case IDM_NEW: <br>                                m_lpDoc-&gt;Close(); <br>                                m_lpDoc = NULL; <br>                                lCreateDoc(hWnd, 0, 0, 0); <br>                                break; <br> <br>                        default: <br>                                return (DefWindowProc(hWnd, message, wParam, lParam)); <br>                        }   // end of switch <br>                }  // end of else <br>        return NULL; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::lSizeHandler <br>// <br>// Purpose: <br>// <br>//      Handles the WM_SIZE message <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       -   Handle to the application Window <br>// <br>//      UINT message    -   message (always WM_SIZE) <br>// <br>//      WPARAM wParam   -   Same as passed to the WndProc <br>// <br>//      LPARAM lParam   -   Same as passed to the WndProc <br>// <br>// Return Value: <br>// <br>//      LONG    -   returned from the "document" resizing <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      GetClientRect               Windows API <br>//      CSimpleDoc::lResizeDoc      DOC.CPP <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>long CSimpleApp::lSizeHandler (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>        CStabilize stabilize(this); <br>        RECT rect; <br> <br>        GetClientRect(m_hAppWnd, &amp;rect); <br>        return m_lpDoc-&gt;lResizeDoc(&amp;rect); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::lCreateDoc <br>// <br>// Purpose: <br>// <br>//      Handles the creation of a document. <br>// <br>// Parameters: <br>// <br>//      HWND hWnd       -   Handle to the application Window <br>// <br>//      UINT message    -   message (always WM_CREATE) <br>// <br>//      WPARAM wParam   -   Same as passed to the WndProc <br>// <br>//      LPARAM lParam   -   Same as passed to the WndProc <br>// <br>// Return Value: <br>// <br>//      NULL <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      GetClientRect               Windows API <br>//      CSimpleDoc::CSimpleDoc      DOC.CPP <br>// <br>// Comments: <br>// <br>//******************************************************************** <br> <br>long CSimpleApp::lCreateDoc (HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>        CStabilize stabilize(this); <br>        RECT rect; <br> <br>        GetClientRect(hWnd, &amp;rect); <br> <br>        m_lpDoc = CSimpleDoc::Create(this, &amp;rect, hWnd); <br> <br>        return NULL; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::AddFrameLevelUI <br>// <br>// Purpose: <br>// <br>//      Used during InPlace negotiation. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                            Location <br>// <br>//      COleInPlaceFrame::SetMenu           IOIPF.CPP <br>//      CSimpleApp::AddFrameLevelTools      APP.CPP <br>// <br>// Comments: <br>// <br>//      Be sure to read the Technotes included in the OLE 2.0 toolkit <br>// <br>//******************************************************************** <br> <br>void CSimpleApp::AddFrameLevelUI() <br>{ <br>        CStabilize stabilize(this); <br>        m_OleInPlaceFrame.SetMenu(NULL, NULL, NULL); <br>        AddFrameLevelTools(); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::AddFrameLevelTools <br>// <br>// Purpose: <br>// <br>//      Used during InPlace negotiation. <br>// <br>// Parameters: <br>// <br>//      None <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                              Location <br>// <br>//      COleInPlaceFrame::SetBorderSpace      IOIPF.CPP <br>//      InvalidateRect                        Windows API <br>// <br>// Comments: <br>// <br>//      Be sure to read the Technotes included in the OLE 2.0 toolkit <br>// <br>//******************************************************************** <br> <br>void CSimpleApp::AddFrameLevelTools() <br>{ <br>        CStabilize stabilize(this); <br>        m_OleInPlaceFrame.SetBorderSpace(&amp;nullRect); <br>        InvalidateRect(m_hAppWnd, NULL, TRUE); <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::HandleAccelerators <br>// <br>// Purpose: <br>// <br>//      To properly handle accelerators in the Message Loop <br>// <br>// Parameters: <br>// <br>//      LPMSG lpMsg -   A pointer to the message structure. <br>// <br>// Return Value: <br>// <br>//      TRUE    -   The accelerator was handled <br>//      FALSE   -   The accelerator was not handled <br>// <br>// Function Calls: <br>//      Function                                        Location <br>// <br>//      IOleInPlaceActiveObject::TranslateAccelerator   Object <br>// <br>// Comments: <br>// <br>//      If an object is InPlace active, it gets the first shot at <br>//      handling the accelerators. <br>// <br>//******************************************************************** <br> <br>BOOL CSimpleApp::HandleAccelerators(LPMSG lpMsg) <br>{ <br>        CStabilize stabilize(this); <br>        HRESULT hResult; <br>        BOOL retval = FALSE; <br> <br>        // if we have an InPlace Active Object <br>        if (m_lpDoc-&gt;m_lpActiveObject) <br>                { <br>                // Pass the accelerator on... <br>                hResult = m_lpDoc-&gt;m_lpActiveObject-&gt;TranslateAccelerator(lpMsg); <br>                if (hResult == NOERROR) <br>                        retval = TRUE; <br>                } <br> <br>        return retval; <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::PaintApp <br>// <br>// Purpose: <br>// <br>//      Handles the painting of the doc window. <br>// <br>// <br>// Parameters: <br>// <br>//      HDC hDC -   hDC to the Doc Window. <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                    Location <br>// <br>//      CSimpleDoc::PaintDoc        DOC.CPP <br>// <br>// Comments: <br>// <br>//      This is an app level function in case we want to do palette <br>//      management. <br>// <br>//******************************************************************** <br> <br>void CSimpleApp::PaintApp (HDC hDC) <br>{ <br>        CStabilize stabilize(this); <br>        // at this level, we could enumerate through all of the <br>        // visible objects in the application, so that a palette <br>        // that best fits all of the objects can be built. <br> <br>        // This app is designed to take on the same palette <br>        // functionality that was provided in OLE 1.0, the palette <br>        // of the last object drawn is realized.  Since we only <br>        // support one object at a time, it shouldn't be a big <br>        // deal. <br> <br>        // if we supported multiple documents, we would enumerate <br>        // through each of the open documents and call paint. <br> <br>        if (m_lpDoc) <br>                m_lpDoc-&gt;PaintDoc(hDC); <br> <br>} <br> <br>//********************************************************************** <br>// <br>// CSimpleApp::ContextSensitiveHelp <br>// <br>// Purpose: <br>//      Used in supporting context sensitive haelp at the app level. <br>// <br>// <br>// Parameters: <br>// <br>//      BOOL fEnterMode    -   Entering/Exiting Context Sensitive <br>//                             help mode. <br>// <br>// Return Value: <br>// <br>//      None <br>// <br>// Function Calls: <br>//      Function                                    Location <br>// <br>//      IOleInPlaceActiveObject::QueryInterface     Object <br>//      IOleInPlaceObject::ContextSensitiveHelp     Object <br>//      IOleInPlaceObject::Release                  Object <br>// <br>// Comments: <br>// <br>//      This function isn't used because we don't support Shift+F1 <br>//      context sensitive help.  Be sure to look at the technotes <br>//      in the OLE 2.0 toolkit. <br>// <br>//******************************************************************** <br> <br>void CSimpleApp::ContextSensitiveHelp (BOOL fEnterMode) <br>{ <br>        CStabilize stabilize(this); <br>        if (m_fCSHMode != fEnterMode) <br>                { <br>                m_fCSHMode = fEnterMode; <br> <br>                // this code "trickles" the context sensitive help via shift+f1 <br>                // to the inplace active object.  See the technotes for implementation <br>                // details. <br>                if (m_lpDoc-&gt;m_lpActiveObject) <br>                        { <br>                        LPOLEINPLACEOBJECT lpInPlaceObject; <br>                        m_lpDoc-&gt;m_lpActiveObject-&gt;QueryInterface(IID_IOleInPlaceObject, (LPVOID FAR *)&amp;lpInPlaceObject); </code></pre>
<p>
</p>
<pre><code>lpInPlaceObject-&gt;ContextSensitiveHelp(fEnterMode); <br>                        lpInPlaceObject-&gt;Release(); <br>                        } <br>                } <br>} <br> <br> <br>/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via <br>**    SendMessage) to UIActive in-place object if there is one. <br>**    this gives the UIActive object the opportunity to select <br>**    and realize its color palette as the FOREGROUND palette. <br>**    this is optional for in-place containers. if a container <br>**    prefers to force its color palette as the foreground <br>**    palette then it should NOT forward the this message. or <br>**    the container can give the UIActive object priority; if <br>**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE <br>**    message (ie. it did not realize its own palette), then <br>**    the container can realize its palette. <br>**    (see ContainerDoc_ForwardPaletteChangedMsg for more info) <br>** <br>**    (It is a good idea for containers to use the standard <br>**    palette even if they do not use colors themselves. this <br>**    will allow embedded object to get a good distribution of <br>**    colors when they are being drawn by the container) <br>** <br>*/ <br> <br>LRESULT CSimpleApp::QueryNewPalette(void) <br>{ <br>        if (m_hwndUIActiveObj) { <br>                if (SendMessage(m_hwndUIActiveObj, WM_QUERYNEWPALETTE, <br>                                (WPARAM)0, (LPARAM)0)) { <br>                        /* Object selected its palette as foreground palette */ <br>                        return (LRESULT)1; <br>                } <br>        } <br> <br>        return wSelectPalette(m_hAppWnd, m_hStdPal, FALSE/*fBackground*/); <br>} <br> <br> <br>/* This is just a helper routine */ <br> <br>LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground) <br>{ <br>        HDC hdc; <br>        HPALETTE hOldPal; <br>        UINT iPalChg = 0; <br> <br>        if (hPal == 0) <br>                return (LRESULT)0; <br> <br>        hdc = GetDC(hWnd); <br>        hOldPal = SelectPalette(hdc, hPal, fBackground); <br>        iPalChg = RealizePalette(hdc); <br>        SelectPalette(hdc, hOldPal, TRUE /*fBackground*/); <br>        ReleaseDC(hWnd, hdc); <br> <br>        if (iPalChg &gt; 0) <br>                InvalidateRect(hWnd, NULL, TRUE); <br> <br>        return (LRESULT)1; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
