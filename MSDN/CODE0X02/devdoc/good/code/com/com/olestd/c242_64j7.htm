<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MALSPY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context253"></a>MALSPY.C</h2>
<pre><code>//+--------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright (C) Microsoft Corporation, 1994 - 1996. <br>// <br>//  File:       cmallspy.c <br>// <br>//  Contents:   Sample implementation of IMallocSpy.  The implementation here <br>//              is pretty simple.  It assumes that all we want to do is keep <br>//              a header on the front of all allocations so we can note <br>//              interesting information. <br>// <br>//  Classes:    CMallocSpy <br>// <br>//---------------------------------------------------------------------- <br> <br>#include &lt;ole2.h&gt; <br>#include &lt;olestd.h&gt; <br> <br>OLEDBGDATA <br> <br>#include "malspy.h" <br> <br>#define TOKEN 0xDEAD <br> <br>typedef struct tagHeader <br>{ <br>    UINT    uiTag; <br>    ULONG   cbSize; <br>} HEADER, * LPHEADER; <br> <br>// The following macro is used to ensure that the token placed at the <br>// end of each memory block is always aligned on a dword boundary. <br>// This is necessary to avoid alignment faults on some systems. <br>#define DWORDALIGN(x) ((x + 3) &amp; (~3)) <br> <br>typedef struct CMallocSpy { <br>  IMallocSpyVtbl FAR*     lpVtbl; <br>  ULONG                   m_cRef;   // interface specific ref count. <br>  ULONG                   m_cbRequested; <br>} CMALLOCSPY, *LPCMALLOCSPY; <br> <br>STDMETHODIMP MallocSpy_QueryInterface( <br>      LPMALLOCSPY             this, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpUnk); <br> <br>STDMETHODIMP_(ULONG) MallocSpy_AddRef( <br>    LPMALLOCSPY this); <br> <br>STDMETHODIMP_(ULONG) MallocSpy_Release( <br>    LPMALLOCSPY this); <br> <br>STDMETHODIMP_(ULONG) MallocSpy_PreAlloc( <br>    LPMALLOCSPY this, <br>    ULONG cbRequest); <br> <br>STDMETHODIMP_(void *) MallocSpy_PostAlloc( <br>    LPMALLOCSPY this, <br>    void *pActual); <br> <br>STDMETHODIMP_(void *) MallocSpy_PreFree( <br>    LPMALLOCSPY this, <br>    void *pRequest, BOOL fSpyed); <br> <br>STDMETHODIMP_(void) MallocSpy_PostFree( <br>    LPMALLOCSPY this, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(ULONG) MallocSpy_PreRealloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    ULONG cbRequest, <br>    void **ppNewRequest, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(void *) MallocSpy_PostRealloc( <br>    LPMALLOCSPY this, <br>    void *pActual, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(void *) MallocSpy_PreGetSize( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(ULONG) MallocSpy_PostGetSize( <br>    LPMALLOCSPY this, <br>    ULONG cbActual, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(void *) MallocSpy_PreDidAlloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed); <br> <br>STDMETHODIMP_(BOOL) MallocSpy_PostDidAlloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed, <br>    BOOL fActual); <br> <br>STDMETHODIMP_(void) MallocSpy_PreHeapMinimize( <br>    LPMALLOCSPY this); <br> <br>STDMETHODIMP_(void) MallocSpy_PostHeapMinimize( <br>    LPMALLOCSPY this); <br> <br> <br>IMallocSpyVtbl g_MallocSpyVtbl; <br> <br>BOOL InitializeMallocSpy(void) <br>{ <br>    BOOL fStatus; <br>    LPCMALLOCSPY lpcMallocSpy = NULL; <br>    HRESULT hr; <br> <br>    OleStdInitVtbl( <br>          &amp;g_MallocSpyVtbl, <br>          sizeof(g_MallocSpyVtbl)); <br> <br>    g_MallocSpyVtbl.QueryInterface      = MallocSpy_QueryInterface; <br>    g_MallocSpyVtbl.AddRef              = MallocSpy_AddRef; <br>    g_MallocSpyVtbl.Release             = MallocSpy_Release; <br>    g_MallocSpyVtbl.PreAlloc            = MallocSpy_PreAlloc; <br>    g_MallocSpyVtbl.PostAlloc           = MallocSpy_PostAlloc; <br>    g_MallocSpyVtbl.PreFree             = MallocSpy_PreFree; <br>    g_MallocSpyVtbl.PostFree            = MallocSpy_PostFree; <br>    g_MallocSpyVtbl.PreRealloc          = MallocSpy_PreRealloc; <br>    g_MallocSpyVtbl.PostRealloc         = MallocSpy_PostRealloc; <br>    g_MallocSpyVtbl.PreGetSize          = MallocSpy_PreGetSize; <br>    g_MallocSpyVtbl.PostGetSize         = MallocSpy_PostGetSize; <br>    g_MallocSpyVtbl.PreDidAlloc         = MallocSpy_PreDidAlloc; <br>    g_MallocSpyVtbl.PostDidAlloc        = MallocSpy_PostDidAlloc; <br>    g_MallocSpyVtbl.PreHeapMinimize     = MallocSpy_PreHeapMinimize; <br>    g_MallocSpyVtbl.PostHeapMinimize    = MallocSpy_PostHeapMinimize; <br> <br>    fStatus = OleStdCheckVtbl( <br>          &amp;g_MallocSpyVtbl, <br>          sizeof(g_MallocSpyVtbl), <br>          OLESTR("IMallocSpy")); <br>    if (! fStatus) <br>        return FALSE; <br> <br>    lpcMallocSpy = malloc(sizeof(CMALLOCSPY)); <br> <br>    if (NULL == lpcMallocSpy) <br>    { <br>        return FALSE; <br>    } <br>    lpcMallocSpy-&gt;lpVtbl = &amp;g_MallocSpyVtbl; <br>    lpcMallocSpy-&gt;m_cRef = 0; <br> <br>    hr = CoRegisterMallocSpy((LPMALLOCSPY)lpcMallocSpy); <br> <br>    return(SUCCEEDED(hr)); <br>} <br> <br>void UninitializeMallocSpy() <br>{ <br>    CoRevokeMallocSpy(); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CbUserFromCbActual <br>// <br>//  Synopsis:   adjusts the size to account for the header and footer <br>// <br>//  Arguments:  [cbActual] - actual size of the memory block <br>// <br>//  Returns:    size reported to the user <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG CbUserFromCbActual(ULONG cbActual) <br>{ <br>    return(cbActual - (sizeof(HEADER) + sizeof(UINT))); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CbActualFromCbUser <br>// <br>//  Synopsis:   adjusts the size to account for the header and footer <br>// <br>//  Arguments:  [cbUser] - size reported to the user <br>// <br>//  Returns:    actual size of the memory block <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG CbActualFromCbUser(ULONG cbUser) <br>{ <br>    return(DWORDALIGN(cbUser) + sizeof(HEADER) + sizeof(UINT)); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   PActualFromPUser <br>// <br>//  Synopsis:   adjusts the pointer to account for the header, verifying <br>//              the memory integrity in the process <br>// <br>//  Arguments:  [pUser] - pointer reported to the user <br>// <br>//  Returns:    acutal pointer to the memory block <br>// <br>//---------------------------------------------------------------------------- <br> <br>void * PActualFromPUser(void * pUser) <br>{ <br>    HEADER * pHeader; <br>    UINT * puiFooter; <br>    pHeader = ((LPHEADER)pUser) - 1; <br>    puiFooter = (UINT *)(((BYTE *)pUser) + DWORDALIGN(pHeader-&gt;cbSize)); <br> <br>    OleDbgAssertSz(TOKEN == pHeader-&gt;uiTag, "Illegal memory block."); <br>    OleDbgAssertSz(TOKEN == *puiFooter, "Memory block was overrun."); <br> <br>    if (TOKEN != pHeader-&gt;uiTag) <br>    { <br>        // Just to be safe, if we don't find the TOKEN we'll not adjust the <br>        // pointer <br>        return(pUser); <br>    } <br>    return ((void *) (pHeader)); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   PUserFromPActual <br>// <br>//  Synopsis:   adjusts the pointer to account for the header, initializing <br>//              the header and footer in the process to allow verification of <br>//              memory integrity <br>// <br>//  Arguments:  [pActual]    - actual pointer to the memory block <br>//              [cbDataSize] - size of the memory block requested by the user <br>// <br>//  Returns:    pointer to the data which the user may modify <br>// <br>//---------------------------------------------------------------------------- <br> <br>void * PUserFromPActual(void * pActual, ULONG cbDataSize) <br>{ <br>    // Mark the block with a TOKEN at the front and the end <br>    // and its size so we can tell if it is bogus <br>    LPHEADER pHeader = pActual; <br>    UINT* puiFooter; <br> <br>    pHeader-&gt;uiTag = TOKEN; <br>    pHeader-&gt;cbSize = cbDataSize; <br> <br>    pActual = (void *)(pHeader + 1); <br> <br>    puiFooter = (UINT *)(((BYTE *) pActual) + DWORDALIGN(pHeader-&gt;cbSize)); <br>    *puiFooter = TOKEN; <br>    return(pActual); <br>} <br> <br>STDMETHODIMP MallocSpy_QueryInterface( <br>      LPMALLOCSPY  this, <br>      REFIID riid, <br>      LPVOID *                ppUnk) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (IsEqualIID(riid, &amp;IID_IUnknown) || IsEqualIID(riid, &amp;IID_IMallocSpy)) <br>    { <br>        *ppUnk = this; <br>    } <br>    else <br>    { <br>        *ppUnk = NULL; <br>        hr =  E_NOINTERFACE; <br>    } <br>    this-&gt;lpVtbl-&gt;AddRef((LPMALLOCSPY)this); <br>    return hr; <br>} <br> <br>STDMETHODIMP_(ULONG) MallocSpy_AddRef( <br>    LPMALLOCSPY this) <br>{ <br>    return ++(((LPCMALLOCSPY)this)-&gt;m_cRef); <br>} <br> <br>STDMETHODIMP_(ULONG) MallocSpy_Release( <br>    LPMALLOCSPY this) <br>{ <br>    ULONG cRef; <br> <br>    cRef = --(((LPCMALLOCSPY)this)-&gt;m_cRef); <br>    if (cRef == 0) <br>    { <br>        free(this); <br>    } <br>    return cRef; <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreAlloc <br>// <br>//  Synopsis:   Called prior to OLE calling IMalloc::Alloc <br>// <br>//  Arguments:  [cbRequest] -- The number of bytes the caller of <br>//                             is requesting IMalloc::Alloc <br>// <br>//  Returns:    The count of bytes to actually allocate <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) MallocSpy_PreAlloc( <br>    LPMALLOCSPY this, <br>    ULONG cbRequest) <br>{ <br>    ((LPCMALLOCSPY)this)-&gt;m_cbRequested = cbRequest; <br>    return CbActualFromCbUser(cbRequest); <br>} <br> <br>#ifdef TRACEMEM <br>char szScratch[256]; <br>#endif <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PostAlloc <br>// <br>//  Synopsis:   Called after OLE calls IMalloc::Alloc <br>// <br>//  Arguments:  [pActual] -- The allocation returned by IMalloc::Alloc <br>// <br>//  Returns:    The allocation pointer to return to the caller of <br>//              IMalloc::Alloc <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void *) MallocSpy_PostAlloc( <br>    LPMALLOCSPY this, <br>    void *pActual) <br>{ <br>    void * pUser = PUserFromPActual(pActual, ((LPCMALLOCSPY)this)-&gt;m_cbRequested); <br> <br>#ifdef TRACEMEM <br>    wsprintf(szScratch, "IMalloc: 0x%08lX allocated\n", pUser); <br>    OleDbgOut1(szScratch); <br>#endif <br> <br>    return(pUser); <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreFree <br>// <br>//  Synopsis:   Called prior to OLE calling IMalloc::Free <br>// <br>//  Arguments:  [pRequest] -- The allocation to be freed <br>//              [fSpyed]   -- Whether it was allocated with a spy active <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void *) MallocSpy_PreFree( <br>    LPMALLOCSPY this, <br>    void *pRequest, BOOL fSpyed) <br>{ <br>    // Check for NULL <br>    if (pRequest == NULL) <br>    { <br>        return NULL; <br>    } <br> <br>#ifdef TRACEMEM <br>    wsprintf(szScratch, "IMalloc: 0x%08lX freeing\n", pRequest); <br>    OleDbgOut1(szScratch); <br>#endif <br> <br>    // Undo the offset <br>    if (fSpyed) <br>    { <br>        return(PActualFromPUser(pRequest)); <br>    } <br>    else <br>    { <br>        return pRequest; <br>    } <br>} <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PostFree <br>// <br>//  Synopsis:   Called after OLE calls IMalloc::Free <br>// <br>//  Arguments:  [fSpyed]   -- Whether it was allocated with a spy active <br>// <br>//  Returns: <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void) MallocSpy_PostFree( <br>    LPMALLOCSPY this, <br>    BOOL fSpyed) <br>{ <br>    return; <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreRealloc <br>// <br>//  Synopsis:   Called prior to OLE calling IMalloc::Realloc <br>// <br>//  Arguments:  [pRequest]     -- The buffer to be reallocated <br>//              [cbRequest]    -- The requested new size of the buffer <br>//              [ppNewRequest] -- Where to store the new buffer pointer <br>//                                to be reallocated <br>//              [fSpyed]       -- Whether it was allocated with a spy active <br>// <br>//  Returns:    The new size to actually be allocated <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) MallocSpy_PreRealloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    ULONG cbRequest, <br>    void **ppNewRequest, <br>    BOOL fSpyed) <br>{ <br>#ifdef TRACEMEM <br>    wsprintf(szScratch, "IMalloc: 0x%08lX realocating\n", pRequest); <br>    OleDbgOut1(szScratch); <br>#endif <br> <br>    if (fSpyed) <br>    { <br>        *ppNewRequest = PActualFromPUser(pRequest); <br>        ((LPCMALLOCSPY)this)-&gt;m_cbRequested = cbRequest; <br>        return CbActualFromCbUser(cbRequest); <br>    } <br>    else <br>    { <br>        *ppNewRequest = pRequest; <br>        return cbRequest; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PostRealloc <br>// <br>//  Synopsis:   Called after OLE calls IMalloc::Realloc <br>// <br>//  Arguments:  [pActual] -- Pointer to the reallocated buffer <br>//              [fSpyed]  -- Whether it was allocated with a spy active <br>// <br>//  Returns:    The buffer pointer to return <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void *) MallocSpy_PostRealloc( <br>    LPMALLOCSPY this, <br>    void *pActual, <br>    BOOL fSpyed) <br>{ <br>    void * pUser; <br> <br>    if (fSpyed) <br>    { <br>        pUser = PUserFromPActual(pActual, ((LPCMALLOCSPY)this)-&gt;m_cbRequested); <br>    } <br>    else <br>    { <br>        pUser = pActual; <br>    } <br> <br>#ifdef TRACEMEM <br>    wsprintf(szScratch, "IMalloc: 0x%08lX reallocated\n", pUser); <br>    OleDbgOut1(szScratch); <br>#endif <br> <br>    return(pUser); <br>} <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreGetSize <br>// <br>//  Synopsis:   Called prior to OLE calling IMalloc::GetSize <br>// <br>//  Arguments:  [pRequest] -- The buffer whose size is to be returned <br>//              [fSpyed]   -- Whether it was allocated with a spy active <br>// <br>//  Returns:    The actual buffer with which to call IMalloc::GetSize <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void *) MallocSpy_PreGetSize( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>    { <br>        return(PActualFromPUser(pRequest)); <br>    }else <br>    { <br>        return pRequest; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PostGetSize <br>// <br>//  Synopsis:   Called after OLE calls IMalloc::GetSize <br>// <br>//  Arguments:  [cbActual] -- The result of IMalloc::GetSize <br>//              [fSpyed]   -- Whether it was allocated with a spy active <br>// <br>//  Returns:    The size to return to the IMalloc::GetSize caller <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) MallocSpy_PostGetSize( <br>    LPMALLOCSPY this, <br>    ULONG cbActual, <br>    BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>    { <br>        return CbUserFromCbActual(cbActual); <br>    } <br>    else <br>    { <br>        return cbActual; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreDidAlloc <br>// <br>//  Synopsis:   Called prior to OLE calling IMalloc::DidAlloc <br>// <br>//  Arguments:  [pRequest] -- The buffer whose allocation is being tested <br>//              [fSpyed]   -- Whether it was allocated with a spy active <br>// <br>//  Returns:    The buffer whose allocation is actually to be tested <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void *) MallocSpy_PreDidAlloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed) <br>{ <br>    if (fSpyed) <br>    { <br>        return(PActualFromPUser(pRequest)); <br>    } <br>    else <br>    { <br>        return pRequest; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Function:   PostDidAlloc <br>// <br>//  Synopsis:   Called after OLE calls the IMalloc::DidAlloc <br>// <br>//  Arguments:  [pRequest] -- The passed allocation <br>//              [fSpyed]   -- Whether it was allocated with a spy active <br>//              [fActual]  -- The result of IMalloc::DidAlloc <br>// <br>//  Returns:    The result of IMalloc::DidAlloc <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(BOOL) MallocSpy_PostDidAlloc( <br>    LPMALLOCSPY this, <br>    void *pRequest, <br>    BOOL fSpyed, <br>    BOOL fActual) <br>{ <br>    return fActual; <br>} <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PreHeapMinimize <br>// <br>//  Synopsis:   Called prior to OLE calling the IMalloc::HeapMinimize <br>// <br>//  Returns: <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void) MallocSpy_PreHeapMinimize( <br>    LPMALLOCSPY this) <br>{ <br>    return; <br>} <br> <br> <br> <br> <br> <br>//+--------------------------------------------------------------------- <br>// <br>//  Member:     CMallocSpy::PostHeapMinimize <br>// <br>//  Synopsis:   Called after OLE calls the IMalloc::HeapMinimize <br>// <br>//  Returns: <br>// <br>//---------------------------------------------------------------------- <br>STDMETHODIMP_(void) MallocSpy_PostHeapMinimize( <br>    LPMALLOCSPY this) <br>{ <br>    return; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
