<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMSTAT.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context250"></a>ENUMSTAT.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Utility Code <br>** <br>**    enumstat.c <br>** <br>**    This file contains a standard implementation of IEnumStatData <br>**    interface. <br>**    This file is part of the OLE 2.0 User Interface support library. <br>** <br>**    (c) Copyright Microsoft Corp. 1990 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br> <br> <br>typedef struct tagOleStdEnumStatData { <br>  IEnumSTATDATAVtbl FAR* lpVtbl; <br>  ULONG m_dwRefs;       /* referance count */ <br>  ULONG m_nIndex;       /* current index in list */ <br>  ULONG m_nCount;       /* how many items in list */ <br>  LPSTATDATA m_lpStat;  /* list of STATDATA */ <br>} OLESTDENUMSTATDATA, FAR* LPOLESTDENUMSTATDATA; <br> <br>VOID  OleStdEnumStatData_Destroy(LPOLESTDENUMSTATDATA pStat); <br> <br>STDMETHODIMP OleStdEnumStatData_QueryInterface( <br>      LPENUMSTATDATA lpThis, REFIID riid, LPVOID FAR* ppobj); <br>STDMETHODIMP_(ULONG)  OleStdEnumStatData_AddRef(LPENUMSTATDATA lpThis); <br>STDMETHODIMP_(ULONG)  OleStdEnumStatData_Release(LPENUMSTATDATA lpThis); <br>STDMETHODIMP  OleStdEnumStatData_Next(LPENUMSTATDATA lpThis, ULONG celt, <br>                          LPSTATDATA rgelt, ULONG FAR* pceltFetched); <br>STDMETHODIMP  OleStdEnumStatData_Skip(LPENUMSTATDATA lpThis, ULONG celt); <br>STDMETHODIMP  OleStdEnumStatData_Reset(LPENUMSTATDATA lpThis); <br>STDMETHODIMP  OleStdEnumStatData_Clone(LPENUMSTATDATA lpThis, <br>                            LPENUMSTATDATA FAR* ppenum); <br> <br>static IEnumSTATDATAVtbl g_EnumSTATDATAVtbl = { <br>      OleStdEnumStatData_QueryInterface, <br>      OleStdEnumStatData_AddRef, <br>      OleStdEnumStatData_Release, <br>      OleStdEnumStatData_Next, <br>      OleStdEnumStatData_Skip, <br>      OleStdEnumStatData_Reset, <br>      OleStdEnumStatData_Clone, <br>}; <br> <br>///////////////////////////////////////////////////////////////////////////// <br> <br>STDAPI_(BOOL) <br>  OleStdCopyStatData(LPSTATDATA pDest, LPSTATDATA pSrc) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  if ((pDest == NULL) || (pSrc == NULL)) { <br>   return FALSE; <br>  } <br> <br>  if (OleStdCopyFormatEtc(&amp;pDest-&gt;formatetc, &amp;pSrc-&gt;formatetc) == FALSE) { <br>   return FALSE; <br>  } <br> <br>  pDest-&gt;advf = pSrc-&gt;advf; <br>  pDest-&gt;pAdvSink = pSrc-&gt;pAdvSink; <br>  pDest-&gt;dwConnection = pSrc-&gt;dwConnection; <br> <br>  if (pDest-&gt;pAdvSink != NULL) { <br>   pDest-&gt;pAdvSink-&gt;lpVtbl-&gt;AddRef(pDest-&gt;pAdvSink); <br>  } <br> <br>  return TRUE; <br> <br>} /* OleStdCopyStatData() <br>   */ <br> <br>STDAPI_(LPENUMSTATDATA) <br>  OleStdEnumStatData_Create(ULONG nCount, LPSTATDATA lpStatOrg) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPMALLOC lpMalloc=NULL; <br>  LPOLESTDENUMSTATDATA lpSD=NULL; <br>  DWORD dwSize; <br>  WORD i; <br>  HRESULT hRes; <br> <br>  hRes = CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc); <br>  if (hRes != NOERROR) { <br>   return NULL; <br>  } <br> <br>  lpSD = (LPOLESTDENUMSTATDATA)lpMalloc-&gt;lpVtbl-&gt;Alloc(lpMalloc, <br>                                     sizeof(OLESTDENUMSTATDATA)); <br>  if (lpSD == NULL) { <br>   goto errReturn; <br>  } <br> <br>  lpSD-&gt;lpVtbl = &amp;g_EnumSTATDATAVtbl; <br>  lpSD-&gt;m_dwRefs = 1; <br>  lpSD-&gt;m_nCount = nCount; <br>  lpSD-&gt;m_nIndex = 0; <br> <br>  dwSize = sizeof(STATDATA) * lpSD-&gt;m_nCount; <br> <br>  lpSD-&gt;m_lpStat = (LPSTATDATA)lpMalloc-&gt;lpVtbl-&gt;Alloc(lpMalloc, dwSize); <br>  if (lpSD-&gt;m_lpStat == NULL) <br>   goto errReturn; <br> <br>  lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br> <br>  for (i=0; i&lt;nCount; i++) { <br>   OleStdCopyStatData( <br>         (LPSTATDATA)&amp;(lpSD-&gt;m_lpStat[i]), (LPSTATDATA)&amp;(lpStatOrg[i])); <br>  } <br> <br>  g_dwObjectCount++ ; <br> <br>  return (LPENUMSTATDATA)lpSD; <br> <br>errReturn: <br>  if (lpSD != NULL) <br>   lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpSD); <br> <br>  if (lpMalloc != NULL) <br>   lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br> <br>  return NULL; <br> <br>} /* OleStdEnumStatData_Create() <br>   */ <br> <br> <br>VOID <br>  OleStdEnumStatData_Destroy(LPOLESTDENUMSTATDATA lpSD) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>   LPMALLOC lpMalloc=NULL; <br>   WORD i; <br> <br>   if (lpSD != NULL) { <br> <br>      if (CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc) == NOERROR) { <br> <br>         /* NOTE: we MUST free any memory that was allocated for <br>         **    TARGETDEVICES contained within the STATDATA elements. <br>         */ <br>         for (i=0; i&lt;lpSD-&gt;m_nCount; i++) { <br>            if( lpSD-&gt;m_lpStat[i].pAdvSink ) <br>               lpSD-&gt;m_lpStat[i].pAdvSink-&gt;lpVtbl-&gt;Release(lpSD-&gt;m_lpStat[i].pAdvSink); <br> <br>            OleStdFree(lpSD-&gt;m_lpStat[i].formatetc.ptd); <br>         } <br> <br>         if (lpSD-&gt;m_lpStat != NULL) { <br>            lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpSD-&gt;m_lpStat); <br>         } <br> <br>         lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpSD); <br>         lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br>      } <br>   } <br> <br>   g_dwObjectCount-- ; <br> <br>} /* OleStdEnumStatData_Destroy() <br>   */ <br> <br> <br>STDMETHODIMP <br>  OleStdEnumStatData_QueryInterface( <br>            LPENUMSTATDATA lpThis, REFIID riid, LPVOID FAR* ppobj) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  *ppobj = NULL; <br> <br>  if (IsEqualIID(riid,&amp;IID_IUnknown) || IsEqualIID(riid,&amp;IID_IEnumSTATDATA)){ <br>   *ppobj = (LPVOID)lpSD; <br>  } <br> <br>  if (*ppobj == NULL) return E_NOINTERFACE; <br>  else{ <br>   OleStdEnumStatData_AddRef(lpThis); <br>   return NOERROR; <br>  } <br> <br>} /* OleStdEnumStatData_QueryInterface() <br>   */ <br> <br> <br>STDMETHODIMP_(ULONG) <br>  OleStdEnumStatData_AddRef(LPENUMSTATDATA lpThis) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  return lpSD-&gt;m_dwRefs++; <br> <br>} /* OleStdEnumStatData_AddRef() <br>   */ <br> <br> <br>STDMETHODIMP_(ULONG) <br>  OleStdEnumStatData_Release(LPENUMSTATDATA lpThis) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  DWORD dwRefs = --lpSD-&gt;m_dwRefs; <br> <br>  if (dwRefs == 0) <br>   OleStdEnumStatData_Destroy(lpSD); <br> <br>  return dwRefs; <br> <br>} /* OleStdEnumStatData_Release() <br>   */ <br> <br> <br>STDMETHODIMP <br>  OleStdEnumStatData_Next(LPENUMSTATDATA lpThis, ULONG celt, LPSTATDATA rgelt, <br>                 ULONG FAR* pceltFetched) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  ULONG i=0; <br>  ULONG nOffset; <br> <br>  if (rgelt == NULL) { <br>   return E_INVALIDARG; <br>  } <br> <br>  while (i &lt; celt) { <br>   nOffset = lpSD-&gt;m_nIndex + i; <br> <br>   if (nOffset &lt; lpSD-&gt;m_nCount) { <br>     OleStdCopyStatData( <br>         (LPSTATDATA)&amp;(rgelt[i]), (LPSTATDATA)&amp;(lpSD-&gt;m_lpStat[nOffset])); <br>     i++; <br>   }else{ <br>     break; <br>   } <br>  } <br> <br>  lpSD-&gt;m_nIndex += (WORD)i; <br> <br>  if (pceltFetched != NULL) { <br>   *pceltFetched = i; <br>  } <br> <br>  if (i != celt) { <br>   return S_FALSE; <br>  } <br> <br>  return NOERROR; <br>} /* OleStdEnumStatData_Next() <br>   */ <br> <br> <br>STDMETHODIMP <br>  OleStdEnumStatData_Skip(LPENUMSTATDATA lpThis, ULONG celt) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  ULONG i=0; <br>  ULONG nOffset; <br> <br>  while (i &lt; celt) { <br>   nOffset = lpSD-&gt;m_nIndex + i; <br> <br>   if (nOffset &lt; lpSD-&gt;m_nCount) { <br>     i++; <br>   }else{ <br>     break; <br>   } <br>  } <br> <br>  lpSD-&gt;m_nIndex += (WORD)i; <br> <br>  if (i != celt) { <br>   return S_FALSE; <br>  } <br> <br>  return NOERROR; <br>} /* OleStdEnumStatData_Skip() <br>   */ <br> <br> <br>STDMETHODIMP <br>  OleStdEnumStatData_Reset(LPENUMSTATDATA lpThis) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br>  lpSD-&gt;m_nIndex = 0; <br> <br>  return NOERROR; <br>} /* OleStdEnumStatData_Reset() <br>   */ <br> <br> <br>STDMETHODIMP <br>  OleStdEnumStatData_Clone(LPENUMSTATDATA lpThis, LPENUMSTATDATA FAR* ppenum) <br>//---------------------------------------------------------------------------- <br>// <br>//---------------------------------------------------------------------------- <br>{ <br>  LPOLESTDENUMSTATDATA lpSD = (LPOLESTDENUMSTATDATA)lpThis; <br> <br>  if (ppenum == NULL) { <br>   return E_INVALIDARG; <br>  } <br> <br>  *ppenum = OleStdEnumStatData_Create(lpSD-&gt;m_nCount, lpSD-&gt;m_lpStat); <br> <br>  // make sure cloned enumerator has same index state as the original <br>  if (*ppenum) { <br>     LPOLESTDENUMSTATDATA lpSDClone = (LPOLESTDENUMSTATDATA)*ppenum; <br>     lpSDClone-&gt;m_nIndex = lpSD-&gt;m_nIndex; <br>     return NOERROR; <br>  } else <br>     return E_OUTOFMEMORY; <br> <br>} /* OleStdEnumStatData_Clone() <br>   */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
