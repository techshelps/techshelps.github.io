<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILITY.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context267"></a>UTILITY.C</h2>
<pre><code>/* <br> * UTILITY.C <br> * <br> * Utility routines for functions inside OLESTD.LIB <br> * <br> *  General: <br> *  ---------------------- <br> *  HourGlassOn             Displays the hourglass <br> *  HourGlassOff            Hides the hourglass <br> * <br> *  Misc Tools: <br> *  ---------------------- <br> *  Browse                  Displays the "File..." or "Browse..." dialog. <br> *  ReplaceCharWithNull     Used to form filter strings for Browse. <br> *  ErrorWithFile           Creates an error message with embedded filename <br> *  OpenFileError           Give error message for OpenFile error return <br> *  ChopText                Chop a file path to fit within a specified width <br> *  DoesFileExist           Checks if file is valid <br> * <br> *  Registration Database: <br> *  ---------------------- <br> *  HIconFromClass          Extracts the first icon in a class's server path <br> *  FServerFromClass        Retrieves the server path for a class name (fast) <br> *  UClassFromDescription   Finds the classname given a description (slow) <br> *  UDescriptionFromClass   Retrieves the description for a class name (fast) <br> *  FGetVerb                Retrieves a specific verb for a class (fast) <br> * <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Right Reserved <br> */ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;cderr.h&gt; <br>#include "common.h" <br>#include "utility.h" <br> <br>#ifdef WIN32 <br>/* 1/23/94 - define LINK_COMMDLG to avoid LoadLibrary("commdlg.dll") */ <br>#define LINK_COMMDLG <br>#endif <br> <br>OLEDBGDATA <br> <br>/* <br> * HourGlassOn <br> * <br> * Purpose: <br> *  Shows the hourglass cursor returning the last cursor in use. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HCURSOR         Cursor in use prior to showing the hourglass. <br> */ <br> <br>HCURSOR WINAPI HourGlassOn(void) <br>   { <br>   HCURSOR     hCur; <br> <br>   hCur=SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>   ShowCursor(TRUE); <br> <br>   return hCur; <br>   } <br> <br> <br> <br>/* <br> * HourGlassOff <br> * <br> * Purpose: <br> *  Turns off the hourglass restoring it to a previous cursor. <br> * <br> * Parameters: <br> *  hCur            HCURSOR as returned from HourGlassOn <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void WINAPI HourGlassOff(HCURSOR hCur) <br>   { <br>   ShowCursor(FALSE); <br>   SetCursor(hCur); <br>   return; <br>   } <br> <br> <br> <br> <br>/* <br> * Browse <br> * <br> * Purpose: <br> *  Displays the standard GetOpenFileName dialog with the title of <br> *  "Browse."  The types listed in this dialog are controlled through <br> *  iFilterString.  If it's zero, then the types are filled with "*.*" <br> *  Otherwise that string is loaded from resources and used. <br> * <br> * Parameters: <br> *  hWndOwner       HWND owning the dialog <br> *  lpszFile        LPSTR specifying the initial file and the buffer in <br> *                  which to return the selected file.  If there is no <br> *                  initial file the first character of this string should <br> *                  be NULL. <br> *  lpszInitialDir  LPSTR specifying the initial directory.  If none is to <br> *                  set (ie, the cwd should be used), then this parameter <br> *                  should be NULL. <br> *  cchFile         UINT length of pszFile <br> *  iFilterString   UINT index into the stringtable for the filter string. <br> *  dwOfnFlags      DWORD flags to OR with OFN_HIDEREADONLY <br> * <br> * Return Value: <br> *  BOOL            TRUE if the user selected a file and pressed OK. <br> *                  FALSE otherwise, such as on pressing Cancel. <br> */ <br> <br>BOOL WINAPI Browse(HWND hWndOwner, LPSTR lpszFile, LPSTR lpszInitialDir, UINT cchFile, UINT iFilterString, DWORD dwOfnFlags) <br>   { <br>      UINT           cch; <br>      char           szFilters[256]; <br>      OPENFILENAME   ofn; <br>      BOOL           fStatus; <br>      DWORD          dwError; <br>      char            szDlgTitle[128];  // that should be big enough <br>#if !defined( LINK_COMMDLG ) <br>      HINSTANCE hinstCommDlg = NULL; <br>      typedef BOOL (WINAPI* LPFNGETOPENFILENAME) (OPENFILENAME FAR*); <br>      LPFNGETOPENFILENAME lpfnGetOpenFileName; <br>      typedef DWORD (WINAPI* LPFNCOMMDLGEXTENDEDERROR) (void); <br>      LPFNCOMMDLGEXTENDEDERROR lpfnCommDlgExtendedError; <br>#endif <br> <br>   if (NULL==lpszFile || 0==cchFile) <br>      return FALSE; <br> <br>   /* <br>    * REVIEW:  Exact contents of the filter combobox is TBD.  One idea <br>    * is to take all the extensions in the RegDB and place them in here <br>    * with the descriptive class name associate with them.  This has the <br>    * extra step of finding all extensions of the same class handler and <br>    * building one extension string for all of them.  Can get messy quick. <br>    * UI demo has only *.* which we do for now. <br>    */ <br> <br>   if (0!=iFilterString) <br>      cch=LoadString(ghInst, iFilterString, /*(LPSTR)*/szFilters, sizeof(szFilters)); <br>   else <br>      { <br>      szFilters[0]=0; <br>      cch=1; <br>      } <br> <br>   if (0==cch) <br>      return FALSE; <br> <br>   ReplaceCharWithNull(szFilters, szFilters[cch-1]); <br> <br>   //Prior string must also be initialized, if there is one. <br>   _fmemset((LPOPENFILENAME)&amp;ofn, 0, sizeof(ofn)); <br>   ofn.lStructSize =sizeof(ofn); <br>   ofn.hwndOwner   =hWndOwner; <br>   ofn.lpstrFile   =lpszFile; <br>   ofn.nMaxFile    =cchFile; <br>   ofn.lpstrFilter =/*(LPSTR)*/szFilters; <br>   ofn.nFilterIndex=1; <br>   if (LoadString(ghInst, (UINT)IDS_BROWSE, /*(LPSTR)*/szDlgTitle, sizeof(szDlgTitle))) <br>      ofn.lpstrTitle  =/*(LPSTR)*/szDlgTitle; <br>   ofn.hInstance = ghInst; <br>   ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPEN); <br>   if (NULL != lpszInitialDir) <br>     ofn.lpstrInitialDir = lpszInitialDir; <br> <br>   ofn.Flags= OFN_HIDEREADONLY | OFN_ENABLETEMPLATE | (dwOfnFlags) ; <br> <br>#if !defined( LINK_COMMDLG ) <br>   // Load the COMMDLG.DLL library module <br>   hinstCommDlg = LoadLibrary("COMMDLG.DLL"); <br>   if (hinstCommDlg &lt;= HINSTANCE_ERROR)   /* load failed */ <br>      return FALSE; <br> <br>   // Retrieve the address of required functions <br>   lpfnGetOpenFileName = (LPFNGETOPENFILENAME) <br>         GetProcAddress(hinstCommDlg, "GetOpenFileName"); <br>   lpfnCommDlgExtendedError = (LPFNCOMMDLGEXTENDEDERROR) <br>         GetProcAddress(hinstCommDlg, "CommDlgExtendedError"); <br> <br>   if (lpfnGetOpenFileName == NULL || lpfnCommDlgExtendedError == NULL) <br>      { <br>      FreeLibrary(hinstCommDlg); <br>      return FALSE; <br>      } <br> <br>   //On success, copy the chosen filename to the static display <br>   fStatus = (*lpfnGetOpenFileName) ((LPOPENFILENAME)&amp;ofn); <br>   dwError = (*lpfnCommDlgExtendedError)(); <br> <br>   FreeLibrary(hinstCommDlg); <br>   return fStatus; <br>#else <br>   //On success, copy the chosen filename to the static display <br>   fStatus = GetOpenFileName((LPOPENFILENAME)&amp;ofn); <br>   dwError = CommDlgExtendedError(); <br>   return fStatus; <br>#endif <br>   } <br> <br> <br> <br> <br> <br>/* <br> * ReplaceCharWithNull <br> * <br> * Purpose: <br> *  Walks a null-terminated string and replaces a given character <br> *  with a zero.  Used to turn a single string for file open/save <br> *  filters into the appropriate filter string as required by the <br> *  common dialog API. <br> * <br> * Parameters: <br> *  psz             LPSTR to the string to process. <br> *  ch              int character to replace. <br> * <br> * Return Value: <br> *  int             Number of characters replaced.  -1 if psz is NULL. <br> */ <br> <br>int WINAPI ReplaceCharWithNull(LPSTR psz, int ch) <br>   { <br>   int             cChanged=-1; <br> <br>   if (NULL!=psz) <br>      { <br>      while (0!=*psz) <br>         { <br>         if (ch==*psz) <br>            { <br>            *psz=0; <br>            cChanged++; <br>            } <br>         psz++; <br>         } <br>      } <br>   return cChanged; <br>   } <br> <br> <br> <br> <br> <br> <br>/* <br> * ErrorWithFile <br> * <br> * Purpose: <br> *  Displays a message box built from a stringtable string containing <br> *  one %s as a placeholder for a filename and from a string of the <br> *  filename to place there. <br> * <br> * Parameters: <br> *  hWnd            HWND owning the message box.  The caption of this <br> *                  window is the caption of the message box. <br> *  hInst           HINSTANCE from which to draw the idsErr string. <br> *  idsErr          UINT identifier of a stringtable string containing <br> *                  the error message with a %s. <br> *  lpszFile        LPSTR to the filename to include in the message. <br> *  uFlags          UINT flags to pass to MessageBox, like MB_OK. <br> * <br> * Return Value: <br> *  int             Return value from MessageBox. <br> */ <br> <br>int WINAPI ErrorWithFile(HWND hWnd, HINSTANCE hInst, UINT idsErr <br>              , LPSTR pszFile, UINT uFlags) <br>   { <br>   int             iRet=0; <br>   HANDLE          hMem; <br>   const UINT      cb=(2*OLEUI_CCHPATHMAX); <br>   LPSTR           psz1, psz2, psz3; <br> <br>   if (NULL==hInst || NULL==pszFile) <br>      return iRet; <br> <br>   //Allocate three 2*OLEUI_CCHPATHMAX byte work buffers <br>   hMem=GlobalAlloc(GHND, (DWORD)(3*cb)); <br> <br>   if (NULL==hMem) <br>      return iRet; <br> <br>   psz1=GlobalLock(hMem); <br>   psz2=psz1+cb; <br>   psz3=psz2+cb; <br> <br>   if (0!=LoadString(hInst, idsErr, psz1, cb)) <br>      { <br>      wsprintf(psz2, psz1, pszFile); <br> <br>      //Steal the caption of the dialog <br>      GetWindowText(hWnd, psz3, cb); <br>      iRet=MessageBox(hWnd, psz2, psz3, uFlags); <br>      } <br> <br>   GlobalUnlock(hMem); <br>   GlobalFree(hMem); <br>   return iRet; <br>   } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * HIconFromClass <br> * <br> * Purpose: <br> *  Given an object class name, finds an associated executable in the <br> *  registration database and extracts the first icon from that <br> *  executable.  If none is available or the class has no associated <br> *  executable, this function returns NULL. <br> * <br> * Parameters: <br> *  pszClass        LPSTR giving the object class to look up. <br> * <br> * Return Value: <br> *  HICON           Handle to the extracted icon if there is a module <br> *                  associated to pszClass.  NULL on failure to either <br> *                  find the executable or extract and icon. <br> */ <br> <br>HICON WINAPI HIconFromClass(LPSTR pszClass) <br>   { <br>   HICON           hIcon; <br>   char            szEXE[OLEUI_CCHPATHMAX]; <br>   UINT            Index; <br>   CLSID           clsid; <br>   OLECHAR         szUniStr[256]; <br> <br>   if (NULL==pszClass) <br>      return NULL; <br> <br>   A2W (pszClass, szUniStr, 256); <br>   CLSIDFromString(szUniStr, &amp;clsid); <br> <br>   if (!FIconFileFromClass((REFCLSID)&amp;clsid, szEXE, sizeof(szEXE), &amp;Index)) <br>      return NULL; <br> <br>   hIcon=ExtractIcon(ghInst, szEXE, Index); <br> <br>   if ((HICON)32 &gt; hIcon) <br>      hIcon=NULL; <br> <br>   return hIcon; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * FServerFromClass <br> * <br> * Purpose: <br> *  Looks up the classname in the registration database and retrieves <br> *  the name under CLSID\[Local|InProc]Server. <br> * <br> * Parameters: <br> *  pszClass        LPSTR to the classname to look up. <br> *  pszEXE          LPSTR at which to store the server name <br> *  cch             UINT size of pszEXE <br> * <br> * Return Value: <br> *  BOOL            TRUE if one or more characters were loaded into pszEXE. <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL WINAPI FServerFromClass(LPSTR pszClass, LPSTR pszEXE, UINT cch) <br>{ <br> <br>   DWORD       dw; <br>   LONG        lRet; <br>   HKEY        hKey; <br> <br>   if (NULL==pszClass || NULL==pszEXE || 0==cch) <br>      return FALSE; <br> <br>   /* <br>    * We have to go walking in the registration database under the <br>    * classname, so we first open the classname key and then check <br>    * under "\\LocalServer" to get the .EXE. <br>    */ <br> <br>   //Open up the class key <br>   lRet=RegOpenKey(HKEY_CLASSES_ROOT, pszClass, &amp;hKey); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>      return FALSE; <br> <br>   //Get the executable path. <br>   dw=(DWORD)cch; <br>#ifdef WIN32 <br>   lRet=RegQueryValue(hKey, "LocalServer32", pszEXE, &amp;dw); <br>#else <br>   lRet=RegQueryValue(hKey, "LocalServer", pszEXE, &amp;dw); <br>#endif <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>        { <br>        //Try InprocServer <br>#ifdef WIN32 <br>        lRet=RegQueryValue(hKey, "InProcServer32", pszEXE, &amp;dw); <br>#else <br>        lRet=RegQueryValue(hKey, "InProcServer32", pszEXE, &amp;dw); <br>#endif <br>        } <br> <br>   RegCloseKey(hKey); <br> <br>   return ((ERROR_SUCCESS == lRet) &amp;&amp; (dw &gt; 0)); <br>} <br> <br> <br> <br>/* <br> * UClassFromDescription <br> * <br> * Purpose: <br> *  Looks up the actual OLE class name in the registration database <br> *  for the given descriptive name chosen from a listbox. <br> * <br> * Parameters: <br> *  psz             LPSTR to the descriptive name. <br> *  pszClass        LPSTR in which to store the class name. <br> *  cb              UINT maximum length of pszClass. <br> * <br> * Return Value: <br> *  UINT            Number of characters copied to pszClass.  0 on failure. <br> */ <br> <br>UINT WINAPI UClassFromDescription(LPSTR psz, LPSTR pszClass, UINT cb) <br>   { <br>   DWORD           dw; <br>   HKEY            hKey; <br>   char            szClass[OLEUI_CCHKEYMAX]; <br>   LONG            lRet; <br>   UINT            i; <br> <br>   //Open up the root key. <br>   lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>      return 0; <br> <br>   i=0; <br>   lRet=RegEnumKey(hKey, i++, szClass, OLEUI_CCHKEYMAX); <br> <br>   //Walk the available keys <br>   while ((LONG)ERROR_SUCCESS==lRet) <br>      { <br>      dw=(DWORD)cb; <br>      lRet=RegQueryValue(hKey, szClass, pszClass, &amp;dw); <br> <br>      //Check if the description matches the one just enumerated <br>      if ((LONG)ERROR_SUCCESS==lRet) <br>         { <br>         if (!lstrcmp(pszClass, psz)) <br>            break; <br>         } <br> <br>      //Continue with the next key. <br>      lRet=RegEnumKey(hKey, i++, szClass, OLEUI_CCHKEYMAX); <br>      } <br> <br>   //If we found it, copy to the return buffer <br>   if ((LONG)ERROR_SUCCESS==lRet) <br>      lstrcpy(pszClass, szClass); <br>   else <br>      dw=0L; <br> <br>   RegCloseKey(hKey); <br>   return (UINT)dw; <br>   } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * UDescriptionFromClass <br> * <br> * Purpose: <br> *  Looks up the actual OLE descriptive name name in the registration <br> *  database for the given class name. <br> * <br> * Parameters: <br> *  pszClass        LPSTR to the class name. <br> *  psz             LPSTR in which to store the descriptive name. <br> *  cb              UINT maximum length of psz. <br> * <br> * Return Value: <br> *  UINT            Number of characters copied to pszClass.  0 on failure. <br> */ <br> <br>UINT WINAPI UDescriptionFromClass(LPSTR pszClass, LPSTR psz, UINT cb) <br>   { <br>   DWORD           dw; <br>   HKEY            hKey; <br>   LONG            lRet; <br> <br>   if (NULL==pszClass || NULL==psz) <br>      return 0; <br> <br>   //Open up the root key. <br>   lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>      return 0; <br> <br>   //Get the descriptive name using the class name. <br>   dw=(DWORD)cb; <br>   lRet=RegQueryValue(hKey, pszClass, psz, &amp;dw); <br> <br>   RegCloseKey(hKey); <br> <br>   psz+=lstrlen(psz)+1; <br>   *psz=0; <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>      return 0; <br> <br>   return (UINT)dw; <br>   } <br> <br> <br> <br>// returns width of line of text. this is a support routine for ChopText <br>static LONG GetTextWSize(HDC hDC, LPSTR lpsz) <br>{ <br>   SIZE size; <br> <br>   if (GetTextExtentPoint(hDC, lpsz, lstrlen(lpsz), (LPSIZE)&amp;size)) <br>      return size.cx; <br>   else { <br>      return 0; <br>   } <br>} <br> <br> <br>/* <br> * ChopText <br> * <br> * Purpose: <br> *  Parse a string (pathname) and convert it to be within a specified <br> *  length by chopping the least significant part <br> * <br> * Parameters: <br> *  hWnd            window handle in which the string resides <br> *  nWidth          max width of string in pixels <br> *                  use width of hWnd if zero <br> *  lpch            pointer to beginning of the string <br> * <br> * Return Value: <br> *  pointer to the modified string <br> */ <br>LPSTR WINAPI ChopText(HWND hWnd, int nWidth, LPSTR lpch) <br>{ <br>#define PREFIX_SIZE    7 + 1 <br>#define PREFIX_FORMAT "%c%c%c...\\" <br> <br>   char    szPrefix[PREFIX_SIZE]; <br>   BOOL    fDone = FALSE; <br>   int     i; <br>   RECT    rc; <br>   HDC     hdc; <br>   HFONT   hfont; <br>   HFONT   hfontOld = NULL; <br> <br>   if (!hWnd || !lpch) <br>      return NULL; <br> <br>   /* Get length of static field. */ <br>   if (!nWidth) { <br>      GetClientRect(hWnd, (LPRECT)&amp;rc); <br>      nWidth = rc.right - rc.left; <br>   } <br> <br>   /* Set up DC appropriately for the static control */ <br>   hdc = GetDC(hWnd); <br>   hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L); <br> <br>   if (NULL != hfont)   // WM_GETFONT returns NULL if window uses system font <br>      hfontOld = SelectObject(hdc, hfont); <br> <br>   /* check horizontal extent of string */ <br>   if (GetTextWSize(hdc, lpch) &gt; nWidth) { <br> <br>      /* string is too long to fit in static control; chop it */ <br>      /* set up new prefix &amp; determine remaining space in control */ <br>      wsprintf(/*(LPSTR)*/ szPrefix, PREFIX_FORMAT, lpch[0], lpch[1], lpch[2]); <br>      nWidth -= (int)GetTextWSize(hdc, /*(LPSTR)*/ szPrefix); <br> <br>      /* <br>      ** advance a directory at a time until the remainder of the <br>      ** string fits into the static control after the "x:\...\" prefix <br>      */ <br>      while (!fDone) { <br> <br>#ifdef DBCS <br>         while (*lpch &amp;&amp; (*lpch != '\\')) <br>            lpch = AnsiNext(lpch); <br>         if (*lpch) <br>            lpch = AnsiNext(lpch); <br>#else <br>         while (*lpch &amp;&amp; (*lpch++ != '\\')); <br>#endif <br> <br>         if (!*lpch || GetTextWSize(hdc, lpch) &lt;= nWidth) { <br>            if (!*lpch) <br>               /* <br>               ** Nothing could fit after the prefix; remove the <br>               ** final "\" from the prefix <br>               */ <br>               szPrefix[lstrlen(/*(LPSTR)*/ szPrefix) - 1] = 0; <br> <br>               /* rest or string fits -- stick prefix on front */ <br>               for (i = lstrlen(/*(LPSTR)*/ szPrefix) - 1; i &gt;= 0; --i) <br>                  *--lpch = szPrefix[i]; <br>               fDone = TRUE; <br>         } <br>      } <br>   } <br> <br>   if (NULL != hfont) <br>     SelectObject(hdc, hfontOld); <br>   ReleaseDC(hWnd, hdc); <br> <br>   return(lpch); <br> <br>#undef PREFIX_SIZE <br>#undef PREFIX_FORMAT <br>} <br> <br> <br>/* <br> * OpenFileError <br> * <br> * Purpose: <br> *  display message for error returned from OpenFile <br> * <br> * Parameters: <br> *  hDlg            HWND of the dialog. <br> *  nErrCode        UINT error code returned in OFSTRUCT passed to OpenFile <br> *  lpszFile        LPSTR file name passed to OpenFile <br> * <br> * Return Value: <br> *  None <br> */ <br>void WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPSTR lpszFile) <br>{ <br>   switch (nErrCode) { <br>      case 0x0005:    // Access denied <br>         ErrorWithFile(hDlg, ghInst, (UINT)IDS_CIFILEACCESS, lpszFile, MB_OK); <br>         break; <br> <br>      case 0x0020:    // Sharing violation <br>         ErrorWithFile(hDlg, ghInst, (UINT)IDS_CIFILESHARE, lpszFile, MB_OK); <br>         break; <br> <br>      case 0x0002:    // File not found <br>      case 0x0003:    // Path not found <br>         ErrorWithFile(hDlg, ghInst, (UINT)IDS_CIINVALIDFILE, lpszFile, MB_OK); <br>         break; <br> <br>      default: <br>         ErrorWithFile(hDlg, ghInst, (UINT)IDS_CIFILEOPENFAIL, lpszFile, MB_OK); <br>         break; <br>   } <br>} <br> <br>#define chSpace        ' ' <br>#define chPeriod       '.' <br>#define PARSE_EMPTYSTRING   -1 <br>#define PARSE_INVALIDDRIVE  -2 <br>#define PARSE_INVALIDPERIOD -3 <br>#define PARSE_INVALIDDIRCHAR    -4 <br>#define PARSE_INVALIDCHAR   -5 <br>#define PARSE_WILDCARDINDIR -6 <br>#define PARSE_INVALIDNETPATH    -7 <br>#define PARSE_INVALIDSPACE  -8 <br>#define PARSE_EXTENTIONTOOLONG  -9 <br>#define PARSE_DIRECTORYNAME -10 <br>#define PARSE_FILETOOLONG   -11 <br> <br>/*--------------------------------------------------------------------------- <br> * ParseFile <br> * Purpose:  Determine if the filename is a legal DOS name <br> * Input:    Long pointer to a SINGLE file name <br> *           Circumstance checked: <br> *           1) Valid as directory name, but not as file name <br> *           2) Empty String <br> *           3) Illegal Drive label <br> *           4) Period in invalid location (in extention, 1st in file name) <br> *           5) Missing directory character <br> *           6) Illegal character <br> *           7) Wildcard in directory name <br> *           8) Double slash beyond 1st 2 characters <br> *           9) Space character in the middle of the name (trailing spaces OK) <br> *          10) Filename greater than 8 characters <br> *          11) Extention greater than 3 characters <br> * Notes: <br> *   Filename length is NOT checked. <br> *   Valid filenames will have leading spaces, trailing spaces and <br> *     terminating period stripped in place. <br> * <br> * Returns:  If valid, LOWORD is byte offset to filename <br> *                     HIWORD is byte offset to extention <br> *                            if string ends with period, 0 <br> *                            if no extention is given, string length <br> *           If invalid, LOWORD is error code suggesting problem (&lt; 0) <br> *                       HIWORD is approximate offset where problem found <br> *                       Note that this may be beyond the offending character <br> *--------------------------------------------------------------------------*/ <br> <br>static long ParseFile(LPSTR lpstrFileName) <br>{ <br>  short nFile, nExt, nFileOffset, nExtOffset; <br>  BOOL bExt; <br>  BOOL bWildcard; <br>  short nNetwork = 0; <br>  BOOL  bUNCPath = FALSE; <br>  LPSTR lpstr = lpstrFileName; <br> <br>/* Strip off initial white space.  Note that TAB is not checked */ <br>/* because it cannot be received out of a standard edit control */ <br>/* 30 January 1991  clarkc                                      */ <br>  while (*lpstr == chSpace) <br>     lpstr++; <br> <br>  if (!*lpstr) <br>   { <br>     nFileOffset = PARSE_EMPTYSTRING; <br>     goto FAILURE; <br>   } <br> <br>  if (lpstr != lpstrFileName) <br>   { <br>     lstrcpy(lpstrFileName, lpstr); <br>     lpstr = lpstrFileName; <br>   } <br> <br>  if (*AnsiNext(lpstr) == ':') <br>   { <br>     char cDrive = (*lpstr | (BYTE) 0x20);  /* make lowercase */ <br> <br>/* This does not test if the drive exists, only if it's legal */ <br>     if ((cDrive &lt; 'a') || (cDrive &gt; 'z')) <br>      { <br>        nFileOffset = PARSE_INVALIDDRIVE; <br>        goto FAILURE; <br>      } <br>     lpstr = AnsiNext(AnsiNext(lpstr)); <br>   } <br> <br>  if ((*lpstr == '\\') || (*lpstr == '/')) <br>   { <br>     if (*++lpstr == chPeriod)               /* cannot have c:\. */ <br>      { <br>        if ((*++lpstr != '\\') &amp;&amp; (*lpstr != '/'))   /* unless it's stupid */ <br>         { <br>           if (!*lpstr)        /* it's the root directory */ <br>              goto MustBeDir; <br> <br>           nFileOffset = PARSE_INVALIDPERIOD; <br>           goto FAILURE; <br>         } <br>        else <br>           ++lpstr;   /* it's saying top directory (again), thus allowed */ <br>      } <br>     else if ((*lpstr == '\\') &amp;&amp; (*(lpstr-1) == '\\')) <br>      { <br>/* It seems that for a full network path, whether a drive is declared or <br> * not is insignificant, though if a drive is given, it must be valid <br> * (hence the code above should remain there). <br> * 13 February 1991           clarkc <br> */ <br>        ++lpstr;            /* ...since it's the first slash, 2 are allowed */ <br>        nNetwork = -1;      /* Must receive server and share to be real     */ <br>        bUNCPath = TRUE;    /* No wildcards allowed if UNC name             */ <br>      } <br>     else if (*lpstr == '/') <br>      { <br>        nFileOffset = PARSE_INVALIDDIRCHAR; <br>        goto FAILURE; <br>      } <br>   } <br>  else if (*lpstr == chPeriod) <br>   { <br>     if (*++lpstr == chPeriod)  /* Is this up one directory? */ <br>        ++lpstr; <br>     if (!*lpstr) <br>        goto MustBeDir; <br>     if ((*lpstr != '\\') &amp;&amp; (*lpstr != '/')) <br>      { <br>        nFileOffset = PARSE_INVALIDPERIOD; <br>        goto FAILURE; <br>      } <br>     else <br>        ++lpstr;   /* it's saying directory, thus allowed */ <br>   } <br> <br>  if (!*lpstr) <br>   { <br>     goto MustBeDir; <br>   } <br> <br>/* Should point to first char in 8.3 filename by now */ <br>  nFileOffset = nExtOffset = nFile = nExt = 0; <br>  bWildcard = bExt = FALSE; <br>  while (*lpstr) <br>   { <br>/* <br> *  The next comparison MUST be unsigned to allow for extended characters! <br> *  21 Feb 1991   clarkc <br> */ <br>     if (*lpstr &lt; chSpace) <br>      { <br>        nFileOffset = PARSE_INVALIDCHAR; <br>        goto FAILURE; <br>      } <br>     switch (*lpstr) <br>      { <br>        case '"':             /* All invalid */ <br>        case '+': <br>        case ',': <br>        case ':': <br>        case ';': <br>        case '&lt;': <br>        case '=': <br>        case '&gt;': <br>        case '[': <br>        case ']': <br>        case '|': <br>         { <br>           nFileOffset = PARSE_INVALIDCHAR; <br>           goto FAILURE; <br>         } <br> <br>        case '\\':      /* Subdirectory indicators */ <br>        case '/': <br>         nNetwork++; <br>         if (bWildcard) <br>           { <br>            nFileOffset = PARSE_WILDCARDINDIR; <br>            goto FAILURE; <br>           } <br> <br>         else if (nFile == 0)        /* can't have 2 in a row */ <br>           { <br>            nFileOffset = PARSE_INVALIDDIRCHAR; <br>            goto FAILURE; <br>           } <br>         else <br>           {                         /* reset flags */ <br>            ++lpstr; <br>            if (!nNetwork &amp;&amp; !*lpstr) <br>              { <br>               nFileOffset = PARSE_INVALIDNETPATH; <br>               goto FAILURE; <br>              } <br>            nFile = nExt = 0; <br>            bExt = FALSE; <br>           } <br>         break; <br> <br>        case chSpace: <br>         { <br>           LPSTR lpSpace = lpstr; <br> <br>           *lpSpace = '\0'; <br>           while (*++lpSpace) <br>            { <br>              if (*lpSpace != chSpace) <br>               { <br>                 *lpstr = chSpace;        /* Reset string, abandon ship */ <br>                 nFileOffset = PARSE_INVALIDSPACE; <br>                 goto FAILURE; <br>               } <br>            } <br>         } <br>         break; <br> <br>        case chPeriod: <br>         if (nFile == 0) <br>           { <br>            if (*++lpstr == chPeriod) <br>               ++lpstr; <br>            if (!*lpstr) <br>               goto MustBeDir; <br> <br>            if ((*lpstr != '\\') &amp;&amp; (*lpstr != '/')) <br>              { <br>               nFileOffset = PARSE_INVALIDPERIOD; <br>               goto FAILURE; <br>              } <br> <br>            ++lpstr;              /* Flags are already set */ <br>           } <br>         else if (bExt) <br>           { <br>            nFileOffset = PARSE_INVALIDPERIOD;  /* can't have one in ext */ <br>            goto FAILURE; <br>           } <br>         else <br>           { <br>            nExtOffset = 0; <br>            ++lpstr; <br>            bExt = TRUE; <br>           } <br>         break; <br> <br>        case '*': <br>        case '?': <br>         if (bUNCPath) <br>           { <br>            nFileOffset = PARSE_INVALIDNETPATH; <br>            goto FAILURE; <br>           } <br>         bWildcard = TRUE; <br>/* Fall through to normal character processing */ <br> <br>        default: <br>         if (bExt) <br>           { <br>            if (++nExt == 1) <br>               nExtOffset = lpstr - lpstrFileName; <br>            else if (nExt &gt; 3) <br>              { <br>               nFileOffset = PARSE_EXTENTIONTOOLONG; <br>               goto FAILURE; <br>              } <br>            if ((nNetwork == -1) &amp;&amp; (nFile + nExt &gt; 11)) <br>              { <br>               nFileOffset = PARSE_INVALIDNETPATH; <br>               goto FAILURE; <br>              } <br>           } <br>         else if (++nFile == 1) <br>            nFileOffset = lpstr - lpstrFileName; <br>         else if (nFile &gt; 8) <br>           { <br>            /* If it's a server name, it can have 11 characters */ <br>            if (nNetwork != -1) <br>              { <br>               nFileOffset = PARSE_FILETOOLONG; <br>               goto FAILURE; <br>              } <br>            else if (nFile &gt; 11) <br>              { <br>               nFileOffset = PARSE_INVALIDNETPATH; <br>               goto FAILURE; <br>              } <br>           } <br> <br>         lpstr = AnsiNext(lpstr); <br>         break; <br>      } <br>   } <br> <br>/* Did we start with a double backslash but not have any more slashes? */ <br>  if (nNetwork == -1) <br>   { <br>     nFileOffset = PARSE_INVALIDNETPATH; <br>     goto FAILURE; <br>   } <br> <br>  if (!nFile) <br>   { <br>MustBeDir: <br>     nFileOffset = PARSE_DIRECTORYNAME; <br>     goto FAILURE; <br>   } <br> <br>  if ((*(lpstr - 1) == chPeriod) &amp;&amp;          /* if true, no extention wanted */ <br>           (*AnsiNext(lpstr-2) == chPeriod)) <br>     *(lpstr - 1) = '\0';               /* Remove terminating period   */ <br>  else if (!nExt) <br>FAILURE: <br>     nExtOffset = lpstr - lpstrFileName; <br> <br>  return(MAKELONG(nFileOffset, nExtOffset)); <br>} <br> <br> <br>/* <br> * DoesFileExist <br> * <br> * Purpose: <br> *  Determines if a file path exists <br> * <br> * Parameters: <br> *  lpszFile        LPSTR - file name <br> *  lpOpenBuf       OFSTRUCT FAR* - points to the OFSTRUCT structure that <br> *                      will receive information about the file when the <br> *                      file is first opened. this field is filled by the <br> *                      Windows OpenFile API. <br> * <br> * Return Value: <br> *  HFILE   HFILE_ERROR - file does NOT exist <br> *          file handle (as returned from OpenFile) - file exists <br> */ <br>HFILE WINAPI DoesFileExist(LPSTR lpszFile, OFSTRUCT FAR* lpOpenBuf) <br>{ <br>   long        nRet; <br>   int         i; <br>   static char *arrIllegalNames[] = { <br>      "LPT1", <br>      "LPT2", <br>      "LPT3", <br>      "COM1", <br>      "COM2", <br>      "COM3", <br>      "COM4", <br>      "CON", <br>      "AUX", <br>      "PRN" <br>   }; <br> <br>   // Check if file name is syntactically correct. <br>   //   (OpenFile sometimes crashes if path is not syntactically correct) <br>   nRet = ParseFile(lpszFile); <br>   if (LOWORD(nRet) &lt; 0) <br>      goto error; <br> <br>   // Check is the name is an illegal name (eg. the name of a device) <br>   for (i=0; i &lt; (sizeof(arrIllegalNames)/sizeof(arrIllegalNames[0])); i++) { <br>      if (lstrcmpi(lpszFile, arrIllegalNames[i])==0) </code></pre>
<p>
</p>
<pre><code>goto error; // illegal name FOUND <br>   } <br>   return OpenFile(lpszFile, lpOpenBuf, OF_EXIST); <br> <br>error: <br>   _fmemset(lpOpenBuf, 0, sizeof(OFSTRUCT)); <br>   lpOpenBuf-&gt;nErrCode = 0x0002;   // File not found <br>   return HFILE_ERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
