<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLESTD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context258"></a>OLESTD.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Standard Utilities <br>** <br>**    olestd.c <br>** <br>**    This file contains utilities that are useful for most standard <br>**        OLE 2.0 compound document type applications. <br>** <br>**    (c) Copyright Microsoft Corp. 1992-1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#define NONAMELESSUNION     // use strict ANSI standard (for DVOBJ.H) <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;shellapi.h&gt; <br>#include "common.h" <br> <br>OLEDBGDATA <br> <br>static char szAssertMemAlloc[] = "CoGetMalloc failed"; <br>static int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight); <br> <br> <br>/* OleStdSetupAdvises <br>** ------------------ <br>**    Setup the standard View advise required by a standard, <br>**    compound document-oriented container. Such a container relies on <br>**    Ole to manage the presentation of the Ole object. The container <br>**    call IViewObject::Draw to render (display) the object. <br>** <br>**    This helper routine performs the following tasks: <br>**                      setup View advise <br>**                      Call IOleObject::SetHostNames <br>**                      Call OleSetContainedObject <br>** <br>**    fCreate should be set to TRUE if the object is being created. if <br>**    an existing object is being loaded, then fCreate should be FALSE. <br>**    if it is a creation situation, then the ADVF_PRIMEFIRST flag is <br>**    used when settinp up the IViewObject::Advise. This will result in <br>**    the immediate sending of the initial picture. <br>** <br>**    NOTE: the standard container does NOT need to set up an OLE <br>**    Advise (IOleObject::Advise). this routine does NOT set up an OLE <br>**    Advise (a previous version of this function used to setup this <br>**    advise, but it was not useful). <br>*/ <br>STDAPI_(BOOL) OleStdSetupAdvises(LPOLEOBJECT lpOleObject, DWORD dwDrawAspect, <br>               LPOLESTR lpszContainerApp, LPOLESTR lpszContainerObj, <br>               LPADVISESINK lpAdviseSink, BOOL fCreate) <br>{ <br>   LPVIEWOBJECT lpViewObject; <br>   HRESULT hrErr; <br>   BOOL fStatus = TRUE; <br>#if defined( SPECIAL_CONTAINER ) <br>   DWORD dwTemp; <br>#endif <br> <br>   hrErr = lpOleObject-&gt;lpVtbl-&gt;QueryInterface( <br>         lpOleObject, <br>         &amp;IID_IViewObject, <br>         (LPVOID FAR*)&amp;lpViewObject <br>   ); <br> <br>   /* Setup View advise */ <br>   if (hrErr == NOERROR) { <br> <br>      OLEDBG_BEGIN2("IViewObject::SetAdvise called\r\n") <br>      lpViewObject-&gt;lpVtbl-&gt;SetAdvise( <br>            lpViewObject, <br>            dwDrawAspect, <br>            (fCreate ? ADVF_PRIMEFIRST : 0), <br>            lpAdviseSink <br>      ); <br>      OLEDBG_END2 <br> <br>      OleStdRelease((LPUNKNOWN)lpViewObject); <br>   } else { <br>      fStatus = FALSE; <br>   } <br> <br>#if defined( SPECIAL_CONTAINER ) <br>   /* Setup OLE advise. <br>   **    NOTE: normally containers do NOT need to setup an OLE <br>   **    advise. this advise connection is only useful for the OLE's <br>   **    DefHandler and the OleLink object implementation. some <br>   **    special container's might need to setup this advise for <br>   **    programatic reasons. <br>   ** <br>   **    NOTE: this advise will be torn down automatically by the <br>   **    server when we release the object, therefore we do not need <br>   **    to store the connection id. <br>   */ <br>   OLEDBG_BEGIN2("IOleObject::Advise called\r\n") <br>   hrErr = lpOleObject-&gt;lpVtbl-&gt;Advise( <br>         lpOleObject, <br>         lpAdviseSink, <br>         (DWORD FAR*)&amp;dwTemp <br>   ); <br>   OLEDBG_END2 <br>   if (hrErr != NOERROR) fStatus = FALSE; <br>#endif <br> <br>   /* Setup the host names for the OLE object. */ <br>   OLEDBG_BEGIN2("IOleObject::SetHostNames called\r\n") <br>   hrErr = lpOleObject-&gt;lpVtbl-&gt;SetHostNames( <br>         lpOleObject, <br>         lpszContainerApp, <br>         lpszContainerObj <br>   ); <br>   OLEDBG_END2 <br>   if (hrErr != NOERROR) fStatus = FALSE; <br> <br>   /* Inform the loadded object's handler/inproc-server that it is in <br>   **    its embedding container's process. <br>   */ <br>   OLEDBG_BEGIN2("OleSetContainedObject(TRUE) called\r\n") <br>   OleSetContainedObject((LPUNKNOWN)lpOleObject, TRUE); <br>   OLEDBG_END2 <br> <br>   return fStatus; <br>} <br> <br> <br>/* OleStdSwitchDisplayAspect <br>** ------------------------- <br>**    Switch the currently cached display aspect between DVASPECT_ICON <br>**    and DVASPECT_CONTENT. <br>** <br>**    NOTE: when setting up icon aspect, any currently cached content <br>**    cache is discarded and any advise connections for content aspect <br>**    are broken. <br>** <br>**    RETURNS: <br>**      S_OK -- new display aspect setup successfully <br>**      E_INVALIDARG -- IOleCache interface is NOT supported (this is <br>**                  required). <br>**      &lt;other SCODE&gt; -- any SCODE that can be returned by <br>**                  IOleCache::Cache method. <br>**      NOTE: if an error occurs then the current display aspect and <br>**            cache contents unchanged. <br>*/ <br>STDAPI OleStdSwitchDisplayAspect( <br>      LPOLEOBJECT             lpOleObj, <br>      LPDWORD                 lpdwCurAspect, <br>      DWORD                   dwNewAspect, <br>      HGLOBAL                 hMetaPict, <br>      BOOL                    fDeleteOldAspect, <br>      BOOL                    fSetupViewAdvise, <br>      LPADVISESINK            lpAdviseSink, <br>      BOOL FAR*               lpfMustUpdate <br>) <br>{ <br>   LPOLECACHE      lpOleCache = NULL; <br>   LPVIEWOBJECT    lpViewObj = NULL; <br>   LPENUMSTATDATA  lpEnumStatData = NULL; <br>   STATDATA        StatData; <br>   FORMATETC       FmtEtc; <br>   STGMEDIUM       Medium; <br>   DWORD           dwAdvf; <br>   DWORD           dwNewConnection; <br>   DWORD           dwOldAspect = *lpdwCurAspect; <br>   HRESULT         hrErr; <br> <br>   if (lpfMustUpdate) <br>      *lpfMustUpdate = FALSE; <br> <br>   lpOleCache = (LPOLECACHE)OleStdQueryInterface( <br>                              (LPUNKNOWN)lpOleObj,&amp;IID_IOleCache); <br> <br>   // if IOleCache* is NOT available, do nothing <br>   if (! lpOleCache) <br>      return E_INVALIDARG; <br> <br>   // Setup new cache with the new aspect <br>   FmtEtc.cfFormat = 0;     // whatever is needed to draw <br>   FmtEtc.ptd      = NULL; <br>   FmtEtc.dwAspect = dwNewAspect; <br>   FmtEtc.lindex   = -1; <br>   FmtEtc.tymed    = TYMED_NULL; <br> <br>   /* NOTE: if we are setting up Icon aspect with a custom icon <br>   **    then we do not want DataAdvise notifications to ever change <br>   **    the contents of the data cache. thus we set up a NODATA <br>   **    advise connection. otherwise we set up a standard DataAdvise <br>   **    connection. <br>   */ <br>   if (dwNewAspect == DVASPECT_ICON &amp;&amp; hMetaPict) <br>      dwAdvf = ADVF_NODATA; <br>   else <br>      dwAdvf = ADVF_PRIMEFIRST; <br> <br>   OLEDBG_BEGIN2("IOleCache::Cache called\r\n") <br>   hrErr = lpOleCache-&gt;lpVtbl-&gt;Cache( <br>         lpOleCache, <br>         (LPFORMATETC)&amp;FmtEtc, <br>         dwAdvf, <br>         (LPDWORD)&amp;dwNewConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   if (! SUCCEEDED(hrErr)) { <br>      OleDbgOutHResult("IOleCache::Cache returned", hrErr); <br>      OleStdRelease((LPUNKNOWN)lpOleCache); <br>      return hrErr; <br>   } <br> <br>   *lpdwCurAspect = dwNewAspect; <br> <br>   /* NOTE: if we are setting up Icon aspect with a custom icon, <br>   **    then stuff the icon into the cache. otherwise the cache must <br>   **    be forced to be updated. set the *lpfMustUpdate flag to tell <br>   **    caller to force the object to Run so that the cache will be <br>   **    updated. <br>   */ <br>   if (dwNewAspect == DVASPECT_ICON &amp;&amp; hMetaPict) { <br> <br>      FmtEtc.cfFormat = CF_METAFILEPICT; <br>      FmtEtc.ptd      = NULL; <br>      FmtEtc.dwAspect = DVASPECT_ICON; <br>      FmtEtc.lindex   = -1; <br>      FmtEtc.tymed    = TYMED_MFPICT; <br> <br>      Medium.tymed            = TYMED_MFPICT; <br>      Medium.u.hGlobal        = hMetaPict; <br>      Medium.pUnkForRelease   = NULL; <br> <br>      OLEDBG_BEGIN2("IOleCache::SetData called\r\n") <br>      hrErr = lpOleCache-&gt;lpVtbl-&gt;SetData( <br>            lpOleCache, <br>            (LPFORMATETC)&amp;FmtEtc, <br>            (LPSTGMEDIUM)&amp;Medium, <br>            FALSE   /* fRelease */ <br>      ); <br>      OLEDBG_END2 <br>   } else { <br>      if (lpfMustUpdate) <br>         *lpfMustUpdate = TRUE; <br>   } <br> <br>   if (fSetupViewAdvise &amp;&amp; lpAdviseSink) { <br>      /* NOTE: re-establish the ViewAdvise connection */ <br>      lpViewObj = (LPVIEWOBJECT)OleStdQueryInterface( <br>                              (LPUNKNOWN)lpOleObj,&amp;IID_IViewObject); <br> <br>      if (lpViewObj) { <br> <br>         OLEDBG_BEGIN2("IViewObject::SetAdvise called\r\n") <br>         lpViewObj-&gt;lpVtbl-&gt;SetAdvise( <br>               lpViewObj, <br>               dwNewAspect, <br>               0, <br>               lpAdviseSink <br>         ); <br>         OLEDBG_END2 <br> <br>         OleStdRelease((LPUNKNOWN)lpViewObj); <br>      } <br>   } <br> <br>   /* NOTE: remove any existing caches that are set up for the old <br>   **    display aspect. It WOULD be possible to retain the caches set <br>   **    up for the old aspect, but this would increase the storage <br>   **    space required for the object and possibly require additional <br>   **    overhead to maintain the unused cachaes. For these reasons the <br>   **    strategy to delete the previous caches is prefered. if it is a <br>   **    requirement to quickly switch between Icon and Content <br>   **    display, then it would be better to keep both aspect caches. <br>   */ <br> <br>   if (fDeleteOldAspect) { <br>      OLEDBG_BEGIN2("IOleCache::EnumCache called\r\n") <br>      hrErr = lpOleCache-&gt;lpVtbl-&gt;EnumCache( <br>            lpOleCache, <br>            (LPENUMSTATDATA FAR*)&amp;lpEnumStatData <br>      ); <br>      OLEDBG_END2 <br> <br>      while(hrErr == NOERROR) { <br>         hrErr = lpEnumStatData-&gt;lpVtbl-&gt;Next( <br>               lpEnumStatData, <br>               1, <br>               (LPSTATDATA)&amp;StatData, <br>               NULL <br>         ); <br>         if (hrErr != NOERROR) <br>            break;              // DONE! no more caches. <br> <br>         if (StatData.formatetc.dwAspect == dwOldAspect) { <br> <br>            // Remove previous cache with old aspect <br>            OLEDBG_BEGIN2("IOleCache::Uncache called\r\n") <br>            lpOleCache-&gt;lpVtbl-&gt;Uncache(lpOleCache,StatData.dwConnection); <br>            OLEDBG_END2 <br>         } <br>      } <br> <br>      if (lpEnumStatData) { <br>         OleStdVerifyRelease( <br>               (LPUNKNOWN)lpEnumStatData, <br>               OLESTR ("OleStdSwitchDisplayAspect: Cache enumerator NOT released")); <br>      } <br>   } <br> <br>   if (lpOleCache) <br>      OleStdRelease((LPUNKNOWN)lpOleCache); <br> <br>   return NOERROR; <br>} <br> <br> <br>/* OleStdSetIconInCache <br>** -------------------- <br>**    SetData a new icon into the existing DVASPECT_ICON cache. <br>** <br>**    RETURNS: <br>**      HRESULT returned from IOleCache::SetData <br>*/ <br>STDAPI OleStdSetIconInCache(LPOLEOBJECT lpOleObj, HGLOBAL hMetaPict) <br>{ <br>   LPOLECACHE      lpOleCache = NULL; <br>   FORMATETC       FmtEtc; <br>   STGMEDIUM       Medium; <br>   HRESULT         hrErr; <br> <br>   if (! hMetaPict) <br>      return FALSE;   // invalid icon <br> <br>   lpOleCache = (LPOLECACHE)OleStdQueryInterface( <br>                              (LPUNKNOWN)lpOleObj,&amp;IID_IOleCache); <br>   if (! lpOleCache) <br>      return FALSE;   // if IOleCache* is NOT available, do nothing <br> <br>   FmtEtc.cfFormat = CF_METAFILEPICT; <br>   FmtEtc.ptd      = NULL; <br>   FmtEtc.dwAspect = DVASPECT_ICON; <br>   FmtEtc.lindex   = -1; <br>   FmtEtc.tymed    = TYMED_MFPICT; <br> <br>   // stuff the icon into the cache. <br>   Medium.tymed            = TYMED_MFPICT; <br>   Medium.u.hGlobal        = hMetaPict; <br>   Medium.pUnkForRelease   = NULL; <br> <br>   OLEDBG_BEGIN2("IOleCache::SetData called\r\n") <br>   hrErr = lpOleCache-&gt;lpVtbl-&gt;SetData( <br>         lpOleCache, <br>         (LPFORMATETC)&amp;FmtEtc, <br>         (LPSTGMEDIUM)&amp;Medium, <br>         FALSE   /* fRelease */ <br>   ); <br>   OLEDBG_END2 <br> <br>   OleStdRelease((LPUNKNOWN)lpOleCache); <br> <br>   return hrErr; <br>} <br> <br> <br> <br>/* OleStdDoConvert <br>** --------------- <br>** Do the container-side responsibilities for converting an object. <br>**    This function would be used in conjunction with the OleUIConvert <br>**    dialog. If the user selects to convert an object then the <br>**    container must do the following: <br>**          1. unload the object. <br>**          2. write the NEW CLSID and NEW user type name <br>**              string into the storage of the object, <br>**              BUT write the OLD format tag. <br>**          3. force an update of the object to force the actual <br>**              conversion of the data bits. <br>** <br>**    This function takes care of step 2. <br>*/ <br>STDAPI OleStdDoConvert(LPSTORAGE lpStg, REFCLSID rClsidNew) <br>{ <br>   HRESULT error; <br>   CLSID clsidOld; <br>   CLIPFORMAT cfOld; <br>   LPOLESTR lpszOld = NULL; <br>   OLECHAR szNew[OLEUI_CCHKEYMAX]; <br> <br>   if ((error = ReadClassStg(lpStg, &amp;clsidOld)) != NOERROR) { <br>      clsidOld = CLSID_NULL; <br>      goto errRtn; <br>   } <br> <br>   // read old fmt/old user type; sets out params to NULL on error <br>   error = ReadFmtUserTypeStg(lpStg, &amp;cfOld, &amp;lpszOld); <br>   OleDbgAssert(error == NOERROR || (cfOld == 0 &amp;&amp; lpszOld == NULL)); <br> <br>   // get new user type name; if error, set to NULL string <br>   if (OleStdGetUserTypeOfClass( <br>         (LPCLSID)rClsidNew, szNew, OLEUI_CCHKEYMAX,NULL /* hKey */) == 0) <br>      OLESTRCPY (szNew, OLESTR ("")); <br> <br>   // write class stg <br>   if ((error = WriteClassStg(lpStg, rClsidNew)) != NOERROR) <br>      goto errRtn; <br> <br>   // write old fmt/new user type; <br>   if ((error = WriteFmtUserTypeStg(lpStg, cfOld, szNew)) != NOERROR) <br>      goto errRewriteInfo; <br> <br>   // set convert bit <br>   if ((error = SetConvertStg(lpStg, TRUE)) != NOERROR) <br>      goto errRewriteInfo; <br> <br>   goto okRtn; <br> <br>errRewriteInfo: <br>   (void)WriteClassStg(lpStg, &amp;clsidOld); <br>   (void)WriteFmtUserTypeStg(lpStg, cfOld, lpszOld); <br> <br>errRtn: <br> <br>okRtn: <br>   OleStdFreeString(lpszOld, NULL); <br>   return error; <br>} <br> <br> <br>/* OleStdGetTreatAsFmtUserType <br>** --------------------------- <br>**    Determine if the application should perform a TreatAs (ActivateAs <br>**    object or emulation) operation for the object that is stored in <br>**    the storage. <br>** <br>**    if the CLSID written in the storage is not the same as the <br>**    application's own CLSID (clsidApp), then a TreatAs operation <br>**    should take place. if so determine the format the data should be <br>**    written and the user type name of the object the app should <br>**    emulate (ie. pretend to be). if this information is not written <br>**    in the storage then it is looked up in the REGDB. if it can not <br>**    be found in the REGDB, then the TreatAs operation can NOT be <br>**    executed. <br>** <br>**    RETURNS: TRUE -- if TreatAs should be performed. <br>**               valid lpclsid, lplpszType, lpcfFmt to TreatAs are returned <br>**                      (NOTE: lplpszType must be freed by caller) <br>**             FALSE -- NO TreatAs. lpszType will be NULL. <br>**               lpclsid = CLSID_NULL; lplpszType = lpcfFmt = NULL; <br>*/ <br>STDAPI_(BOOL) OleStdGetTreatAsFmtUserType( <br>      REFCLSID        rclsidApp, <br>      LPSTORAGE       lpStg, <br>      CLSID FAR*      lpclsid, <br>      CLIPFORMAT FAR* lpcfFmt, <br>      LPOLESTR FAR*   lplpszType <br>) <br>{ <br>   HRESULT hrErr; <br>   HKEY    hKey; <br>   LONG    lRet; <br>   UINT    lSize; <br>   OLECHAR szBuf[OLEUI_CCHKEYMAX]; <br> <br>   *lpclsid    = CLSID_NULL; <br>   *lpcfFmt    = 0; <br>   *lplpszType = NULL; <br> <br>   hrErr = ReadClassStg(lpStg, lpclsid); <br>   if (hrErr == NOERROR &amp;&amp; <br>      ! IsEqualCLSID(lpclsid, &amp;CLSID_NULL) &amp;&amp; <br>      ! IsEqualCLSID(lpclsid, rclsidApp)) { <br> <br>      hrErr = ReadFmtUserTypeStg(lpStg,(CLIPFORMAT FAR*)lpcfFmt,lplpszType); <br>      if (hrErr == NOERROR &amp;&amp; lplpszType &amp;&amp; *lpcfFmt != 0) <br>         return TRUE;    // Do TreatAs. info was in lpStg. <br> <br>      /* read info from REGDB <br>      **    *lpcfFmt = value of field: CLSID\{...}\DataFormats\DefaultFile <br>      **    *lplpszType = value of field: CLSID\{...} <br>      */ <br>      //Open up the root key. <br>      lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br>      if (lRet != (LONG)ERROR_SUCCESS) <br>         return FALSE; <br>      *lpcfFmt = OleStdGetDefaultFileFormatOfClass(lpclsid, hKey); <br>      if (*lpcfFmt == 0) <br>         return FALSE; <br>      lSize = OleStdGetUserTypeOfClass(lpclsid,szBuf,OLEUI_CCHKEYMAX, hKey); <br>      if (lSize == 0) <br>         return FALSE; <br>      *lplpszType = OleStdCopyString(szBuf, NULL); <br>   } else { <br>      return FALSE;       // NO TreatAs <br>   } <br>} <br> <br> <br> <br>/* OleStdDoTreatAsClass <br>** -------------------- <br>** Do the container-side responsibilities for "ActivateAs" (aka. <br>**    TreatAs) for an object. <br>**    This function would be used in conjunction with the OleUIConvert <br>**    dialog. If the user selects to ActivateAs an object then the <br>**    container must do the following: <br>**          1. unload ALL objects of the OLD class that app knows about <br>**          2. add the TreatAs tag in the registration database <br>**              by calling CoTreatAsClass(). <br>**          3. lazily it can reload the objects; when the objects <br>**              are reloaded the TreatAs will take effect. <br>** <br>**    This function takes care of step 2. <br>*/ <br>STDAPI OleStdDoTreatAsClass(LPOLESTR lpszUserType, REFCLSID rclsid, REFCLSID rclsidNew) <br>{ <br>   HRESULT hrErr; <br>   LPOLESTR   lpszCLSID = NULL; <br>   char       lpszAnsiCLSID[256]; <br>   LONG    lRet; <br>   HKEY    hKey; <br>   char    lpszAnsiUserType[256]; <br> <br>   OLEDBG_BEGIN2("CoTreatAsClass called\r\n") <br>   hrErr = CoTreatAsClass(rclsid, rclsidNew); <br>   OLEDBG_END2 <br> <br>   if ((hrErr != NOERROR) &amp;&amp; lpszUserType) { <br>      lRet = RegOpenKey(HKEY_CLASSES_ROOT, (LPCSTR)"CLSID", <br>            (HKEY FAR *)&amp;hKey); <br>      StringFromCLSID(rclsid, /*(LPOLESTR FAR*)*/&amp;lpszCLSID); <br>      W2A (lpszCLSID, lpszAnsiCLSID, 256); <br>      W2A (lpszUserType, lpszAnsiUserType, 256); <br>      RegSetValue(hKey, lpszAnsiCLSID, REG_SZ, lpszAnsiUserType, <br>            lstrlen(lpszAnsiUserType)); <br> <br>      if (lpszCLSID) <br>         OleStdFreeString(lpszCLSID, NULL); <br> <br>      hrErr = CoTreatAsClass(rclsid, rclsidNew); <br>      RegCloseKey(hKey); <br>   } <br> <br>   return hrErr; <br>} <br> <br> <br> <br>/* OleStdIsOleLink <br>** --------------- <br>**    Returns TRUE if the OleObject is infact an OLE link object. this <br>**    checks if IOleLink interface is supported. if so, the object is a <br>**    link, otherwise not. <br>*/ <br>STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk) <br>{ <br>   LPOLELINK lpOleLink; <br> <br>   lpOleLink = (LPOLELINK)OleStdQueryInterface(lpUnk, &amp;IID_IOleLink); <br> <br>   if (lpOleLink) { <br>      OleStdRelease((LPUNKNOWN)lpOleLink); <br>      return TRUE; <br>   } else <br>      return FALSE; <br>} <br> <br> <br>/* OleStdQueryInterface <br>** -------------------- <br>**    Returns the desired interface pointer if exposed by the given object. <br>**    Returns NULL if the interface is not available. <br>**    eg.: <br>**      lpDataObj = OleStdQueryInterface(lpOleObj, &amp;IID_DataObject); <br>*/ <br>STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid) <br>{ <br>   LPUNKNOWN lpInterface; <br>   HRESULT hrErr; <br> <br>   hrErr = lpUnk-&gt;lpVtbl-&gt;QueryInterface( <br>         lpUnk, <br>         riid, <br>         (LPVOID FAR*)&amp;lpInterface <br>   ); <br> <br>   if (hrErr == NOERROR) <br>      return lpInterface; <br>   else <br>      return NULL; <br>} <br> <br> <br>/* OleStdGetData <br>** ------------- <br>**    Retrieve data from an IDataObject in a specified format on a <br>**    global memory block. This function ALWAYS returns a private copy <br>**    of the data to the caller. if necessary a copy is made of the <br>**    data (ie. if lpMedium-&gt;pUnkForRelease != NULL). The caller assumes <br>**    ownership of the data block in all cases and must free the data <br>**    when done with it. The caller may directly free the data handle <br>**    returned (taking care whether it is a simple HGLOBAL or a HANDLE <br>**    to a MetafilePict) or the caller may call <br>**    ReleaseStgMedium(lpMedium). this OLE helper function will do the <br>**    right thing. <br>** <br>**    PARAMETERS: <br>**        LPDATAOBJECT lpDataObj  -- object on which GetData should be <br>**                                                         called. <br>**        CLIPFORMAT cfFormat     -- desired clipboard format (eg. CF_TEXT) <br>**        DVTARGETDEVICE FAR* lpTargetDevice -- target device for which <br>**                                  the data should be composed. This may <br>**                                  be NULL. NULL can be used whenever the <br>**                                  data format is insensitive to target <br>**                                  device or when the caller does not care <br>**                                  what device is used. <br>**        LPSTGMEDIUM lpMedium    -- ptr to STGMEDIUM struct. the <br>**                                  resultant medium from the <br>**                                  IDataObject::GetData call is <br>**                                  returned. <br>** <br>**    RETURNS: <br>**       HGLOBAL -- global memory handle of retrieved data block. <br>**       NULL    -- if error. <br>*/ <br>STDAPI_(HGLOBAL) OleStdGetData( <br>      LPDATAOBJECT        lpDataObj, <br>      CLIPFORMAT          cfFormat, <br>      DVTARGETDEVICE FAR* lpTargetDevice, <br>      DWORD               dwDrawAspect, <br>      LPSTGMEDIUM         lpMedium <br>) <br>{ <br>   HRESULT hrErr; <br>   FORMATETC formatetc; <br>   HGLOBAL hGlobal = NULL; <br>   HGLOBAL hCopy; <br>   LPVOID  lp; <br> <br>   formatetc.cfFormat = cfFormat; <br>   formatetc.ptd = lpTargetDevice; <br>   formatetc.dwAspect = dwDrawAspect; <br>   formatetc.lindex = -1; <br> <br>   switch (cfFormat) { <br>      case CF_METAFILEPICT: <br>         formatetc.tymed = TYMED_MFPICT; <br>         break; <br> <br>      case CF_BITMAP: <br>         formatetc.tymed = TYMED_GDI; <br>         break; <br> <br>      default: <br>         formatetc.tymed = TYMED_HGLOBAL; <br>         break; <br>   } <br> <br>   OLEDBG_BEGIN2("IDataObject::GetData called\r\n") <br>   hrErr = lpDataObj-&gt;lpVtbl-&gt;GetData( <br>         lpDataObj, <br>         (LPFORMATETC)&amp;formatetc, <br>         lpMedium <br>   ); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) <br>      return NULL; <br> <br>   if ((hGlobal = lpMedium-&gt;u.hGlobal) == NULL) <br>      return NULL; <br> <br>   // Check if hGlobal really points to valid memory <br>   if ((lp = GlobalLock(hGlobal)) != NULL) { <br>      if (IsBadReadPtr(lp, 1)) { <br>         GlobalUnlock(hGlobal); <br>         return NULL;    // ERROR: memory is NOT valid <br>      } <br>      GlobalUnlock(hGlobal); <br>   } <br> <br>   if (hGlobal != NULL &amp;&amp; lpMedium-&gt;pUnkForRelease != NULL) { <br>      /* NOTE: the callee wants to retain ownership of the data. <br>      **    this is indicated by passing a non-NULL pUnkForRelease. <br>      **    thus, we will make a copy of the data and release the <br>      **    callee's copy. <br>      */ <br> <br>      hCopy = OleDuplicateData(hGlobal, cfFormat, GHND|GMEM_SHARE); <br>      ReleaseStgMedium(lpMedium); // release callee's copy of data <br> <br>      hGlobal = hCopy; <br>      lpMedium-&gt;u.hGlobal = hCopy; <br>      lpMedium-&gt;pUnkForRelease = NULL; <br>   } <br>   return hGlobal; <br>} <br> <br> <br>/* OleStdMalloc <br>** ------------ <br>**    allocate memory using the currently active IMalloc* allocator <br>*/ <br>STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize) <br>{ <br>   LPVOID pout; <br>   LPMALLOC pmalloc; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      OleDbgAssertSz(0, szAssertMemAlloc); <br>      return NULL; <br>   } <br> <br>   pout = (LPVOID)pmalloc-&gt;lpVtbl-&gt;Alloc(pmalloc, ulSize); <br> <br>   if (pmalloc != NULL) { <br>      ULONG refs = pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>   } <br> <br>   return pout; <br>} <br> <br> <br>/* OleStdRealloc <br>** ------------- <br>**    re-allocate memory using the currently active IMalloc* allocator <br>*/ <br>STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize) <br>{ <br>   LPVOID pout = NULL; <br>   LPMALLOC pmalloc; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      OleDbgAssertSz(0, szAssertMemAlloc); <br>      return NULL; <br>   } <br> <br>   if (pmalloc != NULL) <br>   { <br>       ULONG refs; <br>       pout = (LPVOID)pmalloc-&gt;lpVtbl-&gt;Realloc(pmalloc, pmem, ulSize); <br>       refs = pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>   } <br> <br>   return pout; <br>} <br> <br> <br>/* OleStdFree <br>** ---------- <br>**    free memory using the currently active IMalloc* allocator <br>*/ <br>STDAPI_(void) OleStdFree(LPVOID pmem) <br>{ <br>   LPMALLOC pmalloc; <br> <br>   if (pmem == NULL) <br>      return; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      OleDbgAssertSz(0, szAssertMemAlloc); <br>      return; <br>   } <br> <br> <br>    if (pmalloc != NULL) <br>    { <br>        ULONG refs; <br>#if defined(_DEBUG) <br>        int iReturn; <br>        iReturn = pmalloc-&gt;lpVtbl-&gt;DidAlloc(pmalloc, pmem); <br>        OleDbgAssertSz(1 == iReturn, "OleStdFree tried to release a suspicious pointer"); <br>#endif <br>        pmalloc-&gt;lpVtbl-&gt;Free(pmalloc, pmem); <br>        refs = pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>    } <br>} <br> <br> <br>/* OleStdGetSize <br>** ------------- <br>**    Get the size of a memory block that was allocated using the <br>**    currently active IMalloc* allocator. <br>*/ <br>STDAPI_(ULONG) OleStdGetSize(LPVOID pmem) <br>{ <br>   ULONG ulSize; <br>   LPMALLOC pmalloc; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      OleDbgAssertSz(0, szAssertMemAlloc); <br>      return (ULONG)-1; <br>   } <br> <br>   ulSize = pmalloc-&gt;lpVtbl-&gt;GetSize(pmalloc, pmem); <br> <br>   if (pmalloc != NULL) { <br>      ULONG refs = pmalloc-&gt;lpVtbl-&gt;Release(pmalloc); <br>   } <br> <br>   return ulSize; <br>} <br> <br> <br>/* OleStdFreeString <br>** ---------------- <br>**    Free a string that was allocated with the currently active <br>**    IMalloc* allocator. <br>** <br>**    if the caller has the current IMalloc* handy, then it can be <br>**    passed as a argument, otherwise this function will retrieve the <br>**    active allocator and use it. <br>*/ <br>STDAPI_(void) OleStdFreeString(LPOLESTR lpsz, LPMALLOC lpMalloc) <br>{ <br>   BOOL fMustRelease = FALSE; <br> <br>   if (! lpMalloc) { <br>      if (CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc) != NOERROR) <br>         return; <br>      fMustRelease = TRUE; <br>   } <br> <br>   lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpsz); <br> <br>   if (fMustRelease) <br>      lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br>} <br> <br> <br>/* OleStdCopyString <br>** ---------------- <br>**    Copy a string into memory allocated with the currently active <br>**    IMalloc* allocator. <br>** <br>**    if the caller has the current IMalloc* handy, then it can be <br>**    passed as a argument, otherwise this function will retrieve the <br>**    active allocator and use it. <br>*/ <br>STDAPI_(LPOLESTR) OleStdCopyString(LPOLESTR lpszSrc, LPMALLOC lpMalloc) <br>{ <br>   LPOLESTR lpszDest = NULL; <br>   BOOL fMustRelease = FALSE; <br>   UINT lSize = OLESTRLEN(lpszSrc); <br> <br>   if (! lpMalloc) { <br>      if (CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc) != NOERROR) <br>         return NULL; <br>      fMustRelease = TRUE; <br>   } <br> <br>   lpszDest = lpMalloc-&gt;lpVtbl-&gt;Alloc(lpMalloc, (lSize+1)*sizeof(OLECHAR)); <br> <br>   if (lpszDest) <br>      OLESTRCPY(lpszDest, lpszSrc); <br> <br>   if (fMustRelease) <br>      lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br>   return lpszDest; <br>} <br> <br> <br>/* <br> * OleStdCreateStorageOnHGlobal() <br> * <br> * Purpose: <br> *  Create a memory based IStorage*. <br> * <br> *  NOTE: if fDeleteOnRelease==TRUE, then the ILockBytes is created <br> *            such that it will delete them memory on its last release. <br> *            the IStorage on created on top of the ILockBytes in NOT <br> *            created with STGM_DELETEONRELEASE. when the IStorage receives <br> *            its last release, it will release the ILockBytes which will <br> *            in turn free the memory. it is in fact an error to specify <br> *            STGM_DELETEONRELEASE in this situation. <br> * <br> * Parameters: <br> *  hGlobal --  handle to MEM_SHARE allocated memory. may be NULL and <br> *              memory will be automatically allocated. <br> *  fDeleteOnRelease -- controls if the memory is freed on the last release. <br> *  grfMode --  flags passed to StgCreateDocfileOnILockBytes <br> * <br> *  NOTE: if hGlobal is NULL, then a new IStorage is created and <br> *              STGM_CREATE flag is passed to StgCreateDocfileOnILockBytes. <br> *        if hGlobal is non-NULL, then it is assumed that the hGlobal already <br> *              has an IStorage inside it and STGM_CONVERT flag is passed <br> *              to StgCreateDocfileOnILockBytes. <br> * <br> * Return Value: <br> *    SCODE  -  S_OK if successful <br> */ <br>STDAPI_(LPSTORAGE) OleStdCreateStorageOnHGlobal( <br>      HANDLE hGlobal, <br>      BOOL fDeleteOnRelease, <br>      DWORD grfMode <br>) <br>{ <br>   DWORD grfCreateMode=grfMode | (hGlobal==NULL ? STGM_CREATE:STGM_CONVERT); <br>   HRESULT hrErr; <br>   LPLOCKBYTES lpLockBytes = NULL; <br>   DWORD reserved = 0; <br>   LPSTORAGE lpStg = NULL; <br> <br>   hrErr = CreateILockBytesOnHGlobal( <br>         hGlobal, <br>         fDeleteOnRelease, <br>         (LPLOCKBYTES FAR*)&amp;lpLockBytes <br>   ); <br>   if (hrErr != NOERROR) <br>      return NULL; <br> <br>   hrErr = StgCreateDocfileOnILockBytes( <br>         lpLockBytes, <br>         grfCreateMode, <br>         reserved, <br>         (LPSTORAGE FAR*)&amp;lpStg <br>   ); <br>   if (hrErr != NOERROR) { <br>      OleStdRelease((LPUNKNOWN)lpLockBytes); <br>      return NULL; <br>   } <br>   OleStdRelease((LPUNKNOWN)lpLockBytes); <br>   return lpStg; <br>} <br> <br> <br> <br>/* <br> * OleStdCreateTempStorage() <br> * <br> * Purpose: <br> *  Create a temporay IStorage* that will DeleteOnRelease. <br> *  this can be either memory based or file based. <br> * <br> * Parameters: <br> *  fUseMemory -- controls if memory-based or file-based stg is created <br> *  grfMode --  storage mode flags <br> * <br> * Return Value: <br> *    LPSTORAGE  -  if successful, NULL otherwise <br> */ <br>STDAPI_(LPSTORAGE) OleStdCreateTempStorage(BOOL fUseMemory, DWORD grfMode) <br>{ <br>   LPSTORAGE   lpstg; <br>   HRESULT     hrErr; <br>   DWORD       reserved = 0; <br> <br>   if (fUseMemory) { <br>      lpstg = OleStdCreateStorageOnHGlobal( <br>            NULL,  /* auto allocate */ <br>            TRUE,  /* delete on release */ </code></pre>
<p>
</p>
<pre><code>grfMode <br>      ); <br>   } else { <br>      /* allocate a temp docfile that will delete on last release */ <br>      hrErr = StgCreateDocfile( <br>            NULL, <br>            grfMode | STGM_DELETEONRELEASE | STGM_CREATE, <br>            reserved, <br>            &amp;lpstg <br>      ); <br>      if (hrErr != NOERROR) <br>         return NULL; <br>   } <br>   return lpstg; <br>} <br> <br> <br>/* OleStdGetOleObjectData <br>** ---------------------- <br>**    Render CF_EMBEDSOURCE/CF_EMBEDDEDOBJECT data on an TYMED_ISTORAGE <br>**    medium by asking the object to save into the storage. <br>**    the object must support IPersistStorage. <br>** <br>**    if lpMedium-&gt;tymed == TYMED_NULL, then a delete-on-release <br>**    storage is allocated (either file-based or memory-base depending <br>**    the value of fUseMemory). this is useful to support an <br>**    IDataObject::GetData call where the callee must allocate the <br>**    medium. <br>** <br>**    if lpMedium-&gt;tymed == TYMED_ISTORAGE, then the data is writen <br>**    into the passed in IStorage. this is useful to support an <br>**    IDataObject::GetDataHere call where the caller has allocated his <br>**    own IStorage. <br>*/ <br>STDAPI OleStdGetOleObjectData( <br>      LPPERSISTSTORAGE        lpPStg, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium, <br>      BOOL                    fUseMemory <br>) <br>{ <br>   LPSTORAGE   lpstg = NULL; <br>   DWORD       reserved = 0; <br>   SCODE       sc = S_OK; <br>   HRESULT     hrErr; <br> <br>   lpMedium-&gt;pUnkForRelease = NULL; <br> <br>   if (lpMedium-&gt;tymed == TYMED_NULL) { <br> <br>      if (lpformatetc-&gt;tymed &amp; TYMED_ISTORAGE) { <br> <br>         /* allocate a temp docfile that will delete on last release */ <br>         lpstg = OleStdCreateTempStorage( <br>               TRUE /*fUseMemory*/, <br>               STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE <br>         ); <br>         if (!lpstg) <br>            return E_OUTOFMEMORY; <br> <br>         lpMedium-&gt;u.pstg = lpstg; <br>         lpMedium-&gt;tymed = TYMED_ISTORAGE; <br>         lpMedium-&gt;pUnkForRelease = NULL; <br>      } else { <br>         return DATA_E_FORMATETC; <br>      } <br>   } else if (lpMedium-&gt;tymed == TYMED_ISTORAGE) { <br>      lpMedium-&gt;tymed = TYMED_ISTORAGE; <br>   } else { <br>      return DATA_E_FORMATETC; <br>   } <br> <br>   // NOTE: even if OleSave returns an error you should still call <br>   // SaveCompleted. <br> <br>   OLEDBG_BEGIN2("OleSave called\r\n") <br>   hrErr = OleSave(lpPStg, lpMedium-&gt;u.pstg, FALSE /* fSameAsLoad */); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("WARNING: OleSave returned", hrErr); <br>      sc = hrErr; <br>   } <br>   OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n") <br>   hrErr = lpPStg-&gt;lpVtbl-&gt;SaveCompleted(lpPStg, NULL); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr); <br>      if (sc == S_OK) <br>         sc = hrErr; <br>   } <br> <br>   return sc; <br>} <br> <br> <br>STDAPI OleStdGetLinkSourceData( <br>      LPMONIKER           lpmk, <br>      LPCLSID             lpClsID, <br>      LPFORMATETC         lpformatetc, <br>      LPSTGMEDIUM         lpMedium <br>) <br>{ <br>   LPSTREAM    lpstm = NULL; <br>   DWORD       reserved = 0; <br>   HRESULT     hrErr; <br> <br>   if (lpMedium-&gt;tymed == TYMED_NULL) { <br>      if (lpformatetc-&gt;tymed &amp; TYMED_ISTREAM) { <br>         hrErr = CreateStreamOnHGlobal( <br>               NULL, /* auto allocate */ <br>               TRUE, /* delete on release */ <br>               (LPSTREAM FAR*)&amp;lpstm <br>         ); <br>         if (hrErr != NOERROR) { <br>            lpMedium-&gt;pUnkForRelease = NULL; <br>            return E_OUTOFMEMORY; <br>         } <br>         lpMedium-&gt;u.pstm = lpstm; <br>         lpMedium-&gt;tymed = TYMED_ISTREAM; <br>         lpMedium-&gt;pUnkForRelease = NULL; <br>      } else { <br>         lpMedium-&gt;pUnkForRelease = NULL; <br>         return DATA_E_FORMATETC; <br>      } <br>   } else { <br>      if (lpMedium-&gt;tymed == TYMED_ISTREAM) { <br>         lpMedium-&gt;tymed = TYMED_ISTREAM; <br>         lpMedium-&gt;u.pstm = lpMedium-&gt;u.pstm; <br>         lpMedium-&gt;pUnkForRelease = NULL; <br>      } else { <br>         lpMedium-&gt;pUnkForRelease = NULL; <br>         return DATA_E_FORMATETC; <br>      } <br>   } <br> <br>   hrErr = OleSaveToStream((LPPERSISTSTREAM)lpmk, lpMedium-&gt;u.pstm); <br>   if (hrErr != NOERROR) return hrErr; <br>   return WriteClassStm(lpMedium-&gt;u.pstm, lpClsID); <br>} <br> <br>/* <br> * OleStdGetObjectDescriptorData <br> * <br> * Purpose: <br> *  Fills and returns a OBJECTDESCRIPTOR structure. <br> *  See OBJECTDESCRIPTOR for more information. <br> * <br> * Parameters: <br> *  clsid           CLSID   CLSID of object being transferred <br> *  dwDrawAspect    DWORD   Display Aspect of object <br> *  sizel           SIZEL   Size of object in HIMETRIC <br> *  pointl          POINTL  Offset from upper-left corner of object where mouse went <br> *                          down for drag. Meaningful only when drag-drop is used. <br> *  dwStatus        DWORD   OLEMISC flags <br> *  lpszFullUserTypeName  LPSTR Full User Type Name <br> *  lpszSrcOfCopy   LPSTR   Source of Copy <br> * <br> * Return Value: <br> *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure. <br> */ <br>STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData( <br>   CLSID     clsid, <br>   DWORD     dwDrawAspect, <br>   SIZEL     sizel, <br>   POINTL    pointl, <br>   DWORD     dwStatus, <br>   LPOLESTR  lpszFullUserTypeName, <br>   LPOLESTR  lpszSrcOfCopy <br>) <br>{ <br>   HGLOBAL            hMem = NULL; <br>   IBindCtx   FAR    *pbc = NULL; <br>   LPOBJECTDESCRIPTOR lpOD; <br>   DWORD     dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen; <br>   DWORD dwODSize ; <br> <br>   // Get the length of Full User Type Name; Add 1 for the null terminator <br>   dwFullUserTypeNameLen = lpszFullUserTypeName ? <br>                                    OLESTRLEN(lpszFullUserTypeName)+1 : 0; <br> <br>   // Get the Source of Copy string and it's length; Add 1 for the null terminator <br>   if (lpszSrcOfCopy) <br>      dwSrcOfCopyLen = OLESTRLEN(lpszSrcOfCopy)+1; <br>   else { <br>      // No src moniker so use user type name as source string. <br>      lpszSrcOfCopy =  lpszFullUserTypeName; <br>      dwSrcOfCopyLen = dwFullUserTypeNameLen; <br>   } <br> <br>   // Allocate space for OBJECTDESCRIPTOR and the additional string data <br>   dwObjectDescSize = sizeof(OBJECTDESCRIPTOR); <br>   dwODSize = dwObjectDescSize + (sizeof(OLECHAR) * <br>                                (dwFullUserTypeNameLen + dwSrcOfCopyLen)) ; <br>   hMem = GlobalAlloc((GMEM_MOVEABLE | GMEM_SHARE), dwODSize) ; <br>   if (NULL == hMem) <br>      goto error; <br> <br>   lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem); <br> <br>   // Set the FullUserTypeName offset and copy the string <br>   if (lpszFullUserTypeName) <br>   { <br>      lpOD-&gt;dwFullUserTypeName = dwObjectDescSize; <br>      OLESTRCPY((LPOLESTR)((LPSTR)lpOD + lpOD-&gt;dwFullUserTypeName) , <br>                                                    lpszFullUserTypeName); <br>   } <br>   else lpOD-&gt;dwFullUserTypeName = 0;  // zero offset indicates that string is not present <br> <br>   // Set the SrcOfCopy offset and copy the string <br>   if (lpszSrcOfCopy) <br>   { <br>      lpOD-&gt;dwSrcOfCopy = dwObjectDescSize + <br>                               (sizeof(OLECHAR) * dwFullUserTypeNameLen) ; <br>      OLESTRCPY((LPOLESTR)((LPSTR)lpOD + lpOD-&gt;dwSrcOfCopy), lpszSrcOfCopy); <br>   } <br>   else lpOD-&gt;dwSrcOfCopy = 0;  // zero offset indicates that string is not present <br> <br>   // Initialize the rest of the OBJECTDESCRIPTOR <br>   lpOD-&gt;cbSize       = dwODSize ; <br>   lpOD-&gt;clsid        = clsid; <br>   lpOD-&gt;dwDrawAspect = dwDrawAspect; <br>   lpOD-&gt;sizel        = sizel; <br>   lpOD-&gt;pointl       = pointl; <br>   lpOD-&gt;dwStatus     = dwStatus; <br> <br>   GlobalUnlock(hMem); <br>   return hMem; <br> <br>error: <br>   if (hMem) <br>   { <br>      GlobalUnlock(hMem); <br>      GlobalFree(hMem); <br>   } <br>   return NULL; <br>} <br> <br>/* <br> * OleStdGetObjectDescriptorDataFromOleObject <br> * <br> * Purpose: <br> *  Fills and returns a OBJECTDESCRIPTOR structure. Information for the structure is <br> *  obtained from an OLEOBJECT. <br> *  See OBJECTDESCRIPTOR for more information. <br> * <br> * Parameters: <br> *  lpOleObj        LPOLEOBJECT OleObject from which ONJECTDESCRIPTOR info <br> *                  is obtained. <br> *  lpszSrcOfCopy   LPSTR string to identify source of copy. <br> *                  May be NULL in which case IOleObject::GetMoniker is called <br> *                  to get the moniker of the object. if the object is loaded <br> *                  as part of a data transfer document, then usually <br> *                  lpOleClientSite==NULL is passed to OleLoad when loading <br> *                  the object. in this case the IOleObject:GetMoniker call <br> *                  will always fail (it tries to call back to the object's <br> *                  client site). in this situation a non-NULL lpszSrcOfCopy <br> *                  parameter should be passed. <br> *  dwDrawAspect    DWORD   Display Aspect of object <br> *  pointl          POINTL  Offset from upper-left corner of object where <br> *                  mouse went down for drag. Meaningful only when drag-drop <br> *                  is used. <br> *  lpSizelHim      SIZEL   (optional) If the object is being scaled in its <br> *                  container, then the container should pass the extents <br> *                  that it is using to display the object. <br> *                  May be NULL if the object is NOT being scaled. in this <br> *                  case, IViewObject2::GetExtent will be called to get the <br> *                  extents from the object. <br> * <br> * Return Value: <br> *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure. <br> */ <br> <br>STDAPI_(HGLOBAL) OleStdGetObjectDescriptorDataFromOleObject( <br>      LPOLEOBJECT lpOleObj, <br>      LPOLESTR       lpszSrcOfCopy, <br>      DWORD       dwDrawAspect, <br>      POINTL      pointl, <br>      LPSIZEL     lpSizelHim <br>) <br>{ <br>   CLSID clsid; <br>   LPOLESTR lpszFullUserTypeName = NULL; <br>   char     lpszAnsiFullUserTypeName[256]; <br>   LPMONIKER lpSrcMonikerOfCopy = NULL; <br>   HGLOBAL hObjDesc; <br>   IBindCtx  FAR  *pbc = NULL; <br>   HRESULT hrErr; <br>   SIZEL sizelHim; <br>   BOOL  fFreeSrcOfCopy = FALSE; <br>   LPOLELINK lpOleLink = (LPOLELINK) <br>         OleStdQueryInterface((LPUNKNOWN)lpOleObj,&amp;IID_IOleLink); <br>   LPVIEWOBJECT2 lpViewObj2 = (LPVIEWOBJECT2) <br>         OleStdQueryInterface((LPUNKNOWN)lpOleObj, &amp;IID_IViewObject2); <br>   BOOL  fIsLink = (lpOleLink ? TRUE : FALSE); <br>   OLECHAR  szLinkedTypeFmt[80]; <br>   char     szAnsiLinkedTypeFmt[80]; <br>   LPOLESTR lpszBuf = NULL; <br>   char     lpszAnsiBuf[256]; <br>   DWORD dwStatus = 0; <br> <br>   // Get CLSID <br>   OLEDBG_BEGIN2("IOleObject::GetUserClassID called\r\n") <br>   hrErr = lpOleObj-&gt;lpVtbl-&gt;GetUserClassID(lpOleObj, &amp;clsid); <br>   OLEDBG_END2 <br>   if (hrErr != NOERROR) <br>      clsid = CLSID_NULL; <br> <br>   // Get FullUserTypeName <br>   OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n") <br>   hrErr = lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>         lpOleObj, <br>         USERCLASSTYPE_FULL, <br>         /*(LPOLESTR FAR*)*/&amp;lpszFullUserTypeName <br>   ); <br>   OLEDBG_END2 <br> <br>   /* if object is a link, then expand usertypename to be "Linked %s" */ <br>   if (fIsLink &amp;&amp; lpszFullUserTypeName) { <br>      if (0 == LoadString(ghInst, (UINT)IDS_OLE2UIPASTELINKEDTYPE, <br>                  /*(LPSTR)*/szAnsiLinkedTypeFmt, 80)) <br>         lstrcpy(szAnsiLinkedTypeFmt, /*(LPSTR)*/"Linked %s"); <br>      A2W (szAnsiLinkedTypeFmt, szLinkedTypeFmt, 80); <br>      lpszBuf = OleStdMalloc( <br>            (OLESTRLEN(lpszFullUserTypeName)+OLESTRLEN(szLinkedTypeFmt)+1)*sizeof(OLECHAR)); <br>      if (lpszBuf) { <br>         W2A (lpszFullUserTypeName, lpszAnsiFullUserTypeName, 256); <br>         wsprintf(lpszAnsiBuf, szAnsiLinkedTypeFmt, lpszAnsiFullUserTypeName); <br>         OleStdFreeString(lpszFullUserTypeName, NULL); <br>         A2W (lpszAnsiBuf, lpszBuf, 256); <br>         lpszFullUserTypeName = lpszBuf; <br>      } <br>   } <br> <br>   /* Get Source Of Copy <br>   **    if the object is an embedding, then get the object's moniker <br>   **    if the object is a link, then get the link source moniker <br>   */ <br>   if (fIsLink) { <br> <br>      OLEDBG_BEGIN2("IOleLink::GetSourceDisplayName called\r\n") <br>      hrErr = lpOleLink-&gt;lpVtbl-&gt;GetSourceDisplayName( <br>            lpOleLink, &amp;lpszSrcOfCopy ); <br>      OLEDBG_END2 <br>      fFreeSrcOfCopy = TRUE; <br> <br>   } else { <br> <br>      if (lpszSrcOfCopy == NULL) { <br>         OLEDBG_BEGIN2("IOleObject::GetMoniker called\r\n") <br>         hrErr = lpOleObj-&gt;lpVtbl-&gt;GetMoniker( <br>               lpOleObj, <br>               OLEGETMONIKER_TEMPFORUSER, <br>               OLEWHICHMK_OBJFULL, <br>               (LPMONIKER FAR*)&amp;lpSrcMonikerOfCopy <br>         ); <br>         OLEDBG_END2 <br>         if (hrErr == NOERROR) <br>         { <br>            CreateBindCtx(0, (LPBC FAR*)&amp;pbc); <br>            lpSrcMonikerOfCopy-&gt;lpVtbl-&gt;GetDisplayName( <br>                  lpSrcMonikerOfCopy, pbc, NULL, &amp;lpszSrcOfCopy); <br>            pbc-&gt;lpVtbl-&gt;Release(pbc); <br>            fFreeSrcOfCopy = TRUE; <br>         } <br>      } <br>   } <br> <br>   // Get SIZEL <br>   if (lpSizelHim) { <br>      // Use extents passed by the caller <br>      sizelHim = *lpSizelHim; <br>   } else if (lpViewObj2) { <br>      // Get the current extents from the object <br>      OLEDBG_BEGIN2("IViewObject2::GetExtent called\r\n") <br>      hrErr = lpViewObj2-&gt;lpVtbl-&gt;GetExtent( <br>            lpViewObj2, <br>            dwDrawAspect, <br>            -1,     /*lindex*/ <br>            NULL,   /*ptd*/ <br>            (LPSIZEL)&amp;sizelHim <br>      ); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) <br>         sizelHim.cx = sizelHim.cy = 0; <br>   } else { <br>      sizelHim.cx = sizelHim.cy = 0; <br>   } <br> <br>   // Get DWSTATUS <br>   OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n") <br>   hrErr = lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>            lpOleObj, <br>            dwDrawAspect, <br>            &amp;dwStatus <br>   ); <br>   OLEDBG_END2 <br>   if (hrErr != NOERROR) <br>      dwStatus = 0; <br> <br>   // Get OBJECTDESCRIPTOR <br>   hObjDesc = OleStdGetObjectDescriptorData( <br>         clsid, <br>         dwDrawAspect, <br>         sizelHim, <br>         pointl, <br>         dwStatus, <br>         lpszFullUserTypeName, <br>         lpszSrcOfCopy <br>   ); <br>   if (! hObjDesc) <br>      goto error; <br> <br>   // Clean up <br>   if (lpszFullUserTypeName) <br>      OleStdFreeString(lpszFullUserTypeName, NULL); <br>   if (fFreeSrcOfCopy &amp;&amp; lpszSrcOfCopy) <br>      OleStdFreeString(lpszSrcOfCopy, NULL); <br>   if (lpSrcMonikerOfCopy) <br>      OleStdRelease((LPUNKNOWN)lpSrcMonikerOfCopy); <br>   if (lpOleLink) <br>      OleStdRelease((LPUNKNOWN)lpOleLink); <br>   if (lpViewObj2) <br>      OleStdRelease((LPUNKNOWN)lpViewObj2); <br> <br>   return hObjDesc; <br> <br>error: <br>   if (lpszFullUserTypeName) <br>      OleStdFreeString(lpszFullUserTypeName, NULL); <br>   if (fFreeSrcOfCopy &amp;&amp; lpszSrcOfCopy) <br>      OleStdFreeString(lpszSrcOfCopy, NULL); <br>   if (lpSrcMonikerOfCopy) <br>      OleStdRelease((LPUNKNOWN)lpSrcMonikerOfCopy); <br>   if (lpOleLink) <br>      OleStdRelease((LPUNKNOWN)lpOleLink); <br>   if (lpViewObj2) <br>      OleStdRelease((LPUNKNOWN)lpViewObj2); <br> <br>   return NULL; <br>} <br> <br>/* <br> * OleStdFillObjectDescriptorFromData <br> * <br> * Purpose: <br> *  Fills and returns a OBJECTDESCRIPTOR structure. The source object will <br> *  offer CF_OBJECTDESCRIPTOR if it is an OLE2 object, CF_OWNERLINK if it <br> *  is an OLE1 object, or CF_FILENAME if it has been copied to the clipboard <br> *  by FileManager. <br> * <br> * Parameters: <br> *  lpDataObject    LPDATAOBJECT Source object <br> *  lpmedium        LPSTGMEDIUM  Storage medium <br> *  lpcfFmt         CLIPFORMAT FAR * Format offered by lpDataObject <br> *                  (OUT parameter) <br> * <br> * Return Value: <br> *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure. <br> */ <br> <br>STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData( <br>      LPDATAOBJECT     lpDataObject, <br>      LPSTGMEDIUM      lpmedium, <br>      CLIPFORMAT FAR* lpcfFmt <br>) <br>{ <br>   CLSID              clsid; <br>   SIZEL              sizelHim; <br>   POINTL             pointl; <br>   LPOLESTR           lpsz, szFullUserTypeName, szSrcOfCopy, szClassName, szDocName, szItemName; <br>   int                nClassName, nDocName, nItemName, nFullUserTypeName; <br>   LPOLESTR           szBuf = NULL; <br>   HGLOBAL            hMem = NULL; <br>   HKEY               hKey = NULL; <br>   LPMALLOC           pIMalloc = NULL; <br>   DWORD              dw = OLEUI_CCHKEYMAX; <br>   HGLOBAL            hObjDesc; <br>   HRESULT            hrErr; <br>   char               szAnsiString[256]; <br> <br> <br>   // GetData CF_OBJECTDESCRIPTOR format from the object on the clipboard. <br>   // Only OLE 2 objects on the clipboard will offer CF_OBJECTDESCRIPTOR <br>   if (hMem = OleStdGetData( <br>         lpDataObject, <br>         (CLIPFORMAT)cfObjectDescriptor, <br>         NULL, <br>         DVASPECT_CONTENT, <br>         lpmedium)) <br>   { <br>      *lpcfFmt = cfObjectDescriptor; <br>      return hMem;  // Don't drop to clean up at the end of this function <br>   } <br>   // If CF_OBJECTDESCRIPTOR is not available, i.e. if this is not an OLE2 object, <br>   //     check if this is an OLE 1 object. OLE 1 objects will offer CF_OWNERLINK <br>   else if (hMem = OleStdGetData( <br>            lpDataObject, <br>            (CLIPFORMAT)cfOwnerLink, <br>            NULL, <br>            DVASPECT_CONTENT, <br>            lpmedium)) <br>   { <br>      *lpcfFmt = cfOwnerLink; <br>      // CF_OWNERLINK contains null-terminated strings for class name, document name <br>      // and item name with two null terminating characters at the end <br>      szClassName = /*(LPOLESTR)*/GlobalLock(hMem); <br>      nClassName  = OLESTRLEN(szClassName); <br>      szDocName   = szClassName + nClassName + 1; <br>      nDocName    = OLESTRLEN(szDocName); <br>      szItemName  = szDocName + nDocName + 1; <br>      nItemName   = OLESTRLEN(szItemName); <br> <br>      hrErr = CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br>      if (hrErr != NOERROR) <br>         goto error; <br> <br>      // Find FullUserTypeName from Registration database using class name <br>      if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey) != ERROR_SUCCESS) <br>         goto error; <br> <br>      // Allocate space for szFullUserTypeName &amp; szSrcOfCopy. Maximum length of FullUserTypeName <br>      // is OLEUI_CCHKEYMAX. SrcOfCopy is constructed by concatenating FullUserTypeName, Document <br>      // Name and ItemName separated by spaces. <br>      szBuf = /*(LPOLESTR)*/pIMalloc-&gt;lpVtbl-&gt;Alloc(pIMalloc, <br>                     (DWORD)2*OLEUI_CCHKEYMAX+nDocName+nItemName+4); <br>      if (NULL == szBuf) <br>         goto error; <br>      szFullUserTypeName = szBuf; <br>      szSrcOfCopy = szFullUserTypeName+OLEUI_CCHKEYMAX+1; <br> <br>      // Get FullUserTypeName <br>      if (RegQueryValue(hKey, NULL, szAnsiString, &amp;dw) != ERROR_SUCCESS) <br>         goto error; <br>      A2W (szAnsiString, szFullUserTypeName, OLEUI_CCHKEYMAX); <br> <br>      // Build up SrcOfCopy string from FullUserTypeName, DocumentName &amp; ItemName <br>      lpsz = szSrcOfCopy; <br>      OLESTRCPY(lpsz, szFullUserTypeName); <br>      nFullUserTypeName = OLESTRLEN(szFullUserTypeName); <br>      lpsz[nFullUserTypeName]=' '; <br>      lpsz += nFullUserTypeName+1; <br>      OLESTRCPY(lpsz, szDocName); <br>      lpsz[nDocName] = ' '; <br>      lpsz += nDocName+1; <br>      OLESTRCPY(lpsz, szItemName); <br> <br>      sizelHim.cx = sizelHim.cy = 0; <br>      pointl.x = pointl.y = 0; <br> <br>      CLSIDFromProgID(szClassName, &amp;clsid); <br> <br>      hObjDesc = OleStdGetObjectDescriptorData( <br>            clsid, <br>            DVASPECT_CONTENT, <br>            sizelHim, <br>            pointl, <br>            0, <br>            szFullUserTypeName, <br>            szSrcOfCopy <br>      ); <br>      if (!hObjDesc) <br>         goto error; <br>    } <br>    // Check if object is CF_FILENAME <br>    else if (hMem = OleStdGetData( <br>            lpDataObject, <br>            (CLIPFORMAT)cfFileName, <br>            NULL, <br>            DVASPECT_CONTENT, <br>            lpmedium)) <br>    { <br>       *lpcfFmt = cfFileName; <br>       lpsz = /*(LPOLESTR)*/GlobalLock(hMem); <br>       hrErr = GetClassFile(lpsz, &amp;clsid); <br> <br>       /* NOTE: if the file does not have an OLE class <br>       **    associated, then use the OLE 1 Packager as the class of <br>       **    the object to be created. this is the behavior of <br>       **    OleCreateFromData API <br>       */ <br>       if (hrErr != NOERROR) <br>         CLSIDFromProgID(OLESTR("Package"), &amp;clsid); <br>       sizelHim.cx = sizelHim.cy = 0; <br>       pointl.x = pointl.y = 0; <br> <br>       hrErr = CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br>       if (hrErr != NOERROR) <br>         goto error; <br>       szBuf = /*(LPOLESTR)*/pIMalloc-&gt;lpVtbl-&gt;Alloc(pIMalloc, (DWORD)OLEUI_CCHKEYMAX); <br>       if (NULL == szBuf) <br>         goto error; <br> <br>       OleStdGetUserTypeOfClass(&amp;clsid, szBuf, OLEUI_CCHKEYMAX, NULL); <br> <br>       hObjDesc = OleStdGetObjectDescriptorData( <br>            clsid, <br>            DVASPECT_CONTENT, <br>            sizelHim, <br>            pointl, <br>            0, <br>            szBuf, <br>            lpsz <br>      ); <br>      if (!hObjDesc) <br>         goto error; <br>    } <br>    else goto error; <br> <br>    // Clean up <br>    if (szBuf) <br>       pIMalloc-&gt;lpVtbl-&gt;Free(pIMalloc, (LPVOID)szBuf); <br>    if (pIMalloc) <br>       pIMalloc-&gt;lpVtbl-&gt;Release(pIMalloc); <br>    if (hMem) <br>    { <br>       GlobalUnlock(hMem); <br>       GlobalFree(hMem); <br>    } <br>    if (hKey) <br>       RegCloseKey(hKey); <br>    return hObjDesc; <br> <br>error: <br>   if (szBuf) <br>      pIMalloc-&gt;lpVtbl-&gt;Free(pIMalloc, (LPVOID)szBuf); <br>   if (pIMalloc) <br>      pIMalloc-&gt;lpVtbl-&gt;Release(pIMalloc); <br>    if (hMem) <br>    { <br>       GlobalUnlock(hMem); <br>       GlobalFree(hMem); <br>    } <br>    if (hKey) <br>       RegCloseKey(hKey); <br>    return NULL; <br>} <br> <br> <br>#if defined( OBSOLETE ) <br> <br>/************************************************************************* <br>** The following API's have been converted into macros: <br>**          OleStdQueryOleObjectData <br>**          OleStdQueryLinkSourceData <br>**          OleStdQueryObjectDescriptorData <br>**          OleStdQueryFormatMedium <br>**          OleStdCopyMetafilePict <br>**          OleStdGetDropEffect <br>** <br>**    These macros are defined in olestd.h <br>*************************************************************************/ <br> <br>STDAPI OleStdQueryOleObjectData(LPFORMATETC lpformatetc) <br>{ <br>   if (lpformatetc-&gt;tymed &amp; TYMED_ISTORAGE) { <br>      return NOERROR; <br>   } else { <br>      return DATA_E_FORMATETC; <br>   } <br>} <br> <br> <br>STDAPI OleStdQueryLinkSourceData(LPFORMATETC lpformatetc) <br>{ <br>   if (lpformatetc-&gt;tymed &amp; TYMED_ISTREAM) { <br>      return NOERROR; <br>   } else { <br>      return DATA_E_FORMATETC; <br>   } <br>} <br> <br> <br>STDAPI OleStdQueryObjectDescriptorData(LPFORMATETC lpformatetc) <br>{ <br>   if (lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL) { <br>      return NOERROR; <br>   } else { <br>      return DATA_E_FORMATETC; <br>   } <br>} <br> <br> <br>STDAPI OleStdQueryFormatMedium(LPFORMATETC lpformatetc, TYMED tymed) <br>{ <br>   if (lpformatetc-&gt;tymed &amp; tymed) { <br>      return NOERROR; <br>   } else { <br>      return DATA_E_FORMATETC; <br>   } <br>} <br> <br> <br>/* <br> * OleStdCopyMetafilePict() <br> * <br> * Purpose: <br> *    Make an independent copy of a MetafilePict <br> * Parameters: <br> * <br> * Return Value: <br> *    TRUE if successful, else FALSE. <br> */ <br>STDAPI_(BOOL) OleStdCopyMetafilePict(HANDLE hpictin, HANDLE FAR* phpictout) <br>{ <br>   HANDLE hpictout; <br>   LPMETAFILEPICT ppictin, ppictout; <br> <br>   if (hpictin == NULL || phpictout == NULL) { <br>      OleDbgAssert(hpictin == NULL || phpictout == NULL); <br>      return FALSE; <br>   } <br> <br>   *phpictout = NULL; <br> <br>   if ((ppictin = (LPMETAFILEPICT)GlobalLock(hpictin)) == NULL) { <br>      return FALSE; <br>   } <br> <br>   hpictout = GlobalAlloc(GHND|GMEM_SHARE, sizeof(METAFILEPICT)); <br> <br>   if (hpictout &amp;&amp; (ppictout = (LPMETAFILEPICT)GlobalLock(hpictout))){ <br>      ppictout-&gt;hMF  = CopyMetaFile(ppictin-&gt;hMF, NULL); <br>      ppictout-&gt;xExt = ppictin-&gt;xExt; <br>      ppictout-&gt;yExt = ppictin-&gt;yExt; <br>      ppictout-&gt;mm   = ppictin-&gt;mm; <br>      GlobalUnlock(hpictout); <br>   } <br> <br>   *phpictout = hpictout; <br> <br>   return TRUE; <br> <br>} <br> <br> <br>/* OleStdGetDropEffect <br>** ------------------- <br>** <br>** Convert a keyboard state into a DROPEFFECT. <br>** <br>** returns the DROPEFFECT value derived from the key state. <br>**    the following is the standard interpretation: <br>**          no modifier -- Default Drop     (NULL is returned) <br>**          CTRL        -- DROPEFFECT_COPY <br>**          SHIFT       -- DROPEFFECT_MOVE <br>**          CTRL-SHIFT  -- DROPEFFECT_LINK <br>** <br>**    Default Drop: this depends on the type of the target application. <br>**    this is re-interpretable by each target application. a typical <br>**    interpretation is if the drag is local to the same document <br>**    (which is source of the drag) then a MOVE operation is <br>**    performed. if the drag is not local, then a COPY operation is <br>**    performed. <br>*/ <br>STDAPI_(DWORD) OleStdGetDropEffect( DWORD grfKeyState ) <br>{ <br> <br>   if (grfKeyState &amp; MK_CONTROL) { <br> <br>      if (grfKeyState &amp; MK_SHIFT) <br>         return DROPEFFECT_LINK; <br>      else <br>         return DROPEFFECT_COPY; <br> <br>   } else if (grfKeyState &amp; MK_SHIFT) <br>      return DROPEFFECT_MOVE; <br> <br>   return 0;    // no modifier -- do default operation <br>} <br>#endif  // OBSOLETE <br> <br> <br>/* <br> * OleStdGetMetafilePictFromOleObject() <br> * <br> * Purpose: <br> *      Generate a MetafilePict by drawing the OLE object. <br> * Parameters: <br> *  lpOleObj        LPOLEOBJECT pointer to OLE Object <br> *  dwDrawAspect    DWORD   Display Aspect of object <br> *  lpSizelHim      SIZEL   (optional) If the object is being scaled in its <br> *                  container, then the container should pass the extents <br> *                  that it is using to display the object. <br> *                  May be NULL if the object is NOT being scaled. in this <br> *                  case, IViewObject2::GetExtent will be called to get the <br> *                  extents from the object. <br> *  ptd             TARGETDEVICE FAR*   (optional) target device to render <br> *                  metafile for. May be NULL. <br> * <br> * Return Value: <br> *    HANDLE    -- handle of allocated METAFILEPICT <br> */ <br>STDAPI_(HANDLE) OleStdGetMetafilePictFromOleObject( <br>      LPOLEOBJECT         lpOleObj, <br>      DWORD               dwDrawAspect, <br>      LPSIZEL             lpSizelHim, <br>      DVTARGETDEVICE FAR* ptd <br>) <br>{ <br>   LPVIEWOBJECT2 lpViewObj2 = NULL; <br>   HDC hDC; <br>   HMETAFILE hmf; <br>   HANDLE hMetaPict; <br>   LPMETAFILEPICT lpPict; <br>   RECT rcHim; <br>   RECTL rclHim; <br>   SIZEL sizelHim; <br>   HRESULT hrErr; <br>   SIZE size; <br>   POINT point; <br> <br>   lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface( <br>         (LPUNKNOWN)lpOleObj, &amp;IID_IViewObject2); <br>   if (! lpViewObj2) <br>      return NULL; <br> <br>   // Get SIZEL <br>   if (lpSizelHim) { <br>      // Use extents passed by the caller <br>      sizelHim = *lpSizelHim; <br>   } else { <br>      // Get the current extents from the object <br>      OLEDBG_BEGIN2("IViewObject2::GetExtent called\r\n") <br>      hrErr = lpViewObj2-&gt;lpVtbl-&gt;GetExtent( <br>            lpViewObj2, <br>            dwDrawAspect, <br>            -1,     /*lindex*/ <br>            ptd,    /*ptd*/ <br>            (LPSIZEL)&amp;sizelHim <br>      ); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) <br>         sizelHim.cx = sizelHim.cy = 0; <br>   } <br> <br>   hDC = CreateMetaFile(NULL); <br> <br>   rclHim.left     = 0; <br>   rclHim.top      = 0; <br>   rclHim.right    = sizelHim.cx; <br>   rclHim.bottom   = sizelHim.cy; <br> <br>   rcHim.left      = (int)rclHim.left; <br>   rcHim.top       = (int)rclHim.top; <br>   rcHim.right     = (int)rclHim.right; <br>   rcHim.bottom    = (int)rclHim.bottom; <br> <br>   SetWindowOrgEx(hDC, rcHim.left, rcHim.top, &amp;point); <br>   SetWindowExtEx(hDC, rcHim.right-rcHim.left, rcHim.bottom-rcHim.top,&amp;size); <br> <br>   OLEDBG_BEGIN2("IViewObject::Draw called\r\n") <br>   hrErr = lpViewObj2-&gt;lpVtbl-&gt;Draw( <br>         lpViewObj2, <br>         dwDrawAspect, <br>         -1, <br>         NULL, <br>         ptd, <br>         NULL, <br>         hDC, <br>         (LPRECTL)&amp;rclHim, <br>         (LPRECTL)&amp;rclHim, <br>         NULL, <br>         0 <br>   ); <br>   OLEDBG_END2 <br> <br>   OleStdRelease((LPUNKNOWN)lpViewObj2); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IViewObject::Draw returned", hrErr); <br>      CloseMetaFile(hDC); <br>      return(NULL); <br>   } <br> <br>   hmf = CloseMetaFile(hDC); <br> <br>   hMetaPict = GlobalAlloc(GHND|GMEM_SHARE, sizeof(METAFILEPICT)); <br> <br>   if (hMetaPict &amp;&amp; (lpPict = (LPMETAFILEPICT)GlobalLock(hMetaPict))){ <br>      lpPict-&gt;hMF  = hmf; <br>      lpPict-&gt;xExt = (int)sizelHim.cx ; <br>      lpPict-&gt;yExt = (int)sizelHim.cy ; <br>      lpPict-&gt;mm   = MM_ANISOTROPIC; <br>      GlobalUnlock(hMetaPict); <br>   } <br> <br>   return hMetaPict; <br>} <br> <br> <br>/* Call Release on the object that is expected to go away. <br>**      if the refcnt of the object did no go to 0 then give a debug message. <br>*/ <br>STDAPI_(ULONG) OleStdVerifyRelease(LPUNKNOWN lpUnk, LPOLESTR lpszMsg) <br>{ <br>   ULONG cRef; <br>   char  lpszAnsiMsg[256]; <br> <br>   W2A (lpszMsg, lpszAnsiMsg, 256); <br>   cRef = lpUnk-&gt;lpVtbl-&gt;Release(lpUnk); <br> <br>#if defined( _DEBUG ) <br>   if (cRef != 0) { <br>      char szBuf[80]; <br>      if (lpszMsg) <br>         MessageBox(NULL, lpszAnsiMsg, NULL, MB_ICONEXCLAMATION | MB_OK); <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt (%ld) != 0 after object (0x%lx) release\n", <br>            cRef, <br>            lpUnk <br>      ); <br>      if (lpszMsg) <br>         OleDbgOut1(lpszAnsiMsg); <br>      OleDbgOut1(/*(LPSTR)*/szBuf); <br>      OleDbgAssertSz(cRef == 0, /*(LPSTR)*/szBuf); <br>   } else { <br>      char szBuf[80]; <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt = 0 after object (0x%lx) release\n", lpUnk <br>      ); <br>      OleDbgOut4(/*(LPSTR)*/szBuf); <br>   } <br>#endif <br>   return cRef; <br>} <br> <br> <br>/* Call Release on the object that is NOT necessarily expected to go away. <br>*/ <br>STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk) <br>{ <br>   ULONG cRef; <br> <br>   cRef = lpUnk-&gt;lpVtbl-&gt;Release(lpUnk); <br> <br>#if defined( _DEBUG ) <br>   { <br>      char szBuf[80]; <br>      wsprintf( <br>            /*(LPSTR)*/szBuf, <br>            "refcnt = %ld after object (0x%lx) release\n", </code></pre>
<p>
</p>
<pre><code>cRef, <br>            lpUnk <br>      ); <br>      OleDbgOut4(/*(LPSTR)*/szBuf); <br>   } <br>#endif <br>   return cRef; <br>} <br> <br> <br>/* OleStdInitVtbl <br>** -------------- <br>** <br>**    Initialize an interface Vtbl to ensure that there are no NULL <br>**    function pointers in the Vtbl. All entries in the Vtbl are <br>**    set to a valid funtion pointer (OleStdNullMethod) that issues <br>**        debug assert message (message box) and returns E_NOTIMPL if called. <br>** <br>**    NOTE: this funtion does not initialize the Vtbl with usefull <br>**    function pointers, only valid function pointers to avoid the <br>**    horrible run-time crash when a call is made through the Vtbl with <br>**    a NULL function pointer. this API is only necessary when <br>**    initializing the Vtbl's in C. C++ guarantees that all interface <br>**    functions (in C++ terms -- pure virtual functions) are implemented. <br>*/ <br> <br>STDAPI_(void) OleStdInitVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl) <br>{ <br>   LPVOID FAR* lpFuncPtrArr = (LPVOID FAR*)lpVtbl; <br>   UINT nMethods = nSizeOfVtbl/sizeof(VOID FAR*); <br>   UINT i; <br> <br>   for (i = 0; i &lt; nMethods; i++) { <br>      lpFuncPtrArr[i] = OleStdNullMethod; <br>   } <br>} <br> <br> <br>/* OleStdCheckVtbl <br>** --------------- <br>** <br>**    Check if all entries in the Vtbl are properly initialized with <br>**    valid function pointers. If any entries are either NULL or <br>**    OleStdNullMethod, then this function returns FALSE. If compiled <br>**    for _DEBUG this function reports which function pointers are <br>**    invalid. <br>** <br>**    RETURNS:  TRUE if all entries in Vtbl are valid <br>**                              FALSE otherwise. <br>*/ <br> <br>STDAPI_(BOOL) OleStdCheckVtbl(LPVOID lpVtbl, UINT nSizeOfVtbl, LPOLESTR lpszIface) <br>{ <br>   LPVOID FAR* lpFuncPtrArr = (LPVOID FAR*)lpVtbl; <br>   UINT nMethods = nSizeOfVtbl/sizeof(VOID FAR*); <br>   UINT i; <br>   BOOL fStatus = TRUE; <br>   int nChar = 0; <br> <br>   for (i = 0; i &lt; nMethods; i++) { <br>      if (lpFuncPtrArr[i] == NULL || lpFuncPtrArr[i] == OleStdNullMethod) { <br>#if defined( _DEBUG ) <br>         char szAnsiStr[256]; <br>         char szBuf[256]; <br>         W2A (lpszIface, szAnsiStr, 256); <br>         wsprintf(szBuf, "%s::method# %d NOT valid!", szAnsiStr, i); <br>         OleDbgOut1(/*(LPSTR)*/szBuf); <br>#endif <br>         fStatus = FALSE; <br>      } <br>   } <br>   return fStatus; <br>} <br> <br> <br>/* OleStdNullMethod <br>** ---------------- <br>**    Dummy method used by OleStdInitVtbl to initialize an interface <br>**    Vtbl to ensure that there are no NULL function pointers in the <br>**    Vtbl. All entries in the Vtbl are set to this function. this <br>**    function issues a debug assert message (message box) and returns <br>**    E_NOTIMPL if called. If all is done properly, this function will <br>**    NEVER be called! <br>*/ <br>STDMETHODIMP OleStdNullMethod(LPUNKNOWN lpThis) <br>{ <br>   MessageBox( <br>         NULL, <br>         "ERROR: INTERFACE METHOD NOT IMPLEMENTED!\r\n", <br>         NULL, <br>         MB_SYSTEMMODAL | MB_ICONHAND | MB_OK <br>   ); <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br> <br>static BOOL  GetFileTimes(LPSTR lpszFileName, FILETIME FAR* pfiletime) <br>{ <br>#ifdef WIN32 <br>   WIN32_FIND_DATA fd; <br>   HANDLE hFind; <br>   hFind = FindFirstFile(lpszFileName,&amp;fd); <br>   if (hFind == NULL || hFind == INVALID_HANDLE_VALUE) { <br>      return FALSE; <br>   } <br>   FindClose(hFind); <br>   *pfiletime = fd.ftLastWriteTime; <br>   return TRUE; <br>#else <br>   static char sz[256]; <br>   static struct _find_t fileinfo; <br> <br>   LSTRCPYN(/*(LPSTR)*/sz, lpszFileName, sizeof(sz)-1); <br>   sz[sizeof(sz)-1]= '\0'; <br>   AnsiToOem(sz, sz); <br>   return (_dos_findfirst(sz,_A_NORMAL|_A_HIDDEN|_A_SUBDIR|_A_SYSTEM, <br>                (struct _find_t *)&amp;fileinfo) == 0 &amp;&amp; <br>      CoDosDateTimeToFileTime(fileinfo.wr_date,fileinfo.wr_time,pfiletime)); <br>#endif <br>} <br> <br> <br> <br>/* OleStdRegisterAsRunning <br>** ----------------------- <br>**    Register a moniker in the RunningObjectTable. <br>**    if there is an existing registration (*lpdwRegister!=NULL), then <br>**    first revoke that registration. <br>** <br>**    new dwRegister key is returned via *lpdwRegister parameter. <br>*/ <br>STDAPI_(void) OleStdRegisterAsRunning(LPUNKNOWN lpUnk, LPMONIKER lpmkFull, DWORD FAR* lpdwRegister) <br>{ <br>   LPRUNNINGOBJECTTABLE lpROT; <br>   HRESULT hrErr; <br>   DWORD dwOldRegister = *lpdwRegister; <br> <br>   OLEDBG_BEGIN2("OleStdRegisterAsRunning\r\n") <br> <br>   OLEDBG_BEGIN2("GetRunningObjectTable called\r\n") <br>   hrErr = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&amp;lpROT); <br>   OLEDBG_END2 <br> <br>   if (hrErr == NOERROR) { <br> <br>      /* register as running if a valid moniker is passed <br>      ** <br>      ** NOTE: we deliberately register the new moniker BEFORE <br>      **    revoking the old moniker just in case the object <br>      **    currently has no external locks. if the object has no <br>      **    locks then revoking it from the running object table will <br>      **    cause the object's StubManager to initiate shutdown of <br>      **    the object. <br>      */ <br>      if (lpmkFull) { <br> <br>         OLEDBG_BEGIN2("IRunningObjectTable::Register called\r\n") <br>         lpROT-&gt;lpVtbl-&gt;Register(lpROT, 0, lpUnk,lpmkFull,lpdwRegister); <br>         OLEDBG_END2 <br> <br>#if defined(_DEBUG) <br>         { <br>            char szBuf[512]; <br>            LPOLESTR lpszDisplay; <br>            char     lpszAnsiDisplay[256]; <br>            LPBC lpbc; <br> <br>            CreateBindCtx(0, (LPBC FAR*)&amp;lpbc); <br>            lpmkFull-&gt;lpVtbl-&gt;GetDisplayName( <br>                  lpmkFull, <br>                  lpbc, <br>                  NULL, <br>                  /*(LPOLESTR FAR*)*/&amp;lpszDisplay <br>            ); <br>            OleStdRelease((LPUNKNOWN)lpbc); <br>            W2A (lpszDisplay, lpszAnsiDisplay, 256); <br>            wsprintf( <br>                  szBuf, <br>                  "Moniker '%s' REGISTERED as [0x%lx] in ROT\r\n", <br>                  lpszAnsiDisplay, <br>                  *lpdwRegister <br>            ); <br>            OleDbgOut2(szBuf); <br>            OleStdFreeString(lpszDisplay, NULL); <br>         } <br>#endif  // _DEBUG <br> <br>      } <br> <br>      // if already registered, revoke <br>      if (dwOldRegister != 0) { <br> <br>#if defined(_DEBUG) <br>         { <br>            char szBuf[512]; <br> <br>            wsprintf( <br>                  szBuf, <br>                  "Moniker [0x%lx] REVOKED from ROT\r\n", <br>                  dwOldRegister <br>            ); <br>            OleDbgOut2(szBuf); <br>         } <br>#endif  // _DEBUG <br> <br>         OLEDBG_BEGIN2("IRunningObjectTable::Revoke called\r\n") <br>         lpROT-&gt;lpVtbl-&gt;Revoke(lpROT, dwOldRegister); <br>         OLEDBG_END2 <br>      } <br> <br>      OleStdRelease((LPUNKNOWN)lpROT); <br>   } else { <br>      OleDbgAssertSz( <br>            lpROT != NULL, <br>            "OleStdRegisterAsRunning: GetRunningObjectTable FAILED\r\n" <br>      ); <br>   } <br> <br>   OLEDBG_END2 <br>} <br> <br> <br> <br>/* OleStdRevokeAsRunning <br>** --------------------- <br>**    Revoke a moniker from the RunningObjectTable if there is an <br>**    existing registration (*lpdwRegister!=NULL). <br>** <br>**    *lpdwRegister parameter will be set to NULL. <br>*/ <br>STDAPI_(void) OleStdRevokeAsRunning(DWORD FAR* lpdwRegister) <br>{ <br>   LPRUNNINGOBJECTTABLE lpROT; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleStdRevokeAsRunning\r\n") <br> <br>   // if still registered, then revoke <br>   if (*lpdwRegister != 0) { <br> <br>      OLEDBG_BEGIN2("GetRunningObjectTable called\r\n") <br>      hrErr = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&amp;lpROT); <br>      OLEDBG_END2 <br> <br>      if (hrErr == NOERROR) { <br> <br>#if defined(_DEBUG) <br>         { <br>            char szBuf[512]; <br> <br>            wsprintf( <br>                  szBuf, <br>                  "Moniker [0x%lx] REVOKED from ROT\r\n", <br>                  *lpdwRegister <br>            ); <br>            OleDbgOut2(szBuf); <br>         } <br>#endif  // _DEBUG <br> <br>         OLEDBG_BEGIN2("IRunningObjectTable::Revoke called\r\n") <br>         lpROT-&gt;lpVtbl-&gt;Revoke(lpROT, *lpdwRegister); <br>         OLEDBG_END2 <br> <br>         *lpdwRegister = 0; <br> <br>         OleStdRelease((LPUNKNOWN)lpROT); <br>      } else { <br>         OleDbgAssertSz( <br>               lpROT != NULL, <br>               "OleStdRevokeAsRunning: GetRunningObjectTable FAILED\r\n" <br>         ); <br>      } <br>   } <br>   OLEDBG_END2 <br>} <br> <br> <br>/* OleStdNoteFileChangeTime <br>** ------------------------ <br>**    Note the time a File-Based object has been saved in the <br>**    RunningObjectTable. These change times are used as the basis for <br>**    IOleObject::IsUpToDate. <br>**    It is important to set the time of the file-based object <br>**    following a save operation to exactly the time of the saved file. <br>**    this helps IOleObject::IsUpToDate to give the correct answer <br>**    after a file has been saved. <br>*/ <br>STDAPI_(void) OleStdNoteFileChangeTime(LPOLESTR lpszFileName, DWORD dwRegister) <br>{ <br>   char lpszAnsiFileName[256]; <br> <br>   W2A (lpszFileName, lpszAnsiFileName, 256); <br>   if (dwRegister != 0) { <br> <br>      LPRUNNINGOBJECTTABLE lprot; <br>      FILETIME filetime; <br> <br>      if (GetFileTimes(lpszAnsiFileName, &amp;filetime) &amp;&amp; <br>         GetRunningObjectTable(0,&amp;lprot) == NOERROR) <br>      { <br>         lprot-&gt;lpVtbl-&gt;NoteChangeTime( lprot, dwRegister, &amp;filetime ); <br>         lprot-&gt;lpVtbl-&gt;Release(lprot); <br> <br>         OleDbgOut2("IRunningObjectTable::NoteChangeTime called\r\n"); <br>      } <br>   } <br>} <br> <br> <br>/* OleStdNoteObjectChangeTime <br>** -------------------------- <br>**    Set the last change time of an object that is registered in the <br>**    RunningObjectTable. These change times are used as the basis for <br>**    IOleObject::IsUpToDate. <br>** <br>**    every time the object sends out a OnDataChange notification, it <br>**    should update the Time of last change in the ROT. <br>** <br>**    NOTE: this function set the change time to the current time. <br>*/ <br>STDAPI_(void) OleStdNoteObjectChangeTime(DWORD dwRegister) <br>{ <br>   if (dwRegister != 0) { <br> <br>      LPRUNNINGOBJECTTABLE lprot; <br>      FILETIME filetime; <br> <br>      if (GetRunningObjectTable(0,&amp;lprot) == NOERROR) <br>      { <br>         CoFileTimeNow( &amp;filetime ); <br>         lprot-&gt;lpVtbl-&gt;NoteChangeTime( lprot, dwRegister, &amp;filetime ); <br>         lprot-&gt;lpVtbl-&gt;Release(lprot); <br> <br>         OleDbgOut2("IRunningObjectTable::NoteChangeTime called\r\n"); <br>      } <br>   } <br>} <br> <br> <br>/* OleStdCreateTempFileMoniker <br>** --------------------------- <br>**    return the next available FileMoniker that can be used as the <br>**    name of an untitled document. <br>**    the FileMoniker is built of the form: <br>**          &lt;lpszPrefixString&gt;&lt;number&gt; <br>**      eg. "Outline1", "Outline2", etc. <br>** <br>**    The RunningObjectTable (ROT) is consulted to determine if a <br>**    FileMoniker is in use. If the name is in use then the number is <br>**    incremented and the ROT is checked again. <br>** <br>** Parameters: <br>**    LPSTR lpszPrefixString    - prefix used to build the name <br>**    UINT FAR* lpuUnique       - (IN-OUT) last used number. <br>**                                  this number is used to make the <br>**                                  name unique. on entry, the input <br>**                                  number is incremented. on output, <br>**                                  the number used is returned. this <br>**                                  number should be passed again <br>**                                  unchanged on the next call. <br>**    LPSTR lpszName            - (OUT) buffer used to build string. <br>**                                  caller must be sure buffer is large <br>**                                  enough to hold the generated string. <br>**    LPMONIKER FAR* lplpmk     - (OUT) next unused FileMoniker <br>** <br>** Returns: <br>**    void <br>** <br>** Comments: <br>**    This function is similar in spirit to the Windows API <br>**    CreateTempFileName. <br>*/ <br>STDAPI_(void) OleStdCreateTempFileMoniker( <br>      LPOLESTR        lpszPrefixString, <br>      UINT FAR*       lpuUnique, <br>      LPOLESTR        lpszName, <br>      LPMONIKER FAR*  lplpmk <br>) <br>{ <br>   LPRUNNINGOBJECTTABLE lpROT = NULL; <br>   UINT i = (lpuUnique != NULL ? *lpuUnique : 1); <br>   HRESULT hrErr; <br>   char    lpszAnsiPrefixString[256], lpszAnsiName[256]; <br> <br>   W2A (lpszPrefixString, lpszAnsiPrefixString, 256); <br>   wsprintf(lpszAnsiName, "%s%d", lpszAnsiPrefixString, i++); <br>   A2W (lpszAnsiName, lpszName, OLEUI_CCHLABELMAX); <br>   CreateFileMoniker(lpszName, lplpmk); <br> <br>   OLEDBG_BEGIN2("GetRunningObjectTable called\r\n") <br>   hrErr = GetRunningObjectTable(0,(LPRUNNINGOBJECTTABLE FAR*)&amp;lpROT); <br>   OLEDBG_END2 <br> <br>   if (hrErr == NOERROR) { <br> <br>      while (1) { <br>         if (! *lplpmk) <br>            break;  // failed to create FileMoniker <br> <br>         OLEDBG_BEGIN2("IRunningObjectTable::IsRunning called\r\n") <br>         hrErr = lpROT-&gt;lpVtbl-&gt;IsRunning(lpROT,*lplpmk); <br>         OLEDBG_END2 <br> <br>         if (hrErr != NOERROR) <br>            break;  // the Moniker is NOT running; found unused one! <br> <br>         OleStdVerifyRelease( <br>               (LPUNKNOWN)*lplpmk, <br>               OLESTR("OleStdCreateTempFileMoniker: Moniker NOT released") <br>            ); <br> <br>         wsprintf(lpszAnsiName, "%s%d", lpszAnsiPrefixString, i++); <br>         A2W (lpszAnsiName, lpszName, OLEUI_CCHLABELMAX); <br>         CreateFileMoniker(lpszName, lplpmk); <br>      } <br> <br>      OleStdRelease((LPUNKNOWN)lpROT); <br>   } <br> <br>   if (lpuUnique != NULL) <br>      *lpuUnique = i; <br>} <br> <br> <br>/* OleStdGetFirstMoniker <br>** --------------------- <br>**    return the first piece of a moniker. <br>** <br>**    NOTE: if the given moniker is not a generic composite moniker, <br>**    then an AddRef'ed pointer to the given moniker is returned. <br>*/ <br>STDAPI_(LPMONIKER) OleStdGetFirstMoniker(LPMONIKER lpmk) <br>{ <br>   LPMONIKER       lpmkFirst = NULL; <br>   LPENUMMONIKER   lpenumMoniker; <br>   DWORD           dwMksys; <br>   HRESULT         hrErr; <br> <br>   if (! lpmk) <br>      return NULL; <br> <br>   if (lpmk-&gt;lpVtbl-&gt;IsSystemMoniker(lpmk, (LPDWORD)&amp;dwMksys) == NOERROR <br>      &amp;&amp; dwMksys == MKSYS_GENERICCOMPOSITE) { <br> <br>      /* NOTE: the moniker is a GenericCompositeMoniker. <br>      **    enumerate the moniker to pull off the first piece. <br>      */ <br> <br>      hrErr = lpmk-&gt;lpVtbl-&gt;Enum( <br>            lpmk, <br>            TRUE /* fForward */, <br>            (LPENUMMONIKER FAR*)&amp;lpenumMoniker <br>      ); <br>      if (hrErr != NOERROR) <br>         return NULL;    // ERROR: give up! <br> <br>      hrErr = lpenumMoniker-&gt;lpVtbl-&gt;Next( <br>            lpenumMoniker, <br>            1, <br>            (LPMONIKER FAR*)&amp;lpmkFirst, <br>            NULL <br>      ); <br>      lpenumMoniker-&gt;lpVtbl-&gt;Release(lpenumMoniker); <br>      return lpmkFirst; <br> <br>   } else { <br>      /* NOTE: the moniker is NOT a GenericCompositeMoniker. <br>      **    return an AddRef'ed pointer to the input moniker. <br>      */ <br>      lpmk-&gt;lpVtbl-&gt;AddRef(lpmk); <br>      return lpmk; <br>   } <br>} <br> <br> <br>/* OleStdGetLenFilePrefixOfMoniker <br>** ------------------------------- <br>**    if the first piece of the Moniker is a FileMoniker, then return <br>**    the length of the filename string. <br>** <br>**    lpmk      pointer to moniker <br>** <br>**    Returns <br>**      0       if moniker does NOT start with a FileMoniker <br>**      uLen    string length of filename prefix of the display name <br>**              retrieved from the given (lpmk) moniker. <br>*/ <br>STDAPI_(ULONG) OleStdGetLenFilePrefixOfMoniker(LPMONIKER lpmk) <br>{ <br>   LPMONIKER       lpmkFirst = NULL; <br>   DWORD           dwMksys; <br>   LPOLESTR        lpsz = NULL; <br>   LPBC            lpbc = NULL; <br>   ULONG           uLen = 0; <br>   HRESULT         hrErr; <br> <br>   if (! lpmk) <br>      return 0; <br> <br>   lpmkFirst = OleStdGetFirstMoniker(lpmk); <br>   if (lpmkFirst) { <br>      if ( (lpmkFirst-&gt;lpVtbl-&gt;IsSystemMoniker( <br>                     lpmkFirst, (LPDWORD)&amp;dwMksys) == NOERROR) <br>            &amp;&amp; dwMksys == MKSYS_FILEMONIKER) { <br> <br>         hrErr = CreateBindCtx(0, (LPBC FAR*)&amp;lpbc); <br>         if (hrErr == NOERROR) { <br>            hrErr = lpmkFirst-&gt;lpVtbl-&gt;GetDisplayName( <br>                  lpmkFirst, <br>                  lpbc, <br>                  NULL,   /* pmkToLeft */ <br>                  /*(LPOLESTR FAR*)*/&amp;lpsz <br>            ); <br>            if (hrErr == NOERROR &amp;&amp; lpsz != NULL) { <br>               uLen = OLESTRLEN(lpsz); <br>               OleStdFreeString(lpsz, NULL); <br>            } <br>            OleStdRelease((LPUNKNOWN)lpbc); <br>         } <br>      } <br>      lpmkFirst-&gt;lpVtbl-&gt;Release(lpmkFirst); <br>   } <br>   return uLen; <br>} <br> <br> <br>/* OleStdMkParseDisplayName <br>**    Parse a string into a Moniker by calling the OLE API <br>**    MkParseDisplayName. if the original link source class was an OLE1 <br>**    class, then attempt the parsing assuming the same class applies. <br>** <br>**    if the class of the previous link source was an OLE1 class, <br>**    then first attempt to parse a string that it is qualified <br>**    with the progID associated with the OLE1 class. this more <br>**    closely matches the semantics of OLE1 where the class of <br>**    link sources is not expected to change. prefixing the <br>**    string with "@&lt;ProgID -- OLE1 class name&gt;!" will force the <br>**    parsing of the string to assume the file is of that <br>**    class. <br>**    NOTE: this trick of prepending the string with "@&lt;ProgID&gt; <br>**    only works for OLE1 classes. <br>** <br>**  PARAMETERS: <br>**    REFCLSID rClsid       -- original class of link source. <br>**                              CLSID_NULL if class is unknown <br>**    ... other parameters the same as MkParseDisplayName API ... <br>** <br>**  RETURNS <br>**    NOERROR if string parsed successfully <br>**    else error code returned by MkParseDisplayName <br>*/ <br>STDAPI OleStdMkParseDisplayName( <br>      REFCLSID        rClsid, <br>      LPBC            lpbc, <br>      LPOLESTR        lpszUserName, <br>      ULONG FAR*      lpchEaten, <br>      LPMONIKER FAR*  lplpmk <br>) <br>{ <br>   HRESULT hrErr; <br> <br>   if (!IsEqualCLSID(rClsid,&amp;CLSID_NULL) &amp;&amp; CoIsOle1Class(rClsid) &amp;&amp; <br>      lpszUserName[0] != '@') { <br>      LPOLESTR lpszBuf; <br>      LPOLESTR lpszProgID; <br>      char     lpszAnsiBuf[256], lpszAnsiProgID[256], lpszAnsiUserName[256]; <br> <br>      // Prepend "@&lt;ProgID&gt;!" to the input string <br>      ProgIDFromCLSID(rClsid, &amp;lpszProgID); <br>      if (lpszProgID == NULL) <br>         goto Cont1; <br>      lpszBuf = OleStdMalloc( <br>            ((ULONG)OLESTRLEN(lpszUserName)+OLESTRLEN(lpszProgID)+3) * sizeof(OLECHAR)); <br>      if (lpszBuf == NULL) { <br>         if (lpszProgID) <br>            OleStdFree(lpszProgID); <br>         goto Cont1; <br>      } <br> <br>      W2A (lpszProgID, lpszAnsiProgID, 256); <br>      W2A (lpszUserName, lpszAnsiUserName, 256); <br>      wsprintf(lpszAnsiBuf, "@%s!%s", lpszAnsiProgID, lpszAnsiUserName); <br>      A2W (lpszAnsiBuf, lpszBuf, OLESTRLEN(lpszUserName)+OLESTRLEN(lpszProgID)+3); <br>      OLEDBG_BEGIN2("MkParseDisplayName called\r\n") <br>      hrErr = MkParseDisplayName(lpbc, lpszBuf, lpchEaten, lplpmk); <br>      OLEDBG_END2 <br> <br>      if (lpszProgID) <br>         OleStdFree(lpszProgID); <br>      if (lpszBuf) <br>         OleStdFree(lpszBuf); <br> <br>      if (hrErr == NOERROR) <br>         return NOERROR; <br>   } <br> <br>Cont1: <br>   OLEDBG_BEGIN2("MkParseDisplayName called\r\n") <br>   hrErr = MkParseDisplayName(lpbc, lpszUserName, lpchEaten, lplpmk); <br>   OLEDBG_END2 <br> <br>   return hrErr; <br>} <br> <br> <br>/* <br> * OleStdMarkPasteEntryList <br> * <br> * Purpose: <br> *  Mark each entry in the PasteEntryList if its format is available from <br> *  the source IDataObject*. the dwScratchSpace field of each PasteEntry <br> *  is set to TRUE if available, else FALSE. <br> * <br> * Parameters: <br> *  LPOLEUIPASTEENTRY   array of PasteEntry structures <br> *  int                 count of elements in PasteEntry array <br> *  LPDATAOBJECT        source IDataObject* pointer <br> * <br> * Return Value: <br> *   none <br> */ <br>STDAPI_(void) OleStdMarkPasteEntryList( <br>      LPDATAOBJECT        lpSrcDataObj, <br>      LPOLEUIPASTEENTRY   lpPriorityList, <br>      int                 cEntries <br>) <br>{ <br>   LPENUMFORMATETC     lpEnumFmtEtc = NULL; <br>   #define FORMATETC_MAX 20 <br>   FORMATETC           rgfmtetc[FORMATETC_MAX]; <br>   int                 i; <br>   HRESULT             hrErr; <br>   long                j, cFetched; <br> <br>   // Clear all marks <br>   for (i = 0; i &lt; cEntries; i++) { <br>      lpPriorityList[i].dwScratchSpace = FALSE; <br> <br>      if (! lpPriorityList[i].fmtetc.cfFormat) { <br>         // caller wants this item always considered available <br>         // (by specifying a NULL format) <br>         lpPriorityList[i].dwScratchSpace = TRUE; <br>      } else if (lpPriorityList[i].fmtetc.cfFormat == cfEmbeddedObject <br>            || lpPriorityList[i].fmtetc.cfFormat == cfEmbedSource <br>            || lpPriorityList[i].fmtetc.cfFormat == cfFileName) { <br> <br>         // if there is an OLE object format, then handle it <br>         // specially by calling OleQueryCreateFromData. the caller <br>         // need only specify one object type format. <br>         OLEDBG_BEGIN2("OleQueryCreateFromData called\r\n") <br>         hrErr = OleQueryCreateFromData(lpSrcDataObj); <br>         OLEDBG_END2 <br>         if(NOERROR == hrErr) { <br>            lpPriorityList[i].dwScratchSpace = TRUE; <br>         } <br>      } else if (lpPriorityList[i].fmtetc.cfFormat == cfLinkSource) { <br> <br>         // if there is OLE 2.0 LinkSource format, then handle it <br>         // specially by calling OleQueryLinkFromData. <br>         OLEDBG_BEGIN2("OleQueryLinkFromData called\r\n") <br>         hrErr = OleQueryLinkFromData(lpSrcDataObj); <br>         OLEDBG_END2 <br>         if(NOERROR == hrErr) { <br>            lpPriorityList[i].dwScratchSpace = TRUE; <br>         } <br>      } <br>   } <br> <br>   OLEDBG_BEGIN2("IDataObject::EnumFormatEtc called\r\n") <br>   hrErr = lpSrcDataObj-&gt;lpVtbl-&gt;EnumFormatEtc( <br>         lpSrcDataObj, <br>         DATADIR_GET, <br>         (LPENUMFORMATETC FAR*)&amp;lpEnumFmtEtc <br>   ); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) <br>      return;    // unable to get format enumerator <br> <br>   // Enumerate the formats offered by the source <br>   // Loop over all formats offered by the source <br>   cFetched = 0; <br>   _fmemset(rgfmtetc,0,sizeof(rgfmtetc[FORMATETC_MAX]) ); <br>   if (lpEnumFmtEtc-&gt;lpVtbl-&gt;Next( <br>         lpEnumFmtEtc, FORMATETC_MAX, rgfmtetc, &amp;cFetched) == NOERROR <br>      || (cFetched &gt; 0 &amp;&amp; cFetched &lt;= FORMATETC_MAX) ) <br>   { <br> <br>      for (j = 0; j &lt; cFetched; j++) <br>      { <br>         for (i = 0; i &lt; cEntries; i++) <br>         { <br>            if (! lpPriorityList[i].dwScratchSpace &amp;&amp; <br>               IsCloseFormatEtc(&amp;rgfmtetc[j], &amp;lpPriorityList[i].fmtetc)) <br>            { <br>               lpPriorityList[i].dwScratchSpace = TRUE; <br>            } <br>         } <br>      } <br>   } // endif <br> <br>   // Clean up <br>   if (lpEnumFmtEtc) <br>      OleStdRelease((LPUNKNOWN)lpEnumFmtEtc); <br>} <br> <br> <br>/* OleStdGetPriorityClipboardFormat <br>** -------------------------------- <br>** <br>**    Retrieve the first clipboard format in a list for which data <br>**    exists in the source IDataObject*. <br>** <br>**    Returns -1 if no acceptable match is found. <br>**            index of first acceptable match in the priority list. <br>** <br>*/ <br>STDAPI_(int) OleStdGetPriorityClipboardFormat( <br>      LPDATAOBJECT        lpSrcDataObj, <br>      LPOLEUIPASTEENTRY   lpPriorityList, <br>      int                 cEntries <br>) <br>{ <br>   int i; <br>   int nFmtEtc = -1; <br> <br>   // Mark all entries that the Source provides <br>   OleStdMarkPasteEntryList(lpSrcDataObj, lpPriorityList, cEntries); <br> <br>   // Loop over the target's priority list of formats <br>   for (i = 0; i &lt; cEntries; i++) <br>   { <br>      if (lpPriorityList[i].dwFlags != OLEUIPASTE_PASTEONLY &amp;&amp; <br>            !(lpPriorityList[i].dwFlags &amp; OLEUIPASTE_PASTE)) <br>         continue; <br> <br>      // get first marked entry <br>      if (lpPriorityList[i].dwScratchSpace) { <br>         nFmtEtc = i; <br>         break;          // Found priority format; DONE <br>      } <br>   } <br> <br>   return nFmtEtc; <br>} <br> <br> <br>/* OleStdIsDuplicateFormat <br>** ----------------------- <br>**    Returns TRUE if the lpFmtEtc-&gt;cfFormat is found in the array of <br>**    FormatEtc structures. <br>*/ <br>STDAPI_(BOOL) OleStdIsDuplicateFormat( <br>      LPFORMATETC         lpFmtEtc, <br>      LPFORMATETC         arrFmtEtc, <br>      int                 nFmtEtc <br>) <br>{ <br>   int i; <br> <br>   for (i = 0; i &lt; nFmtEtc; i++) { <br>      if (IsEqualFORMATETC((*lpFmtEtc), arrFmtEtc[i])) <br>         return TRUE; <br>   } <br> <br>   return FALSE; <br>} <br> <br> <br>/* OleStdGetItemToken <br> * ------------------ <br> * <br> * LPSTR lpszSrc - Pointer to a source string <br> * LPSTR lpszDst - Pointer to destination buffer <br> * <br> * Will copy one token from the lpszSrc buffer to the lpszItem buffer. <br> * It considers all alpha-numeric and white space characters as valid <br> * characters for a token. the first non-valid character delimates the <br> * token. <br> * <br> * returns the number of charaters eaten. <br> */ <br>STDAPI_(ULONG) OleStdGetItemToken(LPOLESTR lpszSrc, LPOLESTR lpszDst, int nMaxChars) <br>{ <br>   ULONG chEaten = 0L; <br>   char szAnsiSrc[256], szAnsiDst[256]; <br>   LPSTR lpszAnsiDst = szAnsiDst; <br>   LPSTR lpszAnsiSrc = szAnsiSrc; <br> <br>   W2A (lpszSrc, szAnsiSrc, 256); <br> <br>   // skip leading delimeter characters <br>   while (*lpszAnsiSrc &amp;&amp; --nMaxChars &gt; 0 <br>                        &amp;&amp; ((*lpszAnsiSrc=='/') || (*lpszAnsiSrc=='\\') || <br>                           (*lpszAnsiSrc=='!') || (*lpszAnsiSrc==':'))) { <br>      *lpszAnsiSrc++; <br>      chEaten++; <br>   } <br> <br>   // Extract token string (up to first delimeter char or EOS) <br>   while (*lpszAnsiSrc &amp;&amp; --nMaxChars &gt; 0 <br>                        &amp;&amp; !((*lpszAnsiSrc=='/') || (*lpszAnsiSrc=='\\') || <br>                           (*lpszAnsiSrc=='!') || (*lpszAnsiSrc==':'))) { <br>      *lpszAnsiDst++ = *lpszAnsiSrc++; <br>      chEaten++; <br>   } <br>   *lpszAnsiDst = '\0'; <br> <br>   A2W (szAnsiDst, lpszDst, OLEUI_CCHPATHMAX); <br>   return chEaten; <br>} <br> <br>/************************************************************************* <br>** OleStdCreateRootStorage <br>**    create a root level Storage given a filename that is compatible <br>**    to be used by a top-level OLE container. if the filename <br>**    specifies an existing file, then an error is returned. <br>**    the root storage (Docfile) that is created by this function <br>**    is suitable to be used to create child storages for embedings. <br>**    (CreateChildStorage can be used to create child storages.) <br>**    NOTE: the root-level storage is opened in transacted mode. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTORAGE) OleStdCreateRootStorage(LPOLESTR lpszStgName, DWORD grfMode) <br>{ <br>   HRESULT hr; <br>   DWORD grfCreateMode = STGM_READWRITE | STGM_TRANSACTED; <br>   DWORD reserved = 0; <br>   LPSTORAGE lpRootStg; <br>   char szMsg[64]; <br> <br>   // if temp file is being created, enable delete-on-release <br>   if (! lpszStgName) <br>      grfCreateMode |= STGM_DELETEONRELEASE; <br> <br>   hr = StgCreateDocfile( <br>         lpszStgName, <br>         grfMode | grfCreateMode, <br>         reserved, <br>         (LPSTORAGE FAR*)&amp;lpRootStg <br>      ); <br> <br>   if (hr == NOERROR) <br>      return lpRootStg;               // existing file successfully opened <br> <br>   OleDbgOutHResult("StgCreateDocfile returned", hr); <br> <br>   if (0 == LoadString(ghInst, (UINT)IDS_OLESTDNOCREATEFILE, /*(LPSTR)*/szMsg, 64)) <br>     return NULL; <br> <br>   MessageBox(NULL, /*(LPSTR)*/szMsg, NULL,MB_ICONEXCLAMATION | MB_OK); <br>   return NULL; <br>} <br> <br> <br>/************************************************************************* <br>** OleStdOpenRootStorage <br>**    open a root level Storage given a filename that is compatible <br>**    to be used by a top-level OLE container. if the file does not <br>**    exist then an error is returned. <br>**    the root storage (Docfile) that is opened by this function <br>**    is suitable to be used to create child storages for embedings. <br>**    (CreateChildStorage can be used to create child storages.) <br>**    NOTE: the root-level storage is opened in transacted mode. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTORAGE) OleStdOpenRootStorage(LPOLESTR lpszStgName, DWORD grfMode) <br>{ <br>   HRESULT hr; <br>   DWORD reserved = 0; <br>   LPSTORAGE lpRootStg; <br>   char  szMsg[64]; <br> <br>   if (lpszStgName) { <br> <br>      hr = StgOpenStorage( <br>            lpszStgName, <br>            NULL, <br>            grfMode | STGM_TRANSACTED, <br>            NULL, <br>            reserved, <br>            (LPSTORAGE FAR*)&amp;lpRootStg <br>         ); <br> <br>      if (hr == NOERROR) <br>         return lpRootStg;     // existing file successfully opened <br> <br>      OleDbgOutHResult("StgOpenStorage returned", hr); <br>   } <br> <br>   if (0 == LoadString(ghInst, (UINT)IDS_OLESTDNOOPENFILE, szMsg, 64)) <br>     return NULL; <br> <br>   MessageBox(NULL, /*(LPSTR)*/szMsg, NULL,MB_ICONEXCLAMATION | MB_OK); <br>   return NULL; <br>} <br> <br> <br>/************************************************************************* <br>** OpenOrCreateRootStorage <br>**    open a root level Storage given a filename that is compatible <br>**    to be used by a top-level OLE container. if the filename <br>**    specifies an existing file, then it is open, otherwise a new file <br>**    with the given name is created. <br>**    the root storage (Docfile) that is created by this function <br>**    is suitable to be used to create child storages for embedings. <br>**    (CreateChildStorage can be used to create child storages.) <br>**    NOTE: the root-level storage is opened in transacted mode. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTORAGE) OleStdOpenOrCreateRootStorage(LPOLESTR lpszStgName, DWORD grfMode) <br>{ <br>   HRESULT hrErr; <br>   SCODE sc; <br>   DWORD reserved = 0; <br>   LPSTORAGE lpRootStg; <br>   char      szMsg[64]; <br> <br>   if (lpszStgName) { <br> <br>      hrErr = StgOpenStorage( <br>            lpszStgName, <br>            NULL, <br>            grfMode | STGM_READWRITE | STGM_TRANSACTED, <br>            NULL, <br>            reserved, <br>            (LPSTORAGE FAR*)&amp;lpRootStg <br>      ); <br> </code></pre>
<p>
</p>
<pre><code>if (hrErr == NOERROR) <br>         return lpRootStg;      // existing file successfully opened <br> <br>      OleDbgOutHResult("StgOpenStorage returned", hrErr); <br>      sc = hrErr; <br> <br>      if (sc!=STG_E_FILENOTFOUND &amp;&amp; sc!=STG_E_FILEALREADYEXISTS) { <br>         return NULL; <br>      } <br>   } <br> <br>   /* if file did not already exist, try to create a new one */ <br>   hrErr = StgCreateDocfile( <br>         lpszStgName, <br>         grfMode | STGM_READWRITE | STGM_TRANSACTED, <br>         reserved, <br>         (LPSTORAGE FAR*)&amp;lpRootStg <br>   ); <br> <br>   if (hrErr == NOERROR) <br>      return lpRootStg;               // existing file successfully opened <br> <br>   OleDbgOutHResult("StgCreateDocfile returned", hrErr); <br> <br>   if (0 == LoadString(ghInst, (UINT)IDS_OLESTDNOCREATEFILE, /*(LPSTR)*/szMsg, 64)) <br>     return NULL; <br> <br>   MessageBox(NULL, /*(LPSTR)*/szMsg, NULL, MB_ICONEXCLAMATION | MB_OK); <br>   return NULL; <br>} <br> <br> <br>/* <br>** OleStdCreateChildStorage <br>**    create a child Storage inside the given lpStg that is compatible <br>**    to be used by an embedded OLE object. the return value from this <br>**    function can be passed to OleCreateXXX functions. <br>**    NOTE: the child storage is opened in transacted mode. <br>*/ <br>STDAPI_(LPSTORAGE) OleStdCreateChildStorage(LPSTORAGE lpStg, LPOLESTR lpszStgName) <br>{ <br>   if (lpStg != NULL) { <br>      LPSTORAGE lpChildStg; <br>      DWORD grfMode = (STGM_READWRITE | STGM_TRANSACTED | <br>            STGM_SHARE_EXCLUSIVE); <br>      DWORD reserved = 0; <br> <br>      HRESULT hrErr = lpStg-&gt;lpVtbl-&gt;CreateStorage( <br>            lpStg, <br>            lpszStgName, <br>            grfMode, <br>            reserved, <br>            reserved, <br>            (LPSTORAGE FAR*)&amp;lpChildStg <br>         ); <br> <br>      if (hrErr == NOERROR) <br>         return lpChildStg; <br> <br>      OleDbgOutHResult("lpStg-&gt;lpVtbl-&gt;CreateStorage returned", hrErr); <br>   } <br>   return NULL; <br>} <br> <br> <br>/* <br>** OleStdOpenChildStorage <br>**    open a child Storage inside the given lpStg that is compatible <br>**    to be used by an embedded OLE object. the return value from this <br>**    function can be passed to OleLoad function. <br>**    NOTE: the child storage is opened in transacted mode. <br>*/ <br>STDAPI_(LPSTORAGE) OleStdOpenChildStorage(LPSTORAGE lpStg, LPOLESTR lpszStgName, DWORD grfMode) <br>{ <br>   LPSTORAGE lpChildStg; <br>   LPSTORAGE lpstgPriority = NULL; <br>   DWORD reserved = 0; <br>   HRESULT hrErr; <br> <br>   if (lpStg  != NULL) { <br> <br>      hrErr = lpStg-&gt;lpVtbl-&gt;OpenStorage( <br>            lpStg, <br>            lpszStgName, <br>            lpstgPriority, <br>            grfMode | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE, <br>            NULL, <br>            reserved, <br>            (LPSTORAGE FAR*)&amp;lpChildStg <br>         ); <br> <br>      if (hrErr == NOERROR) <br>         return lpChildStg; <br> <br>      OleDbgOutHResult("lpStg-&gt;lpVtbl-&gt;OpenStorage returned", hrErr); <br>   } <br>   return NULL; <br>} <br> <br> <br>/* OleStdCommitStorage <br>** ------------------- <br>**    Commit the changes to the given IStorage*. This routine can be <br>**    called on either a root-level storage as used by an OLE-Container <br>**    or by a child storage as used by an embedded object. <br>** <br>**    This routine first attempts to perform this commit in a safe <br>**    manner. if this fails it then attempts to do the commit in a less <br>**    robust manner (STGC_OVERWRITE). <br>*/ <br>STDAPI_(BOOL) OleStdCommitStorage(LPSTORAGE lpStg) <br>{ <br>   HRESULT hrErr; <br> <br>   // make the changes permanent <br>   hrErr = lpStg-&gt;lpVtbl-&gt;Commit(lpStg, 0); <br> <br>   if (hrErr == STG_E_MEDIUMFULL) { <br>      // try to commit changes in less robust manner. <br>      OleDbgOut("Warning: commiting with STGC_OVERWRITE specified\n"); <br>      hrErr = lpStg-&gt;lpVtbl-&gt;Commit(lpStg, STGC_OVERWRITE); <br>   } <br> <br>   if (hrErr != NOERROR) <br>   { <br>      char szMsg[64]; <br> <br>      if (0 == LoadString(ghInst, (UINT)IDS_OLESTDDISKFULL, /*(LPSTR)*/szMsg, 64)) <br>         return FALSE; <br> <br>      MessageBox(NULL, /*(LPSTR)*/szMsg, NULL, MB_ICONEXCLAMATION | MB_OK); <br>      return FALSE; <br>   } <br>   else { <br>      return TRUE; <br>   } <br>} <br> <br> <br>/* OleStdDestroyAllElements <br>** ------------------------ <br>**    Destroy all elements within an open storage. this is subject <br>**    to the current transaction. <br>*/ <br>STDAPI OleStdDestroyAllElements(LPSTORAGE lpStg) <br>{ <br>   IEnumSTATSTG FAR* lpEnum; <br>   STATSTG sstg; <br>   HRESULT hrErr; <br> <br>   hrErr = lpStg-&gt;lpVtbl-&gt;EnumElements( <br>         lpStg, 0, NULL, 0, (IEnumSTATSTG FAR* FAR*)&amp;lpEnum); <br> <br>   if (hrErr != NOERROR) <br>      return hrErr; <br> <br>   while (1) { <br>      if (lpEnum-&gt;lpVtbl-&gt;Next(lpEnum, 1, &amp;sstg, NULL) != NOERROR) <br>         break; <br>      lpStg-&gt;lpVtbl-&gt;DestroyElement(lpStg, sstg.pwcsName); <br>      OleStdFree(sstg.pwcsName); <br>   } <br>   lpEnum-&gt;lpVtbl-&gt;Release(lpEnum); <br>   return NOERROR; <br>} <br> <br>// returns 1 for a close match <br>//  (all fields match exactly except the tymed which simply overlaps) <br>// 0 for no match <br> <br>int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight) <br>{ <br>        if (pFetcLeft-&gt;cfFormat != pFetcRight-&gt;cfFormat) <br>                return 0; <br>        else if (!OleStdCompareTargetDevice (pFetcLeft-&gt;ptd, pFetcRight-&gt;ptd)) <br>                return 0; <br>        if (pFetcLeft-&gt;dwAspect != pFetcRight-&gt;dwAspect) <br>                return 0; <br>        return((pFetcLeft-&gt;tymed | pFetcRight-&gt;tymed) != 0); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
