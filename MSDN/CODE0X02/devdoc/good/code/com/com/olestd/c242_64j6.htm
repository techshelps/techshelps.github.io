<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HATCH.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context252"></a>HATCH.C</h2>
<pre><code>/* <br> * HATCH.C <br> * <br> * Miscellaneous API's to generate hatch window for in-place active <br> * objects. This is part of the OLE 2.0 User Interface Support Library. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Right Reserved <br> */ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br> <br>// offsets in the extra bytes stored with the hatch window <br>#define EB_HATCHWIDTH       0 <br>#define EB_HATCHRECT_LEFT   2 <br>#define EB_HATCHRECT_TOP    4 <br>#define EB_HATCHRECT_RIGHT  6 <br>#define EB_HATCHRECT_BOTTOM 8 <br> <br>// class name of hatch window <br>#define CLASS_HATCH     "Hatch Window" <br> <br>// local function prototypes <br>LRESULT FAR PASCAL EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam); <br> <br> <br>/* <br> * HatchRegisterClass <br> * <br> * Purpose: <br> *  Register the hatch window <br> * <br> * Parameters: <br> *  hInst           Process instance <br> * <br> * Return Value: <br> *  TRUE            if successful <br> *  FALSE           if failed <br> * <br> */ <br>STDAPI_(BOOL) RegisterHatchWindowClass(HINSTANCE hInst) <br>{ <br>   WNDCLASS wc; <br> <br>   // Register Hatch Window Class <br>   wc.style = CS_BYTEALIGNWINDOW; <br>   wc.lpfnWndProc = HatchWndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = 5 * sizeof(int);    // extra bytes stores <br>                              //     uHatchWidth <br>                              //     rcHatchRect <br>   wc.hInstance = hInst; <br>   wc.hIcon = NULL; <br>   wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>   wc.lpszMenuName = NULL; <br>   wc.lpszClassName = CLASS_HATCH; <br> <br>   if (!RegisterClass(&amp;wc)) <br>      return FALSE; <br>   else <br>      return TRUE; <br>} <br> <br> <br>/* <br> * CreateHatchWindow <br> * <br> * Purpose: <br> *  Create the hatch window <br> * <br> * Parameters: <br> *  hWndParent          parent of hatch window <br> *  hInst               instance handle <br> * <br> * Return Value: <br> *  pointer to hatch window         if successful <br> *  NULL                            if failed <br> * <br> */ <br>STDAPI_(HWND) CreateHatchWindow(HWND hWndParent, HINSTANCE hInst) <br>{ <br>   HWND         hWnd; <br> <br>   if (!hWndParent || !hInst) <br>      return NULL; <br> <br>   hWnd = CreateWindow( <br>      CLASS_HATCH, <br>      "Hatch Window", <br>      WS_CHILDWINDOW | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, <br>      0, 0, 0, 0, <br>      hWndParent, <br>      (HMENU)NULL, <br>      hInst, <br>      0L <br>   ); <br> <br>   if (!hWnd) <br>      return NULL; <br> <br>   return hWnd; <br>} <br> <br>/* <br> *  GetHatchWidth <br> * <br> *  Purpose: <br> *      Get width of hatch border <br> * <br> *  Parameters: <br> *      hWndHatch       hatch window handle <br> * <br> *  Return Value: <br> *      width of the hatch border <br> */ <br>STDAPI_(UINT) GetHatchWidth(HWND hWndHatch) <br>{ <br>   if (!IsWindow(hWndHatch)) <br>      return 0; <br> <br>   return (UINT)GetWindowWord(hWndHatch, EB_HATCHWIDTH); <br>} <br> <br>/* <br> *  GetHatchRect <br> * <br> *  Purpose: <br> *      Get hatch rect. this is the size of the hatch window if it were <br> *      not clipped by the ClipRect. <br> * <br> *  Parameters: <br> *      hWndHatch       hatch window handle <br> *      lprcHatchRect   hatch rect <br> * <br> *  Return Value: <br> *      none <br> */ <br>STDAPI_(void) GetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect) <br>{ <br>   if (!IsWindow(hWndHatch)) { <br>      SetRect(lprcHatchRect, 0, 0, 0, 0); <br>      return; <br>   } <br> <br>   lprcHatchRect-&gt;left = GetWindowWord(hWndHatch, EB_HATCHRECT_LEFT); <br>   lprcHatchRect-&gt;top = GetWindowWord(hWndHatch, EB_HATCHRECT_TOP); <br>   lprcHatchRect-&gt;right = GetWindowWord(hWndHatch, EB_HATCHRECT_RIGHT); <br>   lprcHatchRect-&gt;bottom = GetWindowWord(hWndHatch, EB_HATCHRECT_BOTTOM); <br>} <br> <br> <br>/* SetHatchRect <br> * <br> * <br> *  Purpose: <br> *      Store hatch rect with HatchRect window. <br> *      this rect is the size of the hatch window if it were <br> *      not clipped by the ClipRect. <br> * <br> *  Parameters: <br> *      hWndHatch       hatch window handle <br> *      lprcHatchRect   hatch rect <br> * <br> *  Return Value: <br> *      none <br> */ <br>STDAPI_(void) SetHatchRect(HWND hWndHatch, LPRECT lprcHatchRect) <br>{ <br>   if (!IsWindow(hWndHatch)) <br>      return; <br> <br>   SetWindowWord(hWndHatch, EB_HATCHRECT_LEFT,  (WORD)lprcHatchRect-&gt;left); <br>   SetWindowWord(hWndHatch, EB_HATCHRECT_TOP,   (WORD)lprcHatchRect-&gt;top); <br>   SetWindowWord(hWndHatch, EB_HATCHRECT_RIGHT, (WORD)lprcHatchRect-&gt;right); <br>   SetWindowWord(hWndHatch, EB_HATCHRECT_BOTTOM,(WORD)lprcHatchRect-&gt;bottom); <br>} <br> <br> <br>/* SetHatchWindowSize <br> * <br> * <br> *  Purpose: <br> *      Move/size the HatchWindow correctly given the rect required by the <br> *      in-place server object window and the lprcClipRect imposed by the <br> *      in-place container. both rect's are expressed in the client coord. <br> *      of the in-place container's window (which is the parent of the <br> *      HatchWindow). <br> * <br> *      NOTE: the in-place server must honor the lprcClipRect specified <br> *      by its in-place container. it must NOT draw outside of the ClipRect. <br> *      in order to achieve this, the hatch window is sized to be <br> *      exactly the size that should be visible (rcVisRect). the <br> *      rcVisRect is defined as the intersection of the full size of <br> *      the HatchRect window and the lprcClipRect. <br> *      the ClipRect could infact clip the HatchRect on the <br> *      right/bottom and/or on the top/left. if it is clipped on the <br> *      right/bottom then it is sufficient to simply resize the hatch <br> *      window. but if the HatchRect is clipped on the top/left then <br> *      in-place server document window (child of HatchWindow) must be moved <br> *      by the delta that was clipped. the window origin of the <br> *      in-place server window will then have negative coordinates relative <br> *      to its parent HatchWindow. <br> * <br> *  Parameters: <br> *      hWndHatch       hatch window handle <br> *      lprcIPObjRect   full size of in-place server object window <br> *      lprcClipRect    clipping rect imposed by in-place container <br> *      lpptOffset      offset required to position in-place server object <br> *                      window properly. caller should call: <br> *                          OffsetRect(&amp;rcObjRect,lpptOffset-&gt;x,lpptOffset-&gt;y) <br> * <br> *  Return Value: <br> *      none <br> */ <br>STDAPI_(void) SetHatchWindowSize( <br>      HWND        hWndHatch, <br>      LPRECT      lprcIPObjRect, <br>      LPRECT      lprcClipRect, <br>      LPPOINT       lpptOffset <br>) <br>{ <br>   RECT        rcHatchRect; <br>   RECT        rcVisRect; <br>   UINT        uHatchWidth; <br>   POINT       ptOffset; <br> <br>   if (!IsWindow(hWndHatch)) <br>      return; <br> <br>   rcHatchRect = *lprcIPObjRect; <br>   uHatchWidth = GetHatchWidth(hWndHatch); <br>   InflateRect((LPRECT)&amp;rcHatchRect, uHatchWidth + 1, uHatchWidth + 1); <br> <br>   IntersectRect((LPRECT)&amp;rcVisRect, (LPRECT)&amp;rcHatchRect, lprcClipRect); <br>   MoveWindow( <br>         hWndHatch, <br>         rcVisRect.left, <br>         rcVisRect.top, <br>         rcVisRect.right-rcVisRect.left, <br>         rcVisRect.bottom-rcVisRect.top, <br>         TRUE    /* fRepaint */ <br>   ); <br>   InvalidateRect(hWndHatch, NULL, TRUE); <br> <br>   ptOffset.x = -rcHatchRect.left + (rcHatchRect.left - rcVisRect.left); <br>   ptOffset.y = -rcHatchRect.top + (rcHatchRect.top - rcVisRect.top); <br> <br>   /* convert the rcHatchRect into the client coordinate system of the <br>   **    HatchWindow itself <br>   */ <br>   OffsetRect((LPRECT)&amp;rcHatchRect, ptOffset.x, ptOffset.y); <br> <br>   SetHatchRect(hWndHatch, (LPRECT)&amp;rcHatchRect); <br> <br>   // calculate offset required to position in-place server doc window <br>   lpptOffset-&gt;x = ptOffset.x; <br>   lpptOffset-&gt;y = ptOffset.y; <br>} <br> <br> <br>/* <br> *  HatchWndProc <br> * <br> *  Purpose: <br> *      WndProc for hatch window <br> * <br> *  Parameters: <br> *      hWnd <br> *      Message <br> *      wParam <br> *      lParam <br> * <br> *  Return Value: <br> *      message dependent <br> */ <br>LRESULT FAR PASCAL EXPORT HatchWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   int nBorderWidth; <br> <br>   switch (Message) { <br> <br>      case WM_CREATE: <br>         nBorderWidth = GetProfileInt( <br>            "windows", <br>            "oleinplaceborderwidth", <br>            DEFAULT_HATCHBORDER_WIDTH <br>         ); <br>         SetWindowWord(hWnd, EB_HATCHWIDTH, (WORD)nBorderWidth); <br>         break; <br> <br>      case WM_PAINT: <br>      { <br>         HDC hDC; <br>         PAINTSTRUCT ps; <br>         RECT rcHatchRect; <br> <br>         nBorderWidth = GetHatchWidth(hWnd); <br>         hDC = BeginPaint(hWnd, &amp;ps); <br>         GetHatchRect(hWnd, (LPRECT)&amp;rcHatchRect); <br>         OleUIDrawShading(&amp;rcHatchRect, hDC, OLEUI_SHADE_BORDERIN, <br>               nBorderWidth); <br>         InflateRect((LPRECT)&amp;rcHatchRect, -nBorderWidth, -nBorderWidth); <br>         OleUIDrawHandles(&amp;rcHatchRect, hDC, OLEUI_HANDLES_OUTSIDE, <br>               nBorderWidth+1, TRUE); <br>         EndPaint(hWnd, &amp;ps); <br>         break; <br>      } <br> <br>      /* NOTE: Any window that is used during in-place activation <br>      **    must handle the WM_SETCURSOR message or else the cursor <br>      **    of the in-place parent will be used. if WM_SETCURSOR is <br>      **    not handled, then DefWindowProc sends the message to the <br>      **    window's parent. <br>      */ <br>      case WM_SETCURSOR: <br>         SetCursor(LoadCursor( NULL, MAKEINTRESOURCE(IDC_ARROW) ) ); <br>         return (LRESULT)TRUE; <br> <br>      default: <br>         return DefWindowProc(hWnd, Message, wParam, lParam); <br>   } <br> <br>   return 0L; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
