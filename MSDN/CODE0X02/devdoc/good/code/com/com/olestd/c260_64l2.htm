<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TARGTDEV.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context266"></a>TARGTDEV.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Standard Utilities <br>** <br>**    olestd.c <br>** <br>**    This file contains utilities that are useful for dealing with <br>**    target devices. <br>** <br>**    (c) Copyright Microsoft Corp. 1992-1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#ifndef WIN32 <br>#include &lt;print.h&gt; <br>#endif <br> <br>/* <br> * OleStdCreateDC() <br> * <br> * Purpose: <br> * <br> * Parameters: <br> * <br> * Return Value: <br> *    SCODE  -  S_OK if successful <br> */ <br>STDAPI_(HDC) OleStdCreateDC(DVTARGETDEVICE FAR* ptd) <br>{ <br>        HDC hdc=NULL; <br>        LPDEVNAMES lpDevNames; <br>        LPDEVMODE lpDevMode; <br>        LPSTR lpszDriverName; <br>        LPSTR lpszDeviceName; <br>        LPSTR lpszPortName; <br> <br>        if (ptd == NULL) { <br>                hdc = CreateDC("DISPLAY", NULL, NULL, NULL); <br>                goto errReturn; <br>        } <br> <br>        lpDevNames = (LPDEVNAMES) ptd; // offset for size field <br> <br>        if (ptd-&gt;tdExtDevmodeOffset == 0) { <br>                lpDevMode = NULL; <br>        }else{ <br>                lpDevMode  = (LPDEVMODE) (/*(LPSTR)*/ptd + ptd-&gt;tdExtDevmodeOffset); <br>        } <br> <br>        lpszDriverName = (LPSTR) lpDevNames + ptd-&gt;tdDriverNameOffset; <br>        lpszDeviceName = (LPSTR) lpDevNames + ptd-&gt;tdDeviceNameOffset; <br>        lpszPortName   = (LPSTR) lpDevNames + ptd-&gt;tdPortNameOffset; <br> <br>        hdc = CreateDC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode); <br> <br>errReturn: <br>        return hdc; <br>} <br> <br> <br>/* <br> * OleStdCreateIC() <br> * <br> * Purpose: Same as OleStdCreateDC, except that information context is <br> *          created, rather than a whole device context.  (CreateIC is <br> *          used rather than CreateDC). <br> *          OleStdDeleteDC is still used to delete the information context. <br> * <br> * Parameters: <br> * <br> * Return Value: <br> *    SCODE  -  S_OK if successful <br> */ <br>STDAPI_(HDC) OleStdCreateIC(DVTARGETDEVICE FAR* ptd) <br>{ <br>        HDC hdcIC=NULL; <br>        LPDEVNAMES lpDevNames; <br>        LPDEVMODE lpDevMode; <br>        LPSTR lpszDriverName; <br>        LPSTR lpszDeviceName; <br>        LPSTR lpszPortName; <br> <br>        if (ptd == NULL) { <br>                hdcIC = CreateIC("DISPLAY", NULL, NULL, NULL); <br>                goto errReturn; <br>        } <br> <br>        lpDevNames = (LPDEVNAMES) ptd; // offset for size field <br> <br>        lpDevMode  = (LPDEVMODE) (/*(LPSTR)*/ptd + ptd-&gt;tdExtDevmodeOffset); <br> <br>        lpszDriverName = (LPSTR) lpDevNames + ptd-&gt;tdDriverNameOffset; <br>        lpszDeviceName = (LPSTR) lpDevNames + ptd-&gt;tdDeviceNameOffset; <br>        lpszPortName   = (LPSTR) lpDevNames + ptd-&gt;tdPortNameOffset; <br> <br>        hdcIC = CreateIC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode); <br> <br>errReturn: <br>        return hdcIC; <br>} <br> <br> <br>/* <br> * OleStdCreateTargetDevice() <br> * <br> * Purpose: <br> * <br> * Parameters: <br> * <br> * Return Value: <br> *    SCODE  -  S_OK if successful <br> */ <br>STDAPI_(DVTARGETDEVICE FAR*) OleStdCreateTargetDevice(LPPRINTDLG lpPrintDlg) <br>{ <br>        DVTARGETDEVICE FAR* ptd=NULL; <br>        LPDEVNAMES lpDevNames, pDN; <br>        LPDEVMODE lpDevMode, pDM; <br>        UINT nMaxOffset; <br>        LPSTR pszName; <br>        DWORD dwDevNamesSize, dwDevModeSize, dwPtdSize; <br> <br>        if ((pDN = (LPDEVNAMES)GlobalLock(lpPrintDlg-&gt;hDevNames)) == NULL) { <br>                goto errReturn; <br>        } <br> <br>        if ((pDM = (LPDEVMODE)GlobalLock(lpPrintDlg-&gt;hDevMode)) == NULL) { <br>                goto errReturn; <br>        } <br> <br>        nMaxOffset =  (pDN-&gt;wDriverOffset &gt; pDN-&gt;wDeviceOffset) ? <br>                pDN-&gt;wDriverOffset : pDN-&gt;wDeviceOffset ; <br> <br>        nMaxOffset =  (pDN-&gt;wOutputOffset &gt; nMaxOffset) ? <br>                pDN-&gt;wOutputOffset : nMaxOffset ; <br> <br>        pszName = (LPSTR)pDN + nMaxOffset; <br> <br>        dwDevNamesSize = (DWORD)(nMaxOffset+lstrlen(pszName) + 1/* NULL term */); <br>        dwDevModeSize = (DWORD) (pDM-&gt;dmSize + pDM-&gt;dmDriverExtra); <br> <br>        dwPtdSize = sizeof(DWORD) + dwDevNamesSize + dwDevModeSize; <br> <br>        if ((ptd = (DVTARGETDEVICE FAR*)OleStdMalloc(dwPtdSize)) != NULL) { <br> <br>                // copy in the info <br>                ptd-&gt;tdSize = (UINT)dwPtdSize; <br> <br>                lpDevNames = (LPDEVNAMES) &amp;ptd-&gt;tdDriverNameOffset; <br>                _fmemcpy(lpDevNames, pDN, (size_t)dwDevNamesSize); <br> <br>                lpDevMode=(LPDEVMODE)(/*(LPSTR)*/&amp;ptd-&gt;tdDriverNameOffset+dwDevNamesSize); <br>                _fmemcpy(lpDevMode, pDM, (size_t)dwDevModeSize); <br> <br>                ptd-&gt;tdDriverNameOffset += 4 ; <br>                ptd-&gt;tdDeviceNameOffset += 4 ; <br>                ptd-&gt;tdPortNameOffset   += 4 ; <br>                ptd-&gt;tdExtDevmodeOffset = (UINT)dwDevNamesSize + 4 ; <br>        } <br> <br>errReturn: <br>        GlobalUnlock(lpPrintDlg-&gt;hDevNames); <br>        GlobalUnlock(lpPrintDlg-&gt;hDevMode); <br> <br>        return ptd; <br>} <br> <br> <br> <br>/* <br> * OleStdDeleteTargetDevice() <br> * <br> * Purpose: <br> * <br> * Parameters: <br> * <br> * Return Value: <br> *    SCODE  -  S_OK if successful <br> */ <br>STDAPI_(BOOL) OleStdDeleteTargetDevice(DVTARGETDEVICE FAR* ptd) <br>{ <br>        BOOL res=TRUE; <br> <br>        if (ptd != NULL) { <br>                OleStdFree(ptd); <br>        } <br> <br>        return res; <br>} <br> <br> <br> <br>/* <br> * OleStdCopyTargetDevice() <br> * <br> * Purpose: <br> *  duplicate a TARGETDEVICE struct. this function allocates memory for <br> *  the copy. the caller MUST free the allocated copy when done with it <br> *  using the standard allocator returned from CoGetMalloc. <br> *  (OleStdFree can be used to free the copy). <br> * <br> * Parameters: <br> *  ptdSrc      pointer to source TARGETDEVICE <br> * <br> * Return Value: <br> *    pointer to allocated copy of ptdSrc <br> *    if ptdSrc==NULL then retuns NULL is returned. <br> *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned <br> */ <br>STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc) <br>{ <br>  DVTARGETDEVICE FAR* ptdDest = NULL; <br> <br>  if (ptdSrc == NULL) { <br>        return NULL; <br>  } <br> <br>  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc-&gt;tdSize)) != NULL) { <br>        _fmemcpy(ptdDest, ptdSrc, (size_t)ptdSrc-&gt;tdSize); <br>  } <br> <br>  return ptdDest; <br>} <br> <br> <br>/* <br> * OleStdCopyFormatEtc() <br> * <br> * Purpose: <br> *  Copies the contents of a FORMATETC structure. this function takes <br> *  special care to copy correctly copying the pointer to the TARGETDEVICE <br> *  contained within the source FORMATETC structure. <br> *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy <br> *  of the TARGETDEVICE will be allocated for the destination of the <br> *  FORMATETC (petcDest). <br> * <br> *  NOTE: the caller MUST free the allocated copy of the TARGETDEVICE <br> *  within the destination FORMATETC when done with it <br> *  using the standard allocator returned from CoGetMalloc. <br> *  (OleStdFree can be used to free the copy). <br> * <br> * Parameters: <br> *  petcDest      pointer to destination FORMATETC <br> *  petcSrc       pointer to source FORMATETC <br> * <br> * Return Value: <br> *    returns TRUE is copy is successful; retuns FALSE if not successful <br> */ <br>STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc) <br>{ <br>  if ((petcDest == NULL) || (petcSrc == NULL)) { <br>        return FALSE; <br>  } <br> <br>  petcDest-&gt;cfFormat = petcSrc-&gt;cfFormat; <br>  petcDest-&gt;ptd      = OleStdCopyTargetDevice(petcSrc-&gt;ptd); <br>  petcDest-&gt;dwAspect = petcSrc-&gt;dwAspect; <br>  petcDest-&gt;lindex   = petcSrc-&gt;lindex; <br>  petcDest-&gt;tymed    = petcSrc-&gt;tymed; <br> <br>  return TRUE; <br> <br>} <br> <br> <br>// returns 0 for exact match, 1 for no match, -1 for partial match (which is <br>// defined to mean the left is a subset of the right: fewer aspects, null target <br>// device, fewer medium). <br> <br>STDAPI_(int) OleStdCompareFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight) <br>{ <br>        BOOL bExact = TRUE; <br> <br>        if (pFetcLeft-&gt;cfFormat != pFetcRight-&gt;cfFormat) <br>                return 1; <br>        else if (!OleStdCompareTargetDevice (pFetcLeft-&gt;ptd, pFetcRight-&gt;ptd)) <br>                return 1; <br>        if (pFetcLeft-&gt;dwAspect == pFetcRight-&gt;dwAspect) <br>                // same aspects; equal <br>                ; <br>        else if ((pFetcLeft-&gt;dwAspect &amp; ~pFetcRight-&gt;dwAspect) != 0) <br>                // left not subset of aspects of right; not equal <br>                return 1; <br>        else <br>                // left subset of right <br>                bExact = FALSE; <br> <br>        if (pFetcLeft-&gt;tymed == pFetcRight-&gt;tymed) <br>                // same medium flags; equal <br>                ; <br>        else if ((pFetcLeft-&gt;tymed &amp; ~pFetcRight-&gt;tymed) != 0) <br>                // left not subset of medium flags of right; not equal <br>                return 1; <br>        else <br>                // left subset of right <br>                bExact = FALSE; <br> <br>        return bExact ? 0 : -1; <br>} <br> <br> <br> <br>STDAPI_(BOOL) OleStdCompareTargetDevice <br>        (DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight) <br>{ <br>        if (ptdLeft == ptdRight) <br>                // same address of td; must be same (handles NULL case) <br>                return TRUE; <br>        else if ((ptdRight == NULL) || (ptdLeft == NULL)) <br>                return FALSE; <br>        else if (ptdLeft-&gt;tdSize != ptdRight-&gt;tdSize) <br>                // different sizes, not equal <br>                return FALSE; <br>#ifdef WIN32 <br>        else if (memcmp(ptdLeft, ptdRight, ptdLeft-&gt;tdSize) != 0) <br>#else <br>        else if (_fmemcmp(ptdLeft, ptdRight, (int)ptdLeft-&gt;tdSize) != 0) <br>#endif <br>                // not same target device, not equal <br>                return FALSE; <br> <br>        return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
