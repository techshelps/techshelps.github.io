<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>REGDB.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context261"></a>REGDB.C</h2>
<pre><code>/* <br> *  REGDB.C <br> * <br> *  Functions to query the registration database <br> * <br> *  OleStdGetMiscStatusOfClass <br> *  OleStdGetDefaultFileFormatOfClass <br> *  OleStdGetAuxUserType <br> *  OleStdGetUserTypeOfClass <br> * <br> *    (c) Copyright Microsoft Corp. 1992-1996 All Rights Reserved <br> * <br> */ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include "common.h" <br>#include &lt;ctype.h&gt; <br> <br>OLEDBGDATA <br> <br> <br>// Replacement for stdlib atol, <br>// which didn't work and doesn't take far pointers. <br>// Must be tolerant of leading spaces. <br>// <br>// <br>static LONG Atol(LPSTR lpsz) <br>{ <br>   signed int sign = +1; <br>   UINT base = 10; <br>   LONG l = 0; <br> <br>   if (NULL==lpsz) <br>   { <br>      OleDbgAssert (0); <br>      return 0; <br>   } <br>   while (isspace(*lpsz)) <br>      lpsz++; <br> <br>   if (*lpsz=='-') <br>   { <br>      lpsz++; <br>      sign = -1; <br>   } <br>   if (lpsz[0]=='0' &amp;&amp; lpsz[1]=='x') <br>   { <br>      base = 16; <br>      lpsz+=2; <br>   } <br> <br>   if (base==10) <br>   { <br>      while (isdigit(*lpsz)) <br>      { <br>         l = l * base + *lpsz - '0'; <br>         lpsz++; <br>      } <br>   } <br>   else <br>   { <br>      OleDbgAssert (base==16); <br>      while (isxdigit(*lpsz)) <br>      { <br>         l = l * base + isdigit(*lpsz) ? *lpsz - '0' : toupper(*lpsz) - 'A' + 10; <br>         lpsz++; <br>      } <br>   } <br>   return l * sign; <br>} <br> <br> <br> <br>/* <br> * OleStdGetUserTypeOfClass(REFCLSID, LPSTR, UINT, HKEY) <br> * <br> * Purpose: <br> *  Returns the user type (human readable class name) of the specified class. <br> * <br> * Parameters: <br> *  rclsid          pointer to the clsid to retrieve user type of. <br> *  lpszUserType    pointer to buffer to return user type in. <br> *  cch             length of buffer pointed to by lpszUserType <br> *  hKey            hKey for reg db - if this is NULL, then we <br> *                   open and close the reg db within this function.  If it <br> *                   is non-NULL, then we assume it's a valid key to the <br> *                   \ root and use it without closing it. (useful <br> *                   if you're doing lots of reg db stuff). <br> * <br> * Return Value: <br> *  UINT            Number of characters in returned string.  0 on error. <br> * <br> */ <br>STDAPI_(UINT) OleStdGetUserTypeOfClass(REFCLSID rclsid, LPOLESTR lpszUserType, UINT cch, HKEY hKey) <br>{ <br> <br>   LONG     dw; <br>   LONG     lRet; <br>   LPOLESTR lpszCLSID, lpszProgID; <br>   char     lpszAnsiCLSID[256], lpszAnsiProgID[256]; <br>   BOOL     fFreeProgID = FALSE; <br>   BOOL     bCloseRegDB = FALSE; <br>   char     szKey[128]; <br>   LPMALLOC lpIMalloc; <br>   char     lpszAnsiUserType[256]; <br> <br>   if (!lpszUserType) <br>      return 0; <br> <br>   *lpszUserType = '\0'; <br>   if (hKey == NULL) <br>   { <br> <br>    //Open up the root key. <br>    lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br> <br>    if ((LONG)ERROR_SUCCESS!=lRet) <br>      return (UINT)FALSE; <br> <br>    bCloseRegDB = TRUE; <br>   } <br> <br>   // Get a string containing the class name <br>   StringFromCLSID(rclsid, &amp;lpszCLSID); <br> <br>   W2A (lpszCLSID, lpszAnsiCLSID, 256); <br>   wsprintf(szKey, "CLSID\\%s", lpszAnsiCLSID); <br> <br> <br>   dw=cch; <br>   lRet = RegQueryValue(hKey, szKey, lpszAnsiUserType, &amp;dw); <br>   A2W (lpszAnsiUserType, lpszUserType, cch); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) { <br>      // Load 'Unknown Source' and 'Unknown Type' strings <br>      dw = (LONG)LoadString(ghInst, (UINT)IDS_PSUNKNOWNTYPE, lpszAnsiUserType, cch); <br>      A2W (lpszAnsiUserType, lpszUserType, cch); <br>   } <br> <br>   if ( ((LONG)ERROR_SUCCESS!=lRet) &amp;&amp; (CoIsOle1Class(rclsid)) ) <br>   { <br>     // We've got an OLE 1.0 class, so let's try to get the user type <br>     // name from the ProgID entry. <br> <br>     ProgIDFromCLSID(rclsid, &amp;lpszProgID); <br>     fFreeProgID = TRUE; <br> <br>     dw = cch; <br>     W2A (lpszProgID, lpszAnsiProgID, 256); <br>     lRet = RegQueryValue(hKey, lpszAnsiProgID, lpszAnsiUserType, &amp;dw); <br>     A2W (lpszAnsiUserType, lpszUserType, cch); <br> <br>     if ((LONG)ERROR_SUCCESS != lRet) <br>      dw = 0; <br>   } <br> <br> <br>   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &amp;lpIMalloc)) <br>   { <br>      if (fFreeProgID) <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, (LPVOID)lpszProgID); <br> <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, (LPVOID)lpszCLSID); <br>      lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>   } <br> <br>   if (bCloseRegDB) <br>     RegCloseKey(hKey); <br> <br>   return (UINT)dw; <br> <br>} <br> <br> <br> <br>/* <br> * OleStdGetAuxUserType(RCLSID, WORD, LPSTR, int, HKEY) <br> * <br> * Purpose: <br> *  Returns the specified AuxUserType from the reg db. <br> * <br> * Parameters: <br> *  rclsid          pointer to the clsid to retrieve aux user type of. <br> *  hKey            hKey for reg db - if this is NULL, then we <br> *                   open and close the reg db within this function.  If it <br> *                   is non-NULL, then we assume it's a valid key to the <br> *                   \ root and use it without closing it. (useful <br> *                   if you're doing lots of reg db stuff). <br> *  wAuxUserType    which aux user type field to look for.  In 4/93 release <br> *                  2 is short name and 3 is exe name. <br> *  lpszUserType    pointer to buffer to return user type in. <br> *  cch             length of buffer pointed to by lpszUserType <br> * <br> * Return Value: <br> *  UINT            Number of characters in returned string.  0 on error. <br> * <br> */ <br>STDAPI_(UINT) OleStdGetAuxUserType(REFCLSID rclsid, <br>                           WORD     wAuxUserType, <br>                           LPOLESTR lpszAuxUserType, <br>                           int      cch, <br>                           HKEY     hKey) <br>{ <br>   HKEY     hThisKey; <br>   BOOL     fCloseRegDB = FALSE; <br>   LONG     dw; <br>   LRESULT  lRet; <br>   LPOLESTR lpszCLSID; <br>   char     lpszAnsiCLSID[256]; <br>   char     lpszAnsiAuxUserType[256]; <br>   LPMALLOC lpIMalloc; <br>   char     szKey[OLEUI_CCHKEYMAX]; <br>   char     szTemp[32]; <br> <br>   lpszAnsiAuxUserType[0] = '\0'; <br> <br>   if (NULL == hKey) <br>   { <br>     lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hThisKey); <br> <br>     if (ERROR_SUCCESS != lRet) <br>        return 0; <br>   } <br>   else <br>     hThisKey = hKey; <br> <br>   StringFromCLSID(rclsid, &amp;lpszCLSID); <br>   W2A (lpszCLSID, lpszAnsiCLSID, 256); <br> <br>   lstrcpy(szKey, "CLSID\\"); <br>   lstrcat(szKey, lpszAnsiCLSID); <br>   wsprintf(szTemp, "\\AuxUserType\\%d", wAuxUserType); <br>   lstrcat(szKey, szTemp); <br> <br>   dw = cch; <br> <br>   lRet = RegQueryValue(hThisKey, szKey, lpszAnsiAuxUserType, &amp;dw); <br> <br>   if (ERROR_SUCCESS != lRet) { <br>    dw = 0; <br>    lpszAuxUserType[0] = '\0'; <br>   } <br> <br> <br>   if (fCloseRegDB) <br>     RegCloseKey(hThisKey); <br> <br>   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &amp;lpIMalloc)) <br>   { <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, (LPVOID)lpszCLSID); <br>      lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>   } <br> <br>   A2W (lpszAnsiAuxUserType, lpszAuxUserType, cch); <br>   return (UINT)dw; <br>} <br> <br> <br> <br>/* <br> * OleStdGetMiscStatusOfClass(REFCLSID, HKEY) <br> * <br> * Purpose: <br> *  Returns the value of the misc status for the given clsid. <br> * <br> * Parameters: <br> *  rclsid          pointer to the clsid to retrieve user type of. <br> *  hKey            hKey for reg db - if this is NULL, then we <br> *                   open and close the reg db within this function.  If it <br> *                   is non-NULL, then we assume it's a valid key to the <br> *                   \\CLSID root and use it without closing it. (useful <br> *                   if you're doing lots of reg db stuff). <br> * <br> * Return Value: <br> *  BOOL            TRUE on success, FALSE on failure. <br> * <br> */ <br>STDAPI_(BOOL) OleStdGetMiscStatusOfClass(REFCLSID rclsid, HKEY hKey, DWORD FAR * lpdwValue) <br>{ <br>   DWORD dw; <br>   LONG  lRet; <br>   LPOLESTR lpszCLSID; <br>   char     lpszAnsiCLSID[256]; <br>   char  szKey[64]; <br>   char  szMiscStatus[OLEUI_CCHKEYMAX]; <br>   BOOL  bCloseRegDB = FALSE; <br> <br>   if (hKey == NULL) <br>   { <br> <br>    //Open up the root key. <br>    lRet=RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &amp;hKey); <br> <br>    if ((LONG)ERROR_SUCCESS!=lRet) <br>      return FALSE; <br> <br>    bCloseRegDB = TRUE; <br>   } <br> <br>   // Get a string containing the class name <br>   StringFromCLSID(rclsid, &amp;lpszCLSID); <br>   W2A (lpszCLSID, lpszAnsiCLSID, 256); <br> <br>   // Construct key <br>   lstrcpy(szKey, lpszAnsiCLSID); <br>   lstrcat(szKey, "\\MiscStatus"); <br> <br> <br>   dw=OLEUI_CCHKEYMAX; <br>   lRet = RegQueryValue(hKey, szKey, /*(LPSTR)*/szMiscStatus, &amp;dw); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>   { <br>      OleStdFreeString(lpszCLSID, NULL); <br> <br>      if (bCloseRegDB) <br>        RegCloseKey(hKey); <br> <br>      return FALSE; <br> <br>   } <br> <br>   *lpdwValue = Atol(/*(LPSTR)*/szMiscStatus); <br> <br>   OleStdFreeString(lpszCLSID, NULL); <br> <br>   if (bCloseRegDB) <br>     RegCloseKey(hKey); <br> <br>   return TRUE; <br> <br> <br>} <br> <br> <br>/* <br> * CLIPFORMAT OleStdGetDefaultFileFormatOfClass(REFCLSID, HKEY) <br> * <br> * Purpose: <br> *  Returns the default file format of the specified class. <br> *  this is entered in REGDB as follows: <br> *      CLSID\{...}\DataFormats\DefaultFile = &lt;cfFmt&gt; <br> * <br> * Parameters: <br> *  rclsid          pointer to the clsid to retrieve user type of. <br> *  hKey            hKey for reg db- if this is NULL, then we <br> *                   open and close the reg db within this function.  If it <br> *                   is non-NULL, then we assume it's a valid key to the <br> *                   \ root and use it without closing it. (useful <br> *                   if you're doing lots of reg db stuff). <br> * <br> * Return Value: <br> *  cfFmt   -- DefaultFile format <br> *  NULL    -- failed to get default file format <br> * <br> */ <br>STDAPI_(CLIPFORMAT) OleStdGetDefaultFileFormatOfClass( <br>      REFCLSID        rclsid, <br>      HKEY            hKey <br>) <br>{ <br>   CLIPFORMAT cfFmt = 0; <br>   DWORD dw; <br>   LONG  lRet; <br>   LPOLESTR lpszCLSID; <br>   char     lpszAnsiCLSID[256]; <br>   BOOL  bCloseRegDB = FALSE; <br>   char  szKey[128]; <br>   char  szDefaultFile[OLEUI_CCHKEYMAX]; <br>   BOOL  bStatus = TRUE; <br> <br> <br>   if (hKey == NULL) <br>   { <br> <br>    //Open up the root key. <br>    lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br> <br>    if ((LONG)ERROR_SUCCESS!=lRet) <br>      return 0; <br> <br>    bCloseRegDB = TRUE; <br>   } <br> <br> <br>   // Get a string containing the class name <br>   StringFromCLSID(rclsid, &amp;lpszCLSID); <br>   W2A (lpszCLSID, lpszAnsiCLSID, 256); <br> <br>   // Construct key <br>   wsprintf(szKey, "CLSID\\%s\\DataFormats\\DefaultFile", lpszCLSID); <br>   OleStdFreeString(lpszCLSID, NULL); <br> <br>   dw=OLEUI_CCHKEYMAX; <br>   lRet = RegQueryValue(hKey, szKey, /*(LPSTR)*/szDefaultFile, (LONG FAR *)&amp;dw); <br> <br>   if ((LONG)ERROR_SUCCESS!=lRet) <br>      bStatus = FALSE; <br>   else { <br>      /* if the format is a number, then it should refer to one of the <br>      **    standard Windows formats. <br>      */ <br>      if (isdigit(szDefaultFile[0])) <br>         cfFmt = (CLIPFORMAT)Atol(szDefaultFile); <br>      else <br>         cfFmt = RegisterClipboardFormat(szDefaultFile); <br>   } <br> <br>   if (bCloseRegDB) <br>     RegCloseKey(hKey); <br> <br>   return cfFmt; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
