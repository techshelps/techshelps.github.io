<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBALLOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context244"></a>DBALLOC.CPP</h2>
<pre><code>/*** <br>*dballoc.cpp <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation.  All Rights Reserved. <br>* <br>*Purpose: <br>*  This file contains a debug implementation of the IMalloc interface. <br>* <br>*  This implementation is basically a simple wrapping of the C runtime, <br>*  with additional work to detect memory leakage, and memory overwrite. <br>* <br>*  Leakage is detected by tracking each allocation in an address <br>*  instance table, and then checking to see if the table is empty <br>*  when the last reference to the allocator is released. <br>* <br>*  Memory overwrite is detected by placing a signature at the end <br>*  of every allocated block, and checking to make sure the signature <br>*  is unchanged when the block is freed. <br>* <br>*  This implementation also has additional param validation code, as <br>*  well as additional check make sure that instances that are passed <br>*  to Free() were actually allocated by the corresponding instance <br>*  of the allocator. <br>* <br>* <br>*  Creating an instance of this debug allocator that uses the default <br>*  output interface would look like the following, <br>* <br>* <br>*  BOOL init_application_instance() <br>*  { <br>*    HRESULT hresult; <br>*    IMalloc FAR* pmalloc; <br>* <br>*    pmalloc = NULL; <br>* <br>*    if((hresult = OleStdCreateDbAlloc(0,&amp;pmalloc))!=NOERROR) <br>*      goto LReturn; <br>* <br>*    hresult = OleInitialize(pmalloc); <br>* <br>*    // release pmalloc to let OLE hold the only ref to the it. later <br>*    // when OleUnitialize is called, memory leaks will be reported. <br>*    if(pmalloc != NULL) <br>*      pmalloc-&gt;Release(); <br>* <br>*  LReturn: <br>* <br>*    return (hresult == NOERROR) ? TRUE : FALSE; <br>*  } <br>* <br>* <br>*  CONSIDER: could add an option to force error generation, something <br>*   like DBALLOC_ERRORGEN <br>* <br>*  CONSIDER: add support for heap-checking. say for example, <br>*   DBALLOC_HEAPCHECK would do a heapcheck every free? every 'n' <br>*   calls to free? ... <br>* <br>* <br>*Implementation Notes: <br>* <br>*  The method IMalloc::DidAlloc() is allowed to always return <br>*  "Dont Know" (-1).  This method is called by Ole, and they take <br>*  some appropriate action when they get this answer. <br>* <br>*****************************************************************************/ <br> <br> <br>// Note: this file is designed to be stand-alone; it includes a <br>// carefully chosen, minimal set of headers. <br>// <br>// For conditional compilation we use the ole2 conventions, <br>//    _MAC      = mac <br>//    WIN32     = Win32 (NT really) <br>//    &lt;nothing&gt; = defaults to Win16 <br> <br> <br>// REVIEW: the following needs to modified to handle _MAC <br>#define STRICT <br> <br>#include &lt;windows.h&gt; <br> <br>#include &lt;ole2.h&gt; <br> <br>#if defined( __TURBOC__) <br>#define __STDC__ (1) <br>#endif <br> <br>#define WINDLL  1           // make far pointer version of stdargs.h <br>#include &lt;stdarg.h&gt; <br> <br>#if defined( __TURBOC__) <br>#undef __STDC__ <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;malloc.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;limits.h&gt; <br> <br>#include "dballoc.h" <br> <br>extern "C" DWORD g_dwObjectCount; // since we don't include ole2ui.h <br> <br>#define DIM(X) (sizeof(X)/sizeof((X)[0])) <br> <br>#define UNREACHED 0 <br> <br>#if defined(WIN32) <br># define MEMCMP(PV1, PV2, CB)   memcmp((PV1), (PV2), (CB)) <br># define MEMCPY(PV1, PV2, CB)   memcpy((PV1), (PV2), (CB)) <br># define MEMSET(PV,  VAL, CB)   memset((PV),  (VAL), (CB)) <br># define MALLOC(CB)     malloc(CB) <br># define REALLOC(PV, CB)    realloc((PV), (CB)) <br># define FREE(PV)       free(PV) <br># define HEAPMIN()      _heapmin() <br>#elif defined(_MAC) <br># define MEMCMP(PV1, PV2)   ERROR -- NYI <br># define MEMCPY(PV1, PV2, CB)   ERROR -- NYI <br># define MEMSET(PV,  VAL, CB)   ERROR -- NYI <br># define MALLOC(CB)     ERROR -- NYI <br># define REALLOC(PV, CB)    ERROR -- NYI <br># define FREE(PV)       ERROR -- NYI <br># define HEAPMIN()      ERROR -- NYI <br>#else <br># define MEMCMP(PV1, PV2, CB)   _fmemcmp((PV1), (PV2), (CB)) <br># define MEMCPY(PV1, PV2, CB)   _fmemcpy((PV1), (PV2), (CB)) <br># define MEMSET(PV,  VAL, CB)   _fmemset((PV),  (VAL), (CB)) <br># define MALLOC(CB)     _fmalloc(CB) <br># define REALLOC(PV, CB)    _frealloc(PV, CB) <br># define FREE(PV)       _ffree(PV) <br># define HEAPMIN()      _fheapmin() <br>#endif <br> <br>/************************************************************************* <br>** DEBUG ASSERTION ROUTINES <br>*************************************************************************/ <br> <br>#if DBG <br>#include &lt;assert.h&gt; <br>#define FnAssert(lpstrExpr, lpstrMsg, lpstrFileName, iLine)     \ <br>        (_assert(lpstrMsg ? lpstrMsg : lpstrExpr,               \ <br>                 lpstrFileName,                                 \ <br>                 iLine), NOERROR) <br>#endif //DBG <br> <br>#if defined( __TURBOC__ ) <br>#define classmodel _huge <br>#else <br>#define classmodel FAR <br>#endif <br> <br>class classmodel CStdDbOutput : public IDbOutput { <br>public: <br>   static IDbOutput FAR* Create(); <br> <br>   // IUnknown methods <br> <br>   STDMETHOD(QueryInterface)(REFIID riid, void FAR* FAR* ppv); <br>   STDMETHOD_(ULONG, AddRef)(void); <br>   STDMETHOD_(ULONG, Release)(void); <br> <br> <br>   // IDbOutput methods <br> <br>   virtual void _cdecl  Printf (char FAR* szFmt, ...); <br> <br>   STDMETHOD_(void, Assertion)( <br>     BOOL cond, <br>     char FAR* szExpr, <br>     char FAR* szFile, <br>     UINT uLine, <br>     char FAR* szMsg); <br> <br> <br>   void FAR* operator new(size_t cb){ <br>     return MALLOC(cb); <br>   } <br>   void operator delete(void FAR* pv){ <br>     FREE(pv); <br>   } <br> <br>   CStdDbOutput(){ <br>     g_dwObjectCount++ ; <br>     m_refs = 0; <br>   } <br> <br>   ~CStdDbOutput() { g_dwObjectCount-- ; } <br> <br> <br>private: <br>   ULONG m_refs; <br> <br>   char m_rgch[128]; // buffer for output formatting <br>}; <br> <br> <br>//--------------------------------------------------------------------- <br>//                implementation of the debug allocator <br>//--------------------------------------------------------------------- <br> <br>class FAR CAddrNode <br>{ <br>public: <br>   void FAR*      m_pv;    // instance <br>   ULONG      m_cb;    // size of allocation in BYTES <br>   ULONG          m_nAlloc;    // the allocation pass count <br>   CAddrNode FAR* m_next; <br> <br>   void FAR* operator new(size_t cb){ <br>     return MALLOC(cb); <br>   } <br>   void operator delete(void FAR* pv){ <br>     FREE(pv); <br>   } <br>}; <br> <br> <br>class classmodel CDbAlloc : public IMalloc <br>{ <br>public: <br>   static HRESULT Create( <br>     ULONG options, IDbOutput FAR* pdbout, IMalloc FAR* FAR* ppmalloc); <br> <br>   // IUnknown methods <br> <br>   STDMETHOD(QueryInterface)(REFIID riid, void FAR* FAR* ppv); <br>   STDMETHOD_(ULONG, AddRef)(void); <br>   STDMETHOD_(ULONG, Release)(void); <br> <br>   // IMalloc methods <br> <br>   STDMETHOD_(void FAR*, Alloc)(ULONG cb); <br>   STDMETHOD_(void FAR*, Realloc)(void FAR* pv, ULONG cb); <br>   STDMETHOD_(void, Free)(void FAR* pv); <br>   STDMETHOD_(ULONG, GetSize)(void FAR* pv); <br>   STDMETHOD_(int, DidAlloc)(void FAR* pv); <br>   STDMETHOD_(void, HeapMinimize)(void); <br> <br> <br>   void FAR* operator new(size_t cb){ <br>     return MALLOC(cb); <br>   } <br>   void operator delete(void FAR* pv){ <br>     FREE(pv); <br>   } <br> <br>   CDbAlloc(){ <br>     m_refs = 1; <br>     m_pdbout = NULL; <br>     m_cAllocCalls = 0; <br>     m_nBreakAtNthAlloc = 0; <br>     m_nBreakAtAllocSize = 0; <br>     MEMSET(m_rganode, 0, sizeof(m_rganode)); <br> <br>     g_dwObjectCount++ ; <br> <br>   } <br> <br>   ~CDbAlloc() {   g_dwObjectCount-- ; } <br> <br> <br>private: <br> <br>   ULONG m_refs; <br>   ULONG m_cAllocCalls;        // total count of allocation calls <br>   ULONG m_nBreakAtNthAlloc;   // allocation number to break to debugger <br>                        //  this value should be set typically in the <br>                        //  debugger. <br>   ULONG m_nBreakAtAllocSize;  // allocation size to break to debugger <br>                        //  this value should be set typically in the <br>                        //  debugger. <br>   IDbOutput FAR* m_pdbout;        // output interface <br>   CAddrNode FAR* m_rganode[64];   // address instance table <br> <br> <br>   // instance table methods <br> <br>   BOOL IsEmpty(void); <br> <br>   void AddInst(void FAR* pv, ULONG nAlloc, ULONG cb); <br>   void DelInst(void FAR* pv); <br>   CAddrNode FAR* GetInst(void FAR* pv); <br> <br>   void DumpInst(CAddrNode FAR* pn); <br>   void DumpInstTable(void); <br> <br>   inline UINT HashInst(void FAR* pv) const { <br>     return ((UINT)((ULONG)pv &gt;&gt; 4)) % DIM(m_rganode); <br>   } <br> <br> <br>   // output method(s) <br> <br>   inline void Assertion( <br>     BOOL cond, <br>     char FAR* szExpr, <br>     char FAR* szFile, <br>     UINT uLine, <br>     char FAR* szMsg) <br>   { <br>     m_pdbout-&gt;Assertion(cond, szExpr, szFile, uLine, szMsg); <br>   } <br> <br>   #define ASSERT(X) Assertion(X, #X, __FILE__, __LINE__, NULL) <br> <br>   #define ASSERTSZ(X, SZ) Assertion(X, #X, __FILE__, __LINE__, SZ) <br> <br>   static const unsigned char m_rgchSig[4]; <br>}; <br> <br> <br>const unsigned char CDbAlloc::m_rgchSig[] = { 0xDE, 0xAD, 0xBE, 0xEF }; <br> <br> <br>/*** <br>*HRESULT OleStdCreateDbAlloc(ULONG reserved, IMalloc** ppmalloc) <br>* Purpose: <br>*  Create an instance of CDbAlloc -- a debug implementation <br>*  of IMalloc. <br>* <br>* Parameters: <br>*   ULONG reserved              - reserved for future use. must be 0. <br>*   IMalloc FAR* FAR* ppmalloc  - (OUT) pointer to an IMalloc interface <br>*                                   of new debug allocator object <br>* Returns: <br>*   HRESULT <br>*       NOERROR         - if no error. <br>*       E_OUTOFMEMORY   - allocation failed. <br>* <br>***********************************************************************/ <br>STDAPI OleStdCreateDbAlloc(ULONG reserved,IMalloc FAR* FAR* ppmalloc) <br>{ <br>   return CDbAlloc::Create(reserved, NULL, ppmalloc); <br>} <br> <br> <br>HRESULT <br>CDbAlloc::Create( <br>   ULONG options, <br>   IDbOutput FAR* pdbout, <br>   IMalloc FAR* FAR* ppmalloc) <br>{ <br>   HRESULT hresult; <br>   CDbAlloc FAR* pmalloc; <br> <br> <br>   // default the instance of IDbOutput if the user didn't supply one <br>   if(pdbout == NULL &amp;&amp; ((pdbout = CStdDbOutput::Create()) == NULL)){ <br>     hresult = E_OUTOFMEMORY; <br>     goto LError0; <br>   } <br> <br>   pdbout-&gt;AddRef(); <br> <br>   if((pmalloc = new FAR CDbAlloc()) == NULL){ <br>     hresult = E_OUTOFMEMORY; <br>     goto LError1; <br>   } <br> <br>   pmalloc-&gt;m_pdbout = pdbout; <br> <br>   *ppmalloc = pmalloc; <br> <br>   return NOERROR; <br> <br>LError1:; <br>   pdbout-&gt;Release(); <br>   pmalloc-&gt;Release(); <br> <br>LError0:; <br>   return hresult; <br>} <br> <br>STDMETHODIMP <br>CDbAlloc::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>   if(riid == IID_IUnknown || riid == IID_IMalloc){ <br>     *ppv = this; <br>     AddRef(); <br>     return NOERROR; <br>   } <br>   return E_NOINTERFACE; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CDbAlloc::AddRef() <br>{ <br>   return ++m_refs; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CDbAlloc::Release() <br>{ <br>   if(--m_refs == 0){ <br> <br>     // check for memory leakage <br>     if(IsEmpty()){ <br>        m_pdbout-&gt;Printf("No Memory Leaks.\n"); <br>     }else{ <br>        m_pdbout-&gt;Printf("Memory Leak Detected,\n"); <br>        DumpInstTable(); <br>     } <br> <br>     m_pdbout-&gt;Release(); <br>     delete this; <br>     return 0; <br>   } <br>   return m_refs; <br>} <br> <br>STDMETHODIMP_(void FAR*) <br>CDbAlloc::Alloc(ULONG cb) <br>{ <br>   size_t size; <br>   void FAR* pv; <br> <br>   ++m_cAllocCalls; <br> <br>   if (m_nBreakAtNthAlloc &amp;&amp; m_cAllocCalls == m_nBreakAtNthAlloc) { <br>      ASSERTSZ(FALSE, "DBALLOC: NthAlloc Break target reached\r\n"); <br>   } else if (m_nBreakAtAllocSize &amp;&amp; cb == m_nBreakAtAllocSize) { <br>      ASSERTSZ(FALSE, "DBALLOC: AllocSize Break target reached\r\n"); <br>   } <br> <br>   // REVIEW: need to add support for huge allocations (on win16) <br>   if((cb + sizeof(m_rgchSig)) &gt; UINT_MAX) <br>     return NULL; <br> <br>   size = (size_t)cb; <br> <br>   if((pv = MALLOC(size + sizeof(m_rgchSig))) == NULL) <br>     return NULL; <br> <br>   // set allocated block to some non-zero value <br>   MEMSET(pv, -1, size); <br> <br>   // put signature at end of allocated block <br>   MEMCPY((char FAR*)pv + size, m_rgchSig, sizeof(m_rgchSig)); <br> <br>   AddInst(pv, m_cAllocCalls, size); <br> <br>   return pv; <br>} <br> <br>STDMETHODIMP_(void FAR*) <br>CDbAlloc::Realloc(void FAR* pv, ULONG cb) <br>{ <br>   size_t size; <br> <br>   // REVIEW: need to add support for huge realloc <br>   if((cb + sizeof(m_rgchSig)) &gt; UINT_MAX) <br>     return NULL; <br> <br>   if(pv == NULL){ <br>     return Alloc(cb); <br>   } <br> <br>   ++m_cAllocCalls; <br> <br>   ASSERT(GetInst(pv) != NULL); <br> <br>   DelInst(pv); <br> <br>   if(cb == 0){ <br>     Free(pv); <br>     return NULL; <br>   } <br> <br>   size = (size_t)cb; <br> <br>   if((pv = REALLOC(pv, size + sizeof(m_rgchSig))) == NULL) <br>     return NULL; <br> <br>   // put signature at end of allocated block <br>   MEMCPY((char FAR*)pv + size, m_rgchSig, sizeof(m_rgchSig)); <br> <br>   AddInst(pv, m_cAllocCalls, size); <br> <br>   return pv; <br>} <br> <br>STDMETHODIMP_(void) <br>CDbAlloc::Free(void FAR* pv) <br>{ <br>   CAddrNode FAR* pn; <br>static char szSigMsg[] = "Signature Check Failed"; <br> <br>   if (pv == NULL) return; <br> <br>   pn = GetInst(pv); <br> <br>   // check for attempt to free an instance we didnt allocate <br>   if(pn == NULL){ <br>     ASSERTSZ(FALSE, "pointer freed by wrong allocator"); <br>     return; <br>   } <br> <br>   // verify the signature <br>   if(MEMCMP((char FAR*)pv + pn-&gt;m_cb, m_rgchSig, sizeof(m_rgchSig)) != 0){ <br>     m_pdbout-&gt;Printf(szSigMsg); m_pdbout-&gt;Printf("\n"); <br>     DumpInst(GetInst(pv)); <br>     ASSERTSZ(FALSE, szSigMsg); <br>   } <br> <br>   // stomp on the contents of the block <br>   MEMSET(pv, 0xCC, (size_t)pn-&gt;m_cb + sizeof(m_rgchSig)); <br> <br>   DelInst(pv); <br> <br>   FREE(pv); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CDbAlloc::GetSize(void FAR* pv) <br>{ <br>   CAddrNode FAR* pn; <br> <br>   pn = GetInst(pv); <br> <br>   if (pn == NULL) { <br>      return (ULONG)-1; <br>   } <br> <br>   return pn-&gt;m_cb; <br>} <br> <br> <br>/*** <br>*PUBLIC HRESULT CDbAlloc::DidAlloc <br>*Purpose: <br>*  Answer if the given address belongs to a block allocated by <br>*  this allocator. <br>* <br>*Entry: <br>*  pv = the instance to lookup <br>* <br>*Exit: <br>*  return value = int <br>*    1 - did alloc <br>*    0 - did *not* alloc <br>*   -1 - dont know (according to the ole2 spec it is always legal <br>*        for the allocator to answer "dont know") <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(int) <br>CDbAlloc::DidAlloc(void FAR* pv) <br>{ <br>   return -1; // answer "I dont know" <br>} <br> <br> <br>STDMETHODIMP_(void) <br>CDbAlloc::HeapMinimize() <br>{ <br>#ifdef WIN32 <br>   ASSERTSZ (FALSE,"In HeapMinimize () - heapmin not defined in 32bit version."); <br>#else <br>   HEAPMIN(); <br>#endif <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                      instance table methods <br>//--------------------------------------------------------------------- <br> <br>/*** <br>*PRIVATE CDbAlloc::AddInst <br>*Purpose: <br>*  Add the given instance to the address instance table. <br>* <br>*Entry: <br>*  pv = the instance to add <br>*  nAlloc = the allocation passcount of this instance <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CDbAlloc::AddInst(void FAR* pv, ULONG nAlloc, ULONG cb) <br>{ <br>   UINT hash; <br>   CAddrNode FAR* pn; <br> <br> <br>   ASSERT(pv != NULL); <br> <br>   pn = (CAddrNode FAR*)new FAR CAddrNode(); <br> <br>   if (pn == NULL) { <br>      ASSERT(pn != NULL); <br>      return; <br>   } <br> <br>   pn-&gt;m_pv = pv; <br>   pn-&gt;m_cb = cb; <br>   pn-&gt;m_nAlloc = nAlloc; <br> <br>   hash = HashInst(pv); <br>   pn-&gt;m_next = m_rganode[hash]; <br>   m_rganode[hash] = pn; <br>} <br> <br> <br>/*** <br>*UNDONE <br>*Purpose: <br>*  Remove the given instance from the address instance table. <br>* <br>*Entry: <br>*  pv = the instance to remove <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CDbAlloc::DelInst(void FAR* pv) <br>{ <br>   CAddrNode FAR* FAR* ppn, FAR* pnDead; <br> <br>   for(ppn = &amp;m_rganode[HashInst(pv)]; *ppn != NULL; ppn = &amp;(*ppn)-&gt;m_next){ <br>     if((*ppn)-&gt;m_pv == pv){ <br>   pnDead = *ppn; <br>   *ppn = (*ppn)-&gt;m_next; <br>   delete pnDead; <br>   // make sure it doesnt somehow appear twice <br>   ASSERT(GetInst(pv) == NULL); <br>   return; <br>     } <br>   } <br> <br>   // didnt find the instance <br>   ASSERT(UNREACHED); <br>} <br> <br> <br>CAddrNode FAR* <br>CDbAlloc::GetInst(void FAR* pv) <br>{ <br>   CAddrNode FAR* pn; <br> <br>   for(pn = m_rganode[HashInst(pv)]; pn != NULL; pn = pn-&gt;m_next){ <br>     if(pn-&gt;m_pv == pv) <br>      return pn; <br>   } <br>   return NULL; <br>} <br> <br> <br>void <br>CDbAlloc::DumpInst(CAddrNode FAR* pn) <br>{ <br>   if (pn == NULL) <br>      return; <br> <br>   m_pdbout-&gt;Printf("[0x%lx]  nAlloc=%ld  size=%ld\n", <br>     pn-&gt;m_pv, pn-&gt;m_nAlloc, GetSize(pn-&gt;m_pv)); <br>} <br> <br> <br>/*** <br>*PRIVATE BOOL IsEmpty <br>*Purpose: <br>*  Answer if the address instance table is empty. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = BOOL, TRUE if empty, FALSE otherwise <br>* <br>***********************************************************************/ <br>BOOL <br>CDbAlloc::IsEmpty() <br>{ <br>   UINT u; <br> <br>   for(u = 0; u &lt; DIM(m_rganode); ++u){ <br>     if(m_rganode[u] != NULL) <br>   return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/*** <br>*PRIVATE CDbAlloc::Dump <br>*Purpose: <br>*  Print the current contents of the address instance table, <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CDbAlloc::DumpInstTable() <br>{ <br>   UINT u; <br>   CAddrNode FAR* pn; <br> <br>   for(u = 0; u &lt; DIM(m_rganode); ++u){ <br>     for(pn = m_rganode[u]; pn != NULL; pn = pn-&gt;m_next){ <br>        DumpInst(pn); <br>     } <br>   } <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                implementation of CStdDbOutput <br>//--------------------------------------------------------------------- <br> <br>IDbOutput FAR* <br>CStdDbOutput::Create() <br>{ <br>   return (IDbOutput FAR*)new FAR CStdDbOutput(); <br>} <br> <br>STDMETHODIMP <br>CStdDbOutput::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>   if(riid == IID_IUnknown){ <br>     *ppv = this; <br>     AddRef(); <br>     return NOERROR; <br>   } <br>   return E_NOINTERFACE; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CStdDbOutput::AddRef() <br>{ <br>   return ++m_refs; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CStdDbOutput::Release() <br>{ <br>   if(--m_refs == 0){ <br>     delete this; <br>     return 0; <br>   } <br>   return m_refs; <br>} <br> <br>void _cdecl <br>CStdDbOutput::Printf(char FAR* lpszFmt, ...) <br>{ <br>   va_list args; <br>   char szBuf[256]; <br>#if defined( OBSOLETE ) <br>   char *pn, FAR* pf; <br>static char rgchFmtBuf[128]; <br>static char rgchOutputBuf[128]; <br> <br>   // copy the 'far' format string to a near buffer so we can use <br>   // a medium model vsprintf, which only supports near data pointers. <br>   // <br>   pn = rgchFmtBuf, pf=szFmt; <br>   while(*pf != '\0') <br>     *pn++ = *pf++; <br>   *pn = '\0'; <br>#endif <br> <br>   va_start(args, lpszFmt); <br> <br>//    wvsprintf(rgchOutputBuf, rgchFmtBuf, args); <br>   wvsprintf(szBuf, lpszFmt, args); <br> <br>   OutputDebugString(szBuf); <br>} <br> <br>STDMETHODIMP_(void) <br>CStdDbOutput::Assertion( <br>   BOOL cond, <br>   char FAR* szExpr, <br>   char FAR* szFile, <br>   UINT uLine, <br>   char FAR* szMsg) <br>{ <br>   if(cond) <br>     return; <br> <br>#ifdef _DEBUG <br>   // following is from compobj.dll (ole2) <br>   FnAssert(szExpr, szMsg, szFile, uLine); <br>#else <br>   // REVIEW: should be able to do something better that this... <br>   DebugBreak(); <br>#endif <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
