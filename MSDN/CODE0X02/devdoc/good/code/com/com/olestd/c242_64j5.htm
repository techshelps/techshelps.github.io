<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GETICON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context251"></a>GETICON.C</h2>
<pre><code>/************************************************************************* <br>** <br>** The following API's are now OBSOLETE because equivalent API's have been <br>** added to the OLE2.DLL library <br>**      GetIconOfFile       superceeded by OleGetIconOfFile <br>**      GetIconOfClass      superceeded by OleGetIconOfClass <br>**      OleUIMetafilePictFromIconAndLabel <br>**                          superceeded by OleMetafilePictFromIconAndLabel <br>*************************************************************************/ <br> <br>/* <br> *  GETICON.C <br> * <br> *  Functions to create DVASPECT_ICON metafile from filename or classname. <br> * <br> *  GetIconOfFile <br> *  GetIconOfClass <br> *  OleUIMetafilePictFromIconAndLabel <br> *  HIconAndSourceFromClass Extracts the first icon in a class's server path <br> *                          and returns the path and icon index to caller. <br> *  FIconFileFromClass      Retrieves the path to the exe/dll containing the <br> *                           default icon, and the index of the icon. <br> *  OleStdIconLabelTextOut  Draw icon label text (line break if necessary) <br> * <br> *    (c) Copyright Microsoft Corp. 1992-1996 All Rights Reserved <br> */ <br> <br> <br>/******* <br> * <br> * ICON (DVASPECT_ICON) METAFILE FORMAT: <br> * <br> * The metafile generated with OleUIMetafilePictFromIconAndLabel contains <br> * the following records which are used by the functions in DRAWICON.C <br> * to draw the icon with and without the label and to extract the icon, <br> * label, and icon source/index. <br> * <br> *  SetWindowOrg <br> *  SetWindowExt <br> *  DrawIcon: <br> *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the <br> *      AND mask, one for the image bits. <br> *  Escape with the comment "IconOnly" <br> *      This indicates where to stop record enumeration to draw only <br> *      the icon. <br> *  SetTextColor <br> *  SetTextAlign <br> *  SetBkColor <br> *  CreateFont <br> *  SelectObject on the font. <br> *  ExtTextOut <br> *      One or more ExtTextOuts occur if the label is wrapped.  The <br> *      text in these records is used to extract the label. <br> *  SelectObject on the old font. <br> *  DeleteObject on the font. <br> *  Escape with a comment that contains the path to the icon source. <br> *  Escape with a comment that is the ASCII of the icon index. <br> * <br> *******/ <br> <br>#define STRICT  1 <br>#include "olestd.h" <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;memory.h&gt; <br>#include &lt;cderr.h&gt; <br>#include "common.h" <br>#include "utility.h" <br> <br>static char szSeparators[] = " \t\\/!:"; <br> <br>#define IS_SEPARATOR(c)         ( (c) == ' ' || (c) == '\\' || (c) == '/' || (c) == '\t' || (c) == '!' || (c) == ':' ) <br>#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' ) <br> <br> <br>#if defined( OBSOLETE ) <br>static HINSTANCE  s_hInst; <br> <br>static char szMaxWidth[] ="WWWWWWWWWW"; <br> <br>//Strings for metafile comments. <br>static OLECHAR szIconOnly[]= OLESTR("IconOnly");        //Where to stop to exclude label. <br> <br> <br>static char szOLE2DLL[] = "ole2.dll";   // name of OLE 2.0 library <br> <br>#define ICONINDEX              0 <br> <br>#define AUXUSERTYPE_SHORTNAME  USERCLASSTYPE_SHORT  // short name <br>#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch <br>#define PTS_PER_INCH          72      // number points (font size) per inch <br> <br>#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli)) <br>#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH) <br> <br>static char szVanillaDocIcon[] = "DefIcon"; <br> <br>static char szDocument[40] = ""; <br> <br> <br>/* <br> * GetIconOfFile(HINSTANCE hInst, LPSTR lpszPath, BOOL fUseFileAsLabel) <br> * <br> * Purpose: <br> *  Returns a hMetaPict containing an icon and label (filename) for the <br> *  specified filename. <br> * <br> * Parameters: <br> *  hinst <br> *  lpszPath        LPSTR path including filename to use <br> *  fUseFileAsLabel BOOL TRUE if the icon's label is the filename, FALSE if <br> *                  there should be no label. <br> * <br> * Return Value: <br> *  HGLOBAL         hMetaPict containing the icon and label - if there's no <br> *                  class in reg db for the file in lpszPath, then we use <br> *                  Document.  If lpszPath is NULL, then we return NULL. <br> */ <br> <br>STDAPI_(HGLOBAL) GetIconOfFile(HINSTANCE hInst, LPSTR lpszPath, BOOL fUseFileAsLabel) <br>{ <br>  char     szIconFile[OLEUI_CCHPATHMAX]; <br>  char     szLabel[OLEUI_CCHLABELMAX]; <br>  LPSTR    lpszClsid = NULL; <br>  CLSID    clsid; <br>  HICON    hDefIcon = NULL; <br>  UINT     IconIndex = 0; <br>  HGLOBAL  hMetaPict; <br>  HRESULT  hResult; <br> <br>  if (NULL == lpszPath)  // even if fUseFileAsLabel is FALSE, we still <br>   return NULL;             // need a valid filename to get the class. <br> <br>  s_hInst = hInst; <br> <br>  hResult = GetClassFile(lpszPath, &amp;clsid); <br> <br>  if (NOERROR == hResult)  // use the clsid we got to get to the icon <br>  { <br>     hDefIcon = HIconAndSourceFromClass(&amp;clsid, <br>                               szIconFile, <br>                               &amp;IconIndex); <br>  } <br> <br>  if ( (NOERROR != hResult) || (NULL == hDefIcon) ) <br>  { <br>    // Here, either GetClassFile failed or HIconAndSourceFromClass failed. <br> <br>    LPSTR lpszTemp; <br> <br>    lpszTemp = lpszPath; <br> <br>    while ((*lpszTemp != '.') &amp;&amp; (*lpszTemp != '\0')) <br>      lpszTemp++; <br> <br> <br>    if ('.' != *lpszTemp) <br>      goto UseVanillaDocument; <br> <br> <br>    if (FALSE == GetAssociatedExecutable(lpszTemp, szIconFile)) <br>      goto UseVanillaDocument; <br> <br>    hDefIcon = ExtractIcon(s_hInst, szIconFile, IconIndex); <br>  } <br> <br>  if (hDefIcon &lt;= (HICON)1) // ExtractIcon returns 1 if szExecutable is not exe, <br>  {                         // 0 if there are no icons. <br>UseVanillaDocument: <br> <br>   OLESTRCPY(szIconFile, szOLE2DLL); <br>   IconIndex = ICONINDEX; <br>   hDefIcon = ExtractIcon(s_hInst, szIconFile, IconIndex); <br> <br>  } <br> <br>  // Now let's get the label we want to use. <br> <br>  if (fUseFileAsLabel)   // strip off path, so we just have the filename. <br>  { <br>    int istrlen; <br>    LPSTR lpszBeginFile; <br> <br>    istrlen = lstrlen(lpszPath); <br> <br>    // set pointer to END of path, so we can walk backwards through it. <br>    lpszBeginFile = lpszPath + istrlen -1; <br> <br>    while ( (lpszBeginFile &gt;= lpszPath) <br>          &amp;&amp; (!IS_FILENAME_DELIM(*lpszBeginFile)) ) <br>     lpszBeginFile--; <br> <br> <br>    lpszBeginFile++;  // step back over the delimiter <br> <br> <br>    LSTRCPYN(szLabel, lpszBeginFile, OLEUI_CCHLABELMAX); <br>  } <br> <br>  else   // use the short user type (AuxUserType2) for the label <br>  { <br> <br>     if (0 == OleStdGetAuxUserType(&amp;clsid, AUXUSERTYPE_SHORTNAME, <br>                           szLabel, OLEUI_CCHLABELMAX, NULL)) { <br> <br>       if ('\0'==szDocument[0]) { <br>          LoadString( <br>             s_hInst,IDS_DEFICONLABEL,szDocument,sizeof(szDocument)); <br>       } <br>       lstrcpy(szLabel, szDocument); <br>     } <br>  } <br> <br> <br>  hMetaPict = OleUIMetafilePictFromIconAndLabel(hDefIcon, <br>                                    szLabel, <br>                                    szIconFile, <br>                                    IconIndex); <br> <br>  DestroyIcon(hDefIcon); <br> <br>  return hMetaPict; <br> <br>} <br> <br> <br>/* <br> * GetIconOfClass(HINSTANCE hInst, REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel) <br> * <br> * Purpose: <br> *  Returns a hMetaPict containing an icon and label (human-readable form <br> *  of class) for the specified clsid. <br> * <br> * Parameters: <br> *  hinst <br> *  rclsid          REFCLSID pointing to clsid to use. <br> *  lpszLabel       label to use for icon. <br> *  fUseTypeAsLabel Use the clsid's user type name as the icon's label. <br> * <br> * Return Value: <br> *  HGLOBAL         hMetaPict containing the icon and label - if we <br> *                  don't find the clsid in the reg db then we <br> *                  return NULL. <br> */ <br> <br>STDAPI_(HGLOBAL)    GetIconOfClass(HINSTANCE hInst, REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel) <br>{ <br> <br>  char    szLabel[OLEUI_CCHLABELMAX]; <br>  char    szIconFile[OLEUI_CCHPATHMAX]; <br>  HICON   hDefIcon; <br>  UINT    IconIndex; <br>  HGLOBAL hMetaPict; <br> <br>  s_hInst = hInst; <br> <br>  if (!fUseTypeAsLabel)  // Use string passed in as label <br>  { <br>   if (NULL != lpszLabel) <br>      LSTRCPYN(szLabel, lpszLabel, sizeof(szLabel)); <br>   else <br>      *szLabel = '\0'; <br>  } <br>  else   // Use AuxUserType2 (short name) as label <br>  { <br> <br>     if (0 == OleStdGetAuxUserType(rclsid, <br>                           AUXUSERTYPE_SHORTNAME, <br>                           szLabel, <br>                           OLEUI_CCHLABELMAX, <br>                           NULL)) <br> <br>      // If we can't get the AuxUserType2, then try the long name <br>      if (0 == OleStdGetUserTypeOfClass(rclsid, szLabel, OLEUI_CCHKEYMAX, NULL)) { <br>       if ('\0'==szDocument[0]) { <br>          LoadString( <br>             s_hInst,IDS_DEFICONLABEL,szDocument,sizeof(szDocument)); <br>       } <br>       lstrcpy(szLabel, szDocument);  // last resort <br>      } <br>  } <br> <br>  // Get the icon, icon index, and path to icon file <br>  hDefIcon = HIconAndSourceFromClass(rclsid, <br>              szIconFile, <br>              &amp;IconIndex); <br> <br>  if (NULL == hDefIcon)  // Use Vanilla Document <br>  { <br>   OLESTRCPY(szIconFile, szOLE2DLL); <br>   IconIndex = ICONINDEX; <br>   hDefIcon = ExtractIcon(s_hInst, szIconFile, IconIndex); <br>  } <br> <br>  // Create the metafile <br>  hMetaPict = OleUIMetafilePictFromIconAndLabel(hDefIcon, szLabel, <br>                                    szIconFile, IconIndex); <br> <br>  DestroyIcon(hDefIcon); <br> <br>  return hMetaPict; <br> <br>} <br> <br> <br>/* <br> * OleUIMetafilePictFromIconAndLabel <br> * <br> * Purpose: <br> *  Creates a METAFILEPICT structure that container a metafile in which <br> *  the icon and label are drawn.  A comment record is inserted between <br> *  the icon and the label code so our special draw function can stop <br> *  playing before the label. <br> * <br> * Parameters: <br> *  hIcon           HICON to draw into the metafile <br> *  pszLabel        LPSTR to the label string. <br> *  pszSourceFile   LPSTR containing the local pathname of the icon <br> *                  as we either get from the user or from the reg DB. <br> *  iIcon           UINT providing the index into pszSourceFile where <br> *                  the icon came from. <br> * <br> * Return Value: <br> *  HGLOBAL         Global memory handle containing a METAFILEPICT where <br> *                  the metafile uses the MM_ANISOTROPIC mapping mode.  The <br> *                  extents reflect both icon and label. <br> */ <br> <br>STDAPI_(HGLOBAL) OleUIMetafilePictFromIconAndLabel(HICON hIcon, LPSTR pszLabel <br>   , LPSTR pszSourceFile, UINT iIcon) <br>   { <br>   HDC             hDC, hDCScreen; <br>   HMETAFILE       hMF; <br>   HGLOBAL         hMem; <br>   LPMETAFILEPICT  pMF; <br>   UINT            cxIcon, cyIcon; <br>   UINT            cxText, cyText; <br>   UINT            cx, cy; <br>   UINT            cchLabel = 0; <br>   HFONT           hFont, hFontT; <br>   int             cyFont; <br>   char            szIndex[10]; <br>   RECT            TextRect; <br>   SIZE            size; <br>   POINT           point; <br>   UINT            fuAlign; <br> <br>   if (NULL==hIcon)  // null label is valid but NOT a null icon <br>      return NULL; <br> <br>   //Create a memory metafile <br>   hDC=(HDC)CreateMetaFile(NULL); <br> <br>   if (NULL==hDC) <br>      return NULL; <br> <br>   //Allocate the metafilepict <br>   hMem=GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(METAFILEPICT)); <br> <br>   if (NULL==hMem) <br>      { <br>      hMF=CloseMetaFile(hDC); <br>      DeleteMetaFile(hMF); <br>      return NULL; <br>      } <br> <br> <br>   if (NULL!=pszLabel) <br>      { <br>      cchLabel=lstrlen(pszLabel); <br> <br>      if (cchLabel &gt;= OLEUI_CCHLABELMAX) <br>         pszLabel[cchLabel] = '\0';   // truncate string <br>      } <br> <br>   //Need to use the screen DC for these operations <br>   hDCScreen=GetDC(NULL); <br>   cyFont=-(8*GetDeviceCaps(hDCScreen, LOGPIXELSY))/72; <br> <br>   //cyFont was calculated to give us 8 point. <br>   hFont=CreateFont(cyFont, 5, 0, 0, FW_NORMAL, 0, 0, 0, ANSI_CHARSET <br>      , OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY <br>      , FF_SWISS, "MS Sans Serif"); <br> <br>   hFontT=SelectObject(hDCScreen, hFont); <br> <br>   GetTextExtentPoint(hDCScreen,szMaxWidth,lstrlen(szMaxWidth),&amp;size); <br>   SelectObject(hDCScreen, hFontT); <br> <br>   cxText = size.cx; <br>   cyText = size.cy * 2; <br> <br>   cxIcon = GetSystemMetrics(SM_CXICON); <br>   cyIcon = GetSystemMetrics(SM_CYICON); <br> <br> <br>   // If we have no label, then we want the metafile to be the width of <br>   // the icon (plus margin), not the width of the fattest string. <br>   if ( (NULL == pszLabel) || ('\0' == *pszLabel) ) <br>      cx = cxIcon + cxIcon / 4; <br>   else <br>      cx = max(cxText, cxIcon); <br> <br>   cy=cyIcon+cyText+4; <br> <br>   //Set the metafile size to fit the icon and label <br>   SetWindowOrgEx(hDC, 0, 0, &amp;point); <br>   SetWindowExtEx(hDC, cx, cy, &amp;size); <br> <br>   //Set up rectangle to pass to OleStdIconLabelTextOut <br>   SetRectEmpty(&amp;TextRect); <br> <br>   TextRect.right = cx; <br>   TextRect.bottom = cy; <br> <br>   //Draw the icon and the text, centered with respect to each other. <br>   DrawIcon(hDC, (cx-cxIcon)/2, 0, hIcon); <br> <br>   //String that indicates where to stop if we're only doing icons <br>   Escape(hDC, MFCOMMENT, lstrlen(szIconOnly)+1, szIconOnly, NULL); <br> <br>   SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>   SetBkMode(hDC, TRANSPARENT); <br>   fuAlign = SetTextAlign(hDC, TA_LEFT | TA_TOP | TA_NOUPDATECP); <br> <br>   OleStdIconLabelTextOut(hDC, <br>                     hFont, <br>                     0, <br>                     cy - cyText, <br>                     ETO_CLIPPED, <br>                     &amp;TextRect, <br>                     pszLabel, <br>                     cchLabel, <br>                     NULL); <br> <br>   //Write comments containing the icon source file and index. <br>   if (NULL!=pszSourceFile) <br>      { <br>      //+1 on string lengths insures the null terminator is embedded. <br>      Escape(hDC, MFCOMMENT, lstrlen(pszSourceFile)+1, pszSourceFile, NULL); <br> <br>      cchLabel=wsprintf(szIndex, "%u", iIcon); <br>      Escape(hDC, MFCOMMENT, cchLabel+1, szIndex, NULL); <br>      } <br> <br>   SetTextAlign(hDC, fuAlign); <br> <br>   //All done with the metafile, now stuff it all into a METAFILEPICT. <br>   hMF=CloseMetaFile(hDC); <br> <br>   if (NULL==hMF) <br>      { <br>      GlobalFree(hMem); <br>      ReleaseDC(NULL, hDCScreen); <br>      return NULL; <br>      } <br> <br>   //Fill out the structure <br>   pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>   //Transform to HIMETRICS <br>   cx=XformWidthInPixelsToHimetric(hDCScreen, cx); <br>   cy=XformHeightInPixelsToHimetric(hDCScreen, cy); <br>   ReleaseDC(NULL, hDCScreen); <br> <br>   pMF-&gt;mm=MM_ANISOTROPIC; <br>   pMF-&gt;xExt=cx; <br>   pMF-&gt;yExt=cy; <br>   pMF-&gt;hMF=hMF; <br> <br>   GlobalUnlock(hMem); <br> <br>   DeleteObject(hFont); <br> <br>   return hMem; <br>   } <br> <br>#endif  // OBSOLETE <br> <br> <br>/* <br> * GetAssociatedExecutable <br> * <br> * Purpose:  Finds the executable associated with the provided extension <br> * <br> * Parameters: <br> *   lpszExtension   LPSTR points to the extension we're trying to find <br> *                   an exe for. Does **NO** validation. <br> * <br> *   lpszExecutable  LPSTR points to where the exe name will be returned. <br> *                   No validation here either - pass in 128 char buffer. <br> * <br> * Return: <br> *   BOOL            TRUE if we found an exe, FALSE if we didn't. <br> * <br> */ <br> <br>BOOL FAR PASCAL GetAssociatedExecutable(LPSTR lpszExtension, LPSTR lpszExecutable) <br> <br>{ <br>   HKEY    hKey; <br>   LONG    dw; <br>   LRESULT lRet; <br>   char    szValue[OLEUI_CCHKEYMAX]; <br>   char    szKey[OLEUI_CCHKEYMAX]; <br>   LPSTR   lpszTemp, lpszExe; <br> <br> <br>   lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &amp;hKey); <br> <br>   if (ERROR_SUCCESS != lRet) <br>     return FALSE; <br> <br>   dw = OLEUI_CCHPATHMAX; <br>   lRet = RegQueryValue(hKey, lpszExtension, szValue, &amp;dw);  //ProgId <br> <br>   if (ERROR_SUCCESS != lRet) <br>   { <br>     RegCloseKey(hKey); <br>     return FALSE; <br>   } <br> <br> <br>   // szValue now has ProgID <br>   lstrcpy(szKey, szValue); <br>   lstrcat(szKey, "\\Shell\\Open\\Command"); <br> <br> <br>   dw = OLEUI_CCHPATHMAX; <br>   lRet = RegQueryValue(hKey, szKey, szValue, &amp;dw); <br> <br>   if (ERROR_SUCCESS != lRet) <br>   { <br>     RegCloseKey(hKey); <br>     return FALSE; <br>   } <br> <br>   // szValue now has an executable name in it.  Let's null-terminate <br>   // at the first post-executable space (so we don't have cmd line <br>   // args. <br> <br>   lpszTemp = szValue; <br> <br>   while (('\0' != *lpszTemp) &amp;&amp; (isspace(*lpszTemp))) <br>     lpszTemp++;     // Strip off leading spaces <br> <br>   lpszExe = lpszTemp; <br> <br>   while (('\0' != *lpszTemp) &amp;&amp; (!isspace(*lpszTemp))) <br>     lpszTemp++;     // Step through exe name <br> <br>   *lpszTemp = '\0';  // null terminate at first space (or at end). <br> <br> <br>   lstrcpy(lpszExecutable, lpszExe); <br> <br>   return TRUE; <br> <br>} <br> <br> <br>/* <br> * HIconAndSourceFromClass <br> * <br> * Purpose: <br> *  Given an object class name, finds an associated executable in the <br> *  registration database and extracts the first icon from that <br> *  executable.  If none is available or the class has no associated <br> *  executable, this function returns NULL. <br> * <br> * Parameters: <br> *  rclsid          pointer to clsid to look up. <br> *  pszSource       LPSTR in which to place the source of the icon. <br> *                  This is assumed to be OLEUI_CCHPATHMAX <br> *  puIcon          UINT FAR * in which to store the index of the <br> *                  icon in pszSource. <br> * <br> * Return Value: <br> *  HICON           Handle to the extracted icon if there is a module <br> *                  associated to pszClass.  NULL on failure to either <br> *                  find the executable or extract and icon. <br> */ <br> <br>HICON FAR PASCAL HIconAndSourceFromClass(REFCLSID rclsid, LPSTR pszSource, UINT FAR *puIcon) <br>   { <br>   HICON           hIcon; <br>   UINT            IconIndex; <br> <br>   if (NULL==rclsid || NULL==pszSource || IsEqualCLSID(rclsid,&amp;CLSID_NULL)) <br>      return NULL; <br> <br>   if (!FIconFileFromClass(rclsid, pszSource, OLEUI_CCHPATHMAX, &amp;IconIndex)) <br>      return NULL; <br> <br>   hIcon=ExtractIcon(ghInst, pszSource, IconIndex); <br> <br>   if ((HICON)32 &gt; hIcon) <br>      hIcon=NULL; <br>   else <br>      *puIcon= IconIndex; <br> <br>   return hIcon; <br>   } <br> <br> <br>/* <br> * PointerToNthField <br> * <br> * Purpose: <br> *  Returns a pointer to the beginning of the nth field. <br> *  Assumes null-terminated string. <br> * <br> * Parameters: <br> *  lpszString        string to parse <br> *  nField            field to return starting index of. <br> *  chDelimiter       char that delimits fields <br> * <br> * Return Value: <br> *  LPSTR             pointer to beginning of nField field. <br> *                    NOTsE: If the null terminator is found <br> *                          Before we find the Nth field, then <br> *                          we return a pointer to the null terminator - <br> *                          calling app should be sure to check for <br> *                          this case. <br> * <br> */ <br>LPSTR FAR PASCAL PointerToNthField(LPSTR lpszString, int nField, char chDelimiter) <br>{ <br>   LPSTR lpField = lpszString; <br>   int   cFieldFound = 1; <br> <br>   if (1 ==nField) <br>     return lpszString; <br> <br>   while (*lpField != '\0') <br>   { <br> <br>     if (*lpField++ == chDelimiter) <br>     { <br> <br>       cFieldFound++; <br> <br>       if (nField == cFieldFound) <br>         return lpField; <br>     } <br>   } <br> <br>   return lpField; <br> <br>} <br> <br> <br>/* <br> * FIconFileFromClass <br> * <br> * Purpose: <br> *  Looks up the path to executable that contains the class default icon. <br> * <br> * Parameters: <br> *  rclsid          pointer to CLSID to look up. <br> *  pszEXE          LPSTR at which to store the server name <br> *  cch             UINT size of pszEXE <br> *  lpIndex         LPUINT to index of icon within executable <br> * <br> * Return Value: <br> *  BOOL            TRUE if one or more characters were loaded into pszEXE. <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL FAR PASCAL FIconFileFromClass(REFCLSID rclsid, LPSTR pszEXE, UINT cch, UINT FAR *lpIndex) <br>{ <br> <br>   LONG          dw; <br>   LONG          lRet; <br>   HKEY          hKey; <br>   LPMALLOC      lpIMalloc; <br>   HRESULT       hrErr; <br>   LPSTR         lpBuffer; <br>   LPSTR         lpIndexString; <br>   UINT          cBufferSize = 136;// room for 128 char path and icon's index <br>   char          szKey[64]; <br>   char          pszClass[256]; <br>   LPOLESTR      pszUniClass; <br> <br> <br>   if (NULL==rclsid || NULL==pszEXE || 0==cch || IsEqualCLSID(rclsid,&amp;CLSID_NULL)) <br>      return FALSE; <br> <br>   //Here, we use CoGetMalloc and alloc a buffer (maxpathlen + 8) to <br>   //pass to RegQueryValue.  Then, we copy the exe to pszEXE and the <br>   //index to *lpIndex. <br> <br>   hrErr = CoGetMalloc(MEMCTX_TASK, &amp;lpIMalloc); <br> <br>   if (NOERROR != hrErr) <br>     return FALSE; <br> <br>   lpBuffer = /*(LPSTR)*/lpIMalloc-&gt;lpVtbl-&gt;Alloc(lpIMalloc, cBufferSize); <br> <br>   if (NULL == lpBuffer) <br>   { <br>     lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>     return FALSE; <br>   } <br> <br> <br>   if (CoIsOle1Class(rclsid)) <br>   { <br> <br>     LPOLESTR lpszUniProgID; <br>     char lpszProgID[256]; <br> <br>     // we've got an ole 1.0 class on our hands, so we look at <br>     // progID\protocol\stdfileedting\server to get the <br>     // name of the executable. <br> <br>     ProgIDFromCLSID(rclsid, &amp;lpszUniProgID); <br>     W2A (lpszUniProgID, lpszProgID, 256); <br> <br>     //Open up the class key <br>     lRet=RegOpenKey(HKEY_CLASSES_ROOT, lpszProgID, &amp;hKey); <br> <br>     if (ERROR_SUCCESS != lRet) <br>     { <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpszUniProgID); <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>       lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>       return FALSE; <br>     } <br> <br>     dw=(LONG)cBufferSize; <br>     lRet = RegQueryValue(hKey, "Protocol\\StdFileEditing\\Server", lpBuffer, &amp;dw); <br> <br>     if (ERROR_SUCCESS != lRet) <br>     { <br> <br>       RegCloseKey(hKey); <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpszUniProgID); <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>       lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>       return FALSE; <br>     } <br> <br> <br>     // Use server and 0 as the icon index <br>     LSTRCPYN(pszEXE, lpBuffer, cch); <br> <br>     *lpIndex = 0; <br> <br>     RegCloseKey(hKey); <br>     lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpszUniProgID); <br>     lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>     lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>     return TRUE; <br> <br>   } <br> <br> <br> <br>   /* <br>    * We have to go walking in the registration database under the <br>    * classname, so we first open the classname key and then check <br>    * under "\\DefaultIcon" to get the file that contains the icon. <br>    */ <br> <br> <br>   StringFromCLSID(rclsid, &amp;pszUniClass); <br>   W2A (pszUniClass, pszClass, 256); <br> <br>   lstrcpy(szKey, "CLSID\\"); <br>   lstrcat(szKey, pszClass); <br> <br>   //Open up the class key <br>   lRet=RegOpenKey(HKEY_CLASSES_ROOT, szKey, &amp;hKey); <br> <br>   if (ERROR_SUCCESS != lRet) <br>   { <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, pszUniClass); <br>      lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>      return FALSE; <br>   } <br> <br>   //Get the executable path and icon index. <br> <br>   dw=(LONG)cBufferSize; <br>   lRet=RegQueryValue(hKey, "DefaultIcon", lpBuffer, &amp;dw); <br> <br>   if (ERROR_SUCCESS != lRet) <br>   { <br>     // no DefaultIcon  key...try LocalServer <br> <br>     dw=(LONG)cBufferSize; <br>#ifdef WIN32 <br>     lRet=RegQueryValue(hKey, "LocalServer32", lpBuffer, &amp;dw); <br>#else <br>     lRet=RegQueryValue(hKey, "LocalServer", lpBuffer, &amp;dw); <br>#endif <br> <br>     if (ERROR_SUCCESS != lRet) <br>     { <br>       // no LocalServer entry either...they're outta luck. <br> <br>       RegCloseKey(hKey); <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>       lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, pszUniClass); <br>       lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>       return FALSE; <br>     } <br> <br> <br>     // Use server from LocalServer or Server and 0 as the icon index <br>     LSTRCPYN(pszEXE, lpBuffer, cch); <br> <br>     *lpIndex = 0; <br> <br>     RegCloseKey(hKey); <br>     lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>     lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, pszUniClass); <br>     lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>     return TRUE; <br>   } <br> <br>   RegCloseKey(hKey); <br> <br>   // lpBuffer contains a string that looks like "&lt;pathtoexe&gt;,&lt;iconindex&gt;", <br>   // so we need to separate the path and the icon index. <br> <br>   lpIndexString = PointerToNthField(lpBuffer, 2, ','); <br> <br>   if ('\0' == *lpIndexString)  // no icon index specified - use 0 as default. <br>   { <br>      *lpIndex = 0; <br> <br>   } <br>   else <br>   { <br>      LPSTR lpTemp; <br>      static char  szTemp[16]; <br> <br>      lstrcpy(szTemp, lpIndexString); <br> <br>      // Put the icon index part into *pIconIndex <br>      *lpIndex = atoi((const char *)szTemp); <br> <br>      // Null-terminate the exe part. <br>      lpTemp = AnsiPrev(lpBuffer, lpIndexString); <br>      *lpTemp = '\0'; <br>   } <br> <br>   if (!LSTRCPYN(pszEXE, lpBuffer, cch)) <br>   { <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>      lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, pszUniClass); <br>      lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>      return FALSE; <br>   } <br> <br>   // Free the memory we alloc'd and leave. <br>   lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, lpBuffer); <br>   lpIMalloc-&gt;lpVtbl-&gt;Free(lpIMalloc, pszUniClass); <br>   lpIMalloc-&gt;lpVtbl-&gt;Release(lpIMalloc); <br>   return TRUE; <br>} <br> <br> <br> <br>/* <br> * OleStdIconLabelTextOut <br> * <br> * Purpose: <br> *  Replacement for DrawText to be used in the "Display as Icon" metafile. <br> *  Uses ExtTextOut to output a string center on (at most) two lines. <br> *  Uses a very simple word wrap algorithm to split the lines. <br> * <br> * Parameters:  (same as for ExtTextOut, except for hFont) <br> *  hDC           device context to draw into; if this is NULL, then we don't <br> *                ETO the text, we just return the index of the beginning <br> *                of the second line <br> *  hFont         font to use <br> *  nXStart       x-coordinate of starting position <br> *  nYStart       y-coordinate of starting position <br> *  fuOptions     rectangle type <br> *  lpRect        rect far * containing rectangle to draw text in. <br> *  lpszString    string to draw <br> *  cchString     length of string (truncated if over OLEUI_CCHLABELMAX) <br> *  lpDX          spacing between character cells <br> * <br> * Return Value: <br> *  UINT          Index of beginning of last line (0 if there's only one <br> *                line of text). <br> * <br> */ <br> <br>STDAPI_(UINT) OleStdIconLabelTextOut(HDC        hDC, <br>                            HFONT      hFont, <br>                            int        nXStart, <br>                            int        nYStart, <br>                            UINT       fuOptions, <br>                            RECT FAR * lpRect, <br>                            LPOLESTR   lpszString, <br>                            UINT       cchString, <br>                            int FAR *  lpDX) <br>{ <br> <br>  HDC          hDCScreen; <br>  static char  szTempBuff[OLEUI_CCHLABELMAX]; <br>  int          cxString, cyString, cxMaxString; <br>  int          cxFirstLine, cyFirstLine, cxSecondLine; <br>  int          index; <br>  int          cch = cchString; <br>  char         chKeep; <br>  LPSTR        lpszSecondLine; <br>  HFONT        hFontT; <br>  BOOL         fPrintText = TRUE; <br>  UINT         iLastLineStart = 0; <br>  SIZE         size; <br> <br>  // Initialization stuff... <br> <br>  if (NULL == hDC)  // If we got NULL as the hDC, then we don't actually call ETO <br>   fPrintText = FALSE; <br> <br> <br>  // Make a copy of the string (NULL or non-NULL) that we're using <br>  if (NULL == lpszString) <br>   *szTempBuff = '\0'; <br> <br>  else <br>  { <br>     W2A (lpszString, szTempBuff, OLEUI_CCHLABELMAX); <br>  } <br> <br>  // set maximum width <br>  cxMaxString = lpRect-&gt;right - lpRect-&gt;left; <br> <br>  // get screen DC to do text size calculations <br>  hDCScreen = GetDC(NULL); <br> <br>  hFontT=SelectObject(hDCScreen, hFont); <br> <br>  // get the extent of our label <br>  GetTextExtentPoint(hDCScreen, szTempBuff, cch, &amp;size); <br> <br>  cxString = size.cx; <br>  cyString = size.cy; <br> <br>  // Select in the font we want to use <br>  if (fPrintText) <br>    SelectObject(hDC, hFont); <br> <br>  // String is smaller than max string - just center, ETO, and return. <br>  if (cxString &lt;= cxMaxString) <br>  { <br> <br>   if (fPrintText) <br>      ExtTextOut(hDC, <br>              nXStart + (lpRect-&gt;right - cxString) / 2, <br>              nYStart, <br>              fuOptions, <br>              lpRect, <br>              szTempBuff, <br>              cch, <br>              NULL); <br> <br>   iLastLineStart = 0;  // only 1 line of text <br>   goto CleanupAndLeave; <br>  } <br> <br>  // String is too long...we've got to word-wrap it. <br> <br> <br>  // Are there any spaces, slashes, tabs, or bangs in string? <br> <br>  if (lstrlen(szTempBuff) != (int)strcspn(szTempBuff, szSeparators)) <br>  { <br>    // Yep, we've got spaces, so we'll try to find the largest <br>    // space-terminated string that will fit on the first line. <br> <br>    index = cch; <br> <br> <br>    while (index &gt;= 0) <br>    { <br> <br>      char cchKeep; <br> <br>      // scan the string backwards for spaces, slashes, tabs, or bangs <br> <br>      while (!IS_SEPARATOR(szTempBuff[index]) ) <br>       index--; <br> <br> <br>      if (index &lt;= 0) <br>       break; <br> <br>      cchKeep = szTempBuff[index];  // remember what char was there <br> <br>      szTempBuff[index] = '\0';  // just for now <br> <br>      GetTextExtentPoint( <br>            hDCScreen, szTempBuff,lstrlen(szTempBuff),&amp;size); <br> <br>      cxFirstLine = size.cx; <br>      cyFirstLine = size.cy; <br> <br>      szTempBuff[index] = cchKeep;   // put the right char back <br> <br>      if (cxFirstLine &lt;= cxMaxString) <br>      { <br> <br>         iLastLineStart = index + 1; <br> <br>         if (!fPrintText) <br>          goto CleanupAndLeave; <br> <br>         ExtTextOut(hDC, <br>                 nXStart +  (lpRect-&gt;right - cxFirstLine) / 2, <br>                 nYStart, <br>                 fuOptions, <br>                 lpRect, <br>                 szTempBuff, </code></pre>
<p>
</p>
<pre><code>index + 1, <br>                 lpDX); <br> <br>         lpszSecondLine = szTempBuff; <br> <br>         lpszSecondLine += index + 1; <br> <br>         GetTextExtentPoint(hDCScreen, <br>                           lpszSecondLine, <br>                           lstrlen(lpszSecondLine), <br>                           &amp;size); <br> <br>         // If the second line is wider than the rectangle, we <br>         // just want to clip the text. <br>         cxSecondLine = min(size.cx, cxMaxString); <br> <br>         ExtTextOut(hDC, <br>                 nXStart + (lpRect-&gt;right - cxSecondLine) / 2, <br>                 nYStart + cyFirstLine, <br>                 fuOptions, <br>                 lpRect, <br>                 lpszSecondLine, <br>                 lstrlen(lpszSecondLine), <br>                 lpDX); <br> <br>         goto CleanupAndLeave; <br> <br>      }  // end if <br> <br>      index--; <br> <br>    }  // end while <br> <br>  }  // end if <br> <br>  // Here, there are either no spaces in the string (strchr(szTempBuff, ' ') <br>  // returned NULL), or there spaces in the string, but they are <br>  // positioned so that the first space terminated string is still <br>  // longer than one line. So, we walk backwards from the end of the <br>  // string until we find the largest string that will fit on the first <br>  // line , and then we just clip the second line. <br> <br>  cch = lstrlen(szTempBuff); <br> <br>  chKeep = szTempBuff[cch]; <br>  szTempBuff[cch] = '\0'; <br> <br>  GetTextExtentPoint(hDCScreen, szTempBuff, lstrlen(szTempBuff),&amp;size); <br> <br>  cxFirstLine = size.cx; <br>  cyFirstLine = size.cy; <br> <br>  while (cxFirstLine &gt; cxMaxString) <br>  { <br>    // We allow 40 characters in the label, but the metafile is <br>    // only as wide as 10 W's (for aesthetics - 20 W's wide looked <br>    // dumb.  This means that if we split a long string in half (in <br>    // terms of characters), then we could still be wider than the <br>    // metafile.  So, if this is the case, we just step backwards <br>    // from the halfway point until we get something that will fit. <br>    // Since we just let ETO clip the second line <br> <br>    szTempBuff[cch--] = chKeep; <br>    if (0 == cch) <br>      goto CleanupAndLeave; <br> <br>    chKeep = szTempBuff[cch]; <br>    szTempBuff[cch] = '\0'; <br> <br>    GetTextExtentPoint( <br>          hDCScreen, szTempBuff, lstrlen(szTempBuff), &amp;size); <br>    cxFirstLine = size.cx; <br>  } <br> <br>  iLastLineStart = cch; <br> <br>  if (!fPrintText) <br>   goto CleanupAndLeave; <br> <br>  ExtTextOut(hDC, <br>          nXStart + (lpRect-&gt;right - cxFirstLine) / 2, <br>          nYStart, <br>          fuOptions, <br>          lpRect, <br>          szTempBuff, <br>          lstrlen(szTempBuff), <br>          lpDX); <br> <br>  szTempBuff[cch] = chKeep; <br>  lpszSecondLine = szTempBuff; <br>  lpszSecondLine += cch; <br> <br>  GetTextExtentPoint( <br>        hDCScreen, lpszSecondLine, lstrlen(lpszSecondLine), &amp;size); <br> <br>  // If the second line is wider than the rectangle, we <br>  // just want to clip the text. <br>  cxSecondLine = min(size.cx, cxMaxString); <br> <br>  ExtTextOut(hDC, <br>          nXStart + (lpRect-&gt;right - cxSecondLine) / 2, <br>          nYStart + cyFirstLine, <br>          fuOptions, <br>          lpRect, <br>          lpszSecondLine, <br>          lstrlen(lpszSecondLine), <br>          lpDX); <br> <br>CleanupAndLeave: <br>  SelectObject(hDCScreen, hFontT); <br>  ReleaseDC(NULL, hDCScreen); <br>  return iLastLineStart; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
