<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUMINFO.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context264"></a>SUMINFO.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2.0 Property Set Utilities <br>** <br>**    suminfo.cpp <br>** <br>**    This file contains functions that are useful for the manipulation <br>**    of OLE 2.0 Property Sets particularly to manage the Summary Info <br>**    property set. <br>** <br>**    (c) Copyright Microsoft Corp. 1990 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>// Note: this file is designed to be stand-alone; it includes a <br>// carefully chosen, minimal set of headers. <br>// <br>// For conditional compilation we use the ole2 conventions, <br>//    _MAC      = mac <br>//    WIN32     = Win32 (NT really) <br>//    &lt;nothing&gt; = defaults to Win16 <br> <br>// REVIEW: the following needs to modified to handle _MAC <br>#define STRICT <br> <br>#include &lt;string.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include "ansiapi.h" <br> <br>#ifdef WIN32 <br>#define _fmemset memset <br>#define _fmemcpy memcpy <br>#define _fmemcmp memcmp <br>#define _fstrcpy strcpy <br>#define _fstrlen strlen <br>#endif <br> <br>/* A LPSUMINFO variable is a pointer to an instance of an abstract data <br>**    type.  There can be an arbitrary number of SummaryInfo streams open <br>**    simultaneously (subject to available memory); each must have its <br>**    own LPSUMINFO instance. Each LPSUMINFO instance must <br>**    be initialized prior to use by calling Init and freed after its <br>**    last use by calling Free.  The param argument to Init is reserved <br>**    for future expansion and should be zero initially. Once a LPSUMINFO <br>**    instance is allocated (by Init), the user can call the Set <br>**    procedures to initialize fields.  A copy of the arguments is made <br>**    in every case except SetThumbnail where control of the storage <br>**    occupied by the METAFILEPICT is merely transferred.  When the <br>**    Free routine is called, all storage will be deallocated including <br>**    that of the thumbnail.  The arguments to SetThumbNail and the <br>**    return values from GetThumbNail correspond to the OLE2.0 spec. <br>**    Note that on input, the thumbnail is read on demand but all the <br>**    other properties are pre-loaded.  The thumbnail is manipulated as <br>**    a windows handle to a METAFILEPICT structure, which in turn <br>**    contains a handle to the METAFILE.  The transferClip argument on <br>**    GetThumbNail, when set to true, transfers responsibility for <br>**    storage management of the thumbnail to the caller; that is, after <br>**    Free has been called, the handle is still valid. Clear can be <br>**    used to free storage for all the properties but then you must <br>**    call Read to load them again.  All the code is based on FAR <br>**    pointers. <br>**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo. <br>**    Memory is allocated using the currently active IMalloc* <br>**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ). <br>** <br>** Common scenarios: <br>**    Read SummaryInfo <br>**    ---------------- <br>**      OleStdInitSummaryInfo() <br>**      OleStdReadSummaryInfo() <br>**      . . . . . <br>**      call different Get routines <br>**      . . . . . <br>**      OleStdFreeSummaryInfo() <br>** <br>**    Create SummaryInfo <br>**    ------------------ <br>**      OleStdInitSummaryInfo() <br>**      call different Set routines <br>**      OleStdWriteSummaryInfo() <br>**      OleStdFreeSummaryInfo() <br>** <br>**    Update SummaryInfo <br>**    ------------------ <br>**      OleStdInitSummaryInfo() <br>**      OleStdReadSummaryInfo() <br>**      OleStdGetThumbNailProperty(necessary only if no SetThumb) <br>**      call different Set routines <br>**      OleStdWriteSummaryInfo() <br>**      OleStdFreeSummaryInfo() <br>*/ <br> <br>#define CHAR unsigned char <br>#define fTrue 1 <br>#define fFalse 0 <br>#define BYTE unsigned char <br>#define WORD unsigned short <br>#define DWORD unsigned long <br>#define LPVOID void FAR * <br>#define uchar unsigned char <br>#define ulong unsigned long <br>#define BOOL unsigned char <br>#define BF unsigned int <br> <br>#include "suminfo.h" <br>#include "wn_dos.h" <br> <br>#if defined( _DEBUG ) <br>// following is from compobj.dll (ole2) <br>#define ASSERT(x) (!(x) ? FnAssert(#x, NULL, __FILE__, __LINE__) : 0) <br>#else <br>#define ASSERT(x) <br>#endif <br> <br> <br>typedef struct _RSUMINFO <br>   { <br>   WORD byteOrder; <br>   WORD formatVersion; <br>   WORD getOSVersion; <br>   WORD osVersion; <br>   CLSID classId;  //from compobj.h <br>   DWORD cSections; <br>   PROPSETLIST rgPropSet[1/*cSections*/]; //one section in standard summary info <br>   STANDARDSECINMEM section; <br>   ULONG fileOffset;   //offset for thumbnail to support demand read <br>   } RSUMINFO; <br> <br>typedef RSUMINFO FAR * LPRSI; <br> <br>   typedef union _foo{ <br>      ULARGE_INTEGER uli; <br>      struct { <br>         DWORD       dw; <br>         DWORD       dwh; <br>         }; <br>      struct { <br>         WORD    w0; <br>         WORD    w1; <br>         WORD    w2; <br>         WORD    w3; <br>         }; <br>      } Foo; <br> <br> <br> <br>/* MemAlloc <br>** --------- <br>**    allocate memory using the currently active IMalloc* allocator <br>*/ <br>static LPVOID MemAlloc(ULONG ulSize) <br>{ <br>   LPVOID pout; <br>   LPMALLOC pmalloc; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      ASSERT(pmalloc); <br>      return NULL; <br>   } <br> <br>   pout = (LPVOID)pmalloc-&gt;Alloc(ulSize); <br> <br>   if (pmalloc != NULL) { <br>      ULONG refs = pmalloc-&gt;Release(); <br>   } <br> <br>   return pout; <br>} <br> <br> <br>/* MemFree <br>** ------- <br>**    free memory using the currently active IMalloc* allocator <br>*/ <br>static void MemFree(LPVOID pmem) <br>{ <br>   LPMALLOC pmalloc; <br> <br>   if (pmem == NULL) <br>      return; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, &amp;pmalloc) != NOERROR) { <br>      ASSERT(pmalloc); <br>      return; <br>   } <br> <br>   pmalloc-&gt;Free(pmem); <br> <br>   if (pmalloc != NULL) { <br>      ULONG refs = pmalloc-&gt;Release(); <br>   } <br>} <br> <br>// Replace the first argument with the product of itself and the multiplier <br>static void ulargeMultiply(ULARGE_INTEGER FAR *ul, USHORT m) <br>{ <br>   Foo out, in; <br>   in.uli = *ul; <br>   out.dw = (ULONG)m * in.w0;      in.w0 = out.w0; <br>   out.dw = (ULONG)m * in.w1 + out.w1; in.w1 = out.w0; <br>   out.dw = (ULONG)m * in.w2 + out.w1; in.w2 = out.w0; <br>   out.dw = (ULONG)m * in.w3 + out.w1; in.w3 = out.w0; <br>   *ul = in.uli; <br>} <br> <br>// Replace the first argument with the product of itself and the multiplier <br>static void ulargeDivide(ULARGE_INTEGER FAR *ul, USHORT m) <br>{ <br>   Foo out, in; <br>   DWORD i; <br>   in.uli = *ul; <br>   out.dwh = in.dwh/(ULONG)m; <br>   i = in.dwh%(ULONG)m; <br>   in.w2 = in.w1; <br>   in.w3 = (WORD)i; <br>   out.w1 = (WORD)(in.dwh/(ULONG)m); <br>   in.w1 = (WORD)(in.dwh%(ULONG)m); <br>   out.w0 = (WORD)(in.dw/(ULONG)m); <br>   *ul = out.uli; <br>} <br> <br> <br>static void setStandard(LPRSI lprsi) <br>{ <br>   int i; <br>   lprsi-&gt;cSections = 1; <br>   SetSumInfFMTID(&amp;lprsi-&gt;rgPropSet[0].formatID); <br>   _fmemcpy(&amp;lprsi-&gt;classId, &amp;lprsi-&gt;rgPropSet[0].formatID, sizeof(FMTID)); <br>   lprsi-&gt;rgPropSet[0].byteOffset = cbNewSummaryInfo(1); <br>   for (i=0; i&lt;cPIDSI_STANDARD; i++) <br>      lprsi-&gt;section.rgPropId[i].propertyID = PIDSI_TITLE+i; <br>   lprsi-&gt;section.cProperties = cPIDSI_STANDARD; //always; do null test to check validity <br>} <br> <br>extern "C" { <br> <br>/************************************************************************* <br>** <br>** OleStdInitSummaryInfo <br>** <br>** Purpose: <br>**    Initialize a Summary Info structure. <br>** <br>** Parameters: <br>**    int reserved             - reserverd for future use. must be 0. <br>** <br>** Return Value: <br>**    LPSUMINFO <br>** <br>** Comments: <br>**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo. <br>**    Memory is allocated using the currently active IMalloc* <br>**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ). <br>**    Each LPSUMINFO instance must be initialized prior to use by <br>**    calling OleStdInitSummaryInfo. Once a LPSUMINFO instance is allocated <br>**    (by OleStdInitSummaryInfo), the user can call the Set procedures to <br>**    initialize fields. <br>*************************************************************************/ <br> <br>STDAPI_(LPSUMINFO) OleStdInitSummaryInfo(int reserved) <br>{ <br>   LPRSI lprsi; <br> <br>   if ((lprsi = (LPRSI)MemAlloc(sizeof(RSUMINFO))) != NULL) <br>   { <br>      ClearSumInf(lprsi, sizeof(RSUMINFO)); <br>   } else return NULL; <br> <br>   setStandard(lprsi); <br>   return (LPSUMINFO)lprsi; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdFreeSummaryInfo <br>** <br>** Purpose: <br>**    Free a Summary Info structure. <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct <br>** <br>** Return Value: <br>**    void <br>** <br>** Comments: <br>**    Memory is freed using the currently active IMalloc* <br>**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ). <br>**    Every LPSUMINFO struct must be freed after its last use. <br>**    When the OleStdFreeSummaryInfo routine is called, all storage will be <br>**    deallocated including that of the thumbnail (unless ownership of <br>**    the thumbnail has been transfered to the caller -- see <br>**    description of transferClip in GetThumbnail API). <br>** <br>*************************************************************************/ <br> <br>STDAPI_(void) OleStdFreeSummaryInfo(LPSUMINFO FAR *lplp) <br>{ <br>   if (lplp==NULL||*lplp==NULL) return; <br>   OleStdClearSummaryInfo(*lplp); <br>   MemFree(*lplp); <br>   *lplp = NULL; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdClearSummaryInfo <br>** <br>** Purpose: <br>**    Free storage (memory) for all the properties of the LPSUMINFO. <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>** <br>** Return Value: <br>**    void <br>** <br>** Comments: <br>**    After calling OleStdClearSummaryInfo you must call OleStdReadSummaryInfo to <br>**    load them again. <br>** <br>*************************************************************************/ <br> <br>STDAPI_(void) OleStdClearSummaryInfo(LPSUMINFO lp) <br>{ <br>   OleStdSetStringProperty(lp, PIDSI_TITLE, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_SUBJECT, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_AUTHOR, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_KEYWORDS, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_COMMENTS, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_TEMPLATE, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_REVNUMBER, NULL); <br>   OleStdSetStringProperty(lp, PIDSI_APPNAME, NULL); <br>   OleStdSetThumbNailProperty(NULL, lp, VT_CF_EMPTY, 0, NULL, NULL, 0); <br>   ClearSumInf((LPRSI)lp, sizeof(RSUMINFO)); <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdReadSummaryInfo <br>** <br>** Purpose: <br>**    Read all Summary Info properties into memory (except thumbnail <br>**    which is demand loaded). <br>** <br>** Parameters: <br>**    LPSTREAM lps                  - open SummaryInfo IStream* <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>** Comments: <br>** <br>*************************************************************************/ <br>/* <br>STDAPI_(int) OleStdReadSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   LPRSI lpSumInfo = (LPRSI)lp; <br>   SCODE sc; <br>   ULONG cbRead,i,sectionOffset; <br>   LARGE_INTEGER a; <br>   ULARGE_INTEGER b; <br>   int j,k,l; <br>   union { <br>      RSUMINFO rsi; <br>      STDZ stdz; <br>   }; <br>   OleStdClearSummaryInfo(lp); <br>   LISet32(a, 0); <br>   sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>   if (FAILED(sc)) goto fail; <br>   sectionOffset = cbNewSummaryInfo(1); <br>   sc = GetScode(lpStream-&gt;Read(&amp;rsi, sectionOffset, &amp;cbRead)); <br>   if (FAILED(sc)||cbRead&lt;sectionOffset) goto fail; <br>   if (!FIntelOrder(&amp;rsi)||rsi.formatVersion!=0) goto fail; <br>   j = (int)rsi.cSections; <br>   while (j--&gt;0) { <br>      if (FEqSumInfFMTID(&amp;rsi.rgPropSet[0].formatID)) { <br>         sectionOffset = rsi.rgPropSet[0].byteOffset; <br>         break; <br>      } else { <br>         sc = GetScode(lpStream-&gt;Read(&amp;rsi.rgPropSet[0].formatID, sizeof(PROPSETLIST), &amp;cbRead)); <br>         if (FAILED(sc)||cbRead!=sizeof(PROPSETLIST)) goto fail; <br>      } <br>      if (j&lt;=0) goto fail; <br>   } <br> <br>   LISet32(a, sectionOffset); <br>   sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>   if (FAILED(sc)) goto fail; <br>   sc = GetScode(lpStream-&gt;Read(&amp;rsi.section, cbNewSection(1), &amp;cbRead)); <br>   if (FAILED(sc)||cbRead!=cbNewSection(1)) goto fail; <br>   i = rsi.section.cBytes+sectionOffset; <br>   j = (int)rsi.section.cProperties; <br>   if (j&gt;cPIDSI_STANDARD) goto fail; <br>   k = 0; <br>   while (j--&gt;0) { <br>      k++; <br>      switch (l=(int)rsi.section.rgPropId[0].propertyID) { <br>         case PIDSI_PAGECOUNT: <br>         case PIDSI_WORDCOUNT: <br>         case PIDSI_CHARCOUNT: <br>         case PIDSI_DOC_SECURITY: <br>            if (l==PIDSI_DOC_SECURITY) l=3; else l-=PIDSI_PAGECOUNT; <br>            cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset; <br>            if (cbRead&gt;=i) goto fail; <br>            LISet32(a, cbRead); <br>            sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>            if (FAILED(sc)) goto fail; <br>            sc = GetScode(lpStream-&gt;Read(&amp;lpSSIM-&gt;rgInts[l], sizeof(INTS), &amp;cbRead)); <br>            if (FAILED(sc)||cbRead!=sizeof(INTS)) goto fail; <br>            if (lpSSIM-&gt;rgInts[l].vtType==VT_EMPTY) break; <br>            if (lpSSIM-&gt;rgInts[l].vtType!=VT_I4) goto fail; <br>            break; <br>         case PIDSI_EDITTIME: <br>         case PIDSI_LASTPRINTED: <br>         case PIDSI_CREATE_DTM: <br>         case PIDSI_LASTSAVE_DTM: <br>            l-=PIDSI_EDITTIME; <br>            cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset; <br>            if (cbRead&gt;=i) goto fail; <br>            LISet32(a, cbRead); <br>            sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>            if (FAILED(sc)) goto fail; <br>            sc = GetScode(lpStream-&gt;Read(&amp;lpSSIM-&gt;rgTime[l], sizeof(TIME), &amp;cbRead)); <br>            if (FAILED(sc)||cbRead!=sizeof(TIME)) goto fail; <br>            if (lpSSIM-&gt;rgTime[l].vtType==VT_EMPTY) break; <br>            if (lpSSIM-&gt;rgTime[l].vtType!=VT_FILETIME) goto fail; <br>            break; <br>         case PIDSI_TITLE: <br>         case PIDSI_SUBJECT: <br>         case PIDSI_AUTHOR: <br>         case PIDSI_KEYWORDS: <br>         case PIDSI_COMMENTS: <br>         case PIDSI_TEMPLATE: <br>         case PIDSI_LASTAUTHOR: <br>         case PIDSI_REVNUMBER: <br>         case PIDSI_APPNAME: <br>            cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset; <br>            if (cbRead&gt;=i) goto fail; <br>            LISet32(a, cbRead); <br>            sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>            if (FAILED(sc)) goto fail; <br>            sc = GetScode(lpStream-&gt;Read(&amp;stdz, sizeof(STDZ), &amp;cbRead)); <br>            if (FAILED(sc)||cbRead&lt;sizeof(DWORD)*2) goto fail; <br>            if (stdz.vtType==VT_EMPTY||stdz.vtByteCount&lt;=1) break; <br>            if (stdz.vtType!=VT_LPSTR||stdz.vtByteCount&gt;WORDMAX) goto fail; <br>            stdz.rgchars[(int)stdz.vtByteCount-1] = '\0'; <br>            OleStdSetStringProperty(lp, (DWORD)l, (LPSTR)&amp;stdz.rgchars[0]); <br>            break; <br>         case PIDSI_THUMBNAIL: <br>            cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset; <br>            if (cbRead&gt;=i) goto fail; <br>            LISet32(a, cbRead); <br>            sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>            if (FAILED(sc)) goto fail; <br>            lpSumInfo-&gt;fileOffset = cbRead+sizeof(DWORD)*3; <br>            sc = GetScode(lpStream-&gt;Read(&amp;lpSSIM-&gt;thumb, sizeof(DWORD)*4, &amp;cbRead)); <br>            if (FAILED(sc)||cbRead!=sizeof(DWORD)*4) { <br>               lpSSIM-&gt;thumb.vtType = VT_EMPTY; <br>               goto fail; <br>            } <br>            if (lpSSIM-&gt;thumb.vtType == VT_EMPTY) { <br>               lpSSIM-&gt;thumb.cBytes = 0; <br>               break; <br>            } <br>            if (lpSSIM-&gt;thumb.vtType != VT_CF) { <br>               lpSSIM-&gt;thumb.vtType = VT_EMPTY; <br>               goto fail; <br>            } <br>            lpSSIM-&gt;thumb.cBytes -= sizeof(DWORD); //for selector <br>            if (lpSSIM-&gt;thumb.selector==VT_CF_WIN||lpSSIM-&gt;thumb.selector==VT_CF_MAC) { <br>               lpSumInfo-&gt;fileOffset += sizeof(DWORD); <br>               lpSSIM-&gt;thumb.cBytes -= sizeof(DWORD); //for format val <br>            } <br>            break; <br>            default: ; <br>      } <br>      if (j&lt;=0) <br>      { <br>      // We should fail if the document is password-protected. <br>         if(OleStdGetSecurityProperty(lp)==fSecurityPassworded) <br>            goto fail; <br>         return 1; <br>      } <br>      LISet32(a, sectionOffset+sizeof(DWORD)*2+k*sizeof(PROPIDLIST)); <br>      sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>      if (FAILED(sc)) goto fail; <br>      sc = GetScode(lpStream-&gt;Read(&amp;rsi.section.rgPropId[0], sizeof(PROPIDLIST), &amp;cbRead)); <br>      if (FAILED(sc)||cbRead!=sizeof(PROPIDLIST)) goto fail; <br>   } <br> <br>fail: <br>   OleStdClearSummaryInfo(lpSumInfo); <br>   return 0; <br>} <br>*/ <br> <br>/************************************************************************* <br>** <br>** OleStdWriteSummaryInfo <br>** <br>** Purpose: <br>**    Write all Summary Info properties to a IStream* <br>** <br>** Parameters: <br>**    LPSTREAM lps                  - open SummaryInfo IStream* <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>** Comments: <br>** <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdWriteSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   // REVIEW: localization issues for propert sets <br>   //         do we need to include a code page and dictionary? <br> <br>   LPRSI lpSumInfo = (LPRSI)lp; <br>   SCODE sc; <br>   ULONG cbWritten; <br>   ULONG cBytes, oBytes, k,l,m,n; <br>   LARGE_INTEGER a; <br>   ULARGE_INTEGER b; <br>   LPOLESTR lps; <br>   LPMETAFILEPICT lpmfp; <br>   int i,j,s; <br> <br>   setStandard(lpSumInfo); <br>   oBytes = cbNewSection(cPIDSI_STANDARD);  //offsets are relative to the section <br>   cBytes = cbNewSection(cPIDSI_STANDARD)+(sizeof(TIME)*MAXTIME)+(sizeof(INTS)*MAXINTS); <br> <br>   lpSSIM-&gt;rgPropId[PIDSI_EDITTIME-2].byteOffset = oBytes; <br>   lpSSIM-&gt;rgPropId[PIDSI_LASTPRINTED-2].byteOffset = oBytes+sizeof(TIME); <br>   lpSSIM-&gt;rgPropId[PIDSI_CREATE_DTM-2].byteOffset = oBytes+sizeof(TIME)*2; <br>   lpSSIM-&gt;rgPropId[PIDSI_LASTSAVE_DTM-2].byteOffset = oBytes+sizeof(TIME)*3; <br> <br>   lpSSIM-&gt;rgPropId[PIDSI_PAGECOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME); <br>   lpSSIM-&gt;rgPropId[PIDSI_WORDCOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS)); <br>   lpSSIM-&gt;rgPropId[PIDSI_CHARCOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS)*2); <br>   lpSSIM-&gt;rgPropId[PIDSI_DOC_SECURITY-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS)*3); <br>   oBytes += sizeof(TIME)*MAXTIME + sizeof(INTS)*MAXINTS; <br> <br>   lpSSIM-&gt;rgPropId[PIDSI_THUMBNAIL-2].byteOffset = oBytes; <br>   l = 0; <br>   if (lpSSIM-&gt;thumb.vtType==VT_EMPTY) k = sizeof(DWORD); <br>   else { <br>      l = ((lpSSIM-&gt;thumb.cBytes+4-1)&gt;&gt;2)&lt;&lt;2; <br>      if (lpSSIM-&gt;thumb.selector==VT_CF_BYTES) k = sizeof(DWORD)*3; <br>      else if (lpSSIM-&gt;thumb.selector==VT_CF_FMTID) {k = sizeof(DWORD)*3; l += sizeof(FMTID); } <br>      else if (lpSSIM-&gt;thumb.selector==VT_CF_NAME)  {k = sizeof(DWORD)*3; l += (((*lpSSIM-&gt;thumb.lpstzName+1+3)&gt;&gt;2)&lt;&lt;2);} <br>      else k = sizeof(DWORD)*4; <br>   } <br>   cBytes += k+l; <br>   oBytes += k+l; <br> <br>   for (i=0; i&lt;MAXSTDZ; i++) { <br>      j = 0; <br>      if (lpSSIM-&gt;rglpsz[i]!=NULL) { <br>         j = lpSSIM-&gt;rglpsz[i]-&gt;VTCB+1/*null*/; <br>         lpSSIM-&gt;rglpsz[i]-&gt;vtByteCount = j; <br>         j = (((j+4-1)&gt;&gt;2)&lt;&lt;2)+sizeof(DWORD); <br>         cBytes += j; <br>      } <br>      if (i!=MAXSTDZ-1) lpSSIM-&gt;rgPropId[i].byteOffset = oBytes; <br>      else lpSSIM-&gt;rgPropId[PIDSI_APPNAME-2].byteOffset = oBytes; <br>      oBytes += j+sizeof(DWORD); <br>      cBytes += sizeof(DWORD); //type <br>   } <br>   lpSSIM-&gt;cBytes = cBytes; <br> <br> <br>   LISet32(a, 0); <br>   sc = GetScode(lpStream-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>   if (FAILED(sc)) return 0; <br>   sc = GetScode(lpStream-&gt;Write(lpSumInfo, cbNewSummaryInfo(1), &amp;cbWritten)); <br>   if (FAILED(sc)||cbWritten!=cbNewSummaryInfo(1)) return 0; <br>   sc = GetScode(lpStream-&gt;Write(lpSSIM, cbNewSection(cPIDSI_STANDARD)+sizeof(TIME)*MAXTIME+sizeof(INTS)*MAXINTS, &amp;cbWritten)); <br>   if (FAILED(sc)||cbWritten!=cbNewSection(cPIDSI_STANDARD)+sizeof(TIME)*MAXTIME+sizeof(INTS)*MAXINTS) return 0; <br> <br>   m = lpSSIM-&gt;thumb.cBytes; <br>   if (lpSSIM-&gt;thumb.lpstzName!=NULL) s = *lpSSIM-&gt;thumb.lpstzName; <br>   else s = 0; <br>   if (m!=0) { <br>      lpSSIM-&gt;thumb.cBytes = (k-sizeof(DWORD)*2)+ <br>         (((lpSSIM-&gt;thumb.cBytes+4-1)&gt;&gt;2)&lt;&lt;2)+(((s+4-1)&gt;&gt;2)&lt;&lt;2); <br>      n = lpSSIM-&gt;thumb.selector; <br>      lps = lpSSIM-&gt;thumb.lpByte; <br>      ASSERT(lps!=NULL);  //maybe a GetThumbNail here <br>      ASSERT(n!=VT_CF_NAME); <br>      if (n==VT_CF_WIN) { //bytes are in global memory <br>         lpmfp = (LPMETAFILEPICT)GlobalLock((HANDLE)(DWORD)lps); <br>         if (lpmfp==NULL) goto fail; <br>         lps = (LPOLESTR)GlobalLock(lpmfp-&gt;hMF); <br>      } <br>      if (n==VT_CF_NAME) lpSSIM-&gt;thumb.selector = *lpSSIM-&gt;thumb.lpstzName+1/*null*/; <br>   } <br>   sc = GetScode(lpStream-&gt;Write(&amp;lpSSIM-&gt;thumb, k, &amp;cbWritten)); <br>   if (FAILED(sc)||cbWritten!=k) goto fail; <br>   if (s!=0) { <br>      k = ((s+1+4-1)&gt;&gt;2)&lt;&lt;2; <br>      sc = GetScode(lpStream-&gt;Write(lpSSIM-&gt;thumb.lpstzName+1, k, &amp;cbWritten)); <br>      if (FAILED(sc)||cbWritten!=k) goto fail; <br>   } <br>   if (m!=0) { <br>      k = ((m+3)&gt;&gt;2)&lt;&lt;2; <br>      if (n==VT_CF_WIN||VT_CF_NAME) { //bytes are in global memory <br>         sc = GetScode(lpStream-&gt;Write(lpmfp, sizeof(METAFILEPICT), &amp;cbWritten)); <br>         k -= sizeof(METAFILEPICT); <br>      } <br>      sc = GetScode(lpStream-&gt;Write(lps, k, &amp;cbWritten)); <br>      if (FAILED(sc)||cbWritten!=k) goto fail; <br>      if (n==VT_CF_WIN||VT_CF_NAME) { //bytes are in global memory <br>         GlobalUnlock(lpmfp-&gt;hMF); <br>         GlobalUnlock((HANDLE)(DWORD)lpSSIM-&gt;thumb.lpByte); <br>      } <br>   } <br>   lpSSIM-&gt;thumb.cBytes = m;   //restore in mem value <br>   lpSSIM-&gt;thumb.selector = n; <br> <br>   k = VT_EMPTY; <br>   for (i=0; i&lt;MAXSTDZ; i++) { <br>      if (lpSSIM-&gt;rglpsz[i]!=NULL) { <br>         l = lpSSIM-&gt;rglpsz[i]-&gt;vtByteCount; <br>         j = ((((int)l+4-1)/4)*4)+sizeof(DWORD)*2; <br>         sc = GetScode(lpStream-&gt;Write(lpSSIM-&gt;rglpsz[i], j, &amp;cbWritten)); <br>         if (FAILED(sc)||cbWritten!=(ULONG)j) return 0; <br>         lpSSIM-&gt;rglpsz[i]-&gt;vtByteCount = 0; //restore stz count convention <br>         lpSSIM-&gt;rglpsz[i]-&gt;VTCB = (int)l; <br>      } else { <br>         sc = GetScode(lpStream-&gt;Write(&amp;k, sizeof(DWORD), &amp;cbWritten)); <br>         if (FAILED(sc)||cbWritten!=sizeof(DWORD)) return 0; <br>      } <br>   } <br>   return 1; <br>fail: <br>   lpSSIM-&gt;thumb.cBytes = m;   //restore in mem value <br>   lpSSIM-&gt;thumb.selector = n; <br>   if (m!=0&amp;&amp;(n==VT_CF_WIN||VT_CF_NAME)) { //bytes are in global memory <br>      GlobalUnlock((HANDLE)(DWORD)lps); <br>   } <br>   return 0; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetSecurityProperty <br>** <br>** Purpose: <br>**    Retrieve the Security Property <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct <br>** <br>** Return Value: <br>**    DWORD                       - security level <br>**          AllSecurityFlagsEqNone 0    - no security <br>**          fSecurityPassworded 1       - password required <br>**          fSecurityRORecommended 2    - read-only is recommended <br>**          fSecurityRO 4               - read-only is required <br>**          fSecurityLockedForAnnotations 8 - locked for annotations <br>** <br>** Comments: <br>**    by noting the (suggested; that is, application-enforced) security <br>**    level on the document, an application other than the originator <br>**    of the document can adjust its user interface to the properties <br>**    appropriately. An application should not display any of the <br>**    information about a password protected document, and should not <br>**    allow modifications to enforced read-only or locked for <br>**    annotations documents. It should warn the user about read-only <br>**    recommended if the user attempts to modify properties. <br>** <br>*************************************************************************/ <br> <br>STDAPI_(DWORD) OleStdGetSecurityProperty(LPSUMINFO lp) <br>{ <br>STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   if (lpSSIM-&gt;rgInts[3].vtType == VT_I4) return lpSSIM-&gt;rgInts[3].value; <br>   return 0; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdSetSecurityProperty <br>** <br>** Purpose: <br>**    Set the Security Property <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct <br>**    DWORD security              - security level <br>**          AllSecurityFlagsEqNone 0    - no security <br>**          fSecurityPassworded 1       - password required <br>**          fSecurityRORecommended 2    - read-only is recommended <br>**          fSecurityRO 4               - read-only is required <br>**          fSecurityLockedForAnnotations 8 - locked for annotations <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>**                                    (there are no errors) <br>** <br>** Comments: <br>**    by noting the (suggested; that is, application-enforced) security <br>**    level on the document, an application other than the originator <br>**    of the document can adjust its user interface to the properties <br>**    appropriately. An application should not display any of the <br>**    information about a password protected document, and should not <br>**    allow modifications to enforced read-only or locked for <br>**    annotations documents. It should warn the user about read-only <br>**    recommended if the user attempts to modify properties. <br>** <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdSetSecurityProperty(LPSUMINFO lp, DWORD security) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br> <br>   // REVIEW: check valid transitions; how do we know APP called us? <br> <br>   if (security==0) { <br>      lpSSIM-&gt;rgInts[3].vtType = VT_EMPTY; <br>      return 1; <br>   } <br>   lpSSIM-&gt;rgInts[3].vtType = VT_I4; <br>   lpSSIM-&gt;rgInts[3].value = security; <br>   return 1; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetStringProperty <br>** <br>** Purpose: <br>**    Retrieve a String Propety. <br>**    (returns zero terminated string -- C string) <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD pid                     - ID of String Property <br>** <br>** Return Value: <br>**    LPSTR                         - value of String Property <br>**                                      (zero terminated string--C string) <br>** <br>** Comments: <br>**    String should NOT be freed by caller. Memory for string will be <br>**    freed when OleStdFreeSummaryInfo is called. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTR) OleStdGetStringProperty(LPSUMINFO lp, DWORD pid) <br>{ <br>   LPSTR l = OleStdGetStringZProperty(lp,pid); <br>   if (l==NULL) return NULL; else return l+1; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdSetStringProperty <br>** <br>** Purpose: <br>**    Set a String Propety <br>**    (takes zero terminated string -- C string) <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD pid                     - ID of String Property <br>**    LPSTR lpsz                    - new value for String Property. <br>**                                      zero terminated string -- C string. <br>**                                      May be NULL, in which case the <br>**                                      propery is cleared. <br>** <br>** Return Value: <br>**    int                           - 1 if successful <br>**                                  - 0 invalid property id <br>** <br>** Comments: <br>**    The input string is copied. <br>** <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdSetStringProperty(LPSUMINFO lp, DWORD pid, LPOLESTR lpsz) <br>{ <br>   LPRSI lprsi=(LPRSI)lp; <br>   STANDARDSECINMEM FAR* lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   int i; <br>   if (pid==PIDSI_APPNAME) { <br>      pid = MAXSTDZ-1; <br>   } else if (pid&lt;PIDSI_TITLE || pid&gt;PIDSI_REVNUMBER) return 0; else pid -= 2; <br>   ASSERT(lpSSIM); <br>   if (lpSSIM-&gt;rglpsz[pid]) MemFree(lpSSIM-&gt;rglpsz[pid]); <br>   if ((lpsz==NULL)||(*lpsz==0)) { <br>      lpSSIM-&gt;rglpsz[pid] = NULL; <br>      return (1); <br>   } <br>   i = OLESTRLEN(lpsz); <br>   lpSSIM-&gt;rglpsz[pid] = (STDZ FAR*)MemAlloc(i+1/*null*/+sizeof(DWORD)*2); <br>   if (lpSSIM-&gt;rglpsz[pid]==NULL) return 0; <br>   W2A(lpsz, (LPSTR)&amp;lpSSIM-&gt;rglpsz[pid]-&gt;rgchars, sizeof(&amp;lpSSIM-&gt;rglpsz[pid]-&gt;rgchars)); <br>   lpSSIM-&gt;rglpsz[pid]-&gt;vtType = VT_LPSTR; <br>   lpSSIM-&gt;rglpsz[pid]-&gt;vtByteCount = 0; <br>   lpSSIM-&gt;rglpsz[pid]-&gt;VTCB = i; <br>   return (1); <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetStringZProperty <br>** <br>** Purpose: <br>**    Retrieve a String Propety. <br>**    (returns zero-terminated with leading byte count string) <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD pid                     - ID of Property <br>** <br>** Return Value: <br>**    LPSTZR                        - value of String Property <br>**                                      (zero-terminated with leading <br>**                                      byte count) </code></pre>
<p>
</p>
<pre><code>** <br>** Comments: <br>**    String should NOT be freed by caller. Memory for string will be <br>**    freed when OleStdFreeSummaryInfo is called. <br>*************************************************************************/ <br> <br>STDAPI_(LPSTZR) OleStdGetStringZProperty(LPSUMINFO lp, DWORD pid) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   if (pid==PIDSI_APPNAME) { <br>      pid = MAXSTDZ-1; <br>   } else if (pid&lt;PIDSI_TITLE || pid&gt;PIDSI_REVNUMBER) return NULL; else pid -= 2; <br>   if (lpSSIM-&gt;rglpsz[pid]!=NULL) { <br>      return (LPSTR)&amp;lpSSIM-&gt;rglpsz[pid]-&gt;VTCB; <br>   } <br>   return NULL; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetDocProperty <br>** <br>** Purpose: <br>**    Retrieve document properties (no. pages, no. words, no. characters) <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD FAR *nPage              - (OUT) number of pages in document <br>**    DWORD FAR *nWords             - (OUT) number of words in document <br>**    DWORD FAR *nChars             - (OUT) number of charactrs in doc <br>** <br>** Return Value: <br>**    void <br>** <br>** Comments: <br>** <br>*************************************************************************/ <br> <br>STDAPI_(void) OleStdGetDocProperty( <br>      LPSUMINFO       lp, <br>      DWORD FAR*      nPage, <br>      DWORD FAR*      nWords, <br>      DWORD FAR*      nChars <br>) <br>{ <br>STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   *nPage=0; *nWords=0; *nChars=0; <br>   if (lpSSIM-&gt;rgInts[0].vtType == VT_I4) *nPage = lpSSIM-&gt;rgInts[0].value; <br>   if (lpSSIM-&gt;rgInts[1].vtType == VT_I4) *nWords = lpSSIM-&gt;rgInts[1].value; <br>   if (lpSSIM-&gt;rgInts[2].vtType == VT_I4) *nChars = lpSSIM-&gt;rgInts[2].value; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdSetDocProperty <br>** <br>** Purpose: <br>**    Set document properties (no. pages, no. words, no. characters) <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD nPage                   - number of pages in document <br>**    DWORD nWords                  - number of words in document <br>**    DWORD nChars                  - number of charactrs in doc <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>**                                    (there are no errors) <br>** <br>** Comments: <br>** <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdSetDocProperty( <br>      LPSUMINFO       lp, <br>      DWORD           nPage, <br>      DWORD           nWords, <br>      DWORD           nChars <br>) <br>{ <br>DWORD vttype=VT_I4; <br>STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   if ((nPage|nWords|nChars)==0) { <br>      vttype = VT_EMPTY; <br>      nPage=0; nWords=0; nChars=0; <br>   } <br>   lpSSIM-&gt;rgInts[0].vtType = vttype; <br>   lpSSIM-&gt;rgInts[1].vtType = vttype; <br>   lpSSIM-&gt;rgInts[2].vtType = vttype; <br>   lpSSIM-&gt;rgInts[0].value = nPage; <br>   lpSSIM-&gt;rgInts[1].value = nWords; <br>   lpSSIM-&gt;rgInts[2].value = nChars; <br>   return 1; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetThumbNailProperty <br>** <br>** Purpose: <br>**    Retrieve a Thumbnail Property <br>** <br>** Parameters: <br>**    LPSTREAM lps <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD FAR* clipFormatNo       - clipboard format for thumbnail <br>**                                      (type of value depends on vtcf <br>**                                      return value.) <br>**                                      NOTE: ONLY VT_CF_WIN is <br>**                                      implemented, so clipFormatNo <br>**                                      will be CF_METAFILEPICT <br>**    LPSTR FAR* lpszName           - format name if VT_CF_NAME is <br>**                                      returned <br>**                                      NOTE: NOT IMPLEMENTED <br>**    THUMBNAIL FAR* clip           - handle to thumbnail <br>**                                      for VT_CF_WIN clip will be <br>**                                      handle to MetafilePict <br>**                                      NOTE: only VT_CF_WIN IMPLEMENTED <br>**    DWORD FAR* byteCount          - size of thumbnail stream <br>**                                      for VT_CF_WIN case this should <br>**                                      be combined size of both the <br>**                                      Metafile as well as the <br>**                                      MetafilePict structure. <br>**    BOOL transferClip             - transfer ownership of thumbnail <br>**                                      to caller. (see comment) <br>** <br>** Return Value: <br>**    int vtcfNo                    - OLE thumbnail selector value <br>**      VT_CF_WIN                   - Windows thumbnail <br>**                                      (interpret clipFormatNo as <br>**                                      Windows clipboard format) <br>**      VT_CF_FMTID                 - (NOT IMPLEMENTED) <br>**                                      thumbnail format is specified <br>**                                      by ID. use clipFormatNo. <br>**                                      (but NOT a Windows format ID) <br>** <br>**      VT_CF_NAME                  - (NOT IMPLEMENTED) <br>**                                      thumbnail format is specified <br>**                                      by name. use lpszName. <br>**      VT_CF_EMPTY                 - blank thumbnail <br>**                                      (clip will be NULL) <br>**      VT_CF_OOM                   - Memory allocation failure <br>** <br>** Comments: <br>**    NOTE: Currently there is only proper support for VT_CF_WIN. <br>**    OleStdSetThumbNailProperty does implement VT_CF_FMTID and VT_CF_NAME, <br>**    however, OleStdGetThumbNailProperty, OleStdReadSummaryInfo and <br>**    OleStdWriteSummaryInfo only support VT_CF_WIN. <br>** <br>**    Note that on input, the thumbnail is read on demand while all the <br>**    other properties are pre-loaded.  The thumbnail is manipulated as <br>**    a windows handle to a METAFILEPICT structure, which in turn <br>**    contains a handle to the METAFILE.  The transferClip argument on <br>**    GetThumbNail, when set to true, transfers responsibility for <br>**    storage management of the thumbnail to the caller; that is, after <br>**    OleStdFreeSummaryInfo has been called, the handle is still valid. <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdGetThumbNailProperty( <br>      LPSTREAM        lps, <br>      LPSUMINFO       lp, <br>      DWORD FAR*      clipFormatNo, <br>      LPOLESTR FAR*   lpszName, <br>      THUMBNAIL FAR*  clip, <br>      DWORD FAR*      byteCount, <br>      BOOL            transferClip <br>) <br>{ <br>   int i; <br>   LPRSI lprsi=(LPRSI)lp; <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   ULONG cbRead, cbToRead; <br>   LARGE_INTEGER a; <br>   ULARGE_INTEGER b; <br>   LPOLESTR lpst; <br>   LPMETAFILEPICT lpmfp; <br>   HANDLE hst, hmfp; <br>   SCODE sc; <br>   *byteCount = 0; <br>   if (lpSSIM-&gt;thumb.cBytes==0) return VT_CF_EMPTY; <br>   if (lpSSIM-&gt;thumb.lpByte==NULL) { <br>      LISet32(a, lprsi-&gt;fileOffset); <br>      sc = GetScode(lps-&gt;Seek(a, STREAM_SEEK_SET, &amp;b)); <br>      if (FAILED(sc)) return VT_CF_EMPTY; <br>      i = (int) lpSSIM-&gt;thumb.selector; <br>      if (i&gt;0||i==VT_CF_FMTID) { <br>         if (i&gt;255) return VT_CF_EMPTY; <br>         else if (i==VT_CF_FMTID) i = sizeof(FMTID); <br>         else lpSSIM-&gt;thumb.selector = (DWORD) VT_CF_NAME; <br>         cbToRead = ((i+3)&gt;&gt;2)&lt;&lt;2; <br>         lpSSIM-&gt;thumb.lpstzName=(LPOLESTR)MemAlloc(i+1/*n*/+1); <br>         if (lpSSIM-&gt;thumb.lpstzName==NULL) return VT_CF_OOM; <br>         sc = GetScode(lps-&gt;Read(lpSSIM-&gt;thumb.lpstzName+1, cbToRead, &amp;cbRead)); <br>         if (FAILED(sc)||cbRead!=cbToRead) return VT_CF_EMPTY; <br>         *lpSSIM-&gt;thumb.lpstzName = i; <br>         *(lpSSIM-&gt;thumb.lpstzName+i) = 0; <br>         lpSSIM-&gt;thumb.cBytes -= cbToRead+sizeof(DWORD); <br>      } <br>      i = (int) lpSSIM-&gt;thumb.selector; <br>      cbToRead = lpSSIM-&gt;thumb.cBytes; <br>      if (cbToRead&gt;65535) return VT_CF_OOM; <br>      ASSERT(i!=VT_CF_NAME); <br>      if (i==VT_CF_WIN) { <br>         cbToRead -= sizeof(METAFILEPICT); <br>         hmfp = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT)); <br>         if (hmfp==NULL) return VT_CF_OOM; <br>         hst = GlobalAlloc(GMEM_MOVEABLE, cbToRead); <br>         if (hst==NULL) { <br>            GlobalFree(hmfp); <br>            return VT_CF_OOM; <br>         } <br>         lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp); <br>         sc = GetScode(lps-&gt;Read(lpmfp, sizeof(METAFILEPICT), &amp;cbRead)); <br>         if (FAILED(sc)||cbRead!=sizeof(METAFILEPICT)) { <br>            GlobalUnlock(hmfp); <br>            GlobalFree(hmfp); <br>            GlobalFree(hst); <br>            return VT_CF_EMPTY; <br>         } <br>         lpst = (LPOLESTR)GlobalLock(hst); <br>         lpmfp-&gt;hMF = (HMETAFILE)hst; <br>         lpSSIM-&gt;thumb.lpByte = (LPOLESTR)hmfp; <br>      } else { <br>         lpst = (LPOLESTR)MemAlloc((int)cbToRead); <br>         if (lpst==NULL) return VT_CF_OOM; <br>         lpSSIM-&gt;thumb.lpByte = lpst; <br>      } <br>      sc = GetScode(lps-&gt;Read(lpst, cbToRead, &amp;cbRead)); <br>      if (i==VT_CF_WIN) { <br>         GlobalUnlock(hst); <br>         GlobalUnlock(hmfp); <br>      } <br>      if (FAILED(sc)||cbRead!=cbToRead) { <br>         if (i==VT_CF_WIN) { <br>            GlobalFree(hst); <br>            GlobalFree(hmfp); <br>         } else MemFree(lpst); <br>         lpSSIM-&gt;thumb.lpByte = NULL; <br>         if ((i==VT_CF_NAME||i==VT_CF_FMTID)&amp;&amp;(lpSSIM-&gt;thumb.lpstzName!=NULL)) <br>            MemFree(lpSSIM-&gt;thumb.lpstzName); <br>         return VT_CF_EMPTY; <br>      } <br>   } <br>   *clipFormatNo = lpSSIM-&gt;thumb.clipFormat; <br>   *byteCount = lpSSIM-&gt;thumb.cBytes; <br>   if(lpszName!=NULL) <br>      *lpszName = (LPOLESTR)lpSSIM-&gt;thumb.lpstzName+1; <br>   *clip = (char FAR*)lpSSIM-&gt;thumb.lpByte; <br>   if (transferClip) lpSSIM-&gt;thumb.lpByte=NULL; <br>   return (int)lpSSIM-&gt;thumb.selector; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdSetThumbNailProperty <br>** <br>** Purpose: <br>**    Set a Thumbnail Property <br>** <br>** Parameters: <br>**    LPSTREAM lps                  - open SummaryInfo IStream* <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    int vtcfNo                    - OLE thumbnail selector value <br>**          VT_CF_WIN                   - Windows thumbnail <br>**                                        (interpret clipFormatNo as <br>**                                        Windows clipboard format) <br>**          VT_CF_FMTID                 - thumbnail format is specified <br>**                                        by ID. use clipFormatNo. <br>**                                        (but NOT a Windows format ID) <br>** <br>**          VT_CF_NAME                  - thumbnail format is specified <br>**                                        by name. use lpszName. <br>**          VT_CF_EMPTY                 - blank thumbnail <br>**                                        (clip will be NULL) <br>** <br>**    DWORD FAR* clipFormatNo       - clipboard format for thumbnail <br>**                                      used if vtcfNo is VT_CF_WIN or <br>**                                      VT_CF_FMTID. interpretation of <br>**                                      value depends on vtcfNo specified. <br>**                                      (normally vtcfNo==VT_CF_WIN and <br>**                                      clipFormatNo==CF_METAFILEPICT) <br>**    LPSTR FAR* lpszName           - format name if vtcfNo is VT_CF_NAME <br>**    THUMBNAIL clip                - handle to thumbnail <br>**                                      for VT_CF_WIN clip will be <br>**                                      handle to MetafilePict <br>**    DWORD FAR* byteCount          - size of thumbnail stream <br>**                                      for VT_CF_WIN case this should <br>**                                      be combined size of both the <br>**                                      Metafile as well as the <br>**                                      MetafilePict structure. <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>** <br>** Comments: <br>**    NOTE: Currently there is only proper support for VT_CF_WIN. <br>**    OleStdSetThumbNailProperty does implement VT_CF_FMTID and VT_CF_NAME, <br>**    however, OleStdGetThumbNailProperty, OleStdReadSummaryInfo and <br>**    OleStdWriteSummaryInfo only support VT_CF_WIN. <br>** <br>**    This function copies lpszName but saves the "clip" handle passed. <br>** <br>**    NOTE: overwriting or emptying frees space for clip and name. <br>**    The thumbnail is manipulated as a windows handle to a <br>**    METAFILEPICT structure, which in turn contains a handle to the <br>**    METAFILE. <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdSetThumbNailProperty( <br>      LPSTREAM        lps, <br>      LPSUMINFO       lp, <br>      int             vtcfNo, <br>      DWORD           clipFormatNo, <br>      LPOLESTR        lpszName, <br>      THUMBNAIL       clip, <br>      DWORD           byteCount <br>) <br>{ <br>   int i; <br>   LPRSI lprsi=(LPRSI)lp; <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   LPMETAFILEPICT lpmfp; <br>   if (lpSSIM==NULL||vtcfNo&gt;0||vtcfNo&lt;VT_CF_EMPTY||(vtcfNo==VT_CF_NAME&amp;&amp;(lpszName==NULL||*lpszName==0))) { <br>      return 0; <br>   } <br>   if (vtcfNo!=VT_CF_EMPTY&amp;&amp;(clip==0||byteCount==0)) return 0; <br>   i = (int) lpSSIM-&gt;thumb.vtType; <br>   if (i!=VT_EMPTY) { <br>      i = (int) lpSSIM-&gt;thumb.selector; <br>      ASSERT(i!=VT_CF_NAME); <br>      if (i==VT_CF_WIN) { <br>         if (lpSSIM-&gt;thumb.lpByte!=NULL) { <br>            lpmfp = (LPMETAFILEPICT)GlobalLock((HANDLE)(DWORD)lpSSIM-&gt;thumb.lpByte); <br>            GlobalFree(lpmfp-&gt;hMF); <br>            GlobalUnlock((HANDLE)(DWORD)lpSSIM-&gt;thumb.lpByte); <br>            GlobalFree((HANDLE)(DWORD)lpSSIM-&gt;thumb.lpByte); <br>         } <br>      } else { <br>         MemFree(lpSSIM-&gt;thumb.lpByte); <br>      } <br>      if ((i==VT_CF_NAME||i==VT_CF_FMTID)&amp;&amp;(lpSSIM-&gt;thumb.lpstzName!=NULL)) <br>         MemFree(lpSSIM-&gt;thumb.lpstzName); <br>      lpSSIM-&gt;thumb.lpstzName = NULL; <br>      lpSSIM-&gt;thumb.lpByte = NULL; <br>   } <br>   if (vtcfNo==VT_CF_EMPTY) { <br>      lpSSIM-&gt;thumb.vtType = VT_EMPTY; <br>      lpSSIM-&gt;thumb.cBytes = 0; <br>   } else { <br>      lpSSIM-&gt;thumb.vtType = VT_CF; <br>      lpSSIM-&gt;thumb.selector = vtcfNo; <br>      lpSSIM-&gt;thumb.cBytes = byteCount; <br>      lpSSIM-&gt;thumb.clipFormat = clipFormatNo; <br>      lpSSIM-&gt;thumb.lpByte = (LPOLESTR)clip;    //just save the hnadle <br>      if (vtcfNo==VT_CF_NAME||vtcfNo==VT_CF_FMTID) { <br>         i = OLESTRLEN(lpszName); <br>         if (vtcfNo==VT_CF_FMTID) ASSERT(i==sizeof(FMTID)); <br>         lpSSIM-&gt;thumb.lpstzName = <br>            (LPOLESTR)MemAlloc(i+1/*n*/+1/*null*/); <br>         if (lpSSIM-&gt;thumb.lpstzName==NULL) { <br>            lpSSIM-&gt;thumb.vtType = VT_EMPTY; <br>            return 0; <br>         } <br>         W2A (lpszName, (char FAR*)lpSSIM-&gt;thumb.lpstzName+1, sizeof(lpSSIM-&gt;thumb.lpstzName+1)); <br>         *lpSSIM-&gt;thumb.lpstzName = i; <br>      } <br>   } <br>   return 1; <br>} <br> <br> <br>/************************************************************************* <br>** <br>** OleStdGetDateProperty <br>** <br>** Purpose: <br>**    Retrieve Data Property <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD pid                     - ID of Property <br>**    int FAR *yr                   - (OUT) year <br>**    int FAR *mo                   - (OUT) month <br>**    int FAR *dy                   - (OUT) day <br>**    DWORD FAR *sc                 - (OUT) seconds <br>** <br>** Return Value: <br>**    void <br>** <br>** Comments: <br>** <br>*************************************************************************/ <br> <br>STDAPI_(void) OleStdGetDateProperty( <br>      LPSUMINFO       lp, <br>      DWORD           pid, <br>      int FAR*        yr, <br>      int FAR*        mo, <br>      int FAR*        dy, <br>      DWORD FAR*      sc <br>) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   SFFS sffs; <br>   pid -= PIDSI_EDITTIME; <br>   *yr = 0; *mo = 0; *dy = 0; *sc = 0; <br>   if (pid&lt;0||pid&gt;=MAXTIME) return; <br>   if (lpSSIM-&gt;rgTime[pid].vtType == VT_FILETIME) { <br>      if (pid==0) { <br>         //convert from 100ns to seconds <br>         ulargeDivide((ULARGE_INTEGER FAR*)&amp;lpSSIM-&gt;rgTime[0].time, 10000); <br>         ulargeDivide((ULARGE_INTEGER FAR*)&amp;lpSSIM-&gt;rgTime[0].time, 1000); <br>         pid = lpSSIM-&gt;rgTime[0].time.dwLowDateTime; <br>         *sc = pid%((DWORD)60*60*24); <br>         pid /= (DWORD)60*60*24; <br>         *dy = (int)(pid%(DWORD)30); <br>         pid /= (DWORD)30; <br>         *mo = (int)(pid%(DWORD)12); <br>         *yr = (int)(pid/(DWORD)12); <br>      } else { <br>         if (CoFileTimeToDosDateTime(&amp;lpSSIM-&gt;rgTime[pid].time, <br>                  &amp;sffs.dateVariable, &amp;sffs.timeVariable)) { <br>            *yr = sffs.yr+1980; <br>            *mo = sffs.mon; <br>            *dy = sffs.dom; <br>            *sc = (DWORD)sffs.hr*3600+sffs.mint*60+sffs.sec*2; <br>         } <br>      } <br>   } <br>   return; <br>} <br> <br> <br> <br>/************************************************************************* <br>** <br>** OleStdSetDateProperty <br>** <br>** Purpose: <br>**    Set Data Property <br>** <br>** Parameters: <br>**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct <br>**    DWORD pid                     - ID of Property <br>**    int yr                        - year <br>**    int mo                        - month <br>**    int dy                        - day <br>**    DWORD sc                      - seconds <br>** <br>** Return Value: <br>**    int                           - 1 for success <br>**                                  - 0 if error occurs <br>** <br>** Comments: <br>**    Use all zeros to clear. <br>**    The following is an example of valid input: <br>**          yr=1993 mo=1(Jan) dy=1(1st) hr=12(noon) mn=30 sc=23 <br>**    for PIDSI_EDITTIME property, the values are a zero-origin duration <br>**    of time. <br>** <br>*************************************************************************/ <br> <br>STDAPI_(int) OleStdSetDateProperty( <br>      LPSUMINFO       lp, <br>      DWORD           pid, <br>      int             yr, <br>      int             mo, <br>      int             dy, <br>      int             hr, <br>      int             mn, <br>      int             sc <br>) <br>{ <br>   STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&amp;((LPRSI)lp)-&gt;section; <br>   SFFS sffs; <br>   pid -= PIDSI_EDITTIME; <br>   if (pid&lt;0||pid&gt;=MAXTIME) return 0; <br>   if ((yr|mo|dy|hr|mn|sc)==0) {   //all must be zero <br>      lpSSIM-&gt;rgTime[pid].vtType = VT_EMPTY; <br>      return 1; <br>   } <br>   lpSSIM-&gt;rgTime[pid].vtType = VT_FILETIME; <br>   if (pid==0) { <br>      lpSSIM-&gt;rgTime[0].time.dwLowDateTime = <br>            (((((DWORD)yr*365+mo*30)+dy)*24+hr)*60+mn)*60+sc; <br>      lpSSIM-&gt;rgTime[0].time.dwHighDateTime = 0; <br>      //10^7 nanoseconds/second <br>      ulargeMultiply((ULARGE_INTEGER FAR*)&amp;lpSSIM-&gt;rgTime[0].time, 10000); <br>      //convert to units of 100 ns <br>      ulargeMultiply((ULARGE_INTEGER FAR*)&amp;lpSSIM-&gt;rgTime[0].time, 1000); <br>   } else { <br>      sffs.yr = max(yr-1980,0); <br>      sffs.mon = mo; <br>      sffs.dom = dy; <br>      sffs.hr = hr; <br>      sffs.mint= mn; <br>      sffs.sec = sc/2;  //dos is 2 second intervals <br>      if (!CoDosDateTimeToFileTime(sffs.date, sffs.time, <br>            &amp;lpSSIM-&gt;rgTime[pid].time)) { <br>         lpSSIM-&gt;rgTime[pid].vtType = VT_EMPTY; <br>         return 0; <br>      } <br>   } <br>   return 1; <br>} <br> <br>} //END C </code></pre>
<p>&nbsp;</p></body>
</HTML>
