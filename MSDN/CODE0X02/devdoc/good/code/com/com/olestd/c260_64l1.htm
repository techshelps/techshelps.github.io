<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SUMINFO.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context265"></a>SUMINFO.H</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2.0 Property Set Utilities <br>** <br>**    suminfo.h <br>** <br>**    This file contains file contains data structure defintions, <br>**    function prototypes, constants, etc. for OLE 2.0 Property Set <br>**    utilities used to manage the Summary Info property set. <br>** <br>**    (c) Copyright Microsoft Corp. 1990 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#ifndef SUMINFO_H <br>#define SUMINFO_H <br> <br>#include &lt;ole2.h&gt; <br>#include &lt;oleauto.h&gt; <br> <br>/* A SUMINFO variable is an instance of an abstract data type.  Thus, <br>**    there can be an arbitrary number of SummaryInfo streams open <br>**    simultaneously (subject to available memory).  Each variable must <br>**    be initialized prior to use by calling Init and freed after its <br>**    last use by calling Free.  The param argument to Init is reserved <br>**    for future expansion and should be zero initially. Once a SUMINFO <br>**    variable is allocated (by Init), the user can call the Set <br>**    procedures to initialize fields.  A copy of the arguments is made <br>**    in every case except SetThumbnail where control of the storage <br>**    occupied by the METAFILEPICT is merely transferred.  When the <br>**    Free routine is called, all storage will be deallocated including <br>**    that of the thumbnail.  The arguments to SetThumbNail and the <br>**    return values from GetThumbNail correspond to the OLE2.0 spec. <br>**    Note that on input, the thumbnail is read on demand but all the <br>**    other properties are pre-loaded.  The thumbnail is manipulated as <br>**    a windows handle to a METAFILEPICT structure, which in turn <br>**    contains a handle to the METAFILE.  The transferClip argument on <br>**    GetThumbNail, when set to true, transfers responsibility for <br>**    storage management of the thumbnail to the caller; that is, after <br>**    Free has been called, the handle is still valid. Clear can be <br>**    used to free storage for all the properties but then you must <br>**    call Read to load them again.  All the code is based on FAR <br>**    pointers. <br>**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo. <br>**    Memory is allocated using the currently active IMalloc* <br>**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ). <br>** <br>** Common scenarios: <br>**    Read SummaryInfo <br>**    ---------------- <br>**      OleStdInitSummaryInfo() <br>**      OleStdReadSummaryInfo() <br>**      . . . . . <br>**      call different Get routines <br>**      . . . . . <br>**      OleStdFreeSummaryInfo() <br>** <br>**    Create SummaryInfo <br>**    ------------------ <br>**      OleStdInitSummaryInfo() <br>**      call different Set routines <br>**      OleStdWriteSummaryInfo() <br>**      OleStdFreeSummaryInfo() <br>** <br>**    Update SummaryInfo <br>**    ------------------ <br>**      OleStdInitSummaryInfo() <br>**      OleStdReadSummaryInfo() <br>**      OleStdGetThumbNailProperty(necessary only if no SetThumb) <br>**      call different Set routines <br>**      OleStdWriteSummaryInfo() <br>**      OleStdFreeSummaryInfo() <br>*/ <br> <br>#define WORDMAX 256     //current string max for APPS; 255 + null terminator <br> <br>typedef     union { <br>     short    iVal;             /* VT_I2                */ <br>     long     lVal;             /* VT_I4                */ <br>     float    fltVal;           /* VT_R4                */ <br>     double       dblVal;       /* VT_R8                */ <br>     DWORD bool;                /* VT_BOOL              */ <br>     SCODE    scodeVal;         /* VT_ERROR             */ <br>     DWORD    systimeVal;       /* VT_SYSTIME           */ <br>     unsigned char bstrVal[WORDMAX]; /* VT_BSTR              */ <br>   } VTUNION; <br> <br>typedef struct _PROPSETLIST <br>   { <br>   FMTID formatID; <br>   DWORD byteOffset; <br>   } PROPSETLIST; <br> <br>typedef struct _PROPIDLIST <br>   { <br>   DWORD propertyID; <br>   DWORD byteOffset; <br>   } PROPIDLIST; <br> <br>typedef struct _PROPVALUE <br>   { <br>   DWORD vtType; <br>   VTUNION vtValue; <br>   } PROPVALUE; <br> <br>typedef struct _SECTION <br>   { <br>   DWORD cBytes; <br>   DWORD cProperties; <br>   PROPIDLIST rgPropId[1/*cProperties*/];  //variable-length array <br>   PROPVALUE rgPropValue[1];      //CANNOT BE ACCESSED BY NAME; ONLY BY POINTER <br>   } SECTION; <br> <br>typedef struct _SUMMARYINFO <br>   { <br>   WORD byteOrder; <br>   WORD formatVersion; <br>   WORD getOSVersion; <br>   WORD osVersion; <br>   CLSID classId;  //from compobj.h <br>   DWORD cSections; <br>   PROPSETLIST rgPropSet[1/*cSections*/]; //variable-length array <br>   SECTION rgSections[1/*cSections*/];    //CANNOT BE ACCESSED BY NAME; ONLY BY POINTER <br>   } SUMMARYINFO; <br> <br>#define osWinOnDos 0 <br>#define osMac 1 <br>#define osWinNT 2 <br> <br>#define cPIDSI_STANDARD (PIDSI_DOC_SECURITY+1-2) <br> <br>#ifndef WIN32 <br>#define MAXWORD 256         //maximum string size for APPS at present <br>#endif <br> <br>typedef struct _STDZ <br>   { <br>   DWORD vtType; <br>   union { <br>   DWORD vtByteCount; <br>   OLECHAR fill[4];  //use last byte as byte count for stz requests <br>   }; <br>   OLECHAR rgchars[MAXWORD]; <br>   } STDZ; <br>#define VTCB fill[3]    //used to set/get the count byte when in memory <br> <br>typedef struct _THUMB <br>   { <br>   DWORD vtType; <br>   DWORD cBytes;       //clip size in memory <br>   DWORD selector;     //on disk -1,win clip no.  -2,mac clip no. -3,ole FMTID  0,bytes  nameLength, format name <br>   DWORD clipFormat; <br>   LPOLESTR lpstzName; <br>   LPOLESTR lpByte; <br>   } THUMB; <br> <br>#define VT_CF_BYTES 0 <br>#define VT_CF_WIN (-1) <br>#define VT_CF_MAC (-2) <br>#define VT_CF_FMTID (-3) <br>#define VT_CF_NAME (-4) <br>#define VT_CF_EMPTY (-5) <br>#define VT_CF_OOM (-6)      // Out of memory <br>typedef THUMB FAR *LPTHUMB; <br> <br>typedef STDZ FAR *LPSTDZ; <br> <br>typedef struct _TIME <br>   { <br>   DWORD vtType; <br>   FILETIME time; <br>   } TIME; <br> <br>typedef struct _INTS <br>   { <br>   DWORD vtType; <br>   DWORD value; <br>   } INTS; <br> <br>#define MAXTIME (PIDSI_LASTSAVE_DTM-PIDSI_EDITTIME+1) <br>#define MAXINTS (PIDSI_CHARCOUNT-PIDSI_PAGECOUNT+1+1) <br>#define MAXSTDZ (PIDSI_REVNUMBER-PIDSI_TITLE+1+1) <br> <br>typedef struct _STANDARDSECINMEM <br>   { <br>   DWORD cBytes; <br>   DWORD cProperties; <br>   PROPIDLIST rgPropId[cPIDSI_STANDARD/*cProperties*/];  //variable-length array <br>   TIME rgTime[MAXTIME]; <br>   INTS rgInts[MAXINTS]; <br>   LPSTDZ rglpsz[MAXSTDZ]; <br>   THUMB thumb; <br>   } STANDARDSECINMEM; <br> <br> <br>#define OFFSET_NIL 0X00000000 <br> <br>#define AllSecurityFlagsEqNone 0 <br>#define fSecurityPassworded 1 <br>#define fSecurityRORecommended 2 <br>#define fSecurityRO 4 <br>#define fSecurityLockedForAnnotations 8 <br> <br>#define PropStreamNamePrefixByte '\005' <br>#define PropStreamName "\005SummaryInformation" <br>#define cbNewSummaryInfo(nSection) (sizeof(SUMMARYINFO)-sizeof(SECTION)+sizeof(PROPSETLIST)*((nSection)-1)) <br>#define cbNewSection(nPropIds) (sizeof(SECTION)-sizeof(PROPVALUE)+sizeof(PROPIDLIST)*((nPropIds)-1)) <br> <br>#define FIntelOrder(prop) ((prop)-&gt;byteOrder==0xfffe) <br>#define SetOs(prop, os) {(prop)-&gt;osVersion=os; (prop)-&gt;getOSVersion=LOWORD(GetVersion());} <br>#define SetSumInfFMTID(fmtId) {(fmtId)-&gt;Data1=0XF29F85E0; *(long FAR *)&amp;(fmtId)-&gt;Data2=0X10684FF9;\ <br>            *(long FAR *)&amp;(fmtId)-&gt;Data4[0]=0X000891AB; *(long FAR *)&amp;(fmtId)-&gt;Data4[4]=0XD9B3272B;} <br>#define FEqSumInfFMTID(fmtId) ((fmtId)-&gt;dword==0XF29F85E0&amp;&amp;*((long FAR *)&amp;(fmtId)-&gt;words)==0X10684FF9&amp;&amp;\ <br>            *((long FAR *)&amp;(fmtId)-&gt;bytes[0])==0X000891AB&amp;&amp;*((long FAR *)&amp;(fmtId)-&gt;bytes[4])==0XD9B3272B) <br>#define FSzEqPropStreamName(sz) _fstricmp(sz, PropStreamName) <br>#define ClearSumInf(lpsuminf, cb) {_fmemset(lpsuminf,0,cb); (lpsuminf)-&gt;byteOrder=0xfffe;\ <br>            SetOs(lpsuminf, osWinOnDos);} <br> <br>typedef void FAR *LPSUMINFO; <br>typedef LPSTR LPSTZR; <br>typedef void FAR *THUMBNAIL;  //for VT_CF_WIN this is an unlocked global handle <br>#define API __far __pascal <br> <br> <br>/************************************************************************* <br>** Public Summary Info Property Set Management API <br>*************************************************************************/ <br> <br>extern "C" { <br>STDAPI_(LPSUMINFO) OleStdInitSummaryInfo(int reserved); <br>STDAPI_(void) OleStdFreeSummaryInfo(LPSUMINFO FAR *lplp); <br>STDAPI_(void) OleStdClearSummaryInfo(LPSUMINFO lp); <br>STDAPI_(int) OleStdReadSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp); <br>STDAPI_(int) OleStdWriteSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp); <br>STDAPI_(DWORD) OleStdGetSecurityProperty(LPSUMINFO lp); <br>STDAPI_(int) OleStdSetSecurityProperty(LPSUMINFO lp, DWORD security); <br>STDAPI_(LPSTR) OleStdGetStringProperty(LPSUMINFO lp, DWORD pid); <br>STDAPI_(int) OleStdSetStringProperty(LPSUMINFO lp, DWORD pid, LPOLESTR lpsz); <br>STDAPI_(LPSTZR) OleStdGetStringZProperty(LPSUMINFO lp, DWORD pid); <br>STDAPI_(void) OleStdGetDocProperty( <br>      LPSUMINFO       lp, <br>      DWORD FAR*      nPage, <br>      DWORD FAR*      nWords, <br>      DWORD FAR*      nChars <br>); <br>STDAPI_(int) OleStdSetDocProperty( <br>      LPSUMINFO       lp, <br>      DWORD           nPage, <br>      DWORD           nWords, <br>      DWORD           nChars <br>); <br>STDAPI_(int) OleStdGetThumbNailProperty( <br>      LPSTREAM        lps, <br>      LPSUMINFO       lp, <br>      DWORD FAR*      clipFormatNo, <br>      LPOLESTR FAR*   lpszName, <br>      THUMBNAIL FAR*  clip, <br>      DWORD FAR*      byteCount, <br>      BOOL            transferClip <br>); <br>STDAPI_(int) OleStdSetThumbNailProperty( <br>      LPSTREAM        lps, <br>      LPSUMINFO       lp, <br>      int             vtcfNo, <br>      DWORD           clipFormatNo, <br>      LPOLESTR        lpszName, <br>      THUMBNAIL       clip, <br>      DWORD           byteCount <br>); <br>STDAPI_(void) OleStdGetDateProperty( <br>      LPSUMINFO       lp, <br>      DWORD           pid, <br>      int FAR*        yr, <br>      int FAR*        mo, <br>      int FAR*        dy, <br>      DWORD FAR*      sc <br>); <br>STDAPI_(int) OleStdSetDateProperty( <br>      LPSUMINFO       lp, <br>      DWORD           pid, <br>      int             yr, <br>      int             mo, <br>      int             dy, <br>      int             hr, <br>      int             mn, <br>      int             sc <br>); <br> <br>} //END C <br> <br>/************************************************************************* <br>** DEBUG ASSERTION ROUTINES <br>*************************************************************************/ <br> <br>#if DBG <br>#include &lt;assert.h&gt; <br>#define FnAssert(lpstrExpr, lpstrMsg, lpstrFileName, iLine)     \ <br>        (_assert(lpstrMsg ? lpstrMsg : lpstrExpr,               \ <br>                 lpstrFileName,                                 \ <br>                 iLine), NOERROR) <br>#endif //DBG <br> <br>#endif  // SUMINFO_H </code></pre>
<p>&nbsp;</p></body>
</HTML>
