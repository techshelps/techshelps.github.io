<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSGFILTR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context255"></a>MSGFILTR.C</h2>
<pre><code>/* <br> *    MSGFILTR.C <br> * <br> *    This file contains a standard implementation of IMessageFilter <br> *    interface. <br> *    This file is part of the OLE 2.0 User Interface support library. <br> * <br> *    (c) Copyright Microsoft Corp. 1990 - 1996 All Rights Reserved <br> * <br> */ <br> <br> <br>#define STRICT  1 <br>#include "olestd.h" <br>#include "msgfiltr.h" <br> <br>OLEDBGDATA <br> <br> <br>typedef struct tagOLESTDMESSAGEFILTER { <br>   IMessageFilterVtbl FAR* m_lpVtbl; <br>   UINT                    m_cRef; <br>   HWND                    m_hWndParent; <br>   DWORD                   m_dwInComingCallStatus; // Status to return from <br>                                       // HandleIncomingCall <br>   HANDLEINCOMINGCALLBACKPROC m_lpfnHandleInComingCallback; <br>                                       // Callback function <br>                                       // to selectively handle <br>                                       // interface method calls <br>   BOOL                    m_fEnableBusyDialog;    // enable RetryRejected <br>                                       //  Call dialog <br>   BOOL                    m_fEnableNotRespondingDialog; // enable <br>                                       // MessagePending dialog <br>   MSGPENDINGPROC          m_lpfnMessagePendingCallback; // MessagePending <br>                                       // Callback function <br>   LPFNOLEUIHOOK           m_lpfnBusyDialogHookCallback; // Busy dialog hook <br>   LPOLESTR                m_lpszAppName;          // Name of application <br>                                       // installing filter <br>   HWND                    m_hWndBusyDialog;       // HWND of busy dialog.  Used <br>                                       // to tear down dialog. <br>   BOOL                    m_bUnblocking; <br> <br> }OLESTDMESSAGEFILTER, FAR* LPOLESTDMESSAGEFILTER; <br> <br>/* interface IMessageFilter implementation */ <br>STDMETHODIMP OleStdMsgFilter_QueryInterface( <br>      LPMESSAGEFILTER lpThis, REFIID riid, LPVOID FAR* ppvObj); <br>STDMETHODIMP_(ULONG) OleStdMsgFilter_AddRef(LPMESSAGEFILTER lpThis); <br>STDMETHODIMP_(ULONG) OleStdMsgFilter_Release(LPMESSAGEFILTER lpThis); <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_HandleInComingCall ( <br>      LPMESSAGEFILTER     lpThis, <br>      DWORD               dwCallType, <br>      HTASK               htaskCaller, <br>      DWORD               dwTickCount, <br>      LPINTERFACEINFO     dwReserved <br>); <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_RetryRejectedCall ( <br>      LPMESSAGEFILTER     lpThis, <br>      HTASK               htaskCallee, <br>      DWORD               dwTickCount, <br>      DWORD               dwRejectType <br>); <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_MessagePending ( <br>      LPMESSAGEFILTER     lpThis, <br>      HTASK               htaskCallee, <br>      DWORD               dwTickCount, <br>      DWORD               dwPendingType <br>); <br> <br> <br>static IMessageFilterVtbl g_OleStdMessageFilterVtbl = { <br>   OleStdMsgFilter_QueryInterface, <br>   OleStdMsgFilter_AddRef, <br>   OleStdMsgFilter_Release, <br>   OleStdMsgFilter_HandleInComingCall, <br>   OleStdMsgFilter_RetryRejectedCall, <br>   OleStdMsgFilter_MessagePending <br>}; <br> <br> <br>/* GetTopWindowInWindowsTask <br>** ------------------------- <br>**    Get the top most window that has focus in the given task to be <br>**    used as the parent for the busy dialog. we do this to handle the <br>**    case where a dialog window is currently up when we need to give <br>**    the busy dialog. if we use the current assigned parent window <br>**    (which typically will be the frame window of the app), then the <br>**    busy dialog will not be modal to the current active dialog <br>**    window. <br>*/ <br>static HWND GetTopWindowInWindowsTask(HWND hwnd) <br>{ <br>   HWND hwndActive = GetActiveWindow(); <br>   if (!hwndActive) <br>      return hwnd; <br> <br>   if (GetWindowTask(hwnd) == GetWindowTask(hwndActive)) <br>      return hwndActive; <br>   else <br>      return hwnd; <br>} <br> <br>STDAPI_(LPMESSAGEFILTER) OleStdMsgFilter_Create( <br>      HWND            hWndParent, <br>      LPOLESTR           szAppName, <br>      MSGPENDINGPROC  lpfnCallback, <br>      LPFNOLEUIHOOK   lpfnOleUIHook         // Busy dialog hook callback <br>) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter; <br>   LPMALLOC lpMalloc; <br> <br>   if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&amp;lpMalloc) != NOERROR) <br>      return NULL; <br> <br>   lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpMalloc-&gt;lpVtbl-&gt;Alloc( <br>         lpMalloc, (sizeof(OLESTDMESSAGEFILTER))); <br>   lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br>   if (! lpStdMsgFilter) return NULL; <br> <br>   lpStdMsgFilter-&gt;m_lpVtbl = &amp;g_OleStdMessageFilterVtbl; <br>   lpStdMsgFilter-&gt;m_cRef = 1; <br>   lpStdMsgFilter-&gt;m_hWndParent = hWndParent; <br>   lpStdMsgFilter-&gt;m_dwInComingCallStatus = SERVERCALL_ISHANDLED; <br>   lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback = NULL; <br>   lpStdMsgFilter-&gt;m_fEnableBusyDialog = TRUE; <br>   lpStdMsgFilter-&gt;m_fEnableNotRespondingDialog = TRUE; <br>   lpStdMsgFilter-&gt;m_lpszAppName = szAppName; <br>   lpStdMsgFilter-&gt;m_lpfnMessagePendingCallback = lpfnCallback; <br>   lpStdMsgFilter-&gt;m_lpfnBusyDialogHookCallback = lpfnOleUIHook; <br>   lpStdMsgFilter-&gt;m_hWndBusyDialog = NULL; <br>   lpStdMsgFilter-&gt;m_bUnblocking = FALSE; <br> <br>  g_dwObjectCount ++; <br> <br>   return (LPMESSAGEFILTER)lpStdMsgFilter; <br>} <br> <br> <br>/* OleStdMsgFilter_SetInComingStatus <br>** --------------------------------- <br>**    This is a private function that allows the caller to control what <br>**    value is returned from the IMessageFilter::HandleInComing method. <br>** <br>**    if a HandleInComingCallbackProc is installed by a call to <br>**    OleStdMsgFilter_SetHandleInComingCallbackProc, then this <br>**    overrides the dwIncomingCallStatus established by a call to <br>**    OleStdMsgFilter_SetInComingStatus.  Using <br>**    OleStdMsgFilter_SetInComingStatus allows the app to reject or <br>**    accept ALL in coming calls. Using a HandleInComingCallbackProc <br>**    allows the app to selectively handle or reject particular method <br>**    calls. <br>*/ <br> <br>STDAPI_(void) OleStdMsgFilter_SetInComingCallStatus( <br>      LPMESSAGEFILTER lpThis, DWORD dwInComingCallStatus) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br> <br>   if (!IsBadWritePtr((LPVOID)lpStdMsgFilter,  sizeof(OLESTDMESSAGEFILTER))) <br>      lpStdMsgFilter-&gt;m_dwInComingCallStatus = dwInComingCallStatus; <br>   else <br>      OleDbgAssert( <br>         "OleStdMsgFilter_SetIncomingCallStatus: Invalid IMessageFilter*"); <br> <br>#if defined( _DEBUG ) <br>   { <br>   char szBuf[80]; <br>   char *szReturn; <br> <br>   switch(dwInComingCallStatus) { <br>      case SERVERCALL_ISHANDLED: <br>         szReturn = "SERVERCALL_ISHANDLED"; <br>         break; <br>      case SERVERCALL_REJECTED: <br>         szReturn = "SERVERCALL_REJECTED"; <br>         break; <br>      case SERVERCALL_RETRYLATER: <br>         szReturn = "SERVERCALL_RETRYLATER"; <br>         break; <br>      default: <br>         szReturn = "** ERROR: UNKNOWN **"; <br>         break; <br>      } <br>   wsprintf( <br>      szBuf, <br>      "OleStdMsgFilter_SetInComingCallStatus: Status set to %s.\r\n", <br>      /*(LPSTR)*/szReturn <br>   ); <br>   OleDbgOut3(szBuf); <br>   } <br>#endif <br> <br>} <br> <br> <br>/* OleStdMsgFilter_SetHandleInComingCallbackProc <br>** --------------------------------------------- <br>**    This is a private function that allows the caller to install (or <br>**    de-install) a special callback function to selectively <br>**    handle/reject specific incoming method calls on particular <br>**    interfaces. <br>** <br>**    if a HandleInComingCallbackProc is installed by a call to <br>**    OleStdMsgFilter_SetHandleInComingCallbackProc, then this <br>**    overrides the dwIncomingCallStatus established by a call to <br>**    OleStdMsgFilter_SetInComingStatus.  Using <br>**    OleStdMsgFilter_SetInComingStatus allows the app to reject or <br>**    accept ALL in coming calls. Using a HandleInComingCallbackProc <br>**    allows the app to selectively handle or reject particular method <br>**    calls. <br>** <br>**    to de-install the HandleInComingCallbackProc, call <br>**          OleStdMsgFilter_SetHandleInComingCallbackProc(NULL); <br>** <br>**    Returns previous callback proc in effect. <br>*/ <br> <br>STDAPI_(HANDLEINCOMINGCALLBACKPROC) <br>   OleStdMsgFilter_SetHandleInComingCallbackProc( <br>      LPMESSAGEFILTER             lpThis, <br>      HANDLEINCOMINGCALLBACKPROC  lpfnHandleInComingCallback) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   HANDLEINCOMINGCALLBACKPROC    lpfnPrevCallback = <br>         lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback; <br> <br>   if (!IsBadWritePtr((LPVOID)lpStdMsgFilter, sizeof(OLESTDMESSAGEFILTER))) { <br>      lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback = <br>            lpfnHandleInComingCallback; <br>   } else { <br>      OleDbgAssert( <br>         "OleStdMsgFilter_SetIncomingCallStatus: Invalid IMessageFilter*"); <br>   } <br> <br>#if defined( _DEBUG ) <br>   { <br>      if (lpfnHandleInComingCallback) <br>         OleDbgOut3( <br>            "OleStdMsgFilter_SetHandleInComingCallbackProc SET\r\n"); <br>      else <br>         OleDbgOut3( <br>            "OleStdMsgFilter_SetHandleInComingCallbackProc CLEARED\r\n"); <br> <br>   } <br>#endif  // _DEBUG <br> <br>   return lpfnPrevCallback; <br>} <br> <br> <br>/* OleStdMsgFilter_GetInComingStatus <br>** --------------------------------- <br>**    This is a private function that returns the current <br>**    incoming call status.  Can be used to disable/enable options <br>**    in the calling application. <br>** <br>** Returns: one of <br>** <br>**    SERVERCALL_ISHANDLED <br>**    SERVERCALL_REJECTED <br>**    SERVERCALL_RETRYLATER <br>**    or -1 for ERROR <br>** <br>*/ <br> <br>STDAPI_(DWORD) OleStdMsgFilter_GetInComingCallStatus( <br>      LPMESSAGEFILTER lpThis) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   DWORD dwReturn; <br> <br>   if (!IsBadReadPtr((LPVOID)lpStdMsgFilter,  sizeof(OLESTDMESSAGEFILTER))) <br>      dwReturn = lpStdMsgFilter-&gt;m_dwInComingCallStatus; <br>   else <br>      { <br>      OleDbgAssert( <br>         "OleStdMsgFilter_GetIncomingCallStatus: Invalid IMessageFilter*"); <br>      dwReturn = (DWORD)-1; <br>      } <br> <br>#if defined( _DEBUG ) <br>   { <br>   char szBuf[80]; <br>   char *szReturn; <br> <br>   switch(dwReturn) { <br>      case SERVERCALL_ISHANDLED: <br>         szReturn = "SERVERCALL_ISHANDLED"; <br>         break; <br>      case SERVERCALL_REJECTED: <br>         szReturn = "SERVERCALL_REJECTED"; <br>         break; <br>      case SERVERCALL_RETRYLATER: <br>         szReturn = "SERVERCALL_RETRYLATER"; <br>         break; <br>      default: <br>         szReturn = "-1"; <br>         break; <br>      } <br>   wsprintf( <br>      szBuf, <br>      "OleStdMsgFilter_GetInComingCallStatus returns %s.\r\n", <br>      /*(LPSTR)*/szReturn <br>   ); <br>   OleDbgOut3(szBuf); <br>   } <br>#endif <br> <br>   return dwReturn; <br>} <br> <br> <br>/* OleStdMsgFilter_EnableBusyDialog <br>** -------------------------------- <br>**    This function allows the caller to control whether <br>**    the busy dialog is enabled. this is the dialog put up when <br>**    IMessageFilter::RetryRejectedCall is called because the server <br>**    responded SERVERCALL_RETRYLATER or SERVERCALL_REJECTED. <br>** <br>**    if the busy dialog is NOT enabled, then the rejected call is <br>**    immediately canceled WITHOUT prompting the user. in this situation <br>**    OleStdMsgFilter_RetryRejectedCall always retuns <br>**    OLESTDCANCELRETRY canceling the outgoing LRPC call. <br>**    If the busy dialog is enabled, then the user is given the choice <br>**    of whether to retry, switch to, or cancel. <br>** <br>**    Returns previous dialog enable state <br>*/ <br> <br>STDAPI_(BOOL) OleStdMsgFilter_EnableBusyDialog( <br>      LPMESSAGEFILTER lpThis, BOOL fEnable) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   BOOL fPrevEnable = lpStdMsgFilter-&gt;m_fEnableBusyDialog; <br> <br>   if (!IsBadWritePtr((LPVOID)lpStdMsgFilter,  sizeof(OLESTDMESSAGEFILTER))) <br>      lpStdMsgFilter-&gt;m_fEnableBusyDialog = fEnable; <br>   else <br>      OleDbgAssert( <br>            "OleStdMsgFilter_EnableBusyDialog: Invalid IMessageFilter*"); <br> <br>#if defined( _DEBUG ) <br>   { <br>   char szBuf[80]; <br>   wsprintf( <br>      szBuf, <br>      "OleStdMsgFilter_EnableBusyDialog: Dialog is %s.\r\n", <br>      fEnable ? /*(LPSTR)*/"ENABLED" : /*(LPSTR)*/"DISABLED" <br>   ); <br>   OleDbgOut3(szBuf); <br>   } <br>#endif <br> <br>   return fPrevEnable; <br>} <br> <br> <br>/* OleStdMsgFilter_EnableNotRespondingDialog <br>** ----------------------------------------- <br>**    This function allows the caller to control whether <br>**    the app "NotResponding" (Blocked) dialog is enabled. this is the <br>**    dialog put up when IMessageFilter::MessagePending is called. <br>**    If the NotResponding dialog is enabled, then the user is given <br>**    the choice of whether to retry or switch to, but NOT to cancel. <br>** <br>**    Returns previous dialog enable state <br>*/ <br> <br>STDAPI_(BOOL) OleStdMsgFilter_EnableNotRespondingDialog( <br>      LPMESSAGEFILTER lpThis, BOOL fEnable) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   BOOL fPrevEnable = lpStdMsgFilter-&gt;m_fEnableNotRespondingDialog; <br> <br>   if (!IsBadWritePtr((LPVOID)lpStdMsgFilter,  sizeof(OLESTDMESSAGEFILTER))) <br>      lpStdMsgFilter-&gt;m_fEnableNotRespondingDialog = fEnable; <br>   else <br>      OleDbgAssert( <br>            "OleStdMsgFilter_EnableNotRespondingDialog: Invalid IMessageFilter*"); <br> <br>#if defined( _DEBUG ) <br>   { <br>   char szBuf[80]; <br>   wsprintf( <br>      szBuf, <br>      "OleStdMsgFilter_EnableNotRespondingDialog: Dialog is %s.\r\n", <br>      fEnable ? /*(LPSTR)*/"ENABLED" : /*(LPSTR)*/"DISABLED" <br>   ); <br>   OleDbgOut3(szBuf); <br>   } <br>#endif <br> <br>   return fPrevEnable; <br>} <br> <br> <br>/* OleStdMsgFilter_SetParentWindow <br>** ------------------------------- <br>**    This function allows caller to set which window will be used as <br>**    the parent for the busy dialog. <br>** <br>**    NOTE: it would be inportant for an in-place active server to <br>**    reset this to its current in-place frame window when in-place <br>**    activated. if the hWndParent is set to NULL then the dialogs will <br>**    be parented to the desktop. <br>** <br>**    Returns: previous parent window <br>*/ <br> <br>STDAPI_(HWND) OleStdMsgFilter_SetParentWindow( <br>      LPMESSAGEFILTER lpThis, HWND hWndParent) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   HWND hWndPrev = lpStdMsgFilter-&gt;m_hWndParent; <br> <br>   lpStdMsgFilter-&gt;m_hWndParent = hWndParent; <br>   return hWndPrev; <br>} <br> <br> <br>STDMETHODIMP OleStdMsgFilter_QueryInterface( <br>      LPMESSAGEFILTER lpThis, REFIID riid, LPVOID FAR* ppvObj) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   SCODE scode; <br> <br>   /* Two interfaces supported: IUnknown, IMessageFilter <br>   */ <br> <br>   if (IsEqualIID(riid, &amp;IID_IMessageFilter) || IsEqualIID(riid, &amp;IID_IUnknown)) { <br>      lpStdMsgFilter-&gt;m_cRef++;   // A pointer to this object is returned <br>      *ppvObj = lpThis; <br>      scode = S_OK; <br>   } <br>   else {                 // unsupported interface <br>      *ppvObj = NULL; <br>      scode = E_NOINTERFACE; <br>   } <br> <br>   return scode; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleStdMsgFilter_AddRef(LPMESSAGEFILTER lpThis) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   return ++lpStdMsgFilter-&gt;m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) OleStdMsgFilter_Release(LPMESSAGEFILTER lpThis) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   LPMALLOC lpMalloc; <br> <br>   if (--lpStdMsgFilter-&gt;m_cRef != 0) // Still used by others <br>      return lpStdMsgFilter-&gt;m_cRef; <br> <br>   // Free storage <br>   if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&amp;lpMalloc) != NOERROR) <br>      return (ULONG)0; <br> <br>   lpMalloc-&gt;lpVtbl-&gt;Free(lpMalloc, lpStdMsgFilter); <br>   lpMalloc-&gt;lpVtbl-&gt;Release(lpMalloc); <br> <br>  g_dwObjectCount --; <br> <br>   return (ULONG)0; <br>} <br> <br> <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_HandleInComingCall ( <br>      LPMESSAGEFILTER     lpThis, <br>      DWORD               dwCallType, <br>      HTASK               htaskCaller, <br>      DWORD               dwTickCount, <br>      LPINTERFACEINFO     dwReserved <br>) <br>{ <br>   LPOLESTDMESSAGEFILTER lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br> <br>   /* if a HandleInComingCallbackProc is in effect, then this <br>   **    overrides dwIncomingCallStatus established by a call to <br>   **    OleStdMsgFilter_SetInComingStatus.  we will call this <br>   **    callback to allow the app to selectively handle or reject <br>   **    incoming method calls. the LPINTERFACEINFO parameter <br>   **    describes which method is being called. <br>   */ <br>   if (lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback &amp;&amp; <br>      !IsBadCodePtr((FARPROC)lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback)){ <br>      return lpStdMsgFilter-&gt;m_lpfnHandleInComingCallback( <br>            dwCallType, <br>            htaskCaller, <br>            dwTickCount, <br>            dwReserved <br>      ); <br>   } <br> <br>   switch (dwCallType) { <br>      case CALLTYPE_TOPLEVEL: <br>         /* NOTE: we currently have NO pending outgoing call and <br>         **    there is a new toplevel incoming call. <br>         **    this call may be rejected. <br>         */ <br>         return lpStdMsgFilter-&gt;m_dwInComingCallStatus; <br> <br>      case CALLTYPE_TOPLEVEL_CALLPENDING: <br>         /* NOTE: we currently HAVE a pending outgoing call and <br>         **    there is a new toplevel incoming call. <br>         **    this call may be rejected. <br>         */ <br>         return lpStdMsgFilter-&gt;m_dwInComingCallStatus; <br> <br>      case CALLTYPE_NESTED: <br>         /* NOTE: we currently HAVE a pending outgoing call and <br>         **    there callback on behalf of the previous outgoing <br>         **    call. this type of call should ALWAYS be handled. <br>         */ <br>         return SERVERCALL_ISHANDLED; <br> <br>      case CALLTYPE_ASYNC: <br>         /* NOTE: we currently have NO pending outgoing call and <br>         **    there is a new asyncronis incoming call. <br>         **    this call can NEVER be rejected. OLE actually ignores <br>         **    the return code in this case and always allows the <br>         **    call through. <br>         */ <br>         return SERVERCALL_ISHANDLED;    // value returned does not matter <br> <br>      case CALLTYPE_ASYNC_CALLPENDING: <br>         /* NOTE: we currently HAVE a pending outgoing call and <br>         **    there is a new asyncronis incoming call. <br>         **    this call can NEVER be rejected. OLE ignore the <br>         **    return code in this case. <br>         */ <br>         return SERVERCALL_ISHANDLED;    // value returned does not <br> <br>      default: <br>         OleDbgAssert( <br>               "OleStdMsgFilter_HandleInComingCall: Invalid CALLTYPE"); <br>         return lpStdMsgFilter-&gt;m_dwInComingCallStatus; <br>   } <br>} <br> <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_RetryRejectedCall ( <br>      LPMESSAGEFILTER     lpThis, <br>      HTASK               htaskCallee, <br>      DWORD               dwTickCount, <br>      DWORD               dwRejectType <br>) <br>{ <br>   LPOLESTDMESSAGEFILTER   lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   DWORD                   dwRet = 0; <br>   UINT                    uRet; <br>   char                    szBuf[80]; <br>   OLEDBG_BEGIN2("OleStdMsgFilter_RetryRejectedCall\r\n") <br> <br>   /* NOTE: we should only put up the application busy dialog when <br>   **    the callee has responded SERVERCALL_RETRYLATER. if the <br>   **    dwRejectType is SERVERCALL_REJECTED then there is something <br>   **    seriously wrong with the callee (perhaps a severe low memory <br>   **    situation). we don't want to even try to "Switch To" this app <br>   **    or even try to "Retry". <br>   */ <br>   if (dwRejectType == SERVERCALL_RETRYLATER &amp;&amp; <br>         lpStdMsgFilter-&gt;m_fEnableBusyDialog) { <br> <br>      OLEUIBUSY bz; <br> <br>      /* NOTE: we do not want to put up the Busy dialog immediately <br>      **    the when an app says RETRYLATER. we should continue retrying <br>      **    for a while in case the app can un-busy itself in a <br>      **    reasonable amount of time. <br>      */ <br>      if (dwTickCount &lt;= (DWORD)OLESTDRETRYDELAY) { <br>         dwRet = 500;                  // Retry after .5 sec <br>         OLEDBG_END2 <br>         return dwRet; <br>      } <br> <br>      /* <br>      ** Set up structure for calling OLEUIBUSY dialog <br>      */ <br> <br>      bz.cbStruct = sizeof(OLEUIBUSY); <br>      bz.dwFlags = 0L; <br>      bz.hWndOwner =GetTopWindowInWindowsTask(lpStdMsgFilter-&gt;m_hWndParent); <br>      W2A(lpStdMsgFilter-&gt;m_lpszAppName, szBuf, sizeof(szBuf)); <br>      bz.lpszCaption = szBuf; <br>      bz.lpfnHook = lpStdMsgFilter-&gt;m_lpfnBusyDialogHookCallback; <br>      bz.lCustData = 0; <br>      bz.hInstance = NULL; <br>      bz.lpszTemplate = NULL; <br>      bz.hResource = 0; <br>      bz.hTask = htaskCallee; <br>      bz.lphWndDialog = NULL; // We don't need the hDlg for this call <br> <br>      uRet = OleUIBusy(&amp;bz); <br> <br>      switch (uRet) { <br>         case OLEUI_BZ_RETRYSELECTED: <br>            dwRet = 0;                  // Retry immediately <br>            break; <br> <br>         case OLEUI_CANCEL: <br>            dwRet = OLESTDCANCELRETRY;  // Cancel pending outgoing call <br>            break; <br> <br>         case OLEUI_BZERR_HTASKINVALID: <br>            // Htask was invalid, return OLESTDRETRYDELAY anyway <br>            dwRet = OLESTDRETRYDELAY;   // Retry after &lt;retry delay&gt; msec <br> <br>#if defined( _DEBUG ) <br>            wsprintf( <br>                  szBuf, <br>                  "OleStdMsgFilter_RetryRejectedCall, HTASK 0x%x invalid\r\n", <br>                  htaskCallee <br>            ); <br>            OleDbgOut3(szBuf); <br>#endif <br>            break; <br>      } <br>   } else { <br>      dwRet = OLESTDCANCELRETRY;  // Cancel pending outgoing call <br>   } <br> <br>#if defined( _DEBUG ) <br>   wsprintf(szBuf, <br>          "OleStdMsgFilter_RetryRejectedCall returns %d\r\n", <br>          dwRet); <br>   OleDbgOut3(szBuf); <br>#endif <br> <br>   OLEDBG_END2 <br>   return dwRet; <br>} <br> <br> <br> <br>/* a significant message is consider a mouse click or keyboard input. */ <br>#define IS_SIGNIFICANT_MSG(lpmsg)   \ <br>   (   \ <br>      (PeekMessage((lpmsg), NULL, WM_LBUTTONDOWN, WM_LBUTTONDOWN, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>    || (PeekMessage((lpmsg), NULL, WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>    || (PeekMessage((lpmsg), NULL, WM_NCLBUTTONDOWN, WM_NCLBUTTONDOWN, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>    || (PeekMessage((lpmsg), NULL, WM_NCLBUTTONDBLCLK, WM_NCLBUTTONDBLCLK, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>    || (PeekMessage((lpmsg), NULL, WM_KEYDOWN, WM_KEYDOWN, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>    || (PeekMessage((lpmsg), NULL, WM_SYSKEYDOWN, WM_SYSKEYDOWN, \ <br>             PM_NOREMOVE | PM_NOYIELD)) \ <br>   ) <br> <br>STDMETHODIMP_(DWORD) OleStdMsgFilter_MessagePending ( <br>      LPMESSAGEFILTER     lpThis, <br>      HTASK               htaskCallee, <br>      DWORD               dwTickCount, <br>      DWORD               dwPendingType <br>) <br>{ <br>   LPOLESTDMESSAGEFILTER   lpStdMsgFilter = (LPOLESTDMESSAGEFILTER)lpThis; <br>   DWORD                   dwReturn = PENDINGMSG_WAITDEFPROCESS; <br>   MSG                     msg; <br>   BOOL                    fIsSignificantMsg = IS_SIGNIFICANT_MSG(&amp;msg); <br>   UINT                    uRet; <br> <br>   char szBuf[128]; <br>#if defined( _DEBUG ) <br>   wsprintf( <br>         szBuf, <br>         "OleStdMsgFilter_MessagePending, dwTickCount = 0x%lX\r\n", <br>         (DWORD)dwTickCount <br>   ); <br>   OleDbgOut4(szBuf); <br>#endif <br> <br>   /* NOTE: If our tick count for this call exceeds our standard retry <br>   **      delay, then we need to put up the dialog.  We will only <br>   **      consider putting up the dialog if the user has issued a <br>   **      "significant" event (ie. mouse click or keyboard event). a <br>   **      simple mouse move should NOT trigger this dialog. <br>   **      Since our call to <br>   **      OleUIBusy below enters a DialogBox() message loop, there's a <br>   **      possibility that another call will be initiated during the dialog, <br>   **      and this procedure will be re-entered.  Just so we don't put up <br>   **      two dialogs at a time, we use the m_bUnblocking varable <br>   **      to keep track of this situation. <br>   */ <br> <br>   if (dwTickCount &gt; (DWORD)OLESTDRETRYDELAY &amp;&amp; fIsSignificantMsg <br>         &amp;&amp; !lpStdMsgFilter-&gt;m_bUnblocking) <br>   { <br> <br>      if (lpStdMsgFilter-&gt;m_fEnableNotRespondingDialog) <br>      { <br>      OLEUIBUSY bz; <br> <br>      lpStdMsgFilter-&gt;m_bUnblocking = TRUE; <br> <br>      // Eat messages in our queue that we do NOT want to be dispatched <br>      while (PeekMessage(&amp;msg, NULL, WM_CLOSE, WM_CLOSE, PM_REMOVE | PM_NOYIELD)); <br> <br>      /* Set up structure for calling OLEUIBUSY dialog, <br>      ** using the "not responding" variety <br>      */ <br> <br>      bz.cbStruct = sizeof(OLEUIBUSY); <br>      bz.dwFlags = BZ_NOTRESPONDINGDIALOG; <br>      bz.hWndOwner =GetTopWindowInWindowsTask(lpStdMsgFilter-&gt;m_hWndParent); <br>      W2A(lpStdMsgFilter-&gt;m_lpszAppName, szBuf, sizeof(szBuf)); <br>      bz.lpszCaption = szBuf; <br>      bz.lpfnHook = lpStdMsgFilter-&gt;m_lpfnBusyDialogHookCallback; <br>      bz.lCustData = 0; <br>      bz.hInstance = NULL; <br>      bz.lpszTemplate = NULL; <br>      bz.hResource = 0; <br>      bz.hTask = htaskCallee; <br> <br>      /* Set up the address to the hWnd in our MsgFilter structure.  The <br>      ** call to OleUIBusy will fill this in with the hWnd of the busy <br>      ** dialog box <br>      */ <br> <br>      bz.lphWndDialog =  (HWND FAR *)&amp;(lpStdMsgFilter-&gt;m_hWndBusyDialog); <br>      uRet = OleUIBusy(&amp;bz); <br> <br>      lpStdMsgFilter-&gt;m_bUnblocking = FALSE; <br> <br>      return PENDINGMSG_WAITNOPROCESS; <br>      } <br>#if defined( _DEBUG ) <br>      else { <br>         OleDbgOut3("OleStdMsgFilter_MessagePending: BLOCKED but dialog Disabled\r\n"); <br>      } <br>#endif <br>   } <br> <br>   /* If we're already unblocking, we're being re-entered.  Don't <br>   ** process message <br>   */ <br> <br>   if (lpStdMsgFilter-&gt;m_bUnblocking) <br>      return PENDINGMSG_WAITDEFPROCESS; <br> <br>   /* NOTE: If we have a callback function set up, call it with the <br>   ** current message.  If not, tell OLE LPRC mechanism to automatically <br>   ** handle all messages. <br>   */ <br>   if (lpStdMsgFilter-&gt;m_lpfnMessagePendingCallback &amp;&amp; <br>      !IsBadCodePtr((FARPROC)lpStdMsgFilter-&gt;m_lpfnMessagePendingCallback)){ <br>      MSG msg; <br> <br>      /* NOTE: the app provided a MessagePendingCallback <br>      **    function. we will PeekMessage for the first message in <br>      **    the queue and pass it to the app. the app in its callback <br>      **    function can decide to Dispatch this message or it can <br>      **    PeekMessage on its own giving particular message filter <br>      **    criteria. if the app returns TRUE then we return <br>      **    PENDINGMSG_WAITNOPROCESS to OLE telling OLE to leave the <br>      **    message in the queue. If the app returns FALSE, then we <br>      **    return PENDINGMSG_WAITDEFPROCESS to OLE telling OLE to do <br>      **    its default processing with the message. by default OLE <br>      **    dispatches system messages and eats other messages and <br>      **    beeps. <br>      */ <br>      if (PeekMessage(&amp;msg, NULL, 0, 0, PM_NOREMOVE | PM_NOYIELD)) { <br> <br>         if (lpStdMsgFilter-&gt;m_lpfnMessagePendingCallback(&amp;msg)) { <br>            /* TRUE return means that the app processed message. <br>            ** <br>            ** NOTE: (CHANGE FROM OLE2.0 VERSION) we leave it up to <br>            **    the callback routine to remove the message if it <br>            **    wants. <br>            */ <br>            dwReturn = PENDINGMSG_WAITNOPROCESS; <br>         } else { <br>            /* FALSE means that the app did not process the <br>            **    message. we will let OLE take its <br>            **    default action. <br>            ** <br>            ** NOTE: (CHANGE FROM OLE2.0 VERSION) we used to return <br>            **    PENDINGMSG_WAITNOPROCESS to leave the message in <br>            **    the queue; now we return PENDINGMSG_WAITDEFPROCESS <br>            **    to let OLE do default processing. <br>            */ <br>            dwReturn = PENDINGMSG_WAITDEFPROCESS; <br> <br>#if defined( _DEBUG ) <br>            wsprintf( <br>                  szBuf, <br>                  "Message (0x%x) (wParam=0x%x, lParam=0x%lx) using WAITDEFPROCESS while blocked\r\n", <br>                  msg.message, <br>                  msg.lParam, <br>                  msg.wParam <br>            ); <br>            OleDbgOut2(szBuf); <br>#endif  // _DEBUG <br>         } <br>      } <br>   } <br> <br>   return dwReturn; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
