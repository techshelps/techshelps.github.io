<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLE2UI.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context257"></a>OLE2UI.C</h2>
<pre><code>/* <br> * OLE2UI.C <br> * <br> * Contains initialization routines and miscellaneous API implementations for <br> * the OLE 2.0 User Interface Support Library. <br> * <br> * Copyright (c)1992-1996 Microsoft Corporation, All Right Reserved <br> */ <br> <br>#define STRICT  1 <br> <br>#include "olestd.h" <br>#include "common.h" <br>#include "utility.h" <br>#include &lt;commdlg.h&gt; <br>#include "malspy.h" <br> <br>OLEDBGDATA <br> <br>#define WINDLL  1           // make far pointer version of stdargs.h <br>#include &lt;stdarg.h&gt; <br> <br>//The instance handle shared amongst all dialogs. <br>HINSTANCE     ghInst; <br> <br>// object count, used to support DllCanUnloadNow and OleUICanUnloadNow <br>DWORD g_dwObjectCount=0; <br>DWORD g_dwLockCount=0; <br> <br>//Registered messages for use with all the dialogs, registered in LibMain <br>UINT        uMsgHelp=0; <br>UINT        uMsgEndDialog=0; <br>UINT        uMsgBrowse=0; <br>UINT        uMsgChangeIcon=0; <br>UINT        uMsgFileOKString=0; <br>UINT        uMsgCloseBusyDlg=0; <br> <br>//Clipboard formats used by PasteSpecial <br>UINT  cfObjectDescriptor; <br>UINT  cfLinkSrcDescriptor; <br>UINT  cfEmbedSource; <br>UINT  cfEmbeddedObject; <br>UINT  cfLinkSource; <br>UINT  cfOwnerLink; <br>UINT  cfFileName; <br> <br> <br>// local definition <br>#define WM_U_UPDATELINK WM_USER <br> <br> <br> <br>/* <br> * OleStdInitialize <br> * <br> * NOTE: This function should be called by your application before using any of <br> *       the functions found in this library. <br> * <br> * Purpose: <br> *   Initializes the OLE UI Library. <br> * <br> * Parameters: <br> * <br> *  hInstance       HINSTANCE of the module where the UI library resources <br> *                  and Dialog Procedures are contained.  If you are calling <br> *                  this function yourself, this should be the instance handle <br> *                  of your application. <br> * <br> *  hPrevInst       HINSTANCE of the previous application instance. <br> *                  This is the parameter passed in to your WinMain.  For <br> *                  the DLL version, this should always be set to zero (for <br> *                  WIN16 DLLs). <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization was successful. <br> *                  FALSE if either the "Magic Number" did not verify, or one of <br> *                  the window classes could not be registered.  If the <br> *                  "Magic Number" did not verify, then the resources <br> *                  in your module are of a different version than the <br> *                  ones you compiled with. <br> */ <br> <br>STDAPI_(BOOL) OleStdInitialize(HINSTANCE hInstance) <br>{ <br>   OleDbgOut1("OleStdInitialize called.\r\n"); <br>   ghInst=hInstance; <br> <br>   // Register Clipboard Formats used by PasteSpecial dialog. <br>   cfObjectDescriptor = RegisterClipboardFormat(CF_OBJECTDESCRIPTOR); <br>   cfLinkSrcDescriptor= RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR); <br>   cfEmbedSource      = RegisterClipboardFormat(CF_EMBEDSOURCE); <br>   cfEmbeddedObject   = RegisterClipboardFormat(CF_EMBEDDEDOBJECT); <br>   cfLinkSource       = RegisterClipboardFormat(CF_LINKSOURCE); <br>   cfOwnerLink        = RegisterClipboardFormat(CF_OWNERLINK); <br>   cfFileName         = RegisterClipboardFormat(CF_FILENAME); <br> <br>#ifdef TRACEMEM <br>   return (InitializeMallocSpy()); <br>#else <br>   return (TRUE); <br>#endif <br>} <br> <br>STDAPI_(void) OleStdUninitialize(void) <br>{ <br>#ifdef TRACEMEM <br>   UninitializeMallocSpy(); <br>#endif <br>} <br> <br>/* <br> * OleUICanUnloadNow <br> * <br> * NOTE: if you link to this library and you implement <br> *       DllCanUnloadNow, then you must call this routine in your <br> *       implementation of DllCanUnloadNow to determine if you can be <br> *       unloaded or not. <br> * <br> * Purpose: <br> *   Determines when it is safe to go away <br> *   (ie. there are no existing object instances). <br> * <br> * Return Value: <br> *   HRESULT    NOERROR it is safe to go away, S_FALSE this code must stay <br> *              loaded. <br> * <br> * Comments: <br> * <br> *   If an INPROC server DLL links to the OLESTD library, <br> *   then the OleUILockLibrary function should NOT be used. <br> *   instead the INPROC server DLL should call OleUICanUnloadNow API from <br> *   within its own DllCanUnloadNow function. The idea here is, that if there <br> *   are any existing instance of objects created by the OLESTD library <br> *   functions (eg. EnumFORMATETC objects created by OleStdEnumFmtEtc_Create) <br> *   then, the INPROC server DLL must NOT let itself be unloaded. <br> * <br> *   An EXE based object using the OLESTD libray need NOT use either the <br> *   OleUILockLibrary or OleUICanUnloadNow functions. All objects created <br> *   by the OLESTD library will have LRPC proxies and stubs created to <br> *   manage remoting method calls. the worst that can happen when the EXE <br> *   exits is that any outstanding proxies for unreleased objects will get <br> *   RPC_E_SERVERDIED errors; they will not GPFault. <br> */ <br> <br>STDAPI OleUICanUnloadNow() <br>{ <br>  if (g_dwObjectCount == 0) { <br>   return NOERROR; <br>  } <br> <br>  return S_FALSE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
