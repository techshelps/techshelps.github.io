<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STABLIZE.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context160"></a>STABLIZE.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       stablize.cxx <br>// <br>//  Contents:   Stabilization Classes used to stabilize objects during <br>//              re-entrant calls. <br>// <br>//  Classes:    CSafeRefCount <br>//              CStabilize <br>// <br>//  History:    8-26-94   stevebl   Modified from code written by AlexGo <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;stablize.h&gt; <br>#include &lt;assert.h&gt; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::CSafeRefCount <br>// <br>//  Synopsis:   constructor for the safe ref count class <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//-------------------------------------------------------------------------- <br> <br>CSafeRefCount::CSafeRefCount() <br>{ <br>        m_cRefs = 0; <br>        m_cNest = 0; <br>        m_fInDelete = FALSE; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::~CSafeRefCount (virtual) <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//-------------------------------------------------------------------------- <br> <br>CSafeRefCount::~CSafeRefCount() <br>{ <br>        assert(m_cRefs == 0 &amp;&amp; m_cNest == 0 &amp;&amp; m_fInDelete == TRUE); <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::SafeAddRef <br>// <br>//  Synopsis:   increments the reference count on the object <br>// <br>//  Returns:    ULONG -- the reference count after the increment <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG CSafeRefCount::SafeAddRef() <br>{ <br>        m_cRefs++; <br>        return m_cRefs; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::SafeRelease <br>// <br>//  Synopsis:   decrements the reference count on the object <br>// <br>//  Effects:    May delete the object! <br>// <br>//  Returns:    ULONG -- the reference count after decrement <br>// <br>//  Algorithm:  decrements the reference count.  If the reference count <br>//              is zero AND the nest count is zero AND we are not currently <br>//              trying to delete our object, then it is safe to delete. <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG CSafeRefCount::SafeRelease() <br>{ <br>        ULONG   cRefs; <br> <br>        if( m_cRefs &gt; 0 ) <br>        { <br>                cRefs = --m_cRefs; <br> <br>                if( m_cRefs == 0 &amp;&amp; m_cNest == 0 &amp;&amp; m_fInDelete == FALSE ) <br>                { <br>                        m_fInDelete = TRUE; <br>                        delete this; <br>                } <br>        } <br>        else <br>        { <br>                // somebody is releasing a non-addrefed pointer!! <br>                assert(NULL == "Release called on a non-addref'ed pointer!\n"); <br>                cRefs = 0; <br>        } <br>        return cRefs; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::IncrementNestCount <br>// <br>//  Synopsis:   increments the nesting count of the object <br>// <br>//  Arguments:  none <br>// <br>//  Returns:    ULONG; the nesting count after increment <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//  Notes:      The nesting count is the count of how many times an <br>//              an object has been re-entered.  For example, suppose <br>//              somebody calls pFoo-&gt;Bar1(), which makes some calls that <br>//              eventually call pFoo-&gt;Bar2();.  On entrace to Bar2, the <br>//              nest count of the object should be 2 (since the invocation <br>//              of Bar1 is still on the stack above us). <br>// <br>//              It is important to keep track of the nest count so we do <br>//              not accidentally delete ourselves during a nested invocation. <br>//              If we did, then when the stack unwinds to the original <br>//              top level call, it could try to access a non-existent member <br>//              variable and crash. <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG CSafeRefCount::IncrementNestCount() <br>{ <br>        m_cNest++; <br>        return m_cNest; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Member:     CSafeRefCount::DecrementNestCount <br>// <br>//  Synopsis:   decrements the nesting count and deletes the object <br>//              (if necessary) <br>// <br>//  Effects:    may delete 'this' object! <br>// <br>//  Arguments:  none <br>// <br>//  Returns:    ULONG, the nesting count after decrement <br>// <br>//  Algorithm:  decrements the nesting count.  If the nesting count is zero <br>//              AND the reference count is zero AND we are not currently <br>//              trying to delete ourselves, then delete 'this' object <br>// <br>//  History:    dd-mmm-yy Author    Comment <br>//              28-Jul-94 alexgo    author <br>//              8-26-94   stevebl   modified for use by SDK samples <br>// <br>//  Notes: <br>// <br>//-------------------------------------------------------------------------- <br> <br>ULONG CSafeRefCount::DecrementNestCount() <br>{ <br>        ULONG   cNest; <br> <br>        if( m_cNest &gt; 0 ) <br>        { <br>                cNest = --m_cNest; <br> <br>                if( m_cRefs == 0 &amp;&amp; m_cNest == 0 &amp;&amp; m_fInDelete == FALSE ) <br>                { <br>                        m_fInDelete = TRUE; <br>                        delete this; <br>                } <br>        } <br>        else <br>        { <br>                // somebody forget to increment the nest count!! <br>                assert(NULL == "Unbalanced nest count!!"); <br>                cNest = 0; <br>        } <br>        return cNest; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
