<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GIZMOBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context167"></a>GIZMOBAR.C</h2>
<pre><code>/* <br> * GIZMOBAR.C <br> * GizmoBar Version 1.01 <br> * <br> * Contains the main window procedure of the GizmoBar control <br> * that handles mouse logic and Windows messages. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include "gizmoint.h" <br> <br> <br> <br>/* <br> * GizmoBarWndProc <br> * <br> * Purpose: <br> *  Window Procedure for the GizmoBar custom control.  Handles all <br> *  messages like WM_PAINT just as a normal application window would. <br> *  Any message not processed here should go to DefWindowProc. <br> * <br> * Parameters: <br> *  Standard <br> * <br> * Return Value: <br> *  Standard <br> */ <br> <br>LRESULT WINAPI GizmoBarWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    BOOL            fSuccess; <br>    BOOL            fTemp; <br>    LPCREATESTRUCT  pCreate; <br>    PGIZMOBAR       pGB; <br>    PGIZMO          pGizmo; <br>    RECT            rc; <br>    POINT           pt; <br>    short           x, y; <br>    COLORREF        cr; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    pGB=(PGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE); <br> <br>    //Pass control messages onto another function for processing. <br>    if (iMsg &gt;= WM_USER) <br>        return GBMessageHandler(hWnd, iMsg, wParam, lParam, pGB); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pCreate=(LPCREATESTRUCT)lParam; <br> <br>            pGB=GizmoBarPAllocate(&amp;fSuccess, hWnd <br>                , pCreate-&gt;hInstance, pCreate-&gt;hwndParent <br>                , pCreate-&gt;style, 0, (UINT)pCreate-&gt;hMenu); <br> <br>            if (!fSuccess) <br>                { <br>                GizmoBarPFree(pGB); <br>                return -1L; <br>                } <br>            else <br>                SetWindowLong(hWnd, GBWL_STRUCTURE, (LONG)pGB); <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_DESTROY: <br>            /* <br>             * We want to clean up before DestroyWindow nukes all the <br>             * children, so WM_DESTROY is a better to do it than <br>             * WM_NCDESTROY. <br>             */ <br>            GizmoBarPFree(pGB); <br>            break; <br> <br> <br>        case WM_ERASEBKGND: <br>            /* <br>             * Eat this message to avoid erasing portions that <br>             * we are going to repaint in WM_PAINT.  Part of a <br>             * change-state-and-repaint strategy is to rely on <br>             * WM_PAINT to do anything visual, which includes <br>             * erasing invalid portions.  Letting WM_ERASEBKGND <br>             * erase the background is redundant. <br>             */ <br>            return TRUE; <br> <br>       #ifdef WIN32 <br>        case WM_CTLCOLORBTN: <br>        case WM_CTLCOLORSTATIC: <br>            fTemp=TRUE; <br>       #else <br>        case WM_CTLCOLOR: <br>            //Change the color of static text on the GizmoBar. <br>            fTemp=(HIWORD(lParam)==CTLCOLOR_STATIC <br>                || HIWORD(lParam)==CTLCOLOR_BTN); <br>       #endif <br> <br>            if (fTemp) <br>                { <br>                cr=GetSysColor(COLOR_BTNFACE); <br>                SetTextColor((HDC)wParam <br>                    , GetSysColor(COLOR_BTNTEXT)); <br>                SetBkColor((HDC)wParam, cr); <br> <br>                /* <br>                 * If the system colors have changed, then crFace <br>                 * will not be equal to COLOR_BTNFACE, so we <br>                 * reinitialize the background brush.  This scheme <br>                 * handles system color changes appropriately <br>                 * without processing WM_WININICHANGE and without <br>                 * blindly creating a new brush on every WM_CTLCOLOR <br>                 * message. <br>                 */ <br>                if (cr!=pGB-&gt;crFace) <br>                    { <br>                    pGB-&gt;crFace=cr; <br> <br>                    if (NULL!=pGB-&gt;hBrFace) <br>                        DeleteObject(pGB-&gt;hBrFace); <br> <br>                    pGB-&gt;hBrFace=CreateSolidBrush(pGB-&gt;crFace); <br>                    } <br> <br>                return (LONG)(UINT)pGB-&gt;hBrFace; <br>                } <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_PAINT: <br>            GizmoBarPaint(hWnd, pGB); <br>            break; <br> <br> <br>        case WM_SETFONT: <br>            /* <br>             * wParam has the new font that we now send to all other <br>             * windows controls in us.  We control repaints here to <br>             * prevent a lot of repainting for each control. <br>             */ <br>            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>            if ((WPARAM)NULL!=wParam) <br>                { <br>                pGB-&gt;hFont=(HFONT)wParam; <br>                GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumChangeFont <br>                    , (DWORD)(LPTSTR)pGB); <br> <br>                DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L); <br>                InvalidateRect(hWnd, NULL, FALSE); <br>                UpdateWindow(hWnd); <br>                } <br> <br>            break; <br> <br> <br>        case WM_GETFONT: <br>            return (LRESULT)(UINT)pGB-&gt;hFont; <br> <br> <br>        case WM_ENABLE: <br>            /* <br>             * wParam has the new enable flag that we use to enable <br>             * or disable ALL controls in us at one time.  We also <br>             * turn the redraw off to prevent a lot of flicker. <br>             */ <br>            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>            pGB-&gt;fEnabled=(BOOL)wParam; <br>            GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumEnable <br>                , (DWORD)(LPTSTR)pGB); <br> <br>            DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L); <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case WM_CANCELMODE: <br>            pGizmo=pGB-&gt;pGizmoTrack; <br> <br>            pGB-&gt;fTracking=FALSE; <br>            pGB-&gt;fMouseOut=FALSE; <br> <br>            if (NULL!=pGizmo) <br>                GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP); <br> <br>            ReleaseCapture(); <br>            break; <br> <br> <br>        case WM_LBUTTONDBLCLK: <br>        case WM_LBUTTONDOWN: <br>            //Get the mouse coordinates. <br>            x=LOWORD(lParam); <br>            y=HIWORD(lParam); <br> <br> <br>            /* <br>             * See if we hit a command or attribute gizmo or not. <br>             * Anything else that is a control will get the message <br>             * instead of us anyway, so we don't have to check. <br>             * FEnumHitTest also validates drawn gizmos, enabled, and <br>             * visible, so we don't. <br>             */ <br>            pGizmo=GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumHitTest, lParam); <br> <br>            if (NULL==pGizmo) <br>                break;          //Didn't hit one matching our needs. <br> <br>            /* <br>             * Inform the associate that a command was hit like a <br>             * menu item. <br>             */ <br>            if (NULL!=pGB-&gt;hWndAssociate) <br>                { <br>                if (pGizmo-&gt;fNotify) <br>                    { <br>                    SendMenuSelect(pGB-&gt;hWndAssociate, pGizmo-&gt;uID <br>                        , 0, 0); <br>                    } <br>                } <br> <br>            /* <br>             * We hit a button.  If it's a command or attribute, <br>             * then change the state and start tracking. <br>             */ <br>            pGB-&gt;fTracking=TRUE; <br>            pGB-&gt;pGizmoTrack=pGizmo; <br>            pGB-&gt;fMouseOut=FALSE; <br>            SetCapture(hWnd); <br> <br>            pGizmo-&gt;uStateOrg=pGizmo-&gt;uState; <br>            GizmoPStateSet(hWnd, pGizmo, ATTRIBUTEBUTTON_MOUSEDOWN); <br> <br>            break; <br> <br> <br>        case WM_MOUSEMOVE: <br>            POINTFROMLPARAM(pt, lParam); <br> <br>            if (!pGB-&gt;fTracking) <br>                break; <br> <br>            pGizmo=pGB-&gt;pGizmoTrack; <br>            SetRect(&amp;rc, pGizmo-&gt;x, pGizmo-&gt;y, pGizmo-&gt;x+pGizmo-&gt;dx <br>                , pGizmo-&gt;y+pGizmo-&gt;dy); <br> <br>            fTemp=pGB-&gt;fMouseOut; <br>            pGB-&gt;fMouseOut=!PtInRect(&amp;rc, pt); <br> <br>            //If the mouse went out, change state to the original. <br>            if (!fTemp &amp;&amp; pGB-&gt;fMouseOut) <br>                { <br>                GizmoPStateSet(hWnd, pGizmo, pGizmo-&gt;uStateOrg); <br> <br>                if (NULL!=pGB-&gt;hWndAssociate) <br>                    { <br>                    //Notify that we left the button <br>                    if (pGizmo-&gt;fNotify) <br>                        SendMenuSelect(pGB-&gt;hWndAssociate, 0, ~0, 0); <br>                    } <br>                } <br> <br>            if (fTemp &amp;&amp; !pGB-&gt;fMouseOut) <br>                { <br>                GizmoPStateSet(hWnd, pGizmo <br>                    , ATTRIBUTEBUTTON_MOUSEDOWN); <br> <br>                if (NULL!=pGB-&gt;hWndAssociate) <br>                    { <br>                    //Notify that we pressed down again <br>                    if (pGizmo-&gt;fNotify) <br>                        { <br>                        SendMenuSelect(pGB-&gt;hWndAssociate <br>                            , pGizmo-&gt;uID , 0, 0); <br>                        } <br>                    } <br>                } <br> <br>            break; <br> <br> <br>        case WM_LBUTTONUP: <br>            if (!pGB-&gt;fTracking) <br>                break; <br> <br>            pGB-&gt;fTracking=FALSE; <br>            pGizmo=pGB-&gt;pGizmoTrack; <br>            ReleaseCapture(); <br> <br> <br>            /* <br>             * Repaint if we were actually below the mouse when this <br>             * occurred.  For command buttons, pop the button up. <br>             * For attributes, either toggle the state (inclusive <br>             * buttons) or check the selected one (exclusive buttons) <br>             */ <br> <br>            if (!pGB-&gt;fMouseOut) <br>                { <br>                //Command buttons always come up. <br>                if (GIZMOTYPE_BUTTONCOMMAND==pGizmo-&gt;iType) <br>                    GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP); <br> <br>                //Attribute inclusive buttons toggle <br>                if (GIZMOTYPE_BUTTONATTRIBUTEIN==pGizmo-&gt;iType) <br>                    { <br>                    GizmoPCheck(hWnd, pGizmo, !(BUTTONGROUP_DOWN <br>                        &amp; pGizmo-&gt;uStateOrg)); <br>                    } <br> <br>                //Attribure exclusive buttons are always checked. <br>                if (GIZMOTYPE_BUTTONATTRIBUTEEX==pGizmo-&gt;iType) <br>                    GizmoPCheck(hWnd, pGizmo, TRUE); <br> <br>                //Only send messages if notify is ON. <br>                if (NULL!=pGB-&gt;hWndAssociate &amp;&amp; pGizmo-&gt;fNotify) <br>                    { <br>                    SendMenuSelect(pGB-&gt;hWndAssociate, 0, ~0, 0); <br>                    SendCommand(pGB-&gt;hWndAssociate, pGizmo-&gt;uID <br>                        , BN_CLICKED, hWnd); <br>                    } <br>                } <br> <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            //Pass control messages on if the gizmo's notify is ON. <br>            if (NULL!=pGB-&gt;hWndAssociate) <br>                { <br>                pGizmo=PGizmoFromHwndID(hWnd, wID); <br> <br>                if (NULL!=pGizmo) <br>                    { <br>                    if (pGizmo-&gt;fNotify) <br>                        { <br>                        SendMessage(pGB-&gt;hWndAssociate, iMsg, wParam <br>                            , lParam); <br>                        } <br>                    } <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FEnumChangeFont <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  send a new font to them that's stored in PGIZMOBAR in dw. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the GizmoBar's pGB. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE otherwise. <br> */ <br> <br>BOOL WINAPI FEnumChangeFont(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    PGIZMOBAR   pGB=(PGIZMOBAR)dw; <br> <br>    //Only need to change fonts in windowed controls using WM_SETFONT <br>    if (NULL!=pGizmo-&gt;hWnd) <br>        { <br>        SendMessage(pGizmo-&gt;hWnd, WM_SETFONT <br>            , (WPARAM)pGB-&gt;hFont, 1L); <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FEnumEnable <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  enable or disable them from the WM_ENABLE message. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the GizmoBar's pGB. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI FEnumEnable(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    PGIZMOBAR   pGB=(PGIZMOBAR)dw; <br>    BOOL        fEnable=pGB-&gt;fEnabled; <br> <br>    //NOTE:  This code is duplicated in GBGizmoEnable in API.C <br>    if (NULL!=pGizmo-&gt;hWnd) <br>        EnableWindow(pGizmo-&gt;hWnd, fEnable); <br>    else <br>        { <br>        //If we're not down, command and attribute buttons act same. <br>        if (!(BUTTONGROUP_DOWN &amp; pGizmo-&gt;uState)) <br>            { <br>            GizmoPStateSet(pGB-&gt;hWnd, pGizmo, fEnable <br>                ? COMMANDBUTTON_UP : COMMANDBUTTON_DISABLED); <br>            } <br>        else <br>            { <br>            /* <br>             * Attribute buttons are a little more sensitive <br>             * with DOWNDISABLED <br>             */ <br>            GizmoPStateSet(pGB-&gt;hWnd, pGizmo, fEnable <br>                ? ATTRIBUTEBUTTON_DOWN <br>                : ATTRIBUTEBUTTON_DOWNDISABLED); <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * FEnumHitTest <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  hit-test them. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the hDC on which to draw. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI FEnumHitTest(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    RECT  rc; <br>    POINT pt; <br> <br>    POINTFROMLPARAM(pt, dw); <br> <br>    /* <br>     * Hit tests have to happen on visible, enabled, and drawn <br>     * controls only. <br>     */ <br>    if (GIZMOTYPE_DRAWN &amp; pGizmo-&gt;iType &amp;&amp; !pGizmo-&gt;fHidden <br>        &amp;&amp; !(BUTTONGROUP_DISABLED &amp; pGizmo-&gt;uState)) <br>        { <br>        SetRect(&amp;rc, pGizmo-&gt;x, pGizmo-&gt;y <br>            , pGizmo-&gt;x+pGizmo-&gt;dx, pGizmo-&gt;y+pGizmo-&gt;dy); <br> <br>        //Stop enumeration if we have a hit. <br>        return !PtInRect(&amp;rc, pt); <br>        } <br> <br>    return TRUE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
