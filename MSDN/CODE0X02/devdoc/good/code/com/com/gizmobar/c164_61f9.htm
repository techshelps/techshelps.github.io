<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GIZMO.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context165"></a>GIZMO.C</h2>
<pre><code>/* <br> * GIZMO.C <br> * GizmoBar Version 1.01 <br> * <br> * Allocate, free, find, and enumerate functions for the GIZMO <br> * structure and a generic subclass procedure to handle tabbing <br> * between gizmos. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include "gizmoint.h" <br> <br> <br>/* <br> * In order to control tabbing in the gizmos, we need to subclass <br> * real pushbuttons, edit controls, listboxes, and comboboxes.  So <br> * we keep an array of the four original procs for such controls. <br> */ <br>WNDPROC     pfnOrg[CSUBGIZMOS]={NULL, NULL, NULL, NULL}; <br> <br> <br>CHAR szStatic[]="static"; <br>CHAR szEdit[]="edit"; <br>CHAR szCombobox[]="combobox"; <br>CHAR szListbox[]="listbox"; <br>CHAR szButton[]="button"; <br> <br> <br>//Here so PAINT.C can get at it. <br>TOOLDISPLAYDATA tdd; <br> <br> <br> <br>/* <br> * GizmoPAllocate <br> * <br> * Purpose: <br> *  Allocates and initializes a GIZMO data structure. <br> * <br> * Parameters: <br> *  pfSuccess       int * flag indicating success of failure. <br> *  ppFirst         PPGIZMO providing the first gizmo in this list. <br> *  hWndParent      HWND of the parent of this gizmo.  Can be NULL <br> *                  for iType==GIZMOTYPE_BUTTON* or <br> *                  GIZMOTYPE_SEPARATOR. <br> *  iType           UINT gizmo control type. <br> *  iGizmo          UINT index of this gizmo in the GizmoBar. <br> *  uID             UINT identifier to send with WM_COMMAND for this <br> *                  control. <br> *  dx, dy          UINT width and height of the gizmo. <br> *  pszText         LPTSTR to the text for edits, listboxes, combobox, <br> *                  and text. <br> *  dwStyle         DWORD style for edits, lists, and combos, and <br> *                  texts. <br> *  hBmp            HBITMAP for button gizmos, is applicable. <br> *  iImage          UINT index into hBmp for the button image, if <br> *                  applicable. <br> *  uState          UINT initial state of the control. <br> * <br> * Return Value: <br> *  PGIZMO          If NULL returned then GizmoPAllocate could not <br> *                  allocate memory.  If a non-NULL pointer is <br> *                  returned with *pfSuccess, then call GizmoPFree <br> *                  immediately.  If you get a non-NULL pointer and <br> *                  *pfSuccess==TRUE then the function succeeded. <br> */ <br> <br>PGIZMO GizmoPAllocate(int *pfSuccess, PPGIZMO ppFirst <br>    , HWND hWndParent, UINT iType, UINT iGizmo, UINT uID, UINT dx <br>    , UINT dy, LPWSTR pszText, HBITMAP hBmp, UINT iImage, UINT uState) <br>    { <br>    PGIZMO          pGizmo; <br>    PGIZMO          pCur, pPrev; <br>    LPSTR           pszClass; <br>    HINSTANCE       hInst; <br>    UINT            i; <br>    DWORD           dwStyle; <br>    HWND            hWndE; <br> <br>    if (NULL==pfSuccess) <br>        return NULL; <br> <br>    //Make sure we know of this gizmo type. <br>    if (GIZMOTYPE_MIN &gt; iType || GIZMOTYPE_MAX &lt; iType) <br>        return NULL; <br> <br>    *pfSuccess=FALSE; <br> <br>    //Allocate the structure <br>    pGizmo=(PGIZMO)(TCHAR *)LocalAlloc(LPTR, CBGIZMO); <br> <br>    if (NULL==pGizmo) <br>        return NULL; <br> <br> <br>    //Store the necessary information for this gizmo. <br>    pGizmo-&gt;iType   =iType; <br>    pGizmo-&gt;uID     =uID; <br>    pGizmo-&gt;hBmp    =hBmp; <br>    pGizmo-&gt;iBmp    =iImage; <br>    pGizmo-&gt;uState  =uState; <br>    pGizmo-&gt;fNotify =TRUE; <br> <br> <br>    /* <br>     * Insert this structure into our gizmo list.  Each time we scan <br>     * we increment the index counter (starting at zero) comparing it <br>     * to the desired index of insertion.  We then know exactly where <br>     * to insert this new gizmo.  Note that we insert the new gizmo <br>     * in the list appropriately for the given owner, so enumerations <br>     * will come out ordered in the same way for that owner. <br>     */ <br> <br>    i=0; <br>    pCur=*ppFirst; <br>    pPrev=NULL; <br> <br>    while (NULL!=pCur &amp;&amp; i++ &lt; iGizmo) <br>        { <br>        pPrev=pCur; <br>        pCur =pCur-&gt;pNext; <br>        } <br> <br>    //Point to our neighbors <br>    pGizmo-&gt;pPrev=pPrev; <br>    pGizmo-&gt;pNext=pCur; <br> <br> <br>    //Point out neighbors to us. <br>    if (NULL==pPrev) <br>        *ppFirst=pGizmo; <br>    else <br>        pPrev-&gt;pNext=pGizmo; <br> <br>    if (NULL!=pCur) <br>        pCur-&gt;pPrev=pGizmo; <br> <br> <br>    //Our x-coordinate is the x of the previous gizmo plus its width. <br>    if (NULL!=pPrev) <br>        pGizmo-&gt;x=pGizmo-&gt;pPrev-&gt;x+pGizmo-&gt;pPrev-&gt;dx; <br>    else <br>        pGizmo-&gt;x=4;    //First gizmo is at x=4 <br> <br> <br>    //If we're a separator or image button, force standards on dx. <br>    UIToolConfigureForDisplay(&amp;tdd); <br>    pGizmo-&gt;cxImage=tdd.cxImage; <br>    pGizmo-&gt;cyImage=tdd.cyImage; <br> <br>    if ((GIZMOTYPE_DRAWN &amp; iType) &amp;&amp; NULL==hBmp) <br>        dx=tdd.cxButton; <br> <br>    if (GIZMOTYPE_SEPARATOR==iType) <br>        dx=6; <br> <br>    /* <br>     * Now create windows for edits, texts, lists, and comboboxes. <br>     * First calculate the most often defaults used in the switch. <br>     */ <br>    pGizmo-&gt;dx=dx+6; <br>    pGizmo-&gt;dy=min(dy, tdd.cyButton); <br>    pGizmo-&gt;y=2; <br>    pszClass=NULL; <br> <br>    //If this is new gizmo is a window, create it. <br>    switch (iType) <br>            { <br>            case GIZMOTYPE_TEXT: <br>                pGizmo-&gt;dx=dx; <br> <br>                //Center vertically. <br>                pGizmo-&gt;y=(tdd.cyBar-1-pGizmo-&gt;dy) &gt;&gt; 1; <br>                pszClass=szStatic; <br>                dwStyle=SS_LEFT; <br>                break; <br> <br>            case GIZMOTYPE_EDIT: <br>                //Center vertically. <br>                pGizmo-&gt;y=(tdd.cyBar-1-pGizmo-&gt;dy) &gt;&gt; 1; <br>                pszClass=szEdit; <br>                dwStyle=ES_LEFT | WS_BORDER | WS_TABSTOP; <br>                break; <br> <br>            case GIZMOTYPE_LISTBOX: <br>                pGizmo-&gt;dy=dy; <br>                pszClass=szCombobox; <br>                dwStyle=CBS_DROPDOWNLIST | WS_TABSTOP; <br>                break; <br> <br>            case GIZMOTYPE_COMBOBOX: <br>                pGizmo-&gt;dy=dy; <br>                pszClass=szCombobox; <br>                dwStyle=CBS_DROPDOWN | WS_TABSTOP; <br>                break; <br> <br>            case GIZMOTYPE_BUTTONNORMAL: <br>                pGizmo-&gt;dy=dy; <br>                pszClass=szButton; <br>                dwStyle=BS_PUSHBUTTON | WS_TABSTOP; <br>                break; <br> <br>            case GIZMOTYPE_SEPARATOR: <br>                pGizmo-&gt;dx=dx; <br>                pGizmo-&gt;y=3; <br>                break; <br> <br>            case GIZMOTYPE_BUTTONATTRIBUTEIN: <br>            case GIZMOTYPE_BUTTONATTRIBUTEEX: <br>            case GIZMOTYPE_BUTTONCOMMAND: <br>                pGizmo-&gt;dx=dx; <br>                pGizmo-&gt;y=3; <br>                break; <br>            } <br> <br> <br>    //If we matched a classname, create a window. <br>    if (GIZMOTYPE_WINDOWS &amp; iType) <br>        { <br>        if (!IsWindow(hWndParent)) <br>            return pGizmo; <br> <br>        hInst=GETWINDOWINSTANCE(hWndParent);    //Macro in book1632.h <br> <br>        // CreateWindowW fails on Windows 95.  Must use CreateWindowA instead. <br>        pGizmo-&gt;hWnd = NULL; <br>        { <br>            char * sz = NULL; <br>            int fSuccess = TRUE; <br>            if (pszText) <br>            { <br>                int iLen; <br>                iLen = wcslen(pszText); <br>                sz = malloc(sizeof(char) * (iLen + 1)); <br>                if (!sz) <br>                { <br>                    fSuccess = FALSE; <br>                } <br>                else <br>                { <br>                    wcstombs(sz, pszText, iLen); <br>                } <br>            } <br>            if (fSuccess) <br>            { <br>                pGizmo-&gt;hWnd=CreateWindowA(pszClass, sz <br>                    , dwStyle | WS_CHILD | WS_VISIBLE, pGizmo-&gt;x, pGizmo-&gt;y <br>                    , dx, pGizmo-&gt;dy, hWndParent, (HMENU)uID, hInst, NULL); <br>                if (sz) <br>                { <br>                    free(sz); <br>                } <br>            } <br>        } <br> <br>        if (NULL==pGizmo-&gt;hWnd) <br>            return pGizmo; <br> <br>        /* <br>         * Subclass comboboxes, listboxes, edits, and windowed <br>         * buttons.  We use iType to index the original proc array <br>         * so we can use a single subclass procedure for all <br>         * controls.  If you mess with the gizmo type definitions, <br>         * this is going to break. <br>         */ <br> <br>        if (GIZMOTYPE_WINDOWS &amp; iType &amp;&amp; GIZMOTYPE_TEXT!=iType) <br>            { <br>            //Give the window its type. <br>            BITPOSITION(iType, i); <br>            SetProp(pGizmo-&gt;hWnd, SZTYPEPROP, (HANDLE)i); <br> <br>            if (NULL==pfnOrg[i]) <br>                { <br>                pfnOrg[i]=(WNDPROC)GetWindowLong(pGizmo-&gt;hWnd <br>                    , GWL_WNDPROC); <br>                } <br> <br>            SetWindowLong(pGizmo-&gt;hWnd, GWL_WNDPROC <br>                , (LONG)GenericSubProc); <br> <br>            //If we're a combobox, subclass edit control <br>            if (GIZMOTYPE_COMBOBOX==iType) <br>                { <br>                hWndE=GetDlgItem(pGizmo-&gt;hWnd, ID_COMBOEDIT); <br>                SetProp(hWndE, SZTYPEPROP, (HANDLE)-1); <br> <br>                if (NULL==pfnOrg[0]) <br>                    { <br>                    pfnOrg[0]=(WNDPROC)GetWindowLong(pGizmo-&gt;hWnd <br>                        , GWL_WNDPROC); <br>                    } <br> <br>                SetWindowLong(hWndE, GWL_WNDPROC <br>                    , (LONG)GenericSubProc); <br>                } <br>            } <br>        } <br> <br> <br>    //Finally, move all our neighbors to the right to accomodate us. <br>    GizmosExpand(pGizmo); <br> <br>    *pfSuccess=TRUE; <br>    return pGizmo; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmoPFree <br> * <br> * Purpose: <br> *  Reverses all initialization done by GizmoPAllocate, cleaning up <br> *  any allocations including the application structure itself. <br> * <br> * Parameters: <br> *  ppFirst         PPGIZMO providing the first gizmo in this list. <br> *  pGizmo          PGIZMO to the structure <br> * <br> * Return Value: <br> *  PGIZMO          NULL if successful, pGizmo if not, meaning we <br> *                  couldn't free something. <br> */ <br> <br>PGIZMO GizmoPFree(PPGIZMO ppFirst, PGIZMO pGizmo) <br>    { <br>    int     i; <br> <br>    if (NULL==pGizmo) <br>        return NULL; <br> <br>    //Move other gizmos to fill in this gap. <br>    GizmosCompact(pGizmo); <br> <br>    //Unsubclass <br>    if (GIZMOTYPE_WINDOWS &amp; pGizmo-&gt;iType <br>        &amp;&amp; GIZMOTYPE_TEXT!=pGizmo-&gt;iType) <br>        { <br>        i=(int)GetProp(pGizmo-&gt;hWnd, SZTYPEPROP); <br>        RemoveProp(pGizmo-&gt;hWnd, SZTYPEPROP); <br> <br>        if (GIZMOTYPE_COMBOBOX==pGizmo-&gt;iType) <br>            { <br>            HWND        hWndE; <br> <br>            hWndE=GetDlgItem(pGizmo-&gt;hWnd, ID_COMBOEDIT); <br>            RemoveProp(hWndE, SZTYPEPROP); <br>            } <br> <br>        SetWindowLong(pGizmo-&gt;hWnd, GWL_WNDPROC, (LONG)pfnOrg[i]); <br>        } <br> <br>    //If this was a window gizmo, destroy the window. <br>    if (NULL!=pGizmo-&gt;hWnd &amp;&amp; IsWindow(pGizmo-&gt;hWnd)) <br>        DestroyWindow(pGizmo-&gt;hWnd); <br> <br>    //Unlink ourselves. <br>    if (NULL!=pGizmo-&gt;pNext) <br>        pGizmo-&gt;pNext-&gt;pPrev=pGizmo-&gt;pPrev; <br> <br>    if (NULL!=pGizmo-&gt;pPrev) <br>        pGizmo-&gt;pPrev-&gt;pNext=pGizmo-&gt;pNext; <br>    else <br>        *ppFirst=pGizmo-&gt;pNext; <br> <br>    return (PGIZMO)LocalFree((HLOCAL)(UINT)(LONG)pGizmo); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmosExpand <br> * <br> * Purpose: <br> *  Given a starting gizmo and a width, moves it and all gizmos to <br> *  its right to the right by the width to make space for showing <br> *  or creating a new gizmo. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO specifying the gizmo that was inserted. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void GizmosExpand(PGIZMO pGizmo) <br>    { <br>    int         cx; <br> <br>    cx=(int)pGizmo-&gt;dx; <br> <br>    /* <br>     * If we and the next control are buttons, use our width-1 to <br>     * expand so we overlap borders with our neighboring button. <br>     */ <br> <br>    if (NULL!=pGizmo-&gt;pNext) <br>        { <br>        if ((GIZMOTYPE_BUTTONS &amp; pGizmo-&gt;pNext-&gt;iType) <br>            &amp;&amp; (GIZMOTYPE_BUTTONS &amp; pGizmo-&gt;iType)) <br>            cx-=1; <br>        } <br> <br>    //Walk the gizmo list moving them right by our width. <br>    pGizmo=pGizmo-&gt;pNext; <br> <br>    while (NULL!=pGizmo) <br>        { <br>        pGizmo-&gt;x+=cx; <br> <br>        //hWnd is NULL for buttons and separators. <br>        if (NULL!=pGizmo-&gt;hWnd) <br>            { <br>            SetWindowPos(pGizmo-&gt;hWnd, NULL, pGizmo-&gt;x, pGizmo-&gt;y <br>                , 0, 0, SWP_NOZORDER | SWP_NOSIZE); <br>            } <br> <br>        pGizmo=pGizmo-&gt;pNext; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmosCompact <br> * <br> * Purpose: <br> *  Given a gizmo, moves all other gizmos to the right of it to the <br> *  left by its width on the GizmoBar.  Used when removing or hiding <br> *  the gizmo. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO that is going away, visibly or physically. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void GizmosCompact(PGIZMO pGizmo) <br>    { <br>    UINT        cx; <br>    PGIZMO      pCur; <br> <br>    //Move all the gizmos beyond us back by our width. <br>    if (NULL!=pGizmo-&gt;pNext) <br>        { <br>        cx=pGizmo-&gt;pNext-&gt;x - pGizmo-&gt;x; <br>        pCur=pGizmo-&gt;pNext; <br> <br>        while (NULL!=pCur) <br>            { <br>            pCur-&gt;x-=cx; <br> <br>            if (NULL!=pCur-&gt;hWnd) <br>                { <br>                SetWindowPos(pCur-&gt;hWnd, NULL, pCur-&gt;x, pCur-&gt;y <br>                             , 0, 0, SWP_NOZORDER | SWP_NOSIZE); <br>                } <br> <br>            pCur=pCur-&gt;pNext; <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmoPFind <br> * <br> * Purpose: <br> *  Given a GIZMO identifier, locates and returns a pointer to the <br> *  structure for that position. <br> * <br> * Parameters: <br> *  ppFirst         PPGIZMO providing the first gizmo in this list. <br> *  uID             UINT identifier to find. <br> * <br> * Return Value: <br> *  PGIZMO          A pointer to a GIZMO structure allocated through <br> *                  GizmoPAllocate, NULL if iGizmo is out of range. <br> */ <br> <br>PGIZMO GizmoPFind(PPGIZMO ppFirst, UINT uID) <br>    { <br>    PGIZMO       pGizmo; <br> <br>    pGizmo=*ppFirst; <br> <br>    /* <br>     * Yep, linear search, but a better search algorithm won't <br>     * improve things appreciably.  The better thing to optimize <br>     * is what the caller passes as ppFirst. <br>     */ <br>    while (NULL!=pGizmo &amp;&amp; uID!=pGizmo-&gt;uID) <br>        pGizmo=pGizmo-&gt;pNext; <br> <br>    return pGizmo; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmoFEnum <br> * <br> * Purpose: <br> *  Enumerates the list of GIZMO structures, passing each one to <br> *  an application-defined callback. <br> * <br> * Parameters: <br> *  ppFirst         PPGIZMO providing the first gizmo in this list. <br> *  pfnEnum         PFNGIZMOENUM to call for each enumerated <br> *                  structure. <br> *  dw              DWORD extra data to pass to the enumeration <br> *                  function. <br> * <br> * Return Value: <br> *  PGIZMO          NULL if the enumeration completed.  Otherwise a <br> *                  pointer to the gizmo that enumeration stopped on. <br> */ <br> <br>PGIZMO GizmoPEnum(PPGIZMO ppFirst, PFNGIZMOENUM pfnEnum, DWORD dw) <br>    { <br>    PGIZMO  pGizmo; <br>    UINT    i=0; <br> <br>    pGizmo=*ppFirst; <br> <br>    while (NULL!=pGizmo) <br>        { <br>        if (!(*pfnEnum)(pGizmo, i++, dw)) <br>            break; <br> <br>        pGizmo=pGizmo-&gt;pNext; <br>        } <br> <br>    return pGizmo; <br>    } <br> <br> <br> <br> <br>/* <br> * GizmoPStateSet <br> * <br> * Purpose: <br> *  State maniuplation functions.  Set and Clear also invalidate <br> *  this gizmo's rectangle on the given window and forces a repaint. <br> * <br> * Parameters: <br> *  hWnd            HWND of the window to repaint. <br> *  pGizmo          PGIZMO affected. <br> *  dwNew           DWORD new state flags. <br> * <br> * Return Value: <br> *  UINT            Previous state. <br> */ <br> <br>UINT  GizmoPStateSet(HWND hWnd, PGIZMO pGizmo, UINT uNew) <br>    { <br>    UINT        uRet; <br>    RECT        rc; <br> <br>    if (GIZMOTYPE_SEPARATOR==pGizmo-&gt;iType) <br>        return pGizmo-&gt;uState; <br> <br>    //Preserve the color conversion flags across this state change. <br>    uRet=pGizmo-&gt;uState; <br>    pGizmo-&gt;uState=(uNew &amp; 0x00FF) | (uRet &amp; 0xFF00); <br> <br>    //Adjust the rectangle by  one to avoid repainting  borders. <br>    SetRect(&amp;rc, pGizmo-&gt;x+1, pGizmo-&gt;y+1, pGizmo-&gt;x+pGizmo-&gt;dx-1 <br>        , pGizmo-&gt;y+pGizmo-&gt;dy-1); <br>    InvalidateRect(hWnd, &amp;rc, FALSE); <br>    UpdateWindow(hWnd); <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmoPCheck <br> * <br> * Purpose: <br> *  Handles checking a single button in a group of attribute buttons. <br> *  If the gizmo belongs to a group of mutually exclusive buttons <br> *  then the others surrounding it are unchecked appropriately. <br> * <br> * Parameters: <br> *  hWnd            HWND of the GizmoBar. <br> *  pGizmo          PGIZMO of the gizmo affected. <br> *  fCheck          BOOL TRUE to check the button, FALSE to uncheck. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the gizmo was previously checked, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL GizmoPCheck(HWND hWnd, PGIZMO pGizmo, BOOL fCheck) <br>    { <br>    BOOL        fPrevCheck; <br>    PGIZMO      pCur; <br> <br> <br>    //Ignore command buttons. <br>    if (GIZMOTYPE_BUTTONCOMMAND==pGizmo-&gt;iType) <br>        return FALSE; <br> <br>    //Get the previous state <br>    fPrevCheck=(BOOL)(BUTTONGROUP_DOWN &amp; pGizmo-&gt;uState); <br> <br> <br>    //Simply set the state for inclusive attribute buttons. <br>    if (GIZMOTYPE_BUTTONATTRIBUTEIN==pGizmo-&gt;iType) <br>        { <br>        if (pGizmo-&gt;fDisabled) <br>            { <br>            GizmoPStateSet(hWnd, pGizmo <br>                , fCheck ? ATTRIBUTEBUTTON_DOWNDISABLED <br>                : ATTRIBUTEBUTTON_DISABLED); <br>            } <br>        else <br>            { <br>            GizmoPStateSet(hWnd, pGizmo, fCheck <br>                ? ATTRIBUTEBUTTON_DOWN : ATTRIBUTEBUTTON_UP); <br>            } <br>        } <br> <br> <br>    if (GIZMOTYPE_BUTTONATTRIBUTEEX==pGizmo-&gt;iType) <br>        { <br>        //We cannot uncheck an exclusive attribute <br>        if (!fCheck) <br>            return fPrevCheck; <br> <br>        /* <br>         * For exclusive buttons we have to do more work.  First, if <br>         * we're already checked (incliding DOWN and MOUSEDOWN) then <br>         * we set DOWN and exit.  If we're not already checked, then <br>         * we look for the gizmo around us, backwards and forwards, <br>         * that is checked and uncheck him. <br>         */ <br> <br>        //Search  backwards. <br>        pCur=pGizmo-&gt;pPrev; <br> <br>        while (NULL!=pCur) <br>            { <br>            //Stop at any non-exclusive attribute. <br>            if (GIZMOTYPE_BUTTONATTRIBUTEEX!=pCur-&gt;iType) <br>                { <br>                pCur=NULL; <br>                break; <br>                } <br> <br>            //If it's down, set it up and we've finished. <br>            if (BUTTONGROUP_DOWN &amp; pCur-&gt;uState) <br>                break; <br> <br>            pCur=pCur-&gt;pPrev; <br>            } <br> <br> <br>        //If we didn't find a previous one, pCur is NULL, look ahead. <br>        if (NULL==pCur) <br>            { <br>            pCur=pGizmo-&gt;pNext; <br> <br>            while (NULL!=pCur) <br>                { <br>                //Stop at any non-exclusive attribute. <br>                if (GIZMOTYPE_BUTTONATTRIBUTEEX!=pCur-&gt;iType) <br>                    { <br>                    pCur=NULL; <br>                    break; <br>                    } <br> <br>                //If it's down, set it up and we've finished. <br>                if (BUTTONGROUP_DOWN &amp; pCur-&gt;uState) <br>                    break; <br> <br>                pCur=pCur-&gt;pNext; <br>                } <br>            } <br> <br>        //If pCur is non-NULL, we found a neighbor, so uncheck it <br>        if (NULL!=pCur) <br>            { <br>            GizmoPStateSet(hWnd, pCur, (pGizmo-&gt;fDisabled) <br>                ? ATTRIBUTEBUTTON_DISABLED : ATTRIBUTEBUTTON_UP); <br>            } <br> <br>        //Always set ourselves down <br>        GizmoPStateSet(hWnd, pGizmo, (pGizmo-&gt;fDisabled) <br>            ? ATTRIBUTEBUTTON_DOWNDISABLED : ATTRIBUTEBUTTON_DOWN); <br>        } <br> <br>    return fPrevCheck; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * GenericSubProc <br> * <br> * Purpose: <br> *  Subclasses window controls in Gizmos so we can trap the tab key <br> *  and tab to the next control.  We can have one shared generic <br> *  subclass procedure because we save the type index for this <br> *  control in the property "iType."  This allows us to look up the <br> *  original procedure in the pfnOrg array. <br> * <br> * Parameters: <br> *  Standard <br> * <br> * Return Value: <br> *  Standard <br> */ <br> <br>LRESULT APIENTRY GenericSubProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    LONG        lRet; <br>    RECT        rc; <br>    RECT        rcE; <br>    HWND        hWndE; <br>    HBRUSH      hBr; <br>    HDC         hDC; <br>    UINT        dx; <br>    UINT        iType, i; <br> <br>    i=(int)GetProp(hWnd, SZTYPEPROP); <br>    iType=POSITIONBIT(i); <br> <br>    //Special:  paint the gap in drop-down comboboxes. <br>    if (GIZMOTYPE_COMBOBOX==iType &amp;&amp; WM_PAINT==iMsg) <br>        { <br>        //Do default painting. <br>        lRet=(*pfnOrg[i])(hWnd, iMsg, wParam, lParam); <br> <br>        hWndE=GetDlgItem(hWnd, ID_COMBOEDIT); <br> <br>        GetClientRect(hWnd, &amp;rc); <br>        GetClientRect(hWndE, &amp;rcE); <br> <br>        //The width of the button is the scroll bar width. <br>        dx=GetSystemMetrics(SM_CXVSCROLL); <br> <br>        //Calculate the rectangle <br>        rc.right -=dx; <br>        rc.left   =rcE.right; <br>        rc.bottom+=1; <br> <br>        //Paint the gap <br>        hDC=GetDC(hWnd);   //Already did BeginPaint and EndPaint <br> <br>        hBr=CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>        FillRect(hDC, &amp;rc, hBr); <br>        DeleteObject(hBr); <br> <br>        ReleaseDC(hWnd, hDC); <br>        return lRet; <br>        } <br> <br>    //Control tabbing to the next or previous control <br>    if (WM_KEYDOWN==iMsg &amp;&amp; VK_TAB==wParam) <br>        { <br>        hWndE=hWnd; <br> <br>        if (-1==i) <br>            hWndE=GetParent(hWnd); <br> <br>        hWndE=GetNextDlgTabItem(GetParent(hWndE), hWnd <br>            , (BOOL)(GetKeyState(VK_SHIFT))); <br>        SetFocus(hWndE); <br>        return 0L; <br>        } <br> <br>    if (-1==i) i=0; <br> <br>    //Eat tab chars in edit controls to prevent beeping. <br>    if (0==i &amp;&amp; WM_CHAR==iMsg &amp;&amp; VK_TAB==wParam) <br>        return 0L; <br> <br> <br>    //Do this or edit controls bomb big-time. <br>    return CallWindowProc(pfnOrg[i], hWnd, iMsg, wParam, lParam); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
