<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context239"></a>SERVER.CXX</h2>
<pre><code>/*+---------------------------------------------------------------------------- <br> <br>Microsoft Windows Sample Program <br>Copyright 1994 - 1998 Microsoft Corporation.  All rights reserved. <br> <br>FILE:       server.cxx <br> <br>USAGE:      server /REGSERVER   - Installs registry entries for the server. <br>            server /UNREGSERVER - Removes registry entries for the server. <br>            server -Embedding   - Server was auto-started by OLE. <br> <br>PURPOSE:    Example of an OLE local server using a custom interface. <br>            This program illustrates the correct reference counting and  <br>            shutdown behavior for a multiple-use local server.   <br>             <br>            The sample code is safe for multiple threads.  This is not <br>            really necessary, but it makes it easy to convert this program <br>            to a multi-threaded server for a future version of Windows. <br> <br>            This sample also provides an example of how to use the  <br>            Win32 registry functions to install a local server and a  <br>            proxy DLL in the registry. <br> <br> <br>FUNCTIONS:  DecrementLockCount  - Decrement the server's lock count. <br>            IncrementLockCount  - Increment the server's lock count. <br>            main                - Main entry point. <br>            ObjectCreated       - Called when object is created. <br>            ObjectDestroyed     - Called when object is destroyed. <br>            RegisterLocalServer - Create a registry entry for a local server. <br>            RegisterProxyDll    - Create a registry entry for a proxy DLL. <br>            UnregisterLocalServer - Remove a registry entry for a local server. <br>            UnregisterProxyDll  - Remove a registry entry for a proxy DLL. <br> <br>COMMENTS:   The server program must be installed before running the client. <br>            Run server.exe /REGSERVER to install the server program. <br> <br>-----------------------------------------------------------------------------*/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "ohello.h" <br> <br>void    PrintErrorMessage(HRESULT hr); <br>HRESULT RegisterClassFactory(); <br>HRESULT RevokeClassFactory(); <br> <br>//Prototypes for local functions <br>HRESULT RegisterLocalServer(REFCLSID rclsid); <br>HRESULT RegisterProxyDll(const char *pszProxyDll); <br>HRESULT UnregisterLocalServer(REFCLSID rclsid); <br>HRESULT UnregisterProxyDll(const char *pszProxyDll); <br> <br>//CLSID for the server object <br>extern "C" const CLSID CLSID_OHello  <br>    = {0xf9246031,0x9f33,0x11cd,{0xb2,0x3f,0x00,0xaa,0x00,0x33,0x9c,0xce}}; <br> <br>long    g_LockCount   = 0; <br>long    g_ObjectCount = 0; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DecrementLockCount <br>// <br>//  Synopsis:   Decrements the lock count.  The lock count controls the  <br>//              registration of the class factory in the class table. <br>//              DecrementLockCount revokes the class factory when the  <br>//              lock count is zero. <br>// <br>//  Called By:  ~CHello, IClassFactory::LockServer(FALSE). <br>// <br>//  See Also:   ObjectCreated, ObjectDestroyed, IncrementLockCount. <br>// <br>//---------------------------------------------------------------------------- <br>void DecrementLockCount() <br>{ <br>    //Decrement the lock count. <br>    if(InterlockedDecrement(&amp;g_LockCount) == 0) <br>    { <br>        //When the lock count is decremented to zero, <br>        //revoke the class factory. <br>        RevokeClassFactory(); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   IncrementLockCount <br>// <br>//  Synopsis:   Increments the lock count.  The lock count controls the  <br>//              registration of the class factory in the class table. <br>//              If necessary, IncrementLockCount will reregister the class <br>//              factory in the class table. <br>// <br>//  Called By:  CHello, IClassFactory::LockServer(TRUE). <br>// <br>//  See Also:   DecrementLockCount, ObjectCreated, ObjectDestroyed. <br>// <br>//---------------------------------------------------------------------------- <br>void IncrementLockCount() <br>{ <br>    if(g_LockCount == 0) <br>    { <br>        //Increment the lock count. <br>        InterlockedIncrement(&amp;g_LockCount); <br> <br>        //Reregister the class factory if necessary. <br>        RegisterClassFactory(); <br>    } <br>    else <br>    { <br>        //Increment the lock count. <br>        InterlockedIncrement(&amp;g_LockCount); <br>    } <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   main <br>// <br>//  Synopsis:   Main entry point for the server application.  This function  <br>//              initializes the server and processes the message loop. <br>// <br>//---------------------------------------------------------------------------- <br>int _cdecl main(int argc, char *argv[]) <br>{ <br>    HRESULT hr = S_OK; <br>    int i; <br>    BOOL fRegisterServer = FALSE; <br>    BOOL fUnregisterServer = FALSE; <br>    BOOL fEmbedding = FALSE; <br>    BOOL fHelp = FALSE; <br>    MSG msg; <br> <br>    // Parse each item, skip the command name <br>    for (i = 1; i &lt; argc; i++) <br>    { <br>        if (stricmp( argv[i], "-Embedding" ) == 0) <br>        { <br>            //This server has been activated by OLE. <br>            fEmbedding = TRUE; <br>        } <br>        else if (stricmp( argv[i], "/REGSERVER" ) == 0) <br>        { <br>            fRegisterServer = TRUE; <br>        } <br>        else if (stricmp( argv[i], "/UNREGSERVER" ) == 0) <br>        { <br>            fUnregisterServer = TRUE; <br>        } <br>        else <br>        { <br>            fHelp = TRUE; <br>        } <br>    } <br> <br>    if(fHelp == TRUE) <br>        { <br>        printf("USAGE: server /REGSERVER   - Installs server in the registry.\n"); <br>        printf("       server /UNREGSERVER - Removes server from the registry.\n"); <br>        printf("       server -Embedding   - Server was auto-started by OLE.\n"); <br>        return 0; <br>    } <br>    else if(fUnregisterServer == TRUE) <br>    { <br>        hr = UnregisterLocalServer(CLSID_OHello); <br>        if(FAILED(hr)) <br>        { <br>            printf("Failed to remove local server from the registry.\n"); <br>            PrintErrorMessage(hr); <br>        } <br> <br>        hr = UnregisterProxyDll("ohello.dll"); <br>        if(FAILED(hr)) <br>        { <br>            printf("Failed to remove proxy DLL from the registry.\n"); <br>            PrintErrorMessage(hr); <br>        } <br>        return 0; <br>    } <br>     <br> <br>    //Install the local server in the registry. <br>    hr = RegisterLocalServer(CLSID_OHello); <br>    if(FAILED(hr)) <br>    { <br>        printf("Failed to install local server in the registry.\n"); <br>        PrintErrorMessage(hr); <br>    } <br> <br>    //Install the proxy DLL in the registry. <br>    hr = RegisterProxyDll("ohello.dll"); <br>    if(FAILED(hr)) <br>    { <br>        printf("Failed to install proxy DLL in the registry.\n"); <br>        PrintErrorMessage(hr); <br>    } <br> <br>    if(fRegisterServer == TRUE) <br>        return 0; <br> <br>   <br>    // <br>    // Initialize OLE before calling any other OLE functions. <br>    // <br> <br>    hr = CoInitialize(NULL); <br> <br>    if(SUCCEEDED(hr)) <br>    {    <br>        hr = RegisterClassFactory(); <br> <br>        if(SUCCEEDED(hr)) <br>        { <br>            printf("Waiting for client to connect...\n"); <br>            // Main message loop.  We will remain in the message loop  <br>            // until we get a WM_QUIT message. <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>        } <br> <br>            //If the class factory is still registered in the  <br>            //class table, revoke it before we shut down. <br>            RevokeClassFactory(); <br>    } <br>        else <br>        { <br>            printf("Failed to register class factory.\n"); <br>            PrintErrorMessage(hr); <br>        } <br>        CoUninitialize(); <br>    } <br>    else <br>    { <br>        printf("CoInitialize failed.\n"); <br>        PrintErrorMessage(hr); <br>    } <br> <br>    return 0; <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ObjectCreated <br>// <br>//  Synopsis:   Increments the object count controlling the main message loop <br>//              of the server process.   <br>// <br>//  Called By:  CHello, CHelloFactory. <br>// <br>//  See Also:   DecrementLockCount, IncrementLockCount, ObjectDestroyed. <br>// <br>//---------------------------------------------------------------------------- <br>void ObjectCreated() <br>{ <br>    InterlockedIncrement(&amp;g_ObjectCount); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ObjectDestroyed <br>// <br>//  Synopsis:   Decrements the object count controlling the main message loop  <br>//              of the server process.  When the object count is decremented  <br>//              to zero, we post a WM_QUIT message.  The main message loop will <br>//              exit and terminate the server process. <br>// <br>//  Called By:  ~CHello, ~CHelloFactory. <br>// <br>//  See Also:   DecrementLockCount, IncrementLockCount, ObjectCreated. <br>// <br>//---------------------------------------------------------------------------- <br>void ObjectDestroyed() <br>{ <br>    if(InterlockedDecrement(&amp;g_ObjectCount) == 0) <br>    { <br>        //When the last object is released, post a quit message. <br>        PostQuitMessage(0); <br>    } <br>} <br> <br>   <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   RegisterLocalServer <br>// <br>//  Synopsis:   Creates a registry key for a local server. <br>// <br>//  Parameters: rclsid - Supplies the class ID of the local server. <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT RegisterLocalServer(REFCLSID rclsid) <br>{ <br>    HRESULT hr; <br>    LONG error; <br>    HKEY hKeyCLSID;         // key for ...\Classes\CLSID <br>    HKEY hKeyClassID; <br>    HKEY hKey;              // current key <br>    DWORD dwDisposition; <br>    char szServer[MAX_PATH]; <br>    char szClassID[39]; <br>    unsigned long length; <br> <br>    length = GetModuleFileNameA(0, szServer, sizeof(szServer)); <br> <br>    if(length == 0) <br>    { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>        return hr; <br>    } <br> <br>    //create the CLSID key <br>    error = RegCreateKeyExA( <br>            HKEY_CLASSES_ROOT,  <br>            "CLSID", <br>            0,  <br>            "REG_SZ",  <br>            REG_OPTION_NON_VOLATILE, <br>            KEY_ALL_ACCESS, <br>            0, <br>            &amp;hKeyCLSID, <br>            &amp;dwDisposition); <br> <br>    if(!error) <br>    { <br>        //convert the class ID to a registry key name. <br>        sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", <br>                rclsid.Data1, rclsid.Data2, rclsid.Data3, <br>                rclsid.Data4[0], rclsid.Data4[1], <br>                rclsid.Data4[2], rclsid.Data4[3], <br>                rclsid.Data4[4], rclsid.Data4[5], <br>                rclsid.Data4[6], rclsid.Data4[7]); <br>   <br>        //create key for the server class <br>        error = RegCreateKeyExA(hKeyCLSID,  <br>                                szClassID, <br>                                0,  <br>                                "REG_SZ",  <br>                                REG_OPTION_NON_VOLATILE, <br>                                KEY_ALL_ACCESS, <br>                                0, <br>                                &amp;hKeyClassID, <br>                                &amp;dwDisposition); <br> <br>        if(!error) <br>        { <br>            //create LocalServer32 key. <br>            error = RegCreateKeyExA(hKeyClassID,            <br>                                    "LocalServer32", <br>                                    0,  <br>                                    "REG_SZ",  <br>                                    REG_OPTION_NON_VOLATILE, <br>                                    KEY_ALL_ACCESS, <br>                                    0,             <br>                                    &amp;hKey, <br>                                    &amp;dwDisposition); <br> <br>            if(!error) <br>            { <br>                //Set the server name. <br>                error = RegSetValueExA(hKey,  <br>                                       "",  <br>                                       0,  <br>                                       REG_SZ,  <br>                                       (const unsigned char *)szServer, <br>                                       strlen(szServer) + 1); <br> <br>                RegFlushKey(hKey); <br>                RegCloseKey(hKey); <br>            } <br>            RegCloseKey(hKeyClassID); <br>        } <br>        RegCloseKey(hKeyCLSID); <br>    } <br> <br>    if(!error) <br>        hr = S_OK; <br>    else <br>        hr = HRESULT_FROM_WIN32(error); <br> <br>    return hr; <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   RegisterProxyDll <br>// <br>//  Synopsis:   Creates registry entries for the interfaces contained in a  <br>//              proxy DLL.   <br>// <br>//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL. <br>// <br>//  Notes:      RegisterProxyDll calls the DllRegisterServer function  <br>//              exported from the proxy DLL. <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT RegisterProxyDll(const char *pszProxyDll) <br>{ <br>    HRESULT hr; <br>    HINSTANCE hProxyDll; <br>    HRESULT (STDAPICALLTYPE *pfnDllRegisterServer)(); <br>  <br>    hProxyDll = LoadLibraryA(pszProxyDll); <br>     <br>    if(hProxyDll != 0) <br>    { <br>        pfnDllRegisterServer = (HRESULT (STDAPICALLTYPE *)()) <br>            GetProcAddress(hProxyDll, "DllRegisterServer"); <br>         <br>        if(pfnDllRegisterServer != 0) <br>            hr = (*pfnDllRegisterServer)(); <br>        else <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br> <br>        FreeLibrary(hProxyDll); <br>    } <br>    else <br>    { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>    } <br> <br>    return hr; <br>} <br> <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   UnregisterLocalServer <br>// <br>//  Synopsis:   Removes the registry key for a local server. <br>// <br>//  Parameters: rclsid - Supplies the class ID of the local server. <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT UnregisterLocalServer(REFCLSID rclsid) <br>{ <br>    HRESULT hr; <br>    HKEY hKeyCLSID; <br>    HKEY hKeyClassID; <br>    long error; <br>    char szClassID[39]; <br> <br>    //open the CLSID key <br>    error = RegOpenKeyExA( <br>        HKEY_CLASSES_ROOT,  <br>        "CLSID", <br>        0,  <br>        KEY_ALL_ACCESS, <br>        &amp;hKeyCLSID); <br> <br>    if(!error) <br>    {  <br>    //convert the class ID to a registry key name. <br>    sprintf(szClassID, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", <br>            rclsid.Data1, rclsid.Data2, rclsid.Data3, <br>            rclsid.Data4[0], rclsid.Data4[1], <br>            rclsid.Data4[2], rclsid.Data4[3], <br>            rclsid.Data4[4], rclsid.Data4[5], <br>            rclsid.Data4[6], rclsid.Data4[7]); <br> <br>        //open registry key for class ID string <br>        error = RegOpenKeyExA( <br>            hKeyCLSID,  <br>            szClassID, <br>            0,  <br>            KEY_ALL_ACCESS, <br>            &amp;hKeyClassID); <br> <br>        if(!error) <br>        { <br>            //delete LocalServer32 key.  <br>            error = RegDeleteKeyA(hKeyClassID, "LocalServer32"); <br>            RegCloseKey(hKeyClassID);           <br>        } <br> <br>        error = RegDeleteKeyA(hKeyCLSID, szClassID); <br>        RegCloseKey(hKeyCLSID); <br>    } <br> <br>    if(!error) <br>        hr = S_OK; <br>    else <br>        hr = HRESULT_FROM_WIN32(error); <br> <br>    return hr; <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   UnregisterProxyDll <br>// <br>//  Synopsis:   Removes registry entries for the interfaces contained in a  <br>//              proxy DLL.   <br>// <br>//  Parameters: pszProxyDll - Supplies the filename of the proxy DLL. <br>// <br>//  Notes:      UnregisterProxyDll calls the DllUnregisterServer function  <br>//              exported from the proxy DLL. <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT UnregisterProxyDll(const char *pszProxyDll) <br>{ <br>    HRESULT hr; <br>    HINSTANCE hProxyDll; <br>    HRESULT (STDAPICALLTYPE *pfnDllUnregisterServer)(); <br>     <br>    hProxyDll = LoadLibraryA(pszProxyDll); <br>     <br>    if(hProxyDll != 0) <br>    { <br>        pfnDllUnregisterServer = (HRESULT (STDAPICALLTYPE *)()) <br>            GetProcAddress(hProxyDll, "DllUnregisterServer"); <br>         <br>        if(pfnDllUnregisterServer != 0) <br>            hr = (*pfnDllUnregisterServer)(); <br>        else <br>            hr = HRESULT_FROM_WIN32(GetLastError()); <br>     <br>        FreeLibrary(hProxyDll); <br>    } <br>    else <br>    { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>    } <br> <br>    return hr; <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
