<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIENT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context231"></a>CLIENT.C</h2>
<pre><code>/**************************************************************************** <br>                       Microsoft RPC <br>                Copyright Microsoft Corp. 1992-1996 <br>                  object call_as Example <br> <br>    FILE:       client.c <br> <br>    USAGE:      client <br> <br>    PURPOSE:    Client side application of remoted custom interface <br> <br>    FUNCTIONS:  main() - binds to server and calls remote procedure <br> <br>    COMMENTS:   This version of the Ole2 distributed application that <br>                prints "hello, world" (or other string) on the server <br>                features a non-rpcable custom interface being remoted with <br>                [call_as]. <br> <br>****************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;assert.h&gt; <br>#include "callas.h"     // generated by MIDL from callas.idl/.acf <br> <br>// the class ID of the server exe <br>const <br>CLSID CLSID_CallAs = <br>    {0xf9246030,0x9f33,0x11cd,{0xb2,0x3f,0x00,0xaa,0x00,0x33,0x9c,0xce}}; <br> <br> <br>/*********************************************************************** <br> <br>    set up the following registry keys: <br> <br>    \Registry\Machine\Software\Classes <br>        CLSID <br>            {f9246030-9f33-11cd-b23f-00aa00339cce} <br>                LocalServer32 <br>                    = server.exe <br>            {a46deb30-9f33-11cd-b23f-00aa00339cce} <br>                InProcServer32 <br>                    = callas.dll <br>        Interface <br>            {a46deb30-9f33-11cd-b23f-00aa00339cce} <br>                ProxyStubClsid32 <br>                    = {a46deb30-9f33-11cd-b23f-00aa00339cce} <br> <br>    for the server, the LocalServer32 is the out-of-process server exe <br>    for the proxy, the InProcServer32 is the proxy dll <br>    for the interface, the ProxyStubClsid32 is the class id of the <br>        proxy class factory. <br> <br>***********************************************************************/ <br> <br>void InitializeRegistry(char *pszProxyDll, char *pszServer) <br>{ <br>    // the server exe CLSID <br>    const char *pszServerKey = "{f9246030-9f33-11cd-b23f-00aa00339cce}"; <br> <br>    // the interface UUID <br>    const char *pszInterfaceKey = "{a46deb30-9f33-11cd-b23f-00aa00339cce}"; <br> <br>    // the class factory CLSID ( the same as the interface UUID ) <br>    const char *pszProxyDllKey = "{a46deb30-9f33-11cd-b23f-00aa00339cce}"; <br> <br> <br>    LONG error          = 0; <br>    HKEY hKeyInterface;     // key for ...\Classes\Interface <br>    HKEY hKeyCLSID;         // key for ...\Classes\CLSID <br>    HKEY hKey;              // current key <br>    DWORD dwDisposition; <br> <br>    //Register the interfaces. <br> <br>    //create ...\Classes\Interface key <br>    error = RegCreateKeyEx( <br>        HKEY_CLASSES_ROOT, <br>        "Interface", <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKeyInterface, <br>        &amp;dwDisposition); <br> <br>    // create the ...\Classes\Interface\{ &lt;interface uuid&gt; }  key <br>    error = RegCreateKeyEx( <br>        hKeyInterface, <br>        pszInterfaceKey, <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //create ProxyStubClsid32 key under the interface <br>    error = RegCreateKeyEx( <br>        hKey, <br>        "ProxyStubClsid32", <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //Set the class id for the PSFactoryBuffer for the interface <br>    error = RegSetValueEx( <br>        hKey, <br>        "", <br>        0, <br>        REG_SZ, <br>        pszProxyDllKey, <br>        strlen(pszProxyDllKey) + 1); <br> <br> <br>    //Register the classes. <br> <br>    //create the CLSID key <br>    error = RegCreateKeyEx( <br>        HKEY_CLASSES_ROOT, <br>        "CLSID", <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKeyCLSID, <br>        &amp;dwDisposition); <br> <br>    //create key for the server <br>    error = RegCreateKeyEx( <br>        hKeyCLSID, <br>        pszServerKey, <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //create LocalServer32 key. <br>    error = RegCreateKeyEx( <br>        hKey, <br>        "LocalServer32", <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //Set the server name. <br>    error = RegSetValueEx( <br>        hKey, <br>        "", <br>        0, <br>        REG_SZ, <br>        pszServer, <br>        strlen(pszServer) + 1); <br> <br>    error = RegFlushKey( <br>        hKey ); <br> <br> <br>    //create key for the proxy dll <br>    error = RegCreateKeyEx( <br>        hKeyCLSID, <br>        pszProxyDllKey, <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //create InProcServer32 key for the proxy dll <br>    error = RegCreateKeyEx( <br>        hKey, <br>        "InProcServer32", <br>        0, <br>        "REG_SZ", <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_ALL_ACCESS, <br>        0, <br>        &amp;hKey, <br>        &amp;dwDisposition); <br> <br>    //register the proxy DLL <br>    error = RegSetValueEx( <br>        hKey, <br>        "", <br>        0, <br>        REG_SZ, <br>        pszProxyDll, <br>        strlen(pszProxyDll) + 1); <br> <br>    error = RegFlushKey( <br>        hKey ); <br> <br>    //  printf("waiting for registry to update OLE\n"); <br>    Sleep(1000); <br>} <br> <br>void Test() <br>{ <br>    IClassFactory *pClassFactory =0; <br>    IUnknown *punk = 0; <br>    IHelloCallAs *pCallAs = 0; <br>    HRESULT hr; <br> <br>    hr = CoInitialize(NULL); <br>    if (FAILED(hr)) <br>    { <br>        printf("CoInitialize failed with %lx\n", hr); <br>        return; <br>    } <br> <br>    hr = CoGetClassObject(&amp;CLSID_CallAs, CLSCTX_LOCAL_SERVER, 0, &amp;IID_IClassFactory, &amp;pClassFactory); <br>    if(FAILED(hr)) <br>        printf("CoGetClassObject failed with %lx\n", hr); <br>    else <br>    { <br>        assert(pClassFactory); <br>        hr = pClassFactory-&gt;lpVtbl-&gt;CreateInstance(pClassFactory, 0, &amp;IID_IUnknown, &amp;punk); <br>        if(FAILED(hr)) <br>            printf("IClassFactory::CreateInstance failed with %lx\n", hr); <br>        else <br>        { <br>            assert(punk); <br>            hr = punk-&gt;lpVtbl-&gt;QueryInterface(punk, &amp;IID_IHelloCallAs, &amp;pCallAs); <br>            if(FAILED(hr)) <br>                printf("IUnknown::QueryInterface failed with %lx\n", hr); <br>            else <br>            { <br>                assert(pCallAs); <br>                hr = pCallAs-&gt;lpVtbl-&gt;HelloProc(pCallAs, "Hello World!"); <br>                if(FAILED(hr)) <br>                    printf("IHelloCallAs::HelloProc failed with %lx\n", hr); <br>                else <br>                    printf("IHelloCallAs::HelloProc succeeded"); <br> <br>                pCallAs-&gt;lpVtbl-&gt;Release(pCallAs); <br>                pCallAs = 0; <br>            } <br>            punk-&gt;lpVtbl-&gt;Release(punk); <br>            punk = 0; <br>        } <br>        pClassFactory-&gt;lpVtbl-&gt;Release(pClassFactory); <br>        pClassFactory = 0; <br>    } <br>    CoUninitialize(); <br>} <br> <br>void TestDll() <br>{ <br>    // the dll name of the proxy dll <br>    const char *pszProxyDllName = "callas.dll"; <br> <br>    char szDrive[_MAX_DRIVE]; <br>    char szDirectory[_MAX_DIR]; <br>    char szFileName[_MAX_FNAME]; <br> <br>    char szClient[_MAX_PATH]; <br>    char szProxyDll[_MAX_PATH]; <br>    char szServer[_MAX_PATH]; <br> <br>    GetModuleFileName(0, szClient, _MAX_PATH); <br>    _splitpath(szClient, szDrive, szDirectory, szFileName, NULL); <br> <br>    //Get the full path name of the server. <br>    sprintf(szServer, "%s%sserver.exe", szDrive, szDirectory); <br> <br>    //Get the full path name of the proxy dll. <br>    sprintf(szProxyDll, "%s%s%s", szDrive, szDirectory, pszProxyDllName); <br> <br>    printf("Testing Dll\n"); <br>    InitializeRegistry(szProxyDll, szServer); <br> <br>    Test(); <br>} <br> <br> <br>void __cdecl main(int argc, char *argv[]) <br>{ <br>    TestDll(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
