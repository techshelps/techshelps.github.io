<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHELLO.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context238"></a>CHELLO.CXX</h2>
<pre><code>/*+---------------------------------------------------------------------------- <br> <br>Microsoft Windows Sample Program <br>Copyright 1994 - 1998 Microsoft Corporation.  All rights reserved. <br> <br>FILE:       CHello.cxx <br> <br>PURPOSE:    Implements the CHello object and class factory. <br> <br>CLASSES:    CHello <br>            CHelloClassFactory <br> <br>FUNCTIONS:  RegisterClassFactory <br>            RevokeClassFactory <br> <br>-----------------------------------------------------------------------------*/ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "ohello.h" <br> <br>void DecrementLockCount(); <br>void IncrementLockCount(); <br>void ObjectCreated(); <br>void ObjectDestroyed(); <br> <br>extern "C" const CLSID CLSID_OHello; <br> <br>long    g_fClassRegistered  = FALSE; <br>DWORD   g_dwRegister        = 0; <br> <br>//The CHello class implements the server object. <br>class CHello : public IHello <br>{ <br>private: <br>    unsigned long    m_cRef; <br> <br>    //destructor <br>    ~CHello() <br>    { <br>        DecrementLockCount(); <br>        ObjectDestroyed(); <br>    } <br>     <br>public: <br>    //constructor <br>    CHello() <br>    { <br>        m_cRef = 1; <br>        ObjectCreated(); <br>        IncrementLockCount(); <br>    } <br>     <br>HRESULT STDMETHODCALLTYPE QueryInterface( <br>REFIID iid, <br>    void **ppv); <br> <br>ULONG STDMETHODCALLTYPE AddRef(); <br> <br>ULONG STDMETHODCALLTYPE Release(); <br> <br>HRESULT STDMETHODCALLTYPE HelloProc(unsigned char *pszString); <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHello::AddRef, public <br>// <br>//  Synopsis:   Increment reference count <br>// <br>//  See Also:   IUnknown::AddRef <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE  <br>CHello::AddRef() <br>{ <br>    InterlockedIncrement((long *) &amp;m_cRef); <br>    return m_cRef; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Method:     CHello::HelloProc() <br>// <br>//  Synopsis:   Displays the specified string. <br>// <br>//  See Also:   IHello::HelloProc <br>// <br>//---------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE <br>CHello::HelloProc(unsigned char *pszString) <br>{ <br>    printf("HelloProc: %s \n", pszString); <br>    return S_OK; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHello::QueryInterface, public <br>// <br>//  Synopsis:   Query for an interface on the class factory. <br>// <br>//  See Also:   IUnknown:QueryInterface <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE  <br>CHello::QueryInterface ( <br>    REFIID iid, <br>    void **ppv ) <br>{ <br>    HRESULT hr; <br> <br>    if ( IsEqualGUID( iid, IID_IUnknown ) || <br>         IsEqualGUID( iid, IID_IHello ) ) <br>    { <br>        *ppv = (IHello *) this; <br>        AddRef(); <br>    hr = S_OK; <br>    } <br>    else <br>    { <br>        *ppv = 0; <br>        hr = E_NOINTERFACE; <br>    } <br> <br>    return hr; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHello::Release, public <br>// <br>//  Synopsis:   Decrement DLL reference count <br>// <br>//  Notes:      After the m_cRef is decremented, the object may be  <br>//              deleted by another thread.  In order to make this code safe <br>//              for multiple threads, we have to access the object state  <br>//              before decrementing m_cRef. <br>// <br>//  See Also:   IUnknown::Release. <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CHello::Release() <br>{ <br>    unsigned long count; <br>     <br>    count = m_cRef - 1; <br> <br>    if(InterlockedDecrement((long *) &amp;m_cRef) == 0) <br>    { <br>        count = 0; <br>        delete this; <br>    } <br> <br>    return count; <br>} <br> <br> <br> <br>// this is the class factory for the CHello server object. <br>// it manufactures CHello server objects in response to a CreateInstance <br>// call <br> <br>class CHelloClassFactory : public IClassFactory <br>{ <br>private: <br>    unsigned long    m_cRef; <br> <br>    //destructor <br>    ~CHelloClassFactory() <br>    { <br>        ObjectDestroyed(); <br>    } <br> <br>public: <br>    //constructor <br>    CHelloClassFactory() <br>    { <br>        m_cRef = 1; <br>        ObjectCreated(); <br>    } <br> <br>HRESULT STDMETHODCALLTYPE QueryInterface( <br>REFIID iid, <br>    void **ppv); <br> <br>ULONG STDMETHODCALLTYPE AddRef(); <br> <br>ULONG STDMETHODCALLTYPE Release(); <br> <br>HRESULT STDMETHODCALLTYPE CreateInstance( <br>    IUnknown *punkOuter, <br>    REFIID riid, <br>    void **ppv); <br> <br>   HRESULT STDMETHODCALLTYPE LockServer( <br>        BOOL fLock ); <br> <br>}; <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHelloClassFactory::AddRef, public <br>// <br>//  Synopsis:   Increment DLL reference counts <br>// <br>//  See Also:   IUnknown::AddRef <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE  <br>CHelloClassFactory::AddRef() <br>{ <br>    InterlockedIncrement((long *) &amp;m_cRef); <br>    return m_cRef; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHelloClassFactory::CreateInstance, public <br>// <br>//  Synopsis:   Create an instance of CHello. <br>// <br>//  See Also:   IClassFactory::CreateInstance <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE  <br>CHelloClassFactory::CreateInstance <br>( <br>    IUnknown *punkOuter, <br>    REFIID riid, <br>    void **ppv <br>) <br>{ <br>    HRESULT hr; <br>    CHello *pHello; <br> <br>    if(punkOuter != 0) <br>    { <br>        //The CHello class doesn't support aggregation. <br>        return CLASS_E_NOAGGREGATION; <br>    } <br> <br>    pHello = new CHello(); <br>    if(pHello != 0) <br>    { <br>        hr = pHello-&gt;QueryInterface(riid, ppv); <br>        pHello-&gt;Release(); <br>    } <br>    else <br>    { <br>        hr = E_OUTOFMEMORY; <br>        *ppv = 0; <br>    } <br> <br>    return hr; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHelloClassFactory::LockServer, public <br>// <br>//  Synopsis:   Lock the server in memory (by adding an extra reference) <br>// <br>//  Notes:      The class factory will be revoked when the lock count <br>//              is decremented to zero.  LockServer(TRUE) will increment the <br>//              lock count and ensure that the class factory will <br>//              not be revoked. <br>// <br>//  See Also:   IClassFactory::LockServer <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE  <br>CHelloClassFactory::LockServer( <br>    BOOL fLock ) <br>{ <br>    if (fLock == TRUE) <br>        IncrementLockCount(); <br>    else <br>        DecrementLockCount(); <br> <br>    return S_OK; <br>} <br> <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHelloClassFactory::QueryInterface, public <br>// <br>//  Synopsis:   Query for an interface on the class factory. <br>// <br>//  See Also:   IUnknown::QueryInterface <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE  <br>CHelloClassFactory::QueryInterface ( <br>    REFIID iid, <br>    void **ppv ) <br>{ <br>    HRESULT hr; <br> <br>    if ( IsEqualGUID( iid, IID_IUnknown) || <br>         IsEqualGUID( iid, IID_IClassFactory ) ) <br>    { <br>        *ppv = this; <br>        AddRef(); <br>        hr = S_OK; <br>    } <br>    else <br>    { <br>        *ppv = 0; <br>        hr = E_NOINTERFACE; <br>    } <br> <br>    return hr; <br>} <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CHelloClassFactory::Release, public <br>// <br>//  Synopsis:   Decrement DLL reference count <br>// <br>//  See Also:   IUnknown::Release <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CHelloClassFactory::Release() <br>{ <br>    unsigned long count; <br>     <br>    count = m_cRef - 1; <br> <br>    if(InterlockedDecrement((long *) &amp;m_cRef) == 0) <br>    { <br>        count = 0; <br> <br>        ObjectDestroyed(); <br>    } <br> <br>    return count; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   RegisterClassFactory. <br>// <br>//  Synopsis:   Register the class factory if it is not currently registered. <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT RegisterClassFactory() <br>{ <br>    HRESULT hr; <br>    CHelloClassFactory *pClassFactory; <br> <br>    if(InterlockedExchange(&amp;g_fClassRegistered, TRUE) == FALSE) <br>    { <br>        pClassFactory = new CHelloClassFactory; <br>         <br>        if(pClassFactory != 0) <br>        { <br>            hr = CoRegisterClassObject(CLSID_OHello, <br>                          (IUnknown *) pClassFactory, <br>                           CLSCTX_LOCAL_SERVER, <br>                           REGCLS_MULTIPLEUSE, <br>                           &amp;g_dwRegister); <br>          pClassFactory-&gt;Release(); <br>        } <br>        else <br>        { <br>           hr = E_OUTOFMEMORY; <br>        } <br>    } <br>    else <br>    { <br>        hr = S_OK; <br>    } <br>    return hr;   <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Function:   RevokeClassFactory. <br>// <br>//  Synopsis:   Revoke the registered class factories if they have not <br>//              already been revoked. <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT RevokeClassFactory() <br>{ <br>    HRESULT hr; <br> <br>    if(InterlockedExchange(&amp;g_fClassRegistered, FALSE) == TRUE) <br>    { <br>        hr = CoRevokeClassObject(g_dwRegister); <br>    } <br>    else <br>    { <br>        hr = S_OK; <br>    } <br>    return hr; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
