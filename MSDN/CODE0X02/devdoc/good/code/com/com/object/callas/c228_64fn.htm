<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SERVER.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context233"></a>SERVER.CXX</h2>
<pre><code>/**************************************************************************** <br>                       Microsoft RPC <br>                Copyright Microsoft Corp. 1992-1996 <br>                  object call_as Example <br> <br>    FILE:       server.cxx <br> <br>    USAGE:      server  - note that this is auto-loaded by the client <br>                          requesting this server, and exits at completion <br> <br>    PURPOSE:    Server side of RPC distributed application <br> <br>    FUNCTIONS:  main() - binds to server and calls remote procedure <br> <br>    COMMENTS:   This version of the Ole2 distributed application that <br>                prints "hello, world" (or other string) on the server <br>                features a non-rpcable custom interface being remoted with <br>                [call_as]. <br> <br>                It provides a class factory to manufacture a server object, <br>                and the implementation of the callas server object <br> <br>****************************************************************************/ <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;assert.h&gt; <br>#include "callas.h" <br> <br>unsigned long   ObjectCount         = 0; <br>BOOL            fClassRegistered    = FALSE; <br>DWORD           dwHandle            = 0; <br> <br>// this is the CLSID for the class factory for the server <br> <br>const CLSID CLSID_CallAs <br>    = {0xf9246030,0x9f33,0x11cd,{0xb2,0x3f,0x00,0xaa,0x00,0x33,0x9c,0xce}}; <br> <br>IClassFactory *GetCallAsFactory(); <br> <br> <br> <br> <br>// here are some convenient inline functions to reduce the casting involved <br>// with having the RefCount be unsigned instead of signed, and pass by <br>// reference <br> <br>inline <br>unsigned long <br>IncrementRefCount( unsigned long &amp; RefCount ) <br>    { <br>    return InterlockedIncrement( (long *) &amp;RefCount ); <br>    } <br> <br>inline <br>unsigned long <br>DecrementRefCount( unsigned long &amp; RefCount ) <br>    { <br>    return InterlockedDecrement( (long *) &amp;RefCount ); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>// this is the class factory for the CCallAs server <br>// it manufactures CCallAs server objects in response to a CreateInstance <br>// call <br> <br>class CCallAsFactory : public IClassFactory <br> <br>{ <br>public: <br>    // note that the virtual methods must exactly match the set for <br>    // the IClassFactory in the idl (and callas.h) <br>    unsigned long    RefCount; <br> <br>                            CCallAsFactory() <br>                                { <br>                                RefCount    = 0; <br>                                } <br> <br>        HRESULT STDMETHODCALLTYPE QueryInterface( <br>                REFIID iid, <br>            void **ppv); <br> <br>        ULONG STDMETHODCALLTYPE AddRef(); <br> <br>        ULONG STDMETHODCALLTYPE Release(); <br> <br>        HRESULT STDMETHODCALLTYPE CreateInstance( <br>            IUnknown *punkOuter, <br>            REFIID riid, <br>            void **ppv); <br> <br>   HRESULT STDMETHODCALLTYPE LockServer( <br>        BOOL fLock ); <br>}; <br> <br>// allocate a static classfactory to avoid construction races if <br>// we were multithreaded. <br>CCallAsFactory       gCallAsClassFactory; <br> <br> <br> <br> <br> <br>class CCallAs   : public IHelloCallAs <br> <br>{ <br> <br>    unsigned long    RefCount; <br> <br>public: <br> <br>    // remoted functions (virtual) <br> <br>        HRESULT STDMETHODCALLTYPE QueryInterface( <br>                REFIID iid, <br>            void **ppv); <br> <br>        ULONG STDMETHODCALLTYPE AddRef(); <br> <br>        ULONG STDMETHODCALLTYPE Release(); <br> <br>        MyBoolean __stdcall HelloProc( <br>            unsigned char *pszString); <br> <br>        // local functions <br>        // constructor <br>                            CCallAs() <br>                                { <br>                                RefCount    = 0; <br>                                } <br> <br>    void    *   operator new( size_t s ) <br>                                { <br>                                return CoTaskMemAlloc( s ); <br>                                } <br> <br>    void        operator delete( void * pv ) <br>                                { <br>                                CoTaskMemFree( pv ); <br>                                } <br> <br>}; <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   main <br>// <br>//  Synopsis: <br>// <br>//  Arguments: <br>// <br>//  Returns:    void <br>// <br>//  Modifies:   nothing <br>// <br>//  Notes:      none <br>// <br>//---------------------------------------------------------------------------- <br> <br>void _cdecl main() <br>{ <br>    HRESULT hr; <br>    MSG msg; <br>        IClassFactory *pClassFactory; <br> <br>    // <br>    // Initialize OLE before calling any other OLE functions. <br>    // <br> <br>    hr = CoInitialize(NULL); <br> <br>    if( FAILED(hr)) <br>    { <br>            printf("Server: CoInitialize failed(%x)\n",hr); <br>        return; <br>    } <br> <br>        pClassFactory = GetCallAsFactory(); <br> <br>        hr = CoRegisterClassObject(CLSID_CallAs, <br>                                               (IUnknown *) pClassFactory, <br>                                               CLSCTX_LOCAL_SERVER, <br>                                               REGCLS_SINGLEUSE, <br>                                               &amp;dwHandle); <br> <br>        pClassFactory-&gt;Release(); <br> <br>        if (FAILED(hr)) <br>            printf("Server: CoRegisterClassObject failed %x\n", hr); <br>        else <br>        { <br>                fClassRegistered = TRUE; <br> <br>            // message loop <br>        while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>        } <br>        } <br>    CoUninitialize(); <br> <br>    return; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     GetCallAsFactory <br>// <br>//  Synopsis:   Get an IClassFactory * for the CallAs class. <br>// <br>//-------------------------------------------------------------------------- <br>IClassFactory *GetCallAsFactory() <br>{ <br>    // increment the file object count the first time it is created <br>        if(gCallAsClassFactory.RefCount == 0) <br>        { <br>                IncrementRefCount(gCallAsClassFactory.RefCount); <br>                IncrementRefCount(ObjectCount); <br>        } <br>        else <br>        { <br>                IncrementRefCount(gCallAsClassFactory.RefCount); <br>        } <br>        return &amp;gCallAsClassFactory; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAsFactory::QueryInterface, public <br>// <br>//  Synopsis:   Query for an interface on the class factory. <br>// <br>//  Derivation: IUnknown <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE <br>CCallAsFactory::QueryInterface ( <br>    REFIID iid, <br>    void **ppv ) <br>{ <br>    HRESULT hr = E_NOINTERFACE; <br> <br>        assert(ppv); <br> <br>    *ppv = 0; <br>    if ( IsEqualGUID( iid, IID_IUnknown) || <br>         IsEqualGUID( iid, IID_IClassFactory ) ) <br>    { <br>        *ppv = this; <br>                AddRef(); <br>            hr = S_OK; <br>    } <br> <br>    return hr; <br>} <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAsFactory::AddRef, public <br>// <br>//  Synopsis:   Increment DLL reference counts <br>// <br>//  Derivation: IUnknown <br>// <br>//      Notes: We have a single instance of the CCallAsFactory. <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CCallAsFactory::AddRef() <br>{ <br>    IncrementRefCount(RefCount); <br>        return RefCount; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAsFactory::Release, public <br>// <br>//  Synopsis:   Decrement DLL reference count <br>// <br>//  Derivation: IUnknown <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CCallAsFactory::Release() <br>{ <br>        long t; <br>        unsigned long count; <br> <br>    t = DecrementRefCount(RefCount); <br> <br>        if(t == 0) <br>        { <br>                count = 0; <br>                //decrement the object count <br>                if(DecrementRefCount(ObjectCount) == 0) <br>                { <br>                        //The last object has been destroyed. <br>                        PostQuitMessage(0); <br>                } <br>        } <br>        else <br>                count = RefCount; <br> <br>    return count; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAsFactory::CreateInstance, public <br>// <br>//  Synopsis:   Create an instance of CCallAs. <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE <br>CCallAsFactory::CreateInstance <br>( <br>    IUnknown *punkOuter, <br>    REFIID riid, <br>    void **ppv <br>) <br>{ <br>    HRESULT hr = E_OUTOFMEMORY; <br>        CCallAs *pCallAs; <br> <br>        assert(ppv); <br> <br>        *ppv = 0; <br> <br>        if(fClassRegistered == TRUE) <br>        { <br>                fClassRegistered = FALSE; <br>                CoRevokeClassObject(dwHandle); <br>        } <br> <br>        pCallAs = new CCallAs(); <br>        if(pCallAs) <br>        { <br>            // invoke the constructor <br>                *pCallAs = CCallAs(); <br> <br>                //increment the object count. <br>                //The object count will keep this process alive until all <br>                //objects are released. <br>                IncrementRefCount(ObjectCount); <br>                hr = pCallAs-&gt;QueryInterface( riid, ppv); <br>        } <br> <br>    return hr; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAsFactory::LockServer, public <br>// <br>//  Synopsis:   Lock the server in memory (by adding an extra reference) <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE <br>CCallAsFactory::LockServer( <br>        BOOL fLock ) <br>{ <br>    if ( fLock ) <br>            IncrementRefCount( ObjectCount ); <br>        else <br>            DecrementRefCount( ObjectCount ); <br> <br>        return S_OK; <br> <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAs::QueryInterface, public <br>// <br>//  Synopsis:   Query for an interface on the class factory. <br>// <br>//  Derivation: IUnknown <br>// <br>//-------------------------------------------------------------------------- <br>HRESULT STDMETHODCALLTYPE <br>CCallAs::QueryInterface ( <br>    REFIID iid, <br>    void **ppv ) <br>{ <br>    HRESULT hr = E_NOINTERFACE; <br> <br>        assert(ppv); <br> <br>    *ppv = 0; <br>    if ( IsEqualGUID( iid, IID_IUnknown ) || <br>         IsEqualGUID( iid, IID_IHelloCallAs ) ) <br>    { <br>        *ppv = this; <br>                AddRef(); <br>            hr = S_OK; <br>    } <br> <br>    return hr; <br>} <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAs::AddRef, public <br>// <br>//  Synopsis:   Increment reference count <br>// <br>//  Derivation: IUnknown <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CCallAs::AddRef() <br>{ <br>    IncrementRefCount(RefCount); <br>        return RefCount; <br>} <br> <br>//+------------------------------------------------------------------------- <br>// <br>//  Method:     CCallAs::Release, public <br>// <br>//  Synopsis:   Decrement DLL reference count <br>// <br>//  Derivation: IUnknown <br>// <br>//-------------------------------------------------------------------------- <br>ULONG STDMETHODCALLTYPE <br>CCallAs::Release() <br>{ <br>        long t; <br>        unsigned long count; <br> <br>    t = DecrementRefCount(RefCount); <br> <br>        if(t == 0) <br>        { <br>                count = 0; <br> <br>                //decrement the object count <br>                if(DecrementRefCount(ObjectCount) == 0) <br>                { <br>                        //The last object has been destroyed. <br>                        PostQuitMessage(0); <br>                } <br>                delete this; <br>        } <br>        else <br>                count = RefCount; <br> <br>    return count; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   CCallAs::HelloProc() <br>// <br>//  Synopsis:   Displays the specified string <br>// <br>//  Arguments:  void <br>// <br>//  Returns:    Success. <br>// <br>//  Modifies:   nothing <br>// <br>//  Notes:      none <br>// <br>//---------------------------------------------------------------------------- <br>MyBoolean __stdcall <br>CCallAs::HelloProc(unsigned char *pszString) <br>{ <br>    printf("HelloProc: %s \n", pszString); <br>    printf(" &lt;pausing for 5 sec&gt;\n"); <br>    // pretend to be busy computing for a bit <br>    Sleep( 5000 ); // 5000 msec = 5 sec <br> <br>    return TRUE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
