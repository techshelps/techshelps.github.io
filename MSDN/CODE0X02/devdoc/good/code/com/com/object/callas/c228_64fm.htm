<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CALL_AS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context232"></a>CALL_AS.C</h2>
<pre><code>/**************************************************************************** <br>                       Microsoft RPC <br>                Copyright Microsoft Corp. 1992-1996 <br>                  object call_as Example <br> <br>    FILE:       call_as.c <br> <br>    PURPOSE:    [call_as] Glue routines for proxy DLL <br> <br>    FUNCTIONS:  IHelloCallAs_HelloProc_Proxy <br>                IHelloCallAs_HelloProc_Stub <br> <br>    COMMENTS:   This version of the Ole2 distributed application that <br>                prints "hello, world" (or other string) on the server <br>                features a non-rpcable custom interface being remoted with <br>                [call_as]. <br> <br>****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include "rpcproxy.h" <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include "callas.h" // this is the header file generated by midl <br> <br> <br>// this file provides the conversion routines between the remoted <br>// interface and the local view of the interface.  This allows an interface <br>// with apparently non-remotable methods to be remoted.  The conversions <br>// may be similar to transmit_as or represent_as conversions, or they <br>// can be more dramatic, such as synthesizing additional parameters, etc. <br>// in this case, the return type is changed <br> <br> <br>// The IHelloCallAs_HelloProc_Proxy routine goes into the vtable for <br>// the clients IHelloCallAs objects, so the client calls this first <br>// when they invoke the HelloProc method on an IHelloCallAs object. <br> <br>// The IHelloCallAs_HelloProc_Stub routine is called by the server <br>// side stub when the remoted call comes in.  It does any conversions <br>// needed and then invokes the real HelloProc method on the servers <br>// IHelloCallAs object implementation. <br> <br>// both of these must be provided in the proxy DLL, because the <br>// SAME proxy dll is used for both the client and server sides. <br> <br> <br> <br> <br>// this routine goes into the client side "proxy" object for the server. <br>// it has the parameter list of the non-remoted (local) flavor of the <br>// call, and converts it to the remoted flavor of the call.  It can also <br>// do special case memory management, have debugging hooks, etc. <br> <br>MyBoolean <br>STDMETHODCALLTYPE <br>IHelloCallAs_HelloProc_Proxy ( <br>     IHelloCallAs        * pThis, <br>     unsigned char * pszString <br>    ) <br>{ <br>    HRESULT     rc; <br> <br>    printf("Proxy: %s\n", pszString); <br>    rc = IHelloCallAs_RemoteHelloProc_Proxy(pThis, pszString); <br> <br>    return FAILED(rc); <br>} <br> <br> <br>// this routine is directly called by the server-side stub code. <br>// it is called with the remoted param list, and must convert to the <br>// local flavor.  As with the proxy side routine, this one can also <br>// do special case memory management, have debugging hooks, etc. <br> <br>HRESULT <br>RPC_ENTRY <br>IHelloCallAs_HelloProc_Stub ( <br>     IHelloCallAs        * pThis, <br>     unsigned char * pszString <br>     ) <br>{ <br>    MyBoolean   rc; <br> <br>    rc = pThis-&gt;lpVtbl-&gt;HelloProc(pThis, pszString); <br>    return rc ? S_OK : E_FAIL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
