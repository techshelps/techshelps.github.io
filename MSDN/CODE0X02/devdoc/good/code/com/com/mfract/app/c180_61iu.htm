<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENGNLIST.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context186"></a>ENGNLIST.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       engnlist.cxx <br>// <br>//  Contents:   implementation for CEngineList <br>// <br>//  Classes:    CEngineList <br>// <br>//  Functions: <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "engnlist.h" <br>#include &lt;mandcid.h&gt; <br>#include &lt;juliacid.h&gt; <br>#include &lt;plasmcid.h&gt; <br>#include &lt;rgencid.h&gt; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CEngineList::CEngineList <br>// <br>//  Synopsis:   constructor <br>// <br>//  Arguments:  [hmenuOuter] - handle to the menu where the list of engines <br>//                             will be attached <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CEngineList::CEngineList(HMENU hmenuOuter) <br>{ <br>    _hmenuOuter = hmenuOuter; <br>    _hMenu = NULL; <br>    _rgCID = NULL; <br>    _rgszName = NULL; <br>    _nEntries = 0; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CEngineList::~CEngineList <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CEngineList::~CEngineList() <br>{ <br>    if (_rgCID) <br>    { <br>        delete(_rgCID); <br>    } <br>    if (_rgszName) <br>    { <br>        for (unsigned x = _nEntries; x--;) <br>        { <br>            delete[](_rgszName[x]); <br>        } <br>        delete[](_rgszName); <br>    } <br>    if (_hMenu) <br>    { <br>        DestroyMenu(_hMenu); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CEngineList::Read <br>// <br>//  Synopsis:   Reads the list of engines from the registry. <br>// <br>//              If there are no entries in the registry for MFract then this <br>//              routine creates some entries with the default set of <br>//              fractal engines. <br>// <br>//  Returns:    S_OK on success <br>//              E_FAIL if there was a problem <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CEngineList::Read() <br>{ <br>    HRESULT hr = S_OK; <br>    if (FAILED(hr)) <br>    { <br>        return(hr); <br>    } <br>    DWORD dwDisposition; <br>    HKEY hkSoftware; <br>    LONG lReturn = RegCreateKeyEx( <br>        HKEY_LOCAL_MACHINE, <br>        TEXT("Software"), <br>        0, <br>        NULL, <br>        REG_OPTION_NON_VOLATILE, <br>        KEY_READ, <br>        NULL, <br>        &amp;hkSoftware, <br>        &amp;dwDisposition); <br>    if (lReturn == ERROR_SUCCESS) <br>    { <br>        HKEY hkMicrosoft; <br>        lReturn = RegCreateKeyEx( <br>            hkSoftware, <br>            TEXT("Microsoft"), <br>            0, <br>            NULL, <br>            REG_OPTION_NON_VOLATILE, <br>            KEY_READ | <br>            KEY_WRITE, <br>            NULL, <br>            &amp;hkMicrosoft, <br>            &amp;dwDisposition); <br>        if (lReturn == ERROR_SUCCESS) <br>        { <br>            HKEY hkApp; <br>            lReturn = RegCreateKeyEx( <br>                hkMicrosoft, <br>                TEXT(APP_TITLE), <br>                0, <br>                NULL, <br>                REG_OPTION_NON_VOLATILE, <br>                KEY_READ | <br>                KEY_WRITE | <br>                KEY_SET_VALUE, <br>                NULL, <br>                &amp;hkApp, <br>                &amp;dwDisposition); <br>            if (lReturn == ERROR_SUCCESS) <br>            { <br>                HKEY hkFractalTypes; <br>                lReturn = RegCreateKeyEx( <br>                    hkApp, <br>                    TEXT("Fractal Types"), <br>                    0, <br>                    NULL, <br>                    REG_OPTION_NON_VOLATILE, <br>                    KEY_READ | <br>                    KEY_WRITE | <br>                    KEY_SET_VALUE, <br>                    NULL, <br>                    &amp;hkFractalTypes, <br>                    &amp;dwDisposition); <br>                if (lReturn == ERROR_SUCCESS) <br>                { <br>                    if (dwDisposition == REG_OPENED_EXISTING_KEY) <br>                    { <br>                        // Enumerate the values in this key to build our list <br>                        DWORD cchClass = 0; <br>                        DWORD cSubkeys; <br>                        DWORD cchMaxSubkey; <br>                        DWORD cchMaxClass; <br>                        DWORD cValues; <br>                        DWORD cchMaxValueName; <br>                        DWORD cbMaxValueData; <br>                        DWORD cbSecurityDescriptor; <br>                        FILETIME ftLastWriteTime; <br>                        lReturn = RegQueryInfoKey( <br>                            hkFractalTypes, <br>                            NULL, <br>                            &amp;cchClass, <br>                            0, <br>                            &amp;cSubkeys, <br>                            &amp;cchMaxSubkey, <br>                            &amp;cchMaxClass, <br>                            &amp;cValues, <br>                            &amp;cchMaxValueName, <br>                            &amp;cbMaxValueData, <br>                            &amp;cbSecurityDescriptor, <br>                            &amp;ftLastWriteTime); <br>                        _rgCID = new CLSID[cValues]; <br>                        _rgszName = new TCHAR *[cValues]; <br>                        for (DWORD uIndex = cValues; uIndex--;) <br>                        { <br>                            TCHAR * szCLSID = (TCHAR *) new BYTE [cbMaxValueData]; <br>                            TCHAR * szName = new TCHAR[cchMaxValueName+1]; <br>                            DWORD cchValue = cchMaxValueName+1; <br>                            DWORD cbData = cbMaxValueData; <br>                            lReturn = RegEnumValue( <br>                                hkFractalTypes, <br>                                uIndex, <br>                                szName, <br>                                &amp;cchValue, <br>                                0, <br>                                NULL, <br>                                NULL, <br>                                &amp;cbData); <br>                            cchValue++; <br>                            _rgszName[uIndex] = new TCHAR[cchValue]; <br>                            lReturn = RegEnumValue( <br>                                hkFractalTypes, <br>                                uIndex, <br>                                _rgszName[uIndex], <br>                                &amp;cchValue, <br>                                0, <br>                                NULL, <br>                                (BYTE *) szCLSID, <br>                                &amp;cbData); <br>#ifdef UNICODE <br>                            CLSIDFromString(szCLSID, &amp;_rgCID[uIndex]); <br>#else <br>                            OLECHAR wszCLSID[40]; // should be more than large enough <br>                            mbstowcs(wszCLSID, szCLSID, 40); <br>                            CLSIDFromString(wszCLSID, &amp;_rgCID[uIndex]); <br>#endif <br>                            delete[] szCLSID; <br>                            delete[] szName; <br>                        } <br>                        _nEntries = cValues; <br>                    } <br>                    else <br>                    { <br>                        // This is the first time MFract has been run on this machine. <br>                        // Create the default key entries. <br>                        _rgCID = new CLSID[4]; <br>                        _rgszName = new TCHAR * [4]; <br>                        TCHAR szCLSID[40];  // more than large enough <br>#ifndef UNICODE <br>                        OLECHAR wszCLSID[40]; <br>#endif <br>#ifdef UNICODE <br>                        StringFromGUID2(CLSID_MANDELBROT, szCLSID, 40); <br>#else <br>                        StringFromGUID2(CLSID_MANDELBROT, wszCLSID, 40); <br>                        wcstombs(szCLSID, wszCLSID, 40); <br>#endif <br>                        lReturn = RegSetValueEx( <br>                            hkFractalTypes, <br>                            TEXT("Mandelbrot Fractal"), <br>                            0, <br>                            REG_SZ, <br>                            (BYTE *) szCLSID, <br>                            sizeof(TCHAR) * (1 + <br>#ifdef UNICODE <br>                                wcslen(szCLSID) <br>#else <br>                                strlen(szCLSID) <br>#endif <br>                                ) <br>                            ); <br>                        memcpy(&amp;_rgCID[0], &amp;CLSID_MANDELBROT, sizeof (CLSID)); <br>                        _rgszName[0] = <br>#ifdef UNICODE <br>                        _wcsdup(TEXT("Mandelbrot Fractal")); <br>#else <br>                        _strdup(TEXT("Mandelbrot Fractal")); <br>#endif <br>#ifdef UNICODE <br>                        StringFromGUID2(CLSID_JULIASET, szCLSID, 40); <br>#else <br>                        StringFromGUID2(CLSID_JULIASET, wszCLSID, 40); <br>                        wcstombs(szCLSID, wszCLSID, 40); <br>#endif <br>                        lReturn = RegSetValueEx( <br>                            hkFractalTypes, <br>                            TEXT("Julia Set Fractal"), <br>                            0, <br>                            REG_SZ, <br>                            (BYTE *) szCLSID, <br>                            sizeof(TCHAR) * (1 + <br>#ifdef UNICODE <br>                                wcslen(szCLSID) <br>#else <br>                                strlen(szCLSID) <br>#endif <br>                                ) <br>                            ); <br>                        memcpy(&amp;_rgCID[1], &amp;CLSID_JULIASET, sizeof (CLSID)); <br>                        _rgszName[1] = <br>#ifdef UNICODE <br>                        _wcsdup(TEXT("Julia Set Fractal")); <br>#else <br>                        _strdup(TEXT("Julia Set Fractal")); <br>#endif <br>#ifdef UNICODE <br>                        StringFromGUID2(CLSID_PLASMA, szCLSID, 40); <br>#else <br>                        StringFromGUID2(CLSID_PLASMA, wszCLSID, 40); <br>                        wcstombs(szCLSID, wszCLSID, 40); <br>#endif <br>                        lReturn = RegSetValueEx( <br>                            hkFractalTypes, <br>                            TEXT("Plasma Cloud Fractal"), <br>                            0, <br>                            REG_SZ, <br>                            (BYTE *) szCLSID, <br>                            sizeof(TCHAR) * (1 + <br>#ifdef UNICODE <br>                                wcslen(szCLSID) <br>#else <br>                                strlen(szCLSID) <br>#endif <br>                                ) <br>                            ); <br>                        memcpy(&amp;_rgCID[2], &amp;CLSID_PLASMA, sizeof (CLSID)); <br>                        _rgszName[2] = <br>#ifdef UNICODE <br>                        _wcsdup(TEXT("Plasma Cloud Fractal")); <br>#else <br>                        _strdup(TEXT("Plasma Cloud Fractal")); <br>#endif <br>#ifdef UNICODE <br>                        StringFromGUID2(CLSID_RGEN, szCLSID, 40); <br>#else <br>                        StringFromGUID2(CLSID_RGEN, wszCLSID, 40); <br>                        wcstombs(szCLSID, wszCLSID, 40); <br>#endif <br>                        lReturn = RegSetValueEx( <br>                            hkFractalTypes, <br>                            TEXT("Recursive Generator Fractal"), <br>                            0, <br>                            REG_SZ, <br>                            (BYTE *) szCLSID, <br>                            sizeof(TCHAR) * (1 + <br>#ifdef UNICODE <br>                                wcslen(szCLSID) <br>#else <br>                                strlen(szCLSID) <br>#endif <br>                                ) <br>                            ); <br>                        memcpy(&amp;_rgCID[3], &amp;CLSID_RGEN, sizeof (CLSID)); <br>                        _rgszName[3] = <br>#ifdef UNICODE <br>                        _wcsdup(TEXT("Recursive Generator Fractal")); <br>#else <br>                        _strdup(TEXT("Recursive Generator Fractal")); <br>#endif <br>                        _nEntries = 4; <br>                    } <br>                    RegCloseKey(hkFractalTypes); <br>                } <br>                else <br>                { <br>                    // couldn't access registry <br>                    hr = E_FAIL; <br>                } <br>                RegCloseKey(hkApp); <br>            } <br>            else <br>            { <br>                // couldn't access registry <br>                hr = E_FAIL; <br>            } <br>            RegCloseKey(hkMicrosoft); <br>        } <br>        else <br>        { <br>            // couldn't access registry <br>            hr = E_FAIL; <br>        } <br>        RegCloseKey(hkSoftware); <br>    } <br>    else <br>    { <br>        // couldn't access registry <br>        hr = E_FAIL; <br>    } <br>    if (_hMenu) <br>    { <br>        DestroyMenu(_hMenu); <br>    } <br>    _hMenu = CreatePopupMenu(); <br>    if (_hMenu) <br>    { <br>        for (unsigned u=_nEntries; u--;) <br>        { <br>            if (!InsertMenu( <br>                _hMenu, <br>                0, <br>                MF_BYPOSITION | (MF_CHECKED * (0 == u)), <br>                IDM_FRACTAL_TYPE + u, <br>                _rgszName[u])) <br>            { <br>                // Insert Menu Failed <br>                hr = E_FAIL; <br>            } <br>        } <br>        TCHAR szMenuString[MAX_STRING_LENGTH]; <br>        GetMenuString(_hmenuOuter, <br>            IDM_SELECT_TYPE, <br>            szMenuString, <br>            MAX_STRING_LENGTH, <br>            MF_BYCOMMAND); <br>        if (!ModifyMenu( <br>            _hmenuOuter, <br>            IDM_SELECT_TYPE, <br>            MF_BYCOMMAND | MF_POPUP, <br>            (UINT)_hMenu, <br>            szMenuString)) <br>        { <br>            // ModifyMenu failed <br>            hr = E_FAIL; <br>        } <br>    } <br>    else <br>    { <br>        // couldn't create menu <br>        hr = E_FAIL; <br>    } <br>    return(hr); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CEngineList::GetEntry <br>// <br>//  Synopsis:   returns the CLSID of the fractal engine at a given index <br>// <br>//  Arguments:  [uIndex] - index of the engine <br>// <br>//  Returns:    CLSID of the fractal engine <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CLSID CEngineList::GetEntry(unsigned uIndex) <br>{ <br>    return(_rgCID[uIndex]); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CEngineList::FindEntry <br>// <br>//  Synopsis:   Looks through the list of CLSIDs to find out what engine number <br>//              has this CLSID. <br>// <br>//  Arguments:  [cid] - CLSID of the fractal engine <br>// <br>//  Returns:    &gt;= 0 if the CLSID was found <br>//              -1   if the CLSID was not found <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>int CEngineList::FindEntry(CLSID cid) <br>{ <br>    for (unsigned u = _nEntries; u--;) <br>    { <br>        if (IsEqualGUID(cid, _rgCID[u])) <br>        { <br>            return((int) u); <br>        } <br>    } <br>    // not found in the list <br>    return(-1); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
