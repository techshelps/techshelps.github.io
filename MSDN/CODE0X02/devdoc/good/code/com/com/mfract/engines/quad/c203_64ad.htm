<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>QUADOBJ.CXX</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context205"></a>QUADOBJ.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       mandelob.cxx <br>// <br>//  Contents:   Quadrant Engine object <br>// <br>//  Classes:    CQuadrantEngine <br>// <br>//  Functions:  StartGraphicsThread <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include "quad.h" <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   StartGraphicsThread <br>// <br>//  Synopsis:   Global function used to bootstrap into the GraphicsThread <br>//              member of the CQuadrantEngine class. <br>// <br>//  Arguments:  [lpdwParam] - this pointer to a CQuadrantEngine class object <br>// <br>//  History:    4-15-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>DWORD StartGraphicsThread(LPDWORD lpdwParam) <br>{ <br>    return (((CQuadrantEngine *)lpdwParam)-&gt;GraphicsThread()); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::QueryInterface <br>// <br>//  Synopsis:   standard OLE method <br>// <br>//  Arguments:  [riid] - reference to the requested interface id <br>//              [ppv]  - pointer to recieve the interface <br>// <br>//  Returns:    S_OK on success <br>//              E_NOINTERFACE if the requested interface isn't supported <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::QueryInterface(REFIID riid, LPVOID * ppv) <br>{ <br>    *ppv = NULL; <br>    if (IsEqualGUID(IID_IQuadrantEngine, riid)) <br>    { <br>        *ppv = (IQuadrantEngine *)this; <br>    } <br>    else if (IsEqualGUID(IID_IUnknown, riid)) <br>    { <br>        *ppv = (IUnknown *)(IFractalEngine *)this; <br>    } <br>    if (*ppv) <br>    { <br>        ((IUnknown *)*ppv)-&gt;AddRef(); <br>        return(S_OK); <br>    } <br>    return(E_NOINTERFACE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::AddRef <br>// <br>//  Synopsis:   increments the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CQuadrantEngine::AddRef(void) <br>{ <br>    return(++_cRef); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Release <br>// <br>//  Synopsis:   decrements the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CQuadrantEngine::Release(void) <br>{ <br>    ULONG cRef = --_cRef; <br>    if (0 == cRef) <br>    { <br>        delete this; <br>        gcRef--; <br>    } <br>    return(cRef); <br>} <br> <br>// IQuadrantEngine methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Init <br>// <br>//  Synopsis:   initializes the quadrant engine <br>// <br>//  Arguments:  [pqc] - pointer to an IQuadrantClient interface <br>//              [pfh] - pointer to an IFractalHost interface <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::Init( <br>    IQuadrantClient *pqc, <br>    IFractalHost *pfh) <br>{ <br>    _pqc = pqc; <br>    _pfh = pfh; <br>    // NOTE that neither of these interface pointers are reference counted since <br>    // I am depending on their owners to tell me when I can be unloaded. <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::UseBoundingBoxes <br>// <br>//  Synopsis:   tells the quadrant engine to use the bounding box optimization <br>// <br>//  Arguments:  [fFlag] - TRUE if the optimization is enabled (FALSE otherwise) <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::UseBoundingBoxes(BOOL fFlag) <br>{ <br>    _fUseBoundingBoxes = fFlag; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::SetGraphSize <br>// <br>//  Synopsis:   tells the quadrant engine how big the graph is <br>// <br>//  Arguments:  [uWidth]  - width of the graph in pixels <br>//              [uHeight] - height of the graph in pixels <br>// <br>//  Returns:    S_OK on success <br>//              E_FAIL if the graph size can't be altered at this time <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::SetGraphSize( <br>    unsigned int uWidth, <br>    unsigned int uHeight) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    _uWidth = uWidth; <br>    _uHeight = uHeight; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Start <br>// <br>//  Synopsis:   Starts the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::Start(void) <br>{ <br>    SetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Stop <br>// <br>//  Synopsis:   stops the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::Stop(void) <br>{ <br>    ResetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Reset <br>// <br>//  Synopsis:   tells the graph engine to quit drawing the current graph <br>//              (if it is drawing it) and start over again <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CQuadrantEngine::Reset(void) <br>{ <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Initialize <br>// <br>//  Synopsis:   private method used to initialize the c++ class object <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CQuadrantEngine::Initialize(void) <br>{ <br>    _hRestart = CreateEvent( <br>        NULL, <br>        TRUE,   // must be manually reset <br>        TRUE,   // initially signaled <br>        NULL); <br>    if (_hRestart == NULL) <br>    { <br>        return(FALSE);  // couldn't create an event <br>    } <br>    _hRunning = CreateEvent( <br>        NULL, <br>        TRUE, <br>        FALSE, <br>        NULL); <br>    if (_hRunning == NULL) <br>    { <br>        return(FALSE); <br>    } <br>    _hEngine = CreateThread( <br>        (LPSECURITY_ATTRIBUTES)NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE) StartGraphicsThread, <br>        this, <br>        0, <br>        &amp;_dwThreadId); <br>    if (_hEngine == NULL) <br>    { <br>        return(FALSE);  // couldn't start the graphics thread <br>    } <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::GraphicsThread <br>// <br>//  Synopsis:   main entry point for the engine's graphics thread <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//  Notes:      This routine enters into an eternal loop.  It will continue <br>//              looping until the class is destroyed at which point this <br>//              thread will be simply terminated. <br>// <br>//  Algorithm:  Wait for the engine to be started. <br>//              Clear the graph. <br>//              Plot the points at the graph's edge and also plot two lines <br>//              through the center of the graph, dividing it into fourths. <br>//              For each quadrant, call Subdivide to begin the recursion. <br>//              After falling out of the recursion, check to see if the <br>//              graph has been aborted. <br>//              If not, notify that the graph has been completed. <br>//              Loop back around to the beginning. <br>// <br>//---------------------------------------------------------------------------- <br> <br>DWORD CQuadrantEngine::GraphicsThread(void) <br>{ <br>    do <br>    { <br>        // wait here until someone starts the graphics engine <br>        WaitForSingleObject(_hRunning, INFINITE); <br>        // reset the _hRestart event so that we won't immediately fall out <br>        // of the engine <br>        ResetEvent(_hRestart); <br>        // Erase the graph <br>        _pfh-&gt;Rect(0, 0, (int) _uWidth - 1, (int) _uHeight - 1, PALETTEINDEX(0)); <br>        unsigned uColor; <br>        for (int x = 0; <br>            x &lt; (int)_uWidth <br>            &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>            ; x++) <br>        { <br>            _pqc-&gt;ComputePoint(&amp;uColor, x, 0); <br>            _pfh-&gt;Point(x, 0, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, x, ((int) _uHeight - 1) / 2); <br>            _pfh-&gt;Point(x, ((int) _uHeight - 1) / 2, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, x, (int) _uHeight - 1); <br>            _pfh-&gt;Point(x, (int) _uHeight - 1, uColor); <br>            WaitForSingleObject(_hRunning, INFINITE); <br>        } <br>        int y; <br>        for (y = 1; <br>            y &lt; ((int) _uHeight - 1) / 2 <br>            &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>            ; y++) <br>        { <br>            _pqc-&gt;ComputePoint(&amp;uColor, 0, y); <br>            _pfh-&gt;Point(0, y, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, ((int) _uWidth - 1) / 2, y); <br>            _pfh-&gt;Point(((int) _uWidth - 1) / 2, y, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, (int) _uWidth - 1, y); <br>            _pfh-&gt;Point((int) _uWidth - 1, y, uColor); <br>            WaitForSingleObject(_hRunning, INFINITE); <br>        } <br>        for (y = ((int) _uHeight - 1) / 2 + 1; <br>            y &lt; (int) _uHeight - 1 <br>            &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>            ; y++) <br>        { <br>            _pqc-&gt;ComputePoint(&amp;uColor, 0, y); <br>            _pfh-&gt;Point(0, y, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, ((int) _uWidth - 1) / 2, y); <br>            _pfh-&gt;Point(((int) _uWidth - 1) / 2, y, uColor); <br>            _pqc-&gt;ComputePoint(&amp;uColor, (int) _uWidth - 1, y); <br>            _pfh-&gt;Point((int) _uWidth - 1, y, uColor); <br>            WaitForSingleObject(_hRunning, INFINITE); <br>        } <br>        Subdivide(0, 0, (int) (_uWidth - 1) / 2, (int) (_uHeight - 1) / 2); <br>        Subdivide((int) (_uWidth - 1) / 2, 0, (int) _uWidth - 1, (int) (_uHeight - 1) / 2); <br>        Subdivide(0, (int) (_uHeight - 1) / 2, (int) (_uWidth - 1) / 2, (int) _uHeight - 1); <br>        Subdivide((int) (_uWidth - 1) / 2, (int) (_uHeight - 1) / 2, (int) _uWidth - 1, (int) _uHeight - 1); <br>        if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>        { <br>            // Tell our clients that we're finished <br>            _pqc-&gt;DoneDrawingGraph(); <br>            _pfh-&gt;DoneDrawingGraph(); <br>            ResetEvent(_hRunning); <br>        } <br>    } while (TRUE); <br>    return(0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::PlotAreaSlowly <br>// <br>//  Synopsis:   plots each point in a rectangle by brute force: one pixel at a <br>//              time <br>// <br>//  Arguments:  [iXLow]  - left side of rectangle <br>//              [iYLow]  - top <br>//              [iXHigh] - right side <br>//              [iYHigh] - bottom <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//  Notes:      Used when a box is to small to be subdivided any farther. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CQuadrantEngine::PlotAreaSlowly( <br>    int iXLow, <br>    int iYLow, <br>    int iXHigh, <br>    int iYHigh) <br>{ <br>    for (int y = iYLow ; y &lt;= iYHigh <br>        &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>        ; y++) <br>    { <br>        for (int x = iXLow; x &lt;= iXHigh <br>            &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>            ; x++) <br>        { <br>            unsigned uColor; <br>            _pqc-&gt;ComputePoint(&amp;uColor, x, y); <br>            _pfh-&gt;Point(x, y, uColor); <br>            WaitForSingleObject(_hRunning, INFINITE); <br>        } <br>    } <br>} <br> <br>// SUBDIVIDE determines at what point the Subdivide routine quits trying <br>// to draw ever-smaller boxes and just plots the pixels by brute force. <br>CONST unsigned SUBDIVIDE = 3; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::Subdivide <br>// <br>//  Synopsis:   recursively plots all points within a rectangle <br>// <br>//  Arguments:  [iXLow]  - left side of rectangle <br>//              [iYLow]  - top <br>//              [iXHigh] - right side <br>//              [iYHigh] - bottom <br>// <br>//  History:    4-27-94   stevebl   Created <br>// <br>//  Algorithm:  If the bounding box optimization is enabled, check to see if <br>//              the perimiter is all the same color. <br>//              If the perimiter is all one color, fill the entire rectangle <br>//              with that color and fall out of the recursion. <br>//              Otherwise, divide the rectangle into four quadrants and <br>//              continue the recursion into each of them. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CQuadrantEngine::Subdivide( <br>    int iXLow, <br>    int iYLow, <br>    int iXHigh, <br>    int iYHigh) <br>{ <br>    if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>    { <br>        BOOL fDescend = !_fUseBoundingBoxes; <br>        // <br>        // If the bounding box optimization is enabled then fDescend <br>        // will be FALSE until it finds two points on the perimiter <br>        // that don't match. <br>        // <br>        // If the bounding box optimization is disabled then fDescend <br>        // will be TRUE, causing the checking to be disabled altogether. <br>        // <br> <br>        if (iXHigh - iXLow &gt; SUBDIVIDE &amp;&amp; iYHigh - iYLow &gt; SUBDIVIDE) <br>        { <br>            unsigned uTest, uTemp; <br>            _pfh-&gt;GetPoint(&amp;uTest, iXLow, iYLow); <br>            for (int x = iXLow; <br>                (!fDescend) &amp;&amp; x &lt;= iXHigh; <br>                x++) <br>            { <br>                _pfh-&gt;GetPoint(&amp;uTemp, x, iYLow); <br>                if (uTest != uTemp) <br>                { <br>                    fDescend = TRUE; <br>                } <br>                else <br>                { <br>                    _pfh-&gt;GetPoint(&amp;uTemp, x, iYHigh); <br>                    if (uTest != uTemp) <br>                    { <br>                        fDescend = TRUE; <br>                    } <br>                } <br>            } <br>            for (int y = iYLow + 1; <br>                (!fDescend) &amp;&amp; y &lt; iYHigh; <br>                y++) <br>            { <br>                _pfh-&gt;GetPoint(&amp;uTemp, iXLow, y); <br>                if (uTest != uTemp) <br>                { <br>                    fDescend = TRUE; <br>                } <br>                else <br>                { <br>                    _pfh-&gt;GetPoint(&amp;uTemp, iXHigh, y); <br>                    if (uTest != uTemp) <br>                    { <br>                        fDescend = TRUE; <br>                    } <br>                } <br>            } <br>            if (fDescend) <br>            { <br>                unsigned uColor; <br>                int iXMid = (iXLow + iXHigh) / 2; <br>                int iYMid = (iYLow + iYHigh) / 2; <br>                for (int x = iXLow + 1; <br>                    x &lt; iXHigh <br>                    &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>                    ; x++) <br>                { <br>                    _pqc-&gt;ComputePoint(&amp;uColor, x, iYMid); <br>                    _pfh-&gt;Point(x, iYMid, uColor); <br>                    WaitForSingleObject(_hRunning, INFINITE); <br>                } <br>                int y; <br>                for (y = iYLow + 1; <br>                    y &lt; iYMid <br>                    &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>                    ; y++) <br>                { <br>                    _pqc-&gt;ComputePoint(&amp;uColor, iXMid, y); <br>                    _pfh-&gt;Point(iXMid, y, uColor); <br>                    WaitForSingleObject(_hRunning, INFINITE); <br>                } <br>                for (y = iYMid + 1; <br>                    y &lt; iYHigh <br>                    &amp;&amp; WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0) <br>                    ; y++) <br>                { <br>                    _pqc-&gt;ComputePoint(&amp;uColor, iXMid, y); <br>                    _pfh-&gt;Point(iXMid, y, uColor); <br>                    WaitForSingleObject(_hRunning, INFINITE); <br>                } <br>                Subdivide(iXLow, iYLow, iXMid, iYMid); <br>                Subdivide(iXMid, iYLow, iXHigh, iYMid); <br>                Subdivide(iXLow, iYMid, iXMid, iYHigh); <br>                Subdivide(iXMid, iYMid, iXHigh, iYHigh); <br>            } <br>            else <br>            { <br>                _pfh-&gt;Rect(iXLow + 1, iYLow + 1, <br>                    iXHigh - 1, iYHigh - 1, <br>                    uTest); <br>            } <br>        } <br>        else <br>        { <br>            // do a simple iteration to plot the graph <br>            PlotAreaSlowly(iXLow + 1, iYLow + 1, iXHigh - 1, iYHigh - 1); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::CQuadrantEngine <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CQuadrantEngine::CQuadrantEngine() <br>{ <br>    _uWidth = 160; <br>    _uHeight = 180; <br>    _cRef = 0; <br>    _pfh = NULL; <br>    _pqc = NULL; <br>    _hRunning = NULL; <br>    _hRestart = NULL; <br>    _hEngine = NULL; <br>    _dwThreadId = 0; <br>    _fUseBoundingBoxes = TRUE; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CQuadrantEngine::~CQuadrantEngine <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CQuadrantEngine::~CQuadrantEngine() <br>{ <br>    if (_hRestart) <br>    { <br>        CloseHandle(_hRestart); <br>    } <br>    if (_hRunning) <br>    { <br>        CloseHandle(_hRunning); <br>    } <br>    if (_hEngine) <br>    { <br>        TerminateThread(_hEngine, 0); <br>        CloseHandle(_hEngine); <br>    } <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
