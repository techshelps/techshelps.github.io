<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GENWIN.CXX</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context206"></a>GENWIN.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       genwin.cxx <br>// <br>//  Contents:   implementation for the generator window control <br>// <br>//  Classes:    CGeneratorWindow <br>// <br>//  Functions: <br>// <br>//  History:    5-05-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include "genwin.h" <br>#include &lt;math.h&gt; <br>#include "polar.h" <br> <br>#define POINTRADIUS 2 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CGeneratorWindow::WindowProc <br>// <br>//  Synopsis:   Handles mouse messages and painting. <br>// <br>//  Arguments:  [uMsg]   - message <br>//              [wParam] - first message parameter <br>//              [lParam] - second message parameter <br>// <br>//  History:    5-05-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CGeneratorWindow::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_LBUTTONDOWN: <br>        { <br>            SetCapture(_hwnd); <br> <br>            // translate mouse coordinates to real coordinates <br>            double x, y; <br>            x = ((double) (LOWORD(lParam) * 2.0) / _uWidth) - 1.0; <br>            y = ((double) (HIWORD(lParam) * -2.0) / _uHeight) + 1.0; <br> <br>            // Find if we need to create a new point or if we are going to track <br>            // an old point. <br> <br>            // Distances used here are really distances squared <br>            // to keep us from having to do a sqrt function. <br> <br>            unsigned uClosest = 1; <br>            double dClosestDistance = 10.0; <br>            // an insanely huge number given our graph dimensions of 2 x 2 <br> <br>            // start with point one and go to point _nPoints - 2 <br>            // since the end points are not moveable <br> <br>            unsigned uIndex = 1; <br>            double dTestDistance = <br>                ((double)(4 * POINTRADIUS) / _uWidth) * <br>                ((double)(4 * POINTRADIUS) / _uHeight); <br>            while (uIndex &lt; _nPoints - 1) <br>            { <br>                double dDistance = <br>                    (x - _rgX[uIndex]) * (x - _rgX[uIndex]) + <br>                    (y - _rgY[uIndex]) * (y - _rgY[uIndex]); <br>                if (dTestDistance &gt;= dDistance) <br>                { <br>                    // we clicked on a point (or at least close enough to it) <br>                    _uTrackingPoint = uIndex; <br>                    return(FALSE); <br>                } <br>                if (dDistance &lt; dClosestDistance) <br>                { <br>                    dClosestDistance = dDistance; <br>                    uClosest = uIndex; <br>                } <br>                uIndex++; <br>            } <br>            // If we haven't returned yet, then we didn't click on a point. <br>            // Therefore we must be inserting a new point. <br> <br>            // Determine if we can add any more points to the list. <br>            if (MAX_POINTS == _nPoints) <br>            { <br>                // Nope.  Better just track the closest point then. <br>                _uTrackingPoint = uClosest; <br>                return(FALSE); <br>            } <br> <br>            // Next determine if we should insert behind or in front. <br>            if (_nPoints &gt; 2) <br>            { <br>                // We always insert in front if there are only two points. <br>                // Otherwise, a simple distance check will help us decide which <br>                // segment to insert in. <br>                double d1 = <br>                    (x - _rgX[uClosest - 1]) * (x - _rgX[uClosest - 1]) + <br>                    (y - _rgY[uClosest - 1]) * (y - _rgY[uClosest - 1]); <br>                double d2 = <br>                    (x - _rgX[uClosest + 1]) * (x - _rgX[uClosest + 1]) + <br>                    (y - _rgY[uClosest + 1]) * (y - _rgY[uClosest + 1]); <br>                if (d2 &lt; d1) <br>                { <br>                    // insert after <br>                    ++uClosest; <br>                } <br>            } <br> <br>            // Then insert the point into the list of points. <br> <br>            for (uIndex = _nPoints; uIndex &gt; uClosest; uIndex--) <br>            { <br>                _rgX[uIndex] = _rgX[uIndex - 1]; <br>                _rgY[uIndex] = _rgY[uIndex - 1]; <br>            } <br>            _rgX[uClosest] = x; <br>            _rgY[uClosest] = y; <br>            _uTrackingPoint = uClosest; <br>            _nPoints++; <br> <br>            // And cause the window to be repainted. <br>            InvalidateRect(_hwnd, NULL, TRUE); <br>        } <br>        break; <br>    case WM_MOUSEMOVE: <br>        if (wParam &amp; MK_LBUTTON) <br>        { <br>            // translate mouse coordinates to real coordinates <br>            double x, y; <br>            x = ((double) (LOWORD(lParam) * 2.0) / _uWidth) - 1.0; <br>            y = ((double) (HIWORD(lParam) * -2.0) / _uHeight) + 1.0; <br> <br>            // Move whatever point we are tracking <br>            _rgX[_uTrackingPoint] = x; <br>            _rgY[_uTrackingPoint] = y; <br> <br>            // And cause the window to be repainted. <br>            InvalidateRect(_hwnd, NULL, TRUE); <br>        } <br>        break; <br>    case WM_LBUTTONUP: <br>        // If the point we have been tracking has moved off the screen, remove it from the list. <br>        if (_rgX[_uTrackingPoint] &lt; -1.0 <br>            || _rgX[_uTrackingPoint] &gt; 1.0 <br>            || _rgY[_uTrackingPoint] &lt; -1.0 <br>            || _rgY[_uTrackingPoint] &gt; 1.0 <br>            ) <br>        { <br>            _nPoints--; <br>            for (unsigned uIndex = _uTrackingPoint; uIndex &lt; _nPoints; uIndex++) <br>            { <br>                _rgX[uIndex] = _rgX[uIndex + 1]; <br>                _rgY[uIndex] = _rgY[uIndex + 1]; <br>            } <br>        } <br> <br>        // And cause the window to be repainted. <br>        InvalidateRect(_hwnd, NULL, TRUE); <br>        ReleaseCapture(); <br>        break; <br>    case WM_SIZE: <br>        _uWidth = LOWORD(lParam); <br>        _uHeight = HIWORD(lParam); <br>        break; <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            RECT rc; <br>            HDC hdc = BeginPaint(_hwnd, &amp;ps); <br>            if (GetClipBox(ps.hdc, &amp;rc) != NULLREGION) <br>            { <br>                // paint the background grid <br>                HPEN hpen = (HPEN) CreatePen(PS_DOT, 0, WHITENESS); <br>                hpen = (HPEN) SelectObject(ps.hdc, hpen); <br> <br>#define NUMDIVISIONS 12 <br> <br>                int i1, i2; <br>                for (i1 = NUMDIVISIONS-1; i1--;) <br>                { <br>                    i2 = (_uHeight * (i1 + 1)) / NUMDIVISIONS; <br>                    MoveToEx(ps.hdc, 0, i2, NULL); <br>                    LineTo(ps.hdc, _uWidth, i2); <br>                    i2 = (_uWidth * (i1 + 1)) / NUMDIVISIONS; <br>                    MoveToEx(ps.hdc, i2, 0, NULL); <br>                    LineTo(ps.hdc, i2, _uHeight); <br>                } <br> <br>                // The vertical lines <br> <br>                hpen = (HPEN) SelectObject(ps.hdc, hpen); <br>                DeleteObject(hpen); <br> <br>                // paint the generator <br>                hpen = (HPEN) GetStockObject(WHITE_PEN); <br>                HBRUSH hbrush = (HBRUSH) GetStockObject(WHITE_BRUSH); <br>                hpen = (HPEN) SelectObject(ps.hdc, hpen); <br>                hbrush = (HBRUSH) SelectObject(ps.hdc, hbrush); <br> <br>                POINT rgPt[MAX_POINTS]; <br>                for (unsigned uIndex = 0; uIndex &lt; _nPoints; uIndex++) <br>                { <br>                    rgPt[uIndex].x = (long)(((_rgX[uIndex] + 1.0) * _uWidth) / 2); <br>                    rgPt[uIndex].y = (long)(((_rgY[uIndex] - 1.0) * _uHeight) / -2); <br>                    Ellipse( <br>                        ps.hdc, <br>                        rgPt[uIndex].x - POINTRADIUS, <br>                        rgPt[uIndex].y - POINTRADIUS, <br>                        rgPt[uIndex].x + POINTRADIUS, <br>                        rgPt[uIndex].y + POINTRADIUS); <br>                } <br>                Polyline(ps.hdc, rgPt, _nPoints); <br> <br>                hbrush = (HBRUSH) SelectObject(ps.hdc, hbrush); <br>                hpen = (HPEN) SelectObject(ps.hdc, hpen); <br>                DeleteObject(hbrush); <br>                DeleteObject(hpen); <br>            } <br>            EndPaint(_hwnd, &amp;ps); <br>        } <br>        break; <br>    default: <br>        return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>    } <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CGeneratorWindow::InitializePoints <br>// <br>//  Synopsis:   sets up internal list of points <br>// <br>//  Arguments:  [rgRadius]  - array of radius values <br>//              [rgTheta]   - array of angles <br>//              [nSegments] - number of segments in the lists <br>// <br>//  Modifies:   _rgX, _rgY, and _nPoints <br>// <br>//  History:    5-05-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CGeneratorWindow::InitializePoints( <br>    double * rgRadius, <br>    double * rgTheta, <br>    unsigned nSegments) <br>{ <br>    _rgX[0] = -0.5; <br>    _rgY[0] = 0; <br>    for (unsigned index = 0; index &lt; nSegments-1; index ++) <br>    { <br>        CartesianFromPolar( <br>            _rgX[index + 1], <br>            _rgY[index + 1], <br>            rgRadius[index], <br>            rgTheta[index]); <br>        _rgX[index + 1] += _rgX[index]; <br>        _rgY[index + 1] += _rgY[index]; <br>    } <br> <br>    // guarantee the position of the last point <br>    _rgX[nSegments] = 0.5; <br>    _rgY[nSegments] = 0; <br>    _nPoints = nSegments + 1; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CGeneratorWindow::RetrievePoints <br>// <br>//  Synopsis:   returns a new list of segments built from the point list <br>// <br>//  Arguments:  [rgRadius]  - [out] array of radius values <br>//              [rgTheta]   - [out] array of angles <br>//              [nSegments] - [out] number of segments <br>// <br>//  History:    5-05-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CGeneratorWindow::RetrievePoints( <br>    double * rgRadius, <br>    double * rgTheta, <br>    unsigned &amp;nSegments) <br>{ <br>    nSegments = _nPoints - 1; <br>    for (unsigned index = 0; index &lt; nSegments - 1; index++) <br>    { <br>        PolarFromCartesian( <br>            rgRadius[index], <br>            rgTheta[index], <br>            _rgX[index + 1] - _rgX[index], <br>            _rgY[index + 1] - _rgY[index]); <br>    } <br>    // guarantee the position of the last point <br>    PolarFromCartesian( <br>        rgRadius[nSegments - 1], <br>        rgTheta[nSegments - 1], <br>        0.5 - _rgX[nSegments - 1], <br>        0.0 - _rgY[nSegments - 1]); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CGeneratorWindow::Redraw <br>// <br>//  Synopsis:   causes the generator control to repaint itself <br>// <br>//  History:    5-05-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CGeneratorWindow::Redraw(void) <br>{ <br>    InvalidateRect(_hwnd, NULL, TRUE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
