<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RGENOB.CXX</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context212"></a>RGENOB.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       RGenob.cxx <br>// <br>//  Contents:   Recursive Generator Fractal engine object <br>// <br>//  Classes:    CRGen <br>// <br>//  Functions:  StartGraphicsThread <br>//              Normalize <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;rgencid.h&gt; <br>#include "RGen.h" <br>#include &lt;stdio.h&gt; <br>#include &lt;strmhelp.h&gt; <br>#include &lt;palsize.h&gt; <br>#include "polar.h" <br>#include &lt;math.h&gt; <br> <br>#define MAX_RANDOM 50.0 <br>#define MIN_RANDOM 0 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   StartGraphicsThread <br>// <br>//  Synopsis:   Global function used to bootstrap into the GraphicsThread <br>//              member of the CRGen class. <br>// <br>//  Arguments:  [lpdwParam] - not used <br>// <br>//  History:    4-15-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>DWORD StartGraphicsThread(LPDWORD lpdwParam) <br>{ <br>    return (((CRGen *)lpdwParam)-&gt;GraphicsThread()); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::QueryInterface <br>// <br>//  Synopsis:   standard OLE method <br>// <br>//  Arguments:  [riid] - id of desired interface <br>//              [ppv]  - pointer to receive interface <br>// <br>//  Returns:    S_OK on success <br>//              E_NOINTERFACE if the requested interface isn't supported <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::QueryInterface(REFIID riid, LPVOID * ppv) <br>{ <br>    *ppv = NULL; <br>    if (IsEqualGUID(IID_IFractalEngine, riid)) <br>    { <br>        *ppv = (IFractalEngine *)this; <br>    } <br>    else if (IsEqualGUID(IID_IPersist, riid)) <br>    { <br>        *ppv = (IPersist *)this; <br>    } <br>    else if (IsEqualGUID(IID_IPersistStream, riid)) <br>    { <br>        *ppv = (IPersistStream *)this; <br>    } <br>    else if (IsEqualGUID(IID_IUnknown, riid)) <br>    { <br>        *ppv = (IUnknown *)(IFractalEngine *)this; <br>    } <br>    if (*ppv) <br>    { <br>        ((IUnknown *)*ppv)-&gt;AddRef(); <br>        return(S_OK); <br>    } <br>    return(E_NOINTERFACE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::AddRef <br>// <br>//  Synopsis:   increments the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CRGen::AddRef(void) <br>{ <br>    return(++_cRef); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Release <br>// <br>//  Synopsis:   decrements the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CRGen::Release(void) <br>{ <br>    ULONG cRef = --_cRef; <br>    if (0 == cRef) <br>    { <br>        delete this; <br>        gcRef--; <br>    } <br>    return(cRef); <br>} <br> <br>// IPersist methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::GetClassID <br>// <br>//  Synopsis:   returns the object's class ID <br>// <br>//  Arguments:  [pclsid] - pointer to recieve the class ID <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::GetClassID(LPCLSID pclsid) <br>{ <br>    memcpy(pclsid, &amp;CLSID_RGEN, sizeof(GUID)); <br>    return(S_OK); <br>} <br> <br>// IPersistStream methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::IsDirty <br>// <br>//  Synopsis:   used to determine if the state of the object has changed <br>// <br>//  Returns:    S_OK if it is dirty <br>//              S_FALSE if it is not dirty <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::IsDirty(void) <br>{ <br>    if (_fDirty) <br>    { <br>        return(S_OK); <br>    } <br>    else <br>    { <br>        return(S_FALSE); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Load <br>// <br>//  Synopsis:   loads the fractal properties from a stream <br>// <br>//  Arguments:  [pStm] - pointer to an IStream interface <br>// <br>//  Returns:    S_OK on success <br>//              E_FAIL on error <br>//              E_OUTOFMEMORY if there's not enough memory (can't happen here) <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::Load(LPSTREAM pStm) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    HRESULT hr; <br>    if (FAILED(hr = pStm-&gt;Read(&amp;_nItterations, sizeof(_nItterations), NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = pStm-&gt;Read(&amp;_nSegments, sizeof(_nSegments), NULL))) <br>    { <br>        return(hr); <br>    } <br>    for (unsigned uIndex = 0; uIndex &lt; _nSegments; uIndex++) <br>    { <br>        if (FAILED(hr = ReadDouble(pStm, &amp;_rgRadius[uIndex], NULL))) <br>        { <br>            return(hr); <br>        } <br>        if (FAILED(hr = ReadDouble(pStm, &amp;_rgTheta[uIndex], NULL))) <br>        { <br>            return(hr); <br>        } <br>    } <br>    if (FAILED(hr = ReadDouble(pStm, &amp;_dLeft, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = ReadDouble(pStm, &amp;_dTop, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = ReadDouble(pStm, &amp;_dRight, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = ReadDouble(pStm, &amp;_dBottom, NULL))) <br>    { <br>        return(hr); <br>    } <br>    _fDirty = FALSE; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Save <br>// <br>//  Synopsis:   saves the fractal properties to a stream <br>// <br>//  Arguments:  [pStm]        - pointer to an IStream interface <br>//              [fClearDirty] - TRUE if the dirty flag should be cleared <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::Save(LPSTREAM pStm, BOOL fClearDirty) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    HRESULT hr; <br>    if (FAILED(hr = pStm-&gt;Write(&amp;_nItterations, sizeof(_nItterations), NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = pStm-&gt;Write(&amp;_nSegments, sizeof(_nSegments), NULL))) <br>    { <br>        return(hr); <br>    } <br>    for (unsigned uIndex = 0; uIndex &lt; _nSegments; uIndex++) <br>    { <br>        if (FAILED(hr = WriteDouble(pStm, _rgRadius[uIndex], NULL))) <br>        { <br>            return(hr); <br>        } <br>        if (FAILED(hr = WriteDouble(pStm, _rgTheta[uIndex], NULL))) <br>        { <br>            return(hr); <br>        } <br>    } <br>    if (FAILED(hr = WriteDouble(pStm, _dLeft, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = WriteDouble(pStm, _dTop, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = WriteDouble(pStm, _dRight, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = WriteDouble(pStm, _dBottom, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (fClearDirty) <br>    { <br>        _fDirty = FALSE; <br>    } <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::GetSizeMax <br>// <br>//  Synopsis:   used to determine the maximum size of the object's data <br>// <br>//  Arguments:  [pcbSize] - pointer to recieve the max size <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::GetSizeMax(ULARGE_INTEGER * pcbSize) <br>{ <br>    pcbSize-&gt;HighPart = 0; <br>    pcbSize-&gt;LowPart = SizeDouble(); <br>    return(S_OK); <br>} <br> <br>// IFractalEngine methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Init <br>// <br>//  Synopsis:   Initializes the graph engine and saves a pointer to the <br>//              IFractalHost interface that WinFract passes in as <br>//              the engine is initialized. <br>// <br>//  Arguments:  [pfh] - pointer to an IFractalHost interface <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::Init(IFractalHost *pfh) <br>{ <br>    _pfh = pfh; <br>    // NOTE that I don't addref this pointer!  That would create a circular <br>    // reference count paradox. <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::SetDefaultSegmentList <br>// <br>//  Synopsis:   sets the default segment list <br>// <br>//  Returns:    S_OK on success <br>//              E_OUTOFMEMORY if the list couldn't be created <br>// <br>//  History:    5-04-94   stevebl   Created <br>// <br>//  Notes:      The default segment list consists of four <br>//              segments that conform to the following shape: <br>// <br>//                   /\      . <br>//                  /  \     . <br>//              ___/    \___ <br>// <br>//              This is the Triadic Koch Curve. <br>// <br>//              The distance from the first point to the last point in the <br>//              segment list (or path) is always 1.0 units.  The degree is <br>//              always 0. <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CRGen::SetDefaultSegmentList(void) <br>{ <br>    _rgTheta[0] = 0; <br> <br>    // acos(0) == pi / 2 <br>    // I'm using the trig functions instead of a constant <br>    // to ensure that the conversion functions use the <br>    // same values as the ones which I have computed. <br>    _rgTheta[1] = (acos((float)0) * 2.0) / 3.0; <br>    _rgTheta[2] = 0 - (acos((float)0) * 2.0) / 3.0; <br>    _rgTheta[3] = 0; <br>    _rgRadius[0] = _rgRadius[1] = _rgRadius[2] = _rgRadius[3] = 1.0 / 3.0; <br>    _nSegments = 4; <br>    return(S_OK); <br>} <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::SetDefaults <br>// <br>//  Synopsis:   initializes the graph engine with its default values <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::SetDefaults(void) <br>{ <br>    if (_uWidth &gt; _uHeight) <br>    { <br>        // image is wider than it is tall <br>        _dTop = 1.0; <br>        _dBottom = -1.0; <br>        _dLeft = (-1.0 * _uWidth) / _uHeight; <br>        _dRight = (1.0 * _uWidth) / _uHeight; <br>    } <br>    else <br>    { <br>        // image is taller than it is wide <br>        _dLeft = -1.0; <br>        _dRight = 1.0; <br>        _dTop = (1.0 * _uHeight) / _uWidth; <br>        _dBottom = (-1.0 * _uHeight) / _uWidth; <br>    } <br>    _nItterations = 6; <br>    _fDirty = TRUE; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::SetProperties <br>// <br>//  Synopsis:   Displays the graph engine's property dialog box. <br>// <br>//  Arguments:  [hwnd] - handle to the parent window <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::SetProperties(HWND hwnd) <br>{ <br>    ShowDialog(ghinst, MAKEINTRESOURCE(PROPERTIES), hwnd); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::GetExtent <br>// <br>//  Synopsis:   retrieves the extent of the graph <br>// <br>//  Arguments:  [pdLeft]   - x value at the left of the graph <br>//              [pdTop]    - y value at the top of the graph <br>//              [pdRight]  - x value at the right of the graph <br>//              [pdBottom] - y value at the bottom of the graph <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::GetExtent( <br>    double *pdLeft, <br>    double *pdTop, <br>    double *pdRight, <br>    double *pdBottom) <br>{ <br>    *pdLeft = _dLeft; <br>    *pdTop = _dTop; <br>    *pdRight = _dRight; <br>    *pdBottom = _dBottom; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::SetExtent <br>// <br>//  Synopsis:   sets the graph's extent <br>// <br>//  Arguments:  [dLeft]   - x value at the left of the graph <br>//              [dTop]    - y value at the top of the graph <br>//              [dRight]  - x value at the right of the graph <br>//              [dBottom] - y value at the bottom of the graph <br>// <br>//  Returns:    S_OK - extents set <br>//              E_FAIL - the graph was running so the extents couldn't be set <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::SetExtent( <br>    double dLeft, <br>    double dTop, <br>    double dRight, <br>    double dBottom) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    _dLeft = dLeft; <br>    _dTop = dTop; <br>    _dRight = dRight; <br>    _dBottom = dBottom; <br>    _fDirty = TRUE; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::SetGraphSize <br>// <br>//  Synopsis:   Tells the graph engine how big the graph is <br>// <br>//  Arguments:  [uWidth]  - width of graph (in pixels) <br>//              [uHeight] - height of graph (in pixels) <br>// <br>//  Returns:    S_OK - success <br>//              E_FAIL - the graph was running or a value was illegal <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::SetGraphSize( <br>    unsigned int uWidth, <br>    unsigned int uHeight) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    if (uWidth == 0 || uHeight == 0) <br>    { <br>        return(E_FAIL); <br>    } <br>    _uWidth = uWidth; <br>    _uHeight = uHeight; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Start <br>// <br>//  Synopsis:   starts the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::Start(void) <br>{ <br>    SetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Stop <br>// <br>//  Synopsis:   stops the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGen::Stop(void) <br>{ <br>    ResetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>// Methods that aren't part of any interface <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Initialize <br>// <br>//  Synopsis:   called by the class factory to initialize the object <br>// <br>//  Returns:    TRUE on success <br>//              FALSE if the object couldn't be initialized <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CRGen::Initialize(void) <br>{ <br>    _hRestart = CreateEvent( <br>        NULL, <br>        TRUE,   // must be manually reset <br>        TRUE,   // initially signaled <br>        NULL); <br>    if (_hRestart == NULL) <br>    { <br>        return(FALSE);  // couldn't create an event <br>    } <br>    _hRunning = CreateEvent( <br>        NULL, <br>        TRUE, <br>        FALSE, <br>        NULL); <br>    if (_hRunning == NULL) <br>    { <br>        return(FALSE); <br>    } <br>    _hEngine = CreateThread( <br>        (LPSECURITY_ATTRIBUTES)NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE) StartGraphicsThread, <br>        this, <br>        0, <br>        &amp;_dwThreadId); <br>    if (_hEngine == NULL) <br>    { <br>        return(FALSE);  // couldn't start the graphics thread <br>    } <br>    SetDefaultSegmentList(); <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::GraphicsThread <br>// <br>//  Synopsis:   main entry point for the engine's graphics thread <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//  Notes:      This routine enters into an eternal loop.  It will continue <br>//              looping until the class is destroyed at which point this <br>//              thread will be simply terminated. <br>// <br>//  Algorithm: <br>// <br>//---------------------------------------------------------------------------- <br>DWORD CRGen::GraphicsThread(void) <br>{ <br>    do <br>    { <br>        // wait here until someone starts the graphics engine <br>        WaitForSingleObject(_hRunning, INFINITE); <br> <br>        // reset the _hRestart event so that we won't immediately fall out <br>        // of the engine <br>        ResetEvent(_hRestart); <br> <br>        // Now begin drawing the graph <br> <br>        // erase the background <br>        _pfh-&gt;Rect(0, 0, _uWidth - 1, _uHeight - 1, 0); <br> <br>        // begin the recursion <br>        _uColor = 1; <br>        Recurse(-0.5, 0.0, 1.0, 0.0, 0); <br> <br>        // We're either done drawing the graph now or we have been restarted <br>        if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>        { <br>            // Tell our clients that we're finished <br>            _pfh-&gt;DoneDrawingGraph(); <br>            ResetEvent(_hRunning); <br>        } <br>    } while (TRUE); <br>    return(0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::Recurse <br>// <br>//  Synopsis:   Plots one level of the recursion. <br>// <br>//  Arguments:  [x]           - the x coordinate of the start of the segment <br>//              [y]           - the y coordinate of the start of the segment <br>//              [dRadius]     - the length of the segment <br>//              [dTheta]      - the angle of the segment <br>//              [uItteration] - the current depth <br>// <br>//  History:    5-04-94   stevebl   Created <br>// <br>//  Notes: <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CRGen::Recurse(double x, double y, double dRadius, double dTheta, unsigned uItteration) <br>{ <br>    if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>    { <br>        WaitForSingleObject(_hRunning, INFINITE); <br>        if (uItteration &lt; _nItterations) <br>        { <br>            double dOffsetX, dOffsetY; <br> <br>            for (unsigned uIndex = 0; uIndex &lt; _nSegments; uIndex++) <br>            { <br>                Recurse( <br>                    x, <br>                    y, <br>                    _rgRadius[uIndex] * dRadius, <br>                    _rgTheta[uIndex] + dTheta, <br>                    uItteration + 1); <br>                CartesianFromPolar( <br>                    dOffsetX, <br>                    dOffsetY, <br>                    _rgRadius[uIndex] * dRadius, <br>                    _rgTheta[uIndex] + dTheta); <br>                x += dOffsetX; <br>                y += dOffsetY; <br>            } <br>        } <br>        else <br>        { <br>            double dDeltaX, dDeltaY; <br> <br>            CartesianFromPolar(dDeltaX, dDeltaY, dRadius, dTheta); <br> <br>            double dWidth = _dRight - _dLeft; <br>            double dHeight = _dBottom - _dTop; <br> <br>#define CONVERTX(x) ((((x) - _dLeft) * (_uWidth - 1)) / dWidth) <br>#define CONVERTY(y) ((((y) - _dTop) * (_uHeight - 1)) / dHeight) <br> <br>            int x1 = (int) CONVERTX(x); <br>            int y1 = (int) CONVERTY(y); <br>            int x2 = (int) CONVERTX(x + dDeltaX); <br>            int y2 = (int) CONVERTY(y + dDeltaY); <br> <br>            _pfh-&gt;Line(x1, y1, x2, y2, _uColor); <br> <br>            // advance to the next color <br>            _uColor = 1 + (_uColor % (PALETTESIZE - 1)); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::CRGen <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CRGen::CRGen() <br>{ <br>    _uWidth = 160; <br>    _uHeight = 120; <br>    _nSegments = 0; <br>    _nItterations = 1; <br>    _hRestart = _hRunning = _hEngine = NULL; <br>    _dwThreadId = 0; <br>    _dLeft = -1; <br>    _dTop = 1; <br>    _dRight = 1; <br>    _dBottom = 1; <br>    _cRef = 0; <br>    _pfh = NULL; <br>    _fDirty = TRUE; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::~CRGen <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CRGen::~CRGen() <br>{ <br>    if (_hRestart) <br>    { <br>        CloseHandle(_hRestart); <br>    } <br>    if (_hRunning) <br>    { <br>        CloseHandle(_hRunning); <br>    } <br>    if (_hEngine) <br>    { <br>        TerminateThread(_hEngine, 0); <br>        CloseHandle(_hEngine); <br>    } <br>} <br> <br>#define LENGTH 50 <br>#define ABOUT_STRING_LENGTH 256 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGen::DialogProc <br>// <br>//  Synopsis:   Dialog proc for the Properties dialog box <br>// <br>//  Arguments:  [hwndDlg] - the dialog's window handle <br>//              [uMsg]    - message <br>//              [wParam]  - first message parameter <br>//              [lParam]  - second message parameter <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CRGen::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        { <br>            _pwinGeneratorWindow = new CGeneratorWindow; <br>            if (_pwinGeneratorWindow) <br>            { <br>                _pwinGeneratorWindow-&gt;InitializePoints(_rgRadius, _rgTheta, _nSegments); <br>                RECT rDim; <br>                rDim.left = 3; <br>                rDim.right = 100; <br>                rDim.top = 10; <br>                rDim.bottom = 100; <br>                MapDialogRect(hwndDlg, &amp;rDim); <br>                _pwinGeneratorWindow-&gt;Create( <br>                    TEXT("RGen Generator"), <br>                    NULL, <br>                    WS_CHILD | WS_VISIBLE, <br>                    rDim.left, <br>                    rDim.top, <br>                    rDim.right, <br>                    rDim.bottom, <br>                    hwndDlg, <br>                    NULL, <br>                    ghinst); <br>            } <br>            SetDlgItemInt(hwndDlg, IDD_ITTERATIONS, _nItterations, FALSE); <br>        } <br>        return(TRUE); <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) <br>        { <br>        case IDOK: <br>            _nItterations = GetDlgItemInt(hwndDlg, IDD_ITTERATIONS, NULL, FALSE); <br>            if (_pwinGeneratorWindow) <br>            { <br>                _pwinGeneratorWindow-&gt;RetrievePoints(_rgRadius, _rgTheta, _nSegments); <br>            } <br>            _fDirty = TRUE; <br>            SetEvent(_hRestart); <br>            EndDialog(hwndDlg, TRUE); <br>            return(TRUE); <br>        case IDD_RESET: <br>            { <br>                SetDefaultSegmentList(); <br>                if (_pwinGeneratorWindow) <br>                { <br>                    _pwinGeneratorWindow-&gt;InitializePoints(_rgRadius, _rgTheta, _nSegments); <br>                    _pwinGeneratorWindow-&gt;Redraw(); <br>                } <br>                return(TRUE); <br>            } <br>        case IDD_ABOUT: <br>            { <br>                TCHAR szTitle[ABOUT_STRING_LENGTH]; <br>                TCHAR szText[ABOUT_STRING_LENGTH]; <br>                if (LoadString(ghinst, IDS_ABOUT_TITLE, szTitle, ABOUT_STRING_LENGTH)) <br>                { <br>                    if (LoadString(ghinst, IDS_ABOUT_TEXT, szText, ABOUT_STRING_LENGTH)) <br>                    { <br>                        MessageBox( <br>                            hwndDlg, <br>                            szText, <br>                            szTitle, <br>                            MB_OK | MB_ICONINFORMATION); <br>                    } <br>                } <br>            } <br>            return(TRUE); <br>        case IDCANCEL: <br>            EndDialog(hwndDlg, FALSE); <br>            return(TRUE); <br>        default: <br>            return(FALSE); <br>        } <br>    } <br>    return(FALSE); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
