<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STMDIB.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context192"></a>STMDIB.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       stmdib.cxx <br>// <br>//  Contents:   functions for saving and loading DIBs to OLE streams <br>// <br>//  Classes: <br>// <br>//  Functions:  WriteDibToStream <br>//              ReadDibFromStream <br>//              ReadDibBitmapInfoFromStream <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "stmdib.h" <br>#include "dib.h" <br>#include &lt;stdlib.h&gt; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   WriteDibToStream <br>// <br>//  Synopsis:   writes a global handle in CF_DIB format to a stream <br>// <br>//  Arguments:  [pstm] - stream <br>//              [hdib] - DIB handle <br>// <br>//  Returns:    S_OK if successful <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT WriteDibToStream (IStream * pstm, HANDLE hdib) <br>{ <br>    BITMAPFILEHEADER    hdr; <br>    LPBITMAPINFOHEADER  lpbi; <br>    OFSTRUCT            of; <br>    HRESULT hr; <br> <br>    if (!hdib) <br>        return FALSE; <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock (hdib); <br> <br>    /* Fill in the fields of the file header */ <br>    hdr.bfType      = BFT_BITMAP; <br>    hdr.bfSize      = GlobalSize (hdib) + sizeof (BITMAPFILEHEADER); <br>    hdr.bfReserved1 = 0; <br>    hdr.bfReserved2 = 0; <br>    hdr.bfOffBits   = (DWORD)sizeof(BITMAPFILEHEADER) + lpbi-&gt;biSize + <br>        PaletteSize(lpbi); <br> <br>    /* Write the file header */ <br>    if (FAILED(hr = pstm-&gt;Write(&amp;hdr, sizeof (BITMAPFILEHEADER), NULL))) <br>    { <br>        return(hr); <br>    } <br> <br>    /* Write the DIB header and the bits */ <br>    if (FAILED(hr = pstm-&gt;Write(lpbi, GlobalSize (hdib), NULL))) <br>    { <br>        return(hr); <br>    } <br> <br>    GlobalUnlock (hdib); <br>    return S_OK; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ReadDibFromStream <br>// <br>//  Synopsis:   reads a DIB stored in CF_DIB format from a stream <br>// <br>//  Arguments:  [pstm]  - pointer to the stream <br>//              [phDib] - pointer to recieve the DIB handle <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT ReadDibFromStream (IStream * pstm, HANDLE * phDib) <br>{ <br>    BITMAPINFOHEADER    bi; <br>    LPBITMAPINFOHEADER  lpbi; <br>    DWORD       dwLen = 0; <br>    DWORD       dwBits; <br>    HANDLE      hdib; <br>    HANDLE      h; <br>    OFSTRUCT        of; <br>    HRESULT hr; <br> <br>    *phDib = NULL; <br> <br>    if (FAILED(hr = ReadDibBitmapInfoFromStream(pstm, &amp;hdib))) <br>    { <br>        return(hr); <br>    } <br>    DibInfo(hdib,&amp;bi); <br> <br>    /* Calculate the memory needed to hold the DIB */ <br>    dwBits = bi.biSizeImage; <br>    dwLen  = bi.biSize + (DWORD)PaletteSize (&amp;bi) + dwBits; <br> <br>    /* Try to increase the size of the bitmap info. buffer to hold the DIB */ <br>    h = GlobalReAlloc(hdib, dwLen, GHND); <br>    if (!h) <br>    { <br>        GlobalFree(hdib); <br>        return(E_OUTOFMEMORY); <br>    } <br>    hdib = h; <br> <br>    /* Read in the bits */ <br> <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hdib); <br>    if (FAILED(hr = pstm-&gt;Read(((LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi)), dwBits, NULL))) <br>    { <br>        return(hr); <br>    } <br>    GlobalUnlock(hdib); <br> <br>    *phDib = hdib; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   ReadDibBitmapInfoFromStream <br>// <br>//  Synopsis:   reads a file in DIB format and retrieves a global HANDLE to <br>//              its BITMAPINFO. <br>// <br>//  Arguments:  [pstm] - stream <br>//              [phbi] - pointer to receive HANDLE to BITMAPINFO <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT ReadDibBitmapInfoFromStream(IStream * pstm, HANDLE * phbi) <br>{ <br>    ULARGE_INTEGER libOff; <br>    LARGE_INTEGER dlibMove; <br>    HANDLE    hbi = NULL; <br>    int       size; <br>    int       i; <br>    WORD      nNumColors; <br> <br>    RGBQUAD FAR       *pRgb; <br>    BITMAPINFOHEADER   bi; <br>    BITMAPCOREHEADER   bc; <br>    LPBITMAPINFOHEADER lpbi; <br>    BITMAPFILEHEADER   bf; <br>    DWORD          dwWidth = 0; <br>    DWORD          dwHeight = 0; <br>    WORD           wPlanes, wBitCount; <br>    HRESULT hr; <br> <br>    *phbi = NULL; <br> <br>    /* Reset file pointer and read file header */ <br> <br>    dlibMove.HighPart = 0; <br>    dlibMove.LowPart = 0; <br>    if (FAILED(hr = pstm-&gt;Seek(dlibMove, STREAM_SEEK_CUR, &amp;libOff))) <br>    { <br>        return(hr); <br>    } <br>    if (FAILED(hr = pstm-&gt;Read(&amp;bf, sizeof(bf), NULL))) <br>    { <br>        return(hr); <br>    } <br> <br>    /* Do we have a RC HEADER? */ <br>    if (!ISDIB (bf.bfType)) <br>    { <br>        bf.bfOffBits = 0L; <br>        dlibMove.HighPart = libOff.HighPart; <br>        dlibMove.LowPart = libOff.LowPart; <br>        if (FAILED(hr = pstm-&gt;Seek(dlibMove, STREAM_SEEK_SET, NULL))) <br>        { <br>            return(hr); <br>        } <br>    } <br>    if (FAILED(hr = pstm-&gt;Read(&amp;bi, sizeof(bi), NULL))) <br>    { <br>        return(hr); <br>    } <br> <br>    nNumColors = DibNumColors (&amp;bi); <br> <br>    /* Check the nature (BITMAPINFO or BITMAPCORE) of the info. block <br>     * and extract the field information accordingly. If a BITMAPCOREHEADER, <br>     * transfer it's field information to a BITMAPINFOHEADER-style block <br>     */ <br>    switch (size = (int)bi.biSize) <br>    { <br>    case sizeof (BITMAPINFOHEADER): <br>        break; <br> <br>    case sizeof (BITMAPCOREHEADER): <br>        bc = *(BITMAPCOREHEADER*)&amp;bi; <br>        dwWidth   = (DWORD)bc.bcWidth; <br>        dwHeight  = (DWORD)bc.bcHeight; <br>        wPlanes   = bc.bcPlanes; <br>        wBitCount = bc.bcBitCount; <br>        bi.biSize           = sizeof(BITMAPINFOHEADER); <br>        bi.biWidth          = dwWidth; <br>        bi.biHeight         = dwHeight; <br>        bi.biPlanes         = wPlanes; <br>        bi.biBitCount       = wBitCount; <br>        bi.biCompression    = BI_RGB; <br>        bi.biSizeImage      = 0; <br>        bi.biXPelsPerMeter  = 0; <br>        bi.biYPelsPerMeter  = 0; <br>        bi.biClrUsed        = nNumColors; <br>        bi.biClrImportant   = nNumColors; <br>        dlibMove.HighPart = 0; <br>        dlibMove.LowPart = sizeof (BITMAPCOREHEADER) - sizeof (BITMAPINFOHEADER); <br>        if (FAILED(hr = pstm-&gt;Seek(dlibMove, STREAM_SEEK_CUR, NULL))) <br>        { <br>            return(hr); <br>        } <br>        break; <br> <br>    default: <br>        /* Not a DIB! */ <br>        return E_FAIL; <br>    } <br> <br>    /*  Fill in some default values if they are zero */ <br>    if (bi.biSizeImage == 0) <br>    { <br>        bi.biSizeImage = WIDTHBYTES ((DWORD)bi.biWidth * bi.biBitCount) <br>            * bi.biHeight; <br>    } <br>    if (bi.biClrUsed == 0) <br>        bi.biClrUsed = DibNumColors(&amp;bi); <br> <br>    /* Allocate for the BITMAPINFO structure and the color table. */ <br>    hbi = GlobalAlloc (GHND, (LONG)bi.biSize + nNumColors * sizeof(RGBQUAD)); <br>    if (!hbi) <br>        return NULL; <br>    lpbi = (LPBITMAPINFOHEADER)GlobalLock (hbi); <br>    *lpbi = bi; <br> <br>    /* Get a pointer to the color table */ <br>    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize); <br>    if (nNumColors) <br>    { <br>        if (size == sizeof(BITMAPCOREHEADER)) <br>        { <br>            /* Convert a old color table (3 byte RGBTRIPLEs) to a new <br>             * color table (4 byte RGBQUADs) <br>             */ <br>             if (FAILED(hr = pstm-&gt;Read(pRgb, nNumColors * sizeof(RGBTRIPLE), NULL))) <br>             { <br>                 return(hr); <br>             } <br> <br>            for (i = nNumColors - 1; i &gt;= 0; i--) <br>            { <br>                RGBQUAD rgb; <br> <br>                rgb.rgbRed  = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed; <br>                rgb.rgbBlue = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue; <br>                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen; <br>                rgb.rgbReserved = (BYTE)0; <br> <br>                pRgb[i] = rgb; <br>            } <br>        } <br>        else <br>        { <br>            if (FAILED(hr = pstm-&gt;Read(pRgb, nNumColors * sizeof(RGBQUAD), NULL))) <br>            { <br>                return(hr); <br>            } <br>        } <br>    } <br> <br>    if (bf.bfOffBits != 0L) <br>    { <br>        dlibMove.HighPart = libOff.HighPart; <br>        dlibMove.LowPart = libOff.LowPart + bf.bfOffBits; <br>        if (FAILED(hr = pstm-&gt;Seek(dlibMove, STREAM_SEEK_SET, NULL))) <br>        { <br>            return(hr); <br>        } <br>    } <br> <br>    GlobalUnlock(hbi); <br>    *phbi = hbi; <br>    return(S_OK); <br>} <br> <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
