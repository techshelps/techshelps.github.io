<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PLASMAOB.CXX</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context202"></a>PLASMAOB.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       plasmaob.cxx <br>// <br>//  Contents:   Plasma Fractal engine object <br>// <br>//  Classes:    CPlasma <br>// <br>//  Functions:  StartGraphicsThread <br>//              Normalize <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;plasmcid.h&gt; <br>#include "plasma.h" <br>#include &lt;stdio.h&gt; <br>#include &lt;strmhelp.h&gt; <br>#include &lt;palsize.h&gt; <br>#include &lt;math.h&gt; <br> <br>#define MAX_RANDOM 50.0 <br>#define MIN_RANDOM 0 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   StartGraphicsThread <br>// <br>//  Synopsis:   Global function used to bootstrap into the GraphicsThread <br>//              member of the CPlasma class. <br>// <br>//  Arguments:  [lpdwParam] - not used <br>// <br>//  History:    4-15-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>DWORD StartGraphicsThread(LPDWORD lpdwParam) <br>{ <br>    return (((CPlasma *)lpdwParam)-&gt;GraphicsThread()); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::QueryInterface <br>// <br>//  Synopsis:   standard OLE method <br>// <br>//  Arguments:  [riid] - id of desired interface <br>//              [ppv]  - pointer to receive interface <br>// <br>//  Returns:    S_OK on success <br>//              E_NOINTERFACE if the requested interface isn't supported <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::QueryInterface(REFIID riid, LPVOID * ppv) <br>{ <br>    *ppv = NULL; <br>    if (IsEqualGUID(IID_IFractalEngine, riid)) <br>    { <br>        *ppv = (IFractalEngine *)this; <br>    } <br>    else if (IsEqualGUID(IID_IPersist, riid)) <br>    { <br>        *ppv = (IPersist *)this; <br>    } <br>    else if (IsEqualGUID(IID_IPersistStream, riid)) <br>    { <br>        *ppv = (IPersistStream *)this; <br>    } <br>    else if (IsEqualGUID(IID_IUnknown, riid)) <br>    { <br>        *ppv = (IUnknown *)(IFractalEngine *)this; <br>    } <br>    if (*ppv) <br>    { <br>        ((IUnknown *)*ppv)-&gt;AddRef(); <br>        return(S_OK); <br>    } <br>    return(E_NOINTERFACE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::AddRef <br>// <br>//  Synopsis:   increments the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CPlasma::AddRef(void) <br>{ <br>    return(++_cRef); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Release <br>// <br>//  Synopsis:   decrements the reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CPlasma::Release(void) <br>{ <br>    ULONG cRef = --_cRef; <br>    if (0 == cRef) <br>    { <br>        delete this; <br>        gcRef--; <br>    } <br>    return(cRef); <br>} <br> <br>// IPersist methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::GetClassID <br>// <br>//  Synopsis:   returns the object's class ID <br>// <br>//  Arguments:  [pclsid] - pointer to recieve the class ID <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CPlasma::GetClassID(LPCLSID pclsid) <br>{ <br>    memcpy(pclsid, &amp;CLSID_PLASMA, sizeof(GUID)); <br>    return(S_OK); <br>} <br> <br>// IPersistStream methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::IsDirty <br>// <br>//  Synopsis:   used to determine if the state of the object has changed <br>// <br>//  Returns:    S_OK if it is dirty <br>//              S_FALSE if it is not dirty <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CPlasma::IsDirty(void) <br>{ <br>    if (_fDirty) <br>    { <br>        return(S_OK); <br>    } <br>    else <br>    { <br>        return(S_FALSE); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Load <br>// <br>//  Synopsis:   loads the fractal properties from a stream <br>// <br>//  Arguments:  [pStm] - pointer to an IStream interface <br>// <br>//  Returns:    S_OK on success <br>//              E_FAIL on error <br>//              E_OUTOFMEMORY if there's not enough memory (can't happen here) <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CPlasma::Load(LPSTREAM pStm) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    HRESULT hr; <br>    if (FAILED(hr = ReadDouble(pStm, &amp;_dRandomnessFactor, NULL))) <br>    { <br>        return(hr); <br>    } <br>    _fDirty = FALSE; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Save <br>// <br>//  Synopsis:   saves the fractal properties to a stream <br>// <br>//  Arguments:  [pStm]        - pointer to an IStream interface <br>//              [fClearDirty] - TRUE if the dirty flag should be cleared <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CPlasma::Save(LPSTREAM pStm, BOOL fClearDirty) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    HRESULT hr; <br>    if (FAILED(hr = WriteDouble(pStm, _dRandomnessFactor, NULL))) <br>    { <br>        return(hr); <br>    } <br>    if (fClearDirty) <br>    { <br>        _fDirty = FALSE; <br>    } <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::GetSizeMax <br>// <br>//  Synopsis:   used to determine the maximum size of the object's data <br>// <br>//  Arguments:  [pcbSize] - pointer to recieve the max size <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT CPlasma::GetSizeMax(ULARGE_INTEGER * pcbSize) <br>{ <br>    pcbSize-&gt;HighPart = 0; <br>    pcbSize-&gt;LowPart = SizeDouble(); <br>    return(S_OK); <br>} <br> <br>// IFractalEngine methods <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Init <br>// <br>//  Synopsis:   Initializes the graph engine and saves a pointer to the <br>//              IFractalHost interface that WinFract passes in as <br>//              the engine is initialized. <br>// <br>//  Arguments:  [pfh] - pointer to an IFractalHost interface <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::Init(IFractalHost *pfh) <br>{ <br>    _pfh = pfh; <br>    // NOTE that I don't addref this pointer!  That would create a circular <br>    // reference count paradox. <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::SetDefaults <br>// <br>//  Synopsis:   initializes the graph engine with its default values <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::SetDefaults(void) <br>{ <br>    _dRandomnessFactor = 2.0; <br>    _fDirty = TRUE; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::SetProperties <br>// <br>//  Synopsis:   Displays the graph engine's property dialog box. <br>// <br>//  Arguments:  [hwnd] - handle to the parent window <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::SetProperties(HWND hwnd) <br>{ <br>    ShowDialog(ghinst, MAKEINTRESOURCE(PROPERTIES), hwnd); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::GetExtent <br>// <br>//  Synopsis:   retrieves the extent of the graph <br>// <br>//  Arguments:  [pdLeft]   - x value at the left of the graph <br>//              [pdTop]    - y value at the top of the graph <br>//              [pdRight]  - x value at the right of the graph <br>//              [pdBottom] - y value at the bottom of the graph <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::GetExtent( <br>    double *pdLeft, <br>    double *pdTop, <br>    double *pdRight, <br>    double *pdBottom) <br>{ <br>    *pdLeft = -1.0; <br>    *pdTop = 1.0; <br>    *pdRight = 1.0; <br>    *pdBottom = -1.0; <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::SetExtent <br>// <br>//  Synopsis:   sets the graph's extent <br>// <br>//  Arguments:  [dLeft]   - x value at the left of the graph <br>//              [dTop]    - y value at the top of the graph <br>//              [dRight]  - x value at the right of the graph <br>//              [dBottom] - y value at the bottom of the graph <br>// <br>//  Returns:    S_OK - extents set <br>//              E_FAIL - the graph was running so the extents couldn't be set <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::SetExtent( <br>    double dLeft, <br>    double dTop, <br>    double dRight, <br>    double dBottom) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    _fDirty = TRUE; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::SetGraphSize <br>// <br>//  Synopsis:   Tells the graph engine how big the graph is <br>// <br>//  Arguments:  [uWidth]  - width of graph (in pixels) <br>//              [uHeight] - height of graph (in pixels) <br>// <br>//  Returns:    S_OK - success <br>//              E_FAIL - the graph was running or a value was illegal <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::SetGraphSize( <br>    unsigned int uWidth, <br>    unsigned int uHeight) <br>{ <br>    if (WAIT_OBJECT_0 == WaitForSingleObject(_hRunning, 0)) <br>    { <br>        return(E_FAIL); <br>    } <br>    if (uWidth == 0 || uHeight == 0) <br>    { <br>        return(E_FAIL); <br>    } <br>    _uWidth = uWidth; <br>    _uHeight = uHeight; <br>    SetEvent(_hRestart); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Start <br>// <br>//  Synopsis:   starts the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::Start(void) <br>{ <br>    SetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Stop <br>// <br>//  Synopsis:   stops the graph engine <br>// <br>//  Returns:    S_OK on success <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CPlasma::Stop(void) <br>{ <br>    ResetEvent(_hRunning); <br>    return(S_OK); <br>} <br> <br>// Methods that aren't part of any interface <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Initialize <br>// <br>//  Synopsis:   called by the clas factory to initialize the object <br>// <br>//  Returns:    TRUE on success <br>//              FALSE if the object couldn't be initialized <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CPlasma::Initialize(void) <br>{ <br>    _hRestart = CreateEvent( <br>        NULL, <br>        TRUE,   // must be manually reset <br>        TRUE,   // initially signaled <br>        NULL); <br>    if (_hRestart == NULL) <br>    { <br>        return(FALSE);  // couldn't create an event <br>    } <br>    _hRunning = CreateEvent( <br>        NULL, <br>        TRUE, <br>        FALSE, <br>        NULL); <br>    if (_hRunning == NULL) <br>    { <br>        return(FALSE); <br>    } <br>    _hEngine = CreateThread( <br>        (LPSECURITY_ATTRIBUTES)NULL, <br>        0, <br>        (LPTHREAD_START_ROUTINE) StartGraphicsThread, <br>        this, <br>        0, <br>        &amp;_dwThreadId); <br>    if (_hEngine == NULL) <br>    { <br>        return(FALSE);  // couldn't start the graphics thread <br>    } <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::GraphicsThread <br>// <br>//  Synopsis:   main entry point for the engine's graphics thread <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//  Notes:      This routine enters into an eternal loop.  It will continue <br>//              looping until the class is destroyed at which point this <br>//              thread will be simply terminated. <br>// <br>//  Algorithm:  Wait for the engine to be started. <br>//              Clear the graph. <br>//              Plot the points at the graph's four corners. <br>//              Divide it into four quadrants and call Subdivide for each. <br>//              After falling out of the recursion, check to see if the <br>//              graph has been aborted. <br>//              If not, notify that the graph has been completed. <br>//              Loop back around to the beginning. <br>// <br>//---------------------------------------------------------------------------- <br>DWORD CPlasma::GraphicsThread(void) <br>{ <br>    do <br>    { <br>        // wait here until someone starts the graphics engine <br>        WaitForSingleObject(_hRunning, INFINITE); <br> <br>        // reset the _hRestart event so that we won't immediately fall out <br>        // of the engine <br>        ResetEvent(_hRestart); <br> <br>        // Now begin drawing the graph <br> <br>        // erase the background <br>        _pfh-&gt;Rect(0, 0, (int) _uWidth - 1, (int) _uHeight - 1, 0); <br> <br>        // Seed the random number generator <br>        srand((UINT)GetTickCount()); <br> <br>        // plot the upper corner <br>        _pfh-&gt;Point(0, 0, rand() % (PALETTESIZE -1 )); <br> <br>        // begin the recursion <br>        Subdivide(0, 0, (int) _uWidth, (int) _uHeight); <br> <br>        // We're either done drawing the graph now or we have been restarted <br>        if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>        { <br>            // Tell our clients that we're finished <br>            _pfh-&gt;DoneDrawingGraph(); <br>            ResetEvent(_hRunning); <br>        } <br>    } while (TRUE); <br>    return(0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   Normalize <br>// <br>//  Synopsis:   Makes sure that the value is within the legal color set. <br>// <br>//  Arguments:  [iTemp] - color index value <br>// <br>//  Returns:    0 &lt;= iTemp &lt; (PALETTESIZE - 1) <br>// <br>//  History:    4-28-94   stevebl   Created <br>// <br>//  Notes:      There are a couple ways this could be achieved, most of them <br>//              are undesirable. <br>// <br>//              For instance, we could just perform a modulus operation on <br>//              the value: <br>// <br>//                  iTemp = iTemp % (PALETTESIZE - 1) <br>// <br>//              This would have the effect of causing numbers to wrap <br>//              around (PALETTESIZE - 1 would become 0).  This would be bad because <br>//              in order for the graph to look good we want all the points to <br>//              transition as smoothley as possible.  Doing it this way <br>//              would cause the graph to have an area where the elevation <br>//              suddenly changed dramaticaly when it should have been very <br>//              smooth. <br>// <br>//              Another option would be to just truncate the value: <br>// <br>//              if (iTemp) &gt; PALETTESIZE - 2) iTemp = PALETTESIZE - 2 <br>// <br>//              This would cause our graph to have areas where it is <br>//              artificially flat. <br>// <br>//              Instead, this routine reflects the value back down into a <br>//              range of values.  For every unit the value is over <br>//              PALETTESIZE - 2, it is made to be that many units under <br>//              PALETTESIZE - 1.  This avoids both sudden elevation changes <br>//              and flat spots. <br>// <br>//---------------------------------------------------------------------------- <br> <br>inline void Normalize(int &amp; iTemp) <br>{ <br>    while (iTemp &lt; 0 || iTemp &gt;= PALETTESIZE - 1) <br>    { <br>        if (iTemp &lt; 0) <br>        { <br>            iTemp = 0 - iTemp; <br>        } <br>        else <br>        { <br>            iTemp = ((PALETTESIZE - 1) * 2) - (iTemp + 1); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::Subdivide <br>// <br>//  Synopsis:   recurses into  a rectangle <br>// <br>//  Arguments:  [xl] - left side <br>//              [yl] - top side <br>//              [xh] - right side <br>//              [yh] - bottom side <br>// <br>//  Returns:    nothing <br>// <br>//  History:    4-25-94   stevebl   Created <br>// <br>//  Notes:      Each ittertation is responsible for drawing the <br>//              points marked X below if the haven't already been drawn. <br>//              The O's are points drawn by previous ittertations. <br>//              The .'s represent points to be drawn by future itterations. <br>// <br>//              O . . . . . X . . . . . O <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              X . . . . . X . . . . . X <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              . . . . . . . . . . . . . <br>//              O . . . . . X . . . . . O <br>// <br>//              Once the routine has plotted its points, it divides <br>//              the graph into quarters and calls itself <br>//              for each quarter. <br>// <br>//              Since the graph is erased to color 0 before itterations are <br>//              begun, testing if a point has already been plotted is simple: <br>//              if the point contians color 0 then it hasn't been plotted yet. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CPlasma::Subdivide(int xl, int yl, int xh, int yh) <br>{ <br>    if (WAIT_TIMEOUT == WaitForSingleObject(_hRestart, 0)) <br>    { <br>        WaitForSingleObject(_hRunning, INFINITE); <br>        // find the midpoints <br>        int iMidX = (xh + xl) / 2; <br>        int iMidY = (yh + yl) / 2; <br> <br>        // find the four corner colors <br>        unsigned char cTL, cTR, cBL, cBR; <br>        unsigned uTemp; <br>        _pfh-&gt;GetPoint(&amp;uTemp, xl, yl); <br>        cTL = uTemp - 1; <br>        _pfh-&gt;GetPoint(&amp;uTemp, xh % _uWidth, yl); <br>        cTR = uTemp - 1; <br>        _pfh-&gt;GetPoint(&amp;uTemp, xl, yh % _uHeight); <br>        cBL = uTemp - 1; <br>        _pfh-&gt;GetPoint(&amp;uTemp, xh % _uWidth, yh % _uHeight); <br>        cBR = uTemp - 1; <br>        int cTM, cLM, cRM, cBM; <br> <br>        unsigned uSpread = (unsigned)((xh - xl) * _dRandomnessFactor); <br> <br>        // choose the top point <br>        _pfh-&gt;GetPoint(&amp;uTemp, iMidX, yl); <br>        if (0 == uTemp) <br>        { <br>            cTM = (rand() % (uSpread * 2 + 1)) - uSpread; <br>            cTM += (cTL + cTR) / 2; <br>            Normalize(cTM); <br>            _pfh-&gt;Point(iMidX, yl, cTM + 1); <br>        } <br> <br>        // choose the bottom point <br>        _pfh-&gt;GetPoint(&amp;uTemp, iMidX, yh % _uHeight); <br>        if (0 == uTemp) <br>        { <br>            cBM = (rand() % (uSpread * 2 + 1)) - uSpread; <br>            cBM += (cBL + cBR) / 2; <br>            Normalize(cBM); <br>            // Don't need to use yh % _uHeight here because the only <br>            // way we can get here is if yh &lt; _uHeight. <br>            _pfh-&gt;Point(iMidX, yh, cBM + 1); <br>        } <br> <br>        uSpread = (unsigned)((yh - yl) * _dRandomnessFactor); <br> <br>        // choose the left point <br>        _pfh-&gt;GetPoint(&amp;uTemp,xl, iMidY); <br>        if (0 == uTemp) <br>        { <br>            cLM = (rand() % (uSpread * 2 + 1)) - uSpread; <br>            cLM += (cTL + cBL) / 2; <br>            Normalize(cLM); <br>            _pfh-&gt;Point(xl, iMidY, cLM + 1); <br>        } <br> <br>        // choose the right point <br>        _pfh-&gt;GetPoint(&amp;uTemp, xh % _uWidth, iMidY); <br>        if (0 == uTemp) <br>        { <br>            cRM = (rand() % (uSpread * 2 + 1)) - uSpread; <br>            cRM += (cTR + cBR) / 2; <br>            Normalize(cRM); <br>            // Don't need to use xh % _uWidth here because the only <br>            // way we can get here is if xh &lt; _uWidth. <br>            _pfh-&gt;Point(xh, iMidY, cRM + 1); <br>        } <br> <br>        _pfh-&gt;GetPoint(&amp;uTemp, iMidX, iMidY); <br>        if (0 == uTemp) <br>        { <br>            // choose the center point <br>            uSpread = (unsigned)((sqrt(((float)(xh - xl) * (xh - xl) + (yh - yl) * (yh - yl))) / 2) * _dRandomnessFactor); <br>            int cC = (rand() % (uSpread * 2 + 1)) - uSpread; <br>            cC += (cTL + cBR + cTR + cBL) / 4; <br>            Normalize(cC); <br>            _pfh-&gt;Point(iMidX, iMidY, cC + 1); <br>        } <br> <br>        // now recurse <br>        if (xh - xl &gt; 2 || yh - yl &gt; 2) <br>        { <br>            Subdivide(xl, yl, iMidX, iMidY); <br>            Subdivide(iMidX, yl, xh, iMidY); <br>            Subdivide(xl, iMidY, iMidX, yh); <br>            Subdivide(iMidX, iMidY, xh, yh); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::CPlasma <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CPlasma::CPlasma() <br>{ <br>    _uWidth = 160; <br>    _uHeight = 120; <br>    _dRandomnessFactor = 2.0; <br>    _hRestart = _hRunning = _hEngine = NULL; <br>    _dwThreadId = 0; <br>    _cRef = 0; <br>    _pfh = NULL; <br>    _fDirty = TRUE; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::~CPlasma <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CPlasma::~CPlasma() <br>{ <br>    if (_hRestart) <br>    { <br>        CloseHandle(_hRestart); <br>    } <br>    if (_hRunning) <br>    { <br>        CloseHandle(_hRunning); <br>    } <br>    if (_hEngine) <br>    { <br>        TerminateThread(_hEngine, 0); <br>        CloseHandle(_hEngine); <br>    } <br>} <br> <br>#define LENGTH 50 <br>#define ABOUT_STRING_LENGTH 256 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CPlasma::DialogProc <br>// <br>//  Synopsis:   Dialog proc for the Properties dialog box <br>// <br>//  Arguments:  [hwndDlg] - the dialog's window handle <br>//              [uMsg]    - message <br>//              [wParam]  - first message parameter <br>//              [lParam]  - second message parameter <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CPlasma::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    char mbs[LENGTH + 1]; <br> <br>    switch (uMsg) <br>    { <br>    case WM_INITDIALOG: <br>        sprintf(mbs, "%.13g", _dRandomnessFactor); <br>        SetDlgItemTextA(hwndDlg, IDM_RANDOMNESS, mbs); <br>        return(TRUE); <br>    case WM_COMMAND: <br>        switch (LOWORD(wParam)) <br>        { <br>        case IDOK: <br>            GetDlgItemTextA(hwndDlg, IDM_RANDOMNESS, mbs, LENGTH); <br>            sscanf(mbs, "%lg", &amp;_dRandomnessFactor); <br>            if (_dRandomnessFactor &lt; MIN_RANDOM) <br>            { <br>                _dRandomnessFactor = MIN_RANDOM; <br>            } <br>            if (_dRandomnessFactor &gt; MAX_RANDOM) <br>            { <br>                _dRandomnessFactor = MAX_RANDOM; <br>            } <br>            _fDirty = TRUE; <br>            SetEvent(_hRestart); <br>            EndDialog(hwndDlg, TRUE); <br>            return(TRUE); <br>        case IDM_ABOUT: <br>            { <br>                TCHAR szTitle[ABOUT_STRING_LENGTH]; <br>                TCHAR szText[ABOUT_STRING_LENGTH]; <br>                if (LoadString(ghinst, IDS_ABOUT_TITLE, szTitle, ABOUT_STRING_LENGTH)) <br>                { <br>                    if (LoadString(ghinst, IDS_ABOUT_TEXT, szText, ABOUT_STRING_LENGTH)) <br>                    { <br>                        MessageBox( <br>                            hwndDlg, <br>                            szText, <br>                            szTitle, <br>                            MB_OK | MB_ICONINFORMATION); <br>                    } <br>                } <br>            } <br>            return(TRUE); <br>        case IDCANCEL: <br>            EndDialog(hwndDlg, FALSE); <br>            return(TRUE); <br>        default: <br>            return(FALSE); <br>        } <br>    } <br>    return(FALSE); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
