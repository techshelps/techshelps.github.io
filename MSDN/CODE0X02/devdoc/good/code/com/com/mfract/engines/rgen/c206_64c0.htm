<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RGEN.CXX</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context210"></a>RGEN.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       RGen.cxx <br>// <br>//  Contents:   implementation for the Recursive Generator Fractal engine <br>// <br>//  Classes:    CRGenCF <br>// <br>//  Functions:  DllEntryPoint <br>//              DllGetClassObject <br>//              DllCanUnloadNow <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include "RGen.h" <br>#include &lt;rgencid.h&gt; <br> <br>ULONG gcRef, gcLock; <br>HINSTANCE ghinst; <br> <br>extern "C" <br>{ <br>    BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DllEntryPoint <br>// <br>//  Synopsis:   the DLL's entry point <br>// <br>//  Arguments:  [hinst]      - instance handle for the dll <br>//              [fdwReason]  - reason for calling the entry point <br>//              [lpReserved] - reserved <br>// <br>//  Returns:    TRUE if DLL_PROCESS_ATTACH initialization succeeds <br>//              FALSE otherwise <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL WINAPI DllMain( <br>    HINSTANCE hinst, <br>    DWORD fdwReason, <br>    LPVOID lpReserved) <br>{ <br>    switch (fdwReason) <br>    { <br>    case DLL_PROCESS_ATTACH: <br>        ghinst = hinst; <br>        gcRef = gcLock = 0; <br>        WNDCLASS wc; <br>        wc.style = 0; <br>        wc.lpfnWndProc = &amp;WindowProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 0; <br>        wc.hInstance = hinst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = (HCURSOR) LoadCursor(hinst, MAKEINTRESOURCE(IDC_CHOOSE)); <br>        wc.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH); <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = TEXT("RGen Generator"); <br>        return(0 != RegisterClass(&amp;wc)); <br>    case DLL_THREAD_ATTACH: <br>        break; <br>    case DLL_THREAD_DETACH: <br>        break; <br>    case DLL_PROCESS_DETACH: <br>        break; <br>    } <br>    return(FALSE);  // initialization failed (ignored if not DLL_PROCESS_ATTACH) <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DllGetClassObject <br>// <br>//  Synopsis:   function called by OLE to get a class object <br>// <br>//  Arguments:  [rclsid] - the class id of the desired class object <br>//              [riid]   - the id of the desired interface <br>//              [ppv]    - pointer to recieve the interface <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT PASCAL DllGetClassObject( <br>    REFCLSID rclsid, <br>    REFIID riid, <br>    LPVOID * ppv) <br>{ <br>    if (!IsEqualGUID(rclsid, CLSID_RGEN)) <br>    { <br>        return(E_FAIL); <br>    } <br>    if ((!IsEqualGUID(riid, IID_IUnknown)) &amp;&amp; <br>        (!IsEqualGUID(riid, IID_IClassFactory))) <br>    { <br>        return(E_NOINTERFACE); <br>    } <br>    *ppv = (LPVOID) new CRGenCF(); <br>    if (NULL == *ppv) <br>    { <br>        return(E_OUTOFMEMORY); <br>    } <br>    ((IUnknown*)*ppv)-&gt;AddRef(); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   DllCanUnloadNow <br>// <br>//  Synopsis:   determines if there are no outstanding references on this DLL <br>// <br>//  Returns:    S_OK if the DLL can be unloaded <br>//              S_FALSE if not <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDAPI DllCanUnloadNow(void) <br>{ <br>    // return S_OK if there are no references on myself <br>    if (0 == gcRef &amp;&amp; 0 == gcLock) <br>    { <br>        return(S_OK); <br>    } <br>    return(S_FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::CRGenCF <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CRGenCF::CRGenCF() <br>{ <br>    _cRef = 0; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::~CRGenCF <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CRGenCF::~CRGenCF() <br>{ <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::QueryInterface <br>// <br>//  Synopsis:   Standard OLE interface <br>// <br>//  Arguments:  [riid] - id of the desired interface <br>//              [ppv]  - pointer to receive the interface <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGenCF::QueryInterface(REFIID riid, LPVOID * ppv) <br>{ <br>    *ppv = NULL; <br>    if ((!IsEqualGUID(riid, IID_IUnknown)) &amp;&amp; <br>        (!IsEqualGUID(riid, IID_IClassFactory))) <br>    { <br>        return(E_NOINTERFACE); <br>    } <br>    *ppv = (IClassFactory *) this; <br>    AddRef(); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::AddRef <br>// <br>//  Synopsis:   increment reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CRGenCF::AddRef(void) <br>{ <br>    return(++_cRef); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::Release <br>// <br>//  Synopsis:   decrement reference count <br>// <br>//  Returns:    new reference count <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>ULONG STDMETHODCALLTYPE CRGenCF::Release(void) <br>{ <br>    ULONG cRef = --_cRef; <br>    if (0 == cRef) <br>    { <br>        delete(this); <br>    } <br>    return(cRef); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::CreateInstance <br>// <br>//  Synopsis:   creates an instance of a RGen Engine <br>// <br>//  Arguments:  [pUnkOuter] - controlling unknown (must be NULL) <br>//              [riid]      - id of desired interface <br>//              [ppv]       - pointer to receive the interface <br>// <br>//  Returns:    S_OK - success <br>//              CLASS_E_NOAGGREATION - the caller tried to aggregate <br>//              CLASS_E_CLASSNOTAVAILABLE - couldn't initialize the class <br>//              E_OUTOFMEMORY - not enough memory to instantiate class <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGenCF::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv) <br>{ <br>    HRESULT hr = S_OK; <br>    *ppv = NULL; <br>    if (pUnkOuter != NULL) <br>    { <br>        return(CLASS_E_NOAGGREGATION); <br>    } <br> <br>    CRGen * pObj = new CRGen; <br>    if (NULL == pObj) <br>    { <br>        return(E_OUTOFMEMORY); <br>    } <br> <br>    if (!pObj-&gt;Initialize()) <br>    { <br>        delete ppv; <br>        return(CLASS_E_CLASSNOTAVAILABLE); <br>    } <br> <br>    hr = pObj-&gt;QueryInterface(riid, ppv); <br>    if (FAILED(hr)) <br>    { <br>        delete ppv; <br>    } <br>    else <br>    { <br>        gcRef++; <br>    } <br> <br>    return(hr); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CRGenCF::LockServer <br>// <br>//  Synopsis:   locks the server, preventing it from being unloaded <br>// <br>//  Arguments:  [fLock] - TRUE to lock, FALSE to unlock <br>// <br>//  Returns:    S_OK <br>// <br>//  Modifies:   gcLock <br>// <br>//  History:    4-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HRESULT STDMETHODCALLTYPE CRGenCF::LockServer(BOOL fLock) <br>{ <br>    if (fLock) <br>    { <br>        gcLock++; <br>    } <br>    else <br>    { <br>        gcLock--; <br>    } <br>    return(S_OK); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
