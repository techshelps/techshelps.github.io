<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FCLASS.CXX</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context188"></a>FCLASS.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       fclass.cxx <br>// <br>//  Contents:   implementation for CFractalWindow <br>// <br>//  Classes:    CFractalWindow <br>// <br>//  Functions: <br>// <br>//  History:    4-11-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include "fractal.h" <br>#include "fclass.h" <br>#include "about.h" <br>#include "chngdim.h" <br>#include "dib.h" <br> <br>#define START_IN_QUICKDRAWMODE <br> <br>#define WM_REFRESHCOLORS    WM_USER <br> <br>#define SCROLL_STEP 10 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::DrawRect <br>// <br>//  Synopsis:   Draws the zoom rectangle <br>// <br>//  Arguments:  [hdc]  - handle to the display context that contains the graph <br>//              [lprc] - rectangle containing the zoom rect's dimensions <br>// <br>//  Returns:    TRUE on success <br>// <br>//  History:    5-02-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CFractalWindow::DrawRect(HDC hdc, const RECT * lprc) <br>{ <br>   HPALETTE hOldPal =  SelectPalette(hdc, _hpal, FALSE); <br>   RealizePalette(hdc); <br>   HBRUSH hbr = CreateSolidBrush(WHITENESS); <br>   BOOL fReturn = FrameRect(hdc, lprc, hbr); <br>   DeleteObject(hbr); <br>   SelectPalette(hdc, hOldPal, TRUE); <br>   RealizePalette(hdc); <br>   return(fReturn); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::EraseRect <br>// <br>//  Synopsis:   Erases the zoom rectangle <br>// <br>//  Arguments:  [hdc]  - handle to a display context <br>//              [lprc] - rectangle containing the dimensions of the zoom rect <br>// <br>//  Returns:    TRUE on success <br>// <br>//  History:    5-02-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CFractalWindow::EraseRect(HDC hdc, const RECT * lprc) <br>{ <br>   HPALETTE hOldPal =  SelectPalette(hdc, _hpal, FALSE); <br>   RealizePalette(hdc); <br>   BOOL fReturn; <br>   fReturn = BitBlt(hdc, <br>      lprc-&gt;left, <br>      lprc-&gt;top, <br>      lprc-&gt;right - lprc-&gt;left, <br>      1, <br>      _hdcMem, <br>      lprc-&gt;left + _uScrollPosX, <br>      lprc-&gt;top + _uScrollPosY, <br>      SRCCOPY); <br>   fReturn &amp;= BitBlt(hdc, <br>      lprc-&gt;left, <br>      lprc-&gt;top, <br>      1, <br>      lprc-&gt;bottom - lprc-&gt;top, <br>      _hdcMem, <br>      lprc-&gt;left + _uScrollPosX, <br>      lprc-&gt;top + _uScrollPosY, <br>      SRCCOPY); <br>   fReturn &amp;= BitBlt(hdc, <br>      lprc-&gt;right - 1, <br>      lprc-&gt;top, <br>      1, <br>      lprc-&gt;bottom - lprc-&gt;top, <br>      _hdcMem, <br>      (lprc-&gt;right - 1) + _uScrollPosX, <br>      lprc-&gt;top + _uScrollPosY, <br>      SRCCOPY); <br>   fReturn &amp;= BitBlt(hdc, <br>      lprc-&gt;left, <br>      lprc-&gt;bottom - 1, <br>      lprc-&gt;right - lprc-&gt;left, <br>      1, <br>      _hdcMem, <br>      lprc-&gt;left + _uScrollPosX, <br>      (lprc-&gt;bottom - 1) + _uScrollPosY, <br>      SRCCOPY); <br>   SelectPalette(hdc, hOldPal, TRUE); <br>   RealizePalette(hdc); <br>   return(fReturn); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::GetHwnd <br>// <br>//  Synopsis:   simple method to retrieve the HWND of the window <br>// <br>//  Returns:    the window handle to the window <br>// <br>//  History:    4-26-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>HWND CFractalWindow::GetHwnd(void) <br>{ <br>    return(_hwnd); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::InitInstance <br>// <br>//  Synopsis:   initializes an instance of a window object belonging to the <br>//              CFractalWindow class <br>// <br>//  Arguments:  [hInstance] - instance handle <br>//              [nCmdShow]  - show command <br>// <br>//  History:    4-11-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CFractalWindow::InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    HWND hwnd = Create( <br>        TEXT("CFractalWindow"), <br>        TEXT(APP_TITLE), <br>        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX <br>            | WS_MAXIMIZEBOX | WS_THICKFRAME | WS_VSCROLL | WS_HSCROLL, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance); <br>    if (!hwnd) <br>    { <br>        return(FALSE); <br>    } <br> <br>    if (!SetTimer(hwnd, REFRESH_TIMER, _uRefreshRate, NULL)) <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_TOOMANYTIMERS, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>        return(FALSE); <br>    } <br> <br> <br>    _hGraphStartedEvent = CreateEvent(NULL, TRUE, FALSE, NULL); <br>    if (!_hGraphStartedEvent) <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_GRAPHICSEVENTFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>        return(FALSE); <br>    } <br> <br>    _hTitleEvent = CreateEvent(NULL, TRUE, TRUE, NULL); <br>    if (!_hTitleEvent) <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_TITLEEVENTFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>        return(FALSE); <br>    } <br> <br>    // build a path to where the help file should be <br>    // (it should be in the same directory as the .EXE) <br>    // first get the exe's path <br>    DWORD cch = GetModuleFileName(hInstance, _szHelpFile, MAX_PATH); <br>    // then back up past the name of the application <br>    while (cch &gt; 0 &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT('\\') &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT('/') &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT(':')) <br>    { <br>        cch--; <br>    } <br>    // finally copy the help file's name at the end of the path <br>    lstrcpy(&amp;_szHelpFile[cch], TEXT(HELPFILE_STR)); <br> <br>    ShowWindow(hwnd, nCmdShow); <br>    UpdateWindow(hwnd); <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::NewWindowSize <br>// <br>//  Synopsis:   updates the scroll bars every time the window's size changes <br>// <br>//  Arguments:  [uWidth]  - window width <br>//              [uHeight] - window height <br>// <br>//  Modifies:   _uWindowWidth, _uWindowHeight <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::NewWindowSize(unsigned uWidth, unsigned uHeight) <br>{ <br>    BOOL fRedraw = FALSE; <br>    _uWindowWidth = uWidth; <br>    _uWindowHeight = uHeight; <br>    unsigned uVRange = (uHeight &gt; _uImageHeight ? 0 : _uImageHeight-uHeight); <br>    unsigned uHRange = (uWidth &gt; _uImageWidth ? 0 : _uImageWidth-uWidth); <br>    SetScrollRange(_hwnd, SB_HORZ, 0, uHRange, FALSE); <br>    SetScrollRange(_hwnd, SB_VERT, 0, uVRange, FALSE); <br>    if (_uScrollPosX &gt; uHRange) <br>    { <br>        fRedraw = TRUE; <br>        _uScrollPosX = uHRange; <br>    } <br>    if (_uScrollPosY &gt; uVRange) <br>    { <br>        fRedraw = TRUE; <br>        _uScrollPosY = uVRange; <br>    } <br>    if (fRedraw) <br>    { <br>        InvalidateRect(_hwnd, NULL, FALSE); <br>    } <br>    SetScrollPos(_hwnd, SB_HORZ, _uScrollPosX, TRUE); <br>    SetScrollPos(_hwnd, SB_VERT, _uScrollPosY, TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::OnCreate <br>// <br>//  Synopsis:   called when the window is first created (on WM_CREATE) <br>//              to initialize all relevent member variables <br>// <br>//  Modifies:   _hdcMem, _uScreenWidth, _uScreenHeight, etc. <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//  Notes:      Calls SetGraphSize to initialize the graph. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::OnCreate(void) <br>{ <br>    HDC hdc = GetDC(_hwnd); <br>    _hdcMem = CreateCompatibleDC(hdc); <br>    _uScreenWidth = GetDeviceCaps(hdc, HORZRES); <br>    _uScreenHeight = GetDeviceCaps(hdc, VERTRES); <br> <br>    // If we don't have an animating palette with 256 colors and <br>    // exactly 20 static colors then we're going to disable our <br>    // animate palette features. <br> <br>    _fCanAnimate = (GetDeviceCaps(hdc, RASTERCAPS) &amp; RC_PALETTE) != 0 <br>        &amp;&amp; GetDeviceCaps(hdc, SIZEPALETTE) == 256 <br>        &amp;&amp; GetDeviceCaps(hdc, NUMRESERVED) == 20; <br> <br>    ReleaseDC(_hwnd, hdc); <br>    SetUpColorTable(); <br>#ifdef START_IN_QUICKDRAWMODE <br>    SetGraphSize(QUICKWIDTH, QUICKHEIGHT); <br>#else <br>    SetGraphSize(_uScreenWidth, _uScreenHeight); <br>#endif <br>    SetDefaultColors(); <br>    // Fill in the Palette's open file name structure <br>    _szPalFileName[0] = 0; <br>    _szPalFileTitle[0] = 0; <br>    _ofnPalette.lStructSize = sizeof(OPENFILENAME); <br>    _ofnPalette.hwndOwner = _hwnd; <br>    _ofnPalette.lpstrFilter = TEXT("Palette Files (*.PAL)\0*.PAL\0All Files (*.*)\0\\*.*\0"); <br>    _ofnPalette.lpstrCustomFilter = NULL; <br>    _ofnPalette.nMaxCustFilter = 0; <br>    _ofnPalette.nFilterIndex = 1; <br>    _ofnPalette.lpstrFile = _szPalFileName; <br>    _ofnPalette.nMaxFile = MAX_PATH; <br>    _ofnPalette.lpstrInitialDir = NULL; <br>    _ofnPalette.lpstrFileTitle = _szPalFileTitle; <br>    _ofnPalette.nMaxFileTitle = MAX_PATH; <br>    _ofnPalette.lpstrTitle = NULL; <br>    _ofnPalette.lpstrDefExt = TEXT("PAL"); <br>    _ofnPalette.Flags = OFN_HIDEREADONLY; <br> <br>    // Fill in the BMP's open file name structure <br>    _szBmpFileName[0] = 0; <br>    _szBmpFileTitle[0] = 0; <br>    _ofnBitmap.lStructSize = sizeof(OPENFILENAME); <br>    _ofnBitmap.hwndOwner = _hwnd; <br>    _ofnBitmap.lpstrFilter = TEXT("Bitmaps (*.BMP)\0*.BMP\0All Files (*.*)\0\\*.*\0"); <br>    _ofnBitmap.lpstrCustomFilter = NULL; <br>    _ofnBitmap.nMaxCustFilter = 0; <br>    _ofnBitmap.nFilterIndex = 1; <br>    _ofnBitmap.lpstrFile = _szBmpFileName; <br>    _ofnBitmap.nMaxFile = MAX_PATH; <br>    _ofnBitmap.lpstrInitialDir = NULL; <br>    _ofnBitmap.lpstrFileTitle = _szBmpFileTitle; <br>    _ofnBitmap.nMaxFileTitle = MAX_PATH; <br>    _ofnBitmap.lpstrTitle = NULL; <br>    _ofnBitmap.lpstrDefExt = TEXT("BMP"); <br>    _ofnBitmap.Flags = OFN_HIDEREADONLY; <br> <br>    // Fill in the File's open file name structure <br>    _szFileName[0] = 0; <br>    _szFileTitle[0] = 0; <br>    _ofnFile.lStructSize = sizeof(OPENFILENAME); <br>    _ofnFile.hwndOwner = _hwnd; <br>    _ofnFile.lpstrFilter = TEXT("Fractal Files (*.MFR)\0*.MFR\0All Files (*.*)\0\\*.*\0"); <br>    _ofnFile.lpstrCustomFilter = NULL; <br>    _ofnFile.nMaxCustFilter = 0; <br>    _ofnFile.nFilterIndex = 1; <br>    _ofnFile.lpstrFile = _szFileName; <br>    _ofnFile.nMaxFile = MAX_PATH; <br>    _ofnFile.lpstrInitialDir = NULL; <br>    _ofnFile.lpstrFileTitle = _szFileTitle; <br>    _ofnFile.nMaxFileTitle = MAX_PATH; <br>    _ofnFile.lpstrTitle = NULL; <br>    _ofnFile.lpstrDefExt = TEXT("MFR"); <br>    _ofnFile.Flags = OFN_HIDEREADONLY; <br>} <br> <br>#include &lt;stdio.h&gt; <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::ChangeFractalEngines <br>// <br>//  Synopsis:   releases the old fractal engine and binds to the new one <br>// <br>//  History:    4-15-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::ChangeFractalEngines(void) <br>{ <br>    if(_pFractalEngine) <br>    { <br>        _pFractalEngine-&gt;Release(); <br>    } <br>    HRESULT hr = CoCreateInstance( <br>        _pEngineList-&gt;GetEntry(_uFractalType), <br>        NULL, <br>        CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER, <br>        IID_IFractalEngine, <br>        (void **)&amp;_pFractalEngine); <br>    if (SUCCEEDED(hr)) <br>    { <br>        hr = _pFractalEngine-&gt;Init((IFractalHost *)this); <br>    } <br>    else <br>    { <br>        _pFractalEngine = NULL; <br>    } <br>    if (SUCCEEDED(hr)) <br>    { <br>        hr = _pFractalEngine-&gt;SetGraphSize(_uImageWidth, _uImageHeight); <br>    } <br>    if (SUCCEEDED(hr)) <br>    { <br>        hr = _pFractalEngine-&gt;SetDefaults(); <br>    } <br>    if (SUCCEEDED(hr)) <br>    { <br>        hr = _pFractalEngine-&gt;GetExtent(&amp;_dLeft, &amp;_dTop, &amp;_dRight, &amp;_dBottom); <br>    } <br>    Rect(0, 0, (int)_uImageWidth - 1, (int)_uImageHeight - 1, 0); <br>    if (FAILED(hr)) <br>    { <br>        if (_pFractalEngine) <br>        { <br>            _pFractalEngine-&gt;Release(); <br>        } <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_NOFRACTALENGINE, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    _hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>        _pFractalEngine = NULL; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::WindowProc <br>// <br>//  Synopsis:   main message proc for CFractalWindow <br>// <br>//  Arguments:  [uMsg]   - message <br>//              [wParam] - first message parameter <br>//              [lParam] - second message parameter <br>// <br>//  History:    4-11-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CFractalWindow::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    if (_fZooming) <br>    { <br>        switch (uMsg) <br>        { <br>        // this first set of messages fall through to the normal message <br>        // handler during a zoom <br>        case WM_PALETTECHANGED: <br>        case WM_QUERYNEWPALETTE: <br>        case WM_PAINT: <br>            break; <br> <br>        // The next set of messages are handled differently during a zoom <br> <br>        case WM_LBUTTONDBLCLK: <br>            // zoom in <br>            { <br>                HDC hdc = GetDC(_hwnd); <br>                EraseRect(hdc, &amp;_rectZoom); <br>                ReleaseDC(_hwnd, hdc); <br>                OffsetRect(&amp;_rectZoom, _uScrollPosX, _uScrollPosY); <br>                double dScaler = (_dRight - _dLeft) / (double)_uImageWidth; <br>                double dLeft = _dLeft <br>                    + (double)_rectZoom.left * dScaler; <br>                double dRight = _dLeft <br>                    + (double)_rectZoom.right * dScaler; <br>                double dBottom = _dBottom <br>                    + (double)(_uImageHeight - _rectZoom.bottom) * dScaler; <br>                double dTop = dBottom + <br>                     (_dTop - _dBottom) * (dRight - dLeft) / (_dRight - _dLeft); <br> <br>                if (_pFractalEngine) <br>                { <br>                    _pFractalEngine-&gt;SetExtent(dLeft, dTop, dRight, dBottom); <br>                } <br>            } <br>            ReleaseCapture(); <br>            ShowCursor(TRUE); <br>            _fZooming = FALSE; <br>            return 0; <br>        case WM_RBUTTONDBLCLK: <br>            // zoom out <br>            { <br>                HDC hdc = GetDC(_hwnd); <br>                EraseRect(hdc, &amp;_rectZoom); <br>                ReleaseDC(_hwnd, hdc); <br>                OffsetRect(&amp;_rectZoom, _uScrollPosX, _uScrollPosY); <br>                double dScaler = (_dRight - _dLeft) / <br>                    (double)(_rectZoom.right - _rectZoom.left); <br>                double dLeft = _dLeft <br>                    - (double)_rectZoom.left * dScaler; <br>                double dRight = _dRight + <br>                    (double)(_uImageWidth - _rectZoom.right) * dScaler; <br>                double dBottom = _dBottom - <br>                    (double)(_uImageHeight - _rectZoom.bottom) * dScaler; <br>                double dTop = _dTop + <br>                    (double)_rectZoom.top * dScaler; <br>                if (_pFractalEngine) <br>                { <br>                    _pFractalEngine-&gt;SetExtent(dLeft, dTop, dRight, dBottom); <br>                } <br>            } <br>            ReleaseCapture(); <br>            ShowCursor(TRUE); <br>            _fZooming = FALSE; <br>            return 0; <br>        case WM_MOUSEMOVE: <br>            { <br>                HDC hdc = GetDC(_hwnd); <br>                EraseRect(hdc, &amp;_rectZoom); <br>                POINT p; <br>                p.x = LOWORD(lParam); <br>                p.y = HIWORD(lParam); <br>                if (p.x &gt; (int) _uImageWidth) <br>                { <br>                    p.x = _uImageWidth; <br>                } <br>                else if (p.x &lt; 0) <br>                { <br>                    p.x = 0; <br>                } <br>                if (p.y &gt; (int) _uImageHeight) <br>                { <br>                    p.y = _uImageHeight; <br>                } <br>                else if (p.y &lt; 0) <br>                { <br>                    p.y = 0; <br>                } <br>                if (MK_RBUTTON == wParam || MK_LBUTTON == wParam) <br>                { <br>                    // change size of the zoom window <br>                    int dx, dy; <br>                    BOOL fChangeX; <br>                    fChangeX = abs(p.y - _rectZoom.bottom) &gt; <br>                        abs(p.x - _rectZoom.right); <br>                    _rectZoom.bottom = p.y; <br>                    _rectZoom.right = p.x; <br>                    if (_rectZoom.right &lt;= _rectZoom.left) <br>                    { <br>                        _rectZoom.right = _rectZoom.left + 1; <br>                    } <br>                    if (_rectZoom.bottom &lt;= _rectZoom.top) <br>                    { <br>                        _rectZoom.bottom = _rectZoom.top + 1; <br>                    } <br>                    dx = _rectZoom.right - _rectZoom.left; <br>                    dy = _rectZoom.bottom - _rectZoom.top; <br>                    if (dx &lt; 4) <br>                    { <br>                        dx = 4; <br>                        _rectZoom.right = _rectZoom.left + 4; <br>                    } <br>                    if (dy &lt; 4) <br>                    { <br>                        dy = 4; <br>                        _rectZoom.bottom = _rectZoom.top + 4; <br>                    } <br>                    // normalize the zoom window <br>                    if (fChangeX) <br>                    { <br>                        _rectZoom.right = _rectZoom.left + <br>                            MulDiv(dy, _uImageWidth, _uImageHeight); <br>                    } <br>                    else <br>                    { <br>                        _rectZoom.bottom = _rectZoom.top + <br>                            MulDiv(dx, _uImageHeight, _uImageWidth); <br>                    } <br>                    p.x = _rectZoom.right; <br>                    p.y = _rectZoom.bottom; <br>                    ClientToScreen(_hwnd, &amp;p); <br>                    SetCursorPos(p.x, p.y); <br>                } <br>                else <br>                { <br>                    // move the zoom window <br>                    OffsetRect( <br>                        &amp;_rectZoom, <br>                        p.x - _rectZoom.right, <br>                        p.y - _rectZoom.bottom); <br>                    OffsetRect( <br>                        &amp;_rectZoom, <br>                        _rectZoom.left &lt; 0 ? 0 - _rectZoom.left : 0, <br>                        _rectZoom.top &lt; 0 ? 0 - _rectZoom.top : 0); <br>                    OffsetRect( <br>                        &amp;_rectZoom, <br>                        _rectZoom.right &gt; (int) _uImageWidth ? _uImageWidth - _rectZoom.right : 0, <br>                        _rectZoom.bottom &gt; (int) _uImageHeight ? _uImageHeight - _rectZoom.bottom : 0); <br>                } <br>                DrawRect(hdc, &amp;_rectZoom); <br>                ReleaseDC(_hwnd, hdc); <br>                return 0; <br>            } <br>            // change zoom rectangle <br>            break; <br>        case WM_KEYUP: <br>            if (wParam == VK_ESCAPE) <br>            { <br>                // abort the zoom window <br>                HDC hdc = GetDC(_hwnd); <br>                EraseRect(hdc, &amp;_rectZoom); <br>                ReleaseDC(_hwnd, hdc); <br>                ReleaseCapture(); <br>                ShowCursor(TRUE); <br>                _fZooming = FALSE; <br>            } <br>            else <br>                return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>            return 0; <br> <br>        // All other messages are swallowed up and sent <br>        // to the DefWindowProc during a zoom. <br>        default: <br>            return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>        } <br>    } <br>    switch (uMsg) <br>    { <br>    case WM_CREATE: <br>        OnCreate(); <br>        break; <br>    case WM_SHOWWINDOW: <br>        if (!_pEngineList) <br>        { <br>            // this is the first time the window is being shown <br> <br>            HMENU hmenu = GetMenu(_hwnd); <br>            if (!_fCanAnimate) <br>            { <br>                EnableMenuItem( <br>                    hmenu, <br>                    IDM_CYCLEIN, <br>                    MF_BYCOMMAND | MF_GRAYED); <br>                EnableMenuItem( <br>                    hmenu, <br>                    IDM_CYCLEOUT, <br>                    MF_BYCOMMAND | MF_GRAYED); <br>                EnableMenuItem( <br>                    hmenu, <br>                    IDM_CYCLESTOP, <br>                    MF_BYCOMMAND | MF_GRAYED); <br>            } <br> <br>            _pEngineList = new CEngineList(hmenu); <br>            if (_pEngineList) <br>            { <br>                if SUCCEEDED(_pEngineList-&gt;Read()) <br>                { <br>                    _uFractalType = 0; <br>                    ChangeFractalEngines(); <br>                    if (_pFractalEngine) <br>                    { <br>                        SetDefaultColors(); <br>                        if (SUCCEEDED(_pFractalEngine-&gt;Start())) <br>                        { <br>                            OnStart(); <br>                        } <br>                        else <br>                        { <br>                            OnStop(); <br>                        } <br>                    } <br>                } <br>                else <br>                { <br>                    // couldn't prime the engine list <br>                    TCHAR szTitle[MAX_STRING_LENGTH]; <br>                    TCHAR szText[MAX_STRING_LENGTH]; <br>                    if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>                    { <br>                        if (LoadString(_hInstance, IDS_REGISTRYERROR, szText, MAX_STRING_LENGTH)) <br>                        { <br>                            MessageBox( <br>                                _hwnd, <br>                                szText, <br>                                szTitle, <br>                                MB_OK | MB_ICONEXCLAMATION); <br>                        } <br>                    } <br>                    SendMessage(_hwnd, WM_CLOSE, 0, 0); <br>                } <br>            } <br>        } <br>        PostMessage(_hwnd, WM_REFRESHCOLORS, 0, 0); <br>        break; <br>    case WM_REFRESHCOLORS: <br>        { <br>            PALETTEENTRY rgColors[PALETTESIZE]; <br>            memcpy(rgColors, _pEntry1, sizeof(PALETTEENTRY) * PALETTESIZE); <br>            Wash(PALETTESIZE, rgColors); <br>        } <br>        break; <br>    case WM_SIZE: <br>        NewWindowSize(LOWORD(lParam), HIWORD(lParam)); <br>        break; <br>    case WM_HSCROLL: <br>        switch (LOWORD(wParam)) <br>        { <br>        case SB_PAGEUP: <br>            _uScrollPosX = (_uScrollPosX &gt; _uWindowWidth ? <br>                _uScrollPosX - _uWindowWidth : <br>                0); <br>            break; <br>        case SB_PAGEDOWN: <br>            _uScrollPosX = (_uScrollPosX + _uWindowWidth * 2 &lt; _uImageWidth ? <br>                _uScrollPosX + _uWindowWidth : <br>                _uImageWidth - _uWindowWidth); <br>            break; <br>        case SB_LINEUP: <br>            _uScrollPosX = (_uScrollPosX &gt; SCROLL_STEP ? <br>                _uScrollPosX - SCROLL_STEP : <br>                0); <br>            break; <br>        case SB_LINEDOWN: <br>            _uScrollPosX = (_uScrollPosX + _uWindowWidth + SCROLL_STEP &lt; _uImageWidth ? <br>                _uScrollPosX + SCROLL_STEP : <br>                _uImageWidth - _uWindowWidth); <br>            break; <br>        case SB_THUMBTRACK: <br>            _uScrollPosX = HIWORD(wParam); <br>            break; <br>        } <br>        SetScrollPos(_hwnd, SB_HORZ, _uScrollPosX, TRUE); <br>        InvalidateRect(_hwnd, NULL, FALSE); <br>        break; <br>    case WM_VSCROLL: <br>        switch (LOWORD(wParam)) <br>        { <br>        case SB_PAGEUP: <br>            _uScrollPosY = (_uScrollPosY &gt; _uWindowHeight ? <br>                _uScrollPosY - _uWindowHeight : <br>                0); <br>            break; <br>        case SB_PAGEDOWN: <br>            _uScrollPosY = (_uScrollPosY + _uWindowHeight * 2 &lt; _uImageHeight ? <br>                _uScrollPosY + _uWindowHeight : <br>                _uImageHeight - _uWindowHeight); <br>            break; <br>        case SB_LINEUP: <br>            _uScrollPosY = (_uScrollPosY &gt; SCROLL_STEP ? <br>                _uScrollPosY - SCROLL_STEP : <br>                0); <br>            break; <br>        case SB_LINEDOWN: <br>            _uScrollPosY = (_uScrollPosY + _uWindowHeight + SCROLL_STEP &lt; _uImageHeight ? <br>                _uScrollPosY + SCROLL_STEP : <br>                _uImageHeight - _uWindowHeight); <br>            break; <br>        case SB_THUMBTRACK: <br>            _uScrollPosY = HIWORD(wParam); <br>            break; <br>        } <br>        SetScrollPos(_hwnd, SB_VERT, _uScrollPosY, TRUE); <br>        InvalidateRect(_hwnd, NULL, FALSE); <br>        break; <br>    case WM_PAINT: <br>        { <br>            PAINTSTRUCT ps; <br>            RECT rc; <br>              EnterCriticalSection(&amp;_csGraph); <br>            HDC hdc = BeginPaint(_hwnd, &amp;ps); <br>            HPALETTE hOldPal =  SelectPalette(hdc, _hpal, FALSE); <br>            RealizePalette(hdc); <br>            if (GetClipBox(ps.hdc, &amp;rc) != NULLREGION) <br>            { <br>                BitBlt(ps.hdc, <br>                    rc.left, <br>                    rc.top, <br>                    rc.right - rc.left, <br>                    rc.bottom - rc.top, <br>                    _hdcMem, <br>                    rc.left + _uScrollPosX, <br>                    rc.top + _uScrollPosY, <br>                    SRCCOPY); <br>            } <br>            SelectPalette(hdc, hOldPal, TRUE); <br>            RealizePalette(hdc); <br>            EndPaint(_hwnd, &amp;ps); <br>            LeaveCriticalSection(&amp;_csGraph); <br>            break; <br>        } <br>    case WM_PALETTECHANGED: <br>        if ((HWND)wParam == _hwnd) <br>        { <br>            break; <br>        } <br>    case WM_QUERYNEWPALETTE: <br>        { <br>            if (_fReRealizePalette &amp;&amp; GetFocus() == _hwnd) <br>            { <br>                // The first time we realized this <br>                // palette, it wasn't in the forground.  This <br>                // means that we must realize it again to ensure <br>                // that we get the entire palette to ourselves. <br> <br>                UnrealizeObject(_hpal); <br>                _fReRealizePalette = FALSE; <br>            } <br>            HDC hdc = GetDC(_hwnd); <br>            HPALETTE hOldPal = SelectPalette(hdc, _hpal, FALSE); <br>            int iTemp = RealizePalette(hdc); <br> <br>            // this next step is really unnecessary since <br>            SelectPalette(hdc, hOldPal, TRUE); <br>            RealizePalette(hdc); <br>            ReleaseDC(_hwnd, hdc); <br>            if (iTemp) <br>            { <br>                InvalidateRect(_hwnd, NULL, TRUE); <br>            } <br>            return(iTemp); <br>        } <br> <br>    // When the title is not shown and mouse is clicked in client area, <br>    // we fool the system into thinking that the mouse has been clicked <br>    // on the caption (see WM_NCHITTEST message handling).  But this means <br>    // that the system thinks that a left button double click in the client <br>    // area when the title is not displayed is a non-client double click. <br>    // Therefore when the title is not displayed, we get WM_NCLBUTTONDBLCLK <br>    // messages instead of WM_LBUTTONDBLCLK messages, but need to handle <br>    // them the same way. <br> <br>    case WM_NCLBUTTONDBLCLK: <br>        if (WaitForSingleObject(_hTitleEvent,0) == WAIT_OBJECT_0) <br>        { <br>            break; <br>        } <br>        // else FALL THROUGH to WM_LBUTTONDBLCLK case <br>        // <br> <br>    case WM_LBUTTONDBLCLK: <br>        ToggleTitle(); <br>        return(0); <br> <br>    case WM_NCRBUTTONDOWN: <br>        if (WaitForSingleObject(_hTitleEvent,0) == WAIT_OBJECT_0) <br>        { <br>            break; <br>        } <br>    case WM_RBUTTONDOWN: <br>        _fRButtonDown = TRUE; <br>        break; <br> <br>    case WM_NCRBUTTONUP: <br>        if (WaitForSingleObject(_hTitleEvent,0) == WAIT_OBJECT_0) <br>        { <br>            break; <br>        } <br>    case WM_RBUTTONUP: <br>        if (_fRButtonDown &amp;&amp; WaitForSingleObject(_hGraphStartedEvent,0) == WAIT_TIMEOUT) <br>        { <br>            SendMessage(_hwnd, WM_COMMAND, IDM_EDIT_PROPERTIES, 0); <br>            _fRButtonDown = FALSE; <br>        } <br>        break; <br> <br>    case WM_NCHITTEST:  // stolen from clock program </code></pre>
<p>
</p>
<pre><code>wParam = DefWindowProc(_hwnd, uMsg, wParam, lParam); <br>        if (WaitForSingleObject(_hTitleEvent,0) != WAIT_OBJECT_0 &amp;&amp; (wParam == HTCLIENT) &amp;&amp; !IsZoomed(_hwnd)) <br>        { <br>            return HTCAPTION; <br>        } <br>        return wParam; <br>        case WM_TIMER: <br>        if (wParam == CYCLE_TIMER) <br>        { <br>            // Cycle the colors <br>            RGBQUAD rgb[PALETTESIZE]; <br>            for (int c = PALETTESIZE - 1; c--;) <br>            { <br>                int iTemp = c + _iCycleVelocity; <br>                while (iTemp &lt; 0) <br>                { <br>                    iTemp += PALETTESIZE - 1; <br>                } <br>                while (iTemp &gt;= PALETTESIZE - 1) <br>                { <br>                    iTemp -= PALETTESIZE - 1; <br>                } <br>                _pEntry2[c + 1] = _pEntry1[iTemp + 1]; <br>                rgb[c].rgbRed = _pEntry2[c + 1].peRed; <br>                rgb[c].rgbBlue = _pEntry2[c + 1].peBlue; <br>                rgb[c].rgbGreen = _pEntry2[c + 1].peGreen; <br>            } <br>            _pEntry2[0] = _pEntry1[0]; <br>            PALETTEENTRY * pEntryTemp = _pEntry1; <br>            _pEntry1 = _pEntry2; <br>            _pEntry2 = pEntryTemp; <br>            EnterCriticalSection(&amp;_csGraph); <br>            SetDIBColorTable(_hdcMem, 11, PALETTESIZE - 1, rgb); <br>            AnimatePalette(_hpal, 11, PALETTESIZE - 1, &amp;_pEntry1[1]); <br>            LeaveCriticalSection(&amp;_csGraph); <br>        } <br>        if (wParam == REFRESH_TIMER) <br>        { <br>            if (WaitForSingleObject(_hGraphStartedEvent, 0) == WAIT_OBJECT_0) <br>            { <br>                InvalidateRect(_hwnd, &amp;_rectPainted, FALSE); <br>                SetRectEmpty(&amp;_rectPainted); <br>            } <br>        } <br>        return(0); <br>    case WM_COMMAND: <br>        return DoMenu(wParam, lParam); <br>    case WM_QUIT: <br>    case WM_CLOSE: <br>    default: <br>        return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>    } <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::DoMenu <br>// <br>//  Synopsis:   processes menu commands <br>// <br>//  Arguments:  [wParam] - menu command <br>//              [lParam] - command parameter <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CFractalWindow::DoMenu(WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (LOWORD(wParam)) <br>    { <br>    case IDM_ABOUT: <br>        { <br>            CAbout dlgAbout; <br>            dlgAbout.ShowDialog(_hInstance, MAKEINTRESOURCE(IDM_ABOUT), _hwnd); <br>        } <br>        break; <br>    case IDM_CHANGEDIM: <br>        if (_pFractalEngine) <br>        { <br>            unsigned uSavedImageWidth = _uImageWidth; <br>            unsigned uSavedImageHeight = _uImageHeight; <br>            CChangeDim dlgChangeDim(this); <br>            if (dlgChangeDim.ShowDialog(_hInstance, MAKEINTRESOURCE(IDM_CHANGEDIM), _hwnd)) <br>            { <br>                if (SUCCEEDED(_pFractalEngine-&gt;SetGraphSize(_uImageWidth, _uImageHeight))) <br>                { <br>                    _pFractalEngine-&gt;SetDefaults(); <br>                } <br>                else <br>                { <br>                    _uImageWidth = uSavedImageWidth; <br>                    _uImageHeight = uSavedImageHeight; <br>                } <br>            } <br>            else <br>            { <br>                if (FAILED(_pFractalEngine-&gt;SetGraphSize(_uImageWidth, _uImageHeight))) <br>                { <br>                    _uImageWidth = uSavedImageWidth; <br>                    _uImageHeight = uSavedImageHeight; <br>                } <br>            } <br>        } <br>        break; <br>    case IDM_START: <br>        if (_pFractalEngine) <br>        { <br>            if (SUCCEEDED(_pFractalEngine-&gt;Start())) <br>            { <br>                _pFractalEngine-&gt;GetExtent(&amp;_dLeft, &amp;_dTop, &amp;_dRight, &amp;_dBottom); <br>                OnStart(); <br>            } <br>        } <br>        break; <br>    case IDM_STOP: <br>        if (_pFractalEngine) <br>        { <br>            if (SUCCEEDED(_pFractalEngine-&gt;Stop())) <br>            { <br>                OnStop(); <br>            } <br>        } <br>        break; <br>    case IDM_EDIT_PROPERTIES: <br>        if (_pFractalEngine) <br>        { <br>            _pFractalEngine-&gt;SetProperties(_hwnd); <br>        } <br>        break; <br>    case IDM_BRING_FORWARD: <br>        ToggleTitle(); <br>        break; <br>    case IDM_EXIT: <br>        SendMessage(_hwnd, WM_CLOSE, 0, 0); <br>        break; <br>    case IDM_ZOOM: <br>        if (WaitForSingleObject(_hGraphStartedEvent,0) == WAIT_TIMEOUT) <br>        { <br>            SetCapture(_hwnd); <br>            ShowCursor(FALSE); <br>            SetRect( <br>                &amp;_rectZoom, <br>                2 * _uImageWidth / 5, <br>                2 * _uImageHeight / 5, <br>                3 * _uImageWidth / 5, <br>                3 * _uImageHeight / 5); <br>            HDC hdc = GetDC(_hwnd); <br>            DrawRect(hdc, &amp;_rectZoom); <br>            ReleaseDC(_hwnd, hdc); <br>            _fZooming = TRUE; <br>        } <br>        break; <br>    case IDM_HELP: <br>        if (!Exists(_szHelpFile)) <br>        { <br>            TCHAR szTitle[MAX_STRING_LENGTH]; <br>            TCHAR szText[MAX_STRING_LENGTH]; <br>            if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>            { <br>                if (LoadString(_hInstance, IDS_NOHELPFILE, szText, MAX_STRING_LENGTH)) <br>                { <br>                    MessageBox( <br>                        _hwnd, <br>                        szText, <br>                        szTitle, <br>                        MB_OK | MB_ICONEXCLAMATION); <br>                } <br>            } <br>        } <br>        else <br>        { <br>            WinHelp(_hwnd, _szHelpFile, HELP_INDEX, 0); <br>        } <br>        break; <br>    case IDM_DEFAULTCOLORS: <br>        SetDefaultColors(); <br>        break; <br>    case IDM_LOADPAL: <br>        if (!GetOpenFileName((LPOPENFILENAME)&amp;_ofnPalette)) <br>        { <br>            return(FALSE); <br>        } <br>        LoadPalette(); <br>        break; <br>    case IDM_SAVEPAL: <br>        if (!GetSaveFileName((LPOPENFILENAME)&amp;_ofnPalette)) <br>        { <br>            return(FALSE); <br>        } <br>        SavePalette(); <br>        break; <br>    case IDM_SAVEBMP: <br>        if (!GetSaveFileName((LPOPENFILENAME)&amp;_ofnBitmap)) <br>        { <br>            return(FALSE); <br>        } <br>        SaveBitmap(); <br>        break; <br>    case IDM_LOAD: <br>        if (!GetOpenFileName((LPOPENFILENAME)&amp;_ofnFile)) <br>        { <br>            return(FALSE); <br>        } <br>        LoadFile(); <br>        break; <br>    case IDM_SAVE: <br>        if (!GetSaveFileName((LPOPENFILENAME)&amp;_ofnFile)) <br>        { <br>            return(FALSE); <br>        } <br>        SaveFile(); <br>        break; <br>    case IDM_CYCLEIN: <br>        if (_fCanAnimate) <br>        { <br>            Faster(-1); <br>        } <br>        break; <br>    case IDM_CYCLEOUT: <br>        if (_fCanAnimate) <br>        { <br>            Faster(1); <br>        } <br>        break; <br>    case IDM_CYCLESTOP: <br>        if (_fCanAnimate) <br>        { <br>            CycleStop(); <br>        } <br>        break; <br>    default: <br>        if (WaitForSingleObject(_hGraphStartedEvent,0) == WAIT_TIMEOUT &amp;&amp; <br>            LOWORD(wParam) &gt;= IDM_FRACTAL_TYPE &amp;&amp; <br>            LOWORD(wParam) &lt; IDM_FRACTAL_TYPE + MAX_FRACTAL_TYPES &amp;&amp; <br>            LOWORD(wParam) - IDM_FRACTAL_TYPE != (int)_uFractalType) <br>        { <br>            // changing fractal types <br>            HMENU hmenu = GetMenu(_hwnd); <br>            CheckMenuItem( <br>                hmenu, <br>                _uFractalType + IDM_FRACTAL_TYPE, <br>                MF_BYCOMMAND | MF_UNCHECKED); <br>            CheckMenuItem( <br>                hmenu, <br>                LOWORD(wParam), <br>                MF_BYCOMMAND | MF_CHECKED); <br>            _uFractalType = LOWORD(wParam) - IDM_FRACTAL_TYPE; <br>            ChangeFractalEngines(); <br>        } <br>        else <br>        { <br>            return(DefWindowProc(_hwnd, WM_COMMAND, wParam, lParam)); <br>        } <br>    } <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::CFractalWindow <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    4-11-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CFractalWindow::CFractalWindow() <br>{ <br>    _pstg = NULL; <br>    _rgPixels = NULL; <br>    _hInstance = NULL; <br>    _hwnd = NULL; <br>    _hdcMem = NULL; <br>    _uScreenWidth = 0; <br>    _uScreenHeight = 0; <br>    _uImageWidth = 0; <br>    _uImageHeight = 0; <br>    _uWindowWidth = 0; <br>    _uWindowHeight = 0; <br>    _uScrollPosX = 0; <br>    _uScrollPosY = 0; <br>    _iCycleVelocity = 0; <br>    _iCurrentDirection = 0; <br>    _uRefreshRate = 1000; <br>    _hTitleEvent = NULL; <br>    _hGraphStartedEvent = NULL; <br>    _hbmSavedBitmap = NULL; <br>    _hbmMainWindow = NULL; <br>    _hpal = NULL; <br>    _pLogPal = NULL; <br>    _pSecondLogPal = NULL; <br>    _pEntry1 = NULL; <br>    _pEntry2 = NULL; <br>    _uRefCount = 0; <br>    _pEngineList = 0; <br>    _uFractalType = 0; <br>    _pFractalEngine = NULL; <br>    _fZooming = FALSE; <br>    _fRButtonDown = FALSE; <br>    InitializeCriticalSection(&amp;_csGraph); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::~CFractalWindow <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    4-11-94   stevebl   Created <br>// <br>//  Notes:      Frees up all resources allocated by the window. <br>// <br>//---------------------------------------------------------------------------- <br> <br>CFractalWindow::~CFractalWindow() <br>{ <br>    if (_pFractalEngine) <br>    { <br>        _pFractalEngine-&gt;Stop(); <br>    } <br>    WinHelp(_hwnd, _szHelpFile, HELP_QUIT, 0); <br>    if (_pFractalEngine) <br>    { <br>        _pFractalEngine-&gt;Release(); <br>    } <br>    if (_hTitleEvent) <br>    { <br>        CloseHandle(_hTitleEvent); <br>    } <br>    if (_hGraphStartedEvent) <br>    { <br>        CloseHandle(_hGraphStartedEvent); <br>    } <br>    if (_hbmSavedBitmap) <br>    { <br>        HDC hdc = GetDC(_hwnd); <br>        HBITMAP hbm = (HBITMAP) SelectObject(hdc,_hbmSavedBitmap); <br>        ReleaseDC(_hwnd, hdc); <br>        DeleteObject(hbm); <br>    } <br>    if (_pLogPal) <br>    { <br>        LocalFree(_pLogPal); <br>    } <br>    if (_pSecondLogPal) <br>    { <br>        LocalFree(_pSecondLogPal); <br>    } <br>    if (_pEntry1) <br>    { <br>        LocalFree(_pEntry1); <br>    } <br>    if (_pEntry2) <br>    { <br>        LocalFree(_pEntry2); <br>    } <br>    if (_pEngineList) <br>    { <br>        delete _pEngineList; <br>    } <br>    DeleteCriticalSection(&amp;_csGraph); <br>    PostQuitMessage(0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::SetUpColorTable <br>// <br>//  Synopsis:   initializes the color palette <br>// <br>//  Modifies:   _pEntry1, _pEntry2, _pLogPal <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::SetUpColorTable(void) <br>{ <br>    _pLogPal = (LOGPALETTE *) LocalAlloc(LMEM_FIXED, <br>        (sizeof(LOGPALETTE)+ <br>        (sizeof(PALETTEENTRY)*(255)))); <br> <br>    _pEntry1 = (PALETTEENTRY *) LocalAlloc(LMEM_FIXED, sizeof(PALETTEENTRY)*(PALETTESIZE)); <br>    _pEntry2 = (PALETTEENTRY *) LocalAlloc(LMEM_FIXED, sizeof(PALETTEENTRY)*(PALETTESIZE)); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::SetDefaultColors <br>// <br>//  Synopsis:   sets the default colors in the color palette wich are: <br>//                  black - background <br>//                  Then red <br>//                  washing to green <br>//                  washing to blue <br>//                  and washing back to red again. <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::SetDefaultColors(void) <br>{ <br>    PALETTEENTRY rgColors[4]; <br> <br>    rgColors[0].peRed = 0; <br>    rgColors[0].peGreen = 0; <br>    rgColors[0].peBlue = 0; <br> <br>    rgColors[1].peRed = 255; <br>    rgColors[1].peGreen = 0; <br>    rgColors[1].peBlue = 0; <br> <br>    rgColors[2].peRed = 0; <br>    rgColors[2].peGreen = 255; <br>    rgColors[2].peBlue = 0; <br> <br>    rgColors[3].peRed = 0; <br>    rgColors[3].peGreen = 0; <br>    rgColors[3].peBlue = 255; <br> <br>    Wash(4,rgColors); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Faster <br>// <br>//  Synopsis:   increses or decreses the palette's cycle velocity <br>// <br>//  Arguments:  [iDirection] - direction to cycle the palette <br>//                             -1 is in, 1 is out <br>// <br>//  History:    4-20-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::Faster(int iDirection) <br>{ <br>    if (_iCycleVelocity == 0) <br>    { <br>        SetTimer(_hwnd, CYCLE_TIMER, CYCLE_RATE, NULL); <br>        _iCurrentDirection = _iCycleVelocity = iDirection; <br>    } <br>    else if (_iCycleVelocity == -iDirection) <br>    { <br>        CycleStop(); <br>    } <br>    else if (iDirection == _iCurrentDirection) <br>    { <br>        _iCycleVelocity *= 2; <br>    } <br>    else <br>    { <br>        _iCycleVelocity /= 2; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::CycleStop <br>// <br>//  Synopsis:   stops color cycling <br>// <br>//  History:    4-20-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::CycleStop(void) <br>{ <br>    if (_iCycleVelocity) <br>    { <br>        KillTimer(_hwnd, CYCLE_TIMER); <br>        _iCycleVelocity = 0; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Wash <br>// <br>//  Synopsis:   "washes" a set of colors over the last n-1 colors in the <br>//              color palette, smoothly cycling the colors over the entire <br>//              range <br>// <br>//  Arguments:  [i]        - number of colors to wash <br>//              [rgColors] - array of colors <br>// <br>//  Modifies:   _pEntry1, _pEntry2, _hpal, _pLogPal <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//  Notes:      Color 0 is the graph background (or points inside the graph <br>//              set where appropriate).  It is always the first palette entry. <br>//              The other colors are cycled or washed over the remaining <br>//              palette entries so that they smoothly transition from one <br>//              to the next. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::Wash(int i, PALETTEENTRY rgColors[]) <br>{ <br>    HPALETTE hPalOld; <br> <br>    int c; <br>    int iFirst, iNext, iSource, iDestination; <br>    int iSpread, iIndex; <br> <br>    EnterCriticalSection(&amp;_csGraph); <br> <br>    // Remember if we were in the foreground when we realized <br>    // our main window's palette.  If we're not in the foreground then we <br>    // will have to do it again when we get the WM_QUERYNEWPALETTE message. <br> <br>    _fReRealizePalette = GetFocus() != _hwnd; <br> <br>    // Now create an all black palette and realize it to rudely bump <br>    // everyone elese's colors out of the system palette. <br> <br>    _pLogPal-&gt;palVersion    = 0x300; <br>    _pLogPal-&gt;palNumEntries = 256; <br> <br>    for (c = 256; c--; ) <br>    { <br>        _pLogPal-&gt;palPalEntry[c].peRed = 0; <br>        _pLogPal-&gt;palPalEntry[c].peGreen = 0; <br>        _pLogPal-&gt;palPalEntry[c].peBlue = 0; <br>        _pLogPal-&gt;palPalEntry[c].peFlags = PC_NOCOLLAPSE; <br>    } <br>    HPALETTE hPalTemp = CreatePalette((LPLOGPALETTE)_pLogPal); <br>    HDC hdc = GetDC(_hwnd); <br>    hPalOld = SelectPalette(hdc, hPalTemp, 0); <br>    RealizePalette(hdc); <br>    DeleteObject(hPalOld); <br> <br>    // Now we're ready to create the palette that we're really interested in. <br> <br>    _pLogPal-&gt;palVersion    = 0x300; <br>    _pLogPal-&gt;palNumEntries = 256; <br> <br>    // First we'll get the system palette and initialize our palette to it. <br> <br>    GetSystemPaletteEntries(hdc, 0, 256, &amp;_pLogPal-&gt;palPalEntry[0]); <br> <br>    // Here we'll make sure that everything in the palette (other than the <br>    // system colors) gets marked at least PC_NOCOLLAPSE.  This way <br>    // we can rudely be sure that no other app will be able to slow our <br>    // app down by destroying our one to one identity mapping with the <br>    // system palette. <br> <br>    for (c = 245; c &gt; PALETTESIZE + 10; c--) <br>    { <br>        _pLogPal-&gt;palPalEntry[c].peFlags = PC_NOCOLLAPSE; <br>    } <br> <br>    // Now we'll fill in the rest of the colors that we're interested in, <br>    // marking them PC_RESERVED so that they can be animated. <br> <br>    _pEntry1[0].peRed = _pLogPal-&gt;palPalEntry[10].peRed = rgColors[0].peRed; <br>    _pEntry1[0].peGreen = _pLogPal-&gt;palPalEntry[10].peGreen = rgColors[0].peGreen; <br>    _pEntry1[0].peBlue = _pLogPal-&gt;palPalEntry[10].peBlue = rgColors[0].peBlue; <br>    _pEntry1[0].peFlags = _pLogPal-&gt;palPalEntry[10].peFlags = <br>        _fCanAnimate ? PC_RESERVED : PC_NOCOLLAPSE; <br>    for (c = 0; c &lt; i - 1 ; c++) <br>    { <br>        iSource = c + 1; <br>        iDestination = (c+1)%(i-1)+1; <br>        iFirst = 1 + MulDiv(c, PALETTESIZE - 1, i - 1); <br>        iNext = 1 + MulDiv(c + 1, PALETTESIZE - 1, i - 1); <br>        iSpread = iNext-iFirst; <br>        for (iIndex = iSpread; iIndex--; ) <br>        { <br>            _pEntry1[iIndex + iFirst].peRed = <br>                _pLogPal-&gt;palPalEntry[iIndex + iFirst + 10].peRed = <br>                    (rgColors[iSource].peRed * (iSpread-iIndex)) / iSpread + <br>                    (rgColors[iDestination].peRed * iIndex) / iSpread; <br>            _pEntry1[iIndex + iFirst].peGreen = <br>                _pLogPal-&gt;palPalEntry[iIndex + iFirst + 10].peGreen = <br>                    (rgColors[iSource].peGreen * (iSpread-iIndex)) / iSpread + <br>                    (rgColors[iDestination].peGreen * iIndex) / iSpread; <br>            _pEntry1[iIndex + iFirst].peBlue = <br>                _pLogPal-&gt;palPalEntry[iIndex + iFirst + 10].peBlue = <br>                    (rgColors[iSource].peBlue * (iSpread-iIndex)) / iSpread + <br>                    (rgColors[iDestination].peBlue * iIndex) / iSpread; <br>            _pEntry1[iIndex + iFirst].peFlags = <br>                _pLogPal-&gt;palPalEntry[iIndex + iFirst + 10].peFlags = <br>                _fCanAnimate ? PC_RESERVED : PC_NOCOLLAPSE; <br>        } <br>    } <br> <br>    _hpal = CreatePalette((LPLOGPALETTE) _pLogPal); <br>    hPalOld = SelectPalette(hdc, _hpal, 0); <br>    RealizePalette(hdc); <br>    ReleaseDC(_hwnd, hdc); <br>    DeleteObject(hPalOld); <br> <br>    // now select the same palette into the memory DC <br> <br>    hPalOld = SelectPalette (_hdcMem, _hpal, 0); <br>    RealizePalette(_hdcMem); <br>    DeleteObject(hPalOld); <br> <br>    // prepare the dibsection's color table to exactly match the palette <br> <br>    RGBQUAD rgb[256]; <br>    for (int x = 256; x--;) <br>    { <br>        rgb[x].rgbRed = _pLogPal-&gt;palPalEntry[x].peRed; <br>        rgb[x].rgbGreen = _pLogPal-&gt;palPalEntry[x].peGreen; <br>        rgb[x].rgbBlue = _pLogPal-&gt;palPalEntry[x].peBlue; <br>        rgb[x].rgbReserved = 0; <br>    } <br> <br>    SetDIBColorTable(_hdcMem, 0, 256, rgb); <br> <br>    // force the bitmap to be repainted <br>    InvalidateRect(_hwnd, NULL, FALSE); <br>    LeaveCriticalSection(&amp;_csGraph); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::LoadPalette <br>// <br>//  Synopsis:   Loads the palette from a text file. <br>// <br>//  History:    4-21-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::LoadPalette(void) <br>{ <br>    HANDLE h; <br>    PALETTEENTRY rgColors[PALETTESIZE]; <br>    int c; <br>    char sz[256]; <br>    DWORD dwCount; <br>    h = CreateFile(_szPalFileName, <br>        GENERIC_READ, <br>        FILE_SHARE_READ | FILE_SHARE_WRITE, <br>        NULL, <br>        OPEN_EXISTING, <br>        0, <br>        0); <br>    if (h != INVALID_HANDLE_VALUE) <br>    { <br>        for (c = 0; c &lt; PALETTESIZE; c++) <br>        { <br>            int n = 0; <br>            do <br>            { <br>                ReadFile(h,&amp;sz[n++], 1, &amp;dwCount, NULL); <br>            } while (sz[n-1] != '\n' &amp;&amp; dwCount &amp;&amp; n &lt; 255); <br>            if (n != 1) <br>            { <br>                unsigned u1, u2, u3; <br>                if(sscanf(sz, "%u %u %u", <br>                    &amp;u1, <br>                    &amp;u2, <br>                    &amp;u3) != 3) <br>                { <br>                    break; <br>                } <br>                rgColors[c].peRed = u1; <br>                rgColors[c].peGreen = u2; <br>                rgColors[c].peBlue = u3; <br>            } <br>            else break; <br>        } <br>        CloseHandle(h); <br>        Wash(c,rgColors); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::SavePalette <br>// <br>//  Synopsis:   Saves the palette to a text file. <br>// <br>//  History:    4-21-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::SavePalette(void) <br>{ <br>    HANDLE h; <br>    int c; <br>    char sz[256]; <br>    DWORD dwCount; <br>    h = CreateFile(_szPalFileName, <br>        GENERIC_WRITE, <br>        0, <br>        NULL, <br>        CREATE_ALWAYS, <br>        FILE_ATTRIBUTE_NORMAL, <br>        0); <br>    if (h != INVALID_HANDLE_VALUE) <br>    { <br>        for (c = 0; c &lt; PALETTESIZE; c++) <br>        { <br>            sprintf(sz, "%u %u %u\n", <br>                _pEntry1[c].peRed, <br>                _pEntry1[c].peGreen, <br>                _pEntry1[c].peBlue); <br>            WriteFile(h, sz, strlen(sz), &amp;dwCount, NULL); <br>        } <br>        CloseHandle(h); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::SaveBitmap <br>// <br>//  Synopsis:   saves the graph as a standard device independent bitmap <br>// <br>//  History:    4-21-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::SaveBitmap(void) <br>{ <br>    HANDLE hdibCurrent = DibFromBitmap(_hbmMainWindow, BI_RGB, 0, _hpal); <br>    StartWait(); <br>#ifndef UNICODE <br>    // convert file name to a wide string <br>    WCHAR wszBmpFileName[MAX_PATH]; <br>    mbstowcs(wszBmpFileName, _szBmpFileName, MAX_PATH); <br>    if (!WriteDIB(wszBmpFileName, hdibCurrent)) <br>#else <br>    if (!WriteDIB(_szBmpFileName, hdibCurrent)) <br>#endif <br>    { <br>        EndWait(); <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_SAVEBMPFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    _hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>    } <br>    else <br>    { <br>        EndWait(); <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_SAVEBMPSUCCEEDED, szText, MAX_STRING_LENGTH)) <br>        { <br>            MessageBox( <br>                _hwnd, <br>                szText, <br>                TEXT(APP_TITLE), <br>                MB_OK | MB_ICONEXCLAMATION); <br>        } <br>    } <br>    GlobalFree(hdibCurrent); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::LoadFile <br>// <br>//  Synopsis:   loads a fractal file <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::LoadFile(void) <br>{ <br>    StartWait(); <br> <br>#ifndef UNICODE <br>    // convert file name to a wide string <br>    WCHAR wszFileName[MAX_PATH]; <br>    mbstowcs(wszFileName, _szFileName, MAX_PATH); <br>#endif <br>    // get IStorage <br>    HRESULT hr = StgOpenStorage( <br>#ifdef UNICODE <br>        _szFileName, <br>#else <br>        wszFileName, <br>#endif <br>        NULL, <br>        STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>        NULL, <br>        0, <br>        &amp;_pstg); <br>    if (SUCCEEDED(hr)) <br>    { <br>        IStream * pstm; <br> <br>        // load properies from "Properties" stream using OleLoadFromStream <br> <br>        hr = _pstg-&gt;OpenStream( <br>            OLESTR("Properties"), <br>            0, <br>            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>            0, <br>            &amp;pstm); <br>        if (SUCCEEDED(hr)) <br>        { <br>            IFractalEngine * pFractalEngine; <br>            IPersistStream * pFractalEngineStream; <br>            hr = OleLoadFromStream(pstm, IID_IFractalEngine, (void **)&amp;pFractalEngine); <br>            if (SUCCEEDED(hr)) <br>            { <br>                if (_pFractalEngine) <br>                { <br>                    _pFractalEngine-&gt;Release(); <br>                } <br>                _pFractalEngine = pFractalEngine; <br>                hr = pFractalEngine-&gt;QueryInterface( IID_IPersistStream, (void**)&amp;pFractalEngineStream); <br>                if (SUCCEEDED(hr) ) <br>                { <br>                    // Tell the new fractal engine where our IFractalHost pointer is. <br> <br>                    _pFractalEngine-&gt;Init((IFractalHost *)this); <br>                    HMENU hmenu = GetMenu(_hwnd); <br> <br>                    // Clear our check mark by our old fractal type. <br> <br>                    CheckMenuItem( <br>                        hmenu, <br>                        _uFractalType + IDM_FRACTAL_TYPE, <br>                        MF_BYCOMMAND | MF_UNCHECKED); <br> <br>                    // And check our new fractal type. <br> <br>                    CLSID cid; <br>                    pFractalEngineStream-&gt;GetClassID(&amp;cid); <br>                    pFractalEngineStream-&gt;Release(); <br>                    int iIndex = _pEngineList-&gt;FindEntry(cid); <br>                    if (iIndex &gt;= 0) <br>                    { <br>                        _uFractalType = (unsigned) iIndex; <br>                        CheckMenuItem( <br>                            hmenu, <br>                            _uFractalType + IDM_FRACTAL_TYPE, <br>                            MF_BYCOMMAND | MF_CHECKED); <br>                    } <br>                    else <br>                    { <br>                        // This is a previously unknown fractal type. <br>                        // HOWEVER it could be loaded and so there is <br>                        // nothing keeping us from adding it to our <br>                        // list of known fractal engines. <br> <br>                        // At this time there is no mechanism for adding <br>                        // fractal engines to the Engine List object. <br>                        // This would be an easy thing to add at some time <br>                        // in the future. <br> <br>                        // For now, we'll allow this condition (since there <br>                        // is no reason not to) but we'll do <br>                        // nothing about it. <br>                    } <br>                    _pFractalEngine-&gt;GetExtent(&amp;_dLeft, &amp;_dTop, &amp;_dRight, &amp;_dBottom); <br>                } <br>            } <br>            pstm-&gt;Release(); <br> <br>        } <br> <br>        // Load image from "Image" stream <br> <br>        if (SUCCEEDED(hr)) <br>        { <br>            hr = _pstg-&gt;OpenStream( <br>                OLESTR("Image"), <br>                0, <br>                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                0, <br>                &amp;pstm); <br>            if (SUCCEEDED(hr)) <br>            { <br>                unsigned uWidth, uHeight; <br>                hr = pstm-&gt;Read(&amp;uWidth, sizeof(unsigned), NULL); <br>                if (SUCCEEDED(hr)) <br>                { <br>                    hr = pstm-&gt;Read(&amp;uHeight, sizeof(unsigned), NULL); <br>                } <br>                if (SUCCEEDED(hr)) <br>                { <br>                    hr = SetGraphSize(uWidth, uHeight); <br>                    if (SUCCEEDED(hr)) <br>                    { <br>                        _pFractalEngine-&gt;SetGraphSize(uWidth, uHeight); <br>                        hr = pstm-&gt;Read(_rgPixels, ((uWidth  + 3) / 4) * 4 * uHeight, NULL); <br>                    } <br>                } <br>                pstm-&gt;Release(); <br>            } <br>        } <br> <br>        // Load palette from "Palette" stream <br> <br>        if (SUCCEEDED(hr)) <br>        { <br>            hr = _pstg-&gt;OpenStream( <br>                OLESTR("Palette"), <br>                0, <br>                STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                0, <br>                &amp;pstm); <br>            if (SUCCEEDED(hr)) <br>            { <br>                PALETTEENTRY rgColors[PALETTESIZE]; <br>                hr = pstm-&gt;Read(rgColors, sizeof(PALETTEENTRY) * (PALETTESIZE), NULL); <br> <br>                // select new palette <br>                if (SUCCEEDED(hr)) <br>                { <br>                    Wash(PALETTESIZE, rgColors); <br>                } <br>                pstm-&gt;Release(); <br>            } <br>        } <br> <br>        _pstg-&gt;Release(); <br>        _pstg = NULL; <br>    } <br>    EndWait(); <br>    if (FAILED(hr)) <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_LOADFRACTALFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    _hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- </code></pre>
<p>
</p>
<pre><code>// <br>//  Member:     CFractalWindow::SaveFile <br>// <br>//  Synopsis:   saves a fractal file <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::SaveFile(void) <br>{ <br>    if (!_pFractalEngine) <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_SAVEFRACTALFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    _hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>        return; <br>    } <br>    StartWait(); <br>#ifndef UNICODE <br>    // convert file name to a wide string <br>    WCHAR wszFileName[MAX_PATH]; <br>    mbstowcs(wszFileName, _szFileName, MAX_PATH); <br>#endif <br>    HRESULT hr = StgCreateDocfile( <br>#ifdef UNICODE <br>        _szFileName, <br>#else <br>        wszFileName, <br>#endif <br>        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>        0, <br>        &amp;_pstg); <br>    if (SUCCEEDED(hr)) <br>    { <br>        IStream * pstm; <br>        hr = _pstg-&gt;CreateStream( <br>            OLESTR("Palette"), <br>            STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>            0, <br>            0, <br>            &amp;pstm); <br>        if (SUCCEEDED(hr)) <br>        { <br>            hr = pstm-&gt;Write(_pEntry1, sizeof(PALETTEENTRY) * (PALETTESIZE), NULL); <br>            if (SUCCEEDED(hr)) <br>            { <br>                hr = pstm-&gt;Commit(STGC_DEFAULT); <br>            } <br>            pstm-&gt;Release(); <br>            if (SUCCEEDED(hr)) <br>            { <br>                hr = _pstg-&gt;CreateStream( <br>                    OLESTR("Image"), <br>                    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                    0, <br>                    0, <br>                    &amp;pstm); <br>                if (SUCCEEDED(hr)) <br>                { <br>                    hr = pstm-&gt;Write(&amp;_uImageWidth, sizeof(unsigned), NULL); <br>                    if (SUCCEEDED(hr)) <br>                    { <br>                        hr = pstm-&gt;Write(&amp;_uImageHeight, sizeof(unsigned), NULL); <br>                    } <br>                    if (SUCCEEDED(hr)) <br>                    { <br>                        hr = pstm-&gt;Write(_rgPixels, ((_uImageWidth  + 3) / 4) * 4 * _uImageHeight, NULL); <br>                    } <br>                    pstm-&gt;Release(); <br> <br>                    hr = _pstg-&gt;CreateStream( <br>                        OLESTR("Properties"), <br>                        STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>                        0, <br>                        0, <br>                        &amp;pstm); <br>                    if (SUCCEEDED(hr)) <br>                    { <br>                        IPersistStream * pPStm; <br>                        hr = _pFractalEngine-&gt;QueryInterface(IID_IPersistStream, (void **)&amp;pPStm); <br>                        if (SUCCEEDED(hr)) <br>                        { <br>                            hr = OleSaveToStream(pPStm, pstm); <br>                            if (SUCCEEDED(hr)) <br>                            { <br>                                hr = pstm-&gt;Commit(STGC_DEFAULT); <br>                            } <br>                            pstm-&gt;Release(); <br>                            pPStm-&gt;Release(); <br>                        } <br>                    } <br>                } <br>            } <br>        } <br>        if (SUCCEEDED(hr)) <br>        { <br>            hr = _pstg-&gt;Commit(STGC_DEFAULT); <br>        } <br>        _pstg-&gt;Release(); <br>        _pstg = NULL; <br>    } <br>    EndWait(); <br>    if (SUCCEEDED(hr)) <br>    { <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_SAVEFRACTALSUCCEEDED, szText, MAX_STRING_LENGTH)) <br>        { <br>            MessageBox( <br>                _hwnd, <br>                szText, <br>                TEXT(APP_TITLE), <br>                MB_OK | MB_ICONEXCLAMATION); <br>        } <br>    } <br>    else <br>    { <br>        TCHAR szTitle[MAX_STRING_LENGTH]; <br>        TCHAR szText[MAX_STRING_LENGTH]; <br>        if (LoadString(_hInstance, IDS_ERROR, szTitle, MAX_STRING_LENGTH)) <br>        { <br>            if (LoadString(_hInstance, IDS_SAVEFRACTALFAILED, szText, MAX_STRING_LENGTH)) <br>            { <br>                MessageBox( <br>                    _hwnd, <br>                    szText, <br>                    szTitle, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>            } <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::ToggleTitle <br>// <br>//  Synopsis:   toggles full screen mode on/off <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::ToggleTitle(void) <br>{ <br>    static ULONG ulID; <br>    static RECT OldRec; <br>    RECT rectTemp; <br>    static int iNoTitleTop = 0; <br>    static int iNoTitleLeft = 0; <br>    ULONG  ulStyleBits = GetWindowLong(_hwnd, GWL_STYLE); <br> <br>    if (WaitForSingleObject(_hTitleEvent,0) != WAIT_OBJECT_0) <br>    { <br>        GetWindowRect(_hwnd,&amp;rectTemp); <br>        iNoTitleTop = rectTemp.top; <br>        iNoTitleLeft = rectTemp.left; <br>        ulStyleBits |= WS_TILEDWINDOW; <br>        SetWindowLong(_hwnd, GWL_ID, ulID); <br>        MoveWindow(_hwnd,OldRec.left,OldRec.top, <br>            OldRec.right-OldRec.left,OldRec.bottom-OldRec.top,TRUE); <br>        SetWindowPos(_hwnd,HWND_NOTOPMOST,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOACTIVATE); <br>        SetEvent(_hTitleEvent); <br>        if (WaitForSingleObject(_hGraphStartedEvent, 0) != WAIT_OBJECT_0) <br>        { <br>            OnStop(); <br>        } <br>        else <br>        { <br>            OnStart(); <br>        } <br>    } <br>    else <br>    { <br>        int iWidth, iHeight; <br>        ResetEvent(_hTitleEvent); <br>        GetWindowRect(_hwnd,&amp;OldRec); <br>        ulStyleBits &amp;= ~(WS_DLGFRAME | WS_SYSMENU | <br>            WS_MINIMIZEBOX | WS_MAXIMIZEBOX | <br>            WS_THICKFRAME | WS_VSCROLL | WS_HSCROLL); <br>        ulID = SetWindowLong(_hwnd, GWL_ID, 0); <br>        iWidth = _uImageWidth + GetSystemMetrics(SM_CXBORDER) * 2; <br>        iHeight = _uImageHeight + GetSystemMetrics(SM_CYBORDER) * 2; <br>        if (iNoTitleTop == 0 &amp;&amp; iNoTitleLeft == 0) <br>        { <br>            iNoTitleTop = 0-GetSystemMetrics(SM_CYBORDER); <br>            iNoTitleLeft = 0-GetSystemMetrics(SM_CXBORDER); <br>        } <br>        MoveWindow(_hwnd <br>            ,iNoTitleLeft <br>            ,iNoTitleTop <br>            ,iWidth <br>            ,iHeight <br>            ,TRUE); <br>    } <br> <br>    SetWindowLong(_hwnd, GWL_STYLE, ulStyleBits); <br>    SetWindowPos( _hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | <br>    SWP_NOZORDER | SWP_FRAMECHANGED ); <br>    ShowWindow(_hwnd, SW_SHOW); <br>} <br> <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::OnStart <br>// <br>//  Synopsis:   Called whenever the graphics engine has been <br>//              successfully started. <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//  Notes:      Disables the following menu items: <br>//                  IDM_LOAD <br>//                  IDM_SAVE <br>//                  IDM_SAVEBMP <br>//                  IDM_START <br>//                  IDM_SELECT_TYPE <br>//                  IDM_EDIT_PROPERTIES <br>//                  IDM_CHANGEDIM <br>//                  IDM_ZOOM <br>// <br>//              Enables the following menu items: <br>//                  IDM_STOP <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::OnStart(void) <br>{ <br>    SetEvent(_hGraphStartedEvent); <br>    HMENU hmenu = GetMenu(_hwnd); <br>    UINT rgCommandList[] = <br>        { <br>            IDM_LOAD, <br>            IDM_SAVE, <br>            IDM_SAVEBMP, <br>            IDM_START, <br>            IDM_SELECT_TYPE, <br>            IDM_EDIT_PROPERTIES, <br>            IDM_CHANGEDIM, <br>            IDM_ZOOM <br>        }; <br>    for (int iIndex = sizeof(rgCommandList)/sizeof(UINT); iIndex--;) <br>    { <br>        EnableMenuItem( <br>            hmenu, <br>            rgCommandList[iIndex], <br>            MF_BYCOMMAND | MF_GRAYED); <br>    } <br>    EnableMenuItem( <br>        hmenu, <br>        IDM_STOP, <br>        MF_BYCOMMAND | MF_ENABLED); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::OnStop <br>// <br>//  Synopsis:   Called whenever the graphics engine has been stopped. <br>// <br>//  History:    4-22-94   stevebl   Created <br>// <br>//  Notes:      Disables the following menu items: <br>//                  IDM_STOP <br>// <br>//              Enables the following menu items: <br>//                  IDM_LOAD <br>//                  IDM_SAVE <br>//                  IDM_SAVEBMP <br>//                  IDM_START <br>//                  IDM_SELECT_TYPE <br>//                  IDM_EDIT_PROPERTIES <br>//                  IDM_CHANGEDIM <br>//                  IDM_ZOOM <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CFractalWindow::OnStop(void) <br>{ <br>    ResetEvent(_hGraphStartedEvent); <br>    HMENU hmenu = GetMenu(_hwnd); <br>    UINT rgCommandList[] = <br>        { <br>            IDM_LOAD, <br>            IDM_SAVE, <br>            IDM_SAVEBMP, <br>            IDM_START, <br>            IDM_SELECT_TYPE, <br>            IDM_EDIT_PROPERTIES, <br>            IDM_CHANGEDIM, <br>            IDM_ZOOM <br>        }; <br>    for (int iIndex = sizeof(rgCommandList)/sizeof(UINT); iIndex--;) <br>    { <br>        EnableMenuItem( <br>            hmenu, <br>            rgCommandList[iIndex], <br>            MF_BYCOMMAND | MF_ENABLED); <br>    } <br>    EnableMenuItem( <br>        hmenu, <br>        IDM_STOP, <br>        MF_BYCOMMAND | MF_GRAYED); <br>    InvalidateRect(_hwnd, NULL, FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::SetGraphSize <br>// <br>//  Synopsis:   called every time the graph's size changes <br>// <br>//  Arguments:  [uWidth]  - width of the graph in pixels <br>//              [uHeight] - height of the graph in pixels <br>// <br>//  Modifies:   _uImageWidth, _uImageHeight <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//  Notes:      calls NewWindowSize to update the scroll bars <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::SetGraphSize(unsigned uWidth, unsigned uHeight) <br>{ <br>    HDC hdc = GetDC(_hwnd); <br>    BITMAPINFO bmi; <br> <br>    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); <br>    bmi.bmiHeader.biWidth = uWidth; <br>    bmi.bmiHeader.biHeight= uHeight; <br>    bmi.bmiHeader.biPlanes = 1; <br>    bmi.bmiHeader.biBitCount = 8; <br>    bmi.bmiHeader.biCompression = BI_RGB; <br>    bmi.bmiHeader.biSizeImage = 0; <br>    bmi.bmiHeader.biXPelsPerMeter = 0; <br>    bmi.bmiHeader.biYPelsPerMeter = 0; <br>    bmi.bmiHeader.biClrUsed = 0; <br>    bmi.bmiHeader.biClrImportant = 0; <br>    char * rgPixels; <br>    HBITMAP hbmMainWindow = CreateDIBSection(hdc, &amp;bmi, DIB_PAL_COLORS, (void **)&amp;rgPixels, NULL, NULL); <br>    ReleaseDC(_hwnd, hdc); <br>    if (hbmMainWindow == NULL) <br>    { <br>        return(E_OUTOFMEMORY); <br>    } <br>    _uImageWidth = uWidth; <br>    _uImageHeight = uHeight; <br>    _hbmMainWindow = hbmMainWindow; <br>    _rgPixels = rgPixels; <br> <br>    if (!_hbmSavedBitmap) <br>    { <br>        // this is the very first time this has been called. <br>        EnterCriticalSection(&amp;_csGraph); <br>        _hbmSavedBitmap = (HBITMAP) SelectObject(_hdcMem, _hbmMainWindow); <br>        LeaveCriticalSection(&amp;_csGraph); <br>    } <br>    else <br>    { <br>        EnterCriticalSection(&amp;_csGraph); <br>        HBITMAP hbm = (HBITMAP) SelectObject(_hdcMem, _hbmMainWindow); <br>        LeaveCriticalSection(&amp;_csGraph); <br>        DeleteObject(hbm); <br>    } <br> <br>    NewWindowSize(_uWindowWidth, _uWindowHeight); <br> <br>    Rect(0, 0, (int)uWidth-1, (int)uHeight-1, 0); <br>    InvalidateRect(_hwnd, NULL, TRUE); <br> <br>    PostMessage(_hwnd, WM_REFRESHCOLORS, 0, 0); <br> <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::GetGraphSize <br>// <br>//  Synopsis:   returns the size of the graph's bitmap <br>// <br>//  Arguments:  [puWidth]  - width in pixels <br>//              [puHeight] - height in pixels <br>// <br>//  History:    4-13-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::GetGraphSize(unsigned * puWidth, unsigned * puHeight) <br>{ <br>    *puWidth = _uImageWidth; <br>    *puHeight = _uImageHeight; <br>    return(S_OK); <br>} <br> <br>// IUnknown methods: <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::QueryInterface <br>// <br>//  Synopsis:   returns an interface supported by this object <br>// <br>//  Arguments:  [riid] - id of desired interface <br>//              [ppv]  - pointer to recieve interface <br>// <br>//  Returns:    S_OK if the interface is supported <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::QueryInterface (REFIID riid, void ** ppv) <br>{ <br>    HRESULT hr = S_OK; <br>    if (IsEqualGUID(riid, IID_IUnknown)) <br>    { <br>        *ppv = (LPVOID)(IUnknown *) this; <br>    } <br>    else if (IsEqualGUID(riid, IID_IFractalHost)) <br>    { <br>        *ppv = (LPVOID)(IFractalHost *) this; <br>    } <br>    else <br>    { <br>        *ppv = NULL; <br>        hr = E_NOINTERFACE; <br>    } <br>    return(hr); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::AddRef <br>// <br>//  Synopsis:   increments refcount <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//  Notes:      Since this is an application, the refcount isn't acutally <br>//              used for anything.  The app will remain around until the <br>//              user closes it. <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) CFractalWindow::AddRef(void) <br>{ <br>    return(++_uRefCount); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Release <br>// <br>//  Synopsis:   decrements the refcount <br>// <br>//  Returns:    new refcount <br>// <br>//  History:    4-14-94   stevebl   Created <br>// <br>//  Notes:      Since this is an application the refcount isn't actually used <br>//              for anything.  If the refcount reaches zero, the app will <br>//              still remain open until the user closes it. <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP_(ULONG) CFractalWindow::Release(void) <br>{ <br>    if (_uRefCount &gt; 0) <br>    { <br>        _uRefCount--; <br>    } <br>    else <br>    { <br>        // This object is _NOT_ destroyed if it's reference count reaches zero. <br>    } <br>    return(_uRefCount); <br>} <br> <br> <br>// IFractalHost methods: <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::GetPoint <br>// <br>//  Synopsis:   gets the color at the given point <br>// <br>//  Arguments:  [puColor] - pointer to variable to recieve the color <br>//              [x]       - x position of the pixel <br>//              [y]       - y position of the pixel <br>// <br>//  Returns:    S_OK if the point is on the graph <br>//              S_FALSE if the point is off the graph (and *puColor is set to 0) <br>// <br>//  History:    4-12-94   stevebl   Created <br>//              7-07-94   stevebl   changed parameters and return value <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::GetPoint(unsigned * puColor, int x, int y) <br>{ <br>    if ((unsigned) x &gt;= _uImageWidth || (unsigned) y &gt;= _uImageHeight) <br>    { <br>        *puColor = 0; <br>        return(S_FALSE); <br>    } <br>    EnterCriticalSection(&amp;_csGraph); <br>    * puColor = (unsigned)_rgPixels[x + (_uImageHeight - (y + 1)) * (((_uImageWidth + 3) / 4) * 4)] - 10; <br>    LeaveCriticalSection(&amp;_csGraph); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Rect <br>// <br>//  Synopsis:   paints a filled rectangle <br>// <br>//  Arguments:  [iLeft]   - left side <br>//              [iTop]    - top <br>//              [iRight]  - right side <br>//              [iBottom] - bottom <br>//              [uColor]  - color index <br>// <br>//  Returns:    S_OK if any part of the rectangle is painted <br>//              S_FALSE if the rectangle is entirely off the graph <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::Rect( <br>    int iLeft, <br>    int iTop, <br>    int iRight, <br>    int iBottom, <br>    unsigned uColor) <br>{ <br>    if (iRight &lt; iLeft) <br>    { <br>        int i = iRight; <br>        iRight = iLeft; <br>        iLeft = i; <br>    } <br>    if (iBottom &lt; iTop) <br>    { <br>        int i = iBottom; <br>        iBottom = iTop; <br>        iTop = i; <br>    } <br>    if (iRight &lt; 0 || iBottom &lt; 0 || iLeft &gt;= (int) _uImageWidth || iTop &gt;= (int) _uImageHeight) <br>    { <br>        // Rectangle is entirely outside of the boundaries <br>        return(S_FALSE); <br>    } <br>    if (iLeft &lt; 0) <br>    { <br>        iLeft = 0; <br>    } <br>    if (iTop &lt; 0) <br>    { <br>        iTop = 0; <br>    } <br>    if (iRight &gt;= (int) _uImageWidth) <br>    { <br>        iRight = _uImageWidth - 1; <br>    } <br>    if (iBottom &gt;= (int) _uImageHeight) <br>    { <br>        iBottom = _uImageHeight - 1; <br>    } <br>    EnterCriticalSection(&amp;_csGraph); <br>    char chColor = char (uColor + 10); <br>    if (0 == iLeft &amp;&amp; <br>        0 == iTop &amp;&amp; <br>        (int) _uImageWidth - 1 == iRight &amp;&amp; <br>        (int) _uImageHeight - 1 == iBottom) <br>    { <br>        memset(_rgPixels, chColor, ((_uImageWidth + 3) / 4) * 4 * _uImageHeight); <br> <br>        // This little trick causes the screen to always repaint if the <br>        // calling process paints the entire window (which always happens <br>        // when a graph engine is restarted). <br> <br>        InvalidateRect(_hwnd, NULL, TRUE); <br>    } <br>    else <br>    { <br>        RECT rect; <br>        rect.left = iLeft; <br>        rect.top = iTop; <br>        // add one to the right and bottom to <br>        // make sure that we never get a null region <br>        rect.right = iRight + 1; <br>        rect.bottom = iBottom + 1; <br>        UnionRect(&amp;_rectPainted, &amp;_rectPainted, &amp;rect); <br>        for (unsigned y = (iBottom - iTop) + 1; y--;) <br>        { <br>            unsigned uBase = (_uImageHeight - (y + iTop + 1)) * ((_uImageWidth + 3) / 4) * 4 + iLeft; <br>            for (unsigned x = (iRight - iLeft) + 1; x--;) <br>            { <br>                _rgPixels[uBase + x] = chColor; <br>            } <br>        } <br>    } <br>    LeaveCriticalSection(&amp;_csGraph); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::ClipLine <br>// <br>//  Synopsis:   clips a line to the graph boundaries <br>// <br>//  Arguments:  [x1] - x coordinate of point 1 <br>//              [y1] - y coordinate of point 1 <br>//              [x2] - x coordinate of point 2 <br>//              [y2] - y coordinate of point 2 <br>// <br>//  Returns:    TRUE if the line is completely outside the graph (rejected) <br>//              FALSE if any part of the line should be drawn <br>// <br>//  Modifies:   the endpoints are clipped to be within the graph <br>// <br>//  History:    5-03-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CFractalWindow::ClipLine(int &amp;x1, int &amp;y1, int &amp;x2, int &amp;y2) <br>{ <br>    // Test for trivial rejections <br>    if ( <br>        (x1 &lt; 0 &amp;&amp; x2 &lt; 0) <br>        || (y1 &lt; 0 &amp;&amp; y2 &lt; 0) <br>        || (x1 &gt;= (int) _uImageWidth &amp;&amp; x2 &gt;= (int) _uImageWidth) <br>        || (y1 &gt;= (int) _uImageHeight &amp;&amp; y2 &gt;= (int) _uImageHeight) <br>       ) <br>    { <br>        return(TRUE);   // line has been rejected <br>    } <br> <br>    // Now adjust any points that are outside the bounding box to be cut off <br>    // at and edge of the bounding box. <br> <br>    int dx = x2 - x1; <br>    int dy = y2 - y1; <br> <br>    if (x1 &lt; 0) <br>    { <br>        y1 = ((0 - x1) * dy) / dx + y1; <br>        x1 = 0; <br>    } <br>    else if (x2 &lt; 0) <br>    { <br>        y2 = ((0 - x2) * dy) / dx + y2; <br>        x2 = 0; <br>    } <br>    if ((int) y1 &lt; 0) <br>    { <br>        x1 = ((0 - y1) * dx) / dy + x1; <br>        y1 = 0; <br>    } <br>    else if (y2 &lt; 0) <br>    { <br>        x2 = ((0 - y2) * dx) / dy + x2; <br>        y2 = 0; <br>    } <br>    if (x1 &gt;= (int) _uImageWidth) <br>    { <br>        y1 = (((int) _uImageWidth - x1) * dy) / dx + y1; <br>        x1 = _uImageWidth - 1; <br>    } <br>    else if (x2 &gt;= (int) _uImageWidth) <br>    { <br>        y2 = (((int) _uImageWidth - x2) * dy) / dx + y2; <br>        x2 = _uImageWidth - 1; <br>    } <br>    if (y1 &gt;= (int) _uImageHeight) <br>    { <br>        x1 = (((int) _uImageHeight - y1) * dx) / dy + x1; <br>        y1 = _uImageHeight - 1; <br>    } <br>    else if (y2 &gt;= (int) _uImageHeight) <br>    { <br>        x2 = (((int) _uImageHeight - y2) * dx) / dy + x2; <br>        y2 = _uImageHeight - 1; <br>    } <br> <br>    // Test again for rejection <br>    if ( <br>        x1 &lt; 0 <br>        || x2 &lt; 0 <br>        || y1 &lt; 0 <br>        || y2 &lt; 0 <br>        || x1 &gt;= (int) _uImageWidth <br>        || x2 &gt;= (int) _uImageWidth <br>        || y1 &gt;= (int) _uImageHeight <br>        || y2 &gt;= (int) _uImageHeight <br>       ) <br>    { <br>        return(TRUE);   // line has been rejected <br>    } <br> <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Line <br>// <br>//  Synopsis:   draws a line on the graph <br>// <br>//  Arguments:  [x1]     - starting point <br>//              [y1] <br>//              [x2]     - ending point <br>//              [y2] <br>//              [uColor] - color <br>// <br>//  Returns:    S_OK if any part of the line could be drawn <br>//              S_FALSE if all of the line was outside the graph (rejected) <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::Line( <br>    int x1, <br>    int y1, <br>    int x2, <br>    int y2, <br>    unsigned uColor) <br>{ <br>    // clip the line <br>    if (ClipLine(x1, y1, x2, y2)) <br>    { <br>        // line was rejected (it's not on the graph) <br>        return(S_FALSE); <br>    } <br> <br>    EnterCriticalSection(&amp;_csGraph); <br>    RECT rect; <br> <br>    if (x1 &lt; x2) <br>    { <br>        rect.left = x1; <br>        rect.right = x2; <br>    } <br>    else <br>    { <br>        rect.left = x2; <br>        rect.right = x1; <br>    } <br>    if (y1 &lt; y2) <br>    { <br>        rect.top = y1; <br>        rect.bottom = y2; <br>    } <br>    else <br>    { <br>        rect.top = y2; <br>        rect.bottom = y1; <br>    } <br>    int dx = rect.right - rect.left; <br>    int dy = rect.bottom - rect.top; <br>    char chColor = (char) uColor + 10; <br>    int p, c1, c2, iNextLine; <br>    unsigned uCurrent, uLast; <br>    if (dx &gt; dy) <br>    { <br>        // step along x axis <br>        p = 2 * dy - dx; <br>        c1 = 2 * dy; <br>        c2 = 2 * (dy - dx); <br>        if (x1 &gt; x2) <br>        { <br>            // last point to first point <br>            uCurrent = x2 + (_uImageHeight - (y2 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            uLast = x1 + (_uImageHeight - (y1 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            if (y2 &lt; y1) <br>            { <br>                // posative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) + 1; <br>            } <br>            else <br>            { <br>                // negative slope <br>                iNextLine = (((_uImageWidth + 3) / 4) * 4) + 1; <br>            } <br>        } <br>        else <br>        { <br>            // first point to last point <br>            uCurrent = x1 + (_uImageHeight - (y1 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            uLast = x2 + (_uImageHeight - (y2 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            if (y1 &lt; y2) <br>            { <br>                // posative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) + 1; <br>            } <br>            else <br>            { <br>                // negative slope <br>                iNextLine = (((_uImageWidth + 3) / 4) * 4) + 1; <br>            } <br>        } <br>        _rgPixels[uCurrent] = chColor; <br>        while (uCurrent != uLast) <br>        { <br>            if (p &lt; 0) <br>            { <br>                uCurrent++; <br>                p += c1; <br>            } <br>            else <br>            { <br>                uCurrent += iNextLine; <br>                p += c2; <br>            } <br>            _rgPixels[uCurrent] = chColor; <br>        } <br>    } <br>    else <br>    { <br>        // step along y axis <br>        p = 2 * dx - dy; <br>        c1 = 2 * dx; <br>        c2 = 2 * (dx - dy); <br>        if (y1 &gt; y2) <br>        { <br>            // last point to first point <br>            uCurrent = x2 + (_uImageHeight - (y2 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            uLast = x1 + (_uImageHeight - (y1 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            if (x2 &gt; x1) <br>            { <br>                // negative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) - 1; <br>            } <br>            else <br>            { <br>                // posative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) + 1; <br>            } <br>        } <br>        else <br>        { <br>            // first point to last point <br>            uCurrent = x1 + (_uImageHeight - (y1 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            uLast = x2 + (_uImageHeight - (y2 + 1)) * (((_uImageWidth + 3) / 4) * 4); <br>            if (x1 &gt; x2) <br>            { <br>                // negative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) - 1; <br>            } <br>            else <br>            { <br>                // posative slope <br>                iNextLine = (0 - (((_uImageWidth + 3) / 4) * 4)) + 1; <br>            } <br>        } <br>        _rgPixels[uCurrent] = chColor; <br>        while (uCurrent != uLast) <br>        { <br>            if (p &lt; 0) <br>            { <br>                uCurrent += (0 - (((_uImageWidth + 3) / 4) * 4)); <br>                p += c1; <br>            } <br>            else <br>            { <br>                uCurrent += iNextLine; <br>                p += c2; <br>            } <br>            _rgPixels[uCurrent] = chColor; <br>        } <br>    } <br>    // add one to the right and bottom to <br>    // make sure that we never get a null region <br>    rect.bottom++; <br>    rect.right++; <br>    UnionRect(&amp;_rectPainted, &amp;_rectPainted, &amp;rect); <br>    LeaveCriticalSection(&amp;_csGraph); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::Point <br>// <br>//  Synopsis:   plots a pixel on the graph <br>// <br>//  Arguments:  [x]      - x coordinate <br>//              [y]      - y coordinate <br>//              [uColor] - color <br>// <br>//  Returns:    S_OK if the point was plotted <br>//              S_FALSE if the point is outside the graph <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::Point( <br>    int x, <br>    int y, <br>    unsigned uColor) <br>{ <br>    // clip the point <br>    if ((unsigned) x &gt;= _uImageWidth || (unsigned) y &gt;= _uImageHeight) <br>    { <br>        return(S_FALSE); <br>    } <br>    RECT rectPt; <br>    EnterCriticalSection(&amp;_csGraph); <br>    rectPt.left = x; <br>    rectPt.top = y; <br>    // Have to have a rectangle with at least one pixel or UnionRect won't <br>    // do anything. <br>    rectPt.right = x + 1; <br>    rectPt.bottom = y + 1; <br>    UnionRect(&amp;_rectPainted, &amp;_rectPainted, &amp;rectPt); <br>    _rgPixels[x + (_uImageHeight - (y + 1)) * (((_uImageWidth + 3) / 4) * 4)] = (char)(uColor + 10); <br>    LeaveCriticalSection(&amp;_csGraph); <br>    return(S_OK); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CFractalWindow::DoneDrawingGraph <br>// <br>//  Synopsis:   called by the fractal engine when its done drawing a graph <br>// <br>//  Returns:    S_OK <br>// <br>//  History:    4-12-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>STDMETHODIMP CFractalWindow::DoneDrawingGraph(void) <br>{ <br>    MessageBeep(0xffffffff); <br>    OnStop(); <br>    return(S_OK); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
