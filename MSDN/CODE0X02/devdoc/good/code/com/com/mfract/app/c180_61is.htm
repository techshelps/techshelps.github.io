<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context184"></a>DIB.C</h2>
<pre><code>/******************************************************************************* <br> *                                                                             * <br> *  MODULE  : DIB.C                                                            * <br> *                                                                             * <br> *  DESCRIPTION : Routines for dealing with Device Independent Bitmaps.        * <br> *                                                                             * <br> *  FUNCTIONS   : OpenDIB()       - Opens DIB file and creates a memory DIB    * <br> *                                                                             * <br> *        WriteDIB()          - Writes a global handle in CF_DIB format        * <br> *                  to a file.                                                 * <br> *                                                                             * <br> *        DibInfo()       - Retrieves the info. block associated               * <br> *                  with a CF_DIB format memory block.                         * <br> *                                                                             * <br> *        CreateBIPalette()   - Creates a GDI palette given a pointer          * <br> *                  to a BITMAPINFO structure.                                 * <br> *                                                                             * <br> *        CreateDibPalette()  - Creates a GDI palette given a HANDLE           * <br> *                  to a BITMAPINFO structure.                                 * <br> *                                                                             * <br> *        ReadDibBitmapInfo() - Reads a file in DIB format and returns         * <br> *                  a global handle to it's BITMAPINFO                         * <br> *                                                                             * <br> *        PaletteSize()       - Calculates the palette size in bytes           * <br> *                  of given DIB                                               * <br> *                                                                             * <br> *        DibNumColors()      - Determines the number of colors in DIB         * <br> *                                                                             * <br> *        BitmapFromDib()     - Creates a DDB given a global handle to         * <br> *                  a block in CF_DIB format.                                  * <br> *                                                                             * <br> *        DibFromBitmap()     - Creates a DIB repr. the DDB passed in.         * <br> *                                                                             * <br> *        DrawBitmap()        - Draws a bitmap at specified position           * <br> *                  in the DC.                                                 * <br> *                                                                             * <br> *        DibBlt()        - Draws a bitmap in CIF_DIB format using             * <br> *                  SetDIBitsToDevice()                                        * <br> *                                                                             * <br> *        StretchDibBlt()     - Draws a bitmap in CIF_DIB format using         * <br> *                  StretchDIBits()                                            * <br> *                                                                             * <br> *        lread()         - Private routine to read more than 64k              * <br> *                                                                             * <br> *        lwrite()        - Private routine to write more than 64k             * <br> *                                                                             * <br> *******************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br> <br>#include "dib.h" <br>HCURSOR hcurSave; <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :OpenDIB(LPWSTR szFile)                                      * <br> *                                                                          * <br> *  PURPOSE    :Open a DIB file and create a MEMORY DIB, a memory handle    * <br> *      containing BITMAPINFO, palette data and the bits.                   * <br> *                                                                          * <br> *  RETURNS    :A handle to the DIB.                                        * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE OpenDIB (szFile) <br>LPWSTR szFile; <br>{ <br>    unsigned        fh; <br>    BITMAPINFOHEADER    bi; <br>    LPBITMAPINFOHEADER  lpbi; <br>    DWORD       dwLen = 0; <br>    DWORD       dwBits; <br>    HANDLE      hdib; <br>    HANDLE      h; <br>    OFSTRUCT        of; <br>    char sz[256]; <br> <br>    /* Open the file and read the DIB information */ <br>    wcstombs(sz,szFile,256); <br>    fh = OpenFile(sz, &amp;of, OF_READ); <br>    if (fh == -1) <br>        return NULL; <br> <br>    hdib = ReadDibBitmapInfo(fh); <br>    if (!hdib) <br>        return NULL; <br>    DibInfo(hdib,&amp;bi); <br> <br>    /* Calculate the memory needed to hold the DIB */ <br>    dwBits = bi.biSizeImage; <br>    dwLen  = bi.biSize + (DWORD)PaletteSize (&amp;bi) + dwBits; <br> <br>    /* Try to increase the size of the bitmap info. buffer to hold the DIB */ <br>    h = GlobalReAlloc(hdib, dwLen, GHND); <br>    if (!h) <br>    { <br>        GlobalFree(hdib); <br>        hdib = NULL; <br>    } <br>    else <br>        hdib = h; <br> <br>    /* Read in the bits */ <br>    if (hdib) <br>    { <br>        lpbi = (VOID FAR *)GlobalLock(hdib); <br>        lread(fh, (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi), dwBits); <br>        GlobalUnlock(hdib); <br>    } <br>    _lclose(fh); <br> <br>    return hdib; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : WriteDIB(LPWSTR szFile,HANDLE hdib)                        * <br> *                                                                          * <br> *  PURPOSE    : Write a global handle in CF_DIB format to a file.          * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if successful.                                     * <br> *       FALSE - otherwise                                                  * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL WriteDIB (szFile, hdib) <br>LPWSTR szFile; <br>HANDLE hdib; <br>{ <br>    BITMAPFILEHEADER    hdr; <br>    LPBITMAPINFOHEADER  lpbi; <br>    int                 fh; <br>    OFSTRUCT            of; <br>    char sz[256]; <br> <br>    if (!hdib) <br>        return FALSE; <br> <br>    wcstombs(sz,szFile,256); <br>    fh = OpenFile (sz, &amp;of, OF_CREATE|OF_READWRITE); <br>    if (fh == -1) <br>        return FALSE; <br> <br>    lpbi = (VOID FAR *)GlobalLock (hdib); <br> <br>    /* Fill in the fields of the file header */ <br>    hdr.bfType      = BFT_BITMAP; <br>    hdr.bfSize      = GlobalSize (hdib) + sizeof (BITMAPFILEHEADER); <br>    hdr.bfReserved1 = 0; <br>    hdr.bfReserved2 = 0; <br>    hdr.bfOffBits   = (DWORD)sizeof(BITMAPFILEHEADER) + lpbi-&gt;biSize + <br>        PaletteSize(lpbi); <br> <br>    /* Write the file header */ <br>    _lwrite (fh, (LPSTR)&amp;hdr, sizeof (BITMAPFILEHEADER)); <br> <br>    /* Write the DIB header and the bits */ <br>    lwrite (fh, (LPSTR)lpbi, GlobalSize (hdib)); <br> <br>    GlobalUnlock (hdib); <br>    _lclose (fh); <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibInfo(HANDLE hbi,LPBITMAPINFOHEADER lpbi)                * <br> *                                                                          * <br> *  PURPOSE    : Retrieves the DIB info associated with a CF_DIB            * <br> *       format memory block.                                               * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if successful.                                     * <br> *       FALSE - otherwise                                                  * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DibInfo (hbi, lpbi) <br>HANDLE hbi; <br>LPBITMAPINFOHEADER lpbi; <br>{ <br>    if (hbi) <br>    { <br>        *lpbi = *(LPBITMAPINFOHEADER)GlobalLock (hbi); <br> <br>        /* fill in the default fields */ <br>        if (lpbi-&gt;biSize != sizeof (BITMAPCOREHEADER)) <br>        { <br>            if (lpbi-&gt;biSizeImage == 0L) <br>                lpbi-&gt;biSizeImage = <br>                    WIDTHBYTES(lpbi-&gt;biWidth*lpbi-&gt;biBitCount) * lpbi-&gt;biHeight; <br> <br>            if (lpbi-&gt;biClrUsed == 0L) <br>                lpbi-&gt;biClrUsed = DibNumColors (lpbi); <br>        } <br>        GlobalUnlock (hbi); <br>        return TRUE; <br>    } <br>    return FALSE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateBIPalette(LPBITMAPINFOHEADER lpbi)                   * <br> *                                                                          * <br> *  PURPOSE    : Given a Pointer to a BITMAPINFO struct will create a       * <br> *       a GDI palette object from the color table.                         * <br> *                                                                          * <br> *  RETURNS    : A handle to the palette.                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>HPALETTE CreateBIPalette (lpbi) <br>LPBITMAPINFOHEADER lpbi; <br>{ <br>    LOGPALETTE  *pPal; <br>    HPALETTE    hpal = NULL; <br>    WORD        nNumColors; <br>    BYTE        red; <br>    BYTE        green; <br>    BYTE        blue; <br>    int         i; <br>    RGBQUAD FAR *pRgb; <br> <br>    if (!lpbi) <br>        return NULL; <br> <br>    if (lpbi-&gt;biSize != sizeof(BITMAPINFOHEADER)) <br>        return NULL; <br> <br>    /* Get a pointer to the color table and the number of colors in it */ <br>    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + (WORD)lpbi-&gt;biSize); <br>    nNumColors = DibNumColors(lpbi); <br> <br>    if (nNumColors) <br>    { <br>        /* Allocate for the logical palette structure */ <br>        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY)); <br>        if (!pPal) <br>            return NULL; <br> <br>        pPal-&gt;palNumEntries = nNumColors; <br>        pPal-&gt;palVersion    = PALVERSION; <br> <br>        /* Fill in the palette entries from the DIB color table and <br>         * create a logical color palette. <br>         */ <br>        for (i = 0; i &lt; nNumColors; i++) <br>        { <br>            pPal-&gt;palPalEntry[i].peRed   = pRgb[i].rgbRed; <br>            pPal-&gt;palPalEntry[i].peGreen = pRgb[i].rgbGreen; <br>            pPal-&gt;palPalEntry[i].peBlue  = pRgb[i].rgbBlue; <br>            pPal-&gt;palPalEntry[i].peFlags = (BYTE)0; <br>        } <br>        hpal = CreatePalette(pPal); <br>        LocalFree((HANDLE)pPal); <br>    } <br>    else if (lpbi-&gt;biBitCount == 24) <br>    { <br>        /* A 24 bitcount DIB has no color table entries so, set the number of <br>         * to the maximum value (256). <br>         */ <br>        nNumColors = MAXPALETTE; <br>        pPal = (LOGPALETTE*)LocalAlloc(LPTR,sizeof(LOGPALETTE) + nNumColors * sizeof(PALETTEENTRY)); <br>        if (!pPal) <br>            return NULL; <br> <br>        pPal-&gt;palNumEntries = nNumColors; <br>        pPal-&gt;palVersion    = PALVERSION; <br> <br>        red = green = blue = 0; <br> <br>        /* Generate 256 (= 8*8*4) RGB combinations to fill the palette <br>         * entries. <br>         */ <br>        for (i = 0; i &lt; pPal-&gt;palNumEntries; i++) <br>        { <br>            pPal-&gt;palPalEntry[i].peRed   = red; <br>            pPal-&gt;palPalEntry[i].peGreen = green; <br>            pPal-&gt;palPalEntry[i].peBlue  = blue; <br>            pPal-&gt;palPalEntry[i].peFlags = (BYTE)0; <br> <br>            if (!(red += 32)) <br>                if (!(green += 32)) <br>                    blue += 64; <br>        } <br>        hpal = CreatePalette(pPal); <br>        LocalFree((HANDLE)pPal); <br>    } <br>    return hpal; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : CreateDibPalette(HANDLE hbi)                               * <br> *                                                                          * <br> *  PURPOSE    : Given a Global HANDLE to a BITMAPINFO Struct               * <br> *       will create a GDI palette object from the color table.             * <br> *       (BITMAPINFOHEADER format DIBs only)                                * <br> *                                                                          * <br> *  RETURNS    : A handle to the palette.                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>HPALETTE CreateDibPalette (hbi) <br>HANDLE hbi; <br>{ <br>    HPALETTE hpal; <br> <br>    if (!hbi) <br>        return NULL; <br>    hpal = CreateBIPalette((LPBITMAPINFOHEADER)GlobalLock(hbi)); <br>    GlobalUnlock(hbi); <br>    return hpal; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : ReadDibBitmapInfo(int fh)                                  * <br> *                                                                          * <br> *  PURPOSE    : Will read a file in DIB format and return a global HANDLE  * <br> *       to it's BITMAPINFO.  This function will work with both             * <br> *       "old" (BITMAPCOREHEADER) and "new" (BITMAPINFOHEADER)              * <br> *       bitmap formats, but will always return a "new" BITMAPINFO          * <br> *                                                                          * <br> *  RETURNS    : A handle to the BITMAPINFO of the DIB in the file.         * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE ReadDibBitmapInfo (fh) <br>int fh; <br>{ <br>    DWORD     off; <br>    HANDLE    hbi = NULL; <br>    int       size; <br>    int       i; <br>    WORD      nNumColors; <br> <br>    RGBQUAD FAR       *pRgb; <br>    BITMAPINFOHEADER   bi; <br>    BITMAPCOREHEADER   bc; <br>    LPBITMAPINFOHEADER lpbi; <br>    BITMAPFILEHEADER   bf; <br>    DWORD          dwWidth = 0; <br>    DWORD          dwHeight = 0; <br>    WORD           wPlanes, wBitCount; <br> <br>    if (fh == -1) <br>        return NULL; <br> <br>    /* Reset file pointer and read file header */ <br>    off = _llseek(fh, 0L, SEEK_CUR); <br>    if (sizeof (bf) != _lread (fh, (LPSTR)&amp;bf, sizeof (bf))) <br>        return FALSE; <br> <br>    /* Do we have a RC HEADER? */ <br>    if (!ISDIB (bf.bfType)) <br>    { <br>        bf.bfOffBits = 0L; <br>        _llseek (fh, off, SEEK_SET); <br>    } <br>    if (sizeof (bi) != _lread (fh, (LPSTR)&amp;bi, sizeof(bi))) <br>        return FALSE; <br> <br>    nNumColors = DibNumColors (&amp;bi); <br> <br>    /* Check the nature (BITMAPINFO or BITMAPCORE) of the info. block <br>     * and extract the field information accordingly. If a BITMAPCOREHEADER, <br>     * transfer it's field information to a BITMAPINFOHEADER-style block <br>     */ <br>    switch (size = (int)bi.biSize) <br>    { <br>    case sizeof (BITMAPINFOHEADER): <br>        break; <br> <br>    case sizeof (BITMAPCOREHEADER): <br>        bc = *(BITMAPCOREHEADER*)&amp;bi; <br>        dwWidth   = (DWORD)bc.bcWidth; <br>        dwHeight  = (DWORD)bc.bcHeight; <br>        wPlanes   = bc.bcPlanes; <br>        wBitCount = bc.bcBitCount; <br>        bi.biSize           = sizeof(BITMAPINFOHEADER); <br>        bi.biWidth          = dwWidth; <br>        bi.biHeight         = dwHeight; <br>        bi.biPlanes         = wPlanes; <br>        bi.biBitCount       = wBitCount; <br>        bi.biCompression    = BI_RGB; <br>        bi.biSizeImage      = 0; <br>        bi.biXPelsPerMeter  = 0; <br>        bi.biYPelsPerMeter  = 0; <br>        bi.biClrUsed        = nNumColors; <br>        bi.biClrImportant   = nNumColors; <br>        _llseek (fh, (LONG)sizeof (BITMAPCOREHEADER) - sizeof (BITMAPINFOHEADER), SEEK_CUR); <br>        break; <br> <br>    default: <br>        /* Not a DIB! */ <br>        return NULL; <br>    } <br> <br>    /*  Fill in some default values if they are zero */ <br>    if (bi.biSizeImage == 0) <br>    { <br>        bi.biSizeImage = WIDTHBYTES ((DWORD)bi.biWidth * bi.biBitCount) <br>            * bi.biHeight; <br>    } <br>    if (bi.biClrUsed == 0) <br>        bi.biClrUsed = DibNumColors(&amp;bi); <br> <br>    /* Allocate for the BITMAPINFO structure and the color table. */ <br>    hbi = GlobalAlloc (GHND, (LONG)bi.biSize + nNumColors * sizeof(RGBQUAD)); <br>    if (!hbi) <br>        return NULL; <br>    lpbi = (VOID FAR *)GlobalLock (hbi); <br>    *lpbi = bi; <br> <br>    /* Get a pointer to the color table */ <br>    pRgb = (RGBQUAD FAR *)((LPSTR)lpbi + bi.biSize); <br>    if (nNumColors) <br>    { <br>        if (size == sizeof(BITMAPCOREHEADER)) <br>        { <br>            /* Convert a old color table (3 byte RGBTRIPLEs) to a new <br>             * color table (4 byte RGBQUADs) <br>             */ <br>            _lread (fh, (LPSTR)pRgb, nNumColors * sizeof(RGBTRIPLE)); <br> <br>            for (i = nNumColors - 1; i &gt;= 0; i--) <br>            { <br>                RGBQUAD rgb; <br> <br>                rgb.rgbRed  = ((RGBTRIPLE FAR *)pRgb)[i].rgbtRed; <br>                rgb.rgbBlue = ((RGBTRIPLE FAR *)pRgb)[i].rgbtBlue; <br>                rgb.rgbGreen    = ((RGBTRIPLE FAR *)pRgb)[i].rgbtGreen; <br>                rgb.rgbReserved = (BYTE)0; <br> <br>                pRgb[i] = rgb; <br>            } <br>        } <br>        else <br>            _lread(fh,(LPSTR)pRgb,nNumColors * sizeof(RGBQUAD)); <br>    } <br> <br>    if (bf.bfOffBits != 0L) <br>        _llseek(fh,off + bf.bfOffBits,SEEK_SET); <br> <br>    GlobalUnlock(hbi); <br>    return hbi; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   :  PaletteSize(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    :  Calculates the palette size in bytes. If the info. block  * <br> *        is of the BITMAPCOREHEADER type, the number of colors is          * <br> *        multiplied by 3 to give the palette size, otherwise the           * <br> *        number of colors is multiplied by 4.                              * <br> *                                                                          * <br> *  RETURNS    :  Palette size in number of bytes.                          * <br> *                                                                          * <br> ****************************************************************************/ <br>WORD PaletteSize (pv) <br>VOID FAR * pv; <br>{ <br>    LPBITMAPINFOHEADER lpbi; <br>    WORD NumColors; <br> <br>    lpbi      = (LPBITMAPINFOHEADER)pv; <br>    NumColors = DibNumColors(lpbi); <br> <br>    if (lpbi-&gt;biSize == sizeof(BITMAPCOREHEADER)) <br>        return NumColors * sizeof(RGBTRIPLE); <br>    else <br>        return NumColors * sizeof(RGBQUAD); <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibNumColors(VOID FAR * pv)                                * <br> *                                                                          * <br> *  PURPOSE    : Determines the number of colors in the DIB by looking at   * <br> *       the BitCount filed in the info block.                              * <br> *                                                                          * <br> *  RETURNS    : The number of colors in the DIB.                           * <br> *                                                                          * <br> ****************************************************************************/ <br>WORD DibNumColors (pv) <br>VOID FAR * pv; <br>{ <br>    int bits; <br>    LPBITMAPINFOHEADER lpbi; <br>    LPBITMAPCOREHEADER lpbc; <br> <br>    lpbi = ((LPBITMAPINFOHEADER)pv); <br>    lpbc = ((LPBITMAPCOREHEADER)pv); <br> <br>    /*  With the BITMAPINFO format headers, the size of the palette <br>     *  is in biClrUsed, whereas in the BITMAPCORE - style headers, it <br>     *  is dependent on the bits per pixel ( = 2 raised to the power of <br>     *  bits/pixel). <br>     */ <br>    if (lpbi-&gt;biSize != sizeof(BITMAPCOREHEADER)) <br>    { <br>        if (lpbi-&gt;biClrUsed != 0) <br>            return (WORD)lpbi-&gt;biClrUsed; <br>        bits = lpbi-&gt;biBitCount; <br>    } <br>    else <br>        bits = lpbc-&gt;bcBitCount; <br> <br>    switch (bits) <br>    { <br>    case 1: <br>        return 2; <br>    case 4: <br>        return 16; <br>    case 8: <br>        return 256; <br>    default: <br>        /* A 24 bitcount DIB has no color table */ <br>        return 0; <br>    } <br>} <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibFromBitmap()                                            * <br> *                                                                          * <br> *  PURPOSE    : Will create a global memory block in DIB format that       * <br> *       represents the Device-dependent bitmap (DDB) passed in.            * <br> *                                                                          * <br> *  RETURNS    : A handle to the DIB                                        * <br> *                                                                          * <br> ****************************************************************************/ <br>HANDLE DibFromBitmap (hbm, biStyle, biBits, hpal) <br>HBITMAP      hbm; <br>DWORD        biStyle; <br>WORD         biBits; <br>HPALETTE     hpal; <br>{ <br>    BITMAP bm; <br>    BITMAPINFOHEADER bi; <br>    BITMAPINFOHEADER FAR *lpbi; <br>    DWORD dwLen; <br>    HANDLE hdib; <br>    HANDLE h; <br>    HDC hdc; <br> <br>    if (!hbm) <br>        return NULL; <br> <br>    if (hpal == NULL) <br>        hpal = GetStockObject(DEFAULT_PALETTE); <br> <br>    GetObject(hbm,sizeof(bm),(LPSTR)&amp;bm); <br> <br>    if (biBits == 0) <br>        biBits =  bm.bmPlanes * bm.bmBitsPixel; <br> <br>    bi.biSize           = sizeof(BITMAPINFOHEADER); <br>    bi.biWidth          = bm.bmWidth; <br>    bi.biHeight         = bm.bmHeight; <br>    bi.biPlanes         = 1; <br>    bi.biBitCount       = biBits; <br>    bi.biCompression    = biStyle; <br>    bi.biSizeImage      = 0; <br>    bi.biXPelsPerMeter  = 0; <br>    bi.biYPelsPerMeter  = 0; <br>    bi.biClrUsed        = 0; <br>    bi.biClrImportant   = 0; <br> <br>    dwLen  = bi.biSize + PaletteSize(&amp;bi); <br> <br>    hdc = GetDC(NULL); <br>    hpal = SelectPalette(hdc,hpal,FALSE); <br>    RealizePalette(hdc); <br> <br>    hdib = GlobalAlloc(GHND,dwLen); <br> <br>    if (!hdib) <br>    { <br>        SelectPalette(hdc,hpal,FALSE); <br>        ReleaseDC(NULL,hdc); <br>        return NULL; <br>    } <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    *lpbi = bi; <br> <br>    /*  call GetDIBits with a NULL lpBits param, so it will calculate the <br>     *  biSizeImage field for us <br>     */ <br>    GetDIBits(hdc, hbm, 0, (WORD)bi.biHeight, <br>    NULL, (LPBITMAPINFO)lpbi, DIB_RGB_COLORS); <br> <br>    bi = *lpbi; <br>    GlobalUnlock(hdib); <br> <br>    /* If the driver did not fill in the biSizeImage field, make one up */ <br>    if (bi.biSizeImage == 0) <br>    { <br>        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight; <br> <br>        if (biStyle != BI_RGB) <br>            bi.biSizeImage = (bi.biSizeImage * 3) / 2; <br>    } <br> <br>    /*  realloc the buffer big enough to hold all the bits */ <br>    dwLen = bi.biSize + PaletteSize(&amp;bi) + bi.biSizeImage; <br>    if (h = GlobalReAlloc(hdib,dwLen,0)) <br>        hdib = h; <br>    else <br>    { <br>        GlobalFree(hdib); <br>        hdib = NULL; <br> <br>        SelectPalette(hdc,hpal,FALSE); <br>        ReleaseDC(NULL,hdc); <br>        return hdib; <br>    } <br> <br>    /*  call GetDIBits with a NON-NULL lpBits param, and actualy get the <br>     *  bits this time <br>     */ <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (GetDIBits( hdc, <br>        hbm, <br>        0, <br>        (WORD)bi.biHeight, <br>        (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi), <br>        (LPBITMAPINFO)lpbi, DIB_RGB_COLORS) == 0) <br>    { <br>        GlobalUnlock(hdib); <br>        hdib = NULL; <br>        SelectPalette(hdc,hpal,FALSE); <br>        ReleaseDC(NULL,hdc); <br>        return NULL; <br>    } <br> <br>    bi = *lpbi; <br>    GlobalUnlock(hdib); <br> <br>    SelectPalette(hdc,hpal,FALSE); <br>    ReleaseDC(NULL,hdc); <br>    return hdib; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : BitmapFromDib(HANDLE hdib, HPALETTE hpal)                  * <br> *                                                                          * <br> *  PURPOSE    : Will create a DDB (Device Dependent Bitmap) given a global * <br> *       handle to a memory block in CF_DIB format                          * <br> *                                                                          * <br> *  RETURNS    : A handle to the DDB.                                       * <br> *                                                                          * <br> ****************************************************************************/ <br>HBITMAP BitmapFromDib (hdib, hpal) <br>HANDLE     hdib; <br>HPALETTE   hpal; <br>{ <br>    LPBITMAPINFOHEADER  lpbi; <br>    HPALETTE    hpalT; <br>    HDC         hdc; <br>    HBITMAP     hbm; <br> <br>    StartWait(); <br> <br>    if (!hdib) <br>        return NULL; <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return NULL; <br> <br>    hdc = GetDC(NULL); <br> <br>    if (hpal) <br>    { <br>        hpalT = SelectPalette(hdc,hpal,FALSE); <br>        RealizePalette(hdc);     // GDI Bug...???? <br>    } <br> <br>    hbm = CreateDIBitmap(hdc, <br>        (LPBITMAPINFOHEADER)lpbi, <br>        (LONG)CBM_INIT, <br>        (LPSTR)lpbi + lpbi-&gt;biSize + PaletteSize(lpbi), <br>        (LPBITMAPINFO)lpbi, <br>        DIB_RGB_COLORS ); <br> <br>    if (hpal) <br>        SelectPalette(hdc,hpalT,FALSE); <br> <br>    ReleaseDC(NULL,hdc); <br>    GlobalUnlock(hdib); <br> <br>    EndWait(); <br> <br>    return hbm; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DrawBitmap(HDC hdc, int x, int y, HBITMAP hbm, DWORD rop)  * <br> *                                                                          * <br> *  PURPOSE    : Draws bitmap &lt;hbm&gt; at the specifed position in DC &lt;hdc&gt;    * <br> *                                                                          * <br> *  RETURNS    : Return value of BitBlt()                                   * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DrawBitmap (hdc, x, y, hbm, rop) <br>HDC    hdc; <br>int    x, y; <br>HBITMAP    hbm; <br>DWORD      rop; <br>{ <br>    HDC       hdcBits; <br>    BITMAP    bm; <br>    BOOL      f; <br> <br>    if (!hdc || !hbm) <br>        return FALSE; <br> <br>    hdcBits = CreateCompatibleDC(hdc); <br>    GetObject(hbm,sizeof(BITMAP),(LPSTR)&amp;bm); <br>    SelectObject(hdcBits,hbm); <br>    f = BitBlt(hdc,0,0,bm.bmWidth,bm.bmHeight,hdcBits,0,0,rop); <br>    DeleteDC(hdcBits); <br> <br>    return f; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : DibBlt( HDC hdc,                                           * <br> *           int x0, int y0,                                                * <br> *           int dx, int dy,                                                * <br> *           HANDLE hdib,                                                   * <br> *           int x1, int y1,                                                * <br> *           LONG rop)                                                      * <br> *                                                                          * <br> *  PURPOSE    : Draws a bitmap in CF_DIB format, using SetDIBits to device.* <br> *       taking the same parameters as BitBlt().                            * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if function succeeds.                              * <br> *       FALSE - otherwise.                                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL DibBlt (hdc, x0, y0, dx, dy, hdib, x1, y1, rop) <br>HDC    hdc; <br>int    x0, y0, dx, dy; <br>HANDLE     hdib; <br>int    x1, y1; <br>LONG       rop; <br>{ <br>    LPBITMAPINFOHEADER   lpbi; <br>    LPSTR        pBuf; <br> <br>    if (!hdib) <br>        return PatBlt(hdc,x0,y0,dx,dy,rop); <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return FALSE; <br> <br>    pBuf = (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi); <br>    SetDIBitsToDevice (hdc, x0, y0, dx, dy, <br>               x1,y1, <br>               x1, <br>               dy, <br>               pBuf, (LPBITMAPINFO)lpbi, <br>               DIB_RGB_COLORS ); <br> <br>    GlobalUnlock(hdib); <br>    return TRUE; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : StretchDibBlt( HDC hdc,                                    * <br> *              int x, int y,                                               * </code></pre>
<p>
</p>
<pre><code>*              int dx, int dy,                                             * <br> *              HANDLE hdib,                                                * <br> *              int x0, int y0,                                             * <br> *              int dx0, int dy0,                                           * <br> *              LONG rop)                                                   * <br> *                                                                          * <br> *  PURPOSE    : Draws a bitmap in CF_DIB format, using StretchDIBits()     * <br> *       taking the same parameters as StretchBlt().                        * <br> *                                                                          * <br> *  RETURNS    : TRUE  - if function succeeds.                              * <br> *       FALSE - otherwise.                                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>BOOL StretchDibBlt (hdc, x, y, dx, dy, hdib, x0, y0, dx0, dy0, rop) <br>HDC hdc; <br>int x, y; <br>int dx, dy; <br>HANDLE hdib; <br>int x0, y0; <br>int dx0, dy0; <br>LONG rop; <br> <br>{ <br>    LPBITMAPINFOHEADER lpbi; <br>    LPSTR    pBuf; <br>    BOOL     f; <br> <br>    if (!hdib) <br>        return PatBlt(hdc,x,y,dx,dy,rop); <br> <br>    lpbi = (VOID FAR *)GlobalLock(hdib); <br> <br>    if (!lpbi) <br>        return FALSE; <br> <br>    pBuf = (LPSTR)lpbi + (WORD)lpbi-&gt;biSize + PaletteSize(lpbi); <br> <br>    f = StretchDIBits ( hdc, <br>            x, y, <br>            dx, dy, <br>            x0, y0, <br>            dx0, dy0, <br>            pBuf, (LPBITMAPINFO)lpbi, <br>            DIB_RGB_COLORS, <br>            rop); <br> <br>    GlobalUnlock(hdib); <br>    return f; <br>} <br> <br> /************* PRIVATE ROUTINES TO READ/WRITE MORE THAN 64K ***************/ <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : lread(int fh, VOID FAR *pv, DWORD ul)                      * <br> *                                                                          * <br> *  PURPOSE    : Reads data in steps of 32k till all the data has been read.* <br> *                                                                          * <br> *  RETURNS    : 0 - If read did not proceed correctly.                     * <br> *       number of bytes read otherwise.                                    * <br> *                                                                          * <br> ****************************************************************************/ <br>DWORD PASCAL lread (fh, pv, ul) <br>int       fh; <br>VOID far      *pv; <br>DWORD         ul; <br>{ <br>    DWORD     ulT = ul; <br>    BYTE      *hp = pv; <br> <br>    while (ul &gt; (DWORD)MAXREAD) <br>    { <br>        if (_lread(fh, (LPSTR)hp, (WORD)MAXREAD) != MAXREAD) <br>            return 0; <br>        ul -= MAXREAD; <br>        hp += MAXREAD; <br>    } <br>    if (_lread(fh, (LPSTR)hp, (WORD)ul) != (WORD)ul) <br>        return 0; <br>    return ulT; <br>} <br> <br>/**************************************************************************** <br> *                                                                          * <br> *  FUNCTION   : lwrite(int fh, VOID FAR *pv, DWORD ul)                     * <br> *                                                                          * <br> *  PURPOSE    : Writes data in steps of 32k till all the data is written.  * <br> *                                                                          * <br> *  RETURNS    : 0 - If write did not proceed correctly.                    * <br> *       number of bytes written otherwise.                                 * <br> *                                                                          * <br> ****************************************************************************/ <br>DWORD PASCAL lwrite (fh, pv, ul) <br>int      fh; <br>VOID FAR     *pv; <br>DWORD        ul; <br>{ <br>    DWORD     ulT = ul; <br>    BYTE      *hp = pv; <br> <br>    while (ul &gt; MAXREAD) <br>    { <br>        if (_lwrite(fh, (LPSTR)hp, (WORD)MAXREAD) != MAXREAD) <br>            return 0; <br>        ul -= MAXREAD; <br>        hp += MAXREAD; <br>    } <br>    if (_lwrite(fh, (LPSTR)hp, (WORD)ul) != (WORD)ul) <br>        return 0; <br>    return ulT; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
