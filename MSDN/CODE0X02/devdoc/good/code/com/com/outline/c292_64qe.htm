<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEOUTL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context296"></a>OLEOUTL.H</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2.0 Sample Code <br>** <br>**    oleoutl.h <br>** <br>**    This file contains file contains data structure defintions, <br>**    function prototypes, constants, etc. which are common to the <br>**    server version and the container version of the app. <br>**    app version of the Outline series of sample applications: <br>**          Outline -- base version of the app (without OLE functionality) <br>**          SvrOutl -- OLE 2.0 Server sample app <br>**          CntrOutl -- OLE 2.0 Containter sample app <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#if !defined( _OLEOUTL_H_ ) <br>#define _OLEOUTL_H_ <br> <br>#ifndef RC_INVOKED <br>#pragma message ("INCLUDING OLEOUTL.H from " __FILE__) <br>// make 'different levels of inderection' considered an error <br>#pragma warning (error:4047) <br>#endif  /* RC_INVOKED */ <br> <br>#if defined( USE_MSGFILTER ) <br>//#include "..\include\msgfiltr.h" <br>#include "msgfiltr.h" <br>#endif  // USE_MSGFILTER <br> <br>#include "defguid.h" <br>#include "ansiapi.h" <br> <br>/* Defines */ <br> <br>/* NOTE: these strings should correspond to the strings registered <br>**    in the registration database. <br>*/ <br>// REVIEW: should load strings from resource file <br>#if defined( INPLACE_SVR ) <br> <br>#ifdef TEST32 <br> <br>#define CLSID_APP   CLSID_ISvrOu32 <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 In-Place Server Outline 32") <br>#define SHORTUSERTYPENAME   OLESTR("Outline32")   // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "Outline Files (*.OLT)|*.olt|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olt"           // Default file extension <br> <br>#else <br> <br>#define CLSID_APP   CLSID_ISvrOtl <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 In-Place Server Outline") <br>#define SHORTUSERTYPENAME   OLESTR("Outline")   // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "oln"           // Default file extension <br> <br>#endif  // TEST32 <br>#endif  // INPLACE_SVR <br> <br>#if defined( INPLACE_CNTR ) <br> <br>#ifdef TEST32 <br> <br>#define CLSID_APP   CLSID_ICntrO32 <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 In-Place Container Outline 32") <br>// #define SHORTUSERTYPENAME    "Outline32"   // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLT)|*.olt|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olc"           // Default file extension <br> <br>#else <br> <br>#define CLSID_APP   CLSID_ICntrOtl <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 In-Place Container Outline") <br>// #define SHORTUSERTYPENAME    "Outline"   // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olc"           // Default file extension <br> <br>#endif TEST32 <br>#endif  // INPLACE_CNTR <br> <br>#if defined( OLE_SERVER ) &amp;&amp; !defined( INPLACE_SVR ) <br> <br>#ifdef TEST32 <br> <br>#define CLSID_APP   CLSID_SvrOut32 <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 Server Sample Outline 32") <br>#define SHORTUSERTYPENAME   OLESTR("Outline32") <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "Outline Files (*.OLT)|*.olt|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olt"           // Default file extension <br> <br>#else <br> <br>#define CLSID_APP   CLSID_SvrOutl <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 Server Sample Outline") <br>#define SHORTUSERTYPENAME   OLESTR("Outline") <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "oln"           // Default file extension <br> <br>#endif  //TEST32 <br>#endif  // OLE_SERVER &amp;&amp; ! INPLACE_SVR <br> <br>#if defined( OLE_CNTR ) &amp;&amp; !defined( INPLACE_CNTR ) <br>#ifdef TEST32 <br> <br>#define CLSID_APP   CLSID_CntrOu32 <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 Container Sample Outline 32") <br>// #define SHORTUSERTYPENAME    "Outline32"  // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLT)|*.olt|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olc"           // Default file extension <br> <br>#else <br> <br>#define CLSID_APP   CLSID_CntrOutl <br>#define FULLUSERTYPENAME    OLESTR("Ole 2.0 Container Sample Outline") <br>// #define SHORTUSERTYPENAME    "Outline"  // max 15 chars <br>#undef  APPFILENAMEFILTER <br>#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|" <br>#undef  DEFEXTENSION <br>#define DEFEXTENSION    "olc"           // Default file extension <br> <br>#endif  //TEST32 <br>#endif  // OLE_CNTR &amp;&amp; ! INPLACE_CNTR <br> <br>// Maximum number of formats offered by IDataObject::GetData/SetData <br>#define MAXNOFMTS       10 <br>#define MAXNOLINKTYPES   3 <br> <br>#if defined( USE_DRAGDROP ) <br>#define DD_SEL_THRESH       HITTESTDELTA    // Border threshold to start drag <br>#define MAX_SEL_ITEMS       0x0080 <br>#endif  // USE_DRAGDROP <br> <br>/* Positions of the various menus */ <br>#define POS_FILEMENU        0 <br>#define POS_EDITMENU        1 <br>#define POS_VIEWMENU        2 <br>#define POS_LINEMENU        3 <br>#define POS_NAMEMENU        4 <br>#define POS_OPTIONSMENU     5 <br>#define POS_DEBUGMENU       6 <br>#define POS_HELPMENU        7 <br> <br> <br>#define POS_OBJECT      11 <br> <br> <br>/* Types */ <br> <br>// Document initialization type <br>#define DOCTYPE_EMBEDDED    3   // init from an IStorage* of an embedded obj <br>#define DOCTYPE_FROMSTG     4   // init from an IStorage* with doc bit set <br> <br>/* Forward type definitions */ <br>typedef struct tagOLEAPP FAR* LPOLEAPP; <br>typedef struct tagOLEDOC FAR* LPOLEDOC; <br> <br>/* Flags to control Moniker assignment for OleDoc_GetFullMoniker */ <br>// REVIEW: should use official OLEGETMONIKER type for final version <br>typedef enum tagGETMONIKERTYPE { <br>   GETMONIKER_ONLYIFTHERE  = 1, <br>   GETMONIKER_FORCEASSIGN  = 2, <br>   GETMONIKER_UNASSIGN     = 3, <br>   GETMONIKER_TEMPFORUSER  = 4 <br>} GETMONIKERTYPE; <br> <br>/* Flags to control direction for drag scrolling */ <br>typedef enum tagSCROLLDIR { <br>   SCROLLDIR_NULL          = 0, <br>   SCROLLDIR_UP            = 1, <br>   SCROLLDIR_DOWN          = 2, <br>   SCROLLDIR_RIGHT         = 3,    // currently not used <br>   SCROLLDIR_LEFT          = 4     // currently not used <br>} SCROLLDIR; <br> <br> <br>/************************************************************************* <br>** class OLEDOC : OUTLINEDOC <br>**    OLEDOC is an extention to the base OUTLINEDOC object (structure) <br>**    that adds common OLE 2.0 functionality used by both the server <br>**    and container versions. This is an abstract class. You do not <br>**    instantiate an instance of OLEDOC directly but instead <br>**    instantiate one of its concrete subclasses: SERVERDOC or <br>**    CONTAINERDOC. There is one instance of an document <br>**    object created per document open in the app. The SDI <br>**    version of the app supports one ServerDoc at a time. The MDI <br>**    version of the app can manage multiple documents at one time. <br>**    The OLEDOC class inherits all fields from the OUTLINEDOC class. <br>**    This inheritance is achieved by including a member variable of <br>**    type OUTLINEDOC as the first field in the OLEDOC <br>**    structure. Thus a pointer to an OLEDOC object can be cast to be <br>**    a pointer to a OUTLINEDOC object. <br>*************************************************************************/ <br> <br>typedef struct tagOLEDOC { <br>   OUTLINEDOC      m_OutlineDoc;       // ServerDoc inherits from OutlineDoc <br>   ULONG           m_cRef;             // total ref count for document <br>   ULONG           m_dwStrongExtConn;  // total strong connection count <br>                              //  (from IExternalConnection) <br>                              //  when this count transitions to 0 <br>                              //  and fLastUnlockCloses==TRUE, then <br>                              //  IOleObject::Close is called to <br>                              //  close the document. <br>#if defined( _DEBUG ) <br>   ULONG           m_cCntrLock;        // total count of LockContainer locks <br>                              //  (for debugging purposes only) <br>#endif <br>   LPSTORAGE       m_lpStg;            // OleDoc must keep its stg open <br>                              //  even in-memory server doc should <br>                              //  keep Stg open for low memory save <br>   LPSTREAM        m_lpLLStm;          // Hold LineList IStream* open for <br>                              //  low memory save <br>   LPSTREAM        m_lpNTStm;          // Hold NameTable IStream* open for <br>                              //  low memory save <br>   BOOL            m_fObjIsClosing;    // flag to guard recursive close call <br>   BOOL            m_fObjIsDestroying; // flag to guard recursiv destroy call <br>   DWORD           m_dwRegROT;         // key if doc registered as running <br>   LPMONIKER       m_lpFileMoniker;    // moniker if file-based/untitled doc <br>   BOOL            m_fLinkSourceAvail; // can doc offer CF_LINKSOURCE <br>   LPOLEDOC        m_lpSrcDocOfCopy;   // src doc if doc created for copy <br>   BOOL            m_fUpdateEditMenu;  // need to update edit menu?? <br> <br>#if defined( USE_DRAGDROP ) <br>   DWORD           m_dwTimeEnterScrollArea;  // time entering scroll region <br>   DWORD           m_dwLastScrollDir;  // current dir for drag scroll <br>   DWORD           m_dwNextScrollTime; // time for next scroll <br>   BOOL            m_fRegDragDrop;     // is doc registered as drop target? <br>   BOOL            m_fLocalDrag;       // is doc source of the drag <br>   BOOL            m_fLocalDrop;       // was doc target of the drop <br>   BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible? <br>   BOOL            m_fCanDropLink;     // is Drag/Drop link possible? <br>   BOOL            m_fDragLeave;       // has drag left <br>   BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending <br>   POINT           m_ptButDown;        // LButtonDown coordinates <br>#endif  // USE_DRAGDROP <br> <br>#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR ) <br>   BOOL            m_fCSHelpMode;      // Shift-F1 context help mode <br>#endif <br> <br>   struct CDocUnknownImpl { <br>      IUnknownVtbl FAR*       lpVtbl; <br>      LPOLEDOC                lpOleDoc; <br>      int                     cRef;   // interface specific ref count. <br>   } m_Unknown; <br> <br>   struct CDocPersistFileImpl { <br>      IPersistFileVtbl FAR*   lpVtbl; <br>      LPOLEDOC                lpOleDoc; <br>      int                     cRef;   // interface specific ref count. <br>   } m_PersistFile; <br> <br>   struct CDocOleItemContainerImpl { <br>      IOleItemContainerVtbl FAR*  lpVtbl; <br>      LPOLEDOC                    lpOleDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_OleItemContainer; <br> <br>   struct CDocExternalConnectionImpl { <br>      IExternalConnectionVtbl FAR* lpVtbl; <br>      LPOLEDOC                lpOleDoc; <br>      int                     cRef;   // interface specific ref count. <br>   } m_ExternalConnection; <br> <br>   struct CDocDataObjectImpl { <br>      IDataObjectVtbl FAR*        lpVtbl; <br>      LPOLEDOC                    lpOleDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_DataObject; <br> <br>#ifdef USE_DRAGDROP <br>   struct CDocDropSourceImpl { <br>      IDropSourceVtbl FAR*    lpVtbl; <br>      LPOLEDOC                lpOleDoc; <br>      int                     cRef;   // interface specific ref count. <br>   } m_DropSource; <br> <br>   struct CDocDropTargetImpl { <br>      IDropTargetVtbl FAR*    lpVtbl; <br>      LPOLEDOC                lpOleDoc; <br>      int                     cRef;   // interface specific ref count. <br>   } m_DropTarget; <br>#endif  // USE_DRAGDROP <br> <br>} OLEDOC; <br> <br>/* OleDoc methods (functions) */ <br>BOOL OleDoc_Init(LPOLEDOC lpOleDoc, BOOL fDataTransferDoc); <br>BOOL OleDoc_InitNewFile(LPOLEDOC lpOleDoc); <br>void OleDoc_ShowWindow(LPOLEDOC lpOleDoc); <br>void OleDoc_HideWindow(LPOLEDOC lpOleDoc, BOOL fShutDown); <br>HRESULT OleDoc_Lock(LPOLEDOC lpOleDoc, BOOL fLock, BOOL fLastUnlockReleases); <br>ULONG OleDoc_AddRef(LPOLEDOC lpOleDoc); <br>ULONG OleDoc_Release (LPOLEDOC lpOleDoc); <br>HRESULT OleDoc_QueryInterface( <br>      LPOLEDOC          lpOleDoc, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpUnk <br>); <br>BOOL OleDoc_Close(LPOLEDOC lpOleDoc, DWORD dwSaveOption); <br>void OleDoc_Destroy(LPOLEDOC lpOleDoc); <br>void OleDoc_SetUpdateEditMenuFlag(LPOLEDOC lpOleDoc, BOOL fUpdate); <br>BOOL OleDoc_GetUpdateEditMenuFlag(LPOLEDOC lpOleDoc); <br>void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel); <br>HGLOBAL OleDoc_GetObjectDescriptorData( <br>      LPOLEDOC            lpOleDoc, <br>      LPLINERANGE         lplrSel <br>); <br>LPMONIKER OleDoc_GetFullMoniker(LPOLEDOC lpOleDoc, DWORD dwAssign); <br>void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel); <br>void OleDoc_DocRenamedUpdate(LPOLEDOC lpOleDoc, LPMONIKER lpmkDoc); <br>void OleDoc_CopyCommand(LPOLEDOC lpSrcOleDoc); <br>void OleDoc_PasteCommand(LPOLEDOC lpOleDoc); <br>void OleDoc_PasteSpecialCommand(LPOLEDOC lpOleDoc); <br>LPOUTLINEDOC OleDoc_CreateDataTransferDoc(LPOLEDOC lpSrcOleDoc); <br>BOOL OleDoc_PasteFromData( <br>      LPOLEDOC            lpOleDoc, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLocalDataObj, <br>      BOOL                fLink <br>); <br>BOOL OleDoc_PasteFormatFromData( <br>      LPOLEDOC            lpOleDoc, <br>      CLIPFORMAT          cfFormat, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLocalDataObj, <br>      BOOL                fLink, <br>      BOOL                fDisplayAsIcon, <br>      HGLOBAL             hMetaPict, <br>      LPSIZEL             lpSizelInSrc <br>); <br>BOOL OleDoc_QueryPasteFromData( <br>      LPOLEDOC            lpOleDoc, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLink <br>); <br> <br>#if defined( USE_DRAGDROP ) <br> <br>BOOL OleDoc_QueryDrag( LPOLEDOC lpOleDoc, int y ); <br>BOOL OleDoc_QueryDrop ( <br>   LPOLEDOC        lpOleDoc, <br>   DWORD           grfKeyState, <br>   POINTL          pointl, <br>   BOOL            fDragScroll, <br>   LPDWORD         lpdwEffect <br>); <br>DWORD OleDoc_DoDragDrop (LPOLEDOC lpSrcOleDoc); <br>BOOL OleDoc_DoDragScroll(LPOLEDOC lpOleDoc, POINTL pointl); <br> <br>#endif  // USE_DRAGDROP <br> <br>/* OleDoc::IUnknown methods (functions) */ <br>STDMETHODIMP OleDoc_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_Unk_AddRef(LPUNKNOWN lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_Unk_Release (LPUNKNOWN lpThis); <br> <br>/* OleDoc::IPersistFile methods (functions) */ <br>STDMETHODIMP OleDoc_PFile_QueryInterface( <br>      LPPERSISTFILE       lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_PFile_AddRef(LPPERSISTFILE lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_PFile_Release (LPPERSISTFILE lpThis); <br>STDMETHODIMP OleDoc_PFile_GetClassID ( <br>      LPPERSISTFILE       lpThis, <br>      CLSID FAR*          lpclsid <br>); <br>STDMETHODIMP  OleDoc_PFile_IsDirty(LPPERSISTFILE lpThis); <br>STDMETHODIMP OleDoc_PFile_Load ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName, <br>      DWORD               grfMode <br>); <br>STDMETHODIMP OleDoc_PFile_Save ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName, <br>      BOOL                fRemember <br>); <br>STDMETHODIMP OleDoc_PFile_SaveCompleted ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName <br>); <br>STDMETHODIMP OleDoc_PFile_GetCurFile ( <br>      LPPERSISTFILE   lpThis, <br>      LPOLESTR FAR*   lplpszFileName <br>); <br> <br>/* OleDoc::IOleItemContainer methods (functions) */ <br>STDMETHODIMP OleDoc_ItemCont_QueryInterface( <br>      LPOLEITEMCONTAINER  lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_ItemCont_AddRef(LPOLEITEMCONTAINER lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_ItemCont_Release(LPOLEITEMCONTAINER lpThis); <br>STDMETHODIMP OleDoc_ItemCont_ParseDisplayName( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPBC                lpbc, <br>      LPOLESTR            lpszDisplayName, <br>      ULONG FAR*          lpchEaten, <br>      LPMONIKER FAR*      lplpmkOut <br>); <br> <br>STDMETHODIMP OleDoc_ItemCont_EnumObjects( <br>      LPOLEITEMCONTAINER  lpThis, <br>      DWORD               grfFlags, <br>      LPENUMUNKNOWN FAR*  lplpenumUnknown <br>); <br>STDMETHODIMP OleDoc_ItemCont_LockContainer( <br>      LPOLEITEMCONTAINER  lpThis, <br>      BOOL                fLock <br>); <br>STDMETHODIMP OleDoc_ItemCont_GetObject( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem, <br>      DWORD               dwSpeedNeeded, <br>      LPBINDCTX           lpbc, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObject <br>); <br>STDMETHODIMP OleDoc_ItemCont_GetObjectStorage( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem, <br>      LPBINDCTX           lpbc, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvStorage <br>); <br>STDMETHODIMP OleDoc_ItemCont_IsRunning( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem <br>); <br> <br>/* OleDoc::IPersistFile methods (functions) */ <br>STDMETHODIMP OleDoc_ExtConn_QueryInterface( <br>      LPEXTERNALCONNECTION    lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_ExtConn_AddRef(LPEXTERNALCONNECTION lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_ExtConn_Release (LPEXTERNALCONNECTION lpThis); <br>STDMETHODIMP_(DWORD) OleDoc_ExtConn_AddConnection( <br>      LPEXTERNALCONNECTION    lpThis, <br>      DWORD                   extconn, <br>      DWORD                   reserved <br>); <br>STDMETHODIMP_(DWORD) OleDoc_ExtConn_ReleaseConnection( <br>      LPEXTERNALCONNECTION    lpThis, <br>      DWORD                   extconn, <br>      DWORD                   reserved, <br>      BOOL                    fLastReleaseCloses <br>); <br> <br>/* OleDoc::IDataObject methods (functions) */ <br>STDMETHODIMP OleDoc_DataObj_QueryInterface ( <br>      LPDATAOBJECT        lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_DataObj_AddRef(LPDATAOBJECT lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_DataObj_Release (LPDATAOBJECT lpThis); <br>STDMETHODIMP OleDoc_DataObj_GetData ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc, <br>      LPSTGMEDIUM         lpMedium <br>); <br>STDMETHODIMP OleDoc_DataObj_GetDataHere ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc, <br>      LPSTGMEDIUM         lpMedium <br>); <br>STDMETHODIMP OleDoc_DataObj_QueryGetData ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc <br>); <br>STDMETHODIMP OleDoc_DataObj_GetCanonicalFormatEtc( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpformatetc, <br>      LPFORMATETC         lpformatetcOut <br>); <br>STDMETHODIMP OleDoc_DataObj_SetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpFormatetc, <br>      LPSTGMEDIUM     lpMedium, <br>      BOOL            fRelease <br>); <br>STDMETHODIMP OleDoc_DataObj_EnumFormatEtc( <br>      LPDATAOBJECT            lpThis, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>); <br>STDMETHODIMP OleDoc_DataObj_DAdvise( <br>      LPDATAOBJECT        lpThis, <br>      FORMATETC FAR*      lpFormatetc, <br>      DWORD               advf, <br>      LPADVISESINK        lpAdvSink, <br>      DWORD FAR*          lpdwConnection <br>); <br>STDMETHODIMP OleDoc_DataObj_DUnadvise(LPDATAOBJECT lpThis,DWORD dwConnection); <br>STDMETHODIMP OleDoc_DataObj_EnumDAdvise( <br>      LPDATAOBJECT        lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>); <br> <br> <br>#ifdef USE_DRAGDROP <br> <br>/* OleDoc::IDropSource methods (functions) */ <br>STDMETHODIMP OleDoc_DropSource_QueryInterface( <br>   LPDROPSOURCE            lpThis, <br>   REFIID                  riid, <br>   LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_DropSource_AddRef( LPDROPSOURCE lpThis ); <br>STDMETHODIMP_(ULONG) OleDoc_DropSource_Release ( LPDROPSOURCE lpThis); <br>STDMETHODIMP    OleDoc_DropSource_QueryContinueDrag ( <br>   LPDROPSOURCE            lpThis, <br>   BOOL                    fEscapePressed, <br>   DWORD                   grfKeyState <br>); <br>STDMETHODIMP    OleDoc_DropSource_GiveFeedback ( <br>   LPDROPSOURCE            lpThis, <br>   DWORD                   dwEffect <br>); <br> <br>/* OleDoc::IDropTarget methods (functions) */ <br>STDMETHODIMP OleDoc_DropTarget_QueryInterface( <br>      LPDROPTARGET        lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleDoc_DropTarget_AddRef(LPDROPTARGET lpThis); <br>STDMETHODIMP_(ULONG) OleDoc_DropTarget_Release ( LPDROPTARGET lpThis); <br>STDMETHODIMP    OleDoc_DropTarget_DragEnter ( <br>   LPDROPTARGET            lpThis, <br>   LPDATAOBJECT            lpDataObj, <br>   DWORD                   grfKeyState, <br>   POINTL                  pointl, <br>   LPDWORD                 lpdwEffect <br>); <br>STDMETHODIMP    OleDoc_DropTarget_DragOver ( <br>   LPDROPTARGET            lpThis, <br>   DWORD                   grfKeyState, <br>   POINTL                  pointl, <br>   LPDWORD                 lpdwEffect <br>); <br>STDMETHODIMP    OleDoc_DropTarget_DragLeave ( LPDROPTARGET lpThis); <br>STDMETHODIMP    OleDoc_DropTarget_Drop ( <br>   LPDROPTARGET            lpThis, <br>   LPDATAOBJECT            lpDataObj, <br>   DWORD                   grfKeyState, <br>   POINTL                  pointl, <br>   LPDWORD                 lpdwEffect <br>); <br> <br>#endif  // USE_DRAGDROP <br> <br> <br>/************************************************************************* <br>** class APPCLASSFACTORY <br>**  APPCLASSFACTORY implements the IClassFactory interface. it <br>**    instantiates document instances of the correct type depending on <br>**    how the application is compiled (either ServerDoc or ContainerDoc <br>**    instances). by implementing this <br>**    interface in a seperate interface from the App object itself, it <br>**    is easier to manage when the IClassFactory should be <br>**    registered/revoked. when the OleApp object is first initialized <br>**    in OleApp_InitInstance an instance of APPCLASSFACTORY is created <br>**    and registered (CoRegisterClassObject called). when the App <br>**    object gets destroyed (in OleApp_Destroy) this APPCLASSFACTORY is <br>**    revoked (CoRevokeClassObject called) and released. the simple <br>**    fact that the IClassFactory is registered does not on its own keep <br>**    the application alive. <br>*************************************************************************/ <br> <br>typedef struct tagAPPCLASSFACTORY { <br>   IClassFactoryVtbl FAR*  m_lpVtbl; <br>   UINT                    m_cRef; <br>#if defined( _DEBUG ) <br>   LONG                    m_cSvrLock; // total count of LockServer locks <br>                              //  (for debugging purposes only) <br>#endif <br> } APPCLASSFACTORY, FAR* LPAPPCLASSFACTORY; <br> <br>/* PUBLIC FUNCTIONS */ <br>LPCLASSFACTORY WINAPI AppClassFactory_Create(void); <br> <br>/* interface IClassFactory implementation */ <br>STDMETHODIMP AppClassFactory_QueryInterface( <br>      LPCLASSFACTORY lpThis, REFIID riid, LPVOID FAR* ppvObj); <br>STDMETHODIMP_(ULONG) AppClassFactory_AddRef(LPCLASSFACTORY lpThis); <br>STDMETHODIMP_(ULONG) AppClassFactory_Release(LPCLASSFACTORY lpThis); <br>STDMETHODIMP AppClassFactory_CreateInstance ( <br>      LPCLASSFACTORY      lpThis, <br>      LPUNKNOWN           lpUnkOuter, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP AppClassFactory_LockServer ( <br>      LPCLASSFACTORY      lpThis, <br>      BOOL                fLock <br>); <br> <br> <br>/************************************************************************* <br>** class OLEAPP : OUTLINEAPP <br>**    OLEAPP is an extention to the base OUTLINEAPP object (structure) <br>**    that adds common OLE 2.0 functionality used by both the server <br>**    and container versions. This is an abstract class. You do not <br>**    instantiate an instance of OLEAPP directly but instead <br>**    instantiate one of its concrete subclasses: SERVERAPP or <br>**    CONTAINERAPP. There is one instance of an document application <br>**    object created per running application instance. This <br>**    object holds many fields that could otherwise be organized as <br>**    global variables. The OLEAPP class inherits all fields <br>**    from the OUTLINEAPP class. This inheritance is achieved by including a <br>**    member variable of type OUTLINEAPP as the first field in the OLEAPP <br>**    structure. Thus a pointer to a OLEAPP object can be cast to be <br>**    a pointer to a OUTLINEAPP object. <br>*************************************************************************/ <br> <br>typedef struct tagOLEAPP { <br>   OUTLINEAPP  m_OutlineApp;       // inherits all fields of OutlineApp <br>   ULONG       m_cRef;             // total ref count for app <br>   ULONG       m_cDoc;             // total count of open documents <br>   BOOL        m_fUserCtrl;        // does user control life-time of app? <br>   DWORD       m_dwRegClassFac;    // value returned by CoRegisterClassObject <br>   LPCLASSFACTORY m_lpClassFactory;// ptr to allocated ClassFactory instance <br>#if defined( USE_MSGFILTER ) <br>   LPMESSAGEFILTER m_lpMsgFilter;  // ptr to allocated MsgFilter instance <br>   MSGPENDINGPROC m_lpfnMsgPending;// ptr to msg pending callback function <br>#endif  // USE_MSGFILTER <br>   BOOL        m_fOleInitialized;  // was OleInitialize called <br>   BOOL        m_fOleStdInit;      // was OleStdInitialize called <br>   UINT        m_cModalDlgActive;  // count of modal dialogs up; 0 = no dlg. <br>   UINT        m_cfEmbedSource;    // OLE 2.0 clipboard format <br>   UINT        m_cfEmbeddedObject; // OLE 2.0 clipboard format <br>   UINT        m_cfLinkSource;     // OLE 2.0 clipboard format <br>   UINT        m_cfObjectDescriptor; // OLE 2.0 clipboard format <br>   UINT        m_cfLinkSrcDescriptor; // OLE 2.0 clipboard format <br>   UINT        m_cfFileName;       // std Windows clipboard format <br>   FORMATETC   m_arrDocGetFmts[MAXNOFMTS];  // fmts offered by copy &amp; GetData <br>   UINT        m_nDocGetFmts;      // no of fmtetc's for GetData <br> <br>   OLEUIPASTEENTRY m_arrPasteEntries[MAXNOFMTS];   // input for PasteSpl. <br>   int         m_nPasteEntries;                    // input for PasteSpl. <br>   UINT        m_arrLinkTypes[MAXNOLINKTYPES];     // input for PasteSpl. <br>   int         m_nLinkTypes;                       // input for PasteSpl. <br> <br>#if defined( USE_DRAGDROP ) <br>   int m_nDragDelay;       // time delay (in msec) before drag should start <br>   int m_nDragMinDist;     // min. distance (radius) before drag should start <br>   int m_nScrollDelay;     // time delay (in msec) before scroll should start <br>   int m_nScrollInset;     // Border inset distance to start drag scroll <br>   int m_nScrollInterval;  // scroll interval time (in msec) <br> <br>#if defined( IF_SPECIAL_DD_CURSORS_NEEDED ) <br>   // This would be used if the app wanted to have custom drag/drop cursors <br>   HCURSOR     m_hcursorDragNone; <br>   HCURSOR     m_hcursorDragCopy; <br>   HCURSOR     m_hcursorDragLink; <br>#endif  // IF_SPECIAL_DD_CURSORS_NEEDED <br>#endif  // USE_DRAGDROP <br> <br> <br>#if defined( OLE_CNTR ) <br>   HPALETTE    m_hStdPal;        // standard color palette for OLE <br>                             //  it is a good idea for containers <br>                             //  to use this standard palette <br>                             //  even if they do not use colors <br>                             //  themselves. this will allow <br>                             //  embedded object to get a good <br>                             //  distribution of colors when they <br>                             //  are being drawn by the container. <br>                             // <br>#endif <br> <br>   struct CAppUnknownImpl { <br>      IUnknownVtbl FAR*       lpVtbl; <br>      LPOLEAPP                lpOleApp; <br>      int                     cRef;   // interface specific ref count. <br>   } m_Unknown; <br> <br>} OLEAPP; <br> <br>/* ServerApp methods (functions) */ <br>BOOL OleApp_InitInstance(LPOLEAPP lpOleApp, HINSTANCE hInst, int nCmdShow); <br>void OleApp_TerminateApplication(LPOLEAPP lpOleApp); <br>BOOL OleApp_ParseCmdLine(LPOLEAPP lpOleApp, LPSTR lpszCmdLine, int nCmdShow); <br>void OleApp_Destroy(LPOLEAPP lpOleApp); <br>BOOL OleApp_CloseAllDocsAndExitCommand( <br>      LPOLEAPP            lpOleApp, <br>      BOOL                fForceEndSession <br>); <br>void OleApp_ShowWindow(LPOLEAPP lpOleApp, BOOL fGiveUserCtrl); <br>void OleApp_HideWindow(LPOLEAPP lpOleApp); <br>void OleApp_HideIfNoReasonToStayVisible(LPOLEAPP lpOleApp); <br>void OleApp_DocLockApp(LPOLEAPP lpOleApp); <br>void OleApp_DocUnlockApp(LPOLEAPP lpOleApp, LPOUTLINEDOC lpOutlineDoc); <br>HRESULT OleApp_Lock(LPOLEAPP lpOleApp, BOOL fLock, BOOL fLastUnlockReleases); <br>ULONG OleApp_AddRef(LPOLEAPP lpOleApp); <br>ULONG OleApp_Release (LPOLEAPP lpOleApp); <br>HRESULT OleApp_QueryInterface ( <br>      LPOLEAPP                lpOleApp, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpUnk <br>); <br>void OleApp_RejectInComingCalls(LPOLEAPP lpOleApp, BOOL fReject); <br>void OleApp_DisableBusyDialogs( <br>      LPOLEAPP        lpOleApp, <br>      BOOL FAR*       lpfPrevBusyEnable, <br>      BOOL FAR*       lpfPrevNREnable <br>); <br>void OleApp_EnableBusyDialogs( <br>      LPOLEAPP        lpOleApp, <br>      BOOL            fPrevBusyEnable, <br>      BOOL            fPrevNREnable <br>); <br>void OleApp_PreModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpActiveOleDoc); <br>void OleApp_PostModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpActiveOleDoc); <br>BOOL OleApp_InitVtbls (LPOLEAPP lpOleApp); <br>void OleApp_InitMenu( <br>      LPOLEAPP                lpOleApp, <br>      LPOLEDOC                lpOleDoc, <br>      HMENU                   hMenu <br>); <br>void OleApp_UpdateEditMenu( <br>      LPOLEAPP                lpOleApp, <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      HMENU                   hMenuEdit <br>); <br>BOOL OleApp_RegisterClassFactory(LPOLEAPP lpOleApp); <br>void OleApp_RevokeClassFactory(LPOLEAPP lpOleApp); <br> <br>#if defined( USE_MSGFILTER ) <br>BOOL OleApp_RegisterMessageFilter(LPOLEAPP lpOleApp); </code></pre>
<p>
</p>
<pre><code>void OleApp_RevokeMessageFilter(LPOLEAPP lpOleApp); <br>BOOL FAR PASCAL EXPORT MessagePendingProc(MSG FAR *lpMsg); <br>#endif  // USE_MSGFILTER <br> <br>void OleApp_FlushClipboard(LPOLEAPP lpOleApp); <br>void OleApp_NewCommand(LPOLEAPP lpOleApp); <br>void OleApp_OpenCommand(LPOLEAPP lpOleApp); <br> <br>#if defined( OLE_CNTR ) <br>LRESULT OleApp_QueryNewPalette(LPOLEAPP lpOleApp); <br>#endif // OLE_CNTR <br> <br>LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground); <br> <br> <br>/* OleApp::IUnknown methods (functions) */ <br>STDMETHODIMP OleApp_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) OleApp_Unk_AddRef(LPUNKNOWN lpThis); <br>STDMETHODIMP_(ULONG) OleApp_Unk_Release (LPUNKNOWN lpThis); <br> <br> <br>/* Function prototypes in debug.c */ <br>void InstallMessageFilterCommand(void); <br>void RejectIncomingCommand(void); <br> <br> <br>#if defined( OLE_SERVER ) <br>#include "svroutl.h" <br>#endif <br>#if defined( OLE_CNTR ) <br>#include "cntroutl.h" <br>#endif <br> <br>#endif // _OLEOUTL_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
