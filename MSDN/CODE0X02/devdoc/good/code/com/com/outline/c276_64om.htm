<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HEADING.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context286"></a>HEADING.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    heading.c <br>** <br>**    This file contains functions and support for OutlineDoc's row and <br>**    column headings. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br> <br>BOOL Heading_Create(LPHEADING lphead, HWND hWndParent, HINSTANCE hInst) <br>{ <br>   HDC         hDC; <br>   TEXTMETRIC  tm; <br> <br>   if (!lphead || !hWndParent || !hInst) <br>      return FALSE; <br> <br>   hDC = GetDC(hWndParent); <br>   if (!hDC) <br>      return FALSE; <br> <br>   if (!GetTextMetrics(hDC, (TEXTMETRIC FAR*)&amp;tm)) <br>      return FALSE; <br>   lphead-&gt;m_colhead.m_uHeight = tm.tmHeight; <br>   lphead-&gt;m_rowhead.m_uWidth = 4 * tm.tmAveCharWidth; <br>   lphead-&gt;m_fShow = TRUE; <br> <br>   ReleaseDC(hWndParent, hDC); <br> <br>   lphead-&gt;m_hfont = CreateFont( <br>         tm.tmHeight, <br>         0,0,0,0,0,0,0,0, <br>         OUT_TT_PRECIS,      // use TrueType <br>         CLIP_DEFAULT_PRECIS, <br>         DEFAULT_QUALITY, <br>         DEFAULT_PITCH | FF_DONTCARE, <br>         HEADING_FONT <br>   ); <br> <br>   if (!lphead-&gt;m_hfont) <br>      return FALSE; <br> <br>   lphead-&gt;m_colhead.m_hWnd = CreateWindow( <br>         "listbox", <br>         "Column Heading", <br>         WS_VISIBLE | WS_CHILD | WS_DISABLED | LBS_OWNERDRAWVARIABLE | <br>               LBS_NOINTEGRALHEIGHT, <br>         0,0,0,0,        // any values <br>         hWndParent, <br>         (HMENU)IDC_COLHEADING, <br>         hInst, <br>         NULL); <br> <br>   if (!lphead-&gt;m_colhead.m_hWnd) <br>      return FALSE; <br> <br>   // add a dummy line to get WM_DRAWITEM message <br>   SendMessage(lphead-&gt;m_colhead.m_hWnd, LB_ADDSTRING, 0, <br>         MAKELPARAM(lphead-&gt;m_colhead.m_uHeight,0)); <br> <br>   lphead-&gt;m_rowhead.m_hWnd = CreateWindow( <br>         "listbox", <br>         "Row Heading", <br>         WS_VISIBLE | WS_CHILD | WS_DISABLED | LBS_OWNERDRAWVARIABLE, <br>         0,0,0,0,        // any values <br>         hWndParent, <br>         (HMENU)IDC_ROWHEADING, <br>         hInst, <br>         NULL); <br> <br>   if (!lphead-&gt;m_rowhead.m_hWnd) <br>      return FALSE; <br> <br>   SendMessage(lphead-&gt;m_rowhead.m_hWnd, LB_ADDSTRING, 0, <br>         MAKELPARAM(lphead-&gt;m_colhead.m_uHeight,0)); <br> <br>   lphead-&gt;m_rowhead.m_WndProc = <br>         (FARPROC) GetWindowLong(lphead-&gt;m_rowhead.m_hWnd, GWL_WNDPROC ); <br>   SetWindowLong(lphead-&gt;m_rowhead.m_hWnd, GWL_WNDPROC, <br>         (LONG) RowHeadWndProc); <br> <br>   lphead-&gt;m_hwndButton = CreateWindow( <br>         "button", <br>         NULL, <br>         WS_VISIBLE | WS_CHILD, <br>         0,0,0,0,        // any values <br>         hWndParent, <br>         (HMENU)IDC_BUTTON, <br>         hInst, <br>         NULL); <br> <br>   if (!lphead-&gt;m_hwndButton) <br>      return FALSE; <br> <br>   return TRUE; <br>} <br> <br> <br>void Heading_Destroy(LPHEADING lphead) <br>{ <br>   if (!lphead) <br>      return; <br> <br>   if (IsWindow(lphead-&gt;m_colhead.m_hWnd)) { <br>      DestroyWindow(lphead-&gt;m_colhead.m_hWnd); <br>      lphead-&gt;m_colhead.m_hWnd = NULL; <br>   } <br>   if (IsWindow(lphead-&gt;m_rowhead.m_hWnd)) { <br>      DestroyWindow(lphead-&gt;m_rowhead.m_hWnd); <br>      lphead-&gt;m_rowhead.m_hWnd = NULL; <br>   } <br>   if (IsWindow(lphead-&gt;m_hwndButton)) { <br>      DestroyWindow(lphead-&gt;m_hwndButton); <br>      lphead-&gt;m_hwndButton = NULL; <br>   } <br>#ifdef WIN32 <br>   if (GetObjectType(lphead-&gt;m_hfont)) { <br>#else <br>   if (IsGDIObject(lphead-&gt;m_hfont)) { <br>#endif <br>      DeleteObject(lphead-&gt;m_hfont); <br>      lphead-&gt;m_hfont = NULL; <br>   } <br> <br>} <br> <br> <br>void Heading_Move(LPHEADING lphead, HWND hwndDoc, LPSCALEFACTOR lpscale) <br>{ <br>   int nOffsetX; <br>   int nOffsetY; <br>   RECT rcDoc; <br> <br>   if (!lphead || !hwndDoc || !lpscale) <br>      return; <br> <br>   if (!lphead-&gt;m_fShow) <br>      return; <br> <br>   nOffsetX = (int) Heading_RH_GetWidth(lphead, lpscale); <br>   nOffsetY = (int) Heading_CH_GetHeight(lphead, lpscale); <br>   GetClientRect(hwndDoc, (LPRECT)&amp;rcDoc); <br> <br>   MoveWindow(lphead-&gt;m_hwndButton, 0, 0, nOffsetX, nOffsetY, TRUE); <br> <br>   MoveWindow( <br>         lphead-&gt;m_colhead.m_hWnd, <br>         nOffsetX, 0, <br>         rcDoc.right-rcDoc.left-nOffsetX, nOffsetY, <br>         TRUE <br>   ); <br> <br>   MoveWindow(lphead-&gt;m_rowhead.m_hWnd, 0, nOffsetY, nOffsetX, <br>         rcDoc.bottom-rcDoc.top-nOffsetY, TRUE); <br>} <br> <br> <br>void Heading_Show(LPHEADING lphead, BOOL fShow) <br>{ <br>   int nCmdShow; <br> <br>   if (!lphead) <br>      return; <br> <br>   lphead-&gt;m_fShow = fShow; <br>   nCmdShow = fShow ? SW_SHOW : SW_HIDE; <br> <br>   ShowWindow(lphead-&gt;m_hwndButton, nCmdShow); <br>   ShowWindow(lphead-&gt;m_colhead.m_hWnd, nCmdShow); <br>   ShowWindow(lphead-&gt;m_rowhead.m_hWnd, nCmdShow); <br>} <br> <br> <br>void Heading_ReScale(LPHEADING lphead, LPSCALEFACTOR lpscale) <br>{ <br>   UINT uHeight; <br> <br>   if (!lphead || !lpscale) <br>      return; <br> <br>   // Row heading is scaled with the LineList_Rescale. So, only <br>   // Column heading needed to be scaled here. <br>   uHeight = (UINT)(lphead-&gt;m_colhead.m_uHeight * lpscale-&gt;dwSyN / <br>         lpscale-&gt;dwSyD); <br>   SendMessage(lphead-&gt;m_colhead.m_hWnd, LB_SETITEMHEIGHT, 0, <br>         MAKELPARAM(uHeight, 0)); <br>} <br> <br> <br>void Heading_CH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis, LPRECT lprcScreen, LPRECT lprcObject) <br>{ <br>   HPEN        hpenOld; <br>   HPEN        hpen; <br>   HBRUSH      hbr; <br>   HFONT       hfOld; <br>   int         nTabInPix; <br>   char        letter; <br>   int         i; <br>   int         nOldMapMode; <br>   RECT        rcWindowOld; <br>   RECT        rcViewportOld; <br>   POINT    point; <br> <br>   if (!lpdis || !lphead) <br>      return; <br> <br>   hbr = GetStockObject(LTGRAY_BRUSH); <br>   FillRect(lpdis-&gt;hDC, (LPRECT)&amp;lpdis-&gt;rcItem, hbr); <br> <br>   nOldMapMode = SetDCToAnisotropic(lpdis-&gt;hDC, lprcScreen, lprcObject, <br>         (LPRECT)&amp;rcWindowOld, (LPRECT)&amp;rcViewportOld); <br> <br>   hfOld = SelectObject(lpdis-&gt;hDC, lphead-&gt;m_hfont); <br>   hpen = GetStockObject(BLACK_PEN); <br>   hpenOld = SelectObject(lpdis-&gt;hDC, hpen); <br> <br>   nTabInPix = XformWidthInHimetricToPixels(lpdis-&gt;hDC, TABWIDTH); <br>   SetBkMode(lpdis-&gt;hDC, TRANSPARENT); <br> <br>   letter = COLUMN_LETTER; <br>   MoveToEx(lpdis-&gt;hDC, lprcObject-&gt;left, lprcObject-&gt;bottom,&amp;point); <br>   LineTo(lpdis-&gt;hDC, lprcObject-&gt;left, lprcObject-&gt;top); <br> <br>   for (i = 0; i &lt; COLUMN; i++) { <br>      lprcObject-&gt;right = lprcObject-&gt;left + nTabInPix; <br>      DrawText(lpdis-&gt;hDC, (LPCSTR)&amp;letter, 1, lprcObject, <br>            DT_SINGLELINE | DT_CENTER | DT_VCENTER); <br>      MoveToEx(lpdis-&gt;hDC, lprcObject-&gt;right, lprcObject-&gt;bottom, &amp;point); <br>      LineTo(lpdis-&gt;hDC, lprcObject-&gt;right, lprcObject-&gt;top); <br> <br>      letter++; <br>      lprcObject-&gt;left += nTabInPix; <br>   } <br> <br>   SelectObject(lpdis-&gt;hDC, hpenOld); <br>   SelectObject(lpdis-&gt;hDC, hfOld); <br> <br>   ResetOrigDC(lpdis-&gt;hDC, nOldMapMode, (LPRECT)&amp;rcWindowOld, <br>         (LPRECT)&amp;rcViewportOld); <br>} <br> <br> <br>void Heading_CH_SetHorizontalExtent(LPHEADING lphead, HWND hwndListBox) <br>{ <br>   RECT rcLL; <br>   RECT rcCH; <br>   int  nLLWidth; <br>   int  nCHWidth; <br>   int  nHorizExtent; <br> <br>   if (!lphead || !hwndListBox) <br>      return; <br> <br>   nHorizExtent=(int)SendMessage(hwndListBox, LB_GETHORIZONTALEXTENT, 0, 0L); <br>   GetClientRect(hwndListBox, (LPRECT)&amp;rcLL); <br>   GetClientRect(lphead-&gt;m_colhead.m_hWnd, (LPRECT)&amp;rcCH); <br> <br>   nLLWidth = rcLL.right - rcLL.left; <br>   nCHWidth = rcCH.right - rcCH.left; <br>   nHorizExtent += nCHWidth - nLLWidth; <br> <br>   SendMessage(lphead-&gt;m_colhead.m_hWnd, LB_SETHORIZONTALEXTENT, <br>         nHorizExtent, 0L); <br>} <br> <br> <br>UINT Heading_CH_GetHeight(LPHEADING lphead, LPSCALEFACTOR lpscale) <br>{ <br>   if (!lphead || !lpscale) <br>      return 0; <br> <br>   if (lphead-&gt;m_fShow) <br>      return (UINT)(lphead-&gt;m_colhead.m_uHeight * lpscale-&gt;dwSyN / <br>            lpscale-&gt;dwSyD); <br>   else <br>      return 0; <br>} <br> <br> <br>LRESULT Heading_CH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   if (!lphead) <br>      return 0; <br> <br>   if (lphead-&gt;m_colhead.m_hWnd) <br>      return SendMessage(lphead-&gt;m_colhead.m_hWnd, msg, wParam, lParam); <br>} <br> <br> <br>void Heading_CH_ForceRedraw(LPHEADING lphead, BOOL fErase) <br>{ <br>   if (!lphead) <br>      return; <br> <br>   InvalidateRect(lphead-&gt;m_colhead.m_hWnd, NULL, fErase); <br>} <br> <br>void Heading_RH_ForceRedraw(LPHEADING lphead, BOOL fErase) <br>{ <br>   if (!lphead) <br>      return; <br> <br>   InvalidateRect(lphead-&gt;m_rowhead.m_hWnd, NULL, fErase); <br>} <br> <br>void Heading_RH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis) <br>{ <br>   char        cBuf[5]; <br>   HPEN        hpenOld; <br>   HPEN        hpen; <br>   HBRUSH      hbrOld; <br>   HBRUSH      hbr; <br>   HFONT       hfOld; <br>   RECT        rc; <br>   RECT        rcWindowOld; <br>   RECT        rcViewportOld; <br>   int         nMapModeOld; <br> <br>   if (!lpdis || !lphead) <br>      return; <br> <br>   lpdis-&gt;rcItem; <br> <br>   rc.left = 0; <br>   rc.bottom = 0; <br>   rc.top = (int)lpdis-&gt;itemData; <br>   rc.right = lphead-&gt;m_rowhead.m_uWidth; <br> <br>   nMapModeOld = SetDCToAnisotropic(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, &amp;rc, <br>         (LPRECT)&amp;rcWindowOld, (LPRECT)&amp;rcViewportOld); <br> <br>   hpen = GetStockObject(BLACK_PEN); <br>   hpenOld = SelectObject(lpdis-&gt;hDC, hpen); <br>   hbr = GetStockObject(LTGRAY_BRUSH); <br>   hbrOld = SelectObject(lpdis-&gt;hDC, hbr); <br> <br>   Rectangle(lpdis-&gt;hDC, rc.left, rc.top, rc.right, <br>         rc.bottom); <br> <br>   hfOld = SelectObject(lpdis-&gt;hDC, lphead-&gt;m_hfont); <br> <br>   SetBkMode(lpdis-&gt;hDC, TRANSPARENT); <br> <br>   wsprintf(cBuf, "%d", lpdis-&gt;itemID + 1); <br> <br>   DrawText(lpdis-&gt;hDC, (LPSTR)cBuf, lstrlen(cBuf), (LPRECT)&amp;rc, <br>         DT_SINGLELINE | DT_CENTER | DT_VCENTER); <br> <br>   SelectObject(lpdis-&gt;hDC, hfOld); <br> <br>   SelectObject(lpdis-&gt;hDC, hpenOld); <br>   SelectObject(lpdis-&gt;hDC, hbrOld); <br> <br>   ResetOrigDC(lpdis-&gt;hDC, nMapModeOld, (LPRECT)&amp;rcWindowOld, <br>         (LPRECT)&amp;rcViewportOld); <br>} <br> <br>LRESULT Heading_RH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   if (!lphead) <br>      return 0; <br> <br>   if (lphead-&gt;m_rowhead.m_hWnd) <br>      return SendMessage(lphead-&gt;m_rowhead.m_hWnd, msg, wParam, lParam); <br>} <br> <br> <br>UINT Heading_RH_GetWidth(LPHEADING lphead, LPSCALEFACTOR lpscale) <br>{ <br>   if (!lphead || !lpscale) <br>      return 0; <br> <br>   if (lphead-&gt;m_fShow) <br>      return (UINT)(lphead-&gt;m_rowhead.m_uWidth * lpscale-&gt;dwSxN / <br>            lpscale-&gt;dwSxD); <br>   else <br>      return 0; <br>} <br> <br> <br>void Heading_RH_Scroll(LPHEADING lphead, HWND hwndListBox) <br>{ <br>   int nTopLL; <br>   int nTopRH; <br> <br>   if (!lphead || !hwndListBox) <br>      return; <br> <br>   nTopLL = (int)SendMessage(hwndListBox, LB_GETTOPINDEX, 0, 0L); <br>   nTopRH = (int)SendMessage( <br>         lphead-&gt;m_rowhead.m_hWnd, LB_GETTOPINDEX, 0, 0L); <br> <br>   if (nTopLL != nTopRH) <br>      SendMessage( <br>            lphead-&gt;m_rowhead.m_hWnd,LB_SETTOPINDEX,(WPARAM)nTopLL,0L); <br>} <br> <br> <br>LRESULT FAR PASCAL RowHeadWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   HWND     hwndParent = GetParent (hWnd); <br>   LPOUTLINEDOC lpDoc = (LPOUTLINEDOC)GetWindowLong(hwndParent, 0); <br>   LPHEADING lphead = OutlineDoc_GetHeading(lpDoc); <br> <br>   switch (Message) { <br>      case WM_PAINT: <br>      { <br>         LPLINELIST lpLL = OutlineDoc_GetLineList(lpDoc); <br>         PAINTSTRUCT ps; <br> <br>         // If there is no line in listbox, trap the message and draw the <br>         // background gray. Without this, the background will be painted <br>         // as default color. <br>         if (!LineList_GetCount(lpLL)) { <br>            BeginPaint(hWnd, &amp;ps); <br>            EndPaint(hWnd, &amp;ps); <br>            return 0; <br>         } <br> <br>         break; <br>      } <br> <br>      case WM_ERASEBKGND: <br>      { <br>         HDC hDC = (HDC)wParam; <br>         RECT rc; <br> <br>         GetClientRect(hWnd, (LPRECT)&amp;rc); <br>         FillRect(hDC, (LPRECT)&amp;rc, GetStockObject(GRAY_BRUSH)); <br> <br>         return 1; <br>      } <br>   } <br> <br>   return CallWindowProc( <br>         (WNDPROC)lphead-&gt;m_rowhead.m_WndProc, <br>         hWnd, <br>         Message, <br>         wParam, <br>         lParam <br>   ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
