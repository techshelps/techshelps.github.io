<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLTXTL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context306"></a>OUTLTXTL.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outltxtl.c <br>** <br>**    This file contains TextLine methods and related support functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br> <br>/* TextLine_Create <br> * --------------- <br> * <br> *      Create a text line object and return the pointer <br> */ <br>LPTEXTLINE TextLine_Create(HDC hDC, UINT nTab, LPSTR lpszText) <br>{ <br>        LPTEXTLINE lpTextLine; <br> <br>        lpTextLine=(LPTEXTLINE) New((DWORD)sizeof(TEXTLINE)); <br>        if (lpTextLine == NULL) { <br>                OleDbgAssertSz(lpTextLine!=NULL,"Error allocating TextLine"); <br>                return NULL; <br>        } <br> <br>        TextLine_Init(lpTextLine, nTab, hDC); <br> <br>        if (lpszText) { <br>                lpTextLine-&gt;m_nLength = lstrlen(lpszText); <br>                lstrcpy((LPSTR)lpTextLine-&gt;m_szText, lpszText); <br>        } else { <br>                lpTextLine-&gt;m_nLength = 0; <br>                lpTextLine-&gt;m_szText[0] = '\0'; <br>        } <br> <br>        TextLine_CalcExtents(lpTextLine, hDC); <br> <br>        return(lpTextLine); <br>} <br> <br> <br>/* TextLine_Init <br> * ------------- <br> * <br> *      Calculate the width/height of a text line object. <br> */ <br>void TextLine_Init(LPTEXTLINE lpTextLine, int nTab, HDC hDC) <br>{ <br>        Line_Init((LPLINE)lpTextLine, nTab, hDC);   // init the base class fields <br> <br>        ((LPLINE)lpTextLine)-&gt;m_lineType = TEXTLINETYPE; <br>        lpTextLine-&gt;m_nLength = 0; <br>        lpTextLine-&gt;m_szText[0] = '\0'; <br>} <br> <br> <br>/* TextLine_Delete <br> * --------------- <br> * <br> *      Delete the TextLine structure <br> */ <br>void TextLine_Delete(LPTEXTLINE lpTextLine) <br>{ <br>        Delete((LPVOID)lpTextLine); <br>} <br> <br> <br>/* TextLine_Edit <br> * ------------- <br> * <br> *      Edit the text line object. <br> * <br> *      Returns TRUE if line was changed <br> *              FALSE if the line was NOT changed <br> */ <br>BOOL TextLine_Edit(LPTEXTLINE lpLine, HWND hWndDoc, HDC hDC) <br>{ <br>#if defined( USE_FRAMETOOLS ) <br>        LPFRAMETOOLS lptb = OutlineApp_GetFrameTools(g_lpApp); <br>#endif <br>        BOOL fStatus = FALSE; <br> <br>#if defined( USE_FRAMETOOLS ) <br>        FrameTools_FB_GetEditText(lptb, lpLine-&gt;m_szText, sizeof(lpLine-&gt;m_szText)); <br>#else <br>        if (! InputTextDlg(hWndDoc, lpLine-&gt;m_szText, "Edit Line")) <br>                return FALSE; <br>#endif <br> <br>        lpLine-&gt;m_nLength = lstrlen(lpLine-&gt;m_szText); <br>        TextLine_CalcExtents(lpLine, hDC); <br>        fStatus = TRUE; <br> <br>        return fStatus; <br>} <br> <br> <br>/* TextLine_CalcExtents <br> * -------------------- <br> * <br> *      Calculate the width/height of a text line object. <br> */ <br>void TextLine_CalcExtents(LPTEXTLINE lpTextLine, HDC hDC) <br>{ <br>        SIZE size; <br>        LPLINE lpLine = (LPLINE)lpTextLine; <br> <br>        if (lpTextLine-&gt;m_nLength) { <br>                GetTextExtentPoint(hDC, lpTextLine-&gt;m_szText, <br>                                                        lpTextLine-&gt;m_nLength, &amp;size); <br>                lpLine-&gt;m_nWidthInHimetric=size.cx; <br>                lpLine-&gt;m_nHeightInHimetric=size.cy; <br>        } else { <br>                // we still need to calculate proper height even for NULL string <br>                TEXTMETRIC tm; <br>                GetTextMetrics(hDC, &amp;tm); <br> <br>                // required to set height <br>                lpLine-&gt;m_nHeightInHimetric = tm.tmHeight; <br>                lpLine-&gt;m_nWidthInHimetric = 0; <br>        } <br> <br>#if defined( _DEBUG ) <br>        { <br>                RECT rc; <br>                rc.left = 0; <br>                rc.top = 0; <br>                rc.right = XformWidthInHimetricToPixels(hDC, <br>                                lpLine-&gt;m_nWidthInHimetric); <br>                rc.bottom = XformHeightInHimetricToPixels(hDC, <br>                                lpLine-&gt;m_nHeightInHimetric); <br> <br>                OleDbgOutRect3("TextLine_CalcExtents", (LPRECT)&amp;rc); <br>        } <br>#endif <br>} <br> <br> <br> <br>/* TextLine_SetHeightInHimetric <br> * ---------------------------- <br> * <br> *      Set the height of a textline object. <br> */ <br>void TextLine_SetHeightInHimetric(LPTEXTLINE lpTextLine, int nHeight) <br>{ <br>        if (!lpTextLine) <br>                return; <br> <br>        ((LPLINE)lpTextLine)-&gt;m_nHeightInHimetric = nHeight; <br>} <br> <br> <br> <br>/* TextLine_GetTextLen <br> * ------------------- <br> * <br> * Return length of string of the TextLine (not considering the tab level). <br> */ <br>int TextLine_GetTextLen(LPTEXTLINE lpTextLine) <br>{ <br>        return lstrlen((LPSTR)lpTextLine-&gt;m_szText); <br>} <br> <br> <br>/* TextLine_GetTextData <br> * -------------------- <br> * <br> * Return the string of the TextLine (not considering the tab level). <br> */ <br>void TextLine_GetTextData(LPTEXTLINE lpTextLine, LPSTR lpszBuf) <br>{ <br>        lstrcpy(lpszBuf, (LPSTR)lpTextLine-&gt;m_szText); <br>} <br> <br> <br>/* TextLine_GetOutlineData <br> * ----------------------- <br> * <br> * Return the CF_OUTLINE format data for the TextLine. <br> */ <br>BOOL TextLine_GetOutlineData(LPTEXTLINE lpTextLine, LPTEXTLINE lpBuf) <br>{ <br>        TextLine_Copy((LPTEXTLINE)lpTextLine, lpBuf); <br>        return TRUE; <br>} <br> <br> <br>/* TextLine_Draw <br> * ------------- <br> * <br> *      Draw a text line object on a DC. <br> * Parameters: <br> *      hDC     - DC to which the line will be drawn <br> *      lpRect  - the object rectangle in logical coordinates <br> *      lpRectWBounds - bounding rect of the metafile underneath hDC <br> *                      (NULL if hDC is not a metafile DC) <br> *                      this is used by ContainerLine_Draw to draw the OLE obj <br> *      fHighlight    - TRUE use selection highlight text color <br> */ <br>void TextLine_Draw( <br>                LPTEXTLINE  lpTextLine, <br>                HDC         hDC, <br>                LPRECT      lpRect, <br>                LPRECT      lpRectWBounds, <br>                BOOL        fHighlight <br>) <br>{ <br>        RECT rc; <br>        int nBkMode; <br>        COLORREF clrefOld; <br> <br>        if (!lpTextLine) <br>                return; <br> <br>        rc = *lpRect; <br>        rc.left += ((LPLINE)lpTextLine)-&gt;m_nTabWidthInHimetric; <br>        rc.right += ((LPLINE)lpTextLine)-&gt;m_nTabWidthInHimetric; <br> <br>        nBkMode = SetBkMode(hDC, TRANSPARENT); <br> <br>        if (fHighlight) { <br>                /*Get proper txt colors */ <br>                clrefOld = SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT)); <br>        } <br>        else { <br>                clrefOld = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        } <br> <br>        ExtTextOut( <br>                        hDC, <br>                        rc.left, <br>                        rc.top, <br>                        ETO_CLIPPED, <br>                        (LPRECT)&amp;rc, <br>                        lpTextLine-&gt;m_szText, <br>                        lpTextLine-&gt;m_nLength, <br>                        (LPINT) NULL /* default char spacing */ <br>        ); <br> <br>        SetTextColor(hDC, clrefOld); <br>        SetBkMode(hDC, nBkMode); <br>} <br> <br>/* TextLine_DrawSelHilight <br> * ----------------------- <br> * <br> *      Handles selection of textline <br> */ <br>void TextLine_DrawSelHilight(LPTEXTLINE lpTextLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState) <br>{ <br>        if (itemAction &amp; ODA_SELECT) { <br>                // check if there is a selection state change, ==&gt; invert rect <br>                if (itemState &amp; ODS_SELECTED) { <br>                        if (!((LPLINE)lpTextLine)-&gt;m_fSelected) { <br>                                ((LPLINE)lpTextLine)-&gt;m_fSelected = TRUE; <br>                                InvertRect(hDC, (LPRECT)lpRect); <br>                        } <br>                } else { <br>                        if (((LPLINE)lpTextLine)-&gt;m_fSelected) { <br>                                ((LPLINE)lpTextLine)-&gt;m_fSelected = FALSE; <br>                                InvertRect(hDC, lpRect); <br>                        } <br>                } <br>        } else if (itemAction &amp; ODA_DRAWENTIRE) { <br>                ((LPLINE)lpTextLine)-&gt;m_fSelected=((itemState &amp; ODS_SELECTED) ? TRUE : FALSE); <br>                InvertRect(hDC, lpRect); <br>        } <br>} <br> <br>/* TextLine_Copy <br> * ------------- <br> * <br> *      Duplicate a textline <br> */ <br>BOOL TextLine_Copy(LPTEXTLINE lpSrcLine, LPTEXTLINE lpDestLine) <br>{ <br>        _fmemcpy(lpDestLine, lpSrcLine, sizeof(TEXTLINE)); <br>        return TRUE; <br>} <br> <br> <br>/* TextLine_CopyToDoc <br> * ------------------ <br> * <br> *      Copy a textline to another Document (usually ClipboardDoc) <br> */ <br>BOOL TextLine_CopyToDoc(LPTEXTLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex) <br>{ <br>        LPTEXTLINE  lpDestLine; <br>        BOOL        fStatus = FALSE; <br> <br>        lpDestLine = (LPTEXTLINE) New((DWORD)sizeof(TEXTLINE)); <br>        if (lpDestLine == NULL) { <br>                OleDbgAssertSz(lpDestLine!=NULL,"Error allocating TextLine"); <br>                return FALSE; <br>        } <br> <br>        if (TextLine_Copy(lpSrcLine, lpDestLine)) { <br>                OutlineDoc_AddLine(lpDestDoc, (LPLINE)lpDestLine, nIndex); <br>                fStatus = TRUE; <br>        } <br> <br>        return fStatus; <br>} <br> <br> <br>/* TextLine_SaveToStg <br> * ------------------ <br> * <br> *      Save a textline into a storage <br> * <br> *      Return TRUE if successful, FALSE otherwise <br> */ <br>BOOL TextLine_SaveToStm(LPTEXTLINE lpTextLine, LPSTREAM lpLLStm) <br>{ <br>        HRESULT hrErr; <br>        ULONG nWritten; <br>        USHORT nLengthOnDisk; <br> <br>        nLengthOnDisk = (USHORT) lpTextLine-&gt;m_nLength; <br> <br>        hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>                        lpLLStm, <br>                        (LPVOID)&amp;nLengthOnDisk, <br>                        sizeof(nLengthOnDisk), <br>                        &amp;nWritten <br>        ); <br>        if (hrErr != NOERROR) { <br>                OleDbgOutHResult("Write TextLine data (1) returned", hrErr); <br>                return FALSE; <br>    } <br> <br>        hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>                        lpLLStm, <br>                        (LPVOID)lpTextLine-&gt;m_szText, <br>                        lpTextLine-&gt;m_nLength, <br>                        &amp;nWritten <br>        ); <br>        if (hrErr != NOERROR) { <br>                OleDbgOutHResult("Write TextLine data (2) returned", hrErr); <br>                return FALSE; <br>    } <br> <br>        return TRUE; <br>} <br> <br> <br>/* TextLine_LoadFromStg <br> * -------------------- <br> * <br> *      Load a textline from storage <br> */ <br>LPLINE TextLine_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc) <br>{ <br>        HRESULT hrErr; <br>        ULONG nRead; <br>        LPTEXTLINE lpTextLine; <br>        USHORT nLengthOnDisk; <br> <br>        lpTextLine=(LPTEXTLINE) New((DWORD)sizeof(TEXTLINE)); <br>        if (lpTextLine == NULL) { <br>                OleDbgAssertSz(lpTextLine!=NULL,"Error allocating TextLine"); <br>                return NULL; <br>        } <br> <br>        TextLine_Init(lpTextLine, 0, NULL); <br> <br>        hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>                        lpLLStm, <br>                        (LPVOID)&amp;nLengthOnDisk, <br>                        sizeof(nLengthOnDisk), <br>                        &amp;nRead <br>        ); <br>        if (hrErr != NOERROR) { <br>                OleDbgOutHResult("Read TextLine data (1) returned", hrErr); <br>                return NULL; <br>    } <br> <br>        lpTextLine-&gt;m_nLength = (UINT) nLengthOnDisk; <br>        OleDbgAssert(lpTextLine-&gt;m_nLength &lt; sizeof(lpTextLine-&gt;m_szText)); <br> <br>        hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>                        lpLLStm, <br>                        (LPVOID)&amp;lpTextLine-&gt;m_szText, <br>                        lpTextLine-&gt;m_nLength, <br>                        &amp;nRead <br>        ); <br>        if (hrErr != NOERROR) { <br>                OleDbgOutHResult("Read TextLine data (1) returned", hrErr); <br>                return NULL; <br>    } <br> <br>        lpTextLine-&gt;m_szText[lpTextLine-&gt;m_nLength] = '\0'; // add str terminator <br> <br>        return (LPLINE)lpTextLine; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
