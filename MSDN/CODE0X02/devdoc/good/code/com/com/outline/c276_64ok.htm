<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRAMETLS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context284"></a>FRAMETLS.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Server Sample Code <br>** <br>**    frametls.c <br>** <br>**    This file contains all FrameTools methods and related support <br>**    functions. The FrameTools object is an encapsulation of the apps <br>**    formula bar and button bar. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>/* private function prototype */ <br>static void Bar_Move(LPBAR lpbar, LPRECT lprcClient, LPRECT lprcPopup); <br>static void FB_ResizeEdit(LPBAR lpbar); <br> <br>extern LPOUTLINEAPP g_lpApp; <br>extern RECT g_rectNull; <br> <br>/* <br> * FrameToolsRegisterClass <br> * <br> * Purpose: <br> *  Register the popup toolbar window class <br> * <br> * Parameters: <br> *  hInst           Process instance <br> * <br> * Return Value: <br> *  TRUE            if successful <br> *  FALSE           if failed <br> * <br> */ <br>BOOL FrameToolsRegisterClass(HINSTANCE hInst) <br>{ <br>        WNDCLASS wc; <br> <br>        // Register Tool Palette Class <br>        wc.style = CS_BYTEALIGNWINDOW; <br>        wc.lpfnWndProc = FrameToolsWndProc; <br>        wc.cbClsExtra = 0; <br>        wc.cbWndExtra = 4; <br>        wc.hInstance = hInst; <br>        wc.hIcon = NULL; <br>        wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName = NULL; <br>        wc.lpszClassName = CLASS_PALETTE; <br> <br>        if (!RegisterClass(&amp;wc)) <br>                return FALSE; <br>        else <br>                return TRUE; <br>} <br> <br> <br>static BOOL FrameTools_CreatePopupPalette(LPFRAMETOOLS lpft, HWND hWndFrame) <br>{ <br>        if (lpft-&gt;m_hWndPopupPalette) <br>                DestroyWindow(lpft-&gt;m_hWndPopupPalette); <br> <br>        lpft-&gt;m_hWndPopupPalette = CreateWindow( <br>                CLASS_PALETTE, <br>                "Tool Palette", <br>                WS_POPUP | WS_CAPTION | WS_CLIPCHILDREN, <br>                CW_USEDEFAULT, 0, 0, 0, <br>                hWndFrame, <br>                (HMENU)NULL, <br>                g_lpApp-&gt;m_hInst, <br>                0L <br>        ); <br> <br>        if (!lpft-&gt;m_hWndPopupPalette) <br>                return FALSE; <br> <br>        SetWindowLong(lpft-&gt;m_hWndPopupPalette, 0, (LONG)lpft); <br>        return TRUE; <br>} <br> <br> <br>/* <br> * FrameTools_Init <br> * <br> * Purpose: <br> *  Init and create the toolbar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  hWndParent      The window which owns the toolbar <br> *  hInst           Process instance <br> * <br> * Return Value: <br> *  TRUE            if successful <br> *  FALSE           if failed <br> * <br> */ <br>BOOL FrameTools_Init(LPFRAMETOOLS lpft, HWND hWndParent, HINSTANCE hInst) <br>{ <br>        RECT        rc; <br>        UINT        uPos; <br>        UINT        dx; <br>        UINT        dy; <br> <br>        if (!lpft || !hWndParent || !hInst) <br>                return FALSE; <br> <br>        //Get BTTNCUR's display information <br>        UIToolConfigureForDisplay(&amp;lpft-&gt;m_tdd); <br> <br>        dx=lpft-&gt;m_tdd.cxButton; <br>        dy=lpft-&gt;m_tdd.cyButton; <br> <br>        // 15 is calculated from the total number of buttons and separators <br>        lpft-&gt;m_uPopupWidth = dx * 15; <br> <br>        lpft-&gt;m_hWndApp = hWndParent; <br>        lpft-&gt;m_ButtonBar.m_nState = BARSTATE_TOP; <br>        lpft-&gt;m_FormulaBar.m_nState = BARSTATE_TOP; <br>        lpft-&gt;m_fInFormulaBar = FALSE; <br> <br>        lpft-&gt;m_fToolsDisabled = FALSE; <br> <br>        lpft-&gt;m_ButtonBar.m_uHeight = lpft-&gt;m_tdd.cyBar; <br>        lpft-&gt;m_FormulaBar.m_uHeight = lpft-&gt;m_tdd.cyBar; <br> <br> <br>        //Get our image bitmaps for the display type we're on <br>        if (72 == lpft-&gt;m_tdd.uDPI) <br>                lpft-&gt;m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image72"); <br>        if (96 == lpft-&gt;m_tdd.uDPI) <br>                lpft-&gt;m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image96"); <br>        if (120 == lpft-&gt;m_tdd.uDPI) <br>                lpft-&gt;m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image120"); <br> <br>        if (!lpft-&gt;m_hBmp) <br>                return FALSE; <br> <br>        /* Create Popup Tool Palette window */ <br>        lpft-&gt;m_hWndPopupPalette = NULL; <br>        if (! FrameTools_CreatePopupPalette(lpft, hWndParent)) <br>                return FALSE; <br> <br>        uPos = 0; <br>        //Create the GizmoBar and the client area window <br>        GetClientRect(hWndParent, &amp;rc); <br>        lpft-&gt;m_ButtonBar.m_hWnd = CreateWindow( <br>                CLASS_GIZMOBAR, <br>                "ButtonBar", <br>                WS_CHILD | WS_VISIBLE, <br>                0, 0, rc.right-rc.left, lpft-&gt;m_tdd.cyBar, <br>                hWndParent, <br>                (HMENU)IDC_GIZMOBAR, <br>                hInst, <br>                0L <br>        ); <br> <br>        if (!lpft-&gt;m_ButtonBar.m_hWnd) <br>                return FALSE; <br> <br> <br>        SendMessage(lpft-&gt;m_ButtonBar.m_hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>        //File new, open, save, print <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_NEW, dx, dy, NULL, NULL, TOOLIMAGE_FILENEW, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_OPEN, dx, dy, NULL, NULL, TOOLIMAGE_FILEOPEN, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_SAVE, dx, dy, NULL, NULL, TOOLIMAGE_FILESAVE, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_PRINT, dx, dy, NULL, NULL, TOOLIMAGE_FILEPRINT, GIZMO_NORMAL); <br> <br>        // separator <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL); <br> <br>        // Edit cut, copy, paste <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_CUT, dx, dy, NULL, NULL, TOOLIMAGE_EDITCUT, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_COPY, dx, dy, NULL, NULL, TOOLIMAGE_EDITCOPY, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_PASTE, dx, dy, NULL, NULL, TOOLIMAGE_EDITPASTE, GIZMO_NORMAL); <br> <br>        // separator <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL); <br> <br>        // Line indent, unindent <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_UNINDENTLINE, dx, dy, NULL, lpft-&gt;m_hBmp, IDB_UNINDENTLINE, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_INDENTLINE, dx, dy, NULL, lpft-&gt;m_hBmp, IDB_INDENTLINE, GIZMO_NORMAL); <br> <br>        // separator <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL); <br> <br>        // Help <br>        GBGizmoAdd(lpft-&gt;m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_H_ABOUT, dx, dy, NULL, NULL, TOOLIMAGE_HELP, GIZMO_NORMAL); <br> <br>        SendMessage(lpft-&gt;m_ButtonBar.m_hWnd, WM_SETREDRAW, TRUE, 0L); <br> <br> <br>        uPos = 0; <br>        lpft-&gt;m_FormulaBar.m_hWnd = CreateWindow( <br>                CLASS_GIZMOBAR, <br>                "FormulaBar", <br>                WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS, <br>                0, lpft-&gt;m_tdd.cyBar, rc.right-rc.left, lpft-&gt;m_tdd.cyBar, <br>                hWndParent, <br>                (HMENU)IDC_FORMULABAR, <br>                hInst, <br>                0L <br>        ); <br> <br>        if (!lpft-&gt;m_FormulaBar.m_hWnd) <br>                return FALSE; <br> <br>        SendMessage(lpft-&gt;m_FormulaBar.m_hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>        // Line add line <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_ADDLINE, dx, dy, NULL, lpft-&gt;m_hBmp, IDB_ADDLINE, GIZMO_NORMAL); <br> <br>        // separator <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL); <br> <br>        // Line edit line, Cancel <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_EDITLINE, dx, dy, NULL, lpft-&gt;m_hBmp, IDB_EDITLINE, GIZMO_NORMAL); <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_FB_CANCEL, dx, dy, NULL, lpft-&gt;m_hBmp, IDB_CANCEL, GIZMO_NORMAL); <br> <br>        // separator <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL); <br> <br>        // Edit control for line input <br>        GBGizmoAdd(lpft-&gt;m_FormulaBar.m_hWnd, GIZMOTYPE_EDIT, uPos++, IDM_FB_EDIT, dx*10, lpft-&gt;m_tdd.cyBar-5, NULL, NULL, 0, GIZMO_NORMAL); <br> <br> <br>        SendMessage(lpft-&gt;m_FormulaBar.m_hWnd, WM_SETREDRAW, TRUE, 0L); <br> <br>        // Limit the text lenght of edit control <br>        GBGizmoSendMessage(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT, EM_LIMITTEXT, <br>                (WPARAM)MAXSTRLEN, 0L); <br> <br>        //Set the GizmoBar's associate to be this client window <br>        GBHwndAssociateSet(lpft-&gt;m_ButtonBar.m_hWnd, hWndParent); <br> <br>        //Set the FormulaBar's associate to be this client window <br>        GBHwndAssociateSet(lpft-&gt;m_FormulaBar.m_hWnd, hWndParent); <br> <br>        return TRUE; <br>} <br> <br> <br>void FrameTools_AttachToFrame(LPFRAMETOOLS lpft, HWND hWndFrame) <br>{ <br>        if (! lpft) <br>                return; <br> <br>        if (hWndFrame == NULL) <br>                hWndFrame = OutlineApp_GetFrameWindow((LPOUTLINEAPP)g_lpApp); <br> <br>        if (lpft-&gt;m_hWndApp == hWndFrame) <br>                return;     // already have this parent frame <br> <br>        lpft-&gt;m_hWndApp = hWndFrame; <br> <br>        /* parent the tool bars to the frame so we can safely <br>        **    destroy/recreate the palette window. <br>        */ <br>        SetParent(lpft-&gt;m_ButtonBar.m_hWnd, hWndFrame); <br>        SetParent(lpft-&gt;m_FormulaBar.m_hWnd, hWndFrame); <br> <br>        // recreate popup palette so that it is owned by the hWndFrame <br>        FrameTools_CreatePopupPalette(lpft, hWndFrame); <br> <br>        // restore the correct parent for the tool bars <br>        FrameTools_BB_SetState(lpft, lpft-&gt;m_ButtonBar.m_nState); <br>        FrameTools_FB_SetState(lpft, lpft-&gt;m_FormulaBar.m_nState); <br>} <br> <br> <br>void FrameTools_AssociateDoc(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>        HWND hWnd = OutlineDoc_GetWindow(lpOutlineDoc); <br> <br>        if (! lpft) <br>                return; <br> <br>        // if no Doc is given, then associate with the App's frame window. <br>        if (lpOutlineDoc) <br>                hWnd = OutlineDoc_GetWindow(lpOutlineDoc); <br>        else <br>                hWnd = OutlineApp_GetWindow((LPOUTLINEAPP)g_lpApp); <br> <br>        //Set the GizmoBar's associate to be this client window <br>        GBHwndAssociateSet(lpft-&gt;m_ButtonBar.m_hWnd, hWnd); <br> <br>        //Set the FormulaBar's associate to be this client window <br>        GBHwndAssociateSet(lpft-&gt;m_FormulaBar.m_hWnd, hWnd); <br>} <br> <br> <br>/* <br> * FrameTools_Destroy <br> * <br> * Purpose: <br> *  Destroy the toolbar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_Destroy(LPFRAMETOOLS lpft) <br>{ <br>        if (!lpft) <br>                return; <br> <br>        if (IsWindow(lpft-&gt;m_ButtonBar.m_hWnd)) <br>                DestroyWindow(lpft-&gt;m_ButtonBar.m_hWnd); <br>        if (IsWindow(lpft-&gt;m_FormulaBar.m_hWnd)) <br>                DestroyWindow(lpft-&gt;m_FormulaBar.m_hWnd); <br>        if (IsWindow(lpft-&gt;m_hWndPopupPalette)) <br>                DestroyWindow(lpft-&gt;m_hWndPopupPalette); <br> <br>        if (lpft-&gt;m_hBmp) <br>                DeleteObject(lpft-&gt;m_hBmp); <br>} <br> <br> <br>/* <br> * FrameTools_Move <br> * <br> * Purpose: <br> *  Move and resize the toolbar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  lprc            Pointer to client rectangle <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_Move(LPFRAMETOOLS lpft, LPRECT lprcClient) <br>{ <br>        RECT rcPopup; <br>        LPRECT lprcPopup = (LPRECT)&amp;rcPopup; <br>        int nCmdShow = SW_HIDE; <br> <br>        if (!lpft || lpft-&gt;m_fToolsDisabled) <br>                return; <br> <br>        lprcPopup-&gt;left = 0; <br>        lprcPopup-&gt;top = 0; <br>        lprcPopup-&gt;right = lpft-&gt;m_uPopupWidth; <br>        lprcPopup-&gt;bottom = lpft-&gt;m_ButtonBar.m_uHeight + <br>                        lpft-&gt;m_FormulaBar.m_uHeight; <br> <br>        switch (lpft-&gt;m_ButtonBar.m_nState) { <br>                case BARSTATE_HIDE: <br>                case BARSTATE_POPUP: <br>                case BARSTATE_TOP: <br>                        Bar_Move(&amp;lpft-&gt;m_ButtonBar, lprcClient, lprcPopup); <br>                        Bar_Move(&amp;lpft-&gt;m_FormulaBar, lprcClient, lprcPopup); <br>                        break; <br> <br>                case BARSTATE_BOTTOM: <br>                        Bar_Move(&amp;lpft-&gt;m_FormulaBar, lprcClient, lprcPopup); <br>                        Bar_Move(&amp;lpft-&gt;m_ButtonBar, lprcClient, lprcPopup); <br>                        break; <br>        } <br> <br>        if (lprcPopup-&gt;top) { <br>                SetWindowPos(lpft-&gt;m_hWndPopupPalette, NULL, 0, 0, lprcPopup-&gt;right, <br>                                lprcPopup-&gt;top + GetSystemMetrics(SM_CYCAPTION), <br>                                SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW); <br>        } <br>        else <br>                ShowWindow(lpft-&gt;m_hWndPopupPalette, SW_HIDE); <br> <br>        FB_ResizeEdit(&amp;lpft-&gt;m_FormulaBar); <br> <br>        InvalidateRect(lpft-&gt;m_ButtonBar.m_hWnd, NULL, TRUE); <br>        InvalidateRect(lpft-&gt;m_FormulaBar.m_hWnd, NULL, TRUE); <br>} <br> <br> <br>/* <br> * FrameTools_PopupTools <br> * <br> * Purpose: <br> *  Put both formula bar and button bar in Popup Window. <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_PopupTools(LPFRAMETOOLS lpft) <br>{ <br>        if (! lpft) <br>                return; <br> <br>        FrameTools_BB_SetState(lpft, BARSTATE_POPUP); <br>        FrameTools_FB_SetState(lpft, BARSTATE_POPUP); <br>        FrameTools_Move(lpft, NULL); <br>} <br> <br> <br>/* <br> * FrameTools_Enable <br> * <br> * Purpose: <br> *  Enable/Disable(hide) all the tools of the toolbar. <br> *  this will hide both the buttonbar and the <br> *  formulabar independent of whether they are floating or anchored. <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  fEnable <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_Enable(LPFRAMETOOLS lpft, BOOL fEnable) <br>{ <br>        lpft-&gt;m_fToolsDisabled = !fEnable; <br>        if (lpft-&gt;m_fToolsDisabled) { <br>                ShowWindow(lpft-&gt;m_hWndPopupPalette, SW_HIDE); <br>                ShowWindow(lpft-&gt;m_ButtonBar.m_hWnd, SW_HIDE); <br>                ShowWindow(lpft-&gt;m_FormulaBar.m_hWnd, SW_HIDE); <br>        } <br>} <br> <br> <br>/* <br> * FrameTools_EnableWindow <br> * <br> * Purpose: <br> *  EnableWindow for all the tools of the toolbar. <br> *  this enables/disables mouse and keyboard input to the tools. <br> *  while a modal dialog is up, it is inportant to disable the <br> *  floating tool windows. <br> *  this will NOT hide any windows; it will only call EnableWindow. <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  fEnable <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_EnableWindow(LPFRAMETOOLS lpft, BOOL fEnable) <br>{ <br>        EnableWindow(lpft-&gt;m_hWndPopupPalette, fEnable); <br>        EnableWindow(lpft-&gt;m_ButtonBar.m_hWnd, fEnable); <br>        EnableWindow(lpft-&gt;m_FormulaBar.m_hWnd, fEnable); <br>} <br> <br> <br>#if defined( INPLACE_CNTR ) || defined( INPLACE_SVR ) <br> <br>/* <br> * FrameTools_NegotiateForSpaceAndShow <br> * <br> * Purpose: <br> *  Negotiate for space for the toolbar tools with the given frame window. <br> *  and make them visible. <br> *  Negotiation steps: <br> *     1. try to get enough space at top/bottom of window <br> *     2. float the tools as a palette if space not available <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  none <br> */ <br>void FrameTools_NegotiateForSpaceAndShow( <br>                LPFRAMETOOLS            lpft, <br>                LPRECT                  lprcFrameRect, <br>                LPOLEINPLACEFRAME       lpTopIPFrame <br>) <br>{ <br>        BORDERWIDTHS    borderwidths; <br>        RECT            rectBorder; <br>        HRESULT         hrErr; <br> <br>        if (lprcFrameRect) <br>                rectBorder = *lprcFrameRect; <br>        else { <br>                /* NOTE: by calling GetBorder, the server can find out the <br>                **    size of the frame window. it can use this information to <br>                **    make decisions about how to orient/organize it tools (eg. <br>                **    if window is taller than wide put tools vertically at <br>                **    left edge). <br>                */ <br>                OLEDBG_BEGIN2("IOleInPlaceFrame::GetBorder called\r\n") <br>                hrErr = lpTopIPFrame-&gt;lpVtbl-&gt;GetBorder( <br>                                lpTopIPFrame, <br>                                (LPRECT)&amp;rectBorder <br>                ); <br>                OLEDBG_END2 <br>        } <br> <br>        /* Try SetBorderSpace() with the space that you need. If it fails then <br>        ** you can negotiate for space and then do the SetBorderSpace(). <br>        */ <br>        FrameTools_GetRequiredBorderSpace(lpft,(LPBORDERWIDTHS)&amp;borderwidths); <br>        OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace called\r\n") <br>        hrErr = lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace( <br>                        lpTopIPFrame, <br>                        (LPCBORDERWIDTHS)&amp;borderwidths <br>        ); <br>        OLEDBG_END2 <br> <br>#if defined( LATER ) <br>        if (hrErr != NOERROR) { <br>                /* Frame did not give the toolsspace that we want. So negotiate */ <br> <br>                // REVIEW: try a different placement of the tools here <br> <br>                OLEDBG_BEGIN2("IOleInPlaceFrame::RequestBorderSpace called\r\n") <br>                hrErr = lpTopIPFrame-&gt;lpVtbl-&gt;RequestBorderSpace( <br>                                lpTopIPFrame, <br>                                (LPCBORDERWIDTHS)&amp;borderwidths <br>                ); <br>                OLEDBG_END2 <br> <br>                if (hrErr == NOERROR) { <br>                        OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace called\r\n") <br>                        hrErr = lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace( <br>                                        lpTopIPFrame, <br>                                        (LPCBORDERWIDTHS)&amp;borderwidths <br>                        ); <br>                        OLEDBG_END2 <br>                } <br>        } <br>#endif <br> <br>        if (hrErr == NOERROR) { <br>                FrameTools_Move(lpft, (LPRECT)&amp;rectBorder);   // we got what we wanted <br>        } else { <br>                /* We did not get tool space, so POP them up. <br>                /* NOTE: since we are poping up our tools, we MUST inform <br>                **    the top in-place frame window that we need NO tool space <br>                **    BUT that it should NOT put its own tools up. if we were <br>                **    to pass NULL instead of (0,0,0,0), then the container <br>                **    would have the option to leave its own tools up. <br>                */ <br>                OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(NULL) called\r\n") <br>                hrErr = lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace( <br>                                lpTopIPFrame, <br>                                (LPCBORDERWIDTHS)&amp;g_rectNull <br>                ); <br>                OLEDBG_END2 <br>                FrameTools_PopupTools(lpft); <br>        } <br>} <br> <br>#endif  // INPLACE_CNTR || INPLACE_SVR <br> <br> <br>/* <br> * FrameTools_GetRequiredBorderSpace <br> * <br> * Purpose: <br> *  Calculate the desired space for the toolbar tools. <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  lpBorderWidths  Widths required at top,bottom,left,right <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_GetRequiredBorderSpace(LPFRAMETOOLS lpft, LPBORDERWIDTHS lpBorderWidths) <br>{ <br>        *lpBorderWidths = g_rectNull; <br> <br>        switch (lpft-&gt;m_ButtonBar.m_nState) { <br>                case BARSTATE_TOP: <br>                        lpBorderWidths-&gt;top += lpft-&gt;m_ButtonBar.m_uHeight; <br>                        break; <br> <br>                case BARSTATE_BOTTOM: <br>                        lpBorderWidths-&gt;bottom += lpft-&gt;m_ButtonBar.m_uHeight; <br>                        break; <br>        } <br> <br>        switch (lpft-&gt;m_FormulaBar.m_nState) { <br>                case BARSTATE_TOP: <br>                        lpBorderWidths-&gt;top += lpft-&gt;m_FormulaBar.m_uHeight; <br>                        break; <br> <br>                case BARSTATE_BOTTOM: <br>                        lpBorderWidths-&gt;bottom += lpft-&gt;m_FormulaBar.m_uHeight; <br>                        break; <br>        } <br>} <br> <br> <br> <br>/* <br> * FrameTools_UpdateButtons <br> * <br> * Purpose: <br> *  Enable/disable individual buttons of the toolbar according to the <br> *  state of the app <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_UpdateButtons(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>        BOOL            fEnable; <br> <br>#if defined( OLE_VERSION ) <br>        LPDATAOBJECT    lpClipboardDataObj; <br>        HRESULT         hrErr; <br>        LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>        BOOL            fPrevEnable1; <br>        BOOL            fPrevEnable2; <br>#endif <br> <br>        if (!lpft) <br>                return; <br> <br>#if defined( INPLACE_CNTR ) <br>        { <br>                LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>                if (lpContainerDoc-&gt;m_lpLastUIActiveLine &amp;&amp; <br>                        lpContainerDoc-&gt;m_lpLastUIActiveLine-&gt;m_fUIActive) { <br> <br>                        /* if there is a UIActive object, then we should disable <br>                        **    all of our "active editor" commands. we should enable <br>                        **    only those commands that are "workspace" commands. <br>                        */ <br>                        if (lpft-&gt;m_FormulaBar.m_nState != BARSTATE_HIDE) { <br> <br>                                GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd,IDM_L_EDITLINE,FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd,IDM_L_ADDLINE,FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd,IDM_FB_CANCEL,FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd,IDM_L_EDITLINE,FALSE); <br>                        } <br> <br>                        if (lpft-&gt;m_ButtonBar.m_nState != BARSTATE_HIDE) <br>                        { <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_CUT, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_COPY, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_PASTE, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd,IDM_L_INDENTLINE,FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_L_UNINDENTLINE, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_H_ABOUT, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_FB_EDIT, FALSE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_NEW, TRUE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_OPEN, TRUE); <br>                                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_SAVE, TRUE); <br>                        } <br>                        return; <br>                } <br>        } <br>#endif    // INPLACE_CNTR <br> <br>        fEnable = (BOOL)OutlineDoc_GetLineCount(lpOutlineDoc); <br> <br>        if (lpft-&gt;m_FormulaBar.m_nState != BARSTATE_HIDE) { <br> <br>                GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_L_EDITLINE, fEnable); <br> <br>                if (! lpft-&gt;m_fInFormulaBar) { <br>                        GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_L_ADDLINE, FALSE); <br>                        GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_CANCEL, FALSE); <br>                        GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_L_EDITLINE, FALSE); <br>                        if (!fEnable) { <br>                                GBGizmoTextSet(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT, ""); <br>                        } <br>                } else { <br>                        GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_L_ADDLINE, TRUE); <br>                        GBGizmoEnable(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_CANCEL, TRUE); <br>                } <br>        } <br> <br>        if (lpft-&gt;m_ButtonBar.m_nState != BARSTATE_HIDE) <br>        { <br>                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_CUT, fEnable); <br>                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_COPY, fEnable); <br>                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_L_INDENTLINE, fEnable); <br>                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_L_UNINDENTLINE, fEnable); <br> <br>#if defined( OLE_SERVER ) <br> <br>                { <br>                        LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br> <br>#if defined( INPLACE_SVR ) <br>                        fEnable = ((lpServerDoc-&gt;m_fUIActive) ? FALSE : TRUE); <br>#else <br>                        fEnable = (lpOutlineDoc-&gt;m_docInitType != DOCTYPE_EMBEDDED); <br>#endif  // INPLACE_SVR <br> <br>                        GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_NEW, fEnable); <br>                        GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_OPEN, fEnable); <br>                        GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_F_SAVE, fEnable); <br>                } <br> <br>#endif  // OLE_SERVER <br> <br>#if defined( OLE_VERSION ) <br> <br>                /* NOTE: we do not want to ever give the busy dialog when we <br>                **    are trying to enable or disable our tool bar buttons eg. <br>                **    even if the source of data on the clipboard is busy, we do <br>                **    not want put up the busy dialog. thus we will disable the <br>                **    dialog and at the end re-enable it. <br>                */ <br>                OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>                /* NOTE: perform OLE specific menu initialization. <br>                **    the OLE versions use the OleGetClipboard mechanism for <br>                **    clipboard handling. thus, they determine if the Paste <br>                **    command should be enabled in an OLE specific manner. <br>                */ <br>                fEnable = FALSE; <br>                hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&amp;lpClipboardDataObj); <br> <br>                if (hrErr == NOERROR) { <br>                        int nFmtEtc; <br> <br>                        nFmtEtc = OleStdGetPriorityClipboardFormat( <br>                                        lpClipboardDataObj, <br>                                        lpOleApp-&gt;m_arrPasteEntries, <br>                                        lpOleApp-&gt;m_nPasteEntries <br>                        ); <br> <br>                        fEnable = (nFmtEtc &gt;= 0);  // there IS a format we like <br> <br>                        OleStdRelease((LPUNKNOWN)lpClipboardDataObj); <br>                } <br> <br>                // re-enable the busy dialog <br>                OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br> <br>                GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_PASTE, fEnable); <br> <br>#else <br> <br>                // Base Outline version uses standard Windows clipboard handling <br>                if(IsClipboardFormatAvailable(g_lpApp-&gt;m_cfOutline) || <br>                                IsClipboardFormatAvailable(CF_TEXT)) <br>                        GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_PASTE, TRUE); <br>                else <br>                        GBGizmoEnable(lpft-&gt;m_ButtonBar.m_hWnd, IDM_E_PASTE, FALSE); <br> <br>#endif  // OLE_VERSION <br> <br>        } <br>} <br> <br>/* <br> * FrameTools_FB_SetEditText <br> * <br> * Purpose: <br> *  Set text in the edit control in FormulaBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  lpsz            pointer to string to be set <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_FB_SetEditText(LPFRAMETOOLS lpft, LPSTR lpsz) <br>{ <br>        GBGizmoTextSet(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT, lpsz); <br>} <br> <br> <br>/* <br> * FrameTools_FB_GetEditText <br> * <br> * Purpose: <br> *  Get text from the edit control in FormulaBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  lpsz            pointer to buffer to receive the text <br> *  cch             buffer size <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_FB_GetEditText(LPFRAMETOOLS lpft, LPSTR lpsz, UINT cch) <br>{ <br>        GBGizmoTextGet(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT, lpsz, cch); <br>} <br> <br> <br>/* <br> * FrameTools_FB_FocusEdit <br> * <br> * Purpose: <br> *  Set the focus in the edit control of FormulaBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_FB_FocusEdit(LPFRAMETOOLS lpft) <br>{ <br>        GBGizmoFocusSet(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT); <br> <br>        // select the whole text in the edit control <br>        GBGizmoSendMessage(lpft-&gt;m_FormulaBar.m_hWnd, IDM_FB_EDIT, EM_SETSEL, <br>                        (WPARAM)TRUE, MAKELPARAM(0, -1)); <br>} <br> <br> <br>/* <br> * FrameTools_FB_SendMessage <br> * <br> * Purpose: <br> *  Send a message to the FormulaBar window gizmo <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  uID             gizmo ID <br> *  msg <br> *  wParam <br> *  lParam <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_FB_SendMessage(LPFRAMETOOLS lpft, UINT uID, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>        GBGizmoSendMessage(lpft-&gt;m_FormulaBar.m_hWnd, uID, msg, wParam, lParam); <br>} <br> <br> <br>/* <br> * FrameTools_FB_ForceRedraw <br> * <br> * Purpose: <br> *  Force the toolbar to draw itself <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_ForceRedraw(LPFRAMETOOLS lpft) <br>{ <br>        InvalidateRect(lpft-&gt;m_ButtonBar.m_hWnd, NULL, TRUE); <br>        InvalidateRect(lpft-&gt;m_FormulaBar.m_hWnd, NULL, TRUE); <br>        InvalidateRect(lpft-&gt;m_hWndPopupPalette, NULL, TRUE); <br>} <br> <br> <br>/* <br> * FrameTools_BB_SetState <br> * <br> * Purpose: </code></pre>
<p>
</p>
<pre><code>*  Set display state of ButtonBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  nState          new display state <br> * <br> * Return Value: <br> *  nil <br> */ <br>void FrameTools_BB_SetState(LPFRAMETOOLS lpft, int nState) <br>{ <br>        if (!lpft) { <br>                return; <br>        } <br> <br>        lpft-&gt;m_ButtonBar.m_nState = nState; <br> <br>        if (nState == BARSTATE_POPUP) <br>                SetParent(lpft-&gt;m_ButtonBar.m_hWnd, lpft-&gt;m_hWndPopupPalette); <br>        else <br>                SetParent(lpft-&gt;m_ButtonBar.m_hWnd, lpft-&gt;m_hWndApp); <br>} <br> <br> <br>/* <br> * FrameTools_BB_GetState <br> * <br> * Purpose: <br> *  Get display state of ButtonBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nState          current display state <br> */ <br>int FrameTools_BB_GetState(LPFRAMETOOLS lpft) <br>{ <br>        return lpft-&gt;m_ButtonBar.m_nState; <br>} <br> <br> <br>/* <br> * FrameTools_FB_SetState <br> * <br> * Purpose: <br> *  Set display state of FormulaBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> *  nState          new display state <br> * <br> * Return Value: <br>4 *  nil <br> */ <br>void FrameTools_FB_SetState(LPFRAMETOOLS lpft, int nState) <br>{ <br>        if (!lpft) { <br>                return; <br>        } <br> <br>        lpft-&gt;m_FormulaBar.m_nState = nState; <br> <br>        if (nState == BARSTATE_POPUP) <br>                SetParent(lpft-&gt;m_FormulaBar.m_hWnd, lpft-&gt;m_hWndPopupPalette); <br> <br>#if defined( INPLACE_SVR ) <br>        /* NOTE: it is dangerous for an in-place server to hide its <br>        **    toolbar window and leave it parented to the hWndFrame of the <br>        **    in-place container. if the in-place container call <br>        **    ShowOwnedPopups, then it could inadvertantly be made visible. <br>        **    to avoid this we will parent the toolbar window back to our <br>        **    own application main window. if we are not in-place active <br>        **    then this is the same as lpft-&gt;m_hWndApp. <br>        */ <br>        else if (nState == BARSTATE_HIDE) <br>                SetParent(lpft-&gt;m_FormulaBar.m_hWnd, g_lpApp-&gt;m_hWndApp); <br>#endif <br> <br>        else <br>                SetParent(lpft-&gt;m_FormulaBar.m_hWnd, lpft-&gt;m_hWndApp); <br>} <br> <br> <br>/* <br> * FrameTools_FB_GetState <br> * <br> * Purpose: <br> *  Get display state of FormulaBar <br> * <br> * Parameters: <br> *  lpft            FrameTools object <br> * <br> * Return Value: <br> *  nState          current display state <br> */ <br>int FrameTools_FB_GetState(LPFRAMETOOLS lpft) <br>{ <br>        return lpft-&gt;m_FormulaBar.m_nState; <br>} <br> <br> <br>/* <br> * FrameToolsWndProc <br> * <br> * Purpose: <br> *  WndProc for toolbar window <br> * <br> * Parameters: <br> *  hWnd <br> *  Message <br> *  wParam <br> *  lParam <br> * <br> * Return Value: <br> *  message dependent <br> */ <br>LRESULT FAR PASCAL FrameToolsWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>        LPFRAMETOOLS lpft = (LPFRAMETOOLS)GetWindowLong(hWnd, 0); <br> <br>        switch (Message) { <br> <br>                case WM_MOUSEACTIVATE: <br>                        return MA_NOACTIVATE; <br> <br>                default: <br>                        return DefWindowProc(hWnd, Message, wParam, lParam); <br>        } <br> <br>        return 0L; <br>} <br> <br> <br>/* <br> * Bar_Move <br> * <br> * Purpose: <br> *  Resize and reposition a bar <br> * <br> * Parameters: <br> *  lpbar           Bar object <br> *  lprcClient      pointer to Client rect <br> *  lprcPopup       pointer to Popup rect <br> * <br> * Return Value: <br> *  nil <br> */ <br>static void Bar_Move(LPBAR lpbar, LPRECT lprcClient, LPRECT lprcPopup) <br>{ <br>        if (lpbar-&gt;m_nState == BARSTATE_HIDE) { <br>                ShowWindow(lpbar-&gt;m_hWnd, SW_HIDE); <br>        } <br>        else { <br>                ShowWindow(lpbar-&gt;m_hWnd, SW_SHOW); <br>                switch (lpbar-&gt;m_nState) { <br>                        case BARSTATE_POPUP: <br>                                MoveWindow(lpbar-&gt;m_hWnd, lprcPopup-&gt;left, lprcPopup-&gt;top, <br>                                                lprcPopup-&gt;right - lprcPopup-&gt;left, lpbar-&gt;m_uHeight, <br>                                                TRUE); <br>                                lprcPopup-&gt;top += lpbar-&gt;m_uHeight; <br>                                break; <br> <br>                        case BARSTATE_TOP: <br>                                MoveWindow(lpbar-&gt;m_hWnd, lprcClient-&gt;left, lprcClient-&gt;top, <br>                                                lprcClient-&gt;right - lprcClient-&gt;left, <br>                                                lpbar-&gt;m_uHeight, TRUE); <br>                                lprcClient-&gt;top += lpbar-&gt;m_uHeight; <br>                                break; <br> <br>                        case BARSTATE_BOTTOM: <br>                                MoveWindow(lpbar-&gt;m_hWnd, lprcClient-&gt;left, <br>                                                lprcClient-&gt;bottom - lpbar-&gt;m_uHeight, <br>                                                lprcClient-&gt;right - lprcClient-&gt;left, <br>                                                lpbar-&gt;m_uHeight, TRUE); <br>                                lprcClient-&gt;bottom -= lpbar-&gt;m_uHeight; <br>                                break; <br>                } <br>        } <br>} <br> <br> <br>/* <br> * FB_ResizeEdit <br> * <br> * Purpose: <br> *  Resize the edit control in FormulaBar <br> * <br> * Parameters: <br> *  lpft            Bar object <br> * <br> * Return Value: <br> *  nil <br> */ <br>static void FB_ResizeEdit(LPBAR lpbar) <br>{ <br>        RECT rcClient; <br>        RECT rcEdit; <br>        HWND hwndEdit; <br> <br>        GetClientRect(lpbar-&gt;m_hWnd, (LPRECT)&amp;rcClient); <br>        hwndEdit = GetDlgItem(lpbar-&gt;m_hWnd, IDM_FB_EDIT); <br>        GetWindowRect(hwndEdit, (LPRECT)&amp;rcEdit); <br>        ScreenToClient(lpbar-&gt;m_hWnd, (LPPOINT)&amp;rcEdit.left); <br>        ScreenToClient(lpbar-&gt;m_hWnd, (LPPOINT)&amp;rcEdit.right); <br> <br>        SetWindowPos(hwndEdit, NULL, 0, 0, rcClient.right - rcEdit.left - SPACE, <br>                        rcEdit.bottom - rcEdit.top, SWP_NOMOVE | SWP_NOZORDER); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
