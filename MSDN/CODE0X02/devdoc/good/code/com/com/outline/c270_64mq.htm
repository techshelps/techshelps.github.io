<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLIPBRD.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context272"></a>CLIPBRD.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    clipbrd.c <br>** <br>**    This file contains the major interfaces, methods and related support <br>**    functions for implementing clipboard data transfer. The code <br>**    contained in this file is used by BOTH the Container and Server <br>**    (Object) versions of the Outline sample code. <br>**    (see file dragdrop.c for Drag/Drop support implementation) <br>** <br>**    OleDoc Object <br>**      exposed interfaces: <br>**          IDataObject <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR ErrMsgPasting[] = OLESTR("Could not paste data from clipboard!"); <br>OLECHAR ErrMsgBadFmt[] = OLESTR("Invalid format selected!"); <br>OLECHAR ErrMsgPasteFailed[] = OLESTR("Could not paste data from clipboard!"); <br>OLECHAR ErrMsgClipboardChanged[] = OLESTR("Contents of clipboard have changed!\r\nNo paste performed."); <br> <br>#ifdef WIN32S <br>#define GALLOCFLG (GMEM_SHARE | GMEM_ZEROINIT | GMEM_MOVEABLE) <br>#else <br>#define GALLOCFLG (GMEM_SHARE | GMEM_ZEROINIT) <br>#endif <br> <br>/************************************************************************* <br>** OleDoc::IDataObject interface implementation <br>*************************************************************************/ <br> <br>// IDataObject::QueryInterface <br>STDMETHODIMP OleDoc_DataObj_QueryInterface ( <br>      LPDATAOBJECT        lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   return OleDoc_QueryInterface((LPOLEDOC)lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>// IDataObject::AddRef <br>STDMETHODIMP_(ULONG) OleDoc_DataObj_AddRef(LPDATAOBJECT lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IDataObject"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpOleDoc); <br>} <br> <br> <br>// IDataObject::Release <br>STDMETHODIMP_(ULONG) OleDoc_DataObj_Release (LPDATAOBJECT lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IDataObject"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpOleDoc); <br>} <br> <br> <br>// IDataObject::GetData <br>STDMETHODIMP OleDoc_DataObj_GetData ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc, <br>      LPSTGMEDIUM         lpMedium <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_GetData\r\n") <br> <br>#if defined( OLE_SERVER ) <br>   // Call OLE Server specific version of this function <br>   hrErr = ServerDoc_GetData((LPSERVERDOC)lpOleDoc, lpFormatetc, lpMedium); <br>#endif <br>#if defined( OLE_CNTR ) <br>   // Call OLE Container specific version of this function <br>   hrErr = ContainerDoc_GetData( <br>         (LPCONTAINERDOC)lpOleDoc, <br>         lpFormatetc, <br>         lpMedium <br>   ); <br>#endif <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IDataObject::GetDataHere <br>STDMETHODIMP OleDoc_DataObj_GetDataHere ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc, <br>      LPSTGMEDIUM         lpMedium <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_GetDataHere\r\n") <br> <br>#if defined( OLE_SERVER ) <br>   // Call OLE Server specific version of this function <br>   hrErr = ServerDoc_GetDataHere( <br>         (LPSERVERDOC)lpOleDoc, <br>         lpFormatetc, <br>         lpMedium <br>   ); <br>#endif <br>#if defined( OLE_CNTR ) <br>   // Call OLE Container specific version of this function <br>   hrErr = ContainerDoc_GetDataHere( <br>         (LPCONTAINERDOC)lpOleDoc, <br>         lpFormatetc, <br>         lpMedium <br>   ); <br>#endif <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IDataObject::QueryGetData <br>STDMETHODIMP OleDoc_DataObj_QueryGetData ( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpFormatetc <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br>   OLEDBG_BEGIN2("OleDoc_DataObj_QueryGetData\r\n"); <br> <br>#if defined( OLE_SERVER ) <br>   // Call OLE Server specific version of this function <br>   hrErr = ServerDoc_QueryGetData((LPSERVERDOC)lpOleDoc, lpFormatetc); <br>#endif <br>#if defined( OLE_CNTR ) <br>   // Call OLE Container specific version of this function <br>   hrErr = ContainerDoc_QueryGetData((LPCONTAINERDOC)lpOleDoc, lpFormatetc); <br>#endif <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IDataObject::GetCanonicalFormatEtc <br>STDMETHODIMP OleDoc_DataObj_GetCanonicalFormatEtc( <br>      LPDATAOBJECT        lpThis, <br>      LPFORMATETC         lpformatetc, <br>      LPFORMATETC         lpformatetcOut <br>) <br>{ <br>   HRESULT hrErr; <br>   OleDbgOut2("OleDoc_DataObj_GetCanonicalFormatEtc\r\n"); <br> <br>   if (!lpformatetcOut) <br>      return E_INVALIDARG; <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   lpformatetcOut-&gt;ptd = NULL; <br> <br>   if (!lpformatetc) <br>      return E_INVALIDARG; <br> <br>   // NOTE: we must validate that the format requested is supported <br>   if ((hrErr=lpThis-&gt;lpVtbl-&gt;QueryGetData(lpThis,lpformatetc)) != NOERROR) <br>      return hrErr; <br> <br>   /* NOTE: an app that is insensitive to target device (as the <br>   **    Outline Sample is) should fill in the lpformatOut parameter <br>   **    but NULL out the "ptd" field; it should return NOERROR if the <br>   **    input formatetc-&gt;ptd what non-NULL. this tells the caller <br>   **    that it is NOT necessary to maintain a separate screen <br>   **    rendering and printer rendering. if should return <br>   **    DATA_S_SAMEFORMATETC if the input and output formatetc's are <br>   **    identical. <br>   */ <br> <br>   *lpformatetcOut = *lpformatetc; <br>   if (lpformatetc-&gt;ptd == NULL) <br>      return DATA_S_SAMEFORMATETC; <br>   else { <br>      lpformatetcOut-&gt;ptd = NULL; <br>      return NOERROR; <br>   } <br>} <br> <br> <br>// IDataObject::SetData <br>STDMETHODIMP OleDoc_DataObj_SetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpFormatetc, <br>      LPSTGMEDIUM     lpMedium, <br>      BOOL            fRelease <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   SCODE sc = S_OK; <br>   OLEDBG_BEGIN2("OleDoc_DataObj_SetData\r\n") <br> <br>   /* NOTE: a document that is used to transfer data (either via <br>   **    the clipboard or drag/drop) does NOT accept SetData on ANY <br>   **    format! <br>   */ <br>   if (lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   if (lpFormatetc-&gt;cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br>      OLEDBG_BEGIN2("ServerDoc_SetData: CF_OUTLINE\r\n") <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br>      OutlineDoc_ClearAllLines(lpOutlineDoc); <br>      OutlineDoc_PasteOutlineData(lpOutlineDoc,lpMedium-&gt;u.hGlobal,-1); <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br>      OLEDBG_END3 <br>   } else if (lpFormatetc-&gt;cfFormat == CF_TEXT) { <br>      OLEDBG_BEGIN2("ServerDoc_SetData: CF_TEXT\r\n") <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br>      OutlineDoc_ClearAllLines(lpOutlineDoc); <br>      OutlineDoc_PasteTextData(lpOutlineDoc,lpMedium-&gt;u.hGlobal,-1); <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br>      OLEDBG_END3 <br>   } else { <br>      sc = DV_E_FORMATETC; <br>   } <br>#endif  // OLE_SERVER <br>#if defined( OLE_CNTR ) <br>   /* the Container-Only version of Outline does NOT offer <br>   **    IDataObject interface from its User documents. this is <br>   **    required by objects which can be embedded or linked. the <br>   **    Container-only app only allows linking to its contained <br>   **    objects, NOT the data of the container itself. <br>   */ <br>   OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n"); <br>   sc = E_NOTIMPL; <br>#endif  // OLE_CNTR <br> <br>error: <br> <br>   /* NOTE: if fRelease==TRUE, then we must take <br>   **    responsibility to release the lpMedium. we should only do <br>   **    this if we are going to return NOERROR. if we do NOT <br>   **    accept the data, then we should NOT release the lpMedium. <br>   **    if fRelease==FALSE, then the caller retains ownership of <br>   **    the data. <br>   */ <br>   if (sc == S_OK &amp;&amp; fRelease) <br>      ReleaseStgMedium(lpMedium); <br> <br>   OLEDBG_END2 <br>   return sc; <br> <br>} <br> <br> <br>// IDataObject::EnumFormatEtc <br>STDMETHODIMP OleDoc_DataObj_EnumFormatEtc( <br>      LPDATAOBJECT            lpThis, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>) <br>{ <br>   LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_EnumFormatEtc\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumFormatEtc = NULL; <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: a user document only needs to enumerate the static list <br>   **    of formats that are registered for our app in the <br>   **    registration database. OLE provides a default enumerator <br>   **    which enumerates from the registration database. this default <br>   **    enumerator is requested by returning OLE_S_USEREG. it is NOT <br>   **    required that a user document (ie. non-DataTransferDoc) <br>   **    enumerate the OLE formats: CF_LINKSOURCE, CF_EMBEDSOURCE, or <br>   **    CF_EMBEDDEDOBJECT. <br>   ** <br>   **    An object implemented as a server EXE (as this sample <br>   **    is) may simply return OLE_S_USEREG to instruct the OLE <br>   **    DefHandler to call the OleReg* helper API which uses info in <br>   **    the registration database. Alternatively, the OleRegEnumFormatEtc <br>   **    API may be called directly. Objects implemented as a server <br>   **    DLL may NOT return OLE_S_USEREG; they must call the OleReg* <br>   **    API or provide their own implementation. For EXE based <br>   **    objects it is more efficient to return OLE_S_USEREG, because <br>   **    in then the enumerator is instantiated in the callers <br>   **    process space and no LRPC remoting is required. <br>   */ <br>   if (! ((LPOUTLINEDOC)lpOleDoc)-&gt;m_fDataTransferDoc) <br>      return OLE_S_USEREG; <br> <br>   // Call OLE Server specific version of this function <br>   hrErr = ServerDoc_EnumFormatEtc( <br>         (LPSERVERDOC)lpOleDoc, <br>         dwDirection, <br>         lplpenumFormatEtc <br>   ); <br>#endif <br>#if defined( OLE_CNTR ) <br>   // Call OLE Container specific version of this function <br>   hrErr = ContainerDoc_EnumFormatEtc( <br>         (LPCONTAINERDOC)lpOleDoc, <br>         dwDirection, <br>         lplpenumFormatEtc <br>   ); <br>#endif <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IDataObject::DAdvise <br>STDMETHODIMP OleDoc_DataObj_DAdvise( <br>      LPDATAOBJECT        lpThis, <br>      FORMATETC FAR*      lpFormatetc, <br>      DWORD               advf, <br>      LPADVISESINK        lpAdvSink, <br>      DWORD FAR*          lpdwConnection <br>) <br>{ <br>   LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   SCODE sc; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_DAdvise\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lpdwConnection = 0; <br> <br>   /* NOTE: a document that is used to transfer data (either via <br>   **    the clipboard or drag/drop) does NOT support Advise notifications. <br>   */ <br>   if (lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = OLE_E_ADVISENOTSUPPORTED; <br>      goto error; <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      HRESULT hrErr; <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br> <br>      /* NOTE: we should validate if the caller is setting up an <br>      **    Advise for a data type that we support. we must <br>      **    explicitly allow an advise for the "wildcard" advise. <br>      */ <br>#ifdef WIN32 <br>      if ( !( lpFormatetc-&gt;cfFormat == 0 &amp;&amp; <br>            lpFormatetc-&gt;ptd == 0 &amp;&amp; <br>#else <br>      if ( !( lpFormatetc-&gt;cfFormat == NULL &amp;&amp; <br>            lpFormatetc-&gt;ptd == NULL &amp;&amp; <br>#endif <br>            lpFormatetc-&gt;dwAspect == -1L &amp;&amp; <br>            lpFormatetc-&gt;lindex == -1L &amp;&amp; <br>            lpFormatetc-&gt;tymed == -1L) &amp;&amp; <br>          (hrErr = OleDoc_DataObj_QueryGetData(lpThis, lpFormatetc)) <br>                                                != NOERROR) { <br>         sc = hrErr; <br>         goto error; <br>      } <br> <br>      if (lpServerDoc-&gt;m_OleDoc.m_fObjIsClosing) <br>      { <br>          // We don't accept any more Advies's once we're closing <br>          sc = OLE_E_ADVISENOTSUPPORTED; <br>          goto error; <br>      } <br> <br>      if (lpServerDoc-&gt;m_lpDataAdviseHldr == NULL &amp;&amp; <br>         CreateDataAdviseHolder(&amp;lpServerDoc-&gt;m_lpDataAdviseHldr) <br>                                                != NOERROR) { <br>            sc = E_OUTOFMEMORY; <br>            goto error; <br>      } <br>      // artificial AddRef in case someone releases this object <br>      // during the next call <br>      OleDoc_DataObj_AddRef(lpThis); <br> <br>      OLEDBG_BEGIN2("IDataAdviseHolder::Advise called\r\n"); <br>      hrErr = lpServerDoc-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;Advise( <br>            lpServerDoc-&gt;m_lpDataAdviseHldr, <br>            (LPDATAOBJECT)&amp;lpOleDoc-&gt;m_DataObject, <br>            lpFormatetc, <br>            advf, <br>            lpAdvSink, <br>            lpdwConnection <br>      ); <br>      OLEDBG_END2 <br> <br>      // release artificial AddRef above <br>      OleDoc_DataObj_Release(lpThis); <br> <br>      OLEDBG_END2 <br>      return hrErr; <br>   } <br>#endif  // OLE_SVR <br>#if defined( OLE_CNTR ) <br>   { <br>      /* the Container-Only version of Outline does NOT offer <br>      **    IDataObject interface from its User documents. this is <br>      **    required by objects which can be embedded or linked. the <br>      **    Container-only app only allows linking to its contained <br>      **    objects, NOT the data of the container itself. <br>      */ <br>      OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n"); <br>      sc = E_NOTIMPL; <br>      goto error; <br>   } <br>#endif  // OLE_CNTR <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br> <br>// IDataObject::DUnadvise <br>STDMETHODIMP OleDoc_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection) <br>{ <br>   LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   SCODE sc; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_DUnadvise\r\n") <br> <br>   /* NOTE: a document that is used to transfer data (either via <br>   **    the clipboard or drag/drop) does NOT support Advise notifications. <br>   */ <br>   if (lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = OLE_E_ADVISENOTSUPPORTED; <br>      goto error; <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      HRESULT hrErr; <br> <br>      if (lpServerDoc-&gt;m_lpDataAdviseHldr == NULL) { <br>         sc = E_FAIL; <br>         goto error; <br>      } <br> <br>      // artificial AddRef in case someone releases this object <br>      // during the next call <br>      OleDoc_DataObj_AddRef(lpThis); <br> <br>      OLEDBG_BEGIN2("IDataAdviseHolder::Unadvise called\r\n"); <br>      hrErr = lpServerDoc-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;Unadvise( <br>            lpServerDoc-&gt;m_lpDataAdviseHldr, <br>            dwConnection <br>      ); <br>      OLEDBG_END2 <br> <br>      // release artifical AddRef <br>      OleDoc_DataObj_Release(lpThis); <br> <br>      OLEDBG_END2 <br>      return hrErr; <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      /* the Container-Only version of Outline does NOT offer <br>      **    IDataObject interface from its User documents. this is <br>      **    required by objects which can be embedded or linked. the <br>      **    Container-only app only allows linking to its contained <br>      **    objects, NOT the data of the container itself. <br>      */ <br>      OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n"); <br>      sc = E_NOTIMPL; <br>      goto error; <br>   } <br>#endif <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>// IDataObject::EnumDAdvise <br>STDMETHODIMP OleDoc_DataObj_EnumDAdvise( <br>      LPDATAOBJECT        lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>) <br>{ <br>   LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   SCODE sc; <br> <br>   OLEDBG_BEGIN2("OleDoc_DataObj_EnumDAdvise\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumAdvise = NULL; <br> <br>   /* NOTE: a document that is used to transfer data (either via <br>   **    the clipboard or drag/drop) does NOT support Advise notifications. <br>   */ <br>   if (lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = OLE_E_ADVISENOTSUPPORTED; <br>      goto error; <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      HRESULT hrErr; <br> <br>      if (lpServerDoc-&gt;m_lpDataAdviseHldr == NULL) { <br>         sc = E_FAIL; <br>         goto error; <br>      } <br> <br>      // artificial AddRef in case someone releases this <br>      // object during the next call <br>      OleDoc_DataObj_AddRef(lpThis); <br> <br>      OLEDBG_BEGIN2("IDataAdviseHolder::EnumAdvise called\r\n"); <br>      hrErr = lpServerDoc-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;EnumAdvise( <br>            lpServerDoc-&gt;m_lpDataAdviseHldr, <br>            lplpenumAdvise <br>      ); <br>      OLEDBG_END2 <br> <br>      // release artifical AddRef <br>      OleDoc_DataObj_Release(lpThis); <br> <br>      OLEDBG_END2 <br>      return hrErr; <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      /* the Container-Only version of Outline does NOT offer <br>      **    IDataObject interface from its User documents. this is <br>      **    required by objects which can be embedded or linked. the <br>      **    Container-only app only allows linking to its contained <br>      **    objects, NOT the data of the container itself. <br>      */ <br>      OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n"); <br>      sc = E_NOTIMPL; <br>      goto error; <br>   } <br>#endif <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br> <br>/************************************************************************* <br>** OleDoc Supprt Functions common to both Container and Server versions <br>*************************************************************************/ <br> <br> <br>/* OleDoc_CopyCommand <br> * ------------------ <br> *  Copy selection to clipboard. <br> *  Post to the clipboard the formats that the app can render. <br> *  the actual data is not rendered at this time. using the <br> *  delayed rendering technique, Windows will send the clipboard <br> *  owner window either a WM_RENDERALLFORMATS or a WM_RENDERFORMAT <br> *  message when the actual data is requested. <br> * <br> *    NOTE: the normal delayed rendering technique where Windows <br> *    sends the clipboard owner window either a WM_RENDERALLFORMATS or <br> *    a WM_RENDERFORMAT message when the actual data is requested is <br> *    NOT exposed to the app calling OleSetClipboard. OLE internally <br> *    creates its own window as the clipboard owner and thus our app <br> *    will NOT get these WM_RENDER messages. <br> */ <br>void OleDoc_CopyCommand(LPOLEDOC lpSrcOleDoc) <br>{ <br>   LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpClipboardDoc; <br> <br>   /* squirrel away a copy of the current selection to the ClipboardDoc */ <br>   lpClipboardDoc = OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc); <br> <br>   if (! lpClipboardDoc) <br>      return;     // Error: could not create DataTransferDoc <br> <br>   lpOutlineApp-&gt;m_lpClipboardDoc = (LPOUTLINEDOC)lpClipboardDoc; <br> <br>   /* NOTE: initially the Doc object is created with a 0 ref <br>   **    count. in order to have a stable Doc object during the <br>   **    process of initializing the Doc instance and transfering it <br>   **    to the clipboard, we intially AddRef the Doc ref cnt and later <br>   **    Release it. This initial AddRef is artificial; it is simply <br>   **    done to guarantee that a harmless QueryInterface followed by <br>   **    a Release does not inadvertantly force our object to destroy <br>   **    itself prematurely. <br>   */ <br>   OleDoc_AddRef((LPOLEDOC)lpClipboardDoc); <br> <br>   /* NOTE: the OLE 2.0 style to put data onto the clipboard is to <br>   **    give the clipboard a pointer to an IDataObject interface that <br>   **    is able to statisfy IDataObject::GetData calls to render <br>   **    data. in our case we give the pointer to the ClipboardDoc <br>   **    which holds a cloned copy of the current user's selection. <br>   */ <br>   OLEDBG_BEGIN2("OleSetClipboard called\r\n") <br>   OleSetClipboard((LPDATAOBJECT)&amp;((LPOLEDOC)lpClipboardDoc)-&gt;m_DataObject); <br>   OLEDBG_END2 <br> <br>   OleDoc_Release((LPOLEDOC)lpClipboardDoc);   // rel artificial AddRef above <br>} <br> <br> <br>/* OleDoc_PasteCommand <br>** ------------------- <br>**    Paste default format data from the clipboard. <br>**    In this function we choose the highest fidelity format that the <br>**    source clipboard IDataObject* offers that we understand. <br>** <br>**    NOTE: clipboard handling in an OLE 2.0 application is <br>**    different than normal Windows clipboard handling. Data from the <br>**    clipboard is retieved by getting the IDataObject* pointer <br>**    returned by calling OleGetClipboard. <br>*/ <br>void OleDoc_PasteCommand(LPOLEDOC lpOleDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPDATAOBJECT lpClipboardDataObj = NULL; <br>   BOOL fLink = FALSE; <br>   BOOL fLocalDataObj = FALSE; <br>   BOOL fStatus; <br>   HRESULT hrErr; <br> <br>   hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&amp;lpClipboardDataObj); <br>   if (hrErr != NOERROR) <br>      return;     // Clipboard seems to be empty or can't be accessed <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>   /* check if the data on the clipboard is local to our application <br>   **    instance. <br>   */ <br>   if (lpOutlineApp-&gt;m_lpClipboardDoc) { <br>      LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br>      if (lpClipboardDataObj == (LPDATAOBJECT)&amp;lpOleDoc-&gt;m_DataObject) <br>         fLocalDataObj = TRUE; <br>   } <br> <br>   fStatus = OleDoc_PasteFromData( <br>         lpOleDoc, <br>         lpClipboardDataObj, <br>         fLocalDataObj, <br>         fLink <br>   ); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br> <br>   if (! fStatus) <br>      OutlineApp_ErrorMessage(g_lpApp,OLESTR("Could not paste data from clipboard!")); <br> <br>   if (lpClipboardDataObj) <br>      OleStdRelease((LPUNKNOWN)lpClipboardDataObj); <br>} <br> <br> <br>/* OleDoc_PasteSpecialCommand <br>** -------------------------- <br>**    Allow the user to paste data in a particular format from the <br>**    clipboard. The paste special command displays a dialog to the <br>**    user that allows him to choose the format to be pasted from the <br>**    list of formats available. <br>** <br>**    NOTE: the PasteSpecial dialog is one of the standard OLE 2.0 <br>**    UI dialogs for which the dialog is implemented and in the OLE2UI <br>**    library. <br>** <br>**    NOTE: clipboard handling in an OLE 2.0 application is <br>**    different than normal Windows clipboard handling. Data from the <br>**    clipboard is retieved by getting the IDataObject* pointer <br>**    returned by calling OleGetClipboard. <br>*/ <br>void OleDoc_PasteSpecialCommand(LPOLEDOC lpOleDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPDATAOBJECT lpClipboardDataObj = NULL; <br>   CLIPFORMAT cfFormat; <br>   int nFmtEtc; <br>   UINT uInt; <br>   BOOL fLink = FALSE; <br>   BOOL fLocalDataObj = FALSE; <br>   BOOL fStatus; <br>   HRESULT hrErr; <br>   OLEUIPASTESPECIAL ouiPasteSpl; <br>   BOOL fDisplayAsIcon; <br> <br>   hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&amp;lpClipboardDataObj); <br>   if (hrErr != NOERROR) <br>      return;     // Clipboard seems to be empty or can't be accessed <br> <br>   /* check if the data on the clipboard is local to our application <br>   **    instance. <br>   */ <br>   if (lpOutlineApp-&gt;m_lpClipboardDoc) { <br>      LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br>      if (lpClipboardDataObj == (LPDATAOBJECT)&amp;lpOleDoc-&gt;m_DataObject) <br>         fLocalDataObj = TRUE; <br>   } <br> <br>   /* Display the PasteSpecial dialog and allow the user to select the <br>   **    format to paste. <br>   */ <br>   _fmemset((LPOLEUIPASTESPECIAL)&amp;ouiPasteSpl, 0, sizeof(OLEUIPASTESPECIAL)); <br>   ouiPasteSpl.cbStruct = sizeof(OLEUIPASTESPECIAL);       //Structure Size <br>   ouiPasteSpl.dwFlags =  PSF_SELECTPASTE | PSF_SHOWHELP;  //IN-OUT:  Flags <br>   ouiPasteSpl.hWndOwner = lpOutlineApp-&gt;m_lpDoc-&gt;m_hWndDoc; //Owning window <br>   ouiPasteSpl.lpszCaption = "Paste Special";    //Dialog caption bar contents <br>   ouiPasteSpl.lpfnHook = NULL;       //Hook callback <br>   ouiPasteSpl.lCustData = 0;         //Custom data to pass to hook <br>   ouiPasteSpl.hInstance = NULL;      //Instance for customized template name <br>   ouiPasteSpl.lpszTemplate = NULL;   //Customized template name <br>   ouiPasteSpl.hResource = NULL;      //Customized template handle <br> <br>   ouiPasteSpl.arrPasteEntries = lpOleApp-&gt;m_arrPasteEntries; <br>   ouiPasteSpl.cPasteEntries = lpOleApp-&gt;m_nPasteEntries; <br>   ouiPasteSpl.lpSrcDataObj = lpClipboardDataObj; <br>   ouiPasteSpl.arrLinkTypes = lpOleApp-&gt;m_arrLinkTypes; <br>   ouiPasteSpl.cLinkTypes = lpOleApp-&gt;m_nLinkTypes; <br>   ouiPasteSpl.cClsidExclude = 0; <br> <br>   OLEDBG_BEGIN3("OleUIPasteSpecial called\r\n") <br>   uInt = OleUIPasteSpecial(&amp;ouiPasteSpl); <br>   OLEDBG_END3 <br> <br>   fDisplayAsIcon = <br>         (ouiPasteSpl.dwFlags &amp; PSF_CHECKDISPLAYASICON ? TRUE : FALSE); <br> <br>   if (uInt == OLEUI_OK) { <br>      nFmtEtc = ouiPasteSpl.nSelectedIndex; <br>      fLink =  ouiPasteSpl.fLink; <br> <br>      if (nFmtEtc &lt; 0 || nFmtEtc &gt;= lpOleApp-&gt;m_nPasteEntries) { <br>         OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgBadFmt); <br>         goto error; <br>      } <br> <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>      cfFormat = lpOleApp-&gt;m_arrPasteEntries[nFmtEtc].fmtetc.cfFormat; <br> <br>      fStatus = OleDoc_PasteFormatFromData( <br>            lpOleDoc, <br>            cfFormat, <br>            lpClipboardDataObj, <br>            fLocalDataObj, <br>            fLink, <br>            fDisplayAsIcon, <br>            ouiPasteSpl.hMetaPict, <br>            (LPSIZEL)&amp;ouiPasteSpl.sizel <br>      ); <br> <br>      OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br> <br>      if (! fStatus) { <br>         OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPasteFailed); <br>         goto error; <br>      } <br> <br>   } else if (uInt == OLEUI_PSERR_CLIPBOARDCHANGED) { <br>      /* NOTE: this error code is returned when the contents of <br>      **    the clipboard change while the PasteSpecial dialog is up. <br>      **    in this situation the PasteSpecial dialog automatically <br>      **    brings itself down and NO paste operation should be performed. <br>      */ <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgClipboardChanged); <br>   } <br> <br>error: <br> <br>   if (lpClipboardDataObj) <br>      OleStdRelease((LPUNKNOWN)lpClipboardDataObj); <br> <br>   if (uInt == OLEUI_OK &amp;&amp; ouiPasteSpl.hMetaPict) <br>      // clean up metafile <br>      OleUIMetafilePictIconFree(ouiPasteSpl.hMetaPict); <br>} <br> <br> <br> <br>/* OleDoc_CreateDataTransferDoc <br> * ---------------------------- <br> * <br> *      Create a document to be use to transfer data (either via a <br> *  drag/drop operation of the clipboard). Copy the selection of the <br> *  source doc to the data transfer document. A data transfer document is <br> *  the same as a document that is created by the user except that it is <br> *  NOT made visible to the user. it is specially used to hold a copy of <br> *  data that the user should not be able to change. <br> * <br> *  NOTE: in the OLE version the data transfer document is used <br> *      specifically to provide an IDataObject* that renders the data copied. <br> */ <br>LPOUTLINEDOC OleDoc_CreateDataTransferDoc(LPOLEDOC lpSrcOleDoc) <br>{ <br>   LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpDestOutlineDoc; <br>   LPLINELIST lpSrcLL = &amp;lpSrcOutlineDoc-&gt;m_LineList; <br>   LINERANGE lrSel; <br>   int nCopied; <br> <br>   lpDestOutlineDoc = OutlineApp_CreateDoc(lpOutlineApp, TRUE); <br>   if (! lpDestOutlineDoc) return NULL; <br> <br>   // set the ClipboardDoc to an (Untitled) doc. <br>   if (! OutlineDoc_InitNewFile(lpDestOutlineDoc)) <br>      goto error; <br> <br>   LineList_GetSel(lpSrcLL, (LPLINERANGE)&amp;lrSel); <br>   nCopied = LineList_CopySelToDoc( <br>         lpSrcLL, <br>         (LPLINERANGE)&amp;lrSel, <br>         lpDestOutlineDoc <br>   ); <br> <br>   if (nCopied != (lrSel.m_nEndLine - lrSel.m_nStartLine + 1)) { <br>      OleDbgAssertSz(FALSE,"OleDoc_CreateDataTransferDoc: entire selection NOT copied\r\n"); <br>      goto error;     // ERROR: all lines could NOT be copied <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPOLEDOC lpSrcOleDoc = (LPOLEDOC)lpSrcOutlineDoc; <br>      LPOLEDOC lpDestOleDoc = (LPOLEDOC)lpDestOutlineDoc; <br>      LPSERVERDOC lpDestServerDoc = (LPSERVERDOC)lpDestOutlineDoc; <br>      LPMONIKER lpmkDoc = NULL; <br>      LPMONIKER lpmkItem = NULL; <br> <br>      /* If source document is able to provide a moniker, then the <br>      **    destination document (lpDestOutlineDoc) should offer <br>      **    CF_LINKSOURCE via its IDataObject interface that it gives <br>      **    to the clipboard or the drag/drop operation. <br>      ** <br>      **    NOTE: we want to ask the source document if it can <br>      **    produce a moniker, but we do NOT want to FORCE moniker <br>      **    assignment at this point. we only want to FORCE moniker <br>      **    assignment later if a Paste Link occurs (ie. GetData for <br>      **    CF_LINKSOURCE). if the source document is able to give </code></pre>
<p>
</p>
<pre><code>**    a moniker, then we store a pointer to the source document <br>      **    so we can ask it at a later time to get the moniker. we <br>      **    also save the range of the current selection so we can <br>      **    generate a proper item name later when Paste Link occurs. <br>      **    Also we need to give a string which identifies the source <br>      **    of the copy in the CF_OBJECTDESCRIPTOR format. this <br>      **    string is used to display in the PasteSpecial dialog. we <br>      **    get and store a TEMPFORUSER moniker which identifies the <br>      **    source of copy. <br>      */ <br>      lpDestOleDoc-&gt;m_lpSrcDocOfCopy = lpSrcOleDoc; <br>      lpmkDoc = OleDoc_GetFullMoniker(lpSrcOleDoc, GETMONIKER_TEMPFORUSER); <br>      if (lpmkDoc != NULL) { <br>         lpDestOleDoc-&gt;m_fLinkSourceAvail = TRUE; <br>         lpDestServerDoc-&gt;m_lrSrcSelOfCopy = lrSel; <br>         OleStdRelease((LPUNKNOWN)lpmkDoc); <br>      } <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      LPOLEDOC lpSrcOleDoc = (LPOLEDOC)lpSrcOutlineDoc; <br>      LPOLEDOC lpDestOleDoc = (LPOLEDOC)lpDestOutlineDoc; <br>      LPCONTAINERDOC lpDestContainerDoc = (LPCONTAINERDOC)lpDestOutlineDoc; <br> <br>      /* If one line was copied from the source document, and it was a <br>      **    single OLE object, then the destination document should <br>      **    offer additional data formats to allow the transfer of <br>      **    the OLE object via IDataObject::GetData. Specifically, the <br>      **    following additional data formats are offered if a single <br>      **    OLE object is copied: <br>      **          CF_EMBEDDEDOBJECT <br>      **          CF_OBJECTDESCRIPTOR     (should be given even w/o object) <br>      **          CF_METAFILEPICT         (note: dwAspect depends on object) <br>      **          CF_LINKSOURCE           -- if linking is possible <br>      **          CF_LINKSOURCEDESCRIPTOR -- if linking is possible <br>      ** <br>      **    optionally the container may give <br>      **          &lt;data format available in OLE object's cache&gt; <br>      */ <br> <br>      if (nCopied == 1) { <br>         LPOLEOBJECT lpSrcOleObj; <br>         LPCONTAINERLINE lpSrcContainerLine; <br>         DWORD dwStatus; <br> <br>         lpSrcContainerLine = (LPCONTAINERLINE)LineList_GetLine( <br>               lpSrcLL, <br>               lrSel.m_nStartLine <br>         ); <br> <br>         if (! lpSrcContainerLine) <br>            goto error; <br> <br>         lpDestOleDoc-&gt;m_lpSrcDocOfCopy = lpSrcOleDoc; <br> <br>         if ((((LPLINE)lpSrcContainerLine)-&gt;m_lineType==CONTAINERLINETYPE) <br>               &amp;&amp; ((lpSrcOleObj=lpSrcContainerLine-&gt;m_lpOleObj)!=NULL)) { <br> <br>            lpDestContainerDoc-&gt;m_fEmbeddedObjectAvail = TRUE; <br>            lpSrcOleObj-&gt;lpVtbl-&gt;GetUserClassID( <br>                  lpSrcOleObj, <br>                  &amp;lpDestContainerDoc-&gt;m_clsidOleObjCopied <br>            ); <br>            lpDestContainerDoc-&gt;m_dwAspectOleObjCopied = <br>                     lpSrcContainerLine-&gt;m_dwDrawAspect; <br> <br>            /* NOTE: if the object is allowed to be linked <br>            **    to from the inside (ie. we are allowed to <br>            **    give out a moniker which binds to the running <br>            **    OLE object), then we want to offer <br>            **    CF_LINKSOURCE format. if the object is an OLE <br>            **    2.0 embedded object then it is allowed to be <br>            **    linked to from the inside. if the object is <br>            **    either an OleLink or an OLE 1.0 embedding <br>            **    then it can not be linked to from the inside. <br>            **    if we were a container/server app then we <br>            **    could offer linking to the outside of the <br>            **    object (ie. a pseudo object within our <br>            **    document). we are a container only app that <br>            **    does not support linking to ranges of its data. <br>            */ <br> <br>            lpSrcOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>                  lpSrcOleObj, <br>                  DVASPECT_CONTENT, /* aspect is not important */ <br>                  (LPDWORD)&amp;dwStatus <br>            ); <br>            if (! (dwStatus &amp; OLEMISC_CANTLINKINSIDE)) { <br>               /* Our container supports linking to an embedded <br>               **    object. We want the lpDestContainerDoc to <br>               **    offer CF_LINKSOURCE via the IDataObject <br>               **    interface that it gives to the clipboard or <br>               **    the drag/drop operation. The link source will <br>               **    be identified by a composite moniker <br>               **    comprised of the FileMoniker of the source <br>               **    document and an ItemMoniker which identifies <br>               **    the OLE object inside the container. we do <br>               **    NOT want to force moniker assignment to the <br>               **    OLE object now (at copy time); we only want <br>               **    to FORCE moniker assignment later if a Paste <br>               **    Link occurs (ie. GetData for CF_LINKSOURCE). <br>               **    thus we store a pointer to the source document <br>               **    and the source ContainerLine so we can <br>               **    generate a proper ItemMoniker later when <br>               **    Paste Link occurs. <br>               */ <br>               lpDestOleDoc-&gt;m_fLinkSourceAvail = TRUE; <br>               lpDestContainerDoc-&gt;m_lpSrcContainerLine = <br>                     lpSrcContainerLine; <br>            } <br>         } <br>      } <br>   } <br> <br>#endif  // OLE_CNTR <br> <br>   return lpDestOutlineDoc; <br> <br>error: <br>   if (lpDestOutlineDoc) <br>      OutlineDoc_Destroy(lpDestOutlineDoc); <br> <br>   return NULL; <br>} <br> <br> <br>/* OleDoc_PasteFromData <br>** -------------------- <br>** <br>**    Paste data from an IDataObject*. The IDataObject* may come from <br>**    the clipboard (GetClipboard) or from a drag/drop operation. <br>**    In this function we choose the best format that we prefer. <br>** <br>**    Returns TRUE if data was successfully pasted. <br>**            FALSE if data could not be pasted. <br>*/ <br> <br>BOOL OleDoc_PasteFromData( <br>      LPOLEDOC            lpOleDoc, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLocalDataObj, <br>      BOOL                fLink <br>) <br>{ <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   CLIPFORMAT      cfFormat; <br>   BOOL            fDisplayAsIcon = FALSE; <br>   SIZEL           sizelInSrc = {0, 0}; <br>   HGLOBAL         hMem = NULL; <br>   HGLOBAL         hMetaPict = NULL; <br>   STGMEDIUM       medium; <br> <br>   if (fLink) { <br>#if defined( OLE_SERVER ) <br>      return FALSE;       // server version of app does NOT support links <br>#endif <br>#if defined( OLE_CNTR ) <br>      // container version of app only supports OLE object type links <br>      cfFormat = lpOleApp-&gt;m_cfLinkSource; <br>#endif <br> <br>   } else { <br> <br>      int nFmtEtc; <br> <br>      nFmtEtc = OleStdGetPriorityClipboardFormat( <br>            lpSrcDataObj, <br>            lpOleApp-&gt;m_arrPasteEntries, <br>            lpOleApp-&gt;m_nPasteEntries <br>      ); <br> <br>      if (nFmtEtc &lt; 0) <br>         return FALSE;   // there is no format we like <br> <br>      cfFormat = lpOleApp-&gt;m_arrPasteEntries[nFmtEtc].fmtetc.cfFormat; <br>   } <br> <br>   /* NOTE: we need to check what dwDrawAspect is being <br>   **    transfered. if the data is an object that is displayed as an <br>   **    icon in the source, then we want to keep it as an icon. the <br>   **    aspect the object is displayed in at the source is transfered <br>   **    via the CF_OBJECTDESCRIPTOR format for a Paste operation. <br>   */ <br>   if (hMem = OleStdGetData( <br>         lpSrcDataObj, <br>         (CLIPFORMAT)lpOleApp-&gt;m_cfObjectDescriptor, <br>         NULL, <br>         DVASPECT_CONTENT, <br>         (LPSTGMEDIUM)&amp;medium)) { <br>      LPOBJECTDESCRIPTOR lpOD = GlobalLock(hMem); <br>      fDisplayAsIcon = (lpOD-&gt;dwDrawAspect == DVASPECT_ICON ? TRUE : FALSE); <br>      sizelInSrc = lpOD-&gt;sizel;   // size of object/picture in source (opt.) <br>      GlobalUnlock(hMem); <br>      ReleaseStgMedium((LPSTGMEDIUM)&amp;medium);     // equiv to GlobalFree <br> <br>      if (fDisplayAsIcon) { <br>         hMetaPict = OleStdGetData( <br>               lpSrcDataObj, <br>               CF_METAFILEPICT, <br>               NULL, <br>               DVASPECT_ICON, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         if (hMetaPict == NULL) <br>            fDisplayAsIcon = FALSE; // give up; failed to get icon MFP <br>      } <br>   } <br> <br>   return OleDoc_PasteFormatFromData( <br>         lpOleDoc, <br>         cfFormat, <br>         lpSrcDataObj, <br>         fLocalDataObj, <br>         fLink, <br>         fDisplayAsIcon, <br>         hMetaPict, <br>         (LPSIZEL)&amp;sizelInSrc <br>   ); <br> <br>   if (hMetaPict) <br>      ReleaseStgMedium((LPSTGMEDIUM)&amp;medium);  // properly free METAFILEPICT <br>} <br> <br> <br>/* OleDoc_PasteFormatFromData <br>** -------------------------- <br>** <br>**    Paste a particular data format from a IDataObject*. The <br>**    IDataObject* may come from the clipboard (GetClipboard) or from a <br>**    drag/drop operation. <br>** <br>**    Returns TRUE if data was successfully pasted. <br>**            FALSE if data could not be pasted. <br>*/ <br> <br>BOOL OleDoc_PasteFormatFromData( <br>      LPOLEDOC            lpOleDoc, <br>      CLIPFORMAT          cfFormat, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLocalDataObj, <br>      BOOL                fLink, <br>      BOOL                fDisplayAsIcon, <br>      HGLOBAL             hMetaPict, <br>      LPSIZEL             lpSizelInSrc <br>) <br>{ <br>#if defined( OLE_SERVER ) <br>   /* call server specific version of the function. */ <br>   return ServerDoc_PasteFormatFromData( <br>         (LPSERVERDOC)lpOleDoc, <br>         cfFormat, <br>         lpSrcDataObj, <br>         fLocalDataObj, <br>         fLink <br>   ); <br>#endif <br>#if defined( OLE_CNTR ) <br> <br>   /* call container specific version of the function. */ <br>   return ContainerDoc_PasteFormatFromData( <br>         (LPCONTAINERDOC)lpOleDoc, <br>         cfFormat, <br>         lpSrcDataObj, <br>         fLocalDataObj, <br>         fLink, <br>         fDisplayAsIcon, <br>         hMetaPict, <br>         lpSizelInSrc <br>   ); <br>#endif <br>} <br> <br> <br>/* OleDoc_QueryPasteFromData <br>** ------------------------- <br>** <br>**    Check if the IDataObject* offers data in a format that we can <br>**    paste. The IDataObject* may come from the clipboard <br>**    (GetClipboard) or from a drag/drop operation. <br>** <br>**    Returns TRUE if paste can be performed <br>**            FALSE if paste is not possible. <br>*/ <br> <br>BOOL OleDoc_QueryPasteFromData( <br>      LPOLEDOC            lpOleDoc, <br>      LPDATAOBJECT        lpSrcDataObj, <br>      BOOL                fLink <br>) <br>{ <br>#if defined( OLE_SERVER ) <br>   return ServerDoc_QueryPasteFromData( <br>         (LPSERVERDOC) lpOleDoc, <br>         lpSrcDataObj, <br>         fLink <br>   ); <br>#endif <br>#if defined( OLE_CNTR ) <br> <br>   return ContainerDoc_QueryPasteFromData( <br>         (LPCONTAINERDOC) lpOleDoc, <br>         lpSrcDataObj, <br>         fLink <br>   ); <br>#endif <br>} <br> <br> <br>/* OleDoc_GetExtent <br> * ---------------- <br> * <br> *      Get the extent (width, height) of the entire document in Himetric. <br> */ <br>void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel) <br>{ <br>   LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br> <br>   LineList_CalcSelExtentInHimetric(lpLL, NULL, lpsizel); <br>} <br> <br> <br>/* OleDoc_GetObjectDescriptorData <br> * ------------------------------ <br> * <br> * Return a handle to an object's data in CF_OBJECTDESCRIPTOR form <br> * <br> */ <br>HGLOBAL OleDoc_GetObjectDescriptorData(LPOLEDOC lpOleDoc, LPLINERANGE lplrSel) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br> <br>   /* Only our data transfer doc renders CF_OBJECTDESCRIPTOR */ <br>   OleDbgAssert(lpOutlineDoc-&gt;m_fDataTransferDoc); <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC   lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      SIZEL         sizel; <br>      POINTL        pointl; <br>      LPOLESTR      lpszSrcOfCopy = NULL; <br>      IBindCtx  FAR *pbc = NULL; <br>      HGLOBAL       hObjDesc; <br>      DWORD         dwStatus = 0; <br>      LPOUTLINEDOC  lpSrcDocOfCopy=(LPOUTLINEDOC)lpOleDoc-&gt;m_lpSrcDocOfCopy; <br>      LPMONIKER lpSrcMonikerOfCopy = ServerDoc_GetSelFullMoniker( <br>            (LPSERVERDOC)lpOleDoc-&gt;m_lpSrcDocOfCopy, <br>            &amp;lpServerDoc-&gt;m_lrSrcSelOfCopy, <br>            GETMONIKER_TEMPFORUSER <br>      ); <br> <br>      SvrDoc_OleObj_GetMiscStatus( <br>            (LPOLEOBJECT)&amp;lpServerDoc-&gt;m_OleObject, <br>            DVASPECT_CONTENT, <br>            &amp;dwStatus <br>      ); <br> <br>      OleDoc_GetExtent(lpOleDoc, &amp;sizel); <br>      pointl.x = pointl.y = 0; <br> <br>      if (lpSrcMonikerOfCopy) { <br>         CreateBindCtx(0, (LPBC FAR*)&amp;pbc); <br>         lpSrcMonikerOfCopy-&gt;lpVtbl-&gt;GetDisplayName( <br>            lpSrcMonikerOfCopy, pbc, NULL, &amp;lpszSrcOfCopy); <br>         pbc-&gt;lpVtbl-&gt;Release(pbc); <br>         lpSrcMonikerOfCopy-&gt;lpVtbl-&gt;Release(lpSrcMonikerOfCopy); <br>      } else { <br>         /* this document has no moniker; use our FullUserTypeName <br>         **    as the description of the source of copy. <br>         */ <br>         lpszSrcOfCopy = FULLUSERTYPENAME; <br>      } <br> <br>      hObjDesc =  OleStdGetObjectDescriptorData( <br>            CLSID_APP, <br>            DVASPECT_CONTENT, <br>            sizel, <br>            pointl, <br>            dwStatus, <br>            FULLUSERTYPENAME, <br>            lpszSrcOfCopy <br>      ); <br> <br>      if (lpSrcMonikerOfCopy &amp;&amp; lpszSrcOfCopy) <br>         OleStdFreeString(lpszSrcOfCopy, NULL); <br>      return hObjDesc; <br> <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br>      LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>      LPCONTAINERLINE lpContainerLine; <br>      HGLOBAL hObjDesc; <br>      BOOL fSelIsOleObject = FALSE; <br>      LPOLEOBJECT lpOleObj; <br>      SIZEL sizel; <br>      POINTL pointl; <br> <br>      if ( lpLL-&gt;m_nNumLines == 1 ) { <br>         fSelIsOleObject = ContainerDoc_IsSelAnOleObject( <br>               lpContainerDoc, <br>               &amp;IID_IOleObject, <br>               (LPUNKNOWN FAR*)&amp;lpOleObj, <br>               NULL,    /* we don't need the line index */ <br>               (LPCONTAINERLINE FAR*)&amp;lpContainerLine <br>         ); <br>      } <br> <br>      pointl.x = pointl.y = 0; <br> <br>      if (fSelIsOleObject) { <br>         /* NOTE: a single OLE object is being transfered via <br>         **    this DataTransferDoc. we need to generate the <br>         **    CF_ObjectDescrioptor which describes the OLE object. <br>         */ <br> <br>         LPOUTLINEDOC lpSrcOutlineDoc = <br>               (LPOUTLINEDOC)lpOleDoc-&gt;m_lpSrcDocOfCopy; <br>         LPOLESTR lpszSrcOfCopy = lpSrcOutlineDoc-&gt;m_szFileName; <br>         BOOL fFreeSrcOfCopy = FALSE; <br>         SIZEL sizelOleObject; <br>         LPLINE lpLine = (LPLINE)lpContainerLine; <br> <br>         /* if the object copied can be linked to then get a <br>         **    TEMPFORUSER form of the moniker which identifies the <br>         **    source of copy. we do not want to force the <br>         **    assignment of the moniker until CF_LINKSOURCE is <br>         **    rendered. <br>         **    if the object copied can not be a link source then use <br>         **    the source filename to identify the source of copy. <br>         **    there is no need to generate a moniker for the object <br>         **    copied. <br>         */ <br>         if (lpOleDoc-&gt;m_fLinkSourceAvail &amp;&amp; <br>               lpContainerDoc-&gt;m_lpSrcContainerLine) { <br>            LPBINDCTX pbc = NULL; <br>            LPMONIKER lpSrcMonikerOfCopy = ContainerLine_GetFullMoniker( <br>                  lpContainerDoc-&gt;m_lpSrcContainerLine, <br>                  GETMONIKER_TEMPFORUSER <br>            ); <br>            if (lpSrcMonikerOfCopy) { <br>               CreateBindCtx(0, (LPBC FAR*)&amp;pbc); <br>               if (pbc != NULL) { <br>                  lpSrcMonikerOfCopy-&gt;lpVtbl-&gt;GetDisplayName( <br>                        lpSrcMonikerOfCopy, pbc, NULL,&amp;lpszSrcOfCopy); <br>                  pbc-&gt;lpVtbl-&gt;Release(pbc); <br>                  fFreeSrcOfCopy = TRUE; <br>               } <br>               lpSrcMonikerOfCopy-&gt;lpVtbl-&gt;Release(lpSrcMonikerOfCopy); <br>            } <br>         } <br> <br>         /* NOTE: Get size that object is being drawn. If the <br>         **    object has been scaled because the user resized the <br>         **    object, then we want to pass the scaled size of the <br>         **    object in the ObjectDescriptor rather than the size <br>         **    that the object would return via <br>         **    IOleObject::GetExtent and IViewObject2::GetExtent. in <br>         **    this way if the object is transfered to another container <br>         **    (via clipboard or drag/drop), then the object will <br>         **    remain the scaled size. <br>         */ <br>         sizelOleObject.cx = lpLine-&gt;m_nWidthInHimetric; <br>         sizelOleObject.cy = lpLine-&gt;m_nHeightInHimetric; <br> <br>         hObjDesc = OleStdGetObjectDescriptorDataFromOleObject( <br>               lpOleObj, <br>               lpszSrcOfCopy, <br>               lpContainerLine-&gt;m_dwDrawAspect, <br>               pointl, <br>               (LPSIZEL)&amp;sizelOleObject <br>         ); <br> <br>         if (fFreeSrcOfCopy &amp;&amp; lpszSrcOfCopy) <br>            OleStdFreeString(lpszSrcOfCopy, NULL); <br>         OleStdRelease((LPUNKNOWN)lpOleObj); <br>         return hObjDesc; <br>      } else { <br>         /* NOTE: the data being transfered via this <br>         **    DataTransferDoc is NOT a single OLE object. thus in <br>         **    this case the CF_ObjectDescriptor data should <br>         **    describe our container app itself. <br>         */ <br>         OleDoc_GetExtent(lpOleDoc, &amp;sizel); <br>         return OleStdGetObjectDescriptorData( <br>               CLSID_NULL, /* not used if no object formats */ <br>               DVASPECT_CONTENT, <br>               sizel, <br>               pointl, <br>               0, <br>               NULL,       /* UserTypeName not used if no obj fmt's */ <br>               FULLUSERTYPENAME   /* string to identify source of copy */ <br>         ); <br> <br>      } <br>   } <br>#endif  // OLE_CNTR <br>} <br> <br> <br>#if defined( OLE_SERVER ) <br> <br>/************************************************************************* <br>** ServerDoc Supprt Functions Used by Server versions <br>*************************************************************************/ <br> <br> <br>/* ServerDoc_PasteFormatFromData <br>** ----------------------------- <br>** <br>**    Paste a particular data format from a IDataObject*. The <br>**    IDataObject* may come from the clipboard (GetClipboard) or from a <br>**    drag/drop operation. <br>** <br>**    NOTE: fLink is specified then FALSE if returned because the <br>**    Server only version of the app can not support links. <br>** <br>**    Returns TRUE if data was successfully pasted. <br>**            FALSE if data could not be pasted. <br>*/ <br>BOOL ServerDoc_PasteFormatFromData( <br>      LPSERVERDOC             lpServerDoc, <br>      CLIPFORMAT              cfFormat, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLocalDataObj, <br>      BOOL                    fLink <br>) <br>{ <br>   LPLINELIST   lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpServerDoc)-&gt;m_LineList; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP     lpOleApp = (LPOLEAPP)g_lpApp; <br>   int          nIndex; <br>   int          nCount = 0; <br>   HGLOBAL      hData; <br>   STGMEDIUM    medium; <br>   LINERANGE    lrSel; <br> <br>   if (LineList_GetCount(lpLL) == 0) <br>      nIndex = -1;    // pasting to empty list <br>   else <br>      nIndex=LineList_GetFocusLineIndex(lpLL); <br> <br>   if (fLink) { <br>      /* We should paste a Link to the data, but we do not support links */ <br>      return FALSE; <br> <br>   } else { <br> <br>      if (cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br> <br>         hData = OleStdGetData( <br>               lpSrcDataObj, <br>               (CLIPFORMAT)lpOutlineApp-&gt;m_cfOutline, <br>               NULL, <br>               DVASPECT_CONTENT, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         if (hData == NULL) <br>            return FALSE; <br> <br>         nCount = OutlineDoc_PasteOutlineData( <br>               (LPOUTLINEDOC)lpServerDoc, <br>               hData, <br>               nIndex <br>         ); <br>         // NOTE: we must free data handle by releasing the medium <br>         ReleaseStgMedium((LPSTGMEDIUM)&amp;medium); <br> <br>      } else if(cfFormat == CF_TEXT) { <br> <br>         hData = OleStdGetData( <br>               lpSrcDataObj, <br>               CF_TEXT, <br>               NULL, <br>               DVASPECT_CONTENT, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         if (hData == NULL) <br>            return FALSE; <br> <br>         nCount = OutlineDoc_PasteTextData( <br>               (LPOUTLINEDOC)lpServerDoc, <br>               hData, <br>               nIndex <br>         ); <br>         // NOTE: we must free data handle by releasing the medium <br>         ReleaseStgMedium((LPSTGMEDIUM)&amp;medium); <br>      } <br>   } <br> <br>   lrSel.m_nEndLine   = nIndex + 1; <br>   lrSel.m_nStartLine = nIndex + nCount; <br>   LineList_SetSel(lpLL, &amp;lrSel); <br>   return TRUE; <br>} <br> <br> <br>/* ServerDoc_QueryPasteFromData <br>** ---------------------------- <br>** <br>**    Check if the IDataObject* offers data in a format that we can <br>**    paste. The IDataObject* may come from the clipboard <br>**    (GetClipboard) or from a drag/drop operation. <br>**    In this function we look if one of the following formats is <br>**    offered: <br>**              CF_OUTLINE <br>**              CF_TEXT <br>** <br>**    NOTE: fLink is specified then FALSE if returned because the <br>**    Server only version of the app can not support links. <br>** <br>**    Returns TRUE if paste can be performed <br>**            FALSE if paste is not possible. <br>*/ <br>BOOL ServerDoc_QueryPasteFromData( <br>      LPSERVERDOC             lpServerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLink <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br> <br>   if (fLink) { <br>      /* we do not support links */ <br>      return FALSE; <br> <br>   } else { <br> <br>      int nFmtEtc; <br> <br>      nFmtEtc = OleStdGetPriorityClipboardFormat( <br>            lpSrcDataObj, <br>            lpOleApp-&gt;m_arrPasteEntries, <br>            lpOleApp-&gt;m_nPasteEntries <br>         ); <br> <br>      if (nFmtEtc &lt; 0) <br>         return FALSE;   // there is no format we like <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* ServerDoc_GetData <br> * ----------------- <br> * <br> * Render data from the document on a CALLEE allocated STGMEDIUM. <br> *      This routine is called via IDataObject::GetData. <br> */ <br> <br>HRESULT ServerDoc_GetData ( <br>      LPSERVERDOC             lpServerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>) <br>{ <br>   LPOLEDOC  lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br>   HRESULT hrErr; <br>   SCODE sc; <br> <br>   // NOTE: we must set out pointer parameters to NULL <br>   lpMedium-&gt;pUnkForRelease = NULL; <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   lpMedium-&gt;tymed = TYMED_NULL; <br>   lpMedium-&gt;pUnkForRelease = NULL;    // we transfer ownership to caller <br>   lpMedium-&gt;u.hGlobal = NULL; <br> <br>   if(lpformatetc-&gt;cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetOutlineData (lpOutlineDoc,NULL); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_OUTLINE\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; DVASPECT_CONTENT) ) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_MFPICT)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = ServerDoc_GetMetafilePictData(lpServerDoc,NULL); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_MFPICT; <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_METAFILEPICT\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; DVASPECT_ICON) ) { <br>      CLSID clsid; <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_MFPICT)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      /* NOTE: we should return the default icon for our class. <br>      **    we must be carefull to use the correct CLSID here. <br>      **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>      **    operation then we need to use the class of the object <br>      **    written in the storage of the object. otherwise we would <br>      **    use our own class id. <br>      */ <br>      if (ServerDoc_GetClassID(lpServerDoc, (LPCLSID)&amp;clsid) != NOERROR) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal=GetIconOfClass(g_lpApp-&gt;m_hInst,(REFCLSID)&amp;clsid, NULL, FALSE); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_MFPICT; <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_METAFILEPICT (icon)\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_TEXT) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetTextData ( <br>            (LPOUTLINEDOC)lpServerDoc, <br>            NULL <br>      ); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_TEXT\r\n"); <br>      return NOERROR; <br>   } <br> <br>   /* the above are the only formats supports by a user document (ie. <br>   **    a non-data transfer doc). if the document is used for <br>   **    purposes of data transfer, then additional formats are offered. <br>   */ <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = DV_E_FORMATETC; <br>      goto error; <br>   } <br> <br>   /* NOTE: ObjectDescriptor and LinkSrcDescriptor will <br>   **    contain the same data for the pure container and pure server <br>   **    type applications. only a container/server application may <br>   **    have different content for ObjectDescriptor and <br>   **    LinkSrcDescriptor. if a container/server copies a link for <br>   **    example, then the ObjectDescriptor would give the class <br>   **    of the link source but the LinkSrcDescriptor would give the <br>   **    class of the container/server itself. in this situation if a <br>   **    paste operation occurs, an equivalent link is pasted, but if <br>   **    a pastelink operation occurs, then a link to a pseudo object <br>   **    in the container/server is created. <br>   */ <br>   if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfObjectDescriptor || <br>      (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSrcDescriptor &amp;&amp; <br>            lpOleDoc-&gt;m_fLinkSourceAvail)) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OleDoc_GetObjectDescriptorData ( <br>            (LPOLEDOC)lpServerDoc, <br>            NULL <br>      ); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_OBJECTDESCRIPTOR\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbedSource) { <br>      hrErr = OleStdGetOleObjectData( <br>            (LPPERSISTSTORAGE)&amp;lpServerDoc-&gt;m_PersistStorage, <br>            lpformatetc, <br>            lpMedium, <br>            FALSE   /* fUseMemory -- (use file-base stg) */ <br> <br>      ); <br>      if (hrErr != NOERROR) { <br>         sc = hrErr; <br>         goto error; <br>      } <br>      OleDbgOut3("ServerDoc_GetData: rendered CF_EMBEDSOURCE\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource) { <br>      if (lpOleDoc-&gt;m_fLinkSourceAvail) { <br>         LPMONIKER lpmk; <br> <br>         lpmk = ServerDoc_GetSelFullMoniker( <br>               (LPSERVERDOC)lpOleDoc-&gt;m_lpSrcDocOfCopy, <br>               &amp;lpServerDoc-&gt;m_lrSrcSelOfCopy, <br>               GETMONIKER_FORCEASSIGN <br>         ); <br>         if (lpmk) { <br>            hrErr = OleStdGetLinkSourceData( <br>                  lpmk, <br>                  (LPCLSID)&amp;CLSID_APP, <br>                  lpformatetc, <br>                  lpMedium <br>            ); <br>            OleStdRelease((LPUNKNOWN)lpmk); <br>            if (hrErr != NOERROR) { <br>               sc = hrErr; <br>               goto error; <br>            } <br>            OleDbgOut3("ServerDoc_GetData: rendered CF_LINKSOURCE\r\n"); <br>            return NOERROR; <br> <br>         } else { <br>            sc = E_FAIL; <br>            goto error; <br>         } <br>      } else { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>   } else { <br>      sc = DV_E_FORMATETC; <br>      goto error; <br>   } <br> <br>   return NOERROR; <br> <br>error: <br>   return sc; <br>} <br> <br> <br>/* ServerDoc_GetDataHere <br> * --------------------- <br> * <br> * Render data from the document on a CALLER allocated STGMEDIUM. <br> *      This routine is called via IDataObject::GetDataHere. <br> */ <br>HRESULT ServerDoc_GetDataHere ( <br>      LPSERVERDOC             lpServerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>) <br>{ <br>   LPOLEDOC        lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp; </code></pre>
<p>
</p>
<pre><code>LPOLEAPP        lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br>   HRESULT         hrErr; <br>   SCODE           sc; <br> <br>   // NOTE: lpMedium is an IN parameter. we should NOT set <br>   //           lpMedium-&gt;pUnkForRelease to NULL <br> <br>   /* our user document does not support any formats for GetDataHere. <br>   **    if the document is used for <br>   **    purposes of data transfer, then additional formats are offered. <br>   */ <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      sc = DV_E_FORMATETC; <br>      goto error; <br>   } <br> <br>   if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbedSource) { <br>      hrErr = OleStdGetOleObjectData( <br>            (LPPERSISTSTORAGE)&amp;lpServerDoc-&gt;m_PersistStorage, <br>            lpformatetc, <br>            lpMedium, <br>            FALSE   /* fUseMemory -- (use file-base stg) */ <br>      ); <br>      if (hrErr != NOERROR) { <br>         sc = hrErr; <br>         goto error; <br>      } <br>      OleDbgOut3("ServerDoc_GetDataHere: rendered CF_EMBEDSOURCE\r\n"); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource) { <br>      if (lpOleDoc-&gt;m_fLinkSourceAvail) { <br>         LPMONIKER lpmk; <br> <br>         lpmk = ServerDoc_GetSelFullMoniker( <br>               (LPSERVERDOC)lpOleDoc-&gt;m_lpSrcDocOfCopy, <br>               &amp;lpServerDoc-&gt;m_lrSrcSelOfCopy, <br>               GETMONIKER_FORCEASSIGN <br>         ); <br>         if (lpmk) { <br>            hrErr = OleStdGetLinkSourceData( <br>                  lpmk, <br>                  (LPCLSID)&amp;CLSID_APP, <br>                  lpformatetc, <br>                  lpMedium <br>            ); <br>            OleStdRelease((LPUNKNOWN)lpmk); <br>            if (hrErr != NOERROR) { <br>               sc = hrErr; <br>               goto error; <br>            } <br> <br>            OleDbgOut3("ServerDoc_GetDataHere: rendered CF_LINKSOURCE\r\n"); <br>            return NOERROR; <br> <br>         } else { <br>            sc = E_FAIL; <br>            goto error; <br>         } <br>      } else { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br>   } else { <br> <br>      /* Caller is requesting data to be returned in Caller allocated <br>      **    medium, but we do NOT support this. we only support <br>      **    global memory blocks that WE allocate for the caller. <br>      */ <br>      sc = DV_E_FORMATETC; <br>      goto error; <br>   } <br> <br>   return NOERROR; <br> <br>error: <br>   return sc; <br>} <br> <br> <br>/* ServerDoc_QueryGetData <br> * ---------------------- <br> * <br> * Answer if a particular data format is supported via GetData/GetDataHere. <br> *      This routine is called via IDataObject::QueryGetData. <br> */ <br> <br>HRESULT ServerDoc_QueryGetData (LPSERVERDOC lpServerDoc,LPFORMATETC lpformatetc) <br>{ <br>   LPOLEDOC        lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br> <br>   /* Caller is querying if we support certain format but does not <br>   **    want any data actually returned. <br>   */ <br>   if (lpformatetc-&gt;cfFormat == lpOutlineApp-&gt;m_cfOutline || <br>         lpformatetc-&gt;cfFormat == CF_TEXT) { <br>      // we only support HGLOBAL <br>      return OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL); <br>   } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; <br>         (DVASPECT_CONTENT | DVASPECT_ICON)) ) { <br>      return OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT); <br>   } <br> <br>   /* the above are the only formats supports by a user document (ie. <br>   **    a non-data transfer doc). if the document is used for <br>   **    purposes of data transfer, then additional formats are offered. <br>   */ <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      return DV_E_FORMATETC; <br> <br>   if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbedSource) { <br>      return OleStdQueryOleObjectData(lpformatetc); <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource &amp;&amp; <br>      lpOleDoc-&gt;m_fLinkSourceAvail) { <br>      return OleStdQueryLinkSourceData(lpformatetc); <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfObjectDescriptor) { <br>      return OleStdQueryObjectDescriptorData(lpformatetc); <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSrcDescriptor &amp;&amp; <br>            lpOleDoc-&gt;m_fLinkSourceAvail) { <br>      return OleStdQueryObjectDescriptorData(lpformatetc); <br>   } <br> <br>   return DV_E_FORMATETC; <br>} <br> <br> <br>/* ServerDoc_EnumFormatEtc <br> * ----------------------- <br> * <br> * Return an enumerator which enumerates the data accepted/offered by <br> *      the document. <br> *      This routine is called via IDataObject::EnumFormatEtc. <br> */ <br>HRESULT ServerDoc_EnumFormatEtc( <br>      LPSERVERDOC             lpServerDoc, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)g_lpApp; <br>   int nActualFmts; <br>   SCODE sc = S_OK; <br> <br>   /* NOTE: the enumeration of formats for a data transfer <br>   **    document is not a static list. the list of formats offered <br>   **    may or may not include CF_LINKSOURCE depending on whether a <br>   **    moniker is available for our document. thus we can NOT use <br>   **    the default OLE enumerator which enumerates the formats that <br>   **    are registered for our app in the registration database. <br>   */ <br>   if (dwDirection == DATADIR_GET) { <br>      nActualFmts = lpOleApp-&gt;m_nDocGetFmts; <br> <br>      /* If the document does not have a Moniker, then exclude <br>      **    CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR from the list of <br>      **    formats available. these formats are deliberately listed <br>      **    last in the array of possible "Get" formats. <br>      */ <br>      if (! lpOleDoc-&gt;m_fLinkSourceAvail) <br>         nActualFmts -= 2; <br> <br>      *lplpenumFormatEtc = OleStdEnumFmtEtc_Create( <br>            nActualFmts, lpOleApp-&gt;m_arrDocGetFmts); <br>      if (*lplpenumFormatEtc == NULL) <br>         sc = E_OUTOFMEMORY; <br> <br>   } else if (dwDirection == DATADIR_SET) { <br>      /* NOTE: a document that is used to transfer data <br>      **    (either via the clipboard or drag/drop does NOT <br>      **    accept SetData on ANY format! <br>      */ <br>      sc = E_NOTIMPL; <br>      goto error; <br>   } else { <br>      sc = E_INVALIDARG; <br>      goto error; <br>   } <br> <br>error: <br>   return sc; <br>} <br> <br> <br>/* ServerDoc_GetMetafilePictData <br> * ----------------------------- <br> * <br> * Return a handle to an object's picture data in metafile format. <br> * <br> * <br> * RETURNS: A handle to the object's data in metafile format. <br> * <br> */ <br>HGLOBAL ServerDoc_GetMetafilePictData( <br>      LPSERVERDOC         lpServerDoc, <br>      LPLINERANGE         lplrSel <br>) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC    lpOutlineDoc=(LPOUTLINEDOC)lpServerDoc; <br>   LPLINELIST      lpLL=(LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   LPLINE          lpLine; <br>   LPMETAFILEPICT  lppict = NULL; <br>   HGLOBAL         hMFPict = NULL; <br>   HMETAFILE       hMF = NULL; <br>   RECT            rect; <br>   RECT            rectWBounds; <br>   HDC             hDC; <br>   int             i; <br>   int             nWidth; <br>   int     nStart = (lplrSel ? lplrSel-&gt;m_nStartLine : 0); <br>   int     nEnd =(lplrSel ? lplrSel-&gt;m_nEndLine : LineList_GetCount(lpLL)-1); <br>   int     nLines = nEnd - nStart + 1; <br>   UINT    fuAlign; <br>   POINT point; <br>   SIZE  size; <br> <br>   hDC = CreateMetaFile(NULL); <br> <br>   rect.left = 0; <br>   rect.right = 0; <br>   rect.bottom = 0; <br> <br>   if (nLines &gt; 0) { <br>   // calculate the total height/width of LineList in HIMETRIC <br>      for(i = nStart; i &lt;= nEnd; i++) { <br>         lpLine = LineList_GetLine(lpLL,i); <br>         if (! lpLine) <br>            continue; <br> <br>         nWidth = Line_GetTotalWidthInHimetric(lpLine); <br>         rect.right = max(rect.right, nWidth); <br>         rect.bottom -= Line_GetHeightInHimetric(lpLine); <br>      } <br> <br> <br>      SetMapMode(hDC, MM_ANISOTROPIC); <br> <br>      SetWindowOrgEx(hDC, 0, 0, &amp;point); <br>      SetWindowExtEx(hDC, rect.right, rect.bottom, &amp;size); <br>      rectWBounds = rect; <br> <br>      // Set the default font size, and font face name <br>      SelectObject(hDC, OutlineApp_GetActiveFont(lpOutlineApp)); <br> <br>      FillRect(hDC, (LPRECT) &amp;rect, GetStockObject(WHITE_BRUSH)); <br> <br>      rect.bottom = 0; <br> <br>      fuAlign = SetTextAlign(hDC, TA_LEFT | TA_TOP | TA_NOUPDATECP); <br> <br>      /* While more lines print out the text */ <br>      for(i = nStart; i &lt;= nEnd; i++) { <br>         lpLine = LineList_GetLine(lpLL,i); <br>         if (! lpLine) <br>            continue; <br> <br>         rect.top = rect.bottom; <br>         rect.bottom -= Line_GetHeightInHimetric(lpLine); <br> <br>         /* Draw the line */ <br>         Line_Draw(lpLine, hDC, &amp;rect, &amp;rectWBounds, FALSE /*fHighlight*/); <br>      } <br> <br>      SetTextAlign(hDC, fuAlign); <br>   } <br> <br>   // Get handle to the metafile. <br>   if (!(hMF = CloseMetaFile (hDC))) <br>      return NULL; <br> <br>   if (!(hMFPict = GlobalAlloc (GALLOCFLG, sizeof (METAFILEPICT)))) { <br>      DeleteMetaFile (hMF); <br>      return NULL; <br>   } <br> <br>   if (!(lppict = (LPMETAFILEPICT)GlobalLock(hMFPict))) { <br>      DeleteMetaFile (hMF); <br>      GlobalFree (hMFPict); <br>      return NULL; <br>   } <br> <br>   lppict-&gt;mm   =  MM_ANISOTROPIC; <br>   lppict-&gt;hMF  =  hMF; <br>   lppict-&gt;xExt =  rect.right; <br>   lppict-&gt;yExt =  - rect.bottom;  // add minus sign to make it +ve <br>   GlobalUnlock (hMFPict); <br> <br>   return hMFPict; <br>} <br> <br>#endif  // OLE_SERVER <br> <br> <br> <br>#if defined( OLE_CNTR ) <br> <br>/************************************************************************* <br>** ContainerDoc Supprt Functions Used by Container versions <br>*************************************************************************/ <br> <br> <br>/* Paste OLE Link from clipboard */ <br>void ContainerDoc_PasteLinkCommand(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPDATAOBJECT    lpClipboardDataObj = NULL; <br>   BOOL            fLink = TRUE; <br>   BOOL            fLocalDataObj = FALSE; <br>   BOOL            fDisplayAsIcon = FALSE; <br>   SIZEL           sizelInSrc; <br>   HCURSOR         hPrevCursor; <br>   HGLOBAL         hMem = NULL; <br>   HGLOBAL         hMetaPict = NULL; <br>   STGMEDIUM       medium; <br>   BOOL            fStatus; <br>   HRESULT         hrErr; <br> <br>   hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&amp;lpClipboardDataObj); <br>   if (hrErr != NOERROR) <br>      return;     // Clipboard seems to be empty or can't be accessed <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   /* check if the data on the clipboard is local to our application <br>   **    instance. <br>   */ <br>   if (lpOutlineApp-&gt;m_lpClipboardDoc) { <br>      LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br>      if (lpClipboardDataObj == (LPDATAOBJECT)&amp;lpOleDoc-&gt;m_DataObject) <br>         fLocalDataObj = TRUE; <br>   } <br> <br>   /* NOTE: we need to check what dwDrawAspect is being <br>   **    transfered. if the data is an object that is displayed as an <br>   **    icon in the source, then we want to keep it as an icon. the <br>   **    aspect the object is displayed in at the source is transfered <br>   **    via the CF_LINKSOURCEDESCRIPTOR format for a PasteLink <br>   **    operation. <br>   */ <br>   if (hMem = OleStdGetData( <br>         lpClipboardDataObj, <br>         (CLIPFORMAT)lpOleApp-&gt;m_cfLinkSrcDescriptor, <br>         NULL, <br>         DVASPECT_CONTENT, <br>         (LPSTGMEDIUM)&amp;medium)) { <br>      LPOBJECTDESCRIPTOR lpOD = GlobalLock(hMem); <br>      fDisplayAsIcon = (lpOD-&gt;dwDrawAspect == DVASPECT_ICON ? TRUE : FALSE); <br>      sizelInSrc = lpOD-&gt;sizel;   // size of object/picture in source (opt.) <br>      GlobalUnlock(hMem); <br>      ReleaseStgMedium((LPSTGMEDIUM)&amp;medium);     // equiv to GlobalFree <br> <br>      if (fDisplayAsIcon) { <br>         hMetaPict = OleStdGetData( <br>               lpClipboardDataObj, <br>               CF_METAFILEPICT, <br>               NULL, <br>               DVASPECT_ICON, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         if (hMetaPict == NULL) <br>            fDisplayAsIcon = FALSE; // give up; failed to get icon MFP <br>      } <br>   } <br> <br>   fStatus = ContainerDoc_PasteFormatFromData( <br>         lpContainerDoc, <br>         (CLIPFORMAT)lpOleApp-&gt;m_cfLinkSource, <br>         lpClipboardDataObj, <br>         fLocalDataObj, <br>         fLink, <br>         fDisplayAsIcon, <br>         hMetaPict, <br>         (LPSIZEL)&amp;sizelInSrc <br>   ); <br> <br>   if (!fStatus) <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgPasting); <br> <br>   if (hMetaPict) <br>      ReleaseStgMedium((LPSTGMEDIUM)&amp;medium);  // properly free METAFILEPICT <br> <br>   if (lpClipboardDataObj) <br>      OleStdRelease((LPUNKNOWN)lpClipboardDataObj); <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>} <br> <br> <br>/* ContainerDoc_PasteFormatFromData <br>** -------------------------------- <br>** <br>**    Paste a particular data format from a IDataObject*. The <br>**    IDataObject* may come from the clipboard (GetClipboard) or from a <br>**    drag/drop operation. <br>** <br>**    Returns TRUE if data was successfully pasted. <br>**            FALSE if data could not be pasted. <br>*/ <br>BOOL ContainerDoc_PasteFormatFromData( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      CLIPFORMAT              cfFormat, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLocalDataObj, <br>      BOOL                    fLink, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPSIZEL                 lpSizelInSrc <br>) <br>{ <br>   LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPCONTAINERAPP  lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   int             nIndex; <br>   int             nCount = 0; <br>   HGLOBAL         hData; <br>   STGMEDIUM       medium; <br>   FORMATETC       formatetc; <br>   HRESULT         hrErr; <br>   LINERANGE       lrSel; <br> <br>   if (LineList_GetCount(lpLL) == 0) <br>      nIndex = -1;    // pasting to empty list <br>   else <br>      nIndex=LineList_GetFocusLineIndex(lpLL); <br> <br>   if (fLink) { <br> <br>      /* We should paste a Link to the data */ <br> <br>      if (cfFormat != lpOleApp-&gt;m_cfLinkSource) <br>         return FALSE;   // we only support OLE object type links <br> <br>      nCount = ContainerDoc_PasteOleObject( <br>            lpContainerDoc, <br>            lpSrcDataObj, <br>            OLECREATEFROMDATA_LINK, <br>            cfFormat, <br>            nIndex, <br>            fDisplayAsIcon, <br>            hMetaPict, <br>            lpSizelInSrc <br>         ); <br>      return (nCount &gt; 0 ? TRUE : FALSE); <br> <br>   } else { <br> <br>      if (cfFormat == lpContainerApp-&gt;m_cfCntrOutl) { <br>         if (fLocalDataObj) { <br> <br>            /* CASE I: IDataObject* is local to our app <br>            ** <br>            **    if the source of the data is local to our <br>            **    application instance, then we can get direct <br>            **    access to the original OleDoc object that <br>            **    corresponds to the IDataObject* given. <br>            **    CF_CNTROUTL data is passed through a LPSTORAGE. <br>            **    if we call OleGetData asking for CF_CNTROUTL, we <br>            **    will be returned a copy of the existing open pStg <br>            **    of the original source document. we can NOT open <br>            **    streams and sub-storages again via this pStg <br>            **    since it is already open within our same <br>            **    application instance. we must copy the data from <br>            **    the original OleDoc source document. <br>            */ <br>            LPLINELIST lpSrcLL; <br>            LPOLEDOC lpLocalSrcDoc = <br>               ((struct CDocDataObjectImpl FAR*)lpSrcDataObj)-&gt;lpOleDoc; <br> <br>            /* copy all lines from SrcDoc to DestDoc. */ <br>            lpSrcLL = &amp;((LPOUTLINEDOC)lpLocalSrcDoc)-&gt;m_LineList; <br>            nCount = LineList_CopySelToDoc( <br>                  lpSrcLL, <br>                  NULL, <br>                  (LPOUTLINEDOC)lpContainerDoc <br>            ); <br> <br>         } else { <br> <br>            /* CASE II: IDataObject* is NOT local to our app <br>            ** <br>            **    if the source of the data comes from another <br>            **    application instance. we can call GetDataHere to <br>            **    retrieve the CF_CNTROUTL data. CF_CNTROUTL data <br>            **    is passed through a LPSTORAGE. we MUST use <br>            **    IDataObject::GetDataHere. calling <br>            **    IDataObject::GetData does NOT work because OLE <br>            **    currently does NOT support remoting of a callee <br>            **    allocated root storage back to the caller. this <br>            **    hopefully will be supported in a future version. <br>            **    in order to call GetDataHere we must allocate an <br>            **    IStorage instance for the callee to write into. <br>            **    we will allocate an IStorage docfile that will <br>            **    delete-on-release. we could use either a <br>            **    memory-based storage or a file-based storage. <br>            */ <br>            LPSTORAGE lpTmpStg = OleStdCreateTempStorage( <br>                  FALSE /*fUseMemory*/, <br>                  STGM_READWRITE | STGM_TRANSACTED |STGM_SHARE_EXCLUSIVE <br>            ); <br>            if (! lpTmpStg) <br>               return FALSE; <br> <br>            formatetc.cfFormat = cfFormat; <br>            formatetc.ptd = NULL; <br>            formatetc.dwAspect = DVASPECT_CONTENT; <br>            formatetc.tymed = TYMED_ISTORAGE; <br>            formatetc.lindex = -1; <br> <br>            medium.tymed = TYMED_ISTORAGE; <br>            medium.u.pstg = lpTmpStg; <br>            medium.pUnkForRelease = NULL; <br> <br>            OLEDBG_BEGIN2("IDataObject::GetDataHere called\r\n") <br>            hrErr = lpSrcDataObj-&gt;lpVtbl-&gt;GetDataHere( <br>                  lpSrcDataObj, <br>                  (LPFORMATETC)&amp;formatetc, <br>                  (LPSTGMEDIUM)&amp;medium <br>            ); <br>            OLEDBG_END2 <br> <br>            if (hrErr == NOERROR) { <br>               nCount = ContainerDoc_PasteCntrOutlData( <br>                     lpContainerDoc, <br>                     lpTmpStg, <br>                     nIndex <br>               ); <br>            } <br>            OleStdVerifyRelease( <br>               (LPUNKNOWN)lpTmpStg, OLESTR("Temp stg NOT released!\r\n")); <br>            return ((hrErr == NOERROR) ? TRUE : FALSE); <br>         } <br> <br>      } else if (cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br> <br>         hData = OleStdGetData( <br>               lpSrcDataObj, <br>               (CLIPFORMAT)lpOutlineApp-&gt;m_cfOutline, <br>               NULL, <br>               DVASPECT_CONTENT, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         nCount = OutlineDoc_PasteOutlineData( <br>               (LPOUTLINEDOC)lpContainerDoc, <br>               hData, <br>               nIndex <br>            ); <br>         // NOTE: we must free data handle by releasing the medium <br>         ReleaseStgMedium((LPSTGMEDIUM)&amp;medium); <br> <br>      } else if (cfFormat == lpOleApp-&gt;m_cfEmbedSource || <br>         cfFormat == lpOleApp-&gt;m_cfEmbeddedObject || <br>         cfFormat == lpOleApp-&gt;m_cfFileName) { <br>         /* NOTE: OleCreateFromData API creates an OLE object if <br>         **    CF_EMBEDDEDOBJECT, CF_EMBEDSOURCE, or CF_FILENAME are <br>         **    available from the source data object. the <br>         **    CF_FILENAME case arises when a file is copied to the <br>         **    clipboard from the FileManager. if the file has an <br>         **    associated class (see GetClassFile API), then an <br>         **    object of that class is created. otherwise an OLE 1.0 <br>         **    Packaged object is created. <br>         */ <br>         nCount = ContainerDoc_PasteOleObject( <br>               lpContainerDoc, <br>               lpSrcDataObj, <br>               OLECREATEFROMDATA_OBJECT, <br>               0,   /* N/A -- cfFormat */ <br>               nIndex, <br>               fDisplayAsIcon, <br>               hMetaPict, <br>               lpSizelInSrc <br>         ); <br>         return (nCount &gt; 0 ? TRUE : FALSE); <br> <br>      } else if (cfFormat == CF_METAFILEPICT <br>               || cfFormat == CF_DIB <br>               || cfFormat == CF_BITMAP) { <br> <br>         /* NOTE: OleCreateStaticFromData API creates an static <br>         **    OLE object if CF_METAFILEPICT, CF_DIB, or CF_BITMAP is <br>         **    CF_EMBEDDEDOBJECT, CF_EMBEDSOURCE, or CF_FILENAME are <br>         **    available from the source data object. <br>         */ <br>         nCount = ContainerDoc_PasteOleObject( <br>               lpContainerDoc, <br>               lpSrcDataObj, <br>               OLECREATEFROMDATA_STATIC, <br>               cfFormat, <br>               nIndex, <br>               fDisplayAsIcon, <br>               hMetaPict, <br>               lpSizelInSrc <br>         ); <br>         return (nCount &gt; 0 ? TRUE : FALSE); <br> <br>      } else if(cfFormat == CF_TEXT) { <br> <br>         hData = OleStdGetData( <br>               lpSrcDataObj, <br>               CF_TEXT, <br>               NULL, <br>               DVASPECT_CONTENT, <br>               (LPSTGMEDIUM)&amp;medium <br>         ); <br>         nCount = OutlineDoc_PasteTextData( <br>               (LPOUTLINEDOC)lpContainerDoc, <br>               hData, <br>               nIndex <br>            ); <br>         // NOTE: we must free data handle by releasing the medium <br>         ReleaseStgMedium((LPSTGMEDIUM)&amp;medium); <br> <br>      } else { <br>         return FALSE;   // no acceptable format available to paste <br>      } <br>   } <br> <br>   lrSel.m_nStartLine = nIndex + nCount; <br>   lrSel.m_nEndLine = nIndex + 1; <br>   LineList_SetSel(lpLL, &amp;lrSel); <br>   return TRUE; <br>} <br> <br> <br>/* ContainerDoc_PasteCntrOutlData <br> * ------------------------------- <br> * <br> *      Load the lines stored in a lpSrcStg (stored in CF_CNTROUTL format) <br> *  into the document. <br> * <br> * Return the number of items added <br> */ <br>int ContainerDoc_PasteCntrOutlData( <br>      LPCONTAINERDOC          lpDestContainerDoc, <br>      LPSTORAGE               lpSrcStg, <br>      int                     nStartIndex <br>) <br>{ <br>   int nCount; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpDestOutlineDoc = (LPOUTLINEDOC)lpDestContainerDoc; <br>   LPOUTLINEDOC lpSrcOutlineDoc; <br>   LPLINELIST   lpSrcLL; <br> <br>   // create a temp document that will be used to load the lpSrcStg data. <br>   lpSrcOutlineDoc = (LPOUTLINEDOC)OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>   if ( ! lpSrcOutlineDoc ) <br>      return 0; <br> <br>   if (! OutlineDoc_LoadFromStg(lpSrcOutlineDoc, lpSrcStg)) <br>      goto error; <br> <br>   /* copy all lines from the SrcDoc to the DestDoc. */ <br>   lpSrcLL = &amp;lpSrcOutlineDoc-&gt;m_LineList; <br>   nCount = LineList_CopySelToDoc(lpSrcLL, NULL, lpDestOutlineDoc); <br> <br>   if (lpSrcOutlineDoc)            // destroy temporary document. <br>      OutlineDoc_Close(lpSrcOutlineDoc, OLECLOSE_NOSAVE); <br> <br>   return nCount; <br> <br>error: <br>   if (lpSrcOutlineDoc)            // destroy temporary document. <br>      OutlineDoc_Close(lpSrcOutlineDoc, OLECLOSE_NOSAVE); <br> <br>   return 0; <br>} <br> <br> <br>/* ContainerDoc_QueryPasteFromData <br>** ------------------------------- <br>** <br>**    Check if the IDataObject* offers data in a format that we can <br>**    paste. The IDataObject* may come from the clipboard <br>**    (GetClipboard) or from a drag/drop operation. <br>**    In this function we look if one of the following formats is <br>**    offered: <br>**              CF_OUTLINE <br>**              &lt;OLE object -- CF_EMBEDSOURCE or CF_EMBEDDEDOBJECT&gt; <br>**              CF_TEXT <br>** <br>**    NOTE: fLink is specified and CF_LINKSOURCE is available then TRUE <br>**    is returned, else FALSE. <br>** <br>**    Returns TRUE if paste can be performed <br>**            FALSE if paste is not possible. <br>*/ <br>BOOL ContainerDoc_QueryPasteFromData( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLink <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br> <br>   if (fLink) { <br>      /* check if we can paste a Link to the data */ <br>      if (OleQueryLinkFromData(lpSrcDataObj) != NOERROR) <br>         return FALSE;   // linking is NOT possible <br>   } else { <br> <br>      int nFmtEtc; <br> <br>      nFmtEtc = OleStdGetPriorityClipboardFormat( <br>            lpSrcDataObj, <br>            lpOleApp-&gt;m_arrPasteEntries, <br>            lpOleApp-&gt;m_nPasteEntries <br>         ); <br> <br>      if (nFmtEtc &lt; 0) <br>         return FALSE;   // there is no format we like <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* ContainerDoc_PasteOleObject <br>** --------------------------- <br>** <br>**    Embed or link an OLE object. the source of the data is a pointer <br>**    to an IDataObject. normally this lpSrcDataObj comes from the <br>**    clipboard after call OleGetClipboard. <br>** <br>**    dwCreateType controls what type of object will created: <br>**    OLECREATEFROMDATA_LINK -- OleCreateLinkFromData will be called <br>**    OLECREATEFROMDATA_OBJECT -- OleCreateFromData will be called <br>**    OLECREATEFROMDATA_STATIC -- OleCreateStaticFromData will be called <br>**                                  cfFormat controls the type of static <br>**    a CONTAINERLINE object is created to manage the OLE object. this <br>**    CONTAINERLINE is added to the ContainerDoc after line nIndex. <br>** <br>*/ <br>int ContainerDoc_PasteOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      DWORD                   dwCreateType, <br>      CLIPFORMAT              cfFormat, <br>      int                     nIndex, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPSIZEL                 lpSizelInSrc <br>) <br>{ <br>   LPLINELIST          lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPLINE              lpLine = NULL; <br>   HDC                 hDC; <br>   int                 nTab = 0; <br>   OLECHAR             szStgName[CWCSTORAGENAME]; <br>   LPCONTAINERLINE     lpContainerLine = NULL; <br> <br>   ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, CWCSTORAGENAME); <br> <br>   /* default the new line to have the same indent as previous line */ <br>   lpLine = LineList_GetLine(lpLL, nIndex); <br>   if (lpLine) <br>      nTab = Line_GetTabLevel(lpLine); <br> <br>   hDC = LineList_GetDC(lpLL); <br> <br>   lpContainerLine = ContainerLine_CreateFromData( <br>         hDC, <br>         nTab, <br>         lpContainerDoc, <br>         lpSrcDataObj, <br>         dwCreateType, <br>         cfFormat, <br>         fDisplayAsIcon, <br>         hMetaPict, <br>         szStgName <br>      ); <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   if (! lpContainerLine) <br>      goto error; <br> <br>   /* add a ContainerLine object to the document's LineList. The <br>   **    ContainerLine manages the rectangle on the screen occupied by <br>   **    the OLE object. later when the app is updated to support <br>   **    extended layout, there could be more than one Line associated <br>   **    with the OLE object. <br>   */ <br> <br>   LineList_AddLine(lpLL, (LPLINE)lpContainerLine, nIndex); <br> <br>   /* NOTE: if the source of the OLE object just pasted, passed a <br>   **    non-zero sizel in the ObjectDescriptor, then we will try to <br>   **    keep the object the same size as it is in the source. this <br>   **    may be a scaled size if the object had been resized in the <br>   **    source container. if the source did not give a valid sizel, <br>   **    then we will retrieve the size of the object by calling <br>   **    IViewObject2::GetExtent. <br>   */ <br>   if (lpSizelInSrc &amp;&amp; (lpSizelInSrc-&gt;cx != 0 || lpSizelInSrc-&gt;cy != 0)) { <br>      ContainerLine_UpdateExtent(lpContainerLine, lpSizelInSrc); <br>   } else <br>      ContainerLine_UpdateExtent(lpContainerLine, NULL); <br> <br>   OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, TRUE); <br> <br>   return 1;   // one line added to LineList <br> <br>error: <br>   // NOTE: if ContainerLine_CreateFromClip failed <br>   OutlineApp_ErrorMessage(g_lpApp, OLESTR("Paste Object failed!")); <br>   return 0;       // no lines added to line list <br>} <br> <br> <br>/* ContainerDoc_GetData <br> * -------------------- <br> * <br> * Render data from the document on a CALLEE allocated STGMEDIUM. <br> *      This routine is called via IDataObject::GetData. <br> */ <br>HRESULT ContainerDoc_GetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>) <br>{ <br>   LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp; <br>   HRESULT hrErr; <br>   SCODE sc; <br> <br>   // NOTE: we must set out pointer parameters to NULL <br>   lpMedium-&gt;pUnkForRelease = NULL; <br> <br>   /* NOTE: we must set all out pointer parameters to NULL. */ <br>   lpMedium-&gt;tymed = TYMED_NULL; <br>   lpMedium-&gt;pUnkForRelease = NULL;    // we transfer ownership to caller <br>   lpMedium-&gt;u.hGlobal = NULL; <br> <br>   if (lpformatetc-&gt;cfFormat == lpContainerApp-&gt;m_cfCntrOutl) { <br> <br>      /* NOTE: currently OLE does NOT support remoting a root <br>      **    level IStorage (either memory or file based) as an OUT <br>      **    parameter. thus, we can NOT support GetData for this <br>      **    TYMED_ISTORAGE based format. the caller MUST call GetDataHere. <br>      */ <br>      sc = DV_E_FORMATETC; <br>      goto error; <br> <br>   } else if (!lpContainerDoc-&gt;m_fEmbeddedObjectAvail &amp;&amp; <br>         lpformatetc-&gt;cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; </code></pre>
<p>
</p>
<pre><code>} <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("ContainerDoc_GetData: rendered CF_OUTLINE\r\n"); <br>      return NOERROR; <br> <br>   } else if (!lpContainerDoc-&gt;m_fEmbeddedObjectAvail &amp;&amp; <br>         lpformatetc-&gt;cfFormat == CF_TEXT) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetTextData ( <br>            (LPOUTLINEDOC)lpContainerDoc, <br>            NULL <br>      ); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("ContainerDoc_GetData: rendered CF_TEXT\r\n"); <br>      return NOERROR; <br> <br>   } else if ( lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfObjectDescriptor || <br>      (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSrcDescriptor &amp;&amp; <br>         lpOleDoc-&gt;m_fLinkSourceAvail) ) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DV_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OleDoc_GetObjectDescriptorData ( <br>            (LPOLEDOC)lpContainerDoc, <br>            NULL <br>      ); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>#if defined( _DEBUG ) <br>      if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfObjectDescriptor) <br>         OleDbgOut3( <br>            "ContainerDoc_GetData: rendered CF_OBJECTDESCRIPTOR\r\n"); <br>      else <br>         OleDbgOut3( <br>            "ContainerDoc_GetData: rendered CF_LINKSRCDESCRIPTOR\r\n"); <br>#endif <br>      return NOERROR; <br> <br>   } else if (lpContainerDoc-&gt;m_fEmbeddedObjectAvail) { <br> <br>      /* NOTE: if this document contains a single OLE object <br>      **    (ie. cfEmbeddedObject data format is available), then <br>      **    the formats offered via our IDataObject must include <br>      **    the formats available from the OLE object itself. <br>      **    thus, we delegate this call to the IDataObject* of the <br>      **    OLE object. <br>      */ <br> <br>      if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbeddedObject) { <br>         LPPERSISTSTORAGE lpPersistStg = <br>               (LPPERSISTSTORAGE)ContainerDoc_GetSingleOleObject( <br>                     lpContainerDoc, <br>                     &amp;IID_IPersistStorage, <br>                     NULL <br>         ); <br> <br>         if (! lpPersistStg) <br>            return DV_E_FORMATETC; <br> <br>         /* render CF_EMBEDDEDOBJECT by asking the object to save <br>         **    into a temporary, DELETEONRELEASE pStg allocated by us. <br>         */ <br> <br>         hrErr = OleStdGetOleObjectData( <br>               lpPersistStg, <br>               lpformatetc, <br>               lpMedium, <br>               FALSE   /* fUseMemory -- (use file-base stg) */ <br>         ); <br>         OleStdRelease((LPUNKNOWN)lpPersistStg); <br>         if (hrErr != NOERROR) { <br>            sc = hrErr; <br>            goto error; <br>         } <br>         OleDbgOut3("ContainerDoc_GetData: rendered CF_EMBEDDEDOBJECT\r\n"); <br>         return hrErr; <br> <br>      } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT) { <br> <br>         /* NOTE: as a container which draws objects, when a single <br>         **    OLE object is copied, we can give the Metafile picture of <br>         **    the object. <br>         */ <br>         LPCONTAINERLINE lpContainerLine; <br>         LPOLEOBJECT lpOleObj; <br>         SIZEL sizelOleObject; <br> <br>         // Verify caller asked for correct medium <br>         if (!(lpformatetc-&gt;tymed &amp; TYMED_MFPICT)) { <br>            sc = DV_E_FORMATETC; <br>            goto error; <br>         } <br> <br>         lpOleObj = (LPOLEOBJECT)ContainerDoc_GetSingleOleObject( <br>               lpContainerDoc, <br>               &amp;IID_IOleObject, <br>               (LPCONTAINERLINE FAR*)&amp;lpContainerLine <br>         ); <br> <br>         if (! lpOleObj) { <br>            sc = E_OUTOFMEMORY;     // could not load object <br>            goto error; <br>         } <br>         if (lpformatetc-&gt;dwAspect &amp; lpContainerLine-&gt;m_dwDrawAspect) { <br>            LPLINE lpLine = (LPLINE)lpContainerLine; <br> <br>            /* render CF_METAFILEPICT by drawing the object into <br>            **    a metafile DC <br>            */ <br> <br>            /* NOTE: Get size that object is being drawn. If the <br>            **    object has been scaled because the user resized the <br>            **    object, then we want to render a metafile with the <br>            **    scaled size. <br>            */ <br>            sizelOleObject.cx = lpLine-&gt;m_nWidthInHimetric; <br>            sizelOleObject.cy = lpLine-&gt;m_nHeightInHimetric; <br> <br>            lpMedium-&gt;u.hGlobal = OleStdGetMetafilePictFromOleObject( <br>                  lpOleObj, <br>                  lpContainerLine-&gt;m_dwDrawAspect, <br>                  (LPSIZEL)&amp;sizelOleObject, <br>                  lpformatetc-&gt;ptd <br>            ); <br>            OleStdRelease((LPUNKNOWN)lpOleObj); <br>            if (! lpMedium-&gt;u.hGlobal) { <br>               sc = E_OUTOFMEMORY; <br>               goto error; <br>            } <br> <br>            lpMedium-&gt;tymed = TYMED_MFPICT; <br>            OleDbgOut3("ContainerDoc_GetData: rendered CF_METAFILEPICT\r\n"); <br>            return NOERROR; <br>         } else { <br>            // improper aspect requested <br>            OleStdRelease((LPUNKNOWN)lpOleObj); <br>            return DV_E_FORMATETC; <br>         } <br> <br>      } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource) { <br>         if (lpOleDoc-&gt;m_fLinkSourceAvail) { <br>            LPMONIKER lpmk; <br> <br>            lpmk = ContainerLine_GetFullMoniker( <br>                  lpContainerDoc-&gt;m_lpSrcContainerLine, <br>                  GETMONIKER_FORCEASSIGN <br>            ); <br>            if (lpmk) { <br>               hrErr = OleStdGetLinkSourceData( <br>                     lpmk, <br>                     &amp;lpContainerDoc-&gt;m_clsidOleObjCopied, <br>                     lpformatetc, <br>                     lpMedium <br>               ); <br>               OleStdRelease((LPUNKNOWN)lpmk); <br>               if (hrErr != NOERROR) { <br>                  sc = hrErr; <br>                  goto error; <br>               } <br>               OleDbgOut3("ContainerDoc_GetData: rendered CF_LINKSOURCE\r\n"); <br>               return hrErr; <br>            } else { <br>               sc = DV_E_FORMATETC; <br>               goto error; <br>            } <br>         } else { <br>            sc = DV_E_FORMATETC; <br>            goto error; <br>         } <br> <br>      } <br>#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER ) <br>      /* NOTE: optionally, a container that wants to have a <br>      **    potentially richer data transfer, can enumerate the data <br>      **    formats from the OLE object's cache and offer them too. if <br>      **    the object has a special handler, then it might be able to <br>      **    render additional data formats. in this case, the <br>      **    container must delegate the GetData call to the object if <br>      **    it does not directly support the format. <br>      ** <br>      **    CNTROUTL does NOT enumerate the cache; it implements the <br>      **    simpler strategy of offering a static list of formats. <br>      **    thus the delegation is NOT required. <br>      */ <br>     else { <br> <br>         /* NOTE: we delegate this call to the IDataObject* of the <br>         **    OLE object. <br>         */ <br>         LPDATAOBJECT lpDataObj; <br> <br>         lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject( <br>               lpContainerDoc, <br>               &amp;IID_IDataObject, <br>               NULL <br>         ); <br> <br>         if (! lpDataObj) { <br>            sc = DV_E_FORMATETC; <br>            goto error; <br>         } <br> <br>         OLEDBG_BEGIN2("ContainerDoc_GetData: delegate to OLE obj\r\n") <br>         hrErr=lpDataObj-&gt;lpVtbl-&gt;GetData(lpDataObj,lpformatetc,lpMedium); <br>         OLEDBG_END2 <br> <br>         OleStdRelease((LPUNKNOWN)lpDataObj); <br>         return hrErr; <br>      } <br>#endif  // ! OPTIONAL_ADVANCED_DATA_TRANSFER <br> <br>   } <br> <br>   // if we get here then we do NOT support the requested format <br>   sc = DV_E_FORMATETC; <br> <br>error: <br>   return sc; <br>} <br> <br> <br>/* ContainerDoc_GetDataHere <br> * ------------------------ <br> * <br> * Render data from the document on a CALLER allocated STGMEDIUM. <br> *      This routine is called via IDataObject::GetDataHere. <br> */ <br>HRESULT ContainerDoc_GetDataHere ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>) <br>{ <br>   LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp; <br>   HRESULT hrErr; <br> <br>   // NOTE: lpMedium is an IN parameter. we should NOT set <br>   //           lpMedium-&gt;pUnkForRelease to NULL <br> <br>   // we only support  IStorage medium <br>   if (lpformatetc-&gt;cfFormat == lpContainerApp-&gt;m_cfCntrOutl) { <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_ISTORAGE)) <br>         return DV_E_FORMATETC; <br> <br>      if (lpMedium-&gt;tymed == TYMED_ISTORAGE) { <br>         /* Caller has allocated the storage. we must copy all of our <br>         **    data into his storage. <br>         */ <br> <br>         /*  NOTE: we must be sure to write our class ID into our <br>         **    storage. this information is used by OLE to determine the <br>         **    class of the data stored in our storage. <br>         */ <br>         if((hrErr=WriteClassStg(lpMedium-&gt;u.pstg,&amp;CLSID_APP)) != NOERROR) <br>            return hrErr; <br> <br>         OutlineDoc_SaveSelToStg( <br>               (LPOUTLINEDOC)lpContainerDoc, <br>               NULL,   /* entire doc */ <br>               lpContainerApp-&gt;m_cfCntrOutl, <br>               lpMedium-&gt;u.pstg, <br>               FALSE,  /* fSameAsLoad */ <br>               FALSE   /* fRemember */ <br>         ); <br>         OleStdCommitStorage(lpMedium-&gt;u.pstg); <br> <br>         OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_CNTROUTL\r\n"); <br>         return NOERROR; <br>      } else { <br>         // we only support IStorage medium <br>         return DV_E_FORMATETC; <br>      } <br> <br>   } else if (lpContainerDoc-&gt;m_fEmbeddedObjectAvail) { <br> <br>      /* NOTE: if this document contains a single OLE object <br>      **    (ie. cfEmbeddedObject data format is available), then <br>      **    the formats offered via our IDataObject must include <br>      **    CF_EMBEDDEDOBJECT and the formats available from the OLE <br>      **    object itself. <br>      */ <br> <br>      if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbeddedObject) { <br>         LPPERSISTSTORAGE lpPersistStg = <br>               (LPPERSISTSTORAGE)ContainerDoc_GetSingleOleObject( <br>                     lpContainerDoc, <br>                     &amp;IID_IPersistStorage, <br>                     NULL <br>         ); <br> <br>         if (! lpPersistStg) { <br>            return E_OUTOFMEMORY; <br>         } <br>         /* render CF_EMBEDDEDOBJECT by asking the object to save <br>         **    into the IStorage allocated by the caller. <br>         */ <br> <br>         hrErr = OleStdGetOleObjectData( <br>               lpPersistStg, <br>               lpformatetc, <br>               lpMedium, <br>               FALSE   /* fUseMemory -- N/A */ <br>         ); <br>         OleStdRelease((LPUNKNOWN)lpPersistStg); <br>         if (hrErr != NOERROR) { <br>            return hrErr; <br>         } <br>         OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_EMBEDDEDOBJECT\r\n"); <br>         return hrErr; <br> <br>      } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource) { <br>         if (lpOleDoc-&gt;m_fLinkSourceAvail) { <br>            LPMONIKER lpmk; <br> <br>            lpmk = ContainerLine_GetFullMoniker( <br>                  lpContainerDoc-&gt;m_lpSrcContainerLine, <br>                  GETMONIKER_FORCEASSIGN <br>            ); <br>            if (lpmk) { <br>               hrErr = OleStdGetLinkSourceData( <br>                     lpmk, <br>                     &amp;lpContainerDoc-&gt;m_clsidOleObjCopied, <br>                     lpformatetc, <br>                     lpMedium <br>               ); <br>               OleStdRelease((LPUNKNOWN)lpmk); <br>               OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_LINKSOURCE\r\n"); <br>               return hrErr; <br>            } else { <br>               return E_FAIL; <br>            } <br>         } else { <br>            return DV_E_FORMATETC; <br>         } <br> <br>      } else { <br>#if !defined( OPTIONAL_ADVANCED_DATA_TRANSFER ) <br>         return DV_E_FORMATETC; <br>#endif <br>#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER ) <br>         /* NOTE: optionally, a container that wants to have a <br>         **    potentially richer data transfer, can enumerate the data <br>         **    formats from the OLE object's cache and offer them too. if <br>         **    the object has a special handler, then it might be able to <br>         **    render additional data formats. in this case, the <br>         **    container must delegate the GetData call to the object if <br>         **    it does not directly support the format. <br>         ** <br>         **    CNTROUTL does NOT enumerate the cache; it implements the <br>         **    simpler strategy of offering a static list of formats. <br>         **    thus the delegation is NOT required. <br>         */ <br>         /* NOTE: we delegate this call to the IDataObject* of the <br>         **    OLE object. <br>         */ <br>         LPDATAOBJECT lpDataObj; <br> <br>         lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject( <br>               lpContainerDoc, <br>               &amp;IID_IDataObject, <br>               NULL <br>         ); <br> <br>         if (! lpDataObj) <br>            return DV_E_FORMATETC; <br> <br>         OLEDBG_BEGIN2("ContainerDoc_GetDataHere: delegate to OLE obj\r\n") <br>         hrErr = lpDataObj-&gt;lpVtbl-&gt;GetDataHere( <br>               lpDataObj, <br>               lpformatetc, <br>               lpMedium <br>         ); <br>         OLEDBG_END2 <br> <br>         OleStdRelease((LPUNKNOWN)lpDataObj); <br>         return hrErr; <br>#endif  // OPTIONAL_ADVANCED_DATA_TRANSFER <br>      } <br>   } else { <br>      return DV_E_FORMATETC; <br>   } <br>} <br> <br> <br>/* ContainerDoc_QueryGetData <br> * ------------------------- <br> * <br> * Answer if a particular data format is supported via GetData/GetDataHere. <br> *      This routine is called via IDataObject::QueryGetData. <br> */ <br>HRESULT ContainerDoc_QueryGetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc <br>) <br>{ <br>   LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp; <br>   LPDATAOBJECT  lpDataObj = NULL; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   SCODE sc; <br>   HRESULT hrErr; <br> <br>   if (lpContainerDoc-&gt;m_fEmbeddedObjectAvail) { <br>      lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject( <br>               lpContainerDoc, <br>               &amp;IID_IDataObject, <br>               (LPCONTAINERLINE FAR*)&amp;lpContainerLine <br>      ); <br>   } <br> <br>   /* Caller is querying if we support certain format but does not <br>   **    want any data actually returned. <br>   */ <br>   if (lpformatetc-&gt;cfFormat == lpContainerApp-&gt;m_cfCntrOutl) { <br>      // we only support ISTORAGE medium <br>      sc =  OleStdQueryFormatMedium(lpformatetc, TYMED_ISTORAGE) ; <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfEmbeddedObject &amp;&amp; <br>         lpContainerDoc-&gt;m_fEmbeddedObjectAvail ) { <br>      sc =  OleStdQueryOleObjectData(lpformatetc) ; <br> <br>   } else if (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSource &amp;&amp; <br>         lpOleDoc-&gt;m_fLinkSourceAvail) { <br>      sc =  OleStdQueryLinkSourceData(lpformatetc) ; <br> <br>   // CF_TEXT and CF_OUTLINE are NOT supported when single object is copied <br>   } else if (!lpContainerDoc-&gt;m_fEmbeddedObjectAvail &amp;&amp; <br>         (lpformatetc-&gt;cfFormat == (lpOutlineApp)-&gt;m_cfOutline || <br>          lpformatetc-&gt;cfFormat == CF_TEXT) ) { <br>      // we only support HGLOBAL medium <br>      sc =  OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL) ; <br> <br>   } else if ( lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfObjectDescriptor || <br>      (lpformatetc-&gt;cfFormat == lpOleApp-&gt;m_cfLinkSrcDescriptor &amp;&amp; <br>         lpOleDoc-&gt;m_fLinkSourceAvail) ) { <br>      sc =  OleStdQueryObjectDescriptorData(lpformatetc) ; <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>         lpContainerDoc-&gt;m_fEmbeddedObjectAvail &amp;&amp; lpContainerLine &amp;&amp; <br>         (lpformatetc-&gt;dwAspect &amp; lpContainerLine-&gt;m_dwDrawAspect)) { <br> <br>      /* NOTE: as a container which draws objects, when a single <br>      **    OLE object is copied, we can give the Metafile picture of <br>      **    the object. <br>      */ <br>      // we only support MFPICT medium <br>      sc =  OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT) ; <br> <br>   } else if (lpDataObj) { <br> <br>      /* NOTE: if this document contains a single OLE object <br>      **    (ie. cfEmbeddedObject data format is available), then <br>      **    the formats offered via our IDataObject must include <br>      **    the formats available from the OLE object itself. <br>      **    thus we delegate this call to the IDataObject* of the <br>      **    OLE object. <br>      */ <br>      OLEDBG_BEGIN2("ContainerDoc_QueryGetData: delegate to OLE obj\r\n") <br>      hrErr = lpDataObj-&gt;lpVtbl-&gt;QueryGetData(lpDataObj, lpformatetc); <br>      OLEDBG_END2 <br> <br>      sc = hrErr; <br> <br>   } else { <br>      sc = DV_E_FORMATETC; <br>   } <br> <br>   if (lpDataObj) <br>      OleStdRelease((LPUNKNOWN)lpDataObj); <br>   return sc; <br>} <br> <br> <br> <br>/* ContainerDoc_SetData <br> * -------------------- <br> * <br> * Set (modify) data of the document. <br> *      This routine is called via IDataObject::SetData. <br> */ <br>HRESULT ContainerDoc_SetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpmedium, <br>      BOOL                    fRelease <br>) <br>{ <br>   /* in the container version of Outline, only DataTransferDoc's support <br>   **    IDataObject interface; the user documents do not support <br>   **    IDataObject. DataTransferDoc's do not accept SetData calls. <br>   */ <br>   return DV_E_FORMATETC; <br>} <br> <br> <br>/* ContainerDoc_EnumFormatEtc <br> * -------------------------- <br> * <br> * Return an enumerator which enumerates the data accepted/offered by <br> *      the document. <br> *      This routine is called via IDataObject::SetData. <br> */ <br>HRESULT ContainerDoc_EnumFormatEtc( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp; <br>   int nActualFmts; <br>   int i; <br>   SCODE sc = S_OK; <br> <br>   /* the Container-Only version of Outline does NOT offer <br>   **    IDataObject interface from its User documents. <br>   */ <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      return E_FAIL; <br> <br>   if (dwDirection == DATADIR_GET) { <br>      if (lpContainerDoc-&gt;m_fEmbeddedObjectAvail) { <br> <br>         /* NOTE: if this document contains a single OLE object <br>         **    (ie. cfEmbeddedObject data format is available), then <br>         **    the formats offered via our enumerator must include <br>         **    the formats available from the OLE object itself. we <br>         **    have previously set up a special array of FORMATETC's <br>         **    in OutlineDoc_CreateDataTransferDoc routine which includes <br>         **    the combination of data we offer directly and data <br>         **    offered by the OLE object. <br>         */ <br> <br>         /* If the document does not have a Moniker, then exclude <br>         **    CF_LINKSOURCE CF_LINKSRCDESCRIPTOR from the list of <br>         **    formats available. these formats are deliberately <br>         **    listed last in the array of possible "Get" formats. <br>         */ <br>         nActualFmts = lpContainerApp-&gt;m_nSingleObjGetFmts; <br>         if (! lpOleDoc-&gt;m_fLinkSourceAvail) <br>            nActualFmts -= 2; <br> <br>         // set correct dwDrawAspect for METAFILEPICT of object copied <br>         for (i = 0; i &lt; nActualFmts; i++) { <br>            if (lpContainerApp-&gt;m_arrSingleObjGetFmts[i].cfFormat == <br>                                             CF_METAFILEPICT) { <br>               lpContainerApp-&gt;m_arrSingleObjGetFmts[i].dwAspect = <br>                     lpContainerDoc-&gt;m_dwAspectOleObjCopied; <br>               break;  // DONE <br>            } <br>         } <br>         *lplpenumFormatEtc = OleStdEnumFmtEtc_Create( <br>               nActualFmts, lpContainerApp-&gt;m_arrSingleObjGetFmts); <br>         if (*lplpenumFormatEtc == NULL) <br>            sc = E_OUTOFMEMORY; <br> <br>      } else { <br> <br>         /* This document does NOT offer cfEmbeddedObject, <br>         **    therefore we can simply enumerate the <br>         **    static list of formats that we handle directly. <br>         */ <br>         *lplpenumFormatEtc = OleStdEnumFmtEtc_Create( <br>               lpOleApp-&gt;m_nDocGetFmts, lpOleApp-&gt;m_arrDocGetFmts); <br>         if (*lplpenumFormatEtc == NULL) <br>            sc = E_OUTOFMEMORY; <br>      } <br>   } else if (dwDirection == DATADIR_SET) { <br>      /* NOTE: a document that is used to transfer data <br>      **    (either via the clipboard or drag/drop does NOT <br>      **    accept SetData on ANY format! <br>      */ <br>      sc = E_NOTIMPL; <br> <br>   } else { <br>      sc = E_NOTIMPL; <br>   } <br> <br>   return sc; <br>} <br> <br> <br>#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER ) <br>/* NOTE: optionally, a container that wants to have a <br>**    potentially richer data transfer, can enumerate the data <br>**    formats from the OLE object's cache and offer them too. if <br>**    the object has a special handler, then it might be able to <br>**    render additional data formats. <br>** <br>**    CNTROUTL does NOT enumerate the cache; it implements the simpler <br>**    strategy of offering a static list of formats. the following <br>**    function is included in order to illustrates how enumerating the <br>**    cache could be done. CNTROUTL does NOT call this function. <br>** <br>*/ <br> <br>/* ContainerDoc_SetupDocGetFmts <br>** ---------------------------- <br>**    Setup the combined list of formats that this data transfer <br>**    ContainerDoc which contains a single OLE object should offer. <br>** <br>**    NOTE: The list of formats that should be offered when a <br>**    single OLE object is being transfered include the following: <br>**          * any formats the container app wants to give <br>**          * CF_EMBEDDEDOBJECT <br>**          * CF_METAFILEPICT <br>**          * any formats that the OLE object's cache can offer directly <br>** <br>**    We will offer the following formats in the order given: <br>**                  1. CF_CNTROUTL <br>**                  2. CF_EMBEDDEDOBJECT <br>**                  3. CF_OBJECTDESCRIPTOR <br>**                  4. CF_METAFILEPICT <br>**                  5. &lt;data formats from OLE object's cache&gt; <br>**                  6. CF_LINKSOURCE <br>**                  7. CF_LINKSRCDESCRIPTOR <br>*/ <br>BOOL ContainerDoc_SetupDocGetFmts( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCONTAINERLINE         lpContainerLine <br>) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOLECACHE lpOleCache; <br>   HRESULT hrErr; <br>   STATDATA        StatData; <br>   LPENUMSTATDATA  lpEnumStatData = NULL; <br>   LPFORMATETC lparrDocGetFmts = NULL; <br>   UINT nOleObjFmts = 0; <br>   UINT nTotalFmts; <br>   UINT i; <br>   UINT iFmt; <br> <br>   lpOleCache = (LPOLECACHE)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, <br>         &amp;IID_IOleCache <br>   ); <br>   if (lpOleCache) { <br>      OLEDBG_BEGIN2("IOleCache::EnumCache called\r\n") <br>      hrErr = lpOleCache-&gt;lpVtbl-&gt;EnumCache( <br>            lpOleCache, <br>            (LPENUMSTATDATA FAR*)&amp;lpEnumStatData <br>      ); <br>      OLEDBG_END2 <br>   } <br> <br>   if (lpEnumStatData) { <br>      /* Cache enumerator is available. count the number of <br>      **    formats that the OLE object's cache offers. <br>      */ <br>      while(lpEnumStatData-&gt;lpVtbl-&gt;Next( <br>               lpEnumStatData, <br>               1, <br>               (LPSTATDATA)&amp;StatData, <br>               NULL) == NOERROR) { <br>         nOleObjFmts++; <br>         // NOTE: we MUST free the TargetDevice <br>         OleStdFree(StatData.formatetc.ptd); <br>      } <br>      lpEnumStatData-&gt;lpVtbl-&gt;Reset(lpEnumStatData);  // reset for next loop <br>   } <br> <br>   /* NOTE: the maximum total number of formats that our IDataObject <br>   **    could offer equals the sum of the following: <br>   **          n offered by the OLE object's cache <br>   **       +  n normally offered by our app <br>   **       +  1 CF_EMBEDDEDOBJECT <br>   **       +  1 CF_METAFILEPICT <br>   **       +  1 CF_LINKSOURCE <br>   **       +  1 CF_LINKSRCDESCRIPTOR <br>   **    the actual number of formats that we can offer could be less <br>   **    than this total if there is any clash between the formats <br>   **    that we offer directly and those offered by the cache. if <br>   **    there is a clash, the container's rendering overrides that of <br>   **    the object. eg.: as a container transfering an OLE object we <br>   **    should directly offer CF_METAFILEPICT to guarantee that this <br>   **    format is always available. thus, if the cache offers <br>   **    CF_METAFILEPICT then it is skipped. <br>   */ <br>   nTotalFmts = nOleObjFmts + lpOleApp-&gt;m_nDocGetFmts + 4; <br>   lparrDocGetFmts = (LPFORMATETC)New (nTotalFmts * sizeof(FORMATETC)); <br> <br>   OleDbgAssertSz(lparrDocGetFmts != NULL,"Error allocating arrDocGetFmts"); <br>   if (lparrDocGetFmts == NULL) <br>         return FALSE; <br> <br>   for (i = 0, iFmt = 0; i &lt; lpOleApp-&gt;m_nDocGetFmts; i++) { <br>      _fmemcpy((LPFORMATETC)&amp;lparrDocGetFmts[iFmt++], <br>            (LPFORMATETC)&amp;lpOleApp-&gt;m_arrDocGetFmts[i], <br>            sizeof(FORMATETC) <br>      ); <br>      if (lpOleApp-&gt;m_arrDocGetFmts[i].cfFormat == <br>         lpContainerApp-&gt;m_cfCntrOutl) { <br>         /* insert CF_EMBEDDEDOBJECT, CF_METAFILEPICT, and formats <br>         **    available from the OLE object's cache following <br>         **    CF_CNTROUTL. <br>         */ <br>         lparrDocGetFmts[iFmt].cfFormat = lpOleApp-&gt;m_cfEmbeddedObject; <br>         lparrDocGetFmts[iFmt].ptd      = NULL; <br>         lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT; <br>         lparrDocGetFmts[iFmt].tymed    = TYMED_ISTORAGE; <br>         lparrDocGetFmts[iFmt].lindex   = -1; <br>         iFmt++; <br>         lparrDocGetFmts[iFmt].cfFormat = CF_METAFILEPICT; <br>         lparrDocGetFmts[iFmt].ptd      = NULL; <br>         lparrDocGetFmts[iFmt].dwAspect = lpContainerLine-&gt;m_dwDrawAspect; <br>         lparrDocGetFmts[iFmt].tymed    = TYMED_MFPICT; <br>         lparrDocGetFmts[iFmt].lindex   = -1; <br>         iFmt++; <br> <br>         if (lpEnumStatData) { <br>            /* Cache enumerator is available. enumerate all of <br>            **    the formats that the OLE object's cache offers. <br>            */ <br>            while(lpEnumStatData-&gt;lpVtbl-&gt;Next( <br>                  lpEnumStatData, <br>                  1, <br>                  (LPSTATDATA)&amp;StatData, <br>                  NULL) == NOERROR) { <br>               /* check if the format clashes with one of our fmts */ <br>               if (StatData.formatetc.cfFormat != CF_METAFILEPICT <br>                  &amp;&amp; ! OleStdIsDuplicateFormat( <br>                        (LPFORMATETC)&amp;StatData.formatetc, <br>                        lpOleApp-&gt;m_arrDocGetFmts, <br>                        lpOleApp-&gt;m_nDocGetFmts)) { <br>                  OleStdCopyFormatEtc( <br>                        &amp;(lparrDocGetFmts[iFmt]),&amp;StatData.formatetc); <br>                  iFmt++; <br>               } <br>               // NOTE: we MUST free the TargetDevice <br>               OleStdFree(StatData.formatetc.ptd); <br>            } <br>         } <br>      } <br>   } <br> <br>   if (lpOleCache) <br>      OleStdRelease((LPUNKNOWN)lpOleCache); <br> <br>   /* append CF_LINKSOURCE format */ <br>   lparrDocGetFmts[iFmt].cfFormat = lpOleApp-&gt;m_cfLinkSource; <br>   lparrDocGetFmts[iFmt].ptd      = NULL; <br>   lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT; <br>   lparrDocGetFmts[iFmt].tymed    = TYMED_ISTREAM; <br>   lparrDocGetFmts[iFmt].lindex   = -1; <br>   iFmt++; <br> <br>   /* append CF_LINKSRCDESCRIPTOR format */ <br>   lparrDocGetFmts[iFmt].cfFormat = lpOleApp-&gt;m_cfLinkSrcDescriptor; <br>   lparrDocGetFmts[iFmt].ptd      = NULL; <br>   lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT; <br>   lparrDocGetFmts[iFmt].tymed    = TYMED_HGLOBAL; <br>   lparrDocGetFmts[iFmt].lindex   = -1; <br>   iFmt++; <br> <br>   lpContainerDoc-&gt;m_lparrDocGetFmts = lparrDocGetFmts; <br>   lpContainerDoc-&gt;m_nDocGetFmts = iFmt; <br> <br>   if (lpEnumStatData) <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpEnumStatData, <br>            "Cache enumerator not released properly" <br>      ); <br> <br>   return TRUE; <br>} <br>#endif  // OPTIONAL_ADVANCED_DATA_TRANSFER <br> <br>#endif  // OLE_CNTR </code></pre>
<p>&nbsp;</p></body>
</HTML>
