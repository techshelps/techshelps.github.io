<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLNTBL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context304"></a>OUTLNTBL.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outlntbl.c <br>** <br>**    This file contains OutlineNameTable functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br>OLECHAR ErrMsgNameTable[] = OLESTR("Can't create NameTable!"); <br> <br> <br>/* OutlineNameTable_Init <br> * --------------------- <br> * <br> *      initialize a name table. <br> */ <br>BOOL OutlineNameTable_Init(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   HWND lpParent = OutlineDoc_GetWindow(lpOutlineDoc); <br> <br>   lpOutlineNameTable-&gt;m_nCount = 0; <br> <br>   /* We will use an OwnerDraw listbox as our data structure to <br>   **    maintain the table of Names. this listbox will never be made <br>   **    visible. the listbox is just a convenient data structure to <br>   **    manage a collection. <br>   */ <br>   lpOutlineNameTable-&gt;m_hWndListBox = CreateWindow( <br>               "listbox",              /* Window class name           */ <br>               NULL,                   /* Window's title              */ <br>               WS_CHILDWINDOW | <br>               LBS_OWNERDRAWFIXED, <br>               0, 0,                   /* Use default X, Y            */ <br>               0, 0,                   /* Use default X, Y            */ <br>               lpParent,               /* Parent window's handle      */ <br>               (HMENU)IDC_NAMETABLE,   /* Child Window ID             */ <br>               g_lpApp-&gt;m_hInst,       /* Instance of window          */ <br>               NULL);                  /* Create struct for WM_CREATE */ <br> <br>   if (! lpOutlineNameTable-&gt;m_hWndListBox) { <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgNameTable); <br>      return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineNameTable_Destroy <br> * ------------------------ <br> * <br> *      Free memory used by the name table. <br> */ <br>void OutlineNameTable_Destroy(LPOUTLINENAMETABLE lpOutlineNameTable) <br>{ <br>   // Delete all names <br>   OutlineNameTable_ClearAll(lpOutlineNameTable); <br> <br>   DestroyWindow(lpOutlineNameTable-&gt;m_hWndListBox); <br>   Delete(lpOutlineNameTable); <br>} <br> <br> <br>/* OutlineNameTable_AddName <br> * ------------------------ <br> * <br> *      Add a name to the table <br> */ <br>void OutlineNameTable_AddName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName) <br>{ <br>   SendMessage( <br>         lpOutlineNameTable-&gt;m_hWndListBox, <br>         LB_ADDSTRING, <br>         0, <br>         (DWORD)lpOutlineName <br>   ); <br>   lpOutlineNameTable-&gt;m_nCount++; <br>} <br> <br> <br>/* OutlineNameTable_DeleteName <br> * --------------------------- <br> * <br> *      Delete a name from table <br> */ <br>void OutlineNameTable_DeleteName(LPOUTLINENAMETABLE lpOutlineNameTable,int nIndex) <br>{ <br>   LPOUTLINENAME lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, nIndex); <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: if there is a pseudo object attached to this name, it <br>   **    must first be closed before deleting the Name. this will <br>   **    cause OnClose notification to be sent to all linking clients. <br>   */ <br>   ServerName_ClosePseudoObj((LPSERVERNAME)lpOutlineName); <br>#endif <br> <br>   if (lpOutlineName) <br>      Delete(lpOutlineName);      // free memory for name <br> <br>   SendMessage( <br>         lpOutlineNameTable-&gt;m_hWndListBox, <br>         LB_DELETESTRING, <br>         (WPARAM)nIndex, <br>         0L <br>   ); <br>   lpOutlineNameTable-&gt;m_nCount--; <br>} <br> <br> <br>/* OutlineNameTable_GetNameIndex <br> * ----------------------------- <br> * <br> *      Return the index of the Name given a pointer to the Name. <br> *      Return -1 if the Name is not found. <br> */ <br>int OutlineNameTable_GetNameIndex(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName) <br>{ <br>   LRESULT lReturn; <br> <br>   if (! lpOutlineName) return -1; <br> <br>   lReturn = SendMessage( <br>         lpOutlineNameTable-&gt;m_hWndListBox, <br>         LB_FINDSTRING, <br>         (WPARAM)-1, <br>         (LPARAM)(LPCSTR)lpOutlineName <br>      ); <br> <br>   return ((lReturn == LB_ERR) ? -1 : (int)lReturn); <br>} <br> <br> <br>/* OutlineNameTable_GetName <br> * ------------------------ <br> * <br> *      Retrieve the pointer to the Name given its index in the NameTable <br> */ <br>LPOUTLINENAME OutlineNameTable_GetName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex) <br>{ <br>   LPOUTLINENAME lpOutlineName = NULL; <br>    LRESULT lResult; <br> <br>   if (lpOutlineNameTable-&gt;m_nCount == 0 || <br>      nIndex &gt; lpOutlineNameTable-&gt;m_nCount || <br>      nIndex &lt; 0) { <br>      return NULL; <br>   } <br> <br>   lResult = SendMessage( <br>         lpOutlineNameTable-&gt;m_hWndListBox, <br>         LB_GETTEXT, <br>         nIndex, <br>         (LPARAM)(LPCSTR)&amp;lpOutlineName <br>   ); <br>    OleDbgAssert(lResult != LB_ERR); <br>   return lpOutlineName; <br>} <br> <br> <br>/* OutlineNameTable_FindName <br> * ------------------------- <br> * <br> *      Find a name in the name table given a string. <br> */ <br>LPOUTLINENAME OutlineNameTable_FindName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOLESTR lpszName) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   BOOL fFound = FALSE; <br>   int i; <br> <br>   for (i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      if (OLESTRCMP(lpOutlineName-&gt;m_szName, lpszName) == 0) { <br>         fFound = TRUE; <br>         break;      // FOUND MATCH! <br>      } <br>   } <br> <br>   return (fFound ? lpOutlineName : NULL); <br>} <br> <br> <br>/* OutlineNameTable_FindNamedRange <br> * ------------------------------- <br> * <br> *      Find a name in the name table which matches a given line range. <br> */ <br>LPOUTLINENAME OutlineNameTable_FindNamedRange(LPOUTLINENAMETABLE lpOutlineNameTable, LPLINERANGE lplrSel) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   BOOL fFound = FALSE; <br>   int i; <br> <br>   for (i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      if ((lpOutlineName-&gt;m_nStartLine == lplrSel-&gt;m_nStartLine) &amp;&amp; <br>         (lpOutlineName-&gt;m_nEndLine == lplrSel-&gt;m_nEndLine) ) { <br>         fFound = TRUE; <br>         break;      // FOUND MATCH! <br>      } <br>   } <br> <br>   return (fFound ? lpOutlineName : NULL); <br>} <br> <br> <br>/* OutlineNameTable_GetCount <br> * ------------------------- <br> * <br> * Return number of names in nametable <br> */ <br>int OutlineNameTable_GetCount(LPOUTLINENAMETABLE lpOutlineNameTable) <br>{ <br>   if (!lpOutlineNameTable) <br>      return 0; <br> <br>   return lpOutlineNameTable-&gt;m_nCount; <br>} <br> <br> <br>/* OutlineNameTable_ClearAll <br> * ------------------------- <br> * <br> *      Remove all names from table <br> */ <br>void OutlineNameTable_ClearAll(LPOUTLINENAMETABLE lpOutlineNameTable) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   int i; <br>   int nCount = lpOutlineNameTable-&gt;m_nCount; <br> <br>   for (i = 0; i &lt; nCount; i++) { <br>      lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      Delete(lpOutlineName);      // free memory for name <br>   } <br> <br>   lpOutlineNameTable-&gt;m_nCount = 0; <br>   SendMessage(lpOutlineNameTable-&gt;m_hWndListBox,LB_RESETCONTENT,0,0L); <br>} <br> <br> <br>/* OutlineNameTable_AddLineUpdate <br> * ------------------------------ <br> * <br> *      Update table when a new line is added at nAddIndex <br> * The line used to be at nAddIndex is pushed down <br> */ <br>void OutlineNameTable_AddLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nAddIndex) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   LINERANGE lrSel; <br>   int i; <br>   BOOL fRangeModified = FALSE; <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      OutlineName_GetSel(lpOutlineName, &amp;lrSel); <br> <br>      if((int)lrSel.m_nStartLine &gt; nAddIndex) { <br>         lrSel.m_nStartLine++; <br>         fRangeModified = !fRangeModified; <br>      } <br>      if((int)lrSel.m_nEndLine &gt; nAddIndex) { <br>         lrSel.m_nEndLine++; <br>         fRangeModified = !fRangeModified; <br>      } <br> <br>      OutlineName_SetSel(lpOutlineName, &amp;lrSel, fRangeModified); <br>   } <br>} <br> <br> <br>/* OutlineNameTable_DeleteLineUpdate <br> * --------------------------------- <br> * <br> *      Update the table when a line at nDeleteIndex is removed <br> */ <br>void OutlineNameTable_DeleteLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nDeleteIndex) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   LINERANGE lrSel; <br>   int i; <br>   BOOL fRangeModified = FALSE; <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      OutlineName_GetSel(lpOutlineName, &amp;lrSel); <br> <br>      if((int)lrSel.m_nStartLine &gt; nDeleteIndex) { <br>         lrSel.m_nStartLine--; <br>         fRangeModified = !fRangeModified; <br>      } <br>      if((int)lrSel.m_nEndLine &gt;= nDeleteIndex) { <br>         lrSel.m_nEndLine--; <br>         fRangeModified = !fRangeModified; <br>      } <br> <br>      // delete the name if its entire range is deleted <br>      if(lrSel.m_nStartLine &gt; lrSel.m_nEndLine) { <br>         OutlineNameTable_DeleteName(lpOutlineNameTable, i); <br>         i--;  // re-examine this name <br>      } else { <br>         OutlineName_SetSel(lpOutlineName, &amp;lrSel, fRangeModified); <br>      } <br>   } <br>} <br> <br> <br>/* OutlineNameTable_SaveSelToStg <br> * ----------------------------- <br> * <br> *      Save only the names that refer to lines completely contained in the <br> * specified selection range. <br> */ <br>BOOL OutlineNameTable_SaveSelToStg( <br>      LPOUTLINENAMETABLE      lpOutlineNameTable, <br>      LPLINERANGE             lplrSel, <br>      UINT                    uFormat, <br>      LPSTREAM                lpNTStm <br>) <br>{ <br>   HRESULT hrErr; <br>   ULONG nWritten; <br>   LPOUTLINENAME lpOutlineName; <br>   short nNameCount = 0; <br>   BOOL fNameSaved; <br>   BOOL fStatus; <br>   int i; <br>   LARGE_INTEGER dlibZeroOffset; <br>   LISet32( dlibZeroOffset, 0 ); <br> <br>   /* initially write 0 for count of names. the correct count will be <br>   **    written at the end when we know how many names qualified to <br>   **    be written (within the selection). <br>   */ <br>   hrErr = lpNTStm-&gt;lpVtbl-&gt;Write( <br>         lpNTStm, <br>         (short FAR*)&amp;nNameCount, <br>         sizeof(nNameCount), <br>         &amp;nWritten <br>   ); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Write NameTable header returned", hrErr); <br>      goto error; <br>    } <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br>      fStatus = OutlineName_SaveToStg( <br>            lpOutlineName, <br>            lplrSel, <br>            uFormat, <br>            lpNTStm, <br>            (BOOL FAR*)&amp;fNameSaved <br>      ); <br>      if (! fStatus) goto error; <br>      if (fNameSaved) nNameCount++; <br>   } <br> <br>   /* write the final count of names written. */ <br>   hrErr = lpNTStm-&gt;lpVtbl-&gt;Seek( <br>         lpNTStm, <br>         dlibZeroOffset, <br>         STREAM_SEEK_SET, <br>         NULL <br>   ); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Seek to NameTable header returned", hrErr); <br>      goto error; <br>    } <br> <br>   hrErr = lpNTStm-&gt;lpVtbl-&gt;Write( <br>         lpNTStm, <br>         (short FAR*)&amp;nNameCount, <br>         sizeof(nNameCount), <br>         &amp;nWritten <br>   ); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Write NameTable count in header returned", hrErr); <br>      goto error; <br>    } <br> <br>   OleStdRelease((LPUNKNOWN)lpNTStm); <br>   return TRUE; <br> <br>error: <br>   if (lpNTStm) <br>      OleStdRelease((LPUNKNOWN)lpNTStm); <br> <br>   return FALSE; <br>} <br> <br> <br>/* OutlineNameTable_LoadFromStg <br> * ---------------------------- <br> * <br> *      Load Name Table from file <br> * <br> *      Return TRUE if ok, FALSE if error <br> */ <br>BOOL OutlineNameTable_LoadFromStg(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTORAGE lpSrcStg) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HRESULT hrErr; <br>   IStream FAR* lpNTStm; <br>   ULONG nRead; <br>   short nCount; <br>   LPOUTLINENAME lpOutlineName; <br>   BOOL fStatus; <br>   short i; <br> <br>   hrErr = lpSrcStg-&gt;lpVtbl-&gt;OpenStream( <br>         lpSrcStg, <br>         OLESTR("NameTable"), <br>         NULL, <br>         STGM_READ | STGM_SHARE_EXCLUSIVE, <br>         0, <br>         &amp;lpNTStm <br>   ); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("OpenStream NameTable returned", hrErr); <br>      goto error; <br>    } <br> <br>   hrErr = lpNTStm-&gt;lpVtbl-&gt;Read(lpNTStm,&amp;nCount,sizeof(nCount),&amp;nRead); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Read NameTable header returned", hrErr); <br>      goto error; <br>    } <br> <br>   for (i = 0; i &lt; nCount; i++) { <br>      lpOutlineName = OutlineApp_CreateName(lpOutlineApp); <br>      if (! lpOutlineName) goto error; <br>      fStatus = OutlineName_LoadFromStg(lpOutlineName, lpNTStm); <br>      if (! fStatus) goto error; <br>      OutlineNameTable_AddName(lpOutlineNameTable, lpOutlineName); <br>   } <br> <br>   OleStdRelease((LPUNKNOWN)lpNTStm); <br>   return TRUE; <br> <br>error: <br>   if (lpNTStm) <br>      OleStdRelease((LPUNKNOWN)lpNTStm); <br> <br>   return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
