<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CNTRINPL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context274"></a>CNTRINPL.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Container Sample Code <br>** <br>**    cntrinpl.c <br>** <br>**    This file contains all interfaces, methods and related support <br>**    functions for an In-Place Container application (aka. Visual <br>**    Editing). The in-place Container application includes the following <br>**    implementation objects: <br>** <br>**    ContainerApp Object <br>**      exposed interfaces: <br>**          IOleInPlaceFrame <br>** <br>**    ContainerDoc Object <br>**      support functions only <br>**      (ICntrOtl is an SDI app; it doesn't support a Doc level IOleUIWindow) <br>** <br>**    ContainerLin Object <br>**      exposed interfaces: <br>**          IOleInPlaceSite <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br>#if defined( USE_STATUSBAR ) <br>#include "status.h" <br>#endif <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br>extern BOOL g_fInsideOutContainer; <br>extern RECT g_rectNull; <br> <br>/************************************************************************* <br>** ContainerApp::IOleInPlaceFrame interface implementation <br>*************************************************************************/ <br> <br>// IOleInPlaceFrame::QueryInterface <br>STDMETHODIMP CntrApp_IPFrame_QueryInterface( <br>      LPOLEINPLACEFRAME   lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   SCODE sc = E_NOINTERFACE; <br>   LPCONTAINERAPP lpContainerApp = <br>         ((struct COleInPlaceFrameImpl FAR*)lpThis)-&gt;lpContainerApp; <br> <br>   /* The object should not be able to access the other interfaces <br>   ** of our App object by doing QI on this interface. <br>   */ <br>   *lplpvObj = NULL; <br>   if (IsEqualIID(riid, &amp;IID_IUnknown) || <br>      IsEqualIID(riid, &amp;IID_IOleWindow) || <br>      IsEqualIID(riid, &amp;IID_IOleInPlaceUIWindow) || <br>      IsEqualIID(riid, &amp;IID_IOleInPlaceFrame)) { <br>      OleDbgOut4("CntrApp_IPFrame_QueryInterface: IOleInPlaceFrame* RETURNED\r\n"); <br>      *lplpvObj = (LPVOID) &amp;lpContainerApp-&gt;m_OleInPlaceFrame; <br>      OleApp_AddRef((LPOLEAPP)lpContainerApp); <br>      sc = S_OK; <br>   } <br> <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br> <br>   return sc; <br>} <br> <br> <br>// IOleInPlaceFrame::AddRef <br>STDMETHODIMP_(ULONG) CntrApp_IPFrame_AddRef(LPOLEINPLACEFRAME lpThis) <br>{ <br>   OleDbgAddRefMethod(lpThis, "IOleInPlaceFrame"); <br> <br>   return OleApp_AddRef((LPOLEAPP)g_lpApp); <br>} <br> <br> <br>// IOleInPlaceFrame::Release <br>STDMETHODIMP_(ULONG) CntrApp_IPFrame_Release(LPOLEINPLACEFRAME lpThis) <br>{ <br>   OleDbgReleaseMethod(lpThis, "IOleInPlaceFrame"); <br> <br>   return OleApp_Release((LPOLEAPP)g_lpApp); <br>} <br> <br> <br>// IOleInPlaceFrame::GetWindow <br>STDMETHODIMP CntrApp_IPFrame_GetWindow( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HWND FAR*           lphwnd <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_GetWindow\r\n") <br>   *lphwnd = lpOutlineApp-&gt;m_hWndApp; <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::ContextSensitiveHelp <br>STDMETHODIMP CntrApp_IPFrame_ContextSensitiveHelp( <br>   LPOLEINPLACEFRAME   lpThis, <br>   BOOL                fEnterMode <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = <br>         ((struct COleInPlaceFrameImpl FAR*)lpThis)-&gt;lpContainerApp; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrApp_IPFrame_AddRef(lpThis); <br> <br>   OleDbgOut("CntrApp_IPFrame_ContextSensitiveHelp\r\n"); <br>   /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>   **    This method is called when F1 is pressed when a menu item is <br>   **    selected. We set the frame's m_fMenuMode flag here. later, <br>   **    in WM_COMMAND processing in the AppWndProc, if this flag is <br>   **    set then the command is NOT executed and help is given <br>   **    instead. <br>   */ <br>   lpContainerApp-&gt;m_fMenuHelpMode = fEnterMode; <br> <br>   // release artificial AddRef <br>   CntrApp_IPFrame_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::GetBorder <br>STDMETHODIMP CntrApp_IPFrame_GetBorder( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPRECT              lprectBorder <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrApp_IPFrame_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_GetBorder\r\n") <br> <br>   OutlineApp_GetFrameRect(lpOutlineApp, lprectBorder); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrApp_IPFrame_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::RequestBorderSpace <br>STDMETHODIMP CntrApp_IPFrame_RequestBorderSpace( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCBORDERWIDTHS     lpWidths <br>) <br>{ <br>#if defined( _DEBUG ) <br>   OleDbgOut2("CntrApp_IPFrame_RequestBorderSpace\r\n"); <br> <br>   { <br>      /* FOR DEBUGING PURPOSES ONLY -- we will fail to allow to an <br>      **    object to get any frame border space for frame tools if <br>      **    our own frame tools are poped up in the tool pallet. this <br>      **    is NOT recommended UI behavior but it allows us to test <br>      **    in the condition when the frame does not give border <br>      **    space for the object. an object in this situation must <br>      **    then either popup its tools in a floating pallet, do <br>      **    without the tools, or fail to in-place activate. <br>      */ <br>      LPCONTAINERAPP lpContainerApp = <br>            ((struct COleInPlaceFrameImpl FAR*)lpThis)-&gt;lpContainerApp; <br>      LPFRAMETOOLS lpft = OutlineApp_GetFrameTools( <br>            (LPOUTLINEAPP)lpContainerApp); <br> <br>      if (lpft-&gt;m_ButtonBar.m_nState == BARSTATE_POPUP &amp;&amp; <br>         lpft-&gt;m_FormulaBar.m_nState == BARSTATE_POPUP) { <br>         OleDbgOut3( <br>               "CntrApp_IPFrame_RequestBorderSpace: allow NO SPACE\r\n"); <br>         return E_FAIL; <br>      } <br>   } <br>#endif  // _DEBUG <br> <br>   /* NOTE: we allow the object to have as much border space as it <br>   **    wants. <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::SetBorderSpace <br>STDMETHODIMP CntrApp_IPFrame_SetBorderSpace( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCBORDERWIDTHS     lpWidths <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = <br>         ((struct COleInPlaceFrameImpl FAR*)lpThis)-&gt;lpContainerApp; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrApp_IPFrame_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_SetBorderSpace\r\n") <br> <br>   /* NOTE: this fMustResizeClientArea flag is used as part of our <br>   **    defensive programming for frame window resizing. when the <br>   **    frame window is resized,IOleInPlaceActiveObject::ResizeBorder <br>   **    is called the object should normally call back to renegotiate <br>   **    for frame-level tools space. if SetBorderSpace is called then <br>   **    our client area windows are properly resized. if the in-place <br>   **    active object does NOT call SetBorderSpace, then the <br>   **    container must take care to resize its client area windows <br>   **    itself (see ContainerDoc_FrameWindowResized) <br>   */ <br>   if (lpContainerApp-&gt;m_fMustResizeClientArea) <br>      lpContainerApp-&gt;m_fMustResizeClientArea = FALSE; <br> <br>   if (lpWidths == NULL) { <br> <br>      /* NOTE: IOleInPlaceSite::SetBorderSpace(NULL) is called <br>      **    when the in-place active object does NOT want any tool <br>      **    space. in this situation the in-place container should <br>      **    put up its tools. <br>      */ <br>      LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpContainerApp; <br>      LPCONTAINERDOC lpContainerDoc; <br> <br>      lpContainerDoc =(LPCONTAINERDOC)OutlineApp_GetActiveDoc(lpOutlineApp); <br>      ContainerDoc_AddFrameLevelTools(lpContainerDoc); <br>   } else { <br> <br>      // NOTE: you could do validation of borderwidths here <br>#if defined( _DEBUG ) <br>      /* FOR DEBUGING PURPOSES ONLY -- we will fail to allow to an <br>      **    object to get any frame border space for frame tools if <br>      **    our own frame tools are poped up in the tool pallet. this <br>      **    is NOT recommended UI behavior but it allows us to test <br>      **    in the condition when the frame does not give border <br>      **    space for the object. an object in this situation must <br>      **    then either popup its tools in a floating pallet, do <br>      **    without the tools, or fail to in-place activate. <br>      */ <br>      LPFRAMETOOLS lpft = OutlineApp_GetFrameTools( <br>            (LPOUTLINEAPP)lpContainerApp); <br> <br>      if ((lpft-&gt;m_ButtonBar.m_nState == BARSTATE_POPUP &amp;&amp; <br>         lpft-&gt;m_FormulaBar.m_nState == BARSTATE_POPUP) &amp;&amp; <br>         (lpWidths-&gt;top || lpWidths-&gt;bottom || <br>            lpWidths-&gt;left || lpWidths-&gt;right) ) { <br>         OleDbgOut3("CntrApp_IPFrame_SetBorderSpace: allow NO SPACE\r\n"); <br>         OLEDBG_END2 <br> <br>         OutlineApp_SetBorderSpace( <br>               (LPOUTLINEAPP) lpContainerApp, <br>               (LPBORDERWIDTHS)&amp;g_rectNull <br>         ); <br>         OLEDBG_END2 <br>         // release artificial AddRef <br>         CntrApp_IPFrame_Release(lpThis); <br> <br>         return E_FAIL; <br>      } <br>#endif  // _DEBUG <br> <br>      OutlineApp_SetBorderSpace( <br>            (LPOUTLINEAPP) lpContainerApp, <br>            (LPBORDERWIDTHS)lpWidths <br>      ); <br>   } <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrApp_IPFrame_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::SetActiveObject <br>STDMETHODIMP CntrApp_IPFrame_SetActiveObject( <br>   LPOLEINPLACEFRAME           lpThis, <br>   LPOLEINPLACEACTIVEOBJECT    lpActiveObject, <br>   LPCOLESTR                   lpszObjName <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   // artificial AddRef in case object is destroyed during call <br>   CntrApp_IPFrame_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_SetActiveObject\r\n") <br> <br>   lpContainerApp-&gt;m_hWndUIActiveObj = NULL; <br> <br>   if (lpContainerApp-&gt;m_lpIPActiveObj) <br>      lpContainerApp-&gt;m_lpIPActiveObj-&gt;lpVtbl-&gt;Release(lpContainerApp-&gt;m_lpIPActiveObj); <br> <br>   if ((lpContainerApp-&gt;m_lpIPActiveObj = lpActiveObject) != NULL) { <br>      lpContainerApp-&gt;m_lpIPActiveObj-&gt;lpVtbl-&gt;AddRef( <br>            lpContainerApp-&gt;m_lpIPActiveObj); <br> <br>      OLEDBG_BEGIN2("IOleInPlaceActiveObject::GetWindow called\r\n") <br>      lpActiveObject-&gt;lpVtbl-&gt;GetWindow( <br>            lpActiveObject, <br>            (HWND FAR*)&amp;lpContainerApp-&gt;m_hWndUIActiveObj <br>      ); <br>      OLEDBG_END2 <br> <br>      /* NOTE: see comment for ContainerDoc_ForwardPaletteChangedMsg */ <br>      /* No need to do this if you don't allow object to own the palette */ <br>      OleApp_QueryNewPalette((LPOLEAPP)lpContainerApp); <br>   } <br> <br>   /* NOTE: the new UI Guidelines recommend that in-place <br>   **    containers do NOT change their window titles when an object <br>   **    becomes in-place (UI) active. <br>   */ <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrApp_IPFrame_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::InsertMenus <br>STDMETHODIMP CntrApp_IPFrame_InsertMenus( <br>   LPOLEINPLACEFRAME       lpThis, <br>   HMENU                   hMenu, <br>   LPOLEMENUGROUPWIDTHS    lpMenuWidths <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   BOOL    fNoError = TRUE; <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_InsertMenus\r\n") <br> <br>   fNoError &amp;= AppendMenu(hMenu, MF_POPUP, (UINT)lpContainerApp-&gt;m_hMenuFile, <br>                  "&amp;File"); <br>   fNoError &amp;= AppendMenu(hMenu, MF_POPUP, (UINT)lpContainerApp-&gt;m_hMenuView, <br>                  "O&amp;utline"); <br>   fNoError &amp;= AppendMenu(hMenu, MF_POPUP,(UINT)lpContainerApp-&gt;m_hMenuDebug, <br>                  "DbgI&amp;Cntr"); <br>   lpMenuWidths-&gt;width[0] = 1; <br>   lpMenuWidths-&gt;width[2] = 1; <br>   lpMenuWidths-&gt;width[4] = 1; <br> <br>   OLEDBG_END2 <br> <br>   return (fNoError ? NOERROR : E_FAIL); <br>} <br> <br> <br>// IOleInPlaceFrame::SetMenu <br>STDMETHODIMP CntrApp_IPFrame_SetMenu( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HMENU               hMenuShared, <br>   HOLEMENU            hOleMenu, <br>   HWND                hwndActiveObject <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HMENU   hMenu; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_InsertMenus\r\n") <br> <br> <br>   /* NOTE: either put up the shared menu (combined menu from <br>   **    in-place server and in-place container) or our container's <br>   **    normal menu as directed. <br>   */ <br>   if (hOleMenu &amp;&amp; hMenuShared) <br>      hMenu = hMenuShared; <br>   else <br>      hMenu = lpOutlineApp-&gt;m_hMenuApp; <br> <br>   /* NOTE: SDI apps put menu on frame by calling SetMenu. <br>   **    MDI apps would send WM_MDISETMENU message instead. <br>   */ <br>   SetMenu (lpOutlineApp-&gt;m_hWndApp, hMenu); <br>   OLEDBG_BEGIN2("OleSetMenuDescriptor called\r\n") <br>   hrErr = OleSetMenuDescriptor (hOleMenu, lpOutlineApp-&gt;m_hWndApp, <br>               hwndActiveObject, NULL, NULL); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IOleInPlaceFrame::RemoveMenus <br>STDMETHODIMP CntrApp_IPFrame_RemoveMenus( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HMENU               hMenu <br>) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   BOOL fNoError = TRUE; <br> <br>   OLEDBG_BEGIN2("CntrApp_IPFrame_RemoveMenus\r\n") <br> <br>   /* Remove container group menus */ <br>   while (GetMenuItemCount(hMenu)) <br>      fNoError &amp;= RemoveMenu(hMenu, 0, MF_BYPOSITION); <br> <br>   OleDbgAssert(fNoError == TRUE); <br> <br>   OLEDBG_END2 <br> <br>   return (fNoError ? NOERROR : E_FAIL); <br>} <br> <br> <br>// IOleInPlaceFrame::SetStatusText <br>STDMETHODIMP CntrApp_IPFrame_SetStatusText( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCOLESTR           lpszStatusText <br>) <br>{ <br>#if defined( USE_STATUSBAR ) <br>   LPOUTLINEAPP   lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   OLECHAR         szMessageHold[128]; <br>   OleDbgOut2("CntrApp_IPFrame_SetStatusText\r\n"); <br> <br>   /* NOTE: it is important to save a private copy of status text. <br>   **    lpszStatusText is only valid for the duration of this call. <br>   */ <br>   OLESTRCPY(szMessageHold, lpszStatusText); <br>   OutlineApp_SetStatusText(lpOutlineApp, /*(LPOLESTR)*/szMessageHold); <br> <br>   return S_OK; <br>#else <br>   return E_NOTIMPL; <br>#endif  // USE_STATUSBAR <br>} <br> <br> <br>// IOleInPlaceFrame::EnableModeless <br>STDMETHODIMP CntrApp_IPFrame_EnableModeless( <br>   LPOLEINPLACEFRAME   lpThis, <br>   BOOL                fEnable <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP) <br>         ((struct COleInPlaceFrameImpl FAR*)lpThis)-&gt;lpContainerApp; <br>#if defined( _DEBUG ) <br>   if (fEnable) <br>      OleDbgOut2("CntrApp_IPFrame_EnableModeless(TRUE)\r\n"); <br>   else <br>      OleDbgOut2("CntrApp_IPFrame_EnableModeless(FALSE)\r\n"); <br>#endif  // _DEBUG <br> <br>   /* NOTE: this method is called when an object puts up a modal <br>   **    dialog. it tells the top-level in-place container to disable <br>   **    it modeless dialogs for the duration that the object is <br>   **    displaying a modal dialog. <br>   ** <br>   **    ICNTROTL does not use any modeless dialogs, thus we can <br>   **    ignore this method. <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceFrame::TranslateAccelerator <br>STDMETHODIMP CntrApp_IPFrame_TranslateAccelerator( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPMSG               lpmsg, <br>   WORD                wID <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   SCODE sc; <br> <br>   if (TranslateAccelerator (lpOutlineApp-&gt;m_hWndApp, <br>                  lpContainerApp-&gt;m_hAccelIPCntr, lpmsg)) <br>      sc = S_OK; <br> <br>#if defined (MDI_VERSION) <br>   else if (TranslateMDISysAccel(lpOutlineApp-&gt;m_hWndMDIClient, lpmsg)) <br>      sc = S_OK; <br>#endif  // MDI_VERSION <br> <br>   else <br>      sc = S_FALSE; <br> <br>   return sc; <br>} <br> <br> <br> <br>/************************************************************************* <br>** ContainerDoc Support Functions <br>*************************************************************************/ <br> <br> <br>/* ContainerDoc_UpdateInPlaceObjectRects <br>** ------------------------------------- <br>**    Update the PosRect and ClipRect of the currently in-place active <br>**    object. if there is no object active in-place, then do nothing. <br>** <br>**    NOTE: this function should be called when an action occurs <br>**    that changes either the position of the object in the document <br>**    (eg. changing document margins changes PosRect) or the clipRect <br>**    changes (eg. resizing the document window changes the ClipRect). <br>*/ <br>void ContainerDoc_UpdateInPlaceObjectRects(LPCONTAINERDOC lpContainerDoc, int nIndex) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int i; <br>   LPLINE lpLine; <br>   RECT rcClipRect; <br> <br>   if (g_fInsideOutContainer) { <br> <br>      if (lpContainerDoc-&gt;m_cIPActiveObjects) { <br> <br>         /* NOTE: (INSIDE-OUT CONTAINER) we must update the <br>         **    PosRect/ClipRect for all in-place active objects <br>         **    starting from line "nIndex". <br>         */ <br>         ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&amp;rcClipRect); <br> <br>#if defined( _DEBUG ) <br>         OleDbgOutRect3( <br>               "ContainerDoc_UpdateInPlaceObjectRects (ClipRect)", <br>               (LPRECT)&amp;rcClipRect <br>         ); <br>#endif <br>         for (i = nIndex; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>            lpLine=LineList_GetLine(lpLL, i); <br> <br>            if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>               LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br>               ContainerLine_UpdateInPlaceObjectRects( <br>                     lpContainerLine, &amp;rcClipRect); <br>            } <br>         } <br>      } <br>   } <br>   else { <br>      /* NOTE: (OUTSIDE-IN CONTAINER) if there is a currently <br>      **    UIActive object, we must inform it that the <br>      **    PosRect/ClipRect has now changed. <br>      */ <br>      LPCONTAINERLINE lpLastUIActiveLine = <br>            lpContainerDoc-&gt;m_lpLastUIActiveLine; <br>      if (lpLastUIActiveLine &amp;&amp; lpLastUIActiveLine-&gt;m_fUIActive) { <br>         ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&amp;rcClipRect); <br> <br>         OleDbgOutRect3("OutlineDoc_Resize (ClipRect)",(LPRECT)&amp;rcClipRect); <br>         ContainerLine_UpdateInPlaceObjectRects( <br>               lpLastUIActiveLine, &amp;rcClipRect); <br>      } <br>   } <br>} <br> <br>/* ContainerDoc_IsUIDeactivateNeeded <br>** --------------------------------- <br>**    Check if it is necessary to UIDeactivate an in-place active <br>**    object upon a mouse LBUTTONDOWN event. The position of the button <br>**    down click is given by "pt". <br>**    If there is not currently an in-place active line, then <br>**    UIDeactivate is NOT needed. <br>**    If there is a current in-place active line, then check if the <br>**    point position is outside of the object extents on the screen. If <br>**    so, then the object should be UIDeactivated, otherwise not. <br>*/ <br>BOOL ContainerDoc_IsUIDeactivateNeeded( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      POINT           pt <br>) <br>{ <br>   LPCONTAINERLINE lpUIActiveLine=lpContainerDoc-&gt;m_lpLastUIActiveLine; <br>   RECT rect; <br> <br>   if (! lpUIActiveLine || ! lpUIActiveLine-&gt;m_fUIActive) <br>      return FALSE; <br> <br>   ContainerLine_GetPosRect( <br>         lpUIActiveLine, <br>         (LPRECT) &amp;rect <br>   ); <br> <br>   if (! PtInRect((LPRECT) &amp;rect, pt)) <br>      return TRUE; <br> <br>   return FALSE; <br>} <br> <br> <br>/* ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded <br>** ------------------------------------------------- <br>**    NOTE: this function ONLY applies for OUTSIDE-IN containers <br>** <br>**    If there is a previous in-place active server still running and <br>**    this server will not be needed to support the next OLE object <br>**    about to be activated, then shut it down. <br>**    in this way we manage a policy of having at most one in-place <br>**    server running at a time. we do not imediately shut down the <br>**    in-place server when the object is UIDeactivated because we want <br>**    it to be fast if the server decides to re-activate the object <br>**    in-place. <br>** <br>**    shutting down the server is achieved by forcing the object to <br>**    transition from running to loaded by calling IOleObject::Close. <br>*/ <br>void ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCONTAINERLINE         lpNextActiveLine <br>) <br>{ <br>   LPCONTAINERLINE lpLastIpActiveLine = lpContainerDoc-&gt;m_lpLastIpActiveLine; <br>   BOOL fEnableServerShutDown = TRUE; <br>   LPMONIKER lpmkLinkSrc; <br>   LPMONIKER lpmkLastActiveObj; <br>   LPMONIKER lpmkCommonPrefix; <br>   LPOLELINK lpOleLink; <br>   HRESULT hrErr; <br> <br>   /* NOTE: an inside-out style container can NOT use this scheme <br>   **    to shut down in-place servers. it would have to have a more <br>   **    sophistocated mechanism by which it keeps track of which <br>   **    objects are on screen and which were the last recently used. <br>   */ <br>   if (g_fInsideOutContainer) <br>      return; <br> <br> <br>   if (lpLastIpActiveLine != lpNextActiveLine) { <br>      if (lpLastIpActiveLine) { <br> <br>         /* NOTE: if the object which is about to be activated is <br>         **    actually a link to the OLE object in last activated line, <br>         **    then we do NOT want to shut down the last activated <br>         **    server because it is about to be used. when activating a <br>         **    linked object, the source of the link gets activated. <br>         */ <br>         lpOleLink = (LPOLELINK)ContainerLine_GetOleObject( <br>               lpNextActiveLine, <br>               &amp;IID_IOleLink <br>         ); <br>         if (lpOleLink) { <br>            OLEDBG_BEGIN2("IOleObject::GetSourceMoniker called\r\n") <br>            lpOleLink-&gt;lpVtbl-&gt;GetSourceMoniker( <br>                  lpOleLink, <br>                  (LPMONIKER FAR*)&amp;lpmkLinkSrc <br>            ); <br>            OLEDBG_END2 <br> <br>            if (lpmkLinkSrc) { <br>               lpmkLastActiveObj = ContainerLine_GetFullMoniker( <br>                     lpLastIpActiveLine, <br>                     GETMONIKER_ONLYIFTHERE <br>               ); <br>               if (lpmkLastActiveObj) { <br>                  hrErr = lpmkLinkSrc-&gt;lpVtbl-&gt;CommonPrefixWith( <br>                        lpmkLinkSrc, <br>                        lpmkLastActiveObj, <br>                        &amp;lpmkCommonPrefix <br> <br>                  ); <br>                  if (hrErr == MK_S_HIM || <br>                                hrErr == NOERROR || <br>                        hrErr == MK_S_US) { <br>                     /* the link source IS to the object <br>                     **    contained in the last activated <br>                     **    line of the document; disable the <br>                     **    attempt to shut down the last <br>                     **    running in-place server. <br>                     */ <br>                     fEnableServerShutDown = FALSE; <br>                  } <br>                  if (lpmkCommonPrefix) <br>                     OleStdRelease((LPUNKNOWN)lpmkCommonPrefix); <br>                  OleStdRelease((LPUNKNOWN)lpmkLastActiveObj); <br>               } <br>               OleStdRelease((LPUNKNOWN)lpmkLinkSrc); <br>            } <br>            OleStdRelease((LPUNKNOWN)lpOleLink); <br>         } <br> <br>         /* if it is OK to shut down the previous in-place server <br>         **    and one is still running, then shut it down. shutting <br>         **    down the server is accomplished by forcing the OLE <br>         **    object to close. this forces the object to transition <br>         **    from running to loaded. if the object is actually <br>         **    only loaded then this is a NOP. <br>         */ <br>         if (fEnableServerShutDown &amp;&amp; <br>               lpLastIpActiveLine-&gt;m_fIpServerRunning) { <br> <br>            OleDbgOut1("@@@ previous in-place server SHUT DOWN\r\n"); <br>            ContainerLine_CloseOleObject( <br>                  lpLastIpActiveLine, OLECLOSE_SAVEIFDIRTY); <br> <br>            // we can now forget this last in-place active line. <br>            lpContainerDoc-&gt;m_lpLastIpActiveLine = NULL; <br>         } <br>      } <br>   } <br>} <br> <br> <br>/* ContainerDoc_GetUIActiveWindow <br>** ------------------------------ <br>**    If there is an UIActive object, then return its HWND. <br>*/ <br>HWND ContainerDoc_GetUIActiveWindow(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   return lpContainerDoc-&gt;m_hWndUIActiveObj; <br>} <br> <br> <br>/* ContainerDoc_GetClipRect <br>** ------------------------ <br>**    Get the ClipRect in client coordinates. <br>** <br>** NOTE: the ClipRect is defined as the maximum window rectangle <br>**    that the in-place active object must be clipped to. this <br>**    rectangle MUST be described in Client Coordinates of the window <br>**    that is used as the Parent of the in-place active object's <br>**    window. in our case, the LineList ListBox window is both the <br>**    parent of the in-place active object AND defines precisely the <br>**    clipping rectangle. <br>*/ <br>void ContainerDoc_GetClipRect( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      LPRECT              lprcClipRect <br>) <br>{ <br>   /* NOTE: the ClipRect can be used to ensure that the in-place <br>   **    server does not overwrite areas of the window that the <br>   **    container paints into but which should never be overwritten <br>   **    (eg. if an app were to paint row and col headings directly in <br>   **    the same window that is the parent of the in-place window. <br>   **    whenever the window size changes or gets scrolled, in-place <br>   **    active object must be informed of the new clip rect. <br>   ** <br>   **    normally an app would pass the rect returned from GetClientRect. <br>   **    but because CntrOutl uses separate windows for row/column <br>   **    headings, status line, formula/tool bars, etc. it is NOT <br>   **    necessary to pass a constrained clip rect. Windows standard <br>   **    window clipping will automatically take care of all clipping <br>   **    that is necessary. thus we can take a short cut of passing an <br>   **    "infinite" clip rect, and then we do NOT need to call <br>   **    IOleInPlaceObject::SetObjectRects when our document is scrolled. <br>   */ <br> <br>   lprcClipRect-&gt;top = -32767; <br>   lprcClipRect-&gt;left = -32767; <br>   lprcClipRect-&gt;right = 32767; <br>   lprcClipRect-&gt;bottom = 32767; <br>} <br> <br> <br>/* ContainerDoc_GetTopInPlaceFrame <br>** ------------------------------- <br>**    returns NON-AddRef'ed pointer to Top In-Place Frame interface <br>*/ <br>LPOLEINPLACEFRAME ContainerDoc_GetTopInPlaceFrame( <br>      LPCONTAINERDOC      lpContainerDoc <br>) <br>{ <br>#if defined( INPLACE_CNTRSVR ) <br>   return lpContainerDoc-&gt;m_lpTopIPFrame; <br>#else <br>   return (LPOLEINPLACEFRAME)&amp;((LPCONTAINERAPP)g_lpApp)-&gt;m_OleInPlaceFrame; <br>#endif <br>} <br> <br>void ContainerDoc_GetSharedMenuHandles( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      HMENU FAR*      lphSharedMenu, <br>      HOLEMENU FAR*   lphOleMenu <br>) <br>{ <br>#if defined( INPLACE_CNTRSVR ) <br>   if (lpContainerDoc-&gt;m_DocType == DOCTYPE_EMEBEDDEDOBJECT) { <br>      *lphSharedMenu = lpContainerDoc-&gt;m_hSharedMenu; <br>      *lphOleMenu = lpContainerDoc-&gt;m_hOleMenu; <br>      return; <br>   } <br>#endif <br> <br>   *lphSharedMenu = NULL; <br>   *lphOleMenu = NULL; <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br>void ContainerDoc_RemoveFrameLevelTools(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   OleDbgAssert(lpOutlineDoc-&gt;m_lpFrameTools != NULL); <br> <br>   FrameTools_Enable(lpOutlineDoc-&gt;m_lpFrameTools, FALSE); <br>} <br>#endif <br> <br> <br>void ContainerDoc_AddFrameLevelUI(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPOLEINPLACEFRAME lpTopIPFrame = ContainerDoc_GetTopInPlaceFrame( <br>         lpContainerDoc); <br>   HMENU           hSharedMenu;            // combined obj/cntr menu <br>   HOLEMENU        hOleMenu;               // returned by OleCreateMenuDesc. <br> <br>   ContainerDoc_GetSharedMenuHandles( <br>         lpContainerDoc, <br>         &amp;hSharedMenu, <br>         &amp;hOleMenu <br>   ); <br> <br>   lpTopIPFrame-&gt;lpVtbl-&gt;SetMenu( <br>         lpTopIPFrame, <br>         hSharedMenu, <br>         hOleMenu, <br>         lpOutlineDoc-&gt;m_hWndDoc <br>   ); <br> <br>   /* NOTE: even if our app does NOT use FrameTools, we must still <br>   **    call IOleInPlaceFrame::SetBorderSpace. <br>   */ <br>   ContainerDoc_AddFrameLevelTools(lpContainerDoc); <br>} <br> <br> <br>void ContainerDoc_AddFrameLevelTools(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPOLEINPLACEFRAME lpTopIPFrame = ContainerDoc_GetTopInPlaceFrame( <br>         lpContainerDoc); <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br> <br> <br>   OleDbgAssert(lpTopIPFrame != NULL); <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>   FrameTools_Enable(lpOutlineDoc-&gt;m_lpFrameTools, TRUE); <br>   OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br> <br>   FrameTools_NegotiateForSpaceAndShow( <br>         lpOutlineDoc-&gt;m_lpFrameTools, <br>         NULL, <br>         lpTopIPFrame <br>   ); <br> <br>#else   // ! USE_FRAMETOOLS <br> <br>#if defined( INPLACE_CNTRSVR ) <br>   if (lpContainerDoc-&gt;m_DocType == DOCTYPE_EMBEDDEDOBJECT) { <br>      /* this says i do not need space, so the top Frame should <br>      **    leave its tools behind <br>      */ <br>      OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(NULL) called\r\n") <br>      lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace(lpTopIPFrame, NULL); <br>      OLEDBG_END2 <br>      return; <br>   } <br>#else   // INPLACE_CNTR &amp;&amp; ! USE_FRAMETOOLS <br> <br>   OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(0,0,0,0) called\r\n") <br>   lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace( <br>         lpTopIPFrame, <br>         (LPCBORDERWIDTHS)&amp;g_rectNull <br>   ); <br>   OLEDBG_END2 <br> <br>#endif  // INPLACE_CNTR &amp;&amp; ! USE_FRAMETOOLS <br>#endif  // ! USE_FRAMETOOLS <br> <br>} <br> <br> <br>void ContainerDoc_FrameWindowResized(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br> <br> <br>   if (lpContainerApp-&gt;m_lpIPActiveObj) { <br>      RECT rcFrameRect; <br> <br>      /* NOTE: this fMustResizeClientArea flag is used as part of <br>      **    our defensive programming for frame window resizing. when </code></pre>
<p>
</p>
<pre><code>**    the frame window is <br>      **    resized, IOleInPlaceActiveObject::ResizeBorder is called <br>      **    the object should normally call back to renegotiate <br>      **    for frame-level tools space. if SetBorderSpace is called <br>      **    then our client area windows are properly resized. <br>      **    CntrApp_IPFrame_SetBorderSpace clears this flag. if the <br>      **    in-place active object does NOT call SetBorderSpace, then <br>      **    the container must take care to resize its client area <br>      **    windows itself. <br>      */ <br>      lpContainerApp-&gt;m_fMustResizeClientArea = TRUE; <br> <br>      OutlineApp_GetFrameRect(g_lpApp, (LPRECT)&amp;rcFrameRect); <br> <br>      OLEDBG_BEGIN2("IOleInPlaceActiveObject::ResizeBorder called\r\n") <br>      lpContainerApp-&gt;m_lpIPActiveObj-&gt;lpVtbl-&gt;ResizeBorder( <br>            lpContainerApp-&gt;m_lpIPActiveObj, <br>            (LPCRECT)&amp;rcFrameRect, <br>            (LPOLEINPLACEUIWINDOW)&amp;lpContainerApp-&gt;m_OleInPlaceFrame, <br>            TRUE    /* fFrameWindow */ <br>      ); <br>      OLEDBG_END2 <br> <br>      /* the object did NOT call IOleInPlaceUIWindow::SetBorderSpace <br>      **    therefore we must resize our client area windows ourself. <br>      */ <br>      if (lpContainerApp-&gt;m_fMustResizeClientArea) { <br>         lpContainerApp-&gt;m_fMustResizeClientArea = FALSE; <br>         OutlineApp_ResizeClientArea(g_lpApp); <br>      } <br>   } <br> <br>#if defined( USE_FRAMETOOLS ) <br>   else { <br>      ContainerDoc_AddFrameLevelTools(lpContainerDoc); <br>   } <br>#endif <br>} <br> <br> <br>#if defined( INPLACE_CNTRSVR ) || defined( INPLACE_MDICNTR ) <br> <br>/* ContainerDoc_GetTopInPlaceDoc <br>**    returns NON-AddRef'ed pointer to Top In-Place Doc interface <br>*/ <br>LPOLEINPLACEUIWINDOW ContainerDoc_GetTopInPlaceDoc( <br>      LPCONTAINERDOC      lpContainerDoc <br>) <br>{ <br>#if defined( INPLACE_CNTRSVR ) <br>   return lpContainerDoc-&gt;m_lpTopIPDoc; <br>#else <br>   return (LPOLEINPLACEUIWINDOW)&amp;lpContainerDoc-&gt;m_OleInPlaceDoc; <br>#endif <br>} <br> <br> <br>void ContainerDoc_RemoveDocLevelTools(LPCONTAINERDOC lpContainerDoc); <br>{ <br>   LPOLEINPLACEUIWINDOW lpTopIPDoc = ContainerDoc_GetTopInPlaceDoc( <br>         lpContainerDoc); <br> <br>   if (lpTopIPDoc &amp;&amp; lpContainerDoc-&gt;m_fMyToolsOnDoc) { <br>      lpContainerDoc-&gt;m_fMyToolsOnDoc = FALSE; <br> <br>      // if we had doc tools we would HIDE them here; <br>      //   but NOT call SetBorderSpace(NULL) <br> <br>   } <br>} <br> <br>void ContainerDoc_AddDocLevelTools(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPOLEINPLACEUIWINDOW lpTopIPDoc = ContainerDoc_GetTopInPlaceDoc( <br>         lpContainerDoc); <br> <br>   if (! lpTopIPDoc) <br>      return; <br> <br> <br>#if defined( USE_DOCTOOLS ) <br>   if (lpTopIPDoc &amp;&amp; ! lpContainerDoc-&gt;m_fMyToolsOnDoc) { <br> <br>      /* if we had doc tools we would negotiate for toolbar space at <br>      **    doc level and SHOW them. <br>      */ <br> <br>      /* we do NOT have doc level tools, so we just call <br>      **    SetBorderSpace() to indicate to the top doc that <br>      **    our object does not need tool space. <br>      */ <br> <br>      lpContainerDoc-&gt;m_fMyToolsOnDoc = TRUE; <br>      return; <br>   } <br>#else   // ! USE_DOCTOOLS <br> <br>#if defined( INPLACE_CNTRSVR ) <br>   if (lpContainerDoc-&gt;m_DocType == DOCTYPE_EMBEDDEDOBJECT) { <br>      /* this says i do not need space, so the top doc should <br>      **    leave its tools behind <br>      */ <br>      lpTopIPDoc-&gt;lpVtbl-&gt;SetBorderSpace(lpTopIPDoc, NULL); <br>      return; <br>   } <br>#else <br>   lpTopIPDoc-&gt;lpVtbl-&gt;SetBorderSpace( <br>         lpTopIPDoc, <br>         (LPCBORDERWIDTHS)&amp;g_rectNull <br>   ); <br> <br>#endif <br>#endif  // ! USE_DOCTOOLS <br>} <br> <br>#endif  // INPLACE_CNTRSVR || INPLACE_MDICNTR <br> <br> <br>/* ContainerDoc_ContextSensitiveHelp <br>** --------------------------------- <br>**    forward the ContextSensitiveHelp mode on to any in-place objects <br>**    that currently have their window visible. this informs the <br>**    objects whether to give help or take action on subsequent mouse <br>**    clicks and menu commands. this function is called from our <br>**    IOleInPlaceSite::ContextSensitiveHelp implementation. <br>** <br>** NOTE: see context sensitive help technote (CSHELP.DOC). <br>**    This function is called when SHIFT-F1 context sensitive help is <br>**    entered. the cursor should then change to a question mark <br>**    cursor and the app should enter a modal state where the next <br>**    mouse click does not perform its normal action but rather <br>**    gives help corresponding to the location clicked. if the app <br>**    does not implement a help system, it should at least eat the <br>**    click and do nothing. <br>*/ <br>void ContainerDoc_ContextSensitiveHelp( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      BOOL            fEnterMode, <br>      BOOL            fInitiatedByObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int i; <br>   LPLINE lpLine; <br> <br>   lpOleDoc-&gt;m_fCSHelpMode = fEnterMode; <br> <br>   if (g_fInsideOutContainer) { <br> <br>      if (lpContainerDoc-&gt;m_cIPActiveObjects) { <br>         for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>            lpLine=LineList_GetLine(lpLL, i); <br> <br>            if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>               LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br>               ContainerLine_ContextSensitiveHelp( <br>                     lpContainerLine, fEnterMode); <br>            } <br>         } <br>      } <br>   } <br>   else if (! fInitiatedByObj) { <br>      /* NOTE: (OUTSIDE-IN CONTAINER) if there is a currently <br>      **    UIActive object (ie. its window is visible), we must <br>      **    forward the ContextSensitiveHelp mode on to the <br>      **    object--assuming it was not the object that initiated the <br>      **    context sensitve help mode. <br>      */ <br>      LPCONTAINERLINE lpLastUIActiveLine = <br>            lpContainerDoc-&gt;m_lpLastUIActiveLine; <br>      if (lpLastUIActiveLine &amp;&amp; lpLastUIActiveLine-&gt;m_fUIActive) { <br>         ContainerLine_ContextSensitiveHelp(lpLastUIActiveLine,fEnterMode); <br>      } <br>   } <br>} <br> <br>/* ContainerDoc_ForwardPaletteChangedMsg <br>** ------------------------------------- <br>**    forward the WM_PALETTECHANGED message (via SendMessage) to any <br>**    in-place objects that currently have their window visible. this <br>**    gives these objects the chance to select their palette as a <br>**    BACKGROUND palette. <br>** <br>**    SEE THE TECHNOTE FOR DETAILED INFORMATION ON PALETTE COORDINATION <br>** <br>**    NOTE: For containers and objects to manage palettes properly <br>**    (when objects are getting inplace edited) they should follow a <br>**    set of rules. <br>** <br>**    Rule 1: The Container can decide if it wants to own the palette or <br>**    it wants to allow its UIActive object to own the palette. <br>**    a) If the container wants to let its UIActive object own the <br>**    palette then it should forward WM_QUERYNEWPALETTE to the object <br>**    when it is received to the top frame window. also it should send <br>**    WM_QUERYNEWPALETTE to the object in its <br>**    IOleInPlaceFrame::SetActiveObject implementation. if the object <br>**    is given ownership of the palette, then it owns the palette until <br>**    it is UIDeactivated. <br>**    b) If the container wants to own the palette it should NOT send <br>**    WM_QUERYNEWPALETTE to the UIActive object. <br>** <br>**    Rule 2: Whether the container wants to own the palette or not, it <br>**    should forward the WM_PALETTECHANGED to the immediate child <br>**    inplace active objects in its documents. if it is an inside-out <br>**    style container then it must forward it to ALL objects that <br>**    currently have their windows visible. When the object recives the <br>**    WM_PALETTECHANGED message it must select its color palette as the <br>**    background palette. When the objects are in loaded state they will be <br>**    drawn by (OLE) by selecting their palettes as background palettes <br>**    anyway. <br>** <br>**    Note: IOleObject::SetColorScheme is not related to the palette <br>**    issue. <br>*/ <br>void ContainerDoc_ForwardPaletteChangedMsg( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      HWND            hwndPalChg <br>) <br>{ <br>   LPLINELIST lpLL; <br>   int i; <br>   LPLINE lpLine; <br> <br>   if (!lpContainerDoc) <br>      return; <br> <br>   lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   if (g_fInsideOutContainer) { <br> <br>      if (lpContainerDoc-&gt;m_cIPActiveObjects) { <br>         for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>            lpLine=LineList_GetLine(lpLL, i); <br> <br>            if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>               LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br>               ContainerLine_ForwardPaletteChangedMsg( <br>                     lpContainerLine, hwndPalChg); <br>            } <br>         } <br>      } <br>   } <br>   else { <br>      /* NOTE: (OUTSIDE-IN CONTAINER) if there is a currently <br>      **    UIActive object (ie. its window is visible), we must <br>      **    forward it the WM_PALETTECHANGED message. <br>      */ <br>      LPCONTAINERLINE lpLastUIActiveLine = <br>            lpContainerDoc-&gt;m_lpLastUIActiveLine; <br>      if (lpLastUIActiveLine &amp;&amp; lpLastUIActiveLine-&gt;m_fUIActive) { <br>         ContainerLine_ForwardPaletteChangedMsg( <br>               lpLastUIActiveLine, hwndPalChg); <br>      } <br>   } <br>} <br> <br> <br>/************************************************************************* <br>** ContainerLine Support Functions and Interfaces <br>*************************************************************************/ <br> <br> <br>/* ContainerLine_UIDeactivate <br>** -------------------------- <br>**    tell the OLE object associated with the ContainerLine to <br>**    UIDeactivate. this informs the in-place server to tear down <br>**    the UI and window that it put up for the object. it will remove <br>**    its active editor menus and any frame and object adornments <br>**    (eg. toolbars, rulers, etc.). <br>*/ <br>void ContainerLine_UIDeactivate(LPCONTAINERLINE lpContainerLine) <br>{ <br>   HRESULT hrErr; <br> <br>   if (!lpContainerLine || !lpContainerLine-&gt;m_fUIActive) <br>      return; <br> <br>   OLEDBG_BEGIN2("IOleInPlaceObject::UIDeactivate called\r\n") <br>   hrErr = lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;UIDeactivate( <br>         lpContainerLine-&gt;m_lpOleIPObj); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleInPlaceObject::UIDeactivate returned", hrErr); <br>   } <br>} <br> <br> <br> <br>/* ContainerLine_UpdateInPlaceObjectRects <br>** ------------------------------------- <br>**    Update the PosRect and ClipRect of the given line <br>**    currently in-place active <br>**    object. if there is no object active in-place, then do nothing. <br>** <br>**    NOTE: this function should be called when an action occurs <br>**    that changes either the position of the object in the document <br>**    (eg. changing document margins changes PosRect) or the clipRect <br>**    changes (eg. resizing the document window changes the ClipRect). <br>*/ <br>void ContainerLine_UpdateInPlaceObjectRects( <br>      LPCONTAINERLINE lpContainerLine, <br>      LPRECT          lprcClipRect <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = lpContainerLine-&gt;m_lpDoc; <br>   RECT rcClipRect; <br>   RECT rcPosRect; <br> <br>   if (! lpContainerLine-&gt;m_fIpVisible) <br>      return; <br> <br>   if (! lprcClipRect) { <br>      ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&amp;rcClipRect); <br>      lprcClipRect = (LPRECT)&amp;rcClipRect; <br>   } <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRect3( <br>         "ContainerLine_UpdateInPlaceObjectRects (ClipRect)", <br>         (LPRECT)&amp;rcClipRect <br>   ); <br>#endif <br>   ContainerLine_GetPosRect(lpContainerLine,(LPRECT)&amp;rcPosRect); <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRect3( <br>      "ContainerLine_UpdateInPlaceObjectRects (PosRect)",(LPRECT)&amp;rcPosRect); <br>#endif <br> <br>   OLEDBG_BEGIN2("IOleInPlaceObject::SetObjectRects called\r\n") <br>   lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;SetObjectRects( <br>         lpContainerLine-&gt;m_lpOleIPObj, <br>         (LPRECT)&amp;rcPosRect, <br>         lprcClipRect <br>   ); <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ContainerLine_ContextSensitveHelp <br>** --------------------------------- <br>**    forward the ContextSensitiveHelp mode on to the in-place object <br>**    if it currently has its window visible. this informs the <br>**    object whether to give help or take action on subsequent mouse <br>**    clicks and menu commands. <br>** <br>**    this function is called from ContainerDoc_ContextSensitiveHelp <br>**    function as a result of a call to <br>**    IOleInPlaceSite::ContextSensitiveHelp if the in-place container <br>**    is operating as an in-side out container. <br>*/ <br>void ContainerLine_ContextSensitiveHelp( <br>      LPCONTAINERLINE lpContainerLine, <br>      BOOL            fEnterMode <br>) <br>{ <br>   if (! lpContainerLine-&gt;m_fIpVisible) <br>      return; <br> <br>   OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp called\r\n") <br>   lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;ContextSensitiveHelp( <br>         lpContainerLine-&gt;m_lpOleIPObj, fEnterMode); <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ContainerLine_ForwardPaletteChangedMsg <br>** -------------------------------------- <br>**    forward it the WM_PALETTECHANGED message (via SendMessage) to the <br>**    in-place object if it currently has its window visible. this <br>**    gives the object the chance to select its palette as a BACKGROUND <br>**    palette if it doesn't own the palette--or as the <br>**    foreground palette if it currently DOES own the palette. <br>** <br>**    SEE THE TECHNOTE FOR DETAILED INFORMATION ON PALETTE COORDINATION <br>*/ <br>void ContainerLine_ForwardPaletteChangedMsg( <br>      LPCONTAINERLINE lpContainerLine, <br>      HWND             hwndPalChg <br>) <br>{ <br>   if (! lpContainerLine-&gt;m_fIpVisible) <br>      return; <br> <br>   if (lpContainerLine-&gt;m_hWndIpObject) <br>   { <br>       SendMessage( <br>             lpContainerLine-&gt;m_hWndIpObject, <br>             WM_PALETTECHANGED, <br>             (WPARAM)hwndPalChg, <br>             0L <br>       ); <br>   } <br>} <br> <br> <br> <br>/************************************************************************* <br>** ContainerLine::IOleInPlaceSite interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP CntrLine_IPSite_QueryInterface( <br>      LPOLEINPLACESITE    lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CntrLine_IPSite_AddRef(LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleInPlaceSite"); <br> <br>   return ContainerLine_AddRef(lpContainerLine); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CntrLine_IPSite_Release(LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleInPlaceSite"); <br> <br>   return ContainerLine_Release(lpContainerLine); <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_GetWindow( <br>   LPOLEINPLACESITE    lpThis, <br>   HWND FAR*           lphwnd <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OleDbgOut2("CntrLine_IPSite_GetWindow\r\n"); <br> <br>   *lphwnd = LineList_GetWindow( <br>         &amp;((LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc)-&gt;m_LineList); <br> <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br>// IOleInPlaceSite::ContextSensitiveHelp <br>STDMETHODIMP CntrLine_IPSite_ContextSensitiveHelp( <br>   LPOLEINPLACESITE    lpThis, <br>   BOOL                fEnterMode <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerLine-&gt;m_lpDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OleDbgOut2("CntrLine_IPSite_ContextSensitiveHelp\r\n"); <br> <br>   /* NOTE: see context sensitive help technote (CSHELP.DOC). <br>   **    This method is called when SHIFT-F1 context sensitive help is <br>   **    entered. the cursor should then change to a question mark <br>   **    cursor and the app should enter a modal state where the next <br>   **    mouse click does not perform its normal action but rather <br>   **    gives help corresponding to the location clicked. if the app <br>   **    does not implement a help system, it should at least eat the <br>   **    click and do nothing. <br>   ** <br>   **    NOTE: the implementation here is specific to an SDI simple <br>   **    container. an MDI container or container/server application <br>   **    would have additional work to do (see the technote). <br>   ** <br>   **    NOTE: (INSIDE-OUT CONTAINER) if there are currently <br>   **    any in-place objects active with their windows visible <br>   **    (ie. fIpVisible), we must forward the <br>   **    ContextSensitiveHelp mode on to these objects. <br>   */ <br>   ContainerDoc_ContextSensitiveHelp( <br>            lpContainerLine-&gt;m_lpDoc,fEnterMode,TRUE /*InitiatedByObj*/); <br> <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_CanInPlaceActivate(LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   OleDbgOut2("CntrLine_IPSite_CanInPlaceActivate\r\n"); <br> <br>   /* NOTE: the container can NOT allow in-place activation if it <br>   **    is currently displaying the object as an ICON <br>   **    (DVASPECT_ICON). it can ONLY do in-place activation if it is <br>   **    displaying the DVASPECT_CONTENT of the OLE object. <br>   */ <br>   if (lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_CONTENT) <br>      return NOERROR; <br>   else <br>      return S_FALSE; <br>} <br> <br>STDMETHODIMP CntrLine_IPSite_OnInPlaceActivate(LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPCONTAINERDOC lpContainerDoc = lpContainerLine-&gt;m_lpDoc; <br>   SCODE sc = S_OK; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br>   OLEDBG_BEGIN2("CntrLine_IPSite_OnInPlaceActivate\r\n"); <br> <br>   /* NOTE: (OUTSIDE-IN CONTAINER) as a policy for managing <br>   **    running in-place servers, we will keep only 1 inplace server <br>   **    active at any given time. so when we start to inp-place activate <br>   **    another line, then we want to shut down the previously <br>   **    activated server. in this way we keep at most one inplace <br>   **    server active at a time. this is NOT a required policy. apps <br>   **    may choose to have a more sophisticated strategy. inside-out <br>   **    containers will HAVE to have a more sophisticated strategy, <br>   **    because they need (at a minimum) to keep all visible object <br>   **    servers running. <br>   ** <br>   **    if the in-place activation is the result of activating a <br>   **    linked object in another container, then we may arrive at <br>   **    this method while another object is currently active. <br>   **    normally, if the object is in-place activated by <br>   **    double-clicking or Edit.&lt;verb&gt; from our own container, then <br>   **    the previous in-place object would have been de-activated in <br>   **    ContainerLine_DoVerb method. <br>   */ <br>   if (!g_fInsideOutContainer) { <br>      if (lpContainerDoc-&gt;m_lpLastIpActiveLine) { <br>         ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded( <br>               lpContainerDoc, lpContainerLine); <br>      } <br>      lpContainerDoc-&gt;m_lpLastIpActiveLine = lpContainerLine; <br>   } <br> <br>   /* NOTE: to avoid LRPC problems it is important to cache the <br>   **    IOleInPlaceObject* pointer and NOT to call QueryInterface <br>   **    each time it is needed. <br>   */ <br>   lpContainerLine-&gt;m_lpOleIPObj = (LPOLEINPLACEOBJECT) <br>         ContainerLine_GetOleObject(lpContainerLine,&amp;IID_IOleInPlaceObject); <br> <br>   if (! lpContainerLine-&gt;m_lpOleIPObj) { <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz( <br>            lpContainerLine-&gt;m_lpOleIPObj!=NULL, <br>            "OLE object must support IOleInPlaceObject" <br>      ); <br>#endif <br>      // release artificial AddRef <br>      CntrLine_IPSite_Release(lpThis); <br>      return E_FAIL; // ERROR: refuse to in-place activate <br>   } <br> <br>   lpContainerLine-&gt;m_fIpActive        = TRUE; <br>   lpContainerLine-&gt;m_fIpVisible       = TRUE; <br> <br>   OLEDBG_BEGIN2("IOleInPlaceObject::GetWindow called\r\n") <br>   lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;GetWindow( <br>         lpContainerLine-&gt;m_lpOleIPObj, <br>         (HWND FAR*)&amp;lpContainerLine-&gt;m_hWndIpObject <br>   ); <br>   OLEDBG_END2 <br> <br>   if (! lpContainerLine-&gt;m_fIpServerRunning) { <br>      /* NOTE: it is VERY important that an in-place container <br>      **    that also support linking to embeddings properly manage <br>      **    the running of its in-place objects. in an outside-in <br>      **    style in-place container, when the user clicks <br>      **    outside of the in-place active object, the object gets <br>      **    UIDeactivated and the object hides its window. in order <br>      **    to make the object fast to reactivate, the container <br>      **    deliberately does not call IOleObject::Close. the object <br>      **    stays running in the invisible unlocked state. the idea <br>      **    here is if the user simply clicks outside of the object <br>      **    and then wants to double click again to re-activate the <br>      **    object, we do not want this to be slow. if we want to <br>      **    keep the object running, however, we MUST Lock it <br>      **    running. otherwise the object will be in an unstable <br>      **    state where if a linking client does a "silent-update" <br>      **    (eg. UpdateNow from the Links dialog), then the in-place <br>      **    server will shut down even before the object has a chance <br>      **    to be saved back in its container. this saving normally <br>      **    occurs when the in-place container closes the object. also <br>      **    keeping the object in the unstable, hidden, running, <br>      **    not-locked state can cause problems in some scenarios. <br>      **    ICntrOtl keeps only one object running. if the user <br>      **    intiates a DoVerb on another object, then that last <br>      **    running in-place active object is closed. a more <br>      **    sophistocated in-place container may keep more object running. <br>      **    this lock gets unlocked in ContainerLine_CloseOleObject. <br>      */ <br>      lpContainerLine-&gt;m_fIpServerRunning = TRUE; <br> <br>      OLEDBG_BEGIN2("OleLockRunning(TRUE, 0) called\r\n") <br>      OleLockRunning((LPUNKNOWN)lpContainerLine-&gt;m_lpOleIPObj, TRUE, 0); <br>      OLEDBG_END2 <br>   } <br> <br>   lpContainerLine-&gt;m_lpDoc-&gt;m_cIPActiveObjects++; <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_OnUIActivate (LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPCONTAINERDOC lpContainerDoc = lpContainerLine-&gt;m_lpDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPCONTAINERLINE lpLastUIActiveLine = lpContainerDoc-&gt;m_lpLastUIActiveLine; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_IPSite_OnUIActivate\r\n"); <br> <br>   lpContainerLine-&gt;m_fUIActive        = TRUE; <br>   lpContainerDoc-&gt;m_fAddMyUI          = FALSE; <br>   lpContainerDoc-&gt;m_lpLastUIActiveLine = lpContainerLine; <br> <br>   if (g_fInsideOutContainer) { <br>      /* NOTE: (INSIDE-OUT CONTAINER) an inside-out style <br>      **    container must UIDeactivate the previous UIActive object <br>      **    when a new object is going UIActive. since the inside-out <br>      **    objects have their own windows visible, it is possible <br>      **    that a click directly in an another server window will <br>      **    cause it to UIActivate. OnUIActivate is the containers <br>      **    notification that such has occured. it must then <br>      **    UIDeactivate the other because at most one object can be <br>      **    UIActive at a time. <br>      */ <br>      if (lpLastUIActiveLine &amp;&amp; (lpLastUIActiveLine!=lpContainerLine)) { <br>         ContainerLine_UIDeactivate(lpLastUIActiveLine); <br> <br>         // Make sure new UIActive window is on top of all others <br>         SetWindowPos( <br>               lpContainerLine-&gt;m_hWndIpObject, <br>               HWND_TOPMOST, <br>               0,0,0,0, <br>               SWP_NOMOVE | SWP_NOSIZE <br>         ); <br> <br>         OLEDBG_END2 <br>         goto cleanup; <br>      } <br>   } <br> <br>   lpContainerDoc-&gt;m_hWndUIActiveObj = lpContainerLine-&gt;m_hWndIpObject; <br> <br>#if defined( USE_FRAMETOOLS ) <br>   ContainerDoc_RemoveFrameLevelTools(lpContainerDoc); <br>#endif <br> <br>#if defined( USE_DOCTOOLS ) <br>   ContainerDoc_RemoveDocLevelTools(lpContainerDoc); <br>#endif <br> <br>   OLEDBG_END2 <br>cleanup: <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_GetWindowContext( <br>   LPOLEINPLACESITE            lpThis, <br>   LPOLEINPLACEFRAME FAR*      lplpFrame, <br>   LPOLEINPLACEUIWINDOW FAR*   lplpDoc, <br>   LPRECT                      lprcPosRect, <br>   LPRECT                      lprcClipRect, <br>   LPOLEINPLACEFRAMEINFO       lpFrameInfo <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_IPSite_GetWindowContext\r\n") <br> <br>   /* NOTE: The server should fill in the "cb" field so that the <br>   **    container can tell what size structure the server is <br>   **    expecting. this enables this structure to be easily extended <br>   **    in future releases of OLE. the container should check this <br>   **    field so that it doesn't try to use fields that do not exist <br>   **    since the server may be using an old structure definition. <br>   **    Since this is the first release of OLE2.0, the structure is <br>   **    guaranteed to be at least large enough for the current <br>   **    definition of OLEINPLACEFRAMEINFO struct. thus we do NOT need <br>   **    to consider this an error if the server did not fill in this <br>   **    field correctly. this server may have trouble in the future, <br>   **    however, when the structure is extended. <br>   */ <br>   *lplpFrame = (LPOLEINPLACEFRAME)&amp;lpContainerApp-&gt;m_OleInPlaceFrame; <br>   (*lplpFrame)-&gt;lpVtbl-&gt;AddRef(*lplpFrame);   // must return AddRef'ed ptr <br> <br>   // NOTE: an MDI app would have to provide *lplpDoc <br>   *lplpDoc  = NULL; <br> <br>   ContainerLine_GetPosRect(lpContainerLine, lprcPosRect); <br>   ContainerDoc_GetClipRect(lpContainerLine-&gt;m_lpDoc, lprcClipRect); <br> <br>   OleDbgOutRect3("CntrLine_IPSite_GetWindowContext (PosRect)", lprcPosRect); <br>   OleDbgOutRect3("CntrLine_IPSite_GetWindowContext (ClipRect)",lprcClipRect); <br>   lpFrameInfo-&gt;hwndFrame      = lpOutlineApp-&gt;m_hWndApp; <br> <br>#if defined( MDI_VERSION ) <br>   lpFrameInfo-&gt;fMDIApp        = TRUE; <br>#else <br>   lpFrameInfo-&gt;fMDIApp        = FALSE; <br>#endif <br> <br>   lpFrameInfo-&gt;haccel         = lpContainerApp-&gt;m_hAccelIPCntr; <br>   lpFrameInfo-&gt;cAccelEntries  = <br>      GetAccelItemCount(lpContainerApp-&gt;m_hAccelIPCntr); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_Scroll( <br>   LPOLEINPLACESITE    lpThis, <br>   SIZE                scrollExtent <br>) <br>{ <br>   OleDbgOut2("CntrLine_IPSite_Scroll\r\n"); <br>   return E_FAIL; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_OnUIDeactivate( <br>   LPOLEINPLACESITE    lpThis, <br>   BOOL                fUndoable <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP) g_lpApp; <br>   LPLINELIST lpLL; <br>   int nIndex; <br>   MSG msg; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_IPSite_OnUIDeactivate\r\n") <br> <br>   lpContainerLine-&gt;m_fUIActive = FALSE; <br>   lpContainerLine-&gt;m_fIpChangesUndoable = fUndoable; <br>   lpContainerLine-&gt;m_lpDoc-&gt;m_hWndUIActiveObj = NULL; <br> <br>   if (lpContainerLine == lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastUIActiveLine) { <br> <br>      lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastUIActiveLine = NULL; <br> <br>      /* NOTE: here we look ahead if there is a DBLCLK sitting in our <br>      **    message queue. if so, it could result in in-place activating <br>      **    another object. we want to avoid placing our tools and <br>      **    repainting if immediately another object is going to do the <br>      **    same. SO, if there is a DBLCLK in the queue for this document <br>      **    we will only set the fAddMyUI flag to indicate that this work <br>      **    is still to be done. if another object actually in-place <br>      **    activates then this flag will be cleared in <br>      **    IOleInPlaceSite::OnUIActivate. if it does NOT get cleared, <br>      **    then at the end of processing the DBLCLK message in our <br>      **    OutlineDocWndProc we will put our tools back. <br>      */ <br>      if (! PeekMessage(&amp;msg, lpOutlineDoc-&gt;m_hWndDoc, <br>            WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK, <br>            PM_NOREMOVE | PM_NOYIELD)) { <br> <br>         /* NOTE: You need to generate QueryNewPalette only if <br>         **    you own the top level frame (ie. you are a top-level <br>         **    inplace container). <br>         */ <br> <br>         OleApp_QueryNewPalette((LPOLEAPP)g_lpApp); </code></pre>
<p>
</p>
<pre><code><br>#if defined( USE_DOCTOOLS ) <br>         ContainerDoc_AddDocLevelTools(lpContainerLine-&gt;m_lpDoc); <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>         ContainerDoc_AddFrameLevelUI(lpContainerLine-&gt;m_lpDoc); <br>#endif <br>      } else { <br>         lpContainerLine-&gt;m_lpDoc-&gt;m_fAddMyUI = TRUE; <br>      } <br> <br>      /* NOTE: we should re-take focus. the in-place server window <br>      **    previously had the focus; this window has just been removed. <br>      */ <br>      SetFocus(OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc)); <br> <br>      // force the line to redraw to remove in-place active hatch <br>      lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>      nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br>      LineList_ForceLineRedraw(lpLL, nIndex, TRUE); <br>   } <br> <br>#if defined( UNDOSUPPORTED ) <br> <br>   /* NOTE: an outside-in style container that supports UNDO would <br>   **    call IOleObject::DoVerb(OLEIVERB_HIDE) to make the in-place <br>   **    object go invisible. when it wants the in-place active object <br>   **    to discard its undo state, it would call <br>   **    IOleInPlaceObject::InPlaceDeactivate when it wants the object <br>   **    to discard its undo state. there is no need for an outside-in <br>   **    style container to call <br>   **    IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE). if either the <br>   **    container or the object do not support UNDO, then the <br>   **    container might as well immediately call InPlaceDeactivate <br>   **    instead of calling DoVerb(HIDE). <br>   ** <br>   **    an inside-out style container that supports UNDO would simply <br>   **    UIDeactivate the object. it would call <br>   **    IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE) when it wants <br>   **    the object discard its undo state. it would call <br>   **    IOleInPlaceObject::InPlaceDeactivate if it wants the object <br>   **    to take down its window. <br>   */ <br>   if (! g_fInsideOutContainer || !lpContainerLine-&gt;m_fInsideOutObj) { <br> <br>      if (lpContainerLine-&gt;m_fIpChangesUndoable) { <br>         ContainerLine_DoVerb( <br>               lpContainerLine,OLEIVERB_HIDE,NULL,FALSE,FALSE); <br>      } else { <br>         lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;InPlaceDeactivate( <br>               lpContainerLine-&gt;m_lpOleIPObj); <br>      } <br>      lpContainerLine-&gt;m_fIpVisible = FALSE; <br>      lpContainerLine-&gt;m_hWndIpObject = NULL; <br>   } <br>#else <br> <br>   /* NOTE: an outside-in style container that does NOT support <br>   **    UNDO would immediately tell the UIDeactivated server (UI <br>   **    removed) to IOleInPlaceObject::InPlaceDeactivate. <br>   ** <br>   **    an inside-out style container that does NOT support UNDO <br>   **    would call IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE) to <br>   **    tell the object to discard its undo state. it would call <br>   **    IOleInPlaceObject::InPlaceDeactivate if it wants the object <br>   **    to take down its window. <br>   */ <br> <br>   if (g_fInsideOutContainer) { <br> <br>      if (lpContainerLine-&gt;m_fInsideOutObj) { <br> <br>         if (lpContainerLine-&gt;m_fIpChangesUndoable) { <br>            OLEDBG_BEGIN3("ContainerLine_DoVerb(OLEIVERB_DISCARDUNDOSTATE) called!\r\n") <br>            ContainerLine_DoVerb(lpContainerLine, <br>                  OLEIVERB_DISCARDUNDOSTATE,NULL,FALSE,FALSE); <br>            OLEDBG_END3 <br>         } <br> <br>      } else {    // !fInsideOutObj <br> <br>         /* NOTE: (INSIDEOUT CONTAINER) if the object is not <br>         **    registered OLEMISC_ACTIVATEWHENVISIBLE, then we will <br>         **    make the object behave in an outside-in manner. since <br>         **    we do NOT deal with UNDO we can simply <br>         **    InPlaceDeactivate the object. it should NOT be <br>         **    allowed to leave its window visible when <br>         **    UIDeactivated. <br>         */ <br>         OLEDBG_BEGIN2("IOleInPlaceObject::InPlaceDeactivate called\r\n") <br>         hrErr = lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;InPlaceDeactivate( <br>                  lpContainerLine-&gt;m_lpOleIPObj); <br>         OLEDBG_END2 <br>         if (hrErr != NOERROR) { <br>            OleDbgOutHResult("IOleInPlaceObject::InPlaceDeactivate returned", hrErr); <br>         } <br>      } <br> <br>   } else { <br> <br>      /* NOTE: (OUTSIDE-IN CONTAINER) since we do NOT deal with <br>      **    UNDO we can simply InPlaceDeactivate the object. it <br>      **    should NOT be allowed to leave its window visible when <br>      **    UIDeactivated. <br>        ** <br>        **    NOTE: In-place servers must handle InPlaceDeactivate <br>        **    being called before its call to <br>        **    IOleInPlaceSite::OnUIDeactivate returns. in case there <br>        **    are misbehaving servers out there, one way to work around <br>        **    this problem is to call <br>        **    IOleObject::DoVerb(OLEIVERB_HIDE...) here. <br>      */ <br>      OLEDBG_BEGIN2("IOleInPlaceObject::InPlaceDeactivate called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;InPlaceDeactivate( <br>            lpContainerLine-&gt;m_lpOleIPObj); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("IOleInPlaceObject::InPlaceDeactivate returned", hrErr); <br>      } <br>   } <br> <br>#endif // ! UNDOSUPPORTED <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_OnInPlaceDeactivate(LPOLEINPLACESITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br>   OLEDBG_BEGIN2("CntrLine_IPSite_OnInPlaceDeactivate\r\n"); <br> <br>   lpContainerLine-&gt;m_fIpActive            = FALSE; <br>   lpContainerLine-&gt;m_fIpVisible           = FALSE; <br>   lpContainerLine-&gt;m_fIpChangesUndoable   = FALSE; <br>   lpContainerLine-&gt;m_hWndIpObject         = NULL; <br> <br>   OleStdRelease((LPUNKNOWN) lpContainerLine-&gt;m_lpOleIPObj); <br>   lpContainerLine-&gt;m_lpOleIPObj = NULL; <br>   lpContainerLine-&gt;m_lpDoc-&gt;m_cIPActiveObjects--; <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_DiscardUndoState(LPOLEINPLACESITE lpThis) <br>{ <br>   OleDbgOut2("CntrLine_IPSite_DiscardUndoState\r\n"); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_DeactivateAndUndo(LPOLEINPLACESITE lpThis) <br>{ <br>   OleDbgOut2("CntrLine_IPSite_DeactivateAndUndo\r\n"); <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP CntrLine_IPSite_OnPosRectChange( <br>   LPOLEINPLACESITE    lpThis, <br>   LPCRECT             lprcPosRect <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleInPlaceSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPSCALEFACTOR lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc); <br>   LPLINE lpLine = (LPLINE)lpContainerLine; <br>   LPLINELIST lpLL; <br>   int nIndex; <br>   RECT rcClipRect; <br>   RECT rcNewPosRect; <br>   SIZEL sizelPix; <br>   SIZEL sizelHim; <br>   int nIPObjHeight = lprcPosRect-&gt;bottom - lprcPosRect-&gt;top; <br>   int nIPObjWidth = lprcPosRect-&gt;right - lprcPosRect-&gt;left; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_IPSite_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_IPSite_OnPosRectChange\r\n") <br>   OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (PosRect --IN)", (LPRECT)lprcPosRect); <br> <br>   /* NOTE: if the in-place container does NOT impose any <br>   **    size contraints on its in-place active objects, then it may <br>   **    simply grant the size requested by the object by immediately <br>   **    calling IOleInPlaceObject::SetObjectRects with the <br>   **    lprcPosRect passed by the in-place object. <br>   ** <br>   **    Container Outline, however, imposes a size constraint on its <br>   **    embedded objects (see comment in ContainerLine_UpdateExtent), <br>   **    thus it is necessary to calculate the size that the in-place <br>   **    active object is allowed to be. <br>   ** <br>   **    Here we need to know the new extents of the in-place object. <br>   **    We can NOT directly ask the object via IOleObject::GetExtent <br>   **    because this method will retreive the extents of the last <br>   **    cached metafile. the cache has not yet been updated by this <br>   **    point. We can not reliably call IOleObject::GetExtent <br>   **    because, despite the fact that will be delegated to the <br>   **    object properly, some objects may not have reformated their <br>   **    object and computed the new extents at the time of calling <br>   **    OnPosRectChange. <br>   ** <br>   **    the best we can do to get the new extents of the object is <br>   **    to determine the scale factor that the object was operating at <br>   **    prior to the OnPosRect call and scale the new lprcPosRect <br>   **    using this scale factor back to HIMETRIC units. <br>   */ <br>   if (lpContainerLine-&gt;m_sizeInHimetric.cx &gt; 0 &amp;&amp; <br>      lpContainerLine-&gt;m_sizeInHimetric.cy &gt; 0) { <br>      sizelHim.cx = lpLine-&gt;m_nWidthInHimetric; <br>      sizelHim.cy = lpLine-&gt;m_nHeightInHimetric; <br>      XformSizeInHimetricToPixels(NULL, &amp;sizelHim, &amp;sizelPix); <br>      sizelHim.cx = lpContainerLine-&gt;m_sizeInHimetric.cx * <br>               nIPObjWidth / sizelPix.cx; <br>      sizelHim.cy = lpContainerLine-&gt;m_sizeInHimetric.cy * <br>               nIPObjHeight / sizelPix.cy; <br> <br>      // Convert size back to 100% zoom <br>      sizelHim.cx = sizelHim.cx * lpscale-&gt;dwSxD / lpscale-&gt;dwSxN; <br>      sizelHim.cy = sizelHim.cy * lpscale-&gt;dwSyD / lpscale-&gt;dwSyN; <br>   } else { <br>      sizelHim.cx = (long)DEFOBJWIDTH; <br>      sizelHim.cy = (long)DEFOBJHEIGHT; <br>      XformSizeInHimetricToPixels(NULL, &amp;sizelHim, &amp;sizelPix); <br>      sizelHim.cx = sizelHim.cx * nIPObjWidth / sizelPix.cx; <br>      sizelHim.cy = sizelHim.cy * nIPObjHeight / sizelPix.cy; <br>   } <br> <br>   ContainerLine_UpdateExtent(lpContainerLine, &amp;sizelHim); <br>   ContainerLine_GetPosRect(lpContainerLine, (LPRECT)&amp;rcNewPosRect); <br>   ContainerDoc_GetClipRect(lpContainerLine-&gt;m_lpDoc, (LPRECT)&amp;rcClipRect); <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (PosRect --OUT)", <br>         (LPRECT)&amp;rcNewPosRect); <br>   OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (ClipRect--OUT)", <br>         (LPRECT)&amp;rcClipRect); <br>#endif <br>   OLEDBG_BEGIN2("IOleInPlaceObject::SetObjectRects called\r\n") <br>   lpContainerLine-&gt;m_lpOleIPObj-&gt;lpVtbl-&gt;SetObjectRects( <br>         lpContainerLine-&gt;m_lpOleIPObj, <br>         (LPRECT)&amp;rcNewPosRect, <br>         (LPRECT)&amp;rcClipRect <br>   ); <br>   OLEDBG_END2 <br> <br>   /* NOTE: (INSIDEOUT CONTAINER) Because this object just changed <br>   **    size, this may cause other in-place active objects in the <br>   **    document to move. in ICNTROTL's case any object below this <br>   **    object would be affected. in this case it would be necessary <br>   **    to call SetObjectRects to each affected in-place active object. <br>   */ <br>   if (g_fInsideOutContainer) { <br>      lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>      nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br> <br>      ContainerDoc_UpdateInPlaceObjectRects( <br>            lpContainerLine-&gt;m_lpDoc, nIndex); <br>   } <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_IPSite_Release(lpThis); <br>   return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
