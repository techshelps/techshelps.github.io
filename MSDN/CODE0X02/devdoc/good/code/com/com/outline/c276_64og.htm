<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DEBUG2.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context280"></a>DEBUG2.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    debug2.c <br>** <br>**    This file contains various debug / subclass routines for the <br>**    ABOUT dialog <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br>#include &lt;stdlib.h&gt; <br>#include &lt;time.h&gt; <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br>LONG CALLBACK EXPORT DebugAbout(HWND hWnd, unsigned uMsg, WORD wParam, LONG lParam); <br>void RandomizeStars(HDC hDC); <br>BOOL InitStrings(void); <br>BOOL DrawString(int iCount, HDC hDC, LPRECT rcDrawIn); <br> <br>static FARPROC lpRealAboutProc = 0L; <br>static int width, height; <br>static RECT rc; <br>static HANDLE hStrBlock = NULL; <br>static LPSTR lpStrings = NULL; <br>static WORD       wLineHeight; <br> <br> <br>/* TraceDebug <br> * ---------- <br> * <br> * Called once when our About Box's gets the INITDIALOG message.  Subclasses <br> * dialog. <br> */ <br> <br>void TraceDebug(HWND hDlg, int iControl) <br>{ <br> <br>        // Load strings, if the strings aren't there, then don't subclass <br>        // the dialog <br>        if (InitStrings() != TRUE) <br>                return; <br> <br>        // Subclass the dialog <br>        lpRealAboutProc = (FARPROC)(LONG)GetWindowLong(hDlg, GWL_WNDPROC); <br>        SetWindowLong(hDlg, GWL_WNDPROC, (LONG)(FARPROC)DebugAbout); <br> <br>        // Get rect of control in screen coords, and translate to our dialog <br>        // box's coordinates <br>        GetWindowRect(GetDlgItem(hDlg, iControl), &amp;rc); <br>        MapWindowPoints(NULL, hDlg, (LPPOINT)&amp;rc, 2); <br> <br>        width  = rc.right - rc.left; <br>        height = rc.bottom - rc.top; <br>} <br> <br>/* DebugAbout <br> * ---------- <br> * <br> * The subclassed About dialog's main window proc. <br> */ <br> <br>LONG CALLBACK EXPORT DebugAbout(HWND hWnd, unsigned uMsg, WORD wParam, LONG lParam) <br>{ <br>        RECT              rcOut; <br>        static BOOL       bTimerStarted = FALSE; <br>        static int        iTopLocation; <br>        HDC               hDCScr; <br>        static HDC        hDCMem; <br>        static HBITMAP    hBitmap; <br>        static HBITMAP    hBitmapOld; <br>        static RECT       rcMem; <br>        static HFONT      hFont; <br> <br>        switch (uMsg) <br>        { <br> <br>        /* <br>         * If we get a LBUTTONDBLCLICK in the upper left of <br>         * the dialog, fire off the about box effects <br>         */ <br> <br>        case WM_LBUTTONDBLCLK: <br>                if ((wParam &amp; MK_CONTROL) &amp;&amp; (wParam &amp; MK_SHIFT) <br>                        &amp;&amp; LOWORD(lParam) &lt; 10 &amp;&amp; HIWORD(lParam) &lt; 10 &amp;&amp; <br>                        bTimerStarted == FALSE) <br>                        { <br>                        if (SetTimer ( hWnd, 1, 10, NULL )) <br>                                { <br>                                LOGFONT lf; <br>                                int i; <br> <br>                                bTimerStarted = TRUE; <br> <br>                                // "Open up" the window <br>                                hDCScr = GetDC ( hWnd ); <br>                                hDCMem = CreateCompatibleDC     ( hDCScr ); <br> <br>                                hBitmap = CreateCompatibleBitmap(hDCScr, width, height); <br>                                hBitmapOld = SelectObject(hDCMem, hBitmap); <br> <br>                                // Blt from dialog to memDC <br>                                BitBlt(hDCMem, 0, 0, width, height, <br>                                hDCScr, rc.left, rc.top, SRCCOPY); <br> <br>                                for (i=0;i&lt;height;i+=1) <br>                                { <br>                                        BitBlt(hDCScr, rc.left, rc.top + i + 1, width, height-i-1, hDCMem, 0, 0, SRCCOPY); <br>                                        PatBlt(hDCScr, rc.left, rc.top + i, width, 1, BLACKNESS); <br>                                } <br> <br>                                SelectObject(hDCMem, hBitmapOld); <br>                                DeleteObject(hBitmap); <br> <br>                                // Set up memory DC with default attributes <br>                                hBitmap   = CreateCompatibleBitmap(hDCScr, width, height); <br>                                ReleaseDC(hWnd, hDCScr); <br> <br>                                hBitmapOld = SelectObject(hDCMem, hBitmap); <br> <br>                                SetBkMode(hDCMem, TRANSPARENT); <br>                                SetBkColor(hDCMem, RGB(0,0,0)); <br> <br>                                // Create font <br>                                memset(&amp;lf, 0, sizeof(LOGFONT)); <br>                                lf.lfHeight = -(height / 7); // Fit 7 lines of text in box <br>                                lf.lfWeight = FW_BOLD; <br>                                strcpy(lf.lfFaceName, "Arial"); <br>                                hFont = CreateFontIndirect(&amp;lf); <br> <br>                                // If we can't create the font, revert and use the standard <br>                                // system font. <br>                                if (!hFont) <br>                                        GetObject(GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &amp;lf); <br> <br>                                wLineHeight = abs(lf.lfHeight) + 5; // 5 pixels between lines <br> <br>                                // Set location of top of banner at bottom of the window <br>                                iTopLocation = height + 50; <br> <br>                                SetRect(&amp;rcMem, 0, 0, width, height); <br>                                } <br>                        } <br>                        // Call our real window procedure in case they want to <br>                        // handle LBUTTONDOWN messages also <br>                        goto Default; <br> <br>        case WM_TIMER: <br>                { <br>                int iCount; <br>                HFONT hfold; <br> <br>                /* <br>                 * On each timer message, we are going to construct the next image <br>                 * in the animation sequence, then bitblt this to our dialog. <br>                 */ <br> <br>                // Clear out old bitmap and place random star image on background <br>                PatBlt(hDCMem, rcMem.left, rcMem.top, rcMem.right, rcMem.bottom, BLACKNESS); <br>                RandomizeStars(hDCMem); <br> <br>                // Set initial location to draw text <br>                rcOut = rcMem; <br>                rcOut.top = 0 + iTopLocation; <br>                rcOut.bottom = rcOut.top + wLineHeight; <br> <br>                iCount = 0; <br>                if (hFont) hfold = SelectObject(hDCMem, hFont); <br> <br>                SetTextColor(hDCMem, RGB(0,255,0)); <br>                while (DrawString(iCount, hDCMem, &amp;rcOut) == TRUE) <br>                        { <br>                        rcOut.top    += wLineHeight; <br>                        rcOut.bottom += wLineHeight; <br>                        iCount++; <br>                        } <br>                if (hFont) SelectObject(hDCMem, hfold); <br> <br>                // Now blt the memory dc that we have just constructed <br>                // to the screen <br>                hDCScr = GetDC(hWnd); <br>                BitBlt(hDCScr, rc.left, rc.top, rc.right, rc.bottom, <br>                        hDCMem, 0, 0, SRCCOPY); <br>                ReleaseDC(hWnd, hDCScr); <br> <br>                // For the next animation sequence, we want to move the <br>                // whole thing up, so decrement the location of the top <br>                // of the banner <br> <br>                iTopLocation -= 2; <br> <br>                // If we've gone through the banner once, reset it <br>                if (iTopLocation &lt; -(int)(wLineHeight * iCount)) <br>                        iTopLocation = height + 50; <br>                } <br>                // Goto default <br>                goto Default; <br> <br>        case WM_NCDESTROY: <br>                { <br>                LONG defReturn; <br> <br>                /* <br>                 * We're being destroyed.  Clean up what we created. <br>                 */ <br> <br>                if (bTimerStarted) <br>                { <br>                        KillTimer(hWnd, 1); <br>                        SelectObject (hDCMem, hBitmapOld); <br>                        DeleteObject (hBitmap); <br>                        DeleteDC (hDCMem); <br>                        if (hFont) DeleteObject(hFont); <br>                        bTimerStarted = FALSE; <br>                } <br> <br>                if (lpStrings) <br>                        UnlockResource(hStrBlock), lpStrings = NULL; <br>                if (hStrBlock) <br>                        FreeResource(hStrBlock), hStrBlock = NULL; <br> <br>                // Pass the NCDESTROY on to our real window procedure.  Since <br>                // this is the last message that we are going to be getting, <br>                // we can go ahead and free the proc instance here. <br> <br>                defReturn = CallWindowProc((WNDPROC)lpRealAboutProc, hWnd, <br>                                           uMsg, wParam, lParam); <br>                return defReturn; <br>                } <br> <br>        Default: <br>        default: <br>                return CallWindowProc( <br>                                (WNDPROC)lpRealAboutProc, hWnd, uMsg, wParam, lParam); <br>        } <br>        return 0L; <br>} <br> <br> <br>/* RandomizeStars <br> * -------------- <br> * <br> * Paints random stars on the specified hDC <br> * <br> */ <br> <br>void RandomizeStars(HDC hDC) <br>{ <br>        int             i; <br> <br>        // Seed the random number generator with current time.  This will, <br>        // in effect, only change the seed every second, so our <br>        // starfield will change only every second. <br>        srand((unsigned)time(NULL)); <br> <br>        // Generate random white stars <br>        for (i=0;i&lt;20;i++) <br>                PatBlt(hDC, getrandom(0,width), getrandom(0,height), 2, 2, WHITENESS); <br>} <br> <br>/* InitStrings <br> * -------------- <br> * <br> * Reads strings from stringtable.  Returns TRUE if it worked OK. <br> * <br> */ <br> <br>BOOL InitStrings() <br>{ <br>        HRSRC hResStrings; <br>        LPSTR lpWalk; <br> <br>        // Load the block of strings <br>        if ((hResStrings = FindResource( <br>                        g_lpApp-&gt;m_hInst, <br>                        MAKEINTRESOURCE(9999), <br>                        RT_RCDATA)) == NULL) <br>                return FALSE; <br>        if ((hStrBlock = LoadResource(g_lpApp-&gt;m_hInst, hResStrings)) == NULL) <br>                return FALSE; <br>        if ((lpStrings = LockResource(hStrBlock)) == NULL) <br>                return FALSE; <br> <br>        if (lpStrings &amp;&amp; *(lpStrings+2)!=0x45) <br>        { <br>                lpWalk = lpStrings; <br>                 while (*(UNALIGNED WORD *)lpWalk != (WORD)0x0000) <br>                { <br>                    if (*lpWalk != (char)0x00) <br>                          *((UNALIGNED WORD *)lpWalk) ^= 0x98; <br>                           lpWalk++; <br>                } <br>        } <br>        return TRUE; <br>} <br> <br>/* DrawString <br> * ---------- <br> * <br> * Draws the next string on the specified hDC using the <br> * output rectangle.  If iCount == 0, reset to start of list. <br> * <br> * Returns: TRUE to contine, FALSE if we're done <br> */ <br> <br>BOOL DrawString(int iCount, HDC hDC, LPRECT rcDrawIn) <br>{ <br>        static LPSTR lpPtr = NULL; <br> <br>        if (iCount == 0) <br>                // First time, reset pointer <br>                lpPtr = lpStrings; <br> <br>        if (*lpPtr == '\0') // If we've hit a NULL string, we're done <br>                return FALSE; <br> <br>        // If we're drawing outside of visible box, don't call DrawText <br>        if ((rcDrawIn-&gt;bottom &gt; 0) &amp;&amp; (rcDrawIn-&gt;top &lt; height)) <br>                DrawText(hDC, lpPtr, -1, rcDrawIn, DT_CENTER); <br> <br>        // Advance pointer to next string <br>        lpPtr += lstrlen(lpPtr) + 1; <br> <br>        return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
