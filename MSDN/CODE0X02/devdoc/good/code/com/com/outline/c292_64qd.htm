<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEDOC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context295"></a>OLEDOC.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Server Sample Code <br>** <br>**    oledoc.c <br>** <br>**    This file contains general OleDoc methods and related support <br>**    functions. OleDoc implementation is used by both the Container <br>**    versions and the Server (Object) versions of the Outline Sample. <br>** <br>**    This file includes general support for the following: <br>**    1. show/hide doc window <br>**    2. QueryInterface, AddRef, Release <br>**    3. document locking (calls CoLockObjectExternal) <br>**    4. document shutdown (Close, Destroy) <br>**    5. clipboard support <br>** <br>**    OleDoc Object <br>**      exposed interfaces: <br>**          IUnknown <br>**          IPersistFile <br>**          IOleItemContainer <br>**          IDataObject <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br>extern IUnknownVtbl             g_OleDoc_UnknownVtbl; <br>extern IPersistFileVtbl         g_OleDoc_PersistFileVtbl; <br>extern IOleItemContainerVtbl    g_OleDoc_OleItemContainerVtbl; <br>extern IExternalConnectionVtbl  g_OleDoc_ExternalConnectionVtbl; <br>extern IDataObjectVtbl          g_OleDoc_DataObjectVtbl; <br> <br>#if defined( USE_DRAGDROP ) <br>extern IDropTargetVtbl          g_OleDoc_DropTargetVtbl; <br>extern IDropSourceVtbl          g_OleDoc_DropSourceVtbl; <br>#endif  // USE_DRAGDROP <br> <br>#if defined( INPLACE_CNTR ) <br>extern BOOL g_fInsideOutContainer; <br>#endif <br> <br> <br>/* OleDoc_Init <br> * ----------- <br> * <br> *  Initialize the fields of a new OleDoc object. The object is initially <br> *  not associated with a file or an (Untitled) document. This function sets <br> *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the <br> *  caller should call: <br> *      1.) Doc_InitNewFile to set the OleDoc to (Untitled) <br> *      2.) Doc_LoadFromFile to associate the OleDoc with a file. <br> *  This function creates a new window for the document. <br> * <br> *  NOTE: the window is initially created with a NIL size. it must be <br> *        sized and positioned by the caller. also the document is initially <br> *        created invisible. the caller must call OutlineDoc_ShowWindow <br> *        after sizing it to make the document window visible. <br> */ <br>BOOL OleDoc_Init(LPOLEDOC lpOleDoc, BOOL fDataTransferDoc) <br>{ <br>   LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br> <br>   lpOleDoc-&gt;m_cRef                        = 0; <br>   lpOleDoc-&gt;m_dwStrongExtConn             = 0; <br>#if defined( _DEBUG ) <br>   lpOleDoc-&gt;m_cCntrLock                   = 0; <br>#endif <br>   lpOleDoc-&gt;m_lpStg                       = NULL; <br>   lpOleDoc-&gt;m_lpLLStm                     = NULL; <br>   lpOleDoc-&gt;m_lpNTStm                     = NULL; <br>   lpOleDoc-&gt;m_dwRegROT                    = 0; <br>   lpOleDoc-&gt;m_lpFileMoniker               = NULL; <br>   lpOleDoc-&gt;m_fLinkSourceAvail            = FALSE; <br>   lpOleDoc-&gt;m_lpSrcDocOfCopy              = NULL; <br>   lpOleDoc-&gt;m_fObjIsClosing               = FALSE; <br>   lpOleDoc-&gt;m_fObjIsDestroying            = FALSE; <br>   lpOleDoc-&gt;m_fUpdateEditMenu             = FALSE; <br> <br>#if defined( USE_DRAGDROP ) <br>   lpOleDoc-&gt;m_dwTimeEnterScrollArea       = 0L; <br>   lpOleDoc-&gt;m_dwNextScrollTime            = 0L; <br>   lpOleDoc-&gt;m_dwLastScrollDir             = SCROLLDIR_NULL; <br>   lpOleDoc-&gt;m_fRegDragDrop                = FALSE; <br>   lpOleDoc-&gt;m_fLocalDrag                  = FALSE; <br>   lpOleDoc-&gt;m_fCanDropCopy                = FALSE; <br>   lpOleDoc-&gt;m_fCanDropLink                = FALSE; <br>   lpOleDoc-&gt;m_fLocalDrop                  = FALSE; <br>   lpOleDoc-&gt;m_fDragLeave                  = FALSE; <br>   lpOleDoc-&gt;m_fPendingDrag                = FALSE; <br>#endif <br>#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR ) <br>   lpOleDoc-&gt;m_fCSHelpMode                 = FALSE;    // Shift-F1 context <br>                                          // sensitive help mode <br>#endif <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_Unknown, <br>         &amp;g_OleDoc_UnknownVtbl, <br>         lpOleDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_PersistFile, <br>         &amp;g_OleDoc_PersistFileVtbl, <br>         lpOleDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_OleItemContainer, <br>         &amp;g_OleDoc_OleItemContainerVtbl, <br>         lpOleDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_ExternalConnection, <br>         &amp;g_OleDoc_ExternalConnectionVtbl, <br>         lpOleDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_DataObject, <br>         &amp;g_OleDoc_DataObjectVtbl, <br>         lpOleDoc <br>   ); <br> <br>#if defined( USE_DRAGDROP ) <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_DropSource, <br>         &amp;g_OleDoc_DropSourceVtbl, <br>         lpOleDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleDoc-&gt;m_DropTarget, <br>         &amp;g_OleDoc_DropTargetVtbl, <br>         lpOleDoc <br>   ); <br>#endif  // USE_DRAGDROP <br> <br>   /* <br>   ** NOTE: each user level document addref's the app object in <br>   **    order to guarentee that the app does not shut down while the <br>   **    doc is still open. <br>   */ <br> <br>   // NOTE: data transfer documents should not hold the app alive <br>   if (! fDataTransferDoc) <br>      OleApp_DocLockApp(lpOleApp); <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: perform initialization specific for an OLE server */ <br>   if (! ServerDoc_Init((LPSERVERDOC)lpOleDoc, fDataTransferDoc)) <br>      return FALSE; <br>#endif <br>#if defined( OLE_CNTR ) <br> <br>   /* NOTE: perform initialization specific for an OLE container */ <br>   if (! ContainerDoc_Init((LPCONTAINERDOC)lpOleDoc, fDataTransferDoc)) <br>      return FALSE; <br>#endif <br> <br>   return TRUE; <br>} <br> <br> <br> <br>/* OleDoc_InitNewFile <br> * ------------------ <br> * <br> *  Initialize the document to be a new (Untitled) document. <br> *  This function sets the docInitType to DOCTYPE_NEW. <br> * <br> *  NOTE: if this is a visible user document then generate a unique <br> *  untitled name that we can use to register in the RunningObjectTable. <br> *  We need a unique name so that clients can link to data in this document <br> *  even when the document is in the un-saved (untitled) state. it would be <br> *  ambiguous to register two documents titled "Outline1" in the ROT. we <br> *  thus generate the lowest numbered document that is not already <br> *  registered in the ROT. <br> */ <br>BOOL OleDoc_InitNewFile(LPOLEDOC lpOleDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br> <br>   static UINT uUnique = 1; <br> <br>   OleDbgAssert(lpOutlineDoc-&gt;m_docInitType == DOCTYPE_UNKNOWN); <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz(lpOleDoc-&gt;m_lpStg == NULL, <br>            "Setting to untitled with current file open" <br>      ); <br>#endif <br> <br>      /* Create a temp, (delete-on-release) file base storage <br>      **  for the untitled document. <br>      */ <br>      lpOleDoc-&gt;m_lpStg = OleStdCreateRootStorage( <br>            NULL, <br>            STGM_SHARE_EXCLUSIVE <br>      ); <br>      if (! lpOleDoc-&gt;m_lpStg) return FALSE; <br>   } <br>#endif <br> <br>   lpOutlineDoc-&gt;m_docInitType = DOCTYPE_NEW; <br> <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      /* NOTE: choose a unique name for a Moniker so that <br>      **    potential clients can link to our new, untitled document. <br>      **    if links are established (and currently are connected), <br>      **    then they will be notified that we have been renamed when <br>      **    this document is saved to a file. <br>      */ <br> <br>      lpOleDoc-&gt;m_fLinkSourceAvail = TRUE; <br> <br>      // REVIEW: should load UNTITLED string from string resource <br>      OleStdCreateTempFileMoniker( <br>            UNTITLED, <br>            (UINT FAR*)&amp;uUnique, <br>            lpOutlineDoc-&gt;m_szFileName, <br>            &amp;lpOleDoc-&gt;m_lpFileMoniker <br>      ); <br> <br>      OLEDBG_BEGIN3("OleStdRegisterAsRunning called\r\n") <br>      OleStdRegisterAsRunning( <br>            (LPUNKNOWN)&amp;lpOleDoc-&gt;m_PersistFile, <br>            (LPMONIKER)lpOleDoc-&gt;m_lpFileMoniker, <br>            &amp;lpOleDoc-&gt;m_dwRegROT <br>      ); <br>      OLEDBG_END3 <br> <br>      lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>      OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/); <br>   } else { <br>      OLESTRCPY(lpOutlineDoc-&gt;m_szFileName, UNTITLED); <br>      lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* OleDoc_ShowWindow <br> * ----------------- <br> * <br> *      Show the window of the document to the user. <br> *      make sure app window is visible and bring the document to the top. <br> *      if the document is a file-based document or a new untitled <br> *      document, give the user the control over the life-time of the doc. <br> */ <br>void OleDoc_ShowWindow(LPOLEDOC lpOleDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>#if defined( OLE_SERVER ) <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>#endif // OLE_SERVER <br> <br>   OLEDBG_BEGIN3("OleDoc_ShowWindow\r\n") <br> <br>   /* NOTE: while the document is visible, we do NOT want it to be <br>   **    prematurely destroyed when a linking client disconnects. thus <br>   **    we must inform OLE to hold an external lock on our document. <br>   **    this arranges that OLE holds at least 1 reference to our <br>   **    document that will NOT be released until we release this <br>   **    external lock. later, when the document window is hidden, we <br>   **    will release this external lock. <br>   */ <br>   if (! IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) <br>      OleDoc_Lock(lpOleDoc, TRUE /* fLock */, 0 /* not applicable */); <br> <br>#if defined( USE_DRAGDROP ) <br>   /* NOTE: since our window is now being made visible, we will <br>   **    register our window as a potential drop target. when the <br>   **    window is hidden there is no reason to be registered as a <br>   **    drop target. <br>   */ <br>   if (! lpOleDoc-&gt;m_fRegDragDrop) { <br>      OLEDBG_BEGIN2("RegisterDragDrop called\r\n") <br>      RegisterDragDrop( <br>            LineList_GetWindow(lpLL), <br>            (LPDROPTARGET)&amp;lpOleDoc-&gt;m_DropTarget <br>      ); <br>      OLEDBG_END2 <br>      lpOleDoc-&gt;m_fRegDragDrop = TRUE; <br>   } <br>#endif  // USE_DRAGDROP <br> <br>#if defined( USE_FRAMETOOLS ) <br>   { <br>      /* NOTE: we need to enable our frame level tools <br>      */ <br>      FrameTools_Enable(lpOutlineDoc-&gt;m_lpFrameTools, TRUE); <br>   } <br>#endif // USE_FRAMETOOLS <br> <br>#if defined( OLE_SERVER ) <br> <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED &amp;&amp; <br>         lpServerDoc-&gt;m_lpOleClientSite != NULL) { <br> <br>      /* NOTE: we must also ask our container to show itself if <br>      **    it is not already visible and to scroll us into view. we <br>      **    must make sure to call this BEFORE showing our server's <br>      **    window and taking focus. we do not want our container's <br>      **    window to end up on top. <br>      */ <br>      OLEDBG_BEGIN2("IOleClientSite::ShowObject called\r\n"); <br>      lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;ShowObject( <br>            lpServerDoc-&gt;m_lpOleClientSite <br>      ); <br>      OLEDBG_END2 <br> <br>      /* NOTE: if we are an embedded object and we are not <br>      **    in-place active in our containers window, we must inform our <br>      **    embedding container that our window is opening. <br>      **    the container must now hatch our object. <br>      */ <br> <br>#if defined( INPLACE_SVR ) <br>      if (! lpServerDoc-&gt;m_fInPlaceActive) <br>#endif <br>      { <br>         OLEDBG_BEGIN2("IOleClientSite::OnShowWindow(TRUE) called\r\n"); <br>         lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;OnShowWindow( <br>               lpServerDoc-&gt;m_lpOleClientSite, <br>               TRUE <br>         ); <br>         OLEDBG_END2 <br>      } <br> <br>      /* NOTE: the life-time of our document is controlled by our <br>      **    client and NOT by the user. we are not an independent <br>      **    file-level object. we simply want to show our window here. <br>      ** <br>      **    if we are not in-place active (ie. we are opening <br>      **    our own window), we must make sure our main app window is <br>      **    visible. we do not, however, want to give the user <br>      **    control of the App window; we do not want OleApp_ShowWindow <br>      **    to call OleApp_Lock on behalf of the user. <br>      */ <br>      if (! IsWindowVisible(lpOutlineApp-&gt;m_hWndApp) || <br>            IsIconic(lpOutlineApp-&gt;m_hWndApp)) { <br>#if defined( INPLACE_SVR ) <br>         if (! ((LPSERVERDOC)lpOleDoc)-&gt;m_fInPlaceActive) <br>#endif <br>            OleApp_ShowWindow(lpOleApp, FALSE /* fGiveUserCtrl */); <br>         SetFocus(lpOutlineDoc-&gt;m_hWndDoc); <br>      } <br> <br>   } else <br>#endif  // OLE_SERVER <br> <br>   {    // DOCTYPE_NEW || DOCTYPE_FROMFILE <br> <br>      // we must make sure our app window is visible <br>      OleApp_ShowWindow(lpOleApp, TRUE /* fGiveUserCtrl */); <br>   } <br> <br>   // make document window visible and make sure it is not minimized <br>   ShowWindow(lpOutlineDoc-&gt;m_hWndDoc, SW_SHOWNORMAL); <br>   SetForegroundWindow(lpOutlineDoc-&gt;m_hWndDoc); <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleDoc_HideWindow <br> * ----------------- <br> * <br> *      Hide the window of the document from the user. <br> *      take away the control of the document by the user. <br> */ <br>void OleDoc_HideWindow(LPOLEDOC lpOleDoc, BOOL fShutdown) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br> <br>   if (! IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) <br>      return;     // already visible <br> <br>   OLEDBG_BEGIN3("OleDoc_HideWindow\r\n") <br> <br>#if defined( USE_DRAGDROP ) <br>   // The document's window is being hidden, revoke it as a DropTarget <br>   if (lpOleDoc-&gt;m_fRegDragDrop) { <br>      OLEDBG_BEGIN2("RevokeDragDrop called\r\n"); <br>      RevokeDragDrop(LineList_GetWindow(lpLL)); <br>      OLEDBG_END2 <br> <br>      lpOleDoc-&gt;m_fRegDragDrop = FALSE ; <br>   } <br>#endif  // USE_DRAGDROP <br> <br>   /* NOTE: the document is now being hidden, so we must release <br>   **    the external lock made when the document was made visible. <br>   **    if this is a shutdown situation (fShutdown==TRUE), then OLE <br>   **    is instructed to release our document. if this is that last <br>   **    external lock on our document, thus enabling our document to <br>   **    complete its shutdown operation. If This is not a shutdown <br>   **    situation (eg. in-place server hiding its window when <br>   **    UIDeactivating or IOleObject::DoVerb(OLEVERB_HIDE) is called), <br>   **    then OLE is told to NOT immediately release the document. <br>   **    this leaves the document in an unstable state where the next <br>   **    Lock/Unlock sequence will shut the document down (eg. a <br>   **    linking client connecting and disconnecting). <br>   */ <br>   if (IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) <br>      OleDoc_Lock(lpOleDoc, FALSE /* fLock */, fShutdown); <br> <br>   ShowWindow(((LPOUTLINEDOC)lpOleDoc)-&gt;m_hWndDoc, SW_HIDE); <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br> <br>      /* NOTE: if we are an embedded object and we are not <br>      **    in-place active, we must inform our <br>      **    embedding container that our window is hiding (closing <br>      **    from the user's perspective). the container must now <br>      **    un-hatch our object. <br>      */ <br>      if (lpServerDoc-&gt;m_lpOleClientSite != NULL <br>#if defined( INPLACE_SVR ) <br>         &amp;&amp; !lpServerDoc-&gt;m_fInPlaceVisible <br>#endif <br>      ) { <br>         OLEDBG_BEGIN2("IOleClientSite::OnShowWindow(FALSE) called\r\n"); <br>         lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;OnShowWindow( <br>               lpServerDoc-&gt;m_lpOleClientSite, <br>               FALSE <br>         ); <br>         OLEDBG_END2 <br>      } <br>   } <br>#endif <br> <br>   /* NOTE: if there are no more documents visible to the user. <br>   **    and the app itself is not under user control, then <br>   **    it has no reason to stay visible. we thus should hide the <br>   **    app. we can not directly destroy the app, because it may be <br>   **    validly being used programatically by another client <br>   **    application and should remain running. it should simply be <br>   **    hidded from the user. <br>   */ <br>   OleApp_HideIfNoReasonToStayVisible(lpOleApp); <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleDoc_Lock <br>** ----------- <br>**    Lock/Unlock the Doc object. if the last lock is unlocked and <br>**    fLastUnlockReleases == TRUE, then the Doc object will shut down <br>**    (ie. it will recieve its final release and its refcnt will go to 0). <br>*/ <br>HRESULT OleDoc_Lock(LPOLEDOC lpOleDoc, BOOL fLock, BOOL fLastUnlockReleases) <br>{ <br>   HRESULT hrErr; <br> <br>#if defined( _DEBUG ) <br>   if (fLock) { <br>      OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,TRUE) called\r\n") <br>   } else { <br>      if (fLastUnlockReleases) <br>         OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,FALSE,TRUE) called\r\n") <br>      else <br>         OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,FALSE,FALSE) called\r\n") <br>   } <br>#endif  // _DEBUG <br> <br>   hrErr = CoLockObjectExternal( <br>         (LPUNKNOWN)&amp;lpOleDoc-&gt;m_Unknown, fLock, fLastUnlockReleases); <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>/* OleDoc_AddRef <br>** ------------- <br>** <br>**  increment the ref count of the document object. <br>** <br>**    Returns the new ref count on the object <br>*/ <br>ULONG OleDoc_AddRef(LPOLEDOC lpOleDoc) <br>{ <br>   ++lpOleDoc-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRefCnt4( <br>         "OleDoc_AddRef: cRef++\r\n", <br>         lpOleDoc, <br>         lpOleDoc-&gt;m_cRef <br>   ); <br>#endif <br>   return lpOleDoc-&gt;m_cRef; <br>} <br> <br> <br>/* OleDoc_Release <br>** -------------- <br>** <br>**  decrement the ref count of the document object. <br>**    if the ref count goes to 0, then the document is destroyed. <br>** <br>**    Returns the remaining ref count on the object <br>*/ <br>ULONG OleDoc_Release (LPOLEDOC lpOleDoc) <br>{ <br>   ULONG cRef; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br> <br>   /********************************************************************* <br>   ** NOTE: when the obj refcnt == 0, then destroy the object.     ** <br>   **     otherwise the object is still in use.                        ** <br>   *********************************************************************/ <br> <br>   cRef = --lpOleDoc-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz (lpOleDoc-&gt;m_cRef &gt;= 0, "Release called with cRef == 0"); <br> <br>   OleDbgOutRefCnt4( <br>         "OleDoc_Release: cRef--\r\n", lpOleDoc, cRef); <br>#endif <br>   if (cRef == 0) <br>      OutlineDoc_Destroy((LPOUTLINEDOC)lpOleDoc); <br> <br>   return cRef; <br>} <br> <br> <br>/* OleDoc_QueryInterface <br>** --------------------- <br>** <br>** Retrieve a pointer to an interface on the document object. <br>** <br>**    NOTE: this function will AddRef the ref cnt of the object. <br>** <br>**    Returns S_OK if interface is successfully retrieved. <br>**            E_NOINTERFACE if the interface is not supported <br>*/ <br>HRESULT OleDoc_QueryInterface( <br>      LPOLEDOC          lpOleDoc, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpvObj <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   SCODE sc = E_NOINTERFACE; <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvObj = NULL; <br> <br>   if (IsEqualIID(riid, &amp;IID_IUnknown)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IUnknown* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_Unknown; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(lpOutlineDoc-&gt;m_fDataTransferDoc <br>         &amp;&amp; IsEqualIID(riid, &amp;IID_IDataObject)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IDataObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_DataObject; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br> <br>   /* NOTE: if this document is a DataTransferDocument used to <br>   **    support a clipboard or drag/drop operation, then it should <br>   **    only expose IUnknown, IDataObject, and IDropSource <br>   **    interfaces. if the document is a normal user document, then <br>   **    we will also continue to consider our other interfaces. <br>   */ <br>   if (lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      goto done; <br> <br>   if(IsEqualIID(riid,&amp;IID_IPersist) || IsEqualIID(riid,&amp;IID_IPersistFile)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IPersistFile* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_PersistFile; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(IsEqualIID(riid, &amp;IID_IOleItemContainer) || <br>         IsEqualIID(riid, &amp;IID_IOleContainer) || <br>         IsEqualIID(riid, &amp;IID_IParseDisplayName) ) { <br>      OleDbgOut4("OleDoc_QueryInterface: IOleItemContainer* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_OleItemContainer; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(IsEqualIID(riid, &amp;IID_IExternalConnection)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IExternalConnection* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_ExternalConnection; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br> <br>#if defined( USE_DRAGDROP ) <br>   else if(IsEqualIID(riid, &amp;IID_IDropTarget)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IDropTarget* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_DropTarget; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(IsEqualIID(riid, &amp;IID_IDropSource)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IDropSource* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_DropSource; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>#endif <br> <br>#if defined( OLE_CNTR ) <br>   else if (IsEqualIID(riid, &amp;IID_IOleUILinkContainer)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IOleUILinkContainer* RETURNED\r\n"); <br> <br>      *lplpvObj=(LPVOID)&amp;((LPCONTAINERDOC)lpOleDoc)-&gt;m_OleUILinkContainer; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>#endif <br> <br>#if defined( OLE_SERVER ) <br> <br>   /* NOTE: if OLE server version, than also offer the server <br>   **    specific interfaces: IOleObject and IPersistStorage. <br>   */ <br>   else if (IsEqualIID(riid, &amp;IID_IOleObject)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IOleObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;((LPSERVERDOC)lpOleDoc)-&gt;m_OleObject; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(IsEqualIID(riid, &amp;IID_IPersistStorage)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IPersistStorage* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;((LPSERVERDOC)lpOleDoc)-&gt;m_PersistStorage; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>   else if(IsEqualIID(riid, &amp;IID_IDataObject)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IDataObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleDoc-&gt;m_DataObject; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br> <br>#if defined( SVR_TREATAS ) <br>   else if(IsEqualIID(riid, &amp;IID_IStdMarshalInfo)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IStdMarshalInfo* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;((LPSERVERDOC)lpOleDoc)-&gt;m_StdMarshalInfo; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>#endif  // SVR_TREATAS <br> <br>#if defined( INPLACE_SVR ) <br>   else if (IsEqualIID(riid, &amp;IID_IOleWindow) || <br>          IsEqualIID(riid, &amp;IID_IOleInPlaceObject)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IOleInPlaceObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;((LPSERVERDOC)lpOleDoc)-&gt;m_OleInPlaceObject; <br>      OleDoc_AddRef(lpOleDoc); <br>      sc = S_OK; <br>   } <br>#endif // INPLACE_SVR <br>#endif // OLE_SERVER <br> <br>done: <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br> <br>   return sc; <br>} <br> <br> <br>/* OleDoc_Close <br> * ------------ <br> * <br> *  Close the document. <br> *      This functions performs the actions that are in common to all <br> *      document types which derive from OleDoc (eg. ContainerDoc and <br> *      ServerDoc) which are required to close a document. <br> * <br> *  Returns: <br> *      FALSE -- user canceled the closing of the doc. <br> *      TRUE -- the doc was successfully closed <br> */ <br> <br>BOOL OleDoc_Close(LPOLEDOC lpOleDoc, DWORD dwSaveOption) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLEDOC lpClipboardDoc; <br>   LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>   BOOL fAbortIfSaveCanceled = (dwSaveOption == OLECLOSE_PROMPTSAVE); <br> <br>   if (! lpOleDoc) <br>      return TRUE;    // active doc's are already destroyed <br> <br>   if (lpOleDoc-&gt;m_fObjIsClosing) <br>      return TRUE;    // Closing is already in progress <br> <br>   OLEDBG_BEGIN3("OleDoc_Close\r\n") <br> <br>   if (! OutlineDoc_CheckSaveChanges((LPOUTLINEDOC)lpOleDoc,&amp;dwSaveOption) <br>         &amp;&amp; fAbortIfSaveCanceled) { <br>      OLEDBG_END3 <br>      return FALSE;           // cancel closing the doc <br>   } <br> <br>   lpOleDoc-&gt;m_fObjIsClosing = TRUE;   // guard against recursive call <br> <br>   /* NOTE: in order to have a stable app and doc during the <br>   **    process of closing, we intially AddRef the App and Doc ref <br>   **    cnts and later Release them. These initial AddRefs are <br>   **    artificial; they simply guarantee that these objects do not <br>   **    get destroyed until the end of this routine. <br>   */ <br>   OleApp_AddRef(lpOleApp); <br>   OleDoc_AddRef(lpOleDoc); <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br> <br>      /* NOTE: force all OLE objects to close. this forces all <br>      **    OLE object to transition from running to loaded. we can <br>      **    NOT exit if any embeddings are still running. <br>      **    if an object can't be closed and this close operation was <br>      **    started by the user, then we will abort closing our document. <br>      */ <br>      if (! ContainerDoc_CloseAllOleObjects(lpContainerDoc, OLECLOSE_NOSAVE) <br>            &amp;&amp; fAbortIfSaveCanceled) { <br>         OleDoc_Release(lpOleDoc);       // release artificial AddRef above <br>         OleApp_Release(lpOleApp);       // release artificial AddRef above <br>         lpOleDoc-&gt;m_fObjIsClosing = FALSE; // clear recursion guard <br> <br>         OLEDBG_END3 <br>         return FALSE;   // Closing is aborted <br>      } <br>   } <br>#endif <br> <br>#if defined( INPLACE_SVR ) <br>   /* NOTE: if the server is currently in-place active we must <br>   **    deactivate it now before closing <br>   */ <br>   ServerDoc_DoInPlaceDeactivate((LPSERVERDOC)lpOleDoc); <br>#endif <br> <br>   /* NOTE: if this document is the source of data for the <br>   **    clipboard, then flush the clipboard. it is important to flush <br>   **    the clipboard BEFORE calling sending any notifications to <br>   **    clients (eg. IOleClientSite::OnShowWindow(FALSE)) which could <br>   **    give them a chance to run and try to get our clipboard data <br>   **    object that we want to destroy. (eg. our app tries to <br>   **    update the paste button of the toolbar when <br>   **    WM_ACTIVATEAPP is received.) <br>   */ <br>   lpClipboardDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br>   if (lpClipboardDoc &amp;&amp; <br>      lpClipboardDoc-&gt;m_lpSrcDocOfCopy == lpOleDoc) { <br>      OleApp_FlushClipboard(lpOleApp); <br>   } <br> <br>   /* NOTE: Revoke the object from the Running Object Table. it is <br>   **    best if the object is revoke prior to calling <br>   **    COLockObjectExternal(FALSE,TRUE) which is called when the <br>   **    document window is hidden from the user. <br>   */ <br>   OLEDBG_BEGIN3("OleStdRevokeAsRunning called\r\n") <br>   OleStdRevokeAsRunning(&amp;lpOleDoc-&gt;m_dwRegROT); <br>   OLEDBG_END3 <br> <br>   /* NOTE: if the user is in control of the document, the user <br>   **    accounts for one refcnt on the document. Closing the <br>   **    document is achieved by releasing the object on behalf of <br>   **    the user. if the document is not referenced by any other <br>   **    clients, then the document will also be destroyed. if it <br>   **    is referenced by other clients, then it will remain until <br>   **    they release it. it is important to hide the window and call <br>   **    IOleClientSite::OnShowWindow(FALSE) BEFORE sending OnClose <br>   **    notification. <br>   */ <br>   OleDoc_HideWindow(lpOleDoc, TRUE); <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      LPSERVERNAMETABLE lpServerNameTable = <br>         (LPSERVERNAMETABLE)((LPOUTLINEDOC)lpOleDoc)-&gt;m_lpNameTable; <br> <br>      /* NOTE: force all pseudo objects to close. this informs all <br>      **    linking clients of pseudo objects to release their PseudoObj. <br>      */ <br>      ServerNameTable_CloseAllPseudoObjs(lpServerNameTable); <br> <br>      /* NOTE: send last OnDataChange notification to clients <br>      **    that have registered for data notifications when object <br>      **    stops running (ADVF_DATAONSTOP), if the data in our <br>      **    object has ever changed. it is best to only send this <br>      **    notification if necessary. <br>      */ <br>      if (lpServerDoc-&gt;m_lpDataAdviseHldr) { <br>         if (lpServerDoc-&gt;m_fSendDataOnStop) { <br>            ServerDoc_SendAdvise( <br>                  (LPSERVERDOC)lpOleDoc, <br>                  OLE_ONDATACHANGE, <br>                  NULL,   /* lpmkDoc -- not relevant here */ <br>                  ADVF_DATAONSTOP <br>            ); <br>         } <br>         /* NOTE: we just sent the last data notification that we <br>         **    need to send; release our DataAdviseHolder. we SHOULD be <br>         **    the only one using it. <br>         */ <br> <br>         OleStdVerifyRelease( <br>               (LPUNKNOWN)lpServerDoc-&gt;m_lpDataAdviseHldr, <br>               OLESTR("DataAdviseHldr not released properly") <br>         ); <br>         lpServerDoc-&gt;m_lpDataAdviseHldr = NULL; <br>      } <br> <br>      // NOTE: inform all of our linking clients that we are closing. <br> <br> <br>      if (lpServerDoc-&gt;m_lpOleAdviseHldr) { </code></pre>
<p>
</p>
<pre><code>ServerDoc_SendAdvise( <br>               (LPSERVERDOC)lpOleDoc, <br>               OLE_ONCLOSE, <br>               NULL,   /* lpmkDoc -- not relevant here */ <br>               0       /* advf -- not relevant here */ <br>         ); <br> <br>         /* NOTE: OnClose is the last notification that we need to <br>         **    send; release our OleAdviseHolder. we SHOULD be the only <br>         **    one using it. this will make our destructor realize that <br>         **    OnClose notification has already been sent. <br>         */ <br>         OleStdVerifyRelease( <br>               (LPUNKNOWN)lpServerDoc-&gt;m_lpOleAdviseHldr, <br>               OLESTR("OleAdviseHldr not released properly") <br>         ); <br>         lpServerDoc-&gt;m_lpOleAdviseHldr = NULL; <br>      } <br> <br>      /* release our Container's ClientSite. */ <br>      if(lpServerDoc-&gt;m_lpOleClientSite) { <br>         OleStdRelease((LPUNKNOWN)lpServerDoc-&gt;m_lpOleClientSite); <br>         lpServerDoc-&gt;m_lpOleClientSite = NULL; <br>      } <br>   } <br>#endif <br> <br>   if (lpOleDoc-&gt;m_lpLLStm) { <br>      /* release our LineList stream. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpLLStm); <br>      lpOleDoc-&gt;m_lpLLStm = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpNTStm) { <br>      /* release our NameTable stream. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpNTStm); <br>      lpOleDoc-&gt;m_lpNTStm = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpStg) { <br>      /* release our doc storage. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg); <br>      lpOleDoc-&gt;m_lpStg = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpFileMoniker) { <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpFileMoniker); <br>      lpOleDoc-&gt;m_lpFileMoniker = NULL; <br>   } <br> <br>   /* NOTE: this call forces all external connections to our <br>   **    object to close down and therefore guarantees that we receive <br>   **    all releases associated with those external connections. <br>   */ <br>   OLEDBG_BEGIN2("CoDisconnectObject(lpDoc) called\r\n") <br>   CoDisconnectObject((LPUNKNOWN)&amp;lpOleDoc-&gt;m_Unknown, 0); <br>   OLEDBG_END2 <br> <br>   OleDoc_Release(lpOleDoc);       // release artificial AddRef above <br>   OleApp_Release(lpOleApp);       // release artificial AddRef above <br> <br>   OLEDBG_END3 <br>   return TRUE; <br>} <br> <br> <br>/* OleDoc_Destroy <br> * -------------- <br> * <br> *  Free all OLE related resources that had been allocated for a document. <br> */ <br>void OleDoc_Destroy(LPOLEDOC lpOleDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br> <br>   if (lpOleDoc-&gt;m_fObjIsDestroying) <br>      return;     // Doc destruction is already in progress <br> <br>   lpOleDoc-&gt;m_fObjIsDestroying = TRUE;    // guard against recursive call <br> <br>#if defined( OLE_SERVER ) <br> <br>   /* NOTE: it is ALWAYS necessary to make sure that the work we <br>   **    do in our OleDoc_Close function is performed before we <br>   **    destroy our document object. this includes revoking from the <br>   **    Running Object Table (ROT), sending OnClose notification, <br>   **    revoking from Drag/Drop, closing all pseudo objects, etc. <br>   **    There are some tricky scenarios involving linking and <br>   **    when IOleObject::Close is called versus when we get our <br>   **    final release causing us to call our OleDoc_Destroy <br>   **    (destructor) function. <br>   ** <br>   **    SCENARIO 1 -- closing from server (File.Exit or File.Close) <br>   **                  OleDoc_Close function is called directly by the <br>   **                  server in response to the menu command <br>   **                  (WM_COMMAND processing). <br>   ** <br>   **    SCENARIO 2 -- closed by embedding container <br>   **                  our embedding container calls IOleObject::Close <br>   **                  directly. <br>   ** <br>   **    SCENARIO 3 -- silent-update final release <br>   **                  THIS IS THE TRICKY ONE!!! <br>   **                  in the case that our object is launched because <br>   **                  a linking client calls IOleObject::Update on <br>   **                  its link, then our object will be run <br>   **                  invisibly, typically GetData will be called, <br>   **                  and then the connection from the linking client <br>   **                  will be released. the release of this last <br>   **                  linking connection should cause our object to <br>   **                  shut down. <br>   **                  there are 2 strategies to deal with this scenario: <br>   ** <br>   **                  STRATEGY 1 -- implement IExternalConnection. <br>   **                  IExternalConnection::AddConnection will be <br>   **                  called (by the StubManager) every time that an <br>   **                  external (linking) connection is created or <br>   **                  CoLockObjectExternal is called. the object <br>   **                  should maintain a count of strong connections <br>   **                  (m_dwStrongExtConn). IExternalConnection:: <br>   **                  ReleaseConnection will be called when these <br>   **                  connections are released. when the <br>   **                  m_dwStrongExtConn transistions to 0, the object <br>   **                  should call its IOleObject::Close function. <br>   **                  this assumes that CoLockObjectExternal is used <br>   **                  to manage locks by the object itself (eg. when <br>   **                  the object is visible to the user--fUserCtrl, <br>   **                  and when PseudoObjects are created, etc.) <br>   **                  this is the strategy implemented by SVROUTL. <br>   ** <br>   **                  STRATEGY 2 -- guard both the destructor <br>   **                  function and the Close function. if the <br>   **                  destructor is called directly without Close <br>   **                  first being called, then call Close before <br>   **                  proceeding with the destruction code. <br>   **                  previously SVROUTL was organized in this <br>   **                  manner. that old code is conditionaly compiled <br>   **                  away with "#ifdef OBSOLETE" below. this <br>   **                  method has the disadvantage that external <br>   **                  remoting is no longer possible by the time the <br>   **                  Close is called making it impossible for <br>   **                  the object to ask its container to save the <br>   **                  object if the object is dirty. this can result <br>   **                  in data loss. thus STRATEGY 1 is safer. <br>   **                  consider the scenario where an in-place <br>   **                  container UIDeactivates an object but does NOT <br>   **                  keep the object locked running (this is <br>   **                  required--see CntrLine_IPSite_OnInPlaceActivate <br>   **                  in cntrline.c), then, if a linking client binds <br>   **                  and unbinds from the object, the object will be <br>   **                  destroyed and will NOT have an opportunity to <br>   **                  be saved. by implementing IExternalConnection, <br>   **                  a server can insulate itself from a poorly <br>   **                  written container. <br>   */ <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz( <br>         (lpOutlineDoc-&gt;m_fDataTransferDoc || lpOleDoc-&gt;m_fObjIsClosing), <br>         "Destroy called without Close being called\r\n" <br>   ); <br>#endif  // _DEBUG <br>#if defined( OBSOLETE ) <br>   /* NOTE: if the document destructor is called directly because <br>   **    the object's refcnt went to 0 (ie. without OleDoc_Close first <br>   **    being called), then we need to make sure that the document is <br>   **    properly closed before destroying the object. this scenario <br>   **    could arise during a silent-update of a link. calling <br>   **    OleDoc_Close here guarantees that the clipboard will be <br>   **    properly flushed, the doc's moniker will be properly revoked, <br>   **    the document will be saved if necessary, etc. <br>   */ <br>   if (!lpOutlineDoc-&gt;m_fDataTransferDoc &amp;&amp; !lpOleDoc-&gt;m_fObjIsClosing) <br>      OleDoc_Close(lpOleDoc, OLECLOSE_NOSAVE); <br>#endif <br> <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      /* NOTE: perform processing specific for an OLE server */ <br> <br>#if defined( SVR_TREATAS ) <br>      if (lpServerDoc-&gt;m_lpszTreatAsType) { <br>         OleStdFreeString(lpServerDoc-&gt;m_lpszTreatAsType, NULL); <br>         lpServerDoc-&gt;m_lpszTreatAsType = NULL; <br>      } <br>#endif  // SVR_TREATAS <br> <br>#if defined( INPLACE_SVR ) <br>      if (IsWindow(lpServerDoc-&gt;m_hWndHatch)) <br>         DestroyWindow(lpServerDoc-&gt;m_hWndHatch); <br>#endif  // INPLACE_SVR <br>   } <br>#endif  // OLE_SERVER <br> <br>   if (lpOleDoc-&gt;m_lpLLStm) { <br>      /* release our LineList stream. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpLLStm); <br>      lpOleDoc-&gt;m_lpLLStm = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpNTStm) { <br>      /* release our NameTable stream. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpNTStm); <br>      lpOleDoc-&gt;m_lpNTStm = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpStg) { <br>      /* release our doc storage. */ <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg); <br>      lpOleDoc-&gt;m_lpStg = NULL; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpFileMoniker) { <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpFileMoniker); <br>      lpOleDoc-&gt;m_lpFileMoniker = NULL; <br>   } <br> <br>   /***************************************************************** <br>   ** NOTE: each document addref's the app object in order to  ** <br>   **    guarentee that the app does not shut down while the doc   ** <br>   **    is still open. since this doc is now destroyed, we will   ** <br>   **    release this refcnt now. if there are now more open       ** <br>   **    documents AND the app is not under the control of the     ** <br>   **    user (ie. launched by OLE) then the app will revoke its   ** <br>   **    ClassFactory. if there are no more references to the      ** <br>   **    ClassFactory after it is revoked, then the app will shut  ** <br>   **    down. this whole procedure is triggered by calling        ** <br>   **    OutlineApp_DocUnlockApp.                                  ** <br>   *****************************************************************/ <br> <br>   OutlineApp_DocUnlockApp(lpOutlineApp, lpOutlineDoc); <br>} <br> <br> <br>/* OleDoc_SetUpdateEditMenuFlag <br> * ---------------------------- <br> * <br> *  Purpose: <br> *      Set/clear the UpdateEditMenuFlag in OleDoc. <br> * <br> *  Parameters: <br> *      fUpdate     new value of the flag <br> * <br> *  Returns: <br> */ <br>void OleDoc_SetUpdateEditMenuFlag(LPOLEDOC lpOleDoc, BOOL fUpdate) <br>{ <br>   if (!lpOleDoc) <br>      return; <br> <br>   lpOleDoc-&gt;m_fUpdateEditMenu = fUpdate; <br>} <br> <br> <br>/* OleDoc_GetUpdateEditMenuFlag <br> * ---------------------------- <br> * <br> *  Purpose: <br> *      Get the value of the UpdateEditMenuFlag in OleDoc <br> * <br> *  Parameters: <br> * <br> *  Returns: <br> *      value of the flag <br> */ <br>BOOL OleDoc_GetUpdateEditMenuFlag(LPOLEDOC lpOleDoc) <br>{ <br>   if (!lpOleDoc) <br>      return FALSE; <br> <br>   return lpOleDoc-&gt;m_fUpdateEditMenu; <br>} <br> <br> <br> <br>/************************************************************************* <br>** OleDoc::IUnknown interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP OleDoc_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_Unk_AddRef(LPUNKNOWN lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IUnknown"); <br> <br>   return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_Unk_Release (LPUNKNOWN lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IUnknown"); <br> <br>   return OleDoc_Release(lpOleDoc); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
