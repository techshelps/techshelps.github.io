<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLINE.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context300"></a>OUTLINE.H</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outline.h <br>** <br>**    This file contains file contains data structure defintions, <br>**    function prototypes, constants, etc. used by the Outline series <br>**    of sample applications: <br>**          Outline  -- base version of the app (without OLE functionality) <br>**          SvrOutl  -- OLE 2.0 Server sample app <br>**          CntrOutl -- OLE 2.0 Containter (Container) sample app <br>**          ISvrOtl  -- OLE 2.0 Server sample app <br>**          CntrOutl -- OLE 2.0 Containter (Container) sample app <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>**    For structures which we read from and write to disk we define shadow <br>**    structures (with the _ONDISK suffix) that allow us to maintain <br>**    16-bit Windows and Macintosh compatibility. <br>** <br>*************************************************************************/ <br> <br>#if !defined( _OUTLINE_H_ ) <br>#define _OUTLINE_H_ <br> <br>#if !defined( RC_INVOKED ) <br>#pragma message ("INCLUDING OUTLINE.H from " __FILE__) <br>#endif  /* RC_INVOKED */ <br> <br>// use strict ANSI standard (for DVOBJ.H) <br>#define NONAMELESSUNION <br> <br>// use system defined bitmap, this line must go before windows.h <br>#define OEMRESOURCE <br> <br>#ifdef WIN32 <br>#define EXPORT <br> <br>#define _fstrchr strchr <br> <br>#else <br>#define EXPORT _export <br>#endif <br> <br>#define SDI_VERSION         1   // ONLY SDI version is currently supported <br> <br>#if defined( OLE_SERVER ) || defined( OLE_CNTR ) <br>#define OLE_VERSION         1 <br>#define USE_DRAGDROP        1   // enable drag/drop code in OLE versions <br>#define USE_MSGFILTER       1   // enable IMessageFilter implementation <br>#endif <br> <br>#define USE_HEADING         1   // enable the row/col headings <br>#define USE_STATUSBAR       1   // enable status bar window <br>#define USE_FRAMETOOLS      1   // enable the toolbar <br>#ifndef WIN32   //BUGBUG32 <br>#define USE_CTL3D           1   // enable 3D looking dialogs <br>#endif <br> <br>#define STRICT  1 <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;commdlg.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;olestd.h&gt; <br>#include "outlrc.h" <br> <br> <br>#define APPMAJORVERSIONNO   3   // major no. incremented for major releases <br>                        //  (eg. when an incompatible change is made <br>                        //  to the storage format) <br>#define APPMINORVERSIONNO   5   // minor no. incremented for minor releases <br> <br> <br>/* Definition of SCALEFACTOR */ <br>typedef struct tagSCALEFACTOR { <br>   ULONG       dwSxN;      // numerator in x direction <br>   ULONG       dwSxD;      // denominator in x direction <br>   ULONG       dwSyN;      // numerator in y direction <br>   ULONG       dwSyD;      // denominator in y direction <br>} SCALEFACTOR, FAR* LPSCALEFACTOR; <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br>#include "frametls.h" <br>#endif <br> <br>#if defined( USE_HEADING ) <br>#include "heading.h" <br>#endif <br> <br>/* max line height (in pixels) allowed in a listbox */ <br>#define LISTBOX_HEIGHT_LIMIT    255 <br> <br> <br>#define MAXSTRLEN   80      // max string len in bytes <br>#define MAXNAMESIZE 30      // max length of names <br>#define MAXFORMATSIZE   10  // max length of DEFDOCFORMAT (actually size is 5) <br>#define TABWIDTH        2000 // 2000 in Himetric units, i.e. 2cm <br>#define DEFFONTPTSIZE   12 <br>#define DEFFONTSIZE     ((DEFFONTPTSIZE*HIMETRIC_PER_INCH)/PTS_PER_INCH) <br>#define DEFFONTFACE     "Times New Roman" <br> <br>#ifdef WIN32S <br>#define OUTLINEDOCFORMAT    OLESTR("Outline32")     // CF_Outline format name <br>#else <br>#define OUTLINEDOCFORMAT    OLESTR("Outline")       // CF_Outline format name <br>#endif <br> <br>#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' ) <br>// REVIEW: some of these strings should be loaded from a resource file <br>#define UNTITLED    OLESTR("Outline")   // title used for untitled document <br>#define HITTESTDELTA    5 <br> <br>/* Macro to get a random integer within a specified range */ <br>#define getrandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min)) <br> <br> <br>// REVIEW: should load strings from string resource file <br>#ifdef TEST32 <br> <br>#define APPFILENAMEFILTER   "Outline Files (*.OLT)|*.olt|All files (*.*)|*.*|" <br>#define DEFEXTENSION    "olt"           // Default file extension <br> <br>#else <br> <br>#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|" <br>#define DEFEXTENSION    "oln"           // Default file extension <br> <br>#endif //TEST32 <br> <br>/* forward type references */ <br>typedef struct tagOUTLINEDOC FAR* LPOUTLINEDOC; <br>typedef struct tagTEXTLINE FAR* LPTEXTLINE; <br> <br> <br>typedef enum tagLINETYPE { <br>   UNKNOWNLINETYPE, <br>   TEXTLINETYPE, <br>   CONTAINERLINETYPE <br>} LINETYPE; <br> <br> <br>/************************************************************************* <br>** class LINE <br>**    The class LINE is an abstract base class. Instances of class LINE <br>**    are NOT created; only instances of the concrete subclasses of <br>**    LINE can be created. In the base app version and the OLE 2.0 <br>**    server-only version only TEXTLINE objects can be created. In the <br>**    OLE 2.0 client app version either TEXTLINE objects or CONTAINERLINE <br>**    objects can be created. The LINE class has all fields and methods <br>**    that are common independent of which subclass of LINE is used. <br>**    Each LINE object that is created in added to the LINELIST of the <br>**    OUTLINEDOC document. <br>*************************************************************************/ <br> <br>typedef struct tagLINE { <br>   LINETYPE    m_lineType; <br>   UINT        m_nTabLevel; <br>   UINT        m_nTabWidthInHimetric; <br>   UINT        m_nWidthInHimetric; <br>   UINT        m_nHeightInHimetric; <br>   BOOL        m_fSelected;        // does line have selection feedback <br> <br>#if defined( USE_DRAGDROP ) <br>   BOOL        m_fDragOverLine;    // does line have drop target feedback <br>#endif <br>} LINE, FAR* LPLINE; <br> <br>/* Line methods (functions) */ <br>void Line_Init(LPLINE lpLine, int nTab, HDC hDC); <br>void Line_Delete(LPLINE lpLine); <br>BOOL Line_CopyToDoc(LPLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex); <br>BOOL Line_Edit(LPLINE lpLine, HWND hWndDoc, HDC hDC); <br>void Line_Draw( <br>      LPLINE      lpLine, <br>      HDC         hDC, <br>      LPRECT      lpRect, <br>      LPRECT      lpRectWBounds, <br>      BOOL        fHighlight <br>); <br>void Line_DrawToScreen( <br>      LPLINE      lpLine, <br>      HDC         hDC, <br>      LPRECT      lprcPix, <br>      UINT        itemAction, <br>      UINT        itemState, <br>      LPRECT      lprcDevice <br>); <br>void Line_DrawSelHilight(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState); <br>void Line_DrawFocusRect(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState); <br>void Line_Unindent(LPLINE lpLine, HDC hDC); <br>void Line_Indent(LPLINE lpLine, HDC hDC); <br>LINETYPE Line_GetLineType(LPLINE lpLine); <br>UINT Line_GetTotalWidthInHimetric(LPLINE lpLine); <br>void Line_SetWidthInHimetric(LPLINE lpLine, int nWidth); <br>UINT Line_GetWidthInHimetric(LPLINE lpLine); <br>UINT Line_GetHeightInHimetric(LPLINE lpLine); <br>void Line_SetHeightInHimetric(LPLINE lpLine, int nHeight); <br>UINT Line_GetTabLevel(LPLINE lpLine); <br>int Line_GetTextLen(LPLINE lpLine); <br>void Line_GetTextData(LPLINE lpLine, LPOLESTR lpszBuf); <br>BOOL Line_GetOutlineData(LPLINE lpLine, LPTEXTLINE lpBuf); <br>int Line_CalcTabWidthInHimetric(LPLINE lpLine, HDC hDC); <br>BOOL Line_SaveToStg(LPLINE lpLine, UINT uFormat, LPSTORAGE lpSrcStg, LPSTORAGE lpDestStg, LPSTREAM lpLLStm, BOOL fRemember); <br>LPLINE Line_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc); <br>void Line_DrawDragFeedback(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemState ); <br>BOOL Line_IsSelected(LPLINE lpLine); <br> <br> <br>/************************************************************************* <br>** class TEXTLINE : LINE <br>**    The class TEXTLINE is a concrete subclass of the abstract base <br>**    class LINE. The TEXTLINE class holds a string that can be edited <br>**    by the user. In the base app version and the OLE 2.0 <br>**    server-only version only TEXTLINE objects can be created. In the <br>**    OLE 2.0 client app version either TEXTLINE objects or CONTAINERLINE <br>**    objects can be created. The TEXTLINE class inherits all fields <br>**    from the LINE class. This inheritance is achieved by including a <br>**    member variable of type LINE as the first field in the TEXTLINE <br>**    structure. Thus a pointer to a TEXTLINE object can be cast to be <br>**    a pointer to a LINE object. <br>**    Each TEXTLINE object that is created in added to the LINELIST of <br>**    the associated OUTLINEDOC document. <br>*************************************************************************/ <br> <br>typedef struct tagTEXTLINE { <br>   LINE m_Line;        // TextLine inherits all fields of Line <br> <br>   UINT m_nLength; <br>   char m_szText[MAXSTRLEN+1]; <br>} TEXTLINE; <br> <br>LPTEXTLINE TextLine_Create(HDC hDC, UINT nTab, LPSTR szText); <br>void TextLine_Init(LPTEXTLINE lpTextLine, int nTab, HDC hDC); <br>void TextLine_CalcExtents(LPTEXTLINE lpLine, HDC hDC); <br>void TextLine_SetHeightInHimetric(LPTEXTLINE lpTextLine, int nHeight); <br>void TextLine_Delete(LPTEXTLINE lpLine); <br>BOOL TextLine_Edit(LPTEXTLINE lpLine, HWND hWndDoc, HDC hDC); <br>void TextLine_Draw( <br>      LPTEXTLINE  lpTextLine, <br>      HDC         hDC, <br>      LPRECT      lpRect, <br>      LPRECT      lpRectWBounds, <br>      BOOL        fHighlight <br>); <br>void TextLine_DrawSelHilight(LPTEXTLINE lpTextLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState); <br>BOOL TextLine_Copy(LPTEXTLINE lpSrcLine, LPTEXTLINE lpDestLine); <br>BOOL TextLine_CopyToDoc(LPTEXTLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex); <br>int TextLine_GetTextLen(LPTEXTLINE lpTextLine); <br>void TextLine_GetTextData(LPTEXTLINE lpTextLine, LPSTR lpszBuf); <br>BOOL TextLine_GetOutlineData(LPTEXTLINE lpTextLine, LPTEXTLINE lpBuf); <br>BOOL TextLine_SaveToStm(LPTEXTLINE lpLine, LPSTREAM lpLLStm); <br>LPLINE TextLine_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc); <br> <br> <br> <br>/************************************************************************* <br>** class LINERANGE <br>**    The class LINERANGE is a supporting object used to describe a <br>**    particular range in an OUTLINEDOC. A range is defined by a starting <br>**    line index and an ending line index. <br>*************************************************************************/ <br> <br>typedef struct tagLINERANGE { <br>   signed short    m_nStartLine; <br>   signed short    m_nEndLine; <br>} LINERANGE, FAR* LPLINERANGE; <br> <br> <br>/************************************************************************* <br>** class OUTLINENAME <br>**    The class OUTLINENAME stores a particular named selection in the <br>**    OUTLINEDOC document. The NAMETABLE class holds all of the names <br>**    defined in a particular OUTLINEDOC document. Each OUTLINENAME <br>**    object has a string as its key and a starting line index and an <br>**    ending line index for the named range. <br>*************************************************************************/ <br> <br>typedef struct tagOUTLINENAME { <br>   OLECHAR         m_szName[MAXNAMESIZE+1]; <br>   signed short    m_nStartLine;  // must be signed for table update <br>   signed short    m_nEndLine;    // functions to work <br>} OUTLINENAME, FAR* LPOUTLINENAME; <br> <br>void OutlineName_SetName(LPOUTLINENAME lpOutlineName, LPOLESTR lpszName); <br>void OutlineName_SetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, BOOL fRangeModified); <br>void OutlineName_GetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel); <br>BOOL OutlineName_SaveToStg(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, UINT uFormat, LPSTREAM lpNTStm, BOOL FAR* lpfNameSaved); <br> <br>BOOL OutlineName_SaveToStg(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, UINT uFormat, LPSTREAM lpNTStm, BOOL FAR* lpfNameSaved); <br>BOOL OutlineName_LoadFromStg(LPOUTLINENAME lpOutlineName, LPSTREAM lpNTStm); <br> <br> <br>/************************************************************************* <br>** class OUTLINENAMETABLE <br>**    OUTLINENAMETABLE manages the table of named selections in the <br>**    OUTLINEDOC document. Each OUTLINENAMETABLE entry has a string as its key <br>**    and a starting line index and an ending line index for the <br>**    named range. There is always one instance of OUTLINENAMETABLE for each <br>**    OUTLINEDOC created. <br>*************************************************************************/ <br> <br>typedef struct tagOUTLINENAMETABLE { <br>   HWND        m_hWndListBox; <br>   int         m_nCount; <br>} OUTLINENAMETABLE, FAR* LPOUTLINENAMETABLE; <br> <br>/* OutlineNameTable methods (functions) */ <br>BOOL OutlineNameTable_Init(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINEDOC lpOutlineDoc); <br>void OutlineNameTable_Destroy(LPOUTLINENAMETABLE lpOutlineNameTable); <br>void OutlineNameTable_ClearAll(LPOUTLINENAMETABLE lpOutlineNameTable); <br>LPOUTLINENAME OutlineNameTable_CreateName(LPOUTLINENAMETABLE lpOutlineNameTable); <br>void OutlineNameTable_AddName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName); <br>void OutlineNameTable_DeleteName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex); <br>int OutlineNameTable_GetNameIndex(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName); <br>LPOUTLINENAME OutlineNameTable_GetName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex); <br>LPOUTLINENAME OutlineNameTable_FindName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOLESTR lpszName); <br>LPOUTLINENAME OutlineNameTable_FindNamedRange(LPOUTLINENAMETABLE lpOutlineNameTable, LPLINERANGE lplrSel); <br>int OutlineNameTable_GetCount(LPOUTLINENAMETABLE lpOutlineNameTable); <br>void OutlineNameTable_AddLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nAddIndex); <br>void OutlineNameTable_DeleteLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nDeleteIndex); <br>BOOL OutlineNameTable_LoadFromStg(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTORAGE lpSrcStg); <br>BOOL OutlineNameTable_SaveSelToStg( <br>      LPOUTLINENAMETABLE      lpOutlineNameTable, <br>      LPLINERANGE             lplrSel, <br>      UINT                    uFormat, <br>      LPSTREAM                lpNTStm <br>); <br> <br> <br>/************************************************************************* <br>** class LINELIST <br>**    The class LINELIST manages the list of Line objects in the <br>**    OUTLINEDOC document. This class uses a Window's Owner-draw ListBox <br>**    to hold the list of LINE objects. There is always one instance of <br>**    LINELIST for each OUTLINEDOC created. <br>*************************************************************************/ <br> <br>typedef struct tagLINELIST { <br>   HWND            m_hWndListBox;  // hWnd of OwnerDraw listbox <br>   int             m_nNumLines;        // number of lines in LineList <br>   int             m_nMaxLineWidthInHimetric;  // max width of listbox <br>   LPOUTLINEDOC    m_lpDoc;        // ptr to associated OutlineDoc <br>   LINERANGE       m_lrSaveSel;    // selection saved on WM_KILLFOCUS <br> <br>#if defined( USE_DRAGDROP ) <br>   int             m_iDragOverLine;    // line index w/ drop target feedback <br>#endif <br>} LINELIST, FAR* LPLINELIST; <br> <br>/* LineList methods (functions) */ <br>BOOL LineList_Init(LPLINELIST lpLL, LPOUTLINEDOC lpOutlineDoc); <br>void LineList_Destroy(LPLINELIST lpLL); <br>void LineList_AddLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex); <br>void LineList_DeleteLine(LPLINELIST lpLL, int nIndex); <br>void LineList_ReplaceLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex); <br>int LineList_GetLineIndex(LPLINELIST lpLL, LPLINE lpLine); <br>LPLINE LineList_GetLine(LPLINELIST lpLL, int nIndex); <br>void LineList_SetFocusLine ( LPLINELIST lpLL, WORD wIndex ); <br>BOOL LineList_GetLineRect(LPLINELIST lpLL, int nIndex, LPRECT lpRect); <br>int LineList_GetFocusLineIndex(LPLINELIST lpLL); <br>int LineList_GetCount(LPLINELIST lpLL); <br>BOOL LineList_SetMaxLineWidthInHimetric( <br>      LPLINELIST lpLL, <br>      int nWidthInHimetric <br>); <br>void LineList_ScrollLineIntoView(LPLINELIST lpLL, int nIndex); <br>int LineList_GetMaxLineWidthInHimetric(LPLINELIST lpLL); <br>BOOL LineList_RecalcMaxLineWidthInHimetric( <br>      LPLINELIST          lpLL, <br>      int                 nWidthInHimetric <br>); <br>void LineList_CalcSelExtentInHimetric( <br>      LPLINELIST          lpLL, <br>      LPLINERANGE         lplrSel, <br>      LPSIZEL             lpsizel <br>); <br>HWND LineList_GetWindow(LPLINELIST lpLL); <br>HDC LineList_GetDC(LPLINELIST lpLL); <br>void LineList_ReleaseDC(LPLINELIST lpLL, HDC hDC); <br>void LineList_SetLineHeight(LPLINELIST lpLL,int nIndex,int nHeightInHimetric); <br>void LineList_ReScale(LPLINELIST lpLL, LPSCALEFACTOR lpscale); <br>void LineList_SetSel(LPLINELIST lpLL, LPLINERANGE lplrSel); <br>int LineList_GetSel(LPLINELIST lpLL, LPLINERANGE lplrSel); <br>void LineList_RemoveSel(LPLINELIST lpLL); <br>void LineList_RestoreSel(LPLINELIST lpLL); <br>void LineList_SetRedraw(LPLINELIST lpLL, BOOL fEnableDraw); <br>void LineList_ForceRedraw(LPLINELIST lpLL, BOOL fErase); <br>void LineList_ForceLineRedraw(LPLINELIST lpLL, int nIndex, BOOL fErase); <br>int LineList_CopySelToDoc( <br>      LPLINELIST              lpSrcLL, <br>      LPLINERANGE             lplrSel, <br>      LPOUTLINEDOC            lpDestDoc <br>); <br>BOOL LineList_SaveSelToStg( <br>      LPLINELIST              lpLL, <br>      LPLINERANGE             lplrSel, <br>      UINT                    uFormat, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTORAGE               lpDestStg, <br>      LPSTREAM                lpLLStm, <br>      BOOL                    fRemember <br>); <br>BOOL LineList_LoadFromStg( <br>      LPLINELIST              lpLL, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTREAM                lpLLStm <br>); <br> <br>#if defined( USE_DRAGDROP ) <br>void LineList_SetFocusLineFromPointl( LPLINELIST lpLL, POINTL pointl ); <br>void LineList_SetDragOverLineFromPointl ( LPLINELIST lpLL, POINTL pointl ); <br>void LineList_Scroll(LPLINELIST lpLL, DWORD dwScrollDir); <br>int LineList_GetLineIndexFromPointl(LPLINELIST lpLL, POINTL pointl); <br>void LineList_RestoreDragFeedback(LPLINELIST lpLL); <br>#endif <br> <br>LRESULT FAR PASCAL LineListWndProc( <br>   HWND   hWnd, <br>   UINT   Message, <br>   WPARAM wParam, <br>   LPARAM lParam <br>); <br> <br> <br>// Document initialization type <br>#define DOCTYPE_UNKNOWN     0   // new doc created but not yet initialized <br>#define DOCTYPE_NEW         1   // init from scratch (new doc) <br>#define DOCTYPE_FROMFILE    2   // init from a file (open doc) <br> <br> <br> <br>/************************************************************************* <br>** class OUTLINEDOC <br>**    There is one instance of the OutlineDoc class created per <br>**    document open in the app. The SDI version of the app supports one <br>**    OUTLINEDOC at a time. The MDI version of the app can manage <br>**    multiple documents at one time. <br>*************************************************************************/ <br> <br>/* Definition of OUTLINEDOC */ <br>typedef struct tagOUTLINEDOC { <br>   LINELIST    m_LineList;         // list of lines in the doc <br>   LPOUTLINENAMETABLE m_lpNameTable;   // table of names in the doc <br>   HWND        m_hWndDoc;          // client area window for the Doc <br>   int         m_docInitType;      // is doc new or loaded from a file? <br>   BOOL        m_fDataTransferDoc; // is doc created for copy | drag/drop <br>   CLIPFORMAT  m_cfSaveFormat;      // format used to save the doc <br>   OLECHAR     m_szFileName[256];  // associated file; "(Untitled)" if none <br>   LPOLESTR    m_lpszDocTitle;     // name of doc to appear in window title <br>   BOOL        m_fModified;        // is the doc dirty (needs to be saved)? <br>   UINT        m_nDisableDraw;     // enable/disable updating the display <br>   SCALEFACTOR m_scale;            // current scale factor of the doc <br>   int         m_nLeftMargin;      // left margin in Himetric <br>   int         m_nRightMargin;     // right margin in Himetric <br>   UINT        m_uCurrentZoom;     // cur. zoom (used for menu checking) <br>   UINT        m_uCurrentMargin;   // cur. margin (used for menu checking) <br>#if defined( USE_HEADING ) <br>   HEADING     m_heading; <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>   LPFRAMETOOLS m_lpFrameTools;    // ptr to frame tools used by this doc <br>#endif <br> <br>} OUTLINEDOC; <br> <br>/* OutlineDoc methods (functions) */ <br> <br>BOOL OutlineDoc_Init(LPOUTLINEDOC lpOutlineDoc, BOOL fDataTransferDoc); <br>BOOL OutlineDoc_InitNewFile(LPOUTLINEDOC lpOutlineDoc); <br>LPOUTLINENAMETABLE OutlineDoc_CreateNameTable(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_Destroy(LPOUTLINEDOC lpOutlineDoc); <br>BOOL OutlineDoc_Close(LPOUTLINEDOC lpOutlineDoc, DWORD dwSaveOption); <br>void OutlineDoc_ShowWindow(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_FrameWindowResized( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPRECT              lprcFrameRect, <br>      LPBORDERWIDTHS      lpFrameToolWidths <br>); <br> <br>void OutlineDoc_ClearCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_CutCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_CopyCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_ClearAllLines(LPOUTLINEDOC lpOutlineDoc); <br>LPOUTLINEDOC OutlineDoc_CreateDataTransferDoc(LPOUTLINEDOC lpSrcOutlineDoc); <br>void OutlineDoc_PasteCommand(LPOUTLINEDOC lpOutlineDoc); <br>int OutlineDoc_PasteOutlineData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hOutline, int nStartIndex); <br>int OutlineDoc_PasteTextData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hText, int nStartIndex); <br>void OutlineDoc_AddTextLineCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_AddTopLineCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                nHeightInHimetric <br>); <br>void OutlineDoc_EditLineCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_IndentCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_UnindentCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetLineHeightCommand(LPOUTLINEDOC lpDoc); <br>void OutlineDoc_SelectAllCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_DefineNameCommand(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_GotoNameCommand(LPOUTLINEDOC lpOutlineDoc); <br> <br>void OutlineDoc_Print(LPOUTLINEDOC lpOutlineDoc, HDC hDC); <br>BOOL OutlineDoc_SaveToFile(LPOUTLINEDOC lpOutlineDoc, LPCOLESTR lpszFileName, UINT uFormat, BOOL fRemember); <br>void OutlineDoc_AddLine(LPOUTLINEDOC lpOutlineDoc, LPLINE lpLine, int nIndex); <br>void OutlineDoc_DeleteLine(LPOUTLINEDOC lpOutlineDoc, int nIndex); <br>void OutlineDoc_AddName(LPOUTLINEDOC lpOutlineDoc, LPOUTLINENAME lpOutlineName); <br>void OutlineDoc_DeleteName(LPOUTLINEDOC lpOutlineDoc, int nIndex); <br>void OutlineDoc_Resize(LPOUTLINEDOC lpDoc, LPRECT lpRect); <br>LPOUTLINENAMETABLE OutlineDoc_GetNameTable(LPOUTLINEDOC lpOutlineDoc); <br>LPLINELIST OutlineDoc_GetLineList(LPOUTLINEDOC lpOutlineDoc); <br>int OutlineDoc_GetNameCount(LPOUTLINEDOC lpOutlineDoc); <br>int OutlineDoc_GetLineCount(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetTitle(LPOUTLINEDOC lpOutlineDoc, BOOL fMakeUpperCase); <br>BOOL OutlineDoc_CheckSaveChanges( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPDWORD             lpdwSaveOption <br>); <br>BOOL OutlineDoc_IsModified(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetModified(LPOUTLINEDOC lpOutlineDoc, BOOL fModified, BOOL fDataChanged, BOOL fSizeChanged); <br>void OutlineDoc_SetRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fEnableDraw); <br>BOOL OutlineDoc_LoadFromFile(LPOUTLINEDOC lpOutlineDoc, LPOLESTR szFileName); <br>BOOL OutlineDoc_SaveSelToStg( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPLINERANGE         lplrSel, <br>      UINT                uFormat, <br>      LPSTORAGE           lpDestStg, <br>      BOOL                fSameAsLoad, <br>      BOOL                fRemember <br>); <br>BOOL OutlineDoc_LoadFromStg(LPOUTLINEDOC lpOutlineDoc, LPSTORAGE lpSrcStg); <br>BOOL OutlineDoc_SetFileName(LPOUTLINEDOC lpOutlineDoc, LPOLESTR lpszFileName, LPSTORAGE lpNewStg); <br>HWND OutlineDoc_GetWindow(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel); <br>int OutlineDoc_GetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel); <br>void OutlineDoc_ForceRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fErase); <br>void OutlineDoc_RenderFormat(LPOUTLINEDOC lpOutlineDoc, UINT uFormat); <br>void OutlineDoc_RenderAllFormats(LPOUTLINEDOC lpOutlineDoc); <br>HGLOBAL OutlineDoc_GetOutlineData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel); <br>HGLOBAL OutlineDoc_GetTextData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel); <br>void OutlineDoc_DialogHelp(HWND hDlg, WPARAM wDlgID); <br>void OutlineDoc_SetCurrentZoomCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                uCurrentZoom <br>); <br>UINT OutlineDoc_GetCurrentZoomMenuCheck(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetScaleFactor( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPSCALEFACTOR       lpscale, <br>      LPRECT              lprcDoc <br>); <br>LPSCALEFACTOR OutlineDoc_GetScaleFactor(LPOUTLINEDOC lpDoc); <br>void OutlineDoc_SetCurrentMarginCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                uCurrentMargin <br>); <br>UINT OutlineDoc_GetCurrentMarginMenuCheck(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetMargin(LPOUTLINEDOC lpDoc, int nLeftMargin, int nRightMargin); <br>LONG OutlineDoc_GetMargin(LPOUTLINEDOC lpDoc); <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br>void OutlineDoc_AddFrameLevelTools(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_SetFormulaBarEditText( <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      LPLINE                  lpLine <br>); <br>void OutlineDoc_SetFormulaBarEditFocus( <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      BOOL                    fEditFocus <br>); <br>BOOL OutlineDoc_IsEditFocusInFormulaBar(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_UpdateFrameToolButtons(LPOUTLINEDOC lpOutlineDoc); <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( USE_HEADING ) <br>LPHEADING OutlineDoc_GetHeading(LPOUTLINEDOC lpOutlineDoc); <br>void OutlineDoc_ShowHeading(LPOUTLINEDOC lpOutlineDoc, BOOL fShow); <br>#endif  // USE_HEADING <br> <br>/************************************************************************* <br>** class OUTLINEAPP <br>**    There is one instance of the OUTLINEAPP class created per running <br>**    application instance. This object holds many fields that could <br>**    otherwise be organized as global variables. <br>*************************************************************************/ <br> <br>/* Definition of OUTLINEAPP */ <br>typedef struct tagOUTLINEAPP { <br>   HWND            m_hWndApp;        // top-level frame window for the App <br>   HMENU           m_hMenuApp;       // handle to frame level menu for App <br>   HACCEL          m_hAccelApp; <br>   HACCEL          m_hAccelFocusEdit;// Accelerator when Edit in Focus <br>   LPOUTLINEDOC    m_lpDoc;          // main SDI document visible to user <br>   LPOUTLINEDOC    m_lpClipboardDoc; // hidden doc for snapshot of copied sel <br>   HWND            m_hWndStatusBar;  // window for the status bar <br>   HCURSOR         m_hcursorSelCur;  // cursor used to select lines <br>   HINSTANCE       m_hInst; <br>   PRINTDLG        m_PrintDlg; <br>   HFONT           m_hStdFont;       // font used for TextLines <br>   UINT            m_cfOutline;      // clipboard format for Outline data <br>   HACCEL          m_hAccel; <br>   HWND            m_hWndAccelTarget; <br>   FARPROC         m_ListBoxWndProc; // orig listbox WndProc for subclassing <br> <br>#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR ) <br>   BORDERWIDTHS    m_FrameToolWidths;  // space required by frame-level tools <br>#endif  // USE_FRAMETOOLS || INPLACE_CNTR <br> <br>#if defined( USE_FRAMETOOLS ) <br>   FRAMETOOLS      m_frametools;     // frame tools (button &amp; formula bars) <br>#endif  // USE_FRAMETOOLS <br> <br>} OUTLINEAPP, FAR* LPOUTLINEAPP; <br> <br>/* OutlineApp methods (functions) */ <br>BOOL OutlineApp_InitApplication(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst); <br>BOOL OutlineApp_InitInstance(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst, int nCmdShow); <br>BOOL OutlineApp_ParseCmdLine(LPOUTLINEAPP lpOutlineApp, LPSTR lpszCmdLine, int nCmdShow); <br>void OutlineApp_Destroy(LPOUTLINEAPP lpOutlineApp); <br>LPOUTLINEDOC OutlineApp_CreateDoc( <br>      LPOUTLINEAPP    lpOutlineApp, <br>      BOOL            fDataTransferDoc <br>); <br>HWND OutlineApp_GetWindow(LPOUTLINEAPP lpOutlineApp); <br>HWND OutlineApp_GetFrameWindow(LPOUTLINEAPP lpOutlineApp); <br>HINSTANCE OutlineApp_GetInstance(LPOUTLINEAPP lpOutlineApp); <br>LPOUTLINENAME OutlineApp_CreateName(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_DocUnlockApp(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc); <br>void OutlineApp_InitMenu(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpDoc, HMENU hMenu); <br>void OutlineApp_GetFrameRect(LPOUTLINEAPP lpOutlineApp, LPRECT lprcFrameRect); <br>void OutlineApp_GetClientAreaRect( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPRECT              lprcClientAreaRect <br>); <br>void OutlineApp_GetStatusLineRect( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPRECT              lprcStatusLineRect <br>); <br>void OutlineApp_ResizeWindows(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_ResizeClientArea(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_AboutCommand(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_NewCommand(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_OpenCommand(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_PrintCommand(LPOUTLINEAPP lpOutlineApp); <br>BOOL OutlineApp_SaveCommand(LPOUTLINEAPP lpOutlineApp); <br>BOOL OutlineApp_SaveAsCommand(LPOUTLINEAPP lpOutlineApp); <br>BOOL OutlineApp_CloseAllDocsAndExitCommand( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      BOOL                fForceEndSession <br>); <br>void OutlineApp_DestroyWindow(LPOUTLINEAPP lpOutlineApp); <br> <br>#if defined( USE_FRAMETOOLS ) <br>void OutlineApp_SetBorderSpace( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPBORDERWIDTHS      lpBorderWidths <br>); <br>LPFRAMETOOLS OutlineApp_GetFrameTools(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_SetFormulaBarAccel( <br>      LPOUTLINEAPP            lpOutlineApp, <br>      BOOL                    fEditFocus <br>); <br>#endif  // USE_FRAMETOOLS <br> <br>void OutlineApp_SetStatusText(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszMessage); <br>LPOUTLINEDOC OutlineApp_GetActiveDoc(LPOUTLINEAPP lpOutlineApp); <br>HMENU OutlineApp_GetMenu(LPOUTLINEAPP lpOutlineApp); <br>HFONT OutlineApp_GetActiveFont(LPOUTLINEAPP lpOutlineApp); <br>HDC OutlineApp_GetPrinterDC(LPOUTLINEAPP lpApp); <br>void OutlineApp_PrinterSetupCommand(LPOUTLINEAPP lpOutlineApp); <br>void OutlineApp_ErrorMessage(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszMsg); <br>void OutlineApp_GetAppVersionNo(LPOUTLINEAPP lpOutlineApp, int narrAppVersionNo[]); <br>void OutlineApp_GetAppName(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszAppName); <br>BOOL OutlineApp_VersionNoCheck(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszAppName, int narrAppVersionNo[]); </code></pre>
<p>
</p>
<pre><code>void OutlineApp_SetEditText(LPOUTLINEAPP lpApp); <br>void OutlineApp_SetFocusEdit(LPOUTLINEAPP lpApp, BOOL bFocusEdit); <br>BOOL OutlineApp_GetFocusEdit(LPOUTLINEAPP lpApp); <br>void OutlineApp_ForceRedraw(LPOUTLINEAPP lpOutlineApp, BOOL fErase); <br> <br>/* struct definition for persistant data storage of OutlineDoc data */ <br> <br>#pragma pack(push, 2) <br>typedef struct tagOUTLINEDOCHEADER_ONDISK { <br>        OLECHAR     m_szFormatName[32]; <br>        short       m_narrAppVersionNo[2]; <br>        USHORT      m_fShowHeading; <br>        DWORD       m_reserved1;            // space reserved for future use <br>        DWORD       m_reserved2;            // space reserved for future use <br>        DWORD       m_reserved3;            // space reserved for future use <br>        DWORD       m_reserved4;            // space reserved for future use <br>} OUTLINEDOCHEADER_ONDISK, FAR* LPOUTLINEDOCHEADER_ONDISK; <br>#pragma pack(pop) <br> <br>typedef struct tagOUTLINEDOCHEADER { <br>   OLECHAR     m_szFormatName[32]; <br>   int         m_narrAppVersionNo[2]; <br>   BOOL        m_fShowHeading; <br>   DWORD       m_reserved1;            // space reserved for future use <br>   DWORD       m_reserved2;            // space reserved for future use <br>   DWORD       m_reserved3;            // space reserved for future use <br>   DWORD       m_reserved4;            // space reserved for future use <br>} OUTLINEDOCHEADER, FAR* LPOUTLINEDOCHEADER; <br> <br>#pragma pack(push,2) <br>typedef struct tagLINELISTHEADER_ONDISK { <br>        USHORT      m_nNumLines; <br>        DWORD       m_reserved1;            // space reserved for future use <br>        DWORD       m_reserved2;            // space reserved for future use <br>} LINELISTHEADER_ONDISK, FAR* LPLINELISTHEADER_ONDISK; <br>#pragma pack(pop) <br> <br> <br>typedef struct tagLINELISTHEADER { <br>   int         m_nNumLines; <br>   DWORD       m_reserved1;            // space reserved for future use <br>   DWORD       m_reserved2;            // space reserved for future use <br>} LINELISTHEADER, FAR* LPLINELISTHEADER; <br> <br>#pragma pack(push,2) <br>typedef struct tagLINERECORD_ONDISK { <br>        USHORT      m_lineType; <br>        USHORT      m_nTabLevel; <br>        USHORT      m_nTabWidthInHimetric; <br>        USHORT      m_nWidthInHimetric; <br>        USHORT      m_nHeightInHimetric; <br>        DWORD       m_reserved;         // space reserved for future use <br>} LINERECORD_ONDISK, FAR* LPLINERECORD_ONDISK; <br>#pragma pack(pop) <br> <br>typedef struct tagLINERECORD { <br>   LINETYPE    m_lineType; <br>   UINT        m_nTabLevel; <br>   UINT        m_nTabWidthInHimetric; <br>   UINT        m_nWidthInHimetric; <br>   UINT        m_nHeightInHimetric; <br>   DWORD       m_reserved;         // space reserved for future use <br>} LINERECORD, FAR* LPLINERECORD; <br> <br> <br>/* Function prototypes in main.c */ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                  LPSTR lpszCmdLine, int nCmdShow); <br>BOOL MyTranslateAccelerator(LPMSG lpmsg); <br>int GetAccelItemCount(HACCEL hAccel); <br> <br>LRESULT CALLBACK EXPORT AppWndProc(HWND hWnd, UINT Message, WPARAM wParam, <br>                  LPARAM lParam); <br>LRESULT CALLBACK EXPORT DocWndProc(HWND hWnd, UINT Message, WPARAM wParam, <br>                  LPARAM lParam); <br> <br>/* Function prototypes in outldlgs.c */ <br>BOOL InputTextDlg(HWND hWnd, LPSTR lpszText, LPSTR lpszDlgTitle); <br>BOOL CALLBACK EXPORT AddEditDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL CALLBACK EXPORT SetLineHeightDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam); <br>BOOL CALLBACK EXPORT DefineNameDlgProc(HWND, UINT, WPARAM, LPARAM); <br>BOOL CALLBACK EXPORT GotoNameDlgProc(HWND, UINT, WPARAM, LPARAM); <br>void NameDlg_LoadComboBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hCombo); <br>void NameDlg_LoadListBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hListBox); <br>void NameDlg_AddName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, LPOLESTR lpszName, LPLINERANGE lplrSel); <br>void NameDlg_UpdateName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, int nIndex, LPOLESTR lpszName, LPLINERANGE lplrSel); <br>void NameDlg_DeleteName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, UINT nIndex); <br>BOOL CALLBACK EXPORT AboutDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam); <br> <br>/* Function prototypes in outldata.c */ <br>LPVOID New(DWORD lSize); <br>void Delete(LPVOID p); <br> <br>/* Function prototypes in outlprnt.c */ <br>BOOL CALLBACK EXPORT AbortProc (HDC hdc, WORD reserved); <br>BOOL CALLBACK EXPORT PrintDlgProc(HWND hwnd, WORD msg, WORD wParam, LONG lParam); <br> <br>/* Function prototypes in debug.c */ <br>void SetDebugLevelCommand(void); <br>void TraceDebug(HWND, int); <br> <br>/************************************************************************* <br>** DEBUG ASSERTION ROUTINES <br>*************************************************************************/ <br> <br>#ifdef DBG <br>#include &lt;assert.h&gt; <br>#define FnAssert(lpstrExpr, lpstrMsg, lpstrFileName, iLine)     \ <br>        (_assert(lpstrMsg ? lpstrMsg : lpstrExpr,               \ <br>                 lpstrFileName,                                 \ <br>                 iLine), NOERROR) <br>#endif //DBG <br> <br>#if defined( OLE_VERSION ) <br>#include "oleoutl.h" <br> <br>#endif  // OLE_VERSION <br> <br> <br>#endif // _OUTLINE_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
