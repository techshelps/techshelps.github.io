<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLDOC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context298"></a>OUTLDOC.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outldoc.c <br>** <br>**    This file contains OutlineDoc functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>#if !defined( OLE_VERSION ) <br>#include &lt;commdlg.h&gt; <br>#endif <br> <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br>#ifdef WIN32S <br>#define GALLOCFLG (GMEM_SHARE | GMEM_ZEROINIT | GMEM_MOVEABLE) <br>#else <br>#define GALLOCFLG (GMEM_SHARE | GMEM_ZEROINIT) <br>#endif <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR ErrMsgDocWnd[] = OLESTR("Can't create Document Window!"); <br>OLECHAR ErrMsgFormatNotSupported[] = OLESTR("Clipboard format not supported!"); <br>OLECHAR MsgSaveFile[] = OLESTR("Save existing file ?"); <br>OLECHAR ErrMsgSaving[] = OLESTR("Error in saving file!"); <br>OLECHAR ErrMsgOpening[] = OLESTR("Error in opening file!"); <br>OLECHAR ErrMsgFormat[] = OLESTR("Improper file format!"); <br>OLECHAR ErrOutOfMemory[] = OLESTR("Error: out of memory!"); <br>static OLECHAR ErrMsgPrint[] = OLESTR("Printing Error!"); <br> <br>static BOOL fCancelPrint;    // TRUE if the user has canceled the print job <br>static HWND hWndPDlg;       // Handle to the cancel print dialog <br> <br> <br>/* OutlineDoc_Init <br> * --------------- <br> * <br> *  Initialize the fields of a new OutlineDoc object. The object is initially <br> *  not associated with a file or an (Untitled) document. This function sets <br> *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the <br> *  caller should call: <br> *      1. OutlineDoc_InitNewFile to set the OutlineDoc to (Untitled) <br> *      2. OutlineDoc_LoadFromFile to associate the OutlineDoc with a file. <br> *  This function creates a new window for the document. <br> * <br> *  NOTE: the window is initially created with a NIL size. it must be <br> *        sized and positioned by the caller. also the document is initially <br> *        created invisible. the caller must call OutlineDoc_ShowWindow <br> *        after sizing it to make the document window visible. <br> */ <br>BOOL OutlineDoc_Init(LPOUTLINEDOC lpOutlineDoc, BOOL fDataTransferDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>#if defined( INPLACE_CNTR ) <br>   lpOutlineDoc-&gt;m_hWndDoc = CreateWindow( <br>               DOCWNDCLASS,            // Window class name <br>               NULL,                   // Window's title <br> <br>               /* NOTE: an in-place contanier MUST use <br>               **    WS_CLIPCHILDREN window style for the window <br>               **    that it uses as the parent for the server's <br>               **    in-place active window so that its <br>               **    painting does NOT interfere with the painting <br>               **    of the server's in-place active child window. <br>               */ <br> <br>               WS_CLIPCHILDREN | WS_CLIPSIBLINGS | <br>               WS_CHILDWINDOW, <br>               0, 0, <br>               0, 0, <br>               lpOutlineApp-&gt;m_hWndApp,// Parent window's handle <br>               (HMENU)1,               // child window id <br>               lpOutlineApp-&gt;m_hInst,  // Instance of window <br>               NULL);                  // Create struct for WM_CREATE <br> <br>#else <br> <br>   lpOutlineDoc-&gt;m_hWndDoc = CreateWindow( <br>               DOCWNDCLASS,            // Window class name <br>               NULL,                   // Window's title <br>               WS_CHILDWINDOW, <br>               0, 0, <br>               0, 0, <br>               lpOutlineApp-&gt;m_hWndApp,// Parent window's handle <br>               (HMENU)1,               // child window id <br>               lpOutlineApp-&gt;m_hInst,  // Instance of window <br>               NULL);                  // Create struct for WM_CREATE <br>#endif <br> <br>   if(! lpOutlineDoc-&gt;m_hWndDoc) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgDocWnd); <br>      return FALSE; <br>   } <br> <br>   SetWindowLong(lpOutlineDoc-&gt;m_hWndDoc, 0, (LONG) lpOutlineDoc); <br> <br>   if (! LineList_Init(&amp;lpOutlineDoc-&gt;m_LineList, lpOutlineDoc)) <br>      return FALSE; <br> <br>   lpOutlineDoc-&gt;m_lpNameTable = OutlineDoc_CreateNameTable(lpOutlineDoc); <br>   if (! lpOutlineDoc-&gt;m_lpNameTable ) <br>      return FALSE; <br> <br>   lpOutlineDoc-&gt;m_docInitType = DOCTYPE_UNKNOWN; <br>   lpOutlineDoc-&gt;m_cfSaveFormat = lpOutlineApp-&gt;m_cfOutline; <br>   lpOutlineDoc-&gt;m_szFileName[0] = '\0'; <br>   lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>   lpOutlineDoc-&gt;m_fDataTransferDoc = fDataTransferDoc; <br>   lpOutlineDoc-&gt;m_uCurrentZoom = IDM_V_ZOOM_100; <br>   lpOutlineDoc-&gt;m_scale.dwSxN  = (DWORD) 1; <br>   lpOutlineDoc-&gt;m_scale.dwSxD  = (DWORD) 1; <br>   lpOutlineDoc-&gt;m_scale.dwSyN  = (DWORD) 1; <br>   lpOutlineDoc-&gt;m_scale.dwSyD  = (DWORD) 1; <br>   lpOutlineDoc-&gt;m_uCurrentMargin = IDM_V_SETMARGIN_0; <br>   lpOutlineDoc-&gt;m_nLeftMargin  = 0; <br>   lpOutlineDoc-&gt;m_nRightMargin = 0; <br>   lpOutlineDoc-&gt;m_nDisableDraw = 0; <br>   OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE); <br> <br>#if defined( USE_HEADING ) <br>   if (! fDataTransferDoc) { <br>      if (!Heading_Create((LPHEADING)&amp;lpOutlineDoc-&gt;m_heading, <br>            lpOutlineDoc-&gt;m_hWndDoc, lpOutlineApp-&gt;m_hInst)) { <br>         return FALSE; <br> <br>      } <br>   } <br>#endif  // USE_HEADING <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (! fDataTransferDoc) { <br>      lpOutlineDoc-&gt;m_lpFrameTools = OutlineApp_GetFrameTools(lpOutlineApp); <br>      FrameTools_AssociateDoc( <br>            lpOutlineDoc-&gt;m_lpFrameTools, <br>            lpOutlineDoc <br>      ); <br>   } <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: perform initialization required for OLE */ <br>   if (! OleDoc_Init((LPOLEDOC)lpOutlineDoc, fDataTransferDoc)) <br>      return FALSE; <br>#endif  // OLE_VERSION <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineDoc_InitNewFile <br> * ---------------------- <br> * <br> *  Initialize the OutlineDoc object to be a new (Untitled) document. <br> *  This function sets the docInitType to DOCTYPE_NEW. <br> */ <br>BOOL OutlineDoc_InitNewFile(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>#if defined( OLE_VERSION ) <br>   // NOTE: call OLE version of this function instead <br>   return OleDoc_InitNewFile((LPOLEDOC)lpOutlineDoc); <br> <br>#else <br> <br>   OleDbgAssert(lpOutlineDoc-&gt;m_docInitType == DOCTYPE_UNKNOWN); <br> <br>   // set file name to untitled <br>   // REVIEW: should load from string resource <br>   lstrcpyW(lpOutlineDoc-&gt;m_szFileName, UNTITLED); <br>   lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>   lpOutlineDoc-&gt;m_docInitType = DOCTYPE_NEW; <br> <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/); <br> <br>   return TRUE; <br> <br>#endif      // BASE OUTLINE VERSION <br>} <br> <br> <br>/* OutlineDoc_CreateNameTable <br> * -------------------------- <br> * <br> * Allocate a new NameTable of the appropriate type. Each document has <br> * a NameTable and a LineList. <br> *  OutlineDoc --&gt; creates standard OutlineNameTable type name tables. <br> *  ServerDoc  --&gt; creates enhanced SeverNameTable type name tables. <br> * <br> *      Returns lpNameTable for successful, NULL if error. <br> */ <br>LPOUTLINENAMETABLE OutlineDoc_CreateNameTable(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable; <br> <br>   lpOutlineNameTable = (LPOUTLINENAMETABLE)New( <br>         (DWORD)sizeof(OUTLINENAMETABLE) <br>   ); <br> <br>   OleDbgAssertSz(lpOutlineNameTable != NULL,"Error allocating NameTable"); <br>   if (lpOutlineNameTable == NULL) <br>      return NULL; <br> <br>   // initialize new NameTable <br>   if (! OutlineNameTable_Init(lpOutlineNameTable, lpOutlineDoc) ) <br>      goto error; <br> <br>   return lpOutlineNameTable; <br> <br>error: <br>   if (lpOutlineNameTable) <br>      Delete(lpOutlineNameTable); <br>   return NULL; <br>} <br> <br> <br>/* OutlineDoc_ClearCommand <br> * ----------------------- <br> * <br> *      Delete selection in list box by calling OutlineDoc_Delete <br> */ <br>void OutlineDoc_ClearCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   int i; <br>   int nNumSel; <br>   LINERANGE lrSel; <br> <br>   nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br>   for(i = 0; i &lt; nNumSel; i++) <br>      OutlineDoc_DeleteLine(lpOutlineDoc, lrSel.m_nStartLine); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br> <br>   LineList_RecalcMaxLineWidthInHimetric(lpLL, 0); <br>} <br> <br> <br>/* OutlineDoc_CutCommand <br> * --------------------- <br> * <br> * Cut selection to clipboard <br> */ <br>void OutlineDoc_CutCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   OutlineDoc_CopyCommand(lpOutlineDoc); <br>   OutlineDoc_ClearCommand(lpOutlineDoc); <br>} <br> <br> <br>/* OutlineDoc_CopyCommand <br> * ---------------------- <br> *  Copy selection to clipboard. <br> *  Post to the clipboard the formats that the app can render. <br> *  the actual data is not rendered at this time. using the <br> *  delayed rendering technique, Windows will send the clipboard <br> *  owner window either a WM_RENDERALLFORMATS or a WM_RENDERFORMAT <br> *  message when the actual data is requested. <br> * <br> *    NOTE: the normal delayed rendering technique where Windows <br> *    sends the clipboard owner window either a WM_RENDERALLFORMATS or <br> *    a WM_RENDERFORMAT message when the actual data is requested is <br> *    NOT exposed to the app calling OleSetClipboard. OLE internally <br> *    creates its own window as the clipboard owner and thus our app <br> *    will NOT get these WM_RENDER messages. <br> */ <br>void OutlineDoc_CopyCommand(LPOUTLINEDOC lpSrcOutlineDoc) <br>{ <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   OleDoc_CopyCommand((LPOLEDOC)lpSrcOutlineDoc); <br> <br>#else <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpClipboardDoc; <br> <br>   OpenClipboard(lpSrcOutlineDoc-&gt;m_hWndDoc); <br>   EmptyClipboard(); <br> <br>   /* squirrel away a copy of the current selection to the ClipboardDoc */ <br>   lpClipboardDoc = OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc); <br> <br>   if (! lpClipboardDoc) <br>      return;     // Error: could not create DataTransferDoc <br> <br>   lpOutlineApp-&gt;m_lpClipboardDoc = (LPOUTLINEDOC)lpClipboardDoc; <br> <br>   SetClipboardData(lpOutlineApp-&gt;m_cfOutline, NULL); <br>   SetClipboardData(CF_TEXT, NULL); <br> <br>   CloseClipboard(); <br> <br>#endif  // ! OLE_VERSION <br>} <br> <br> <br>/* OutlineDoc_ClearAllLines <br> * ------------------------ <br> * <br> *      Delete all lines in the document. <br> */ <br>void OutlineDoc_ClearAllLines(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   int i; <br> <br>   for(i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) <br>      OutlineDoc_DeleteLine(lpOutlineDoc, 0); <br> <br>   LineList_RecalcMaxLineWidthInHimetric(lpLL, 0); <br>} <br> <br> <br>/* OutlineDoc_CreateDataTransferDoc <br> * -------------------------------- <br> * <br> *      Create a document to be use to transfer data (either via a <br> *  drag/drop operation of the clipboard). Copy the selection of the <br> *  source doc to the data transfer document. A data transfer document is <br> *  the same as a document that is created by the user except that it is <br> *  NOT made visible to the user. it is specially used to hold a copy of <br> *  data that the user should not be able to change. <br> * <br> *  NOTE: in the OLE version the data transfer document is used <br> *      specifically to provide an IDataObject* that renders the data copied. <br> */ <br>LPOUTLINEDOC OutlineDoc_CreateDataTransferDoc(LPOUTLINEDOC lpSrcOutlineDoc) <br>{ <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   return OleDoc_CreateDataTransferDoc((LPOLEDOC)lpSrcOutlineDoc); <br> <br>#else <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpDestOutlineDoc; <br>   LPLINELIST lpSrcLL = &amp;lpSrcOutlineDoc-&gt;m_LineList; <br>   LINERANGE lrSel; <br>   int nCopied; <br> <br>   lpDestOutlineDoc = OutlineApp_CreateDoc(lpOutlineApp, TRUE); <br>   if (! lpDestOutlineDoc) return NULL; <br> <br>   // set the ClipboardDoc to an (Untitled) doc. <br>   if (! OutlineDoc_InitNewFile(lpDestOutlineDoc)) <br>      goto error; <br> <br>   LineList_GetSel(lpSrcLL, (LPLINERANGE)&amp;lrSel); <br>   nCopied = LineList_CopySelToDoc( <br>         lpSrcLL, <br>         (LPLINERANGE)&amp;lrSel, <br>         lpDestOutlineDoc <br>   ); <br> <br>   return lpDestOutlineDoc; <br> <br>error: <br>   if (lpDestOutlineDoc) <br>      OutlineDoc_Destroy(lpDestOutlineDoc); <br> <br>   return NULL; <br> <br>#endif  // ! OLE_VERSION <br>} <br> <br> <br>/* OutlineDoc_PasteCommand <br> * ----------------------- <br> * <br> * Paste lines from clipboard <br> */ <br>void OutlineDoc_PasteCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   OleDoc_PasteCommand((LPOLEDOC)lpOutlineDoc); <br> <br>#else <br> <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST lpLL = (LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   int nIndex; <br>   int nCount; <br>   HGLOBAL hData; <br>   LINERANGE lrSel; <br>   UINT uFormat; <br> <br>   if (LineList_GetCount(lpLL) == 0) <br>      nIndex = -1;    // pasting to empty list <br>   else <br>      nIndex=LineList_GetFocusLineIndex(lpLL); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>   OpenClipboard(lpOutlineDoc-&gt;m_hWndDoc); <br> <br>   uFormat = 0; <br>   while(uFormat = EnumClipboardFormats(uFormat)) { <br>      if(uFormat == lpOutlineApp-&gt;m_cfOutline) { <br>         hData = GetClipboardData(lpOutlineApp-&gt;m_cfOutline); <br>         nCount = OutlineDoc_PasteOutlineData(lpOutlineDoc, hData, nIndex); <br>         break; <br>      } <br>      if(uFormat == CF_TEXT) { <br>         hData = GetClipboardData(CF_TEXT); <br>         nCount = OutlineDoc_PasteTextData(lpOutlineDoc, hData, nIndex); <br>         break; <br>      } <br>   } <br> <br>   lrSel.m_nStartLine = nIndex + nCount; <br>   lrSel.m_nEndLine = nIndex + 1; <br>   LineList_SetSel(lpLL, &amp;lrSel); <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br> <br>   CloseClipboard(); <br> <br>#endif      // ! OLE_VERSION <br>} <br> <br> <br>/* OutlineDoc_PasteOutlineData <br> * --------------------------- <br> * <br> *      Put an array of Line Objects (stored in hOutline) into the document <br> * <br> * Return the number of items added <br> */ <br>int OutlineDoc_PasteOutlineData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hOutline, int nStartIndex) <br>{ <br>   int nCount; <br>   int i; <br>   LPTEXTLINE arrLine; <br> <br>   nCount = (int) GlobalSize(hOutline) / sizeof(TEXTLINE); <br>   arrLine = (LPTEXTLINE)GlobalLock(hOutline); <br>   if (!arrLine) <br>      return 0; <br> <br>   for(i = 0; i &lt; nCount; i++) <br>      Line_CopyToDoc((LPLINE)&amp;arrLine[i], lpOutlineDoc, nStartIndex+i); <br> <br>   GlobalUnlock(hOutline); <br> <br>   return nCount; <br>} <br> <br> <br>/* OutlineDoc_PasteTextData <br> * ------------------------ <br> * <br> *      Build Line Objects from the strings (separated by '\n') in hText <br> * and put them into the document <br> */ <br>int OutlineDoc_PasteTextData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hText, int nStartIndex) <br>{ <br>   LPLINELIST  lpLL = (LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   HDC         hDC; <br>   LPSTR       lpszText; <br>   LPSTR       lpszEnd; <br>   LPTEXTLINE  lpLine; <br>   int         nLineCount; <br>   int         i; <br>   UINT        nTab; <br>   char        szBuf[MAXSTRLEN+1]; <br> <br>   lpszText=(LPSTR)GlobalLock(hText); <br>   if(!lpszText) <br>      return 0; <br> <br>   lpszEnd = lpszText + lstrlen(lpszText); <br>   nLineCount=0; <br> <br>   while(*lpszText &amp;&amp; (lpszText&lt;lpszEnd)) { <br> <br>      // count the tab level <br>      nTab = 0; <br>      while((*lpszText == '\t') &amp;&amp; (lpszText&lt;lpszEnd)) { <br>         nTab++; <br>         lpszText++; <br>      } <br> <br>      // collect the text string character by character <br>      for(i=0; (i&lt;MAXSTRLEN) &amp;&amp; (lpszText&lt;lpszEnd); i++) { <br>         if ((! *lpszText) || (*lpszText == '\n')) <br>            break; <br>         szBuf[i] = *lpszText++; <br>      } <br>      szBuf[i] = 0; <br>      lpszText++; <br>      if ((i &gt; 0) &amp;&amp; (szBuf[i-1] == '\r')) <br>         szBuf[i-1] = 0;     // remove carriage return at the end <br> <br>      hDC = LineList_GetDC(lpLL); <br>      lpLine = TextLine_Create(hDC, nTab, szBuf); <br>      LineList_ReleaseDC(lpLL, hDC); <br> <br>      OutlineDoc_AddLine( <br>            lpOutlineDoc, <br>            (LPLINE)lpLine, <br>            nStartIndex + nLineCount <br>      ); <br>      nLineCount++; <br> <br>   } <br> <br>   GlobalUnlock(hText); <br> <br>   return nLineCount; <br>} <br> <br> <br>/* OutlineDoc_AddTextLineCommand <br> * ----------------------------- <br> * <br> *      Add a new text line following the current focus line. <br> */ <br>void OutlineDoc_AddTextLineCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   HDC hDC; <br>   int nIndex = LineList_GetFocusLineIndex(lpLL); <br>   char szBuf[MAXSTRLEN+1]; <br>   UINT nTab = 0; <br>   LPLINE lpLine; <br>   LPTEXTLINE lpTextLine; <br> <br>   szBuf[0] = '\0'; <br> <br>#if defined( USE_FRAMETOOLS ) <br>   FrameTools_FB_GetEditText( <br>         lpOutlineDoc-&gt;m_lpFrameTools, szBuf, MAXSTRLEN+1); <br>#else <br>   if (! InputTextDlg(lpOutlineDoc-&gt;m_hWndDoc, szBuf, "Add Line")) <br>      return; <br>#endif <br> <br>   hDC = LineList_GetDC(lpLL); <br>   lpLine = LineList_GetLine(lpLL, nIndex); <br>   if (lpLine) <br>      nTab = Line_GetTabLevel(lpLine); <br> <br>   lpTextLine=TextLine_Create(hDC, nTab, szBuf); <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   if (! lpTextLine) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrOutOfMemory); <br>      return; <br>   } <br>   OutlineDoc_AddLine(lpOutlineDoc, (LPLINE)lpTextLine, nIndex); <br>} <br> <br> <br>/* OutlineDoc_AddTopLineCommand <br> * ---------------------------- <br> * <br> *      Add a top (margin) line as the first line in the LineList. <br> *      (do not change the current selection) <br> */ <br>void OutlineDoc_AddTopLineCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                nHeightInHimetric <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST  lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   HDC         hDC = LineList_GetDC(lpLL); <br>   LPTEXTLINE  lpTextLine = TextLine_Create(hDC, 0, NULL); <br>   LPLINE      lpLine = (LPLINE)lpTextLine; <br>   LINERANGE   lrSel; <br>   int         nNumSel; <br> <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   if (! lpTextLine) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrOutOfMemory); <br>      return; <br>   } <br> <br>   Line_SetHeightInHimetric(lpLine, nHeightInHimetric); <br> <br>   nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br>   if (nNumSel &gt; 0) { <br>      // adjust current selection to keep equivalent selection <br>      lrSel.m_nStartLine += 1; <br>      lrSel.m_nEndLine += 1; <br>   } <br>   OutlineDoc_AddLine(lpOutlineDoc, lpLine, -1); <br>   if (nNumSel &gt; 0) <br>      LineList_SetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br> <br>/* OutlineDoc_SetFormulaBarEditText <br> * -------------------------------- <br> * <br> *      Fill the edit control in the formula with the text string from a <br> * TextLine in focus. <br> */ <br>void OutlineDoc_SetFormulaBarEditText( <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      LPLINE                  lpLine <br>) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   char cBuf[MAXSTRLEN+1]; <br> <br>   if (! lpOutlineDoc || ! lpOutlineDoc-&gt;m_lpFrameTools) <br>      return; <br> <br>   if (Line_GetLineType(lpLine) != TEXTLINETYPE) { <br>      FrameTools_FB_SetEditText(lpOutlineDoc-&gt;m_lpFrameTools, NULL); <br>   } else { <br>      TextLine_GetTextData((LPTEXTLINE)lpLine, (LPSTR)cBuf); <br>      FrameTools_FB_SetEditText(lpOutlineDoc-&gt;m_lpFrameTools, (LPSTR)cBuf); <br>   } <br>} <br> <br> <br>/* OutlineDoc_SetFormulaBarEditFocus <br> * --------------------------------- <br> * <br> *  Setup for formula bar to gain or loose edit focus. <br> *  if gaining focus, setup up special accelerator table and scroll line <br> *      into view. <br> *  else restore normal accelerator table. <br> */ <br>void OutlineDoc_SetFormulaBarEditFocus( <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      BOOL                    fEditFocus <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST lpLL; <br>   int nFocusIndex; <br> <br>   if (! lpOutlineDoc || ! lpOutlineDoc-&gt;m_lpFrameTools) <br>      return; <br> <br>   lpOutlineDoc-&gt;m_lpFrameTools-&gt;m_fInFormulaBar = fEditFocus; <br> <br>   if (fEditFocus &amp;&amp; lpOutlineDoc-&gt;m_lpFrameTools) { <br>      lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br> <br>      nFocusIndex = LineList_GetFocusLineIndex(lpLL); <br>      LineList_ScrollLineIntoView(lpLL, nFocusIndex); <br>      FrameTools_FB_FocusEdit(lpOutlineDoc-&gt;m_lpFrameTools); <br>   } <br> <br>   OutlineApp_SetFormulaBarAccel(lpOutlineApp, fEditFocus); <br>} <br> <br> <br>/* OutlineDoc_IsEditFocusInFormulaBar <br>** ---------------------------------- <br>**    Returns TRUE if edit focus is currently in the formula bar <br>**    else FALSE if not. <br>*/ <br>BOOL OutlineDoc_IsEditFocusInFormulaBar(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (! lpOutlineDoc || ! lpOutlineDoc-&gt;m_lpFrameTools) <br>      return FALSE; <br> <br>   return lpOutlineDoc-&gt;m_lpFrameTools-&gt;m_fInFormulaBar; <br>} <br> <br> <br>/* OutlineDoc_UpdateFrameToolButtons <br>** --------------------------------- <br>**    Update the Enable/Disable states of the buttons in the formula <br>**    bar and button bar. <br>*/ <br>void OutlineDoc_UpdateFrameToolButtons(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (! lpOutlineDoc || ! lpOutlineDoc-&gt;m_lpFrameTools) <br>      return; <br>   FrameTools_UpdateButtons(lpOutlineDoc-&gt;m_lpFrameTools, lpOutlineDoc); <br>} <br>#endif  // USE_FRAMETOOLS <br> <br> <br>/* OutlineDoc_EditLineCommand <br> * -------------------------- <br> * <br> *      Edit the current focus line. <br> */ <br>void OutlineDoc_EditLineCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   HDC hDC = LineList_GetDC(lpLL); <br>   int nIndex = LineList_GetFocusLineIndex(lpLL); <br>   LPLINE lpLine = LineList_GetLine(lpLL, nIndex); <br>   int nOrgLineWidthInHimetric; <br>   int nNewLineWidthInHimetric; <br>   BOOL fSizeChanged; <br> <br>   if (!lpLine) <br>      return; <br> <br>   nOrgLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine); <br>   if (Line_Edit(lpLine, lpOutlineDoc-&gt;m_hWndDoc, hDC)) { <br>      nNewLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine); <br> <br>      if (nNewLineWidthInHimetric &gt; nOrgLineWidthInHimetric) { <br>         fSizeChanged = LineList_SetMaxLineWidthInHimetric( <br>               lpLL, <br>               nNewLineWidthInHimetric <br>            ); <br>      } else { <br>         fSizeChanged = LineList_RecalcMaxLineWidthInHimetric( <br>               lpLL, <br>               nOrgLineWidthInHimetric <br>            ); <br>      } <br> <br>#if defined( OLE_SERVER ) <br>      /* Update Name Table */ <br>      ServerNameTable_EditLineUpdate( <br>            (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable, <br>            nIndex <br>      ); <br>#endif <br> <br>      OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged); <br> <br>      LineList_ForceLineRedraw(lpLL, nIndex, TRUE); <br>   } <br>   LineList_ReleaseDC(lpLL, hDC); <br>} <br> <br> <br>/* OutlineDoc_IndentCommand <br> * ------------------------ <br> * <br> *      Indent selection of lines <br> */ <br>void OutlineDoc_IndentCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST  lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   LPLINE      lpLine; <br>   HDC         hDC = LineList_GetDC(lpLL); <br>   int         i; <br>   int         nIndex; <br>   int         nNumSel; <br>   LINERANGE   lrSel; <br>   BOOL        fSizeChanged = FALSE; <br> <br>   nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>   for(i = 0; i &lt; nNumSel; i++) { <br>      nIndex = lrSel.m_nStartLine + i; <br>      lpLine=LineList_GetLine(lpLL, nIndex); <br>      if (! lpLine) <br>         continue; <br> <br>      Line_Indent(lpLine, hDC); <br>      if (LineList_SetMaxLineWidthInHimetric(lpLL, <br>         Line_GetTotalWidthInHimetric(lpLine))) { <br>         fSizeChanged = TRUE; <br>      } <br>      LineList_ForceLineRedraw(lpLL, nIndex, TRUE); <br> <br>#if defined( OLE_SERVER ) <br>      /* Update Name Table */ <br>      ServerNameTable_EditLineUpdate( <br>            (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable, <br>            nIndex <br>      ); <br>#endif <br> <br>   } <br> <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged); <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br>} <br> <br> <br>/* OutlineDoc_UnindentCommand <br> * -------------------------- <br> * <br> *      Unindent selection of lines <br> */ <br>void OutlineDoc_UnindentCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST  lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   LPLINE      lpLine; <br>   HDC         hDC = LineList_GetDC(lpLL); <br>   int         nOrgLineWidthInHimetric; <br>   int         nOrgMaxLineWidthInHimetric = 0; <br>   int         i; <br>   int         nIndex; <br>   int         nNumSel; <br>   LINERANGE   lrSel; <br>   BOOL        fSizeChanged; <br> <br>   nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>   for(i = 0; i &lt; nNumSel; i++) { <br>      nIndex = lrSel.m_nStartLine + i; <br>      lpLine=LineList_GetLine(lpLL, nIndex); <br>      if (!lpLine) <br>         continue; <br> <br>      nOrgLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine); <br>      nOrgMaxLineWidthInHimetric = <br>            (nOrgLineWidthInHimetric &gt; nOrgMaxLineWidthInHimetric ? <br>               nOrgLineWidthInHimetric : nOrgMaxLineWidthInHimetric); <br>      Line_Unindent(lpLine, hDC); <br>      LineList_ForceLineRedraw(lpLL, nIndex, TRUE); <br> <br>#if defined( OLE_SERVER ) <br>      /* Update Name Table */ <br>      ServerNameTable_EditLineUpdate( <br>            (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable, <br>            nIndex <br>      ); <br>#endif <br> <br>   } <br> <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   fSizeChanged = LineList_RecalcMaxLineWidthInHimetric( <br>         lpLL, <br>         nOrgMaxLineWidthInHimetric <br>      ); <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged); <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br>} <br> <br> <br>/* OutlineDoc_SetLineHeightCommand <br> * ------------------------------- <br> * <br> *      Set height of the selection of lines <br> */ <br>void OutlineDoc_SetLineHeightCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST  lpLL; <br>   HDC         hDC; <br>   LPLINE      lpLine; <br>   int         nNewHeight; <br>   int         i; <br>   int         nIndex; <br>   int         nNumSel; <br>   LINERANGE   lrSel; <br> <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br>   lpLine = LineList_GetLine(lpLL, lrSel.m_nStartLine); <br>   if (!lpLine) <br>      return; <br> <br>   nNewHeight = Line_GetHeightInHimetric(lpLine); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br> <br>   DialogBoxParam( <br>         lpOutlineApp-&gt;m_hInst, <br>         (LPSTR)"SetLineHeight", <br>         lpOutlineDoc-&gt;m_hWndDoc, <br>         (DLGPROC)SetLineHeightDlgProc, <br>         (LPARAM)(LPINT)&amp;nNewHeight <br>   ); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br> <br>   if (nNewHeight == 0) <br>      return;     /* user hit cancel */ <br> <br>   hDC = LineList_GetDC(lpLL); <br> <br>   for (i = 0; i &lt; nNumSel; i++) { <br>      nIndex = lrSel.m_nStartLine + i; <br>      lpLine=LineList_GetLine(lpLL, nIndex); <br>      if (nNewHeight == -1) { <br>         switch (Line_GetLineType(lpLine)) { <br> <br>            case TEXTLINETYPE: <br> <br>               TextLine_CalcExtents((LPTEXTLINE)lpLine, hDC); <br>               break; <br> <br>#if defined( OLE_CNTR ) <br>            case CONTAINERLINETYPE: <br> <br>               ContainerLine_SetHeightInHimetric( <br>                     (LPCONTAINERLINE)lpLine, -1); <br>               break; <br>#endif <br> <br>         } <br>      } <br>      else <br>         Line_SetHeightInHimetric(lpLine, nNewHeight); <br> <br> <br>      LineList_SetLineHeight(lpLL, nIndex, <br>            Line_GetHeightInHimetric(lpLine)); <br>   } <br> <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE); <br>   LineList_ForceRedraw(lpLL, TRUE); <br>} <br> <br> <br> <br>/* OutlineDoc_SelectAllCommand <br> * --------------------------- <br> * <br> *      Select all the lines in the document. <br> */ <br>void OutlineDoc_SelectAllCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   LINERANGE lrSel; <br> <br>   lrSel.m_nStartLine = 0; <br>   lrSel.m_nEndLine = LineList_GetCount(lpLL) - 1; <br>   LineList_SetSel(lpLL, &amp;lrSel); <br>} <br> <br> <br>/* OutlineDoc_DefineNameCommand <br> * ---------------------------- <br> * <br> *      Define a name in the document <br> */ <br>void OutlineDoc_DefineNameCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br> <br>   DialogBoxParam( <br>         lpOutlineApp-&gt;m_hInst, <br>         (LPSTR)"DefineName", <br>         lpOutlineDoc-&gt;m_hWndDoc, <br>         (DLGPROC)DefineNameDlgProc, <br>         (LPARAM) lpOutlineDoc <br>   ); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br>} <br> <br> <br>/* OutlineDoc_GotoNameCommand <br> * -------------------------- <br> * <br> *      Goto a predefined name in the document <br> */ <br>void OutlineDoc_GotoNameCommand(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br> <br>   DialogBoxParam( <br>         lpOutlineApp-&gt;m_hInst, <br>         (LPSTR)"GotoName", <br>         lpOutlineDoc-&gt;m_hWndDoc, <br>         (DLGPROC)GotoNameDlgProc, <br>         (LPARAM)lpOutlineDoc <br>   ); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc); <br>#endif <br>} <br> <br> <br>/* OutlineDoc_ShowWindow <br> * --------------------- <br> * <br> *      Show the window of the document to the user. </code></pre>
<p>
</p>
<pre><code>*/ <br>void OutlineDoc_ShowWindow(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz(lpOutlineDoc-&gt;m_docInitType != DOCTYPE_UNKNOWN, <br>            "OutlineDoc_ShowWindow: can't show unitialized document\r\n"); <br>#endif <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_UNKNOWN) <br>      return; <br> <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   OleDoc_ShowWindow((LPOLEDOC)lpOutlineDoc); <br>#else <br>   ShowWindow(lpOutlineDoc-&gt;m_hWndDoc, SW_SHOWNORMAL); <br>   SetForegroundWindow(lpOutlineDoc-&gt;m_hWndDoc); <br>#endif <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>void OutlineDoc_AddFrameLevelTools(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>#if defined( INPLACE_CNTR ) <br>   // Call OLE In-Place Container version of this function instead <br>   ContainerDoc_AddFrameLevelTools((LPCONTAINERDOC)lpOutlineDoc); <br> <br>#else   // ! INPLACE_CNTR <br>   RECT rcFrameRect; <br>   BORDERWIDTHS frameToolWidths; <br> <br>#if defined( INPLACE_SVR ) <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>   LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc); <br> <br>   // if in-place active, add our tools to our in-place container's frame. <br>   if (lpTopIPFrame) { <br>      ServerDoc_AddFrameLevelTools(lpServerDoc); <br>      return; <br>   } <br>#endif  // INPLACE_SVR <br> <br>   OutlineApp_GetFrameRect(g_lpApp, (LPRECT)&amp;rcFrameRect); <br>   FrameTools_GetRequiredBorderSpace( <br>         lpOutlineDoc-&gt;m_lpFrameTools, <br>         (LPBORDERWIDTHS)&amp;frameToolWidths <br>   ); <br>   OutlineApp_SetBorderSpace(g_lpApp, (LPBORDERWIDTHS)&amp;frameToolWidths); <br>   FrameTools_AttachToFrame( <br>         lpOutlineDoc-&gt;m_lpFrameTools, OutlineApp_GetWindow(lpOutlineApp)); <br>   FrameTools_Move(lpOutlineDoc-&gt;m_lpFrameTools, (LPRECT)&amp;rcFrameRect); <br>#endif  // ! INPLACE_CNTR <br> <br>} <br> <br>#endif  // USE_FRAMETOOLS <br> <br> <br>/* OutlineDoc_GetWindow <br> * -------------------- <br> * <br> *      Get the window handle of the document. <br> */ <br>HWND OutlineDoc_GetWindow(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if(! lpOutlineDoc) return NULL; <br>   return lpOutlineDoc-&gt;m_hWndDoc; <br>} <br> <br> <br>/* OutlineDoc_AddLine <br> * ------------------ <br> * <br> *      Add one line to the Document's LineList <br> */ <br>void OutlineDoc_AddLine(LPOUTLINEDOC lpOutlineDoc, LPLINE lpLine, int nIndex) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br> <br>   LineList_AddLine(lpLL, lpLine, nIndex); <br> <br>   /* Update Name Table */ <br>   OutlineNameTable_AddLineUpdate(lpOutlineDoc-&gt;m_lpNameTable, nIndex); <br> <br>#if defined( INPLACE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>      /* NOTE: after adding a line we need to <br>      **    update the PosRect of the In-Place active <br>      **    objects (if any) that follow the added line. <br>      **    NOTE: nIndex is index of line before new line. <br>      **          nIndex+1 is index of new line <br>      **          nIndex+2 is index of line after new line. <br>      */ <br>      ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nIndex+2); <br>   } <br>#endif <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE); <br>} <br> <br> <br>/* OutlineDoc_DeleteLine <br> * --------------------- <br> * <br> * <br> *      Delete one line from the document's LineList <br> */ <br>void OutlineDoc_DeleteLine(LPOUTLINEDOC lpOutlineDoc, int nIndex) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br> <br>#if defined( OLE_CNTR ) <br>   LPLINE lpLine = LineList_GetLine(lpLL, nIndex); <br>   LPSTORAGE lpStgDoc = NULL; <br>   OLECHAR szSaveStgName[CWCSTORAGENAME]; <br>   BOOL fDeleteChildStg = FALSE; <br> <br>   if (lpLine &amp;&amp; (Line_GetLineType(lpLine) == CONTAINERLINETYPE) ) { <br> <br>      /* NOTE: when a ContainerLine is being deleted by the user, <br>      **    it is important to delete the object's sub-storage <br>      **    otherwise it wastes space in the ContainerDoc's file. <br>      **    this function is called when lines are deleted by the <br>      **    Clear command and when lines are deleted by a DRAGMOVE <br>      **    operation. <br>      */ <br>      LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>      // save name of child storage <br>//      LSTRCPYN(szSaveStgName, lpContainerLine-&gt;m_szStgName,sizeof(szSaveStgName)); <br>      OLESTRCPY(szSaveStgName, lpContainerLine-&gt;m_szStgName); <br>      lpStgDoc = ((LPOLEDOC)lpContainerLine-&gt;m_lpDoc)-&gt;m_lpStg; <br>      fDeleteChildStg = TRUE; <br>   } <br>#endif  // OLE_CNTR <br> <br>   LineList_DeleteLine(lpLL, nIndex); <br> <br>#if defined( OLE_CNTR ) <br>   if (fDeleteChildStg &amp;&amp; lpStgDoc) { <br>      HRESULT hrErr; <br> <br>      // delete the obsolete child storage. it is NOT fatal if this fails <br> <br>      hrErr = lpStgDoc-&gt;lpVtbl-&gt;DestroyElement(lpStgDoc, szSaveStgName); <br> <br>#if defined( _DEBUG ) <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("IStorage::DestroyElement return", hrErr); <br>      } <br>#endif <br>   } <br>#endif  // OLE_CNTR <br> <br>   /* Update Name Table */ <br>   OutlineNameTable_DeleteLineUpdate(lpOutlineDoc-&gt;m_lpNameTable, nIndex); <br> <br>#if defined( INPLACE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>      /* NOTE: after deleting a line we need to <br>      **    update the PosRect of the In-Place active <br>      **    objects (if any). <br>      */ <br>      ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nIndex); <br>   } <br>#endif <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE); <br> <br>#if defined( OLE_VERSION ) <br>   { <br>      LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>      LPOLEDOC    lpClipboardDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br> <br>      /* NOTE: if the document that is the source of data on the <br>      **    clipborad has just had lines deleted, then the copied data <br>      **    is no longer considered a valid potential link source. <br>      **    disable the offering of CF_LINKSOURCE from the clipboard <br>      **    document. this avoids problems that arise when the <br>      **    editing operation changes or deletes the original data <br>      **    copied. we will not go to the trouble of determining if <br>      **    the deleted line actually is part of the link source. <br>      */ <br>      if (lpClipboardDoc <br>         &amp;&amp; lpClipboardDoc-&gt;m_fLinkSourceAvail <br>         &amp;&amp; lpClipboardDoc-&gt;m_lpSrcDocOfCopy == (LPOLEDOC)lpOutlineDoc) { <br>         lpClipboardDoc-&gt;m_fLinkSourceAvail = FALSE; <br> <br>         /* NOTE: since we are changing the list of formats on <br>         **    the clipboard (ie. removing CF_LINKSOURCE), we must <br>         **    call OleSetClipboard again. to be sure that the <br>         **    clipboard datatransfer document object does not get <br>         **    destroyed we will guard the call to OleSetClipboard <br>         **    within a pair of AddRef/Release. <br>         */ <br>         OleDoc_AddRef((LPOLEDOC)lpClipboardDoc);    // guard obj life-time <br> <br>         OLEDBG_BEGIN2("OleSetClipboard called\r\n") <br>         OleSetClipboard( <br>               (LPDATAOBJECT)&amp;((LPOLEDOC)lpClipboardDoc)-&gt;m_DataObject); <br>         OLEDBG_END2 <br> <br>         OleDoc_Release((LPOLEDOC)lpClipboardDoc);    // rel. AddRef above <br>      } <br>   } <br>#endif  // OLE_VERSION <br>} <br> <br> <br>/* OutlineDoc_AddName <br> * ------------------ <br> * <br> *      Add a Name to the Document's NameTable <br> */ <br>void OutlineDoc_AddName(LPOUTLINEDOC lpOutlineDoc, LPOUTLINENAME lpOutlineName) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = lpOutlineDoc-&gt;m_lpNameTable; <br> <br>   OutlineNameTable_AddName(lpOutlineNameTable, lpOutlineName); <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE); <br>} <br> <br> <br>/* OutlineDoc_DeleteName <br> * --------------------- <br> * <br> * <br> *      Delete Name from the document's NameTable <br> */ <br>void OutlineDoc_DeleteName(LPOUTLINEDOC lpOutlineDoc, int nIndex) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = lpOutlineDoc-&gt;m_lpNameTable; <br> <br>   OutlineNameTable_DeleteName(lpOutlineNameTable, nIndex); <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE); <br>} <br> <br> <br>/* OutlineDoc_Destroy <br> * ------------------ <br> * <br> *  Free all memory that had been allocated for a document. <br> *      this destroys the LineList &amp; NameTable of the document. <br> */ <br>void OutlineDoc_Destroy(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>#if defined( OLE_VERSION ) <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>   if (lpOleDoc-&gt;m_fObjIsDestroying) <br>      return;     // doc destruction is in progress <br>#endif  // OLE_VERSION <br> <br>   OLEDBG_BEGIN3("OutlineDoc_Destroy\r\n"); <br> <br>#if defined( OLE_VERSION ) <br> <br>   /* NOTE: in order to guarantee that the application does not <br>   **    prematurely exit before the destruction of the document is <br>   **    complete, we intially AddRef the App refcnt later Release it. <br>   **    This initial AddRef is artificial; it simply guarantees that <br>   **    the app object does not get destroyed until the end of this <br>   **    routine. <br>   */ <br>   OleApp_AddRef(lpOleApp); <br> <br>   /* NOTE: perform processing required for OLE */ <br>   OleDoc_Destroy(lpOleDoc); <br>#endif <br> <br>   LineList_Destroy(lpLL); <br>   OutlineNameTable_Destroy(lpOutlineDoc-&gt;m_lpNameTable); <br> <br>#if defined( USE_HEADING ) <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      Heading_Destroy((LPHEADING)&amp;lpOutlineDoc-&gt;m_heading); <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      FrameTools_AssociateDoc(lpOutlineDoc-&gt;m_lpFrameTools, NULL); <br>#endif  // USE_FRAMETOOLS <br> <br>   DestroyWindow(lpOutlineDoc-&gt;m_hWndDoc); <br>   Delete(lpOutlineDoc);   // free memory for doc itself <br>   OleDbgOut1("@@@@ DOC DESTROYED\r\n"); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_Release(lpOleApp);       // release artificial AddRef above <br>#endif <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OutlineDoc_ReSize <br> * ----------------- <br> * <br> *  Resize the document and its components <br> * <br> * Parameter: <br> *      lpRect  the new size of the document. Use current size if NULL <br> */ <br>void OutlineDoc_Resize(LPOUTLINEDOC lpOutlineDoc, LPRECT lpRect) <br>{ <br>   RECT            rect; <br>   LPLINELIST      lpLL; <br> <br>#if defined( USE_HEADING ) <br>   LPHEADING       lphead; <br>#endif  // USE_HEADING <br> <br>   LPSCALEFACTOR   lpscale; <br>   HWND            hWndLL; <br> <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   lpLL = (LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   lpscale = (LPSCALEFACTOR)&amp;lpOutlineDoc-&gt;m_scale; <br>   hWndLL = LineList_GetWindow(lpLL); <br> <br>   if (lpRect) { <br>      CopyRect((LPRECT)&amp;rect, lpRect); <br>      MoveWindow(lpOutlineDoc-&gt;m_hWndDoc, rect.left, rect.top, <br>            rect.right-rect.left, rect.bottom-rect.top, TRUE); <br>   } <br> <br>   GetClientRect(lpOutlineDoc-&gt;m_hWndDoc, (LPRECT)&amp;rect); <br> <br>#if defined( USE_HEADING ) <br>   lphead = OutlineDoc_GetHeading(lpOutlineDoc); <br>   rect.left += Heading_RH_GetWidth(lphead, lpscale); <br>   rect.top += Heading_CH_GetHeight(lphead, lpscale); <br>#endif  // USE_HEADING <br> <br>   if (lpLL) { <br>      MoveWindow(hWndLL, rect.left, rect.top, <br>            rect.right-rect.left, rect.bottom-rect.top, TRUE); <br>   } <br> <br>#if defined( USE_HEADING ) <br>   if (lphead) <br>      Heading_Move(lphead, lpOutlineDoc-&gt;m_hWndDoc, lpscale); <br>#endif  // USE_HEADING <br> <br>#if defined( INPLACE_CNTR ) <br>   ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0); <br>#endif <br>} <br> <br> <br>/* OutlineDoc_GetNameTable <br> * ----------------------- <br> * <br> *      Get nametable associated with the line list <br> */ <br>LPOUTLINENAMETABLE OutlineDoc_GetNameTable(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (!lpOutlineDoc) <br>      return NULL; <br>   else <br>      return lpOutlineDoc-&gt;m_lpNameTable; <br>} <br> <br> <br>/* OutlineDoc_GetLineList <br> * ---------------------- <br> * <br> *      Get listlist associated with the OutlineDoc <br> */ <br>LPLINELIST OutlineDoc_GetLineList(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (!lpOutlineDoc) <br>      return NULL; <br>   else <br>      return (LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>} <br> <br> <br>/* OutlineDoc_GetNameCount <br> * ----------------------- <br> * <br> * Return number of names in table <br> */ <br>int OutlineDoc_GetNameCount(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   return OutlineNameTable_GetCount(lpOutlineDoc-&gt;m_lpNameTable); <br>} <br> <br> <br>/* OutlineDoc_GetLineCount <br> * ----------------------- <br> * <br> * Return number of lines in the LineList <br> */ <br>int OutlineDoc_GetLineCount(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   return LineList_GetCount(&amp;lpOutlineDoc-&gt;m_LineList); <br>} <br> <br> <br>/* OutlineDoc_SetFileName <br> * ---------------------- <br> * <br> *      Set the filename of a document. <br> * <br> *  NOTE: If the ServerDoc has a valid filename then, the object is <br> *  registered in the running object table (ROT). if the name of the doc <br> *  changes (eg. via SaveAs) then the previous registration must be revoked <br> *  and the document re-registered under the new name. <br> */ <br>BOOL OutlineDoc_SetFileName(LPOUTLINEDOC lpOutlineDoc, LPOLESTR lpszNewFileName, LPSTORAGE lpNewStg) <br>{ <br>   OleDbgAssertSz(lpszNewFileName != NULL,   "Can't reset doc to Untitled!"); <br>   if (lpszNewFileName == NULL) <br>      return FALSE; <br> <br>//   AnsiLowerBuff(lpszNewFileName, (UINT)OLESTRLEN(lpszNewFileName)); <br>   CharLowerBuffW(lpszNewFileName, OLESTRLEN(lpszNewFileName)); <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>      LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>      /* NOTE: the container version of the application keeps its <br>      **    storage open at all times. if the document's storage is not <br>      **    open, then open it. <br>      */ <br> <br>      if (lpNewStg) { <br> <br>         /* CASE 1 -- document is being loaded from a file. lpNewStg is <br>         **    still open from the OutlineDoc_LoadFromFile function. <br>         */ <br> <br>         lpOutlineDoc-&gt;m_docInitType = DOCTYPE_FROMFILE; <br> <br>      } else { <br> <br>         /* CASE 2 -- document is being associated with a valid file <br>         **    that is not yet open. thus we must now open the file. <br>         */ <br> <br>         if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_FROMFILE &amp;&amp; <br>               OLESTRCMP(lpOutlineDoc-&gt;m_szFileName,lpszNewFileName)==0) { <br> <br>            /* CASE 2a -- new filename is same as current file. if the <br>            **    stg is already open, then the lpStg is still valid. <br>            **    if it is not open, then open it. <br>            */ <br>            if (! lpOleDoc-&gt;m_lpStg) { <br>               lpOleDoc-&gt;m_lpStg = OleStdOpenRootStorage( <br>                     lpszNewFileName, <br>                     STGM_READWRITE | STGM_SHARE_DENY_WRITE <br>               ); <br>               if (! lpOleDoc-&gt;m_lpStg) return FALSE; <br>            } <br> <br>         } else { <br> <br>            /* CASE 2b -- new filename is NOT same as current file. <br>            **    a SaveAs operation is pending. open the new file and <br>            **    hold the storage pointer in m_lpNewStg. the <br>            **    subsequent call to Doc_SaveToFile will save the <br>            **    document into the new storage pointer and release the <br>            **    old storage pointer. <br>            */ <br> <br>            lpOutlineDoc-&gt;m_docInitType = DOCTYPE_FROMFILE; <br> <br>            lpContainerDoc-&gt;m_lpNewStg = OleStdCreateRootStorage( <br>                  lpszNewFileName, <br>                  STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE <br>            ); <br>            if (! lpContainerDoc-&gt;m_lpNewStg) return FALSE; <br>         } <br>      } <br>   } <br>#endif      // OLE_CNTR <br> <br>   if (lpOutlineDoc-&gt;m_docInitType != DOCTYPE_FROMFILE || <br>      OLESTRCMP(lpOutlineDoc-&gt;m_szFileName, lpszNewFileName) != 0) { <br> <br>      /* A new valid file name is being associated with the document */ <br> <br>      OLESTRCPY(lpOutlineDoc-&gt;m_szFileName, lpszNewFileName); <br>      lpOutlineDoc-&gt;m_docInitType = DOCTYPE_FROMFILE; <br> <br>      // set lpszDocTitle to point to filename without path <br>      lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName + <br>         OLESTRLEN(lpOutlineDoc-&gt;m_szFileName) - 1; <br>      while (lpOutlineDoc-&gt;m_lpszDocTitle &gt; lpOutlineDoc-&gt;m_szFileName <br>         &amp;&amp; ! IS_FILENAME_DELIM(lpOutlineDoc-&gt;m_lpszDocTitle[-1])) { <br>         lpOutlineDoc-&gt;m_lpszDocTitle--; <br>      } <br> <br>      OutlineDoc_SetTitle(lpOutlineDoc, TRUE /*fMakeUpperCase*/); <br> <br>#if defined( OLE_VERSION ) <br>      { <br>         /* NOTE: both containers and servers must properly <br>         **    register in the RunningObjectTable. if the document <br>         **    is performing a SaveAs operation, then it must <br>         **    re-register in the ROT with the new moniker. in <br>         **    addition any embedded object, pseudo objects, and/or <br>         **    linking clients must be informed that the document's <br>         **    moniker has changed. <br>         */ <br> <br>         LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>         if (lpOleDoc-&gt;m_lpFileMoniker) { <br>            OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpFileMoniker); <br>            lpOleDoc-&gt;m_lpFileMoniker = NULL; <br>         } <br> <br>         CreateFileMoniker(lpszNewFileName,&amp;lpOleDoc-&gt;m_lpFileMoniker); <br>         OleDoc_DocRenamedUpdate(lpOleDoc, lpOleDoc-&gt;m_lpFileMoniker); <br>      } <br>#endif      // OLE_VERSION <br> <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineDoc_SetTitle <br> * ------------------- <br> * <br> * Set window text to be current filename. <br> * The following window hierarchy exits: <br> *      hWndApp <br> *          hWndDoc <br> *              hWndListBox <br> *  The frame window is the window which gets the title. <br> */ <br>void OutlineDoc_SetTitle(LPOUTLINEDOC lpOutlineDoc, BOOL fMakeUpperCase) <br>{ <br>   HWND hWnd; <br>   LPSTR lpszText; <br>   char  szAnsiStr[256]; <br> <br>   if (!lpOutlineDoc-&gt;m_hWndDoc) return; <br>   if ((hWnd = GetParent(lpOutlineDoc-&gt;m_hWndDoc)) == NULL) return; <br> <br>   lpszText = OleStdMalloc((UINT)(OLESTRLEN(APPNAME) + 4 + <br>                           OLESTRLEN(lpOutlineDoc-&gt;m_lpszDocTitle))); <br>   if (!lpszText) return; <br> <br>   W2A(APPNAME, lpszText, OLESTRLEN(APPNAME)+1); <br>   lstrcat(lpszText," - "); <br>   W2A (lpOutlineDoc-&gt;m_lpszDocTitle, szAnsiStr, 256); <br>   lstrcat(lpszText, (LPSTR)szAnsiStr); <br> <br>   if (fMakeUpperCase) <br>      AnsiUpperBuff(lpszText, (UINT)lstrlen(lpszText)); <br> <br>   SetWindowText(hWnd,lpszText); <br>   OleStdFree(lpszText); <br>} <br> <br> <br>/* OutlineDoc_Close <br> * ---------------- <br> * <br> * Close active document. If modified, prompt the user if <br> * he wants to save. <br> * <br> *  Returns: <br> *      FALSE -- user canceled the closing of the doc. <br> *      TRUE -- the doc was successfully closed <br> */ <br>BOOL OutlineDoc_Close(LPOUTLINEDOC lpOutlineDoc, DWORD dwSaveOption) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: call OLE specific function instead */ <br>   return OleDoc_Close((LPOLEDOC)lpOutlineDoc, dwSaveOption); <br> <br>#else <br> <br>   if (! lpOutlineDoc) <br>      return TRUE;            // active doc's are already destroyed <br> <br>   if (! OutlineDoc_CheckSaveChanges(lpOutlineDoc, &amp;dwSaveOption)) <br>      return FALSE;           // abort closing the doc <br> <br>   OutlineDoc_Destroy(lpOutlineDoc); <br> <br>   OutlineApp_DocUnlockApp(lpOutlineApp, lpOutlineDoc); <br> <br>   return TRUE; <br> <br>#endif      // ! OLE_VERSION <br>} <br> <br> <br>/* OutlineDoc_CheckSaveChanges <br> * --------------------------- <br> * <br> * Check if the document has been modified. if so, prompt the user if <br> *      the changes should be saved. if yes save them. <br> * Returns TRUE if the doc is safe to close (user answered Yes or No) <br> *         FALSE if the user canceled the save changes option. <br> */ <br>BOOL OutlineDoc_CheckSaveChanges( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPDWORD             lpdwSaveOption <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   int nResponse; <br>   char szAnsiString[256]; <br>   char szAnsiString2[256]; <br> <br>   if (*lpdwSaveOption == OLECLOSE_NOSAVE) <br>      return TRUE; <br> <br>   if(! OutlineDoc_IsModified(lpOutlineDoc)) <br>      return TRUE;    // saving is not necessary <br> <br>   /* NOTE: our document is dirty so it needs to be saved. if <br>   **    OLECLOSE_PROMPTSAVE the user should be prompted to see if the <br>   **    document should be saved. is specified but the document is NOT <br>   **    visible to the user, then the user can NOT be prompted. in <br>   **    the situation the document should be saved without prompting. <br>   **    if OLECLOSE_SAVEIFDIRTY is specified then, the document <br>   **    should also be saved without prompting. <br>   */ <br>   if (*lpdwSaveOption == OLECLOSE_PROMPTSAVE &amp;&amp; <br>         IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) { <br> <br>      // prompt the user to see if changes should be saved. <br>#if defined( OLE_VERSION ) <br>      OleApp_PreModalDialog( <br>            (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br>      W2A (APPNAME, szAnsiString, 256); <br>      W2A (MsgSaveFile, szAnsiString2, 256); <br>      nResponse = MessageBox( <br>            lpOutlineApp-&gt;m_hWndApp, <br>            szAnsiString2, <br>            szAnsiString, <br>            MB_ICONQUESTION | MB_YESNOCANCEL <br>      ); <br>#if defined( OLE_VERSION ) <br>      OleApp_PostModalDialog( <br>            (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br>      if(nResponse==IDCANCEL) <br>         return FALSE;   // close is canceled <br>      if(nResponse==IDNO) { <br>         // Reset the save option to NOSAVE per user choice <br>         *lpdwSaveOption = OLECLOSE_NOSAVE; <br>         return TRUE;    // don't save, but is ok to close <br>      } <br>   } else if (*lpdwSaveOption != OLECLOSE_SAVEIFDIRTY) { <br>      OleDbgAssertSz(FALSE, "Invalid dwSaveOption\r\n"); <br>      *lpdwSaveOption = OLECLOSE_NOSAVE; <br>      return TRUE;        // unknown *lpdwSaveOption; close w/o saving <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED) { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>      HRESULT hrErr; <br> <br>      /* NOTE: Update the container before closing without prompting <br>      **    the user. To update the container, we must ask our container <br>      **    to save us. <br>      */ <br>      OleDbgAssert(lpServerDoc-&gt;m_lpOleClientSite != NULL); <br>      OLEDBG_BEGIN2("IOleClientSite::SaveObject called\r\n") <br>      hrErr = lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;SaveObject( <br>            lpServerDoc-&gt;m_lpOleClientSite <br>      ); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("IOleClientSite::SaveObject returned", hrErr); <br>         return FALSE; <br>      } <br> <br>      return TRUE;    // doc is safe to be closed <br> <br>   } else <br>#endif      // OLE_SERVER <br>   { <br>      return OutlineApp_SaveCommand(lpOutlineApp); <br>   } <br>} <br> <br> <br>/* OutlineDoc_IsModified <br> * --------------------- <br> * <br> * Return modify flag of OUTLINEDOC <br> */ <br>BOOL OutlineDoc_IsModified(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (lpOutlineDoc-&gt;m_fModified) <br>      return lpOutlineDoc-&gt;m_fModified; <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      /* NOTE: if there are OLE objects, then we must ask if any of <br>      **    them are dirty. if so we must consider our document <br>      **    as modified. <br>      */ <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>      LPLINELIST  lpLL; <br>      int         nLines; <br>      int         nIndex; <br>      LPLINE      lpLine; <br>      HRESULT     hrErr; <br> <br>      lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>      nLines = LineList_GetCount(lpLL); <br> <br>      for (nIndex = 0; nIndex &lt; nLines; nIndex++) { <br>         lpLine = LineList_GetLine(lpLL, nIndex); <br>         if (!lpLine) <br>            break; <br>         if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) { <br>            LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br>            if (lpContainerLine-&gt;m_lpPersistStg) { <br>               hrErr = lpContainerLine-&gt;m_lpPersistStg-&gt;lpVtbl-&gt;IsDirty( <br>                     lpContainerLine-&gt;m_lpPersistStg); <br>               /* NOTE: we will only accept an explicit "no i <br>               **    am NOT dirty statement" (ie. S_FALSE) as an <br>               **    indication that the object is clean. eg. if <br>               **    the object returns E_NOTIMPL we must <br>               **    interpret it as the object IS dirty. <br>               */ <br>               if (GetScode(hrErr) != S_FALSE) <br>                  return TRUE; <br>            } <br>         } <br>      } <br>   } <br>#endif <br>   return FALSE; <br>} <br> <br> <br>/* OutlineDoc_SetModified <br> * ---------------------- <br> * <br> *  Set the modified flag of the document <br> * <br> */ <br>void OutlineDoc_SetModified(LPOUTLINEDOC lpOutlineDoc, BOOL fModified, BOOL fDataChanged, BOOL fSizeChanged) <br>{ <br>   lpOutlineDoc-&gt;m_fModified = fModified; <br> <br>#if defined( OLE_SERVER ) <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br> <br>      /* NOTE: if the document has changed, then broadcast the change <br>      **    to all clients who have set up Advise connections. notify <br>      **    them that our data (and possibly also our extents) have <br>      **    changed. <br>      */ <br>      if (fDataChanged) { <br>         lpServerDoc-&gt;m_fDataChanged     = TRUE; <br>         lpServerDoc-&gt;m_fSizeChanged     = fSizeChanged; <br>         lpServerDoc-&gt;m_fSendDataOnStop  = TRUE; <br> <br>         ServerDoc_SendAdvise( <br>               lpServerDoc, <br>               OLE_ONDATACHANGE, <br>               NULL,   /* lpmkDoc -- not relevant here */ <br>               0       /* advf -- no flags necessary */ <br>         ); <br>      } <br>   } <br>#endif  // OLE_SERVER <br>} <br> <br> <br>/* OutlineDoc_SetRedraw <br> * -------------------- <br> * <br> *  Enable/Disable the redraw of the document on screen. <br> *  The calls to SetRedraw counted so that nested calls can be handled <br> *  properly. calls to SetRedraw must be balanced. <br> * <br> *  fEnbaleDraw = TRUE      - enable redraw <br> *                FALSE     - disable redraw <br> */ <br>void OutlineDoc_SetRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fEnableDraw) <br>{ <br>   static HCURSOR hPrevCursor = NULL; <br> <br>   if (fEnableDraw) { <br>      if (lpOutlineDoc-&gt;m_nDisableDraw == 0) <br>         return;     // already enabled; no state transition <br> <br>      if (--lpOutlineDoc-&gt;m_nDisableDraw &gt; 0) <br>         return;     // drawing should still be disabled <br>   } else { <br>      if (lpOutlineDoc-&gt;m_nDisableDraw++ &gt; 0) <br>         return;     // already disabled; no state transition <br>   } <br> <br>   if (lpOutlineDoc-&gt;m_nDisableDraw &gt; 0) { <br>      // this may take a while, put up hourglass cursor <br>      hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>   } else { <br>      if (hPrevCursor) { <br>         SetCursor(hPrevCursor);     // restore original cursor <br>         hPrevCursor = NULL; <br>      } <br>   } <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: for the Server version, while Redraw is disabled <br>   **    postpone sending advise notifications until Redraw is re-enabled. <br>   */ <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>      LPSERVERNAMETABLE lpServerNameTable = <br>            (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable; <br> <br>      if (lpOutlineDoc-&gt;m_nDisableDraw == 0) { <br>         /* drawing is being Enabled. if changes occurred while drawing <br>         **    was disabled, then notify clients now. <br>         */ <br>         if (lpServerDoc-&gt;m_fDataChanged) <br>            ServerDoc_SendAdvise( <br>                  lpServerDoc, <br>                  OLE_ONDATACHANGE, <br>                  NULL,   /* lpmkDoc -- not relevant here */ <br>                  0       /* advf -- no flags necessary */ <br>            ); <br> <br>         /* NOTE: send pending change notifications for pseudo objs. */ <br>         ServerNameTable_SendPendingAdvises(lpServerNameTable); <br> <br>      } <br>   } <br>#endif      // OLE_SERVER <br> <br>#if defined( OLE_CNTR ) <br>   /* NOTE: for the Container version, while Redraw is disabled <br>   **    postpone updating the extents of OLE objects until Redraw is <br>   **    re-enabled. <br>   */ <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br> <br>      /* Update the extents of any OLE object that is marked that <br>      **    its size may  have changed. when an <br>      **    IAdviseSink::OnViewChange notification is received, <br>      **    the corresponding ContainerLine is marked <br>      **    (m_fDoGetExtent==TRUE) and a message <br>      **    (WM_U_UPDATEOBJECTEXTENT) is posted to the document <br>      **    indicating that there are dirty objects. <br>      */ <br>      if (lpOutlineDoc-&gt;m_nDisableDraw == 0) <br>         ContainerDoc_UpdateExtentOfAllOleObjects(lpContainerDoc); <br>   } <br>#endif      // OLE_CNTR <br> <br>   // enable/disable redraw of the LineList listbox <br>   LineList_SetRedraw(&amp;lpOutlineDoc-&gt;m_LineList, fEnableDraw); <br>} <br> <br> <br>/* OutlineDoc_SetSel <br> * ----------------- <br> * <br> *      Set the selection in the documents's LineList <br> */ <br>void OutlineDoc_SetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel) <br>{ <br>   LineList_SetSel(&amp;lpOutlineDoc-&gt;m_LineList, lplrSel); <br>} <br> <br> <br>/* OutlineDoc_GetSel <br> * ----------------- <br> * <br> *      Get the selection in the documents's LineList. <br> * <br> *      Returns the count of items selected <br> */ <br>int OutlineDoc_GetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel) <br>{ <br>   return LineList_GetSel(&amp;lpOutlineDoc-&gt;m_LineList, lplrSel); <br>} <br> <br> <br>/* OutlineDoc_ForceRedraw <br> * ---------------------- <br> * <br> *      Force the document window to repaint. <br> */ <br>void OutlineDoc_ForceRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fErase) <br>{ <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   LineList_ForceRedraw(&amp;lpOutlineDoc-&gt;m_LineList, fErase); <br>   Heading_CH_ForceRedraw(&amp;lpOutlineDoc-&gt;m_heading, fErase); <br>   Heading_RH_ForceRedraw(&amp;lpOutlineDoc-&gt;m_heading, fErase); <br>} <br> <br> <br>/* OutlineDoc_RenderFormat <br> * ----------------------- <br> * <br> *      Render a clipboard format supported by ClipboardDoc <br> */ <br>void OutlineDoc_RenderFormat(LPOUTLINEDOC lpOutlineDoc, UINT uFormat) </code></pre>
<p>
</p>
<pre><code>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HGLOBAL      hData = NULL; <br> <br>   if (uFormat == lpOutlineApp-&gt;m_cfOutline) <br>      hData = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL); <br> <br>   else if (uFormat == CF_TEXT) <br>      hData = OutlineDoc_GetTextData(lpOutlineDoc, NULL); <br> <br>   else { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFormatNotSupported); <br>      return; <br>   } <br> <br>   SetClipboardData(uFormat, hData); <br>} <br> <br> <br>/* OutlineDoc_RenderAllFormats <br> * --------------------------- <br> * <br> *      Render all formats supported by ClipboardDoc <br> */ <br>void OutlineDoc_RenderAllFormats(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HGLOBAL      hData = NULL; <br> <br>   OpenClipboard(lpOutlineDoc-&gt;m_hWndDoc); <br> <br>   hData = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL); <br>   SetClipboardData(lpOutlineApp-&gt;m_cfOutline, hData); <br> <br>   hData = OutlineDoc_GetTextData(lpOutlineDoc, NULL); <br>   SetClipboardData(CF_TEXT, hData); <br> <br>   CloseClipboard(); <br>} <br> <br> <br> <br>/* OutlineDoc_GetOutlineData <br> * ------------------------- <br> * <br> * Return a handle to an array of TextLine objects for the desired line <br> *      range. <br> *  NOTE: if lplrSel == NULL, then all lines are returned <br> * <br> */ <br>HGLOBAL OutlineDoc_GetOutlineData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel) <br>{ <br>   HGLOBAL     hOutline  = NULL; <br>   LPLINELIST  lpLL=(LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   LPLINE      lpLine; <br>   LPTEXTLINE  arrLine; <br>   int     i; <br>   int     nStart = (lplrSel ? lplrSel-&gt;m_nStartLine : 0); <br>   int     nEnd =(lplrSel ? lplrSel-&gt;m_nEndLine : LineList_GetCount(lpLL)-1); <br>   int     nLines = nEnd - nStart + 1; <br>   int     nCopied = 0; <br> <br>   hOutline=GlobalAlloc(GALLOCFLG, sizeof(TEXTLINE)*nLines); <br> <br>   if (! hOutline) return NULL; <br> <br>   arrLine=(LPTEXTLINE)GlobalLock(hOutline); <br> <br>   for (i = nStart; i &lt;= nEnd; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br>      if (lpLine &amp;&amp; Line_GetOutlineData(lpLine, &amp;arrLine[nCopied])) <br>         nCopied++; <br>   } <br> <br>   GlobalUnlock(hOutline); <br> <br>   return hOutline; <br>} <br> <br> <br> <br>/* OutlineDoc_GetTextData <br> * ---------------------- <br> * <br> * Return a handle to an object's data in text form for the desired line <br> *      range. <br> *  NOTE: if lplrSel == NULL, then all lines are returned <br> * <br> */ <br>HGLOBAL OutlineDoc_GetTextData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel) <br>{ <br>   LPLINELIST  lpLL=(LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   LPLINE  lpLine; <br>   HGLOBAL hText = NULL; <br>   LPOLESTR   lpszText = NULL; <br>   DWORD   dwMemSize=0; <br>   int     i,j; <br>   int     nStart = (lplrSel ? lplrSel-&gt;m_nStartLine : 0); <br>   int     nEnd =(lplrSel ? lplrSel-&gt;m_nEndLine : LineList_GetCount(lpLL)-1); <br>   int     nTabLevel; <br> <br>   // calculate memory size required <br>   for(i = nStart; i &lt;= nEnd; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br>      if (! lpLine) <br>         continue; <br> <br>      dwMemSize += Line_GetTabLevel(lpLine); <br>      dwMemSize += Line_GetTextLen(lpLine); <br> <br>      dwMemSize += 2; // add 1 for '\r\n' at the end of each line <br>   } <br>   dwMemSize++;        // add 1 for '\0' at the end of string <br> <br>   if(!(hText = GlobalAlloc(GALLOCFLG, dwMemSize))) <br>      return NULL; <br> <br>   if(!(lpszText = /*(LPOLESTR)*/GlobalLock(hText))) <br>      return NULL; <br> <br>   // put line text to memory <br>   for(i = nStart; i &lt;= nEnd; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br>      if (! lpLine) <br>         continue; <br> <br>      nTabLevel=Line_GetTabLevel(lpLine); <br>      for(j = 0; j &lt; nTabLevel; j++) <br>         *lpszText++='\t'; <br> <br>      Line_GetTextData(lpLine, lpszText); <br>      while(*lpszText) <br>         lpszText++;     // advance to end of string <br> <br>      *lpszText++ = '\r'; <br>      *lpszText++ = '\n'; <br>   } <br> <br>   GlobalUnlock (hText); <br> <br>   return hText; <br>} <br> <br> <br>/* OutlineDoc_SaveToFile <br> * --------------------- <br> * <br> *      Save the document to a file with the same name as stored in the <br> * document <br> */ <br>BOOL OutlineDoc_SaveToFile(LPOUTLINEDOC lpOutlineDoc, LPCOLESTR lpszFileName, UINT uFormat, BOOL fRemember) <br>{ <br>#if defined( OLE_CNTR ) <br>   // Call OLE container specific function instead <br>   return ContainerDoc_SaveToFile( <br>         (LPCONTAINERDOC)lpOutlineDoc, <br>         lpszFileName, <br>         uFormat, <br>         fRemember <br>   ); <br> <br>#else <br> <br>   LPSTORAGE lpDestStg = NULL; <br>   HRESULT hrErr; <br>   BOOL fStatus; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>   if (fRemember) { <br>      if (lpszFileName) { <br>         fStatus = OutlineDoc_SetFileName( <br>               lpOutlineDoc, <br>               (LPOLESTR)lpszFileName, <br>               NULL <br>         ); <br>         if (! fStatus) goto error; <br>      } else <br>         lpszFileName = lpOutlineDoc-&gt;m_szFileName; // use cur. file name <br>   } else if (! lpszFileName) { <br>      goto error; <br>   } <br> <br>   hrErr = StgCreateDocfile( <br>         lpszFileName, <br>         STGM_READWRITE|STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_CREATE, <br>         0, <br>         &amp;lpDestStg <br>   ); <br> <br>   OleDbgAssertSz(hrErr == NOERROR, "Could not create Docfile"); <br>   if (hrErr != NOERROR) <br>      goto error; <br> <br>#if defined( OLE_SERVER ) <br> <br>   /*  NOTE: we must be sure to write our class ID into our <br>   **    storage. this information is used by OLE to determine the <br>   **    class of the data stored in our storage. Even for top <br>   **    "file-level" objects this information should be written to <br>   **    the file. <br>   */ <br>   if(WriteClassStg(lpDestStg, &amp;CLSID_APP) != NOERROR) <br>      goto error; <br>#endif <br> <br>   fStatus = OutlineDoc_SaveSelToStg( <br>         lpOutlineDoc, <br>         NULL, <br>         uFormat, <br>         lpDestStg, <br>         FALSE,      /* fSameAsLoad */ <br>         fRemember <br>   ); <br>   if (! fStatus) goto error; <br> <br>   OleStdRelease((LPUNKNOWN)lpDestStg); <br> <br>   if (fRemember) <br>      OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE); <br> <br>#if defined( OLE_SERVER ) <br> <br>   /* NOTE: (SERVER-ONLY) inform any linking clients that the <br>   **    document has been saved. in addition, any currently active <br>   **    pseudo objects should also inform their clients. <br>   */ <br>   ServerDoc_SendAdvise ( <br>         (LPSERVERDOC)lpOutlineDoc, <br>         OLE_ONSAVE, <br>         NULL,   /* lpmkDoc -- not relevant here */ <br>         0       /* advf -- not relevant here */ <br>   ); <br> <br>#endif <br> <br>   return TRUE; <br> <br>error: <br>   if (lpDestStg) <br>      OleStdRelease((LPUNKNOWN)lpDestStg); <br> <br>   OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgSaving); <br>   return FALSE; <br> <br>#endif  // ! OLE_CNTR <br>} <br> <br> <br>/* OutlineDoc_LoadFromFile <br> * ----------------------- <br> * <br> *      Load a document from a file <br> */ <br>BOOL OutlineDoc_LoadFromFile(LPOUTLINEDOC lpOutlineDoc, LPOLESTR lpszFileName) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPLINELIST      lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   HRESULT         hrErr; <br>   SCODE           sc; <br>   LPSTORAGE       lpSrcStg; <br>   BOOL            fStatus; <br> <br>   hrErr = StgOpenStorage(lpszFileName, <br>         NULL, <br>#if defined( OLE_CNTR ) <br>         STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE, <br>#else <br>         STGM_READ | STGM_SHARE_DENY_WRITE, <br>#endif <br>         NULL, <br>         0, <br>         &amp;lpSrcStg <br>   ); <br> <br>   if ((sc = GetScode(hrErr)) == STG_E_FILENOTFOUND) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("File not found")); <br>      return FALSE; <br>   } else if (sc == STG_E_FILEALREADYEXISTS) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFormat); <br>      return FALSE; <br>   } else if (sc != S_OK) { <br>      OleDbgOutScode("StgOpenStorage returned", sc); <br>      OutlineApp_ErrorMessage( <br>            lpOutlineApp, <br>            OLESTR("File already in use--could not be opened") <br>      ); <br>      return FALSE; <br>   } <br> <br>   if(! OutlineDoc_LoadFromStg(lpOutlineDoc, lpSrcStg)) goto error; <br> <br>   fStatus = OutlineDoc_SetFileName(lpOutlineDoc, lpszFileName, lpSrcStg); <br>   if (! fStatus) goto error; <br> <br>   OleStdRelease((LPUNKNOWN)lpSrcStg); <br> <br>   return TRUE; <br> <br>error: <br>   OleStdRelease((LPUNKNOWN)lpSrcStg); <br>   OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgOpening); <br>   return FALSE; <br>} <br> <br> <br> <br>/* OutlineDoc_LoadFromStg <br> * ---------------------- <br> * <br> *  Load entire document from an open IStorage pointer (lpSrcStg) <br> *      Return TRUE if ok, FALSE if error. <br> */ <br>BOOL OutlineDoc_LoadFromStg(LPOUTLINEDOC lpOutlineDoc, LPSTORAGE lpSrcStg) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HRESULT hrErr; <br>   BOOL fStatus; <br>   ULONG nRead; <br>   LINERANGE lrSel = { 0, 0 }; <br>   LPSTREAM lpLLStm; <br>   OUTLINEDOCHEADER docRecord; <br>   OUTLINEDOCHEADER_ONDISK docRecordOnDisk; <br> <br>   hrErr = lpSrcStg-&gt;lpVtbl-&gt;OpenStream( <br>         lpSrcStg, <br>         OLESTR("LineList"), <br>         NULL, <br>         STGM_READ | STGM_SHARE_EXCLUSIVE, <br>         0, <br>         &amp;lpLLStm <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Open LineList Stream returned", hrErr); <br>      goto error; <br>   } <br> <br>   /* read OutlineDoc header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>         lpLLStm, <br>         (LPVOID)&amp;docRecordOnDisk, <br>         sizeof(docRecordOnDisk), <br>         &amp;nRead <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Read OutlineDoc header returned", hrErr); <br>      goto error; <br>    } <br> <br>    //  Transform docRecordOnDisk into docRecord <br>    //  Compilers should handle aligment correctly <br>    OLESTRCPY(docRecord.m_szFormatName, docRecordOnDisk.m_szFormatName); <br>    docRecord.m_narrAppVersionNo[0] = (int) docRecordOnDisk.m_narrAppVersionNo[0]; <br>    docRecord.m_narrAppVersionNo[1] = (int) docRecordOnDisk.m_narrAppVersionNo[1]; <br>    docRecord.m_fShowHeading = (BOOL) docRecordOnDisk.m_fShowHeading; <br>    docRecord.m_reserved1 = docRecordOnDisk.m_reserved1; <br>    docRecord.m_reserved2 = docRecordOnDisk.m_reserved2; <br>    docRecord.m_reserved3 = docRecordOnDisk.m_reserved3; <br>    docRecord.m_reserved4 = docRecordOnDisk.m_reserved4; <br> <br>   fStatus = OutlineApp_VersionNoCheck( <br>         lpOutlineApp, <br>         docRecord.m_szFormatName, <br>         docRecord.m_narrAppVersionNo <br>   ); <br> <br>   /* storage is an incompatible version; file can not be read */ <br>   if (! fStatus) <br>      goto error; <br> <br>   lpOutlineDoc-&gt;m_heading.m_fShow = docRecord.m_fShowHeading; <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      // Load ServerDoc specific data <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>#if defined( SVR_TREATAS ) <br>      LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>      CLSID       clsid; <br>      CLIPFORMAT  cfFmt; <br>      LPOLESTR       lpszType; <br>#endif  // SVR_TREATAS <br> <br>      lpServerDoc-&gt;m_nNextRangeNo = (ULONG)docRecord.m_reserved1; <br> <br>#if defined( SVR_TREATAS ) <br>      /* NOTE: if the Server is capable of supporting "TreatAs" <br>      **    (aka. ActivateAs), it must read the class that is written <br>      **    into the storage. if this class is NOT the app's own <br>      **    class ID, then this is a TreatAs operation. the server <br>      **    then must faithfully pretend to be the class that is <br>      **    written into the storage. it must also faithfully write <br>      **    the data back to the storage in the SAME format as is <br>      **    written in the storage. <br>      ** <br>      **    SVROUTL and ISVROTL can emulate each other. they have the <br>      **    simplification that they both read/write the identical <br>      **    format. thus for these apps no actual conversion of the <br>      **    native bits is actually required. <br>      */ <br>      lpServerDoc-&gt;m_clsidTreatAs = CLSID_NULL; <br>      if (OleStdGetTreatAsFmtUserType(&amp;CLSID_APP, lpSrcStg, &amp;clsid, <br>                     (CLIPFORMAT FAR*)&amp;cfFmt, /*(LPOLESTR FAR*)*/&amp;lpszType)) { <br> <br>         if (cfFmt == lpOutlineApp-&gt;m_cfOutline) { <br>            // We should perform TreatAs operation <br>            if (lpServerDoc-&gt;m_lpszTreatAsType) <br>               OleStdFreeString(lpServerDoc-&gt;m_lpszTreatAsType, NULL); <br> <br>            lpServerDoc-&gt;m_clsidTreatAs = clsid; <br>            ((LPOUTLINEDOC)lpServerDoc)-&gt;m_cfSaveFormat = cfFmt; <br>            lpServerDoc-&gt;m_lpszTreatAsType = lpszType; <br> <br>            OleDbgOut3("OutlineDoc_LoadFromStg: TreateAs ==&gt; '"); <br>//          OleDbgOutNoPrefix3(lpServerDoc-&gt;m_lpszTreatAsType); <br>            OleDbgOutNoPrefix3("'\r\n"); <br>         } else { <br>            // ERROR: we ONLY support TreatAs for CF_OUTLINE format <br>            OleDbgOut("SvrDoc_PStg_InitNew: INVALID TreatAs Format\r\n"); <br>            OleStdFreeString(lpszType, NULL); <br>         } <br>      } <br>#endif  // SVR_TREATAS <br>   } <br>#endif  // OLE_SVR <br>#if defined( OLE_CNTR ) <br>   { <br>      // Load ContainerDoc specific data <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br> <br>      lpContainerDoc-&gt;m_nNextObjNo = (ULONG)docRecord.m_reserved2; <br>   } <br>#endif  // OLE_CNTR <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE ); <br> <br>   if(! LineList_LoadFromStg(&amp;lpOutlineDoc-&gt;m_LineList, lpSrcStg, lpLLStm)) <br>      goto error; <br>   if(! OutlineNameTable_LoadFromStg(lpOutlineDoc-&gt;m_lpNameTable, lpSrcStg)) <br>      goto error; <br> <br>   OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE); <br>   OutlineDoc_SetSel(lpOutlineDoc, &amp;lrSel); <br> <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br> <br>   OleStdRelease((LPUNKNOWN)lpLLStm); <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>      /* A ContainerDoc keeps its storage open at all times. it is necessary <br>      *   to AddRef the lpSrcStg in order to hang on to it. <br>      */ <br>      if (lpOleDoc-&gt;m_lpStg) { <br>         OleStdVerifyRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg, <br>               OLESTR("Doc Storage not released properly")); <br>      } <br>      lpSrcStg-&gt;lpVtbl-&gt;AddRef(lpSrcStg); <br>      lpOleDoc-&gt;m_lpStg = lpSrcStg; <br>   } <br>#endif      // OLE_CNTR <br> <br>   return TRUE; <br> <br>error: <br>   OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE ); <br>   if (lpLLStm) <br>      OleStdRelease((LPUNKNOWN)lpLLStm); <br>   return FALSE; <br>} <br> <br> <br>/* OutlineDoc_SaveSelToStg <br> * ----------------------- <br> * <br> *      Save the specified selection of document into an IStorage*. All lines <br> * within the selection along with any names completely contained within the <br> * selection will be written <br> * <br> *      Return TRUE if ok, FALSE if error <br> */ <br>BOOL OutlineDoc_SaveSelToStg( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPLINERANGE         lplrSel, <br>      UINT                uFormat, <br>      LPSTORAGE           lpDestStg, <br>      BOOL                fSameAsLoad, <br>      BOOL                fRemember <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HRESULT hrErr = NOERROR; <br>   LPSTREAM lpLLStm = NULL; <br>   LPSTREAM lpNTStm = NULL; <br>   ULONG nWritten; <br>   BOOL fStatus; <br>   OUTLINEDOCHEADER docRecord; <br>   OUTLINEDOCHEADER_ONDISK docRecordOnDisk; <br>   HCURSOR  hPrevCursor; <br>   char szAnsiString[256]; <br> <br>#if defined( OLE_VERSION ) <br>   LPOLESTR lpszUserType; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>   /*  NOTE: we must be sure to write the information required for <br>   **    OLE into our docfile. this includes user type <br>   **    name, data format, etc. Even for top "file-level" objects <br>   **    this information should be written to the file. Both <br>   **    containters and servers should write this information. <br>   */ <br> <br>#if defined( OLE_SERVER ) &amp;&amp; defined( SVR_TREATAS ) <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br> <br>   /* NOTE: if the Server is emulating another class (ie. <br>   **    "TreatAs" aka. ActivateAs), it must write the same user type <br>   **    name and format that was was originally written into the <br>   **    storage rather than its own user type name. <br>   ** <br>   **    SVROUTL and ISVROTL can emulate each other. they have the <br>   **    simplification that they both read/write the identical <br>   **    format. thus for these apps no actual conversion of the <br>   **    native bits is actually required. <br>   */ <br>   if (! IsEqualCLSID(&amp;lpServerDoc-&gt;m_clsidTreatAs, &amp;CLSID_NULL)) <br>      lpszUserType = lpServerDoc-&gt;m_lpszTreatAsType; <br>   else <br>#endif  // OLE_SERVER &amp;&amp; SVR_TREATAS <br> <br>      lpszUserType = /*(LPOLESTR)*/FULLUSERTYPENAME; <br> <br>   hrErr = WriteFmtUserTypeStg(lpDestStg, (CLIPFORMAT)uFormat, lpszUserType); <br>   if(hrErr != NOERROR) goto error; <br> <br>   if (fSameAsLoad) { <br>      /* NOTE: we are saving into to same storage that we were <br>      **    passed an load time. we deliberatly opened the streams we <br>      **    need (lpLLStm and lpNTStm) at load time, so that we can <br>      **    robustly save at save time in a low-memory situation. <br>      **    this is particulary important the embedded objects do NOT <br>      **    consume additional memory when <br>      **    IPersistStorage::Save(fSameAsLoad==TRUE) is called. <br>      */ <br>      LARGE_INTEGER libZero; <br>      ULARGE_INTEGER ulibZero; <br>      LISet32( libZero, 0 ); <br>      LISet32( ulibZero, 0 ); <br>      lpLLStm = lpOleDoc-&gt;m_lpLLStm; <br> <br>      /*  because this is the fSameAsLoad==TRUE case, we will save <br>      **    into the streams that we hold open. we will AddRef the <br>      **    stream here so that the release below will NOT close the <br>      **    stream. <br>      */ <br>      lpLLStm-&gt;lpVtbl-&gt;AddRef(lpLLStm); <br> <br>      // truncate the current stream and seek to beginning <br>      lpLLStm-&gt;lpVtbl-&gt;SetSize(lpLLStm, ulibZero); <br>      lpLLStm-&gt;lpVtbl-&gt;Seek( <br>            lpLLStm, libZero, STREAM_SEEK_SET, NULL); <br> <br>      lpNTStm = lpOleDoc-&gt;m_lpNTStm; <br>      lpNTStm-&gt;lpVtbl-&gt;AddRef(lpNTStm);   // (see comment above) <br> <br>      // truncate the current stream and seek to beginning <br>      lpNTStm-&gt;lpVtbl-&gt;SetSize(lpNTStm, ulibZero); <br>      lpNTStm-&gt;lpVtbl-&gt;Seek( <br>            lpNTStm, libZero, STREAM_SEEK_SET, NULL); <br>   } else <br>#endif  // OLE_VERSION <br>   { <br>      hrErr = lpDestStg-&gt;lpVtbl-&gt;CreateStream( <br>            lpDestStg, <br>            OLESTR("LineList"), <br>            STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>            0, <br>            0, <br>            &amp;lpLLStm <br>      ); <br>      if (hrErr != NOERROR) { <br>         OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream"); <br>         OleDbgOutHResult("LineList CreateStream returned", hrErr); <br>         goto error; <br>      } <br> <br>      hrErr = lpDestStg-&gt;lpVtbl-&gt;CreateStream( <br>            lpDestStg, <br>            OLESTR("NameTable"), <br>            STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>            0, <br>            0, <br>            &amp;lpNTStm <br>      ); <br>      if (hrErr != NOERROR) { <br>         OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream"); <br>         OleDbgOutHResult("NameTable CreateStream returned", hrErr); <br>         goto error; <br>      } <br>   } <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   _fmemset((LPOUTLINEDOCHEADER)&amp;docRecord,0,sizeof(OUTLINEDOCHEADER)); <br>   GetClipboardFormatName( <br>         uFormat, <br>         szAnsiString, <br>         256 <br>   ); <br>   A2W(szAnsiString, docRecord.m_szFormatName, sizeof(docRecord.m_szFormatName) / sizeof(WCHAR)); <br>   OutlineApp_GetAppVersionNo(lpOutlineApp, docRecord.m_narrAppVersionNo); <br> <br>   docRecord.m_fShowHeading = lpOutlineDoc-&gt;m_heading.m_fShow; <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      // Store ServerDoc specific data <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br> <br>      docRecord.m_reserved1 = (DWORD)lpServerDoc-&gt;m_nNextRangeNo; <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      // Store ContainerDoc specific data <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br> <br>      docRecord.m_reserved2 = (DWORD)lpContainerDoc-&gt;m_nNextObjNo; <br>   } <br>#endif <br> <br>   /* write OutlineDoc header record */ <br> <br>    //  Transform docRecord into docRecordOnDisk <br>    //  Compilers should handle aligment correctly <br>    OLESTRCPY(docRecordOnDisk.m_szFormatName, docRecord.m_szFormatName); <br>    docRecordOnDisk.m_narrAppVersionNo[0] = (short) docRecord.m_narrAppVersionNo[0]; <br>    docRecordOnDisk.m_narrAppVersionNo[1] = (short) docRecord.m_narrAppVersionNo[1]; <br>    docRecordOnDisk.m_fShowHeading = (USHORT) docRecord.m_fShowHeading; <br>    docRecordOnDisk.m_reserved1 = docRecord.m_reserved1; <br>    docRecordOnDisk.m_reserved2 = docRecord.m_reserved2; <br>    docRecordOnDisk.m_reserved3 = docRecord.m_reserved3; <br>    docRecordOnDisk.m_reserved4 = docRecord.m_reserved4; <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>         lpLLStm, <br>         (LPVOID)&amp;docRecordOnDisk, <br>         sizeof(docRecordOnDisk), <br>         &amp;nWritten <br>      ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Write OutlineDoc header returned", hrErr); <br>      goto error; <br>    } <br> <br>   // Save LineList <br>   /* NOTE: A ContainerDoc keeps its storage open at all times. It is <br>   **    necessary to pass the current open storage (lpOleDoc-&gt;m_lpStg) <br>   **    to the LineList_SaveSelToStg method so that currently written data <br>   **    for any embeddings is also saved to the new destination <br>   **    storage. The data required by a contained object is both the <br>   **    ContainerLine information and the associated sub-storage that is <br>   **    written directly by the embedded object. <br>   */ <br>   fStatus = LineList_SaveSelToStg( <br>      &amp;lpOutlineDoc-&gt;m_LineList, <br>         lplrSel, <br>         uFormat, <br>#if defined( OLE_CNTR ) <br>         lpOleDoc-&gt;m_lpStg, <br>#else <br>         NULL, <br>#endif <br>         lpDestStg, <br>         lpLLStm, <br>         fRemember <br>   ); <br>   if (! fStatus) goto error; <br> <br>   // Save associated NameTable <br>   fStatus = OutlineNameTable_SaveSelToStg( <br>         lpOutlineDoc-&gt;m_lpNameTable, <br>         lplrSel, <br>         uFormat, <br>         lpNTStm <br>   ); <br> <br>   if (! fStatus) goto error; <br> <br>   OleStdRelease((LPUNKNOWN)lpLLStm); <br>   lpOutlineDoc-&gt;m_cfSaveFormat = uFormat;  // remember format used to save <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>   return TRUE; <br> <br>error: <br>   if (lpLLStm) <br>      OleStdRelease((LPUNKNOWN)lpLLStm); <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>   return FALSE; <br>} <br> <br> <br>/* OutlineDoc_Print <br> * ---------------- <br> *  Prints the contents of the list box in HIMETRIC mapping mode. Origin <br> *  remains to be the upper left corner and the print proceeds down the <br> *  page using a negative y-cordinate. <br> * <br> */ <br>void OutlineDoc_Print(LPOUTLINEDOC lpOutlineDoc, HDC hDC) <br>{ <br>   LPLINELIST lpLL = &amp;lpOutlineDoc-&gt;m_LineList; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   WORD    nIndex; <br>   WORD    nTotal; <br>   int     dy; <br>   BOOL    fError = FALSE; <br>   LPLINE  lpLine; <br>   RECT    rcLine; <br>   RECT    rcPix; <br>   RECT    rcHim; <br>   RECT    rcWindowOld; <br>   RECT    rcViewportOld; <br>   HFONT   hOldFont; <br>   DOCINFO di;         /* Document information for StartDoc function */ <br>   char    szAnsiStr[256]; <br> <br>   /* Get dimension of page */ <br>   rcPix.left = 0; <br>   rcPix.top = 0; <br>   rcPix.right = GetDeviceCaps(hDC, HORZRES); <br>   rcPix.bottom = GetDeviceCaps(hDC, VERTRES); <br> <br>   SetDCToDrawInHimetricRect(hDC, (LPRECT)&amp;rcPix, (LPRECT)&amp;rcHim, <br>         (LPRECT)&amp;rcWindowOld, (LPRECT)&amp;rcViewportOld); <br> <br>   // Set the default font size, and font face name <br>   hOldFont = SelectObject(hDC, lpOutlineApp-&gt;m_hStdFont); <br> <br>   /* Get the lines in document */ <br>   nIndex     = 0; <br>   nTotal  = LineList_GetCount(lpLL); <br> <br>   /* Create the Cancel dialog */ <br>   // REVIEW: should load dialog title from string resource file <br>   hWndPDlg = CreateDialog ( <br>         lpOutlineApp-&gt;m_hInst, <br>         "Print", <br>         lpOutlineApp-&gt;m_hWndApp, <br>         (DLGPROC)PrintDlgProc <br>   ); <br> <br>   if(!hWndPDlg) <br>      goto getout; <br> <br>   /* Allow the app. to inform GDI of the abort function to call */ <br>   if(SetAbortProc(hDC, (ABORTPROC)AbortProc) &lt; 0) { <br>      fError = TRUE; <br>      goto getout3; <br>   } <br> <br>   /* Disable the main application window */ <br>   EnableWindow (lpOutlineApp-&gt;m_hWndApp, FALSE); <br> <br>   // initialize the rectangle for the first line <br>   rcLine.left = rcHim.left; <br>   rcLine.bottom = rcHim.top; <br> <br>   /* Initialize the document */ <br>   fCancelPrint = FALSE; <br> <br>   di.cbSize = sizeof(DOCINFO); <br>   W2A (lpOutlineDoc-&gt;m_lpszDocTitle, szAnsiStr, 256); <br>   di.lpszDocName = szAnsiStr; <br>   di.lpszOutput = NULL; <br> <br>   if(StartDoc(hDC, (DOCINFO FAR*)&amp;di) &lt;= 0) { <br>      fError = TRUE; <br>      OleDbgOut2("StartDoc error\n"); <br>      goto getout5; <br>   } <br> <br>   if(StartPage(hDC) &lt;= 0) {       // start first page <br>      fError = TRUE; <br>      OleDbgOut2("StartPage error\n"); <br>      goto getout2; <br>   } <br> <br>   /* While more lines print out the text */ <br>   while(nIndex &lt; nTotal) { <br>      lpLine = LineList_GetLine(lpLL, nIndex); <br>      if (! lpLine) <br>         continue; <br> <br>      dy = Line_GetHeightInHimetric(lpLine); <br> <br>      /* Reached end of page. Tell the device driver to eject a page */ <br>      if(rcLine.bottom - dy &lt; rcHim.bottom) { <br>         if (EndPage(hDC) &lt; 0) { <br>            fError=TRUE; <br>            OleDbgOut2("EndPage error\n"); <br>            goto getout2; <br>         } <br> <br>         // NOTE: Reset the Mapping mode of DC <br>         SetDCToDrawInHimetricRect(hDC, (LPRECT)&amp;rcPix, (LPRECT)&amp;rcHim, <br>               (LPRECT)&amp;rcWindowOld, (LPRECT)&amp;rcViewportOld); <br> <br>         // Set the default font size, and font face name <br>         SelectObject(hDC, lpOutlineApp-&gt;m_hStdFont); <br> <br>         if (StartPage(hDC) &lt;= 0) { <br>            fError=TRUE; <br>            OleDbgOut2("StartPage error\n"); <br>            goto getout2; <br>         } <br> <br>         rcLine.bottom = rcHim.top; <br>      } <br> <br>      rcLine.top = rcLine.bottom; <br>      rcLine.bottom -= dy; <br>      rcLine.right = rcLine.left + Line_GetWidthInHimetric(lpLine); <br> <br>      /* Print the line */ <br>      Line_Draw(lpLine, hDC, &amp;rcLine, NULL, FALSE /*fHighlight*/); <br> <br>      OleDbgOut2("a line is drawn\n"); <br> <br>      /* Test and see if the Abort flag has been set. If yes, exit. */ <br>      if (fCancelPrint) <br>         goto getout2; <br> <br>      /* Move down the page */ <br>      nIndex++; <br>   } <br> <br>   { <br>      int nCode; <br> <br>      /* Eject the last page. */ <br>      if((nCode = EndPage(hDC)) &lt; 0) { <br>#if defined( _DEBUG ) <br>         char szBuf[255]; <br>         wsprintf(szBuf, "EndPage error code is %d\n", nCode); <br>         OleDbgOut2(szBuf); <br>#endif <br>         fError=TRUE; <br>         goto getout2; <br>      } <br>   } <br> <br> <br>   /* Complete the document. */ <br>   if(EndDoc(hDC) &lt; 0) { <br>      fError=TRUE; <br>      OleDbgOut2("EndDoc error\n"); <br> <br>getout2: <br>      /* Ran into a problem before NEWFRAME? Abort the document */ <br>      AbortDoc(hDC); <br>   } <br> <br>getout5: <br>   /* Re-enable main app. window */ <br>   EnableWindow (lpOutlineApp-&gt;m_hWndApp, TRUE); <br> <br>getout3: <br>   /* Close the cancel dialog */ <br>   DestroyWindow (hWndPDlg); <br> <br>getout: <br> <br>   /* Error? make sure the user knows... */ <br>   if(fError || CommDlgExtendedError()) <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPrint); <br> <br>   SelectObject(hDC, hOldFont); <br>} <br> <br> <br> <br> <br> <br>/* OutlineDoc_DialogHelp <br> * --------------------- <br> * <br> *  Show help message for ole2ui dialogs. <br> * <br> * Parameters: <br> * <br> *   hDlg      HWND to the dialog the help message came from - use <br> *             this in the call to WinHelp/MessageBox so that <br> *             activation/focus goes back to the dialog, and not the <br> *             main window. <br> * <br> *   wParam    ID of the dialog (so we know what type of dialog it is). <br> */ <br>void OutlineDoc_DialogHelp(HWND hDlg, WPARAM wDlgID) <br>{ <br> <br>   char szMessageBoxText[64]; <br> <br>   if (!IsWindow(hDlg))  // don't do anything if we've got a bogus hDlg. <br>    return; <br> <br>   lstrcpy(szMessageBoxText, "Help Message for "); <br> <br>   switch (wDlgID) <br>   { <br> <br>   case IDD_CONVERT: <br>      lstrcat(szMessageBoxText, "Convert"); <br>      break; <br> <br>   case IDD_CHANGEICON: <br>      lstrcat(szMessageBoxText, "Change Icon"); <br>      break; <br> <br>   case IDD_INSERTOBJECT: <br>      lstrcat(szMessageBoxText, "Insert Object"); <br>      break; <br> <br>   case IDD_PASTESPECIAL: <br>      lstrcat(szMessageBoxText, "Paste Special"); <br>      break; <br> <br>   case IDD_EDITLINKS: <br>      lstrcat(szMessageBoxText, "Edit Links"); <br>      break; <br> <br>   case IDD_CHANGESOURCE: <br>      lstrcat(szMessageBoxText, "Change Source"); <br>      break; <br> <br>   case IDD_INSERTFILEBROWSE: <br>      lstrcat(szMessageBoxText, "Insert From File Browse"); <br>      break; <br> <br>   case IDD_CHANGEICONBROWSE: <br>      lstrcat(szMessageBoxText, "Change Icon Browse"); <br>      break; <br> <br>   default: <br>      lstrcat(szMessageBoxText, "Unknown"); <br>      break; <br>   } <br> <br>   lstrcat(szMessageBoxText, " Dialog."); <br> <br>   // You'd probably really a call to WinHelp here. <br>   MessageBox(hDlg, szMessageBoxText, "Help", MB_OK); <br> <br>   return; <br>} <br> <br> <br>/* OutlineDoc_SetCurrentZoomCommand <br> * -------------------------------- <br> * <br> *  Set current zoom level to be checked in the menu. <br> *  Set the corresponding scalefactor for the document. <br> */ <br>void OutlineDoc_SetCurrentZoomCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                uCurrentZoom <br>) <br>{ <br>   SCALEFACTOR scale; <br> <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   lpOutlineDoc-&gt;m_uCurrentZoom = uCurrentZoom; <br> <br>   switch (uCurrentZoom) { <br> <br>#if !defined( OLE_CNTR ) <br>         case IDM_V_ZOOM_400: <br>            scale.dwSxN = (DWORD) 4; <br>            scale.dwSxD = (DWORD) 1; <br>            scale.dwSyN = (DWORD) 4; <br>            scale.dwSyD = (DWORD) 1; <br>            break; <br> <br>         case IDM_V_ZOOM_300: <br>            scale.dwSxN = (DWORD) 3; </code></pre>
<p>
</p>
<pre><code>scale.dwSxD = (DWORD) 1; <br>            scale.dwSyN = (DWORD) 3; <br>            scale.dwSyD = (DWORD) 1; <br>            break; <br> <br>         case IDM_V_ZOOM_200: <br>            scale.dwSxN = (DWORD) 2; <br>            scale.dwSxD = (DWORD) 1; <br>            scale.dwSyN = (DWORD) 2; <br>            scale.dwSyD = (DWORD) 1; <br>            break; <br>#endif      // !OLE_CNTR <br> <br>         case IDM_V_ZOOM_100: <br>            scale.dwSxN = (DWORD) 1; <br>            scale.dwSxD = (DWORD) 1; <br>            scale.dwSyN = (DWORD) 1; <br>            scale.dwSyD = (DWORD) 1; <br>            break; <br> <br>         case IDM_V_ZOOM_75: <br>            scale.dwSxN = (DWORD) 3; <br>            scale.dwSxD = (DWORD) 4; <br>            scale.dwSyN = (DWORD) 3; <br>            scale.dwSyD = (DWORD) 4; <br>            break; <br> <br>         case IDM_V_ZOOM_50: <br>            scale.dwSxN = (DWORD) 1; <br>            scale.dwSxD = (DWORD) 2; <br>            scale.dwSyN = (DWORD) 1; <br>            scale.dwSyD = (DWORD) 2; <br>            break; <br> <br>         case IDM_V_ZOOM_25: <br>            scale.dwSxN = (DWORD) 1; <br>            scale.dwSxD = (DWORD) 4; <br>            scale.dwSyN = (DWORD) 1; <br>            scale.dwSyD = (DWORD) 4; <br>            break; <br>   } <br> <br>   OutlineDoc_SetScaleFactor(lpOutlineDoc, (LPSCALEFACTOR)&amp;scale, NULL); <br>} <br> <br> <br>/* OutlineDoc_GetCurrentZoomMenuCheck <br> * ---------------------------------- <br> * <br> *  Get current zoom level to be checked in the menu. <br> */ <br>UINT OutlineDoc_GetCurrentZoomMenuCheck(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   return lpOutlineDoc-&gt;m_uCurrentZoom; <br>} <br> <br> <br>/* OutlineDoc_SetScaleFactor <br> * ------------------------- <br> * <br> *  Set the scale factor of the document which will affect the <br> *      size of the document on the screen <br> * <br> * Parameters: <br> * <br> *   scale      structure containing x and y scales <br> */ <br>void OutlineDoc_SetScaleFactor( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      LPSCALEFACTOR       lpscale, <br>      LPRECT              lprcDoc <br>) <br>{ <br>   LPLINELIST      lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   HWND            hWndLL = LineList_GetWindow(lpLL); <br> <br>   if (!lpOutlineDoc || !lpscale) <br>      return; <br> <br>   InvalidateRect(hWndLL, NULL, TRUE); <br> <br>   lpOutlineDoc-&gt;m_scale = *lpscale; <br>   LineList_ReScale((LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList, lpscale); <br> <br>#if defined( USE_HEADING ) <br>   Heading_ReScale((LPHEADING)&amp;lpOutlineDoc-&gt;m_heading, lpscale); <br>#endif <br> <br>   OutlineDoc_Resize(lpOutlineDoc, lprcDoc); <br>} <br> <br> <br>/* OutlineDoc_GetScaleFactor <br> * ------------------------- <br> * <br> *  Retrieve the scale factor of the document <br> * <br> * Parameters: <br> * <br> */ <br>LPSCALEFACTOR OutlineDoc_GetScaleFactor(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (!lpOutlineDoc) <br>      return NULL; <br> <br>   return (LPSCALEFACTOR)&amp;lpOutlineDoc-&gt;m_scale; <br>} <br> <br> <br>/* OutlineDoc_SetCurrentMarginCommand <br> * ---------------------------------- <br> * <br> *  Set current Margin level to be checked in the menu. <br> */ <br>void OutlineDoc_SetCurrentMarginCommand( <br>      LPOUTLINEDOC        lpOutlineDoc, <br>      UINT                uCurrentMargin <br>) <br>{ <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   lpOutlineDoc-&gt;m_uCurrentMargin = uCurrentMargin; <br> <br>   switch (uCurrentMargin) { <br>      case IDM_V_SETMARGIN_0: <br>         OutlineDoc_SetMargin(lpOutlineDoc, 0, 0); <br>         break; <br> <br>      case IDM_V_SETMARGIN_1: <br>         OutlineDoc_SetMargin(lpOutlineDoc, 1000, 1000); <br>         break; <br> <br>      case IDM_V_SETMARGIN_2: <br>         OutlineDoc_SetMargin(lpOutlineDoc, 2000, 2000); <br>         break; <br> <br>      case IDM_V_SETMARGIN_3: <br>         OutlineDoc_SetMargin(lpOutlineDoc, 3000, 3000); <br>         break; <br> <br>      case IDM_V_SETMARGIN_4: <br>         OutlineDoc_SetMargin(lpOutlineDoc, 4000, 4000); <br>         break; <br>   } <br>} <br> <br> <br>/* OutlineDoc_GetCurrentMarginMenuCheck <br> * ------------------------------------ <br> * <br> *  Get current Margin level to be checked in the menu. <br> */ <br>UINT OutlineDoc_GetCurrentMarginMenuCheck(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   return lpOutlineDoc-&gt;m_uCurrentMargin; <br>} <br> <br> <br>/* OutlineDoc_SetMargin <br> * -------------------- <br> * <br> *  Set the left and right margin of the document <br> * <br> * Parameters: <br> *      nLeftMargin  - left margin in Himetric values <br> *      nRightMargin - right margin in Himetric values <br> */ <br>void OutlineDoc_SetMargin(LPOUTLINEDOC lpOutlineDoc, int nLeftMargin, int nRightMargin) <br>{ <br>   LPLINELIST lpLL; <br>   int        nMaxWidthInHim; <br> <br>   if (!lpOutlineDoc) <br>      return; <br> <br>   lpOutlineDoc-&gt;m_nLeftMargin = nLeftMargin; <br>   lpOutlineDoc-&gt;m_nRightMargin = nRightMargin; <br>   lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br> <br>   // Force recalculation of Horizontal extent <br>   nMaxWidthInHim = LineList_GetMaxLineWidthInHimetric(lpLL); <br>   LineList_SetMaxLineWidthInHimetric(lpLL, -nMaxWidthInHim); <br> <br>#if defined( INPLACE_CNTR ) <br>   ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0); <br>#endif <br> <br>   OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE); <br>} <br> <br> <br>/* OutlineDoc_GetMargin <br> * -------------------- <br> * <br> *  Get the left and right margin of the document <br> * <br> *  Parameters: <br> *      nLeftMargin  - left margin in Himetric values <br> *      nRightMargin - right margin in Himetric values <br> * <br> *  Returns: <br> *      low order word  - left margin <br> *      high order word - right margin <br> */ <br>LONG OutlineDoc_GetMargin(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (!lpOutlineDoc) <br>      return 0; <br> <br>   return MAKELONG(lpOutlineDoc-&gt;m_nLeftMargin, lpOutlineDoc-&gt;m_nRightMargin); <br>} <br> <br>#if defined( USE_HEADING ) <br> <br>/* OutlineDoc_GetHeading <br> * --------------------- <br> * <br> *      Get Heading Object in OutlineDoc <br> */ <br>LPHEADING OutlineDoc_GetHeading(LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   if (!lpOutlineDoc || lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      return NULL; <br>   else <br>      return (LPHEADING)&amp;lpOutlineDoc-&gt;m_heading; <br>} <br> <br> <br>/* OutlineDoc_ShowHeading <br> * ---------------------- <br> * <br> *  Show/Hide document row/column headings. <br> */ <br>void OutlineDoc_ShowHeading(LPOUTLINEDOC lpOutlineDoc, BOOL fShow) <br>{ <br>   LPHEADING   lphead = OutlineDoc_GetHeading(lpOutlineDoc); <br>#if defined( INPLACE_SVR ) <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>#endif <br> <br>   if (! lphead) <br>      return; <br> <br>   Heading_Show(lphead, fShow); <br> <br>#if defined( INPLACE_SVR ) <br>   if (lpServerDoc-&gt;m_fUIActive) { <br>      LPINPLACEDATA lpIPData = lpServerDoc-&gt;m_lpIPData; <br> <br>      /* NOTE: our extents have NOT changed; only our the size of <br>      **    our object-frame adornments is changing. we can use the <br>      **    current PosRect and ClipRect and simply resize our <br>      **    windows WITHOUT informing our in-place container. <br>      */ <br>      ServerDoc_ResizeInPlaceWindow( <br>            lpServerDoc, <br>            (LPRECT)&amp;(lpIPData-&gt;rcPosRect), <br>            (LPRECT)&amp;(lpIPData-&gt;rcClipRect) <br>      ); <br>   } else <br>#else   // !INPLACE_SVR <br> <br>   OutlineDoc_Resize(lpOutlineDoc, NULL); <br> <br>#if defined( INPLACE_CNTR ) <br>   ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0); <br>#endif  // INPLACE_CNTR <br> <br>#endif  // INPLACE_SVR <br> <br>   OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE); <br>} <br> <br>#endif  // USE_HEADING <br> <br> <br>/* AbortProc <br> * --------- <br> *  AborProc is called by GDI print code to check for user abort. <br> */ <br>BOOL FAR PASCAL EXPORT AbortProc (HDC hdc, WORD reserved) <br>{ <br>   MSG msg; <br> <br>   /* Allow other apps to run, or get abort messages */ <br>   while(! fCancelPrint &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) { <br>      if(!hWndPDlg || !IsDialogMessage (hWndPDlg, &amp;msg)) { <br>         TranslateMessage (&amp;msg); <br>         DispatchMessage  (&amp;msg); <br>      } <br>   } <br>   return !fCancelPrint; <br>} <br> <br> <br>/* PrintDlgProc <br> * ------------ <br> *  Dialog function for the print cancel dialog box. <br> * <br> *  RETURNS    : TRUE  - OK to abort/ not OK to abort <br> *               FALSE - otherwise. <br> */ <br>BOOL FAR PASCAL EXPORT PrintDlgProc( <br>      HWND hwnd, <br>      WORD msg, <br>      WORD wParam, <br>      LONG lParam <br>) <br>{ <br>   switch (msg) { <br>      case WM_COMMAND: <br>      /* abort printing if the only button gets hit */ <br>         fCancelPrint = TRUE; <br>         return TRUE; <br>   } <br> <br>   return FALSE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
