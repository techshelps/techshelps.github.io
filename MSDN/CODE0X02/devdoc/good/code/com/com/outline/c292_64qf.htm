<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context297"></a>OUTLAPP.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outlapp.c <br>** <br>**    This file contains OutlineApp functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br>#include "ansiapi.h" <br> <br>#if defined( USE_STATUSBAR ) <br>#include "status.h" <br>#endif <br> <br>#if !defined( WIN32 ) <br>#include &lt;print.h&gt; <br>#endif <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br>extern RECT g_rectNull; <br> <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR ErrMsgClass[] = OLESTR("Can't register window classes!"); <br>OLECHAR ErrMsgFrame[] = OLESTR("Can't create Frame Window!"); <br>OLECHAR ErrMsgPrinting[] = OLESTR("Can't access printer!"); <br> <br> <br>/* OutlineApp_InitApplication <br>** -------------------------- <br>** Sets up the class data structures and does a one-time <br>**      initialization of the app by registering the window classes. <br>**      Returns TRUE if initialization is successful <br>**              FALSE otherwise <br>*/ <br> <br>BOOL OutlineApp_InitApplication(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst) <br>{ <br>   WNDCLASS    wndclass; <br> <br>   // REVIEW: should load msg strings from string resource <br> <br>   /* Register the app frame class */ <br>   wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW; <br>   wndclass.lpfnWndProc = AppWndProc; <br>   /* Extra storage for Class and Window objects */ <br>   wndclass.cbClsExtra = 0; <br>   wndclass.cbWndExtra = sizeof(LPOUTLINEAPP); /* to store lpApp */ <br>   wndclass.hInstance = hInst; <br>   wndclass.hIcon = LoadIcon(hInst, APPICON); <br>   wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   /* Create brush for erasing background */ <br>   wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>   wndclass.lpszMenuName = APPMENU;     /* Menu Name is App Name */ <br>   wndclass.lpszClassName = APPWNDCLASS; /* Class Name is App Name */ <br> <br>   if(! RegisterClass(&amp;wndclass)) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFrame); <br>      return FALSE; <br>   } <br> <br>   /* Register the document window class */ <br>   wndclass.style = CS_BYTEALIGNWINDOW; <br>   wndclass.lpfnWndProc = DocWndProc; <br>   wndclass.hIcon = NULL; <br>   wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>   wndclass.lpszMenuName = NULL; <br>   wndclass.lpszClassName = DOCWNDCLASS; <br>   wndclass.cbWndExtra = sizeof(LPOUTLINEDOC); /* to store lpDoc */ <br>   if(! RegisterClass(&amp;wndclass)) { <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgClass); <br>      return FALSE; <br>   } <br> <br>#if defined( USE_STATUSBAR ) <br>   if (! RegisterStatusClass(hInst)) <br>      return FALSE; <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (! FrameToolsRegisterClass(hInst)) { <br>      return FALSE; <br>   } <br>#endif <br> <br>#if defined( INPLACE_SVR ) <br>   // We should only register the hatch window class <br>   // in the UI Library once per application. <br>   RegisterHatchWindowClass(hInst); <br> <br>#endif <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineApp_InitInstance <br> * ----------------------- <br> * <br> *  Performs a per-instance initialization of app. <br> *  This method creates the frame window. <br> * <br> *  RETURNS    : TRUE  - If initialization was successful. <br> *               FALSE - otherwise. <br> */ <br> <br>BOOL OutlineApp_InitInstance(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst, int nCmdShow) <br>{ <br>   char  szAnsiString[256]; <br>   lpOutlineApp-&gt;m_hInst = hInst; <br> <br>   /* create application's Frame window */ <br>   W2A (APPNAME, szAnsiString, 256); <br>   lpOutlineApp-&gt;m_hWndApp = CreateWindow( <br>         APPWNDCLASS,             /* Window class name */ <br>         szAnsiString,            /* initial Window title */ <br>         WS_OVERLAPPEDWINDOW| <br>         WS_CLIPCHILDREN, <br>         CW_USEDEFAULT, 0,        /* Use default X, Y            */ <br>         CW_USEDEFAULT, 0,        /* Use default X, Y            */ <br>         HWND_DESKTOP,            /* Parent window's handle      */ <br>         NULL,                    /* Default to Class Menu       */ <br>         hInst,                   /* Instance of window          */ <br>         NULL                     /* Create struct for WM_CREATE */ <br>   ); <br> <br>   if(! lpOutlineApp-&gt;m_hWndApp) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFrame); <br>      return FALSE; <br>   } <br> <br>   SetWindowLong(lpOutlineApp-&gt;m_hWndApp, 0, (LONG) lpOutlineApp); <br> <br>   /* defer creating the user's SDI document until we parse the cmd line. */ <br>   lpOutlineApp-&gt;m_lpDoc = NULL; <br> <br>   /* Initialize clipboard. <br>   */ <br>   lpOutlineApp-&gt;m_lpClipboardDoc = NULL; <br>   W2A (OUTLINEDOCFORMAT, szAnsiString, 256); <br>   if(!(lpOutlineApp-&gt;m_cfOutline = RegisterClipboardFormat(szAnsiString))) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Can't register clipboard format!")); <br>      return FALSE; <br>   } <br> <br>   /* init the standard font to be used for drawing/printing text <br>   *       request a Roman style True Type font of the desired size <br>   */ <br>   lpOutlineApp-&gt;m_hStdFont = CreateFont( <br>         -DEFFONTSIZE, <br>         0,0,0,0,0,0,0,0, <br>         OUT_TT_PRECIS,      // use TrueType <br>         CLIP_DEFAULT_PRECIS, <br>         DEFAULT_QUALITY, <br>         VARIABLE_PITCH | FF_ROMAN, <br>         DEFFONTFACE <br>   ); <br> <br>   // Load special cursor for selection of Lines in ListBox. <br>   lpOutlineApp-&gt;m_hcursorSelCur = LoadCursor ( hInst, "SelCur" ); <br> <br>   /* init the Print Dialog structure */ <br>   _fmemset((LPVOID)&amp;lpOutlineApp-&gt;m_PrintDlg,0,sizeof(PRINTDLG)); <br>   lpOutlineApp-&gt;m_PrintDlg.lStructSize = sizeof(PRINTDLG); <br>   lpOutlineApp-&gt;m_PrintDlg.hDevMode = NULL; <br>   lpOutlineApp-&gt;m_PrintDlg.hDevNames = NULL; <br>   lpOutlineApp-&gt;m_PrintDlg.Flags = PD_RETURNDC | PD_NOSELECTION | PD_NOPAGENUMS | <br>               PD_HIDEPRINTTOFILE; <br>   lpOutlineApp-&gt;m_PrintDlg.nCopies = 1; <br>   lpOutlineApp-&gt;m_PrintDlg.hwndOwner = lpOutlineApp-&gt;m_hWndApp; <br> <br>#if defined( USE_STATUSBAR ) <br>   lpOutlineApp-&gt;m_hWndStatusBar = CreateStatusWindow(lpOutlineApp-&gt;m_hWndApp, hInst); <br>   if (! lpOutlineApp-&gt;m_hWndStatusBar) <br>      return FALSE; <br> <br>   lpOutlineApp-&gt;m_hMenuApp = GetMenu(lpOutlineApp-&gt;m_hWndApp); <br> <br>   /* setup status messages for the application menus */ <br>   { <br>      HMENU hMenuFile = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 0); <br>      HMENU hMenuEdit = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 1); <br>      HMENU hMenuOutline = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 2); <br>      HMENU hMenuLine = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 3); <br>      HMENU hMenuName = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 4); <br>      HMENU hMenuOptions = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 5); <br>      HMENU hMenuDebug = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 6); <br>      HMENU hMenuHelp = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 7); <br>      HMENU hMenuSys = GetSystemMenu(lpOutlineApp-&gt;m_hWndApp, FALSE); <br> <br>      AssignPopupMessage(hMenuFile, "Create, open, save, print outlines or quit application"); <br>      AssignPopupMessage(hMenuEdit, "Cut, copy, paste or clear selection"); <br>      AssignPopupMessage(hMenuOutline, "Set zoom and margins"); <br>      AssignPopupMessage(hMenuLine, "Create, edit, and indent lines"); <br>      AssignPopupMessage(hMenuName, "Create, edit, delete and goto names"); <br>      AssignPopupMessage(hMenuOptions, "Modify tools, row/col headings, display options"); <br>      AssignPopupMessage(hMenuDebug, "Set debug trace level and other debug options"); <br>      AssignPopupMessage(hMenuHelp, "Get help on using the application"); <br>      AssignPopupMessage(hMenuSys,"Move, size or close application window"); <br>   } <br>#endif <br> <br>#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR ) <br>   lpOutlineApp-&gt;m_FrameToolWidths = g_rectNull; <br>#endif  // USE_FRAMETOOLS || INPLACE_CNTR <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (! FrameTools_Init(&amp;lpOutlineApp-&gt;m_frametools, <br>         lpOutlineApp-&gt;m_hWndApp, lpOutlineApp-&gt;m_hInst)) <br>      return FALSE; <br>#endif <br> <br>#if defined( OLE_VERSION ) <br> <br>   /* NOTE: perform initialization required for OLE */ <br>   if (! OleApp_InitInstance((LPOLEAPP)lpOutlineApp, hInst, nCmdShow)) <br>      return FALSE; <br>#else <br>   /* NOTE: Although no OLE call is made in the base outline, <br>   **    OLE memory allocator is used and thus CoInitialize() needs to <br>   **    be called. <br>   */ <br>   { <br>      HRESULT hrErr; <br> <br>      hrErr = CoInitialize(NULL); <br>      if (hrErr != NOERROR) { <br>         OutlineApp_ErrorMessage(lpOutlineApp, <br>               OLESTR("CoInitialize initialization failed!")); <br>         return FALSE; <br>      } <br>   } <br>#endif <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineApp_ParseCmdLine <br> * ----------------------- <br> * <br> * Parse the command line for any execution flags/arguments. <br> */ <br>BOOL OutlineApp_ParseCmdLine(LPOUTLINEAPP lpOutlineApp, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br> <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   return OleApp_ParseCmdLine((LPOLEAPP)lpOutlineApp,lpszCmdLine,nCmdShow); <br> <br>#else <br> <br>   BOOL fStatus = TRUE; <br>   char szFileName[256];   /* buffer for filename in command line */ <br>   OLECHAR szTempW[256];   /* buffer for unicode/ansi strings*/ <br> <br>   szFileName[0] = '\0'; <br>   ParseCmdLine(lpszCmdLine, NULL, (LPSTR)szFileName); <br> <br>   if(*szFileName) { <br>      // allocate a new document <br>      lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>      if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>      // open the specified file <br>      A2W(szFileName, szTempW, 256); <br>      if (! OutlineDoc_LoadFromFile(lpOutlineApp-&gt;m_lpDoc, szTempW)) <br>         goto error; <br>   } else { <br>      // create a new document <br>      lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>      if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>      // set the doc to an (Untitled) doc. <br>      if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>         goto error; <br>   } <br> <br>   // position and size the new doc window <br>   OutlineApp_ResizeWindows(lpOutlineApp); <br>   OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); <br> <br>   // show main app window <br>   ShowWindow(lpOutlineApp-&gt;m_hWndApp, nCmdShow); <br>   UpdateWindow(lpOutlineApp-&gt;m_hWndApp); <br> <br>   return TRUE; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Could not create new document")); <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>      OutlineDoc_Destroy(lpOutlineApp-&gt;m_lpDoc); <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   } <br> <br>   return FALSE; <br> <br>#endif <br>} <br> <br> <br>/* OutlineApp_InitMenu <br> * ------------------- <br> * <br> *      Enable or Disable menu items depending on the state of <br> * the appliation <br> */ <br>void OutlineApp_InitMenu(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc, HMENU hMenu) <br>{ <br>   WORD status; <br>   static UINT     uCurrentZoom = (UINT)-1; <br>   static UINT     uCurrentMargin = (UINT)-1; <br>   static UINT     uBBState = (UINT)-1; <br>   static UINT     uFBState = (UINT)-1; <br> <br>   if (!lpOutlineApp || !lpOutlineDoc || !hMenu) <br>      return; <br> <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_UNDO, MF_GRAYED); <br> <br>   status = (WORD)(OutlineDoc_GetLineCount(lpOutlineDoc) ? MF_ENABLED : MF_GRAYED); <br> <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_CUT ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_COPY ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_CLEAR ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_SELECTALL ,status); <br> <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_EDITLINE ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_INDENTLINE ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_UNINDENTLINE ,status); <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_SETLINEHEIGHT ,status); <br> <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_N_DEFINENAME ,status); <br> <br>   status = (WORD)(OutlineDoc_GetNameCount(lpOutlineDoc) ? MF_ENABLED : MF_GRAYED); <br> <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_N_GOTONAME, status); <br> <br>   if (uCurrentZoom != (UINT)-1) <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uCurrentZoom, MF_UNCHECKED); <br>   uCurrentZoom = OutlineDoc_GetCurrentZoomMenuCheck(lpOutlineDoc); <br>   CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uCurrentZoom, MF_CHECKED); <br> <br>   if (uCurrentMargin != (UINT)-1) <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uCurrentMargin, MF_UNCHECKED); <br>   uCurrentMargin = OutlineDoc_GetCurrentMarginMenuCheck(lpOutlineDoc); <br>   CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uCurrentMargin, MF_CHECKED); <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (uBBState != (UINT)-1) <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uBBState, MF_UNCHECKED); <br>   if (lpOutlineDoc-&gt;m_lpFrameTools) { <br>      switch (FrameTools_BB_GetState(lpOutlineDoc-&gt;m_lpFrameTools)) { <br>         case BARSTATE_TOP: <br>            uBBState = IDM_O_BB_TOP; <br>            break; <br>         case BARSTATE_BOTTOM: <br>            uBBState = IDM_O_BB_BOTTOM; <br>            break; <br>         case BARSTATE_POPUP: <br>            uBBState = IDM_O_BB_POPUP; <br>            break; <br>         case BARSTATE_HIDE: <br>            uBBState = IDM_O_BB_HIDE; <br>            break; <br>      } <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uBBState, MF_CHECKED); <br>   } <br> <br>   if (uFBState != (UINT)-1) <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uFBState, MF_UNCHECKED); <br>   if (lpOutlineDoc-&gt;m_lpFrameTools) { <br>      switch (FrameTools_FB_GetState(lpOutlineDoc-&gt;m_lpFrameTools)) { <br>         case BARSTATE_TOP: <br>            uFBState = IDM_O_FB_TOP; <br>            break; <br>         case BARSTATE_BOTTOM: <br>            uFBState = IDM_O_FB_BOTTOM; <br>            break; <br>         case BARSTATE_POPUP: <br>            uFBState = IDM_O_FB_POPUP; <br>            break; <br>      } <br>      CheckMenuItem(lpOutlineApp-&gt;m_hMenuApp, uFBState, MF_CHECKED); <br>   } <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: perform OLE specific menu initialization. <br>   **    the OLE versions use the OleGetClipboard mechanism for <br>   **    clipboard handling. thus, they determine if the Paste and <br>   **    PasteSpecial commands should be enabled in an OLE specific <br>   **    manner. <br>   **    (Container only) build the OLE object verb menu if necessary. <br>   */ <br>   OleApp_InitMenu( <br>         (LPOLEAPP)lpOutlineApp, <br>         (LPOLEDOC)lpOutlineDoc, <br>         lpOutlineApp-&gt;m_hMenuApp <br>   ); <br> <br>   /* NOTE: To avoid the overhead of initializing the Edit menu, <br>   **    we do it only when it is popped up. Thus we just set a flag <br>   **    in the OleDoc saying that the Edit menu needs to be updated <br>   **    but we don't do it immediately <br>   */ <br>   OleDoc_SetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc, TRUE); <br> <br>#else <br>   // Base Outline version uses standard Windows clipboard handling <br>   if(IsClipboardFormatAvailable(lpOutlineApp-&gt;m_cfOutline) || <br>      IsClipboardFormatAvailable(CF_TEXT)) <br>      status = MF_ENABLED; <br>   else <br>      status = MF_GRAYED; <br>   EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_E_PASTE, status); <br> <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>   if (! OutlineDoc_IsEditFocusInFormulaBar(lpOutlineDoc)) { <br>      EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_ADDLINE, MF_GRAYED); <br>      EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_EDITLINE, MF_GRAYED); <br>   } <br>   else <br>      EnableMenuItem(lpOutlineApp-&gt;m_hMenuApp, IDM_L_ADDLINE, MF_ENABLED); <br> <br>#endif      // USE_FRAMETOOLS <br> <br>} <br> <br> <br>/* OutlineApp_GetWindow <br> * -------------------- <br> * <br> *      Get the window handle of the application frame. <br> */ <br>HWND OutlineApp_GetWindow(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   if (!lpOutlineApp) <br>      return NULL; <br> <br>   return lpOutlineApp-&gt;m_hWndApp; <br>} <br> <br> <br>/* OutlineApp_GetFrameWindow <br>** ------------------------- <br>**    Gets the current frame window to use as a parent to any dialogs <br>**    this app uses. <br>** <br>**    NOTE: normally this is simply the main hWnd of the app. but, <br>**    if the app is currently supporting an in-place server document, <br>**    then the frame window of the top in-place container must be used. <br>*/ <br>HWND OutlineApp_GetFrameWindow(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   HWND hWndApp = OutlineApp_GetWindow(lpOutlineApp); <br> <br>#if defined( INPLACE_SVR ) <br>   LPSERVERDOC lpServerDoc = <br>         (LPSERVERDOC)OutlineApp_GetActiveDoc(lpOutlineApp); <br>   if (lpServerDoc &amp;&amp; lpServerDoc-&gt;m_fUIActive) <br>      return lpServerDoc-&gt;m_lpIPData-&gt;frameInfo.hwndFrame; <br>#endif <br> <br>   return hWndApp; <br>} <br> <br> <br>/* OutlineApp_GetInstance <br> * ---------------------- <br> * <br> *      Get the process instance of the application. <br> */ <br>HINSTANCE OutlineApp_GetInstance(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   if (!lpOutlineApp) <br>      return NULL; <br> <br>   return lpOutlineApp-&gt;m_hInst; <br>} <br> <br> <br>/* OutlineApp_CreateDoc <br> * -------------------- <br> * <br> * Allocate a new document of the appropriate type. <br> *  OutlineApp  --&gt; creates OutlineDoc type documents <br> * <br> *      Returns lpOutlineDoc for successful, NULL if error. <br> */ <br>LPOUTLINEDOC OutlineApp_CreateDoc( <br>      LPOUTLINEAPP    lpOutlineApp, <br>      BOOL            fDataTransferDoc <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc; <br> <br>   OLEDBG_BEGIN3("OutlineApp_CreateDoc\r\n") <br> <br>#if defined( OLE_SERVER ) <br>   lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(SERVERDOC)); <br>   _fmemset(lpOutlineDoc, 0, sizeof(SERVERDOC)); <br>#endif <br>#if defined( OLE_CNTR ) <br>   lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(CONTAINERDOC)); <br>   _fmemset(lpOutlineDoc, 0, sizeof(CONTAINERDOC)); <br>#endif <br>#if !defined( OLE_VERSION ) <br>   lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(OUTLINEDOC)); <br>   _fmemset(lpOutlineDoc, 0, sizeof(OUTLINEDOC)); <br>#endif <br> <br>   OleDbgAssertSz(lpOutlineDoc != NULL, "Error allocating OutlineDoc"); <br>   if (lpOutlineDoc == NULL) <br>      return NULL; <br> <br>   // initialize new document <br>   if (! OutlineDoc_Init(lpOutlineDoc, fDataTransferDoc)) <br>      goto error; <br> <br>   OLEDBG_END3 <br>   return lpOutlineDoc; <br> <br>error: <br>   if (lpOutlineDoc) <br>      Delete(lpOutlineDoc); <br> <br>   OLEDBG_END3 <br>   return NULL; <br>} <br> <br> <br>/* OutlineApp_CreateName <br> * --------------------- <br> * <br> * Allocate a new Name of the appropriate type. <br> *  OutlineApp --&gt; creates standard OutlineName type names. <br> *  ServerApp  --&gt; creates enhanced SeverName type names. <br> * <br> *      Returns lpOutlineName for successful, NULL if error. <br> */ <br>LPOUTLINENAME OutlineApp_CreateName(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br> <br>#if defined( OLE_SERVER ) <br>   lpOutlineName = (LPOUTLINENAME)New((DWORD)sizeof(SERVERNAME)); <br>#else <br>   lpOutlineName = (LPOUTLINENAME)New((DWORD)sizeof(OUTLINENAME)); <br>#endif <br> <br>   OleDbgAssertSz(lpOutlineName != NULL, "Error allocating Name"); <br>   if (lpOutlineName == NULL) <br>      return NULL; <br> <br>#if defined( OLE_SERVER ) <br>   _fmemset((LPVOID)lpOutlineName,0,sizeof(SERVERNAME)); <br>#else <br>   _fmemset((LPVOID)lpOutlineName,0,sizeof(OUTLINENAME)); <br>#endif <br> <br>   return lpOutlineName; <br>} <br> <br> <br>/* OutlineApp_DocUnlockApp <br>** ----------------------- <br>**    Forget all references to a closed document. <br>*/ <br>void OutlineApp_DocUnlockApp(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   /* forget pointers to destroyed document */ <br>   if (lpOutlineApp-&gt;m_lpDoc == lpOutlineDoc) <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   else if (lpOutlineApp-&gt;m_lpClipboardDoc == lpOutlineDoc) <br>      lpOutlineApp-&gt;m_lpClipboardDoc = NULL; <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: when there are no open documents and the app is not <br>   **    under the control of the user then revoke our ClassFactory to <br>   **    enable the app to shut down. <br>   ** <br>   **    NOTE: data transfer documents (non-user documents) do NOT <br>   **    hold the app alive. therefore they do not Lock the app. <br>   */ <br>   if (! lpOutlineDoc-&gt;m_fDataTransferDoc) <br>      OleApp_DocUnlockApp((LPOLEAPP)lpOutlineApp, lpOutlineDoc); <br>#endif <br>} <br> <br> <br>/* OutlineApp_NewCommand <br> * --------------------- <br> * <br> *  Start a new untitled document (File.New command). <br> */ <br>void OutlineApp_NewCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   OleApp_NewCommand((LPOLEAPP)lpOutlineApp); <br> <br>#else <br> <br>   LPOUTLINEDOC lpOutlineDoc = lpOutlineApp-&gt;m_lpDoc; <br> <br>   if (! OutlineDoc_Close(lpOutlineDoc, OLECLOSE_PROMPTSAVE)) <br>      return; <br> <br>   OleDbgAssertSz(lpOutlineApp-&gt;m_lpDoc==NULL,"Closed doc NOT properly destroyed"); <br> <br>   lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>   if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>   // set the doc to an (Untitled) doc. <br>   if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>      goto error; <br> <br>   // position and size the new doc window <br>   OutlineApp_ResizeWindows(lpOutlineApp); <br>   OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); // calls OleDoc_Lock <br> <br>   return; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Could not create new document")); <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>      OutlineDoc_Destroy(lpOutlineApp-&gt;m_lpDoc); <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   } <br> <br>   return; <br> <br>#endif <br>} <br> <br> <br>/* OutlineApp_OpenCommand <br> * ---------------------- <br> * <br> *  Load a document from file (File.Open command). <br> */ <br>void OutlineApp_OpenCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>#if defined( OLE_VERSION ) <br>   // Call OLE version of this function instead <br>   OleApp_OpenCommand((LPOLEAPP)lpOutlineApp); <br> <br>#else <br> <br>   OPENFILENAME ofn; <br>   char szFilter[]=APPFILENAMEFILTER; <br>   char szFileName[256]; <br>   OLECHAR szUniFileName[256]; <br>   UINT i; <br>   DWORD dwSaveOption = OLECLOSE_PROMPTSAVE; <br>   BOOL fStatus = TRUE; <br> <br>   if (! OutlineDoc_CheckSaveChanges(lpOutlineApp-&gt;m_lpDoc, &amp;dwSaveOption)) <br>      return;           // abort opening new doc <br> <br>   for(i=0; szFilter[i]; i++) <br>      if(szFilter[i]=='|') szFilter[i]='\0'; <br> <br>   _fmemset((LPOPENFILENAME)&amp;ofn,0,sizeof(OPENFILENAME)); <br> <br>   szFileName[0]='\0'; <br> <br>   ofn.lStructSize=sizeof(OPENFILENAME); <br>   ofn.hwndOwner=lpOutlineApp-&gt;m_hWndApp; <br>   ofn.lpstrFilter=(LPSTR)szFilter; <br>   ofn.lpstrFile=(LPSTR)szFileName; <br>   ofn.nMaxFile=256; <br>   ofn.Flags=OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br>   ofn.lpstrDefExt=DEFEXTENSION; <br> <br>   if(! GetOpenFileName((LPOPENFILENAME)&amp;ofn)) <br>      return;         // user canceled file open dialog <br> <br>   OutlineDoc_Close(lpOutlineApp-&gt;m_lpDoc, OLECLOSE_NOSAVE); <br>   OleDbgAssertSz(lpOutlineApp-&gt;m_lpDoc==NULL,"Closed doc NOT properly destroyed"); <br> <br>   lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>   if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>   A2W (szFileName, szUniFileName, 256); <br>   fStatus=OutlineDoc_LoadFromFile(lpOutlineApp-&gt;m_lpDoc, /*(LPOLESTR)*/szUniFileName); <br> <br>   if (! fStatus) { <br>      // loading the doc failed; create an untitled instead <br>      OutlineDoc_Destroy(lpOutlineApp-&gt;m_lpDoc);  // destroy unused doc <br>      lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>      if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br>      if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>         goto error; <br>   } <br> <br>   // position and size the new doc window <br>   OutlineApp_ResizeWindows(lpOutlineApp); <br>   OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); <br> <br>   return; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Could not create new document")); <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>      OutlineDoc_Destroy(lpOutlineApp-&gt;m_lpDoc); <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   } <br> <br>   return; <br> <br>#endif <br>} <br> <br> <br>/* OutlineApp_PrintCommand <br> * ----------------------- <br> * <br> *      Print the document <br> */ <br>void OutlineApp_PrintCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   LPOUTLINEDOC    lpOutlineDoc = lpOutlineApp-&gt;m_lpDoc; <br>   HDC             hDC=NULL; <br>   BOOL            fMustDeleteDC = FALSE; <br>   BOOL            fStatus; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   fStatus = PrintDlg((LPPRINTDLG)&amp;lpOutlineApp-&gt;m_PrintDlg); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   if (!fStatus) { <br>      if (!CommDlgExtendedError()) {      // Cancel button pressed <br>         return; <br>      } <br>   } <br>   else { <br>      hDC = OutlineApp_GetPrinterDC(lpOutlineApp); <br>      if (hDC) { <br> <br>#if defined( OLE_VERSION ) <br>         /* NOTE: while we are printing we do NOT want to <br>         **    receive any OnDataChange notifications or other OLE <br>         **    interface calls which could disturb the printing of <br>         **    the document. we will temporarily reply <br>         **    SERVERCALL_RETRYLATER <br>         */ <br>         OleApp_RejectInComingCalls((LPOLEAPP)lpOutlineApp, TRUE); <br>#endif <br> <br>         OutlineDoc_Print(lpOutlineDoc, hDC); <br>         DeleteDC(hDC); <br> <br>#if defined( OLE_VERSION ) <br>         // re-enable LRPC calls <br>         OleApp_RejectInComingCalls((LPOLEAPP)lpOutlineApp, FALSE); <br>#endif <br> <br>         return;                         // Printing completed <br>      } <br>   } <br> <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPrinting); <br>} <br> <br> <br>/* OutlineApp_PrinterSetupCommand <br> * ------------------------------ <br> * <br> *      Setup a different printer for printing <br> */ <br>void OutlineApp_PrinterSetupCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   DWORD FlagSave; <br> <br>   FlagSave = lpOutlineApp-&gt;m_PrintDlg.Flags; <br>   lpOutlineApp-&gt;m_PrintDlg.Flags |= PD_PRINTSETUP; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   PrintDlg((LPPRINTDLG)&amp;lpOutlineApp-&gt;m_PrintDlg); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   lpOutlineApp-&gt;m_PrintDlg.Flags = FlagSave; <br>} <br> <br>/* <br> *  FUNCTION   : OutlineApp_GetPrinterDC () <br> * <br> *  PURPOSE    : Creates a printer display context for the printer <br> * <br> *  RETURNS    : HDC   - A handle to printer DC. <br> */ <br>HDC OutlineApp_GetPrinterDC(LPOUTLINEAPP lpApp) <br>{ <br> <br>   HDC         hDC; <br>   LPDEVMODE   lpDevMode = NULL; <br>   LPDEVNAMES  lpDevNames; <br>   LPSTR       lpszDriverName; <br>   LPSTR       lpszDeviceName; <br>   LPSTR       lpszPortName; <br> <br>   if(lpApp-&gt;m_PrintDlg.hDC) { <br>      hDC = lpApp-&gt;m_PrintDlg.hDC; <br>   } else { <br>      if(! lpApp-&gt;m_PrintDlg.hDevNames) <br>         return(NULL); <br>      lpDevNames = (LPDEVNAMES)GlobalLock(lpApp-&gt;m_PrintDlg.hDevNames); <br>      lpszDriverName = (LPSTR)lpDevNames + lpDevNames-&gt;wDriverOffset; <br>      lpszDeviceName = (LPSTR)lpDevNames + lpDevNames-&gt;wDeviceOffset; <br>      lpszPortName   = (LPSTR)lpDevNames + lpDevNames-&gt;wOutputOffset; <br>      GlobalUnlock(lpApp-&gt;m_PrintDlg.hDevNames); <br> <br>      if(lpApp-&gt;m_PrintDlg.hDevMode) <br>         lpDevMode = (LPDEVMODE)GlobalLock(lpApp-&gt;m_PrintDlg.hDevMode); <br>#if defined( WIN32 ) <br>      hDC = CreateDC( <br>            lpszDriverName, <br>            lpszDeviceName, <br>            lpszPortName, <br>            (CONST DEVMODE FAR*)lpDevMode); <br>#else <br>      hDC = CreateDC( <br>            lpszDriverName, <br>            lpszDeviceName, <br>            lpszPortName, <br>            (LPSTR)lpDevMode); <br>#endif <br> <br>      if(lpApp-&gt;m_PrintDlg.hDevMode &amp;&amp; lpDevMode) <br>         GlobalUnlock(lpApp-&gt;m_PrintDlg.hDevMode); <br>   } <br> <br>   return(hDC); <br>} <br> <br> <br>/* OutlineApp_SaveCommand <br> * ---------------------- <br> * <br> *      Save the document with same name. If no name exists, prompt the user <br> *      for a name (via SaveAsCommand) <br> * <br> *  Parameters: <br> * <br> *  Returns: <br> *      TRUE    if succesfully <br> *      FALSE   if failed or aborted <br> */ <br>BOOL OutlineApp_SaveCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp); <br> <br>   if(lpOutlineDoc-&gt;m_docInitType == DOCTYPE_NEW)  /* file with no name */ <br>      return OutlineApp_SaveAsCommand(lpOutlineApp); <br> <br> <br>   if(OutlineDoc_IsModified(lpOutlineDoc)) { <br> <br>#if defined( OLE_SERVER ) <br> <br>      if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED) { <br>         LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>         HRESULT hrErr; <br> <br>         /* NOTE: if the document is an embedded object, then <br>         **    the "File.Save" command is changed to "File.Update". <br>         **    in order to update our container, we must ask our <br>         **    container to save us. <br>         */ <br>         OleDbgAssert(lpServerDoc-&gt;m_lpOleClientSite != NULL); <br>         OLEDBG_BEGIN2("IOleClientSite::SaveObject called\r\n") <br>         hrErr = lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;SaveObject( <br>               lpServerDoc-&gt;m_lpOleClientSite <br>         ); <br>         OLEDBG_END2 <br> <br>         if (hrErr != NOERROR) { <br>            OleDbgOutHResult("IOleClientSite::SaveObject returned",hrErr); <br>            return FALSE; <br>         } <br>      } else <br>         // document is file-base user document, save it to its file. <br> <br>#endif      // OLE_SERVER <br> <br>      (void)OutlineDoc_SaveToFile( <br>            lpOutlineDoc, <br>            NULL, <br>            lpOutlineDoc-&gt;m_cfSaveFormat, <br>            TRUE <br>      ); <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineApp_SaveAsCommand <br> * ------------------------ <br> * <br> *      Save the document as another name <br> * <br> *  Parameters: <br> * <br> *  Returns: <br> *      TRUE    if saved successful <br> *      FALSE   if failed or aborted <br> */ <br>BOOL OutlineApp_SaveAsCommand(LPOUTLINEAPP lpOutlineApp) </code></pre>
<p>
</p>
<pre><code>{ <br>   LPOUTLINEDOC lpOutlineDoc = lpOutlineApp-&gt;m_lpDoc; <br>   OPENFILENAME ofn; <br>   char szFilter[]=APPFILENAMEFILTER; <br>   char szFileName[256]=""; <br>   OLECHAR szUniFileName[256]; <br>   int i; <br>   UINT uFormat; <br>   BOOL fNoError = TRUE; <br>   BOOL fRemember = TRUE; <br>   BOOL fStatus; <br> <br>   for(i=0; szFilter[i]; i++) <br>      if(szFilter[i]=='|') szFilter[i]='\0'; <br> <br>   _fmemset((LPOPENFILENAME)&amp;ofn,0,sizeof(OPENFILENAME)); <br> <br>   ofn.lStructSize=sizeof(OPENFILENAME); <br>   ofn.hwndOwner=lpOutlineDoc-&gt;m_hWndDoc; <br>   ofn.lpstrFilter=(LPSTR)szFilter; <br>   ofn.lpstrFile=(LPSTR)szFileName; <br>   ofn.nMaxFile=256; <br> <br>   ofn.Flags=OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY; <br>   ofn.lpstrDefExt=DEFEXTENSION; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   fStatus = GetSaveFileName((LPOPENFILENAME)&amp;ofn); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   if (fStatus) { <br> <br>#if defined( OLE_CNTR ) <br>      // determine which file type the user selected. <br>      switch (ofn.nFilterIndex) { <br>         case 1: <br>            uFormat = ((LPCONTAINERAPP)lpOutlineApp)-&gt;m_cfCntrOutl; <br>            break; <br>         case 2: <br>            uFormat = lpOutlineApp-&gt;m_cfOutline; <br>            break; <br>         default: <br>            uFormat = ((LPCONTAINERAPP)lpOutlineApp)-&gt;m_cfCntrOutl; <br>            break; <br>      } <br>#else <br>      uFormat = lpOutlineApp-&gt;m_cfOutline; <br>#endif <br> <br>#if defined( OLE_SERVER ) <br>      /* NOTE: if the document is an embedded object, then the <br>      **    File.SaveAs command is changed to File.SaveCopyAs. with the <br>      **    Save Copy As operation, the document does NOT remember the <br>      **    saved file as the associated file for the document. <br>      */ <br>      if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED) <br>         fRemember = FALSE; <br>#endif <br>      A2W (szFileName, szUniFileName, 256); <br>      (void)OutlineDoc_SaveToFile( <br>            lpOutlineDoc, <br>            szUniFileName, <br>            uFormat, <br>            fRemember <br>      ); <br> <br>   } <br>   else <br>      fNoError = FALSE; <br> <br>   return fNoError; <br> <br>} <br> <br> <br>/* OutlineApp_AboutCommand <br> * ----------------------- <br> * <br> *      Show the About dialog box <br> */ <br>void OutlineApp_AboutCommand(LPOUTLINEAPP lpOutlineApp) <br>{ <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   DialogBox( <br>         lpOutlineApp-&gt;m_hInst, <br>         (LPSTR)"About", <br>         OutlineApp_GetFrameWindow(lpOutlineApp), <br>         (DLGPROC)AboutDlgProc <br>   ); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog( <br>         (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br>} <br> <br> <br>/* OutlineApp_CloseAllDocsAndExitCommand <br> * ------------------------------------- <br> * <br> *  Close all active documents and exit the app. <br> *  Because this is an SDI, there is only one document <br> *  If the doc was modified, prompt the user if he wants to save it. <br> * <br> *  Returns: <br> *      TRUE if the app is successfully closed <br> *      FALSE if failed or aborted <br> */ <br>BOOL OutlineApp_CloseAllDocsAndExitCommand( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      BOOL                fForceEndSession <br>) <br>{ <br>   BOOL fResult; <br> <br>   OLEDBG_BEGIN2("OutlineApp_CloseAllDocsAndExitCommand\r\n") <br> <br>#if defined( OLE_VERSION ) <br>   // Call OLE specific version of this function <br>   fResult = OleApp_CloseAllDocsAndExitCommand( <br>         (LPOLEAPP)lpOutlineApp, fForceEndSession); <br> <br>#else <br> <br>   /* Because this is an SDI app, there is only one document. <br>   ** Close the doc. if it is successfully closed and the app will <br>   ** not automatically exit, then also exit the app. <br>   ** if this were an MDI app, we would loop through and close all <br>   ** open MDI child documents. <br>   */ <br>   if (OutlineDoc_Close(lpOutlineApp-&gt;m_lpDoc, OLECLOSE_PROMPTSAVE)) { <br> <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz( <br>            lpOutlineApp-&gt;m_lpDoc==NULL, <br>            "Closed doc NOT properly destroyed" <br>      ); <br>#endif <br> <br>      OutlineApp_Destroy(lpOutlineApp); <br>      fResult = TRUE; <br> <br>   } // else User Canceled shutdown <br>   else <br>      fResult = FALSE; <br> <br>#endif <br> <br>   OLEDBG_END2 <br> <br>   return fResult; <br>} <br> <br> <br>/* OutlineApp_Destroy <br> * ------------------ <br> * <br> *      Destroy all data structures used by the app and force the <br> * app to shut down. This should be called after all documents have <br> * been closed. <br> */ <br>void OutlineApp_Destroy(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   OLEDBG_BEGIN3("OutlineApp_Destroy\r\n"); <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: perform processing required for OLE */ <br>   OleApp_Destroy((LPOLEAPP)lpOutlineApp); <br>#endif <br> <br>   SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW))); <br>   DestroyCursor(lpOutlineApp-&gt;m_hcursorSelCur); <br> <br>#if defined( USE_FRAMETOOLS ) <br>   FrameTools_Destroy(&amp;lpOutlineApp-&gt;m_frametools); <br>#endif <br> <br>   if (lpOutlineApp-&gt;m_hStdFont) <br>      DeleteObject(lpOutlineApp-&gt;m_hStdFont); <br> <br>   if(lpOutlineApp-&gt;m_PrintDlg.hDevMode) <br>      GlobalFree(lpOutlineApp-&gt;m_PrintDlg.hDevMode); <br>   if(lpOutlineApp-&gt;m_PrintDlg.hDevNames) <br>      GlobalFree(lpOutlineApp-&gt;m_PrintDlg.hDevNames); <br> <br>#if defined( USE_STATUSBAR ) <br>   if(lpOutlineApp-&gt;m_hWndStatusBar) { <br>      DestroyStatusWindow(lpOutlineApp-&gt;m_hWndStatusBar); <br>      lpOutlineApp-&gt;m_hWndStatusBar = NULL; <br>   } <br>#endif <br> <br>   OutlineApp_DestroyWindow(lpOutlineApp); <br>   OleDbgOut1("@@@@ APP DESTROYED\r\n"); <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OutlineApp_DestroyWindow <br> * ------------------------ <br> * <br> *  Destroy all windows created by the App. <br> */ <br>void OutlineApp_DestroyWindow(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   HWND hWndApp = lpOutlineApp-&gt;m_hWndApp; <br> <br>   if(hWndApp) { <br>      lpOutlineApp-&gt;m_hWndApp = NULL; <br>      lpOutlineApp-&gt;m_hWndAccelTarget = NULL; <br>      DestroyWindow(hWndApp);  /* Quit the app */ <br>   } <br>} <br> <br> <br>/* OutlineApp_GetFrameRect <br>** ----------------------- <br>**    Get the rectangle of the app frame window EXCLUDING space for the <br>**    status line. <br>** <br>**    NOTE: this is the rectangle that an in-place container can <br>**    offer to an in-place active object from which to get frame tool <br>**    space. <br>*/ <br>void OutlineApp_GetFrameRect(LPOUTLINEAPP lpOutlineApp, LPRECT lprcFrameRect) <br>{ <br>   GetClientRect(lpOutlineApp-&gt;m_hWndApp, lprcFrameRect); <br> <br>#if defined( USE_STATUSBAR ) <br>   lprcFrameRect-&gt;bottom -= STATUS_HEIGHT; <br>#endif <br> <br>} <br> <br> <br>/* OutlineApp_GetClientAreaRect <br>** ---------------------------- <br>**    Get the rectangle of the app frame window EXCLUDING space for the <br>**    status line AND EXCLUDING space for any frame-level tools. <br>** <br>**    NOTE: this is the rectangle that an in-place container gives <br>**    to its in-place active object as the lpClipRect in <br>**    IOleInPlaceSite::GetWindowContext. <br>*/ <br>void OutlineApp_GetClientAreaRect( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPRECT              lprcClientAreaRect <br>) <br>{ <br>   OutlineApp_GetFrameRect(lpOutlineApp, lprcClientAreaRect); <br> <br>   /* if the app either uses frame-level tools itself or, as in-place <br>   **    container, is prepared to allow an in-place active object to <br>   **    have space for tools, then it must subtract away the space <br>   **    required for the tools. <br>   */ <br>#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR ) <br> <br>   lprcClientAreaRect-&gt;top    += lpOutlineApp-&gt;m_FrameToolWidths.top; <br>   lprcClientAreaRect-&gt;left   += lpOutlineApp-&gt;m_FrameToolWidths.left; <br>   lprcClientAreaRect-&gt;right  -= lpOutlineApp-&gt;m_FrameToolWidths.right; <br>   lprcClientAreaRect-&gt;bottom -= lpOutlineApp-&gt;m_FrameToolWidths.bottom; <br>#endif  // USE_FRAMETOOLS || INPLACE_CNTR <br> <br>} <br> <br> <br>/* OutlineApp_GetStatusLineRect <br>** ---------------------------- <br>**    Get the rectangle required for the status line. <br>** <br>**    NOTE: the top frame-level in-place container displays its <br>**    status line even when an object is active in-place. <br>*/ <br>void OutlineApp_GetStatusLineRect( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPRECT              lprcStatusLineRect <br>) <br>{ <br>   RECT rcFrameRect; <br>   GetClientRect(lpOutlineApp-&gt;m_hWndApp, (LPRECT)&amp;rcFrameRect); <br>   lprcStatusLineRect-&gt;left    = rcFrameRect.left; <br>   lprcStatusLineRect-&gt;top     = rcFrameRect.bottom - STATUS_HEIGHT; <br>   lprcStatusLineRect-&gt;right   = rcFrameRect.right; <br>   lprcStatusLineRect-&gt;bottom  = rcFrameRect.bottom; <br>} <br> <br> <br>/* OutlineApp_ResizeWindows <br> * ------------------------ <br> * <br> * Changes the size and position of the SDI document and tool windows. <br> * Normally called on a WM_SIZE message. <br> * <br> * Currently the app supports a status bar and a single SDI document window. <br> * In the future it will have a formula bar and possibly multiple MDI <br> * document windows. <br> * <br> * CUSTOMIZATION: Change positions of windows. <br> */ <br>void OutlineApp_ResizeWindows(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp); <br>   RECT rcStatusLineRect; <br> <br>   if (! lpOutlineApp) <br>      return; <br> <br>#if defined( INPLACE_CNTR ) <br>   if (lpOutlineDoc) <br>      ContainerDoc_FrameWindowResized((LPCONTAINERDOC)lpOutlineDoc); <br>#else <br>#if defined( USE_FRAMETOOLS ) <br>   if (lpOutlineDoc) <br>      OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>#else <br>   OutlineApp_ResizeClientArea(lpOutlineApp); <br>#endif  // ! USE_FRAMETOOLS <br>#endif  // ! INPLACE_CNTR <br> <br>#if defined( USE_STATUSBAR ) <br>   if (lpOutlineApp-&gt;m_hWndStatusBar) { <br>      OutlineApp_GetStatusLineRect(lpOutlineApp, (LPRECT)&amp;rcStatusLineRect); <br>      MoveWindow( <br>            lpOutlineApp-&gt;m_hWndStatusBar, <br>            rcStatusLineRect.left, <br>            rcStatusLineRect.top, <br>            rcStatusLineRect.right - rcStatusLineRect.left, <br>            rcStatusLineRect.bottom - rcStatusLineRect.top, <br>            TRUE    /* fRepaint */ <br>         ); <br>   } <br>#endif  // USE_STATUSBAR <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) || defined( INPLACE_CNTR ) <br> <br>void OutlineApp_SetBorderSpace( <br>      LPOUTLINEAPP        lpOutlineApp, <br>      LPBORDERWIDTHS      lpBorderWidths <br>) <br>{ <br>   lpOutlineApp-&gt;m_FrameToolWidths = *lpBorderWidths; <br>   OutlineApp_ResizeClientArea(lpOutlineApp); <br>} <br>#endif  // USE_FRAMETOOLS || INPLACE_CNTR <br> <br> <br>void OutlineApp_ResizeClientArea(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   RECT rcClientAreaRect; <br> <br>#if defined( MDI_VERSION ) <br> <br>   // Resize MDI Client Area Window here <br> <br>#else <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>         OutlineApp_GetClientAreaRect( <br>               lpOutlineApp, (LPRECT)&amp;rcClientAreaRect); <br>         OutlineDoc_Resize(lpOutlineApp-&gt;m_lpDoc, <br>               (LPRECT)&amp;rcClientAreaRect); <br>   } <br> <br>#endif <br> <br>} <br> <br> <br>/* OutlineApp_GetActiveDoc <br> * ----------------------- <br> * <br> * Return the document in focus. For SDI, the same (only one) document is <br> * always returned. <br> */ <br>LPOUTLINEDOC OutlineApp_GetActiveDoc(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   return lpOutlineApp-&gt;m_lpDoc; <br>} <br> <br>/* OutlineApp_GetMenu <br> * ------------------ <br> * <br> * Return the menu handle of the app <br> */ <br>HMENU OutlineApp_GetMenu(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   if (!lpOutlineApp) { <br>      return NULL; <br>   } <br> <br>   return lpOutlineApp-&gt;m_hMenuApp; <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>/* OutlineApp_GetFrameTools <br> * --------------------- <br> * <br> * Return the pointer to the toolbar object <br> */ <br>LPFRAMETOOLS OutlineApp_GetFrameTools(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   return (LPFRAMETOOLS)&amp;lpOutlineApp-&gt;m_frametools; <br>} <br>#endif <br> <br> <br>/* OutlineApp_SetStatusText <br> * ------------------------ <br> * <br> * Show the given string in the status line <br> */ <br>void OutlineApp_SetStatusText(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszMessage) <br>{ <br>   char szAnsiMessage[256]; <br> <br>   W2A (lpszMessage, szAnsiMessage, 256); <br>   SetStatusText(lpOutlineApp-&gt;m_hWndStatusBar, szAnsiMessage); <br>} <br> <br> <br>/* OutlineApp_GetActiveFont <br> * ------------------------ <br> * <br> *      Return the font used by the application <br> */ <br>HFONT OutlineApp_GetActiveFont(LPOUTLINEAPP lpOutlineApp) <br>{ <br>   return lpOutlineApp-&gt;m_hStdFont; <br>} <br> <br> <br>/* OutlineApp_GetAppName <br> * --------------------- <br> * <br> *      Retrieve the application name <br> */ <br>void OutlineApp_GetAppName(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszAppName) <br>{ <br>   OLESTRCPY (lpszAppName, APPNAME); <br>} <br> <br> <br>/* OutlineApp_GetAppVersionNo <br> * -------------------------- <br> * <br> *      Get the version number (major and minor) of the application <br> */ <br>void OutlineApp_GetAppVersionNo(LPOUTLINEAPP lpOutlineApp, int narrAppVersionNo[]) <br>{ <br>   narrAppVersionNo[0] = APPMAJORVERSIONNO; <br>   narrAppVersionNo[1] = APPMINORVERSIONNO; <br>} <br> <br> <br>/* OutlineApp_VersionNoCheck <br> * ------------------------- <br> * <br> *      Check if the version stamp read from a file is compatible <br> *      with the current instance of the application. <br> *      returns TRUE if the file can be read, else FALSE. <br> */ <br>BOOL OutlineApp_VersionNoCheck(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszFormatName, int narrAppVersionNo[]) <br>{ <br>#if defined( OLE_CNTR ) <br> <br>   /* ContainerApp accepts both CF_OUTLINE and CF_CONTAINEROUTLINE formats */ <br>   if (OLESTRCMP(lpszFormatName, CONTAINERDOCFORMAT) != 0 &amp;&amp; <br>      OLESTRCMP(lpszFormatName, OUTLINEDOCFORMAT) != 0) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage( <br>            lpOutlineApp, <br>            OLESTR("File is either corrupted or not of proper type.") <br>         ); <br>      return FALSE; <br>   } <br> <br>#else <br> <br>   /* OutlineApp accepts CF_OUTLINE format only */ <br>   if (OLESTRCMP(lpszFormatName, OUTLINEDOCFORMAT) != 0) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage( <br>            lpOutlineApp, <br>            OLESTR("File is either corrupted or not of proper type.") <br>         ); <br>      return FALSE; <br>   } <br>#endif <br> <br>   if (narrAppVersionNo[0] &lt; APPMAJORVERSIONNO) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage( <br>            lpOutlineApp, <br>            OLESTR("File was created by an older version; it can not be read.") <br>         ); <br>      return FALSE; <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* OutlineApp_ErrorMessage <br> * ----------------------- <br> * <br> *      Display an error message box <br> */ <br>void OutlineApp_ErrorMessage(LPOUTLINEAPP lpOutlineApp, LPOLESTR lpszErrMsg) <br>{ <br>   HWND hWndFrame = OutlineApp_GetFrameWindow(lpOutlineApp); <br>   char   szAnsiErrMsg[256]; <br> <br>   // NOTE: only put up user message boxes if app is visible <br>   if (IsWindowVisible(hWndFrame)) { <br>#if defined( OLE_VERSION ) <br>      OleApp_PreModalDialog( <br>            (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br>      W2A (lpszErrMsg, szAnsiErrMsg, 256); <br>      MessageBox(hWndFrame, szAnsiErrMsg, NULL, MB_ICONEXCLAMATION | MB_OK); <br> <br>#if defined( OLE_VERSION ) <br>      OleApp_PostModalDialog( <br>            (LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br>   } <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>/* OutlineApp_SetFormulaBarAccel <br> * ----------------------------- <br> * <br> *  Set accelerator table based on state of formula bar. <br> */ <br>void OutlineApp_SetFormulaBarAccel( <br>      LPOUTLINEAPP            lpOutlineApp, <br>      BOOL                    fEditFocus <br>) <br>{ <br>   if (fEditFocus) <br>      lpOutlineApp-&gt;m_hAccel = lpOutlineApp-&gt;m_hAccelFocusEdit; <br>   else <br>      lpOutlineApp-&gt;m_hAccel = lpOutlineApp-&gt;m_hAccelApp; <br>} <br> <br>#endif  // USE_FRAMETOOLS <br> <br> <br> <br> <br>/* OutlineApp_ForceRedraw <br> * ---------------------- <br> * <br> *      Force the Application window to repaint. <br> */ <br>void OutlineApp_ForceRedraw(LPOUTLINEAPP lpOutlineApp, BOOL fErase) <br>{ <br>   if (!lpOutlineApp) <br>      return; <br> <br>   InvalidateRect(lpOutlineApp-&gt;m_hWndApp, NULL, fErase); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
