<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SVRINPL.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context311"></a>SVRINPL.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Server Sample Code <br>** <br>**    svrinpl.c <br>** <br>**    This file contains all interfaces, methods and related support <br>**    functions for an In-Place Object (Server) application (aka. Visual <br>**    Editing). The in-place Object application includes the following <br>**    implementation objects: <br>** <br>**    ServerDoc Object <br>**      exposed interfaces: <br>**          IOleInPlaceObject <br>**          IOleInPlaceActiveObject <br>** <br>**    ServerApp Object <br>**      exposed interfaces: <br>**          IUnknown <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br> <br>/* NOTE: the object should compose a string that is used by <br>**    in-place containers to be used for the window titles. this string <br>**    is passed to the container application via <br>**    IOleInPlaceUIWindow::SetActiveObject. the string should have the <br>**    following form: <br>**          &lt;application name&gt; - &lt;object short type name&gt; <br>**    SDI containers can use the string directly to display in the <br>**    frame window title. the container would concatenate the string <br>**    " in &lt;container doc name&gt;". <br>**    an MDI container with the MDI child window maximized can do the <br>**    same as the SDI container. an MDI container with the MDI child <br>**    windows NOT maximized can look for the " - " in the string from <br>**    the object. the first part of the string (app name) would be put <br>**    as the frame window title; the second part would be composed with <br>**    " in &lt;container doc name&gt;" and used as the MDI child window <br>**    title. <br>*/ <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR g_szIPObjectTitle[] = APPNAME OLESTR(" - ") SHORTUSERTYPENAME; <br> <br>extern RECT g_rectNull; <br> <br> <br> <br>/************************************************************************* <br>** ServerDoc::IOleInPlaceObject interface implementation <br>*************************************************************************/ <br> <br>// IOleInPlaceObject::QueryInterface method <br> <br>STDMETHODIMP SvrDoc_IPObj_QueryInterface( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      REFIID              riid, <br>      LPVOID FAR *        lplpvObj <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj); <br>} <br> <br> <br>// IOleInPlaceObject::AddRef method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleInPlaceObject"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleInPlaceObject::Release method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleInPlaceObject"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleInPlaceObject::GetWindow method <br> <br>STDMETHODIMP SvrDoc_IPObj_GetWindow( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      HWND FAR*           lphwnd <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPObj_GetWindow\r\n") <br> <br>   *lphwnd = ((LPOUTLINEDOC)lpServerDoc)-&gt;m_hWndDoc; <br> <br>   OLEDBG_END2 <br>   return S_OK; <br>} <br> <br> <br>// IOleInPlaceObject::ContextSensitiveHelp method <br> <br>STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      BOOL                fEnable <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         (LPOLEDOC)((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_IPObj_ContextSensitiveHelp\r\n"); <br> <br>   /* NOTE: see context sensitive help technote (CSHELP.DOC). <br>   **    This method is called when SHIFT-F1 context sensitive help is <br>   **    entered. the cursor should then change to a question mark <br>   **    cursor and the app should enter a modal state where the next <br>   **    mouse click does not perform its normal action but rather <br>   **    gives help corresponding to the location clicked. if the app <br>   **    does not implement a help system, it should at least eat the <br>   **    click and do nothing. <br>   */ <br>   lpOleDoc-&gt;m_fCSHelpMode = fEnable; <br> <br>   return S_OK; <br>} <br> <br> <br>// IOleInPlaceObject::InPlaceDeactivate method <br> <br>STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is deleted during call <br>   SvrDoc_IPObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPObj_InPlaceDeactivate\r\n") <br> <br>   hrErr = ServerDoc_DoInPlaceDeactivate(lpServerDoc); <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_IPObj_Release(lpThis); <br> <br>   return hrErr; <br>} <br> <br> <br>// IOleInPlaceObject::UIDeactivate method <br> <br>STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis) <br>{ <br>   LPSERVERDOC     lpServerDoc = <br>                  ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LPLINELIST      lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpServerDoc)-&gt;m_LineList; <br>   HWND            hWndApp = OutlineApp_GetWindow(g_lpApp); <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPObj_UIDeactivate\r\n"); <br> <br>   if (!lpServerDoc-&gt;m_fUIActive) { <br>      OLEDBG_END2 <br>      return NOERROR; <br>   } <br> <br>   // artificial AddRef in case object is deleted during call <br>   SvrDoc_IPObj_AddRef(lpThis); <br> <br>   lpServerDoc-&gt;m_fUIActive = FALSE; <br> <br>   // Clip the hatch window to the size of pos rect so, that the object <br>   // adornments and hatch border will not be visible. <br>   ServerDoc_ResizeInPlaceWindow(lpServerDoc, <br>         (LPRECT)&amp;(lpServerDoc-&gt;m_lpIPData-&gt;rcPosRect), <br>         (LPRECT)&amp;(lpServerDoc-&gt;m_lpIPData-&gt;rcPosRect) <br>   ); <br> <br>   if (lpIPData-&gt;lpDoc) <br>      lpIPData-&gt;lpDoc-&gt;lpVtbl-&gt;SetActiveObject(lpIPData-&gt;lpDoc, NULL, NULL); <br> <br>   if (lpIPData-&gt;lpFrame) { <br>      lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;SetActiveObject( <br>         lpIPData-&gt;lpFrame, <br>         NULL, <br>         NULL <br>      ); <br>   } <br> <br>#if defined( USE_FRAMETOOLS ) <br>   /* NOTE: we must hide our frame tools here but NOT call <br>   **    IOleInPlaceFrame::SetBorderSpace(NULL) or SetMenu(NULL). <br>   **    we must hide our tools BEFORE calling <br>   **    IOleInPlaceSite::OnUIDeactivate. the container will put <br>   **    his menus and tools back when OnUIDeactivate is called. <br>   */ <br>   ServerDoc_RemoveFrameLevelTools(lpServerDoc); <br>#endif <br> <br>   OLEDBG_BEGIN2("IOleInPlaceSite::OnUIDeactivate called\r\n"); <br>   lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;OnUIDeactivate(lpIPData-&gt;lpSite, FALSE); <br>   OLEDBG_END2 <br> <br>   /* Reset to use our normal app's accelerator table */ <br>   g_lpApp-&gt;m_hAccelApp = lpServerApp-&gt;m_hAccelBaseApp; <br>   g_lpApp-&gt;m_hAccel = lpServerApp-&gt;m_hAccelBaseApp; <br>   g_lpApp-&gt;m_hWndAccelTarget = hWndApp; <br> <br>   OLEDBG_END2 <br> <br>#if !defined( SVR_INSIDEOUT ) <br>   /* NOTE: an "outside-in" style in-place server would hide its <br>   **    window here. an "inside-out" style server leaves its window <br>   **    visible when it is UIDeactivated. it would only hide its <br>   **    window when InPlaceDeactivated. this app is an "inside-out" <br>   **    style server. it is recommended for most server to support <br>   **    inside-out behavior if possible. <br>   */ <br>   ServerDoc_DoInPlaceHide(lpServerDoc); <br>#endif // INSIEDOUT <br>   // release artificial AddRef <br>   SvrDoc_IPObj_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceObject::SetObjectRects method <br> <br>STDMETHODIMP SvrDoc_IPObj_SetObjectRects( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      LPCRECT             lprcPosRect, <br>      LPCRECT             lprcClipRect <br>) <br>{ <br>   LPSERVERDOC  lpServerDoc = <br>               ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPINPLACEDATA lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LPLINELIST   lpLL = OutlineDoc_GetLineList((LPOUTLINEDOC)lpServerDoc); <br> <br> <br>   // artificial AddRef in case object is deleted during call <br>   SvrDoc_IPObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPObj_SetObjectRects\r\n") <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (PosRect)", <br>         (LPRECT)lprcPosRect); <br>   OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (ClipRect)", <br>         (LPRECT)lprcClipRect); <br>#endif <br>   // save the current PosRect and ClipRect <br>   lpIPData-&gt;rcPosRect = *lprcPosRect; <br>   lpIPData-&gt;rcClipRect = *lprcClipRect; <br> <br>   if (! lpServerDoc-&gt;m_fUIActive) // hatch and adornaments must not be drawn <br>      lprcClipRect = lprcPosRect; <br> <br>   ServerDoc_ResizeInPlaceWindow( <br>         lpServerDoc, (LPRECT)lprcPosRect, (LPRECT)lprcClipRect); <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_IPObj_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceObject::ReactivateAndUndo method <br> <br>STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis) <br>{ <br>   OLEDBG_BEGIN2("SvrDoc_IPObj_ReactivateAndUndo\r\n") <br> <br>   // We do not support support UNDO. <br> <br>   /* REVIEW: for debugging purposes it would be useful to give a <br>   **    message box indicating that this method has been called. <br>   */ <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>/************************************************************************* <br>** ServerDoc::IOleInPlaceActiveObject interface implementation <br>*************************************************************************/ <br> <br>// IOleInPlaceActiveObject::QueryInterface method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      REFIID                      riid, <br>      LPVOID FAR *                lplpvObj <br>) <br>{ <br>   SCODE sc = E_NOINTERFACE; <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   /* The container should not be able to access the other interfaces <br>   ** of our object by doing QI on this interface. <br>   */ <br> <br>   *lplpvObj = NULL; <br>   if (IsEqualIID(riid, &amp;IID_IUnknown) || <br>      IsEqualIID(riid, &amp;IID_IOleWindow) || <br>      IsEqualIID(riid, &amp;IID_IOleInPlaceActiveObject)) { <br>      OleDbgOut4("OleDoc_QueryInterface: IOleInPlaceActiveObject* RETURNED\r\n"); <br> <br>      *lplpvObj = lpThis; <br>      OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>      sc = NOERROR; <br>   } <br> <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br> <br>   return sc; <br>} <br> <br> <br>// IOleInPlaceActiveObject::AddRef method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef( <br>      LPOLEINPLACEACTIVEOBJECT lpThis <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleInPlaceActiveObject"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleInPlaceActiveObject::Release method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release( <br>      LPOLEINPLACEACTIVEOBJECT lpThis <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleInPlaceActiveObject"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleInPlaceActiveObject::GetWindow method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_GetWindow( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      HWND FAR*                   lphwnd <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPActiveObj_GetWindow\r\n") <br> <br>   *lphwnd = ((LPOUTLINEDOC)lpServerDoc)-&gt;m_hWndDoc; <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::ContextSensitiveHelp method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fEnterMode <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_IPActiveObj_ContextSensitiveHelp\r\n"); <br> <br>   /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>   **    This method is called when F1 is pressed when a menu item is <br>   **    selected. this tells the in-place server application to give <br>   **    help rather than execute the next menu command. at a minimum, <br>   **    even if the in-place server application does not implement a <br>   **    help system, it should NOT execute the next command when <br>   **    fEnable==TRUE. We set the active object's m_fMenuMode flag here. <br>   **    later, in WM_COMMAND processing in the DocWndProc, if this <br>   **    flag is set then the command is NOT executed (and help could <br>   **    be given if we had a help system....but we don't.) <br>   */ <br>   lpServerDoc-&gt;m_fMenuHelpMode = fEnterMode; <br> <br>#if !defined( HACK ) <br>   ((LPOLEDOC)lpServerDoc)-&gt;m_fCSHelpMode = fEnterMode; <br>#endif <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::TranslateAccelerator method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      LPMSG                       lpmsg <br>) <br>{ <br>   // This will never be called because this server is implemented as an EXE <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::OnFrameWindowActivate method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fActivate <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC) <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc); <br>#if defined( _DEBUG ) <br>   if (fActivate) <br>      OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(TRUE)\r\n"); <br>   else <br>      OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(FALSE)\r\n"); <br>#endif  // _DEBUG <br> <br>   /* NOTE: this is a notification of the container application's <br>   **    WM_ACTIVATEAPP status. some applications may find this <br>   **    important. we need to update the enable/disable status of our <br>   **    tool bar buttons. <br>   */ <br> <br>   // NOTE: We can't call OutlineDoc_UpdateFrameToolButtons <br>   //           right away which <br>   //           would generate some OLE calls and eventually <br>   //           WM_ACTIVATEAPP and a loop was formed. Therefore, we <br>   //           should delay the frame tool initialization until <br>   //           WM_ACTIVATEAPP is finished by posting a message <br>   //           to ourselves. <br> <br>   /* Update enable/disable state of buttons in toolbar */ <br>   if (fActivate) <br>      PostMessage(hWndDoc, WM_U_INITFRAMETOOLS, 0, 0L); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::OnDocWindowActivate method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fActivate <br>) <br>{ <br>   LPSERVERDOC     lpServerDoc = <br>                  ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>#if defined( _DEBUG ) <br>   if (fActivate) <br>      OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(TRUE)\r\n"); <br>   else <br>      OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(FALSE)\r\n"); <br>#endif <br> <br>   if (fActivate) { <br>      ServerDoc_AddFrameLevelUI(lpServerDoc); <br>   } <br>   else { <br>#if defined( USE_FRAMETOOLS ) <br>      /* NOTE: we must NOT call IOleInPlaceFrame::SetBorderSpace(NULL) <br>      **    or SetMenu(NULL) here. we should simply hide our tools. <br>      */ <br>      ServerDoc_RemoveFrameLevelTools(lpServerDoc); <br>#endif <br>   } <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::ResizeBorder method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      LPCRECT                     lprectBorder, <br>      LPOLEINPLACEUIWINDOW        lpIPUiWnd, <br>      BOOL                        fFrameWindow <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>               ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_IPActiveObj_ResizeBorder\r\n") <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>   if (fFrameWindow) { <br>      FrameTools_NegotiateForSpaceAndShow( <br>            lpOutlineDoc-&gt;m_lpFrameTools, <br>            (LPRECT)lprectBorder, <br>            (LPOLEINPLACEFRAME)lpIPUiWnd <br>      ); <br>   } <br> <br>#endif <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>// IOleInPlaceActiveObject::EnableModeless method <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fEnable <br>) <br>{ <br>#if defined( USE_FRAMETOOLS ) <br>   LPSERVERDOC lpServerDoc = <br>            ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPFRAMETOOLS lptb; <br> <br>   /* NOTE: we must enable/disable mouse and keyboard input to our <br>   **    floating tool palette <br>   */ <br>   if (lpOutlineDoc) { <br>      lptb = lpOutlineDoc-&gt;m_lpFrameTools; <br>      if (lptb) <br>         FrameTools_EnableWindow(lptb, fEnable); <br>   } <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( _DEBUG ) <br>   if (fEnable) <br>      OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(TRUE)\r\n"); <br>   else <br>      OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(FALSE)\r\n"); <br>#endif  // _DEBUG <br> <br>   /* NOTE: this method is called when the top-level, in-place <br>   **    container puts up a modal dialog. it tells the UIActive <br>   **    object to disable it modeless dialogs for the duration that <br>   **    the container is displaying a modal dialog. <br>   ** <br>   **    ISVROTL does not use any modeless dialogs, thus we can <br>   **    ignore this method. <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>/************************************************************************* <br>** Support Functions <br>*************************************************************************/ <br> <br> <br>HRESULT ServerDoc_DoInPlaceActivate( <br>      LPSERVERDOC     lpServerDoc, <br>      LONG            lVerb, <br>      LPMSG           lpmsg, <br>      LPOLECLIENTSITE lpActiveSite <br>) <br>{ <br>   LPOUTLINEAPP            lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPSERVERAPP             lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP                lpOleApp = (LPOLEAPP)g_lpApp; <br>   SCODE                   sc = E_FAIL; <br>   RECT                    rcPos; <br>   RECT                    rcClip; <br>   LPINPLACEDATA           lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LPOUTLINEDOC            lpOutlineDoc=(LPOUTLINEDOC)lpServerDoc; <br>   HWND                    hWndDoc = lpOutlineDoc-&gt;m_hWndDoc; <br>   HWND                    hWndHatch = lpServerDoc-&gt;m_hWndHatch; <br>   HRESULT                 hrErr; <br>   LPLINELIST              lpLL=(LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   LPOLEINPLACESITE    lpIPSite = NULL; <br> <br>   /* NOTE: lpActiveSite should be used only for InPlace PLAYing. <br>   **    This app does not do inplace PLAYing, so it never uses <br>   **    lpActiveSite. <br>   */ <br> <br>   /* InPlace activation can only be done if the ClientSite is non-NULL. */ <br>   if (! lpServerDoc-&gt;m_lpOleClientSite) <br>      return NOERROR; <br> <br>   if (! lpServerDoc-&gt;m_fInPlaceActive) { <br> <br>      // if the object is in open mode then we do not want to do inplace <br>      // activation. <br>      if (IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) <br>      { <br>         return NOERROR; <br>      } <br> <br>      lpIPSite = (LPOLEINPLACESITE)OleStdQueryInterface( <br>            (LPUNKNOWN)lpServerDoc-&gt;m_lpOleClientSite, <br>            &amp;IID_IOleInPlaceSite <br>      ); <br> <br>      if (! lpIPSite) <br>         goto errActivate; <br> <br>      OLEDBG_BEGIN2("IOleInPlaceSite::CanInPlaceActivate called\r\n"); <br>      hrErr = lpIPSite-&gt;lpVtbl-&gt;CanInPlaceActivate(lpIPSite); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) <br>         goto errActivate; <br> <br>      lpServerDoc-&gt;m_fInPlaceActive = TRUE; <br>      OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceActivate called\r\n"); <br>      hrErr = lpIPSite-&gt;lpVtbl-&gt;OnInPlaceActivate(lpIPSite); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) <br>         goto errActivate; <br> <br>      if (! ServerDoc_AllocInPlaceData(lpServerDoc)) { <br>         sc = E_OUTOFMEMORY; <br>         OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n"); <br>         lpIPSite-&gt;lpVtbl-&gt;OnInPlaceDeactivate(lpIPSite); <br>         OLEDBG_END2 <br>         goto errActivate; <br>      } <br> <br>      (lpIPData = lpServerDoc-&gt;m_lpIPData)-&gt;lpSite = lpIPSite; <br>      goto InPlaceActive; <br> <br>   errActivate: <br>      lpServerDoc-&gt;m_fInPlaceActive = FALSE; <br>      if (lpIPSite) <br>         OleStdRelease((LPUNKNOWN)lpIPSite); <br> <br>      return sc; <br>   } <br> <br> <br>InPlaceActive: <br> <br>   if (! lpServerDoc-&gt;m_fInPlaceVisible) { <br>      lpServerDoc-&gt;m_fInPlaceVisible = TRUE; <br> <br>      OLEDBG_BEGIN2("IOleInPlaceSite::GetWindow called\r\n"); <br>      hrErr = lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;GetWindow( <br>               lpIPData-&gt;lpSite, &amp;lpServerDoc-&gt;m_hWndParent); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) { <br>         sc = hrErr; <br>         goto errRtn; <br>      } <br> <br>      if (! lpServerDoc-&gt;m_hWndParent) <br>         goto errRtn; <br> <br>      /* NOTE: The server should fill in the "cb" field so that the <br>      **    container can tell what size structure the server is <br>      **    expecting. this enables this structure to be easily extended <br>      **    in future releases of OLE. the container should check this <br>      **    field so that it doesn't try to use fields that do not exist <br>      **    since the server may be using an old structure definition. <br>      */ <br>      _fmemset( <br>         (LPOLEINPLACEFRAMEINFO)&amp;lpIPData-&gt;frameInfo, <br>         0, <br>         sizeof(OLEINPLACEFRAMEINFO) <br>      ); <br>      lpIPData-&gt;frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br> <br>      OLEDBG_BEGIN2("IOleInPlaceSite::GetWindowContext called\r\n"); <br>      hrErr = lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;GetWindowContext(lpIPData-&gt;lpSite, <br>               (LPOLEINPLACEFRAME FAR*) &amp;lpIPData-&gt;lpFrame, <br>               (LPOLEINPLACEUIWINDOW FAR*)&amp;lpIPData-&gt;lpDoc, <br>               (LPRECT)&amp;rcPos, <br>               (LPRECT)&amp;rcClip, <br>               (LPOLEINPLACEFRAMEINFO)&amp;lpIPData-&gt;frameInfo); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         sc = hrErr; <br>         goto errRtn; <br>      } <br> <br>      lpServerApp-&gt;m_lpIPData = lpIPData; <br>      ShowWindow(hWndDoc, SW_HIDE);   // make sure we are hidden <br> <br>      /* NOTE: reparent in-place server document's window to the <br>      **    special in-place hatch border window. set the in-place site's <br>      **    window as the parent of the hatch window. position the <br>      **    in-place and hatch border windows using the PosRect and <br>      **    ClipRect. <br>      **    it is important to properly parent and position the in-place <br>      **    server window BEFORE calling IOleInPlaceFrame::SetMenu and <br>      **    SetBorderSpace. <br>      */ <br>      ShowWindow(lpServerDoc-&gt;m_hWndHatch, SW_SHOW); <br>      // make sure App busy/blocked dialogs are parented to our <br>      // new hWndFrame <br>      OleStdMsgFilter_SetParentWindow( <br>         lpOleApp-&gt;m_lpMsgFilter,lpIPData-&gt;frameInfo.hwndFrame); <br>      SetParent(lpServerDoc-&gt;m_hWndHatch, lpServerDoc-&gt;m_hWndParent); <br>      SetParent(hWndDoc, lpServerDoc-&gt;m_hWndHatch); <br> <br>#if defined( _DEBUG ) <br>      OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (PosRect)", <br>            (LPRECT)&amp;rcPos); <br>      OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (ClipRect)", <br>            (LPRECT)&amp;rcClip); <br>#endif <br>      // save the current PosRect and ClipRect <br>      lpIPData-&gt;rcPosRect  = rcPos; <br>      lpIPData-&gt;rcClipRect = rcClip; <br> <br>      /* NOTE: build the shared menu for the in-place container and <br>      **    the server. <br>      */ <br>      if (ServerDoc_AssembleMenus (lpServerDoc) != NOERROR) <br>         goto errRtn; <br> <br>#if defined( SVR_INSIDEOUT ) <br>      if (lVerb == OLEIVERB_INPLACEACTIVATE) { <br>         // Clip the hatch window to the size of pos rect so, that <br>         // hatch and object adornments  will not be visible. <br>         ServerDoc_ResizeInPlaceWindow(lpServerDoc, <br>            (LPRECT)&amp;(lpServerDoc-&gt;m_lpIPData-&gt;rcPosRect), <br>            (LPRECT)&amp;(lpServerDoc-&gt;m_lpIPData-&gt;rcPosRect) <br>         ); <br>      } <br>#endif  // SVR_INSIDEOUT <br>   } <br> <br>#if defined( SVR_INSIDEOUT ) <br>   // NOTE: if verb is OLEIVERB_INPLACEACTIVATE we do NOT want to <br>   // show our UI <br>   if (lVerb == OLEIVERB_INPLACEACTIVATE) { <br> <br>      return NOERROR; <br>   } <br>#endif  // SVR_INSIDEOUT <br> <br>   if (! lpServerDoc-&gt;m_fUIActive) { <br>      lpServerDoc-&gt;m_fUIActive = TRUE; <br>      OLEDBG_BEGIN2("IOleInPlaceSite::OnUIActivate called\r\n"); <br>      hrErr = lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;OnUIActivate(lpIPData-&gt;lpSite); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) { <br>         lpServerDoc-&gt;m_fUIActive = FALSE; <br>         goto errRtn; <br>      } <br> <br>      SetFocus(hWndDoc); <br> <br>      // Show the object adornments and hacth border around them. <br>      ServerDoc_ResizeInPlaceWindow(lpServerDoc, <br>               (LPRECT)&amp;lpIPData-&gt;rcPosRect, <br>               (LPRECT)&amp;lpIPData-&gt;rcClipRect <br>      ); <br> <br>      /* NOTE: IOleInPlaceFrame::SetActiveObject must be called BEFORE <br>      **    IOleInPlaceFrame::SetMenu. <br>      */ <br>      OLEDBG_BEGIN2("IOleInPlaceSite::SetActiveObject called\r\n"); <br>      lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;SetActiveObject( <br>         lpIPData-&gt;lpFrame, <br>         (LPOLEINPLACEACTIVEOBJECT) &amp;lpServerDoc-&gt;m_OleInPlaceActiveObject, <br>         /*(LPOLESTR)*/g_szIPObjectTitle <br>      ); <br>      OLEDBG_END2 <br> <br>      /* NOTE: If the container wants to give ownership of the <br>      **    palette then he would sendmessage WM_QUEYNEWPALETTE to <br>      **    the object window proc, before returning from <br>      **    IOleInPlaceFrame::SetActiveObject. Those objects which <br>      **    want to be edited inplace only if they have the ownership of <br>      **    the palette, can check at this point in the code whether <br>      **    they got WM_QUERYNEWPALETTE or not. If they didn't get <br>      **    the message, then they can inplace deactivate and do open <br>      **    editing instead. <br>      */ <br> <br> <br> <br>      if (lpIPData-&gt;lpDoc) { <br>         lpIPData-&gt;lpDoc-&gt;lpVtbl-&gt;SetActiveObject( <br>            lpIPData-&gt;lpDoc, <br>            (LPOLEINPLACEACTIVEOBJECT)&amp;lpServerDoc-&gt;m_OleInPlaceActiveObject, <br>            /*(LPOLESTR)*/g_szIPObjectTitle <br>         ); <br>      } <br> <br>      /* NOTE: install the menu and frame-level tools on the in-place <br>      **    frame. <br>      */ <br>      ServerDoc_AddFrameLevelUI(lpServerDoc); <br>   } <br> <br> <br>   return NOERROR; <br> <br>errRtn: <br>   ServerDoc_DoInPlaceDeactivate(lpServerDoc); <br> <br>   return sc; <br>} <br> <br> <br> <br>HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc) <br>{ <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br> <br>   if (!lpServerDoc-&gt;m_fInPlaceActive) <br>      return S_OK; <br> <br>   lpServerDoc-&gt;m_fInPlaceActive = FALSE; <br> <br>   SvrDoc_IPObj_UIDeactivate( <br>         (LPOLEINPLACEOBJECT)&amp;lpServerDoc-&gt;m_OleInPlaceObject); <br> <br>   /* NOTE: an inside-out style in-place server will <br>   **    NOT hide its window in UIDeactive (an outside-in <br>   **    style object will hide its window in UIDeactivate). <br>   **    thus, an inside-out server must explicitly hide <br>   **    its window in InPlaceDeactivate. it is ALSO important for an <br>   **    outside-in style object to call ServerDoc_DoInPlaceHide here <br>   **    BEFORE freeing the InPlaceData structure. it will be common <br>   **    for in-place containers to call IOleInPlaceObject:: <br>   **    InPlaceDeactivate in their IOleInPlaceSite::OnUIDeactiate <br>   **    implementation. <br>   */ <br>   ServerDoc_DoInPlaceHide(lpServerDoc); <br> <br>   OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n"); <br>   lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;OnInPlaceDeactivate(lpIPData-&gt;lpSite); <br>   OLEDBG_END2 <br> <br>   OleStdRelease((LPUNKNOWN)lpIPData-&gt;lpSite); <br>   lpIPData-&gt;lpSite = NULL; <br> <br>   ServerDoc_FreeInPlaceData(lpServerDoc); <br> <br>   return NOERROR; <br>} <br> <br> <br>HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc) <br>{ <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   HWND            hWndApp = OutlineApp_GetWindow(g_lpApp); <br> <br>   if (! lpServerDoc-&gt;m_fInPlaceVisible) <br>      return NOERROR; <br> <br>   // Set the parent back to server app's window <br>   OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /* fShutdown */); <br> <br>   /* we need to enusure that our window is set to normal 100% zoom. <br>   **    if the window is next shown in open mode it should start out <br>   **    at normal zoom factor. our window may have been set to a <br>   **    different zoom factor while it was in-place active. <br>   */ <br>   OutlineDoc_SetCurrentZoomCommand(lpOutlineDoc,IDM_V_ZOOM_100); <br> <br>   lpServerDoc-&gt;m_fInPlaceVisible = FALSE; <br> <br>   lpServerDoc-&gt;m_hWndParent = hWndApp; <br>   SetParent( <br>      lpOutlineDoc-&gt;m_hWndDoc, <br>      lpServerDoc-&gt;m_hWndParent <br>   ); <br> <br>   // make sure App busy/blocked dialogs are parented to our own hWndApp <br>   OleStdMsgFilter_SetParentWindow(lpOleApp-&gt;m_lpMsgFilter, hWndApp); <br> <br>   // Hide the in-place hatch border window. <br>   ShowWindow(lpServerDoc-&gt;m_hWndHatch, SW_HIDE); <br> <br>   ServerDoc_DisassembleMenus(lpServerDoc); <br> <br>   /* we no longer need the IOleInPlaceFrame* or the doc's </code></pre>
<p>
</p>
<pre><code>**    IOleInPlaceWindow* interface pointers. <br>   */ <br>   if (lpIPData-&gt;lpDoc) { <br>      OleStdRelease((LPUNKNOWN)lpIPData-&gt;lpDoc); <br>      lpIPData-&gt;lpDoc = NULL; <br>   } <br> <br>   if (lpIPData-&gt;lpFrame) { <br>      OleStdRelease((LPUNKNOWN)lpIPData-&gt;lpFrame); <br>      lpIPData-&gt;lpFrame = NULL; <br>   } <br> <br>   ((LPSERVERAPP)g_lpApp)-&gt;m_lpIPData = NULL; <br> <br>   return NOERROR; <br>} <br> <br> <br>BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc) <br>{ <br>   LPINPLACEDATA   lpIPData; <br> <br>   if (!(lpIPData = (LPINPLACEDATA) New(sizeof(INPLACEDATA)))) <br>      return FALSE; <br> <br>   lpIPData-&gt;lpFrame       = NULL; <br>   lpIPData-&gt;lpDoc         = NULL; <br>   lpIPData-&gt;lpSite        = NULL; <br>   lpIPData-&gt;hOlemenu      = NULL; <br>   lpIPData-&gt;hMenuShared   = NULL; <br> <br>   lpServerDoc-&gt;m_lpIPData = lpIPData; <br>   return TRUE; <br>} <br> <br> <br>void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc) <br>{ <br>   Delete(lpServerDoc-&gt;m_lpIPData); <br>   lpServerDoc-&gt;m_lpIPData = NULL; <br>} <br> <br> <br>HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc) <br>{ <br>   HMENU           hMenuShared; <br>   LONG FAR*       lpWidths; <br>   UINT            uPosition; <br>   UINT            uPositionStart; <br>   LPSERVERAPP     lpServerApp = (LPSERVERAPP) g_lpApp; <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   HRESULT         hresult; <br>   BOOL            fNoError = TRUE; <br> <br>   lpWidths = lpIPData-&gt;menuGroupWidths.width; <br>   hMenuShared = CreateMenu(); <br> <br>   if (hMenuShared &amp;&amp; <br>      (hresult = lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;InsertMenus( <br>         lpIPData-&gt;lpFrame, hMenuShared, <br>         &amp;lpIPData-&gt;menuGroupWidths)) == NOERROR) { <br> <br>      /* Insert EDIT group menus */ <br> <br>      uPosition = (UINT)lpWidths[0]; /* # of menus in the FILE group */ <br>      uPositionStart = uPosition; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuEdit, <br>            (LPCSTR)"&amp;Edit" <br>      ); <br>      uPosition++; <br> <br>      lpWidths[1] = uPosition - uPositionStart; <br> <br>      /* Insert OBJECT group menus */ <br> <br>      uPosition += (UINT)lpWidths[2]; <br>      uPositionStart = uPosition; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuLine, <br>            (LPCSTR)"&amp;Line" <br>      ); <br>      uPosition++; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuName, <br>            (LPCSTR)"&amp;Name" <br>      ); <br>      uPosition++; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuOptions, <br>            (LPCSTR)"&amp;Options" <br>      ); <br>      uPosition++; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuDebug, <br>            (LPCSTR)"DbgI&amp;Svr" <br>      ); <br>      uPosition++; <br> <br>      lpWidths[3] = uPosition - uPositionStart; <br> <br>      /* Insert HELP group menus */ <br> <br>      uPosition += (UINT) lpWidths[4]; /* # of menus in WINDOW group */ <br>      uPositionStart = uPosition; <br> <br>      fNoError &amp;= InsertMenu( <br>            hMenuShared, <br>            (UINT)uPosition, <br>            (UINT)(MF_BYPOSITION | MF_POPUP), <br>            (UINT)lpServerApp-&gt;m_hMenuHelp, <br>            (LPCSTR)"&amp;Help" <br>      ); <br>      uPosition++; <br> <br>      lpWidths[5] = uPosition - uPositionStart; <br> <br>      OleDbgAssert(fNoError == TRUE); <br> <br>   } else { <br>      /* In-place container does not allow us to add menus to the <br>      **    frame. <br>      ** NOTE: even when the in-place container does NOT allow <br>      **    the building of a merged menu bar, it is CRITICAL that <br>      **    the in-place server still call OleCreateMenuDescriptor <br>      **    passing NULL for hMenuShared. <br>      */ <br>      if (hMenuShared) { <br>         DestroyMenu(hMenuShared); <br>         hMenuShared = NULL; <br>      } <br>   } <br> <br>   lpIPData-&gt;hMenuShared = hMenuShared; <br> <br>   if (!(lpIPData-&gt;hOlemenu = OleCreateMenuDescriptor(hMenuShared, <br>                                 &amp;lpIPData-&gt;menuGroupWidths))) <br>    { <br>      return E_OUTOFMEMORY; <br>    } <br> <br>   return NOERROR; <br>} <br> <br> <br>void ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc) <br>{ <br>   UINT             uCount; <br>   UINT            uGroup; <br>   UINT            uDeleteAt; <br>   LPINPLACEDATA   lpIPData = lpServerDoc-&gt;m_lpIPData; <br>   LONG FAR*       lpWidths = lpIPData-&gt;menuGroupWidths.width; <br>   BOOL            fNoError = TRUE; <br> <br>   /* NOTE: even when hMenuShared is NULL (ie. the server has no <br>   **    Menu), there is still an hOleMenu created that must be destroyed. <br>   */ <br>   if (lpIPData-&gt;hOlemenu) { <br>      OleDestroyMenuDescriptor (lpIPData-&gt;hOlemenu); <br>      lpIPData-&gt;hOlemenu = NULL; <br>   } <br> <br>   if (! lpIPData-&gt;hMenuShared) <br>      return;     // no menus to be destroyed <br> <br>   /* Remove server group menus. */ <br>   uDeleteAt = 0; <br>   for (uGroup = 0; uGroup &lt; 6; uGroup++) { <br>      uDeleteAt += (UINT)lpWidths[uGroup++]; <br>      for (uCount = 0; uCount &lt; (UINT)lpWidths[uGroup]; uCount++) <br>         fNoError &amp;= RemoveMenu(lpIPData-&gt;hMenuShared, uDeleteAt, <br>                        MF_BYPOSITION); <br>   } <br> <br>   /* Remove container group menus */ <br>   fNoError &amp;= (lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;RemoveMenus( <br>      lpIPData-&gt;lpFrame, <br>      lpIPData-&gt;hMenuShared) == NOERROR); <br> <br>   OleDbgAssert(fNoError == TRUE); <br> <br>   DestroyMenu(lpIPData-&gt;hMenuShared); <br>   lpIPData-&gt;hMenuShared = NULL; <br>} <br> <br> <br>/* ServerDoc_UpdateInPlaceWindowOnExtentChange <br>** ------------------------------------------- <br>**    The size of the in-place window needs to be changed. <br>**    calculate the size required in Client coordinates (taking into <br>**    account the current scale factor imposed by the in-place <br>**    container) and ask our in-place container to allow us to resize. <br>**    our container must call us back via <br>**    IOleInPlaceObject::SetObjectRects for the actual sizing to take <br>**    place. <br>** <br>**    NOTE: the rectangle that we ask for from our in-place <br>**    container is always the rectangle required for the object display <br>**    itself (in our case the size of the LineList contents). it does <br>**    NOT include the space we require for object frame adornments. <br>*/ <br>void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc) <br>{ <br>   SIZEL       sizelHim; <br>   SIZEL       sizelPix; <br>   RECT        rcPosRect; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPLINELIST  lpLL=(LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   HWND        hWndLL = lpLL-&gt;m_hWndListBox; <br>   LPSCALEFACTOR lpscale = (LPSCALEFACTOR)&amp;lpOutlineDoc-&gt;m_scale; <br> <br>   if (!lpServerDoc-&gt;m_fInPlaceActive) <br>      return; <br> <br>   OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&amp;sizelHim); <br> <br>   // apply current scale factor <br>   sizelHim.cx = sizelHim.cx * lpscale-&gt;dwSxN / lpscale-&gt;dwSxD; <br>   sizelHim.cy = sizelHim.cy * lpscale-&gt;dwSxN / lpscale-&gt;dwSxD; <br>   XformSizeInHimetricToPixels(NULL, (LPSIZEL)&amp;sizelHim, (LPSIZEL)&amp;sizelPix); <br> <br>   GetWindowRect(hWndLL, (LPRECT)&amp;rcPosRect); <br>   ScreenToClient(lpServerDoc-&gt;m_hWndParent, (POINT FAR *)&amp;rcPosRect); <br> <br>   rcPosRect.right = rcPosRect.left + (int) sizelPix.cx; <br>   rcPosRect.bottom = rcPosRect.top + (int) sizelPix.cy; <br>   OleDbgOutRect3("ServerDoc_UpdateInPlaceWindowOnExtentChange: (PosRect)", (LPRECT)&amp;rcPosRect); <br> <br>   OLEDBG_BEGIN2("IOleInPlaceSite::OnPosRectChange called\r\n"); <br>   lpServerDoc-&gt;m_lpIPData-&gt;lpSite-&gt;lpVtbl-&gt;OnPosRectChange( <br>         lpServerDoc-&gt;m_lpIPData-&gt;lpSite, <br>         (LPRECT) &amp;rcPosRect <br>   ); <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ServerDoc_CalcInPlaceWindowPos <br> * ------------------------------ <br> * <br> *  Move (and re-scale) the ServerDoc to the specified rectangle. <br> * <br> *  Parameters: <br> *      lprcListBox - rect in client coordinate in which the listbox will fit <br> *      lprcDoc     - corresponding size of the Doc in client coordinate <br> * <br> */ <br>void ServerDoc_CalcInPlaceWindowPos( <br>      LPSERVERDOC         lpServerDoc, <br>      LPRECT              lprcListBox, <br>      LPRECT              lprcDoc, <br>      LPSCALEFACTOR       lpscale <br>) <br>{ <br>   SIZEL sizelHim; <br>   SIZEL sizelPix; <br>   LPLINELIST lpLL; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPHEADING lphead; <br> <br>   if (!lpServerDoc || !lprcListBox || !lprcDoc) <br>      return; <br>   lphead = (LPHEADING)&amp;lpOutlineDoc-&gt;m_heading; <br> <br>   lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&amp;sizelHim); <br>   XformSizeInHimetricToPixels(NULL, &amp;sizelHim, &amp;sizelPix); <br> <br>   if (sizelHim.cx == 0 || sizelPix.cx == 0) { <br>      lpscale-&gt;dwSxN = 1; <br>      lpscale-&gt;dwSxD = 1; <br>   } else { <br>      lpscale-&gt;dwSxN = lprcListBox-&gt;right - lprcListBox-&gt;left; <br>      lpscale-&gt;dwSxD = sizelPix.cx; <br>   } <br> <br>   if (sizelHim.cy == 0 || sizelPix.cy == 0) { <br>      lpscale-&gt;dwSyN = 1; <br>      lpscale-&gt;dwSyD = 1; <br>   } else { <br>      lpscale-&gt;dwSyN = lprcListBox-&gt;bottom - lprcListBox-&gt;top; <br>      lpscale-&gt;dwSyD = sizelPix.cy; <br>   } <br> <br>   lprcDoc-&gt;left = lprcListBox-&gt;left - Heading_RH_GetWidth(lphead,lpscale); <br>   lprcDoc-&gt;right = lprcListBox-&gt;right; <br>   lprcDoc-&gt;top = lprcListBox-&gt;top - Heading_CH_GetHeight(lphead,lpscale); <br>   lprcDoc-&gt;bottom = lprcListBox-&gt;bottom; <br>} <br> <br> <br>/* ServerDoc_ResizeInPlaceWindow <br>** ----------------------------- <br>**    Actually resize the in-place ServerDoc windows according to the <br>**    PosRect and ClipRect allowed by our in-place container. <br>** <br>**    NOTE: the PosRect rectangle that our in-place container tells <br>**    us is always the rectangle required for the object display <br>**    itself (in our case the size of the LineList contents). it does <br>**    NOT include the space we require for object frame adornments. <br>*/ <br>void ServerDoc_ResizeInPlaceWindow( <br>      LPSERVERDOC         lpServerDoc, <br>      LPCRECT             lprcPosRect, <br>      LPCRECT             lprcClipRect <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPLINELIST   lpLL = (LPLINELIST)&amp;lpOutlineDoc-&gt;m_LineList; <br>   SCALEFACTOR  scale; <br>   RECT         rcDoc; <br>   POINT        ptOffset; <br> <br>   /* NOTE: calculate the space needed for our object frame <br>   **    adornments. our in-place container tells us the size that our <br>   **    object should take in window client coordinates <br>   **    (lprcPosRect). the rectangle cooresponds to the size that our <br>   **    LineList ListBox should be. our Doc window must the correct <br>   **    amount larger to accomodate our row/column headings. <br>   **    then move all windows into position. <br>   */ <br>   ServerDoc_CalcInPlaceWindowPos( <br>         lpServerDoc, <br>         (LPRECT)lprcPosRect, <br>         (LPRECT)&amp;rcDoc, <br>         (LPSCALEFACTOR)&amp;scale <br>   ); <br> <br>   /* NOTE: we need to honor the lprcClipRect specified by our <br>   **    in-place container. we must NOT draw outside of the ClipRect. <br>   **    in order to achieve this, we will size the hatch window to be <br>   **    exactly the size that should be visible (rcVisRect). the <br>   **    rcVisRect is defined as the intersection of the full size of <br>   **    the in-place server window and the lprcClipRect. <br>   **    the ClipRect could infact clip the HatchRect on the <br>   **    right/bottom and/or on the top/left. if it is clipped on the <br>   **    right/bottom then it is sufficient to simply resize the hatch <br>   **    window. but if the HatchRect is clipped on the top/left then <br>   **    we must "move" the ServerDoc window (child of HatchWindow) by <br>   **    the delta that was clipped. the window origin of the <br>   **    ServerDoc window will then have negative coordinates relative <br>   **    to its parent HatchWindow. <br>   */ <br>   SetHatchWindowSize( <br>         lpServerDoc-&gt;m_hWndHatch, <br>         (LPRECT)&amp;rcDoc, <br>         (LPRECT)lprcClipRect, <br>         (LPPOINT)&amp;ptOffset <br>   ); <br> <br>   // shift Doc window to account for hatch frame being drawn <br>   OffsetRect((LPRECT)&amp;rcDoc, ptOffset.x, ptOffset.y); <br> <br>   // move/size/set scale factor of ServerDoc window. <br>   OutlineDoc_SetScaleFactor( <br>         lpOutlineDoc, (LPSCALEFACTOR)&amp;scale, (LPRECT)&amp;rcDoc); <br> <br>   /* reset the horizontal extent of the listbox. this makes <br>   **    the listbox realize that a scroll bar is not needed. <br>   */ <br>   SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_SETHORIZONTALEXTENT, <br>         (int) 0, <br>         0L <br>   ); <br>   SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_SETHORIZONTALEXTENT, <br>         (int) (lprcPosRect-&gt;right - lprcPosRect-&gt;left), <br>         0L <br>   ); <br>} <br> <br> <br>/* ServerDoc_SetStatusText <br>**    Tell the active in-place frame to display a status message. <br>*/ <br>void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPOLESTR lpszMessage) <br>{ <br>   if (lpServerDoc &amp;&amp; lpServerDoc-&gt;m_fUIActive &amp;&amp; <br>      lpServerDoc-&gt;m_lpIPData != NULL) { <br> <br>      OLEDBG_BEGIN2("IOleInPlaceFrame::SetStatusText called\r\n") <br>      lpServerDoc-&gt;m_lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;SetStatusText <br>            (lpServerDoc-&gt;m_lpIPData-&gt;lpFrame, lpszMessage); <br>      OLEDBG_END2 <br>   } <br>} <br> <br> <br>/* ServerDoc_GetTopInPlaceFrame <br>** ---------------------------- <br>**    returns NON-AddRef'ed pointer to Top In-Place Frame interface <br>*/ <br>LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc) <br>{ <br>   if (lpServerDoc-&gt;m_lpIPData) <br>      return lpServerDoc-&gt;m_lpIPData-&gt;lpFrame; <br>   else <br>      return NULL; <br>} <br> <br>void ServerDoc_GetSharedMenuHandles( <br>      LPSERVERDOC lpServerDoc, <br>      HMENU FAR*      lphSharedMenu, <br>      HOLEMENU FAR*   lphOleMenu <br>) <br>{ <br>   if (lpServerDoc-&gt;m_lpIPData) { <br>      *lphSharedMenu = lpServerDoc-&gt;m_lpIPData-&gt;hMenuShared; <br>      *lphOleMenu = lpServerDoc-&gt;m_lpIPData-&gt;hOlemenu; <br>   } else { <br>      *lphSharedMenu = NULL; <br>      *lphOleMenu = NULL; <br>   } <br>} <br> <br> <br>void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc); <br>   HMENU           hSharedMenu;            // combined obj/cntr menu <br>   HOLEMENU        hOleMenu;               // returned by OleCreateMenuDesc. <br> <br>   ServerDoc_GetSharedMenuHandles( <br>         lpServerDoc, <br>         &amp;hSharedMenu, <br>         &amp;hOleMenu <br>   ); <br> <br>   lpTopIPFrame-&gt;lpVtbl-&gt;SetMenu( <br>         lpTopIPFrame, <br>         hSharedMenu, <br>         hOleMenu, <br>         lpOutlineDoc-&gt;m_hWndDoc <br>   ); <br> <br>   // save normal accelerator table <br>   lpServerApp-&gt;m_hAccelBaseApp = lpOutlineApp-&gt;m_hAccelApp; <br> <br>   // install accelerator table for UIActive server (w/ active editor cmds) <br>   lpOutlineApp-&gt;m_hAccel = lpServerApp-&gt;m_hAccelIPSvr; <br>   lpOutlineApp-&gt;m_hAccelApp = lpServerApp-&gt;m_hAccelIPSvr; <br>   lpOutlineApp-&gt;m_hWndAccelTarget = lpOutlineDoc-&gt;m_hWndDoc; <br> <br>#if defined( USE_FRAMETOOLS ) <br>   ServerDoc_AddFrameLevelTools(lpServerDoc); <br> <br>   // update toolbar button enable states <br>   OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>} <br> <br> <br>void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc); <br> <br>#if defined( USE_FRAMETOOLS ) <br>   HWND            hWndFrame; <br> <br>   FrameTools_Enable(lpOutlineDoc-&gt;m_lpFrameTools, TRUE); <br> <br>   // if not in-place UI active, add our tools to our own frame. <br>   if (! lpServerDoc-&gt;m_fUIActive) { <br>      OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>      return; <br>   } <br> <br>   if ((hWndFrame = OutlineApp_GetFrameWindow(lpOutlineApp)) == NULL) { <br>      /* we could NOT get a valid frame window, so POP our tools up. */ <br> <br>      /* NOTE: since we are poping up our tools, we MUST inform <br>      **    the top in-place frame window that we need NO tool space <br>      **    BUT that it should NOT put its own tools up. if we were <br>      **    to pass NULL instead of (0,0,0,0), then the container <br>      **    would have the option to leave its own tools up. <br>      */ <br>      lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace( <br>            lpTopIPFrame, <br>            (LPCBORDERWIDTHS)&amp;g_rectNull <br>      ); <br>      FrameTools_PopupTools(lpOutlineDoc-&gt;m_lpFrameTools); <br>   } else { <br> <br>      /* NOTE: we need to negotiate for space and attach our frame <br>      **    level tools to the top-level in-place container's frame window. <br>      */ <br>      FrameTools_AttachToFrame(lpOutlineDoc-&gt;m_lpFrameTools, hWndFrame); <br> <br>      FrameTools_NegotiateForSpaceAndShow( <br>            lpOutlineDoc-&gt;m_lpFrameTools, <br>            NULL, <br>            lpTopIPFrame <br>      ); <br>   } <br> <br>#else   // ! USE_FRAMETOOLS <br>   /* NOTE: if you do NOT use frame tools, you MUST inform the top <br>   **    in-place frame window so that it can put back its own tools. <br>   */ <br>   lpTopIPFrame-&gt;lpVtbl-&gt;SetBorderSpace(lpIPData-&gt;lpFrame, NULL); <br>#endif  // ! USE_FRAMETOOLS <br>} <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br> <br>void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   OleDbgAssert(lpOutlineDoc-&gt;m_lpFrameTools != NULL); <br> <br>    // Reparent our tools back to one of our own windows <br>    FrameTools_AttachToFrame(lpOutlineDoc-&gt;m_lpFrameTools,g_lpApp-&gt;m_hWndApp); <br> <br>   FrameTools_Enable(lpOutlineDoc-&gt;m_lpFrameTools, FALSE); <br>} <br>#endif  // USE_FRAMETOOLS <br> <br> <br> <br>void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc) <br>{ <br>   if (lpServerDoc-&gt;m_fInPlaceActive &amp;&amp; !lpServerDoc-&gt;m_fUIActive) { <br>      ServerDoc_DoInPlaceActivate(lpServerDoc, <br>            OLEIVERB_UIACTIVATE, <br>            NULL /*lpmsg*/, <br>            lpServerDoc-&gt;m_lpOleClientSite <br>      ); <br>      OutlineDoc_ShowWindow((LPOUTLINEDOC)lpServerDoc); <br>   } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
