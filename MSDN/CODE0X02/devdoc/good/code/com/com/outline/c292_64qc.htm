<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEAPP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context294"></a>OLEAPP.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    oleapp.c <br>** <br>**    This file contains functions and methods that are common to <br>**    server and the client version of the app. This includes the class <br>**    factory methods and all OleApp functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br>#include &lt;ole2ver.h&gt; <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br>extern IUnknownVtbl             g_OleApp_UnknownVtbl; <br> <br>extern IUnknownVtbl             g_OleDoc_UnknownVtbl; <br>extern IPersistFileVtbl         g_OleDoc_PersistFileVtbl; <br>extern IOleItemContainerVtbl    g_OleDoc_OleItemContainerVtbl; <br>extern IExternalConnectionVtbl  g_OleDoc_ExternalConnectionVtbl; <br>extern IDataObjectVtbl          g_OleDoc_DataObjectVtbl; <br> <br>#if defined( USE_DRAGDROP ) <br>extern IDropTargetVtbl          g_OleDoc_DropTargetVtbl; <br>extern IDropSourceVtbl          g_OleDoc_DropSourceVtbl; <br>#endif  // USE_DRAGDROP <br> <br>#if defined( OLE_SERVER ) <br>extern IOleObjectVtbl       g_SvrDoc_OleObjectVtbl; <br>extern IPersistStorageVtbl  g_SvrDoc_PersistStorageVtbl; <br> <br>#if defined( SVR_TREATAS ) <br>extern IStdMarshalInfoVtbl  g_SvrDoc_StdMarshalInfoVtbl; <br>#endif  // SVR_TREATAS <br> <br>extern IUnknownVtbl         g_PseudoObj_UnknownVtbl; <br>extern IOleObjectVtbl       g_PseudoObj_OleObjectVtbl; <br>extern IDataObjectVtbl      g_PseudoObj_DataObjectVtbl; <br> <br>#if defined( INPLACE_SVR ) <br>extern IOleInPlaceObjectVtbl        g_SvrDoc_OleInPlaceObjectVtbl; <br>extern IOleInPlaceActiveObjectVtbl  g_SvrDoc_OleInPlaceActiveObjectVtbl; <br>#endif  // INPLACE_SVR <br> <br>#endif  // OLE_SERVER <br> <br>#if defined( OLE_CNTR ) <br> <br>extern IOleUILinkContainerVtbl  g_CntrDoc_OleUILinkContainerVtbl; <br>extern IUnknownVtbl             g_CntrLine_UnknownVtbl; <br>extern IOleClientSiteVtbl       g_CntrLine_OleClientSiteVtbl; <br>extern IAdviseSinkVtbl          g_CntrLine_AdviseSinkVtbl; <br> <br>#if defined( INPLACE_CNTR ) <br>extern IOleInPlaceSiteVtbl      g_CntrLine_OleInPlaceSiteVtbl; <br>extern IOleInPlaceFrameVtbl     g_CntrApp_OleInPlaceFrameVtbl; <br>extern BOOL g_fInsideOutContainer; <br>#endif  // INPLACE_CNTR <br> <br>#endif  // OLE_CNTR <br> <br>// REVIEW: these are NOT useful end-user messages <br>static OLECHAR ErrMsgCreateCF[] = OLESTR("Can't create Class Factory!"); <br>static OLECHAR ErrMsgRegCF[] = OLESTR("Can't register Class Factory!"); <br>static OLECHAR ErrMsgRegMF[] = OLESTR("Can't register Message Filter!"); <br> <br>extern UINT g_uMsgHelp; <br> <br> <br>/* OleApp_InitInstance <br> * ------------------- <br> * <br> * Initialize the app instance by creating the main frame window and <br> * performing app instance specific initializations <br> *  (eg. initializing interface Vtbls). <br> * <br> * RETURNS: TRUE if the memory could be allocated, and the server app <br> *               was properly initialized. <br> *          FALSE otherwise <br> * <br> */ <br>BOOL OleApp_InitInstance(LPOLEAPP lpOleApp, HINSTANCE hInst, int nCmdShow) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   HRESULT hrErr; <br>   DWORD   dwBuildVersion = OleBuildVersion(); <br>   LPMALLOC lpMalloc = NULL; <br> <br>   OLEDBG_BEGIN3("OleApp_InitInstance\r\n") <br> <br>   lpOleApp-&gt;m_fOleInitialized = FALSE; <br>   lpOleApp-&gt;m_fOleStdInit = FALSE; <br> <br>   /* NOTE: check if the build version of the OLE2 DLL's match <br>   **    what our application is expecting. <br>   */ <br>   if (HIWORD(dwBuildVersion) != rmm || LOWORD(dwBuildVersion) &lt; rup) { <br>      OleDbgAssertSz(0, "ERROR: OLE 2.0 DLL's are NOT compatible!"); <br> <br>#if !defined( _DEBUG ) <br>      return FALSE;   // Wrong version of DLL's <br>#endif <br>   } <br> <br>   /* NOTE: the OLE libraries must be properly initialized before <br>   **    making any calls. OleInitialize automatically calls <br>   **    CoInitialize. we will use the default task memory allocator <br>   **    therefore we pass NULL to OleInitialize. <br>   */ <br>   OLEDBG_BEGIN2("OleInitialize called\r\n") <br>   hrErr = OleInitialize(NULL); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OutlineApp_ErrorMessage(lpOutlineApp,OLESTR("OLE initialization failed!")); <br>      goto error; <br>   } <br> <br> <br>   /***************************************************************** <br>   ** NOTE: we must remember the fact that OleInitialize has <br>   **    been call successfully. the very last thing an app must <br>   **    be do is properly shut down OLE by calling <br>   **    OleUninitialize. This call MUST be guarded! it is only <br>   **    allowable to call OleUninitialize if OleInitialize has <br>   **    been called SUCCESSFULLY. <br>   *****************************************************************/ <br> <br>   lpOleApp-&gt;m_fOleInitialized = TRUE; <br> <br>   lpOleApp-&gt;m_fOleStdInit = OleStdInitialize(hInst); <br>   if (!lpOleApp-&gt;m_fOleStdInit) <br>   { <br>      OutlineApp_ErrorMessage(lpOutlineApp,OLESTR("OleStd initialization failed!")); <br>      goto error; <br>   } <br> <br>   // Initialize the OLE 2.0 interface method tables. <br>   if (! OleApp_InitVtbls(lpOleApp)) <br>      goto error; <br> <br>   // Register OLE 2.0 clipboard formats. <br>   lpOleApp-&gt;m_cfEmbedSource = RegisterClipboardFormat(CF_EMBEDSOURCE); <br>   lpOleApp-&gt;m_cfEmbeddedObject = RegisterClipboardFormat( <br>         CF_EMBEDDEDOBJECT <br>   ); <br>   lpOleApp-&gt;m_cfLinkSource = RegisterClipboardFormat(CF_LINKSOURCE); <br>   lpOleApp-&gt;m_cfFileName = RegisterClipboardFormat(CF_FILENAME); <br>   lpOleApp-&gt;m_cfObjectDescriptor = <br>         RegisterClipboardFormat(CF_OBJECTDESCRIPTOR); <br>   lpOleApp-&gt;m_cfLinkSrcDescriptor = <br>         RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR); <br> <br>   lpOleApp-&gt;m_cRef                    = 0; <br>   lpOleApp-&gt;m_cDoc                    = 0; <br>   lpOleApp-&gt;m_fUserCtrl               = FALSE; <br>   lpOleApp-&gt;m_dwRegClassFac           = 0; <br>   lpOleApp-&gt;m_lpClassFactory          = NULL; <br>   lpOleApp-&gt;m_cModalDlgActive         = 0; <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpOleApp-&gt;m_Unknown, <br>         &amp;g_OleApp_UnknownVtbl, <br>         lpOleApp <br>   ); <br> <br>#if defined( USE_DRAGDROP ) <br> <br>   // delay before dragging should start, in milliseconds <br>   lpOleApp-&gt;m_nDragDelay = GetProfileInt( <br>         "windows", <br>         "DragDelay", <br>         DD_DEFDRAGDELAY <br>   ); <br> <br>   // minimum distance (radius) before drag should start, in pixels <br>   lpOleApp-&gt;m_nDragMinDist = GetProfileInt( <br>         "windows", <br>         "DragMinDist", <br>         DD_DEFDRAGMINDIST <br>   ); <br> <br>   // delay before scrolling, in milliseconds <br>   lpOleApp-&gt;m_nScrollDelay = GetProfileInt( <br>         "windows", <br>         "DragScrollDelay", <br>         DD_DEFSCROLLDELAY <br>   ); <br> <br>   // inset-width of the hot zone, in pixels <br>   lpOleApp-&gt;m_nScrollInset = GetProfileInt( <br>         "windows", <br>         "DragScrollInset", <br>         DD_DEFSCROLLINSET <br>   ); <br> <br>   // scroll interval, in milliseconds <br>   lpOleApp-&gt;m_nScrollInterval = GetProfileInt( <br>         "windows", <br>         "DragScrollInterval", <br>         DD_DEFSCROLLINTERVAL <br>   ); <br> <br>#if defined( IF_SPECIAL_DD_CURSORS_NEEDED ) <br>   // This would be used if the app wanted to have custom drag/drop cursors <br>   lpOleApp-&gt;m_hcursorDragNone  = LoadCursor ( hInst, "DragNoneCur" ); <br>   lpOleApp-&gt;m_hcursorDragCopy  = LoadCursor ( hInst, "DragCopyCur" ); <br>   lpOleApp-&gt;m_hcursorDragMove  = LoadCursor ( hInst, "DragMoveCur" ); <br>   lpOleApp-&gt;m_hcursorDragLink  = LoadCursor ( hInst, "DragLinkCur" ); <br>#endif  // IF_SPECIAL_DD_CURSORS_NEEDED <br> <br>#endif  // USE_DRAGDROP <br> <br>   lpOleApp-&gt;m_lpMsgFilter = NULL; <br> <br>#if defined( USE_MSGFILTER ) <br>   /* NOTE: Register our message filter upon app startup. the <br>   **    message filter is used to handle concurrency. <br>   **    we will use a standard implementation of IMessageFilter that <br>   **    is included as part of the OLE2UI library. <br>   */ <br>   lpOleApp-&gt;m_lpMsgFilter = NULL; <br>   if (! OleApp_RegisterMessageFilter(lpOleApp)) <br>      goto error; <br> <br>   /* NOTE: because our app is initially INVISIBLE, we must <br>   **    DISABLE the busy dialog. we should NOT put up any dialogs if <br>   **    our app is invisible. when our app window is made visible, <br>   **    then the busy dialog will be enabled. <br>   */ <br>   OleStdMsgFilter_EnableBusyDialog(lpOleApp-&gt;m_lpMsgFilter, FALSE); <br>#endif  // USE_MSGFILTER <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: perform initialization specific for an OLE server */ <br>   if (! ServerApp_InitInstance((LPSERVERAPP)lpOutlineApp, hInst, nCmdShow)) <br>      goto error; <br>#endif <br>#if defined( OLE_CNTR ) <br>   /* NOTE: perform initialization specific for an OLE container */ <br> <br>   // Register help message <br>   g_uMsgHelp = RegisterWindowMessage(SZOLEUI_MSG_HELP); <br> <br>   if (! ContainerApp_InitInstance((LPCONTAINERAPP)lpOutlineApp, hInst, nCmdShow)) <br>      goto error; <br>#endif <br> <br>#if defined( OLE_CNTR ) <br>   lpOleApp-&gt;m_hStdPal = OleStdCreateStandardPalette(); <br>#endif <br> <br>   OLEDBG_END3 <br>   return TRUE; <br> <br>error: <br>   OLEDBG_END3 <br>   return FALSE; <br>} <br> <br> <br>/* <br> * OleApp_TerminateApplication <br> * --------------------------- <br> *  Perform proper OLE application cleanup before shutting down <br> */ <br>void OleApp_TerminateApplication(LPOLEAPP lpOleApp) <br>{ <br>   OLEDBG_BEGIN3("OleApp_TerminateApplication\r\n") <br> <br>   /* NOTE: perform a clean shut down for OLE. at this point our <br>   **    App refcnt should be 0, or else we should never have reached <br>   **    this point! <br>   */ <br>   OleDbgAssertSz(lpOleApp-&gt;m_cRef == 0, "App NOT shut down properly"); <br> <br>   if (lpOleApp-&gt;m_fOleStdInit) <br>   { <br>       OLEDBG_BEGIN2("OleStdUninitialize called\r\n") <br>       OleStdUninitialize(); <br>       OLEDBG_END2 <br>   } <br>   if(lpOleApp-&gt;m_fOleInitialized) { <br>      OLEDBG_BEGIN2("OleUninitialize called\r\n") <br>      OleUninitialize(); <br>      OLEDBG_END2 <br>   } <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_ParseCmdLine <br> * ------------------- <br> * <br> * Parse the command line for any execution flags/arguments. <br> *      NOTE: check if "-Embedding" switch is given. <br> */ <br>BOOL OleApp_ParseCmdLine(LPOLEAPP lpOleApp, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   char szFileName[256];   /* buffer for filename in command line */ <br>   BOOL fStatus = TRUE; <br>   BOOL fEmbedding = FALSE; <br>   OLECHAR szUniStr[256]; <br> <br>   OLEDBG_BEGIN3("OleApp_ParseCmdLine\r\n") <br> <br>   szFileName[0] = '\0'; <br>   ParseCmdLine(lpszCmdLine, &amp;fEmbedding, (LPSTR)szFileName); <br> <br>#if defined( MDI_VERSION ) <br>   /* NOTE: an MDI app would ALWAYS register its ClassFactory. it <br>   **    can handle multiple objects at the same time, while an SDI <br>   **    application can only handle a single embedded or file-based <br>   **    object at a time. <br>   */ <br>   fStatus = OleApp_RegisterClassFactory(lpOleApp); <br>#endif <br> <br>   if(fEmbedding) { <br> <br>      if (szFileName[0] == '\0') { <br> <br>         /***************************************************************** <br>         ** App was launched with /Embedding. <br>         **    We must register our ClassFactory with OLE, remain hidden <br>         **    (the app window is initially created not visible), and <br>         **    wait for OLE to call IClassFactory::CreateInstance <br>         **    method. We do not automatically create a document as we <br>         **    do when the app is launched by the user from the <br>         **    FileManager. We must NOT make our app window visible <br>         **    until told to do so by our container. <br>         ** <br>         ** NOTE: Because we are an SDI app, we only register our <br>         **    ClassFactory if we are launched with the /Embedding <br>         **    flag WITHOUT a filename. an MDI app would ALWAYS <br>         **    register its ClassFactory. it can handle multiple <br>         **    objects at the same time, while an SDI application <br>         **    can only handle a single embedded or file-based <br>         **    object at a time. <br>         *****************************************************************/ <br> <br>#if defined( SDI_VERSION ) <br>         fStatus = OleApp_RegisterClassFactory(lpOleApp); <br>#endif <br>      } else { <br> <br>         /***************************************************************** <br>         ** App was launched with /Embedding &lt;Filename&gt;. <br>         **    We must create a document and load the file and <br>         **    register it in the RunningObjectTable BEFORE we <br>         **    enter our GetMessage loop (ie. before we yield). <br>         **    One way to perform these tasks is to call the same <br>         **    interface methods that OLE 2.0 calls for linking to a <br>         **    file: <br>         **          IClassFactory::CreateInstance <br>         **          IPersistFile::Load <br>         ** <br>         **    We must NOT make our app window visible until told to <br>         **    do so by our container. An application will be <br>         **    launched in this manner by an OLE 1.0 application <br>         **    link situation (eg. double clicking a linked object <br>         **    or OleCreateLinkFromFile called). <br>         ** <br>         ** NOTE: Because we are an SDI app, we should NOT <br>         **    register our ClassFactory when we are launched with the <br>         **    /Embedding &lt;Filename&gt; flag. our SDI instance can only <br>         **    handle a single embedded or file-based object. <br>         **    an MDI app WOULD register its ClassFactory at all <br>         **    times because it can handle multiple objects. <br>         *****************************************************************/ <br> <br>         // allocate a new document object <br>         lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>         if (! lpOutlineApp-&gt;m_lpDoc) { <br>            OLEDBG_END3 <br>            return FALSE; <br>         } <br> <br>         /* NOTE: initially the Doc object is created with a 0 ref <br>         **    count. in order to have a stable Doc object during the <br>         **    process of initializing the new Doc instance, <br>         **    we intially AddRef the Doc ref cnt and later <br>         **    Release it. This initial AddRef is artificial; it is simply <br>         **    done to guarantee that a harmless QueryInterface followed by <br>         **    a Release does not inadvertantly force our object to destroy <br>         **    itself prematurely. <br>         */ <br>         OleDoc_AddRef((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>         /* NOTE: OutlineDoc_LoadFromFile will register our document <br>         **    in the RunningObjectTable. this registration will <br>         **    AddRef our document. therefore our document will not <br>         **    be destroyed when we release the artificial AddRef <br>         */ <br>         A2W (szFileName, szUniStr, 256); <br>         fStatus = OutlineDoc_LoadFromFile( <br>               lpOutlineApp-&gt;m_lpDoc, /*(LPOLESTR)*/szUniStr); <br> <br>         OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); // rel AddRef <br> <br>         OLEDBG_END3 <br>         return fStatus; <br>      } <br>   } else { <br> <br>      /***************************************************************** <br>      ** App was launched by the user (without /Embedding) and <br>      **    therefore is marked to be under user control. <br>      **    In this case, because we are an SDI app, we do NOT <br>      **    register our ClassFactory with OLE. This app instance can <br>      **    only manage one document at a time (either a user <br>      **    document or an embedded object document). An MDI app <br>      **    would register its ClassFactory here. <br>      ** <br>      **    We must create a document for the user (either <br>      **    initialized from a file given on the command line or <br>      **    initialized as an untitled document. We must also make <br>      **    our app window visible to the user. <br>      *****************************************************************/ <br> <br>      // allocate a new document object <br>      lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>      if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>      /* NOTE: initially the Doc object is created with a 0 ref <br>      **    count. in order to have a stable Doc object during the <br>      **    process of initializing the new Doc instance, <br>      **    we intially AddRef the Doc ref cnt and later <br>      **    Release it. This initial AddRef is artificial; it is simply <br>      **    done to guarantee that a harmless QueryInterface followed by <br>      **    a Release does not inadvertantly force our object to destroy <br>      **    itself prematurely. <br>      */ <br>      OleDoc_AddRef((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>      if(*szFileName) { <br>         // initialize the document from the specified file <br>         A2W (szFileName, szUniStr, 256); <br>         if (! OutlineDoc_LoadFromFile(lpOutlineApp-&gt;m_lpDoc, szUniStr)) <br>            goto error; <br>      } else { <br>         // set the doc to an (Untitled) doc. <br>         if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>            goto error; <br>      } <br> <br>      // position and size the new doc window <br>      OutlineApp_ResizeWindows(lpOutlineApp); <br>      OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); // calls OleDoc_Lock <br>      OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc);// rel AddRef above <br> <br>      // show main app window <br>      ShowWindow(lpOutlineApp-&gt;m_hWndApp, nCmdShow); <br>      UpdateWindow(lpOutlineApp-&gt;m_hWndApp); <br> <br>#if defined( OLE_CNTR ) <br>      ContainerDoc_UpdateLinks((LPCONTAINERDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   } <br> <br>   OLEDBG_END3 <br>   return fStatus; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage( <br>         lpOutlineApp, <br>         OLESTR("Could not create document--Out of Memory") <br>   ); <br>   if (lpOutlineApp-&gt;m_lpDoc)      // rel artificial AddRef above <br>      OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>   OLEDBG_END3 <br>   return FALSE; <br>} <br> <br> <br>/* OleApp_CloseAllDocsAndExitCommand <br> * --------------------------------- <br> * <br> *  Close all active documents and exit the app. <br> *  Because this is an SDI, there is only one document <br> *  If the doc was modified, prompt the user if he wants to save it. <br> * <br> *  Returns: <br> *      TRUE if the app is successfully closed <br> *      FALSE if failed or aborted <br> * <br> * NOTE: in the OLE version, we can NOT directly <br> *     destroy the App object. we can only take all <br> *     necessary actions to ensure that our object receives <br> *     all of its Releases from clients holding onto <br> *     pointers (eg. closing all docs and flushing the <br> *     clipboard) and then we must hide our window and wait <br> *     actually for our refcnt to reach 0. when it reaches 0, <br> *     our destructor (OutlineApp_Destroy) will be called. <br> *     each document addref's the app object in order to <br> *     guarentee that the app does not shut down while the doc <br> *     is still open. closing all docs, will release these <br> *     refcnt's. if there are now more open documents AND the <br> *     app is not under the control of the user (ie. launched by <br> *     OLE) then the app will now shut down. the OleApp_Release <br> *     function executes this shut down procedure. after closing <br> *     all docs, then releasing the user refcnt will force the <br> *     app to shut down. <br> */ <br>BOOL OleApp_CloseAllDocsAndExitCommand( <br>      LPOLEAPP            lpOleApp, <br>      BOOL                fForceEndSession <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   DWORD dwSaveOption = (fForceEndSession ? <br>                           OLECLOSE_NOSAVE : OLECLOSE_PROMPTSAVE); <br> <br>   /* NOTE: in order to have a stable App object during the <br>   **    process of closing, we intially AddRef the App ref cnt and <br>   **    later Release it. This initial AddRef is artificial; it is <br>   **    simply done to guarantee that our App object does not <br>   **    destroy itself until the end of this routine. <br>   */ <br>   OleApp_AddRef(lpOleApp); <br> <br>   /* Because this is an SDI app, there is only one document. <br>   ** Close the doc. if it is successfully closed and the app will <br>   ** not automatically exit, then also exit the app. <br>   ** if this were an MDI app, we would loop through and close all <br>   ** open MDI child documents. <br>   */ <br> <br>#if defined( OLE_SERVER ) <br>   if (!fForceEndSession &amp;&amp; <br>         lpOutlineApp-&gt;m_lpDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED) <br>      dwSaveOption = OLECLOSE_SAVEIFDIRTY; <br>#endif <br> <br>   if (! OutlineDoc_Close(lpOutlineApp-&gt;m_lpDoc, dwSaveOption)) { <br>      OleApp_Release(lpOleApp); <br>      return FALSE;     // User Aborted shutdown <br>   } <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz( <br>         lpOutlineApp-&gt;m_lpDoc==NULL, <br>         "Closed doc NOT properly destroyed" <br>   ); <br>#endif <br> <br>#if defined( OLE_CNTR ) <br>   /* if we currently have data on the clipboard then we must tell <br>   **    the clipboard to release our clipboard data object <br>   **    (document) <br>   */ <br>   if (lpOutlineApp-&gt;m_lpClipboardDoc) <br>      OleApp_FlushClipboard(lpOleApp); <br>#endif <br> <br>   OleApp_HideWindow(lpOleApp); <br> <br>   /* NOTE: this call forces all external connections to our <br>   **    object to close down and therefore guarantees that we receive <br>   **    all releases associated with those external connections. <br>   */ <br>   OLEDBG_BEGIN2("CoDisconnectObject(lpApp) called\r\n") <br>   CoDisconnectObject((LPUNKNOWN)&amp;lpOleApp-&gt;m_Unknown, 0); <br>   OLEDBG_END2 <br> <br>   OleApp_Release(lpOleApp);       // release artificial AddRef above <br> <br>   return TRUE; <br>} <br> <br> <br>/* OleApp_ShowWindow <br> * ----------------- <br> * <br> *      Show the window of the app to the user. <br> *      make sure app window is visible and bring the app to the top. <br> *      IF fGiveUserCtrl == TRUE <br> *          THEN give the user the control over the life-time of the app. <br> */ <br>void OleApp_ShowWindow(LPOLEAPP lpOleApp, BOOL fGiveUserCtrl) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br> <br>   OLEDBG_BEGIN3("OleApp_ShowWindow\r\n") <br> <br>   /* NOTE: while the application is visible and under user <br>   **    control, we do NOT want it to be prematurely destroyed when <br>   **    the user closes a document. thus we must inform OLE to hold <br>   **    an external lock on our application on behalf of the user. <br>   **    this arranges that OLE holds at least 1 reference to our <br>   **    application that will NOT be released until we release this <br>   **    external lock. later, when the application window is hidden, we <br>   **    will release this external lock. <br>   */ <br>   if (fGiveUserCtrl &amp;&amp; ! lpOleApp-&gt;m_fUserCtrl) { <br>      lpOleApp-&gt;m_fUserCtrl = TRUE; <br>      OleApp_Lock(lpOleApp, TRUE /* fLock */, 0 /* not applicable */); <br>   } <br> <br>   // we must show our App window and force it to have input focus <br>   ShowWindow(lpOutlineApp-&gt;m_hWndApp, SW_SHOWNORMAL); <br>   SetForegroundWindow(lpOutlineApp-&gt;m_hWndApp); <br> <br>   /* NOTE: because our app is now visible, we can enable the busy <br>   **    dialog. we should NOT put up any dialogs if our app is <br>   **    invisible. <br>   */ <br>   OleApp_EnableBusyDialogs(lpOleApp, TRUE, TRUE); <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_HideWindow <br> * ----------------- <br> * <br> *      Hide the window of the app from the user. <br> *      take away the control of the app by the user. <br> */ <br>void OleApp_HideWindow(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br> <br>   OLEDBG_BEGIN3("OleApp_HideWindow\r\n") <br> <br>   /* NOTE: the application is now being hidden, so we must release <br>   **    the external lock that was made on behalf of the user. <br>   **    if this is that last external lock on our application, thus <br>   **    enabling our application to complete its shutdown operation. <br>   */ <br>   if (lpOleApp-&gt;m_fUserCtrl) { <br>      lpOleApp-&gt;m_fUserCtrl = FALSE; <br>      OleApp_Lock(lpOleApp, FALSE /*fLock*/, TRUE /*fLastUnlockReleases*/); <br>   } <br> <br>   ShowWindow(lpOutlineApp-&gt;m_hWndApp, SW_HIDE); <br> <br>   /* NOTE: because our app is now INVISIBLE, we must DISABLE the busy <br>   **    dialog. we should NOT put up any dialogs if our app is <br>   **    invisible. <br>   */ <br>   OleApp_EnableBusyDialogs(lpOleApp, FALSE, FALSE); <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_Lock <br>** ----------- <br>**    Lock/Unlock the App object. if the last lock is unlocked and <br>**    fLastUnlockReleases == TRUE, then the app object will shut down <br>**    (ie. it will recieve its final release and its refcnt will go to 0). <br>*/ <br>HRESULT OleApp_Lock(LPOLEAPP lpOleApp, BOOL fLock, BOOL fLastUnlockReleases) <br>{ <br>   HRESULT hrErr; <br> <br>#if defined( _DEBUG ) <br>   if (fLock) { <br>      OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,TRUE) called\r\n") <br>   } else { <br>      if (fLastUnlockReleases) <br>         OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,FALSE,TRUE) called\r\n") <br>      else <br>         OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,FALSE,FALSE) called\r\n") <br>   } <br>#endif  // _DEBUG <br> <br>   OleApp_AddRef(lpOleApp);       // artificial AddRef to make object stable <br> <br>   hrErr = CoLockObjectExternal( <br>         (LPUNKNOWN)&amp;lpOleApp-&gt;m_Unknown, fLock, fLastUnlockReleases); <br> <br>   OleApp_Release(lpOleApp);       // release artificial AddRef above <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>/* OleApp_Destroy <br> * -------------- <br> * <br> *  Free all OLE related resources that had been allocated for the app. <br> */ <br>void OleApp_Destroy(LPOLEAPP lpOleApp) <br>{ <br>   // NOTE: Revoke our message filter upon app shutdown. <br>   OleApp_RevokeMessageFilter(lpOleApp); <br> <br>   // NOTE: Revoke our ClassFactory upon app shutdown. <br>   OleApp_RevokeClassFactory(lpOleApp); <br> <br>#if defined( IF_SPECIAL_DD_CURSORS_NEEDED ) <br>   // This would be used if the app wanted to have custom drag/drop cursors <br>   DestroyCursor(lpOleApp-&gt;m_hcursorDragNone); <br>   DestroyCursor(lpOleApp-&gt;m_hcursorDragCopy); <br>   DestroyCursor(lpOleApp-&gt;m_hcursorDragLink); <br>   DestroyCursor(lpOleApp-&gt;m_hcursorDragMove); <br>#endif  // IF_SPECIAL_DD_CURSORS_NEEDED <br> <br>#if defined( OLE_CNTR ) <br>   if (lpOleApp-&gt;m_hStdPal) { <br>      DeleteObject(lpOleApp-&gt;m_hStdPal); <br>      lpOleApp-&gt;m_hStdPal = NULL; <br>   } <br>#endif <br>} <br> <br> <br>/* OleApp_DocLockApp <br>** ----------------- <br>**    Add a lock on the App on behalf of the Doc. the App may not close <br>**    while the Doc exists. <br>** <br>**    when a document is first created, it calls this method to <br>**    guarantee that the application stays alive (OleDoc_Init). <br>**    when a document is destroyed, it calls <br>**    OleApp_DocUnlockApp to release this hold on the app. <br>*/ <br>void OleApp_DocLockApp(LPOLEAPP lpOleApp) <br>{ <br>   ULONG cDoc; <br> <br>   OLEDBG_BEGIN3("OleApp_DocLockApp\r\n") <br> <br>   cDoc = ++lpOleApp-&gt;m_cDoc; <br> <br>   OleDbgOutRefCnt3("OleApp_DocLockApp: cDoc++\r\n", lpOleApp, cDoc); <br> <br>   OleApp_Lock(lpOleApp, TRUE /* fLock */, 0 /* not applicable */); <br> <br>   OLEDBG_END3 <br>   return; <br>} <br> <br> <br>/* OleApp_DocUnlockApp <br>** ------------------- <br>**    Forget all references to a closed document. <br>**    Release the lock on the App on behalf of the Doc. if this was the <br>**    last lock on the app, then it will shutdown. <br>*/ <br>void OleApp_DocUnlockApp(LPOLEAPP lpOleApp, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   ULONG cDoc; <br> <br>   OLEDBG_BEGIN3("OleApp_DocUnlockApp\r\n") <br> <br>   /* NOTE: when there are no open documents and the app is not <br>   **    under the control of the user then revoke our ClassFactory to <br>   **    enable the app to shut down. <br>   */ <br>   cDoc = --lpOleApp-&gt;m_cDoc; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz ( <br>         lpOleApp-&gt;m_cDoc &gt;= 0, "DocUnlockApp called with cDoc == 0"); <br> <br>   OleDbgOutRefCnt3( <br>         "OleApp_DocUnlockApp: cDoc--\r\n", lpOleApp, cDoc); <br>#endif <br> <br>   OleApp_Lock(lpOleApp, FALSE /* fLock */, TRUE /* fLastUnlockReleases */); <br> <br>   OLEDBG_END3 <br>   return; <br>} <br> <br> <br>/* OleApp_HideIfNoReasonToStayVisible <br>** ---------------------------------- <br>** <br>** if there are no more documents visible to the user and the app <br>**    itself is not under user control, then it has no reason to stay <br>**    visible. we thus should hide the app. we can not directly destroy <br>**    the app, because it may be validly being used programatically by <br>**    another client application and should remain running. the app <br>**    should simply be hidden from the user. <br>*/ <br>void OleApp_HideIfNoReasonToStayVisible(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   LPOUTLINEDOC lpOutlineDoc; <br> <br>   OLEDBG_BEGIN3("OleApp_HideIfNoReasonToStayVisible\r\n") <br> <br>   if (lpOleApp-&gt;m_fUserCtrl) { <br>      OLEDBG_END3 <br>      return;     // remain visible; user in control of app <br>   } <br> <br>   /* Because this is an SDI app, there is only one user document. <br>   ** check if it is visible to the user. an MDI app would loop over <br>   ** all open MDI child documents to see if any are visible. <br>   */ <br>   lpOutlineDoc = (LPOUTLINEDOC)lpOutlineApp-&gt;m_lpDoc; <br>   if (lpOutlineDoc &amp;&amp; IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc)) <br>      return;     // remain visible; the doc is visible to the user <br> <br>   // if we reached here, the app should be hidden <br>   OleApp_HideWindow(lpOleApp); <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_AddRef <br>** ------------- <br>** <br>**  increment the ref count of the App object. <br>** <br>**    Returns the new ref count on the object <br>*/ <br>ULONG OleApp_AddRef(LPOLEAPP lpOleApp) <br>{ <br>   ++lpOleApp-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRefCnt4( <br>         "OleApp_AddRef: cRef++\r\n", <br>         lpOleApp, <br>         lpOleApp-&gt;m_cRef <br>   ); <br>#endif <br>   return lpOleApp-&gt;m_cRef; <br>} <br> <br> <br>/* OleApp_Release <br>** -------------- <br>** <br>**  decrement the ref count of the App object. <br>**    if the ref count goes to 0, then the app object is destroyed. <br>** <br>**    Returns the remaining ref count on the object <br>*/ <br>ULONG OleApp_Release (LPOLEAPP lpOleApp) <br>{ <br>   ULONG cRef; <br> <br>   cRef = --lpOleApp-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz (lpOleApp-&gt;m_cRef &gt;= 0, "Release called with cRef == 0"); <br> <br>   OleDbgOutRefCnt4( <br>         "OleApp_Release: cRef--\r\n", lpOleApp, cRef); </code></pre>
<p>
</p>
<pre><code>#endif  // _DEBUG <br>   /********************************************************************* <br>   ** NOTE: when the ClassFactory refcnt == 0, then destroy it.    ** <br>   **    otherwise the ClassFactory is still in use.                   ** <br>   *********************************************************************/ <br> <br>   if(cRef == 0) <br>      OutlineApp_Destroy((LPOUTLINEAPP)lpOleApp); <br> <br>   return cRef; <br>} <br> <br> <br> <br>/* OleApp_QueryInterface <br>** --------------------- <br>** <br>** Retrieve a pointer to an interface on the app object. <br>** <br>**    NOTE: this function will AddRef the ref cnt of the object. <br>** <br>**    Returns NOERROR if interface is successfully retrieved. <br>**            E_NOINTERFACE if the interface is not supported <br>*/ <br>HRESULT OleApp_QueryInterface ( <br>      LPOLEAPP                lpOleApp, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   SCODE sc; <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvObj = NULL; <br> <br>   if (IsEqualIID(riid, &amp;IID_IUnknown)) { <br>      OleDbgOut4("OleApp_QueryInterface: IUnknown* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpOleApp-&gt;m_Unknown; <br>      OleApp_AddRef(lpOleApp); <br>      sc = S_OK; <br>   } <br>   else { <br>      sc = E_NOINTERFACE; <br>   } <br> <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br>   return sc; <br>} <br> <br> <br>/* OleApp_RejectInComingCalls <br>** ------------------------- <br>**    Reject/Handle in coming OLE (LRPC) calls. <br>** <br>**    NOTE: if the app is in a state when it can NOT handle in <br>**    coming OLE method calls from an external process (eg. the app has <br>**    an application modal dialog up), then it should call <br>**    OleApp_RejectInComingCalls(TRUE). in this state the <br>**    IMessageFilter::HandleInComingCall method will return <br>**    SERVERCALL_RETRYLATER. this tells the caller to try again in a <br>**    little while. normally the calling app will put up a dialog (see <br>**    OleUIBusy dialog) in this situation informing the user of the <br>**    situation. the user then is normally given the option to <br>**    "Switch To..." the busy application, retry, or cancel the <br>**    operation. when the app is ready to continue processing such <br>**    calls, it should call OleApp_RejectInComingCalls(FALSE). in this <br>**    state, SERVERCALL_ISHANDLED is returned by <br>**    IMessageFilter::HandleInComingCall. <br>*/ <br>void OleApp_RejectInComingCalls(LPOLEAPP lpOleApp, BOOL fReject) <br>{ <br>#if defined( _DEBUG ) <br>   if (fReject) <br>      OleDbgOut3("OleApp_RejectInComingCalls(TRUE)\r\n"); <br>   else <br>      OleDbgOut3("OleApp_RejectInComingCalls(FALSE)\r\n"); <br>#endif  // _DEBUG <br> <br>   OleDbgAssert(lpOleApp-&gt;m_lpMsgFilter != NULL); <br>   if (! lpOleApp-&gt;m_lpMsgFilter) <br>      return; <br> <br>   OleStdMsgFilter_SetInComingCallStatus( <br>         lpOleApp-&gt;m_lpMsgFilter, <br>         (fReject ? SERVERCALL_RETRYLATER : SERVERCALL_ISHANDLED) <br>   ); <br>} <br> <br> <br>/* OleApp_DisableBusyDialogs <br>** ------------------------- <br>**    Disable the Busy and NotResponding dialogs. <br>** <br>**    Returns previous enable state so that it can be restored by <br>**    calling OleApp_ReEnableBusyDialogs. <br>*/ <br>void OleApp_DisableBusyDialogs( <br>      LPOLEAPP        lpOleApp, <br>      BOOL FAR*       lpfPrevBusyEnable, <br>      BOOL FAR*       lpfPrevNREnable <br>) <br>{ <br>   if (lpOleApp-&gt;m_lpMsgFilter) { <br>      *lpfPrevNREnable = OleStdMsgFilter_EnableNotRespondingDialog( <br>            lpOleApp-&gt;m_lpMsgFilter, FALSE); <br>      *lpfPrevBusyEnable = OleStdMsgFilter_EnableBusyDialog( <br>            lpOleApp-&gt;m_lpMsgFilter, FALSE); <br>   } <br>} <br> <br> <br>/* OleApp_EnableBusyDialogs <br>** ------------------------ <br>**    Set the enable state of the Busy and NotResponding dialogs. <br>** <br>**    This function is typically used after a call to <br>**    OleApp_DisableBusyDialogs in order to restore the previous enable <br>**    state of the dialogs. <br>*/ <br>void OleApp_EnableBusyDialogs( <br>      LPOLEAPP        lpOleApp, <br>      BOOL            fPrevBusyEnable, <br>      BOOL            fPrevNREnable <br>) <br>{ <br>   if (lpOleApp-&gt;m_lpMsgFilter) { <br>      OleStdMsgFilter_EnableNotRespondingDialog( <br>            lpOleApp-&gt;m_lpMsgFilter, fPrevNREnable); <br>      OleStdMsgFilter_EnableBusyDialog( <br>            lpOleApp-&gt;m_lpMsgFilter, fPrevBusyEnable); <br>   } <br>} <br> <br> <br>/* OleApp_PreModalDialog <br>** --------------------- <br>**    Keep track that a modal dialog is about to be brought up. <br>** <br>**    while a modal dialog is up we need to take special actions: <br>**    1. we do NOT want to initialize our tool bar buttons on <br>**    WM_ACTIVATEAPP. the tool bar is not accessible. <br>**    2. we want to reject new top-level, incoming LRPC calls <br>**       (return SERVERCALL_RETRYLATER from IMessageFilter:: <br>**        HandleInComingCall). <br>**    3. (IN-PLACE SERVER) tell our in-place container to disable <br>**    modeless dialogs by calling IOleInPlaceFrame:: <br>**    EnableModeless(FALSE). <br>**    4. (IN-PLACE CONTAINER) tell our UIActive in-place object to <br>**    disable modeless dialogs by calling IOleInPlaceActiveObject:: <br>**    EnableModeless(FALSE). <br>*/ <br>void OleApp_PreModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpOleDoc) <br>{ <br>   if (lpOleApp-&gt;m_cModalDlgActive == 0) { <br>      // top-level modal dialog is being brought up <br> <br>#if defined( USE_FRAMETOOLS ) <br>      LPFRAMETOOLS lptb; <br> <br>      if (lpOleDoc) <br>         lptb = ((LPOUTLINEDOC)lpOleDoc)-&gt;m_lpFrameTools; <br>      else <br>         lptb = OutlineApp_GetFrameTools((LPOUTLINEAPP)lpOleApp); <br>      if (lptb) <br>         FrameTools_EnableWindow(lptb, FALSE); <br>#endif  // USE_FRAMETOOLS <br> <br>      OleApp_RejectInComingCalls(lpOleApp, TRUE); <br> <br>#if defined( INPLACE_SVR ) <br>      { <br>         LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOleDoc; <br> <br>         /* if the document bringing up the modal dialog is <br>         **    currently a UIActive in-place object, then tell the <br>         **    top-level in-place frame to disable its modeless <br>         **    dialogs. <br>         */ <br>         if (lpServerDoc &amp;&amp; lpServerDoc-&gt;m_fUIActive &amp;&amp; <br>               lpServerDoc-&gt;m_lpIPData &amp;&amp; <br>               lpServerDoc-&gt;m_lpIPData-&gt;lpFrame) { <br>            OLEDBG_BEGIN2("IOleInPlaceFrame::EnableModless(FALSE) called\r\n"); <br>            lpServerDoc-&gt;m_lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;EnableModeless( <br>                  lpServerDoc-&gt;m_lpIPData-&gt;lpFrame, FALSE); <br>            OLEDBG_END2 <br>         } <br>      } <br>#endif  // INPLACE_SVR <br>#if defined( INPLACE_CNTR ) <br>      { <br>         LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp; <br> <br>         /* if the document bringing up the modal dialog is an <br>         **    in-place container that has a UIActive object, then <br>         **    tell the UIActive object to disable its modeless <br>         **    dialogs. <br>         */ <br>         if (lpContainerApp-&gt;m_lpIPActiveObj) { <br>            OLEDBG_BEGIN2("IOleInPlaceActiveObject::EnableModless(FALSE) called\r\n"); <br>            lpContainerApp-&gt;m_lpIPActiveObj-&gt;lpVtbl-&gt;EnableModeless( <br>                  lpContainerApp-&gt;m_lpIPActiveObj, FALSE); <br>            OLEDBG_END2 <br>         } <br>      } <br>#endif  // INPLACE_CNTR <br>   } <br> <br>   lpOleApp-&gt;m_cModalDlgActive++; <br>} <br> <br> <br>/* OleApp_PostModalDialog <br>** ---------------------- <br>**    Keep track that a modal dialog is being brought down. this call <br>**    balances the OleApp_PreModalDialog call. <br>*/ <br>void OleApp_PostModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpOleDoc) <br>{ <br>   lpOleApp-&gt;m_cModalDlgActive--; <br> <br>   if (lpOleApp-&gt;m_cModalDlgActive == 0) { <br>      // last modal dialog is being brought down <br> <br>#if defined( USE_FRAMETOOLS ) <br>      LPFRAMETOOLS lptb; <br> <br>      if (lpOleDoc) <br>         lptb = ((LPOUTLINEDOC)lpOleDoc)-&gt;m_lpFrameTools; <br>      else <br>         lptb = OutlineApp_GetFrameTools((LPOUTLINEAPP)lpOleApp); <br>      if (lptb) { <br>         FrameTools_EnableWindow(lptb, TRUE); <br>         FrameTools_UpdateButtons(lptb, (LPOUTLINEDOC)lpOleDoc); <br>      } <br>#endif  // USE_FRAMETOOLS <br> <br>      OleApp_RejectInComingCalls(lpOleApp, FALSE); <br> <br>#if defined( INPLACE_SVR ) <br>      { <br>         LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOleDoc; <br> <br>         /* if the document bringing down the modal dialog is <br>         **    currently a UIActive in-place object, then tell the <br>         **    top-level in-place frame it can re-enable its <br>         **    modeless dialogs. <br>         */ <br>         if (lpServerDoc &amp;&amp; lpServerDoc-&gt;m_fUIActive &amp;&amp; <br>               lpServerDoc-&gt;m_lpIPData &amp;&amp; <br>               lpServerDoc-&gt;m_lpIPData-&gt;lpFrame) { <br>            OLEDBG_BEGIN2("IOleInPlaceFrame::EnableModless(TRUE) called\r\n"); <br>            lpServerDoc-&gt;m_lpIPData-&gt;lpFrame-&gt;lpVtbl-&gt;EnableModeless( <br>                  lpServerDoc-&gt;m_lpIPData-&gt;lpFrame, TRUE); <br>            OLEDBG_END2 <br>         } <br>      } <br>#endif  // INPLACE_SVR <br>#if defined( INPLACE_CNTR ) <br>      { <br>         LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp; <br> <br>         /* if the document bringing down the modal dialog is an <br>         **    in-place container that has a UIActive object, then <br>         **    tell the UIActive object it can re-enable its <br>         **    modeless dialogs. <br>         */ <br>         if (lpContainerApp-&gt;m_lpIPActiveObj) { <br>            OLEDBG_BEGIN2("IOleInPlaceActiveObject::EnableModless(TRUE) called\r\n"); <br>            lpContainerApp-&gt;m_lpIPActiveObj-&gt;lpVtbl-&gt;EnableModeless( <br>                  lpContainerApp-&gt;m_lpIPActiveObj, TRUE); <br>            OLEDBG_END2 <br>         } <br>      } <br>#endif  // INPLACE_CNTR <br>   } <br>} <br> <br> <br>/* OleApp_InitVtbls <br> * ---------------- <br> * <br> * initialize the methods in all of the interface Vtbl's <br> * <br> * NOTE: we only need one copy of each Vtbl. When an object which <br> *      exposes an interface is instantiated, its lpVtbl is intialized <br> *      to point to the single copy of the Vtbl. <br> * <br> */ <br>BOOL OleApp_InitVtbls (LPOLEAPP lpOleApp) <br>{ <br>   BOOL fStatus; <br> <br>   // OleApp::IUnknown method table <br>   OleStdInitVtbl(&amp;g_OleApp_UnknownVtbl, sizeof(IUnknownVtbl)); <br>   g_OleApp_UnknownVtbl.QueryInterface = OleApp_Unk_QueryInterface; <br>   g_OleApp_UnknownVtbl.AddRef         = OleApp_Unk_AddRef; <br>   g_OleApp_UnknownVtbl.Release        = OleApp_Unk_Release; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleApp_UnknownVtbl, <br>         sizeof(IUnknownVtbl), <br>         OLESTR("IUnknown") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // OleDoc::IUnknown method table <br>   OleStdInitVtbl(&amp;g_OleDoc_UnknownVtbl, sizeof(IUnknownVtbl)); <br>   g_OleDoc_UnknownVtbl.QueryInterface = OleDoc_Unk_QueryInterface; <br>   g_OleDoc_UnknownVtbl.AddRef         = OleDoc_Unk_AddRef; <br>   g_OleDoc_UnknownVtbl.Release        = OleDoc_Unk_Release; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_UnknownVtbl, <br>         sizeof(IUnknownVtbl), <br>         OLESTR("IUnknown") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // OleDoc::IPersistFile method table <br>   OleStdInitVtbl(&amp;g_OleDoc_PersistFileVtbl, sizeof(IPersistFileVtbl)); <br>   g_OleDoc_PersistFileVtbl.QueryInterface = OleDoc_PFile_QueryInterface; <br>   g_OleDoc_PersistFileVtbl.AddRef         = OleDoc_PFile_AddRef; <br>   g_OleDoc_PersistFileVtbl.Release        = OleDoc_PFile_Release; <br>   g_OleDoc_PersistFileVtbl.GetClassID     = OleDoc_PFile_GetClassID; <br>   g_OleDoc_PersistFileVtbl.IsDirty        = OleDoc_PFile_IsDirty; <br>   g_OleDoc_PersistFileVtbl.Load           = OleDoc_PFile_Load; <br>   g_OleDoc_PersistFileVtbl.Save           = OleDoc_PFile_Save; <br>   g_OleDoc_PersistFileVtbl.SaveCompleted  = OleDoc_PFile_SaveCompleted; <br>   g_OleDoc_PersistFileVtbl.GetCurFile     = OleDoc_PFile_GetCurFile; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_PersistFileVtbl, <br>         sizeof(IPersistFileVtbl), <br>         OLESTR("IPersistFile") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // OleDoc::IOleItemContainer method table <br>   OleStdInitVtbl(&amp;g_OleDoc_OleItemContainerVtbl, sizeof(IOleItemContainerVtbl)); <br>   g_OleDoc_OleItemContainerVtbl.QueryInterface = <br>                                 OleDoc_ItemCont_QueryInterface; <br>   g_OleDoc_OleItemContainerVtbl.AddRef    = OleDoc_ItemCont_AddRef; <br>   g_OleDoc_OleItemContainerVtbl.Release   = OleDoc_ItemCont_Release; <br>   g_OleDoc_OleItemContainerVtbl.ParseDisplayName  = <br>                                 OleDoc_ItemCont_ParseDisplayName; <br>   g_OleDoc_OleItemContainerVtbl.EnumObjects= OleDoc_ItemCont_EnumObjects; <br>   g_OleDoc_OleItemContainerVtbl.LockContainer = <br>                                 OleDoc_ItemCont_LockContainer; <br>   g_OleDoc_OleItemContainerVtbl.GetObject = OleDoc_ItemCont_GetObject; <br>   g_OleDoc_OleItemContainerVtbl.GetObjectStorage = <br>                                 OleDoc_ItemCont_GetObjectStorage; <br>   g_OleDoc_OleItemContainerVtbl.IsRunning = OleDoc_ItemCont_IsRunning; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_OleItemContainerVtbl, <br>         sizeof(IOleItemContainerVtbl), <br>         OLESTR("IOleItemContainer") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // OleDoc::IExternalConnection method table <br>   OleStdInitVtbl( <br>         &amp;g_OleDoc_ExternalConnectionVtbl,sizeof(IExternalConnectionVtbl)); <br>   g_OleDoc_ExternalConnectionVtbl.QueryInterface = <br>                                 OleDoc_ExtConn_QueryInterface; <br>   g_OleDoc_ExternalConnectionVtbl.AddRef         = OleDoc_ExtConn_AddRef; <br>   g_OleDoc_ExternalConnectionVtbl.Release        = OleDoc_ExtConn_Release; <br>   g_OleDoc_ExternalConnectionVtbl.AddConnection  = <br>                                 OleDoc_ExtConn_AddConnection; <br>   g_OleDoc_ExternalConnectionVtbl.ReleaseConnection = <br>                                 OleDoc_ExtConn_ReleaseConnection; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_ExternalConnectionVtbl, <br>         sizeof(IExternalConnectionVtbl), <br>         OLESTR("IExternalConnection") <br>   ); <br>   if (! fStatus) return FALSE; <br> <br>   // OleDoc::IDataObject method table <br>   OleStdInitVtbl(&amp;g_OleDoc_DataObjectVtbl, sizeof(IDataObjectVtbl)); <br>   g_OleDoc_DataObjectVtbl.QueryInterface  = OleDoc_DataObj_QueryInterface; <br>   g_OleDoc_DataObjectVtbl.AddRef          = OleDoc_DataObj_AddRef; <br>   g_OleDoc_DataObjectVtbl.Release         = OleDoc_DataObj_Release; <br>   g_OleDoc_DataObjectVtbl.GetData         = OleDoc_DataObj_GetData; <br>   g_OleDoc_DataObjectVtbl.GetDataHere     = OleDoc_DataObj_GetDataHere; <br>   g_OleDoc_DataObjectVtbl.QueryGetData    = OleDoc_DataObj_QueryGetData; <br>   g_OleDoc_DataObjectVtbl.GetCanonicalFormatEtc = <br>                              OleDoc_DataObj_GetCanonicalFormatEtc; <br>   g_OleDoc_DataObjectVtbl.SetData         = OleDoc_DataObj_SetData; <br>   g_OleDoc_DataObjectVtbl.EnumFormatEtc   = OleDoc_DataObj_EnumFormatEtc; <br>   g_OleDoc_DataObjectVtbl.DAdvise          = OleDoc_DataObj_DAdvise; <br>   g_OleDoc_DataObjectVtbl.DUnadvise        = OleDoc_DataObj_DUnadvise; <br>   g_OleDoc_DataObjectVtbl.EnumDAdvise      = OleDoc_DataObj_EnumDAdvise; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_DataObjectVtbl, <br>         sizeof(IDataObjectVtbl), <br>         OLESTR("IDataObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#if defined( USE_DRAGDROP ) <br> <br>   // OleDoc::IDropTarget method table <br>   OleStdInitVtbl(&amp;g_OleDoc_DropTargetVtbl, sizeof(IDropTargetVtbl)); <br>   g_OleDoc_DropTargetVtbl.QueryInterface= OleDoc_DropTarget_QueryInterface; <br>   g_OleDoc_DropTargetVtbl.AddRef      = OleDoc_DropTarget_AddRef; <br>   g_OleDoc_DropTargetVtbl.Release     = OleDoc_DropTarget_Release; <br> <br>   g_OleDoc_DropTargetVtbl.DragEnter   = OleDoc_DropTarget_DragEnter; <br>   g_OleDoc_DropTargetVtbl.DragOver    = OleDoc_DropTarget_DragOver; <br>   g_OleDoc_DropTargetVtbl.DragLeave   = OleDoc_DropTarget_DragLeave; <br>   g_OleDoc_DropTargetVtbl.Drop        = OleDoc_DropTarget_Drop; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_DropTargetVtbl, <br>         sizeof(IDropTargetVtbl), <br>         OLESTR("IDropTarget") <br>   ); <br>   if (! fStatus) <br>      return FALSE; <br> <br>   // OleDoc::IDropSource method table <br>   OleStdInitVtbl(&amp;g_OleDoc_DropSourceVtbl, sizeof(IDropSourceVtbl)); <br>   g_OleDoc_DropSourceVtbl.QueryInterface  = <br>                              OleDoc_DropSource_QueryInterface; <br>   g_OleDoc_DropSourceVtbl.AddRef          = OleDoc_DropSource_AddRef; <br>   g_OleDoc_DropSourceVtbl.Release         = OleDoc_DropSource_Release; <br> <br>   g_OleDoc_DropSourceVtbl.QueryContinueDrag = <br>                              OleDoc_DropSource_QueryContinueDrag; <br>   g_OleDoc_DropSourceVtbl.GiveFeedback    = OleDoc_DropSource_GiveFeedback; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_OleDoc_DropSourceVtbl, <br>         sizeof(IDropSourceVtbl), <br>         OLESTR("IDropSource") <br>   ); <br>   if (! fStatus) return FALSE; <br>#endif  // USE_DRAGDROP <br> <br>#if defined( OLE_SERVER ) <br> <br>   // Initialize the server specific interface method tables. <br>   if (! ServerApp_InitVtbls((LPSERVERAPP)lpOleApp)) <br>      return FALSE; <br>#endif <br>#if defined( OLE_CNTR ) <br> <br>   // Initialize the container specific interface method tables. <br>   if (! ContainerApp_InitVtbls((LPCONTAINERAPP)lpOleApp)) <br>      return FALSE; <br>#endif <br>   return TRUE; <br>}; <br> <br> <br> <br>/* OleApp_InitMenu <br> * --------------- <br> * <br> *      Enable or Disable menu items depending on the state of <br> * the appliation. <br> * The OLE versions of the Outline sample app add a PasteSpecial command. <br> * Also, the container version add InsertObject and ObjectVerb menu items. <br> */ <br>void OleApp_InitMenu( <br>      LPOLEAPP                lpOleApp, <br>      LPOLEDOC                lpOleDoc, <br>      HMENU                   hMenu <br>) <br>{ <br>   BOOL bMsgFilterInstalled = FALSE; <br>   BOOL bRejecting = FALSE; <br> <br>   if (!lpOleApp || !hMenu) <br>      return; <br> <br>   OLEDBG_BEGIN3("OleApp_InitMenu\r\n") <br> <br>   /* <br>   ** Enable/disable menu items for Message Filter <br>   */ <br>   bMsgFilterInstalled = (lpOleApp-&gt;m_lpMsgFilter != NULL); <br>   bRejecting = bMsgFilterInstalled &amp;&amp; <br>      OleStdMsgFilter_GetInComingCallStatus(lpOleApp-&gt;m_lpMsgFilter) != SERVERCALL_ISHANDLED; <br> <br>   CheckMenuItem(hMenu, <br>      IDM_D_INSTALLMSGFILTER, <br>      bMsgFilterInstalled ? MF_CHECKED : MF_UNCHECKED); <br> <br>   EnableMenuItem(hMenu, <br>      IDM_D_REJECTINCOMING, <br>      bMsgFilterInstalled ? MF_ENABLED : MF_GRAYED); <br> <br>   CheckMenuItem(hMenu, <br>      IDM_D_REJECTINCOMING, <br>      bRejecting ? MF_CHECKED : MF_UNCHECKED); <br> <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br>      BOOL fShowObject; <br> <br>      fShowObject = ContainerDoc_GetShowObjectFlag(lpContainerDoc); <br>      CheckMenuItem( <br>            hMenu, <br>            IDM_O_SHOWOBJECT, <br>            (fShowObject ? MF_CHECKED : MF_UNCHECKED) <br>      ); <br> <br>#if defined( INPLACE_CNTR ) &amp;&amp; defined( _DEBUG ) <br>      CheckMenuItem( <br>            hMenu, <br>            IDM_D_INSIDEOUT, <br>            g_fInsideOutContainer ? MF_CHECKED:MF_UNCHECKED); <br>#endif  // INPLACE_CNTR &amp;&amp; _DEBUG <br> <br>   } <br>#endif  // OLE_CNTR <br> <br>   OLEDBG_END3 <br>} <br> <br> <br> <br>/* OleApp_UpdateEditMenu <br> * --------------------- <br> * <br> *  Purpose: <br> *      Update the Edit menuitems of the App according to the state of <br> *      OutlineDoc <br> * <br> *  Parameter: <br> *      lpOutlineDoc        pointer to the document <br> *      hMenuEdit           edit menu handle <br> */ <br>void OleApp_UpdateEditMenu( <br>      LPOLEAPP                lpOleApp, <br>      LPOUTLINEDOC            lpOutlineDoc, <br>      HMENU                   hMenuEdit <br>) <br>{ <br>   int             nFmtEtc; <br>   UINT            uEnablePaste = MF_GRAYED; <br>   UINT            uEnablePasteLink = MF_GRAYED; <br>   LPDATAOBJECT    lpClipboardDataObj; <br>   LPOLEDOC        lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br>   HRESULT         hrErr; <br>   BOOL            fPrevEnable1; <br>   BOOL            fPrevEnable2; <br> <br>   if (!lpOleApp || !lpOutlineDoc || !hMenuEdit) <br>      return; <br> <br>   if (!OleDoc_GetUpdateEditMenuFlag(lpOleDoc)) <br>      /* NOTE: if the flag is not set, we don't have to update <br>      **    the edit menu again. This blocks repetitive updating when <br>      **    the user move the mouse across Edit menu while holding <br>      **    down the button <br>      */ <br>      return; <br> <br>   OLEDBG_BEGIN3("OleApp_InitEditMenu\r\n") <br> <br>   /* NOTE: we do not want to ever give the busy dialog when we <br>   **    are trying to put up our menus. eg. even if the source of <br>   **    data on the clipboard is busy, we do not want put up the busy <br>   **    dialog. thus we will disable the dialog and at the end <br>   **    re-enable it. <br>   */ <br>   OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>   // check if there is data on the clipboard that we can paste/paste link <br> <br>   OLEDBG_BEGIN2("OleGetClipboard called\r\n") <br>   hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&amp;lpClipboardDataObj); <br>   OLEDBG_END2 <br> <br>   if (hrErr == NOERROR) { <br>      nFmtEtc = OleStdGetPriorityClipboardFormat( <br>            lpClipboardDataObj, <br>            lpOleApp-&gt;m_arrPasteEntries, <br>            lpOleApp-&gt;m_nPasteEntries <br>      ); <br> <br>      if (nFmtEtc &gt;= 0) <br>         uEnablePaste = MF_ENABLED;  // there IS a format we like <br> <br>      OLEDBG_BEGIN2("OleQueryLinkFromData called\r\n") <br>      hrErr = OleQueryLinkFromData(lpClipboardDataObj); <br>      OLEDBG_END2 <br> <br>      if(hrErr == NOERROR) <br>         uEnablePasteLink = MF_ENABLED; <br> <br>      OleStdRelease((LPUNKNOWN)lpClipboardDataObj); <br>   } <br> <br>   EnableMenuItem(hMenuEdit, IDM_E_PASTE, uEnablePaste); <br>   EnableMenuItem(hMenuEdit, IDM_E_PASTESPECIAL, uEnablePaste); <br> <br> <br>#if defined( OLE_CNTR ) <br>   if (ContainerDoc_GetNextLink((LPCONTAINERDOC)lpOutlineDoc, NULL)) <br>      EnableMenuItem(hMenuEdit, IDM_E_EDITLINKS, MF_ENABLED); <br>   else <br>      EnableMenuItem(hMenuEdit, IDM_E_EDITLINKS, MF_GRAYED); <br> <br> <br>   { <br>      LPCONTAINERAPP  lpContainerApp = (LPCONTAINERAPP)lpOleApp; <br>      HMENU           hMenuVerb = NULL; <br>      LPOLEOBJECT     lpOleObj = NULL; <br>      LPCONTAINERLINE lpContainerLine = NULL; <br>      BOOL            fSelIsOleObject; <br>      char            szAnsiString[256]; <br> <br>      EnableMenuItem(hMenuEdit, IDM_E_PASTELINK, uEnablePasteLink); <br> <br>      /* check if selection is a single line that contains an OleObject */ <br> <br>      fSelIsOleObject = ContainerDoc_IsSelAnOleObject( <br>            (LPCONTAINERDOC)lpOutlineDoc, <br>            &amp;IID_IOleObject, <br>            (LPUNKNOWN FAR*)&amp;lpOleObj, <br>            NULL,    /* we don't need the line index */ <br>            (LPCONTAINERLINE FAR*)&amp;lpContainerLine <br>      ); <br> <br>      if (hMenuEdit != NULL) { <br>         if (lpContainerLine) <br>         { <br>             W2A(lpContainerLine-&gt;m_lpszShortType, szAnsiString, 256); <br>         } <br>         /* If the current line is an ContainerLine, add the object <br>         **    verb sub menu to the Edit menu. if the line is not an <br>         **    ContainerLine, (lpOleObj==NULL) then disable the <br>         **    Edit.Object command. this helper API takes care of <br>         **    building the verb menu as appropriate. <br>         */ <br>         OleUIAddVerbMenu( <br>               (LPOLEOBJECT)lpOleObj, <br>               (lpContainerLine ? szAnsiString:NULL), <br>               hMenuEdit, <br>               POS_OBJECT, <br>               IDM_E_OBJECTVERBMIN, <br>               0,                     // no uIDVerbMax enforced <br>               TRUE,                  // Add Convert menu item <br>               IDM_E_CONVERTVERB,     // ID for Convert menu item <br>               (HMENU FAR*) &amp;hMenuVerb <br>         ); <br> <br>#if defined( USE_STATUSBAR_LATER ) <br>         /* setup status messages for the object verb menu */ <br>         if (hMenuVerb) { <br>            // REVIEW: this string should come from a string resource. <br>            // REVIEW: this doesn't work for dynamically created menus <br>            AssignPopupMessage( <br>                  hMenuVerb, <br>                  "Open, edit or interact with an object" <br>            ); <br>         } <br>#endif  // USE_STATUSBAR_LATER <br>      } <br> <br>      if (lpOleObj) <br>         OleStdRelease((LPUNKNOWN)lpOleObj); <br>   } <br> <br>#endif  // OLE_CNTR <br> <br>   // re-enable the Busy/NotResponding dialogs <br>   OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br> <br>   OleDoc_SetUpdateEditMenuFlag(lpOleDoc, FALSE); <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_RegisterClassFactory <br> * --------------------------- <br> * <br> * Register our app's ClassFactory with OLE. <br> * <br> */ <br>BOOL OleApp_RegisterClassFactory(LPOLEAPP lpOleApp) <br>{ <br>   HRESULT hrErr; <br> <br>   if (lpOleApp-&gt;m_lpClassFactory) <br>      return TRUE;    // already registered <br> <br>   OLEDBG_BEGIN3("OleApp_RegisterClassFactory\r\n") <br> <br>   /****************************************************************** <br>   ** An SDI app must register its ClassFactory if it is launched <br>   **    for embedding (/Embedding command line option specified). <br>   ** An MDI app must register its ClassFactory in all cases, <br>   ******************************************************************/ <br> <br>   lpOleApp-&gt;m_lpClassFactory = AppClassFactory_Create(); <br>   if (! lpOleApp-&gt;m_lpClassFactory) { <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgCreateCF); <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("CoRegisterClassObject called\r\n") <br>   hrErr = CoRegisterClassObject( <br>            &amp;CLSID_APP, <br>            (LPUNKNOWN)lpOleApp-&gt;m_lpClassFactory, <br>            CLSCTX_LOCAL_SERVER, <br>            REGCLS_SINGLEUSE, <br>            &amp;lpOleApp-&gt;m_dwRegClassFac <br>   ); <br>   OLEDBG_END2 <br> <br>   if(hrErr != NOERROR) { <br>      OleDbgOutHResult("CoRegisterClassObject returned", hrErr); <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgRegCF); <br>      goto error; <br>   } <br> <br>   OLEDBG_END3 <br>   return TRUE; <br> <br>error: <br> <br>   if (lpOleApp-&gt;m_lpClassFactory) { <br>      OleStdRelease((LPUNKNOWN)lpOleApp-&gt;m_lpClassFactory); <br>      lpOleApp-&gt;m_lpClassFactory = NULL; <br>   } <br>   OLEDBG_END3 <br>   return FALSE; <br>} <br> <br> <br>/* OleApp_RevokeClassFactory <br> * ------------------------- <br> * <br> * Revoke our app's ClassFactory. <br> * <br> */ <br>void OleApp_RevokeClassFactory(LPOLEAPP lpOleApp) <br>{ <br>   HRESULT hrErr; <br> <br>   if (lpOleApp-&gt;m_lpClassFactory) { <br> <br>      OLEDBG_BEGIN2("CoRevokeClassObject called\r\n") <br>      hrErr = CoRevokeClassObject(lpOleApp-&gt;m_dwRegClassFac); <br>      OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("CoRevokeClassObject returned", hrErr); <br>      } <br>#endif <br> <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpOleApp-&gt;m_lpClassFactory, <br>            OLESTR("ClassFactory NOT released properly!") <br>      ); <br>      lpOleApp-&gt;m_lpClassFactory = NULL; <br>   } <br>} <br> <br> <br>#if defined( USE_MSGFILTER ) <br> <br>/* OleApp_RegisterMessageFilter <br> * ---------------------------- <br> *  Register our IMessageFilter*. the message filter is used to handle <br> *  concurrency. we will use a standard implementation of IMessageFilter <br> *  that is included as part of the OLE2UI library. <br> */ <br>BOOL OleApp_RegisterMessageFilter(LPOLEAPP lpOleApp) <br>{ <br>   HRESULT hrErr; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br> <br>   if (lpOleApp-&gt;m_lpMsgFilter == NULL) { <br>      // Register our message filter. <br>      lpOleApp-&gt;m_lpfnMsgPending = (MSGPENDINGPROC)MessagePendingProc; <br>      lpOleApp-&gt;m_lpMsgFilter = OleStdMsgFilter_Create( <br>            g_lpApp-&gt;m_hWndApp, <br>            /*(LPOLESTR)*/APPNAME, <br>            lpOleApp-&gt;m_lpfnMsgPending, <br>            NULL    /* Busy dialog callback hook function */ <br>      ); <br> <br>      OLEDBG_BEGIN2("CoRegisterMessageFilter called\r\n") <br>      hrErr = CoRegisterMessageFilter( <br>               lpOleApp-&gt;m_lpMsgFilter, <br>               NULL    /* don't need previous message filter */ <br>      ); <br>      OLEDBG_END2 <br> <br>      if(hrErr != NOERROR) { <br>         OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgRegMF); <br>         return FALSE; <br>      } <br>   } <br>   return TRUE; <br>} <br> <br> <br>/* OleApp_RevokeMessageFilter <br> * -------------------------- <br> *  Revoke our IMessageFilter*. the message filter is used to handle <br> *  concurrency. we will use a standard implementation of IMessageFilter <br> *  that is included as part of the OLE2UI library. <br> */ <br>void OleApp_RevokeMessageFilter(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>   if (lpOleApp-&gt;m_lpMsgFilter != NULL) { <br>      // Revoke our message filter <br>      OLEDBG_BEGIN2("CoRegisterMessageFilter(NULL) called\r\n") <br>      CoRegisterMessageFilter(NULL, NULL); <br>      OLEDBG_END2 <br> <br>      if (lpOleApp-&gt;m_lpfnMsgPending) { <br>         lpOleApp-&gt;m_lpfnMsgPending = NULL; <br>      } <br> <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpOleApp-&gt;m_lpMsgFilter, <br>            OLESTR("Release MessageFilter FAILED!") <br>      ); <br>      lpOleApp-&gt;m_lpMsgFilter = NULL; <br>   } <br>} <br> <br> <br>/* MessagePendingProc <br> * ------------------ <br> * <br> * Callback function for the IMessageFilter::MessagePending procedure.  This <br> * function is called when a message is received by our application while <br> * we are waiting for an OLE call to complete.  We are essentially <br> * blocked at this point, waiting for a response from the other OLE application. <br> * We should not process any messages which might cause another OLE call <br> * to become blocked, or any other call which might cause re-entrancy problems. <br> * <br> * For this application, only process WM_PAINT messages.  A more sophisticated <br> * application might allow certain menu messages and menu items to be processed <br> * also. <br> * <br> * RETURNS: TRUE if we processed the message, FALSE if we did not. <br> */ <br> <br>BOOL FAR PASCAL EXPORT MessagePendingProc(MSG FAR *lpMsg) <br>{ <br>   // Our application is only handling WM_PAINT messages when we are blocked <br>   switch (lpMsg-&gt;message) { <br>      case WM_PAINT: <br>         OleDbgOut2("WM_PAINT dispatched while blocked\r\n"); <br> <br>         DispatchMessage(lpMsg); <br>         break; <br>   } <br> <br>   return FALSE;   // return PENDINGMSG_WAITDEFPROCESS from MessagePending <br>} <br>#endif  // USE_MSGFILTER <br> <br> <br>/* OleApp_FlushClipboard <br> * --------------------- </code></pre>
<p>
</p>
<pre><code>* <br> *  Force the Windows clipboard to release our clipboard DataObject. <br> */ <br>void OleApp_FlushClipboard(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   LPOLEDOC lpClipboardDoc = (LPOLEDOC)lpOutlineApp-&gt;m_lpClipboardDoc; <br>   OLEDBG_BEGIN3("OleApp_FlushClipboard\r\n") <br> <br>   /* NOTE: if for some reason our clipboard data transfer <br>   **    document is still held on to by an external client, we want <br>   **    to forceably break all external connections. <br>   */ <br>   OLEDBG_BEGIN2("CoDisconnectObject called\r\n") <br>   CoDisconnectObject((LPUNKNOWN)&amp;lpClipboardDoc-&gt;m_Unknown, 0); <br>   OLEDBG_END2 <br> <br>   OLEDBG_BEGIN2("OleFlushClipboard called\r\n") <br>   OleFlushClipboard(); <br>   OLEDBG_END2 <br> <br>   lpOutlineApp-&gt;m_lpClipboardDoc = NULL; <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* OleApp_NewCommand <br> * ----------------- <br> * <br> *  Start a new untitled document (File.New command). <br> */ <br>void OleApp_NewCommand(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   LPOUTLINEDOC lpOutlineDoc = lpOutlineApp-&gt;m_lpDoc; <br> <br>   if (! OutlineDoc_Close(lpOutlineDoc, OLECLOSE_PROMPTSAVE)) <br>      return; <br> <br>   OleDbgAssertSz(lpOutlineApp-&gt;m_lpDoc==NULL,"Closed doc NOT properly destroyed"); <br>   lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>   if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>   /* NOTE: initially the Doc object is created with a 0 ref <br>   **    count. in order to have a stable Doc object during the <br>   **    process of initializing the new Doc instance, <br>   **    we intially AddRef the Doc ref cnt and later <br>   **    Release it. This initial AddRef is artificial; it is simply <br>   **    done to guarantee that a harmless QueryInterface followed by <br>   **    a Release does not inadvertantly force our object to destroy <br>   **    itself prematurely. <br>   */ <br>   OleDoc_AddRef((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>   // set the doc to an (Untitled) doc. <br>   if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>      goto error; <br> <br>   // position and size the new doc window <br>   OutlineApp_ResizeWindows(lpOutlineApp); <br>   OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); // calls OleDoc_Lock <br> <br>   OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc);  // rel artificial AddRef <br> <br>   return; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Could not create new document")); <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>      // releasing the artificial AddRef above will destroy the document <br>      OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   } <br> <br>   return; <br>} <br> <br> <br>/* OleApp_OpenCommand <br> * ------------------ <br> * <br> *  Load a document from file (File.Open command). <br> */ <br>void OleApp_OpenCommand(LPOLEAPP lpOleApp) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp; <br>   LPOUTLINEDOC lpOutlineDoc = lpOutlineApp-&gt;m_lpDoc; <br>   OPENFILENAME ofn; <br>   char szFilter[]=APPFILENAMEFILTER; <br>   char szFileName[256]; <br>   UINT i; <br>   DWORD dwSaveOption = OLECLOSE_PROMPTSAVE; <br>   BOOL fStatus = TRUE; <br>   OLECHAR szUniStr[256]; <br> <br>   if (! OutlineDoc_CheckSaveChanges(lpOutlineDoc, &amp;dwSaveOption)) <br>      return;           // abort opening new doc <br> <br>   for(i=0; szFilter[i]; i++) <br>      if(szFilter[i]=='|') szFilter[i]='\0'; <br> <br>   _fmemset((LPOPENFILENAME)&amp;ofn,0,sizeof(OPENFILENAME)); <br> <br>   szFileName[0]='\0'; <br> <br>   ofn.lStructSize=sizeof(OPENFILENAME); <br>   ofn.hwndOwner=lpOutlineApp-&gt;m_hWndApp; <br>   ofn.lpstrFilter=(LPSTR)szFilter; <br>   ofn.lpstrFile=(LPSTR)szFileName; <br>   ofn.nMaxFile=256; <br>   ofn.Flags=OFN_FILEMUSTEXIST | OFN_HIDEREADONLY; <br>   ofn.lpstrDefExt=DEFEXTENSION; <br> <br>   OleApp_PreModalDialog(lpOleApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>   fStatus = GetOpenFileName((LPOPENFILENAME)&amp;ofn); <br> <br>   OleApp_PostModalDialog(lpOleApp, (LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>   if(! fStatus) <br>      return;         // user canceled file open dialog <br> <br>   OutlineDoc_Close(lpOutlineDoc, OLECLOSE_NOSAVE); <br>   OleDbgAssertSz(lpOutlineApp-&gt;m_lpDoc==NULL,"Closed doc NOT properly destroyed"); <br> <br>   lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>   if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br> <br>   /* NOTE: initially the Doc object is created with a 0 ref <br>   **    count. in order to have a stable Doc object during the <br>   **    process of initializing the new Doc instance, <br>   **    we intially AddRef the Doc ref cnt and later <br>   **    Release it. This initial AddRef is artificial; it is simply <br>   **    done to guarantee that a harmless QueryInterface followed by <br>   **    a Release does not inadvertantly force our object to destroy <br>   **    itself prematurely. <br>   */ <br>   OleDoc_AddRef((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>   A2W (szFileName, szUniStr, 256); <br>   fStatus=OutlineDoc_LoadFromFile(lpOutlineApp-&gt;m_lpDoc, /*(LPOLESTR)*/szUniStr); <br> <br>   if (! fStatus) { <br>      // loading the doc failed; create an untitled instead <br> <br>      // releasing the artificial AddRef above will destroy the document <br>      OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>      lpOutlineApp-&gt;m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE); <br>      if (! lpOutlineApp-&gt;m_lpDoc) goto error; <br>      OleDoc_AddRef((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br> <br>      if (! OutlineDoc_InitNewFile(lpOutlineApp-&gt;m_lpDoc)) <br>         goto error; <br>   } <br> <br>   // position and size the new doc window <br>   OutlineApp_ResizeWindows(lpOutlineApp); <br>   OutlineDoc_ShowWindow(lpOutlineApp-&gt;m_lpDoc); <br> <br>#if defined( OLE_CNTR ) <br>   UpdateWindow(lpOutlineApp-&gt;m_hWndApp); <br>   ContainerDoc_UpdateLinks((LPCONTAINERDOC)lpOutlineApp-&gt;m_lpDoc); <br>#endif <br> <br>   OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc);  // rel artificial AddRef <br> <br>   return; <br> <br>error: <br>   // REVIEW: should load string from string resource <br>   OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Could not create new document")); <br> <br>   if (lpOutlineApp-&gt;m_lpDoc) { <br>      // releasing the artificial AddRef above will destroy the document <br>      OleDoc_Release((LPOLEDOC)lpOutlineApp-&gt;m_lpDoc); <br>      lpOutlineApp-&gt;m_lpDoc = NULL; <br>   } <br> <br>   return; <br>} <br> <br> <br> <br>#if defined( OLE_CNTR ) <br> <br>/* NOTE: forward the WM_QUERYNEWPALETTE message (via <br>**    SendMessage) to UIActive in-place object if there is one. <br>**    this gives the UIActive object the opportunity to select <br>**    and realize its color palette as the FOREGROUND palette. <br>**    this is optional for in-place containers. if a container <br>**    prefers to force its color palette as the foreground <br>**    palette then it should NOT forward the this message. or <br>**    the container can give the UIActive object priority; if <br>**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE <br>**    message (ie. it did not realize its own palette), then <br>**    the container can realize its palette. <br>**    (see ContainerDoc_ForwardPaletteChangedMsg for more info) <br>** <br>**    (It is a good idea for containers to use the standard <br>**    palette even if they do not use colors themselves. this <br>**    will allow embedded object to get a good distribution of <br>**    colors when they are being drawn by the container) <br>** <br>*/ <br> <br>LRESULT OleApp_QueryNewPalette(LPOLEAPP lpOleApp) <br>{ <br>#if defined( INPLACE_CNTR ) <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp; <br> <br>   if (lpContainerApp &amp;&amp; lpContainerApp-&gt;m_hWndUIActiveObj) { <br>      if (SendMessage(lpContainerApp-&gt;m_hWndUIActiveObj, WM_QUERYNEWPALETTE, <br>            (WPARAM)0, (LPARAM)0)) { <br>         /* Object selected its palette as foreground palette */ <br>         return (LRESULT)1; <br>      } <br>   } <br>#endif  // INPLACE_CNTR <br> <br> <br>   return wSelectPalette(((LPOUTLINEAPP)lpOleApp)-&gt;m_hWndApp, <br>      lpOleApp-&gt;m_hStdPal, FALSE/*fBackground*/); <br>} <br> <br>#endif // OLE_CNTR <br> <br> <br> <br>/* This is just a helper routine */ <br> <br>LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground) <br>{ <br>   HDC hdc; <br>   HPALETTE hOldPal; <br>   UINT iPalChg = 0; <br> <br>   if (hPal == 0) <br>      return (LRESULT)0; <br> <br>   hdc = GetDC(hWnd); <br>   hOldPal = SelectPalette(hdc, hPal, fBackground); <br>   iPalChg = RealizePalette(hdc); <br>   SelectPalette(hdc, hOldPal, TRUE /*fBackground*/); <br>   ReleaseDC(hWnd, hdc); <br> <br>   if (iPalChg &gt; 0) <br>      InvalidateRect(hWnd, NULL, TRUE); <br> <br>   return (LRESULT)1; <br>} <br> <br> <br> <br> <br>/************************************************************************* <br>** OleApp::IUnknown interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP OleApp_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)-&gt;lpOleApp; <br> <br>   return OleApp_QueryInterface(lpOleApp, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleApp_Unk_AddRef(LPUNKNOWN lpThis) <br>{ <br>   LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)-&gt;lpOleApp; <br> <br>   OleDbgAddRefMethod(lpThis, "IUnknown"); <br> <br>   return OleApp_AddRef(lpOleApp); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleApp_Unk_Release (LPUNKNOWN lpThis) <br>{ <br>   LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)-&gt;lpOleApp; <br> <br>   OleDbgReleaseMethod(lpThis, "IUnknown"); <br> <br>   return OleApp_Release(lpOleApp); <br>} <br> <br> <br> <br> <br>#if defined( OLE_SERVER ) <br> <br>/************************************************************************* <br>** ServerDoc Supprt Functions Used by Server versions <br>*************************************************************************/ <br> <br>/* ServerApp_InitInstance <br> * ---------------------- <br> * <br> * Initialize the app instance by creating the main frame window and <br> * performing app instance specific initializations <br> *  (eg. initializing interface Vtbls). <br> * <br> * RETURNS: TRUE if the memory could be allocated, and the server app <br> *               was properly initialized. <br> *          FALSE otherwise <br> * <br> */ <br> <br>BOOL ServerApp_InitInstance( <br>      LPSERVERAPP             lpServerApp, <br>      HINSTANCE               hInst, <br>      int                     nCmdShow <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br> <br>   /* Setup arrays used by IDataObject::EnumFormatEtc. <br>   ** <br>   ** NOTE: The order that the formats are listed for GetData is very <br>   **    significant. It should be listed in order of highest fidelity <br>   **    formats to least fidelity formats. A common ordering will be: <br>   **                  1. private app formats <br>   **                  2. EmbedSource <br>   **                  3. lower fidelity interchange formats <br>   **                  4. pictures (metafile, dib, etc.) <br>   **                      (graphic-related apps offer pictures 1st!) <br>   **                  5. LinkSource <br>   */ <br> <br>   /* m_arrDocGetFmts array enumerates the formats that a ServerDoc <br>   **    DataTransferDoc object can offer (give) through a <br>   **    IDataObject::GetData call. a ServerDoc DataTransferDoc offers <br>   **    data formats in the following order: <br>   **                  1. CF_OUTLINE <br>   **                  2. CF_EMBEDSOURCE <br>   **                  3. CF_OBJECTDESCRIPTOR <br>   **                  4. CF_TEXT <br>   **                  5. CF_METAFILEPICT <br>   **                  6. CF_LINKSOURCE * <br>   **                  7. CF_LINKSRCDESCRIPTOR * <br>   ** <br>   **    * NOTE: CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR is only <br>   **    offered if the doc is able to give <br>   **    a Moniker which references the data. CF_LINKSOURCE is <br>   **    deliberately listed last in this array of possible formats. <br>   **    if the doc does not have a Moniker then the last element of <br>   **    this array is not used. (see SvrDoc_DataObj_EnumFormatEtc). <br>   ** <br>   **    NOTE: The list of formats that a USER ServerDoc document can <br>   **    offer is a static list and is registered in the registration <br>   **    database for the SVROUTL class. The <br>   **    IDataObject::EnumFormatEtc method returns OLE_S_USEREG in the <br>   **    case the document is a user docuemt (ie. created via <br>   **    File.New, File.Open, InsertObject in a container, or <br>   **    IPersistFile::Load during binding a link source). this tells <br>   **    OLE to enumerate the formats automatically using the data the <br>   **    the REGDB. <br>   */ <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[0].cfFormat   = lpOutlineApp-&gt;m_cfOutline; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].tymed      = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[1].cfFormat   = lpOleApp-&gt;m_cfEmbedSource; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].tymed      = TYMED_ISTORAGE; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[2].cfFormat   = CF_TEXT; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].tymed      = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[3].cfFormat   = CF_METAFILEPICT; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].tymed      = TYMED_MFPICT; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[4].cfFormat   = lpOleApp-&gt;m_cfObjectDescriptor; <br>   lpOleApp-&gt;m_arrDocGetFmts[4].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[4].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[4].tymed      = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[4].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[5].cfFormat   = lpOleApp-&gt;m_cfLinkSource; <br>   lpOleApp-&gt;m_arrDocGetFmts[5].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[5].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[5].tymed      = TYMED_ISTREAM; <br>   lpOleApp-&gt;m_arrDocGetFmts[5].lindex     = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[6].cfFormat   = lpOleApp-&gt;m_cfLinkSrcDescriptor; <br>   lpOleApp-&gt;m_arrDocGetFmts[6].ptd        = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[6].dwAspect   = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[6].tymed      = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[6].lindex     = -1; <br> <br>   lpOleApp-&gt;m_nDocGetFmts = 7; <br> <br>   /* m_arrPasteEntries array enumerates the formats that a ServerDoc <br>   **    object can accept (get) from the clipboard. <br>   **    The formats are listed in priority order. <br>   **    ServerDoc accept data formats in the following order: <br>   **                  1. CF_OUTLINE <br>   **                  2. CF_TEXT <br>   */ <br>   // REVIEW: strings should be loaded from string resource <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.cfFormat =lpOutlineApp-&gt;m_cfOutline; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[0].lpstrFormatName = "Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[0].lpstrResultText = "Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[0].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.cfFormat = CF_TEXT; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[1].lpstrFormatName = "Text"; <br>   lpOleApp-&gt;m_arrPasteEntries[1].lpstrResultText = "text"; <br>   lpOleApp-&gt;m_arrPasteEntries[1].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_nPasteEntries = 2; <br> <br>   /**    m_arrLinkTypes array enumerates the link types that a ServerDoc <br>   **    object can accept from the clipboard. ServerDoc does NOT <br>   **    accept any type of link from the clipboard. ServerDoc can <br>   **    only be the source of a link. it can not contain links. <br>   */ <br> <br>   lpOleApp-&gt;m_nLinkTypes = 0; <br> <br>#if defined( INPLACE_SVR ) <br> <br>   lpServerApp-&gt;m_hAccelBaseApp = NULL; <br>   lpServerApp-&gt;m_hAccelIPSvr = LoadAccelerators( <br>         hInst, <br>         "InPlaceSvrOutlAccel" <br>   ); <br> <br>   lpServerApp-&gt;m_lpIPData = NULL; <br> <br>   lpServerApp-&gt;m_hMenuEdit = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_EDITMENU <br>   ); <br>   lpServerApp-&gt;m_hMenuLine = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_LINEMENU <br>   ); <br>   lpServerApp-&gt;m_hMenuName = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_NAMEMENU <br>   ); <br>   lpServerApp-&gt;m_hMenuOptions = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_OPTIONSMENU <br>   ); <br>   lpServerApp-&gt;m_hMenuDebug = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_DEBUGMENU <br>   ); <br>   lpServerApp-&gt;m_hMenuHelp = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_HELPMENU <br>   ); <br> <br>#endif  // INPLACE_SVR <br> <br>   return TRUE; <br>} <br> <br> <br>/* ServerApp_InitVtbls <br> * ------------------- <br> * <br> * initialize the methods in all of the interface Vtbl's <br> * <br> * NOTE: we only need one copy of each Vtbl. When an object which <br> *      exposes an interface is instantiated, its lpVtbl is intialized <br> *      to point to the single copy of the Vtbl. <br> * <br> */ <br>BOOL ServerApp_InitVtbls (LPSERVERAPP lpServerApp) <br>{ <br>   BOOL fStatus; <br> <br>   // ServerDoc::IOleObject method table <br>   OleStdInitVtbl(&amp;g_SvrDoc_OleObjectVtbl, sizeof(IOleObjectVtbl)); <br>   g_SvrDoc_OleObjectVtbl.QueryInterface   = SvrDoc_OleObj_QueryInterface; <br>   g_SvrDoc_OleObjectVtbl.AddRef           = SvrDoc_OleObj_AddRef; <br>   g_SvrDoc_OleObjectVtbl.Release          = SvrDoc_OleObj_Release; <br>   g_SvrDoc_OleObjectVtbl.SetClientSite    = SvrDoc_OleObj_SetClientSite; <br>   g_SvrDoc_OleObjectVtbl.GetClientSite    = SvrDoc_OleObj_GetClientSite; <br>   g_SvrDoc_OleObjectVtbl.SetHostNames     = SvrDoc_OleObj_SetHostNames; <br>   g_SvrDoc_OleObjectVtbl.Close            = SvrDoc_OleObj_Close; <br>   g_SvrDoc_OleObjectVtbl.SetMoniker       = SvrDoc_OleObj_SetMoniker; <br>   g_SvrDoc_OleObjectVtbl.GetMoniker       = SvrDoc_OleObj_GetMoniker; <br>   g_SvrDoc_OleObjectVtbl.InitFromData     = SvrDoc_OleObj_InitFromData; <br>   g_SvrDoc_OleObjectVtbl.GetClipboardData = SvrDoc_OleObj_GetClipboardData; <br>   g_SvrDoc_OleObjectVtbl.DoVerb           = SvrDoc_OleObj_DoVerb; <br>   g_SvrDoc_OleObjectVtbl.EnumVerbs        = SvrDoc_OleObj_EnumVerbs; <br>   g_SvrDoc_OleObjectVtbl.Update           = SvrDoc_OleObj_Update; <br>   g_SvrDoc_OleObjectVtbl.IsUpToDate       = SvrDoc_OleObj_IsUpToDate; <br>   g_SvrDoc_OleObjectVtbl.GetUserClassID   = SvrDoc_OleObj_GetUserClassID; <br>   g_SvrDoc_OleObjectVtbl.GetUserType      = SvrDoc_OleObj_GetUserType; <br>   g_SvrDoc_OleObjectVtbl.SetExtent        = SvrDoc_OleObj_SetExtent; <br>   g_SvrDoc_OleObjectVtbl.GetExtent        = SvrDoc_OleObj_GetExtent; <br>   g_SvrDoc_OleObjectVtbl.Advise           = SvrDoc_OleObj_Advise; <br>   g_SvrDoc_OleObjectVtbl.Unadvise         = SvrDoc_OleObj_Unadvise; <br>   g_SvrDoc_OleObjectVtbl.EnumAdvise       = SvrDoc_OleObj_EnumAdvise; <br>   g_SvrDoc_OleObjectVtbl.GetMiscStatus    = SvrDoc_OleObj_GetMiscStatus; <br>   g_SvrDoc_OleObjectVtbl.SetColorScheme   = SvrDoc_OleObj_SetColorScheme; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_SvrDoc_OleObjectVtbl, <br>         sizeof(IOleObjectVtbl), <br>         OLESTR("IOleObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // ServerDoc::IPersistStorage method table <br>   OleStdInitVtbl(&amp;g_SvrDoc_PersistStorageVtbl, sizeof(IPersistStorageVtbl)); <br>   g_SvrDoc_PersistStorageVtbl.QueryInterface  = SvrDoc_PStg_QueryInterface; <br>   g_SvrDoc_PersistStorageVtbl.AddRef          = SvrDoc_PStg_AddRef; <br>   g_SvrDoc_PersistStorageVtbl.Release         = SvrDoc_PStg_Release; <br>   g_SvrDoc_PersistStorageVtbl.GetClassID      = SvrDoc_PStg_GetClassID; <br>   g_SvrDoc_PersistStorageVtbl.IsDirty         = SvrDoc_PStg_IsDirty; <br>   g_SvrDoc_PersistStorageVtbl.InitNew         = SvrDoc_PStg_InitNew; <br>   g_SvrDoc_PersistStorageVtbl.Load            = SvrDoc_PStg_Load; <br>   g_SvrDoc_PersistStorageVtbl.Save            = SvrDoc_PStg_Save; <br>   g_SvrDoc_PersistStorageVtbl.SaveCompleted   = SvrDoc_PStg_SaveCompleted; <br>   g_SvrDoc_PersistStorageVtbl.HandsOffStorage = SvrDoc_PStg_HandsOffStorage; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_SvrDoc_PersistStorageVtbl, <br>         sizeof(IPersistStorageVtbl), <br>         OLESTR("IPersistStorage") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#if defined( SVR_TREATAS ) <br>   // ServerDoc::IStdMarshalInfo method table <br>   OleStdInitVtbl( <br>         &amp;g_SvrDoc_StdMarshalInfoVtbl, sizeof(IStdMarshalInfoVtbl)); <br>   g_SvrDoc_StdMarshalInfoVtbl.QueryInterface  = <br>                                 SvrDoc_StdMshl_QueryInterface; <br>   g_SvrDoc_StdMarshalInfoVtbl.AddRef          = SvrDoc_StdMshl_AddRef; <br>   g_SvrDoc_StdMarshalInfoVtbl.Release         = SvrDoc_StdMshl_Release; <br>   g_SvrDoc_StdMarshalInfoVtbl.GetClassForHandler = <br>                                 SvrDoc_StdMshl_GetClassForHandler; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_SvrDoc_StdMarshalInfoVtbl, <br>         sizeof(IStdMarshalInfoVtbl), <br>         OLESTR("IStdMarshalInfo") <br>      ); <br>   if (! fStatus) return FALSE; <br>#endif  // SVR_TREATAS <br> <br>#if defined( INPLACE_SVR ) <br>   // ServerDoc::IOleInPlaceObject method table <br>   OleStdInitVtbl( <br>      &amp;g_SvrDoc_OleInPlaceObjectVtbl, <br>      sizeof(IOleInPlaceObjectVtbl) <br>   ); <br>   g_SvrDoc_OleInPlaceObjectVtbl.QueryInterface <br>                  = SvrDoc_IPObj_QueryInterface; <br>   g_SvrDoc_OleInPlaceObjectVtbl.AddRef <br>                  = SvrDoc_IPObj_AddRef; <br>   g_SvrDoc_OleInPlaceObjectVtbl.Release <br>                  = SvrDoc_IPObj_Release; <br>   g_SvrDoc_OleInPlaceObjectVtbl.GetWindow <br>                  = SvrDoc_IPObj_GetWindow; <br>   g_SvrDoc_OleInPlaceObjectVtbl.ContextSensitiveHelp <br>                  = SvrDoc_IPObj_ContextSensitiveHelp; <br>   g_SvrDoc_OleInPlaceObjectVtbl.InPlaceDeactivate <br>                  = SvrDoc_IPObj_InPlaceDeactivate; <br>   g_SvrDoc_OleInPlaceObjectVtbl.UIDeactivate <br>                  = SvrDoc_IPObj_UIDeactivate; <br>   g_SvrDoc_OleInPlaceObjectVtbl.SetObjectRects <br>                  = SvrDoc_IPObj_SetObjectRects; <br>   g_SvrDoc_OleInPlaceObjectVtbl.ReactivateAndUndo <br>                  = SvrDoc_IPObj_ReactivateAndUndo; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_SvrDoc_OleInPlaceObjectVtbl, <br>         sizeof(IOleInPlaceObjectVtbl), <br>         OLESTR("IOleInPlaceObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // ServerDoc::IOleInPlaceActiveObject method table <br>   OleStdInitVtbl( <br>      &amp;g_SvrDoc_OleInPlaceActiveObjectVtbl, <br>      sizeof(IOleInPlaceActiveObjectVtbl) <br>   ); <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.QueryInterface <br>                  = SvrDoc_IPActiveObj_QueryInterface; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.AddRef <br>                  = SvrDoc_IPActiveObj_AddRef; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.Release <br>                  = SvrDoc_IPActiveObj_Release; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.GetWindow <br>                  = SvrDoc_IPActiveObj_GetWindow; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.ContextSensitiveHelp <br>                  = SvrDoc_IPActiveObj_ContextSensitiveHelp; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.TranslateAccelerator <br>                  = SvrDoc_IPActiveObj_TranslateAccelerator; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.OnFrameWindowActivate <br>                  = SvrDoc_IPActiveObj_OnFrameWindowActivate; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.OnDocWindowActivate <br>                  = SvrDoc_IPActiveObj_OnDocWindowActivate; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.ResizeBorder <br>                  = SvrDoc_IPActiveObj_ResizeBorder; <br>   g_SvrDoc_OleInPlaceActiveObjectVtbl.EnableModeless <br>                  = SvrDoc_IPActiveObj_EnableModeless; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_SvrDoc_OleInPlaceActiveObjectVtbl, <br>         sizeof(IOleInPlaceActiveObjectVtbl), <br>         OLESTR("IOleInPlaceActiveObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#endif <br> <br> <br>   // PseudoObj::IUnknown method table <br>   OleStdInitVtbl(&amp;g_PseudoObj_UnknownVtbl, sizeof(IUnknownVtbl)); <br>   g_PseudoObj_UnknownVtbl.QueryInterface  = PseudoObj_Unk_QueryInterface; <br>   g_PseudoObj_UnknownVtbl.AddRef          = PseudoObj_Unk_AddRef; <br>   g_PseudoObj_UnknownVtbl.Release         = PseudoObj_Unk_Release; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_PseudoObj_UnknownVtbl, <br>         sizeof(IUnknownVtbl), <br>         OLESTR("IUnknown") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // PseudoObj::IOleObject method table <br>   OleStdInitVtbl(&amp;g_PseudoObj_OleObjectVtbl, sizeof(IOleObjectVtbl)); <br>   g_PseudoObj_OleObjectVtbl.QueryInterface= PseudoObj_OleObj_QueryInterface; <br>   g_PseudoObj_OleObjectVtbl.AddRef        = PseudoObj_OleObj_AddRef; <br>   g_PseudoObj_OleObjectVtbl.Release       = PseudoObj_OleObj_Release; <br>   g_PseudoObj_OleObjectVtbl.SetClientSite = PseudoObj_OleObj_SetClientSite; <br>   g_PseudoObj_OleObjectVtbl.GetClientSite = PseudoObj_OleObj_GetClientSite; <br>   g_PseudoObj_OleObjectVtbl.SetHostNames  = PseudoObj_OleObj_SetHostNames; <br>   g_PseudoObj_OleObjectVtbl.Close         = PseudoObj_OleObj_Close; <br>   g_PseudoObj_OleObjectVtbl.SetMoniker    = PseudoObj_OleObj_SetMoniker; <br>   g_PseudoObj_OleObjectVtbl.GetMoniker    = PseudoObj_OleObj_GetMoniker; <br>   g_PseudoObj_OleObjectVtbl.InitFromData  = PseudoObj_OleObj_InitFromData; <br>   g_PseudoObj_OleObjectVtbl.GetClipboardData = <br>                                 PseudoObj_OleObj_GetClipboardData; <br>   g_PseudoObj_OleObjectVtbl.DoVerb        = PseudoObj_OleObj_DoVerb; <br>   g_PseudoObj_OleObjectVtbl.EnumVerbs     = PseudoObj_OleObj_EnumVerbs; <br>   g_PseudoObj_OleObjectVtbl.Update        = PseudoObj_OleObj_Update; <br>   g_PseudoObj_OleObjectVtbl.IsUpToDate    = PseudoObj_OleObj_IsUpToDate; <br>   g_PseudoObj_OleObjectVtbl.GetUserType   = PseudoObj_OleObj_GetUserType; <br>   g_PseudoObj_OleObjectVtbl.GetUserClassID= PseudoObj_OleObj_GetUserClassID; <br>   g_PseudoObj_OleObjectVtbl.SetExtent     = PseudoObj_OleObj_SetExtent; <br>   g_PseudoObj_OleObjectVtbl.GetExtent     = PseudoObj_OleObj_GetExtent; <br>   g_PseudoObj_OleObjectVtbl.Advise        = PseudoObj_OleObj_Advise; <br>   g_PseudoObj_OleObjectVtbl.Unadvise      = PseudoObj_OleObj_Unadvise; <br>   g_PseudoObj_OleObjectVtbl.EnumAdvise    = PseudoObj_OleObj_EnumAdvise; <br>   g_PseudoObj_OleObjectVtbl.GetMiscStatus = PseudoObj_OleObj_GetMiscStatus; <br>   g_PseudoObj_OleObjectVtbl.SetColorScheme= PseudoObj_OleObj_SetColorScheme; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_PseudoObj_OleObjectVtbl, <br>         sizeof(IOleObjectVtbl), <br>         OLESTR("IOleObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // ServerDoc::IDataObject method table <br>   OleStdInitVtbl(&amp;g_PseudoObj_DataObjectVtbl, sizeof(IDataObjectVtbl)); <br>   g_PseudoObj_DataObjectVtbl.QueryInterface = <br>                           PseudoObj_DataObj_QueryInterface; <br>   g_PseudoObj_DataObjectVtbl.AddRef       = PseudoObj_DataObj_AddRef; <br>   g_PseudoObj_DataObjectVtbl.Release      = PseudoObj_DataObj_Release; <br>   g_PseudoObj_DataObjectVtbl.GetData      = PseudoObj_DataObj_GetData; <br>   g_PseudoObj_DataObjectVtbl.GetDataHere  = PseudoObj_DataObj_GetDataHere; <br>   g_PseudoObj_DataObjectVtbl.QueryGetData = PseudoObj_DataObj_QueryGetData; <br>   g_PseudoObj_DataObjectVtbl.GetCanonicalFormatEtc = <br>                           PseudoObj_DataObj_GetCanonicalFormatEtc; <br>   g_PseudoObj_DataObjectVtbl.SetData      = PseudoObj_DataObj_SetData; <br>   g_PseudoObj_DataObjectVtbl.EnumFormatEtc= PseudoObj_DataObj_EnumFormatEtc; <br>   g_PseudoObj_DataObjectVtbl.DAdvise       = PseudoObj_DataObj_DAdvise; <br>   g_PseudoObj_DataObjectVtbl.DUnadvise     = PseudoObj_DataObj_DUnadvise; <br>   g_PseudoObj_DataObjectVtbl.EnumDAdvise   = PseudoObj_DataObj_EnumAdvise; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_PseudoObj_DataObjectVtbl, <br>         sizeof(IDataObjectVtbl), <br>         OLESTR("IDataObject") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   return TRUE; <br>} <br> <br>#endif  // OLE_SERVER <br> <br> <br> <br>#if defined( OLE_CNTR ) <br> <br>/************************************************************************* <br>** ContainerDoc Supprt Functions Used by Container versions <br>*************************************************************************/ <br> <br> <br>/* ContainerApp_InitInstance <br> * ------------------------- <br> * <br> * Initialize the app instance by creating the main frame window and <br> * performing app instance specific initializations <br> *  (eg. initializing interface Vtbls). <br> * <br> * RETURNS: TRUE if the memory could be allocated, and the server app <br> *               was properly initialized. <br> *          FALSE otherwise <br> * <br> */ <br> <br>BOOL ContainerApp_InitInstance( <br>      LPCONTAINERAPP          lpContainerApp, <br>      HINSTANCE               hInst, <br>      int                     nCmdShow <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)lpContainerApp; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpContainerApp; <br>   char  szAnsiString[256]; <br> <br>   W2A (CONTAINERDOCFORMAT, szAnsiString, 256); <br>   lpContainerApp-&gt;m_cfCntrOutl=RegisterClipboardFormat(szAnsiString); <br>   if(! lpContainerApp-&gt;m_cfCntrOutl) { <br>      // REVIEW: should load string from string resource <br>      OutlineApp_ErrorMessage(lpOutlineApp, OLESTR("Can't register clipboard format!")); <br>      return FALSE; <br>   } <br> <br>#if defined( INPLACE_CNTR ) <br> <br>   lpContainerApp-&gt;m_fPendingUIDeactivate  = FALSE; <br>   lpContainerApp-&gt;m_fMustResizeClientArea = FALSE; <br>   lpContainerApp-&gt;m_lpIPActiveObj         = NULL; <br>   lpContainerApp-&gt;m_hWndUIActiveObj       = NULL; <br>   lpContainerApp-&gt;m_hAccelIPCntr = LoadAccelerators( <br>         hInst, <br>         "InPlaceCntrOutlAccel" <br>   ); <br>   lpContainerApp-&gt;m_hMenuFile = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, </code></pre>
<p>
</p>
<pre><code>POS_FILEMENU <br>   ); <br>   lpContainerApp-&gt;m_hMenuView = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_VIEWMENU <br>   ); <br>   lpContainerApp-&gt;m_hMenuDebug = GetSubMenu ( <br>         lpOutlineApp-&gt;m_hMenuApp, <br>         POS_DEBUGMENU <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerApp-&gt;m_OleInPlaceFrame, <br>         &amp;g_CntrApp_OleInPlaceFrameVtbl, <br>         lpContainerApp <br>   ); <br> <br>#endif <br> <br>   /* Setup arrays used by IDataObject::EnumFormatEtc. This is used to <br>   **    support copy/paste and drag/drop operations. <br>   ** <br>   ** NOTE: The order that the formats are listed for GetData is very <br>   **    significant. It should be listed in order of highest fidelity <br>   **    formats to least fidelity formats. A common ordering will be: <br>   **                  1. private app formats <br>   **                  2. CF_EMBEDSOURCE or CF_EMBEDOBJECT (as appropriate) <br>   **                  3. lower fidelity interchange formats <br>   **                  4. CF_METAFILEPICT <br>   **                      (graphic-related apps might offer picture 1st!) <br>   **                  5. CF_OBJECTDESCRIPTOR <br>   **                  6. CF_LINKSOURCE <br>   **                  6. CF_LINKSRCDESCRIPTOR <br>   */ <br> <br>   /* m_arrDocGetFmts array enumerates the formats that a ContainerDoc <br>   **    object can offer (give) through a IDataObject::GetData call <br>   **    when the selection copied is NOT a single embedded object. <br>   **    when a single embedded object this list of formats available <br>   **    is built dynamically depending on the object copied. (see <br>   **    ContainerDoc_SetupDocGetFmts). <br>   **    The formats are listed in priority order. <br>   **    ContainerDoc objects accept data formats in the following order: <br>   **                  1. CF_CNTROUTL <br>   **                  2. CF_OUTLINE <br>   **                  3. CF_TEXT <br>   **                  4. CF_OBJECTDESCRIPTOR <br>   ** <br>   **    NOTE: CF_OBJECTDESCRIPTOR format is used to describe the <br>   **    data on the clipboard. this information is intended to be <br>   **    used, for example, to drive the PasteSpecial dialog. it is <br>   **    useful to render CF_OBJECTDESCRIPTOR format even when the <br>   **    data on the clipboard does NOT include CF_EMBEDDEDOBJECT <br>   **    format or CF_EMBEDSOURCE format as when a selection that is <br>   **    not a single OLE object is copied from the container only <br>   **    version CNTROUTL. by rendering CF_OBJECTDESCRIPTOR format the <br>   **    app can indicate a useful string to identifiy the source of <br>   **    the copy to the user. <br>   */ <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[0].cfFormat = lpContainerApp-&gt;m_cfCntrOutl; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].ptd      = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].tymed    = TYMED_ISTORAGE; <br>   lpOleApp-&gt;m_arrDocGetFmts[0].lindex   = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[1].cfFormat = lpOutlineApp-&gt;m_cfOutline; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].ptd      = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[1].lindex   = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[2].cfFormat = CF_TEXT; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].ptd      = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[2].lindex   = -1; <br> <br>   lpOleApp-&gt;m_arrDocGetFmts[3].cfFormat = lpOleApp-&gt;m_cfObjectDescriptor; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].ptd      = NULL; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrDocGetFmts[3].lindex   = -1; <br> <br>   lpOleApp-&gt;m_nDocGetFmts = 4; <br> <br>   /* m_arrSingleObjGetFmts array enumerates the formats that a <br>   **    ContainerDoc object can offer (give) through a <br>   **    IDataObject::GetData call when the selection copied IS a <br>   **    single OLE object. <br>   **    ContainerDoc objects accept data formats in the following order: <br>   **                  1. CF_CNTROUTL <br>   **                  2. CF_EMBEDDEDOBJECT <br>   **                  3. CF_OBJECTDESCRIPTOR <br>   **                  4. CF_METAFILEPICT  (note DVASPECT will vary) <br>   **                  5. CF_LINKSOURCE * <br>   **                  6. CF_LINKSRCDESCRIPTOR * <br>   ** <br>   **    * NOTE: CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR is only <br>   **    offered if the OLE object is allowed to be linked to from the <br>   **    inside (ie. we are allowed to give out a moniker which binds <br>   **    to the running OLE object), then we want to offer <br>   **    CF_LINKSOURCE format. if the object is an OLE 2.0 embedded <br>   **    object then it is allowed to be linked to from the inside. if <br>   **    the object is either an OleLink or an OLE 1.0 embedding then <br>   **    it can not be linked to from the inside. if we were a <br>   **    container/server app then we could offer linking to the <br>   **    outside of the object (ie. a pseudo object within our <br>   **    document). we are a container only app that does not support <br>   **    linking to ranges of its data. <br>   **    the simplest way to determine if an object can be linked to <br>   **    on the inside is to call IOleObject::GetMiscStatus and test <br>   **    to see if the OLEMISC_CANTLINKINSIDE bit is NOT set. <br>   ** <br>   **    NOTE: optionally, a container that wants to have a <br>   **    potentially richer data transfer, can enumerate the data <br>   **    formats from the OLE object's cache and offer them too. if <br>   **    the object has a special handler, then it might be able to <br>   **    render additional data formats. <br>   */ <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[0].cfFormat = <br>                                    lpContainerApp-&gt;m_cfCntrOutl; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[0].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[0].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[0].tymed    = TYMED_ISTORAGE; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[0].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[1].cfFormat = <br>                                    lpOleApp-&gt;m_cfEmbeddedObject; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[1].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[1].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[1].tymed    = TYMED_ISTORAGE; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[1].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[2].cfFormat = <br>                                    lpOleApp-&gt;m_cfObjectDescriptor; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[2].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[2].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[2].tymed    = TYMED_HGLOBAL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[2].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[3].cfFormat = CF_METAFILEPICT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[3].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[3].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[3].tymed    = TYMED_MFPICT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[3].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[4].cfFormat = <br>                                       lpOleApp-&gt;m_cfLinkSource; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[4].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[4].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[4].tymed    = TYMED_ISTREAM; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[4].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[5].cfFormat = <br>                                   lpOleApp-&gt;m_cfLinkSrcDescriptor; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[5].ptd      = NULL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[5].dwAspect = DVASPECT_CONTENT; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[5].tymed    = TYMED_HGLOBAL; <br>   lpContainerApp-&gt;m_arrSingleObjGetFmts[5].lindex   = -1; <br> <br>   lpContainerApp-&gt;m_nSingleObjGetFmts = 6; <br> <br>   /* NOTE: the Container-Only version of Outline does NOT offer <br>   **    IDataObject interface from its User documents and the <br>   **    IDataObject interface available from DataTransferDoc's do NOT <br>   **    support SetData. IDataObject interface is required by objects <br>   **    which can be embedded or linked. the Container-only app only <br>   **    allows linking to its contained objects, NOT the data of the <br>   **    container itself. <br>   */ <br> <br>   /*    m_arrPasteEntries array enumerates the formats that a ContainerDoc <br>   **    object can accept from the clipboard. this array is used to <br>   **    support the PasteSpecial dialog. <br>   **    The formats are listed in priority order. <br>   **    ContainerDoc objects accept data formats in the following order: <br>   **                  1. CF_CNTROUTL <br>   **                  2. CF_OUTLINE <br>   **                  3. CF_EMBEDDEDOBJECT <br>   **                  4. CF_TEXT <br>   **                  5. CF_METAFILEPICT <br>   **                  6. CF_DIB <br>   **                  7. CF_BITMAP <br>   **                  8. CF_LINKSOURCE <br>   ** <br>   **    NOTE: specifying CF_EMBEDDEDOBJECT in the PasteEntry array <br>   **    indicates that the caller is interested in pasting OLE <br>   **    objects (ie. the caller calls OleCreateFromData). the <br>   **    OleUIPasteSpecial dialog and OleStdGetPriorityClipboardFormat <br>   **    call OleQueryCreateFromData to see if an OLE object format is <br>   **    available. thus, in fact if CF_EMBEDSOURCE or CF_FILENAME are <br>   **    available from the data source then and OLE object can be <br>   **    created and this entry will be matched. the caller should <br>   **    only specify one object type format. <br>   **    CF_FILENAME format (as generated by copying a file to <br>   **    the clipboard from the FileManager) is considered an object <br>   **    format; OleCreatFromData creates an object if the file has an <br>   **    associated class (see GetClassFile API) or if no class it <br>   **    creates an OLE 1.0 Package object. this format can also be <br>   **    paste linked by calling OleCreateLinkFromData. <br>   */ <br>   // REVIEW: strings should be loaded from string resource <br> <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.cfFormat = <br>                           lpContainerApp-&gt;m_cfCntrOutl; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.tymed    = TYMED_ISTORAGE; <br>   lpOleApp-&gt;m_arrPasteEntries[0].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[0].lpstrFormatName = "Container Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[0].lpstrResultText = "Container Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[0].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.cfFormat =lpOutlineApp-&gt;m_cfOutline; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrPasteEntries[1].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[1].lpstrFormatName = "Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[1].lpstrResultText = "Outline Data"; <br>   lpOleApp-&gt;m_arrPasteEntries[1].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[2].fmtetc.cfFormat = <br>                           lpOleApp-&gt;m_cfEmbeddedObject; <br>   lpOleApp-&gt;m_arrPasteEntries[2].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[2].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[2].fmtetc.tymed    = TYMED_ISTORAGE; <br>   lpOleApp-&gt;m_arrPasteEntries[2].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[2].lpstrFormatName = "%s"; <br>   lpOleApp-&gt;m_arrPasteEntries[2].lpstrResultText = "%s"; <br>   lpOleApp-&gt;m_arrPasteEntries[2].dwFlags         = <br>                           OLEUIPASTE_PASTE | OLEUIPASTE_ENABLEICON; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[3].fmtetc.cfFormat = CF_TEXT; <br>   lpOleApp-&gt;m_arrPasteEntries[3].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[3].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[3].fmtetc.tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrPasteEntries[3].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[3].lpstrFormatName = "Text"; <br>   lpOleApp-&gt;m_arrPasteEntries[3].lpstrResultText = "text"; <br>   lpOleApp-&gt;m_arrPasteEntries[3].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[4].fmtetc.cfFormat = CF_METAFILEPICT; <br>   lpOleApp-&gt;m_arrPasteEntries[4].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[4].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[4].fmtetc.tymed    = TYMED_MFPICT; <br>   lpOleApp-&gt;m_arrPasteEntries[4].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[4].lpstrFormatName = "Picture (Metafile)"; <br>   lpOleApp-&gt;m_arrPasteEntries[4].lpstrResultText = "a static picture"; <br>   lpOleApp-&gt;m_arrPasteEntries[4].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[5].fmtetc.cfFormat = CF_DIB; <br>   lpOleApp-&gt;m_arrPasteEntries[5].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[5].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[5].fmtetc.tymed    = TYMED_HGLOBAL; <br>   lpOleApp-&gt;m_arrPasteEntries[5].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[5].lpstrFormatName = "Picture (DIB)"; <br>   lpOleApp-&gt;m_arrPasteEntries[5].lpstrResultText = "a static picture"; <br>   lpOleApp-&gt;m_arrPasteEntries[5].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[6].fmtetc.cfFormat = CF_BITMAP; <br>   lpOleApp-&gt;m_arrPasteEntries[6].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[6].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[6].fmtetc.tymed    = TYMED_GDI; <br>   lpOleApp-&gt;m_arrPasteEntries[6].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[6].lpstrFormatName = "Picture (Bitmap)"; <br>   lpOleApp-&gt;m_arrPasteEntries[6].lpstrResultText = "a static picture"; <br>   lpOleApp-&gt;m_arrPasteEntries[6].dwFlags         = OLEUIPASTE_PASTEONLY; <br> <br>   lpOleApp-&gt;m_arrPasteEntries[7].fmtetc.cfFormat = lpOleApp-&gt;m_cfLinkSource; <br>   lpOleApp-&gt;m_arrPasteEntries[7].fmtetc.ptd      = NULL; <br>   lpOleApp-&gt;m_arrPasteEntries[7].fmtetc.dwAspect = DVASPECT_CONTENT; <br>   lpOleApp-&gt;m_arrPasteEntries[7].fmtetc.tymed    = TYMED_ISTREAM; <br>   lpOleApp-&gt;m_arrPasteEntries[7].fmtetc.lindex   = -1; <br>   lpOleApp-&gt;m_arrPasteEntries[7].lpstrFormatName = "%s"; <br>   lpOleApp-&gt;m_arrPasteEntries[7].lpstrResultText = "%s"; <br>   lpOleApp-&gt;m_arrPasteEntries[7].dwFlags         = <br>                        OLEUIPASTE_LINKTYPE1 | OLEUIPASTE_ENABLEICON; <br> <br>   lpOleApp-&gt;m_nPasteEntries = 8; <br> <br>   /*    m_arrLinkTypes array enumerates the link types that a ContainerDoc <br>   **    object can accept from the clipboard <br>   */ <br> <br>   lpOleApp-&gt;m_arrLinkTypes[0] = lpOleApp-&gt;m_cfLinkSource; <br>   lpOleApp-&gt;m_nLinkTypes = 1; <br> <br>   return TRUE; <br>} <br> <br> <br>/* ContainerApp_InitVtbls <br>** ---------------------- <br>** <br>**    initialize the interface Vtbl's used to support the OLE 2.0 <br>**    Container functionality. <br>*/ <br> <br>BOOL ContainerApp_InitVtbls(LPCONTAINERAPP lpApp) <br>{ <br>   BOOL fStatus; <br> <br>   // ContainerDoc::IOleUILinkContainer method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrDoc_OleUILinkContainerVtbl, <br>         sizeof(IOleUILinkContainerVtbl) <br>   ); <br>   g_CntrDoc_OleUILinkContainerVtbl.QueryInterface = <br>                                 CntrDoc_LinkCont_QueryInterface; <br>   g_CntrDoc_OleUILinkContainerVtbl.AddRef    = CntrDoc_LinkCont_AddRef; <br>   g_CntrDoc_OleUILinkContainerVtbl.Release   = CntrDoc_LinkCont_Release; <br>   g_CntrDoc_OleUILinkContainerVtbl.GetNextLink = <br>                              CntrDoc_LinkCont_GetNextLink; <br>   g_CntrDoc_OleUILinkContainerVtbl.SetLinkUpdateOptions = <br>                              CntrDoc_LinkCont_SetLinkUpdateOptions; <br>   g_CntrDoc_OleUILinkContainerVtbl.GetLinkUpdateOptions = <br>                              CntrDoc_LinkCont_GetLinkUpdateOptions; <br>   g_CntrDoc_OleUILinkContainerVtbl.SetLinkSource = <br>                              CntrDoc_LinkCont_SetLinkSource; <br>   g_CntrDoc_OleUILinkContainerVtbl.GetLinkSource = <br>                              CntrDoc_LinkCont_GetLinkSource; <br>   g_CntrDoc_OleUILinkContainerVtbl.OpenLinkSource = <br>                              CntrDoc_LinkCont_OpenLinkSource; <br>   g_CntrDoc_OleUILinkContainerVtbl.UpdateLink = <br>                              CntrDoc_LinkCont_UpdateLink; <br>   g_CntrDoc_OleUILinkContainerVtbl.CancelLink = <br>                              CntrDoc_LinkCont_CancelLink; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrDoc_OleUILinkContainerVtbl, <br>         sizeof(IOleUILinkContainerVtbl), <br>         OLESTR("IOleUILinkContainer") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#if defined( INPLACE_CNTR ) <br> <br>   // ContainerApp::IOleInPlaceFrame interface method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrApp_OleInPlaceFrameVtbl, <br>         sizeof(g_CntrApp_OleInPlaceFrameVtbl) <br>   ); <br> <br>   g_CntrApp_OleInPlaceFrameVtbl.QueryInterface <br>                  = CntrApp_IPFrame_QueryInterface; <br>   g_CntrApp_OleInPlaceFrameVtbl.AddRef <br>                  = CntrApp_IPFrame_AddRef; <br>   g_CntrApp_OleInPlaceFrameVtbl.Release <br>                  = CntrApp_IPFrame_Release; <br>   g_CntrApp_OleInPlaceFrameVtbl.GetWindow <br>                  = CntrApp_IPFrame_GetWindow; <br>   g_CntrApp_OleInPlaceFrameVtbl.ContextSensitiveHelp <br>                  = CntrApp_IPFrame_ContextSensitiveHelp; <br> <br>   g_CntrApp_OleInPlaceFrameVtbl.GetBorder <br>                  = CntrApp_IPFrame_GetBorder; <br>   g_CntrApp_OleInPlaceFrameVtbl.RequestBorderSpace <br>                  = CntrApp_IPFrame_RequestBorderSpace; <br>   g_CntrApp_OleInPlaceFrameVtbl.SetBorderSpace <br>                  = CntrApp_IPFrame_SetBorderSpace; <br>   g_CntrApp_OleInPlaceFrameVtbl.SetActiveObject <br>                  = CntrApp_IPFrame_SetActiveObject; <br>   g_CntrApp_OleInPlaceFrameVtbl.InsertMenus <br>                  = CntrApp_IPFrame_InsertMenus; <br>   g_CntrApp_OleInPlaceFrameVtbl.SetMenu <br>                  = CntrApp_IPFrame_SetMenu; <br>   g_CntrApp_OleInPlaceFrameVtbl.RemoveMenus <br>                  = CntrApp_IPFrame_RemoveMenus; <br>   g_CntrApp_OleInPlaceFrameVtbl.SetStatusText <br>                  = CntrApp_IPFrame_SetStatusText; <br>   g_CntrApp_OleInPlaceFrameVtbl.EnableModeless <br>                  = CntrApp_IPFrame_EnableModeless; <br>   g_CntrApp_OleInPlaceFrameVtbl.TranslateAccelerator <br>                  = CntrApp_IPFrame_TranslateAccelerator; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrApp_OleInPlaceFrameVtbl, <br>         sizeof(g_CntrApp_OleInPlaceFrameVtbl), <br>         OLESTR("IOleInPlaceFrame") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#endif  // INPLACE_CNTR <br> <br> <br>   // ContainerLine::IUnknown interface method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrLine_UnknownVtbl, <br>         sizeof(g_CntrLine_UnknownVtbl) <br>      ); <br>   g_CntrLine_UnknownVtbl.QueryInterface   = CntrLine_Unk_QueryInterface; <br>   g_CntrLine_UnknownVtbl.AddRef           = CntrLine_Unk_AddRef; <br>   g_CntrLine_UnknownVtbl.Release          = CntrLine_Unk_Release; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrLine_UnknownVtbl, <br>         sizeof(g_CntrLine_UnknownVtbl), <br>         OLESTR("IUnknown") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // ContainerLine::IOleClientSite interface method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrLine_OleClientSiteVtbl, <br>         sizeof(g_CntrLine_OleClientSiteVtbl) <br>      ); <br>   g_CntrLine_OleClientSiteVtbl.QueryInterface = <br>                                 CntrLine_CliSite_QueryInterface; <br>   g_CntrLine_OleClientSiteVtbl.AddRef       = CntrLine_CliSite_AddRef; <br>   g_CntrLine_OleClientSiteVtbl.Release      = CntrLine_CliSite_Release; <br>   g_CntrLine_OleClientSiteVtbl.SaveObject   = CntrLine_CliSite_SaveObject; <br>   g_CntrLine_OleClientSiteVtbl.GetMoniker   = CntrLine_CliSite_GetMoniker; <br>   g_CntrLine_OleClientSiteVtbl.GetContainer = CntrLine_CliSite_GetContainer; <br>   g_CntrLine_OleClientSiteVtbl.ShowObject   = CntrLine_CliSite_ShowObject; <br>   g_CntrLine_OleClientSiteVtbl.OnShowWindow = CntrLine_CliSite_OnShowWindow; <br>   g_CntrLine_OleClientSiteVtbl.RequestNewObjectLayout = <br>                           CntrLine_CliSite_RequestNewObjectLayout; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrLine_OleClientSiteVtbl, <br>         sizeof(g_CntrLine_OleClientSiteVtbl), <br>         OLESTR("IOleClientSite") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>   // ContainerLine::IAdviseSink interface method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrLine_AdviseSinkVtbl, <br>         sizeof(g_CntrLine_AdviseSinkVtbl) <br>   ); <br>   g_CntrLine_AdviseSinkVtbl.QueryInterface= CntrLine_AdvSink_QueryInterface; <br>   g_CntrLine_AdviseSinkVtbl.AddRef        = CntrLine_AdvSink_AddRef; <br>   g_CntrLine_AdviseSinkVtbl.Release       = CntrLine_AdvSink_Release; <br>   g_CntrLine_AdviseSinkVtbl.OnDataChange  = CntrLine_AdvSink_OnDataChange; <br>   g_CntrLine_AdviseSinkVtbl.OnViewChange  = CntrLine_AdvSink_OnViewChange; <br>   g_CntrLine_AdviseSinkVtbl.OnRename      = CntrLine_AdvSink_OnRename; <br>   g_CntrLine_AdviseSinkVtbl.OnSave        = CntrLine_AdvSink_OnSave; <br>   g_CntrLine_AdviseSinkVtbl.OnClose       = CntrLine_AdvSink_OnClose; <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrLine_AdviseSinkVtbl, <br>         sizeof(g_CntrLine_AdviseSinkVtbl), <br>         OLESTR("IAdviseSink") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br> <br>#if defined( INPLACE_CNTR ) <br> <br>   // ContainerLine::IOleInPlaceSite interface method table <br>   OleStdInitVtbl( <br>         &amp;g_CntrLine_OleInPlaceSiteVtbl, <br>         sizeof(g_CntrLine_OleInPlaceSiteVtbl) <br>   ); <br> <br>   g_CntrLine_OleInPlaceSiteVtbl.QueryInterface <br>                  = CntrLine_IPSite_QueryInterface; <br>   g_CntrLine_OleInPlaceSiteVtbl.AddRef <br>                  = CntrLine_IPSite_AddRef; <br>   g_CntrLine_OleInPlaceSiteVtbl.Release <br>                  = CntrLine_IPSite_Release; <br>   g_CntrLine_OleInPlaceSiteVtbl.GetWindow <br>                  = CntrLine_IPSite_GetWindow; <br>   g_CntrLine_OleInPlaceSiteVtbl.ContextSensitiveHelp <br>                  = CntrLine_IPSite_ContextSensitiveHelp; <br>   g_CntrLine_OleInPlaceSiteVtbl.CanInPlaceActivate <br>                  = CntrLine_IPSite_CanInPlaceActivate; <br>   g_CntrLine_OleInPlaceSiteVtbl.OnInPlaceActivate <br>                  = CntrLine_IPSite_OnInPlaceActivate; <br>   g_CntrLine_OleInPlaceSiteVtbl.OnUIActivate <br>                  = CntrLine_IPSite_OnUIActivate; <br>   g_CntrLine_OleInPlaceSiteVtbl.GetWindowContext <br>                  = CntrLine_IPSite_GetWindowContext; <br>   g_CntrLine_OleInPlaceSiteVtbl.Scroll <br>                  = CntrLine_IPSite_Scroll; <br>   g_CntrLine_OleInPlaceSiteVtbl.OnUIDeactivate <br>                  = CntrLine_IPSite_OnUIDeactivate; <br> <br>   g_CntrLine_OleInPlaceSiteVtbl.OnInPlaceDeactivate <br>                  = CntrLine_IPSite_OnInPlaceDeactivate; <br>   g_CntrLine_OleInPlaceSiteVtbl.DiscardUndoState <br>                  = CntrLine_IPSite_DiscardUndoState; <br>   g_CntrLine_OleInPlaceSiteVtbl.DeactivateAndUndo <br>                  = CntrLine_IPSite_DeactivateAndUndo; <br>   g_CntrLine_OleInPlaceSiteVtbl.OnPosRectChange <br>                  = CntrLine_IPSite_OnPosRectChange; <br> <br>   fStatus = OleStdCheckVtbl( <br>         &amp;g_CntrLine_OleInPlaceSiteVtbl, <br>         sizeof(g_CntrLine_OleInPlaceSiteVtbl), <br>         OLESTR("IOleInPlaceSite") <br>      ); <br>   if (! fStatus) return FALSE; <br> <br>#endif  // INPLACE_CNTR <br> <br>   return TRUE; <br>} <br> <br> <br>#endif  // OLE_CNTR </code></pre>
<p>&nbsp;</p></body>
</HTML>
