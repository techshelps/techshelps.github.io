<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINKING.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context290"></a>LINKING.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    linking.c <br>** <br>**    This file contains the major interfaces, methods and related support <br>**    functions for implementing linking to items. The code <br>**    contained in this file is used by BOTH the Container and Server <br>**    (Object) versions of the Outline sample code. <br>** <br>**    As a server SVROUTL supports linking to the whole document object <br>**    (either a file-based document or as an embedded object). It also <br>**    supports linking to ranges (or PseudoObjects). <br>** <br>**    As a container CNTROUTL supports linking to embedded objects. <br>**    (see file svrpsobj.c for Pseudo Object implementation) <br>** <br>**    OleDoc Object <br>**      exposed interfaces: <br>**          IPersistFile <br>**          IOleItemContainer <br>**          IExternalConnection <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br> <br>/************************************************************************* <br>** OleDoc::IPersistFile interface implementation <br>*************************************************************************/ <br> <br>// IPersistFile::QueryInterface <br>STDMETHODIMP OleDoc_PFile_QueryInterface( <br>      LPPERSISTFILE       lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>// IPersistFile::AddRef <br>STDMETHODIMP_(ULONG) OleDoc_PFile_AddRef(LPPERSISTFILE lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IPersistFile"); <br> <br>   return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>// IPersistFile::Release <br>STDMETHODIMP_(ULONG) OleDoc_PFile_Release (LPPERSISTFILE lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IPersistFile"); <br> <br>   return OleDoc_Release(lpOleDoc); <br>} <br> <br> <br>// IPersistFile::GetClassID <br>STDMETHODIMP OleDoc_PFile_GetClassID ( <br>      LPPERSISTFILE       lpThis, <br>      CLSID FAR*          lpclsid <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   OleDbgOut2("OleDoc_PFile_GetClassID\r\n"); <br> <br>#if defined( OLE_SERVER ) &amp;&amp; defined( SVR_TREATAS ) <br> <br>   /* NOTE: we must be carefull to return the correct CLSID here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the class of the object <br>   **    written in the storage of the object. otherwise we would <br>   **    return our own class id. <br>   */ <br>   return ServerDoc_GetClassID((LPSERVERDOC)lpOleDoc, lpclsid); <br>#else <br>   *lpclsid = CLSID_APP; <br>#endif <br>   return NOERROR; <br>} <br> <br> <br>// IPersistFile::IsDirty <br>STDMETHODIMP  OleDoc_PFile_IsDirty(LPPERSISTFILE lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   OleDbgOut2("OleDoc_PFile_IsDirty\r\n"); <br> <br>   if (OutlineDoc_IsModified((LPOUTLINEDOC)lpOleDoc)) <br>      return NOERROR; <br>   else <br>      return S_FALSE; <br>} <br> <br> <br>// IPersistFile::Load <br>STDMETHODIMP OleDoc_PFile_Load ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName, <br>      DWORD               grfMode <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   SCODE sc; <br> <br>   OLEDBG_BEGIN2("OleDoc_PFile_Load\r\n") <br> <br>   /* NOTE: grfMode passed from the caller indicates if the caller <br>   **    needs Read or ReadWrite permissions. if appropriate the <br>   **    callee should open the file with the requested permissions. <br>   **    the caller will normally not impose sharing permissions. <br>   ** <br>   **    the sample code currently always opens its file ReadWrite. <br>   */ <br> <br>   if (OutlineDoc_LoadFromFile((LPOUTLINEDOC)lpOleDoc, (LPOLESTR)lpszFileName)) <br>      sc = S_OK; <br>   else <br>      sc = E_FAIL; <br> <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>// IPersistFile::Save <br>STDMETHODIMP OleDoc_PFile_Save ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName, <br>      BOOL                fRemember <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   SCODE sc; <br> <br>   OLEDBG_BEGIN2("OleDoc_PFile_Save\r\n") <br> <br>   /* NOTE: it is only legal to perform a Save or SaveAs operation <br>   **    on a file-based document. if the document is an embedded <br>   **    object then we can not be changed to a file-base object. <br>   ** <br>   **      fRemember   lpszFileName     Type of Save <br>   **    ---------------------------------------------- <br>   **        TRUE        NULL           SAVE <br>   **        TRUE        ! NULL         SAVE AS <br>   **        FALSE       ! NULL         SAVE COPY AS <br>   **        FALSE       NULL           ***error*** <br>   */ <br>   if ( (lpszFileName==NULL || (lpszFileName != NULL &amp;&amp; fRemember)) <br>         &amp;&amp; ((lpOutlineDoc-&gt;m_docInitType != DOCTYPE_FROMFILE <br>            &amp;&amp; lpOutlineDoc-&gt;m_docInitType != DOCTYPE_NEW)) ) { <br>      OLEDBG_END2 <br>      return E_INVALIDARG; <br>   } <br> <br>   if (OutlineDoc_SaveToFile( <br>         (LPOUTLINEDOC)lpOleDoc, <br>         lpszFileName, <br>         lpOutlineDoc-&gt;m_cfSaveFormat, <br>         fRemember)) { <br>      sc = S_OK; <br>   } else <br>      sc = E_FAIL; <br> <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>// IPersistFile::SaveCompleted <br>STDMETHODIMP OleDoc_PFile_SaveCompleted ( <br>      LPPERSISTFILE       lpThis, <br>      LPCOLESTR           lpszFileName <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br> <br>   OleDbgOut2("OleDoc_PFile_SaveCompleted\r\n"); <br> <br>   /* This method is called after IPersistFile::Save is called. during <br>   **    the period between Save and SaveCompleted the object must <br>   **    consider itself in NOSCRIBBLE mode (ie. it is NOT allowed to <br>   **    write to its file. here the object can clear its NOSCRIBBLE <br>   **    mode flag. the outline app never scribbles to its storage, so <br>   **    we have nothing to do. <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>// IPersistFile::GetCurFile <br>STDMETHODIMP OleDoc_PFile_GetCurFile ( <br>      LPPERSISTFILE   lpThis, <br>      LPOLESTR FAR*   lplpszFileName <br>) <br>{ <br>   LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br>   LPMALLOC lpMalloc; <br>   LPOLESTR lpsz; <br>   SCODE sc; <br>   char  szAnsiStr[256]; <br> <br>   OleDbgOut2("OleDoc_PFile_GetCurFile\r\n"); <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpszFileName = NULL; <br> <br>   /********************************************************************* <br>   ** NOTE: memory returned for the lplpszFileName must be <br>   **    allocated appropriately using the current registered IMalloc <br>   **    interface. the allows the ownership of the memory to be <br>   **    passed to the caller (even if in another process). <br>   *********************************************************************/ <br> <br>   CoGetMalloc(MEMCTX_TASK, &amp;lpMalloc); <br>   if (! lpMalloc) { <br> <br>      return E_FAIL; <br>   } <br> <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_FROMFILE) { <br>      /* valid filename associated; return file name */ <br>      lpsz = /*(LPOLESTR)*/lpMalloc-&gt;lpVtbl-&gt;Alloc( <br>            lpMalloc, <br>            (OLESTRLEN(lpOutlineDoc-&gt;m_szFileName)+1)*sizeof(OLECHAR) <br>      ); <br>      if (! lpsz) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      OLESTRCPY(lpsz, /*(LPOLESTR)*/lpOutlineDoc-&gt;m_szFileName); <br>      sc = S_OK; <br>   } else { <br>      /* no file associated; return default file name prompt */ <br>      lpsz=/*(LPOLESTR)*/lpMalloc-&gt;lpVtbl-&gt;Alloc(lpMalloc, (lstrlen(DEFEXTENSION)+3)*sizeof(OLECHAR)); <br>      wsprintf(szAnsiStr, "*.%s", DEFEXTENSION); <br>      A2W (szAnsiStr, lpsz, OLEUI_CCHPATHMAX); <br>      sc = S_FALSE; <br>   } <br> <br>error: <br>   OleStdRelease((LPUNKNOWN)lpMalloc); <br>   *lplpszFileName = lpsz; <br> <br> <br>   return sc; <br>} <br> <br> <br>/************************************************************************* <br>** OleDoc::IOleItemContainer interface implementation <br>*************************************************************************/ <br> <br>// IOleItemContainer::QueryInterface <br>STDMETHODIMP OleDoc_ItemCont_QueryInterface( <br>      LPOLEITEMCONTAINER  lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>// IOleItemContainer::AddRef <br>STDMETHODIMP_(ULONG) OleDoc_ItemCont_AddRef(LPOLEITEMCONTAINER lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleItemContainer"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpOleDoc); <br>} <br> <br> <br>// IOleItemContainer::Release <br>STDMETHODIMP_(ULONG) OleDoc_ItemCont_Release(LPOLEITEMCONTAINER lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleItemContainer"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpOleDoc); <br>} <br> <br> <br>// IOleItemContainer::ParseDisplayName <br>STDMETHODIMP OleDoc_ItemCont_ParseDisplayName( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPBC                lpbc, <br>      LPOLESTR            lpszDisplayName, <br>      ULONG FAR*          lpchEaten, <br>      LPMONIKER FAR*      lplpmkOut <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   OLECHAR szItemName[MAXNAMESIZE]; <br>   LPUNKNOWN lpUnk; <br>   HRESULT hrErr; <br> <br>   OleDbgOut2("OleDoc_ItemCont_ParseDisplayName\r\n"); <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpmkOut = NULL; <br> <br>   *lpchEaten = OleStdGetItemToken( <br>         lpszDisplayName, <br>         szItemName, <br>         MAXNAMESIZE*sizeof(OLECHAR) <br>   ); <br> <br>   /* NOTE: get a pointer to a running instance of the object. we <br>   **    should force the object to go running if necessary (even if <br>   **    this means launching its server EXE). this is the meaining of <br>   **    BINDSPEED_INDEFINITE. Parsing a Moniker is known to be an <br>   **    "EXPENSIVE" operation. <br>   */ <br>   hrErr = OleDoc_ItemCont_GetObject( <br>         lpThis, <br>         szItemName, <br>         BINDSPEED_INDEFINITE, <br>         lpbc, <br>         &amp;IID_IUnknown, <br>         (LPVOID FAR*)&amp;lpUnk <br>   ); <br> <br>   if (hrErr == NOERROR) { <br>      OleStdRelease(lpUnk);   // item name FOUND; don't need obj ptr. <br>      CreateItemMoniker(OLESTR("\\"), szItemName, lplpmkOut); <br>   } else <br>      *lpchEaten = 0;     // item name is NOT valid <br> <br>   return hrErr; <br>} <br> <br> <br>// IOleItemContainer::EnumObjects <br>STDMETHODIMP OleDoc_ItemCont_EnumObjects( <br>      LPOLEITEMCONTAINER  lpThis, <br>      DWORD               grfFlags, <br>      LPENUMUNKNOWN FAR*  lplpenumUnknown <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OLEDBG_BEGIN2("OleDoc_ItemCont_EnumObjects\r\n") <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpenumUnknown = NULL; <br> <br>   /* NOTE: this method should be implemented to allow programatic <br>   **    clients the ability to what elements the container holds. <br>   **    this method is NOT called in the standard linking scenarios. <br>   ** <br>   **    grfFlags can be one of the following: <br>   **        OLECONTF_EMBEDDINGS   -- enumerate embedded objects <br>   **        OLECONTF_LINKS        -- enumerate linked objects <br>   **        OLECONTF_OTHERS       -- enumerate non-OLE compound doc objs <br>   **        OLECONTF_ONLYUSER     -- enumerate only objs named by user <br>   **        OLECONTF_ONLYIFRUNNING-- enumerate only objs in running state <br>   */ <br> <br>   OleDbgAssertSz(0, "NOT YET IMPLEMENTED!"); <br> <br>   OLEDBG_END2 <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br>// IOleItemContainer::LockContainer <br>STDMETHODIMP OleDoc_ItemCont_LockContainer( <br>      LPOLEITEMCONTAINER  lpThis, <br>      BOOL                fLock <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br>   OLEDBG_BEGIN2("OleDoc_ItemCont_LockContainer\r\n") <br> <br>#if defined( _DEBUG ) <br>   if (fLock) { <br>      ++lpOleDoc-&gt;m_cCntrLock; <br>      OleDbgOutRefCnt3( <br>            "OleDoc_ItemCont_LockContainer: cLock++\r\n", <br>            lpOleDoc, <br>            lpOleDoc-&gt;m_cCntrLock <br>      ); <br>   } else { <br>      /* NOTE: when there are no open documents and the app is not <br>      **    under the control of the user and there are no outstanding <br>      **    locks on the app, then revoke our ClassFactory to enable the <br>      **    app to shut down. <br>      */ <br>      --lpOleDoc-&gt;m_cCntrLock; <br>      OleDbgAssertSz ( <br>            lpOleDoc-&gt;m_cCntrLock &gt;= 0, <br>            "OleDoc_ItemCont_LockContainer(FALSE) called with cLock == 0" <br>      ); <br> <br>      if (lpOleDoc-&gt;m_cCntrLock == 0) { <br>         OleDbgOutRefCnt2( <br>               "OleDoc_ItemCont_LockContainer: UNLOCKED\r\n", <br>               lpOleDoc, lpOleDoc-&gt;m_cCntrLock); <br>      } else { <br>         OleDbgOutRefCnt3( <br>               "OleDoc_ItemCont_LockContainer: cLock--\r\n", <br>               lpOleDoc, lpOleDoc-&gt;m_cCntrLock); <br>      } <br>   } <br>#endif  // _DEBUG <br> <br>   /* NOTE: in order to hold the document alive we call <br>   **    CoLockObjectExternal to add a strong reference to our Doc <br>   **    object. this will keep the Doc alive when all other external <br>   **    references release us. whenever an embedded object goes <br>   **    running a LockContainer(TRUE) is called. when the embedded <br>   **    object shuts down (ie. transitions from running to loaded) <br>   **    LockContainer(FALSE) is called. if the user issues File.Close <br>   **    the document will shut down in any case ignoring any <br>   **    outstanding LockContainer locks because CoDisconnectObject is <br>   **    called in OleDoc_Close. this will forceably break any <br>   **    existing strong reference counts including counts that we add <br>   **    ourselves by calling CoLockObjectExternal and guarantee that <br>   **    the Doc object gets its final release (ie. cRefs goes to 0). <br>   */ <br>   hrErr = OleDoc_Lock(lpOleDoc, fLock, TRUE /* fLastUnlockReleases */); <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>// IOleItemContainer::GetObject <br>STDMETHODIMP OleDoc_ItemCont_GetObject( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem, <br>      DWORD               dwSpeedNeeded, <br>      LPBINDCTX           lpbc, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObject <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleDoc_ItemCont_GetObject\r\n") <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvObject = NULL; <br> <br>#if defined( OLE_SERVER ) <br> <br>   /* NOTE: SERVER ONLY version should return PseudoObjects with <br>   **    BINDSPEED_IMMEDIATE, thus the dwSpeedNeeded is not important <br>   **    in the case of a pure server. <br>   */ <br>   hrErr = ServerDoc_GetObject( <br>         (LPSERVERDOC)lpOleDoc, lpszItem,riid,lplpvObject); <br>#endif <br>#if defined( OLE_CNTR ) <br> <br>   /* NOTE: dwSpeedNeeded indicates how long the caller is willing <br>   **    to wait for us to get the object: <br>   **      BINDSPEED_IMMEDIATE -- only if obj already loaded &amp;&amp; IsRunning <br>   **      BINDSPEED_MODERATE  -- load obj if necessary &amp;&amp; if IsRunning <br>   **      BINDSPEED_INDEFINITE-- force obj to load and run if necessary <br>   */ <br>   hrErr = ContainerDoc_GetObject( <br>         (LPCONTAINERDOC)lpOleDoc,lpszItem,dwSpeedNeeded,riid,lplpvObject); <br>#endif <br> <br>   OLEDBG_END2 <br> <br>   return hrErr; <br>} <br> <br> <br>// IOleItemContainer::GetObjectStorage <br>STDMETHODIMP OleDoc_ItemCont_GetObjectStorage( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem, <br>      LPBINDCTX           lpbc, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvStorage <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   OleDbgOut2("OleDoc_ItemCont_GetObjectStorage\r\n"); <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvStorage = NULL; <br> <br>#if defined( OLE_SERVER ) <br>   /* NOTE: in the SERVER ONLY version, item names identify pseudo <br>   **    objects. pseudo objects, do NOT have identifiable storage. <br>   */ <br>   return E_FAIL; <br>#endif <br>#if defined( OLE_CNTR ) <br>   // We can only return an IStorage* type pointer <br>   if (! IsEqualIID(riid, &amp;IID_IStorage)) <br>   { <br>      return E_FAIL; <br>   } <br> <br>   return ContainerDoc_GetObjectStorage( <br>         (LPCONTAINERDOC)lpOleDoc, <br>         lpszItem, <br>         (LPSTORAGE FAR*)lplpvStorage <br>   ); <br>#endif <br>} <br> <br> <br>// IOleItemContainer::IsRunning <br>STDMETHODIMP OleDoc_ItemCont_IsRunning( <br>      LPOLEITEMCONTAINER  lpThis, <br>      LPOLESTR            lpszItem <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocOleItemContainerImpl FAR*)lpThis)-&gt;lpOleDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("OleDoc_ItemCont_IsRunning\r\n") <br> <br>   /* NOTE: Check if item name is valid. if so then return if <br>   **    Object is running. PseudoObjects in the Server version are <br>   **    always considered running. Ole objects in the container must <br>   **    be checked if they are running. <br>   */ <br> <br>#if defined( OLE_SERVER ) <br>   hrErr = ServerDoc_IsRunning((LPSERVERDOC)lpOleDoc, lpszItem); <br>#endif <br>#if defined( OLE_CNTR ) <br>   hrErr = ContainerDoc_IsRunning((LPCONTAINERDOC)lpOleDoc, lpszItem); <br>#endif <br> <br>   OLEDBG_END2 <br>   return hrErr; <br>} <br> <br> <br>/************************************************************************* <br>** OleDoc::IExternalConnection interface implementation <br>*************************************************************************/ <br> <br>// IExternalConnection::QueryInterface <br>STDMETHODIMP OleDoc_ExtConn_QueryInterface( <br>      LPEXTERNALCONNECTION    lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocExternalConnectionImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>// IExternalConnection::AddRef <br>STDMETHODIMP_(ULONG) OleDoc_ExtConn_AddRef(LPEXTERNALCONNECTION lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocExternalConnectionImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IExternalConnection"); <br> <br>   return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>// IExternalConnection::Release <br>STDMETHODIMP_(ULONG) OleDoc_ExtConn_Release (LPEXTERNALCONNECTION lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocExternalConnectionImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IExternalConnection"); <br> <br>   return OleDoc_Release(lpOleDoc); <br>} <br> <br> <br>// IExternalConnection::AddConnection <br>STDMETHODIMP_(DWORD) OleDoc_ExtConn_AddConnection( <br>      LPEXTERNALCONNECTION    lpThis, <br>      DWORD                   extconn, <br>      DWORD                   reserved <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocExternalConnectionImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   if( extconn &amp; EXTCONN_STRONG ) { <br> <br>#if defined( _DEBUG ) <br>      OleDbgOutRefCnt3( <br>            "OleDoc_ExtConn_AddConnection: dwStrongExtConn++\r\n", <br>            lpOleDoc, <br>            lpOleDoc-&gt;m_dwStrongExtConn + 1 <br>      ); <br>#endif <br>      return ++(lpOleDoc-&gt;m_dwStrongExtConn); <br>   } else <br>   { <br>      return 0; <br>   } <br>} <br> <br> <br>// IExternalConnection::ReleaseConnection <br>STDMETHODIMP_(DWORD) OleDoc_ExtConn_ReleaseConnection( <br>      LPEXTERNALCONNECTION    lpThis, <br>      DWORD                   extconn, <br>      DWORD                   reserved, <br>      BOOL                    fLastReleaseCloses <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         ((struct CDocExternalConnectionImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>   if( extconn &amp; EXTCONN_STRONG ){ <br>      DWORD dwSave = --(lpOleDoc-&gt;m_dwStrongExtConn); <br>#if defined( _DEBUG ) <br>      OLEDBG_BEGIN2( (fLastReleaseCloses ? <br>                  "OleDoc_ExtConn_ReleaseConnection(TRUE)\r\n" : <br>                  "OleDoc_ExtConn_ReleaseConnection(FALSE)\r\n") ) <br>      OleDbgOutRefCnt3( <br>            "OleDoc_ExtConn_ReleaseConnection: dwStrongExtConn--\r\n", <br>            lpOleDoc, <br>            lpOleDoc-&gt;m_dwStrongExtConn <br>      ); <br>      OleDbgAssertSz ( <br>            lpOleDoc-&gt;m_dwStrongExtConn &gt;= 0, <br>            "OleDoc_ExtConn_ReleaseConnection called with dwStrong == 0" <br>      ); <br>#endif  // _DEBUG <br> <br>      if( lpOleDoc-&gt;m_dwStrongExtConn == 0 &amp;&amp; fLastReleaseCloses ) <br>         OleDoc_Close(lpOleDoc, OLECLOSE_SAVEIFDIRTY); <br> <br>      OLEDBG_END2 <br>      return dwSave; <br>   } else <br>   { <br>      return 0; <br>   } <br>} <br> <br> <br>/************************************************************************* <br>** OleDoc Common Support Functions <br>*************************************************************************/ <br> <br> <br>/* OleDoc_GetFullMoniker <br>** --------------------- <br>**    Return the full, absolute moniker of the document. <br>** <br>**    NOTE: the caller must release the pointer returned when done. <br>*/ <br>LPMONIKER OleDoc_GetFullMoniker(LPOLEDOC lpOleDoc, DWORD dwAssign) <br>{ <br>   LPMONIKER lpMoniker = NULL; <br> <br>   OLEDBG_BEGIN3("OleDoc_GetFullMoniker\r\n") <br> <br>   if (lpOleDoc-&gt;m_lpSrcDocOfCopy) { <br>      /* CASE I: this document was created for a copy or drag/drop <br>      **    operation. generate the moniker which identifies the <br>      **    source document of the original copy. <br>      */ <br>      if (! lpOleDoc-&gt;m_fLinkSourceAvail) <br>         goto done;        // we already know a moniker is not available <br> <br>      lpMoniker=OleDoc_GetFullMoniker(lpOleDoc-&gt;m_lpSrcDocOfCopy, dwAssign); <br>   } <br>   else if (lpOleDoc-&gt;m_lpFileMoniker) { <br> <br>      /* CASE II: this document is a top-level user document (either <br>      **    file-based or untitled). return the FileMoniker stored <br>      **    with the document; it uniquely identifies the document. <br>      */ <br>      // we must AddRef the moniker to pass out a ptr <br>      lpOleDoc-&gt;m_lpFileMoniker-&gt;lpVtbl-&gt;AddRef(lpOleDoc-&gt;m_lpFileMoniker); <br> <br>      lpMoniker = lpOleDoc-&gt;m_lpFileMoniker; <br>   } <br> <br>#if defined( OLE_SERVER ) <br> <br>   else if (((LPSERVERDOC)lpOleDoc)-&gt;m_lpOleClientSite) { <br> <br>      /* CASE III: this document is an embedded object, ask our <br>      **    container for our moniker. <br>      */ <br>      OLEDBG_BEGIN2("IOleClientSite::GetMoniker called\r\n"); <br>      ((LPSERVERDOC)lpOleDoc)-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;GetMoniker( <br>            ((LPSERVERDOC)lpOleDoc)-&gt;m_lpOleClientSite, <br>            dwAssign, <br>            OLEWHICHMK_OBJFULL, <br>            &amp;lpMoniker <br>      ); <br>      OLEDBG_END2 <br>   } <br> <br>#endif <br> <br>   else { <br>      lpMoniker = NULL; <br>   } <br> <br>done: <br>   OLEDBG_END3 <br>   return lpMoniker; <br>} <br> <br> <br>/* OleDoc_DocRenamedUpdate <br>** ----------------------- <br>**    Update the documents registration in the running object table (ROT). <br>**    Also inform all embedded OLE objects (container only) and/or psedudo <br>**    objects (server only) that the name of the document has changed. <br>*/ <br>void OleDoc_DocRenamedUpdate(LPOLEDOC lpOleDoc, LPMONIKER lpmkDoc) <br>{ <br>   OLEDBG_BEGIN3("OleDoc_DocRenamedUpdate\r\n") <br> <br>   OleDoc_AddRef(lpOleDoc); <br> <br>   /* NOTE: we must re-register ourselves as running when we <br>   **    get a new moniker assigned (ie. when we are renamed). <br>   */ <br>   OLEDBG_BEGIN3("OleStdRegisterAsRunning called\r\n") <br>   OleStdRegisterAsRunning( <br>         (LPUNKNOWN)&amp;lpOleDoc-&gt;m_Unknown, <br>         lpmkDoc, <br>         &amp;lpOleDoc-&gt;m_dwRegROT <br>   ); <br>   OLEDBG_END3 <br> <br>#if defined( OLE_SERVER ) <br>   { <br>      LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>      LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc; <br> <br>      /* NOTE: inform any linking clients that the document has been <br>      **    renamed. <br>      */ <br>      ServerDoc_SendAdvise ( <br>            lpServerDoc, <br>            OLE_ONRENAME, <br>            lpmkDoc, <br>            0        /* advf -- not relevant here */ <br>      ); <br> <br>      /* NOTE: inform any clients of pseudo objects <br>      **    within our document, that our document's <br>      **    Moniker has changed. <br>      */ <br>      ServerNameTable_InformAllPseudoObjectsDocRenamed( <br>            (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable, lpmkDoc); <br>   } <br>#endif <br>#if defined( OLE_CNTR ) <br>   { <br>      LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br> <br>      /* NOTE: must tell all OLE objects that our container <br>      **    moniker changed. <br>      */ <br>      ContainerDoc_InformAllOleObjectsDocRenamed( <br>            lpContainerDoc, <br>            lpmkDoc <br>      ); <br>   } <br>#endif <br> <br>   OleDoc_Release(lpOleDoc);       // release artificial AddRef above <br>   OLEDBG_END3 <br>} <br> <br> <br> <br>#if defined( OLE_SERVER ) <br> <br>/************************************************************************* <br>** ServerDoc Supprt Functions Used by Server versions <br>*************************************************************************/ <br> <br> <br>/* ServerDoc_PseudoObjLockDoc <br>** -------------------------- <br>**    Add a lock on the Doc on behalf of the PseudoObject. the Doc may not <br>**    close while the Doc exists. <br>** <br>**    when a pseudo object is first created, it calls this method to <br>**    guarantee that the document stays alive (PseudoObj_Init). <br>**    when a pseudo object is destroyed, it call <br>**    ServerDoc_PseudoObjUnlockDoc to release this hold on the document. <br>*/ <br>void ServerDoc_PseudoObjLockDoc(LPSERVERDOC lpServerDoc) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   ULONG cPseudoObj; <br> <br>   cPseudoObj = ++lpServerDoc-&gt;m_cPseudoObj; <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRefCnt3( <br>         "ServerDoc_PseudoObjLockDoc: cPseudoObj++\r\n", <br>         lpServerDoc, <br>         cPseudoObj <br>   ); <br>#endif <br>   OleDoc_Lock(lpOleDoc, TRUE /* fLock */, 0 /* not applicable */); <br>   return; <br>} <br> <br> <br>/* ServerDoc_PseudoObjUnlockDoc <br>** ---------------------------- <br>**    Release the lock on the Doc on behalf of the PseudoObject. if this was <br>**    the last lock on the Doc, then it will shutdown. <br>*/ <br>void ServerDoc_PseudoObjUnlockDoc( <br>      LPSERVERDOC         lpServerDoc, <br>      LPPSEUDOOBJ         lpPseudoObj <br>) <br>{ <br>   ULONG cPseudoObj; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   OLEDBG_BEGIN3("ServerDoc_PseudoObjUnlockDoc\r\n") <br> <br>   /* NOTE: when there are no active pseudo objects in the Doc and <br>   **    the Doc is not visible, and if there are no outstanding locks <br>   **    on the Doc, then this is a "silent update" <br>   **    situation. our Doc is being used programatically by some <br>   **    client; it is NOT accessible to the user because it is <br>   **    NOT visible. thus since all Locks have been released, we <br>   **    will close the document. if the app is only running due <br>   **    to the presence of this document, then the app will now <br>   **    also shut down. <br>   */ <br>   cPseudoObj = --lpServerDoc-&gt;m_cPseudoObj; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz ( <br>         lpServerDoc-&gt;m_cPseudoObj &gt;= 0, <br>         "PseudoObjUnlockDoc called with cPseudoObj == 0" <br>   ); <br> <br>   OleDbgOutRefCnt3( <br>         "ServerDoc_PseudoObjUnlockDoc: cPseudoObj--\r\n", <br>         lpServerDoc, <br>         cPseudoObj <br>   ); <br>#endif <br>   OleDoc_Lock(lpOleDoc, FALSE /* fLock */, TRUE /* fLastUnlockReleases */); <br> <br>   OLEDBG_END3 <br>   return; <br>} <br> <br> <br>/* ServerDoc_GetObject <br>** ------------------- <br>** <br>**    Return a pointer to an object identified by an item string <br>**    (lpszItem). For a server-only app, the object returned will be a <br>**    pseudo object. <br>*/ <br>HRESULT ServerDoc_GetObject( <br>      LPSERVERDOC             lpServerDoc, <br>      LPOLESTR                lpszItem, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObject <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj; <br>   LPSERVERNAMETABLE lpServerNameTable = <br>         (LPSERVERNAMETABLE)((LPOUTLINEDOC)lpServerDoc)-&gt;m_lpNameTable; <br> <br>   *lplpvObject = NULL; <br> <br>   /* Get the PseudoObj which corresponds to an item name. if the item <br>   **    name does NOT exist in the name table then NO object is <br>   **    returned. the ServerNameTable_GetPseudoObj routine finds a <br>   **    name entry corresponding to the item name, it then checks if <br>   **    a PseudoObj has already been allocated. if so, it returns the <br>   **    existing object, otherwise it allocates a new PseudoObj. <br>   */ <br>   lpPseudoObj = ServerNameTable_GetPseudoObj( <br>         lpServerNameTable, <br>         lpszItem, <br>         lpServerDoc <br>   ); <br> <br>   if (! lpPseudoObj) { <br>      *lplpvObject = NULL; <br>      return MK_E_NOOBJECT; <br>   } <br> <br>   // return the desired interface pointer of the pseudo object. <br>   return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObject); <br>} <br> <br> <br>/* ServerDoc_IsRunning <br>** ------------------- <br>** <br>**    Check if the object identified by an item string (lpszItem) is in <br>**    the running state. For a server-only app, if the item name exists in <br>**    in the NameTable then the item name is considered running. <br>**    IOleItemContainer::GetObject would succeed. <br>*/ <br> <br>HRESULT ServerDoc_IsRunning(LPSERVERDOC lpServerDoc, LPOLESTR lpszItem) </code></pre>
<p>
</p>
<pre><code>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>         ((LPOUTLINEDOC)lpServerDoc)-&gt;m_lpNameTable; <br>   LPSERVERNAME lpServerName; <br> <br>   lpServerName = (LPSERVERNAME)OutlineNameTable_FindName( <br>         lpOutlineNameTable, <br>         lpszItem <br>   ); <br> <br>   if (lpServerName) <br>      return NOERROR; <br>   else <br>      return MK_E_NOOBJECT; <br>} <br> <br> <br>/* ServerDoc_GetSelRelMoniker <br>** -------------------------- <br>**    Retrieve the relative item moniker which identifies the given <br>**    selection (lplrSel). <br>** <br>**    Returns NULL if a moniker can NOT be created. <br>*/ <br> <br>LPMONIKER ServerDoc_GetSelRelMoniker( <br>      LPSERVERDOC             lpServerDoc, <br>      LPLINERANGE             lplrSel, <br>      DWORD                   dwAssign <br>) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERNAMETABLE lpServerNameTable = <br>         (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable; <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>         (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPOUTLINENAME lpOutlineName; <br>   LPMONIKER lpmk; <br> <br>   lpOutlineName=OutlineNameTable_FindNamedRange(lpOutlineNameTable,lplrSel); <br> <br>   if (lpOutlineName) { <br>      /* the selection range already has a name assigned */ <br>      CreateItemMoniker(OLESTR("\\"), lpOutlineName-&gt;m_szName, &amp;lpmk); <br>   } else { <br>      char szbuf[MAXNAMESIZE]; <br>      OLECHAR szUniBuf[MAXNAMESIZE]; <br> <br>      switch (dwAssign) { <br> <br>         case GETMONIKER_FORCEASSIGN: <br> <br>            /* Force the assignment of the name. This is called when a <br>            **    Paste Link actually occurs. At this point we want to <br>            **    create a Name and add it to the NameTable in order to <br>            **    track the source of the link. This name (as all <br>            **    names) will be updated upon editing of the document. <br>            */ <br>            wsprintf( <br>                  szbuf, <br>                  "%s %ld", <br>                  (LPSTR)DEFRANGENAMEPREFIX, <br>                  ++(lpServerDoc-&gt;m_nNextRangeNo) <br>            ); <br> <br>            lpOutlineName = OutlineApp_CreateName(lpOutlineApp); <br> <br>            if (lpOutlineName) { <br>               A2W (szbuf, lpOutlineName-&gt;m_szName, OLEUI_CCHPATHMAX); <br>               lpOutlineName-&gt;m_nStartLine = lplrSel-&gt;m_nStartLine; <br>               lpOutlineName-&gt;m_nEndLine = lplrSel-&gt;m_nEndLine; <br>               OutlineDoc_AddName(lpOutlineDoc, lpOutlineName); <br>            } else { <br>               // REVIEW: do we need "Out-of-Memory" error message here? <br>            } <br>            break; <br> <br>         case GETMONIKER_TEMPFORUSER: <br> <br>            /* Create a name to show to the user in the Paste <br>            **    Special dialog but do NOT yet incur the overhead <br>            **    of adding a Name to the NameTable. The Moniker <br>            **    generated should be useful to display to the user <br>            **    to indicate the source of the copy, but will NOT <br>            **    be used to create a link directly (the caller <br>            **    should ask again for a moniker specifying FORCEASSIGN). <br>            **    we will generate the name that would be the next <br>            **    auto-generated range name, BUT will NOT actually <br>            **    increment the range counter. <br>            */ <br>            wsprintf( <br>                  szbuf, <br>                  "%s %ld", <br>                  (LPSTR)DEFRANGENAMEPREFIX, <br>                  (lpServerDoc-&gt;m_nNextRangeNo)+1 <br>            ); <br>            break; <br> <br>         case GETMONIKER_ONLYIFTHERE: <br> <br>            /* the caller only wants a name if one has already been <br>            **    assigned. we have already above checked if the <br>            **    current selection has a name, so we will simply <br>            **    return NULL here. <br>            */ <br>            return NULL;    // no moniker is assigned <br> <br>         default: <br>            return NULL;    // unknown flag given <br>      } <br> <br>      A2W (szbuf, szUniBuf, MAXNAMESIZE); <br>      CreateItemMoniker(OLESTR("\\"), szUniBuf, &amp;lpmk); <br>   } <br> <br>   return lpmk; <br>} <br> <br> <br>/* ServerDoc_GetSelFullMoniker <br>** --------------------------- <br>**    Retrieve the full absolute moniker which identifies the given <br>**    selection (lplrSel). <br>**    this moniker is created as a composite of the absolute moniker for <br>**    the entire document appended with an item moniker which identifies <br>**    the selection relative to the document. <br>**    Returns NULL if a moniker can NOT be created. <br>*/ <br>LPMONIKER ServerDoc_GetSelFullMoniker( <br>      LPSERVERDOC             lpServerDoc, <br>      LPLINERANGE             lplrSel, <br>      DWORD                   dwAssign <br>) <br>{ <br>   LPMONIKER lpmkDoc = NULL; <br>   LPMONIKER lpmkItem = NULL; <br>   LPMONIKER lpmkFull = NULL; <br> <br>   lpmkDoc = OleDoc_GetFullMoniker( <br>         (LPOLEDOC)lpServerDoc, <br>         dwAssign <br>   ); <br>   if (! lpmkDoc) return NULL; <br> <br>   lpmkItem = ServerDoc_GetSelRelMoniker( <br>         lpServerDoc, <br>         lplrSel, <br>         dwAssign <br>   ); <br>   if (lpmkItem) { <br>      CreateGenericComposite(lpmkDoc, lpmkItem, (LPMONIKER FAR*)&amp;lpmkFull); <br>      OleStdRelease((LPUNKNOWN)lpmkItem); <br>   } <br> <br>   if (lpmkDoc) <br>      OleStdRelease((LPUNKNOWN)lpmkDoc); <br> <br>   return lpmkFull; <br>} <br> <br> <br>/* ServerNameTable_EditLineUpdate <br> * ------------------------------- <br> * <br> *      Update the table when a line at nEditIndex is edited. <br> */ <br>void ServerNameTable_EditLineUpdate( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      int                     nEditIndex <br>) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>                              (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPOUTLINENAME lpOutlineName; <br>   LINERANGE lrSel; <br>   LPPSEUDOOBJ lpPseudoObj; <br>   int i; <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br> <br>      lpPseudoObj = ((LPSERVERNAME)lpOutlineName)-&gt;m_lpPseudoObj; <br> <br>      /* if there is a pseudo object associated with this name, then <br>      **    check if the line that was modified is included within <br>      **    the named range. <br>      */ <br>      if (lpPseudoObj) { <br>         OutlineName_GetSel(lpOutlineName, &amp;lrSel); <br> <br>         if(((int)lrSel.m_nStartLine &lt;= nEditIndex) &amp;&amp; <br>            ((int)lrSel.m_nEndLine &gt;= nEditIndex)) { <br> <br>            // inform linking clients data has changed <br>            PseudoObj_SendAdvise( <br>                  lpPseudoObj, <br>                  OLE_ONDATACHANGE, <br>                  NULL,   /* lpmkDoc -- not relevant here */ <br>                  0       /* advf -- no flags necessary */ <br>            ); <br>         } <br> <br>      } <br>   } <br>} <br> <br> <br>/* ServerNameTable_InformAllPseudoObjectsDocRenamed <br> * ------------------------------------------------ <br> * <br> *      Inform all pseudo object clients that the name of the pseudo <br> *      object has changed. <br> */ <br>void ServerNameTable_InformAllPseudoObjectsDocRenamed( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPMONIKER               lpmkDoc <br>) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>                              (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPOUTLINENAME lpOutlineName; <br>   LPPSEUDOOBJ lpPseudoObj; <br>   LPMONIKER lpmkObj; <br>   int i; <br> <br>   OLEDBG_BEGIN2("ServerNameTable_InformAllPseudoObjectsDocRenamed\r\n"); <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br> <br>      lpPseudoObj = ((LPSERVERNAME)lpOutlineName)-&gt;m_lpPseudoObj; <br> <br>      /* if there is a pseudo object associated with this name, then <br>      **    send OnRename advise to its linking clients. <br>      */ <br>      if (lpPseudoObj &amp;&amp; <br>         ((lpmkObj=PseudoObj_GetFullMoniker(lpPseudoObj,lpmkDoc))!=NULL)) { <br> <br>         // inform the clients that the name has changed <br>         PseudoObj_SendAdvise ( <br>               lpPseudoObj, <br>               OLE_ONRENAME, <br>               lpmkObj, <br>               0           /* advf -- not relevant here */ <br>         ); <br>      } <br>   } <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ServerNameTable_InformAllPseudoObjectsDocSaved <br> * ------------------------------------------------ <br> * <br> *      Inform all pseudo object clients that the name of the pseudo <br> *      object has changed. <br> */ <br>void ServerNameTable_InformAllPseudoObjectsDocSaved( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPMONIKER               lpmkDoc <br>) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>                              (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPOUTLINENAME lpOutlineName; <br>   LPPSEUDOOBJ lpPseudoObj; <br>   LPMONIKER lpmkObj; <br>   int i; <br> <br>   OLEDBG_BEGIN2("ServerNameTable_InformAllPseudoObjectsDocSaved\r\n"); <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i); <br> <br>      lpPseudoObj = ((LPSERVERNAME)lpOutlineName)-&gt;m_lpPseudoObj; <br> <br>      /* if there is a pseudo object associated with this name, then <br>      **    send OnSave advise to its linking clients. <br>      */ <br>      if (lpPseudoObj &amp;&amp; <br>         ((lpmkObj=PseudoObj_GetFullMoniker(lpPseudoObj,lpmkDoc))!=NULL)) { <br> <br>         // inform the clients that the name has been saved <br>         PseudoObj_SendAdvise ( <br>               lpPseudoObj, <br>               OLE_ONSAVE, <br>               NULL,   /* lpmkDoc -- not relevant here */ <br>               0       /* advf -- not relevant here */ <br>         ); <br>      } <br>   } <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ServerNameTable_SendPendingAdvises <br> * ---------------------------------- <br> * <br> *      Send any pending change notifications for pseudo objects. <br> *  while ReDraw is diabled on the ServerDoc, then change advise <br> *  notifications are not sent to pseudo object clients. <br> */ <br>void ServerNameTable_SendPendingAdvises(LPSERVERNAMETABLE lpServerNameTable) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>                              (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPSERVERNAME lpServerName; <br>   int i; <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpServerName = (LPSERVERNAME)OutlineNameTable_GetName( <br>            lpOutlineNameTable, <br>            i <br>      ); <br>      ServerName_SendPendingAdvises(lpServerName); <br>   } <br>} <br> <br> <br>/* ServerNameTable_GetPseudoObj <br>** ---------------------------- <br>** <br>**    Return a pointer to a pseudo object identified by an item string <br>**    (lpszItem). if the pseudo object already exists, then return the <br>**    existing object, otherwise allocate a new pseudo object. <br>*/ <br>LPPSEUDOOBJ ServerNameTable_GetPseudoObj( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPOLESTR                lpszItem, <br>      LPSERVERDOC             lpServerDoc <br>) <br>{ <br>   LPSERVERNAME lpServerName; <br> <br>   lpServerName = (LPSERVERNAME)OutlineNameTable_FindName( <br>         (LPOUTLINENAMETABLE)lpServerNameTable, <br>         lpszItem <br>   ); <br> <br>   if (lpServerName) <br>      return ServerName_GetPseudoObj(lpServerName, lpServerDoc); <br>   else <br>      return NULL; <br>} <br> <br> <br>/* ServerNameTable_CloseAllPseudoObjs <br> * ---------------------------------- <br> * <br> *  Force all pseudo objects to close. this results in sending OnClose <br> *  notification to each pseudo object's linking clients. <br> */ <br>void ServerNameTable_CloseAllPseudoObjs(LPSERVERNAMETABLE lpServerNameTable) <br>{ <br>   LPOUTLINENAMETABLE lpOutlineNameTable = <br>                              (LPOUTLINENAMETABLE)lpServerNameTable; <br>   LPSERVERNAME lpServerName; <br>   int i; <br> <br>   OLEDBG_BEGIN3("ServerNameTable_CloseAllPseudoObjs\r\n") <br> <br>   for(i = 0; i &lt; lpOutlineNameTable-&gt;m_nCount; i++) { <br>      lpServerName = (LPSERVERNAME)OutlineNameTable_GetName( <br>            lpOutlineNameTable, <br>            i <br>      ); <br>        ServerName_ClosePseudoObj(lpServerName); <br>   } <br> <br>   OLEDBG_END3 <br>} <br> <br> <br> <br>/* ServerName_SetSel <br> * ----------------- <br> * <br> *      Change the line range of a  name. <br> */ <br>void ServerName_SetSel( <br>      LPSERVERNAME            lpServerName, <br>      LPLINERANGE             lplrSel, <br>      BOOL                    fRangeModified <br>) <br>{ <br>   LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpServerName; <br>   BOOL fPseudoObjChanged = fRangeModified; <br> <br>   if (lpOutlineName-&gt;m_nStartLine != lplrSel-&gt;m_nStartLine) { <br>      lpOutlineName-&gt;m_nStartLine = lplrSel-&gt;m_nStartLine; <br>      fPseudoObjChanged = TRUE; <br>   } <br> <br>   if (lpOutlineName-&gt;m_nEndLine != lplrSel-&gt;m_nEndLine) { <br>      lpOutlineName-&gt;m_nEndLine = lplrSel-&gt;m_nEndLine; <br>      fPseudoObjChanged = TRUE; <br>   } <br> <br>   /* NOTE: if the range of an active pseudo object has <br>   **    changed, then inform any linking clients that the object <br>   **    has changed. <br>   */ <br>   if (lpServerName-&gt;m_lpPseudoObj &amp;&amp; fPseudoObjChanged) { <br>      PseudoObj_SendAdvise( <br>            lpServerName-&gt;m_lpPseudoObj, <br>            OLE_ONDATACHANGE, <br>            NULL,   /* lpmkDoc -- not relevant here */ <br>            0       /* advf -- no flags necessary */ <br>      ); <br>   } <br>} <br> <br> <br>/* ServerName_SendPendingAdvises <br> * ----------------------------- <br> * <br> *      Send any pending change notifications for the associated <br> *  pseudo objects for this name (if one exists). <br> *  while ReDraw is diabled on the ServerDoc, then change advise <br> *  notifications are not sent to pseudo object clients. <br> */ <br>void ServerName_SendPendingAdvises(LPSERVERNAME lpServerName) <br>{ <br>   if (! lpServerName-&gt;m_lpPseudoObj) <br>      return;     // no associated pseudo object <br> <br>   if (lpServerName-&gt;m_lpPseudoObj-&gt;m_fDataChanged) <br>      PseudoObj_SendAdvise( <br>            lpServerName-&gt;m_lpPseudoObj, <br>            OLE_ONDATACHANGE, <br>            NULL,   /* lpmkDoc -- not relevant here */ <br>            0       /* advf -- no flags necessary */ <br>      ); <br>} <br> <br> <br>/* ServerName_GetPseudoObj <br>** ----------------------- <br>** <br>**    Return a pointer to a pseudo object associated to a ServerName. <br>**    if the pseudo object already exists, then return the <br>**    existing object, otherwise allocate a new pseudo object. <br>** <br>**    NOTE: the PseudoObj is returned with a 0 refcnt if first created, <br>**    else the existing refcnt is unchanged. <br>*/ <br>LPPSEUDOOBJ ServerName_GetPseudoObj( <br>      LPSERVERNAME            lpServerName, <br>      LPSERVERDOC             lpServerDoc <br>) <br>{ <br>   // Check if a PseudoObj already exists <br>   if (lpServerName-&gt;m_lpPseudoObj) <br>      return lpServerName-&gt;m_lpPseudoObj; <br> <br>   // A PseudoObj does NOT already exist, allocate a new one. <br>   lpServerName-&gt;m_lpPseudoObj=(LPPSEUDOOBJ) New((DWORD)sizeof(PSEUDOOBJ)); <br>   if (lpServerName-&gt;m_lpPseudoObj == NULL) { <br>      OleDbgAssertSz(lpServerName-&gt;m_lpPseudoObj != NULL,   "Error allocating PseudoObj"); <br>      return NULL; <br>   } <br> <br>   PseudoObj_Init(lpServerName-&gt;m_lpPseudoObj, lpServerName, lpServerDoc); <br>   return lpServerName-&gt;m_lpPseudoObj; <br>} <br> <br> <br>/* ServerName_ClosePseudoObj <br> * ------------------------- <br> * <br> *      if there is an associated pseudo objects for this name (if one <br> *  exists), then close it. this results in sending OnClose <br> *  notification to the pseudo object's linking clients. <br> */ <br>void ServerName_ClosePseudoObj(LPSERVERNAME lpServerName) <br>{ <br>   if (!lpServerName || !lpServerName-&gt;m_lpPseudoObj) <br>      return;     // no associated pseudo object <br> <br>   PseudoObj_Close(lpServerName-&gt;m_lpPseudoObj); <br>} <br> <br> <br>#endif  // OLE_SERVER <br> <br> <br>#if defined( OLE_CNTR ) <br> <br> <br>/************************************************************************* <br>** ContainerDoc Supprt Functions Used by Container versions <br>*************************************************************************/ <br> <br> <br>/* ContainerLine_GetRelMoniker <br>** --------------------------- <br>**    Retrieve the relative item moniker which identifies the OLE object <br>**    relative to the container document. <br>** <br>**    Returns NULL if a moniker can NOT be created. <br>*/ <br>LPMONIKER ContainerLine_GetRelMoniker( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwAssign <br>) <br>{ <br>   LPMONIKER lpmk = NULL; <br> <br>   /* NOTE: we should only give out a moniker for the OLE object <br>   **    if the object is allowed to be linked to from the inside. if <br>   **    so we are allowed to give out a moniker which binds to the <br>   **    running OLE object). if the object is an OLE 2.0 embedded <br>   **    object then it is allowed to be linked to from the inside. if <br>   **    the object is either an OleLink or an OLE 1.0 embedding <br>   **    then it can not be linked to from the inside. <br>   **    if we were a container/server app then we could offer linking <br>   **    to the outside of the object (ie. a pseudo object within our <br>   **    document). we are a container only app that does not support <br>   **    linking to ranges of its data. <br>   */ <br> <br>   switch (dwAssign) { <br> <br>      case GETMONIKER_FORCEASSIGN: <br> <br>            /* Force the assignment of the name. This is called when a <br>            **    Paste Link actually occurs. From now on we want <br>            **    to inform the OLE object that its moniker is <br>            **    assigned and is thus necessary to register itself <br>            **    in the RunningObjectTable. <br>            */ <br>            CreateItemMoniker( <br>                  OLESTR("\\"), lpContainerLine-&gt;m_szStgName, &amp;lpmk); <br> <br>            /* NOTE: if the OLE object is already loaded and it <br>            **    is being assigned a moniker for the first time, <br>            **    then we need to inform it that it now has a moniker <br>            **    assigned by calling IOleObject::SetMoniker. this <br>            **    will force the OLE object to register in the <br>            **    RunningObjectTable when it enters the running <br>            **    state. if the object is not currently loaded, <br>            **    SetMoniker will be called automatically later when <br>            **    the object is loaded by the function <br>            **    ContainerLine_LoadOleObject. <br>            */ <br>            if (! lpContainerLine-&gt;m_fMonikerAssigned) { <br> <br>               /* we must remember forever more that this object has a <br>               **    moniker assigned. <br>               */ <br>               lpContainerLine-&gt;m_fMonikerAssigned = TRUE; <br> <br>               // we are now dirty and must be saved <br>               OutlineDoc_SetModified( <br>                     (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc, <br>                     TRUE,   /* fModified */ <br>                     FALSE,  /* fDataChanged--N/A for container ver. */ <br>                     FALSE   /* fSizeChanged--N/A for container ver. */ <br>               ); <br> <br>               if (lpContainerLine-&gt;m_lpOleObj) { <br>                  OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n") <br>                  lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetMoniker( <br>                        lpContainerLine-&gt;m_lpOleObj, <br>                        OLEWHICHMK_OBJREL, <br>                        lpmk <br>                  ); <br>                  OLEDBG_END2 <br>               } <br>            } <br>            break; <br> <br>      case GETMONIKER_ONLYIFTHERE: <br> <br>            /* If the OLE object currently has a moniker assigned, <br>            **    then return it. <br>            */ <br>            if (lpContainerLine-&gt;m_fMonikerAssigned) { <br>               CreateItemMoniker( <br>                     OLESTR("\\"), <br>                     lpContainerLine-&gt;m_szStgName, <br>                     &amp;lpmk <br>               ); <br>            } <br>            break; <br> <br>      case GETMONIKER_TEMPFORUSER: <br> <br>            /* Return the moniker that would be used for the OLE <br>            **    object but do NOT force moniker assignment at <br>            **    this point. Since our strategy is to use the <br>            **    storage name of the object as its item name, we <br>            **    can simply create the corresponding ItemMoniker <br>            **    (indepenedent of whether the moniker is currently <br>            **    assigned or not). <br>            */ <br>            CreateItemMoniker( <br>                  OLESTR("\\"), <br>                  lpContainerLine-&gt;m_szStgName, <br>                  &amp;lpmk <br>            ); <br>            break; <br> <br>      case GETMONIKER_UNASSIGN: <br> <br>            lpContainerLine-&gt;m_fMonikerAssigned = FALSE; <br>            break; <br> <br>   } <br> <br>   return lpmk; <br>} <br> <br> <br>/* ContainerLine_GetFullMoniker <br>** ---------------------------- <br>**    Retrieve the full absolute moniker which identifies the OLE object <br>**    in the container document. <br>**    this moniker is created as a composite of the absolute moniker for <br>**    the entire document appended with an item moniker which identifies <br>**    the OLE object relative to the document. <br>**    Returns NULL if a moniker can NOT be created. <br>*/ <br>LPMONIKER ContainerLine_GetFullMoniker( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwAssign <br>) <br>{ <br>   LPMONIKER lpmkDoc = NULL; <br>   LPMONIKER lpmkItem = NULL; <br>   LPMONIKER lpmkFull = NULL; <br> <br>   lpmkDoc = OleDoc_GetFullMoniker( <br>         (LPOLEDOC)lpContainerLine-&gt;m_lpDoc, <br>         dwAssign <br>   ); <br>   if (! lpmkDoc) <br>   { <br>       return NULL; <br>   } <br>   lpmkItem = ContainerLine_GetRelMoniker(lpContainerLine, dwAssign); <br> <br>   if (lpmkItem) { <br>      CreateGenericComposite(lpmkDoc, lpmkItem, (LPMONIKER FAR*)&amp;lpmkFull); <br>      OleStdRelease((LPUNKNOWN)lpmkItem); <br>   } <br> <br>   if (lpmkDoc) <br>      OleStdRelease((LPUNKNOWN)lpmkDoc); <br> <br>   return lpmkFull; <br>} <br> <br> <br>/* ContainerDoc_InformAllOleObjectsDocRenamed <br>** ------------------------------------------ <br>**    Inform all OLE objects that the name of the ContainerDoc has changed. <br>*/ <br>void ContainerDoc_InformAllOleObjectsDocRenamed( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPMONIKER               lpmkDoc <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int i; <br>   LPLINE lpLine; <br> <br>   // artificial AddRef in case someone releases object during call <br>   OleDoc_AddRef((LPOLEDOC)lpContainerDoc); <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         /* NOTE: if the OLE object is already loaded AND the <br>         **    object already has a moniker assigned, then we need <br>         **    to inform it that the moniker of the ContainerDoc has <br>         **    changed. of course, this means the full moniker of <br>         **    the object has changed. to do this we call <br>         **    IOleObject::SetMoniker. this will force the OLE <br>         **    object to re-register in the RunningObjectTable if it <br>         **    is currently in the running state. it is not in the <br>         **    running state, the object handler can make not that <br>         **    the object has a new moniker. if the object is not <br>         **    currently loaded, SetMoniker will be called <br>         **    automatically later when the object is loaded by the <br>         **    function ContainerLine_LoadOleObject. <br>         **    also if the object is a linked object, we always want <br>         **    to call SetMoniker on the link so that in case the <br>         **    link source is contained within our same container, <br>         **    the link source will be tracked. the link rebuilds <br>         **    its absolute moniker if it has a relative moniker. <br>         */ <br>         if (lpContainerLine-&gt;m_lpOleObj) { <br>            if (lpContainerLine-&gt;m_fMonikerAssigned || <br>               lpContainerLine-&gt;m_dwLinkType != 0) { <br>               OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n") <br>               lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetMoniker( <br>                     lpContainerLine-&gt;m_lpOleObj, <br>                     OLEWHICHMK_CONTAINER, <br>                     lpmkDoc <br>               ); <br>               OLEDBG_END2 <br>            } <br> <br>            /* NOTE: we must call IOleObject::SetHostNames so <br>            **    any open objects can update their window titles. <br>            */ <br>            OLEDBG_BEGIN2("IOleObject::SetHostNames called\r\n") <br>            lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetHostNames( <br>                  lpContainerLine-&gt;m_lpOleObj, <br>                  /*(LPOLESTR)*/APPNAME, <br>                  ((LPOUTLINEDOC)lpContainerDoc)-&gt;m_lpszDocTitle <br>            ); <br>            OLEDBG_END2 <br>         } <br>      } <br>   } <br>   // release artificial AddRef <br>   OleDoc_Release((LPOLEDOC)lpContainerDoc); <br>} <br> <br> <br>/* ContainerDoc_GetObject <br>** ---------------------- <br>**    Return a pointer to the desired interface of an object identified <br>**    by an item string (lpszItem). the object returned will be an OLE <br>**    object (either link or embedding). <br>** <br>**      NOTE: we must force the object to run because we are <br>**          REQUIRED to return a pointer the OLE object in the <br>**          RUNNING state. <br>** <br>**    dwSpeedNeeded indicates how long the caller is willing <br>**    to wait for us to get the object: <br>**      BINDSPEED_IMMEDIATE -- only if obj already loaded &amp;&amp; IsRunning <br>**      BINDSPEED_MODERATE  -- load obj if necessary &amp;&amp; if IsRunning <br>**      BINDSPEED_INDEFINITE-- force obj to load and run if necessary <br>*/ <br>HRESULT ContainerDoc_GetObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszItem, <br>      DWORD                   dwSpeedNeeded, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObject <br>) <br>{ <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int         i; <br>   LPLINE      lpLine; <br>   BOOL        fMatchFound = FALSE; <br>   DWORD       dwStatus; <br>   HRESULT     hrErr; <br> <br>   *lplpvObject = NULL; <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         if (OLESTRCMP(lpContainerLine-&gt;m_szStgName, lpszItem) == 0) { <br> <br>            fMatchFound = TRUE;     // valid item name <br> <br>            // check if object is loaded. <br>            if (lpContainerLine-&gt;m_lpOleObj == NULL) { <br> <br>               // if BINDSPEED_IMMEDIATE is requested, object must <br>               // ALREADY be loadded. <br>               if (dwSpeedNeeded == BINDSPEED_IMMEDIATE) <br>                  return MK_E_EXCEEDEDDEADLINE; <br> <br>               ContainerLine_LoadOleObject(lpContainerLine); <br>               if (! lpContainerLine-&gt;m_lpOleObj) <br>                  return E_OUTOFMEMORY; <br>            } <br> <br>            /* NOTE: check if the object is allowed to be linked <br>            **    to from the inside (ie. we are allowed to <br>            **    give out a moniker which binds to the running <br>            **    OLE object). if the object is an OLE <br>            **    2.0 embedded object then it is allowed to be <br>            **    linked to from the inside. if the object is <br>            **    either an OleLink or an OLE 1.0 embedding <br>            **    then it can not be linked to from the inside. <br>            **    if we were a container/server app then we <br>            **    could offer linking to the outside of the <br>            **    object (ie. a pseudo object within our <br>            **    document). we are a container only app that <br>            **    does not support linking to ranges of its data. <br>            */ <br>            OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n"); <br>            lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>                  lpContainerLine-&gt;m_lpOleObj, <br>                  DVASPECT_CONTENT, /* aspect is not important */ <br>                  (LPDWORD)&amp;dwStatus <br>            ); <br>            OLEDBG_END2 <br>            if (dwStatus &amp; OLEMISC_CANTLINKINSIDE) <br>            { <br>               return MK_E_NOOBJECT; <br>            } <br> <br>            // check if object is running. <br>            if (! OleIsRunning(lpContainerLine-&gt;m_lpOleObj)) { <br> <br>               // if BINDSPEED_MODERATE is requested, object must <br>               // ALREADY be running. <br>               if (dwSpeedNeeded == BINDSPEED_MODERATE) <br>               { <br>                  return MK_E_EXCEEDEDDEADLINE; <br>               } <br> <br>               /* NOTE: we have found a match for the item name. <br>               **    now we must return a pointer to the desired <br>               **    interface on the RUNNING object. we must <br>               **    carefully load the object and initially ask for <br>               **    an interface that we are sure the loaded form of <br>               **    the object supports. if we immediately ask the <br>               **    loaded object for the desired interface, the <br>               **    QueryInterface call might fail if it is an <br>               **    interface that is supported only when the object <br>               **    is running. thus we force the object to load and <br>               **    return its IUnknown*. then we force the object to <br>               **    run, and then finally, we can ask for the <br>               **    actually requested interface. <br>               */ <br>               hrErr = ContainerLine_RunOleObject(lpContainerLine); <br>               if (hrErr != NOERROR) { <br>                  return hrErr; <br>               } <br>            } <br> <br>            // Retrieve the requested interface <br>            *lplpvObject = OleStdQueryInterface( <br>                  (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, riid); <br> <br>            break;  // Match FOUND! <br>         } <br>      } <br>   } <br> <br>   if (*lplpvObject != NULL) { <br>      return NOERROR; <br>   } else <br>   { <br>      return (fMatchFound ? E_NOINTERFACE <br>                     : MK_E_NOOBJECT); <br>   } <br>} <br> <br> <br>/* ContainerDoc_GetObjectStorage </code></pre>
<p>
</p>
<pre><code>** ----------------------------- <br>**    Return a pointer to the IStorage* used by the object identified <br>**    by an item string (lpszItem). the object identified could be either <br>**    an OLE object (either link or embedding). <br>*/ <br>HRESULT ContainerDoc_GetObjectStorage( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszItem, <br>      LPSTORAGE FAR*          lplpStg <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int i; <br>   LPLINE lpLine; <br> <br>   *lplpStg = NULL; <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         if (OLESTRCMP(lpContainerLine-&gt;m_szStgName, lpszItem) == 0) { <br> <br>            *lplpStg = lpContainerLine-&gt;m_lpStg; <br>            break;  // Match FOUND! <br>         } <br>      } <br>   } <br> <br>   if (*lplpStg != NULL) { <br>      return NOERROR; <br>   } else <br>   { <br>      return MK_E_NOOBJECT; <br>   } <br>} <br> <br> <br>/* ContainerDoc_IsRunning <br>** ---------------------- <br>**    Check if the object identified by an item string (lpszItem) is in <br>**    the running state. <br>**    For a container-only app, a check is made if the OLE object <br>**    associated with the item name is running. <br>*/ <br>HRESULT ContainerDoc_IsRunning(LPCONTAINERDOC   lpContainerDoc, LPOLESTR lpszItem) <br>{ <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int         i; <br>   LPLINE      lpLine; <br>   DWORD       dwStatus; <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         if (OLESTRCPY(lpContainerLine-&gt;m_szStgName, lpszItem) == 0) { <br> <br>            /* NOTE: we have found a match for the item name. <br>            **    now we must check if the OLE object is running. <br>            **    we will load the object if not already loaded. <br>            */ <br>            if (! lpContainerLine-&gt;m_lpOleObj) { <br>               ContainerLine_LoadOleObject(lpContainerLine); <br>               if (! lpContainerLine-&gt;m_lpOleObj) <br>                  return E_OUTOFMEMORY; <br>            } <br> <br>            /* NOTE: check if the object is allowed to be linked <br>            **    to from the inside (ie. we are allowed to <br>            **    give out a moniker which binds to the running <br>            **    OLE object). if the object is an OLE <br>            **    2.0 embedded object then it is allowed to be <br>            **    linked to from the inside. if the object is <br>            **    either an OleLink or an OLE 1.0 embedding <br>            **    then it can not be linked to from the inside. <br>            **    if we were a container/server app then we <br>            **    could offer linking to the outside of the <br>            **    object (ie. a pseudo object within our <br>            **    document). we are a container only app that <br>            **    does not support linking to ranges of its data. <br>            */ <br>            OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n") <br>            lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>                  lpContainerLine-&gt;m_lpOleObj, <br>                  DVASPECT_CONTENT, /* aspect is not important */ <br>                  (LPDWORD)&amp;dwStatus <br>            ); <br>            OLEDBG_END2 <br>            if (dwStatus &amp; OLEMISC_CANTLINKINSIDE) <br>            { <br>               return MK_E_NOOBJECT; <br>            } <br> <br>            if (OleIsRunning(lpContainerLine-&gt;m_lpOleObj)) <br>            { <br>               return NOERROR; <br>            } <br>            else <br>            { <br>               return S_FALSE; <br>            } <br>         } <br>      } <br>   } <br>   // no object was found corresponding to the item name <br>   return MK_E_NOOBJECT; <br>} <br> <br>#endif  // OLE_CNTR </code></pre>
<p>&nbsp;</p></body>
</HTML>
