<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CNTRBASE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context273"></a>CNTRBASE.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Container Sample Code <br>** <br>**    cntrbase.c <br>** <br>**    This file contains all interfaces, methods and related support <br>**    functions for the basic OLE Container application. The <br>**    basic OLE Container application supports being a container for <br>**    embedded and linked objects. <br>**    The basic Container application includes the following <br>**    implementation objects: <br>** <br>**    ContainerDoc Object <br>**      no required interfaces for basic functionality <br>**      (see linking.c for linking related support) <br>**      (see clipbrd.c for clipboard related support) <br>**      (see dragdrop.c for drag/drop related support) <br>** <br>**    ContainerLine Object <br>**    (see cntrline.c for all ContainerLine functions and interfaces) <br>**      exposed interfaces: <br>**          IOleClientSite <br>**          IAdviseSink <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br> <br>OLEDBGDATA <br> <br> <br>extern LPOUTLINEAPP             g_lpApp; <br>extern IOleUILinkContainerVtbl  g_CntrDoc_OleUILinkContainerVtbl; <br> <br>#if defined( INPLACE_CNTR ) <br>extern BOOL g_fInsideOutContainer; <br>#endif  // INPLACE_CNTR <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR ErrMsgShowObj[] = OLESTR("Could not show object server!"); <br>OLECHAR ErrMsgInsertObj[] = OLESTR("Insert Object failed!"); <br>OLECHAR ErrMsgConvertObj[] = OLESTR("Convert Object failed!"); <br>OLECHAR ErrMsgCantConvert[] = OLESTR("Unable to convert the selection!"); <br>OLECHAR ErrMsgActivateAsObj[] = OLESTR("Activate As Object failed!"); <br> <br>extern OLECHAR ErrMsgSaving[]; <br>extern OLECHAR ErrMsgOpening[]; <br> <br> <br>/* ContainerDoc_Init <br> * ----------------- <br> * <br> *  Initialize the fields of a new ContainerDoc object. The doc is initially <br> *  not associated with a file or an (Untitled) document. This function sets <br> *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the <br> *  caller should call: <br> *      1.) Doc_InitNewFile to set the ContainerDoc to (Untitled) <br> *      2.) Doc_LoadFromFile to associate the ContainerDoc with a file. <br> *  This function creates a new window for the document. <br> * <br> *  NOTE: the window is initially created with a NIL size. it must be <br> *        sized and positioned by the caller. also the document is initially <br> *        created invisible. the caller must call Doc_ShowWindow <br> *        after sizing it to make the document window visible. <br> */ <br>BOOL ContainerDoc_Init(LPCONTAINERDOC lpContainerDoc, BOOL fDataTransferDoc) <br>{ <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br> <br>   lpOutlineDoc-&gt;m_cfSaveFormat             = lpContainerApp-&gt;m_cfCntrOutl; <br>   lpContainerDoc-&gt;m_nNextObjNo            = 0L; <br>   lpContainerDoc-&gt;m_lpNewStg              = NULL; <br>   lpContainerDoc-&gt;m_fEmbeddedObjectAvail  = FALSE; <br>   lpContainerDoc-&gt;m_clsidOleObjCopied     = CLSID_NULL; <br>   lpContainerDoc-&gt;m_dwAspectOleObjCopied  = DVASPECT_CONTENT; <br>   lpContainerDoc-&gt;m_lpSrcContainerLine    = NULL; <br>   lpContainerDoc-&gt;m_fShowObject           = TRUE; <br> <br>#if defined( INPLACE_CNTR ) <br>   lpContainerDoc-&gt;m_lpLastIpActiveLine    = NULL; <br>   lpContainerDoc-&gt;m_lpLastUIActiveLine    = NULL; <br>   lpContainerDoc-&gt;m_hWndUIActiveObj       = NULL; <br>   lpContainerDoc-&gt;m_fAddMyUI              = TRUE; // UI needs to be added <br>   lpContainerDoc-&gt;m_cIPActiveObjects      = 0; <br>   lpContainerApp-&gt;m_fMenuHelpMode         = FALSE; // F1 pressed in menu <br> <br>#if defined( INPLACE_CNTRSVR ) <br>   lpContainerDoc-&gt;m_lpTopIPFrame          = <br>               (LPOLEINPLACEUIWINDOW)&amp;lpContainerDoc-&gt;m_OleInPlaceFrame; <br>   lpContainerDoc-&gt;m_lpTopIPDoc            = <br>               (LPOLEINPLACEUIWINDOW)&amp;lpContainerDoc-&gt;m_OleInPlaceDoc; <br>   lpContainerDoc-&gt;m_hSharedMenu           = NULL; <br>   lpContainerDoc-&gt;m_hOleMenu              = NULL; <br> <br>#endif  // INPLACE_CNTRSVR <br>#endif  // INPLACE_CNTR <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerDoc-&gt;m_OleUILinkContainer, <br>         &amp;g_CntrDoc_OleUILinkContainerVtbl, <br>         lpContainerDoc <br>   ); <br> <br>   return TRUE; <br>} <br> <br> <br>/* ContainerDoc_GetNextLink <br> * ------------------------ <br> * <br> *  Update all links in the document. A dialog box will be popped up showing <br> *  the progress of the update and allow the user to quit by pushing the <br> *  stop button <br> */ <br>LPCONTAINERLINE ContainerDoc_GetNextLink( <br>      LPCONTAINERDOC lpContainerDoc, <br>      LPCONTAINERLINE lpContainerLine <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   DWORD dwNextLink = 0; <br>   LPLINE lpLine; <br>   static int nIndex = 0; <br> <br>   if (lpContainerLine==NULL) <br>      nIndex = 0; <br> <br>   for ( ; nIndex &lt; lpLL-&gt;m_nNumLines; nIndex++) { <br>      lpLine = LineList_GetLine(lpLL, nIndex); <br> <br>      if (lpLine <br>         &amp;&amp; (Line_GetLineType(lpLine) == CONTAINERLINETYPE) <br>         &amp;&amp; ContainerLine_IsOleLink((LPCONTAINERLINE)lpLine)) { <br> <br>         nIndex++; <br>         ContainerLine_LoadOleObject((LPCONTAINERLINE)lpLine); <br>         return (LPCONTAINERLINE)lpLine; <br>      } <br>   } <br> <br>   return NULL; <br>} <br> <br> <br> <br>/* ContainerDoc_UpdateLinks <br> * ------------------------ <br> * <br> *  Update all links in the document. A dialog box will be popped up showing <br> *  the progress of the update and allow the user to quit by pushing the <br> *  stop button <br> */ <br>void ContainerDoc_UpdateLinks(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   int             cLinks; <br>   BOOL            fAllLinksUpToDate = TRUE; <br>   HWND            hwndDoc = ((LPOUTLINEDOC)lpContainerDoc)-&gt;m_hWndDoc; <br>   HCURSOR         hCursor; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   HRESULT         hrErr; <br>   DWORD           dwUpdateOpt; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   BOOL            fPrevEnable1; <br>   BOOL            fPrevEnable2; <br> <br>   hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   /* NOTE: we do not want to ever give the Busy/NotResponding <br>   **    dialogs when we are updating automatic links as part of <br>   **    opening a document.  even if the link source of data is busy, <br>   **    we do not want put up the busy dialog. thus we will disable <br>   **    the dialog and later re-enable them <br>   */ <br>   OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>   /* get total number of automatic links */ <br>   cLinks = 0; <br>   while (lpContainerLine = ContainerDoc_GetNextLink( <br>                           lpContainerDoc, <br>                           lpContainerLine)) { <br>      hrErr = CntrDoc_LinkCont_GetLinkUpdateOptions( <br>            (LPOLEUILINKCONTAINER)&amp;lpContainerDoc-&gt;m_OleUILinkContainer, <br>            (DWORD)lpContainerLine, <br>            (LPDWORD)&amp;dwUpdateOpt <br>      ); <br>      if (hrErr == NOERROR) { <br>         if (dwUpdateOpt==OLEUPDATE_ALWAYS) { <br>            cLinks++; <br>            if (fAllLinksUpToDate) { <br>               OLEDBG_BEGIN2("IOleObject::IsUpToDate called\r\n") <br>               hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;IsUpToDate( <br>                     lpContainerLine-&gt;m_lpOleObj); <br>               OLEDBG_END2 <br>               if (hrErr != NOERROR) <br>                  fAllLinksUpToDate = FALSE; <br>            } <br>         } <br>      } <br>#if defined( _DEBUG ) <br>      else <br>         OleDbgOutHResult("IOleUILinkContainer::GetLinkUpdateOptions returned",hrErr); <br>#endif <br> <br>   } <br> <br>   if (fAllLinksUpToDate) <br>      goto done; // don't bother user if all links are up-to-date <br> <br>   SetCursor(hCursor); <br> <br>   if ((cLinks &gt; 0) &amp;&amp; !OleUIUpdateLinks( <br>         (LPOLEUILINKCONTAINER)&amp;lpContainerDoc-&gt;m_OleUILinkContainer, <br>         hwndDoc, <br>         APPNAMEA, <br>         cLinks)) <br>      { <br>      char szTemp[256]; <br>      wcstombs(szTemp, APPNAME, 255); <br>      if (ID_PU_LINKS == OleUIPromptUser( <br>            (WORD)IDD_CANNOTUPDATELINK, <br>            hwndDoc, <br>            szTemp)) { <br>         ContainerDoc_EditLinksCommand(lpContainerDoc); <br>      } <br>   } <br> <br>done: <br>   // re-enable the Busy/NotResponding dialogs <br>   OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br>} <br> <br> <br> <br>/* ContainerDoc_SetShowObjectFlag <br> * ------------------------------ <br> * <br> *  Set/Clear the ShowObject flag of ContainerDoc <br> */ <br>void ContainerDoc_SetShowObjectFlag(LPCONTAINERDOC lpContainerDoc, BOOL fShow) <br>{ <br>   if (!lpContainerDoc) <br>      return; <br> <br>   lpContainerDoc-&gt;m_fShowObject = fShow; <br>} <br> <br> <br>/* ContainerDoc_GetShowObjectFlag <br> * ------------------------------ <br> * <br> *  Get the ShowObject flag of ContainerDoc <br> */ <br>BOOL ContainerDoc_GetShowObjectFlag(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   if (!lpContainerDoc) <br>      return FALSE; <br> <br>   return lpContainerDoc-&gt;m_fShowObject; <br>} <br> <br> <br>/* ContainerDoc_InsertOleObjectCommand <br> * ----------------------------------- <br> * <br> * Insert a new OLE object in the ContainerDoc. <br> */ <br>void ContainerDoc_InsertOleObjectCommand(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPLINELIST              lpLL =&amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPLINE                  lpLine = NULL; <br>   HDC                     hDC; <br>   int                     nTab = 0; <br>   int                     nIndex = LineList_GetFocusLineIndex(lpLL); <br>   LPCONTAINERLINE         lpContainerLine=NULL; <br>   OLECHAR                 szStgName[CWCSTORAGENAME]; <br>   UINT                    uRet; <br>   OLEUIINSERTOBJECT       io; <br>   char                   szFile[OLEUI_CCHPATHMAX]; <br>   OLECHAR                  szFileW[OLEUI_CCHPATHMAX]; <br>   DWORD                   dwOleCreateType; <br>   BOOL                    fDisplayAsIcon; <br>   HCURSOR                 hPrevCursor; <br> <br>   _fmemset((LPOLEUIINSERTOBJECT)&amp;io, 0, sizeof(OLEUIINSERTOBJECT)); <br>   io.cbStruct=sizeof(OLEUIINSERTOBJECT); <br>   io.dwFlags=IOF_SELECTCREATENEW | IOF_SHOWHELP; <br>   io.hWndOwner=((LPOUTLINEDOC)lpContainerDoc)-&gt;m_hWndDoc; <br>   io.lpszFile=szFile; <br>   io.cchFile=OLEUI_CCHPATHMAX; <br>//   _fmemset(/*(LPOLESTR)*/szFile, 0, OLEUI_CCHPATHMAX); <br>   _fmemset(/*(LPOLESTR)*/szFile, 0, sizeof(szFile)); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   OLEDBG_BEGIN3("OleUIInsertObject called\r\n") <br>   uRet=OleUIInsertObject((LPOLEUIINSERTOBJECT)&amp;io); <br>   OLEDBG_END3 <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   if (OLEUI_OK != uRet) <br>      return;     // user canceled dialog <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   fDisplayAsIcon = (io.dwFlags &amp; IOF_CHECKDISPLAYASICON ? TRUE : FALSE); <br> <br>   // make up a storage name for the OLE object <br>   ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, CWCSTORAGENAME); <br> <br>   /* default the new line to have the same indent as previous line */ <br>   lpLine = LineList_GetLine(lpLL, nIndex); <br>   if (lpLine) <br>      nTab = Line_GetTabLevel(lpLine); <br> <br>   hDC = LineList_GetDC(lpLL); <br> <br>   if ((io.dwFlags &amp; IOF_SELECTCREATENEW)) <br>      dwOleCreateType = IOF_SELECTCREATENEW; <br>   else if ((io.dwFlags &amp; IOF_CHECKLINK)) <br>      dwOleCreateType = IOF_CHECKLINK; <br>   else <br>      dwOleCreateType = IOF_SELECTCREATEFROMFILE; <br> <br>   A2W(szFile, szFileW, OLEUI_CCHPATHMAX); <br>   lpContainerLine = ContainerLine_Create( <br>         dwOleCreateType, <br>         hDC, <br>         nTab, <br>         lpContainerDoc, <br>         &amp;io.clsid, <br>         szFileW, <br>         fDisplayAsIcon, <br>         io.hMetaPict, <br>         szStgName <br>   ); <br> <br>   if (!lpContainerLine) <br>      goto error;         // creation of OLE object FAILED <br> <br>   if (io.hMetaPict) { <br>      OleUIMetafilePictIconFree(io.hMetaPict);    // clean up metafile <br>   } <br> <br>   /* add a ContainerLine object to the document's LineList. The <br>   **    ContainerLine manages the rectangle on the screen occupied by <br>   **    the OLE object. <br>   */ <br> <br>   LineList_AddLine(lpLL, (LPLINE)lpContainerLine, nIndex); <br> <br>   /* before calling DoVerb(OLEIVERB_SHOW), check to see if the object <br>   **    has any initial extents. <br>   */ <br>   ContainerLine_UpdateExtent(lpContainerLine, NULL); <br> <br>   /* If a new embedded object was created, tell the object server to <br>   **    make itself visible (show itself). <br>   **    NOTE: the standard OLE 2 User Model is to only call <br>   **    IOleObject::DoVerb(OLEIVERB_SHOW...) if a new object is <br>   **    created. specifically, it should NOT be calld if the object <br>   **    is created from file or link to file. <br>   */ <br>   if (dwOleCreateType == IOF_SELECTCREATENEW) { <br>      if (! ContainerLine_DoVerb( <br>            lpContainerLine, OLEIVERB_SHOW, NULL, TRUE, TRUE)) { <br>         OutlineApp_ErrorMessage(g_lpApp, ErrMsgShowObj); <br>      } <br> <br>      /* NOTE: we will immediately force a save of the object <br>      **    to guarantee that a valid initial object is saved <br>      **    with our document. if the object is a OLE 1.0 object, <br>      **    then it may exit without update. by forcing this <br>      **    initial save we consistently always have a valid <br>      **    object even if it is a OLE 1.0 object that exited <br>      **    without saving. if we did NOT do this save here, then <br>      **    we would have to worry about deleting the object if <br>      **    it was a OLE 1.0 object that closed without saving. <br>      **    the OLE 2.0 User Model dictates that the object <br>      **    should always be valid after CreateNew performed. the <br>      **    user must explicitly delete it. <br>      */ <br>      ContainerLine_SaveOleObjectToStg( <br>            lpContainerLine, <br>            lpContainerLine-&gt;m_lpStg, <br>            lpContainerLine-&gt;m_lpStg, <br>            TRUE    /* fRemember */ <br>      ); <br>   } <br>#if defined( INPLACE_CNTR ) <br>   else if (dwOleCreateType == IOF_SELECTCREATEFROMFILE) { <br>      /* NOTE: an inside-out container should check if the object <br>      **    created from file is an inside-out and prefers to be <br>      **    activated when visible type of object. if so, the object <br>      **    should be immediately activated in-place, BUT NOT UIActived. <br>      */ <br>      if (g_fInsideOutContainer &amp;&amp; <br>            lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_CONTENT &amp;&amp; <br>            lpContainerLine-&gt;m_fInsideOutObj ) { <br>         HWND hWndDoc = OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerDoc); <br> <br>         ContainerLine_DoVerb( <br>               lpContainerLine,OLEIVERB_INPLACEACTIVATE,NULL,FALSE,FALSE); <br> <br>         /* NOTE: following this DoVerb(INPLACEACTIVATE) the <br>         **    object may have taken focus. but because the <br>         **    object is NOT UIActive it should NOT have focus. <br>         **    we will make sure our document has focus. <br>         */ <br>         SetFocus(hWndDoc); <br>      } <br>   } <br>#endif  // INPLACE_CNTR <br> <br>   OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, TRUE); <br> <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br> <br>   return; <br> <br>error: <br>   // NOTE: if ContainerLine_Create failed <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   if (OLEUI_OK == uRet &amp;&amp; io.hMetaPict) <br>      OleUIMetafilePictIconFree(io.hMetaPict);    // clean up metafile <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>   OutlineApp_ErrorMessage(g_lpApp, ErrMsgInsertObj); <br>} <br> <br> <br> <br>void ContainerDoc_EditLinksCommand(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   UINT        uRet; <br>   OLEUIEDITLINKS      el; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br> <br>   _fmemset((LPOLEUIEDITLINKS)&amp;el,0,sizeof(OLEUIEDITLINKS)); <br>   el.cbStruct=sizeof(OLEUIEDITLINKS); <br>   el.dwFlags=ELF_SHOWHELP; <br>   el.hWndOwner=((LPOUTLINEDOC)lpContainerDoc)-&gt;m_hWndDoc; <br>   el.lpOleUILinkContainer = <br>         (LPOLEUILINKCONTAINER)&amp;lpContainerDoc-&gt;m_OleUILinkContainer; <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   OLEDBG_BEGIN3("OleUIEditLinks called\r\n") <br>   uRet=OleUIEditLinks((LPOLEUIEDITLINKS)&amp;el); <br>   OLEDBG_END3 <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   OleDbgAssert((uRet==1) || (uRet==OLEUI_CANCEL)); <br> <br>} <br> <br> <br>/* Convert command - brings up the "Convert" dialog <br> */ <br>void ContainerDoc_ConvertCommand( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      BOOL                fServerNotRegistered <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   OLEUICONVERT ct; <br>   UINT         uRet; <br>   LPDATAOBJECT  lpDataObj; <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   BOOL         fSelIsOleObject; <br>   int          nIndex; <br>   STGMEDIUM    medium; <br>   LPOLESTR     lpErrMsg = NULL; <br>   HRESULT      hrErr; <br>   HCURSOR      hPrevCursor; <br>   BOOL         fMustRun = FALSE; <br>   BOOL         fMustClose = FALSE; <br>   BOOL         fObjConverted = FALSE; <br>   BOOL         fDisplayChanged = FALSE; <br>   BOOL         fHaveCLSID = FALSE; <br>   BOOL         fHaveFmtUserType = FALSE; <br>   OLECHAR      szUserType[128]; <br>   LPOLESTR     lpszUserType; <br>   LPOLESTR     lpszDefLabel; <br>   BOOL         fMustActivate; <br> <br>   /* NOTE: if we came to the Convert dialog because the user <br>   **    activated a non-registered object, then we should activate <br>   **    the object after the user has converted it or setup an <br>   **    ActivateAs server. <br>   */ <br>   fMustActivate = fServerNotRegistered; <br> <br>   _fmemset((LPOLEUICONVERT)&amp;ct,0,sizeof(OLEUICONVERT)); <br> <br>   fSelIsOleObject = ContainerDoc_IsSelAnOleObject( <br>         (LPCONTAINERDOC)lpContainerDoc, <br>         &amp;IID_IDataObject, <br>         (LPUNKNOWN FAR*)&amp;lpDataObj, <br>         &amp;nIndex, <br>         (LPCONTAINERLINE FAR*)&amp;lpContainerLine <br>   ); <br> <br>   lpErrMsg = ErrMsgCantConvert; <br> <br>   if (! fSelIsOleObject) <br>      goto error;     // can NOT do Convert. <br> <br>   if (! lpContainerLine) { <br>      OleStdRelease((LPUNKNOWN)lpDataObj); <br>      goto error;     // can NOT do Convert. <br>   } <br> <br>   ct.cbStruct  = sizeof(OLEUICONVERT); <br>   ct.dwFlags   = CF_SHOWHELPBUTTON; <br>   ct.hWndOwner = lpContainerDoc-&gt;m_OleDoc.m_OutlineDoc.m_hWndDoc; <br>   ct.lpszCaption = NULL; <br>   ct.lpfnHook  = NULL; <br>   ct.lCustData = 0; <br>   ct.hInstance = NULL; <br>   ct.lpszTemplate = NULL; <br>   ct.hResource = 0; <br>   ct.fIsLinkedObject = ContainerLine_IsOleLink(lpContainerLine); <br>   ct.dvAspect = lpContainerLine-&gt;m_dwDrawAspect; <br>   ct.cClsidExclude = 0; <br>   ct.lpClsidExclude = NULL; <br> <br>   if (! ct.fIsLinkedObject || !lpContainerLine-&gt;m_lpOleLink) { <br>      /* NOTE: the object is an embedded object. we should first <br>      **    attempt to read the actual object CLSID, file data <br>      **    format, and full user type name that is written inside of <br>      **    the object's storage as this should be the most <br>      **    definitive information. if this fails we will ask the <br>      **    object what its class is and attempt to get the rest of <br>      **    the information out of the REGDB. <br>      */ <br>      hrErr=ReadClassStg(lpContainerLine-&gt;m_lpStg,(CLSID FAR*)&amp;(ct.clsid)); <br>      if (hrErr == NOERROR) <br>         fHaveCLSID = TRUE; <br>      else { <br>         OleDbgOutHResult("ReadClassStg returned", hrErr); <br>      } <br>      hrErr = ReadFmtUserTypeStg( <br>            lpContainerLine-&gt;m_lpStg, <br>            (CLIPFORMAT FAR*)&amp;ct.wFormat, <br>            &amp;lpszUserType); <br>      ct.lpszUserType = NULL; <br>      if (lpszUserType) <br>      { <br>          int cch = OLESTRLEN(lpszUserType)+1; <br>          ct.lpszUserType=OleStdMalloc(cch); <br>          if (ct.lpszUserType) <br>          { <br>              W2A(lpszUserType, ct.lpszUserType, cch); <br>          } <br>      } <br>      if (hrErr == NOERROR) <br>         fHaveFmtUserType = TRUE; <br>      else { <br>         OleDbgOutHResult("ReadFmtUserTypeStg returned", hrErr); <br>      } <br>   } else { <br>      /* NOTE: the object is a linked object. we should give the <br>      **    DisplayName of the link source as the default icon label. <br>      */ <br>      OLEDBG_BEGIN2("IOleLink::GetSourceDisplayName called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpOleLink-&gt;lpVtbl-&gt;GetSourceDisplayName( <br>            lpContainerLine-&gt;m_lpOleLink, &amp;lpszDefLabel); <br>      if (lpszDefLabel) <br>      { <br>          int cch = OLESTRLEN(lpszDefLabel) + 1; <br>          ct.lpszDefLabel = OleStdMalloc(cch); <br>          if (ct.lpszDefLabel) <br>          { <br>              W2A(lpszDefLabel, ct.lpszDefLabel, cch); <br>          } <br>      } <br>      OLEDBG_END2 <br>   } <br> <br>   if (! fHaveCLSID) { <br>      hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserClassID( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            (CLSID FAR*)&amp;ct.clsid <br>      ); <br>      if (hrErr != NOERROR) <br>         ct.clsid = CLSID_NULL; <br>   } <br>   if (! fHaveFmtUserType) { <br>      ct.wFormat = 0; <br>      if (OleStdGetUserTypeOfClass( <br>            (CLSID FAR*)&amp;ct.clsid,szUserType,128,NULL)) <br>      { <br>          int cch = OLESTRLEN(szUserType) + 1; <br>          ct.lpszUserType = OleStdMalloc(cch); <br>          if (ct.lpszUserType) <br>          { <br>              W2A(szUserType, ct.lpszUserType, cch); <br>          } <br>      } else { <br>         ct.lpszUserType = NULL; <br>      } <br>   } <br> <br>   if (lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_ICON) { <br>      ct.hMetaPict = OleStdGetData( <br>            lpDataObj, <br>            CF_METAFILEPICT, <br>            NULL, <br>            DVASPECT_ICON, <br>            (LPSTGMEDIUM)&amp;medium <br>      ); <br>   } else { <br>      ct.hMetaPict = NULL; <br>   } <br>   OleStdRelease((LPUNKNOWN)lpDataObj); <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   OLEDBG_BEGIN3("OleUIConvert called\r\n") <br>   uRet = OleUIConvert(&amp;ct); <br>   OLEDBG_END3 <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc); <br>#endif <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   if (uRet == OLEUI_OK) { <br> <br>      /***************************************************************** <br>      **  NOTE: the convert dialog actually allows the user to <br>      **    change two orthogonal properties of the object: the <br>      **    object's type/server and the object's display aspect. <br>      **    first we will execute the ConvertTo/ActivateAs action and <br>      **    then we will deal with any display aspect change. we want <br>      **    to be careful to only call IOleObject::Update once <br>      **    because this is an expensive operation; it results in <br>      **    launching the object's server. <br>      *****************************************************************/ <br> <br>      if (ct.dwFlags &amp; CF_SELECTCONVERTTO &amp;&amp; <br>            ! IsEqualCLSID(&amp;ct.clsid, &amp;ct.clsidNew)) { <br> <br>         /* user selected CONVERT. <br>         ** <br>         ** NOTE: to achieve the "Convert To" at this point we <br>         **    need to take the following steps: <br>         **    1. unload the object. <br>         **    2. write the NEW CLSID and NEW user type name <br>         **       string into the storage of the object, <br>         **       BUT write the OLD format tag. <br>         **    3. force an update to force the actual conversion of <br>         **       the data bits. <br>         */ <br>         lpErrMsg = ErrMsgConvertObj; // setup correct msg in case of error <br> <br>         ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_SAVEIFDIRTY); <br> <br>         OLEDBG_BEGIN2("OleStdDoConvert called \r\n") <br>         hrErr = OleStdDoConvert( <br>               lpContainerLine-&gt;m_lpStg, (REFCLSID)&amp;ct.clsidNew); <br>         OLEDBG_END2 <br>         if (hrErr != NOERROR) <br>            goto error; <br> <br>         // Reload the object <br>         ContainerLine_LoadOleObject(lpContainerLine); <br> <br>         /* we need to force the object to run to complete the <br>         **    conversion. set flag to force OleRun to be called at <br>         **    end of function. <br>         */ <br>         fMustRun = TRUE; <br>         fObjConverted = TRUE; <br> <br>      } else if (ct.dwFlags &amp; CF_SELECTACTIVATEAS) { <br>         /* user selected ACTIVATE AS. <br>         ** <br>         ** NOTE: to achieve the "Activate As" at this point we <br>         **    need to take the following steps: <br>         **    1. unload ALL objects of the OLD class that app knows about <br>         **    2. add the TreatAs tag in the registration database <br>         **    by calling CoTreatAsClass(). <br>         **    3. lazily it can reload the objects; when the objects <br>         **    are reloaded the TreatAs will take effect. <br>         */ <br>         lpErrMsg = ErrMsgActivateAsObj; // setup msg in case of error <br> <br>         ContainerDoc_UnloadAllOleObjectsOfClass( <br>               lpContainerDoc, <br>               (REFCLSID)&amp;ct.clsid, <br>               OLECLOSE_SAVEIFDIRTY <br>         ); <br> <br>         OLEDBG_BEGIN2("OleStdDoTreatAsClass called \r\n") <br>         A2W(ct.lpszUserType, szUserType, 128); <br>         hrErr = OleStdDoTreatAsClass(szUserType, (REFCLSID)&amp;ct.clsid, <br>               (REFCLSID)&amp;ct.clsidNew); <br>         OLEDBG_END2 <br> <br>         // Reload the object <br>         ContainerLine_LoadOleObject(lpContainerLine); <br> <br>         fMustActivate = TRUE;   // we should activate this object <br>      } <br> <br>      /***************************************************************** <br>      **  NOTE: now we will try to change the display if <br>      **    necessary. <br>      *****************************************************************/ <br> <br>      if (lpContainerLine-&gt;m_lpOleObj &amp;&amp; <br>            ct.dvAspect != lpContainerLine-&gt;m_dwDrawAspect) { <br>         /* user has selected to change display aspect between icon <br>         **    aspect and content aspect. <br>         ** <br>         ** NOTE: if we got here because the server was not <br>         **    registered, then we will NOT delete the object's <br>         **    original display aspect. because we do not have the <br>         **    original server, we can NEVER get it back. this is a <br>         **    safety precaution. <br>         */ <br> <br>         hrErr = OleStdSwitchDisplayAspect( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               &amp;lpContainerLine-&gt;m_dwDrawAspect, <br>               ct.dvAspect, <br>               ct.hMetaPict, <br>               !fServerNotRegistered,   /* fDeleteOldAspect */ <br>               TRUE,                    /* fSetupViewAdvise */ <br>               (LPADVISESINK)&amp;lpContainerLine-&gt;m_AdviseSink, <br>               (BOOL FAR*)&amp;fMustRun <br>         ); <br> <br>         if (hrErr == NOERROR) <br>            fDisplayChanged = TRUE; <br> <br>#if defined( INPLACE_CNTR ) <br>            ContainerDoc_UpdateInPlaceObjectRects( <br>                  lpContainerLine-&gt;m_lpDoc, nIndex); <br>#endif <br> <br>      } else if (ct.dvAspect == DVASPECT_ICON &amp;&amp; ct.fObjectsIconChanged) { <br>         hrErr = OleStdSetIconInCache( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               ct.hMetaPict <br>         ); <br> <br>         if (hrErr == NOERROR) <br>            fDisplayChanged = TRUE; <br>      } <br> <br>      /* we deliberately run the object so that the update won't shut <br>      ** the server down. <br>      */ <br>      if (fMustActivate || fMustRun) { <br> <br>         /* if we force the object to run, then shut it down after <br>         **    the update. do NOT force the object to close if we <br>         **    want to activate the object or if the object was <br>         **    already running. <br>         */ <br>         if (!fMustActivate &amp;&amp; !OleIsRunning(lpContainerLine-&gt;m_lpOleObj)) <br>            fMustClose = TRUE;  // shutdown after update <br> <br>         hrErr = ContainerLine_RunOleObject(lpContainerLine); <br> <br>         if (fObjConverted &amp;&amp; <br>            FAILED(hrErr) &amp;&amp; hrErr!=OLE_E_STATIC) { <br> <br>            // ERROR: convert of the object failed. <br>            // revert the storage to restore the original link. <br>            // (NOTE: static object always return OLE_E_STATIC <br>            //        when told to run; this is NOT an error here. <br>            //        the OLE2 libraries have built in handlers for <br>            //        the static objects that do the conversion. <br>            ContainerLine_UnloadOleObject( <br>                  lpContainerLine, OLECLOSE_NOSAVE); <br>            lpContainerLine-&gt;m_lpStg-&gt;lpVtbl-&gt;Revert( <br>                  lpContainerLine-&gt;m_lpStg); <br>            goto error; <br> <br>         } else if (fObjConverted) { <br>            FORMATETC  FmtEtc; <br>            DWORD      dwNewConnection; <br>            LPOLECACHE lpOleCache = (LPOLECACHE)OleStdQueryInterface <br>                 ((LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj,&amp;IID_IOleCache); <br> <br>            /* NOTE: we need to force the converted object to <br>            **    setup a new OLERENDER_DRAW cache. it is possible <br>            **    that the new object needs to cache different data <br>            **    in order to support drawing than the old object. <br>            */ <br>            if (lpOleCache &amp;&amp; <br>                  lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_CONTENT) { <br>               FmtEtc.cfFormat = 0; //NULL; // whatever is needed for Draw <br>               FmtEtc.ptd      = NULL; <br>               FmtEtc.dwAspect = DVASPECT_CONTENT; <br>               FmtEtc.lindex   = -1; <br>               FmtEtc.tymed    = TYMED_NULL; <br> <br>               OLEDBG_BEGIN2("IOleCache::Cache called\r\n") <br>               hrErr = lpOleCache-&gt;lpVtbl-&gt;Cache( <br>                     lpOleCache, <br>                     (LPFORMATETC)&amp;FmtEtc, <br>                     ADVF_PRIMEFIRST, <br>                     (LPDWORD)&amp;dwNewConnection <br>               ); <br>               OLEDBG_END2 <br>#if defined( _DEBUG ) <br>               if (! SUCCEEDED(hrErr)) <br>                  OleDbgOutHResult("IOleCache::Cache returned", hrErr); <br>#endif <br>               OleStdRelease((LPUNKNOWN)lpOleCache); </code></pre>
<p>
</p>
<pre><code>} <br> <br>            // Close and force object to save; this will commit the stg <br>            ContainerLine_CloseOleObject( <br>               lpContainerLine, OLECLOSE_SAVEIFDIRTY); <br>            fMustClose = FALSE;     // we already closed the object <br>         } <br>         if (fMustClose) <br>            ContainerLine_CloseOleObject(lpContainerLine,OLECLOSE_NOSAVE); <br>      } <br> <br>      if (fDisplayChanged) { <br>         /* the Object's display was changed, force a repaint of <br>         **    the line. note the extents of the object may have <br>         **    changed. <br>         */ <br>         ContainerLine_UpdateExtent(lpContainerLine, NULL); <br>         LineList_ForceLineRedraw(lpLL, nIndex, TRUE); <br>      } <br> <br>      if (fDisplayChanged || fObjConverted) { <br>         /* mark ContainerDoc as now dirty. if display changed, then <br>         **    the extents of the object may have changed. <br>         */ <br>         OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fDisplayChanged); <br>      } <br> <br>      if (fMustActivate) { <br>         ContainerLine_DoVerb( <br>               lpContainerLine, OLEIVERB_PRIMARY, NULL, FALSE,FALSE); <br>      } <br>   } <br> <br> <br>   if (ct.lpszUserType) <br>      OleStdFree(ct.lpszUserType); <br> <br>   if (ct.lpszDefLabel) <br>      OleStdFree(ct.lpszDefLabel); <br> <br>   if (ct.hMetaPict) <br>      OleUIMetafilePictIconFree(ct.hMetaPict);    // clean up metafile <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br> <br>   return; <br> <br>error: <br>   if (ct.lpszUserType) <br>      OleStdFree(ct.lpszUserType); <br> <br>   if (ct.hMetaPict) <br>      OleUIMetafilePictIconFree(ct.hMetaPict);    // clean up metafile <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>   if (lpErrMsg) <br>      OutlineApp_ErrorMessage(g_lpApp, lpErrMsg); <br>} <br> <br> <br>/* ContainerDoc_CloseAllOleObjects <br>** ------------------------------- <br>**    Close all OLE objects. This forces all OLE objects to transition <br>**    from the running state to the loaded state. <br>** <br>**    Returns TRUE if all objects closed successfully <br>**            FALSE if any object could not be closed. <br>*/ <br>BOOL ContainerDoc_CloseAllOleObjects( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      DWORD                   dwSaveOption <br>) <br>{ <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int         i; <br>   LPLINE      lpLine; <br>   BOOL        fStatus = TRUE; <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) <br>         if (! ContainerLine_CloseOleObject( <br>                              (LPCONTAINERLINE)lpLine,dwSaveOption)) <br>            fStatus = FALSE; <br>   } <br> <br>   return fStatus; <br>} <br> <br> <br>/* ContainerDoc_UnloadAllOleObjectsOfClass <br>** --------------------------------------- <br>**    Unload all OLE objects of a particular class. this is necessary <br>**    when a class level "ActivateAs" (aka. TreatAs) is setup. the user <br>**    can do this with the Convert dialog. for the TreatAs to take <br>**    effect, all objects of the class have to loaded and reloaded. <br>*/ <br>void ContainerDoc_UnloadAllOleObjectsOfClass( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      REFCLSID            rClsid, <br>      DWORD               dwSaveOption <br>) <br>{ <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int         i; <br>   LPLINE      lpLine; <br>   CLSID       clsid; <br>   HRESULT     hrErr; <br> <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         if (! lpContainerLine-&gt;m_lpOleObj) <br>            continue;       // this object is NOT loaded <br> <br>         hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserClassID( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               (CLSID FAR*)&amp;clsid <br>         ); <br>         if (hrErr == NOERROR &amp;&amp; <br>               ( IsEqualCLSID((CLSID FAR*)&amp;clsid,rClsid) <br>                 || IsEqualCLSID(rClsid,&amp;CLSID_NULL) ) ) { <br>            ContainerLine_UnloadOleObject(lpContainerLine, dwSaveOption); <br>         } <br>      } <br>   } <br>} <br> <br> <br>/* ContainerDoc_UpdateExtentOfAllOleObjects <br>** ---------------------------------------- <br>**    Update the extents of any OLE object that is marked that its size <br>**    may  have changed. when an IAdviseSink::OnViewChange notification <br>**    is received, the corresponding ContainerLine is marked <br>**    (m_fDoGetExtent==TRUE) and a message (WM_U_UPDATEOBJECTEXTENT) is <br>**    posted to the document indicating that there are dirty objects. <br>**    when this message is received, this function is called. <br>*/ <br>void ContainerDoc_UpdateExtentOfAllOleObjects(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int         i; <br>   LPLINE      lpLine; <br>   BOOL        fStatus = TRUE; <br>#if defined( INPLACE_CNTR ) <br>   int         nFirstUpdate = -1; <br>#endif <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>         if (lpContainerLine-&gt;m_fDoGetExtent) { <br>            ContainerLine_UpdateExtent(lpContainerLine, NULL); <br>#if defined( INPLACE_CNTR ) <br>            if (nFirstUpdate == -1) <br>               nFirstUpdate = i; <br>#endif <br>         } <br>      } <br>   } <br> <br>#if defined( INPLACE_CNTR ) <br>   /* NOTE: after changing the extents of any line, we need to <br>   **    update the PosRect of the In-Place active <br>   **    objects (if any) that follow the first modified line. <br>   */ <br>   if (nFirstUpdate != -1) <br>      ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nFirstUpdate+1); <br>#endif <br>} <br> <br> <br>BOOL ContainerDoc_SaveToFile( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCOLESTR               lpszFileName, <br>      UINT                    uFormat, <br>      BOOL                    fRemember <br>) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc; <br>   LPSTORAGE lpDestStg; <br>   BOOL fStatus; <br>   BOOL fMustRelDestStg = FALSE; <br>   HRESULT hrErr; <br>#if defined( OPTIONAL ) <br>   FILETIME filetimeBeforeSave; <br>#endif <br> <br>   if (fRemember) { <br>      if (lpszFileName) { <br>         fStatus = OutlineDoc_SetFileName( <br>               lpOutlineDoc, (LPOLESTR)lpszFileName, NULL); <br>         if (! fStatus) goto error; <br>      } <br> <br>      /* The ContainerDoc keeps its storage open at all times. it is not <br>      **    necessary to reopen the file. <br>      ** if SaveAs is pending, then lpNewStg is the new destination for <br>      **    the save operation, else the existing storage is the dest. <br>      */ <br>      lpDestStg = (lpContainerDoc-&gt;m_lpNewStg ? <br>                  lpContainerDoc-&gt;m_lpNewStg : lpOleDoc-&gt;m_lpStg); <br> <br>#if defined( OPTIONAL ) <br>      /* NOTE: an automatic link to an embedded object within the <br>      **    same container document (that uses ItemMonikers) will <br>      **    always be considered "out-of-date' by OLE. if a container <br>      **    application REALLY wants to fix this it can do one of the <br>      **    following: <br>      **      1. implement a new moniker better than ItemMonikers <br>      **    that look into the objects storage to find the real last <br>      **    change time (rather then defaulting to that of the outer <br>      **    container file). <br>      ** or   2. using item monikers it is possible to fix the case <br>      **    where the container document is saved while the embedded <br>      **    object is running but it will NOT fix the case when the <br>      **    document is saved when the embedded object was only <br>      **    loaded. the fix is to: <br>      **      a. remember the time (T) before the save operation starts <br>      **      b. call IRunningObjectTable::NoteChangeTime(lpDoc, T) <br>      **      c. do the saving and commit the file <br>      **      d. call StgSetTimes to reset the file time to T <br>      **      e. remember time T in document structure and when the <br>      **         root storage is finally released reset the file time <br>      **         again to T (closing the file on DOS sets the time). <br>      */ <br>      CoFileTimeNow( &amp;filetimeBeforeSave ); <br>      if (lpOleDoc-&gt;m_dwRegROT != 0) { <br>         LPRUNNINGOBJECTTABLE lprot; <br> <br>         if (GetRunningObjectTable(0,&amp;lprot) == NOERROR) <br>         { <br>            OleDbgOut2("IRunningObjectTable::NoteChangeTime called\r\n"); <br>            lprot-&gt;lpVtbl-&gt;NoteChangeTime( <br>                  lprot, lpOleDoc-&gt;m_dwRegROT, &amp;filetimeBeforeSave ); <br>            lprot-&gt;lpVtbl-&gt;Release(lprot); <br>         } <br>      } <br>#endif <br>   } else { <br>      if (! lpszFileName) <br>         goto error; <br> <br>      /* NOTE: since we are preforming a SaveCopyAs operation, we <br>      **    do not need to have the DocFile open in STGM_TRANSACTED mode. <br>      **    there is less overhead to use STGM_DIRECT mode. <br>      */ <br>      hrErr = StgCreateDocfile( <br>            lpszFileName, <br>            STGM_READWRITE|STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_CREATE, <br>            0, <br>            &amp;lpDestStg <br>      ); <br>      OleDbgAssertSz(hrErr == NOERROR, "Could not create Docfile"); <br>      if (hrErr != NOERROR) { <br>            OleDbgOutHResult("StgCreateDocfile returned", hrErr); <br>         goto error; <br>        } <br>      fMustRelDestStg = TRUE; <br>   } <br> <br>   /*  NOTE: we must be sure to write our class ID into our <br>   **    storage. this information is used by OLE to determine the <br>   **    class of the data stored in our storage. Even for top <br>   **    "file-level" objects this information should be written to <br>   **    the file. <br>   */ <br>   hrErr = WriteClassStg(lpDestStg, &amp;CLSID_APP); <br>   if(hrErr != NOERROR) goto error; <br> <br>   fStatus = OutlineDoc_SaveSelToStg( <br>         lpOutlineDoc, <br>         NULL,           // save all lines <br>         uFormat, <br>         lpDestStg, <br>         FALSE,          // fSameAsLoad <br>         TRUE            // remember this stg <br>      ); <br> <br>   if (fStatus) <br>      fStatus = OleStdCommitStorage(lpDestStg); <br> <br>   if (fRemember) { <br>      /* if SaveAs was pending, then release the old storage and remember <br>      **    the new storage as the active current storage. all data from <br>      **    the old storage has been copied into the new storage. <br>      */ <br>      if (lpContainerDoc-&gt;m_lpNewStg) { <br>         OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg);  // free old stg <br>         lpOleDoc-&gt;m_lpStg = lpContainerDoc-&gt;m_lpNewStg;   // save new stg <br>         lpContainerDoc-&gt;m_lpNewStg = NULL; <br>      } <br>      if (! fStatus) goto error; <br> <br>      OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE); <br> <br>#if defined( OPTIONAL ) <br>      /* reset time of file on disk to be time just prior to saving. <br>      ** NOTE: it would also be necessary to remember <br>      **    filetimeBeforeSave in the document structure and when the <br>      **    root storage is finally released reset the file time <br>      **    again to this value (closing the file on DOS sets the time). <br>      */ <br>      StgSetTimes( <br>            lpOutlineDoc-&gt;m_szFileName, NULL, NULL, &amp;filetimeBeforeSave); <br>#endif <br>   } <br> <br>   if (fMustRelDestStg) <br>      OleStdRelease((LPUNKNOWN)lpDestStg); <br>   return TRUE; <br> <br>error: <br>   if (fMustRelDestStg) <br>      OleStdRelease((LPUNKNOWN)lpDestStg); <br>   OutlineApp_ErrorMessage(g_lpApp, ErrMsgSaving); <br>   return FALSE; <br>} <br> <br> <br>/* ContainerDoc_ContainerLineDoVerbCommand <br>** --------------------------------------- <br>**    Execute a verb of the OLE object in the current focus line. <br>*/ <br>void ContainerDoc_ContainerLineDoVerbCommand( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LONG                    iVerb <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int nIndex = LineList_GetFocusLineIndex(lpLL); <br>   LPLINE lpLine = LineList_GetLine(lpLL, nIndex); <br>   HCURSOR                 hPrevCursor; <br> <br>   if (! lpLine || (Line_GetLineType(lpLine) != CONTAINERLINETYPE) ) return; <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>   ContainerLine_DoVerb((LPCONTAINERLINE) lpLine, iVerb, NULL, TRUE, TRUE); <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br>} <br> <br> <br>/* ContainerDoc_GetNextStgName <br>** --------------------------- <br>**    Generate the next unused name for a sub-storage to be used by an <br>**    OLE object. The ContainerDoc keeps a counter. The storages for <br>**    OLE objects are simply numbered (eg. Obj 0, Obj 1). A "long" <br>**    integer worth of storage names should be more than enough than we <br>**    will ever need. <br>** <br>**    NOTE: when an OLE object is transfered via drag/drop or the <br>**    clipboard, we attempt to keep the currently assigned name for the <br>**    object (if not currently in use). thus it is possible that an <br>**    object with a the next default name (eg. "Obj 5") already exists <br>**    in the current document if an object with this name was privously <br>**    transfered (pasted or dropped). we therefore loop until we find <br>**    the next lowest unused name. <br>*/ <br>void ContainerDoc_GetNextStgName( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszStgName, <br>      int                     nLen <br>) <br>{ <br>   char szAnsiStgName[256]; <br> <br>   wsprintf(szAnsiStgName, "%s %ld", <br>         (LPSTR)DEFOBJNAMEPREFIX, <br>         ++(lpContainerDoc-&gt;m_nNextObjNo) <br>   ); <br> <br>   while (ContainerDoc_IsStgNameUsed(lpContainerDoc, lpszStgName) == TRUE) { <br>      wsprintf(szAnsiStgName, "%s %ld", <br>            (LPSTR)DEFOBJNAMEPREFIX, <br>            ++(lpContainerDoc-&gt;m_nNextObjNo) <br>      ); <br>   } <br>   A2W (szAnsiStgName, lpszStgName, nLen); <br>} <br> <br> <br>/* ContainerDoc_IsStgNameUsed <br>** -------------------------- <br>**    Check if a given StgName is already in use. <br>*/ <br>BOOL ContainerDoc_IsStgNameUsed( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszStgName <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   int i; <br>   LPLINE lpLine; <br> <br>   for (i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>      lpLine=LineList_GetLine(lpLL, i); <br> <br>      if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>         if (OLESTRCMP(lpszStgName, <br>               ((LPCONTAINERLINE)lpLine)-&gt;m_szStgName) == 0) { <br>            return TRUE;    // Match FOUND! <br>         } <br>      } <br>   } <br>   return FALSE;   // if we get here, then NO match was found. <br>} <br> <br> <br>LPSTORAGE ContainerDoc_GetStg(LPCONTAINERDOC lpContainerDoc) <br>{ <br>   return ((LPOLEDOC)lpContainerDoc)-&gt;m_lpStg; <br>} <br> <br> <br>/* ContainerDoc_GetSingleOleObject <br>** ------------------------------- <br>**    If the entire document contains a single OLE object, then <br>**    return the desired interface of the object. <br>** <br>**    Returns NULL if there is are multiple lines in the document or <br>**    the single line is not a ContainerLine. <br>*/ <br>LPUNKNOWN ContainerDoc_GetSingleOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      REFIID                  riid, <br>      LPCONTAINERLINE FAR*    lplpContainerLine <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPLINE lpLine; <br>   LPUNKNOWN lpObj = NULL; <br> <br> <br>   if (lplpContainerLine) <br>      *lplpContainerLine = NULL; <br> <br>   if (lpLL-&gt;m_nNumLines != 1) <br>   { <br>      return NULL;    // doc does NOT contain a single line <br>   } <br> <br>   lpLine=LineList_GetLine(lpLL, 0); <br> <br>   if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) <br>      lpObj = ContainerLine_GetOleObject((LPCONTAINERLINE)lpLine, riid); <br> <br>   if (lplpContainerLine) <br>      *lplpContainerLine = (LPCONTAINERLINE)lpLine; <br> <br>   return lpObj; <br>} <br> <br> <br>/* ContainerDoc_IsSelAnOleObject <br>** ----------------------------- <br>**    Check if the selection is a single selection of an OLE object. <br>**    if so, then optionally return the desired interface of the object <br>**    and/or index of the ContainerLine containing the OLE object. <br>** <br>**    Returns FALSE if there is a multiple selection or the single <br>**    selection is not a ContainerLine. <br>*/ <br>BOOL ContainerDoc_IsSelAnOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      REFIID                  riid, <br>      LPUNKNOWN FAR*          lplpvObj, <br>      int FAR*                lpnIndex, <br>      LPCONTAINERLINE FAR*    lplpContainerLine <br>) <br>{ <br>   LPLINELIST lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LINERANGE lrSel; <br>   int nNumSel; <br>   LPLINE lpLine; <br> <br> <br>   if (lplpvObj) *lplpvObj = NULL; <br>   if (lpnIndex) *lpnIndex = -1; <br>   if (lplpContainerLine) *lplpContainerLine = NULL; <br> <br>   nNumSel = LineList_GetSel(lpLL, (LPLINERANGE)&amp;lrSel); <br>   if (nNumSel != 1) <br>   { <br>      return FALSE;   // selection is not a single line <br>   } <br> <br>   lpLine = LineList_GetLine(lpLL, lrSel.m_nStartLine); <br> <br>   if (lpLine &amp;&amp; (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) { <br>      if (lpnIndex) <br>         *lpnIndex = lrSel.m_nStartLine; <br>      if (lplpContainerLine) <br>         *lplpContainerLine = (LPCONTAINERLINE)lpLine; <br>      if (riid) { <br>         *lplpvObj = ContainerLine_GetOleObject( <br>               (LPCONTAINERLINE)lpLine, <br>               riid <br>         ); <br>      } <br> <br>      return (*lplpvObj ? TRUE : FALSE); <br>   } <br> <br>   return FALSE; <br>} <br> <br> <br>/************************************************************************* <br>** ContainerDoc::IOleUILinkContainer interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP CntrDoc_LinkCont_QueryInterface( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC) <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br> <br>   return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CntrDoc_LinkCont_AddRef(LPOLEUILINKCONTAINER lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC) <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, OLESTR("IOleUILinkContainer")); <br> <br>   return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) CntrDoc_LinkCont_Release(LPOLEUILINKCONTAINER lpThis) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC) <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleUILinkContainer"); <br> <br>   return OleDoc_Release(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP_(DWORD) CntrDoc_LinkCont_GetNextLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br> <br>    // artificial AddRef in case object is released <br>    // during this call <br>    CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_GetNextLink\r\n") <br> <br>   lpContainerLine = ContainerDoc_GetNextLink( <br>         lpContainerDoc, <br>         (LPCONTAINERLINE)dwLink <br>   ); <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return (DWORD)lpContainerLine; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_SetLinkUpdateOptions( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      DWORD                   dwUpdateOpt <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   LPOLELINK lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   SCODE sc = S_OK; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is released during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_SetLinkUpdateOptions\r\n") <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   if (! lpOleLink) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleLink::SetUpdateOptions called\r\n") <br>   hrErr = lpOleLink-&gt;lpVtbl-&gt;SetUpdateOptions( <br>         lpOleLink, <br>         dwUpdateOpt <br>   ); <br>   OLEDBG_END2 <br> <br>   // save new link type update option <br>   lpContainerLine-&gt;m_dwLinkType = dwUpdateOpt; <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleLink::SetUpdateOptions returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>error: <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_GetLinkUpdateOptions( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      DWORD FAR*              lpdwUpdateOpt <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   LPOLELINK lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   SCODE sc = S_OK; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is released during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_GetLinkUpdateOptions\r\n") <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   if (! lpOleLink) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleLink::GetUpdateOptions called\r\n") <br>   hrErr = lpOleLink-&gt;lpVtbl-&gt;GetUpdateOptions( <br>         lpOleLink, <br>         lpdwUpdateOpt <br>   ); <br>   OLEDBG_END2 <br> <br>   // reset saved link type to ensure it is correct <br>   lpContainerLine-&gt;m_dwLinkType = *lpdwUpdateOpt; <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleLink::GetUpdateOptions returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>error: <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_SetLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      LPSTR                lpszDisplayName, <br>      ULONG                   lenFileName, <br>      ULONG FAR*              lpchEaten, <br>      BOOL                    fValidateSource <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   SCODE       sc = S_OK; <br>   HRESULT     hrErr; <br>   LPOLELINK   lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   LPBC        lpbc = NULL; <br>   LPMONIKER   lpmk = NULL; <br>   LPOLEOBJECT lpLinkSrcOleObj = NULL; <br>   CLSID       clsid = CLSID_NULL; <br>   CLSID       clsidOld = CLSID_NULL; <br>   OLECHAR     szDisplayName[256]; <br> <br> <br>   // artificial AddRef in case object is released during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_SetLinkSource\r\n") <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   lpContainerLine-&gt;m_fLinkUnavailable = TRUE; <br> <br>   if (fValidateSource) { <br> <br>      /* NOTE: validate the link source by parsing the string <br>      **    into a Moniker. if this is successful, then the string is <br>      **    valid. <br>      */ <br>      hrErr = CreateBindCtx(0, (LPBC FAR*)&amp;lpbc); <br>      if (hrErr != NOERROR) { <br>         sc = hrErr;   // ERROR: OOM <br>         goto cleanup; <br>      } <br> <br>      // Get class of orignial link source if it is available <br>      if (lpContainerLine-&gt;m_lpOleObj) { <br> <br>         OLEDBG_BEGIN2("IOleObject::GetUserClassID called\r\n") <br>         hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserClassID( <br>               lpContainerLine-&gt;m_lpOleObj, (CLSID FAR*)&amp;clsidOld); <br>         OLEDBG_END2 <br>         if (hrErr != NOERROR) clsidOld = CLSID_NULL; <br>      } <br> <br>      A2W(lpszDisplayName, szDisplayName, 256); <br>      hrErr = OleStdMkParseDisplayName( <br>           &amp;clsidOld,lpbc,szDisplayName,lpchEaten,(LPMONIKER FAR*)&amp;lpmk); <br> <br>      if (hrErr != NOERROR) { <br>         sc = hrErr;   // ERROR in parsing moniker! <br>         goto cleanup; <br>      } <br>      /* NOTE: the link source was validated; it successfully <br>      **    parsed into a Moniker. we can set the source of the link <br>      **    directly with this Moniker. if we want the link to be <br>      **    able to know the correct class for the new link source, <br>      **    we must bind to the moniker and get the CLSID. if we do <br>      **    not do this then methods like IOleObject::GetUserType <br>      **    will return nothing (NULL strings). <br>      */ <br> <br>      hrErr = lpmk-&gt;lpVtbl-&gt;BindToObject( <br>            lpmk,lpbc,NULL,&amp;IID_IOleObject,(LPVOID FAR*)&amp;lpLinkSrcOleObj); <br>      if (hrErr == NOERROR) { <br>         OLEDBG_BEGIN2("IOleObject::GetUserClassID called\r\n") <br>         hrErr = lpLinkSrcOleObj-&gt;lpVtbl-&gt;GetUserClassID( <br>                     lpLinkSrcOleObj, (CLSID FAR*)&amp;clsid); <br>         OLEDBG_END2 <br>         lpContainerLine-&gt;m_fLinkUnavailable = FALSE; <br> <br>         /* get the short user type name of the link because it may <br>         **    have changed. we cache this name and must update our <br>         **    cache. this name is used all the time when we have to <br>         **    build the object verb menu. we cache this information <br>         **    to make it quicker to build the verb menu. <br>         */ <br>         if (lpContainerLine-&gt;m_lpszShortType) { <br>            OleStdFree(lpContainerLine-&gt;m_lpszShortType); <br>            lpContainerLine-&gt;m_lpszShortType = NULL; <br>         } <br>         OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n") <br>         lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               USERCLASSTYPE_SHORT, <br>               /*(LPOLESTR FAR*)*/&amp;lpContainerLine-&gt;m_lpszShortType <br>         ); <br>         OLEDBG_END2 <br>      } <br>      else <br>         lpContainerLine-&gt;m_fLinkUnavailable = TRUE; <br>   } <br>   else { <br>      LPMONIKER   lpmkFile = NULL; <br>      LPMONIKER   lpmkItem = NULL; <br>      char        szDelim[2]; <br>      OLECHAR     wszDelim[2]; <br>      char        *lpszName; <br>      OLECHAR     wszName[256]; <br> <br>      szDelim[0] = lpszDisplayName[(int)lenFileName]; <br>      szDelim[1] = '\0'; <br>      lpszDisplayName[(int)lenFileName] = '\0'; <br> <br>      OLEDBG_BEGIN2("CreateFileMoniker called\r\n") <br>      A2W(lpszDisplayName, szDisplayName, 256); <br>      CreateFileMoniker(szDisplayName, (LPMONIKER FAR*)&amp;lpmkFile); <br>      OLEDBG_END2 <br> <br>      lpszDisplayName[(int)lenFileName] = szDelim[0]; <br> <br>      if (!lpmkFile) <br>         goto cleanup; <br> <br>      if (strlen(lpszDisplayName) &gt; (int)lenFileName) {  // have item name <br>         lpszName = lpszDisplayName + lenFileName + 1; <br> <br>         OLEDBG_BEGIN2("CreateItemMoniker called\r\n") <br>         A2W(szDelim, wszDelim, 2); <br>         A2W(lpszName, wszName, 256); <br>         CreateItemMoniker( <br>               wszDelim, wszName, (LPMONIKER FAR*)&amp;lpmkItem); <br>         OLEDBG_END2 <br> <br>         if (!lpmkItem) { <br>            OleStdRelease((LPUNKNOWN)lpmkFile); <br>            goto cleanup; <br>         } <br> <br>         OLEDBG_BEGIN2("CreateGenericComposite called\r\n") <br>         CreateGenericComposite(lpmkFile, lpmkItem, (LPMONIKER FAR*)&amp;lpmk); <br>         OLEDBG_END2 <br> <br>         if (lpmkFile) <br>            OleStdRelease((LPUNKNOWN)lpmkFile); <br>         if (lpmkItem) <br>            OleStdRelease((LPUNKNOWN)lpmkItem); <br> <br>         if (!lpmk) <br>            goto cleanup; <br>      } <br>      else <br>         lpmk = lpmkFile; <br>   } <br> <br>   if (! lpOleLink) { <br>      OleDbgAssert(lpOleLink != NULL); <br>      sc = E_FAIL; <br>      goto cleanup; <br>   } <br> <br>   if (lpmk) { <br> <br>      OLEDBG_BEGIN2("IOleLink::SetSourceMoniker called\r\n") <br>      hrErr = lpOleLink-&gt;lpVtbl-&gt;SetSourceMoniker( <br>            lpOleLink, lpmk, (REFCLSID)&amp;clsid); <br>      OLEDBG_END2 <br> <br>      if (FAILED(hrErr)) { <br>         OleDbgOutHResult("IOleLink::SetSourceMoniker returned",hrErr); <br>         sc = hrErr; <br>         goto cleanup; <br>      } <br> <br>      /* NOTE: above we forced the link source moniker to bind. <br>      **    because we deliberately hold on to the bind context <br>      **    (lpbc) the link source object will not shut down. during <br>      **    the call to IOleLink::SetSourceMoniker, the link will <br>      **    connect to the running link source (the link internally <br>      **    calls BindIfRunning). it is important to initially allow <br>      **    the link to bind to the running object so that it can get <br>      **    an update of the presentation for its cache. we do not <br>      **    want the connection from our link to the link source be <br>      **    the only reason the link source stays running. thus we <br>      **    deliberately for the link to release (unbind) the source <br>      **    object, we then release the bind context, and then we <br>      **    allow the link to rebind to the link source if it is <br>      **    running anyway. <br>      */ <br>      if (lpbc &amp;&amp; lpmk-&gt;lpVtbl-&gt;IsRunning(lpmk,lpbc,NULL,NULL) == NOERROR) { <br> <br>         OLEDBG_BEGIN2("IOleLink::Update called\r\n") <br>         hrErr = lpOleLink-&gt;lpVtbl-&gt;Update(lpOleLink, NULL); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (FAILED(hrErr)) <br>            OleDbgOutHResult("IOleLink::Update returned",hrErr); <br>#endif <br> <br>         OLEDBG_BEGIN2("IOleLink::UnbindSource called\r\n") <br>         hrErr = lpOleLink-&gt;lpVtbl-&gt;UnbindSource(lpOleLink); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (FAILED(hrErr)) <br>            OleDbgOutHResult("IOleLink::UnbindSource returned",hrErr); <br>#endif <br> <br>         if (lpLinkSrcOleObj) { <br>            OleStdRelease((LPUNKNOWN)lpLinkSrcOleObj); <br>            lpLinkSrcOleObj = NULL; </code></pre>
<p>
</p>
<pre><code>} <br> <br>         if (lpbc) { <br>            OleStdRelease((LPUNKNOWN)lpbc); <br>            lpbc = NULL; <br>         } <br> <br>         OLEDBG_BEGIN2("IOleLink::BindIfRunning called\r\n") <br>         hrErr = lpOleLink-&gt;lpVtbl-&gt;BindIfRunning(lpOleLink); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (FAILED(hrErr)) <br>            OleDbgOutHResult("IOleLink::BindIfRunning returned",hrErr); <br>#endif <br>      } <br>   } else { <br>      /* NOTE: the link source was NOT validated; it was NOT <br>      **    successfully parsed into a Moniker. we can only set the <br>      **    display name string as the source of the link. this link <br>      **    is not able to bind. <br>      */ <br>      OLEDBG_BEGIN2("IOleLink::SetSourceDisplayName called\r\n") <br>      hrErr = lpOleLink-&gt;lpVtbl-&gt;SetSourceDisplayName( <br>            lpOleLink, (LPCOLESTR)lpszDisplayName); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("IOleLink::SetSourceDisplayName returned",hrErr); <br>         sc = hrErr; <br>         goto cleanup; <br>      } <br>   } <br> <br>cleanup: <br>   if (lpLinkSrcOleObj) <br>      OleStdRelease((LPUNKNOWN)lpLinkSrcOleObj); <br>   if (lpmk) <br>      OleStdRelease((LPUNKNOWN)lpmk); <br>   if (lpbc) <br>      OleStdRelease((LPUNKNOWN)lpbc); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_GetLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      LPSTR FAR*           lplpszDisplayName, <br>      ULONG FAR*              lplenFileName, <br>      LPSTR FAR*           lplpszFullLinkType, <br>      LPSTR FAR*           lplpszShortLinkType, <br>      BOOL FAR*               lpfSourceAvailable, <br>      BOOL FAR*               lpfIsSelected <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   LPOLELINK       lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   LPOLEOBJECT     lpOleObj = NULL; <br>   LPMONIKER       lpmk = NULL; <br>   LPMONIKER       lpmkFirst = NULL; <br>   LPBC            lpbc = NULL; <br>   SCODE           sc = S_OK; <br>   HRESULT         hrErr; <br>   LPOLESTR        lpwszFullLinkType; <br>   LPOLESTR        lpwszShortLinkType; <br>   LPOLESTR        lpwszDisplayName; <br>   int cch; <br> <br>   // artificial AddRef in case object is released during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_GetLinkSource\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   lpwszDisplayName  = NULL; <br>   lpwszFullLinkType = NULL; <br>   lpwszShortLinkType= NULL; <br>   *lplenFileName      = 0; <br>   *lpfSourceAvailable = !lpContainerLine-&gt;m_fLinkUnavailable; <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   if (! lpOleLink) { <br>      OLEDBG_END2 <br>      sc = E_FAIL; <br>      goto cleanup; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleLink::GetSourceMoniker called\r\n") <br>   hrErr = lpOleLink-&gt;lpVtbl-&gt;GetSourceMoniker( <br>         lpOleLink, <br>         (LPMONIKER FAR*)&amp;lpmk <br>   ); <br>   OLEDBG_END2 <br> <br>   if (hrErr == NOERROR) { <br>      /* NOTE: the link has the Moniker form of the link source; <br>      **    this is therefore a validated link source. if the first <br>      **    part of the Moniker is a FileMoniker, then we need to <br>      **    return the length of the filename string. we need to <br>      **    return the ProgID associated with the link source as the <br>      **    "lpszShortLinkType". we need to return the <br>      **    FullUserTypeName associated with the link source as the <br>      **    "lpszFullLinkType". <br>      */ <br> <br>      lpOleObj = (LPOLEOBJECT)OleStdQueryInterface( <br>            (LPUNKNOWN)lpOleLink, &amp;IID_IOleObject); <br>      *lplpszFullLinkType = NULL; <br>      *lplpszShortLinkType = NULL; <br>      if (lpOleObj) { <br>         lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>               lpOleObj, <br>               USERCLASSTYPE_FULL, <br>               &amp;lpwszFullLinkType <br>         ); <br>         if (lpwszFullLinkType) <br>         { <br>             cch = OLESTRLEN(lpwszFullLinkType) + 1; <br>             *lplpszFullLinkType = OleStdMalloc(cch); <br>             if (*lplpszFullLinkType) <br>             { <br>                 W2A(lpwszFullLinkType, *lplpszFullLinkType, cch); <br>             } <br>         } <br>         lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>               lpOleObj, <br>               USERCLASSTYPE_SHORT, <br>               &amp;lpwszShortLinkType <br>         ); <br>         if (lpwszShortLinkType) <br>         { <br>             cch = OLESTRLEN(lpwszShortLinkType) + 1; <br>             *lplpszShortLinkType = OleStdMalloc(cch); <br>             if (*lplpszShortLinkType) <br>             { <br>                 W2A(lpwszShortLinkType, *lplpszShortLinkType, cch); <br>             } <br>         } <br>         OleStdRelease((LPUNKNOWN)lpOleObj); <br>      } <br>      *lplenFileName = OleStdGetLenFilePrefixOfMoniker(lpmk); <br>      lpmk-&gt;lpVtbl-&gt;Release(lpmk); <br>   } <br> <br>   OLEDBG_BEGIN2("IOleLink::GetSourceDisplayName called\r\n") <br>   hrErr = lpOleLink-&gt;lpVtbl-&gt;GetSourceDisplayName( <br>         lpOleLink, <br>         &amp;lpwszDisplayName <br>   ); <br>   if (lpwszDisplayName) <br>   { <br>       cch = OLESTRLEN(lpwszDisplayName) + 1; <br>       *lplpszDisplayName = OleStdMalloc(cch); <br>       if (*lplpszDisplayName) <br>       { <br>           W2A(lpwszDisplayName, *lplpszDisplayName, cch); <br>       } <br>   } <br>   else <br>       *lplpszDisplayName = NULL; <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleLink::GetSourceDisplayName returned", hrErr); <br>      OLEDBG_END2 <br>      sc = hrErr; <br>      goto cleanup; <br>   } <br> <br>   OLEDBG_END2 <br> <br>   if (lpfIsSelected) <br>      *lpfIsSelected = Line_IsSelected((LPLINE)lpContainerLine); <br> <br>   sc = NOERROR; <br> <br>cleanup: <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_OpenLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   SCODE sc = S_OK; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_OpenLinkSource\r\n") <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   if (! ContainerLine_DoVerb( <br>         lpContainerLine, OLEIVERB_SHOW, NULL, TRUE, FALSE)) { <br>      sc = E_FAIL; <br>   } <br> <br>   lpContainerLine-&gt;m_fLinkUnavailable = (sc != S_OK); <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP CntrDoc_LinkCont_UpdateLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      BOOL                    fErrorMessage, <br>      BOOL                    fErrorAction        // ignore if fErrorMessage <br>                                       //      is FALSE <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   SCODE sc = S_OK; <br>   // default to update of the link <br>   HRESULT hrErr = S_FALSE; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_UpdateLink\r\n") <br> <br>   OleDbgAssert(lpContainerLine); <br> <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_LoadOleObject(lpContainerLine); <br> <br>   if (!fErrorMessage) { <br>      OLEDBG_BEGIN2("IOleObject::IsUpToDate called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;IsUpToDate( <br>            lpContainerLine-&gt;m_lpOleObj <br>      ); <br>      OLEDBG_END2 <br>   } <br> <br>   if (hrErr != NOERROR) { <br>      OLEDBG_BEGIN2("IOleObject::Update called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;Update( <br>            lpContainerLine-&gt;m_lpOleObj <br>      ); <br>      OLEDBG_END2 <br>   } <br> <br>   /* NOTE: If IOleObject::Update on the Link object returned <br>   **    OLE_E_CLASSDIFF because the link source is no longer <br>   **    the expected class, then the link should be re-created with <br>   **    the new link source. thus the link will be updated with the <br>   **    new link source. <br>   */ <br>   if (hrErr == OLE_E_CLASSDIFF) <br>      hrErr = ContainerLine_ReCreateLinkBecauseClassDiff(lpContainerLine); <br> <br>   lpContainerLine-&gt;m_fLinkUnavailable = (hrErr != NOERROR); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleObject::Update returned", hrErr); <br>      sc = hrErr; <br>      if (fErrorMessage) { <br>         ContainerLine_ProcessOleRunError( <br>               lpContainerLine,hrErr,fErrorAction,FALSE/*fMenuInvoked*/); <br>      } <br>   } <br>   /* NOTE: if the update of the object requires us to update our <br>   **    display, then we will automatically be sent a OnViewChange <br>   **    advise. thus we do not need to take any action here to force <br>   **    a repaint. <br>   */ <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return sc; <br>} <br> <br> <br>/* CntrDoc_LinkCont_CancelLink <br>** --------------------------- <br>**    Convert the link to a static picture. <br>** <br>**    NOTE: OleCreateStaticFromData can be used to create a static <br>**    picture object. <br>*/ <br>STDMETHODIMP CntrDoc_LinkCont_CancelLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>) <br>{ <br>   LPCONTAINERDOC lpContainerDoc = <br>         ((struct CDocOleUILinkContainerImpl FAR*)lpThis)-&gt;lpContainerDoc; <br>   LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink; <br>   LPLINELIST          lpLL = &amp;((LPOUTLINEDOC)lpContainerDoc)-&gt;m_LineList; <br>   LPLINE              lpLine = NULL; <br>   HDC                 hDC; <br>   int                 nTab = 0; <br>   OLECHAR             szStgName[CWCSTORAGENAME]; <br>   LPCONTAINERLINE     lpNewContainerLine = NULL; <br>   LPDATAOBJECT        lpSrcDataObj; <br>   LPOLELINK           lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrDoc_LinkCont_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrDoc_LinkCont_CancelLink\r\n") <br> <br>   /* we will first break the connection of the link to its source. */ <br>   if (lpOleLink) { <br>      lpContainerLine-&gt;m_dwLinkType = 0; <br>      OLEDBG_BEGIN2("IOleLink::SetSourceMoniker called\r\n") <br>      lpOleLink-&gt;lpVtbl-&gt;SetSourceMoniker( <br>            lpOleLink, NULL, (REFCLSID)&amp;CLSID_NULL); <br>      OLEDBG_END2 <br>   } <br> <br>   lpSrcDataObj = (LPDATAOBJECT)ContainerLine_GetOleObject( <br>         lpContainerLine,&amp;IID_IDataObject); <br>   if (! lpSrcDataObj) <br>      goto error; <br> <br>   ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, CWCSTORAGENAME); <br>   nTab = Line_GetTabLevel((LPLINE)lpContainerLine); <br>   hDC = LineList_GetDC(lpLL); <br> <br>   lpNewContainerLine = ContainerLine_CreateFromData( <br>         hDC, <br>         nTab, <br>         lpContainerDoc, <br>         lpSrcDataObj, <br>         OLECREATEFROMDATA_STATIC, <br>         0,   /* no special cfFormat required */ <br>         (lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_ICON), <br>         NULL,   /* hMetaPict */ <br>         szStgName <br>   ); <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   OleStdRelease((LPUNKNOWN)lpSrcDataObj); <br> <br>   if (! lpNewContainerLine) <br>      goto error; <br> <br>   OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, FALSE); <br> <br>   LineList_ReplaceLine(lpLL, (LPLINE)lpNewContainerLine, nIndex); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return NOERROR; <br> <br>error: <br>   OutlineApp_ErrorMessage(g_lpApp, OLESTR("Could not break the link.")); <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrDoc_LinkCont_Release(lpThis); <br> <br>   return E_FAIL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
