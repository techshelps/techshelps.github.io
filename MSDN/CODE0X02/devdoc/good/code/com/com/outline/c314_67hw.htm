<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SVRPSOBJ.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context314"></a>SVRPSOBJ.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Server Sample Code <br>** <br>**    svrpsobj.c <br>** <br>**    This file contains all PseudoObj methods and related support <br>**    functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br>extern IUnknownVtbl             g_PseudoObj_UnknownVtbl; <br>extern IOleObjectVtbl           g_PseudoObj_OleObjectVtbl; <br>extern IDataObjectVtbl          g_PseudoObj_DataObjectVtbl; <br> <br> <br>/* PseudoObj_Init <br>** -------------- <br>**  Initialize fields in a newly constructed PseudoObj. <br>**  NOTE: ref cnt of PseudoObj initialized to 0 <br>*/ <br>void PseudoObj_Init( <br>      LPPSEUDOOBJ             lpPseudoObj, <br>      LPSERVERNAME            lpServerName, <br>      LPSERVERDOC             lpServerDoc <br>) <br>{ <br>   OleDbgOut2("++PseudoObj Created\r\n"); <br> <br>   lpPseudoObj-&gt;m_cRef             = 0; <br>   lpPseudoObj-&gt;m_lpName           = lpServerName; <br>   lpPseudoObj-&gt;m_lpDoc            = lpServerDoc; <br>   lpPseudoObj-&gt;m_lpOleAdviseHldr  = NULL; <br>   lpPseudoObj-&gt;m_lpDataAdviseHldr = NULL; <br>   lpPseudoObj-&gt;m_fObjIsClosing    = FALSE; <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpPseudoObj-&gt;m_Unknown, <br>         &amp;g_PseudoObj_UnknownVtbl, <br>         lpPseudoObj <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpPseudoObj-&gt;m_OleObject, <br>         &amp;g_PseudoObj_OleObjectVtbl, <br>         lpPseudoObj <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpPseudoObj-&gt;m_DataObject, <br>         &amp;g_PseudoObj_DataObjectVtbl, <br>         lpPseudoObj <br>   ); <br> <br>   /* NOTE: Increment the refcnt of the Doc on behalf of the <br>   **    PseudoObj. the Document should not shut down unless all <br>   **    pseudo objects are closed. when a pseudo object is destroyed, <br>   **    it calls ServerDoc_PseudoObjUnlockDoc to release this hold on <br>   **    the document. <br>   */ <br>   ServerDoc_PseudoObjLockDoc(lpServerDoc); <br>} <br> <br> <br> <br>/* PseudoObj_AddRef <br>** ---------------- <br>** <br>**  increment the ref count of the PseudoObj object. <br>** <br>**    Returns the new ref count on the object <br>*/ <br>ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj) <br>{ <br>   ++lpPseudoObj-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRefCnt4( <br>         "PseudoObj_AddRef: cRef++\r\n", <br>         lpPseudoObj, <br>         lpPseudoObj-&gt;m_cRef <br>   ); <br>#endif <br>   return lpPseudoObj-&gt;m_cRef; <br>} <br> <br> <br>/* PseudoObj_Release <br>** ----------------- <br>** <br>**  decrement the ref count of the PseudoObj object. <br>**    if the ref count goes to 0, then the PseudoObj is destroyed. <br>** <br>**    Returns the remaining ref count on the object <br>*/ <br>ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj) <br>{ <br>   ULONG cRef; <br> <br>   /********************************************************************* <br>   ** NOTE: when the obj refcnt == 0, then destroy the object.     ** <br>   **     otherwise the object is still in use.                        ** <br>   *********************************************************************/ <br> <br>   cRef = --lpPseudoObj-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz(lpPseudoObj-&gt;m_cRef &gt;= 0,"Release called with cRef == 0"); <br> <br>   OleDbgOutRefCnt4( <br>         "PseudoObj_Release: cRef--\r\n", lpPseudoObj,cRef); <br>#endif <br> <br>   if (cRef == 0) <br>      PseudoObj_Destroy(lpPseudoObj); <br> <br>   return cRef; <br>} <br> <br> <br>/* PseudoObj_QueryInterface <br>** ------------------------ <br>** <br>** Retrieve a pointer to an interface on the PseudoObj object. <br>** <br>**    Returns S_OK if interface is successfully retrieved. <br>**            E_NOINTERFACE if the interface is not supported <br>*/ <br>HRESULT PseudoObj_QueryInterface( <br>      LPPSEUDOOBJ         lpPseudoObj, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   SCODE sc = E_NOINTERFACE; <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvObj = NULL; <br> <br>   if (IsEqualIID(riid, &amp;IID_IUnknown)) { <br>      OleDbgOut4("PseudoObj_QueryInterface: IUnknown* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpPseudoObj-&gt;m_Unknown; <br>      PseudoObj_AddRef(lpPseudoObj); <br>      sc = S_OK; <br>   } <br>   else if (IsEqualIID(riid, &amp;IID_IOleObject)) { <br>      OleDbgOut4("PseudoObj_QueryInterface: IOleObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpPseudoObj-&gt;m_OleObject; <br>      PseudoObj_AddRef(lpPseudoObj); <br>      sc = S_OK; <br>   } <br>   else if (IsEqualIID(riid, &amp;IID_IDataObject)) { <br>      OleDbgOut4("PseudoObj_QueryInterface: IDataObject* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpPseudoObj-&gt;m_DataObject; <br>      PseudoObj_AddRef(lpPseudoObj); <br>      sc = S_OK; <br>   } <br> <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br> <br>   return sc; <br>} <br> <br> <br>/* PseudoObj_Close <br> * --------------- <br> * <br> *  Close the pseudo object. Force all external connections to close <br> *      down. This causes link clients to release this PseudoObj. when <br> *      the refcount actually reaches 0, then the PseudoObj will be <br> *      destroyed. <br> * <br> *  Returns: <br> *      FALSE -- user canceled the closing of the doc. <br> *      TRUE -- the doc was successfully closed <br> */ <br> <br>BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj) <br>{ <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj-&gt;m_lpDoc; <br>   LPSERVERNAME lpServerName = (LPSERVERNAME)lpPseudoObj-&gt;m_lpName; <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   BOOL fStatus = TRUE; <br> <br>   if (lpPseudoObj-&gt;m_fObjIsClosing) <br>      return TRUE;    // Closing is already in progress <br> <br>   lpPseudoObj-&gt;m_fObjIsClosing = TRUE;   // guard against recursive call <br> <br>   OLEDBG_BEGIN3("PseudoObj_Close\r\n") <br> <br>   /* NOTE: in order to have a stable App, Doc, AND pseudo object <br>   **    during the process of closing, we intially AddRef the App, <br>   **    Doc, and PseudoObj ref counts and later Release them. These <br>   **    initial AddRefs are artificial; they are simply done to <br>   **    guarantee that these objects do not get destroyed until the <br>   **    end of this routine. <br>   */ <br>   OleApp_AddRef(lpOleApp); <br>   OleDoc_AddRef(lpOleDoc); <br>   PseudoObj_AddRef(lpPseudoObj); <br> <br>   if (lpPseudoObj-&gt;m_lpDataAdviseHldr) { <br>      /* NOTE: send last OnDataChange notification to clients <br>      **    that have registered for data notifications when object <br>      **    stops running (ADVF_DATAONSTOP) <br>      */ <br>      PseudoObj_SendAdvise( <br>            lpPseudoObj, <br>            OLE_ONDATACHANGE, <br>            NULL,   /* lpmkObj -- not relevant here */ <br>            ADVF_DATAONSTOP <br>      ); <br> <br>      /* NOTE: we just sent the last data notification that we <br>      **    need to send; release our DataAdviseHolder. we SHOULD be <br>      **    the only one using it. <br>      */ <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>            OLESTR("DataAdviseHldr not released properly") <br>      ); <br>      lpPseudoObj-&gt;m_lpDataAdviseHldr = NULL; <br>   } <br> <br>   if (lpPseudoObj-&gt;m_lpOleAdviseHldr) { <br>      // NOTE: inform all of our linking clients that we are closing. <br>      PseudoObj_SendAdvise( <br>            lpPseudoObj, <br>            OLE_ONCLOSE, <br>            NULL,   /* lpmkObj -- not relevant here */ <br>            0       /* advf -- not relevant here */ <br>      ); <br> <br>      /* NOTE: OnClose is the last notification that we need to <br>      **    send; release our OleAdviseHolder. we SHOULD be the only <br>      **    one using it. this will make our destructor realize that <br>      **    OnClose notification has already been sent. <br>      */ <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>            OLESTR("OleAdviseHldr not released properly") <br>      ); <br>      lpPseudoObj-&gt;m_lpOleAdviseHldr = NULL; <br>   } <br> <br>   /* NOTE: this call forces all external connections to our <br>   **    object to close down and therefore guarantees that we receive <br>   **    all releases associated with those external connections. <br>   */ <br>   OLEDBG_BEGIN2("CoDisconnectObject called\r\n") <br>   CoDisconnectObject((LPUNKNOWN)&amp;lpPseudoObj-&gt;m_Unknown, 0); <br>   OLEDBG_END2 <br> <br>   PseudoObj_Release(lpPseudoObj);     // release artificial AddRef above <br>   OleDoc_Release(lpOleDoc);           // release artificial AddRef above <br>   OleApp_Release(lpOleApp);           // release artificial AddRef above <br> <br>   OLEDBG_END3 <br>   return fStatus; <br>} <br> <br> <br>/* PseudoObj_Destroy <br>** ----------------- <br>**    Destroy (Free) the memory used by a PseudoObj structure. <br>**    This function is called when the ref count of the PseudoObj goes <br>**    to zero. the ref cnt goes to zero after PseudoObj_Delete forces <br>**    the OleObject to unload and release its pointers to the <br>**    PseudoObj IOleClientSite and IAdviseSink interfaces. <br>*/ <br> <br>void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj) <br>{ <br>   LPSERVERDOC lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LPOLEAPP    lpOleApp = (LPOLEAPP)g_lpApp; <br>   LPOLEDOC    lpOleDoc = (LPOLEDOC)lpServerDoc; <br> <br>   OLEDBG_BEGIN3("PseudoObj_Destroy\r\n") <br> <br>   /* NOTE: in order to have a stable App, Doc, AND pseudo object <br>   **    during the process of closing, we intially AddRef the App, <br>   **    Doc ref counts and later Release them. These <br>   **    initial AddRefs are artificial; they are simply done to <br>   **    guarantee that these objects do not get destroyed until the <br>   **    end of this routine. <br>   */ <br>   OleApp_AddRef(lpOleApp); <br>   OleDoc_AddRef(lpOleDoc); <br> <br>   /****************************************************************** <br>   ** NOTE: we no longer need the advise and enum holder objects, <br>   **    so release them. <br>   ******************************************************************/ <br> <br>   if (lpPseudoObj-&gt;m_lpDataAdviseHldr) { <br>      /* release DataAdviseHldr; we SHOULD be the only one using it. */ <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>            OLESTR("DataAdviseHldr not released properly") <br>         ); <br>      lpPseudoObj-&gt;m_lpDataAdviseHldr = NULL; <br>   } <br> <br>   if (lpPseudoObj-&gt;m_lpOleAdviseHldr) { <br>      /* release OleAdviseHldr; we SHOULD be the only one using it. */ <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>            OLESTR("OleAdviseHldr not released properly") <br>         ); <br>      lpPseudoObj-&gt;m_lpOleAdviseHldr = NULL; <br>   } <br> <br>   /* forget the pointer to destroyed PseudoObj in NameTable */ <br>   if (lpPseudoObj-&gt;m_lpName) <br>      lpPseudoObj-&gt;m_lpName-&gt;m_lpPseudoObj = NULL; <br> <br>   /* NOTE: release the lock on the Doc held on behalf of the <br>   **    PseudoObj. the Document should not shut down unless all <br>   **    pseudo objects are closed. when a pseudo object is first <br>   **    created, it calls ServerDoc_PseudoObjLockDoc to guarantee <br>   **    that the document stays alive (called from PseudoObj_Init). <br>   */ <br>   ServerDoc_PseudoObjUnlockDoc(lpServerDoc, lpPseudoObj); <br> <br>   Delete(lpPseudoObj);        // Free the memory for the structure itself <br> <br>   OleDoc_Release(lpOleDoc);       // release artificial AddRef above <br>   OleApp_Release(lpOleApp);       // release artificial AddRef above <br> <br>   OLEDBG_END3 <br>} <br> <br> <br>/* PseudoObj_GetSel <br>** ---------------- <br>**    Return the line range for the pseudo object <br>*/ <br>void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel) <br>{ <br>   LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj-&gt;m_lpName; <br>   lplrSel-&gt;m_nStartLine = lpOutlineName-&gt;m_nStartLine; <br>   lplrSel-&gt;m_nEndLine = lpOutlineName-&gt;m_nEndLine; <br>} <br> <br> <br>/* PseudoObj_GetExtent <br> * ------------------- <br> * <br> *      Get the extent (width, height) of the entire document. <br> */ <br>void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel) <br>{ <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj-&gt;m_lpDoc; <br>   LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>   LINERANGE lrSel; <br> <br>   PseudoObj_GetSel(lpPseudoObj, (LPLINERANGE)&amp;lrSel); <br> <br>   LineList_CalcSelExtentInHimetric(lpLL, (LPLINERANGE)&amp;lrSel, lpsizel); <br>} <br> <br> <br>/* PseudoObj_SendAdvise <br> * -------------------- <br> * <br> * This function sends an advise notification on behalf of a specific <br> *  doc object to all its clients. <br> */ <br>void PseudoObj_SendAdvise( <br>      LPPSEUDOOBJ lpPseudoObj, <br>      WORD        wAdvise, <br>      LPMONIKER   lpmkObj, <br>      DWORD       dwAdvf <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj-&gt;m_lpDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_AddRef(lpPseudoObj); <br> <br>   switch (wAdvise) { <br> <br>      case OLE_ONDATACHANGE: <br> <br>         // inform clients that the data of the object has changed <br> <br>         if (lpOutlineDoc-&gt;m_nDisableDraw == 0) { <br>            /* drawing is currently enabled. inform clients that <br>            **    the data of the object has changed <br>            */ <br> <br>            lpPseudoObj-&gt;m_fDataChanged = FALSE; <br>            if (lpPseudoObj-&gt;m_lpDataAdviseHldr) { <br> <br>               OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n"); <br>               lpPseudoObj-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;SendOnDataChange( <br>                     lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>                     (LPDATAOBJECT)&amp;lpPseudoObj-&gt;m_DataObject, <br>                     0, <br>                     dwAdvf <br>               ); <br>               OLEDBG_END2 <br>            } <br> <br>         } else { <br>            /* drawing is currently disabled. do not send <br>            **    notifications until drawing is re-enabled. <br>            */ <br>            lpPseudoObj-&gt;m_fDataChanged = TRUE; <br>         } <br>         break; <br> <br>      case OLE_ONCLOSE: <br> <br>         // inform clients that the object is shutting down <br> <br>         if (lpPseudoObj-&gt;m_lpOleAdviseHldr) { <br> <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n"); <br>            lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnClose( <br>                  lpPseudoObj-&gt;m_lpOleAdviseHldr <br>            ); <br>            OLEDBG_END2 <br>         } <br>         break; <br> <br>      case OLE_ONSAVE: <br> <br>         // inform clients that the object has been saved <br> <br>         if (lpPseudoObj-&gt;m_lpOleAdviseHldr) { <br> <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n"); <br>            lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnSave( <br>                  lpPseudoObj-&gt;m_lpOleAdviseHldr <br>            ); <br>            OLEDBG_END2 <br>         } <br>         break; <br> <br>      case OLE_ONRENAME: <br> <br>         // inform clients that the object's name has changed <br>         if (lpmkObj &amp;&amp; lpPseudoObj-&gt;m_lpOleAdviseHldr) { <br> <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n"); <br>            if (lpPseudoObj-&gt;m_lpOleAdviseHldr) <br>               lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnRename( <br>                     lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>                     lpmkObj <br>               ); <br>            OLEDBG_END2 <br>         } <br>         break; <br>   } <br>   // release artificial AddRef <br>   PseudoObj_Release(lpPseudoObj); <br>} <br> <br> <br>/* PseudoObj_GetFullMoniker <br> * ------------------------ <br> * <br> * Returns the Full, absolute Moniker which identifies this pseudo object. <br> */ <br>LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc) <br>{ <br>   LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj-&gt;m_lpName; <br>   LPMONIKER lpmkItem = NULL; <br>   LPMONIKER lpmkPseudoObj = NULL; <br> <br>   if (lpmkDoc != NULL) { <br>      CreateItemMoniker(OLESTR("\\"), lpOutlineName-&gt;m_szName, &amp;lpmkItem); <br> <br>      /* NOTE: create an absolute moniker which identifies the <br>      **    pseudo object. this moniker is created as a composite of <br>      **    the absolute moniker for the entire document appended <br>      **    with an item moniker which identifies the selection of <br>      **    the pseudo object relative to the document. <br>      */ <br>      CreateGenericComposite(lpmkDoc, lpmkItem, &amp;lpmkPseudoObj); <br> <br>      if (lpmkItem) <br>         OleStdRelease((LPUNKNOWN)lpmkItem); <br> <br>      return lpmkPseudoObj; <br>   } else { <br>      return NULL; <br>   } <br>} <br> <br> <br>/************************************************************************* <br>** PseudoObj::IUnknown interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP PseudoObj_Unk_QueryInterface( <br>      LPUNKNOWN         lpThis, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpvObj <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjUnknownImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjUnknownImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgAddRefMethod(lpThis, "IUnknown"); <br> <br>   return PseudoObj_AddRef(lpPseudoObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjUnknownImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgReleaseMethod(lpThis, "IUnknown"); <br> <br>   return PseudoObj_Release(lpPseudoObj); <br>} <br> <br> <br>/************************************************************************* <br>** PseudoObj::IOleObject interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP PseudoObj_OleObj_QueryInterface( <br>      LPOLEOBJECT     lpThis, <br>      REFIID          riid, <br>      LPVOID FAR*     lplpvObj <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleObject"); <br> <br>   return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleObject"); <br> <br>   return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj); <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_SetClientSite( <br>      LPOLEOBJECT         lpThis, <br>      LPOLECLIENTSITE     lpClientSite <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_SetClientSite\r\n"); <br> <br>   // NOTE: a pseudo object does NOT support SetExtent <br> <br>   return E_FAIL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE FAR*    lplpClientSite <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_GetClientSite\r\n"); <br> <br>   *lplpClientSite = NULL; <br> <br>   // NOTE: a pseudo object does NOT support SetExtent <br> <br>   return E_FAIL; <br>} <br> <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_SetHostNames( <br>      LPOLEOBJECT             lpThis, <br>      LPCOLESTR               szContainerApp, <br>      LPCOLESTR               szContainerObj <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_SetHostNames\r\n"); <br> <br>   // NOTE: a pseudo object does NOT support SetExtent <br> <br>   return E_FAIL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_Close( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwSaveOption <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   BOOL fStatus; <br> <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_Close\r\n") <br> <br>   /* NOTE: a pseudo object's implementation of IOleObject::Close <br>   **    should ignore the dwSaveOption parameter. it is NOT <br>   **    applicable to pseudo objects. <br>   */ <br> <br>   fStatus = PseudoObj_Close(lpPseudoObj); <br>   OleDbgAssertSz(fStatus == TRUE, "PseudoObj_OleObj_Close failed\r\n"); <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_SetMoniker( <br>      LPOLEOBJECT lpThis, <br>      DWORD       dwWhichMoniker, <br>      LPMONIKER   lpmk <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_SetMoniker\r\n"); <br> <br>   // NOTE: a pseudo object does NOT support SetMoniker <br> <br>   return E_FAIL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetMoniker( <br>      LPOLEOBJECT     lpThis, <br>      DWORD           dwAssign, <br>      DWORD           dwWhichMoniker, <br>      LPMONIKER FAR*  lplpmk <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj-&gt;m_lpDoc; <br>   LPMONIKER lpmkDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_GetMoniker\r\n") <br> <br>   lpmkDoc = OleDoc_GetFullMoniker(lpOleDoc, GETMONIKER_ONLYIFTHERE); <br>   *lplpmk = PseudoObj_GetFullMoniker(lpPseudoObj, lpmkDoc); <br> <br>   OLEDBG_END2 <br> <br>   if (*lplpmk != NULL) <br>   { <br>      // release artificial AddRef <br>      PseudoObj_OleObj_Release(lpThis); <br>      return NOERROR; <br>   } <br>   else <br>   { <br>      // release artificial AddRef <br>      PseudoObj_OleObj_Release(lpThis); <br>      return E_FAIL; <br>   } <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_InitFromData( <br>      LPOLEOBJECT             lpThis, <br>      LPDATAOBJECT            lpDataObject, <br>      BOOL                    fCreation, <br>      DWORD                   reserved <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   OleDbgOut2("PseudoObj_OleObj_InitFromData\r\n"); <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetClipboardData( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   reserved, <br>      LPDATAOBJECT FAR*       lplpDataObject <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   OleDbgOut2("PseudoObj_OleObj_GetClipboardData\r\n"); <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_DoVerb( <br>      LPOLEOBJECT             lpThis, <br>      LONG                    lVerb, <br>      LPMSG                   lpmsg, <br>      LPOLECLIENTSITE         lpActiveSite, <br>      LONG                    lindex, <br>      HWND                    hwndParent, <br>      LPCRECT                 lprcPosRect <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj-&gt;m_lpDoc; <br>   LPSERVERDOC lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LINERANGE lrSel; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_DoVerb\r\n"); <br> <br>   /* NOTE: we must first ask our Document to perform the same <br>   **    verb. then if the verb is NOT OLEIVERB_HIDE we should also <br>   **    select the range of our pseudo object. <br>   **    however, we must give our document its own embedding site as <br>   **    its active site. <br>   */ <br>   hrErr = SvrDoc_OleObj_DoVerb( <br>         (LPOLEOBJECT)&amp;lpServerDoc-&gt;m_OleObject, <br>         lVerb, <br>         lpmsg, <br>         lpServerDoc-&gt;m_lpOleClientSite, <br>         lindex, <br>         NULL,   /* we have no hwndParent to give */ <br>         NULL    /* we have no lprcPosRect to give */ <br>   ); <br>   if (FAILED(hrErr)) { <br>      OLEDBG_END2 <br>      // release artificial AddRef <br>      PseudoObj_OleObj_Release(lpThis); <br>      return hrErr; <br>   } <br> <br>   if (lVerb != OLEIVERB_HIDE) { <br>      PseudoObj_GetSel(lpPseudoObj, &amp;lrSel); <br>      OutlineDoc_SetSel(lpOutlineDoc, &amp;lrSel); <br>   } <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_OleObj_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_EnumVerbs( <br>      LPOLEOBJECT         lpThis, <br>      LPENUMOLEVERB FAR*  lplpenumOleVerb <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_EnumVerbs\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumOleVerb = NULL; <br> <br>   /* A pseudo object may NOT return OLE_S_USEREG; they must call the <br>   **    OleReg* API or provide their own implementation. Because this <br>   **    pseudo object does NOT implement IPersist, simply a low-level <br>   **    remoting handler (ProxyManager) object as opposed to a <br>   **    DefHandler object is used as the handler for the pseudo <br>   **    object in a clients process space. The ProxyManager does NOT <br>   **    handle the OLE_S_USEREG return values. <br>   */ <br>   return OleRegEnumVerbs((REFCLSID)&amp;CLSID_APP, lplpenumOleVerb); <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_Update\r\n"); <br> <br>   /* NOTE: a server-only app is always "up-to-date". <br>   **    a container-app which contains links where the link source <br>   **    has changed since the last update of the link would be <br>   **    considered "out-of-date". the "Update" method instructs the <br>   **    object to get an update from any out-of-date links. <br>   */ <br> <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   OleDbgOut2("PseudoObj_OleObj_IsUpToDate\r\n"); <br> <br>   /* NOTE: a server-only app is always "up-to-date". <br>   **    a container-app which contains links where the link source <br>   **    has changed since the last update of the link would be <br>   **    considered "out-of-date". <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetUserClassID( <br>      LPOLEOBJECT             lpThis, <br>      LPCLSID                 lpclsid <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj-&gt;m_lpDoc; <br>   OleDbgOut2("PseudoObj_OleObj_GetUserClassID\r\n"); <br> <br>   /* NOTE: we must be carefull to return the correct CLSID here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the class of the object <br>   **    written in the storage of the object. otherwise we would <br>   **    return our own class id. <br>   */ <br>   return ServerDoc_GetClassID(lpServerDoc, lpclsid); <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetUserType( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwFormOfType, <br>      LPOLESTR FAR*           lpszUserType <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj-&gt;m_lpDoc; <br>   OleDbgOut2("PseudoObj_OleObj_GetUserType\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lpszUserType = NULL; <br> <br>   /* NOTE: we must be carefull to return the correct user type here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the user type name that <br>   **    corresponds to the class of the object we are currently <br>   **    emmulating. otherwise we should return our normal user type <br>   **    name corresponding to our own class. This routine determines <br>   **    the current clsid in effect. <br>   ** <br>   **    A pseudo object may NOT return OLE_S_USEREG; they must call the <br>   **    OleReg* API or provide their own implementation. Because this <br>   **    pseudo object does NOT implement IPersist, simply a low-level <br>   **    remoting handler (ProxyManager) object as opposed to a <br>   **    DefHandler object is used as the handler for the pseudo <br>   **    object in a clients process space. The ProxyManager does NOT <br>   **    handle the OLE_S_USEREG return values. <br>   */ <br>#if defined( SVR_TREATAS ) <br>   if (! IsEqualCLSID(&amp;lpServerDoc-&gt;m_clsidTreatAs, &amp;CLSID_NULL) ) <br>      return OleRegGetUserType( <br>         (REFCLSID)&amp;lpServerDoc-&gt;m_clsidTreatAs,dwFormOfType,lpszUserType); <br>   else <br>#endif  // SVR_TREATAS <br> <br>   return OleRegGetUserType((REFCLSID)&amp;CLSID_APP,dwFormOfType,lpszUserType); <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_SetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_SetExtent\r\n"); <br> <br>   // NOTE: a pseudo object does NOT support SetExtent <br> <br>   return E_FAIL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lpsizel <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   OleDbgOut2("PseudoObj_OleObj_GetExtent\r\n"); <br> <br>   /* NOTE: it is VERY important to check which aspect the caller <br>   **    is asking about. an object implemented by a server EXE MAY <br>   **    fail to return extents when asked for DVASPECT_ICON. <br>   */ <br>   if (dwDrawAspect == DVASPECT_CONTENT) { <br>      PseudoObj_GetExtent(lpPseudoObj, lpsizel); <br>      return NOERROR; <br>   } <br>   else <br>   { <br>      return E_FAIL; <br>   } <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_Advise( <br>      LPOLEOBJECT lpThis, <br>      LPADVISESINK lpAdvSink, <br>      LPDWORD lpdwConnection <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_Advise\r\n"); <br> <br>   if (lpPseudoObj-&gt;m_lpOleAdviseHldr == NULL &amp;&amp; <br>      CreateOleAdviseHolder(&amp;lpPseudoObj-&gt;m_lpOleAdviseHldr) != NOERROR) { </code></pre>
<p>
</p>
<pre><code>sc = E_OUTOFMEMORY; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;Advise( <br>         lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>         lpAdvSink, <br>         lpdwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_Unadvise\r\n"); <br> <br>   if (lpPseudoObj-&gt;m_lpOleAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::Unadvise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;Unadvise( <br>         lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>         dwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_OleObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_EnumAdvise( <br>      LPOLEOBJECT lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_OleObj_EnumAdvise\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumAdvise = NULL; <br> <br>   if (lpPseudoObj-&gt;m_lpOleAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;EnumAdvise( <br>         lpPseudoObj-&gt;m_lpOleAdviseHldr, <br>         lplpenumAdvise <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_OleObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_GetMiscStatus( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAspect, <br>      DWORD FAR*              lpdwStatus <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjOleObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj-&gt;m_lpDoc; <br>   OleDbgOut2("PseudoObj_OleObj_GetMiscStatus\r\n"); <br> <br>   /* Get our default MiscStatus for the given Aspect. this <br>   **    information is registered in the RegDB. We query the RegDB <br>   **    here to guarantee that the value returned from this method <br>   **    agrees with the values in RegDB. in this way we only have to <br>   **    maintain the info in one place (in the RegDB). Alternatively <br>   **    we could have the values hard coded here. <br>   ** <br>   ** NOTE: A pseudo object may NOT return OLE_S_USEREG; they must <br>   **    call the <br>   **    OleReg* API or provide their own implementation. Because this <br>   **    pseudo object does NOT implement IPersist, simply a low-level <br>   **    remoting handler (ProxyManager) object as opposed to a <br>   **    DefHandler object is used as the handler for the pseudo <br>   **    object in a clients process space. The ProxyManager does NOT <br>   **    handle the OLE_S_USEREG return values. <br>   */ <br>   OleRegGetMiscStatus((REFCLSID)&amp;CLSID_APP, dwAspect, lpdwStatus); <br> <br>   /* NOTE: check if the pseudo object is compatible to be <br>   **    linked by an OLE 1.0 container. it is compatible if <br>   **    either the pseudo object is an untitled document or a <br>   **    file-based document. if the pseudo object is part of <br>   **    an embedded object, then it is NOT compatible to be <br>   **    linked by an OLE 1.0 container. if it is compatible then <br>   **    we should include OLEMISC_CANLINKBYOLE1 as part of the <br>   **    dwStatus flags. <br>   */ <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_NEW || <br>      lpOutlineDoc-&gt;m_docInitType == DOCTYPE_FROMFILE) <br>      *lpdwStatus |= OLEMISC_CANLINKBYOLE1; <br> <br>   return NOERROR; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_OleObj_SetColorScheme( <br>      LPOLEOBJECT             lpThis, <br>      LPLOGPALETTE            lpLogpal <br>) <br>{ <br>   OleDbgOut2("PseudoObj_OleObj_SetColorScheme\r\n"); <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br>/************************************************************************* <br>** PseudoObj::IDataObject interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP PseudoObj_DataObj_QueryInterface ( <br>      LPDATAOBJECT      lpThis, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpvObj <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgAddRefMethod(lpThis, "IDataObject"); <br> <br>   return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br> <br>   OleDbgReleaseMethod(lpThis, "IDataObject"); <br> <br>   return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj); <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_GetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpMedium <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC  lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br>   LINERANGE lrSel; <br>   SCODE sc = S_OK; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_DataObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_DataObj_GetData\r\n") <br> <br>   PseudoObj_GetSel(lpPseudoObj, &amp;lrSel); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   lpMedium-&gt;tymed = TYMED_NULL; <br>   lpMedium-&gt;pUnkForRelease = NULL;    // we transfer ownership to caller <br>   lpMedium-&gt;u.hGlobal = NULL; <br> <br>   if (lpformatetc-&gt;cfFormat == lpOutlineApp-&gt;m_cfOutline) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DATA_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetOutlineData (lpOutlineDoc,&amp;lrSel); <br>      if (! lpMedium-&gt;u.hGlobal) return E_OUTOFMEMORY; <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_OUTLINE\r\n"); <br> <br>   } else if(lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; DVASPECT_CONTENT) ) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_MFPICT)) { <br>         sc = DATA_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal=ServerDoc_GetMetafilePictData(lpServerDoc,&amp;lrSel); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br>      lpMedium-&gt;tymed = TYMED_MFPICT; <br>      OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT\r\n"); <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; DVASPECT_ICON) ) { <br>      CLSID clsid; <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_MFPICT)) { <br>         sc = DATA_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      /* NOTE: we should return the default icon for our class. <br>      **    we must be carefull to use the correct CLSID here. <br>      **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>      **    operation then we need to use the class of the object <br>      **    written in the storage of the object. otherwise we would <br>      **    use our own class id. <br>      */ <br>      if (ServerDoc_GetClassID(lpServerDoc, (LPCLSID)&amp;clsid) != NOERROR) { <br>         sc = DATA_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal=GetIconOfClass( <br>            g_lpApp-&gt;m_hInst,(REFCLSID)&amp;clsid, NULL, FALSE); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;tymed = TYMED_MFPICT; <br>      OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT (icon)\r\n"); <br>      // release artificial AddRef <br>      PseudoObj_DataObj_Release(lpThis); <br>      return NOERROR; <br> <br>   } else if (lpformatetc-&gt;cfFormat == CF_TEXT) { <br>      // Verify caller asked for correct medium <br>      if (!(lpformatetc-&gt;tymed &amp; TYMED_HGLOBAL)) { <br>         sc = DATA_E_FORMATETC; <br>         goto error; <br>      } <br> <br>      lpMedium-&gt;u.hGlobal = OutlineDoc_GetTextData (lpOutlineDoc, &amp;lrSel); <br>      if (! lpMedium-&gt;u.hGlobal) { <br>         sc = E_OUTOFMEMORY; <br>         goto error; <br>      } <br>      lpMedium-&gt;tymed = TYMED_HGLOBAL; <br>      OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_TEXT\r\n"); <br> <br>   } else { <br>      sc = DATA_E_FORMATETC; <br>      goto error; <br>   } <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_GetDataHere ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpMedium <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC  lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br> <br> <br>   OleDbgOut("PseudoObj_DataObj_GetDataHere\r\n"); <br> <br>   /* Caller is requesting data to be returned in Caller allocated <br>   **    medium, but we do NOT support this. we only support <br>   **    global memory blocks that WE allocate for the caller. <br>   */ <br>   return DATA_E_FORMATETC; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_QueryGetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC  lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br>   LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp; <br>   LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_DataObj_AddRef(lpThis); <br> <br>   OleDbgOut2("PseudoObj_DataObj_QueryGetData\r\n"); <br> <br>   /* Caller is querying if we support certain format but does not <br>   **    want any data actually returned. <br>   */ <br>   if (lpformatetc-&gt;cfFormat == CF_METAFILEPICT &amp;&amp; <br>      (lpformatetc-&gt;dwAspect &amp; (DVASPECT_CONTENT | DVASPECT_ICON)) ) { <br>      // release artificial AddRef <br>      PseudoObj_DataObj_Release(lpThis); <br>      return OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT); <br> <br>   } else if (lpformatetc-&gt;cfFormat == (lpOutlineApp)-&gt;m_cfOutline || <br>         lpformatetc-&gt;cfFormat == CF_TEXT) { <br>      // release artificial AddRef <br>      PseudoObj_DataObj_Release(lpThis); <br>      return OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL); <br>   } <br> <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return DATA_E_FORMATETC; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPFORMATETC     lpformatetcOut <br>) <br>{ <br>   HRESULT hrErr; <br>   OleDbgOut2("PseudoObj_DataObj_GetCanonicalFormatEtc\r\n"); <br> <br>   if (!lpformatetcOut) <br>      return E_INVALIDARG; <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   lpformatetcOut-&gt;ptd = NULL; <br> <br>   if (!lpformatetc) <br>      return E_INVALIDARG; <br> <br>   // NOTE: we must validate that the format requested is supported <br>   if ((hrErr=lpThis-&gt;lpVtbl-&gt;QueryGetData(lpThis,lpformatetc)) != NOERROR) <br>      return hrErr; <br> <br>   /* NOTE: an app that is insensitive to target device (as the <br>   **    Outline Sample is) should fill in the lpformatOut parameter <br>   **    but NULL out the "ptd" field; it should return NOERROR if the <br>   **    input formatetc-&gt;ptd what non-NULL. this tells the caller <br>   **    that it is NOT necessary to maintain a separate screen <br>   **    rendering and printer rendering. if should return <br>   **    DATA_S_SAMEFORMATETC if the input and output formatetc's are <br>   **    identical. <br>   */ <br> <br>   *lpformatetcOut = *lpformatetc; <br>   if (lpformatetc-&gt;ptd == NULL) <br>      return DATA_S_SAMEFORMATETC; <br>   else { <br>      lpformatetcOut-&gt;ptd = NULL; <br>      return NOERROR; <br>   } <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_SetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpmedium, <br>      BOOL            fRelease <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   LPSERVERDOC  lpServerDoc = lpPseudoObj-&gt;m_lpDoc; <br>   LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp; <br> <br>   OleDbgOut2("PseudoObj_DataObj_SetData\r\n"); <br> <br>   // REVIEW: NOT-YET-IMPLEMENTED <br>   return E_NOTIMPL; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc( <br>      LPDATAOBJECT            lpThis, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>) <br>{ <br>   SCODE sc; <br>   OleDbgOut2("PseudoObj_DataObj_EnumFormatEtc\r\n"); <br> <br>   /* NOTE: a pseudo object only needs to enumerate the static list <br>   **    of formats that are registered for our app in the <br>   **    registration database. it is NOT <br>   **    required that a pseudo object (ie. non-DataTransferDoc) <br>   **    enumerate the OLE formats: CF_LINKSOURCE, CF_EMBEDSOURCE, or <br>   **    CF_EMBEDDEDOBJECT. we do NOT use pseudo objects for data <br>   **    transfers. <br>   ** <br>   **    A pseudo object may NOT return OLE_S_USEREG; they must call the <br>   **    OleReg* API or provide their own implementation. Because this <br>   **    pseudo object does NOT implement IPersist, simply a low-level <br>   **    remoting handler (ProxyManager) object as opposed to a <br>   **    DefHandler object is used as the handler for the pseudo <br>   **    object in a clients process space. The ProxyManager does NOT <br>   **    handle the OLE_S_USEREG return values. <br>   */ <br>   if (dwDirection == DATADIR_GET) <br>      return OleRegEnumFormatEtc( <br>            (REFCLSID)&amp;CLSID_APP, dwDirection, lplpenumFormatEtc); <br>   else if (dwDirection == DATADIR_SET) <br>      sc = E_NOTIMPL; <br>   else <br>      sc = E_INVALIDARG; <br> <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_DAdvise( <br>      LPDATAOBJECT    lpThis, <br>      FORMATETC FAR*  lpFormatetc, <br>      DWORD           advf, <br>      LPADVISESINK    lpAdvSink, <br>      DWORD FAR*      lpdwConnection <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_DataObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_DataObj_DAdvise\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lpdwConnection = 0; <br> <br>   /* NOTE: we should validate if the caller is setting up an <br>   **    Advise for a data type that we support. we must <br>   **    explicitly allow an advise for the "wildcard" advise. <br>   */ <br>#ifdef WIN32 <br>   if ( !( lpFormatetc-&gt;cfFormat == 0 &amp;&amp; <br>      lpFormatetc-&gt;ptd == 0 &amp;&amp; <br>#else <br>   if ( !( lpFormatetc-&gt;cfFormat == NULL &amp;&amp; <br>      lpFormatetc-&gt;ptd == NULL &amp;&amp; <br>#endif <br>      lpFormatetc-&gt;dwAspect == -1L &amp;&amp; <br>      lpFormatetc-&gt;lindex == -1L &amp;&amp; <br>      lpFormatetc-&gt;tymed == -1L) &amp;&amp; <br>      (hrErr = PseudoObj_DataObj_QueryGetData(lpThis, lpFormatetc)) <br>         != NOERROR) { <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   if (lpPseudoObj-&gt;m_lpDataAdviseHldr == NULL &amp;&amp; <br>      CreateDataAdviseHolder(&amp;lpPseudoObj-&gt;m_lpDataAdviseHldr) != NOERROR) { <br>      sc = E_OUTOFMEMORY; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;Advise( <br>         lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>         (LPDATAOBJECT)&amp;lpPseudoObj-&gt;m_DataObject, <br>         lpFormatetc, <br>         advf, <br>         lpAdvSink, <br>         lpdwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_DataObj_AddRef(lpThis); <br>   OLEDBG_BEGIN2("PseudoObj_DataObj_Unadvise\r\n"); <br> <br>   // no one registered <br>   if (lpPseudoObj-&gt;m_lpDataAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::DUnadvise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;Unadvise( <br>         lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>         dwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>STDMETHODIMP PseudoObj_DataObj_EnumAdvise( <br>      LPDATAOBJECT lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>) <br>{ <br>   LPPSEUDOOBJ lpPseudoObj = <br>         ((struct CPseudoObjDataObjectImpl FAR*)lpThis)-&gt;lpPseudoObj; <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   PseudoObj_DataObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("PseudoObj_DataObj_EnumAdvise\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumAdvise = NULL; <br> <br>   if (lpPseudoObj-&gt;m_lpDataAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n") <br>   hrErr = lpPseudoObj-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;EnumAdvise( <br>         lpPseudoObj-&gt;m_lpDataAdviseHldr, <br>         lplpenumAdvise <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   PseudoObj_DataObj_Release(lpThis); <br>   return sc; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
