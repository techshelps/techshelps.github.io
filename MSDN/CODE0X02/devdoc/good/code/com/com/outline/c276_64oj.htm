<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAGDROP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context283"></a>DRAGDROP.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    dragdrop.c <br>** <br>**    This file contains the major interfaces, methods and related support <br>**    functions for implementing Drag/Drop. The code contained in this <br>**    file is used by BOTH the Container and Server (Object) versions <br>**    of the Outline sample code. <br>**    The Drag/Drop support includes the following implementation objects: <br>** <br>**    OleDoc Object <br>**      exposed interfaces: <br>**          IDropSource <br>**          IDropTarget <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br> <br> <br>#if defined( USE_DRAGDROP ) <br> <br>/* OleDoc_QueryDrag <br> * ---------------- <br> * Check to see if Drag operation should be initiated. A Drag operation <br> * should be initiated when the mouse in either the top 10 pixels of the <br> * selected list box entry or in the bottom 10 pixels of the last selected <br> * item. <br> */ <br> <br>BOOL OleDoc_QueryDrag(LPOLEDOC lpOleDoc, int y) <br>{ <br>        LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>        LINERANGE LineRange; <br> <br>        if ( LineList_GetSel( lpLL,  (LPLINERANGE)&amp;LineRange) ) { <br>                RECT rect; <br> <br>                if (!LineList_GetLineRect(lpLL,LineRange.m_nStartLine,(LPRECT)&amp;rect)) <br>                        return FALSE ; <br> <br>                if ( rect.top &lt;= y &amp;&amp; y &lt;= rect.top + DD_SEL_THRESH ) <br>                        return TRUE; <br> <br>                LineList_GetLineRect( lpLL, LineRange.m_nEndLine, (LPRECT)&amp;rect ); <br>                if ( rect.bottom &gt;= y &amp;&amp; y &gt;= rect.bottom - DD_SEL_THRESH ) <br>                        return TRUE; <br> <br>        } <br> <br>        return FALSE; <br>} <br> <br>/* OleDoc_DoDragScroll <br> * ------------------- <br> * Check to see if Drag scroll operation should be initiated. A Drag scroll <br> * operation should be initiated when the mouse has remained in the active <br> * scroll area (11 pixels frame around border of window) for a specified <br> * amount of time (50ms). <br> */ <br> <br>BOOL OleDoc_DoDragScroll(LPOLEDOC lpOleDoc, POINTL pointl) <br>{ <br>        LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>        LPLINELIST lpLL = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>        HWND hWndListBox = LineList_GetWindow(lpLL); <br>        DWORD dwScrollDir = SCROLLDIR_NULL; <br>        DWORD dwTime = GetCurrentTime(); <br>        int nScrollInset = lpOleApp-&gt;m_nScrollInset; <br>        int nScrollDelay = lpOleApp-&gt;m_nScrollDelay; <br>        int nScrollInterval = lpOleApp-&gt;m_nScrollInterval; <br>        POINT point; <br>        RECT rect; <br> <br>        if ( lpLL-&gt;m_nNumLines == 0 ) <br>                return FALSE; <br> <br>        point.x = (int)pointl.x; <br>        point.y = (int)pointl.y; <br> <br>        ScreenToClient( hWndListBox, &amp;point); <br>        GetClientRect ( hWndListBox, (LPRECT) &amp;rect ); <br> <br>        if (rect.top &lt;= point.y &amp;&amp; point.y&lt;=(rect.top+nScrollInset)) <br>                dwScrollDir = SCROLLDIR_UP; <br>        else if ((rect.bottom-nScrollInset) &lt;= point.y &amp;&amp; point.y &lt;= rect.bottom) <br>                dwScrollDir = SCROLLDIR_DOWN; <br> <br>        if (lpOleDoc-&gt;m_dwTimeEnterScrollArea) { <br> <br>                /* cursor was already in Scroll Area */ <br> <br>                if (! dwScrollDir) { <br>                        /* cusor moved OUT of scroll area. <br>                        **      clear "EnterScrollArea" time. <br>                        */ <br>                        lpOleDoc-&gt;m_dwTimeEnterScrollArea = 0L; <br>                        lpOleDoc-&gt;m_dwNextScrollTime = 0L; <br>                        lpOleDoc-&gt;m_dwLastScrollDir = SCROLLDIR_NULL; <br>                } else if (dwScrollDir != lpOleDoc-&gt;m_dwLastScrollDir) { <br>                        /* cusor moved into a different direction scroll area. <br>                        **      reset "EnterScrollArea" time to start a new 50ms delay. <br>                        */ <br>                        lpOleDoc-&gt;m_dwTimeEnterScrollArea = dwTime; <br>                        lpOleDoc-&gt;m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay; <br>                        lpOleDoc-&gt;m_dwLastScrollDir = dwScrollDir; <br>                } else if (dwTime  &amp;&amp; dwTime &gt;= lpOleDoc-&gt;m_dwNextScrollTime) { <br>                        LineList_Scroll ( lpLL, dwScrollDir );  // Scroll doc NOW <br>                        lpOleDoc-&gt;m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval; <br>                } <br>        } else { <br>                if (dwScrollDir) { <br>                        /* cusor moved INTO a scroll area. <br>                        **      reset "EnterScrollArea" time to start a new 50ms delay. <br>                        */ <br>                        lpOleDoc-&gt;m_dwTimeEnterScrollArea = dwTime; <br>                        lpOleDoc-&gt;m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay; <br>                        lpOleDoc-&gt;m_dwLastScrollDir = dwScrollDir; <br>                } <br>        } <br> <br>        return (dwScrollDir ? TRUE : FALSE); <br>} <br> <br> <br>/* OleDoc_QueryDrop <br>** ---------------- <br>**    Check if the desired drop operation (identified by the given key <br>**    state) is possible at the current mouse position (pointl). <br>*/ <br>BOOL OleDoc_QueryDrop ( <br>        LPOLEDOC        lpOleDoc, <br>        DWORD           grfKeyState, <br>        POINTL          pointl, <br>        BOOL            fDragScroll, <br>        LPDWORD         lpdwEffect <br>) <br>{ <br>        LPLINELIST lpLL   = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>        LINERANGE  linerange; <br>        short      nIndex = LineList_GetLineIndexFromPointl( lpLL, pointl ); <br>        DWORD      dwScrollEffect = 0L; <br>        DWORD      dwOKEffects = *lpdwEffect; <br> <br>        /* check if the cursor is in the active scroll area, if so need the <br>        **    special scroll cursor. <br>        */ <br>        if (fDragScroll) <br>                dwScrollEffect = DROPEFFECT_SCROLL; <br> <br>        /* if we have already determined that the source does NOT have any <br>        **    acceptable data for us, the return NO-DROP <br>        */ <br>        if (! lpOleDoc-&gt;m_fCanDropCopy &amp;&amp; ! lpOleDoc-&gt;m_fCanDropLink) <br>                goto dropeffect_none; <br> <br>        /* if the Drag/Drop is local to our document, we can NOT accept a <br>        **    drop in the middle of the current selection (which is the exact <br>        **    data that is being dragged!). <br>        */ <br>        if (lpOleDoc-&gt;m_fLocalDrag) { <br>                LineList_GetSel( lpLL, (LPLINERANGE)&amp;linerange ); <br> <br>                if (linerange.m_nStartLine &lt;= nIndex &amp;&amp; nIndex&lt;linerange.m_nEndLine) <br>                        goto dropeffect_none; <br>        } <br> <br>        /* NOTE: determine what type of drop should be performed given <br>        **    the current modifier key state. we rely on the standard <br>        **    interpretation of the modifier keys: <br>        **          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src <br>        **          SHIFT       -- DROPEFFECT_MOVE <br>        **          CTRL        -- DROPEFFECT_COPY <br>        **          CTRL-SHIFT  -- DROPEFFECT_LINK <br>        */ <br> <br>        *lpdwEffect = OleStdGetDropEffect(grfKeyState); <br>        if (*lpdwEffect == 0) { <br>                // No modifier keys given. Try in order MOVE, COPY, LINK. <br>                if ((DROPEFFECT_MOVE &amp; dwOKEffects) &amp;&amp; lpOleDoc-&gt;m_fCanDropCopy) <br>                        *lpdwEffect = DROPEFFECT_MOVE; <br>                else if ((DROPEFFECT_COPY &amp; dwOKEffects) &amp;&amp; lpOleDoc-&gt;m_fCanDropCopy) <br>                        *lpdwEffect = DROPEFFECT_COPY; <br>                else if ((DROPEFFECT_LINK &amp; dwOKEffects) &amp;&amp; lpOleDoc-&gt;m_fCanDropLink) <br>                        *lpdwEffect = DROPEFFECT_LINK; <br>                else <br>                        goto dropeffect_none; <br>        } else { <br>                /* NOTE: we should check if the drag source application allows <br>                **    the desired drop effect. <br>                */ <br>                if (!(*lpdwEffect &amp; dwOKEffects)) <br>                        goto dropeffect_none; <br> <br>                if ((*lpdwEffect == DROPEFFECT_COPY || *lpdwEffect == DROPEFFECT_MOVE) <br>                                &amp;&amp; ! lpOleDoc-&gt;m_fCanDropCopy) <br>                        goto dropeffect_none; <br> <br>                if (*lpdwEffect == DROPEFFECT_LINK &amp;&amp; ! lpOleDoc-&gt;m_fCanDropLink) <br>                        goto dropeffect_none; <br>        } <br> <br>        *lpdwEffect |= dwScrollEffect; <br>        return TRUE; <br> <br>dropeffect_none: <br> <br>        *lpdwEffect = DROPEFFECT_NONE; <br>        return FALSE; <br>} <br> <br>/* OleDoc_DoDragDrop <br> * ----------------- <br> *  Actually perform a drag/drop operation with the current selection in <br> *      the source document (lpSrcOleDoc). <br> * <br> *  returns the result effect of the drag/drop operation: <br> *      DROPEFFECT_NONE, <br> *      DROPEFFECT_COPY, <br> *      DROPEFFECT_MOVE, or <br> *      DROPEFFECT_LINK <br> */ <br> <br>DWORD OleDoc_DoDragDrop (LPOLEDOC lpSrcOleDoc) <br>{ <br>        LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>        LPOLEAPP     lpOleApp = (LPOLEAPP)g_lpApp; <br>        LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc; <br>        LPOLEDOC lpDragDoc; <br>        LPLINELIST  lpSrcLL = <br>                                        (LPLINELIST)&amp;((LPOUTLINEDOC)lpSrcOleDoc)-&gt;m_LineList; <br>        DWORD       dwEffect     = 0; <br>        LPLINE      lplineStart, lplineEnd; <br>        LINERANGE   linerange; <br>        BOOL        fPrevEnable1; <br>        BOOL        fPrevEnable2; <br>        HRESULT     hrErr; <br> <br>        OLEDBG_BEGIN3("OleDoc_DoDragDrop\r\n") <br> <br>        /* squirrel away a copy of the current selection to the ClipboardDoc */ <br>        lpDragDoc = (LPOLEDOC)OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc); <br>        if ( ! lpDragDoc) { <br>                dwEffect = DROPEFFECT_NONE; <br>                goto error; <br>        } <br> <br>        /* NOTE: initially the DataTransferDoc is created with a 0 ref <br>        **    count. in order to have a stable Doc object during the drag/ <br>        **    drop operation, we intially AddRef the Doc ref cnt and later <br>        **    Release it. This AddRef is artificial; it is simply <br>        **    done to guarantee that a harmless QueryInterface followed by <br>        **    a Release does not inadvertantly force our object to destroy <br>        **    itself prematurely. <br>        */ <br>        OleDoc_AddRef(lpDragDoc); <br> <br>        //NOTE: we need to keep the LPLINE pointers <br>        //      rather than the indexes because the <br>        //      indexes will not be the same after the <br>        //      drop occurs  -- the drop adds new <br>        //      entries to the list thereby shifting <br>        //      the whole list. <br>        LineList_GetSel( lpSrcLL, (LPLINERANGE)&amp;linerange ); <br>        lplineStart = LineList_GetLine ( lpSrcLL, linerange.m_nStartLine ); <br>        lplineEnd   = LineList_GetLine ( lpSrcLL, linerange.m_nEndLine ); <br> <br>        if (! lplineStart || ! lplineEnd) { <br>                dwEffect = DROPEFFECT_NONE; <br>                goto error; <br>        } <br> <br>        lpSrcOleDoc-&gt;m_fLocalDrop     = FALSE; <br>        lpSrcOleDoc-&gt;m_fLocalDrag     = TRUE; <br> <br>        /* NOTE: it is VERY important to DISABLE the Busy/NotResponding <br>        **    dialogs BEFORE calling DoDragDrop. The DoDragDrop API starts <br>        **    a mouse capture modal loop. if the Busy/NotResponding comes <br>        **    up in the middle of this loop (eg. if one of the remoted <br>        **    calls like IDropTarget::DragOver call takes a long time, then <br>        **    the NotResponding dialog may want to come up), then the mouse <br>        **    capture is lost by OLE and things can get messed up. <br>        */ <br>        OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>        OLEDBG_BEGIN2("DoDragDrop called\r\n") <br>        hrErr = DoDragDrop ( (LPDATAOBJECT) &amp;lpDragDoc-&gt;m_DataObject, <br>                                 (LPDROPSOURCE) &amp;lpSrcOleDoc-&gt;m_DropSource, <br>                                 DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK, <br>                                 (LPDWORD) &amp;dwEffect <br>        ); <br>        OLEDBG_END2 <br> <br>        // re-enable the Busy/NotResponding dialogs <br>        OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br> <br>#if defined( _DEBUG ) <br>        if (FAILED(hrErr)) <br>                OleDbgOutHResult("DoDragDrop returned", hrErr); <br>#endif <br>        lpSrcOleDoc-&gt;m_fLocalDrag     = FALSE; <br> <br>        /* NOTE: we need to guard the lifetime of our lpSrcOleDoc <br>        **    object while we are deleting the lines that were drag <br>        **    moved. it is possible that deleting these lines could <br>        **    cause the deletion of a PseudoObj. the deletion of a <br>        **    PseudoObj will cause the Doc to be unlock <br>        **    (CoLockObjectExternal(FALSE,TRUE) called). each PseudoObj <br>        **    holds a strong lock on the Doc. It is always best to have <br>        **    a memory guard around such critical sections of code. in <br>        **    this case, it is particularly important if we were an <br>        **    in-place active server and this drag ended up in a drop <br>        **    in our outer container. this scenario will lead to a <br>        **    crash if we do not hold this memory guard. <br>        */ <br>        OleDoc_Lock(lpSrcOleDoc, TRUE, 0); <br> <br>        /* if after the Drag/Drop modal (mouse capture) loop is finished <br>        **    and a drag MOVE operation was performed, then we must delete <br>        **    the lines that were dragged. <br>        */ <br>        if ( hrErr == DRAGDROP_S_DROP <br>                        &amp;&amp; (dwEffect &amp; DROPEFFECT_MOVE) != 0 ) { <br> <br>                int i,j,iEnd; <br>                LPLINE lplineFocusLine; <br> <br>                /* disable repainting and sending data changed notifications <br>                **    until after all lines have been deleted. <br>                */ <br>                OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, FALSE ); <br> <br>                /* if the drop was local to our document, then we must take <br>                **    into account that the line indices of the original source <br>                **    of the drag could have shifted because the dropped lines <br>                **    have been inserted into our document. thus we will <br>                **    re-determine the source line indices. <br>                */ <br>                if (lpSrcOleDoc-&gt;m_fLocalDrop) { <br>                        i = LineList_GetFocusLineIndex ( lpSrcLL ); <br>                        lplineFocusLine = LineList_GetLine ( lpSrcLL, i ); <br>                } <br> <br>                for ( i = j = LineList_GetLineIndex(lpSrcLL,lplineStart ) , <br>                          iEnd  = LineList_GetLineIndex(lpSrcLL,lplineEnd ) ; <br>                          i &lt;= iEnd ; <br>                          i++ <br>                ) OutlineDoc_DeleteLine ((LPOUTLINEDOC)lpSrcOleDoc, j ); <br> <br>                LineList_RecalcMaxLineWidthInHimetric(lpSrcLL, 0); <br> <br>                if (lpSrcOleDoc-&gt;m_fLocalDrop) { <br>                        i = LineList_GetLineIndex ( lpSrcLL, lplineFocusLine ); <br>                        LineList_SetFocusLine ( lpSrcLL, (WORD)i ); <br>                } <br> <br>                OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, TRUE ); <br> <br>                /* if it is a local Drag/Drop move, we need to balance the <br>                **    SetRedraw(FALSE) call that was made in the implementation <br>                **    of IDropTarget::Drop. <br>                */ <br>                if (lpSrcOleDoc-&gt;m_fLocalDrop) <br>                        OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, TRUE ); <br> <br>                LineList_ForceRedraw ( lpSrcLL, FALSE ); <br>        } <br> <br>        OleDoc_Release(lpDragDoc);  // rel artificial AddRef above <br>        OleDoc_Lock(lpSrcOleDoc, FALSE, FALSE);  // unlock artificial lock guard <br> <br>        OLEDBG_END3 <br>        return dwEffect; <br> <br>error: <br>        OLEDBG_END3 <br>        return dwEffect; <br>} <br> <br> <br> <br>/************************************************************************* <br>** OleDoc::IDropSource interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP OleDoc_DropSource_QueryInterface( <br>        LPDROPSOURCE            lpThis, <br>        REFIID                  riid, <br>        LPVOID FAR*             lplpvObj <br>) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_DropSource_AddRef( LPDROPSOURCE lpThis ) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        OleDbgAddRefMethod(lpThis, "IDropSource"); <br> <br>        return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_DropSource_Release ( LPDROPSOURCE lpThis) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        OleDbgReleaseMethod(lpThis, "IDropSource"); <br> <br>        return OleDoc_Release(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP    OleDoc_DropSource_QueryContinueDrag ( <br>        LPDROPSOURCE            lpThis, <br>        BOOL                    fEscapePressed, <br>        DWORD                   grfKeyState <br>){ <br>        if (fEscapePressed) <br>                return DRAGDROP_S_CANCEL; <br>        else if (!(grfKeyState &amp; MK_LBUTTON)) <br>                return DRAGDROP_S_DROP; <br>        else <br>                return NOERROR; <br>} <br> <br> <br>STDMETHODIMP    OleDoc_DropSource_GiveFeedback ( <br>        LPDROPSOURCE            lpThis, <br>        DWORD                   dwEffect <br>) <br>{ <br>        // Tell OLE to use the standard drag/drop feedback cursors <br>        return DRAGDROP_S_USEDEFAULTCURSORS; <br> <br>#if defined( IF_SPECIAL_DD_CURSORS_NEEDED ) <br>        switch (dwEffect) { <br> <br>                case DROPEFFECT_NONE: <br>                        SetCursor ( ((LPOLEAPP)g_lpApp)-&gt;m_hcursorDragNone ); <br>                        break; <br> <br>                case DROPEFFECT_COPY: <br>                        SetCursor ( ((LPOLEAPP)g_lpApp)-&gt;m_hcursorDragCopy ); <br>                        break; <br> <br>                case DROPEFFECT_MOVE: <br>                        SetCursor ( ((LPOLEAPP)g_lpApp)-&gt;m_hcursorDragMove ); <br>                        break; <br> <br>                case DROPEFFECT_LINK: <br>                        SetCursor ( ((LPOLEAPP)g_lpApp)-&gt;m_hcursorDragLink ); <br>                        break; <br> <br>        } <br> <br>        return NOERROR; <br>#endif <br> <br>} <br> <br>/************************************************************************* <br>** OleDoc::IDropTarget interface implementation <br>*************************************************************************/ <br> <br>STDMETHODIMP OleDoc_DropTarget_QueryInterface( <br>                LPDROPTARGET        lpThis, <br>                REFIID              riid, <br>                LPVOID FAR*         lplpvObj <br>) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_DropTarget_AddRef(LPDROPTARGET lpThis) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        OleDbgAddRefMethod(lpThis, "IDropTarget"); <br> <br>        return OleDoc_AddRef(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) OleDoc_DropTarget_Release ( LPDROPTARGET lpThis) <br>{ <br>        LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br> <br>        OleDbgReleaseMethod(lpThis, "IDropTarget"); <br> <br>        return OleDoc_Release(lpOleDoc); <br>} <br> <br> <br>STDMETHODIMP    OleDoc_DropTarget_DragEnter ( <br>        LPDROPTARGET            lpThis, <br>        LPDATAOBJECT            lpDataObj, <br>        DWORD                   grfKeyState, <br>        POINTL                  pointl, <br>        LPDWORD                 lpdwEffect <br>) <br>{ <br>        LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp; <br>        LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br>        LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>        BOOL       fDragScroll; <br> <br>        // artificial AddRef in case object is destroyed during call <br>        OleDoc_DropTarget_AddRef(lpThis); <br> <br>        OLEDBG_BEGIN2("OleDoc_DropTarget_DragEnter\r\n") <br> <br>        lpOleDoc-&gt;m_fDragLeave              = FALSE; <br>        lpOleDoc-&gt;m_dwTimeEnterScrollArea   = 0; <br>        lpOleDoc-&gt;m_dwLastScrollDir         = SCROLLDIR_NULL; <br> <br> <br>        /* Determine if the drag source data object offers a data format <br>        **    that we can copy and/or link to. <br>        */ <br> <br>        lpOleDoc-&gt;m_fCanDropCopy = OleDoc_QueryPasteFromData( <br>                        lpOleDoc, <br>                        lpDataObj, <br>                        FALSE   /* fLink */ <br>        ); <br> <br>        lpOleDoc-&gt;m_fCanDropLink = OleDoc_QueryPasteFromData( <br>                        lpOleDoc, <br>                        lpDataObj, <br>                        TRUE   /* fLink */ <br>        ); <br> <br>        fDragScroll = OleDoc_DoDragScroll ( lpOleDoc, pointl ); <br> <br>        if (OleDoc_QueryDrop(lpOleDoc,grfKeyState,pointl,fDragScroll,lpdwEffect)) <br>                LineList_SetDragOverLineFromPointl( lpLL, pointl ); <br> <br>        OLEDBG_END2 <br> <br>        // release artificial AddRef <br>        OleDoc_DropTarget_Release(lpThis); <br> <br>        return NOERROR; <br>} <br> <br>STDMETHODIMP OleDoc_DropTarget_DragOver ( <br>        LPDROPTARGET            lpThis, <br>        DWORD                   grfKeyState, <br>        POINTL                  pointl, <br>        LPDWORD                 lpdwEffect <br>) <br>{ <br>        LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp; <br>        LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br>        LPLINELIST lpLL   = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br>        BOOL       fDragScroll; <br> <br>        // artificial AddRef in case object is destroyed during call <br>        OleDoc_DropTarget_AddRef(lpThis); <br> <br>        fDragScroll = OleDoc_DoDragScroll ( lpOleDoc, pointl ); <br> <br>        if (OleDoc_QueryDrop(lpOleDoc,grfKeyState, pointl,fDragScroll,lpdwEffect)) <br>                LineList_SetDragOverLineFromPointl( lpLL, pointl ); <br>        else <br>                LineList_RestoreDragFeedback( lpLL ); <br> <br>        // release artificial AddRef <br>        OleDoc_DropTarget_Release(lpThis); <br>        return NOERROR; <br>} <br> <br> <br>STDMETHODIMP    OleDoc_DropTarget_DragLeave ( LPDROPTARGET lpThis) <br>{ <br>        LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br>        LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br> <br>        // artificial AddRef in case object is destroyed during call <br>        OleDoc_DropTarget_AddRef(lpThis); <br> <br>        OLEDBG_BEGIN2("OleDoc_DropTarget_DragLeave\r\n") <br> <br>        lpOleDoc-&gt;m_fDragLeave = TRUE; <br> <br>        LineList_RestoreDragFeedback( lpLL ); <br> <br>        OLEDBG_END2 <br> <br>        // release artificial AddRef <br>        OleDoc_DropTarget_Release(lpThis); <br>        return NOERROR; <br> <br>} <br> <br>STDMETHODIMP    OleDoc_DropTarget_Drop ( <br>        LPDROPTARGET            lpThis, <br>        LPDATAOBJECT            lpDataObj, <br>        DWORD                   grfKeyState, <br>        POINTL                  pointl, <br>        LPDWORD                 lpdwEffect <br>) <br>{ <br>        LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)-&gt;lpOleDoc; <br>        LPLINELIST lpLL     = (LPLINELIST)&amp;((LPOUTLINEDOC)lpOleDoc)-&gt;m_LineList; <br> <br>        // artificial AddRef in case object is destroyed during call <br>        OleDoc_DropTarget_AddRef(lpThis); <br> <br>        OLEDBG_BEGIN2("OleDoc_DropTarget_Drop\r\n") <br> <br>        lpOleDoc-&gt;m_fDragLeave = TRUE; <br>        lpOleDoc-&gt;m_fLocalDrop = TRUE; <br> <br>        LineList_RestoreDragFeedback( lpLL ); <br>        SetFocus( LineList_GetWindow( lpLL) ); <br> <br>        if (OleDoc_QueryDrop(lpOleDoc, grfKeyState, pointl, FALSE, lpdwEffect)) { <br>                BOOL fLink     = (*lpdwEffect == DROPEFFECT_LINK); <br>                int iFocusLine = LineList_GetFocusLineIndex( lpLL ); <br>                BOOL fStatus; <br> <br>                OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpOleDoc, FALSE ); <br>                LineList_SetFocusLineFromPointl ( lpLL, pointl ); <br> <br>                fStatus = OleDoc_PasteFromData( <br>                                lpOleDoc, <br>                                lpDataObj, <br>                                lpOleDoc-&gt;m_fLocalDrag, /* data source is local to app */ <br>                                fLink <br>                ); <br> <br>                // if drop was unsuccessfull, restore the original focus line <br>                if (! fStatus) <br>                        LineList_SetFocusLine( lpLL, (WORD)iFocusLine ); <br> <br>#if defined( INPLACE_CNTR ) <br>                { <br>                        LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc; <br> <br>                        /* NOTE: if there is currently a UIActive OLE object, <br>                        **    then we must tell it to UIDeactivate after <br>                        **    the drop has completed. <br>                        */ <br>                        if (lpContainerDoc-&gt;m_lpLastUIActiveLine) { <br>                                ContainerLine_UIDeactivate( <br>                                                lpContainerDoc-&gt;m_lpLastUIActiveLine); <br>                        } <br>                } <br>#endif <br> <br>#if defined( INPLACE_SVR ) <br>                { <br>                        /* NOTE: if the drop was into a in-place visible <br>                        **    (in-place active but NOT UIActive object), then we <br>                        **    want to UIActivate the object after the drop is <br>                        **    complete. <br>                        */ <br>                        ServerDoc_UIActivate((LPSERVERDOC) lpOleDoc); <br>                } <br>#endif <br> <br> <br>                /* if it is a local Drag/Drop move, don't enable redraw. <br>                **    after the source is done deleting the moved lines, it <br>                **    will re-enable redraw <br>                */ <br>                if (! (lpOleDoc-&gt;m_fLocalDrag <br>                        &amp;&amp; (*lpdwEffect &amp; DROPEFFECT_MOVE) != 0 )) <br>                        OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpOleDoc, TRUE ); <br>        } <br> <br>        OLEDBG_END2 <br>        // release artificial AddRef <br>        OleDoc_DropTarget_Release(lpThis); <br>        return NOERROR; <br>} <br> <br> <br>#endif  // USE_DRAGDROP </code></pre>
<p>&nbsp;</p></body>
</HTML>
