<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context291"></a>MAIN.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    main.c <br>** <br>**    This file contains initialization functions which are WinMain, <br>**    WndProc, and OutlineApp_InitalizeMenu. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "ansiapi.h" <br>#include "outline.h" <br>#if defined( USE_STATUSBAR ) <br>#include "status.h" <br>#endif <br> <br>#if !defined( WIN32 ) <br>#if defined( USE_CTL3D ) <br>//#include "..\include\ctl3d.h" <br>#include "ctl3d.h" <br>#endif  // USE_CTL3D <br>#endif  // !WIN32 <br> <br>#include "initguid.h"           // forces our GUIDs to be initialized <br>#include "defguid.h" <br> <br>#if defined( OLE_CNTR ) <br>//************************************************************************* <br> <br>#if defined( INPLACE_CNTR ) <br>OLEDBGDATA_MAIN("ICNTR") <br>#else <br>OLEDBGDATA_MAIN("CNTR") <br>#endif <br> <br>CONTAINERAPP g_OutlineApp;  // Global App object maintains app instance state <br> <br>/* Global interface Vtbl's <br> * NOTE: we only need one copy of each Vtbl. When an object which <br> *      exposes an interface is instantiated, its lpVtbl is intialized <br> *      to point to one of these global Vtbl's. <br> */ <br>IUnknownVtbl            g_OleApp_UnknownVtbl; <br>IClassFactoryVtbl       g_OleApp_ClassFactoryVtbl; <br>IMessageFilterVtbl      g_OleApp_MessageFilterVtbl; <br> <br>IUnknownVtbl            g_OleDoc_UnknownVtbl; <br>IPersistFileVtbl        g_OleDoc_PersistFileVtbl; <br>IOleItemContainerVtbl   g_OleDoc_OleItemContainerVtbl; <br>IExternalConnectionVtbl g_OleDoc_ExternalConnectionVtbl; <br>IDataObjectVtbl         g_OleDoc_DataObjectVtbl; <br> <br>#if defined( USE_DRAGDROP ) <br>IDropSourceVtbl         g_OleDoc_DropSourceVtbl; <br>IDropTargetVtbl         g_OleDoc_DropTargetVtbl; <br>#endif  // USE_DRAGDROP <br> <br>IOleUILinkContainerVtbl g_CntrDoc_OleUILinkContainerVtbl; <br> <br>IOleClientSiteVtbl      g_CntrLine_UnknownVtbl; <br>IOleClientSiteVtbl      g_CntrLine_OleClientSiteVtbl; <br>IAdviseSinkVtbl         g_CntrLine_AdviseSinkVtbl; <br> <br>#if defined( INPLACE_CNTR ) <br>IOleInPlaceSiteVtbl     g_CntrLine_OleInPlaceSiteVtbl; <br>IOleInPlaceFrameVtbl    g_CntrApp_OleInPlaceFrameVtbl; <br>BOOL g_fInsideOutContainer = FALSE;     // default to outside-in activation <br>#endif  // INPLACE_CNTR <br> <br>//************************************************************************* <br>#endif  // OLE_CNTR <br> <br>#if defined( OLE_SERVER ) <br>//************************************************************************* <br> <br>#if defined( INPLACE_SVR ) <br>OLEDBGDATA_MAIN("ISVR") <br>#else <br>OLEDBGDATA_MAIN("SVR") <br>#endif <br> <br>SERVERAPP g_OutlineApp; // Global App object maintains app instance state <br> <br>/* Global interface Vtbl's <br> * NOTE: we only need one copy of each Vtbl. When an object which <br> *      exposes an interface is instantiated, its lpVtbl is intialized <br> *      to point to one of these global Vtbl's. <br> */ <br>IUnknownVtbl            g_OleApp_UnknownVtbl; <br>IClassFactoryVtbl       g_OleApp_ClassFactoryVtbl; <br>IMessageFilterVtbl      g_OleApp_MessageFilterVtbl; <br> <br>IUnknownVtbl            g_OleDoc_UnknownVtbl; <br>IPersistFileVtbl        g_OleDoc_PersistFileVtbl; <br>IOleItemContainerVtbl   g_OleDoc_OleItemContainerVtbl; <br>IExternalConnectionVtbl g_OleDoc_ExternalConnectionVtbl; <br>IDataObjectVtbl         g_OleDoc_DataObjectVtbl; <br> <br>#if defined( USE_DRAGDROP ) <br>IDropSourceVtbl         g_OleDoc_DropSourceVtbl; <br>IDropTargetVtbl         g_OleDoc_DropTargetVtbl; <br>#endif  // USE_DRAGDROP <br> <br>IOleObjectVtbl          g_SvrDoc_OleObjectVtbl; <br>IPersistStorageVtbl     g_SvrDoc_PersistStorageVtbl; <br> <br>#if defined( SVR_TREATAS ) <br>IStdMarshalInfoVtbl     g_SvrDoc_StdMarshalInfoVtbl; <br>#endif  // SVR_TREATAS <br> <br>#if defined( INPLACE_SVR ) <br>IOleInPlaceObjectVtbl       g_SvrDoc_OleInPlaceObjectVtbl; <br>IOleInPlaceActiveObjectVtbl g_SvrDoc_OleInPlaceActiveObjectVtbl; <br>#endif // INPLACE_SVR <br> <br>IUnknownVtbl            g_PseudoObj_UnknownVtbl; <br>IOleObjectVtbl          g_PseudoObj_OleObjectVtbl; <br>IDataObjectVtbl         g_PseudoObj_DataObjectVtbl; <br> <br>//************************************************************************* <br>#endif  // OLE_SVR <br> <br>#if !defined( OLE_VERSION ) <br>OLEDBGDATA_MAIN("OUTL") <br>OUTLINEAPP g_OutlineApp;    // Global App object maintains app instance state <br>#endif <br> <br>LPOUTLINEAPP g_lpApp=(LPOUTLINEAPP)&amp;g_OutlineApp;   // ptr to global app obj <br>RECT        g_rectNull = {0, 0, 0, 0}; <br>UINT        g_uMsgHelp = 0;  // help msg from ole2ui dialogs <br>BOOL        g_fAppActive = FALSE; <br> <br>/* WinMain <br>** ------- <br>**    Main routine for the Windows application. <br>*/ <br>int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, <br>                  LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   MSG         msg;            /* MSG structure to store your messages */ <br> <br>#if defined( OLE_VERSION ) <br>   /* NOTE: it is recommended that all OLE applications to set <br>   **    their message queue size to 96. this improves the capacity <br>   **    and performance of OLE's LRPC mechanism. <br>   */ <br>   int cMsg = 96;   // recommend msg queue size for OLE <br>   while (cMsg &amp;&amp; ! SetMessageQueue(cMsg))  // take largest size we can get. <br>      cMsg -= 8; <br>   if (! cMsg) <br>      return -1;  // ERROR: we got no message queue <br>#endif <br> <br>#if defined( USE_CTL3D ) <br>   Ctl3dRegister(hInstance); <br>   Ctl3dAutoSubclass(hInstance); <br>#endif <br> <br>   if(! hPrevInstance) { <br>      /* register window classes if first instance of application */ <br>      if(! OutlineApp_InitApplication(lpOutlineApp, hInstance)) <br>         return 0; <br>   } <br> <br>   /* Create App Frame window */ <br>   if (! OutlineApp_InitInstance(lpOutlineApp, hInstance, nCmdShow)) <br>      return 0; <br> <br>   if (! OutlineApp_ParseCmdLine(lpOutlineApp, lpszCmdLine, nCmdShow)) <br>      return 0; <br> <br>   lpOutlineApp-&gt;m_hAccelApp = LoadAccelerators(hInstance, APPACCEL); <br>   lpOutlineApp-&gt;m_hAccelFocusEdit = LoadAccelerators(hInstance, <br>         FB_EDIT_ACCEL); <br>   lpOutlineApp-&gt;m_hAccel = lpOutlineApp-&gt;m_hAccelApp; <br>   lpOutlineApp-&gt;m_hWndAccelTarget = lpOutlineApp-&gt;m_hWndApp; <br> <br> <br>   // Main message loop <br>   while(GetMessage(&amp;msg, NULL, 0, 0)) {        /* Until WM_QUIT message */ <br>      if(!MyTranslateAccelerator(&amp;msg)) { <br>         TranslateMessage(&amp;msg); <br>         DispatchMessage(&amp;msg); <br>      } <br>   } <br> <br>#if defined( OLE_VERSION ) <br>   OleApp_TerminateApplication((LPOLEAPP)lpOutlineApp); <br>#else <br>   /* NOTE: CoInitialize() is called in OutlineApp_InitInstance <br>   **    and therefore we need to uninitialize it when exit. <br>   */ <br>   CoUninitialize(); <br>#endif <br> <br>#if defined( USE_CTL3D ) <br>   Ctl3dUnregister(hInstance); <br>#endif <br> <br>   return msg.wParam; <br> <br>} /*  End of WinMain */ <br> <br>BOOL MyTranslateAccelerator(LPMSG lpmsg) <br>{ <br>   // if it's not a keystroke it can not be an accelerator <br>   if (lpmsg-&gt;message &lt; WM_KEYFIRST || lpmsg-&gt;message &gt; WM_KEYLAST) <br>      return FALSE; <br> <br>   if (g_lpApp-&gt;m_hWndAccelTarget &amp;&amp; <br>      TranslateAccelerator(g_lpApp-&gt;m_hWndAccelTarget, <br>                                       g_lpApp-&gt;m_hAccel,lpmsg)) <br>      return TRUE; <br> <br>#if defined( INPLACE_SVR ) <br>   /* NOTE: if we are in-place active and we did not translate the <br>   **    accelerator, we need to give the top-level (frame) in-place <br>   **    container a chance to translate the accelerator. <br>   **    we ONLY need to call OleTranslateAccelerator API if the <br>   **    message is a keyboard message. otherwise it is harmless but <br>   **    unnecessary. <br>   ** <br>   **    NOTE: even a in-place server that does NOT have any <br>   **    Accelerators must still call OleTranslateAccelerator for all <br>   **    keyboard messages so that the server's OWN menu mneumonics <br>   **    (eg. &amp;Edit -- Alt-e) function properly. <br>   ** <br>   **    NOTE: an in-place server MUST check that the accelerator is <br>   **    NOT one of its own accelerators BEFORE calling <br>   **    OleTranslateAccelerator which tries to see if it is a <br>   **    container accelerator. if this is a server accelerator that <br>   **    was not translateed because the associated menu command was <br>   **    disabled, we MUST NOT call OleTranslateAccelerator. The <br>   **    IsAccelerator helper API has been added to assist with this <br>   **    check. <br>   */ <br>   if (g_OutlineApp.m_lpIPData &amp;&amp; <br>      !IsAccelerator(g_lpApp-&gt;m_hAccel, <br>         GetAccelItemCount(g_lpApp-&gt;m_hAccel), lpmsg,NULL) &amp;&amp; <br>      OleTranslateAccelerator(g_OutlineApp.m_lpIPData-&gt;lpFrame, <br>            (LPOLEINPLACEFRAMEINFO)&amp;g_OutlineApp.m_lpIPData-&gt;frameInfo, <br>            lpmsg) == NOERROR) { <br>      return TRUE; <br>   } <br>#endif <br> <br>   return FALSE; <br>} <br> <br> <br>/************************************************************************/ <br>/*                                                                      */ <br>/* Main Window Procedure                                                */ <br>/*                                                                      */ <br>/* This procedure provides service routines for the Windows events      */ <br>/* (messages) that Windows sends to the window, as well as the user     */ <br>/* initiated events (messages) that are generated when the user selects */ <br>/* the action bar and pulldown menu controls or the corresponding       */ <br>/* keyboard accelerators.                                               */ <br>/*                                                                      */ <br>/************************************************************************/ <br> <br>LRESULT FAR PASCAL AppWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)GetWindowLong(hWnd, 0); <br>   LPOUTLINEDOC lpOutlineDoc = NULL; <br>#if defined( OLE_VERSION ) <br>   LPOLEAPP lpOleApp = (LPOLEAPP)lpOutlineApp; <br>#endif <br>#if defined( OLE_CNTR ) <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOutlineApp; <br>   char         szAnsiString[256]; <br>#endif <br>   HWND         hWndDoc = NULL; <br> <br>#if defined( USE_FRAMETOOLS ) <br>   LPFRAMETOOLS lptb = OutlineApp_GetFrameTools(lpOutlineApp); <br>#endif <br> <br>   if (lpOutlineApp) { <br>      lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp); <br> <br>      if (lpOutlineDoc) <br>         hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc); <br>   } <br> <br>   switch (Message) { <br>      case WM_COMMAND: <br>      { <br>#ifdef WIN32 <br>         WORD wID    = LOWORD(wParam); <br>#else <br>         WORD wID    = wParam; <br>#endif <br> <br>#if defined( INPLACE_CNTR ) <br>         LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>         LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br> <br>         /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>         **    m_fMenuHelpMode flag is set when F1 is pressed when a <br>         **    menu item is selected. this flag is set in <br>         **    IOleInPlaceFrame::ContextSensitveHelp method. <br>         **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>         **    sensitive help is entered. this flag is set in <br>         **    IOleInPlaceSite::ContextSensitiveHelp method. <br>         **    if either of these flags are set then the WM_COMMAND <br>         **    message is received then, the corresponding command <br>         **    should NOT executed; help can be given (if desired). <br>         **    also the context sensitve help mode should be exited. <br>         **    the two different cases have their own way to exit <br>         **    the mode (please refer to the technote). <br>         */ <br>         if (lpOleDoc &amp;&amp; <br>            (lpContainerApp-&gt;m_fMenuHelpMode||lpOleDoc-&gt;m_fCSHelpMode) &amp;&amp; <br>            (wID &gt; IDM_FILE)   /* min wID for app command */ &amp;&amp; <br>            (wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) { <br> <br>            if ((lpContainerApp-&gt;m_fMenuHelpMode)) { <br>               LPOLEINPLACEACTIVEOBJECT lpIPActiveObj = <br>                     lpContainerApp-&gt;m_lpIPActiveObj; <br> <br>               lpContainerApp-&gt;m_fMenuHelpMode = FALSE; <br> <br>               // inform the in-place active object that we handled the <br>               //   menu help mode (F1) selection. <br>               if (lpIPActiveObj) { <br>                  OLEDBG_BEGIN2("IOleInPlaceActiveObject::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpIPActiveObj-&gt;lpVtbl-&gt;ContextSensitiveHelp( <br>                        lpIPActiveObj, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            if ((lpOleDoc-&gt;m_fCSHelpMode)) { <br>               LPOLEINPLACEOBJECT lpIPObj; <br>               LPCONTAINERLINE lpLastIpActiveLine = <br>                     lpContainerDoc-&gt;m_lpLastIpActiveLine; <br> <br>               lpOleDoc-&gt;m_fCSHelpMode = FALSE; <br> <br>               /* inform immediate in-place container parent and, <br>               **    if we were a container/server, immediate <br>               **    in-place object children that we handled the <br>               **    context sensitive help mode. <br>               */ <br>               if (lpLastIpActiveLine &amp;&amp; <br>                     (lpIPObj=lpLastIpActiveLine-&gt;m_lpOleIPObj)!=NULL){ <br>                  OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpIPObj-&gt;lpVtbl-&gt;ContextSensitiveHelp(lpIPObj, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            // if we provided help, we would do it here... <br> <br>            // remove context sensitive help cursor <br>            SetCursor(LoadCursor(NULL,IDC_ARROW)); <br>            return 0L; <br>         } <br>#endif  // INPLACE_CNTR <br> <br>         switch (wID) { <br> <br>            case IDM_F_NEW: <br>               OleDbgIndent(-2);   // Reset debug output indent level <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_NewCommand\r\n") <br>               OutlineApp_NewCommand(lpOutlineApp); <br>               OLEDBG_END3 <br> <br>#if defined( OLE_CNTR ) <br>               /* NOTE: this call will attempt to recover <br>               **    resources by unloading DLL's that were loaded <br>               **    by OLE and are no longer being used. it is a <br>               **    good idea to call this API now and then if <br>               **    your app tends to run for a long time. <br>               **    otherwise these DLL's will be unloaded when <br>               **    the app exits. some apps may want to call <br>               **    this as part of idle-time processing. this <br>               **    call is optional. <br>               */ <br>               OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n") <br>               CoFreeUnusedLibraries(); <br>               OLEDBG_END2 <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons( <br>                     OutlineApp_GetActiveDoc(lpOutlineApp)); <br>#endif <br>               break; <br> <br>            case IDM_F_OPEN: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_OpenCommand\r\n") <br>               OutlineApp_OpenCommand(lpOutlineApp); <br>               OLEDBG_END3 <br> <br>#if defined( OLE_CNTR ) <br>               /* NOTE: this call will attempt to recover <br>               **    resources by unloading DLL's that were loaded <br>               **    by OLE and are no longer being used. it is a <br>               **    good idea to call this API now and then if <br>               **    your app tends to run for a long time. <br>               **    otherwise these DLL's will be unloaded when <br>               **    the app exits. some apps may want to call <br>               **    this as part of idle-time processing. this <br>               **    call is optional. <br>               */ <br>               OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n") <br>               CoFreeUnusedLibraries(); <br>               OLEDBG_END2 <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons( <br>                     OutlineApp_GetActiveDoc(lpOutlineApp)); <br>#endif <br>               break; <br> <br>            case IDM_F_SAVE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_SaveCommand\r\n") <br>               OutlineApp_SaveCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_F_SAVEAS: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_SaveAsCommand\r\n") <br>               OutlineApp_SaveAsCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_F_PRINT: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_PrintCommand\r\n") <br>               OutlineApp_PrintCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_F_PRINTERSETUP: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_PrinterSetupCommand\r\n") <br>               OutlineApp_PrinterSetupCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_F_EXIT: <br>               SendMessage(hWnd, WM_CLOSE, 0, 0L); <br>               break; <br> <br>            case IDM_H_ABOUT: <br>               OutlineApp_AboutCommand(lpOutlineApp); <br>               break; <br> <br>#if defined( INPLACE_CNTR ) <br>            case IDM_ESCAPE: <br>            { <br>               /* ESCAPE key pressed */ <br>               LPCONTAINERDOC lpContainerDoc = <br>                        (LPCONTAINERDOC)lpOutlineDoc; <br> <br>               /* NOTE: The standard OLE 2.0 UI convention <br>               **    is to have ESCAPE key exit in-place <br>               **    activation (ie. UIDeactivate). If <br>               **    possible it is recommended for both <br>               **    in-place servers AND in-place containers <br>               **    to take responsibility to handle the <br>               **    ESCAPE key accelerator. The server has <br>               **    the first crack at handling accelerator <br>               **    keys and normally the server should do <br>               **    the UIDeactivation. It is a good idea for <br>               **    in-place containers, in order to <br>               **    guarantee consistent behavior, to also <br>               **    handle the ESCAPE key and UIDeactivate <br>               **    the object in case the object does not do <br>               **    it itself. normally this should be <br>               **    unnecessary. <br>               */ <br>               if (lpContainerDoc-&gt;m_lpLastUIActiveLine &amp;&amp; <br>                  lpContainerDoc-&gt;m_lpLastUIActiveLine-&gt;m_fUIActive) <br>               { <br>                  ContainerLine_UIDeactivate( <br>                        lpContainerDoc-&gt;m_lpLastUIActiveLine); <br>               } <br>               break; <br>            } <br>#endif  // INPLACE_CNTR <br> <br> <br>            default: <br>               // forward message to document window <br>               if (hWndDoc) { <br>                  return DocWndProc(hWndDoc, Message,wParam,lParam); <br>               } <br>         } <br> <br>         break;  /* End of WM_COMMAND */ <br>      } <br> <br>      case WM_INITMENU: <br>         OutlineApp_InitMenu(lpOutlineApp, lpOutlineDoc, (HMENU)wParam); <br>         break; <br> <br>#if defined( OLE_VERSION ) <br> <br>      /* NOTE: WM_INITMENUPOPUP is trapped primarily for the Edit <br>      **    menu. We didn't update the Edit menu until it is popped <br>      **    up to avoid the overheads of the OLE calls which are <br>      **    required to initialize some Edit menu items. <br>      */ <br>      case WM_INITMENUPOPUP: <br>      { <br>         HMENU hMenuEdit = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 1); <br>#if defined( INPLACE_CNTR ) <br>         LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br> <br>         /* NOTE: we must check if there is an object currently <br>         **    in-place UIActive. if so, then our edit menu is not <br>         **    on the menu; we do not want to bother updating the <br>         **    edit menu when it is not even there. <br>         */ <br>         if (lpContainerDoc &amp;&amp; lpContainerDoc-&gt;m_lpLastUIActiveLine &amp;&amp; <br>            lpContainerDoc-&gt;m_lpLastUIActiveLine-&gt;m_fUIActive) <br>            break;  // an object is in-place UI active <br>#endif <br>         if ((HMENU)wParam == hMenuEdit &amp;&amp; <br>            (LOWORD(lParam) == POS_EDITMENU) &amp;&amp; <br>            OleDoc_GetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc)) { <br>            OleApp_UpdateEditMenu(lpOleApp, lpOutlineDoc, hMenuEdit); <br>         } <br>         break; <br>      } <br>#endif      // OLE_VERSION <br> <br>      case WM_SIZE: <br>         if (wParam != SIZE_MINIMIZED) <br>            OutlineApp_ResizeWindows(lpOutlineApp); <br>         break; <br> <br> <br>      case WM_ACTIVATEAPP: <br>#if defined (OLE_CNTR) <br>         if (g_fAppActive = (BOOL) wParam) <br>            OleApp_QueryNewPalette(lpOleApp); <br>#endif <br> <br>#if defined( INPLACE_CNTR ) <br>         { <br>            BOOL fActivate = (BOOL)wParam; <br>            LPOLEINPLACEACTIVEOBJECT lpIPActiveObj = <br>                  lpContainerApp-&gt;m_lpIPActiveObj; <br> <br>            /* NOTE: the in-place container MUST inform the <br>            **    inner most in-place active object (this is NOT <br>            **    necessarily our immediate child if there are <br>            **    nested levels of embedding) of the WM_ACTIVATEAPP <br>            **    status. <br>            */ <br>            if (lpIPActiveObj) { <br>#if defined( _DEBUG ) <br>               OLEDBG_BEGIN2((fActivate ? <br>                  "IOleInPlaceActiveObject::OnFrameWindowActivate(TRUE) called\r\n" : <br>                  "IOleInPlaceActiveObject::OnFrameWindowActivate(FALSE) called\r\n")) <br>#endif  // _DEUBG <br>               lpIPActiveObj-&gt;lpVtbl-&gt;OnFrameWindowActivate( <br>                  lpIPActiveObj, fActivate); <br>               OLEDBG_END2 <br>            } <br>         } <br> <br>#endif  // INPLACE_CNTR <br> <br>         // NOTE: We can't call OutlineDoc_UpdateFrameToolButtons <br>         //           right away which <br>         //           would generate some OLE calls and eventually <br>         //           WM_ACTIVATEAPP and a loop was formed. Therefore, we <br>         //           should delay the frame tool initialization until <br>         //           WM_ACTIVATEAPP is finished by posting a message <br>         //           to ourselves. <br>         //           we want to ignore the WM_ACTIVATEAPP that comes <br>         //           as we bring up a modal dialog. <br> <br>         /* Update enable/disable state of buttons in toolbar */ <br>         if (wParam <br>#if defined( OLE_VERSION ) <br>               &amp;&amp; lpOleApp-&gt;m_cModalDlgActive == 0 <br>#endif <br>         ) { <br>            PostMessage(hWnd, WM_U_INITFRAMETOOLS, 0, 0L); <br>         } <br>         return 0L; <br> <br>      case WM_SETFOCUS: <br>         SetFocus(hWndDoc); <br>         break; <br> <br> <br>#if defined( OLE_CNTR ) <br>      case WM_QUERYNEWPALETTE: <br>         if (!g_fAppActive) <br>            return 0L; <br> <br>         return OleApp_QueryNewPalette(lpOleApp); <br> <br>      case WM_PALETTECHANGED: <br>      { <br>         HWND hWndPalChg = (HWND) wParam; <br>         static BOOL fInPaletteChanged = FALSE; <br> <br>         if (fInPaletteChanged)  // Guard against recursion <br>            return 0L; <br> <br>         fInPaletteChanged = TRUE; <br> <br>         if (hWnd != hWndPalChg) <br>            wSelectPalette(hWnd, lpOleApp-&gt;m_hStdPal,TRUE/*fBackground*/); <br> <br>#if defined( INPLACE_CNTR ) <br>         /* NOTE: always forward the WM_PALETTECHANGED message (via <br>         **    SendMessage) to any in-place objects that currently have <br>         **    their window visible. this gives these objects the chance <br>         **    to select their palettes. this is <br>         **    REQUIRED by all in-place containers independent of <br>         **    whether they use color palettes themselves--their objects <br>         **    may use color palettes. <br>         **    (see ContainerDoc_ForwardPaletteChangedMsg for more info) <br>         */ <br>         if (lpOutlineDoc){ <br>            ContainerDoc_ForwardPaletteChangedMsg( <br>                  (LPCONTAINERDOC)lpOutlineDoc, hWndPalChg); <br>         } <br>#endif  // INPLACE_CNTR <br> <br>         fInPaletteChanged = FALSE; <br>         return 0L; <br>      } <br>#endif  // OLE_CNTR <br> <br>      case WM_DESTROY: <br>         PostQuitMessage(0); <br>         break; <br> <br>      case WM_CLOSE:  /* close the window */ <br> <br>         /* Close all active documents. if successful, then exit */ <br>         OleDbgOutNoPrefix2("\r\n"); <br> <br>         OutlineApp_CloseAllDocsAndExitCommand(lpOutlineApp, FALSE); <br>         break; <br> <br>      case WM_QUERYENDSESSION: <br>      { <br>#if defined( OLE_CNTR ) <br>         /* NOTE: we are not able to make OLE LRPC calls when <br>         **    WM_QUERYENDSESSION is recieved (this is a <br>         **    SendMessage). this means, for example, that we are <br>         **    NOT able to ask objects to save. thus the most we can <br>         **    do is ask the user if he wants to exit with <br>         **    discarding changes or else abort shutting down. <br>         */ <br> <br>         int nResponse; <br> <br>         W2A (APPNAME, szAnsiString, 256); <br> <br>         nResponse = MessageBox( <br>               hWnd, <br>               "Discard changes?", <br>               szAnsiString, <br>               MB_ICONQUESTION | MB_OKCANCEL <br>         ); <br>         if(nResponse == IDOK) <br>            return 1L;      /* can terminate */ <br> <br>#endif <br>#if defined( OLE_SERVER ) <br>         /* NOTE: an embedded object should never prompt whether <br>         **    it should be saved (according the OLE 2.0 User <br>         **    Model). therefore, an embedded object will never <br>         **    complain that it needs to be saved. it will always <br>         **    allow the QueryEndSession to proceed. <br>         */ <br>         if (lpOutlineApp-&gt;m_lpDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED) <br>            return 1L;      /* can terminate */ <br>         else <br>#endif <br>         { <br>            /* this is not an embedded object; it is a user <br>            **    document. we will prompt if the user wants to <br>            **    save the document now in WM_QUERYENDSESSION. if <br>            **    the user cancels then that would abort the <br>            **    shutdown. if the user does not abort, then later <br>            **    in WM_ENDSESSION the document will be actually <br>            **    closed. <br>            ** <br>            **    Because this is an SDI app, there is only one <br>            **    document. An MDI would need to loop through all <br>            **    open documents. <br>            */ <br>            DWORD dwSaveOption = OLECLOSE_PROMPTSAVE; <br>            if (OutlineDoc_CheckSaveChanges( <br>                  lpOutlineApp-&gt;m_lpDoc, &amp;dwSaveOption)) <br>               return 1L;      /* can terminate */ <br>         } <br> <br>         /* else: can't terminate now */ <br> <br>         break; <br>      } <br> <br>#if defined( OLE_VERSION) <br>      case WM_ENDSESSION: <br>      { <br>         BOOL fEndSession = (BOOL)wParam; <br> <br>         if (fEndSession) { <br>            OutlineApp_CloseAllDocsAndExitCommand(lpOutlineApp, TRUE); <br>            return 0L; <br>         } <br>      } <br>      break; <br>#endif  // OLE_VERSION <br> <br> <br>#if defined( USE_STATUSBAR ) <br>      case WM_MENUSELECT: <br>      { <br>         LPSTR lpszMessage; <br>         OLECHAR lpszUniMessage[256]; <br>#ifdef WIN32 <br>         UINT fuFlags    = (UINT)HIWORD(wParam); <br>         UINT uItem      = (UINT)LOWORD(wParam); <br>#else <br>         UINT fuFlags    = (UINT)LOWORD(lParam); <br>         UINT uItem      = (UINT)wParam; <br>#endif <br> <br>         if (uItem == 0 &amp;&amp; fuFlags == (UINT)-1) { <br>            GetControlMessage(STATUS_READY, &amp;lpszMessage); <br>            A2W (lpszMessage, lpszUniMessage, 256); <br>            OutlineApp_SetStatusText(lpOutlineApp, lpszUniMessage); <br>         } <br>         else if (fuFlags &amp; MF_POPUP) { <br>#ifdef WIN32 <br>            HMENU hMainMenu = (HMENU)lParam; <br>            HMENU hPopupMenu = GetSubMenu(hMainMenu,uItem); <br>#else <br>            HMENU hPopupMenu = (HMENU)wParam; <br>#endif <br>            GetPopupMessage(hPopupMenu, &amp;lpszMessage); <br>            A2W (lpszMessage, lpszUniMessage, 256); <br>            OutlineApp_SetStatusText(lpOutlineApp, lpszUniMessage); <br>         } <br>         else if (fuFlags &amp; MF_SYSMENU) { <br>            GetSysMenuMessage(uItem, &amp;lpszMessage); <br>            A2W (lpszMessage, lpszUniMessage, 256); <br>            OutlineApp_SetStatusText(lpOutlineApp, lpszUniMessage); <br>         } <br>         else if (uItem != 0) {  // Command Item <br>            GetItemMessage(uItem, &amp;lpszMessage); <br>            A2W (lpszMessage, lpszUniMessage, 256); <br>            OutlineApp_SetStatusText(lpOutlineApp, lpszUniMessage); <br>         } <br>         else { <br>            GetControlMessage(STATUS_BLANK, &amp;lpszMessage); <br>            A2W (lpszMessage, lpszUniMessage, 256); <br>            OutlineApp_SetStatusText(lpOutlineApp, lpszUniMessage); <br>         } <br>         break; <br>      } <br>#endif  // USE_STATUSBAR <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br>      case WM_U_INITFRAMETOOLS: <br>         OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>         break; <br>#endif <br> <br>      default: <br>         /* For any message for which you don't specifically provide a  */ <br>         /* service routine, you should return the message to Windows   */ <br>         /* for default message processing.                             */ <br> <br>         return DefWindowProc(hWnd, Message, wParam, lParam); <br>   } <br> <br>   return (LRESULT)0; <br>}     /* End of AppWndProc*/ <br> <br> <br>/************************************************************************/ <br>/*                                                                      */ <br>/* Document Window Procedure                                            */ <br>/*                                                                      */ <br>/*   The Document Window is the parent of the OwnerDraw Listbox which   */ <br>/* maintains the list of lines in the current document. This window     */ <br>/* receives the ownerdraw callback messages from the list box.          */ <br>/************************************************************************/ <br> <br>LRESULT FAR PASCAL DocWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ </code></pre>
<p>
</p>
<pre><code>LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)GetWindowLong(hWnd, 0); <br>   LPLINELIST      lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   LPSCALEFACTOR   lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc); <br> <br>#if defined( OLE_VERSION ) <br>   LPOLEAPP lpOleApp = (LPOLEAPP)lpOutlineApp; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br>#if defined( OLE_CNTR ) <br>   LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc; <br>#endif <br>#if defined( OLE_SERVER ) <br>   LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>#endif <br>#if defined( INPLACE_CNTR ) <br>   LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOutlineApp; <br>#endif <br>#endif  // OLE_VERSION <br> <br>   switch(Message) { <br> <br>#if defined( INPLACE_SVR ) <br> <br>      /* NOTE: ISVROTL doesn't use color palettes. The inplace objects <br>      **    that use color palettes must implement the following <br>      **    lines of code. <br>      ** <br>         case WM_QUERYNEWPALETTE: <br>            return wSelectPalette(hWnd, hPal, FALSE); // foreground <br> <br>         case WM_PALETTECHANGED: <br>            if (hWnd != (HWND) wParam) <br>               wSelectPalette(hWnd, hPal, TRUE);     // background <br>         break; <br>      ** <br>      ** <br>      ** <br>      */ <br>#endif <br> <br>      case WM_MEASUREITEM: <br>      { <br>         LPMEASUREITEMSTRUCT lpmis = ((LPMEASUREITEMSTRUCT)lParam); <br> <br>         switch (wParam) { <br>            case IDC_LINELIST: <br>            { <br>               HDC hDC = LineList_GetDC(lpLL); <br>               UINT uHeight; <br> <br>               uHeight=Line_GetHeightInHimetric((LPLINE)lpmis-&gt;itemData); <br>               uHeight = XformHeightInHimetricToPixels(hDC, uHeight); <br>               uHeight = (UINT) (uHeight * lpscale-&gt;dwSyN / <br>                     lpscale-&gt;dwSyD); <br> <br>               if (uHeight &gt;LISTBOX_HEIGHT_LIMIT) <br>                  uHeight = LISTBOX_HEIGHT_LIMIT; <br> <br>               lpmis-&gt;itemHeight = uHeight; <br>               LineList_ReleaseDC(lpLL, hDC); <br>               break; <br>            } <br> <br>            case IDC_NAMETABLE: <br>            { <br>               // NOTE: NameTable is never made visible. do nothing. <br>               break; <br>            } <br> <br>#if defined( USE_HEADING ) <br>            case IDC_ROWHEADING: <br>            { <br>               UINT uHeight; <br> <br>               uHeight = LOWORD(lpmis-&gt;itemData); <br>               uHeight = (UINT) (uHeight * lpscale-&gt;dwSyN / <br>                     lpscale-&gt;dwSyD); <br>               if (uHeight &gt;LISTBOX_HEIGHT_LIMIT) <br>                  uHeight = LISTBOX_HEIGHT_LIMIT; <br>               lpmis-&gt;itemHeight = uHeight; <br>               break; <br>            } <br> <br>            case IDC_COLHEADING: <br>            { <br>               UINT uHeight; <br> <br>               uHeight = LOWORD(lpmis-&gt;itemData); <br>               uHeight = (UINT) (uHeight * lpscale-&gt;dwSyN / <br>                     lpscale-&gt;dwSyD); <br>               if (uHeight &gt; LISTBOX_HEIGHT_LIMIT) <br>                  uHeight = LISTBOX_HEIGHT_LIMIT; <br>               lpmis-&gt;itemHeight = uHeight; <br>               break; <br>            } <br>#endif  // USE_HEADING <br> <br>         } <br>         return (LRESULT)TRUE; <br>      } <br> <br>      case WM_DRAWITEM: <br>      { <br>         LPDRAWITEMSTRUCT lpdis = ((LPDRAWITEMSTRUCT)lParam); <br> <br>         switch (lpdis-&gt;CtlID) { <br> <br>            case IDC_LINELIST: <br>            { <br>               RECT   rcClient; <br>               RECT   rcDevice; <br>               HWND   hWndLL = LineList_GetWindow(lpLL); <br>               LPLINE lpLine = (LPLINE)lpdis-&gt;itemData; <br> <br>               // NOTE: When itemID == -1, the listbox is empty. <br>               //       We are supposed to draw focus rect only <br>               //       But it is not done in this app. If this line is <br>               //       removed, the app will crash in Line_DrawToScreen <br>               //       because of invalid lpLine. <br>               if (lpdis-&gt;itemID == -1) <br>                  break; <br> <br>               GetClientRect(hWndLL, &amp;rcClient); <br> <br>               rcDevice = lpdis-&gt;rcItem; <br> <br>               // shift the item rect to account for horizontal scrolling <br> <br>               rcDevice.left += rcClient.right - lpdis-&gt;rcItem.right; <br> <br>#if defined( OLE_CNTR ) <br>               /* we need to remember the horizontal scroll offset <br>               **    needed for the in-place object's window. <br>               **    (this is specific to ICNTROTL) <br>               */ <br>               if(lpdis-&gt;itemAction &amp; ODA_DRAWENTIRE) { <br>                  if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) <br>                     ((LPCONTAINERLINE)lpLine)-&gt;m_nHorizScrollShift = <br>                        rcDevice.left; <br>               } <br>#endif  // OLE_CNTR <br> <br>               // shift rect for left margin <br>               rcDevice.left += (int)(XformWidthInHimetricToPixels(NULL, <br>                     LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) * <br>                     lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br> <br>               rcDevice.right = rcDevice.left + <br>                     (int)(XformWidthInHimetricToPixels(lpdis-&gt;hDC, <br>                           Line_GetWidthInHimetric(lpLine)) * <br>                     lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br> <br>               Line_DrawToScreen( <br>                     lpLine, <br>                     lpdis-&gt;hDC, <br>                     &amp;lpdis-&gt;rcItem, <br>                     lpdis-&gt;itemAction, <br>                     lpdis-&gt;itemState, <br>                     &amp;rcDevice <br>               ); <br> <br>#if defined( USE_FRAMETOOLS ) <br>               if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>                  OutlineDoc_SetFormulaBarEditText(lpOutlineDoc,lpLine); <br>#endif <br>               break; <br>            } <br>            case IDC_NAMETABLE: <br>            { <br>               // NOTE: NameTable is never made visible. do nothing <br>               break; <br>            } <br> <br>#if defined( USE_HEADING ) <br>            case IDC_ROWHEADING: <br>            { <br>               LPHEADING lphead; <br> <br>               // Last dummy item shouldn't be drawn <br>               if (lpdis-&gt;itemID == (UINT)LineList_GetCount(lpLL)) <br>                  break; <br> <br>               // only DrawEntire need be trapped as window is disabled <br>               if (lpdis-&gt;itemAction == ODA_DRAWENTIRE) { <br>                  lphead = OutlineDoc_GetHeading(lpOutlineDoc); <br>                  Heading_RH_Draw(lphead, lpdis); <br>               } <br>               break; <br>            } <br> <br>            case IDC_COLHEADING: <br>            { <br>               RECT   rect; <br>               RECT   rcDevice; <br>               RECT   rcLogical; <br>               LPHEADING lphead; <br> <br>               // only DrawEntire need be trapped as window is disabled <br>               if (lpdis-&gt;itemAction == ODA_DRAWENTIRE) { <br>                  lphead = OutlineDoc_GetHeading(lpOutlineDoc); <br>                  GetClientRect(lpdis-&gt;hwndItem, &amp;rect); <br> <br>                  rcDevice = lpdis-&gt;rcItem; <br> <br>                  // shift the item rect to account for <br>                  // horizontal scrolling <br>                  rcDevice.left = -(rcDevice.right - rect.right); <br> <br>                  // shift rect for left margin <br>                  rcDevice.left += (int)(XformWidthInHimetricToPixels( <br>                        NULL, <br>                        LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) * <br>                     lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br> <br>                  rcDevice.right = rcDevice.left + (int)lpscale-&gt;dwSxN; <br>                  rcLogical.left = 0; <br>                  rcLogical.bottom = 0; <br>                  rcLogical.right = (int)lpscale-&gt;dwSxD; <br>                  rcLogical.top = LOWORD(lpdis-&gt;itemData); <br> <br>                  Heading_CH_Draw(lphead, lpdis, &amp;rcDevice, &amp;rcLogical); <br>               } <br>               break; <br>            } <br>#endif  // USE_HEADING <br> <br>         } <br>         return (LRESULT)TRUE; <br>      } <br> <br>      case WM_SETFOCUS: <br>         if (lpLL) <br>            SetFocus(LineList_GetWindow(lpLL)); <br>         break; <br> <br>#if !defined( OLE_VERSION ) <br>      case WM_RENDERFORMAT: <br>      { <br>         LPOUTLINEDOC lpClipboardDoc = lpOutlineApp-&gt;m_lpClipboardDoc; <br>         if (lpClipboardDoc) <br>            OutlineDoc_RenderFormat(lpClipboardDoc, wParam); <br> <br>         break; <br>      } <br>      case WM_RENDERALLFORMATS: <br>      { <br>         LPOUTLINEDOC lpClipboardDoc = lpOutlineApp-&gt;m_lpClipboardDoc; <br>         if (lpClipboardDoc) <br>            OutlineDoc_RenderAllFormats(lpClipboardDoc); <br> <br>         break; <br>      } <br>      case WM_DESTROYCLIPBOARD: <br>         if (g_lpApp-&gt;m_lpClipboardDoc) { <br>            OutlineDoc_Destroy(g_lpApp-&gt;m_lpClipboardDoc); <br>            g_lpApp-&gt;m_lpClipboardDoc = NULL; <br>         } <br>         break; <br> <br>#endif   // OLE_VERSION <br> <br>#if defined( OLE_CNTR ) <br>      case WM_U_UPDATEOBJECTEXTENT: <br>      { <br>         /* Update the extents of any OLE object that is marked that <br>         **    its size may  have changed. when an <br>         **    IAdviseSink::OnViewChange notification is received, <br>         **    the corresponding ContainerLine is marked <br>         **    (m_fDoGetExtent==TRUE) and a message <br>         **    (WM_U_UPDATEOBJECTEXTENT) is posted to the document <br>         **    indicating that there are dirty objects. <br>         */ <br>         ContainerDoc_UpdateExtentOfAllOleObjects(lpContainerDoc); <br>         break; <br>      } <br>#endif  // OLE_CNTR <br> <br>#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR ) <br>      /* NOTE: Any window that is used during in-place activation <br>      **    must handle the WM_SETCURSOR message or else the cursor <br>      **    of the in-place parent will be used. if WM_SETCURSOR is <br>      **    not handled, then DefWindowProc sends the message to the <br>      **    window's parent. <br>      ** <br>      **    see context sensitive help technote (CSHELP.DOC). <br>      **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>      **    sensitive help is entered. <br>      **    if this flag is set then the context sensitive help <br>      **    cursor should be shown. <br>      */ <br>      case WM_SETCURSOR: <br>         if (lpOleDoc-&gt;m_fCSHelpMode) <br>            SetCursor(UICursorLoad(IDC_CONTEXTHELP)); <br>         else <br>            SetCursor(LoadCursor(NULL, IDC_ARROW) ); <br>         return (LRESULT)TRUE; <br>#endif  // INPLACE_SVR || INPLACE_CNTR <br> <br>#if defined( INPLACE_SVR ) <br>      /* NOTE: when the in-place active, our in-place server <br>      **    document window (passed to IOleInPlaceFrame::SetMenu) <br>      **    will receive the WM_INITMENU and WM_INITMENUPOPUP messages. <br>      */ <br>      case WM_INITMENU: <br>         OutlineApp_InitMenu(lpOutlineApp, lpOutlineDoc, (HMENU)wParam); <br>         break; <br> <br>      /* NOTE: WM_INITMENUPOPUP is trapped primarily for the Edit <br>      **    menu. We didn't update the Edit menu until it is popped <br>      **    up to avoid the overheads of the OLE calls which are <br>      **    required to initialize some Edit menu items. <br>      */ <br>      case WM_INITMENUPOPUP: <br>      { <br>         HMENU hMenuEdit = GetSubMenu(lpOutlineApp-&gt;m_hMenuApp, 1); <br>         if ((HMENU)wParam == hMenuEdit &amp;&amp; <br>            (LOWORD(lParam) == POS_EDITMENU) &amp;&amp; <br>            OleDoc_GetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc)) { <br>            OleApp_UpdateEditMenu( <br>                  (LPOLEAPP)lpOutlineApp, lpOutlineDoc, hMenuEdit); <br>         } <br>         break; <br>      } <br>#endif      // INPLACE_SVR <br> <br>#if defined( INPLACE_SVR ) &amp;&amp; defined( USE_STATUSBAR ) <br>      /* NOTE: when the server is in-place active the <br>      **    WM_MENUSELECT message is sent to the object's window and <br>      **    not the server app's frame window. processing this <br>      **    message allows there in-place server to give status bar <br>      **    help text for menu commands. <br>      */ <br>      case WM_MENUSELECT: <br>      { <br>         LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc; <br>         LPSTR lpszMessage; <br>         OLECHAR szUniMessage[256]; <br> <br>#ifdef WIN32 <br>         UINT fuFlags    = (UINT)HIWORD(wParam); <br>         UINT uItem      = (UINT)LOWORD(wParam); <br>#else <br>         UINT fuFlags    = (UINT)LOWORD(lParam); <br>         UINT uItem      = (UINT)wParam; <br>#endif <br> <br>         if (uItem == 0 &amp;&amp; fuFlags == (UINT)-1) { <br>            GetControlMessage(STATUS_READY, &amp;lpszMessage); <br>            A2W( lpszMessage, szUniMessage, 256); <br>            ServerDoc_SetStatusText(lpServerDoc, szUniMessage); <br>         } <br>         else if (fuFlags &amp; MF_POPUP) { <br>#ifdef WIN32 <br>            HMENU hMainMenu = (HMENU)lParam; <br>            HMENU hPopupMenu = GetSubMenu(hMainMenu,uItem); <br>#else <br>            HMENU hPopupMenu = (HMENU)wParam; <br>#endif <br>            GetPopupMessage(hPopupMenu, &amp;lpszMessage); <br>            A2W( lpszMessage, szUniMessage, 256); <br>            ServerDoc_SetStatusText(lpServerDoc, szUniMessage); <br>         } <br>         else if (uItem != 0) {  // Command Item <br>            GetItemMessage(uItem, &amp;lpszMessage); <br>            A2W( lpszMessage, szUniMessage, 256); <br>            ServerDoc_SetStatusText(lpServerDoc, szUniMessage); <br>         } <br>         else { <br>            GetControlMessage(STATUS_BLANK, &amp;lpszMessage); <br>            A2W( lpszMessage, szUniMessage, 256); <br>            ServerDoc_SetStatusText(lpServerDoc, szUniMessage); <br>         } <br>         break; <br>      } <br>#endif  // INPLACE_SVR &amp;&amp; USE_STATUSBAR <br>#if defined( INPLACE_SVR ) &amp;&amp; defined( USE_FRAMETOOLS ) <br> <br>      case WM_U_INITFRAMETOOLS: <br>         OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>         break; <br>#endif      // INPLACE_SVR &amp;&amp; USE_FRAMETOOLS <br> <br> <br>      case WM_COMMAND: <br>      { <br>#ifdef WIN32 <br>         WORD wNotifyCode = HIWORD(wParam); <br>         WORD wID          = LOWORD(wParam); <br>         HWND hwndCtl     = (HWND) lParam; <br>#else <br>         WORD wNotifyCode = HIWORD(lParam); <br>         WORD wID             = wParam; <br>         HWND hwndCtl     = (HWND) LOWORD(lParam); <br>#endif <br> <br>#if defined( INPLACE_SVR ) <br>         /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>         **    m_fMenuHelpMode flag is set when F1 is pressed when a <br>         **    menu item is selected. this flag is set in <br>         **    IOleInPlaceActiveObject::ContextSensitveHelp method. <br>         **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>         **    sensitive help is entered. this flag is set in <br>         **    IOleInPlaceObject::ContextSensitiveHelp method. <br>         **    if either of these flags are set then the WM_COMMAND <br>         **    message is received then, the corresponding command <br>         **    should NOT executed; help can be given (if desired). <br>         **    also the context sensitve help mode should be exited. <br>         **    the two different cases have their own way to exit <br>         **    the mode (please refer to the technote). <br>         */ <br>         if (lpOleDoc &amp;&amp; <br>            (lpServerDoc-&gt;m_fMenuHelpMode||lpOleDoc-&gt;m_fCSHelpMode) &amp;&amp; <br>            (wID &gt; IDM_FILE)   /* min wID for app command */ &amp;&amp; <br>            (wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) { <br> <br>            if ((lpServerDoc-&gt;m_fMenuHelpMode)) { <br>               LPOLEINPLACEFRAME lpFrame; <br> <br>               lpServerDoc-&gt;m_fMenuHelpMode = FALSE; <br> <br>               // inform top-level frame that we handled the <br>               //   menu help mode (F1) selection. <br>               if (lpServerDoc-&gt;m_lpIPData &amp;&amp; <br>                     (lpFrame=lpServerDoc-&gt;m_lpIPData-&gt;lpFrame)!=NULL){ <br>                  OLEDBG_BEGIN2("IOleInPlaceFrame::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpFrame-&gt;lpVtbl-&gt;ContextSensitiveHelp(lpFrame, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            if ((lpOleDoc-&gt;m_fCSHelpMode)) { <br>               LPOLEINPLACESITE lpSite; <br> <br>               lpOleDoc-&gt;m_fCSHelpMode = FALSE; <br> <br>               /* inform immediate in-place container parent and, <br>               **    if we were a container/server, immediate <br>               **    in-place object children that we handled the <br>               **    context sensitive help mode. <br>               */ <br>               if (lpServerDoc-&gt;m_lpIPData &amp;&amp; <br>                     (lpSite=lpServerDoc-&gt;m_lpIPData-&gt;lpSite) !=NULL) { <br>                  OLEDBG_BEGIN2("IOleInPlaceSite::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpSite-&gt;lpVtbl-&gt;ContextSensitiveHelp(lpSite, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            // if we provided help, we would do it here... <br> <br>            // remove context sensitive help cursor <br>            SetCursor(LoadCursor(NULL,IDC_ARROW)); <br>            return 0L; <br>         } <br>#endif  // INPLACE_SVR <br>#if defined( INPLACE_CNTR ) <br> <br>         /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>         **    m_fMenuHelpMode flag is set when F1 is pressed when a <br>         **    menu item is selected. this flag is set in <br>         **    IOleInPlaceFrame::ContextSensitveHelp method. <br>         **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>         **    sensitive help is entered. this flag is set in <br>         **    IOleInPlaceSite::ContextSensitiveHelp method. <br>         **    if either of these flags are set then the WM_COMMAND <br>         **    message is received then, the corresponding command <br>         **    should NOT executed; help can be given (if desired). <br>         **    also the context sensitve help mode should be exited. <br>         **    the two different cases have their own way to exit <br>         **    the mode (please refer to the technote). <br>         */ <br>         if (lpOleDoc &amp;&amp; <br>            (lpContainerApp-&gt;m_fMenuHelpMode||lpOleDoc-&gt;m_fCSHelpMode) &amp;&amp; <br>            (wID &gt; IDM_FILE)   /* min wID for app command */ &amp;&amp; <br>            (wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) { <br> <br>            if ((lpContainerApp-&gt;m_fMenuHelpMode)) { <br>               LPOLEINPLACEACTIVEOBJECT lpIPActiveObj = <br>                     lpContainerApp-&gt;m_lpIPActiveObj; <br> <br>               lpContainerApp-&gt;m_fMenuHelpMode = FALSE; <br> <br>               // inform the in-place active object that we handled the <br>               //   menu help mode (F1) selection. <br>               if (lpIPActiveObj) { <br>                  OLEDBG_BEGIN2("IOleInPlaceActiveObject::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpIPActiveObj-&gt;lpVtbl-&gt;ContextSensitiveHelp( <br>                        lpIPActiveObj, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            if ((lpOleDoc-&gt;m_fCSHelpMode)) { <br>               LPOLEINPLACEOBJECT lpIPObj; <br>               LPCONTAINERLINE lpLastIpActiveLine = <br>                     lpContainerDoc-&gt;m_lpLastIpActiveLine; <br> <br>               lpOleDoc-&gt;m_fCSHelpMode = FALSE; <br> <br>               /* inform immediate in-place container parent and, <br>               **    if we were a container/server, immediate <br>               **    in-place object children that we handled the <br>               **    context sensitive help mode. <br>               */ <br>               if (lpLastIpActiveLine &amp;&amp; <br>                     (lpIPObj=lpLastIpActiveLine-&gt;m_lpOleIPObj)!=NULL){ <br>                  OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp(FALSE) called\r\n") <br>                  lpIPObj-&gt;lpVtbl-&gt;ContextSensitiveHelp(lpIPObj, FALSE); <br>                  OLEDBG_END2 <br>               } <br>            } <br> <br>            // if we provided help, we would do it here... <br> <br>            // remove context sensitive help cursor <br>            SetCursor(LoadCursor(NULL,IDC_ARROW)); <br>            return 0L; <br>         } <br>#endif  // INPLACE_CNTR <br> <br>         switch (wID) { <br> <br>            /********************************************************* <br>            ** File new, open, save and print as well as Help about <br>            **    are duplicated in this switch statement and they are <br>            **    used to trap the message from the toolbar <br>            ** <br>            *********************************************************/ <br> <br>            case IDM_F_NEW: <br>               OleDbgIndent(-2);   // Reset debug output indent level <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_NewCommand\r\n") <br>               OutlineApp_NewCommand(lpOutlineApp); <br>               OLEDBG_END3 <br> <br>#if defined( OLE_CNTR ) <br>               /* NOTE: this call will attempt to recover <br>               **    resources by unloading DLL's that were loaded <br>               **    by OLE and are no longer being used. it is a <br>               **    good idea to call this API now and then if <br>               **    your app tends to run for a long time. <br>               **    otherwise these DLL's will be unloaded when <br>               **    the app exits. some apps may want to call <br>               **    this as part of idle-time processing. this <br>               **    call is optional. <br>               */ <br>               OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n") <br>               CoFreeUnusedLibraries(); <br>               OLEDBG_END2 <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons( <br>                     OutlineApp_GetActiveDoc(lpOutlineApp)); <br>#endif <br>               break; <br> <br>            case IDM_F_OPEN: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_OpenCommand\r\n") <br>               OutlineApp_OpenCommand(lpOutlineApp); <br>               OLEDBG_END3 <br> <br>#if defined( OLE_CNTR ) <br>               /* NOTE: this call will attempt to recover <br>               **    resources by unloading DLL's that were loaded <br>               **    by OLE and are no longer being used. it is a <br>               **    good idea to call this API now and then if <br>               **    your app tends to run for a long time. <br>               **    otherwise these DLL's will be unloaded when <br>               **    the app exits. some apps may want to call <br>               **    this as part of idle-time processing. this <br>               **    call is optional. <br>               */ <br>               OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n") <br>               CoFreeUnusedLibraries(); <br>               OLEDBG_END2 <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons( <br>                     OutlineApp_GetActiveDoc(lpOutlineApp)); <br>#endif <br>               break; <br> <br>            case IDM_F_SAVE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_SaveCommand\r\n") <br>               OutlineApp_SaveCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_F_PRINT: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineApp_PrintCommand\r\n") <br>               OutlineApp_PrintCommand(lpOutlineApp); <br>               OLEDBG_END3 <br>               break; <br> <br> <br>            case IDM_E_UNDO: <br>               // SORRY. NOT IMPLEMENTED <br>               break; <br> <br>            case IDM_E_CUT: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_CutCommand\r\n") <br>               OutlineDoc_CutCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>            case IDM_E_COPY: <br> <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_CopyCommand\r\n") <br>               OutlineDoc_CopyCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>            case IDM_E_PASTE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_PasteCommand\r\n") <br>               OutlineDoc_PasteCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>#if defined( OLE_VERSION ) <br>            case IDM_E_PASTESPECIAL: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OleDoc_PasteSpecialCommand\r\n") <br>               OleDoc_PasteSpecialCommand((LPOLEDOC)lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>#endif  // OLE_VERSION <br> <br>            case IDM_E_CLEAR: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_ClearCommand\r\n") <br>               OutlineDoc_ClearCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( OLE_CNTR ) <br>               /* NOTE: this call will attempt to recover <br>               **    resources by unloading DLL's that were loaded <br>               **    by OLE and are no longer being used. it is a <br>               **    good idea to call this API now and then if <br>               **    your app tends to run for a long time. <br>               **    otherwise these DLL's will be unloaded when <br>               **    the app exits. some apps may want to call <br>               **    this as part of idle-time processing. this <br>               **    call is optional. <br>               */ <br>               OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n") <br>               CoFreeUnusedLibraries(); <br>               OLEDBG_END2 <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>            case IDM_L_ADDLINE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_AddTextLineCommand\r\n") <br>               OutlineDoc_AddTextLineCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>               SetFocus(LineList_GetWindow(lpLL)); <br>#endif <br>               break; <br> <br>            case IDM_L_EDITLINE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_EditLineCommand\r\n") <br>               OutlineDoc_EditLineCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               SetFocus(LineList_GetWindow(lpLL)); <br>               break; <br> <br>            case IDM_L_INDENTLINE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_IndentCommand\r\n") <br>               OutlineDoc_IndentCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_L_UNINDENTLINE: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_UnindentCommand\r\n") <br>               OutlineDoc_UnindentCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_L_SETLINEHEIGHT: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_SetLineHeight\r\n") <br>               OutlineDoc_SetLineHeightCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_E_SELECTALL: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_SelectAllCommand\r\n") <br>               OutlineDoc_SelectAllCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>#if defined( OLE_CNTR ) <br>            case IDM_E_INSERTOBJECT: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("ContainerDoc_InsertOleObjectCommand\r\n") <br>               ContainerDoc_InsertOleObjectCommand(lpContainerDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>            case IDM_E_EDITLINKS: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("ContainerDoc_EditLinksCommand\r\n") <br>               ContainerDoc_EditLinksCommand(lpContainerDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_E_CONVERTVERB: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("ContainerDoc_ConvertCommand\r\n") <br>               ContainerDoc_ConvertCommand( <br>                     lpContainerDoc, FALSE /*fMustActivate*/); <br>               OLEDBG_END3 <br>               break; <br> <br> <br>            case IDM_E_PASTELINK: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("ContainerDoc_PasteLinkCommand\r\n") <br>               ContainerDoc_PasteLinkCommand(lpContainerDoc); <br>               OLEDBG_END3 <br> <br>#if defined( USE_FRAMETOOLS ) <br>               OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>#endif <br>               break; <br> <br>#endif  // OLE_CNTR <br> <br>            case IDM_N_DEFINENAME: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_DefineNameCommand\r\n") <br>               OutlineDoc_DefineNameCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>            case IDM_N_GOTONAME: <br>               OleDbgOutNoPrefix2("\r\n"); <br> <br>               OLEDBG_BEGIN3("OutlineDoc_GotoNameCommand\r\n") <br>               OutlineDoc_GotoNameCommand(lpOutlineDoc); <br>               OLEDBG_END3 <br>               break; <br> <br>#if defined( USE_FRAMETOOLS ) <br>            case IDM_O_BB_TOP: <br>               FrameTools_BB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_TOP); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_BB_BOTTOM: <br>               FrameTools_BB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_BOTTOM); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_BB_POPUP: <br>               FrameTools_BB_SetState( </code></pre>
<p>
</p>
<pre><code>lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_POPUP); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_BB_HIDE: <br>               FrameTools_BB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_HIDE); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_FB_TOP: <br>               FrameTools_FB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_TOP); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_FB_BOTTOM: <br>               FrameTools_FB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_BOTTOM); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_O_FB_POPUP: <br>               FrameTools_FB_SetState( <br>                     lpOutlineDoc-&gt;m_lpFrameTools, BARSTATE_POPUP); <br>               OutlineDoc_AddFrameLevelTools(lpOutlineDoc); <br>               break; <br> <br>            case IDM_FB_EDIT: <br> <br>               switch (wNotifyCode) { <br>                  case EN_SETFOCUS: <br>                     OutlineDoc_SetFormulaBarEditFocus( <br>                           lpOutlineDoc, TRUE); <br>                     OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>                     break; <br> <br>                  case EN_KILLFOCUS: <br>                     OutlineDoc_SetFormulaBarEditFocus( <br>                           lpOutlineDoc, FALSE); <br>                     OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc); <br>                     break; <br>               } <br>               break; <br> <br>            case IDM_FB_CANCEL: <br> <br>               SetFocus(hWnd); <br>               break; <br> <br> <br>            case IDM_F2: <br>               SendMessage(hWnd, WM_COMMAND, (WPARAM)IDM_FB_EDIT, <br>                     MAKELONG(0, EN_SETFOCUS)); <br>               break; <br>#endif  // USE_FRAMETOOLS <br> <br>            case IDM_ESCAPE: <br>               /* ESCAPE key pressed */ <br> <br>#if defined( USE_FRAMETOOLS ) <br>               if (OutlineDoc_IsEditFocusInFormulaBar(lpOutlineDoc)) <br>                  SendMessage( <br>                     hWnd, WM_COMMAND,(WPARAM)IDM_FB_CANCEL,(LPARAM)0); <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( INPLACE_SVR ) <br>               else { <br>                  LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br> <br>                  /* NOTE: The standard OLE 2.0 UI convention <br>                  **    is to have ESCAPE key exit in-place <br>                  **    activation (ie. UIDeactivate). If <br>                  **    possible it is recommended for both <br>                  **    in-place servers AND in-place containers <br>                  **    to take responsibility to handle the <br>                  **    ESCAPE key accelerator. The server has <br>                  **    the first crack at handling accelerator <br>                  **    keys and normally the server should do <br>                  **    the UIDeactivation. <br>                  */ <br>                  if (lpServerDoc-&gt;m_fUIActive) { <br>                     SvrDoc_IPObj_UIDeactivate( (LPOLEINPLACEOBJECT)&amp; <br>                           lpServerDoc-&gt;m_OleInPlaceObject); <br>                  } <br>               } <br>#endif  // INPLACE_SVR <br> <br>               break; <br> <br> <br>#if defined( USE_HEADING ) <br>            case IDC_BUTTON: <br>               if (wNotifyCode == BN_CLICKED) { <br>                  SendMessage(hWnd, WM_COMMAND, IDM_E_SELECTALL, 0L); <br>                  SetFocus(hWnd); <br>               } <br>               break; <br> <br>            case IDM_O_HEAD_SHOW: <br>               OutlineDoc_ShowHeading(lpOutlineDoc, TRUE); <br>               break; <br> <br>            case IDM_O_HEAD_HIDE: <br>               OutlineDoc_ShowHeading(lpOutlineDoc, FALSE); <br>               break; <br>#endif  // USE_HEADING <br> <br> <br>#if defined( OLE_CNTR ) <br>            case IDM_O_SHOWOBJECT: <br>            { <br>               LPCONTAINERDOC lpContainerDoc = <br>                        (LPCONTAINERDOC)lpOutlineDoc; <br>               BOOL        fShowObject; <br> <br>               fShowObject = !ContainerDoc_GetShowObjectFlag( <br>                     lpContainerDoc); <br>               ContainerDoc_SetShowObjectFlag( <br>                     lpContainerDoc, fShowObject); <br>               LineList_ForceRedraw(lpLL, TRUE); <br> <br>               break; <br>            } <br>#endif  // OLE_CNTR <br> <br>#if !defined( OLE_CNTR ) <br>            // Container does not allow zoom factors &gt; 100% <br>            case IDM_V_ZOOM_400: <br>            case IDM_V_ZOOM_300: <br>            case IDM_V_ZOOM_200: <br>#endif      // !OLE_CNTR <br> <br>            case IDM_V_ZOOM_100: <br>            case IDM_V_ZOOM_75: <br>            case IDM_V_ZOOM_50: <br>            case IDM_V_ZOOM_25: <br>               OutlineDoc_SetCurrentZoomCommand(lpOutlineDoc, wID); <br>               break; <br> <br>            case IDM_V_SETMARGIN_0: <br>            case IDM_V_SETMARGIN_1: <br>            case IDM_V_SETMARGIN_2: <br>            case IDM_V_SETMARGIN_3: <br>            case IDM_V_SETMARGIN_4: <br>               OutlineDoc_SetCurrentMarginCommand(lpOutlineDoc, wID); <br>               break; <br> <br>            case IDM_V_ADDTOP_1: <br>            case IDM_V_ADDTOP_2: <br>            case IDM_V_ADDTOP_3: <br>            case IDM_V_ADDTOP_4: <br>            { <br>               UINT nHeightInHimetric; <br> <br>               switch (wID) { <br>                  case IDM_V_ADDTOP_1: <br>                     nHeightInHimetric = 1000; <br>                     break; <br> <br>                  case IDM_V_ADDTOP_2: <br>                     nHeightInHimetric = 2000; <br>                     break; <br> <br>                  case IDM_V_ADDTOP_3: <br>                     nHeightInHimetric = 3000; <br>                     break; <br> <br>                  case IDM_V_ADDTOP_4: <br>                     nHeightInHimetric = 4000; <br>                     break; <br>               } <br> <br>               OutlineDoc_AddTopLineCommand( <br>                     lpOutlineDoc, nHeightInHimetric); <br>               break; <br>            } <br> <br> <br>            case IDM_H_ABOUT: <br>               OutlineApp_AboutCommand(lpOutlineApp); <br>               break; <br> <br>            case IDM_D_DEBUGLEVEL: <br>               SetDebugLevelCommand(); <br>               break; <br> <br>#if defined( OLE_VERSION ) <br>            case IDM_D_INSTALLMSGFILTER: <br>               InstallMessageFilterCommand(); <br>               break; <br> <br>            case IDM_D_REJECTINCOMING: <br>               RejectIncomingCommand(); <br>               break; <br>#endif  // OLE_VERSION <br> <br>#if defined( INPLACE_CNTR ) <br>            case IDM_D_INSIDEOUT: <br>               g_fInsideOutContainer = !g_fInsideOutContainer; <br> <br>               // force all object to unload so they can start new <br>               // activation behavior. <br>               ContainerDoc_UnloadAllOleObjectsOfClass( <br>                     (LPCONTAINERDOC)lpOutlineDoc, <br>                     &amp;CLSID_NULL, <br>                     OLECLOSE_SAVEIFDIRTY <br>               ); <br>               OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE); <br>               break; <br>#endif  // INPLACE_CNTR <br> <br> <br>#if defined( OLE_CNTR ) <br>            case IDC_LINELIST: { <br> <br>               if (wNotifyCode == LBN_DBLCLK) { <br> <br>                  /* NOTE: a container should execute the <br>                  **    OLEIVERB_PRIMARY verb on an OLE object <br>                  **    when the user DBLCLK's the object. <br>                  */ <br>                  int nIndex = LineList_GetFocusLineIndex(lpLL); <br>                  LPLINE lpLine = LineList_GetLine(lpLL, nIndex); <br> <br>                  if (lpLine &amp;&amp; <br>                        Line_GetLineType(lpLine)==CONTAINERLINETYPE) { <br>                     MSG msg; <br> <br>                     _fmemset((LPMSG)&amp;msg,0,sizeof(msg)); <br>                     msg.hwnd = hWnd; <br>                     msg.message = Message; <br>                     msg.wParam = wParam; <br>                     msg.lParam = lParam; <br> <br>                     ContainerLine_DoVerb( <br>                           (LPCONTAINERLINE)lpLine, <br>                           OLEIVERB_PRIMARY, <br>                           (LPMSG)&amp;msg, <br>                           TRUE, <br>                           TRUE <br>                     ); <br>                  } <br> <br>#if defined( INPLACE_CNTR ) <br>                  { // BEGIN BLOCK <br>                     LPCONTAINERDOC lpContainerDoc = <br>                           (LPCONTAINERDOC) lpOutlineDoc; <br>                     if (lpContainerDoc-&gt;m_fAddMyUI) { <br>                        /* NOTE: fAddMyUI is TRUE when <br>                        **    there was previously an in-place <br>                        **    active object which got <br>                        **    UIDeactivated as a result of this <br>                        **    DBLCLK AND the DBLCLK did NOT <br>                        **    result in in-place activating <br>                        **    another object. <br>                        **    (see IOleInPlaceSite::OnUIActivate and <br>                        **    IOleInPlaceSite::OnUIDeactivate <br>                        **    methods). <br>                        */ <br> <br>                        /* NOTE: You need to generate <br>                        **    QueryNewPalette only if you own <br>                        **    the top level frame (ie. you are <br>                        **    a top-level inplace container). <br>                        */ <br> <br> <br>                        OleApp_QueryNewPalette((LPOLEAPP)g_lpApp); <br> <br>#if defined( USE_DOCTOOLS ) <br>                        ContainerDoc_AddDocLevelTools(lpContainerDoc); <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>                        ContainerDoc_AddFrameLevelUI(lpContainerDoc); <br>#endif <br>                        lpContainerDoc-&gt;m_fAddMyUI = FALSE; <br>                     } <br>                  } // END BLOCK <br>#endif // INPLACE_CNTR <br>               } <br>               break; <br>            } <br>#endif  // OLE_CNTR <br> <br> <br>            default: <br> <br>#if defined( OLE_CNTR ) <br>               if (wID &gt;= IDM_E_OBJECTVERBMIN) { <br> <br>                  OleDbgOutNoPrefix2("\r\n"); <br>                  OLEDBG_BEGIN3("ContainerDoc_ContainerLineDoVerbCommand\r\n") <br>                  ContainerDoc_ContainerLineDoVerbCommand( <br>                        (LPCONTAINERDOC)lpOutlineDoc, <br>                        (LONG)(wID-IDM_E_OBJECTVERBMIN) <br>                  ); <br>                  OLEDBG_END3 <br>                  break; <br>               } <br>#endif  // OLE_CNTR <br>               return DefWindowProc(hWnd, Message, wParam, lParam); <br>         } <br> <br>         break;  /* End of WM_COMMAND */ <br>      } <br>      default: <br> <br>         if (Message == g_uMsgHelp) { <br>            /* Handle OLE2UI dialog's help messages. <br>            ** We get the hDlg of the dialog that called us in the wParam <br>            ** and the dialog type in the LOWORD of the lParam, <br>            ** so we pass this along to our help function. <br>            */ <br>            OutlineDoc_DialogHelp((HWND)wParam, LOWORD(lParam)); <br>            break; <br>         } <br> <br>         /* For any message for which you don't specifically provide a  */ <br>         /* service routine, you should return the message to Windows   */ <br>         /* for default message processing.                             */ <br>         return DefWindowProc(hWnd, Message, wParam, lParam); <br>   } <br> <br>   return (LRESULT)0; <br> <br>} /* End of DocWndProc */ <br> <br> <br> <br>//*********************************************************************** <br>//* <br>//* LineListWndProc()  Drag and Drop Listbox Window Proc Sub-Class <br>//* <br>//* Sub Class the Ownerdraw list box in order to activate the drag drop. <br>//*********************************************************************** <br> <br>LRESULT FAR PASCAL LineListWndProc( <br>   HWND   hWnd, <br>   UINT   Message, <br>   WPARAM wParam, <br>   LPARAM lParam <br>) <br>{ <br>   HWND         hwndParent = GetParent ( hWnd ); <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC) GetWindowLong( hwndParent, 0 ); <br>   LPLINELIST   lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br> <br>#if defined( OLE_VERSION ) <br>   LPOLEAPP     lpOleApp = (LPOLEAPP)lpOutlineApp; <br>   LPOLEDOC     lpOleDoc = (LPOLEDOC)lpOutlineDoc; <br>#endif  // OLE_VERSION <br> <br>#if defined( INPLACE_SVR ) <br>   LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOutlineDoc; <br>   static BOOL  fUIActivateClick = FALSE; <br>   static BOOL  fInWinPosChged = FALSE; <br>#endif  // INPLACE_SVR <br> <br>#if defined( INPLACE_CNTR ) <br>   LPCONTAINERAPP lpContainerApp=(LPCONTAINERAPP)lpOutlineApp; <br>   LPCONTAINERDOC lpContainerDoc=(LPCONTAINERDOC)lpOutlineDoc; <br>#endif  // INPLACE_CNTR <br> <br>   switch (Message) { <br> <br>      case WM_KILLFOCUS: <br>         /* NOTE: when our window looses focus we <br>         **    should not display any active selection <br>         */ <br>#if defined( INPLACE_CNTR ) <br>         if (! lpContainerApp-&gt;m_fPendingUIDeactivate) <br>#endif  // INPLACE_CNTR <br>            LineList_RemoveSel(lpLL); <br>         break; <br> <br>      case WM_SETFOCUS: <br> <br>#if defined( INPLACE_CNTR ) <br>         { <br>            HWND hWndObj=ContainerDoc_GetUIActiveWindow(lpContainerDoc); <br> <br>            /* NOTE: if there is a UIActive in-place object, we must <br>            **    forward focus to its window as long as there is <br>            **    not a pending UIDeactivate. if the mouse is <br>            **    clicked outside of the object and the object is <br>            **    about to be deactivated then we do NOT want to <br>            **    forward focus to the object. we do NOT want it to <br>            **    restore its selection feedback. <br>            */ <br>            if (lpContainerApp-&gt;m_fPendingUIDeactivate) <br>               break; <br>            else if (hWndObj) { <br>               SetFocus(hWndObj); <br>               break;      // do not restore containers selection state <br>            } <br>         } <br>#endif  // INPLACE_CNTR <br> <br>         /* NOTE: when our window gains focus we <br>         **    should restore the previous selection <br>         */ <br>         LineList_RestoreSel(lpLL); <br> <br>         break; <br> <br>#if defined( INPLACE_SVR ) <br>      case WM_MOUSEACTIVATE: <br>      { <br>         if (lpServerDoc-&gt;m_fInPlaceActive &amp;&amp; !lpServerDoc-&gt;m_fUIActive) { <br>            fUIActivateClick = TRUE; <br>         }; <br>         break; <br>      } <br> <br>#endif  // INPLACE_SVR <br> <br> <br>#if defined( USE_FRAMETOOLS ) <br>      case WM_CHAR: <br>      { <br>         OutlineDoc_SetFormulaBarEditFocus(lpOutlineDoc, TRUE); <br>         FrameTools_FB_SetEditText(lpOutlineDoc-&gt;m_lpFrameTools, NULL); <br>         FrameTools_FB_SendMessage( <br>               lpOutlineDoc-&gt;m_lpFrameTools, <br>               IDM_FB_EDIT, <br>               Message, <br>               wParam, <br>               lParam <br>         ); <br> <br>         return (LRESULT)0;   // don't do default listbox processing <br>      } <br>#endif  // USE_FRAMETOOLS <br> <br>#if defined( INPLACE_CNTR ) <br>      case WM_VSCROLL: <br>      { <br>         if (wParam == SB_ENDSCROLL) { <br>            /* NOTE: after scrolling finishes, update position of <br>            **    in-place visible windows. <br>            **    (ICNTROTL specific) we first let the ListBox <br>            **    perform it normal processing with the EndScroll <br>            **    message. also we let the ListBox handle all other <br>            **    scroll messages. <br>            */ <br>            LRESULT lResult =  CallWindowProc( <br>                  (WNDPROC)lpOutlineApp-&gt;m_ListBoxWndProc, <br>                  hWnd, <br>                  Message, <br>                  wParam, <br>                  lParam <br>            ); <br>            ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, 0); <br>            return lResult; <br>         } <br> <br>         break; <br>      } <br>#endif  // INPLACR_CNTR <br> <br>#if defined( USE_HEADING ) <br>      case WM_HSCROLL: <br>      { <br>         LPHEADING lphead = OutlineDoc_GetHeading(lpOutlineDoc); <br> <br>         Heading_CH_SendMessage(lphead, Message, wParam, lParam); <br> <br>         break; <br>      } <br> <br>      /* NOTE: WM_PAINT trapped in order to track vertical scrolling <br>      **    that has taken place so the row headings can be <br>      **    coordinated with the LineList. we wanted to trap instead <br>      **    but it is not generated from scrolling without using <br>      **    scroll bar (e.g. use keyboard). <br>      */ <br>      case WM_PAINT: <br>      { <br>         Heading_RH_Scroll(OutlineDoc_GetHeading(lpOutlineDoc), hWnd); <br>         break; <br>      } <br> <br>#endif  // USE_HEADING <br> <br>      case WM_LBUTTONUP: <br>      { <br> <br>#if defined( USE_DRAGDROP ) <br>         if (lpOleDoc-&gt;m_fPendingDrag) { <br>            /* ButtonUP came BEFORE distance/time threshholds were <br>            **    exceeded. clear fPendingDrag state. <br>            */ <br>            ReleaseCapture(); <br>            KillTimer(hWnd, 1); <br>            lpOleDoc-&gt;m_fPendingDrag = FALSE; <br>         } <br>#endif  // USE_DRAGDROP <br> <br>#if defined( INPLACE_SVR ) <br>         if (fUIActivateClick) { <br>            fUIActivateClick = FALSE; <br>            ServerDoc_UIActivate((LPSERVERDOC) lpOleDoc); <br>         } <br>#endif  // INPLACE_SVR <br> <br>#if defined( INPLACE_CNTR ) <br>         { <br>            /* check if a UIDeactivate is pending. <br>            **      (see comment in WM_LBUTTONDOWN) <br>            */ <br>            if ( lpContainerApp-&gt;m_fPendingUIDeactivate ) { <br>               ContainerLine_UIDeactivate( <br>                     lpContainerDoc-&gt;m_lpLastUIActiveLine); <br> <br>               lpContainerApp-&gt;m_fPendingUIDeactivate = FALSE; <br>            } <br>         } <br>#endif  // INPLACE_CNTR <br> <br>         break; <br>      } <br> <br>      case WM_LBUTTONDOWN: <br>      { <br>         POINT pt; <br> <br>         pt.x = (int)(short)LOWORD (lParam ); <br>         pt.y = (int)(short)HIWORD (lParam ); <br> <br>#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR ) <br>         /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>         **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>         **    sensitive help is entered. <br>         **    if this flag is set then the button click should not <br>         **    cause any action. if the application implements a <br>         **    help system, then context sensitive help should be <br>         **    given for the location clicked by the user. <br>         */ <br>         if (lpOleDoc-&gt;m_fCSHelpMode) { <br>            return (LRESULT)0;   // eat the button click because we do <br>                            // not give any help. <br>         } <br>#endif  // INPLACE_SVR || INPLACE_CNTR <br> <br>#if defined( INPLACE_CNTR ) <br>         { <br>            /* NOTE: both inside-out and outside-in style <br>            **    containers must check if the mouse click is <br>            **    outside of the current UIActive object (if <br>            **    any). If so, then set the flag indicating that <br>            **    there is a pending UIDeactivate needed. We do NOT <br>            **    want to do it now, <br>            **    because that would result in un-wanted movement of <br>            **    the data on the screen as frame adornments (eg. <br>            **    toolbar) and/or object adornments (eg. ruler) would <br>            **    be removed from the screen. we want to defer the <br>            **    UIDeactivate till the mouse up event. The listbox's <br>            **    default processing captures the mouse on button down <br>            **    so that it is sure to get the button up message. <br>            ** <br>            **    SPECIAL NOTE: there is potential interaction here <br>            **    with Drag/Drop. if this button down event actually <br>            **    starts a Drag/Drop operation, then OLE does the mouse <br>            **    capture. in this situation we will NOT get our button <br>            **    up event. we must instead perform the UIDeactivate <br>            **    when the drop operation finishes <br>            */ <br>            lpContainerApp-&gt;m_fPendingUIDeactivate = <br>                  ContainerDoc_IsUIDeactivateNeeded(lpContainerDoc, pt); <br>         } <br>#endif  // INPLACE_CNTR <br> <br>#if defined( USE_DRAGDROP ) <br> <br>         /* NOTE: check if this is a button down on the region <br>         **    that is a handle to start a drag operation. for us, <br>         **    this this the top/bottom border of the selection. <br>         **    do NOT want to start a drag immediately; we want to <br>         **    wait until the mouse moves a certain threshold. if <br>         **    LButtonUp comes before mouse move to start drag, then <br>         **    the fPendingDrag state is cleared. we must capture <br>         **    the mouse to ensure the modal state is handled <br>         **    properly. <br>         */ <br>         if ( OleDoc_QueryDrag(lpOleDoc, pt.y) ) { <br>            lpOleDoc-&gt;m_fPendingDrag = TRUE; <br>            lpOleDoc-&gt;m_ptButDown = pt; <br>            SetTimer(hWnd, 1, lpOleApp-&gt;m_nDragDelay, NULL); <br>            SetCapture(hWnd); <br> <br>            /* We do NOT want to do the listbox's default <br>            **    processing which would be to capture the mouse <br>            **    and enter a modal multiple selection state until <br>            **    a mouse up occurs. we have just finished a modal <br>            **    drag/drop operation where OLE has captured the <br>            **    mouse. thus by now the mouse up has already occured. <br>            */ <br> <br>            return (LRESULT)0;   // don't do default listbox processing <br>         } <br>#endif  // USE_DRAGDROP <br> <br>         break; <br>      } <br> <br> <br>      case WM_MOUSEMOVE: { <br> <br>#if defined( USE_DRAGDROP ) <br> <br>         int  x = (int)(short)LOWORD (lParam ); <br>         int  y = (int)(short)HIWORD (lParam ); <br>         POINT pt = lpOleDoc-&gt;m_ptButDown; <br>         int nDragMinDist = lpOleApp-&gt;m_nDragMinDist; <br> <br>         if (lpOleDoc-&gt;m_fPendingDrag) { <br> <br>            if (! ( ((pt.x - nDragMinDist) &lt;= x) <br>                  &amp;&amp; (x &lt;= (pt.x + nDragMinDist)) <br>                  &amp;&amp; ((pt.y - nDragMinDist) &lt;= y) <br>                  &amp;&amp; (y &lt;= (pt.y + nDragMinDist)) ) ) { <br> <br>               DWORD dwEffect; <br> <br>               // mouse moved beyond threshhold to start drag <br>               ReleaseCapture(); <br>               KillTimer(hWnd, 1); <br>               lpOleDoc-&gt;m_fPendingDrag = FALSE; <br> <br>               // perform the modal drag/drop operation. <br>               dwEffect = OleDoc_DoDragDrop( lpOleDoc ); <br> <br>#if defined( INPLACE_CNTR ) <br>               { <br>                  /* if necessary UIDeactive the in-place object. <br>                  **    this applies to outside-in style <br>                  **    container only. <br>                  **    (see comment above) <br>                  */ <br>                  if (lpContainerApp-&gt;m_fPendingUIDeactivate) { <br>                     lpContainerApp-&gt;m_fPendingUIDeactivate = FALSE; <br> <br>                     // do not UIDeactivate if drag/drop was canceled <br>                     if (dwEffect != DROPEFFECT_NONE) <br>                        ContainerLine_UIDeactivate( <br>                              lpContainerDoc-&gt;m_lpLastUIActiveLine <br>                        ); <br>                  } <br>               } <br>#endif  // INPLACE_CNTR <br> <br>               return (LRESULT)0; // don't do default listbox process <br>            } <br>            else { <br>               /* cursor did not move from initial mouse down <br>               **    (pending drag) point. <br>               */ <br>               return (LRESULT)0; // don't do default listbox process <br>            } <br>         } <br> <br>#endif  // USE_DRAGDROP <br> <br>#if defined( INPLACE_CNTR ) <br>         { // BEGIN BLOCK <br>            if (lpContainerDoc-&gt;m_fAddMyUI) { <br>               /* NOTE: fAddMyUI is TRUE when <br>               **    there was previously an in-place <br>               **    active object which got <br>               **    UIDeactivated as a result of a <br>               **    DBLCLK AND the DBLCLK did NOT <br>               **    result in in-place activating <br>               **    another object. <br>               **    (see IOleInPlaceSite::OnUIActivate and <br>               **    IOleInPlaceSite::OnUIDeactivate <br>               **    methods). <br>               */ <br>#if defined( USE_DOCTOOLS ) <br>               ContainerDoc_AddDocLevelTools(lpContainerDoc); <br>#endif <br> <br>#if defined( USE_FRAMETOOLS ) <br>               ContainerDoc_AddFrameLevelUI(lpContainerDoc); <br>#endif <br>               lpContainerDoc-&gt;m_fAddMyUI = FALSE; <br>            } <br>         } // END BLOCK <br>#endif // INPLACE_CNTR <br> <br>         break; <br>      } <br> <br> <br>#if defined( USE_DRAGDROP ) <br>      case WM_TIMER: <br>      { <br>         DWORD dwEffect; <br> <br>         // drag time delay threshhold exceeded -- start drag <br>         ReleaseCapture(); <br>         KillTimer(hWnd, 1); <br>         lpOleDoc-&gt;m_fPendingDrag = FALSE; <br> <br>         // perform the modal drag/drop operation. <br>         dwEffect = OleDoc_DoDragDrop( lpOleDoc ); <br> <br>#if defined( INPLACE_CNTR ) <br>         /* if necessary UIDeactive the in-place object. <br>         **    this applies to outside-in style <br>         **    container only. <br>         **    (see comment above) <br>         */ <br>         if (lpContainerApp-&gt;m_fPendingUIDeactivate) { <br>            lpContainerApp-&gt;m_fPendingUIDeactivate = FALSE; <br> <br>            // do not UIDeactivate if drag/drop was canceled <br>            if (dwEffect != DROPEFFECT_NONE) <br>               ContainerLine_UIDeactivate( <br>                     lpContainerDoc-&gt;m_lpLastUIActiveLine); <br>         } <br>#endif  // INPLACE_CNTR <br>         break; <br>      } <br>#endif  // USE_DRAGDROP <br> <br>      case WM_SETCURSOR: <br>      { <br>         RECT rc; <br>         POINT ptCursor; <br>#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR ) <br>         /* NOTE: see context sensitive help technote (CSHELP.DOC) <br>         **    m_fCSHelpMode flag is set when SHIFT-F1 context <br>         **    sensitive help is entered. <br>         **    if this flag is set then the context sensitive help <br>         **    cursor should be shown. <br>         */ <br>         if (lpOleDoc-&gt;m_fCSHelpMode) { <br>            SetCursor(UICursorLoad(IDC_CONTEXTHELP)); <br>            return (LRESULT)TRUE; <br>         } <br>#endif  // INPLACE_SVR || INPLACE_CNTR <br> <br>         GetCursorPos((POINT FAR*)&amp;ptCursor); <br>         ScreenToClient(hWnd, (POINT FAR*)&amp;ptCursor); <br>         GetClientRect(hWnd, (LPRECT)&amp;rc); <br> <br>         // use arrow cursor if in scroll bar <br>         if (! PtInRect((LPRECT)&amp;rc, ptCursor) ) <br>            SetCursor(LoadCursor(NULL, IDC_ARROW) ); <br> <br>#if defined( USE_DRAGDROP ) <br>         // use arrow cursor if on drag handle (top/bottom of selection) <br>         else if ( OleDoc_QueryDrag ( lpOleDoc, ptCursor.y) ) <br>            SetCursor(LoadCursor(NULL, IDC_ARROW) ); <br>#endif  // USE_DRAGDROP <br> <br>         else <br>            SetCursor(lpOutlineApp-&gt;m_hcursorSelCur); <br> <br>         return (LRESULT)TRUE; <br>      } <br> <br>#if defined( INPLACE_SVR ) <br> <br>      /* The handling of WM_WINDOWPOSCHANGED message is ISVROTL <br>      **    application specific. The nature of the owner-draw list <br>      **    box used by the ISVROTL application causes a recursive <br>      **    call to this message in some situations when in-place <br>      **    active. in order not to crash this recursive call must be <br>      **    guarded. <br>      */ <br>      case WM_WINDOWPOSCHANGED: <br>      { <br>         WINDOWPOS FAR* lpWinPos = (WINDOWPOS FAR*) lParam; <br>         LRESULT lResult; <br> <br>         // guard against recursive call <br>         if (fInWinPosChged) <br>            return (LRESULT)0; <br> <br>         fInWinPosChged = TRUE; <br>         lResult = CallWindowProc( <br>               (WNDPROC)lpOutlineApp-&gt;m_ListBoxWndProc, <br>               hWnd, <br>               Message, <br>               wParam, <br>               lParam <br>         ); <br>         fInWinPosChged = FALSE; <br> <br>         return lResult; <br>      } <br>#endif  // INPLACE_SVR <br> <br>   } <br> <br>   return CallWindowProc( <br>         (WNDPROC)lpOutlineApp-&gt;m_ListBoxWndProc, <br>         hWnd, <br>         Message, <br>         wParam, <br>         lParam <br>   ); <br> <br>} <br> <br>// Utility function to count the number of accelerator items in an <br>//  accelerator table.  A number of OLE APIs need this count, so <br>//  this can be quite handy. <br>// (code shamelessly stolen from the Microsoft Foundation Classes) <br> <br>int GetAccelItemCount(HACCEL hAccel) <br>{ <br>#if defined( WIN32 ) <br>    return CopyAcceleratorTable(hAccel, NULL, 0); <br>#else <br>   #pragma pack(1) <br>   typedef struct tagACCELERATOR <br>   { <br>      BYTE    fFlags; <br>      WORD    wEvent; <br>      WORD    wID; <br>   } ACCELERATOR; <br>   #pragma pack() <br> <br>   // attempt to lock down the accelerator resource <br>   ACCELERATOR FAR* pAccel; <br>   int cAccelItems = 1; <br>   if (hAccel == NULL || <br>      (pAccel = (ACCELERATOR FAR*)LockResource((HGLOBAL)hAccel)) == NULL) <br>   { <br>      // NULL accerator table or LockResource failed on the HACCEL, <br>      //  no accelerators <br>      return 0; <br>   } <br>   // otherwise, count them -- last entry in accel table has 0x80 bit set <br>   while ((pAccel-&gt;fFlags &amp; 0x80) == 0) <br>   { <br>      ++cAccelItems; <br>      ++pAccel; <br>   } <br>   UnlockResource((HGLOBAL)hAccel); <br>   return cAccelItems; <br>#endif <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
