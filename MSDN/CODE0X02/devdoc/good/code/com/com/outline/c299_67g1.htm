<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLLINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context301"></a>OUTLLINE.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outlline.c <br>** <br>**    This file contains Line functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br> <br>/* Line_Init <br> * --------- <br> * <br> *      Init the calculated data of a line object <br> */ <br>void Line_Init(LPLINE lpLine, int nTab, HDC hDC) <br>{ <br>   lpLine-&gt;m_lineType              = UNKNOWNLINETYPE; <br>   lpLine-&gt;m_nTabLevel             = nTab; <br>   lpLine-&gt;m_nTabWidthInHimetric   = Line_CalcTabWidthInHimetric(lpLine,hDC); <br>   lpLine-&gt;m_nWidthInHimetric      = 0; <br>   lpLine-&gt;m_nHeightInHimetric     = 0; <br>   lpLine-&gt;m_fSelected             = FALSE; <br> <br>#if defined( USE_DRAGDROP ) <br>   lpLine-&gt;m_fDragOverLine         = FALSE; <br>#endif <br>} <br> <br> <br>/* Line_Edit <br> * --------- <br> * <br> *      Edit the line object. <br> * <br> *      Returns TRUE if line was changed <br> *              FALSE if the line was NOT changed <br> */ <br>BOOL Line_Edit(LPLINE lpLine, HWND hWndDoc, HDC hDC) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         return TextLine_Edit((LPTEXTLINE)lpLine, hWndDoc, hDC); <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_Edit((LPCONTAINERLINE)lpLine, hWndDoc, hDC); <br>         break; <br>#endif <br> <br>      default: <br>         return FALSE;       // unknown line type <br>   } <br>} <br> <br> <br>/* Line_GetLineType <br> * ---------------- <br> * <br> * Return type of the line <br> */ <br>LINETYPE Line_GetLineType(LPLINE lpLine) <br>{ <br>   if (! lpLine) return 0; <br> <br>   return lpLine-&gt;m_lineType; <br>} <br> <br> <br>/* Line_GetTextLen <br> * --------------- <br> * <br> * Return length of string representation of the Line <br> *  (not considering the tab level). <br> */ <br>int Line_GetTextLen(LPLINE lpLine) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         return TextLine_GetTextLen((LPTEXTLINE)lpLine); <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         return ContainerLine_GetTextLen((LPCONTAINERLINE)lpLine); <br>#endif <br> <br>      default: <br>         return 0;       // unknown line type <br>   } <br>} <br> <br> <br>/* Line_GetTextData <br> * ---------------- <br> * <br> * Return the string representation of the Line. <br> *  (not considering the tab level). <br> */ <br>void Line_GetTextData(LPLINE lpLine, LPOLESTR lpszBuf) <br>{ <br>   char szAnsiStr[256]; <br> <br>   switch (lpLine-&gt;m_lineType) { <br>     case TEXTLINETYPE: <br>         TextLine_GetTextData((LPTEXTLINE)lpLine, szAnsiStr); <br>         A2W (szAnsiStr, lpszBuf, 256);  // lpszBuf ought to be big enough <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_GetTextData((LPCONTAINERLINE)lpLine, lpszBuf); <br>         break; <br>#endif <br> <br>      default: <br>         *lpszBuf = '\0'; <br>         return;     // unknown line type <br>   } <br>} <br> <br> <br>/* Line_GetOutlineData <br> * ------------------- <br> * <br> * Return the CF_OUTLINE format representation of the Line. <br> */ <br>BOOL Line_GetOutlineData(LPLINE lpLine, LPTEXTLINE lpBuf) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         return TextLine_GetOutlineData((LPTEXTLINE)lpLine, lpBuf); <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         return ContainerLine_GetOutlineData( <br>               (LPCONTAINERLINE)lpLine, <br>               lpBuf <br>         ); <br>#endif <br> <br>      default: <br>         return FALSE;       // unknown line type <br>   } <br>} <br> <br> <br>/* Line_CalcTabWidthInHimetric <br> * --------------------------- <br> * <br> *      Recalculate the width for the line's current tab level <br> */ <br>static int Line_CalcTabWidthInHimetric(LPLINE lpLine, HDC hDC) <br>{ <br>   int nTabWidthInHimetric; <br> <br>   nTabWidthInHimetric=lpLine-&gt;m_nTabLevel * TABWIDTH; <br>   return nTabWidthInHimetric; <br>} <br> <br> <br>/* Line_Indent <br> * ----------- <br> * <br> *      Increment the tab level for the line <br> */ <br>void Line_Indent(LPLINE lpLine, HDC hDC) <br>{ <br>   lpLine-&gt;m_nTabLevel++; <br>   lpLine-&gt;m_nTabWidthInHimetric = Line_CalcTabWidthInHimetric(lpLine, hDC); <br> <br>#if defined( INPLACE_CNTR ) <br>   if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) <br>      ContainerLine_UpdateInPlaceObjectRects((LPCONTAINERLINE)lpLine, NULL); <br>#endif <br>} <br> <br> <br>/* Line_Unindent <br> * ------------- <br> * <br> * Decrement the tab level for the line <br> */ <br>void Line_Unindent(LPLINE lpLine, HDC hDC) <br>{ <br>   if(lpLine-&gt;m_nTabLevel &gt; 0) { <br>      lpLine-&gt;m_nTabLevel--; <br>      lpLine-&gt;m_nTabWidthInHimetric = Line_CalcTabWidthInHimetric(lpLine, hDC); <br>   } <br> <br>#if defined( INPLACE_CNTR ) <br>   if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) <br>      ContainerLine_UpdateInPlaceObjectRects((LPCONTAINERLINE)lpLine, NULL); <br>#endif <br>} <br> <br> <br>/* Line_GetTotalWidthInHimetric <br> * ---------------------------- <br> * <br> *      Calculate the total width of the line <br> */ <br>UINT Line_GetTotalWidthInHimetric(LPLINE lpLine) <br>{ <br>   return lpLine-&gt;m_nWidthInHimetric + lpLine-&gt;m_nTabWidthInHimetric; <br>} <br> <br> <br>/* Line_SetWidthInHimetric <br> * ----------------------- <br> * <br> *      Set the width of the line <br> */ <br>void Line_SetWidthInHimetric(LPLINE lpLine, int nWidth) <br>{ <br>   if (!lpLine) <br>      return; <br> <br>   lpLine-&gt;m_nWidthInHimetric = nWidth; <br>} <br> <br> <br>/* Line_GetWidthInHimetric <br> * ----------------------- <br> * <br> *      Return the width of the line <br> */ <br>UINT Line_GetWidthInHimetric(LPLINE lpLine) <br>{ <br>   if (!lpLine) <br>      return 0; <br> <br>   return lpLine-&gt;m_nWidthInHimetric; <br>} <br> <br> <br> <br> <br> <br>/* Line_GetTabLevel <br> * ---------------- <br> * <br> * Return the tab level of a line object. <br> */ <br>UINT Line_GetTabLevel(LPLINE lpLine) <br>{ <br>   return lpLine-&gt;m_nTabLevel; <br>} <br> <br> <br>/* Line_DrawToScreen <br> * ----------------- <br> * <br> *      Draw the item in the owner-draw listbox <br> */ <br>void Line_DrawToScreen( <br>      LPLINE      lpLine, <br>      HDC         hDC, <br>      LPRECT      lprcPix, <br>      UINT        itemAction, <br>      UINT        itemState, <br>      LPRECT      lprcDevice <br>) <br>{ <br>   if (!lpLine || !hDC || !lprcPix || !lprcDevice) <br>      return; <br> <br>   /* Draw a list box item in its normal drawing action. <br>    * Then check if it is selected or has the focus state, and call <br>    * functions to handle drawing for these states if necessary. <br>    */ <br>   if(itemAction &amp; (ODA_SELECT | ODA_DRAWENTIRE)) { <br>      HFONT hfontOld; <br>      int nMapModeOld; <br>      RECT rcWindowOld; <br>      RECT rcViewportOld; <br>      RECT rcLogical; <br> <br>      // NOTE: we have to set the device context to HIMETRIC in order <br>      // draw the line; however, we have to restore the HDC before <br>      // we draw focus or dragfeedback... <br> <br>      rcLogical.left = 0; <br>      rcLogical.bottom = 0; <br>      rcLogical.right = lpLine-&gt;m_nWidthInHimetric; <br>      rcLogical.top = lpLine-&gt;m_nHeightInHimetric; <br> <br>      { <br>         HBRUSH hbr; <br>         RECT    rcDraw; <br> <br>         lpLine-&gt;m_fSelected = (BOOL)(itemState &amp; ODS_SELECTED); <br> <br>         if (ODS_SELECTED &amp; itemState) { <br>            /*Get proper txt colors */ <br>            hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT)); <br>         } <br>         else { <br>            hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>         } <br> <br>         rcDraw = *lprcPix; <br>         rcDraw.right = lprcDevice-&gt;left; <br>         FillRect(hDC, lprcPix, hbr); <br> <br>         rcDraw = *lprcPix; <br>         rcDraw.left = lprcDevice-&gt;right; <br>         FillRect(hDC, lprcPix, hbr); <br> <br>         DeleteObject(hbr); <br>      } <br> <br>      nMapModeOld=SetDCToAnisotropic(hDC, lprcDevice, &amp;rcLogical, <br>                     (LPRECT)&amp;rcWindowOld, (LPRECT)&amp;rcViewportOld); <br> <br>      // Set the default font size, and font face name <br>      hfontOld = SelectObject(hDC, OutlineApp_GetActiveFont(g_lpApp)); <br> <br>      Line_Draw(lpLine, hDC, &amp;rcLogical, NULL, (ODS_SELECTED &amp; itemState)); <br> <br>      SelectObject(hDC, hfontOld); <br> <br>      ResetOrigDC(hDC, nMapModeOld, (LPRECT)&amp;rcWindowOld, <br>            (LPRECT)&amp;rcViewportOld); <br> <br>#if defined( OLE_CNTR ) <br>      if ((itemState &amp; ODS_SELECTED) &amp;&amp; <br>         (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) <br>         ContainerLine_DrawSelHilight( <br>               (LPCONTAINERLINE)lpLine, <br>               hDC, <br>               lprcPix, <br>               ODA_SELECT, <br>               ODS_SELECTED <br>         ); <br>#endif <br> <br>   } <br> <br>   /* If a list box item just gained or lost the focus, <br>   * call function (which could check if ODS_FOCUS bit is set) <br>   * and draws item in focus or non-focus state. <br>   */ <br>   if(itemAction &amp; ODA_FOCUS ) <br>      Line_DrawFocusRect(lpLine, hDC, lprcPix, itemAction, itemState); <br> <br> <br>#if defined( OLE_CNTR ) <br>   if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) { <br>      LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine; <br>      LPCONTAINERDOC lpDoc = lpContainerLine-&gt;m_lpDoc; <br>      BOOL fIsLink; <br>      RECT rcObj; <br> <br>      if (ContainerDoc_GetShowObjectFlag(lpDoc)) { <br>         ContainerLine_GetOleObjectRectInPixels(lpContainerLine, &amp;rcObj); <br>         fIsLink = ContainerLine_IsOleLink(lpContainerLine); <br>         OleUIShowObject(&amp;rcObj, hDC, fIsLink); <br>      } <br>   } <br>#endif <br> <br>#if defined( USE_DRAGDROP ) <br>   if (lpLine-&gt;m_fDragOverLine) <br>      Line_DrawDragFeedback(lpLine, hDC, lprcPix, itemState ); <br>#endif <br> <br>} <br> <br> <br>/* Line_Draw <br> * --------- <br> * <br> *  Draw a line on a DC. <br> * <br> * Parameters: <br> *      hDC     - DC to which the line will be drawn <br> *      lpRect  - the object rect in logical coordinates <br> */ <br>void Line_Draw( <br>      LPLINE      lpLine, <br>      HDC         hDC, <br>      LPRECT      lpRect, <br>      LPRECT      lpRectWBounds, <br>      BOOL        fHighlight <br>) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         TextLine_Draw( <br>             (LPTEXTLINE)lpLine, hDC, lpRect,lpRectWBounds,fHighlight); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_Draw( <br>             (LPCONTAINERLINE)lpLine,hDC,lpRect,lpRectWBounds,fHighlight); <br>         break; <br>#endif <br> <br>      default: <br>         return;     // unknown line type <br>   } <br>   return; <br>} <br> <br> <br>/* Line_DrawSelHilight <br> * ------------------- <br> * <br> *      Handles selection of list box item <br> */ <br>void Line_DrawSelHilight(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         TextLine_DrawSelHilight((LPTEXTLINE)lpLine, hDC, lpRect, <br>            itemAction, itemState); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_DrawSelHilight((LPCONTAINERLINE)lpLine, hDC, lpRect, <br>            itemAction, itemState); <br>         break; <br>#endif <br> <br>      default: <br>         return;     // unknown line type <br>   } <br>   return; <br> <br>} <br> <br>/* Line_DrawFocusRect <br> * ------------------ <br> * <br> *      Handles focus state of list box item <br> */ <br>void Line_DrawFocusRect(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState) <br>{ <br>   if(lpLine) <br>      DrawFocusRect(hDC, lpRect); <br>} <br> <br>#if defined( USE_DRAGDROP ) <br> <br>/* Line_DrawDragFeedback <br> * --------------------- <br> * <br> *      Handles focus state of list box item <br> */ <br>void Line_DrawDragFeedback(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemState ) <br>{ <br>   if(lpLine) <br>      DrawFocusRect(hDC, lpRect); <br>} <br> <br>#endif  // USE_DRAGDROP <br> <br> <br>/* Line_GetHeightInHimetric <br> * ------------------------ <br> * <br> *      Return the height of the item in HIMETRIC units <br> */ <br>UINT Line_GetHeightInHimetric(LPLINE lpLine) <br>{ <br>   if (!lpLine) <br>      return 0; <br> <br>   return (UINT)lpLine-&gt;m_nHeightInHimetric; <br>} <br> <br> <br>/* Line_SetHeightInHimetric <br> * ------------------------ <br> * <br> *      Set the height of the item in HIMETRIC units. <br> */ <br>void Line_SetHeightInHimetric(LPLINE lpLine, int nHeight) <br>{ <br>   if (!lpLine) <br>      return; <br> <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         TextLine_SetHeightInHimetric((LPTEXTLINE)lpLine, nHeight); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_SetHeightInHimetric((LPCONTAINERLINE)lpLine, <br>               nHeight); <br>         break; <br>#endif <br> <br>   } <br>} <br> <br> <br>/* Line_Delete <br> * ----------- <br> * <br> *      Delete the Line structure <br> */ <br>void Line_Delete(LPLINE lpLine) <br>{ <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         TextLine_Delete((LPTEXTLINE)lpLine); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         ContainerLine_Delete((LPCONTAINERLINE)lpLine); <br>         break; <br>#endif <br> <br>      default: <br>         break;      // unknown line type <br>   } <br>} <br> <br> <br>/* Line_CopyToDoc <br> * -------------- <br> * <br> *      Copy a line to another Document (usually ClipboardDoc) <br> */ <br>BOOL Line_CopyToDoc(LPLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex) <br>{ <br>   switch (lpSrcLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         return TextLine_CopyToDoc((LPTEXTLINE)lpSrcLine,lpDestDoc,nIndex); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         return ContainerLine_CopyToDoc( <br>               (LPCONTAINERLINE)lpSrcLine, <br>               lpDestDoc, <br>               nIndex <br>         ); <br>         break; <br>#endif <br> <br>      default: <br>         return FALSE;       // unknown line type <br>   } <br>} <br> <br> <br>/* Line_SaveToStg <br> * -------------- <br> * <br> *      Save a single line object to a storage <br> * <br> *      Return TRUE if successful, FALSE otherwise <br> */ <br>BOOL Line_SaveToStg(LPLINE lpLine, UINT uFormat, LPSTORAGE lpSrcStg, LPSTORAGE lpDestStg, LPSTREAM lpLLStm, BOOL fRemember) <br>{ <br>   LINERECORD_ONDISK lineRecord; <br>   ULONG nWritten; <br>   HRESULT hrErr; <br>   BOOL fStatus; <br>   LARGE_INTEGER dlibSavePos; <br>   LARGE_INTEGER dlibZeroOffset; <br>   LISet32( dlibZeroOffset, 0 ); <br> <br>   /* save seek position before line record is written in case of error */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Seek( <br>         lpLLStm, <br>         dlibZeroOffset, <br>         STREAM_SEEK_CUR, <br>         (ULARGE_INTEGER FAR*)&amp;dlibSavePos <br>   ); <br>   if (hrErr != NOERROR) return FALSE; <br> <br>#if defined( OLE_CNTR ) <br>   if (lpLine-&gt;m_lineType == CONTAINERLINETYPE) { <br>      /* NOTE: asking an OLE object to save may cause the <br>      **    object to send an OnViewChange notification if there are any <br>      **    outstanding changes to the object. this is particularly true <br>      **    for objects with coarse update granularity like OLE 1.0 <br>      **    objects. if an OnViewChange notification is received then the <br>      **    object's presentation cache will be updated BEFORE it is <br>      **    saved. It is important that the extents stored as part of <br>      **    the ContainerLine/Line record associated with the OLE object <br>      **    are updated before the Line data is saved to the storage. it <br>      **    is important that this extent information matches the data <br>      **    saved with the OLE object. the Line extent information is <br>      **    updated in the IAdviseSink::OnViewChange method implementation. <br>      */ <br>      // only save the OLE object if format is compatible. <br>      if (uFormat != ((LPCONTAINERAPP)g_lpApp)-&gt;m_cfCntrOutl) <br>         goto error; <br> <br>      fStatus = ContainerLine_SaveOleObjectToStg( <br>            (LPCONTAINERLINE)lpLine, <br>            lpSrcStg, <br>            lpDestStg, <br>            fRemember <br>      ); <br>      if (! fStatus) goto error; <br>   } <br>#endif <br> <br>   // compilers should handle alignment correctly <br>   lineRecord.m_lineType = (USHORT)lpLine-&gt;m_lineType; <br>   lineRecord.m_nTabLevel = (USHORT)lpLine-&gt;m_nTabLevel; <br>   lineRecord.m_nTabWidthInHimetric = (USHORT)lpLine-&gt;m_nTabWidthInHimetric; <br>   lineRecord.m_nWidthInHimetric = (USHORT)lpLine-&gt;m_nWidthInHimetric; <br>   lineRecord.m_nHeightInHimetric = (USHORT)lpLine-&gt;m_nHeightInHimetric; <br>   lineRecord.m_reserved = 0; <br> <br>   /* write line record header */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>         lpLLStm, <br>         (LPVOID)&amp;lineRecord, <br>         sizeof(lineRecord), <br>         &amp;nWritten <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Write Line header returned", hrErr); <br>      goto error; <br>    } <br> <br>   switch (lpLine-&gt;m_lineType) { <br>      case TEXTLINETYPE: <br>         fStatus = TextLine_SaveToStm((LPTEXTLINE)lpLine, lpLLStm); <br>         if (! fStatus) goto error; <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         fStatus=ContainerLine_SaveToStm((LPCONTAINERLINE)lpLine,lpLLStm); <br>         if (! fStatus) goto error; <br>         break; <br>#endif <br> <br>      default: <br>         goto error;       // unknown line type <br>   } <br> <br>   return TRUE; <br> <br>error: <br> <br>   /* retore seek position prior to writing Line record */ <br>   lpLLStm-&gt;lpVtbl-&gt;Seek( <br>         lpLLStm, <br>         dlibSavePos, <br>         STREAM_SEEK_SET, <br>         NULL <br>   ); <br> <br>   return FALSE; <br>} <br> <br> <br>/* Line_LoadFromStg <br> * ---------------- <br> * <br> *      Load a single line object from storage <br> */ <br>LPLINE Line_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc) <br>{ <br>   LINERECORD_ONDISK lineRecord; <br>   LPLINE lpLine = NULL; <br>   ULONG nRead; <br>   HRESULT hrErr; <br> <br>   /* read line record header */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>         lpLLStm, <br>         (LPVOID)&amp;lineRecord, <br>         sizeof(lineRecord), <br>         &amp;nRead <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Read Line header returned", hrErr); <br>      return NULL; <br>    } <br> <br>   switch ((LINETYPE)lineRecord.m_lineType) { <br>      case TEXTLINETYPE: <br>         lpLine = TextLine_LoadFromStg(lpSrcStg, lpLLStm, lpDestDoc); <br>         break; <br> <br>#if defined( OLE_CNTR ) <br>      case CONTAINERLINETYPE: <br>         lpLine = ContainerLine_LoadFromStg(lpSrcStg, lpLLStm, lpDestDoc); <br>         break; <br>#endif <br> <br>      default: <br>         return NULL;        // unknown line type <br>   } <br> <br>   lpLine-&gt;m_lineType = (LINETYPE) lineRecord.m_lineType; <br>   lpLine-&gt;m_nTabLevel = (UINT) lineRecord.m_nTabLevel; <br>   lpLine-&gt;m_nTabWidthInHimetric = (UINT) lineRecord.m_nTabWidthInHimetric; <br>   lpLine-&gt;m_nWidthInHimetric = (UINT) lineRecord.m_nWidthInHimetric; <br>   lpLine-&gt;m_nHeightInHimetric = (UINT) lineRecord.m_nHeightInHimetric; <br> <br>   return lpLine; <br>} <br> <br> <br>/* Line_IsSelected <br> * --------------- <br> * <br> *      Return the selection state of the line <br> */ <br>BOOL Line_IsSelected(LPLINE lpLine) <br>{ <br>   if (!lpLine) <br>      return FALSE; <br> <br>   return lpLine-&gt;m_fSelected; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
