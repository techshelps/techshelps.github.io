<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CNTROUTL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context277"></a>CNTROUTL.H</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2.0 Container Sample Code <br>** <br>**    cntroutl.h <br>** <br>**    This file contains file contains data structure defintions, <br>**    function prototypes, constants, etc. used by the OLE 2.0 container <br>**    app version of the Outline series of sample applications: <br>**          Outline -- base version of the app (without OLE functionality) <br>**          SvrOutl -- OLE 2.0 Server sample app <br>**          CntrOutl -- OLE 2.0 Containter (Container) sample app <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#if !defined( _CNTROUTL_H_ ) <br>#define _CNTROUTL_H_ <br> <br>#ifndef RC_INVOKED <br>#pragma message ("INCLUDING CNTROUTL.H from " __FILE__) <br>#endif  /* RC_INVOKED */ <br> <br>#include "oleoutl.h" <br>#include "cntrrc.h" <br>#include "ansiapi.h" <br> <br>// REVIEW: should load from string resource <br>#define DEFOBJNAMEPREFIX    "Obj"   // Prefix for auto-generated stg names <br>#define DEFOBJWIDTH         5000    // default size for embedded obj. <br>#define DEFOBJHEIGHT        5000    // default size for embedded obj. <br>#define UNKNOWN_OLEOBJ_TYPE "Unknown OLE Object Type" <br>#define szOLEOBJECT OLESTR("Object") <br>#define szOLELINK   OLESTR("Link") <br> <br>#ifdef TEST32 <br>#define CONTAINERDOCFORMAT  OLESTR("CntrOu32")      // CF_CntrOutl format name <br>#else <br>#define CONTAINERDOCFORMAT  OLESTR("CntrOutl")      // CF_CntrOutl format name <br>#endif //TEST32 <br> <br>/* Forward definition of types */ <br>typedef struct tagCONTAINERDOC FAR* LPCONTAINERDOC; <br>typedef struct tagCONTAINERLINE FAR* LPCONTAINERLINE; <br> <br> <br>// Flags to specify type of OLECREATE???FROMDATA call required <br>typedef enum tagOLECREATEFROMDATATYPE { <br>   OLECREATEFROMDATA_LINK    = 1, <br>   OLECREATEFROMDATA_OBJECT  = 2, <br>   OLECREATEFROMDATA_STATIC  = 3 <br>} OLECREATEFROMDATATYPE; <br> <br>/************************************************************************* <br>** class CONTAINERLINE : LINE <br>**    The class CONTAINERLINE is a concrete subclass of the abstract base <br>**    class LINE. The CONTAINERLINE maintains all information about the <br>**    place within the CONTAINERDOC that an OLE object is embedded. This <br>**    object implements the following OLE 2.0 interfaces: <br>**          IOleClientSite <br>**          IAdviseSink <br>**    In the CntrOutl client app either CONTAINERLINE objects or TEXTLINE <br>**    objects can be created. The CONTAINERLINE class inherits all fields <br>**    from the LINE class. This inheritance is achieved by including a <br>**    member variable of type LINE as the first field in the CONTAINERLINE <br>**    structure. Thus a pointer to a CONTAINERLINE object can be cast to be <br>**    a pointer to a LINE object. <br>**    Each CONTAINERLINE object that is created in added to the LINELIST of <br>**    the associated OUTLINEDOC document. <br>*************************************************************************/ <br> <br>typedef struct tagCONTAINERLINE { <br>   LINE            m_Line;         // ContainerLine inherits fields of Line <br>   ULONG           m_cRef;         // total ref count for line <br>   OLECHAR         m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg <br>   BOOL            m_fObjWinOpen;  // is obj window open? if so, shade obj. <br>   BOOL            m_fMonikerAssigned; // has a moniker been assigned to obj <br>   DWORD           m_dwDrawAspect; // current display aspect for obj <br>                           //      (either DVASPECT_CONTENT or <br>                           //      DVASPECT_ICON) <br>   BOOL            m_fGuardObj;    // Guard against re-entrancy while <br>                           //  loading or creating an OLE object <br>   BOOL            m_fDoGetExtent; // indicates extents may have changed <br>   BOOL            m_fDoSetExtent; // obj was resized when not running <br>                           //  IOO::SetExtent needed on next run <br>   SIZEL           m_sizeInHimetric; // extents of obj in himetric units <br>   LPSTORAGE       m_lpStg;        // open pstg when obj is loaded <br>   LPCONTAINERDOC  m_lpDoc;        // ptr to associated client doc <br>   LPOLEOBJECT     m_lpOleObj;     // ptr to IOleObject* when obj is loaded <br>   LPVIEWOBJECT2   m_lpViewObj2;   // ptr to IViewObject2* when obj is loaded <br>   LPPERSISTSTORAGE m_lpPersistStg;// ptr to IPersistStorage* when obj loaded <br>   LPOLELINK       m_lpOleLink;    // ptr to IOleLink* if link is loaded <br>   DWORD           m_dwLinkType;   // is it a linked object? <br>                           //   0 -- NOT a link <br>                           //   OLEUPDATE_ALWAYS (1) -- auto link <br>                           //   OLEUPDATE_ONCALL (3) -- man. link <br>   BOOL            m_fLinkUnavailable;     // is the link unavailable? <br>   LPOLESTR        m_lpszShortType;// short type name of OLE object needed <br>                           //  to make the Edit.Object.Verb menu <br>   int             m_nHorizScrollShift;    // horiz scroll shift required <br>                           // for object's inplace window. <br>                           // (note: this is ICNTROTL specific) <br> <br>#if defined( INPLACE_CNTR ) <br>   BOOL            m_fIpActive;    // is object in-place active (undo valid) <br>   BOOL            m_fUIActive;    // is object UIActive <br>   BOOL            m_fIpVisible;   // is object's in-place window visible <br>   BOOL            m_fInsideOutObj;// is obj inside-out (visible when loaded) <br>   LPOLEINPLACEOBJECT m_lpOleIPObj; // IOleInPlaceObject* of in-place obj <br>   BOOL            m_fIpChangesUndoable;   // can in-place object do undo <br>   BOOL            m_fIpServerRunning; // is in-place server running <br>   HWND            m_hWndIpObject; <br> <br>   struct COleInPlaceSiteImpl { <br>      IOleInPlaceSiteVtbl FAR* lpVtbl; <br>      LPCONTAINERLINE         lpContainerLine; <br>      int                     cRef;   // interface specific ref count. <br>   } m_OleInPlaceSite; <br>#endif  // INPLACE_CNTR <br> <br>   struct CUnknownImpl { <br>      IUnknownVtbl FAR*       lpVtbl; <br>      LPCONTAINERLINE         lpContainerLine; <br>      int                     cRef;   // interface specific ref count. <br>   } m_Unknown; <br> <br>   struct COleClientSiteImpl { <br>      IOleClientSiteVtbl FAR* lpVtbl; <br>      LPCONTAINERLINE         lpContainerLine; <br>      int                 cRef;   // interface specific ref count. <br>   } m_OleClientSite; <br> <br>   struct CAdviseSinkImpl { <br>      IAdviseSinkVtbl FAR*    lpVtbl; <br>      LPCONTAINERLINE         lpContainerLine; <br>      int                     cRef;   // interface specific ref count. <br>   } m_AdviseSink; <br> <br>} CONTAINERLINE; <br> <br> <br>/* ContainerLine methods (functions) */ <br>void ContainerLine_Init(LPCONTAINERLINE lpContainerLine, int nTab, HDC hDC); <br>BOOL ContainerLine_SetupOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict <br>); <br>LPCONTAINERLINE ContainerLine_Create( <br>      DWORD                   dwOleCreateType, <br>      HDC                     hDC, <br>      UINT                    nTab, <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCLSID                 lpclsid, <br>      LPOLESTR                lpszFileName, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPOLESTR                lpszStgName <br>); <br>LPCONTAINERLINE ContainerLine_CreateFromData( <br>      HDC                     hDC, <br>      UINT                    nTab, <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      DWORD                   dwCreateType, <br>      CLIPFORMAT              cfFormat, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPOLESTR                lpszStgName <br>); <br>ULONG ContainerLine_AddRef(LPCONTAINERLINE lpContainerLine); <br>ULONG ContainerLine_Release(LPCONTAINERLINE lpContainerLine); <br>HRESULT ContainerLine_QueryInterface( <br>      LPCONTAINERLINE         lpContainerLine, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpUnk <br>); <br>BOOL ContainerLine_CloseOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwSaveOption <br>); <br>void ContainerLine_UnloadOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwSaveOption <br>); <br>void ContainerLine_Delete(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_Destroy(LPCONTAINERLINE lpContainerLine); <br>BOOL ContainerLine_CopyToDoc( <br>      LPCONTAINERLINE         lpSrcLine, <br>      LPOUTLINEDOC            lpDestDoc, <br>      int                     nIndex <br>); <br>BOOL ContainerLine_LoadOleObject(LPCONTAINERLINE lpContainerLine); <br>BOOL ContainerLine_UpdateExtent( <br>      LPCONTAINERLINE     lpContainerLine, <br>      LPSIZEL             lpsizelHim <br>); <br>BOOL ContainerLine_DoVerb( <br>      LPCONTAINERLINE lpContainerLine, <br>      LONG iVerb, <br>      LPMSG lpMsg, <br>      BOOL fMessage, <br>      BOOL fAction <br>); <br>LPUNKNOWN ContainerLine_GetOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      REFIID                  riid <br>); <br>HRESULT ContainerLine_RunOleObject(LPCONTAINERLINE lpContainerLine); <br>BOOL ContainerLine_ProcessOleRunError( <br>      LPCONTAINERLINE         lpContainerLine, <br>      HRESULT                 hrErr, <br>      BOOL                    fAction, <br>      BOOL                    fMenuInvoked <br>); <br>HRESULT ContainerLine_ReCreateLinkBecauseClassDiff( <br>      LPCONTAINERLINE lpContainerLine <br>); <br>BOOL ContainerLine_IsOleLink(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_BindLinkIfLinkSrcIsRunning(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_Draw( <br>      LPCONTAINERLINE         lpContainerLine, <br>      HDC                     hDC, <br>      LPRECT                  lpRect, <br>      LPRECT                  lpRectWBounds, <br>      BOOL                    fHighlight <br> <br>); <br>void ContainerLine_DrawSelHilight( <br>      LPCONTAINERLINE lpContainerLine, <br>      HDC             hDC, <br>      LPRECT          lpRect, <br>      UINT            itemAction, <br>      UINT            itemState <br>); <br>BOOL ContainerLine_Edit(LPCONTAINERLINE lpContainerLine,HWND hWndDoc,HDC hDC); <br>void ContainerLine_SetHeightInHimetric(LPCONTAINERLINE lpContainerLine, int nHeight); <br>void ContainerLine_SetLineHeightFromObjectExtent( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSIZEL                 lpsizelOleObject <br>); <br>BOOL ContainerLine_SaveToStm( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSTREAM                lpLLStm <br>); <br>BOOL ContainerLine_SaveOleObjectToStg( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTORAGE               lpDestStg, <br>      BOOL                    fRemember <br>); <br>LPLINE ContainerLine_LoadFromStg( <br>      LPSTORAGE               lpSrcStg, <br>      LPSTREAM                lpLLStm, <br>      LPOUTLINEDOC            lpDestDoc <br>); <br>LPMONIKER ContainerLine_GetRelMoniker( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwAssign <br>); <br>LPMONIKER ContainerLine_GetFullMoniker( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwAssign <br>); <br>int ContainerLine_GetTextLen(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_GetTextData(LPCONTAINERLINE lpContainerLine,LPOLESTR lpszBuf); <br>BOOL ContainerLine_GetOutlineData( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPTEXTLINE              lpBuf <br>); <br>void ContainerLine_GetOleObjectRectInPixels( <br>      LPCONTAINERLINE lpContainerLine, <br>      LPRECT lprc <br>); <br>void ContainerLine_GetPosRect( <br>      LPCONTAINERLINE     lpContainerLine, <br>      LPRECT              lprcPosRect <br>); <br>void ContainerLine_GetOleObjectSizeInHimetric( <br>      LPCONTAINERLINE lpContainerLine, <br>      LPSIZEL lpsizel <br>); <br> <br>#if defined( INPLACE_CNTR ) <br>void ContainerLine_UIDeactivate(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_InPlaceDeactivate(LPCONTAINERLINE lpContainerLine); <br>void ContainerLine_UpdateInPlaceObjectRects( <br>   LPCONTAINERLINE lpContainerLine, <br>   LPRECT          lprcClipRect <br>); <br>void ContainerLine_ContextSensitiveHelp( <br>      LPCONTAINERLINE lpContainerLine, <br>      BOOL            fEnterMode <br>); <br>void ContainerLine_ForwardPaletteChangedMsg( <br>      LPCONTAINERLINE lpContainerLine, <br>      HWND             hwndPalChg <br>); <br>void ContainerDoc_ContextSensitiveHelp( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      BOOL            fEnterMode, <br>      BOOL            fInitiatedByObj <br>); <br>void ContainerDoc_ForwardPaletteChangedMsg( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      HWND            hwndPalChg <br>); <br>#endif  // INPLACE_CNTR <br> <br>/* ContainerLine::IUnknown methods (functions) */ <br>STDMETHODIMP CntrLine_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrLine_Unk_AddRef(LPUNKNOWN lpThis); <br>STDMETHODIMP_(ULONG) CntrLine_Unk_Release(LPUNKNOWN lpThis); <br> <br>/* ContainerLine::IOleClientSite methods (functions) */ <br>STDMETHODIMP CntrLine_CliSite_QueryInterface( <br>      LPOLECLIENTSITE     lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrLine_CliSite_AddRef(LPOLECLIENTSITE lpThis); <br>STDMETHODIMP_(ULONG) CntrLine_CliSite_Release(LPOLECLIENTSITE lpThis); <br>STDMETHODIMP CntrLine_CliSite_SaveObject(LPOLECLIENTSITE lpThis); <br>STDMETHODIMP CntrLine_CliSite_GetMoniker( <br>      LPOLECLIENTSITE     lpThis, <br>      DWORD               dwAssign, <br>      DWORD               dwWhichMoniker, <br>      LPMONIKER FAR*      lplpmk <br>); <br>STDMETHODIMP CntrLine_CliSite_GetContainer( <br>      LPOLECLIENTSITE     lpThis, <br>      LPOLECONTAINER FAR* lplpContainer <br>); <br>STDMETHODIMP CntrLine_CliSite_ShowObject(LPOLECLIENTSITE lpThis); <br>STDMETHODIMP CntrLine_CliSite_OnShowWindow(LPOLECLIENTSITE lpThis,BOOL fShow); <br>STDMETHODIMP CntrLine_CliSite_RequestNewObjectLayout(LPOLECLIENTSITE lpThis); <br> <br>/* ContainerLine::IAdviseSink methods (functions) */ <br>STDMETHODIMP CntrLine_AdvSink_QueryInterface( <br>      LPADVISESINK        lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrLine_AdvSink_AddRef(LPADVISESINK lpThis); <br>STDMETHODIMP_(ULONG) CntrLine_AdvSink_Release (LPADVISESINK lpThis); <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnDataChange( <br>      LPADVISESINK        lpThis, <br>      FORMATETC FAR*      lpFormatetc, <br>      STGMEDIUM FAR*      lpStgmed <br>); <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnViewChange( <br>      LPADVISESINK        lpThis, <br>      DWORD               aspects, <br>      LONG                lindex <br>); <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnRename( <br>      LPADVISESINK        lpThis, <br>      LPMONIKER           lpmk <br>); <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnSave(LPADVISESINK lpThis); <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnClose(LPADVISESINK lpThis); <br> <br>#if defined( INPLACE_CNTR ) <br>/* ContainerLine::IOleInPlaceSite methods (functions) */ <br> <br>STDMETHODIMP CntrLine_IPSite_QueryInterface( <br>      LPOLEINPLACESITE    lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrLine_IPSite_AddRef(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP_(ULONG) CntrLine_IPSite_Release(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_GetWindow( <br>      LPOLEINPLACESITE    lpThis, <br>      HWND FAR*           lphwnd <br>); <br>STDMETHODIMP CntrLine_IPSite_ContextSensitiveHelp( <br>   LPOLEINPLACESITE    lpThis, <br>   BOOL                fEnterMode <br>); <br>STDMETHODIMP CntrLine_IPSite_CanInPlaceActivate(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_OnInPlaceActivate(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_OnUIActivate (LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_GetWindowContext( <br>   LPOLEINPLACESITE            lpThis, <br>   LPOLEINPLACEFRAME FAR*      lplpFrame, <br>   LPOLEINPLACEUIWINDOW FAR*   lplpDoc, <br>   LPRECT                      lprcPosRect, <br>   LPRECT                      lprcClipRect, <br>   LPOLEINPLACEFRAMEINFO       lpFrameInfo <br>); <br>STDMETHODIMP CntrLine_IPSite_Scroll( <br>   LPOLEINPLACESITE    lpThis, <br>   SIZE                scrollExtent <br>); <br>STDMETHODIMP CntrLine_IPSite_OnUIDeactivate( <br>   LPOLEINPLACESITE    lpThis, <br>   BOOL                fUndoable <br>); <br>STDMETHODIMP CntrLine_IPSite_OnInPlaceDeactivate(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_DiscardUndoState(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_DeactivateAndUndo(LPOLEINPLACESITE lpThis); <br>STDMETHODIMP CntrLine_IPSite_OnPosRectChange( <br>   LPOLEINPLACESITE    lpThis, <br>   LPCRECT             lprcPosRect <br>); <br>#endif  // INPLACE_CNTR <br> <br> <br>/* struct definition for persistant data storage of ContainerLine */ <br> <br>#pragma pack(push, 2) <br>typedef struct tagCONTAINERLINERECORD_ONDISK <br>{ <br>      OLECHAR m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg <br>      USHORT  m_fMonikerAssigned;          // has a moniker been assigned to obj <br>      DWORD   m_dwDrawAspect;              // current display aspect for obj <br>                                                                               //     (either DVASPECT_CONTENT or <br>                                                                               //     DVASPECT_ICON) <br>      SIZEL   m_sizeInHimetric;            // extents of obj in himetric units <br>      DWORD   m_dwLinkType;                // is it a linked object? <br>                                                                               //  0 -- NOT a link <br>                                                                               //  OLEUPDATE_ALWAYS (1) -- auto link <br>                                                                               //  OLEUPDATE_ONCALL (3) -- man. link <br>      USHORT  m_fDoSetExtent;              // obj was resized when not running <br>                                                                               //  IOO::SetExtent needed on next run <br>} CONTAINERLINERECORD_ONDISK, FAR* LPCONTAINERLINERECORD_ONDISK; <br>#pragma pack(pop) <br> <br>typedef struct tagCONTAINERLINERECORD { <br>   OLECHAR m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg <br>   BOOL    m_fMonikerAssigned;          // has a moniker been assigned to obj <br>   DWORD   m_dwDrawAspect;              // current display aspect for obj <br>                               //     (either DVASPECT_CONTENT or <br>                               //     DVASPECT_ICON) <br>   SIZEL   m_sizeInHimetric;            // extents of obj in himetric units <br>   DWORD   m_dwLinkType;                // is it a linked object? <br>                               //  0 -- NOT a link <br>                               //  OLEUPDATE_ALWAYS (1) -- auto link <br>                               //  OLEUPDATE_ONCALL (3) -- man. link <br>   BOOL    m_fDoSetExtent;              // obj was resized when not running <br>                               //  IOO::SetExtent needed on next run <br>} CONTAINERLINERECORD, FAR* LPCONTAINERLINERECORD; <br> <br> <br>/************************************************************************* <br>** class CONTAINERDOC : OUTLINEDOC <br>**    CONTAINERDOC is an extention to the base OUTLINEDOC object (structure) <br>**    that adds OLE 2.0 Container functionality. There is one instance of <br>**    CONTAINERDOC object created per document open in the app. The SDI <br>**    version of the app supports one CONTAINERDOC at a time. The MDI <br>**    version of the app can manage multiple documents at one time. <br>**    The CONTAINERDOC class inherits all fields <br>**    from the OUTLINEDOC class. This inheritance is achieved by including a <br>**    member variable of type OUTLINEDOC as the first field in the <br>**    CONTAINERDOC structure. Thus a pointer to a CONTAINERDOC object <br>**    can be cast to be a pointer to a OUTLINEDOC object. <br>*************************************************************************/ <br> <br>typedef struct tagCONTAINERDOC { <br>   OLEDOC      m_OleDoc;       // ContainerDoc inherits all fields of OleDoc <br>   ULONG       m_nNextObjNo;   // next available obj no. for stg name <br>   LPSTORAGE   m_lpNewStg;     // holds new pStg when SaveAs is pending <br>   BOOL        m_fEmbeddedObjectAvail; // is single OLE embed copied to doc <br>   CLSID       m_clsidOleObjCopied;    // if obj copied, CLSID of obj <br>   DWORD       m_dwAspectOleObjCopied; // if obj copied, draw aspect of obj <br>   LPCONTAINERLINE m_lpSrcContainerLine;  // src line if doc created for copy <br>   BOOL        m_fShowObject;          // show object flag <br> <br>#if defined( INPLACE_CNTR ) <br>   LPCONTAINERLINE m_lpLastIpActiveLine;   // last in-place active line <br>   LPCONTAINERLINE m_lpLastUIActiveLine;   // last UIActive line <br>   HWND            m_hWndUIActiveObj;      // HWND of UIActive obj. <br>   BOOL            m_fAddMyUI;             // if adding tools/menu postponed <br>   int             m_cIPActiveObjects; <br> <br>#if defined( INPLACE_CNTRSVR ) <br>   LPOLEINPLACEFRAME m_lpTopIPFrame;       // ptr to Top In-place frame. <br>   LPOLEINPLACEFRAME m_lpTopIPDoc;         // ptr to Top In-place Doc window. <br>   HMENU             m_hSharedMenu;        // combined obj/cntr menu <br>                                 // NULL if we are top container <br>   HOLEMENU        m_hOleMenu;             // returned by OleCreateMenuDesc. <br>                                 // NULL if we are top container <br>#endif  // INPLACE_CNTRSVR <br>#endif  // INPLACE_CNTR <br> <br>   struct CDocOleUILinkContainerImpl { <br>      IOleUILinkContainerVtbl FAR*  lpVtbl; <br>      LPCONTAINERDOC                lpContainerDoc; <br>      int                           cRef;   // interface specific ref count. <br>   } m_OleUILinkContainer; <br> <br>} CONTAINERDOC; <br> <br>/* ContainerDoc methods (functions) */ <br>BOOL ContainerDoc_Init(LPCONTAINERDOC lpContainerDoc, BOOL fDataTransferDoc); <br>LPCONTAINERLINE ContainerDoc_GetNextLink( <br>      LPCONTAINERDOC lpContainerDoc, <br>      LPCONTAINERLINE lpContainerLine <br>); <br>void ContainerDoc_UpdateLinks(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_SetShowObjectFlag(LPCONTAINERDOC lpContainerDoc, BOOL fShow); <br>BOOL ContainerDoc_GetShowObjectFlag(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_InsertOleObjectCommand(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_EditLinksCommand(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_PasteLinkCommand(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_ConvertCommand( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      BOOL                fServerNotRegistered <br>); <br>BOOL ContainerDoc_PasteFormatFromData( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      CLIPFORMAT              cfFormat, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLocalDataObj, <br>      BOOL                    fLink, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPSIZEL                 lpSizelInSrc <br>); <br>int ContainerDoc_PasteCntrOutlData( <br>      LPCONTAINERDOC          lpDestContainerDoc, <br>      LPSTORAGE               lpSrcStg, <br>      int                     nStartIndex <br>); <br>BOOL ContainerDoc_QueryPasteFromData( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLink <br>); <br>int ContainerDoc_PasteOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      DWORD                   dwCreateType, <br>      CLIPFORMAT              cfFormat, <br>      int                     nIndex, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPSIZEL                 lpSizelInSrc <br>); <br>BOOL ContainerDoc_CloseAllOleObjects( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      DWORD                   dwSaveOption <br>); <br>void ContainerDoc_UnloadAllOleObjectsOfClass( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      REFCLSID            rClsid, <br>      DWORD               dwSaveOption <br>); <br>void ContainerDoc_InformAllOleObjectsDocRenamed( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPMONIKER               lpmkDoc <br>); <br>void ContainerDoc_UpdateExtentOfAllOleObjects(LPCONTAINERDOC lpContainerDoc); <br>BOOL ContainerDoc_SaveToFile( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCOLESTR               lpszFileName, <br>      UINT                    uFormat, <br>      BOOL                    fRemember <br>); <br>void ContainerDoc_ContainerLineDoVerbCommand( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LONG                    iVerb <br>); <br>void ContainerDoc_GetNextStgName( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszStgName, <br>      int                     nLen <br>); <br>BOOL ContainerDoc_IsStgNameUsed( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszStgName <br>); <br>LPSTORAGE ContainerDoc_GetStg(LPCONTAINERDOC lpContainerDoc); <br>HRESULT ContainerDoc_GetObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszItem, <br>      DWORD                   dwSpeedNeeded, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObject <br>); <br>HRESULT ContainerDoc_GetObjectStorage( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPOLESTR                lpszItem, <br>      LPSTORAGE FAR*          lplpStg <br>); <br>HRESULT ContainerDoc_IsRunning(LPCONTAINERDOC   lpContainerDoc, LPOLESTR lpszItem); <br>LPUNKNOWN ContainerDoc_GetSingleOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      REFIID                  riid, <br>      LPCONTAINERLINE FAR*    lplpContainerLine <br>); <br>BOOL ContainerDoc_IsSelAnOleObject( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      REFIID                  riid, <br>      LPUNKNOWN FAR*          lplpvObj, <br>      int FAR*                lpnIndex, <br>      LPCONTAINERLINE FAR*    lplpContainerLine <br>); <br>HRESULT ContainerDoc_GetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>); <br>HRESULT ContainerDoc_GetDataHere ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>); <br>HRESULT ContainerDoc_QueryGetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc <br>); <br>HRESULT ContainerDoc_SetData ( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpmedium, <br>      BOOL                    fRelease <br>); <br>HRESULT ContainerDoc_EnumFormatEtc( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>); <br>BOOL ContainerDoc_SetupDocGetFmts( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCONTAINERLINE         lpContainerLine <br>); <br> <br>#if defined( INPLACE_CNTR ) <br> <br>void ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded( <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCONTAINERLINE         lpNextActiveLine <br>); <br>BOOL ContainerDoc_IsUIDeactivateNeeded( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      POINT           pt <br>); <br>HWND ContainerDoc_GetUIActiveWindow(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_UpdateInPlaceObjectRects(LPCONTAINERDOC lpContainerDoc, int nIndex); <br>void ContainerDoc_GetClipRect( <br>      LPCONTAINERDOC      lpContainerDoc, <br>      LPRECT              lprcClipRect <br>); <br>void ContainerDoc_FrameWindowResized(LPCONTAINERDOC lpContainerDoc); <br>LPOLEINPLACEFRAME ContainerDoc_GetTopInPlaceFrame( <br>      LPCONTAINERDOC      lpContainerDoc <br>); <br>void ContainerDoc_GetSharedMenuHandles( <br>      LPCONTAINERDOC  lpContainerDoc, <br>      HMENU FAR*      lphSharedMenu, <br>      HOLEMENU FAR*   lphOleMenu <br>); <br>void ContainerDoc_RemoveFrameLevelTools(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_AddFrameLevelUI(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_AddFrameLevelTools(LPCONTAINERDOC lpContainerDoc); <br> <br>#if defined( INPLACE_CNTRSVR ) || defined( INPLACE_MDICNTR ) <br> <br>LPOLEINPLACEUIWINDOW ContainerDoc_GetTopInPlaceDoc( <br>      LPCONTAINERDOC      lpContainerDoc <br>); <br>void ContainerDoc_RemoveDocLevelTools(LPCONTAINERDOC lpContainerDoc); <br>void ContainerDoc_AddDocLevelTools(LPCONTAINERDOC lpContainerDoc); <br> <br>#endif  // INPLACE_CNTRSVR || INPLACE_MDICNTR <br>#endif  // INPLACE_CNTR <br> <br>/* ContainerDoc::IOleUILinkContainer methods (functions) */ <br>STDMETHODIMP CntrDoc_LinkCont_QueryInterface( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrDoc_LinkCont_AddRef(LPOLEUILINKCONTAINER lpThis); <br>STDMETHODIMP_(ULONG) CntrDoc_LinkCont_Release(LPOLEUILINKCONTAINER lpThis); <br>STDMETHODIMP_(DWORD) CntrDoc_LinkCont_GetNextLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>); <br>STDMETHODIMP CntrDoc_LinkCont_SetLinkUpdateOptions( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      DWORD                   dwUpdateOpt <br>); <br>STDMETHODIMP CntrDoc_LinkCont_GetLinkUpdateOptions( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      DWORD FAR*              dwUpdateOpt <br>); <br> <br>STDMETHODIMP CntrDoc_LinkCont_SetLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      LPSTR                lpszDisplayName, <br>      ULONG                   clenFileName, <br>      ULONG FAR*              lpchEaten, <br>      BOOL                    fValidateSource <br>); <br>STDMETHODIMP CntrDoc_LinkCont_GetLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, <br>      LPSTR FAR*           lplpszDisplayName, <br>      ULONG FAR*              lplenFileName, <br>      LPSTR FAR*           lplpszFullLinkType, <br>      LPSTR FAR*           lplpszShortLinkType, <br>      BOOL FAR*               lpfSourceAvailable, <br>      BOOL FAR*               lpfIsSelected <br>); <br>STDMETHODIMP CntrDoc_LinkCont_OpenLinkSource( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>); <br>STDMETHODIMP CntrDoc_LinkCont_UpdateLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink, </code></pre>
<p>
</p>
<pre><code>BOOL                    fErrorMessage, <br>      BOOL                    fErrorAction <br>); <br>STDMETHODIMP CntrDoc_LinkCont_CancelLink( <br>      LPOLEUILINKCONTAINER    lpThis, <br>      DWORD                   dwLink <br>); <br> <br> <br> <br>/************************************************************************* <br>** class CONTAINERAPP : OLEAPP <br>**    CONTAINERAPP is an extention to the base OLEAPP object (structure) <br>**    that adds special Container functionality. There is one instance of <br>**    CONTAINERApp object created per running application instance. This <br>**    object holds many fields that could otherwise be organized as <br>**    global variables. The CONTAINERAPP class inherits all fields <br>**    from the OLEAPP class. This inheritance is achieved by including a <br>**    member variable of type OLEAPP as the first field in the CONTAINERAPP <br>**    structure. OLEAPP inherits from OUTLINEAPP. This inheritance is <br>**    achieved in the same manner. Thus a pointer to a CONTAINERAPP object <br>**    can be cast to be a pointer to an OLEAPP or an OUTLINEAPP object <br>*************************************************************************/ <br> <br>/* Forward definition of types */ <br>typedef struct tagCONTAINERAPP FAR* LPCONTAINERAPP; <br> <br>typedef struct tagCONTAINERAPP { <br>   OLEAPP  m_OleApp;       // ContainerApp inherits all fields of OleApp <br>   UINT    m_cfCntrOutl;   // clipboard format for CntrOutl (client ver) data <br>   int     m_nSingleObjGetFmts; // no. formats avail when single obj copied <br>   FORMATETC m_arrSingleObjGetFmts[MAXNOFMTS]; <br>                              // array of FormatEtc's available via <br>                              // IDataObject::GetData when a single <br>                              // OLE object is copied. <br> <br>#if defined( INPLACE_CNTR ) <br>   HACCEL  m_hAccelIPCntr; // accelerators for container's workspace commands <br>   HMENU   m_hMenuFile;    // handle to File menu of container app <br>   HMENU   m_hMenuView;    // handle to View menu of container app <br>   HMENU   m_hMenuDebug;   // handle to Debug menu of container app <br>   LPOLEINPLACEACTIVEOBJECT m_lpIPActiveObj; // ptr to inplace active OLE obj <br>   HWND    m_hWndUIActiveObj;      // HWND of UIActive obj. <br>   BOOL    m_fPendingUIDeactivate; // should app UIDeactivate on LBUTTONUP <br>   BOOL    m_fMustResizeClientArea;// if client area resize pending <br>                           //  (see Doc_FrameWindowResized) <br>   BOOL    m_fMenuHelpMode;// is F1 pressed in menu, if so give help <br>#ifdef _DEBUG <br>   BOOL    m_fOutSideIn; <br>#endif <br> <br>   struct COleInPlaceFrameImpl { <br>      IOleInPlaceFrameVtbl FAR* lpVtbl; <br>      LPCONTAINERAPP          lpContainerApp; <br>      int                     cRef;   // interface specific ref count. <br>   } m_OleInPlaceFrame; <br> <br>#endif  // INPLACE_CNTR <br> <br>} CONTAINERAPP; <br> <br>/* ContainerApp methods (functions) */ <br>BOOL ContainerApp_InitInstance( <br>      LPCONTAINERAPP          lpContainerApp, <br>      HINSTANCE               hInst, <br>      int                     nCmdShow <br>); <br>BOOL ContainerApp_InitVtbls(LPCONTAINERAPP lpApp); <br> <br>#if defined( INPLACE_CNTR ) <br> <br>/* ContainerApp::IOleInPlaceFrame methods (functions) */ <br> <br>STDMETHODIMP CntrApp_IPFrame_QueryInterface( <br>      LPOLEINPLACEFRAME   lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>); <br>STDMETHODIMP_(ULONG) CntrApp_IPFrame_AddRef(LPOLEINPLACEFRAME lpThis); <br>STDMETHODIMP_(ULONG) CntrApp_IPFrame_Release(LPOLEINPLACEFRAME lpThis); <br>STDMETHODIMP CntrApp_IPFrame_GetWindow( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HWND FAR*           lphwnd <br>); <br>STDMETHODIMP CntrApp_IPFrame_ContextSensitiveHelp( <br>   LPOLEINPLACEFRAME   lpThis, <br>   BOOL                fEnterMode <br>); <br>STDMETHODIMP CntrApp_IPFrame_GetBorder( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPRECT              lprectBorder <br>); <br>STDMETHODIMP CntrApp_IPFrame_RequestBorderSpace( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCBORDERWIDTHS     lpWidths <br>); <br>STDMETHODIMP CntrApp_IPFrame_SetBorderSpace( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCBORDERWIDTHS     lpWidths <br>); <br>STDMETHODIMP CntrApp_IPFrame_SetActiveObject( <br>   LPOLEINPLACEFRAME           lpThis, <br>   LPOLEINPLACEACTIVEOBJECT    lpActiveObject, <br>   LPCOLESTR                   lpszObjName <br>); <br>STDMETHODIMP CntrApp_IPFrame_InsertMenus( <br>   LPOLEINPLACEFRAME       lpThis, <br>   HMENU                   hmenu, <br>   LPOLEMENUGROUPWIDTHS    lpMenuWidths <br>); <br>STDMETHODIMP CntrApp_IPFrame_SetMenu( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HMENU               hmenuShared, <br>   HOLEMENU            holemenu, <br>   HWND                hwndActiveObject <br>); <br>STDMETHODIMP CntrApp_IPFrame_RemoveMenus( <br>   LPOLEINPLACEFRAME   lpThis, <br>   HMENU               hmenu <br>); <br>STDMETHODIMP CntrApp_IPFrame_SetStatusText( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPCOLESTR           lpszStatusText <br>); <br>STDMETHODIMP CntrApp_IPFrame_EnableModeless( <br>   LPOLEINPLACEFRAME   lpThis, <br>   BOOL                fEnable <br>); <br>STDMETHODIMP CntrApp_IPFrame_TranslateAccelerator( <br>   LPOLEINPLACEFRAME   lpThis, <br>   LPMSG               lpmsg, <br>   WORD                wID <br>); <br> <br>#endif  // INPLACE_CNTR <br> <br> <br>#endif // _CNTROUTL_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
