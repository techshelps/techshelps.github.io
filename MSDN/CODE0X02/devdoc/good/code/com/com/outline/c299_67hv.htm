<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SVROUTL.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context313"></a>SVROUTL.H</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2.0 Server Sample Code <br>** <br>**    svroutl.h <br>** <br>**    This file contains file contains data structure defintions, <br>**    function prototypes, constants, etc. used by the OLE 2.0 server <br>**    app version of the Outline series of sample applications: <br>**          Outline -- base version of the app (without OLE functionality) <br>**          SvrOutl -- OLE 2.0 Server sample app <br>**          CntrOutl -- OLE 2.0 Containter sample app <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#if !defined( _SVROUTL_H_ ) <br>#define _SVROUTL_H_ <br> <br>#ifndef RC_INVOKED <br>#pragma message ("INCLUDING SVROUTL.H from " __FILE__) <br>#endif  /* RC_INVOKED */ <br> <br>#include "oleoutl.h" <br>#include "ansiapi.h" <br> <br>/* Defines */ <br> <br>// Enable SVROUTL and ISVROTL to emulate each other (TreatAs aka. ActivateAs) <br>#define SVR_TREATAS     1 <br> <br>// Enable SVROUTL and ISVROTL to convert each other (TreatAs aka. ActivateAs) <br>#define SVR_CONVERTTO   1 <br> <br>// Enable ISVROTL to operate as in inside-out style in-place object <br>#define SVR_INSIDEOUT   1 <br> <br>/* Default name used for container of the embedded object. used if <br>**    container forgets to call IOleObject::SetHostNames <br>*/ <br>// REVIEW: should load from string resource <br>#define DEFCONTAINERNAME    "Unknown Document" <br> <br>/* Default prefix for auto-generated range names. This is used with <br>**    links to unnamed ranges (pseudo objects). <br>*/ <br>// REVIEW: should load from string resource <br>#define DEFRANGENAMEPREFIX  "Range" <br> <br>// Maximum length of strings accepted through IOleObject::SetHostNames <br>//      (note: this is rather arbitrary; a better strategy would be to <br>//             dynamically allocated buffers for these strings.) <br>#define MAXAPPNAME  80 <br>#define MAXCONTAINERNAME    80 <br> <br>// Menu option in embedding mode <br>#define IDM_F_UPDATE    1151 <br> <br>/* Types */ <br> <br>/* Codes for CallBack events */ <br>typedef enum tagOLE_NOTIFICATION { <br>   OLE_ONDATACHANGE,        // 0 <br>   OLE_ONSAVE,              // 1 <br>   OLE_ONRENAME,            // 2 <br>   OLE_ONCLOSE              // 3 <br>} OLE_NOTIFICATION; <br> <br>/* Codes to indicate mode of storage for an object. <br>**    Mode of the storage is modified by the IPersistStorage methods: <br>**      Save, HandsOffStorage, and SaveCompleted. <br>*/ <br>typedef enum tagSTGMODE { <br>   STGMODE_NORMAL      = 0, <br>   STGMODE_NOSCRIBBLE  = 1, <br>   STGMODE_HANDSOFF    = 2 <br>} STGMODE; <br> <br> <br>/* Forward type definitions */ <br>typedef struct tagSERVERAPP FAR* LPSERVERAPP; <br>typedef struct tagSERVERDOC FAR* LPSERVERDOC; <br>typedef struct tagPSEUDOOBJ FAR* LPPSEUDOOBJ; <br> <br>typedef struct tagINPLACEDATA { <br>   OLEMENUGROUPWIDTHS      menuGroupWidths; <br>   HOLEMENU                hOlemenu; <br>   HMENU                   hMenuShared; <br>   LPOLEINPLACESITE        lpSite; <br>   LPOLEINPLACEUIWINDOW    lpDoc; <br>   LPOLEINPLACEFRAME       lpFrame; <br>   OLEINPLACEFRAMEINFO     frameInfo; <br>   HWND                    hWndFrame; <br>   BOOL                    fBorderOn; <br>   RECT                    rcPosRect; <br>   RECT                    rcClipRect; <br>} INPLACEDATA, FAR* LPINPLACEDATA; <br> <br> <br>/************************************************************************* <br>** class SERVERDOC : OLEDOC <br>**    SERVERDOC is an extention to the abstract base OLEDOC class. <br>**    The OLEDOC class defines the fields, methods and interfaces that <br>**    are common to both server and client implementations. The <br>**    SERVERDOC class adds the fields, methods and interfaces that are <br>**    specific to OLE 2.0 Server functionality. There is one instance <br>**    of SERVERDOC object created per document open in the app. The SDI <br>**    version of the app supports one SERVERDOC at a time. The MDI <br>**    version of the app can manage multiple documents at one time. <br>**    The SERVERDOC class inherits all fields from the OLEDOC class. <br>**    This inheritance is achieved by including a member variable of <br>**    type OLEDOC as the first field in the SERVERDOC structure. Thus a <br>**    pointer to a SERVERDOC object can be cast to be a pointer to a <br>**    OLEDOC object or an OUTLINEDOC object <br>*************************************************************************/ <br> <br>typedef struct tagSERVERDOC { <br>   OLEDOC              m_OleDoc;           // ServerDoc inherits from OleDoc <br>   ULONG               m_cPseudoObj;       // total count of pseudo obj's <br>   LPOLECLIENTSITE     m_lpOleClientSite;  // Client associated with the obj <br>   LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises <br>   LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises <br>   BOOL                m_fNoScribbleMode;  // was IPS::Save called <br>   BOOL                m_fSaveWithSameAsLoad;  // was IPS::Save called with <br>                                 // fSameAsLoad==TRUE. <br>   OLECHAR             m_szContainerApp[MAXAPPNAME]; <br>   OLECHAR             m_szContainerObj[MAXCONTAINERNAME]; <br>   ULONG               m_nNextRangeNo;     // next no. for unnamed range <br>   LINERANGE           m_lrSrcSelOfCopy;   // src sel if doc created for copy <br>   BOOL                m_fDataChanged;     // data changed when draw disabled <br>   BOOL                m_fSizeChanged;     // size changed when draw disabled <br>   BOOL                m_fSendDataOnStop;  // did data ever change? <br>#if defined( SVR_TREATAS ) <br>   CLSID               m_clsidTreatAs;     // clsid to pretend to be <br>   LPOLESTR            m_lpszTreatAsType;  // user type name to pretend to be <br>#endif  // SVR_TREATAS <br> <br>#if defined( LATER ) <br>   // REVIEW: is it necessary to register a WildCard Moniker <br>   DWORD               m_dwWildCardRegROT; // key if wildcard reg'ed in ROT <br>#endif <br> <br>#if defined( INPLACE_SVR ) <br>   BOOL                m_fInPlaceActive; <br>   BOOL                m_fInPlaceVisible; <br>   BOOL                m_fUIActive; <br>   HWND                m_hWndParent; <br>   HWND                m_hWndHatch; <br>   LPINPLACEDATA       m_lpIPData; <br>   BOOL                m_fMenuHelpMode;// is F1 pressed in menu, give help <br> <br>   struct CDocOleInPlaceObjectImpl { <br>      IOleInPlaceObjectVtbl FAR*  lpVtbl; <br>      LPSERVERDOC                 lpServerDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_OleInPlaceObject; <br> <br>   struct CDocOleInPlaceActiveObjectImpl { <br>      IOleInPlaceActiveObjectVtbl FAR* lpVtbl; <br>      LPSERVERDOC                      lpServerDoc; <br>      int                              cRef;// interface specific ref count. <br>   } m_OleInPlaceActiveObject; <br>#endif // INPLACE_SVR <br> <br>   struct CDocOleObjectImpl { <br>      IOleObjectVtbl FAR*         lpVtbl; <br>      LPSERVERDOC                 lpServerDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_OleObject; <br> <br>   struct CDocPersistStorageImpl { <br>      IPersistStorageVtbl FAR*    lpVtbl; <br>      LPSERVERDOC                 lpServerDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_PersistStorage; <br> <br>#if defined( SVR_TREATAS ) <br>   struct CDocStdMarshalInfoImpl { <br>      IStdMarshalInfoVtbl FAR*    lpVtbl; <br>      LPSERVERDOC                 lpServerDoc; <br>      int                         cRef;   // interface specific ref count. <br>   } m_StdMarshalInfo; <br>#endif  // SVR_TREATAS <br> <br>} SERVERDOC; <br> <br>/* ServerDoc methods (functions) */ <br>BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc); <br>BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc); <br>void ServerDoc_PseudoObjUnlockDoc( <br>      LPSERVERDOC         lpServerDoc, <br>      LPPSEUDOOBJ         lpPseudoObj <br>); <br>void ServerDoc_PseudoObjLockDoc(LPSERVERDOC lpServerDoc); <br>BOOL ServerDoc_PasteFormatFromData( <br>      LPSERVERDOC             lpServerDoc, <br>      CLIPFORMAT              cfFormat, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLocalDataObj, <br>      BOOL                    fLink <br>); <br>BOOL ServerDoc_QueryPasteFromData( <br>      LPSERVERDOC             lpServerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      BOOL                    fLink <br>); <br>HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid); <br>void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc); <br>void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc); <br>HRESULT ServerDoc_GetData ( <br>      LPSERVERDOC             lpServerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>); <br>HRESULT ServerDoc_GetDataHere ( <br>      LPSERVERDOC             lpServerDoc, <br>      LPFORMATETC             lpformatetc, <br>      LPSTGMEDIUM             lpMedium <br>); <br>HRESULT ServerDoc_QueryGetData(LPSERVERDOC lpServerDoc,LPFORMATETC lpformatetc); <br>HRESULT ServerDoc_EnumFormatEtc( <br>      LPSERVERDOC             lpServerDoc, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>); <br>HANDLE ServerDoc_GetMetafilePictData( <br>      LPSERVERDOC             lpServerDoc, <br>      LPLINERANGE             lplrSel <br>); <br>void ServerDoc_SendAdvise( <br>      LPSERVERDOC     lpServerDoc, <br>      WORD            wAdvise, <br>      LPMONIKER       lpmkDoc, <br>      DWORD           dwAdvf <br>); <br>HRESULT ServerDoc_GetObject( <br>      LPSERVERDOC             lpServerDoc, <br>      LPOLESTR                   lpszItem, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObject <br>); <br>HRESULT ServerDoc_IsRunning(LPSERVERDOC lpServerDoc, LPOLESTR lpszItem); <br>LPMONIKER ServerDoc_GetSelRelMoniker( <br>      LPSERVERDOC             lpServerDoc, <br>      LPLINERANGE             lplrSel, <br>      DWORD                   dwAssign <br>); <br>LPMONIKER ServerDoc_GetSelFullMoniker( <br>      LPSERVERDOC             lpServerDoc, <br>      LPLINERANGE             lplrSel, <br>      DWORD                   dwAssign <br>); <br> <br> <br>#if defined( INPLACE_SVR ) <br>HRESULT ServerDoc_DoInPlaceActivate( <br>      LPSERVERDOC     lpServerDoc, <br>      LONG            lVerb, <br>      LPMSG           lpmsg, <br>      LPOLECLIENTSITE lpActiveSite <br>); <br>HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc); <br>HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc); <br>BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc); <br>void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc); <br> <br>HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc); <br>void    ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc); <br>void ServerDoc_CalcInPlaceWindowPos( <br>      LPSERVERDOC         lpServerDoc, <br>      LPRECT              lprcListBox, <br>      LPRECT              lprcDoc, <br>      LPSCALEFACTOR       lpscale <br>); <br>void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc); <br>void ServerDoc_ResizeInPlaceWindow( <br>      LPSERVERDOC         lpServerDoc, <br>      LPCRECT             lprcPosRect, <br>      LPCRECT             lprcClipRect <br>); <br>void ServerDoc_ShadeInPlaceBorder(LPSERVERDOC lpServerDoc, BOOL fShadeOn); <br>void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPOLESTR lpszMessage); <br>LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc); <br>void ServerDoc_GetSharedMenuHandles( <br>      LPSERVERDOC lpServerDoc, <br>      HMENU FAR*      lphSharedMenu, <br>      HOLEMENU FAR*   lphOleMenu <br>); <br>void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc); <br>void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc); <br>void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc); <br> <br>#if defined( USE_FRAMETOOLS ) <br>void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc); <br>#endif // USE_FRAMETOOLS <br> <br>#endif // INPLACE_SVR <br> <br> <br>/* ServerDoc::IOleObject methods (functions) */ <br>STDMETHODIMP SvrDoc_OleObj_QueryInterface( <br>      LPOLEOBJECT             lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_OleObj_AddRef(LPOLEOBJECT lpThis); <br>STDMETHODIMP_(ULONG) SvrDoc_OleObj_Release(LPOLEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_OleObj_SetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE         lpclientSite <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE FAR*    lplpClientSite <br>); <br>STDMETHODIMP SvrDoc_OleObj_SetHostNames( <br>      LPOLEOBJECT             lpThis, <br>      LPCOLESTR               szContainerApp, <br>      LPCOLESTR               szContainerObj <br>); <br>STDMETHODIMP SvrDoc_OleObj_Close( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwSaveOption <br>); <br>STDMETHODIMP SvrDoc_OleObj_SetMoniker( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwWhichMoniker, <br>      LPMONIKER               lpmk <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetMoniker( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAssign, <br>      DWORD                   dwWhichMoniker, <br>      LPMONIKER FAR*          lplpmk <br>); <br>STDMETHODIMP SvrDoc_OleObj_InitFromData( <br>      LPOLEOBJECT             lpThis, <br>      LPDATAOBJECT            lpDataObject, <br>      BOOL                    fCreation, <br>      DWORD                   reserved <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetClipboardData( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   reserved, <br>      LPDATAOBJECT FAR*       lplpDataObject <br>); <br>STDMETHODIMP SvrDoc_OleObj_DoVerb( <br>      LPOLEOBJECT             lpThis, <br>      LONG                    lVerb, <br>      LPMSG                   lpmsg, <br>      LPOLECLIENTSITE         lpActiveSite, <br>      LONG                    lindex, <br>      HWND                    hwndParent, <br>      LPCRECT                 lprcPosRect <br>); <br>STDMETHODIMP SvrDoc_OleObj_EnumVerbs( <br>      LPOLEOBJECT             lpThis, <br>      LPENUMOLEVERB FAR*      lplpenumOleVerb <br>); <br>STDMETHODIMP SvrDoc_OleObj_Update(LPOLEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_OleObj_IsUpToDate(LPOLEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_OleObj_GetUserClassID( <br>      LPOLEOBJECT             lpThis, <br>      LPCLSID                 lpclsid <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetUserType( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwFormOfType, <br>      LPOLESTR FAR*           lpszUserType <br>); <br>STDMETHODIMP SvrDoc_OleObj_SetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>); <br>STDMETHODIMP SvrDoc_OleObj_Advise( <br>      LPOLEOBJECT             lpThis, <br>      LPADVISESINK            lpAdvSink, <br>      LPDWORD                 lpdwConnection <br>); <br>STDMETHODIMP SvrDoc_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection); <br>STDMETHODIMP SvrDoc_OleObj_EnumAdvise( <br>      LPOLEOBJECT             lpThis, <br>      LPENUMSTATDATA FAR*     lplpenumAdvise <br>); <br>STDMETHODIMP SvrDoc_OleObj_GetMiscStatus( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAspect, <br>      DWORD FAR*              lpdwStatus <br>); <br>STDMETHODIMP SvrDoc_OleObj_SetColorScheme( <br>      LPOLEOBJECT             lpThis, <br>      LPLOGPALETTE            lpLogpal <br>); <br>STDMETHODIMP SvrDoc_OleObj_LockObject( <br>      LPOLEOBJECT             lpThis, <br>      BOOL                    fLock <br>); <br> <br>/* ServerDoc::IPersistStorage methods (functions) */ <br>STDMETHODIMP SvrDoc_PStg_QueryInterface( <br>      LPPERSISTSTORAGE        lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis); <br>STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis); <br>STDMETHODIMP SvrDoc_PStg_GetClassID( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPCLSID                 lpClassID <br>); <br>STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis); <br>STDMETHODIMP SvrDoc_PStg_InitNew( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg <br>); <br>STDMETHODIMP SvrDoc_PStg_Load( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg <br>); <br>STDMETHODIMP SvrDoc_PStg_Save( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg, <br>      BOOL                    fSameAsLoad <br>); <br>STDMETHODIMP SvrDoc_PStg_SaveCompleted( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStgNew <br>); <br>STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis); <br> <br> <br>#if defined( SVR_TREATAS ) <br> <br>/* ServerDoc::IStdMarshalInfo methods (functions) */ <br>STDMETHODIMP SvrDoc_StdMshl_QueryInterface( <br>      LPSTDMARSHALINFO        lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis); <br>STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis); <br>STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler( <br>      LPSTDMARSHALINFO        lpThis, <br>      DWORD                   dwDestContext, <br>      LPVOID                  pvDestContext, <br>      LPCLSID                 lpClassID <br>); <br>#endif  // SVR_TREATAS <br> <br>/************************************************************************* <br>** class SERVERAPP : OLEAPP <br>**    SERVERAPP is an extention to the abstract base OLEAPP class. <br>**    The OLEAPP class defines the fields, methods and interfaces that <br>**    are common to both server and client implementations. The <br>**    SERVERAPP class adds the fields and methods that are specific to <br>**    OLE 2.0 Server functionality. There is one instance of <br>**    SERVERAPP object created per running application instance. This <br>**    object holds many fields that could otherwise be organized as <br>**    global variables. The SERVERAPP class inherits all fields <br>**    from the OLEAPP class. This inheritance is achieved by including a <br>**    member variable of type OLEAPP as the first field in the SERVERAPP <br>**    structure. OLEAPP inherits from OLEAPP. This inheritance is <br>**    achieved in the same manner. Thus a pointer to a SERVERAPP object <br>**    can be cast to be a pointer to an OLEAPP or an OUTLINEAPP object <br>*************************************************************************/ <br> <br>typedef struct tagSERVERAPP { <br>   OLEAPP      m_OleApp;       // ServerApp inherits all fields of OleApp <br> <br>#if defined( INPLACE_SVR ) <br>   HACCEL  m_hAccelIPSvr; // accelerators for server's active object commands <br>   HACCEL  m_hAccelBaseApp;    // normal accel for non-inplace server mode <br>   HMENU   m_hMenuEdit;   // handle to Edit menu of the server app <br>   HMENU   m_hMenuLine;   // handle to Line menu of the server app <br>   HMENU   m_hMenuName;   // handle to Name menu of the server app <br>   HMENU   m_hMenuOptions; // handle to Options menu of the server app <br>   HMENU   m_hMenuDebug;       // handle to Debug menu of the server app <br>   HMENU   m_hMenuHelp;   // handle to Help menu of the server app <br>   LPINPLACEDATA   m_lpIPData; <br>#endif <br> <br>} SERVERAPP; <br> <br>/* ServerApp methods (functions) */ <br>BOOL ServerApp_InitInstance( <br>      LPSERVERAPP             lpServerApp, <br>      HINSTANCE               hInst, <br>      int                     nCmdShow <br>); <br>BOOL ServerApp_InitVtbls (LPSERVERAPP lpServerApp); <br> <br> <br> <br>/************************************************************************* <br>** class SERVERNAME : OUTLINENAME <br>**    SERVERNAME class is an extension to the OUTLINENAME base class that <br>**    adds functionallity required to support linking to ranges (pseudo <br>**    objects). Pseudo objects are used to allow linking to a range <br>**    (sub-selection) of a SERVERDOC document. The base class OUTLINENAME <br>**    stores a particular named selection in the document. The <br>**    NAMETABLE class holds all of the names defined in a particular <br>**    document. Each OUTLINENAME object has a string as its key and a <br>**    starting line index and an ending line index for the named range. <br>**    The SERVERNAME class, also, stores a pointer to a PSEUDOOBJ if one <br>**    has been allocated that corresponds to the named selection. <br>**    The SERVERNAME class inherits all fields from the OUTLINENAME class. <br>**    This inheritance is achieved by including a member variable of <br>**    type OUTLINENAME as the first field in the SERVERNAME <br>**    structure. Thus a pointer to an SERVERNAME object can be cast to be <br>**    a pointer to a OUTLINENAME object. <br>*************************************************************************/ <br> <br>typedef struct tagSERVERNAME { <br>   OUTLINENAME     m_Name;         // ServerName inherits all fields of Name <br>   LPPSEUDOOBJ m_lpPseudoObj;  // ptr to pseudo object if allocated <br>} SERVERNAME, FAR* LPSERVERNAME; <br> <br>/* ServerName methods (functions) */ <br>void ServerName_SetSel( <br>      LPSERVERNAME            lpServerName, <br>      LPLINERANGE             lplrSel, <br>      BOOL                    fRangeModified <br>); <br>void ServerName_SendPendingAdvises(LPSERVERNAME lpServerName); <br>LPPSEUDOOBJ ServerName_GetPseudoObj( <br>      LPSERVERNAME            lpServerName, <br>      LPSERVERDOC             lpServerDoc <br>); <br>void ServerName_ClosePseudoObj(LPSERVERNAME lpServerName); <br> <br> <br>/************************************************************************* <br>** class PSEUDOOBJ <br>**    The PSEUDOOBJ (pseudo object) is a concrete class. A pseudo object <br>**    is created when a link is made to a range of lines within an <br>**    SERVERDOC document. A pseudo object is dependent on the existance <br>**    of the SERVERDOC which represents the whole document. <br>*************************************************************************/ <br> <br>typedef struct tagPSEUDOOBJ { <br>   ULONG               m_cRef;             // total ref count for obj <br>   BOOL                m_fObjIsClosing;    // flag to guard recursive close <br>   LPSERVERNAME        m_lpName;           // named range for this pseudo obj <br>   LPSERVERDOC         m_lpDoc;            // ptr to whole document <br>   LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises <br>   LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises <br>   BOOL                m_fDataChanged;     // data changed when draw disabled <br> <br>   struct CPseudoObjUnknownImpl { <br>      IUnknownVtbl FAR*       lpVtbl; <br>      LPPSEUDOOBJ             lpPseudoObj; <br>      int                     cRef;   // interface specific ref count. <br>   } m_Unknown; <br> <br>   struct CPseudoObjOleObjectImpl { <br>      IOleObjectVtbl FAR*     lpVtbl; <br>      LPPSEUDOOBJ             lpPseudoObj; <br>      int                     cRef;   // interface specific ref count. <br>   } m_OleObject; <br> <br>   struct CPseudoObjDataObjectImpl { <br>      IDataObjectVtbl FAR*    lpVtbl; <br>      LPPSEUDOOBJ             lpPseudoObj; <br>      int                     cRef;   // interface specific ref count. <br>   } m_DataObject; <br> <br>} PSEUDOOBJ; <br> <br>/* PseudoObj methods (functions) */ <br>void PseudoObj_Init( <br>      LPPSEUDOOBJ             lpPseudoObj, <br>      LPSERVERNAME            lpServerName, <br>      LPSERVERDOC             lpServerDoc <br>); <br>ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj); <br>ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj); <br>HRESULT PseudoObj_QueryInterface( <br>      LPPSEUDOOBJ         lpPseudoObj, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpUnk <br>); <br>BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj); <br>void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj); <br>void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel); <br>void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel); <br>void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel); <br>void PseudoObj_SendAdvise( <br>      LPPSEUDOOBJ lpPseudoObj, <br>      WORD        wAdvise, <br>      LPMONIKER   lpmkObj, <br>      DWORD       dwAdvf <br>); <br>LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc); <br> <br>/* PseudoObj::IUnknown methods (functions) */ <br>STDMETHODIMP PseudoObj_Unk_QueryInterface( <br>      LPUNKNOWN         lpThis, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpvObj <br>); <br>STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis); <br>STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis); <br> <br>/* PseudoObj::IOleObject methods (functions) */ <br>STDMETHODIMP PseudoObj_OleObj_QueryInterface( <br>      LPOLEOBJECT     lpThis, <br>      REFIID          riid, <br>      LPVOID FAR*     lplpvObj <br>); <br>STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis); <br>STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis); <br>STDMETHODIMP PseudoObj_OleObj_SetClientSite( <br>      LPOLEOBJECT         lpThis, <br>      LPOLECLIENTSITE     lpClientSite <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE FAR*    lplpClientSite <br>); <br>STDMETHODIMP PseudoObj_OleObj_SetHostNames( <br>      LPOLEOBJECT             lpThis, <br>      LPCOLESTR               szContainerApp, <br>      LPCOLESTR               szContainerObj <br>); <br>STDMETHODIMP PseudoObj_OleObj_Close( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwSaveOption <br>); <br>STDMETHODIMP PseudoObj_OleObj_SetMoniker( <br>      LPOLEOBJECT lpThis, <br>      DWORD       dwWhichMoniker, <br>      LPMONIKER   lpmk <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetMoniker( <br>      LPOLEOBJECT     lpThis, <br>      DWORD           dwAssign, <br>      DWORD           dwWhichMoniker, <br>      LPMONIKER FAR*  lplpmk <br>); <br>STDMETHODIMP PseudoObj_OleObj_InitFromData( <br>      LPOLEOBJECT             lpThis, <br>      LPDATAOBJECT            lpDataObject, <br>      BOOL                    fCreation, <br>      DWORD                   reserved <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetClipboardData( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   reserved, <br>      LPDATAOBJECT FAR*       lplpDataObject <br>); <br>STDMETHODIMP PseudoObj_OleObj_DoVerb( <br>      LPOLEOBJECT             lpThis, <br>      LONG                    lVerb, <br>      LPMSG                   lpmsg, <br>      LPOLECLIENTSITE         lpActiveSite, <br>      LONG                    lindex, <br>      HWND                    hwndParent, <br>      LPCRECT                 lprcPosRect <br>); <br>STDMETHODIMP PseudoObj_OleObj_EnumVerbs( <br>      LPOLEOBJECT         lpThis, <br>      LPENUMOLEVERB FAR*  lplpenumOleVerb <br>); <br>STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis); <br>STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis); <br>STDMETHODIMP PseudoObj_OleObj_GetUserClassID( <br>      LPOLEOBJECT             lpThis, <br>      LPCLSID                 lpclsid <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetUserType( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwFormOfType, <br>      LPOLESTR FAR*           lpszUserType <br>); <br>STDMETHODIMP PseudoObj_OleObj_SetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>); <br>STDMETHODIMP PseudoObj_OleObj_Advise( <br>      LPOLEOBJECT lpThis, <br>      LPADVISESINK lpAdvSink, <br>      LPDWORD lpdwConnection <br>); <br>STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis,DWORD dwConnection); <br>STDMETHODIMP PseudoObj_OleObj_EnumAdvise( <br>      LPOLEOBJECT lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>); <br>STDMETHODIMP PseudoObj_OleObj_GetMiscStatus( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAspect, <br>      DWORD FAR*              lpdwStatus <br>); <br>STDMETHODIMP PseudoObj_OleObj_SetColorScheme( <br>      LPOLEOBJECT             lpThis, <br>      LPLOGPALETTE            lpLogpal <br>); <br>STDMETHODIMP PseudoObj_OleObj_LockObject( <br>      LPOLEOBJECT             lpThis, <br>      BOOL                    fLock <br>); <br> <br>/* PseudoObj::IDataObject methods (functions) */ <br>STDMETHODIMP PseudoObj_DataObj_QueryInterface ( <br>      LPDATAOBJECT      lpThis, <br>      REFIID            riid, <br>      LPVOID FAR*       lplpvObj <br>); <br>STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis); <br>STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis); <br>STDMETHODIMP PseudoObj_DataObj_GetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpMedium <br>); <br>STDMETHODIMP PseudoObj_DataObj_GetDataHere ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpMedium <br>); <br>STDMETHODIMP PseudoObj_DataObj_QueryGetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc <br>); <br>STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPFORMATETC     lpformatetcOut <br>); <br>STDMETHODIMP PseudoObj_DataObj_SetData ( <br>      LPDATAOBJECT    lpThis, <br>      LPFORMATETC     lpformatetc, <br>      LPSTGMEDIUM     lpmedium, <br>      BOOL            fRelease <br>); <br>STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc( <br>      LPDATAOBJECT            lpThis, <br>      DWORD                   dwDirection, <br>      LPENUMFORMATETC FAR*    lplpenumFormatEtc <br>); <br>STDMETHODIMP PseudoObj_DataObj_DAdvise( <br>      LPDATAOBJECT    lpThis, <br>      FORMATETC FAR*  lpFormatetc, <br>      DWORD           advf, <br>      LPADVISESINK    lpAdvSink, <br>      DWORD FAR*      lpdwConnection <br>); <br>STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection); <br>STDMETHODIMP PseudoObj_DataObj_EnumAdvise( <br>      LPDATAOBJECT lpThis, <br>      LPENUMSTATDATA FAR* lplpenumAdvise <br>); <br> <br> <br>/************************************************************************* <br>** class SERVERNAMETABLE : OUTLINENAMETABLE <br>**    SERVERNAMETABLE class is an extension to the OUTLINENAMETABLE <br>**    base class that adds functionallity required to support linking <br>**    to ranges (pseudo objects). The name table manages the table of <br>**    named selections in the document. Each name table entry has a <br>**    string as its key and a starting line index and an ending line <br>**    index for the named range. The SERVERNAMETABLE entries, in </code></pre>
<p>
</p>
<pre><code>**    addition, maintain a pointer to a PSEUDOOBJ pseudo object if one <br>**    has been already allocated. There is always one instance of <br>**    SERVERNAMETABLE for each SERVERDOC object created. <br>**    The SERVERNAME class inherits all fields from the NAME class. <br>**    This inheritance is achieved by including a member variable of <br>**    type NAME as the first field in the SERVERNAME <br>**    structure. Thus a pointer to an SERVERNAME object can be cast to be <br>**    a pointer to a NAME object. <br>*************************************************************************/ <br> <br>typedef struct tagSERVERNAMETABLE { <br>   OUTLINENAMETABLE    m_NameTable;    // we inherit from OUTLINENAMETABLE <br> <br>   // ServerNameTable does NOT add any fields <br> <br>} SERVERNAMETABLE, FAR* LPSERVERNAMETABLE; <br> <br>/* ServerNameTable methods (functions) */ <br>void ServerNameTable_EditLineUpdate( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      int                     nEditIndex <br>); <br>void ServerNameTable_InformAllPseudoObjectsDocRenamed( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPMONIKER               lpmkDoc <br>); <br>void ServerNameTable_InformAllPseudoObjectsDocSaved( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPMONIKER               lpmkDoc <br>); <br>void ServerNameTable_SendPendingAdvises(LPSERVERNAMETABLE lpServerNameTable); <br>LPPSEUDOOBJ ServerNameTable_GetPseudoObj( <br>      LPSERVERNAMETABLE       lpServerNameTable, <br>      LPOLESTR                lpszItem, <br>      LPSERVERDOC             lpServerDoc <br>); <br>void ServerNameTable_CloseAllPseudoObjs(LPSERVERNAMETABLE lpServerNameTable); <br> <br> <br>#if defined( INPLACE_SVR) <br> <br>/* ServerDoc::IOleInPlaceObject methods (functions) */ <br> <br>STDMETHODIMP SvrDoc_IPObj_QueryInterface( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      REFIID              riid, <br>      LPVOID FAR *        lplpvObj <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis); <br>STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_IPObj_GetWindow( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      HWND FAR*           lphwnd <br>); <br>STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      BOOL                fEnable <br>); <br>STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis); <br>STDMETHODIMP SvrDoc_IPObj_SetObjectRects( <br>      LPOLEINPLACEOBJECT  lpThis, <br>      LPCRECT             lprcPosRect, <br>      LPCRECT             lprcClipRect <br>); <br>STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis); <br> <br>/* ServerDoc::IOleInPlaceActiveObject methods (functions) */ <br> <br>STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      REFIID                      riidReq, <br>      LPVOID FAR *                lplpUnk <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef( <br>      LPOLEINPLACEACTIVEOBJECT lpThis <br>); <br>STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release( <br>      LPOLEINPLACEACTIVEOBJECT lpThis <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_GetWindow( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      HWND FAR*                   lphwnd <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fEnable <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      LPMSG                       lpmsg <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fActivate <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fActivate <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      LPCRECT                     lprectBorder, <br>      LPOLEINPLACEUIWINDOW        lpIPUiWnd, <br>      BOOL                        fFrameWindow <br>); <br>STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless( <br>      LPOLEINPLACEACTIVEOBJECT    lpThis, <br>      BOOL                        fEnable <br>); <br> <br>#endif // INPLACE_SVR <br> <br>#endif // _SVROUTL_H_ <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
