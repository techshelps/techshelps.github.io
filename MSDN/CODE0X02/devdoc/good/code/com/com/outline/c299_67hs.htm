<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SVRBASE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context310"></a>SVRBASE.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Server Sample Code <br>** <br>**    svrbase.c <br>** <br>**    This file contains all interfaces, methods and related support <br>**    functions for the basic OLE Object (Server) application. The <br>**    basic OLE Object application supports embedding an object and <br>**    linking to a file-based or embedded object as a whole. The basic <br>**    Object application includes the following implementation objects: <br>** <br>**    ClassFactory (aka. ClassObject) Object    (see file classfac.c) <br>**      exposed interfaces: <br>**          IClassFactory interface <br>** <br>**    ServerDoc Object <br>**      exposed interfaces: <br>**          IUnknown <br>**          IOleObject interface <br>**          IPersistStorage interface <br>**          IDataObject interface <br>** <br>**    ServerApp Object <br>**      exposed interfaces: <br>**          IUnknown <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP             g_lpApp; <br>extern IOleObjectVtbl           g_SvrDoc_OleObjectVtbl; <br>extern IPersistStorageVtbl      g_SvrDoc_PersistStorageVtbl; <br> <br>#if defined( INPLACE_SVR ) <br>extern IOleInPlaceObjectVtbl        g_SvrDoc_OleInPlaceObjectVtbl; <br>extern IOleInPlaceActiveObjectVtbl  g_SvrDoc_OleInPlaceActiveObjectVtbl; <br>#endif  // INPLACE_SVR <br> <br>#if defined( SVR_TREATAS ) <br>extern IStdMarshalInfoVtbl      g_SvrDoc_StdMarshalInfoVtbl; <br>#endif  // SVR_TREATAS <br> <br> <br>// REVIEW: should use string resource for messages <br>extern OLECHAR ErrMsgSaving[]; <br>extern OLECHAR ErrMsgFormatNotSupported[]; <br>static OLECHAR ErrMsgPSSaveFail[] = OLESTR("PSSave failed"); <br>static OLECHAR ErrMsgLowMemNClose[] = OLESTR("Warning OUT OF MEMORY! We must close down"); <br>extern char g_szUpdateCntrDoc[] = "&amp;Update %s"; <br>extern char g_szExitNReturnToCntrDoc[] = "E&amp;xit &amp;&amp; Return to %s"; <br> <br> <br>/************************************************************************* <br>** ServerDoc::IOleObject interface implementation <br>*************************************************************************/ <br> <br>// IOleObject::QueryInterface method <br> <br>STDMETHODIMP SvrDoc_OleObj_QueryInterface( <br>      LPOLEOBJECT             lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj); <br>} <br> <br> <br>// IOleObject::AddRef method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_OleObj_AddRef(LPOLEOBJECT lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleObject"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleObject::Release method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_OleObj_Release(LPOLEOBJECT lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleObject"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IOleObject::SetClientSite method <br> <br>STDMETHODIMP SvrDoc_OleObj_SetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE         lpclientSite <br>) <br>{ <br>      LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_SetClientSite\r\n") <br> <br>   // SetClientSite is only valid to call on an embedded object <br>   if (lpOutlineDoc-&gt;m_docInitType != DOCTYPE_EMBEDDED) { <br>      OleDbgAssert(lpOutlineDoc-&gt;m_docInitType == DOCTYPE_EMBEDDED); <br>      OLEDBG_END2 <br>      // release artificial AddRef <br>      SvrDoc_OleObj_Release(lpThis); <br>      return E_UNEXPECTED; <br>   } <br> <br>   /* if we currently have a client site ptr, then release it. */ <br>   if (lpServerDoc-&gt;m_lpOleClientSite) <br>      OleStdRelease((LPUNKNOWN)lpServerDoc-&gt;m_lpOleClientSite); <br> <br>   lpServerDoc-&gt;m_lpOleClientSite = (LPOLECLIENTSITE) lpclientSite; <br>   // NOTE: to be able to hold onto clientSite pointer, we must AddRef it <br>   if (lpclientSite) <br>      lpclientSite-&gt;lpVtbl-&gt;AddRef(lpclientSite); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>// IOleObject::GetClientSite method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetClientSite( <br>      LPOLEOBJECT             lpThis, <br>      LPOLECLIENTSITE FAR*    lplpClientSite <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OleDbgOut2("SvrDoc_OleObj_GetClientSite\r\n"); <br> <br>   /* NOTE: we MUST AddRef this interface pointer to give the <br>   **    caller a personal copy of the pointer <br>   */ <br>   lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;AddRef( <br>         lpServerDoc-&gt;m_lpOleClientSite <br>   ); <br>   *lplpClientSite = lpServerDoc-&gt;m_lpOleClientSite; <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br> <br>   return NOERROR; <br> <br>} <br> <br> <br>// IOleObject::SetHostNames method <br> <br>STDMETHODIMP SvrDoc_OleObj_SetHostNames( <br>      LPOLEOBJECT             lpThis, <br>      LPCOLESTR               szContainerApp, <br>      LPCOLESTR               szContainerObj <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   char szAnsiStr1[256], szAnsiStr2[256], szAnsiStr3[256]; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OleDbgOut2("SvrDoc_OleObj_SetHostNames\r\n"); <br> <br>   OLESTRCPY(/*(LPOLESTR)*/lpServerDoc-&gt;m_szContainerApp, szContainerApp); <br>   OLESTRCPY(/*(LPOLESTR)*/lpServerDoc-&gt;m_szContainerObj, szContainerObj); <br> <br>   /* The Window title for an embedded object is constructed as <br>   **    follows: <br>   **      &lt;server app name&gt; - &lt;obj short type&gt; in &lt;cont. doc name&gt; <br>   ** <br>   **    here we construct the current document title portion of the <br>   **    name which follows the '-'. OutlineDoc_SetTitle prepends the <br>   **    "&lt;server app name&gt; - " to the document title. <br>   */ <br>   // REVIEW: this string should be loaded from string resource <br>   W2A (lpServerDoc-&gt;m_szContainerObj, szAnsiStr1, 256); <br>   W2A (SHORTUSERTYPENAME, szAnsiStr3, 256); <br>   wsprintf(szAnsiStr2, "%s in %s", <br>         szAnsiStr3, (LPSTR)szAnsiStr1); <br>   A2W (szAnsiStr2, lpOutlineDoc-&gt;m_szFileName, OLEUI_CCHPATHMAX); <br> <br>   lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>   OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/); <br> <br>   /* NOTE: update the application menus correctly for an embedded <br>   **    object. the changes include: <br>   **      1 Remove File/New and File/Open (SDI ONLY) <br>   **      2 Change File/Save As.. to File/Save Copy As.. <br>   **      3 Change File menu so it contains "Update" instead of "Save" <br>   **      4 Change File/Exit to File/Exit &amp; Return to &lt;client doc&gt;" <br>   */ <br>   ServerDoc_UpdateMenu(lpServerDoc); <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleObject::Close method <br> <br>STDMETHODIMP SvrDoc_OleObj_Close( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwSaveOption <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   BOOL fStatus; <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_Close\r\n") <br> <br>   /* NOTE: the OLE 2.0 user model is that embedded objects should <br>   **    always be saved when closed WITHOUT any prompting to the <br>   **    user. this is the recommendation irregardless of whether the <br>   **    object is activated in-place or open in its own window. <br>   **    this is a CHANGE from the OLE 1.0 user model where it <br>   **    was the guideline that servers always prompt to save changes. <br>   **    thus OLE 2.0 compound document oriented container's should <br>   **    always pass dwSaveOption==OLECLOSE_SAVEIFDIRTY. it is <br>   **    possible that for programmatic uses a container may want to <br>   **    specify a different dwSaveOption. the implementation of <br>   **    various save options can be tricky, particularly considering <br>   **    cases involving in-place activation. the following would be <br>   **    reasonable behavior: <br>   ** <br>   **      (1) OLECLOSE_SAVEIFDIRTY: if dirty, save. close. <br>   **      (2) OLECLOSE_NOSAVE: close. <br>   **      (3) OLECLOSE_PROMPTSAVE: <br>   **        (a) object visible, but not in-place: <br>   **               if not dirty, close. <br>   **               switch(prompt) <br>   **                  case IDYES: save. close. <br>   **                  case IDNO: close. <br>   **                  case IDCANCEL: return OLE_E_PROMPTSAVECANCELLED <br>   **        (b) object invisible (includes UIDeactivated object) <br>   **               if dirty, save. close. <br>   **               NOTE: NO PROMPT. it is not appropriate to prompt <br>   **                     if the object is not visible. <br>   **        (c) object is in-place active: <br>   **               if dirty, save. close. <br>   **               NOTE: NO PROMPT. it is not appropriate to prompt <br>   **                     if the object is active in-place. <br>   */ <br>   fStatus = OutlineDoc_Close((LPOUTLINEDOC)lpServerDoc, dwSaveOption); <br>   OleDbgAssertSz(fStatus == TRUE, "SvrDoc_OleObj_Close failed\r\n"); <br> <br>   OLEDBG_END2 <br> <br>   return (fStatus ? NOERROR : E_FAIL); <br>} <br> <br> <br>// IOleObject::SetMoniker method <br> <br>STDMETHODIMP SvrDoc_OleObj_SetMoniker( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwWhichMoniker, <br>      LPMONIKER               lpmk <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPMONIKER lpmkFull = NULL; <br>   HRESULT hrErr; <br>   HRESULT sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_SetMoniker\r\n") <br> <br>   /* NOTE: if our full moniker is passed then we can use it, <br>   **    otherwise we must call back to our ClientSite to get our full <br>   **    moniker. <br>   */ <br>   if (dwWhichMoniker == OLEWHICHMK_OBJFULL) { <br> <br>      /* Register the document as running with the new moniker and <br>      **      notify any clients that our moniker has changed. <br>      */ <br>      OleDoc_DocRenamedUpdate(lpOleDoc, lpmk); <br> <br>      if (lpOutlineDoc-&gt;m_docInitType != DOCTYPE_EMBEDDED) { <br>         IBindCtx  FAR  *pbc = NULL; <br>         LPOLESTR lpszName = NULL; <br> <br>         /* NOTE: if this is a FILE-based or untitled document <br>         **    then we should accept this new moniker as our document's <br>         **    moniker. we will remember this moniker instead of the <br>         **    FileMoniker that we have by default. this allows <br>         **    systems that use special monikers to track the <br>         **    location of documents to inform a document that is a <br>         **    link source of its special moniker. this enables the <br>         **    document to use this special moniker when building <br>         **    composite monikers to identify contained objects and <br>         **    pseudo objects (ranges). <br>         ** <br>         **    we should also use the DisplayName form of this <br>         **    moniker as our document name in our window title. <br>         */ <br>         if (lpOleDoc-&gt;m_lpFileMoniker) { <br>            lpOleDoc-&gt;m_lpFileMoniker-&gt;lpVtbl-&gt;Release( <br>                  lpOleDoc-&gt;m_lpFileMoniker); <br>         } <br>         lpOleDoc-&gt;m_lpFileMoniker = lpmk; <br>         // we must AddRef the moniker to hold on to it <br>         lpmk-&gt;lpVtbl-&gt;AddRef(lpmk); <br> <br>         /* we should also use the DisplayName form of this <br>         **    moniker as our document name in our window title. <br>         */ <br>         CreateBindCtx(0, (LPBC FAR*)&amp;pbc); <br>         lpmk-&gt;lpVtbl-&gt;GetDisplayName(lpmk,pbc,NULL,&amp;lpszName); <br>         pbc-&gt;lpVtbl-&gt;Release(pbc); <br>         if (lpszName) { <br>            OLESTRCPY(lpOutlineDoc-&gt;m_szFileName, lpszName); <br>            lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br>            OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/); <br>            OleStdFreeString(lpszName, NULL); <br>         } <br>      } <br> <br>      OLEDBG_END2 <br>      // release artificial AddRef <br>      SvrDoc_OleObj_Release(lpThis); <br>      return NOERROR; <br>   } <br> <br>   /* if the passed moniker was NOT a full moniker then we must call <br>   **    back to our ClientSite to get our full moniker. this is <br>   **    needed in order to register in the RunningObjectTable. if we <br>   **    don't have a ClientSite then this is an error. <br>   */ <br>   if (lpServerDoc-&gt;m_lpOleClientSite == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   hrErr = lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;GetMoniker( <br>         lpServerDoc-&gt;m_lpOleClientSite, <br>         OLEGETMONIKER_ONLYIFTHERE, <br>         OLEWHICHMK_OBJFULL, <br>         &amp;lpmkFull <br>   ); <br>   if (hrErr != NOERROR) { <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   /* Register the document as running with the new moniker and <br>   **      notify any clients that our moniker has changed. <br>   */ <br>   OleDoc_DocRenamedUpdate(lpOleDoc, lpmkFull); <br> <br>   if (lpmkFull) <br>      OleStdRelease((LPUNKNOWN)lpmkFull); <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::GetMoniker method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetMoniker( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAssign, <br>      DWORD                   dwWhichMoniker, <br>      LPMONIKER FAR*          lplpmk <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   HRESULT sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_GetMoniker\r\n") <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpmk = NULL; <br> <br>   if (lpServerDoc-&gt;m_lpOleClientSite) { <br> <br>      /* document is an embedded object. retrieve our moniker from <br>      **    our container. <br>      */ <br>      OLEDBG_BEGIN2("IOleClientSite::GetMoniker called\r\n") <br>      sc =  lpServerDoc-&gt;m_lpOleClientSite-&gt;lpVtbl-&gt;GetMoniker( <br>            lpServerDoc-&gt;m_lpOleClientSite, <br>            dwAssign, <br>            dwWhichMoniker, <br>            lplpmk <br>      ) ; <br>      OLEDBG_END2 <br> <br>   } else if (lpOleDoc-&gt;m_lpFileMoniker) { <br> <br>      /* document is a top-level user document (either <br>      **    file-based or untitled). return the FileMoniker stored <br>      **    with the document; it uniquely identifies the document. <br>      */ <br>      if (dwWhichMoniker == OLEWHICHMK_CONTAINER) <br>         sc = E_INVALIDARG;  // file-based object has no CONTAINER moniker <br>      else { <br>         *lplpmk = lpOleDoc-&gt;m_lpFileMoniker; <br>         (*lplpmk)-&gt;lpVtbl-&gt;AddRef(*lplpmk); // must AddRef to pass out ptr <br>         sc = S_OK; <br>      } <br> <br>   } else { <br>      // document is not yet fully initialized =&gt; no moniker <br>      sc = E_FAIL; <br>   } <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::InitFromData method <br> <br>STDMETHODIMP SvrDoc_OleObj_InitFromData( <br>      LPOLEOBJECT             lpThis, <br>      LPDATAOBJECT            lpDataObject, <br>      BOOL                    fCreation, <br>      DWORD                   reserved <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_InitFromData\r\n") <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   OLEDBG_END2 <br>   return E_NOTIMPL; <br>} <br> <br> <br>// IOleObject::GetClipboardData method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetClipboardData( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   reserved, <br>      LPDATAOBJECT FAR*       lplpDataObject <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_GetClipboardData\r\n") <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   OLEDBG_END2 <br>   return E_NOTIMPL; <br>} <br> <br> <br>// IOleObject::DoVerb method <br> <br>STDMETHODIMP SvrDoc_OleObj_DoVerb( <br>      LPOLEOBJECT             lpThis, <br>      LONG                    lVerb, <br>      LPMSG                   lpmsg, <br>      LPOLECLIENTSITE         lpActiveSite, <br>      LONG                    lindex, <br>      HWND                    hwndParent, <br>      LPCRECT                 lprcPosRect <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   HRESULT sc = S_OK; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_DoVerb\r\n") <br> <br>   switch (lVerb) { <br> <br>      default: <br>         /* NOTE: when an unknown verb number is given, the <br>         **    server must take careful action: <br>         **    1. if it is one of the specially defined OLEIVERB <br>         **    (negative numbered) verbs, the app should return an <br>         **    error (E_NOTIMPL) and perform no action. <br>         ** <br>         **    2. if the verb is a application specific verb <br>         **    (positive numbered verb), then the app should <br>         **    return the special HRESULT (OLEOBJ_S_INVALIDVERB). BUT, <br>         **    we should still perform our normal primary verb action. <br>         */ <br>         if (lVerb &lt; 0) { <br>            OLEDBG_END2 <br>            return E_NOTIMPL; <br>         } else { <br>            sc = OLEOBJ_S_INVALIDVERB; <br>         } <br> <br>         // deliberatly fall through to Primary Verb <br> <br>#if !defined( INPLACE_SVR ) <br>      case 0: <br>      case OLEIVERB_SHOW: <br>      case OLEIVERB_OPEN: <br>         OutlineDoc_ShowWindow(lpOutlineDoc); <br>         break; <br> <br>      case OLEIVERB_HIDE: <br>         OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /*fShutdown*/); <br>         break; <br>#endif  // ! INPLACE_SVR <br>#if defined( INPLACE_SVR ) <br>      case 0: <br>      case OLEIVERB_SHOW: <br> <br>         /* NOTE: if our window is already open (visible) then <br>         **    we should simply surface the open window. if not, <br>         **    then we can do our primary action of in-place <br>         **    activation. <br>         */ <br>         if ( lpServerDoc-&gt;m_lpOleClientSite <br>               &amp;&amp; ! (IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc) &amp;&amp; <br>                     ! lpServerDoc-&gt;m_fInPlaceActive) ) { <br>            ServerDoc_DoInPlaceActivate( <br>                  lpServerDoc, lVerb, lpmsg, lpActiveSite); <br>         } <br>         OutlineDoc_ShowWindow(lpOutlineDoc); <br>         break; <br> <br>      case 1: <br>      case OLEIVERB_OPEN: <br>         ServerDoc_DoInPlaceDeactivate(lpServerDoc); <br>         OutlineDoc_ShowWindow(lpOutlineDoc); <br>         break; <br> <br> <br>      case OLEIVERB_HIDE: <br>         if (lpServerDoc-&gt;m_fInPlaceActive) { <br> <br>            SvrDoc_IPObj_UIDeactivate( <br>                  (LPOLEINPLACEOBJECT)&amp;lpServerDoc-&gt;m_OleInPlaceObject); <br> <br>#if defined( SVR_INSIDEOUT ) <br>            /* NOTE: an inside-out style in-place server will <br>            **    NOT hide its window in UIDeactive (an outside-in <br>            **    style object will hide its window in <br>            **    UIDeactivate). thus we need to explicitly hide <br>            **    our window now. <br>            */ <br>            ServerDoc_DoInPlaceHide(lpServerDoc); <br>#endif // INSIEDOUT <br> <br>         } else { <br>            OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /*fShutdown*/); <br>         } <br>         break; <br> <br>      case OLEIVERB_UIACTIVATE: <br> <br>#if defined( SVR_INSIDEOUT ) <br>      /* NOTE: only an inside-out style object supports <br>      **    INPLACEACTIVATE verb <br>      */ <br>      case OLEIVERB_INPLACEACTIVATE: <br>#endif // SVR_INSIDEOUT <br> <br>         /* NOTE: if our window is already open (visible) then <br>         **    we can NOT activate in-place. <br>         */ <br>         if (IsWindowVisible(lpOutlineDoc-&gt;m_hWndDoc) &amp;&amp; <br>                  ! lpServerDoc-&gt;m_fInPlaceActive ) { <br>            sc = OLE_E_NOT_INPLACEACTIVE; <br>         } else { <br>            sc =  ServerDoc_DoInPlaceActivate( <br>                  lpServerDoc, lVerb, lpmsg, lpActiveSite) ; <br>            if (SUCCEEDED(sc)) <br>               OutlineDoc_ShowWindow(lpOutlineDoc); <br>         } <br>         break; <br>#endif  // INPLACE_SVR <br>   } <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::EnumVerbs method <br> <br>STDMETHODIMP SvrDoc_OleObj_EnumVerbs( <br>      LPOLEOBJECT             lpThis, <br>      LPENUMOLEVERB FAR*      lplpenumOleVerb <br>) <br>{ <br>   OleDbgOut2("SvrDoc_OleObj_EnumVerbs\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumOleVerb = NULL; <br> <br>   /* An object implemented as a server EXE (as this sample <br>   **    is) may simply return OLE_S_USEREG to instruct the OLE <br>   **    DefHandler to call the OleReg* helper API which uses info in <br>   **    the registration database. Alternatively, the OleRegEnumVerbs <br>   **    API may be called directly. Objects implemented as a server <br>   **    DLL may NOT return OLE_S_USEREG; they must call the OleReg* <br>   **    API or provide their own implementation. For EXE based <br>   **    objects it is more efficient to return OLE_S_USEREG, because <br>   **    in then the verb enumerator is instantiated in the callers <br>   **    process space and no LRPC remoting is required. <br>   */ <br>   return OLE_S_USEREG; <br>} <br> <br> <br>// IOleObject::Update method <br> <br>STDMETHODIMP SvrDoc_OleObj_Update(LPOLEOBJECT lpThis) <br>{ <br>   OleDbgOut2("SvrDoc_OleObj_Update\r\n"); <br> <br>   /* NOTE: a server-only app is always "up-to-date". <br>   **    a container-app which contains links where the link source <br>   **    has changed since the last update of the link would be <br>   **    considered "out-of-date". the "Update" method instructs the <br>   **    object to get an update from any out-of-date links. <br>   */ <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleObject::IsUpToDate method <br> <br>STDMETHODIMP SvrDoc_OleObj_IsUpToDate(LPOLEOBJECT lpThis) <br>{ <br>   OleDbgOut2("SvrDoc_OleObj_IsUpToDate\r\n"); <br> <br>   /* NOTE: a server-only app is always "up-to-date". <br>   **    a container-app which contains links where the link source <br>   **    has changed since the last update of the link would be <br>   **    considered "out-of-date". <br>   */ <br>   return NOERROR; <br>} <br> <br> <br>// IOleObject::GetUserClassID method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetUserClassID( <br>      LPOLEOBJECT             lpThis, <br>      LPCLSID                 lpClassID <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_OleObj_GetClassID\r\n"); <br> <br>   /* NOTE: we must be carefull to return the correct CLSID here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the class of the object <br>   **    written in the storage of the object. otherwise we would <br>   **    return our own class id. <br>   */ <br>   return ServerDoc_GetClassID(lpServerDoc, lpClassID); <br>} <br> <br> <br>// IOleObject::GetUserType method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetUserType( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwFormOfType, <br>      LPOLESTR FAR*           lpszUserType <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_OleObj_GetUserType\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lpszUserType = NULL; <br> <br>   /* NOTE: we must be carefull to return the correct user type here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the user type name that <br>   **    corresponds to the class of the object we are currently <br>   **    emmulating. otherwise we should return our normal user type <br>   **    name corresponding to our own class. This routine determines <br>   **    the current clsid in effect. <br>   ** <br>   **    An object implemented as a server EXE (as this sample <br>   **    is) may simply return OLE_S_USEREG to instruct the OLE <br>   **    DefHandler to call the OleReg* helper API which uses info in <br>   **    the registration database. Alternatively, the OleRegGetUserType <br>   **    API may be called directly. Objects implemented as a server <br>   **    DLL may NOT return OLE_S_USEREG; they must call the OleReg* <br>   **    API or provide their own implementation. For EXE based <br>   **    objects it is more efficient to return OLE_S_USEREG, because <br>   **    in then the return string is instantiated in the callers <br>   **    process space and no LRPC remoting is required. <br>   */ <br>#if defined( SVR_TREATAS ) <br>   if (! IsEqualCLSID(&amp;lpServerDoc-&gt;m_clsidTreatAs, &amp;CLSID_NULL) ) <br>      return OleRegGetUserType( <br>         (REFCLSID)&amp;lpServerDoc-&gt;m_clsidTreatAs,dwFormOfType,lpszUserType); <br>   else <br>#endif  // SVR_TREATAS <br> <br>   return OLE_S_USEREG; <br>} <br> <br> <br>// IOleObject::SetExtent method <br> <br>STDMETHODIMP SvrDoc_OleObj_SetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lplgrc <br>) <br>{ <br>   OleDbgOut2("SvrDoc_OleObj_SetExtent\r\n"); <br> <br>   /* SVROUTL does NOT allow the object's size to be set by its <br>   **    container. the size of the ServerDoc object is determined by <br>   **    the data contained within the document. <br>   */ <br>   return E_FAIL; <br>} <br> <br> <br>// IOleObject::GetExtent method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetExtent( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwDrawAspect, <br>      LPSIZEL                 lpsizel <br>) <br>{ <br>   LPOLEDOC lpOleDoc = <br>         (LPOLEDOC)((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OleDbgOut2("SvrDoc_OleObj_GetExtent\r\n"); <br> <br>   /* NOTE: it is VERY important to check which aspect the caller <br>   **    is asking about. an object implemented by a server EXE MAY <br>   **    fail to return extents when asked for DVASPECT_ICON. <br>   */ <br>   if (dwDrawAspect == DVASPECT_CONTENT) { <br>      OleDoc_GetExtent(lpOleDoc, lpsizel); <br>      // release artificial AddRef <br>      SvrDoc_OleObj_Release(lpThis); <br>      return NOERROR; <br>   } <br> <br>#if defined( LATER ) <br> <br>   else if (dwDrawAspect == DVASPECT_THUMBNAIL) <br>   { <br>      /* as our thumbnail we will render only the first page of the <br>      **    document. calculate extents of our thumbnail rendering. <br>      ** <br>      ** NOTE: thumbnails are most often used by applications in <br>      **    FindFile or FileOpen type dialogs to give the user a <br>      **    quick view of the contents of the file or object. <br>      */ <br>      OleDoc_GetThumbnailExtent(lpOleDoc, lpsizel); <br>      // release artificial AddRef <br>      SvrDoc_OleObj_Release(lpThis); <br>      return NOERROR; <br>   } <br>#endif <br> <br>   else <br>   { <br>      // release artificial AddRef <br>      SvrDoc_OleObj_Release(lpThis); <br>      return E_FAIL; <br>   } <br>} <br> <br> <br>// IOleObject::Advise method <br> <br>STDMETHODIMP SvrDoc_OleObj_Advise( <br>      LPOLEOBJECT             lpThis, <br>      LPADVISESINK            lpAdvSink, <br>      LPDWORD                 lpdwConnection <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   HRESULT hrErr; <br>   HRESULT   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_Advise\r\n"); <br> <br>   if (lpServerDoc-&gt;m_OleDoc.m_fObjIsClosing) <br>   { <br>       //  We don't accept any more Advise's once we're closing <br>       sc = OLE_E_ADVISENOTSUPPORTED; <br>       goto error; <br>   } <br> <br>   if (lpServerDoc-&gt;m_lpOleAdviseHldr == NULL &amp;&amp; <br>      CreateOleAdviseHolder(&amp;lpServerDoc-&gt;m_lpOleAdviseHldr) != NOERROR) { <br>      sc = E_OUTOFMEMORY; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n") <br>   hrErr = lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;Advise( <br>         lpServerDoc-&gt;m_lpOleAdviseHldr, <br>         lpAdvSink, <br>         lpdwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br>   *lpdwConnection = 0; <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::Unadvise method <br> <br>STDMETHODIMP SvrDoc_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   HRESULT hrErr; <br>   HRESULT   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_Unadvise\r\n"); <br> <br>   if (lpServerDoc-&gt;m_lpOleAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::Unadvise called\r\n") </code></pre>
<p>
</p>
<pre><code>hrErr = lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;Unadvise( <br>         lpServerDoc-&gt;m_lpOleAdviseHldr, <br>         dwConnection <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::EnumAdvise method <br> <br>STDMETHODIMP SvrDoc_OleObj_EnumAdvise( <br>      LPOLEOBJECT             lpThis, <br>      LPENUMSTATDATA FAR*     lplpenumAdvise <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   HRESULT hrErr; <br>   HRESULT   sc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("SvrDoc_OleObj_EnumAdvise\r\n"); <br> <br>   /* NOTE: we must make sure to set all out parameters to NULL. */ <br>   *lplpenumAdvise = NULL; <br> <br>   if (lpServerDoc-&gt;m_lpOleAdviseHldr == NULL) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n") <br>   hrErr = lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;EnumAdvise( <br>         lpServerDoc-&gt;m_lpOleAdviseHldr, <br>         lplpenumAdvise <br>   ); <br>   OLEDBG_END2 <br> <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return hrErr; <br> <br>error: <br>   OLEDBG_END2 <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return sc; <br>} <br> <br> <br>// IOleObject::GetMiscStatus method <br> <br>STDMETHODIMP SvrDoc_OleObj_GetMiscStatus( <br>      LPOLEOBJECT             lpThis, <br>      DWORD                   dwAspect, <br>      DWORD FAR*              lpdwStatus <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocOleObjectImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   SvrDoc_OleObj_AddRef(lpThis); <br> <br>   OleDbgOut2("SvrDoc_OleObj_GetMiscStatus\r\n"); <br> <br>   /* Get our default MiscStatus for the given Aspect. this <br>   **    information is registered in the RegDB. We query the RegDB <br>   **    here to guarantee that the value returned from this method <br>   **    agrees with the values in RegDB. in this way we only have to <br>   **    maintain the info in one place (in the RegDB). Alternatively <br>   **    we could have the values hard coded here. <br>   */ <br>   OleRegGetMiscStatus((REFCLSID)&amp;CLSID_APP, dwAspect, lpdwStatus); <br> <br>   /* NOTE: check if the data copied is compatible to be <br>   **    linked by an OLE 1.0 container. it is compatible if <br>   **    either the data is an untitled document, a file, or a <br>   **    selection of data within a file. if the data is part of <br>   **    an embedded object, then it is NOT compatible to be <br>   **    linked by an OLE 1.0 container. if it is compatible then <br>   **    we must include OLEMISC_CANLINKBYOLE1 as part of the <br>   **    dwStatus flags transfered via CF_OBJECTDESCRIPTOR or <br>   **    CF_LINKSRCDESCRIPTOR. <br>   */ <br>   if (lpOutlineDoc-&gt;m_docInitType == DOCTYPE_NEW || <br>      lpOutlineDoc-&gt;m_docInitType == DOCTYPE_FROMFILE) <br>      *lpdwStatus |= OLEMISC_CANLINKBYOLE1; <br> <br>#if defined( INPLACE_SVR ) <br>   if (dwAspect == DVASPECT_CONTENT) <br>      *lpdwStatus |= (OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE); <br>#endif  // INPLACE_SVR <br> <br>   // release artificial AddRef <br>   SvrDoc_OleObj_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>// IOleObject::SetColorScheme method <br> <br>STDMETHODIMP SvrDoc_OleObj_SetColorScheme( <br>      LPOLEOBJECT             lpThis, <br>      LPLOGPALETTE            lpLogpal <br>) <br>{ <br>   OleDbgOut2("SvrDoc_OleObj_SetColorScheme\r\n"); <br> <br>   // REVIEW: NOT YET IMPLEMENTED <br> <br>   return E_NOTIMPL; <br>} <br> <br> <br>/************************************************************************* <br>** ServerDoc::IPersistStorage interface implementation <br>*************************************************************************/ <br> <br>// IPersistStorage::QueryInterface method <br> <br>STDMETHODIMP SvrDoc_PStg_QueryInterface( <br>      LPPERSISTSTORAGE        lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj); <br>} <br> <br> <br>// IPersistStorage::AddRef method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IPersistStorage"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IPersistStorage::Release method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IPersistStorage"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IPersistStorage::GetClassID method <br> <br>STDMETHODIMP SvrDoc_PStg_GetClassID( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPCLSID                 lpClassID <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_PStg_GetClassID\r\n"); <br> <br>   /* NOTE: we must be carefull to return the correct CLSID here. <br>   **    if we are currently preforming a "TreatAs (aka. ActivateAs)" <br>   **    operation then we need to return the class of the object <br>   **    written in the storage of the object. otherwise we would <br>   **    return our own class id. <br>   */ <br>   return ServerDoc_GetClassID(lpServerDoc, lpClassID); <br>} <br> <br> <br>// IPersistStorage::IsDirty method <br> <br>STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_PStg_IsDirty\r\n"); <br> <br>   if (OutlineDoc_IsModified((LPOUTLINEDOC)lpServerDoc)) <br>      return NOERROR; <br>   else <br>      return S_FALSE; <br>} <br> <br> <br> <br>// IPersistStorage::InitNew method <br> <br>STDMETHODIMP SvrDoc_PStg_InitNew( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOLESTR    lpszUserType = /*(LPOLESTR)*/FULLUSERTYPENAME; <br>   HRESULT hrErr; <br>   HRESULT sc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_PStg_InitNew\r\n") <br> <br>#if defined( SVR_TREATAS ) <br>   { <br>      LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>      CLSID       clsid; <br>      CLIPFORMAT  cfFmt; <br>      LPOLESTR       lpszType; <br> <br>      /* NOTE: if the Server is capable of supporting "TreatAs" <br>      **    (aka. ActivateAs), it must read the class that is written <br>      **    into the storage. if this class is NOT the app's own <br>      **    class ID, then this is a TreatAs operation. the server <br>      **    then must faithfully pretend to be the class that is <br>      **    written into the storage. it must also faithfully write <br>      **    the data back to the storage in the SAME format as is <br>      **    written in the storage. <br>      ** <br>      **    SVROUTL and ISVROTL can emulate each other. they have the <br>      **    simplification that they both read/write the identical <br>      **    format. thus for these apps no actual conversion of the <br>      **    native bits is actually required. <br>      */ <br>      lpServerDoc-&gt;m_clsidTreatAs = CLSID_NULL; <br>      if (OleStdGetTreatAsFmtUserType(&amp;CLSID_APP, lpStg, &amp;clsid, <br>                     (CLIPFORMAT FAR*)&amp;cfFmt, /*(LPOLESTR FAR*)*/&amp;lpszType)) { <br> <br>         if (cfFmt == lpOutlineApp-&gt;m_cfOutline) { <br>            // We should perform TreatAs operation <br>            if (lpServerDoc-&gt;m_lpszTreatAsType) <br>               OleStdFreeString(lpServerDoc-&gt;m_lpszTreatAsType, NULL); <br> <br>            lpServerDoc-&gt;m_clsidTreatAs = clsid; <br>            ((LPOUTLINEDOC)lpServerDoc)-&gt;m_cfSaveFormat = cfFmt; <br>            lpServerDoc-&gt;m_lpszTreatAsType = lpszType; <br>            lpszUserType = lpServerDoc-&gt;m_lpszTreatAsType; <br> <br>            OleDbgOut3("SvrDoc_PStg_InitNew: TreateAs ==&gt; '"); <br>//            OleDbgOutNoPrefix3(lpServerDoc-&gt;m_lpszTreatAsType); <br>            OleDbgOutNoPrefix3("'\r\n"); <br>         } else { <br>            // ERROR: we ONLY support TreatAs for CF_OUTLINE format <br>            OleDbgOut("SvrDoc_PStg_InitNew: INVALID TreatAs Format\r\n"); <br>            OleStdFreeString(lpszType, NULL); <br>         } <br>      } <br>   } <br>#endif  // SVR_TREATAS <br> <br>   /* NOTE: a server EXE object should write its format tag to its <br>   **    storage in InitNew so that the DefHandler can know the format <br>   **    of the object. this is particularly important if the objects <br>   **    uses CF_METATFILE or CF_DIB as its format. the DefHandler <br>   **    automatically avoids separately storing presentation cache <br>   **    data when the object's native data is a standard presentation <br>   **    format. <br>   */ <br>   WriteFmtUserTypeStg(lpStg,(CLIPFORMAT)lpOutlineApp-&gt;m_cfOutline,lpszUserType); <br> <br>   // set the doc to a new embedded object. <br>   if (! ServerDoc_InitNewEmbed(lpServerDoc)) { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   /* NOTE: An embedded object must guarantee that it can save <br>   **    even in low memory situations. it must be able to <br>   **    successfully save itself without consuming any additional <br>   **    memory. this means that a server is NOT supposed to open or <br>   **    create any streams or storages when <br>   **    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an <br>   **    embedded object should hold onto its storage and pre-open and <br>   **    hold open any streams that it will need later when it is time <br>   **    to save. <br>   */ <br>   hrErr = lpStg-&gt;lpVtbl-&gt;CreateStream( <br>         lpStg, <br>         OLESTR("LineList"), <br>         STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>         0, <br>         0, <br>         &amp;lpOleDoc-&gt;m_lpLLStm <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream"); <br>      OleDbgOutHResult("LineList CreateStream returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   hrErr = lpStg-&gt;lpVtbl-&gt;CreateStream( <br>         lpStg, <br>         OLESTR("NameTable"), <br>         STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>         0, <br>         0, <br>         &amp;lpOleDoc-&gt;m_lpNTStm <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream"); <br>      OleDbgOutHResult("NameTable CreateStream returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   lpOleDoc-&gt;m_lpStg = lpStg; <br> <br>   // NOTE: to be able to hold onto IStorage* pointer, we must AddRef it <br>   lpStg-&gt;lpVtbl-&gt;AddRef(lpStg); <br> <br>   OLEDBG_END2 <br> <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br> <br>   return sc; <br>} <br> <br> <br>// IPersistStorage::Load method <br> <br>STDMETHODIMP SvrDoc_PStg_Load( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   HRESULT sc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("SvrDoc_PStg_Load\r\n") <br> <br>   if (OutlineDoc_LoadFromStg((LPOUTLINEDOC)lpServerDoc, lpStg)) { <br> <br>      ((LPOUTLINEDOC)lpServerDoc)-&gt;m_docInitType = DOCTYPE_EMBEDDED; <br> <br>      /* NOTE: we need to check if the ConvertStg bit is on. if <br>      **    so, we need to clear the ConvertStg bit and mark the <br>      **    document as dirty so as to force a save when the document <br>      **    is closed. the actual conversion of the bits should be <br>      **    performed when the data is loaded from the IStorage*. in <br>      **    our case any conversion of data formats would be done in <br>      **    OutlineDoc_LoadFromStg function. in reality both SVROUTL <br>      **    and ISVROTL read and write the same format so no actual <br>      **    conversion of data bits is necessary. <br>      */ <br>      if (GetConvertStg(lpStg) == NOERROR) { <br>         SetConvertStg(lpStg, FALSE); <br> <br>         OleDbgOut3("SvrDoc_PStg_Load: ConvertStg==TRUE\r\n"); <br>         OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE); <br>      } <br> <br>   } else { <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   /* NOTE: An embedded object must guarantee that it can save <br>   **    even in low memory situations. it must be able to <br>   **    successfully save itself without consuming any additional <br>   **    memory. this means that a server is NOT supposed to open or <br>   **    create any streams or storages when <br>   **    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an <br>   **    embedded object should hold onto its storage and pre-open and <br>   **    hold open any streams that it will need later when it is time <br>   **    to save. <br>   */ <br>   if (lpOleDoc-&gt;m_lpLLStm) <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpLLStm); <br>   hrErr = lpStg-&gt;lpVtbl-&gt;OpenStream( <br>         lpStg, <br>         OLESTR("LineList"), <br>         NULL, <br>         STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>         0, <br>         &amp;lpOleDoc-&gt;m_lpLLStm <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream"); <br>      OleDbgOutHResult("LineList CreateStream returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   if (lpOleDoc-&gt;m_lpNTStm) <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpNTStm); <br>   hrErr = lpStg-&gt;lpVtbl-&gt;OpenStream( <br>         lpStg, <br>         OLESTR("NameTable"), <br>         NULL, <br>         STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>         0, <br>         &amp;lpOleDoc-&gt;m_lpNTStm <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream"); <br>      OleDbgOutHResult("NameTable CreateStream returned", hrErr); <br>      sc = hrErr; <br>      goto error; <br>   } <br> <br>   lpOleDoc-&gt;m_lpStg = lpStg; <br> <br>   // NOTE: to be able to hold onto IStorage* pointer, we must AddRef it <br>   lpStg-&gt;lpVtbl-&gt;AddRef(lpStg); <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>// IPersistStorage::Save method <br> <br>STDMETHODIMP SvrDoc_PStg_Save( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStg, <br>      BOOL                    fSameAsLoad <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   BOOL fStatus; <br>   HRESULT sc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_PStg_Save\r\n") <br> <br>   fStatus = OutlineDoc_SaveSelToStg( <br>         (LPOUTLINEDOC)lpServerDoc, <br>         NULL, <br>         lpOutlineDoc-&gt;m_cfSaveFormat, <br>         lpStg, <br>         fSameAsLoad, <br>         FALSE <br>   ); <br> <br>   if (! fStatus) { <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgPSSaveFail); <br>      sc = E_FAIL; <br>      goto error; <br>   } <br> <br>   lpServerDoc-&gt;m_fSaveWithSameAsLoad = fSameAsLoad; <br>   lpServerDoc-&gt;m_fNoScribbleMode = TRUE; <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br> <br>// IPersistStorage::SaveCompleted method <br> <br>STDMETHODIMP SvrDoc_PStg_SaveCompleted( <br>      LPPERSISTSTORAGE        lpThis, <br>      LPSTORAGE               lpStgNew <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("SvrDoc_PStg_SaveCompleted\r\n") <br> <br>   /* NOTE: this sample application is a pure server application. <br>   **    a container/server application would have to call SaveCompleted <br>   **    for each of its contained compound document objects. if a new <br>   **    storage was given, then the container/server would have to <br>   **    open the corresponding new sub-storage for each compound <br>   **    document object and pass as an argument in the SaveCompleted <br>   **    call. <br>   */ <br> <br>   /* NOTE: it is only legal to perform a Save or SaveAs operation <br>   **    on an embedded object. if the document is a file-based document <br>   **    then we can not be changed to a IStorage-base object. <br>   ** <br>   **      fSameAsLoad   lpStgNew     Type of Save     Send OnSave <br>   **    --------------------------------------------------------- <br>   **         TRUE        NULL        SAVE             YES <br>   **         TRUE        ! NULL      SAVE *           YES <br>   **         FALSE       ! NULL      SAVE AS          YES <br>   **         FALSE       NULL        SAVE COPY AS     NO <br>   ** <br>   **    * this is a strange case that is possible. it is inefficient <br>   **    for the caller; it would be better to pass lpStgNew==NULL for <br>   **    the Save operation. <br>   */ <br>   if ( ((lpServerDoc-&gt;m_fSaveWithSameAsLoad &amp;&amp; lpStgNew==NULL) || lpStgNew) <br>         &amp;&amp; (lpOutlineDoc-&gt;m_docInitType != DOCTYPE_EMBEDDED) ) { <br>      OLEDBG_END2 <br>      return E_INVALIDARG; <br>   } <br> <br>   /* NOTE: inform any linking clients that the document has been <br>   **    saved. in addition, any currently active pseudo objects <br>   **    should also inform their clients. we should only broadcast an <br>   **    OnSave notification if a Save or SaveAs operation was <br>   **    performed. we do NOT want to send the notification if a <br>   **    SaveCopyAs operation was performed. <br>   */ <br>   if (lpStgNew || lpServerDoc-&gt;m_fSaveWithSameAsLoad) { <br> <br>      /* NOTE: if IPersistStorage::Save has been called, then we <br>      **    need to clear the dirty bit and send OnSave notification. <br>      **    if HandsOffStorage is called directly without first <br>      **    calling Save, then we do NOT want to clear the dirty bit <br>      **    and send OnSave when SaveCompleted is called. <br>      */ <br>      if (lpServerDoc-&gt;m_fNoScribbleMode) { <br>         OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE); <br> <br>         ServerDoc_SendAdvise ( <br>               lpServerDoc, <br>               OLE_ONSAVE, <br>               NULL,   /* lpmkDoc -- not relevant here */ <br>               0       /* advf -- not relevant here */ <br>         ); <br>      } <br>      lpServerDoc-&gt;m_fSaveWithSameAsLoad = FALSE; <br>   } <br>   lpServerDoc-&gt;m_fNoScribbleMode = FALSE; <br> <br>   /* NOTE: An embedded object must guarantee that it can save <br>   **    even in low memory situations. it must be able to <br>   **    successfully save itself without consuming any additional <br>   **    memory. this means that a server is NOT supposed to open or <br>   **    create any streams or storages when <br>   **    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an <br>   **    embedded object should hold onto its storage and pre-open and <br>   **    hold open any streams that it will need later when it is time <br>   **    to save. if this is a SaveAs situtation, then we want to <br>   **    pre-open and hold open our streams to guarantee that a <br>   **    subsequent save will be successful in low-memory. if we fail <br>   **    to open these streams then we want to force ourself to close <br>   **    to make sure the can't make editing changes that can't be <br>   **    later saved. <br>   */ <br>   if ( lpStgNew &amp;&amp; !lpServerDoc-&gt;m_fSaveWithSameAsLoad ) { <br> <br>      // release previous streams <br>      if (lpOleDoc-&gt;m_lpLLStm) { <br>         OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpLLStm); <br>         lpOleDoc-&gt;m_lpLLStm = NULL; <br>      } <br>      if (lpOleDoc-&gt;m_lpNTStm) { <br>         OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpNTStm); <br>         lpOleDoc-&gt;m_lpNTStm = NULL; <br>      } <br>      if (lpOleDoc-&gt;m_lpStg) { <br>         OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg); <br>         lpOleDoc-&gt;m_lpStg = NULL; <br>      } <br> <br>      hrErr = lpStgNew-&gt;lpVtbl-&gt;OpenStream( <br>            lpStgNew, <br>            OLESTR("LineList"), <br>            NULL, <br>            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>            0, <br>            &amp;lpOleDoc-&gt;m_lpLLStm <br>      ); <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream"); <br>         OleDbgOutHResult("LineList CreateStream returned", hrErr); <br>         goto error; <br>      } <br> <br>      hrErr = lpStgNew-&gt;lpVtbl-&gt;OpenStream( <br>            lpStgNew, <br>            OLESTR("NameTable"), <br>            NULL, <br>            STGM_READWRITE | STGM_SHARE_EXCLUSIVE, <br>            0, <br>            &amp;lpOleDoc-&gt;m_lpNTStm <br>      ); <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream"); <br>         OleDbgOutHResult("NameTable CreateStream returned", hrErr); <br>         goto error; <br>      } <br> <br>      lpOleDoc-&gt;m_lpStg = lpStgNew; <br> <br>      // NOTE: to hold onto IStorage* pointer, we must AddRef it <br>      lpStgNew-&gt;lpVtbl-&gt;AddRef(lpStgNew); <br>   } <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br> <br>error: <br>   OLEDBG_END2 <br>   return E_OUTOFMEMORY; <br>} <br> <br> <br>// IPersistStorage::HandsOffStorage method <br> <br>STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocPersistStorageImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br> <br>   OLEDBG_BEGIN2("SvrDoc_PStg_HandsOffStorage\r\n") <br> <br>   /* NOTE: An embedded object must guarantee that it can save <br>   **    even in low memory situations. it must be able to <br>   **    successfully save itself without consuming any additional <br>   **    memory. this means that a server is NOT supposed to open or <br>   **    create any streams or storages when <br>   **    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an <br>   **    embedded object should hold onto its storage and pre-open and <br>   **    hold open any streams that it will need later when it is time <br>   **    to save. Now when HandsOffStorage is called the object must <br>   **    release its storage and any streams that is holds open. <br>   **    later when SaveCompleted is called, it will be given back its <br>   **    storage. <br>   */ <br>   if (lpOleDoc-&gt;m_lpLLStm) { <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpLLStm); <br>      lpOleDoc-&gt;m_lpLLStm = NULL; <br>   } <br>   if (lpOleDoc-&gt;m_lpNTStm) { <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpNTStm); <br>      lpOleDoc-&gt;m_lpNTStm = NULL; <br>   } <br>   if (lpOleDoc-&gt;m_lpStg) { <br>      OleStdRelease((LPUNKNOWN)lpOleDoc-&gt;m_lpStg); <br>      lpOleDoc-&gt;m_lpStg = NULL; <br>   } <br> <br>   OLEDBG_END2 <br>   return NOERROR; <br>} <br> <br> <br> <br>#if defined( SVR_TREATAS ) <br> <br>/************************************************************************* <br>** ServerDoc::IStdMarshalInfo interface implementation <br>*************************************************************************/ <br> <br>// IStdMarshalInfo::QueryInterface method <br> <br>STDMETHODIMP SvrDoc_StdMshl_QueryInterface( <br>      LPSTDMARSHALINFO        lpThis, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocStdMarshalInfoImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj); <br>} <br> <br> <br>// IStdMarshalInfo::AddRef method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocStdMarshalInfoImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgAddRefMethod(lpThis, "IStdMarshalInfo"); <br> <br>   return OleDoc_AddRef((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IStdMarshalInfo::Release method <br> <br>STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocStdMarshalInfoImpl FAR*)lpThis)-&gt;lpServerDoc; <br> <br>   OleDbgReleaseMethod(lpThis, "IStdMarshalInfo"); <br> <br>   return OleDoc_Release((LPOLEDOC)lpServerDoc); <br>} <br> <br> <br>// IStdMarshalInfo::GetClassForHandler <br> <br>STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler( <br>      LPSTDMARSHALINFO        lpThis, <br>      DWORD                   dwDestContext, <br>      LPVOID                  pvDestContext, <br>      LPCLSID                 lpClassID <br>) <br>{ <br>   LPSERVERDOC lpServerDoc = <br>         ((struct CDocStdMarshalInfoImpl FAR*)lpThis)-&gt;lpServerDoc; <br>   OleDbgOut2("SvrDoc_StdMshl_GetClassForHandler\r\n"); <br> <br>   // NOTE: we only handle LOCAL marshal context. <br>   if (dwDestContext != MSHCTX_LOCAL || pvDestContext != NULL) <br>      return E_INVALIDARG; <br> <br>   /* NOTE: we must return our REAL clsid, NOT the clsid that we <br>   **    are pretending to be if a "TreatAs" is in effect. <br>   */ <br>   *lpClassID = CLSID_APP; <br>   return NOERROR; <br>} <br>#endif  // SVR_TREATAS <br> <br> <br> <br>/************************************************************************* <br>** ServerDoc Support Functions <br>*************************************************************************/ <br> <br> <br>/* ServerDoc_Init <br> * -------------- <br> * <br> *  Initialize the fields of a new ServerDoc object. The object is initially <br> *  not associated with a file or an (Untitled) document. This function sets <br> *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the <br> *  caller should call: <br> *      1.) OutlineDoc_InitNewFile to set the ServerDoc to (Untitled) <br> *      2.) OutlineDoc_LoadFromFile to associate the ServerDoc with a file. <br> *  This function creates a new window for the document. <br> * <br> *  NOTE: the window is initially created with a NIL size. it must be <br> *        sized and positioned by the caller. also the document is initially <br> *        created invisible. the caller must call OutlineDoc_ShowWindow <br> *        after sizing it to make the document window visible. <br> */ <br>BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc) <br>{ <br>   lpServerDoc-&gt;m_cPseudoObj                   = 0; <br>   lpServerDoc-&gt;m_lpOleClientSite              = NULL; <br>   lpServerDoc-&gt;m_lpOleAdviseHldr              = NULL; <br>   lpServerDoc-&gt;m_lpDataAdviseHldr             = NULL; <br> <br>   // initialy doc does not have any storage <br>   lpServerDoc-&gt;m_fNoScribbleMode              = FALSE; <br>   lpServerDoc-&gt;m_fSaveWithSameAsLoad          = FALSE; <br>   lpServerDoc-&gt;m_szContainerApp[0]            = '\0'; <br>   lpServerDoc-&gt;m_szContainerObj[0]            = '\0'; <br>   lpServerDoc-&gt;m_nNextRangeNo                 = 0L; <br>   lpServerDoc-&gt;m_lrSrcSelOfCopy.m_nStartLine  = -1; <br>   lpServerDoc-&gt;m_lrSrcSelOfCopy.m_nEndLine    = -1; <br>   lpServerDoc-&gt;m_fDataChanged                 = FALSE; <br>   lpServerDoc-&gt;m_fSizeChanged                 = FALSE; <br>   lpServerDoc-&gt;m_fSendDataOnStop              = FALSE; <br> <br>#if defined( SVR_TREATAS ) <br>   lpServerDoc-&gt;m_clsidTreatAs                 = CLSID_NULL; <br>   lpServerDoc-&gt;m_lpszTreatAsType              = NULL; <br>#endif  // SVR_TREATAS <br> <br>#if defined( INPLACE_SVR ) <br>   lpServerDoc-&gt;m_hWndHatch                    = <br>         CreateHatchWindow( <br>               OutlineApp_GetWindow(g_lpApp), <br>               OutlineApp_GetInstance(g_lpApp) <br>         ); <br>   if (!lpServerDoc-&gt;m_hWndHatch) <br>      return FALSE; <br> <br>   lpServerDoc-&gt;m_fInPlaceActive               = FALSE; <br>   lpServerDoc-&gt;m_fInPlaceVisible              = FALSE; <br>   lpServerDoc-&gt;m_fUIActive                    = FALSE; <br>   lpServerDoc-&gt;m_lpIPData                     = NULL; <br>   lpServerDoc-&gt;m_fMenuHelpMode                = FALSE; // F1 pressed in menu <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpServerDoc-&gt;m_OleInPlaceObject, <br>         &amp;g_SvrDoc_OleInPlaceObjectVtbl, <br>         lpServerDoc <br>   ); <br>   INIT_INTERFACEIMPL( <br>         &amp;lpServerDoc-&gt;m_OleInPlaceActiveObject, <br>         &amp;g_SvrDoc_OleInPlaceActiveObjectVtbl, <br>         lpServerDoc <br>   ); <br>#endif // INPLACE_SVR <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpServerDoc-&gt;m_OleObject, <br>         &amp;g_SvrDoc_OleObjectVtbl, <br>         lpServerDoc <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpServerDoc-&gt;m_PersistStorage, <br>         &amp;g_SvrDoc_PersistStorageVtbl, <br>         lpServerDoc <br>   ); <br> <br>#if defined( SVR_TREATAS ) <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpServerDoc-&gt;m_StdMarshalInfo, <br>         &amp;g_SvrDoc_StdMarshalInfoVtbl, <br>         lpServerDoc <br>   ); <br>#endif  // SVR_TREATAS <br>   return TRUE; <br>} <br> <br> <br>/* ServerDoc_InitNewEmbed <br> * ---------------------- <br> * <br> *  Initialize the ServerDoc object to be a new embedded object document. <br> *  This function sets the docInitType to DOCTYPE_EMBED. <br> */ <br>BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc) <br>{ <br>   char szAnsiStr[256]; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br> <br>   OleDbgAssert(lpOutlineDoc-&gt;m_docInitType == DOCTYPE_UNKNOWN); <br> <br>   lpOutlineDoc-&gt;m_docInitType = DOCTYPE_EMBEDDED; <br> <br>   /* The Window title for an embedded object is constructed as <br>   **    follows: <br>   **      &lt;server app name&gt; - &lt;obj short type&gt; in &lt;cont. doc name&gt; <br>   ** <br>   **    here we construct the current document title portion of the <br>   **    name which follows the '-'. OutlineDoc_SetTitle prepends the <br>   **    "&lt;server app name&gt; - " to the document title. <br>   */ <br>   // REVIEW: this string should be loaded from string resource <br>   wsprintf(szAnsiStr, "%s in %s", <br>      (LPSTR)SHORTUSERTYPENAME, <br>      (LPSTR)DEFCONTAINERNAME); <br>   A2W (szAnsiStr, lpOutlineDoc-&gt;m_szFileName, OLEUI_CCHPATHMAX); <br>   lpOutlineDoc-&gt;m_lpszDocTitle = lpOutlineDoc-&gt;m_szFileName; <br> <br> <br>   /* NOTE: an embedding should be marked as initially dirty so <br>   **    that on close we always call IOleClientSite::SaveObject. <br>   */ <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE); <br> <br>   OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/); <br> <br>   return TRUE; <br>} <br> <br> <br>/* ServerDoc_SendAdvise <br> * -------------------- </code></pre>
<p>
</p>
<pre><code>* <br> * This function sends an advise notification on behalf of a specific <br> *  doc object to all its clients. <br> */ <br>void ServerDoc_SendAdvise( <br>      LPSERVERDOC     lpServerDoc, <br>      WORD            wAdvise, <br>      LPMONIKER       lpmkDoc, <br>      DWORD           dwAdvf <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc; <br>   LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc; <br> <br> <br>   switch (wAdvise) { <br> <br>      case OLE_ONDATACHANGE: <br> <br>         // inform clients that the data of the object has changed <br> <br>         if (lpOutlineDoc-&gt;m_nDisableDraw == 0) { <br>            /* drawing is currently enabled. inform clients that <br>            **    the data of the object has changed <br>            */ <br> <br>            lpServerDoc-&gt;m_fDataChanged = FALSE; <br> <br>            /* NOTE: we must note the time of last change <br>            **    for our object in the RunningObjectTable. <br>            **    this is used as the basis to answer <br>            **    IOleObject::IsUpToDate. we only want to note <br>            **    the change time when an actual change takes <br>            **    place. we do NOT want to set it when we are <br>            **    notifying clients of ADVF_DATAONSTOP <br>            */ <br>            if (dwAdvf == 0) <br>               OleStdNoteObjectChangeTime(lpOleDoc-&gt;m_dwRegROT); <br> <br>            if (lpServerDoc-&gt;m_lpDataAdviseHldr) { <br>               OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n"); <br>               lpServerDoc-&gt;m_lpDataAdviseHldr-&gt;lpVtbl-&gt;SendOnDataChange( <br>                     lpServerDoc-&gt;m_lpDataAdviseHldr, <br>                     (LPDATAOBJECT)&amp;lpOleDoc-&gt;m_DataObject, <br>                     0, <br>                     dwAdvf <br>               ); <br>               OLEDBG_END2 <br> <br>            } <br> <br>#if defined( INPLACE_SVR ) <br>            /* NOTE: if the ServerDoc is currently in-place UI active, <br>            **    then is it important to renegotiate the size for the <br>            **    in-place document window BEFORE sending OnDataChange <br>            **    (which will cause the window to repaint). <br>            */ <br>            if (lpServerDoc-&gt;m_fSizeChanged) { <br>               lpServerDoc-&gt;m_fSizeChanged = FALSE; <br>               if (lpServerDoc-&gt;m_fInPlaceActive) <br>                  ServerDoc_UpdateInPlaceWindowOnExtentChange(lpServerDoc); <br>            } <br>#endif <br> <br>            /* NOTE: we do NOT need to tell our pseudo objects to <br>            **    broadcast OnDataChange notification because <br>            **    they will do it automatically when an editing <br>            **    change in the document affects a PseudoObj. <br>            **    (see OutlineNameTable_AddLineUpdate, <br>            **         OutlineNameTable_DeleteLineUpdate, <br>            **    and  ServerNameTable_EditLineUpdate) <br>            */ <br> <br>         } else { <br>            /* drawing is currently disabled. do not send <br>            **    notifications or call <br>            **    IOleInPlaceObject::OnPosRectChange until drawing <br>            **    is re-enabled. <br>            */ <br>         } <br>         break; <br> <br>      case OLE_ONCLOSE: <br> <br>         // inform clients that the document is shutting down <br> <br>         if (lpServerDoc-&gt;m_lpOleAdviseHldr) { <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n"); <br>            lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnClose( <br>                  lpServerDoc-&gt;m_lpOleAdviseHldr <br>            ); <br>            OLEDBG_END2 <br>         } <br> <br>         /* NOTE: we do NOT need to tell our pseudo objects to <br>         **    broadcast OnClose notification because they will do <br>         **    it automatically when the pseudo object is closed. <br>         **    (see PseudoObj_Close) <br>         */ <br> <br>         break; <br> <br>      case OLE_ONSAVE: <br> <br>         // inform clients that the object has been saved <br> <br>         OLEDBG_BEGIN3("ServerDoc_SendAdvise ONSAVE\r\n"); <br> <br>         if (lpServerDoc-&gt;m_lpOleAdviseHldr) { <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnSave called\r\n"); <br>            lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnSave( <br>                  lpServerDoc-&gt;m_lpOleAdviseHldr <br>            ); <br>            OLEDBG_END2 <br>         } <br> <br>         /* NOTE: inform any clients of pseudo objects <br>         **    within our document, that our document has been <br>         **    saved. <br>         */ <br>         ServerNameTable_InformAllPseudoObjectsDocSaved( <br>               (LPSERVERNAMETABLE)lpOutlineDoc-&gt;m_lpNameTable, <br>               lpmkDoc <br>         ); <br>         OLEDBG_END3 <br>         break; <br> <br>      case OLE_ONRENAME: <br> <br>         // inform clients that the object's name has changed <br> <br>         OLEDBG_BEGIN3("ServerDoc_SendAdvise ONRENAME\r\n"); <br> <br>         if (lpmkDoc &amp;&amp; lpServerDoc-&gt;m_lpOleAdviseHldr) { <br>            OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n"); <br>            lpServerDoc-&gt;m_lpOleAdviseHldr-&gt;lpVtbl-&gt;SendOnRename( <br>                  lpServerDoc-&gt;m_lpOleAdviseHldr, <br>                  lpmkDoc <br>            ); <br>            OLEDBG_END2 <br>         } <br> <br>         OLEDBG_END3 <br>         break; <br>   } <br>} <br> <br> <br>/* ServerDoc_GetClassID <br>** -------------------- <br>**    Return the class ID corresponding to the bits in the storage. <br>**    normally this will be our application's given CLSID. but if a <br>**    "TreateAs (aka. ActivateAs)" operation is taking place, then our <br>**    application needs to pretend to be the class of the object that <br>**    we are emulating. this is also the class that will be written <br>**    into the storage. <br>*/ <br>HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid) <br>{ <br>#if defined( SVR_TREATAS ) <br>   if (! IsEqualCLSID(&amp;lpServerDoc-&gt;m_clsidTreatAs, &amp;CLSID_NULL)) <br>      *lpclsid = lpServerDoc-&gt;m_clsidTreatAs; <br>   else <br>#endif  // SVR_TREATAS <br>      *lpclsid = CLSID_APP; <br> <br>   return NOERROR; <br>} <br> <br> <br> <br>/* ServerDoc_UpdateMenu <br> * -------------------- <br> * <br> *  Update menu for embedding mode. the changes include: <br> *      1 Remove File/New and File/Open (SDI ONLY) <br> *      2 Change File/Save As.. to File/Save Copy As.. <br> *      3 Change File menu so it contains "Update" instead of "Save" <br> *      4 Change File/Exit to File/Exit &amp; Return to &lt;client doc&gt;" <br> */ <br>void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc) <br>{ <br>   char    str[256]; <br>   HWND    hWndMain; <br>   HMENU   hMenu; <br>   char    szAnsiStr[256]; <br> <br> <br>   OleDbgOut2("ServerDoc_UpdateMenu\r\n"); <br> <br>   hWndMain=g_lpApp-&gt;m_hWndApp; <br>   hMenu=GetMenu(hWndMain); <br> <br>#if defined( SDI_VERSION ) <br>   /* SDI ONLY: Remove File/New and File/Open */ <br>   DeleteMenu(hMenu, IDM_F_NEW, MF_BYCOMMAND); <br>   DeleteMenu(hMenu, IDM_F_OPEN, MF_BYCOMMAND); <br>#endif <br> <br>   // Change File.Save As.. to File.Save Copy As.. */ <br>   ModifyMenu(hMenu,IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save Copy As.."); <br> <br>   // Change File.Save to "&amp;Update &lt;container doc&gt;" <br>   W2A (lpServerDoc-&gt;m_szContainerObj, szAnsiStr, 256); <br>   wsprintf(str, g_szUpdateCntrDoc, szAnsiStr); <br>   ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, str); <br> <br>   // Change File/Exit to File/Exit &amp; Return to &lt;container doc&gt;" */ <br>   W2A (lpServerDoc-&gt;m_szContainerObj, szAnsiStr, 256); <br>   wsprintf(str, g_szExitNReturnToCntrDoc, szAnsiStr); <br>   ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, str); <br> <br>   DrawMenuBar(hWndMain); <br>} <br> <br>#if defined( MDI_VERSION ) <br> <br>// NOTE: ServerDoc_RestoreMenu is actually redundant because the <br>//          app is dying when the function is called.  (In SDI, the <br>//          app will terminate when the ref counter of the server doc <br>//          is zero). However, it is important for MDI. <br> <br>/* ServerDoc_RestoreMenu <br> * --------------------- <br> * <br> *      Reset the menu to non-embedding mode <br> */ <br>void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc) <br>{ <br>   LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   HWND            hWndMain; <br>   HMENU           hMenu; <br> <br> <br>   OleDbgOut2("ServerDoc_RestoreMenu\r\n"); <br> <br>   hWndMain = lpOutlineApp-&gt;m_hWndApp; <br>   hMenu = GetMenu(hWndMain); <br> <br>   /* Add back File/New, File/Open.. and File/Save */ <br>   InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING, <br>      IDM_F_NEW, "&amp;New"); <br>   InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING, <br>      IDM_F_OPEN, "&amp;Open..."); <br> <br>   /* Change File menu so it contains "Save As..." instead of */ <br>   /* "Save Copy As..." */ <br>   ModifyMenu(hMenu, IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save &amp;As.."); <br> <br>   /* Change File menu so it contains "Save" instead of "Update" */ <br>   ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, "&amp;Save"); <br> <br>   /* Change File menu so it contains "Exit" */ <br>   /* instead of just "Exit &amp; Return to &lt;client doc&gt;" */ <br>   ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, "E&amp;xit"); <br> <br>   DrawMenuBar (hWndMain); <br> <br>} <br> <br>#endif  // MDI_VERSION </code></pre>
<p>&nbsp;</p></body>
</HTML>
