<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CNTRLINE.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context275"></a>CNTRLINE.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Container Sample Code <br>** <br>**    cntrline.c <br>** <br>**    This file contains ContainerLine methods. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1997 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br> <br> <br>extern LPOUTLINEAPP         g_lpApp; <br>extern IUnknownVtbl         g_CntrLine_UnknownVtbl; <br>extern IOleClientSiteVtbl   g_CntrLine_OleClientSiteVtbl; <br>extern IAdviseSinkVtbl      g_CntrLine_AdviseSinkVtbl; <br> <br>#if defined( INPLACE_CNTR ) <br>extern IOleInPlaceSiteVtbl  g_CntrLine_OleInPlaceSiteVtbl; <br>extern BOOL g_fInsideOutContainer; <br>#endif  // INPLACE_CNTR <br> <br>// REVIEW: should use string resource for messages <br>OLECHAR ErrMsgDoVerb[] = OLESTR("OLE object action failed!"); <br> <br> <br>/* prototype for static functions */ <br>static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC); <br> <br> <br>/************************************************************************* <br>** ContainerLine <br>**    This object represents the location within the container where <br>**    the embedded/linked object lives. It exposes interfaces to the <br>**    object that allow the object to get information about its <br>**    embedding site and to announce notifications of important events <br>**    (changed, closed, saved) <br>** <br>**    The ContainerLine exposes the following interfaces: <br>**      IUnknown <br>**      IOleClientSite <br>**      IAdviseSink <br>*************************************************************************/ <br> <br> <br> <br>/************************************************************************* <br>** ContainerLine::IUnknown interface implementation <br>*************************************************************************/ <br> <br> <br>// IUnknown::QueryInterface <br>STDMETHODIMP CntrLine_Unk_QueryInterface( <br>      LPUNKNOWN           lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj); <br>} <br> <br> <br>// IUnknown::AddRef <br>STDMETHODIMP_(ULONG) CntrLine_Unk_AddRef(LPUNKNOWN lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgAddRefMethod(lpThis, "IUnknown"); <br> <br>   return ContainerLine_AddRef(lpContainerLine); <br>} <br> <br> <br>// IUnknown::Release <br>STDMETHODIMP_(ULONG) CntrLine_Unk_Release(LPUNKNOWN lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgReleaseMethod(lpThis, "IUnknown"); <br> <br>   return ContainerLine_Release(lpContainerLine); <br>} <br> <br> <br>/************************************************************************* <br>** ContainerLine::IOleClientSite interface implementation <br>*************************************************************************/ <br> <br>// IOleClientSite::QueryInterface <br>STDMETHODIMP CntrLine_CliSite_QueryInterface( <br>      LPOLECLIENTSITE     lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj); <br>} <br> <br> <br>// IOleClientSite::AddRef <br>STDMETHODIMP_(ULONG) CntrLine_CliSite_AddRef(LPOLECLIENTSITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgAddRefMethod(lpThis, "IOleClientSite"); <br> <br>   return ContainerLine_AddRef(lpContainerLine); <br>} <br> <br> <br>// IOleClientSite::Release <br>STDMETHODIMP_(ULONG) CntrLine_CliSite_Release(LPOLECLIENTSITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgReleaseMethod(lpThis, "IOleClientSite"); <br> <br>   return ContainerLine_Release(lpContainerLine); <br>} <br> <br> <br>// IOleClientSite::SaveObject <br>STDMETHODIMP CntrLine_CliSite_SaveObject(LPOLECLIENTSITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPPERSISTSTORAGE lpPersistStg = lpContainerLine-&gt;m_lpPersistStg; <br>   SCODE sc = S_OK; <br>   HRESULT hrErr; <br> <br>   OLEDBG_BEGIN2("CntrLine_CliSite_SaveObject\r\n") <br> <br>   if (! lpPersistStg) { <br>      /* NOTE: The object is NOT loaded. a container must be <br>      **    prepared for the fact that an object that it thinks it <br>      **    has unloaded may still call IOleClientSite::SaveObject. <br>      **    in this case the container should fail the save call and <br>      **    NOT try to reload the object. this scenario arises if you <br>      **    have a in-process server (DLL object) which has a <br>      **    connected linking client. even after the embedding <br>      **    container unloads the DLL object, the link connection <br>      **    keeps the object alive. it may then as part of its <br>      **    shutdown try to call IOCS::SaveObject, but then it is too <br>      **    late. <br>      */ <br>      OLEDBG_END2 <br> <br>      return E_FAIL; <br>   } <br> <br>   // mark ContainerDoc as now dirty <br>   OutlineDoc_SetModified( <br>         (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc, TRUE, TRUE, FALSE); <br> <br>   /* Tell OLE object to save itself <br>   ** NOTE: it is NOT sufficient to ONLY call <br>   **    IPersistStorage::Save method. it is also necessary to call <br>   **    WriteClassStg. the helper API OleSave does this automatically. <br>   */ <br>   OLEDBG_BEGIN2("OleSave called\r\n") <br>   hrErr=OleSave(lpPersistStg,lpContainerLine-&gt;m_lpStg, TRUE/*fSameAsLoad*/); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("WARNING: OleSave returned", hrErr); <br>      sc = hrErr; <br>   } <br> <br>   // NOTE: even if OleSave fails, SaveCompleted must be called. <br>   OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n") <br>   hrErr = lpPersistStg-&gt;lpVtbl-&gt;SaveCompleted(lpPersistStg, NULL); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr); <br>      if (sc == S_OK) <br>         sc = hrErr; <br>   } <br> <br>   OLEDBG_END2 <br>   return sc; <br>} <br> <br> <br>// IOleClientSite::GetMoniker <br>STDMETHODIMP CntrLine_CliSite_GetMoniker( <br>      LPOLECLIENTSITE     lpThis, <br>      DWORD               dwAssign, <br>      DWORD               dwWhichMoniker, <br>      LPMONIKER FAR*      lplpmk <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine; <br> <br>   lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OLEDBG_BEGIN2("CntrLine_CliSite_GetMoniker\r\n") <br> <br>   // NOTE: we must make sure to set output pointer parameters to NULL <br>   *lplpmk = NULL; <br> <br>   switch (dwWhichMoniker) { <br> <br>      case OLEWHICHMK_CONTAINER: <br>         /* NOTE: create a FileMoniker which identifies the <br>         **    entire container document. <br>         */ <br>         *lplpmk = OleDoc_GetFullMoniker( <br>               (LPOLEDOC)lpContainerLine-&gt;m_lpDoc, <br>               dwAssign <br>         ); <br>         break; <br> <br>      case OLEWHICHMK_OBJREL: <br> <br>         /* NOTE: create an ItemMoniker which identifies the <br>         **    OLE object relative to the container document. <br>         */ <br>         *lplpmk = ContainerLine_GetRelMoniker(lpContainerLine, dwAssign); <br>         break; <br> <br>      case OLEWHICHMK_OBJFULL: <br>      { <br>         /* NOTE: create an absolute moniker which identifies the <br>         **    OLE object in the container document. this moniker is <br>         **    created as a composite of the absolute moniker for the <br>         **    entire document appended with an item moniker which <br>         **    identifies the OLE object relative to the document. <br>         */ <br> <br>         *lplpmk = ContainerLine_GetFullMoniker(lpContainerLine, dwAssign); <br>         break; <br>      } <br>   } <br> <br>   OLEDBG_END2 <br> <br>   if (*lplpmk != NULL) <br>      return NOERROR; <br>   else <br>      return E_FAIL; <br>} <br> <br> <br>// IOleClientSite::GetContainer <br>STDMETHODIMP CntrLine_CliSite_GetContainer( <br>      LPOLECLIENTSITE     lpThis, <br>      LPOLECONTAINER FAR* lplpContainer <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine; <br>   HRESULT hrErr; <br> <br>   // artificial AddRef in case object is deleted during call <br>   CntrLine_CliSite_AddRef(lpThis); <br>   OLEDBG_BEGIN2("CntrLine_CliSite_GetContainer\r\n") <br> <br>   lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   hrErr = OleDoc_QueryInterface( <br>         (LPOLEDOC)lpContainerLine-&gt;m_lpDoc, <br>         &amp;IID_IOleContainer, <br>         (LPVOID FAR*)lplpContainer <br>   ); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_CliSite_Release(lpThis); <br>   return hrErr; <br>} <br> <br> <br>// IOleClientSite::ShowObject <br>STDMETHODIMP CntrLine_CliSite_ShowObject(LPOLECLIENTSITE lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br>   HWND hWndFrame = OutlineApp_GetFrameWindow(g_lpApp); <br> <br>   // artificial AddRef in case object is deleted during call <br>   CntrLine_CliSite_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_CliSite_ShowObject\r\n") <br> <br>   /* make sure our doc window is visible and not minimized. <br>   **    the OutlineDoc_ShowWindow function will cause the app window <br>   **    to show itself SW_SHOWNORMAL. <br>   */ <br>   if (! IsWindowVisible(hWndFrame) || IsIconic(hWndFrame)) <br>      OutlineDoc_ShowWindow(lpOutlineDoc); <br> <br>   BringWindowToTop(hWndFrame); <br> <br>   /* make sure that the OLE object is currently in view. if necessary <br>   **    scroll the document in order to bring it into view. <br>   */ <br>   LineList_ScrollLineIntoView(lpLL, nIndex); <br> <br>#if defined( INPLACE_CNTR ) <br>   /* after the in-place object is scrolled into view, we need to ask <br>   **    it to update its rect for the new clip rect coordinates <br>   */ <br>   ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0); <br>#endif <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_CliSite_Release(lpThis); <br>   return NOERROR; <br>} <br> <br> <br>// IOleClientSite::OnShowWindow <br>STDMETHODIMP CntrLine_CliSite_OnShowWindow(LPOLECLIENTSITE lpThis, BOOL fShow) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br> <br>   // artificial AddRef in case object is deleted during call <br>   CntrLine_CliSite_AddRef(lpThis); <br> <br>   if (fShow) { <br>      OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(TRUE)\r\n") <br> <br>      /* NOTE: we need to hatch out the OLE object now; it has <br>      **    just been opened in a window elsewhere (open editing as <br>      **    opposed to in-place activation). <br>      **    force the line to re-draw with the hatch. <br>      */ <br>      lpContainerLine-&gt;m_fObjWinOpen = TRUE; <br>      LineList_ForceLineRedraw(lpLL, nIndex, FALSE /*fErase*/); <br> <br>   } else { <br>      OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(FALSE)\r\n") <br> <br>      /* NOTE: the object associated with this container site has <br>      **    just closed its server window. we should now remove the <br>      **    hatching that indicates that the object is open <br>      **    elsewhere. also our window should now come to the top. <br>      **    force the line to re-draw without the hatch. <br>      */ <br>      lpContainerLine-&gt;m_fObjWinOpen = FALSE; <br>      LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/); <br> <br>      BringWindowToTop(lpOutlineDoc-&gt;m_hWndDoc); <br>      SetFocus(lpOutlineDoc-&gt;m_hWndDoc); <br>   } <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_CliSite_Release(lpThis); <br> <br>   return NOERROR; <br>} <br> <br> <br>// IOleClientSite::RequestNewObjectLayout <br>STDMETHODIMP CntrLine_CliSite_RequestNewObjectLayout(LPOLECLIENTSITE lpThis) <br>{ <br>   OleDbgOut2("CntrLine_CliSite_RequestNewObjectLayout\r\n"); <br> <br>   /* NOTE: this method is NOT yet used. it is for future layout <br>   **    negotiation support. <br>   */ <br>   return E_NOTIMPL; <br>} <br> <br> <br>/************************************************************************* <br>** ContainerLine::IAdviseSink interface implementation <br>*************************************************************************/ <br> <br>// IAdviseSink::QueryInterface <br>STDMETHODIMP CntrLine_AdvSink_QueryInterface( <br>      LPADVISESINK        lpThis, <br>      REFIID              riid, <br>      LPVOID FAR*         lplpvObj <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj); <br>} <br> <br> <br>// IAdviseSink::AddRef <br>STDMETHODIMP_(ULONG) CntrLine_AdvSink_AddRef(LPADVISESINK lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgAddRefMethod(lpThis, "IAdviseSink"); <br> <br>   return ContainerLine_AddRef(lpContainerLine); <br>} <br> <br> <br>// IAdviseSink::Release <br>STDMETHODIMP_(ULONG) CntrLine_AdvSink_Release (LPADVISESINK lpThis) <br>{ <br>   LPCONTAINERLINE lpContainerLine = <br>         ((struct COleClientSiteImpl FAR*)lpThis)-&gt;lpContainerLine; <br> <br>   OleDbgReleaseMethod(lpThis, "IAdviseSink"); <br> <br>   return ContainerLine_Release(lpContainerLine); <br>} <br> <br> <br>// IAdviseSink::OnDataChange <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnDataChange( <br>      LPADVISESINK        lpThis, <br>      FORMATETC FAR*      lpFormatetc, <br>      STGMEDIUM FAR*      lpStgmed <br>) <br>{ <br>   OleDbgOut2("CntrLine_AdvSink_OnDataChange\r\n"); <br>   // We are not interested in data changes (only view changes) <br>   //      (ie. nothing to do) <br>} <br> <br> <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnViewChange( <br>      LPADVISESINK        lpThis, <br>      DWORD               aspects, <br>      LONG                lindex <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine; <br>   LPOUTLINEDOC lpOutlineDoc; <br>   HWND hWndDoc; <br>   LPLINELIST lpLL; <br>   MSG msg; <br>   int nIndex; <br> <br>   // artificial AddRef in case object is destroyed during call <br>   CntrLine_AdvSink_AddRef(lpThis); <br> <br>   OLEDBG_BEGIN2("CntrLine_AdvSink_OnViewChange\r\n") <br> <br>   lpContainerLine = ((struct CAdviseSinkImpl FAR*)lpThis)-&gt;lpContainerLine; <br>   lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br> <br>   /* NOTE: at this point we simply invalidate the rectangle of <br>   **    the object to force a repaint in the future, we mark <br>   **    that the extents of the object may have changed <br>   **    (m_fDoGetExtent=TRUE), and we post a message <br>   **    (WM_U_UPDATEOBJECTEXTENT) to our document that one or more <br>   **    OLE objects may need to have their extents updated. later <br>   **    when this message is processed, the document loops through <br>   **    all lines to see if any are marked as needing an extent update. <br>   **    if infact the extents did change. this can be done by calling <br>   **    IViewObject2::GetExtent to retreive the object's current <br>   **    extents and comparing with the last known extents for the <br>   **    object. if the extents changed, then relayout space for the <br>   **    object before drawing. we postpone the check to get <br>   **    the extents now because OnViewChange is an asyncronis method, <br>   **    and we have to careful not to call any syncronis methods back <br>   **    to the object. while it WOULD be OK to call the <br>   **    IViewObject2::GetExtent method within the asyncronis <br>   **    OnViewChange method (because this method is handled by the <br>   **    object handler and never remoted), it is good practise to not <br>   **    call any object methods from within an asyncronis <br>   **    notification method. <br>   **    if there is already WM_U_UPDATEOBJECTEXTENT message waiting <br>   **    in our message queue, there is no need to post another one. <br>   **    in this way, if the server is updating quicker than we can <br>   **    keep up, we do not make unneccsary GetExtent calls. also if <br>   **    drawing is disabled, we postpone updating the extents of any <br>   **    objects until drawing is re-enabled. <br>   */ <br>   lpContainerLine-&gt;m_fDoGetExtent = TRUE; <br>   hWndDoc = OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc); <br> <br>   if (lpOutlineDoc-&gt;m_nDisableDraw == 0 &amp;&amp; <br>      ! PeekMessage(&amp;msg, hWndDoc, <br>         WM_U_UPDATEOBJECTEXTENT, WM_U_UPDATEOBJECTEXTENT, <br>         PM_NOREMOVE | PM_NOYIELD)) { <br>      PostMessage(hWndDoc, WM_U_UPDATEOBJECTEXTENT, 0, 0L); <br>   } <br> <br>   // force the modified line to redraw. <br>   lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine); <br>   LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/); <br> <br>   OLEDBG_END2 <br>   // release artificial AddRef <br>   CntrLine_AdvSink_Release(lpThis); <br>} <br> <br> <br>// IAdviseSink::OnRename <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnRename( <br>      LPADVISESINK        lpThis, <br>      LPMONIKER           lpmk <br>) <br>{ <br>   OleDbgOut2("CntrLine_AdvSink_OnRename\r\n"); <br>   /* NOTE: the Embedding Container has nothing to do here. this <br>   **    notification is important for linking situations. it tells <br>   **    the OleLink objects to update their moniker because the <br>   **    source object has been renamed (track the link source). <br>   */ <br>} <br> <br> <br>// IAdviseSink::OnSave <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnSave(LPADVISESINK lpThis) <br>{ <br>   OleDbgOut2("CntrLine_AdvSink_OnSave\r\n"); <br>   /* NOTE: the Embedding Container has nothing to do here. this <br>   **    notification is only useful to clients which have set up a <br>   **    data cache with the ADVFCACHE_ONSAVE flag. <br>   */ <br>} <br> <br> <br>// IAdviseSink::OnClose <br>STDMETHODIMP_(void) CntrLine_AdvSink_OnClose(LPADVISESINK lpThis) <br>{ <br>   OleDbgOut2("CntrLine_AdvSink_OnClose\r\n"); <br>   /* NOTE: the Embedding Container has nothing to do here. this <br>   **    notification is important for the OLE's default object handler <br>   **    and the OleLink object. it tells them the remote object is <br>   **    shutting down. <br>   */ <br>} <br> <br> <br>/************************************************************************* <br>** ContainerLine Support Functions <br>*************************************************************************/ <br> <br> <br>/* ContainerLine_Init <br>** ------------------ <br>**  Initialize fields in a newly constructed ContainerLine line object. <br>**  NOTE: ref cnt of ContainerLine initialized to 0 <br>*/ <br>void ContainerLine_Init(LPCONTAINERLINE lpContainerLine, int nTab, HDC hDC) <br>{ <br>   Line_Init((LPLINE)lpContainerLine, nTab, hDC);  // init base class fields <br> <br>   ((LPLINE)lpContainerLine)-&gt;m_lineType           = CONTAINERLINETYPE; <br>   ((LPLINE)lpContainerLine)-&gt;m_nWidthInHimetric   = DEFOBJWIDTH; <br>   ((LPLINE)lpContainerLine)-&gt;m_nHeightInHimetric  = DEFOBJHEIGHT; <br>   lpContainerLine-&gt;m_cRef                         = 0; <br>   lpContainerLine-&gt;m_szStgName[0]                 = '\0'; <br>   lpContainerLine-&gt;m_fObjWinOpen                  = FALSE; <br>   lpContainerLine-&gt;m_fMonikerAssigned             = FALSE; <br>   lpContainerLine-&gt;m_dwDrawAspect                 = DVASPECT_CONTENT; <br> <br>   lpContainerLine-&gt;m_fGuardObj                    = FALSE; <br>   lpContainerLine-&gt;m_fDoGetExtent                 = FALSE; <br>   lpContainerLine-&gt;m_fDoSetExtent                 = FALSE; <br>   lpContainerLine-&gt;m_sizeInHimetric.cx            = -1; <br>   lpContainerLine-&gt;m_sizeInHimetric.cy            = -1; <br> <br>   lpContainerLine-&gt;m_lpStg                        = NULL; <br>   lpContainerLine-&gt;m_lpDoc                        = NULL; <br>   lpContainerLine-&gt;m_lpOleObj                     = NULL; <br>   lpContainerLine-&gt;m_lpViewObj2                   = NULL; <br>   lpContainerLine-&gt;m_lpPersistStg                 = NULL; <br>   lpContainerLine-&gt;m_lpOleLink                    = NULL; <br>   lpContainerLine-&gt;m_dwLinkType                   = 0; <br>   lpContainerLine-&gt;m_fLinkUnavailable             = FALSE; <br>   lpContainerLine-&gt;m_lpszShortType                = NULL; <br> <br>#if defined( INPLACE_CNTR ) <br>   lpContainerLine-&gt;m_fIpActive                    = FALSE; <br>   lpContainerLine-&gt;m_fUIActive                    = FALSE; <br>   lpContainerLine-&gt;m_fIpVisible                   = FALSE; <br>   lpContainerLine-&gt;m_lpOleIPObj                   = NULL; <br>   lpContainerLine-&gt;m_fInsideOutObj                = FALSE; <br>   lpContainerLine-&gt;m_fIpChangesUndoable           = FALSE; <br>   lpContainerLine-&gt;m_fIpServerRunning             = FALSE; <br>   lpContainerLine-&gt;m_hWndIpObject                 = NULL; <br>   lpContainerLine-&gt;m_nHorizScrollShift            = 0; <br>#endif  // INPLACE_CNTR <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerLine-&gt;m_Unknown, <br>         &amp;g_CntrLine_UnknownVtbl, <br>         lpContainerLine <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerLine-&gt;m_OleClientSite, <br>         &amp;g_CntrLine_OleClientSiteVtbl, <br>         lpContainerLine <br>   ); <br> <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerLine-&gt;m_AdviseSink, <br>         &amp;g_CntrLine_AdviseSinkVtbl, <br>         lpContainerLine <br>   ); <br> <br>#if defined( INPLACE_CNTR ) <br>   INIT_INTERFACEIMPL( <br>         &amp;lpContainerLine-&gt;m_OleInPlaceSite, <br>         &amp;g_CntrLine_OleInPlaceSiteVtbl, <br>         lpContainerLine <br>   ); <br>#endif  // INPLACE_CNTR <br>} <br> <br> <br>/* Setup the OLE object associated with the ContainerLine */ <br>BOOL ContainerLine_SetupOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict <br>) <br>{ <br>   DWORD dwDrawAspect = (fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT); <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br> <br>   /* Cache a pointer to the IViewObject2* interface. *Required* <br>   **      we need this everytime we draw the object. <br>   ** <br>   ** NOTE: We require the object to support IViewObject2 <br>   **    interface. this is an extension to the IViewObject interface <br>   **    that was added with the OLE 2.01 release. This interface must <br>   **    be supported by all object handlers and DLL-based objects. <br>   */ <br>   lpContainerLine-&gt;m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IViewObject2); <br>   if (! lpContainerLine-&gt;m_lpViewObj2) { <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz( <br>         lpContainerLine-&gt;m_lpViewObj2,"IViewObject2 NOT supported\r\n"); <br>#endif <br>      return FALSE; <br>   } <br> <br>   // Cache a pointer to the IPersistStorage* interface. *Required* <br>   //      we need this everytime we save the object. <br>   lpContainerLine-&gt;m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IPersistStorage); <br>   if (! lpContainerLine-&gt;m_lpPersistStg) { <br>      OleDbgAssert(lpContainerLine-&gt;m_lpPersistStg); <br>      return FALSE; <br>   } <br> <br>   // Cache a pointer to the IOleLink* interface if supported. *Optional* <br>   //      if supported the object is a link. we need this to manage the link <br>   lpContainerLine-&gt;m_lpOleLink = (LPOLELINK)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IOleLink); <br>   if (lpContainerLine-&gt;m_lpOleLink) { <br>      OLEDBG_BEGIN2("IOleLink::GetUpdateOptions called\r\n") <br>      lpContainerLine-&gt;m_lpOleLink-&gt;lpVtbl-&gt;GetUpdateOptions( <br>            lpContainerLine-&gt;m_lpOleLink, &amp;lpContainerLine-&gt;m_dwLinkType); <br>      OLEDBG_END2 <br>   } else <br>      lpContainerLine-&gt;m_dwLinkType = 0;  // NOT a link <br> <br>   /* get the short user type name of the object. this <br>   **    is used all the time when we have to build the object <br>   **    verb menu. we will cache this information to make it <br>   **    quicker to build the verb menu. <br>   */ <br>   OleDbgAssert(lpContainerLine-&gt;m_lpszShortType == NULL); <br>   OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n") <br>   lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         USERCLASSTYPE_SHORT, <br>         /*(LPOLESTR FAR*)*/&amp;lpContainerLine-&gt;m_lpszShortType <br>   ); <br>   OLEDBG_END2 <br> <br>   /* Perform that standard setup for the OLE object. this includes: <br>   **      setup View advise <br>   **      Call IOleObject::SetHostNames <br>   **      Call OleSetContainedObject <br>   */ <br>   OleStdSetupAdvises( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         dwDrawAspect, <br>         /*(LPOLESTR)*/APPNAME, <br>         lpOutlineDoc-&gt;m_lpszDocTitle, <br>         (LPADVISESINK)&amp;lpContainerLine-&gt;m_AdviseSink, <br>         TRUE    /*fCreate*/ <br>   ); <br> <br>#if defined( INPLACE_CNTR ) <br>   /* NOTE: (INSIDE-OUT CONTAINER) An inside-out container should <br>   **    check if the object is an inside-out and prefers to be <br>   **    activated when visible type of object. if not the object <br>   **    should not be allowed to keep its window up after it gets <br>   **    UIDeactivated. <br>   */ <br>   if (g_fInsideOutContainer) { <br>      DWORD mstat; <br>      OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n") <br>      lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            DVASPECT_CONTENT, <br>            (DWORD FAR*)&amp;mstat <br>      ); <br>      OLEDBG_END2 <br> <br>      lpContainerLine-&gt;m_fInsideOutObj = (BOOL) <br>            (mstat &amp; (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE)); <br>   } <br>#endif  // INPLACE_CNTR <br> <br>   if (fDisplayAsIcon) { <br>      /* user has requested to display icon aspect instead of content <br>      **    aspect. <br>      **    NOTE: we do not have to delete the previous aspect cache <br>      **    because one did not get set up. <br>      */ <br>      OleStdSwitchDisplayAspect( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            &amp;lpContainerLine-&gt;m_dwDrawAspect, <br>            dwDrawAspect, <br>            hMetaPict, <br>            FALSE,  /* fDeleteOldAspect */ <br>            TRUE,   /* fSetupViewAdvise */ <br>            (LPADVISESINK)&amp;lpContainerLine-&gt;m_AdviseSink, <br>            NULL /*fMustUpdate*/        // this can be ignored; update <br>                                 // for switch to icon not req'd <br>      ); <br>   } <br>   return TRUE; <br>} <br> <br> <br>/* Create an ContainerLine object and return the pointer */ <br>LPCONTAINERLINE ContainerLine_Create( <br>      DWORD                   dwOleCreateType, <br>      HDC                     hDC, <br>      UINT                    nTab, <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPCLSID                 lpclsid, <br>      LPOLESTR                lpszFileName, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPOLESTR                lpszStgName <br>) <br>{ <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   LPOLEOBJECT     lpObj = NULL; <br>   LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc); <br>   DWORD           dwDrawAspect = <br>                  (fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT); <br>   DWORD           dwOleRenderOpt = <br>                  (fDisplayAsIcon ? OLERENDER_NONE : OLERENDER_DRAW); <br>   HRESULT         hrErr; <br> <br>   OLEDBG_BEGIN3("ContainerLine_Create\r\n") <br> <br>   if (lpDocStg == NULL) { <br>      OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL"); <br>      goto error; <br>   } <br> <br>   lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE)); <br>   if (lpContainerLine == NULL) { <br>      OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine"); <br>      goto error; <br>   } <br> <br>   ContainerLine_Init(lpContainerLine, nTab, hDC); <br> <br>   /* NOTE: in order to avoid re-entrancy we will set a flag to <br>   **    guard our object. if this guard is set, then the object is <br>   **    not ready to have any OLE interface methods called. it is <br>   **    necessary to guard the object this way while it is being <br>   **    created or loaded. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = TRUE; <br> <br>   /* NOTE: In order to have a stable ContainerLine object we must <br>   **    AddRef the object's refcnt. this will be later released when <br>   **    the ContainerLine is deleted. <br>   */ <br>   ContainerLine_AddRef(lpContainerLine); <br> <br>   OLESTRCPY(lpContainerLine-&gt;m_szStgName, lpszStgName); <br>   lpContainerLine-&gt;m_lpDoc = lpContainerDoc; <br> <br>   /* Create a new storage for the object inside the doc's storage */ <br>   lpContainerLine-&gt;m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName); <br>   if (lpContainerLine-&gt;m_lpStg == NULL) { <br>      OleDbgAssert(lpContainerLine-&gt;m_lpStg != NULL); <br>      goto error; <br>   } <br> <br>   lpContainerLine-&gt;m_dwLinkType = 0; <br> <br>   switch (dwOleCreateType) { <br> <br>      case IOF_SELECTCREATENEW: <br> <br>         OLEDBG_BEGIN2("OleCreate called\r\n") <br>         hrErr = OleCreate ( <br>               lpclsid, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               NULL, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreate returned", hrErr); <br>#endif <br> <br>         break; <br> <br>      case IOF_SELECTCREATEFROMFILE: <br> <br>         OLEDBG_BEGIN2("OleCreateFromFile called\r\n") <br>         hrErr = OleCreateFromFile ( <br>               &amp;CLSID_NULL, <br>               lpszFileName, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               NULL, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreateFromFile returned", hrErr); </code></pre>
<p>
</p>
<pre><code>#endif <br>         break; <br> <br>      case IOF_CHECKLINK: <br> <br>         OLEDBG_BEGIN2("OleCreateLinkToFile called\r\n") <br>         hrErr = OleCreateLinkToFile ( <br>               lpszFileName, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               NULL, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreateLinkToFile returned", hrErr); <br>#endif <br>         break; <br>   } <br>   if (hrErr != NOERROR) <br>      goto error; <br> <br>   if (! ContainerLine_SetupOleObject( <br>                        lpContainerLine, fDisplayAsIcon, hMetaPict)) { <br>      goto error; <br>   } <br> <br>   /* NOTE: clear our re-entrancy guard. the object is now ready <br>   **    to have interface methods called. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = FALSE; <br> <br>   OLEDBG_END3 <br>   return lpContainerLine; <br> <br>error: <br>   OutlineApp_ErrorMessage(g_lpApp, OLESTR("Could not create object!")); <br> <br>   // Destroy partially created OLE object <br>   if (lpContainerLine) <br>      ContainerLine_Delete(lpContainerLine); <br>   OLEDBG_END3 <br>   return NULL; <br>} <br> <br> <br>LPCONTAINERLINE ContainerLine_CreateFromData( <br>      HDC                     hDC, <br>      UINT                    nTab, <br>      LPCONTAINERDOC          lpContainerDoc, <br>      LPDATAOBJECT            lpSrcDataObj, <br>      DWORD                   dwCreateType, <br>      CLIPFORMAT              cfFormat, <br>      BOOL                    fDisplayAsIcon, <br>      HGLOBAL                 hMetaPict, <br>      LPOLESTR                lpszStgName <br>) <br>{ <br>   HGLOBAL         hData = NULL; <br>   LPCONTAINERLINE lpContainerLine = NULL; <br>   LPOLEOBJECT     lpObj = NULL; <br>   LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc); <br>   DWORD           dwDrawAspect = <br>                  (fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT); <br>   DWORD           dwOleRenderOpt; <br>   FORMATETC       renderFmtEtc; <br>   LPFORMATETC     lpRenderFmtEtc = NULL; <br>   HRESULT         hrErr; <br>   LPUNKNOWN       lpUnk = NULL; <br> <br>   OLEDBG_BEGIN3("ContainerLine_CreateFromData\r\n") <br> <br>   if (dwCreateType == OLECREATEFROMDATA_STATIC &amp;&amp; cfFormat != 0) { <br>      // a particular type of static object should be created <br> <br>      dwOleRenderOpt = OLERENDER_FORMAT; <br>      lpRenderFmtEtc = (LPFORMATETC)&amp;renderFmtEtc; <br> <br>      if (cfFormat == CF_METAFILEPICT) <br>         SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_MFPICT); <br>      else if (cfFormat == CF_BITMAP) <br>         SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_GDI); <br>      else <br>         SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_HGLOBAL); <br> <br>   } else if (dwCreateType == OLECREATEFROMDATA_STATIC &amp;&amp; fDisplayAsIcon) { <br>      // a link that currently displayed as an icon needs to be <br>      // converted to a STATIC picture object. this case is driven <br>      // from "BreakLink" in the "Links" dialog. because the current <br>      // data in the source object's cache is DVASPECT_ICON we need <br>      // to tell the OleCreateStaticFromData API to look for <br>      // DVASPECT_ICON data. the static object that results however, <br>      // is considered to be displayed in the DVASPECT_CONTENT view. <br> <br>      dwOleRenderOpt = OLERENDER_DRAW; <br>      lpRenderFmtEtc = (LPFORMATETC)&amp;renderFmtEtc; <br>      SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1); <br>      dwDrawAspect = DVASPECT_CONTENT;   // static obj displays only CONTENT <br> <br>   } else if (fDisplayAsIcon &amp;&amp; hMetaPict) { <br>      // a special icon should be used. first we create the object <br>      // OLERENDER_NONE and then we stuff the special icon into the cache. <br> <br>      dwOleRenderOpt = OLERENDER_NONE; <br> <br>   } else if (fDisplayAsIcon &amp;&amp; hMetaPict == NULL) { <br>      // the object's default icon should be used <br> <br>      dwOleRenderOpt = OLERENDER_DRAW; <br>      lpRenderFmtEtc = (LPFORMATETC)&amp;renderFmtEtc; <br>      SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1); <br> <br>   } else { <br>      // create standard DVASPECT_CONTENT/OLERENDER_DRAW object <br>      dwOleRenderOpt = OLERENDER_DRAW; <br>   } <br> <br>   if (lpDocStg == NULL) { <br>      OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL"); <br>      goto error; <br>   } <br> <br>   lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE)); <br>   if (lpContainerLine == NULL) { <br>      OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine"); <br>      goto error; <br>   } <br> <br>   ContainerLine_Init(lpContainerLine, nTab, hDC); <br> <br>   /* NOTE: in order to avoid re-entrancy we will set a flag to <br>   **    guard our object. if this guard is set, then the object is <br>   **    not ready to have any OLE interface methods called. it is <br>   **    necessary to guard the object this way while it is being <br>   **    created or loaded. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = TRUE; <br> <br>   /* NOTE: In order to have a stable ContainerLine object we must <br>   **    AddRef the object's refcnt. this will be later released when <br>   **    the ContainerLine is deleted. <br>   */ <br>   ContainerLine_AddRef(lpContainerLine); <br> <br>   OLESTRCPY(lpContainerLine-&gt;m_szStgName, lpszStgName); <br>   lpContainerLine-&gt;m_lpDoc = lpContainerDoc; <br> <br>   /* Create a new storage for the object inside the doc's storage */ <br>   lpContainerLine-&gt;m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName); <br>   if (lpContainerLine-&gt;m_lpStg == NULL) { <br>      OleDbgAssert(lpContainerLine-&gt;m_lpStg != NULL); <br>      goto error; <br>   } <br> <br>   switch (dwCreateType) { <br> <br>      case OLECREATEFROMDATA_LINK: <br> <br>         OLEDBG_BEGIN2("OleCreateLinkFromData called\r\n") <br>         hrErr = OleCreateLinkFromData ( <br>               lpSrcDataObj, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               lpRenderFmtEtc, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreateLinkFromData returned", hrErr); <br>#endif <br>         break; <br> <br>      case OLECREATEFROMDATA_OBJECT: <br> <br>         OLEDBG_BEGIN2("OleCreateFromData called\r\n") <br>         hrErr = OleCreateFromData ( <br>               lpSrcDataObj, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               lpRenderFmtEtc, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreateFromData returned", hrErr); <br>#endif <br>         break; <br> <br>      case OLECREATEFROMDATA_STATIC: <br> <br>         OLEDBG_BEGIN2("OleCreateStaticFromData called\r\n") <br>         hrErr = OleCreateStaticFromData ( <br>               lpSrcDataObj, <br>               &amp;IID_IOleObject, <br>               dwOleRenderOpt, <br>               lpRenderFmtEtc, <br>               (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>               lpContainerLine-&gt;m_lpStg, <br>               (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>         ); <br>         OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>         if (hrErr != NOERROR) <br>            OleDbgOutHResult("OleCreateStaticFromData returned", hrErr); <br>#endif <br>         break; <br>   } <br> <br>   if (hrErr != NOERROR) <br>      goto error; <br> <br>   if (! ContainerLine_SetupOleObject( <br>                        lpContainerLine, fDisplayAsIcon, hMetaPict)) { <br>      goto error; <br>   } <br> <br>   /* NOTE: clear our re-entrancy guard. the object is now ready <br>   **    to have interface methods called. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = FALSE; <br> <br>   OLEDBG_END3 <br>   return lpContainerLine; <br> <br>error: <br>   OutlineApp_ErrorMessage(g_lpApp, OLESTR("Could not create object!")); <br>   // Destroy partially created OLE object <br>   if (lpContainerLine) <br>      ContainerLine_Delete(lpContainerLine); <br>   OLEDBG_END3 <br>   return NULL; <br>} <br> <br> <br>/* ContainerLine_AddRef <br>** -------------------- <br>** <br>**  increment the ref count of the line object. <br>** <br>**    Returns the new ref count on the object <br>*/ <br>ULONG ContainerLine_AddRef(LPCONTAINERLINE lpContainerLine) <br>{ <br>   ++lpContainerLine-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgOutRefCnt4( <br>         "ContainerLine_AddRef: cRef++\r\n", <br>         lpContainerLine, <br>         lpContainerLine-&gt;m_cRef <br>   ); <br>#endif <br>   return lpContainerLine-&gt;m_cRef; <br>} <br> <br> <br>/* ContainerLine_Release <br>** --------------------- <br>** <br>**  decrement the ref count of the line object. <br>**    if the ref count goes to 0, then the line is destroyed. <br>** <br>**    Returns the remaining ref count on the object <br>*/ <br>ULONG ContainerLine_Release(LPCONTAINERLINE lpContainerLine) <br>{ <br>   ULONG cRef; <br> <br>   /********************************************************************* <br>   ** NOTE: when the obj refcnt == 0, then destroy the object.     ** <br>   **     otherwise the object is still in use.                        ** <br>   *********************************************************************/ <br> <br>   cRef = --lpContainerLine-&gt;m_cRef; <br> <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz( <br>         lpContainerLine-&gt;m_cRef &gt;= 0,"Release called with cRef == 0"); <br> <br>   OleDbgOutRefCnt4( <br>         "ContainerLine_Release: cRef--\r\n", <br>         lpContainerLine, <br>         cRef <br>   ); <br>#endif <br>   if (cRef == 0) <br>      ContainerLine_Destroy(lpContainerLine); <br> <br>   return cRef; <br>} <br> <br> <br>/* ContainerLine_QueryInterface <br>** ---------------------------- <br>** <br>** Retrieve a pointer to an interface on the ContainerLine object. <br>** <br>**    Returns NOERROR if interface is successfully retrieved. <br>**            E_NOINTERFACE if the interface is not supported <br>*/ <br>HRESULT ContainerLine_QueryInterface( <br>      LPCONTAINERLINE         lpContainerLine, <br>      REFIID                  riid, <br>      LPVOID FAR*             lplpvObj <br>) <br>{ <br>   SCODE sc = E_NOINTERFACE; <br> <br>   /* NOTE: we must make sure to set all out ptr parameters to NULL. */ <br>   *lplpvObj = NULL; <br> <br>   if (IsEqualIID(riid, &amp;IID_IUnknown)) { <br>      OleDbgOut4("ContainerLine_QueryInterface: IUnknown* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpContainerLine-&gt;m_Unknown; <br>      ContainerLine_AddRef(lpContainerLine); <br>      sc = S_OK; <br>   } <br>   else if (IsEqualIID(riid, &amp;IID_IOleClientSite)) { <br>      OleDbgOut4("ContainerLine_QueryInterface: IOleClientSite* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpContainerLine-&gt;m_OleClientSite; <br>      ContainerLine_AddRef(lpContainerLine); <br>      sc = S_OK; <br>   } <br>   else if (IsEqualIID(riid, &amp;IID_IAdviseSink)) { <br>      OleDbgOut4("ContainerLine_QueryInterface: IAdviseSink* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpContainerLine-&gt;m_AdviseSink; <br>      ContainerLine_AddRef(lpContainerLine); <br>      sc = S_OK; <br>   } <br>#if defined( INPLACE_CNTR ) <br>   else if (IsEqualIID(riid, &amp;IID_IOleWindow) <br>          || IsEqualIID(riid, &amp;IID_IOleInPlaceSite)) { <br>      OleDbgOut4("ContainerLine_QueryInterface: IOleInPlaceSite* RETURNED\r\n"); <br> <br>      *lplpvObj = (LPVOID) &amp;lpContainerLine-&gt;m_OleInPlaceSite; <br>      ContainerLine_AddRef(lpContainerLine); <br>      sc = S_OK; <br>   } <br>#endif  // INPLACE_CNTR <br> <br>   OleDbgQueryInterfaceMethod(*lplpvObj); <br> <br>   return sc; <br>} <br> <br> <br>BOOL ContainerLine_LoadOleObject(LPCONTAINERLINE lpContainerLine) <br>{ <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerLine-&gt;m_lpDoc); <br>   LPOLECLIENTSITE lpOleClientSite; <br>   LPMONIKER       lpmkObj; <br>   LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp; <br>   BOOL            fPrevEnable1; <br>   BOOL            fPrevEnable2; <br>   HRESULT         hrErr; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) <br>      return FALSE;                // object in process of creation <br> <br>   if (lpContainerLine-&gt;m_lpOleObj) <br>      return TRUE;                // object already loaded <br> <br>   OLEDBG_BEGIN3("ContainerLine_LoadOleObject\r\n") <br> <br>   /* NOTE: in order to avoid re-entrancy we will set a flag to <br>   **    guard our object. if this guard is set, then the object is <br>   **    not ready to have any OLE interface methods called. it is <br>   **    necessary to guard the object this way while it is being <br>   **    created or loaded. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = TRUE; <br> <br>   /* if object storage is not already open, then open it */ <br>   if (! lpContainerLine-&gt;m_lpStg) { <br>      lpContainerLine-&gt;m_lpStg = OleStdOpenChildStorage( <br>            lpDocStg, <br>            lpContainerLine-&gt;m_szStgName, <br>            STGM_READWRITE <br>      ); <br>      if (lpContainerLine-&gt;m_lpStg == NULL) { <br>         OleDbgAssert(lpContainerLine-&gt;m_lpStg != NULL); <br>         goto error; <br>      } <br>   } <br> <br>   /* NOTE: if the OLE object being loaded is in a data transfer <br>   **    document, then we should NOT pass a IOleClientSite* pointer <br>   **    to the OleLoad call. This particularly critical if the OLE <br>   **    object is an OleLink object. If a non-NULL client site is <br>   **    passed to the OleLoad function, then the link will bind to <br>   **    the source if its is running. in the situation that we are <br>   **    loading the object as part of a data transfer document we do <br>   **    not want this connection to be established. even worse, if <br>   **    the link source is currently blocked or busy, then this could <br>   **    hang the system. it is simplest to never pass a <br>   **    IOleClientSite* when loading an object in a data transfer <br>   **    document. <br>   */ <br>   lpOleClientSite = (lpOutlineDoc-&gt;m_fDataTransferDoc ? <br>         NULL : (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite); <br> <br>   /* NOTE: we do not want to ever give the Busy/NotResponding <br>   **    dialogs when we are loading an object. if the object is a <br>   **    link, it will attempt to BindIfRunning to the link source. if <br>   **    the link source is currently busy, this could cause the Busy <br>   **    dialog to come up. even if the link source is busy, <br>   **    we do not want put up the busy dialog. thus we will disable <br>   **    the dialog and later re-enable them <br>   */ <br>   OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>   OLEDBG_BEGIN2("OleLoad called\r\n") <br>   hrErr = OleLoad ( <br>         lpContainerLine-&gt;m_lpStg, <br>         &amp;IID_IOleObject, <br>         lpOleClientSite, <br>         (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>   ); <br>   OLEDBG_END2 <br> <br>   // re-enable the Busy/NotResponding dialogs <br>   OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr == NOERROR, "Could not load object!"); <br>      OleDbgOutHResult("OleLoad returned", hrErr); <br>      goto error; <br>   } <br> <br>   /* Cache a pointer to the IViewObject2* interface. *Required* <br>   **      we need this everytime we draw the object. <br>   ** <br>   ** NOTE: We require the object to support IViewObject2 <br>   **    interface. this is an extension to the IViewObject interface <br>   **    that was added with the OLE 2.01 release. This interface must <br>   **    be supported by all object handlers and DLL-based objects. <br>   */ <br>   lpContainerLine-&gt;m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IViewObject2); <br>   if (! lpContainerLine-&gt;m_lpViewObj2) { <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz( <br>         lpContainerLine-&gt;m_lpViewObj2,"IViewObject2 NOT supported\r\n"); <br>#endif <br>      goto error; <br>   } <br> <br>   // Cache a pointer to the IPersistStorage* interface. *Required* <br>   //      we need this everytime we save the object. <br>   lpContainerLine-&gt;m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface( <br>         (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IPersistStorage); <br>   if (! lpContainerLine-&gt;m_lpPersistStg) { <br>      OleDbgAssert(lpContainerLine-&gt;m_lpPersistStg); <br>      goto error; <br>   } <br> <br>   // Cache a pointer to the IOleLink* interface if supported. *Optional* <br>   //      if supported the object is a link. we need this to manage the link <br>   if (lpContainerLine-&gt;m_dwLinkType != 0) { <br>      lpContainerLine-&gt;m_lpOleLink = (LPOLELINK)OleStdQueryInterface( <br>            (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, &amp;IID_IOleLink); <br>      if (! lpContainerLine-&gt;m_lpOleLink) { <br>         OleDbgAssert(lpContainerLine-&gt;m_lpOleLink); <br>         goto error; <br>      } <br>   } <br> <br>   /* NOTE: clear our re-entrancy guard. the object is now ready <br>   **    to have interface methods called. <br>   */ <br>   lpContainerLine-&gt;m_fGuardObj = FALSE; <br> <br>   /* NOTE: similarly, if the OLE object being loaded is in a data <br>   **    transfer document, then we do NOT need to setup any advises, <br>   **    call SetHostNames, SetMoniker, etc. <br>   */ <br>   if (lpOleClientSite) { <br>      /* Setup the Advises (OLE notifications) that we are interested <br>      ** in receiving. <br>      */ <br>      OleStdSetupAdvises( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            lpContainerLine-&gt;m_dwDrawAspect, <br>            /*(LPOLESTR)*/APPNAME, <br>            lpOutlineDoc-&gt;m_lpszDocTitle, <br>            (LPADVISESINK)&amp;lpContainerLine-&gt;m_AdviseSink, <br>            FALSE   /*fCreate*/ <br>      ); <br> <br>      /* NOTE: if the OLE object has a moniker assigned, we need to <br>      **    inform the object by calling IOleObject::SetMoniker. this <br>      **    will force the OLE object to register in the <br>      **    RunningObjectTable when it enters the running state. <br>      */ <br>      if (lpContainerLine-&gt;m_fMonikerAssigned) { <br>         lpmkObj = ContainerLine_GetRelMoniker( <br>               lpContainerLine, <br>               GETMONIKER_ONLYIFTHERE <br>         ); <br> <br>         if (lpmkObj) { <br>            OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n") <br>            lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetMoniker( <br>                  lpContainerLine-&gt;m_lpOleObj, <br>                  OLEWHICHMK_OBJREL, <br>                  lpmkObj <br>            ); <br>            OLEDBG_END2 <br>            OleStdRelease((LPUNKNOWN)lpmkObj); <br>         } <br>      } <br> <br>      /* get the Short form of the user type name of the object. this <br>      **    is used all the time when we have to build the object <br>      **    verb menu. we will cache this information to make it <br>      **    quicker to build the verb menu. <br>      */ <br>      OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n") <br>      lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            USERCLASSTYPE_SHORT, <br>            /*(LPOLESTR FAR*)*/&amp;lpContainerLine-&gt;m_lpszShortType <br>      ); <br>      OLEDBG_END2 <br> <br>#if defined( INPLACE_CNTR ) <br>      /* NOTE: an inside-out container should check if the object <br>      **    is an inside-out and prefers to be activated when visible <br>      **    type of object. if so, the object should be immediately <br>      **    activated in-place, BUT NOT UIActived. <br>      */ <br>      if (g_fInsideOutContainer &amp;&amp; <br>            lpContainerLine-&gt;m_dwDrawAspect == DVASPECT_CONTENT) { <br>         DWORD mstat; <br>         OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n") <br>         lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               DVASPECT_CONTENT, <br>               (DWORD FAR*)&amp;mstat <br>         ); <br>         OLEDBG_END2 <br> <br>         lpContainerLine-&gt;m_fInsideOutObj = (BOOL) <br>               (mstat &amp; (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE)); <br> <br>         if ( lpContainerLine-&gt;m_fInsideOutObj ) { <br>            HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc); <br> <br>            ContainerLine_DoVerb( <br>                  lpContainerLine, <br>                  OLEIVERB_INPLACEACTIVATE, <br>                  NULL, <br>                  FALSE, <br>                  FALSE <br>            ); <br> <br>            /* NOTE: following this DoVerb(INPLACEACTIVATE) the <br>            **    object may have taken focus. but because the <br>            **    object is NOT UIActive it should NOT have focus. <br>            **    we will make sure our document has focus. <br>            */ <br>            SetFocus(hWndDoc); <br>         } <br>      } <br>#endif  // INPLACE_CNTR <br>      OLEDBG_END2 <br> <br>   } <br> <br>   OLEDBG_END2 <br>   return TRUE; <br> <br>error: <br>   OLEDBG_END2 <br>   return FALSE; <br>} <br> <br> <br>/* ContainerLine_CloseOleObject <br>** ---------------------------- <br>**    Close the OLE object associated with the ContainerLine. <br>** <br>**    Closing the object forces the object to transition from the <br>**    running state to the loaded state. if the object was not running, <br>**    then there is no effect. it is necessary to close the OLE object <br>**    before releasing the pointers to the OLE object. <br>** <br>**    Returns TRUE if successfully closed, <br>**            FALSE if closing was aborted. <br>*/ <br>BOOL ContainerLine_CloseOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwSaveOption <br>) <br>{ <br>   HRESULT hrErr; <br>   SCODE   sc; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) <br>      return FALSE;                // object in process of creation <br> <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      return TRUE;    // object is NOT loaded <br> <br>   OLEDBG_BEGIN2("IOleObject::Close called\r\n") <br>   hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;Close( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         (dwSaveOption == OLECLOSE_NOSAVE ? <br>               OLECLOSE_NOSAVE : OLECLOSE_SAVEIFDIRTY) <br>   ); <br>   OLEDBG_END2 <br> <br>#if defined( INPLACE_CNTR ) <br>   if (lpContainerLine-&gt;m_fIpServerRunning) { <br>      /* NOTE: unlock the lock held on the in-place object. <br>      **    it is VERY important that an in-place container <br>      **    that also support linking to embeddings properly manage <br>      **    the running of its in-place objects. in an outside-in <br>      **    style in-place container, when the user clicks <br>      **    outside of the in-place active object, the object gets <br>      **    UIDeactivated and the object hides its window. in order <br>      **    to make the object fast to reactivate, the container <br>      **    deliberately does not call IOleObject::Close. the object <br>      **    stays running in the invisible unlocked state. the idea <br>      **    here is if the user simply clicks outside of the object <br>      **    and then wants to double click again to re-activate the <br>      **    object, we do not want this to be slow. if we want to <br>      **    keep the object running, however, we MUST Lock it <br>      **    running. otherwise the object will be in an unstable <br>      **    state where if a linking client does a "silent-update" <br>      **    (eg. UpdateNow from the Links dialog), then the in-place <br>      **    server will shut down even before the object has a chance <br>      **    to be saved back in its container. this saving normally <br>      **    occurs when the in-place container closes the object. also <br>      **    keeping the object in the unstable, hidden, running, <br>      **    not-locked state can cause problems in some scenarios. <br>      **    ICntrOtl keeps only one object running. if the user <br>      **    intiates a DoVerb on another object, then that last <br>      **    running in-place active object is closed. a more <br>      **    sophistocated in-place container may keep more object running. <br>      **    (see CntrLine_IPSite_OnInPlaceActivate) <br>      */ <br>      lpContainerLine-&gt;m_fIpServerRunning = FALSE; <br> <br>      OLEDBG_BEGIN2("OleLockRunning(FALSE,TRUE) called\r\n") <br>      OleLockRunning((LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, FALSE, TRUE); <br>      OLEDBG_END2 <br>   } <br>#endif <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("IOleObject::Close returned", hrErr); <br>      sc = hrErr; <br>      if (sc == RPC_E_CALL_REJECTED || sc==OLE_E_PROMPTSAVECANCELLED) <br>         return FALSE;   // object aborted shutdown <br>   } <br>   return TRUE; <br>} <br> <br> <br>/* ContainerLine_UnloadOleObject <br>** ----------------------------- <br>**    Close the OLE object associated with the ContainerLine and <br>**    release all pointer held to the object. <br>** <br>**    Closing the object forces the object to transition from the <br>**    running state to the loaded state. if the object was not running, <br>**    then there is no effect. it is necessary to close the OLE object <br>**    before releasing the pointers to the OLE object. releasing all <br>**    pointers to the object allows the object to transition from <br>**    loaded to unloaded (or passive). <br>*/ <br>void ContainerLine_UnloadOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      DWORD                   dwSaveOption <br>) <br>{ <br>   if (lpContainerLine-&gt;m_lpOleObj) { <br> <br>      OLEDBG_BEGIN2("IOleObject::Close called\r\n") <br>      lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;Close( <br>            lpContainerLine-&gt;m_lpOleObj, dwSaveOption); <br>      OLEDBG_END2 <br> <br>      /* NOTE: we will take our IOleClientSite* pointer away from <br>      **    the object before we release all pointers to the object. <br>      **    in the scenario where the object is implemented as an <br>      **    in-proc server (DLL object), then, if there are link <br>      **    connections to the DLL object, it is possible that the <br>      **    object will not be destroyed when we release our pointers <br>      **    to the object. the existance of the remote link <br>      **    connections will hold the object alive. later when these <br>      **    strong connections are released, then the object may <br>      **    attempt to call IOleClientSite::Save if we had not taken <br>      **    away the client site pointer. <br>      */ <br>      OLEDBG_BEGIN2("IOleObject::SetClientSite(NULL) called\r\n") <br>      lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetClientSite( <br>            lpContainerLine-&gt;m_lpOleObj, NULL); <br>      OLEDBG_END2 <br> <br>      OleStdRelease((LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj); <br>      lpContainerLine-&gt;m_lpOleObj = NULL; <br> <br>      if (lpContainerLine-&gt;m_lpViewObj2) { <br>         OleStdRelease((LPUNKNOWN)lpContainerLine-&gt;m_lpViewObj2); <br>         lpContainerLine-&gt;m_lpViewObj2 = NULL; <br>      } <br>      if (lpContainerLine-&gt;m_lpPersistStg) { <br>         OleStdRelease((LPUNKNOWN)lpContainerLine-&gt;m_lpPersistStg); <br>         lpContainerLine-&gt;m_lpPersistStg = NULL; <br>      } <br> <br>      if (lpContainerLine-&gt;m_lpOleLink) { <br>         OleStdRelease((LPUNKNOWN)lpContainerLine-&gt;m_lpOleLink); <br>         lpContainerLine-&gt;m_lpOleLink = NULL; <br>      } <br>   } <br> <br>   if (lpContainerLine-&gt;m_lpszShortType) { <br>      OleStdFreeString(lpContainerLine-&gt;m_lpszShortType, NULL); <br>      lpContainerLine-&gt;m_lpszShortType = NULL; <br>   } <br>} <br> <br> <br>/* ContainerLine_Delete <br>** -------------------- <br>**    Delete the ContainerLine. <br>** <br>**    NOTE: we can NOT directly destroy the memory for the <br>**    ContainerLine; the ContainerLine maintains a reference count. a <br>**    non-zero reference count indicates that the object is still <br>**    in-use. The OleObject keeps a reference-counted pointer to the <br>**    ClientLine object. we must take the actions necessary so that the <br>**    ContainerLine object receives Releases for outstanding <br>**    references. when the reference count of the ContainerLine reaches <br>**    zero, then the memory for the object will actually be destroyed <br>**    (ContainerLine_Destroy called). <br>** <br>*/ <br>void ContainerLine_Delete(LPCONTAINERLINE lpContainerLine) <br>{ <br>   OLEDBG_BEGIN2("ContainerLine_Delete\r\n") <br> <br>#if defined( INPLACE_CNTR ) <br>   if (lpContainerLine == lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastIpActiveLine) <br>      lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastIpActiveLine = NULL; <br>   if (lpContainerLine == lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastUIActiveLine) <br>      lpContainerLine-&gt;m_lpDoc-&gt;m_lpLastUIActiveLine = NULL; <br>#endif <br> <br>   /* NOTE: in order to have a stable line object during the <br>   **    process of deleting, we intially AddRef the line ref cnt and <br>   **    later Release it. This initial AddRef is artificial; it is <br>   **    simply done to guarantee that our object does not destroy <br>   **    itself until the END of this routine. <br>   */ <br>   ContainerLine_AddRef(lpContainerLine); <br> <br>   // Unload the loaded OLE object <br>   if (lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_NOSAVE); <br> <br>   /* NOTE: we can NOT directly free the memory for the ContainerLine <br>   **    data structure until everyone holding on to a pointer to our <br>   **    ClientSite interface and IAdviseSink interface has released <br>   **    their pointers. There is one refcnt on the ContainerLine object <br>   **    which is held by the container itself. we will release this <br>   **    refcnt here. <br>   */ <br>   ContainerLine_Release(lpContainerLine); <br> <br>   /* NOTE: this call forces all external connections to our <br>   **    ContainerLine to close down and therefore guarantees that <br>   **    we receive all releases associated with those external <br>   **    connections. Strictly this call should NOT be necessary, but <br>   **    it is defensive coding to make this call. <br>   */ <br>   OLEDBG_BEGIN2("CoDisconnectObject(lpContainerLine) called\r\n") <br>   CoDisconnectObject((LPUNKNOWN)&amp;lpContainerLine-&gt;m_Unknown, 0); <br>   OLEDBG_END2 <br> <br>#if defined( _DEBUG ) <br>   /* at this point the object all references from the OLE object to <br>   **    our ContainerLine object should have been released. there <br>   **    should only be 1 remaining reference that will be released below. <br>   */ <br>   if (lpContainerLine-&gt;m_cRef != 1) { <br>      OleDbgOutRefCnt( <br>         "WARNING: ContainerLine_Delete: cRef != 1\r\n", <br>         lpContainerLine, <br>         lpContainerLine-&gt;m_cRef <br>      ); <br>   } <br>#endif <br> <br>   ContainerLine_Release(lpContainerLine); // release artificial AddRef above <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ContainerLine_Destroy </code></pre>
<p>
</p>
<pre><code>** --------------------- <br>**    Destroy (Free) the memory used by a ContainerLine structure. <br>**    This function is called when the ref count of the ContainerLine goes <br>**    to zero. the ref cnt goes to zero after ContainerLine_Delete forces <br>**    the OleObject to unload and release its pointers to the <br>**    ContainerLine IOleClientSite and IAdviseSink interfaces. <br>*/ <br> <br>void ContainerLine_Destroy(LPCONTAINERLINE lpContainerLine) <br>{ <br>   LPUNKNOWN lpTmpObj; <br> <br>   OLEDBG_BEGIN2("ContainerLine_Destroy\r\n") <br> <br>   // Release the storage opened for the OLE object <br>   if (lpContainerLine-&gt;m_lpStg) { <br>      lpTmpObj = (LPUNKNOWN)lpContainerLine-&gt;m_lpStg; <br>      lpContainerLine-&gt;m_lpStg = NULL; <br> <br>      OleStdRelease(lpTmpObj); <br>   } <br> <br>   if (lpContainerLine-&gt;m_lpszShortType) { <br>      OleStdFreeString(lpContainerLine-&gt;m_lpszShortType, NULL); <br>      lpContainerLine-&gt;m_lpszShortType = NULL; <br>   } <br> <br>   Delete(lpContainerLine);        // Free the memory for the structure itself <br>   OLEDBG_END2 <br>} <br> <br> <br>/* ContainerLine_CopyToDoc <br> * ----------------------- <br> * <br> *      Copy a ContainerLine to another Document (usually ClipboardDoc) <br> */ <br>BOOL ContainerLine_CopyToDoc( <br>      LPCONTAINERLINE         lpSrcLine, <br>      LPOUTLINEDOC            lpDestDoc, <br>      int                     nIndex <br>) <br>{ <br>   LPCONTAINERLINE lpDestLine = NULL; <br>   LPLINELIST  lpDestLL = &amp;lpDestDoc-&gt;m_LineList; <br>   HDC         hDC; <br>   HRESULT     hrErr; <br>   BOOL        fStatus; <br>   LPSTORAGE   lpDestDocStg = ((LPOLEDOC)lpDestDoc)-&gt;m_lpStg; <br>   LPSTORAGE   lpDestObjStg = NULL; <br> <br>   lpDestLine = (LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE)); <br>   if (lpDestLine == NULL) { <br>      OleDbgAssertSz(lpDestLine!=NULL, "Error allocating ContainerLine"); <br>      return FALSE; <br>   } <br> <br>   hDC = LineList_GetDC(lpDestLL); <br>   ContainerLine_Init(lpDestLine, ((LPLINE)lpSrcLine)-&gt;m_nTabLevel, hDC); <br>   LineList_ReleaseDC(lpDestLL, hDC); <br> <br>   /* NOTE: In order to have a stable ContainerLine object we must <br>   **    AddRef the object's refcnt. this will be later released when <br>   **    the ContainerLine is deleted. <br>   */ <br>   ContainerLine_AddRef(lpDestLine); <br> <br>   lpDestLine-&gt;m_lpDoc = (LPCONTAINERDOC)lpDestDoc; <br> <br>   // Copy data of the original source ContainerLine. <br>   ((LPLINE)lpDestLine)-&gt;m_nWidthInHimetric = <br>         ((LPLINE)lpSrcLine)-&gt;m_nWidthInHimetric; <br>   ((LPLINE)lpDestLine)-&gt;m_nHeightInHimetric = <br>         ((LPLINE)lpSrcLine)-&gt;m_nHeightInHimetric; <br>   lpDestLine-&gt;m_fMonikerAssigned = lpSrcLine-&gt;m_fMonikerAssigned; <br>   lpDestLine-&gt;m_dwDrawAspect = lpSrcLine-&gt;m_dwDrawAspect; <br>   lpDestLine-&gt;m_sizeInHimetric = lpSrcLine-&gt;m_sizeInHimetric; <br>   lpDestLine-&gt;m_dwLinkType = lpSrcLine-&gt;m_dwLinkType; <br> <br> <br>   /* We must create a new sub-storage for the embedded object within <br>   **    the destination document's storage. We will first attempt to <br>   **    use the same storage name as the source line. if this name is <br>   **    in use, then we will allocate a new name. in this way we try <br>   **    to keep the name associated with the OLE object unchanged <br>   **    through a Cut/Paste operation. <br>   */ <br>   lpDestObjStg = OleStdCreateChildStorage( <br>         lpDestDocStg, <br>         lpSrcLine-&gt;m_szStgName <br>   ); <br>   if (lpDestObjStg) { <br>      OLESTRCPY(lpDestLine-&gt;m_szStgName, lpSrcLine-&gt;m_szStgName); <br>   } else { <br>      /* the original name was in use, make up a new name. */ <br>      ContainerDoc_GetNextStgName( <br>            (LPCONTAINERDOC)lpDestDoc, <br>            lpDestLine-&gt;m_szStgName, <br>            CWCSTORAGENAME <br>      ); <br>      lpDestObjStg = OleStdCreateChildStorage( <br>            lpDestDocStg, <br>            lpDestLine-&gt;m_szStgName <br>      ); <br>   } <br>   if (lpDestObjStg == NULL) { <br>      OleDbgAssertSz(lpDestObjStg != NULL, "Error creating child stg"); <br>      goto error; <br>   } <br> <br>   // Copy over storage of the embedded object itself <br> <br>   if (! lpSrcLine-&gt;m_lpOleObj) { <br> <br>      /***************************************************************** <br>      ** CASE 1: object is NOT loaded. <br>      **    because the object is not loaded, we can simply copy the <br>      **    object's current storage to the new storage. <br>      *****************************************************************/ <br> <br>      /* if current object storage is not already open, then open it */ <br>      if (! lpSrcLine-&gt;m_lpStg) { <br>         LPSTORAGE lpSrcDocStg = ((LPOLEDOC)lpSrcLine-&gt;m_lpDoc)-&gt;m_lpStg; <br> <br>         if (! lpSrcDocStg) goto error; <br> <br>         // open object storage. <br>         lpSrcLine-&gt;m_lpStg = OleStdOpenChildStorage( <br>               lpSrcDocStg, <br>               lpSrcLine-&gt;m_szStgName, <br>               STGM_READWRITE <br>         ); <br>         if (lpSrcLine-&gt;m_lpStg == NULL) { <br>#if defined( _DEBUG ) <br>            OleDbgAssertSz( <br>                  lpSrcLine-&gt;m_lpStg != NULL, <br>                  "Error opening child stg" <br>            ); <br>#endif <br>            goto error; <br>         } <br>      } <br> <br>      hrErr = lpSrcLine-&gt;m_lpStg-&gt;lpVtbl-&gt;CopyTo( <br>            lpSrcLine-&gt;m_lpStg, <br>            0, <br>            NULL, <br>            NULL, <br>            lpDestObjStg <br>      ); <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("WARNING: lpSrcObjStg-&gt;CopyTo returned", hrErr); <br>         goto error; <br>      } <br> <br>      fStatus = OleStdCommitStorage(lpDestObjStg); <br> <br>   } else { <br> <br>      /***************************************************************** <br>      ** CASE 2: object IS loaded. <br>      **    we must tell the object to save into the new storage. <br>      *****************************************************************/ <br> <br>      SCODE sc = S_OK; <br>      LPPERSISTSTORAGE lpPersistStg = lpSrcLine-&gt;m_lpPersistStg; <br>      OleDbgAssert(lpPersistStg); <br> <br>      OLEDBG_BEGIN2("OleSave called\r\n") <br>      hrErr = OleSave(lpPersistStg, lpDestObjStg, FALSE /*fSameAsLoad*/); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("WARNING: OleSave returned", hrErr); <br>         sc = hrErr; <br>      } <br> <br>      // NOTE: even if OleSave fails, SaveCompleted must be called. <br>      OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n") <br>      hrErr=lpPersistStg-&gt;lpVtbl-&gt;SaveCompleted(lpPersistStg,NULL); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr); <br>         if (sc == S_OK) <br>            sc = hrErr; <br>      } <br> <br>      if (sc != S_OK) <br>         goto error; <br> <br>   } <br> <br>   OutlineDoc_AddLine(lpDestDoc, (LPLINE)lpDestLine, nIndex); <br>   OleStdVerifyRelease( <br>         (LPUNKNOWN)lpDestObjStg, <br>         OLESTR("Copied object stg not released") <br>   ); <br> <br>   return TRUE; <br> <br>error: <br> <br>   // Delete any partially created storage. <br>   if (lpDestObjStg) { <br>      OleStdVerifyRelease( <br>            (LPUNKNOWN)lpDestObjStg, <br>            OLESTR("Copied object stg not released") <br>      ); <br> <br>      lpDestDocStg-&gt;lpVtbl-&gt;DestroyElement( <br>            lpDestDocStg, <br>            lpDestLine-&gt;m_szStgName <br>      ); <br>      lpDestLine-&gt;m_szStgName[0] = '\0'; <br>   } <br> <br>   // destroy partially created ContainerLine <br>   if (lpDestLine) <br>      ContainerLine_Delete(lpDestLine); <br>   return FALSE; <br>} <br> <br> <br>/* ContainerLine_UpdateExtent <br>** -------------------------- <br>**   Update the size of the ContainerLine because the extents of the <br>**    object may have changed. <br>** <br>**    NOTE: because we are using a Windows OwnerDraw ListBox, we must <br>**    constrain the maximum possible height of a line. the ListBox has <br>**    a limitation (unfortunately) that no line can become larger than <br>**    255 pixels. thus we force the object to scale maintaining its <br>**    aspect ratio if this maximum line height limit is reached. the <br>**    actual maximum size for an object at 100% Zoom is <br>**    255 <br>** <br>**    RETURNS TRUE -- if the extents of the object changed <br>**            FALSE -- if the extents did NOT change <br>*/ <br>BOOL ContainerLine_UpdateExtent( <br>      LPCONTAINERLINE     lpContainerLine, <br>      LPSIZEL             lpsizelHim <br>) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   LPLINE lpLine = (LPLINE)lpContainerLine; <br>   int nIndex = LineList_GetLineIndex(lpLL, lpLine); <br>   UINT nOrgWidthInHimetric = lpLine-&gt;m_nWidthInHimetric; <br>   UINT nOrgHeightInHimetric = lpLine-&gt;m_nHeightInHimetric; <br>   BOOL fWidthChanged = FALSE; <br>   BOOL fHeightChanged = FALSE; <br>   SIZEL sizelHim; <br>   HRESULT hrErr; <br> <br>   if (!lpContainerLine || !lpContainerLine-&gt;m_lpOleObj) <br>      return FALSE; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) <br>      return FALSE;                // object in process of creation <br> <br>   OLEDBG_BEGIN3("ContainerLine_UpdateExtent\r\n"); <br> <br>   lpContainerLine-&gt;m_fDoGetExtent = FALSE; <br> <br>   if (! lpsizelHim) { <br>      /* NOTE: We want to call IViewObject2::GetExtent instead of <br>      **    IOleObject::GetExtent. IViewObject2::GetExtent method was <br>      **    added in OLE 2.01 release. It always retrieves the <br>      **    extents of the object corresponding to that which will be <br>      **    drawn by calling IViewObject::Draw. Normally, this is <br>      **    determined by the data stored in the data cache. This <br>      **    call will never result in a remoted (LRPC) call. <br>      */ <br>      OLEDBG_BEGIN2("IViewObject2::GetExtent called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpViewObj2-&gt;lpVtbl-&gt;GetExtent( <br>            lpContainerLine-&gt;m_lpViewObj2, <br>            lpContainerLine-&gt;m_dwDrawAspect, <br>            -1,     /*lindex*/ <br>            NULL,   /*ptd*/ <br>            (LPSIZEL)&amp;sizelHim <br>      ); <br>      OLEDBG_END2 <br>      if (hrErr != NOERROR) <br>         sizelHim.cx = sizelHim.cy = 0; <br> <br>      lpsizelHim = (LPSIZEL)&amp;sizelHim; <br>   } <br> <br>   if (lpsizelHim-&gt;cx == lpContainerLine-&gt;m_sizeInHimetric.cx &amp;&amp; <br>      lpsizelHim-&gt;cy == lpContainerLine-&gt;m_sizeInHimetric.cy) { <br>      goto noupdate; <br>   } <br> <br>   if (lpsizelHim-&gt;cx &gt; 0 || lpsizelHim-&gt;cy &gt; 0) { <br>      lpContainerLine-&gt;m_sizeInHimetric = *lpsizelHim; <br>   } else { <br>      /* object does not have any extents; let's use our container <br>      **    chosen arbitrary size for OLE objects. <br>      */ <br>      lpContainerLine-&gt;m_sizeInHimetric.cx = (long)DEFOBJWIDTH; <br>      lpContainerLine-&gt;m_sizeInHimetric.cy = (long)DEFOBJHEIGHT; <br>   } <br> <br>   ContainerLine_SetLineHeightFromObjectExtent( <br>         lpContainerLine, <br>         (LPSIZEL)&amp;lpContainerLine-&gt;m_sizeInHimetric); <br> <br>   // if height of object changed, then reset the height of line in LineList <br>   if (nOrgHeightInHimetric != lpLine-&gt;m_nHeightInHimetric) { <br>      LineList_SetLineHeight(lpLL, nIndex, lpLine-&gt;m_nHeightInHimetric); <br>      fHeightChanged = TRUE; <br>   } <br> <br>   fWidthChanged = LineList_RecalcMaxLineWidthInHimetric( <br>         lpLL, <br>         nOrgWidthInHimetric <br>   ); <br>   fWidthChanged |= (nOrgWidthInHimetric != lpLine-&gt;m_nWidthInHimetric); <br> <br>   if (fHeightChanged || fWidthChanged) { <br>      OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE); <br> <br>      // mark ContainerDoc as now dirty <br>      OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE); <br>   } <br> <br>   OLEDBG_END3 <br>   return TRUE; <br> <br>noupdate: <br>   OLEDBG_END3 <br>   return FALSE;   // No UPDATE necessary <br>} <br> <br> <br>/* ContainerLine_DoVerb <br>** -------------------- <br>**    Activate the OLE object and perform a specific verb. <br>*/ <br>BOOL ContainerLine_DoVerb( <br>      LPCONTAINERLINE lpContainerLine, <br>      LONG            iVerb, <br>      LPMSG           lpMsg, <br>      BOOL            fMessage, <br>      BOOL            fAction <br>) <br>{ <br>   HRESULT hrErr; <br>   LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   RECT rcPosRect; <br>   OLEDBG_BEGIN3("ContainerLine_DoVerb\r\n") <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--Fail the DoVerb call <br>      hrErr = E_FAIL; <br>      goto error; <br>   } <br> <br>   /* if object is not already loaded, then load it now. objects are <br>   **    loaded lazily in this manner. <br>   */ <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_LoadOleObject(lpContainerLine); <br> <br>   if (! lpContainerLine-&gt;m_lpOleObj) { <br>#if defined( _DEBUG ) <br>      OleDbgAssertSz( <br>            lpContainerLine-&gt;m_lpOleObj != NULL, <br>            "OLE object not loaded" <br>      ); <br>#endif <br>      goto error; <br>   } <br> <br>ExecuteDoVerb: <br> <br>   ContainerLine_GetPosRect(lpContainerLine, (LPRECT)&amp;rcPosRect); <br> <br>   // run the object <br>   hrErr = ContainerLine_RunOleObject(lpContainerLine); <br>   if (hrErr != NOERROR) <br>      goto error; <br> <br>   /* Tell object server to perform a "verb". */ <br>   OLEDBG_BEGIN2("IOleObject::DoVerb called\r\n") <br>   hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;DoVerb ( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         iVerb, <br>         lpMsg, <br>         (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>         -1, <br>         OutlineDoc_GetWindow(lpOutlineDoc), <br>         (LPCRECT)&amp;rcPosRect <br>   ); <br>   OLEDBG_END2 <br> <br>   /* NOTE: IOleObject::DoVerb may return a success code <br>   **    OLE_S_INVALIDVERB. this SCODE should NOT be considered an <br>   **    error; thus it is important to use the "FAILED" macro to <br>   **    check for an error SCODE. <br>   */ <br>   if (FAILED(hrErr)) { <br>      OleDbgOutHResult("WARNING: lpOleObj-&gt;DoVerb returned", hrErr); <br>      goto error; <br>   } <br> <br>#if defined( INPLACE_CNTR ) <br>   /* NOTE: we want to keep only 1 inplace server active at any <br>   **    given time. so when we start to do a DoVerb on another line, <br>   **    then we want to shut down the previously activated server. in <br>   **    this way we keep at most one inplace server active at a time. <br>   **    because it is possible that the object we want to do DoVerb <br>   **    on is handled by the same EXE as that of the previously <br>   **    activated server, then we do not want the EXE to be shut down <br>   **    only to be launched again. in order to avoid this we will do <br>   **    the DoVerb BEFORE trying to shutdown the previous object. <br>   */ <br>   if (!g_fInsideOutContainer) { <br>      ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded( <br>            lpContainerLine-&gt;m_lpDoc, lpContainerLine); <br>   } <br>#endif  // INPLACE_CNTR <br> <br>   OLEDBG_END3 <br>   return TRUE; <br> <br>error: <br> <br>   if (lpContainerLine-&gt;m_dwLinkType != 0) <br>      lpContainerLine-&gt;m_fLinkUnavailable = TRUE; <br> <br>#if defined( INPLACE_CNTR ) <br>   /* NOTE: we want to keep only 1 inplace server active at any <br>   **    given time. so when we start to do a DoVerb on another line, <br>   **    then we want to shut down the previously activated server. in <br>   **    this way we keep at most one inplace server active at a time. <br>   **    even though the DoVerb failed, we will still shutdown the <br>   **    previous server. it is possible that we ran out of memory and <br>   **    that the DoVerb will succeed next time after shutting down <br>   **    the pervious server. <br>   */ <br>   if (!g_fInsideOutContainer) { <br>      ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded( <br>            lpContainerLine-&gt;m_lpDoc, lpContainerLine); <br>   } <br>#endif  // INPLACE_CNTR <br> <br>   /* NOTE: if an error occurs we must give the appropriate error <br>   **    message box. there are many potential errors that can occur. <br>   **    the OLE2.0 user model has specific guidelines as to the <br>   **    dialogs that should be displayed given the various potential <br>   **    errors (eg. server not registered, unavailable link source. <br>   **    the OLE2UI library includes support for most of the <br>   **    recommended message dialogs. (see OleUIPrompUser function) <br>   */ <br>   if (fMessage) { <br>      BOOL fReDoVerb = ContainerLine_ProcessOleRunError( <br>            lpContainerLine, <br>            hrErr, <br>            fAction, <br>            (lpMsg==NULL &amp;&amp; iVerb&gt;=0)   /* fMenuInvoked */ <br>      ); <br>      if (fReDoVerb) { <br>         goto ExecuteDoVerb; <br>      } <br>   } <br> <br>   OLEDBG_END3 <br>   return FALSE; <br>} <br> <br> <br> <br>/* ContainerLine_ProcessOleRunError <br> * -------------------------------- <br> * <br> *  Handle the various errors possible when attempting OleRun of an object. <br> *  Popup up appropriate message according to the error and/or take action <br> *  specified button pressed by the user. <br> * <br> *  NOTE: The OLE 2.0 User Interface Guidelines specify the messages <br> *            that should be given for the following situations: <br> *                  1. Link Source Unavailable...goto Links dialog <br> *                  2. Server Not Registered...goto Convert dialog <br> *                  3. Link Type Changed <br> *                  4. Server Not Found <br> * <br> *  Returns:    TRUE -- repeat IOleObject::DoVerb call. <br> *              FALSE -- do NOT repeat IOleObject::DoVerb call. <br> * <br> *  Comments: <br> *      (see LinkTypeChanged case) <br> */ <br>BOOL ContainerLine_ProcessOleRunError( <br>      LPCONTAINERLINE         lpContainerLine, <br>      HRESULT                 hrErr, <br>      BOOL                    fAction, <br>      BOOL                    fMenuInvoked <br>) <br>{ <br>   LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   HWND            hwndParent = OutlineDoc_GetWindow(lpOutlineDoc); <br>   SCODE           sc = hrErr; <br>   BOOL            fReDoVerb = FALSE; <br>   char szTemp[256]; <br>   char szTemp2[256]; <br> <br>   OleDbgOutHResult("ProcessError", hrErr); <br>   if ((sc &gt;= MK_E_FIRST) &amp;&amp; (sc &lt;= MK_E_LAST)) <br>      goto LinkSourceUnavailable; <br>   if (sc == OLE_E_CANT_BINDTOSOURCE) <br>      goto LinkSourceUnavailable; <br>   if (sc == STG_E_PATHNOTFOUND) <br>      goto LinkSourceUnavailable; <br>   if (sc == REGDB_E_CLASSNOTREG) <br>      goto ServerNotReg; <br>   if (sc == OLE_E_STATIC) <br>      goto ServerNotReg;  // user dblclk'ed a static object w/ no svr reg'd <br>   if (sc == OLE_E_CLASSDIFF) <br>      goto LinkTypeChanged; <br>   if (sc == CO_E_APPDIDNTREG) <br>      goto ServerNotFound; <br>   if (sc == CO_E_APPNOTFOUND) <br>      goto ServerNotFound; <br>   if (sc == E_OUTOFMEMORY) <br>      goto OutOfMemory; <br> <br>   if (ContainerLine_IsOleLink(lpContainerLine)) <br>      goto LinkSourceUnavailable; <br>   else <br>      goto ServerNotFound; <br> <br> <br>/************************************************************************* <br>** Error handling routines                                              ** <br>*************************************************************************/ <br>LinkSourceUnavailable: <br>   wcstombs(szTemp, APPNAME, 255); <br>   if (ID_PU_LINKS == OleUIPromptUser( <br>            (WORD)IDD_LINKSOURCEUNAVAILABLE, <br>            hwndParent, <br>            szTemp)) { <br>      if (fAction) { <br>         ContainerDoc_EditLinksCommand(lpContainerLine-&gt;m_lpDoc); <br>      } <br>   } <br>   return fReDoVerb; <br> <br>ServerNotReg: <br>   { <br>   LPOLESTR lpszUserType = NULL; <br>   CLIPFORMAT  cfFormat;       // not used <br> <br>   hrErr = ReadFmtUserTypeStg( <br>         lpContainerLine-&gt;m_lpStg, &amp;cfFormat, &amp;lpszUserType); <br> <br>   wcstombs(szTemp, APPNAME, 255); <br>   wcstombs(szTemp2, lpszUserType, 255); <br>   if (ID_PU_CONVERT == OleUIPromptUser( <br>         (WORD)IDD_SERVERNOTREG, <br>         hwndParent, <br>         szTemp, <br>         (hrErr == NOERROR) ? szTemp2 : "Unknown Object")) { <br>      if (fAction) { <br>         ContainerDoc_ConvertCommand( <br>               lpContainerLine-&gt;m_lpDoc, <br>               TRUE        // fMustActivate <br>         ); <br>      } <br>   } <br> <br>   if (lpszUserType) <br>      OleStdFreeString(lpszUserType, NULL); <br> <br>   return fReDoVerb; <br>   } <br> <br> <br>LinkTypeChanged: <br>   { <br>   /* NOTE: If IOleObject::DoVerb is executed on a Link object and it <br>   **    returns OLE_E_CLASSDIFF because the link source is no longer <br>   **    the expected class, then if the verb is a semantically <br>   **    defined verb (eg. OLEIVERB_PRIMARY, OLEIVERB_SHOW, <br>   **    OLEIVERB_OPEN, etc.), then the link should be re-created with <br>   **    the new link source and the same verb executed on the new <br>   **    link. there is no need to give a message to the user. if the <br>   **    user had selected a verb from the object's verb menu <br>   **    (fMenuInvoked==TRUE), then we can not be certain of the <br>   **    semantics of the verb and whether the new link can still <br>   **    support the verb. in this case the user is given a prompt <br>   **    telling him to "choose a different command offered by the new <br>   **    type". <br>   */ <br> <br>   LPOLESTR       lpszUserType = NULL; <br> <br>   if (fMenuInvoked) { <br>      hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>            lpContainerLine-&gt;m_lpOleObj,USERCLASSTYPE_FULL,&amp;lpszUserType); <br>      wcstombs(szTemp, APPNAME, 255); <br>      wcstombs(szTemp2, lpszUserType, 255); <br>      OleUIPromptUser( <br>            (WORD)IDD_LINKTYPECHANGED, <br>            hwndParent, <br>            szTemp, <br>            (hrErr == NOERROR) ? szTemp2 : "Unknown Object" <br>      ); <br>   } else { <br>      fReDoVerb = TRUE; <br>   } <br>   ContainerLine_ReCreateLinkBecauseClassDiff(lpContainerLine); <br> <br>   if (lpszUserType) <br>      OleStdFreeString(lpszUserType, NULL); <br> <br>   return fReDoVerb; <br>   } <br> <br>ServerNotFound: <br>   wcstombs(szTemp, APPNAME, 255); <br>   OleUIPromptUser( <br>         (WORD)IDD_SERVERNOTFOUND, <br>         hwndParent, <br>         /*(LPOLESTR)*/szTemp); <br>   return fReDoVerb; <br> <br>OutOfMemory: <br>   wcstombs(szTemp, APPNAME, 255); <br>   OleUIPromptUser( <br>         (WORD)IDD_OUTOFMEMORY, <br>         hwndParent, <br>         szTemp); <br>   return fReDoVerb; <br>} <br> <br> <br>/* ContainerLine_ReCreateLinkBecauseClassDiff <br>** ------------------------------------------ <br>**    Re-create the link. The existing link was created when <br>**    the moniker binds to a link source bound of a different class <br>**    than the same moniker currently binds to. the link may be a <br>**    special link object specifically used with the old link <br>**    source class. thus the link object needs to be re-created to <br>**    give the new link source the opportunity to create its own <br>**    special link object. (see description "Custom Link Source") <br>*/ <br>HRESULT ContainerLine_ReCreateLinkBecauseClassDiff( <br>      LPCONTAINERLINE lpContainerLine <br>) <br>{ <br>   LPOLELINK   lpOleLink = lpContainerLine-&gt;m_lpOleLink; <br>   HGLOBAL     hMetaPict = NULL; <br>   LPMONIKER   lpmkLinkSrc = NULL; <br>   SCODE       sc = E_FAIL; <br>   HRESULT     hrErr; <br> <br>   if (lpOleLink &amp;&amp; <br>      lpOleLink-&gt;lpVtbl-&gt;GetSourceMoniker( <br>            lpOleLink, (LPMONIKER FAR*)&amp;lpmkLinkSrc) == NOERROR) { <br> <br>      BOOL            fDisplayAsIcon = <br>                     (lpContainerLine-&gt;m_dwDrawAspect==DVASPECT_ICON); <br>      STGMEDIUM       medium; <br>      LPDATAOBJECT    lpDataObj = NULL; <br>      DWORD           dwOleRenderOpt; <br>      FORMATETC       renderFmtEtc; <br>      LPFORMATETC     lpRenderFmtEtc = NULL; <br> <br>      // get the current icon if object is displayed as icon <br>      if (fDisplayAsIcon &amp;&amp; <br>         (lpDataObj = (LPDATAOBJECT)OleStdQueryInterface( (LPUNKNOWN) <br>               lpContainerLine-&gt;m_lpOleObj,&amp;IID_IDataObject)) != NULL ) { <br>         hMetaPict = OleStdGetData( <br>               lpDataObj, CF_METAFILEPICT, NULL, DVASPECT_ICON, &amp;medium); <br>         OleStdRelease((LPUNKNOWN)lpDataObj); <br>      } <br> <br>      if (fDisplayAsIcon &amp;&amp; hMetaPict) { <br>         // a special icon should be used. first we create the object <br>         // OLERENDER_NONE. then we stuff the special icon into the cache. <br> <br>         dwOleRenderOpt = OLERENDER_NONE; <br> <br>      } else if (fDisplayAsIcon &amp;&amp; hMetaPict == NULL) { <br>         // the object's default icon should be used <br> <br>         dwOleRenderOpt = OLERENDER_DRAW; <br>         lpRenderFmtEtc = (LPFORMATETC)&amp;renderFmtEtc; <br>         SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1); <br> <br>      } else { <br>         // create standard DVASPECT_CONTENT/OLERENDER_DRAW object <br>         dwOleRenderOpt = OLERENDER_DRAW; <br>      } <br> <br>      // unload original link object <br>      ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_SAVEIFDIRTY); <br> <br>      // delete entire contents of the current object's storage <br>      OleStdDestroyAllElements(lpContainerLine-&gt;m_lpStg); <br> <br>      OLEDBG_BEGIN2("OleCreateLink called\r\n") <br>      hrErr = OleCreateLink ( <br>            lpmkLinkSrc, <br>            &amp;IID_IOleObject, <br>            dwOleRenderOpt, <br>            lpRenderFmtEtc, <br>            (LPOLECLIENTSITE)&amp;lpContainerLine-&gt;m_OleClientSite, <br>            lpContainerLine-&gt;m_lpStg, <br>            (LPVOID FAR*)&amp;lpContainerLine-&gt;m_lpOleObj <br>      ); <br>      OLEDBG_END2 <br> <br>      if (hrErr == NOERROR) { <br>         if (! ContainerLine_SetupOleObject( <br>               lpContainerLine, fDisplayAsIcon, hMetaPict) ) { <br> <br>            // ERROR: setup of the new link failed. <br>            // revert the storage to restore the original link. <br>            ContainerLine_UnloadOleObject( <br>                  lpContainerLine, OLECLOSE_NOSAVE); <br>            lpContainerLine-&gt;m_lpStg-&gt;lpVtbl-&gt;Revert( <br>                  lpContainerLine-&gt;m_lpStg); <br>            sc = E_FAIL; <br>         } else { <br>            sc = S_OK;  // IT WORKED! <br> <br>         } <br>      } <br>      else { <br>         sc = hrErr; <br>         OleDbgOutHResult("OleCreateLink returned", hrErr); <br>         // ERROR: Re-creating the link failed. <br>         // revert the storage to restore the original link. <br>         lpContainerLine-&gt;m_lpStg-&gt;lpVtbl-&gt;Revert( <br>               lpContainerLine-&gt;m_lpStg); <br>      } <br>   } <br> <br>   if (hMetaPict) <br>      OleUIMetafilePictIconFree(hMetaPict); // clean up metafile <br>   return sc; <br>} <br> <br>/* ContainerLine_GetOleObject <br>** -------------------------- <br>**    return pointer to desired interface of embedded/linked object. <br>** <br>**    NOTE: this function causes an AddRef to the object. when the caller is <br>**          finished with the object, it must call Release. <br>**          this function does not AddRef the ContainerLine object. <br>*/ <br>LPUNKNOWN ContainerLine_GetOleObject( <br>      LPCONTAINERLINE         lpContainerLine, <br>      REFIID                  riid <br>) <br>{ <br>   /* if object is not already loaded, then load it now. objects are <br>   **    loaded lazily in this manner. <br>   */ <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_LoadOleObject(lpContainerLine); <br> <br>   if (lpContainerLine-&gt;m_lpOleObj) <br>      return OleStdQueryInterface( <br>            (LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj, <br>            riid <br>      ); <br>   else <br>      return NULL; <br>} <br> <br> <br> <br>/* ContainerLine_RunOleObject <br>** -------------------------- <br>**    Load and run the object. Upon running and if size of object has changed, <br>**    use SetExtent to change to new size. <br>** <br>*/ <br>HRESULT ContainerLine_RunOleObject(LPCONTAINERLINE lpContainerLine) <br>{ <br>   LPLINE lpLine = (LPLINE)lpContainerLine; <br>   SIZEL   sizelNew; <br>   HRESULT hrErr; <br>   HCURSOR  hPrevCursor; <br> <br>   if (! lpContainerLine) <br>      return NOERROR; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--Fail to Run the object <br>      return E_FAIL; <br>   } <br> <br>   if (lpContainerLine-&gt;m_lpOleObj &amp;&amp; <br>      OleIsRunning(lpContainerLine-&gt;m_lpOleObj)) <br>      return NOERROR;     // object already running <br> <br>   // this may take a while, put up hourglass cursor <br>   hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>   OLEDBG_BEGIN3("ContainerLine_RunOleObject\r\n") <br> <br>   if (! lpContainerLine-&gt;m_lpOleObj) { <br>      if (! ContainerLine_LoadOleObject(lpContainerLine)) <br>      { <br>         SetCursor(hPrevCursor); <br>         return E_OUTOFMEMORY; // Error: couldn't load obj <br>      } <br>   } <br> <br>   OLEDBG_BEGIN2("OleRun called\r\n") <br>   hrErr = OleRun((LPUNKNOWN)lpContainerLine-&gt;m_lpOleObj); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR) { <br>      SetCursor(hPrevCursor);     // restore original cursor <br> <br>      OleDbgOutHResult("OleRun returned", hrErr); <br>      OLEDBG_END3 <br>      return hrErr; <br>   } <br> <br>   if (lpContainerLine-&gt;m_fDoSetExtent) { <br>      /* NOTE: the OLE object was resized when it was not running <br>      **    and the object did not have the OLEMISC_RECOMPOSEONRESIZE <br>      **    bit set. if it had, the object would have been run <br>      **    immediately when it was resized. this flag indicates that <br>      **    the object does something other than simple scaling when <br>      **    it is resized. because the object is being run now, we <br>      **    will call IOleObject::SetExtent. <br>      */ <br>      lpContainerLine-&gt;m_fDoSetExtent = FALSE; <br> <br>      // the size stored in our Line includes the border around the object. <br>      // we must subtract the border to get the size of the object itself. <br>      sizelNew.cx = lpLine-&gt;m_nWidthInHimetric; <br>      sizelNew.cy = lpLine-&gt;m_nHeightInHimetric; <br> <br>      if ((sizelNew.cx != lpContainerLine-&gt;m_sizeInHimetric.cx) || <br>         (sizelNew.cy != lpContainerLine-&gt;m_sizeInHimetric.cy)) { <br> <br>         OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n") <br>         lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetExtent( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               lpContainerLine-&gt;m_dwDrawAspect, <br>               (LPSIZEL)&amp;sizelNew <br>         ); <br>         OLEDBG_END2 <br>      } <br>   } <br> <br>   SetCursor(hPrevCursor);     // restore original cursor <br> <br>   OLEDBG_END3 <br>   return NOERROR; <br> <br>} <br> <br> <br>/* ContainerLine_IsOleLink <br>** ----------------------- <br>** <br>**    return TRUE if the ContainerLine has an OleLink. <br>**           FALSE if the ContainerLine has an embedding <br>*/ <br>BOOL ContainerLine_IsOleLink(LPCONTAINERLINE lpContainerLine) <br>{ <br>   if (!lpContainerLine) <br>      return FALSE; <br> <br>   return (lpContainerLine-&gt;m_dwLinkType != 0); <br>} <br> <br> <br>/*  ContainerLine_Draw <br>**  ------------------ <br>** <br>**      Draw a ContainerLine object on a DC. <br>** <br>**  Parameters: <br>**      hDC     - DC to which the line will be drawn <br>**      lpRect  - the object rect in logical coordinates <br>**      lpRectWBounds - bounding rect of the metafile underneath hDC </code></pre>
<p>
</p>
<pre><code>**                      (NULL if hDC is not a metafile DC) <br>**      fHighlight    - TRUE if line has selection highlight <br>*/ <br>void ContainerLine_Draw( <br>      LPCONTAINERLINE         lpContainerLine, <br>      HDC                     hDC, <br>      LPRECT                  lpRect, <br>      LPRECT                  lpRectWBounds, <br>      BOOL                    fHighlight <br>) <br>{ <br>   LPLINE  lpLine = (LPLINE) lpContainerLine; <br>   HRESULT hrErr = NOERROR; <br>   RECTL   rclHim; <br>   RECTL   rclHimWBounds; <br>   RECT    rcHim; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--do NOT try to draw <br>      return; <br>   } <br> <br>   /* if object is not already loaded, then load it now. objects are <br>   **    loaded lazily in this manner. <br>   */ <br>   if (! lpContainerLine-&gt;m_lpViewObj2) { <br>      if (! ContainerLine_LoadOleObject(lpContainerLine)) <br>      { <br>         return;     // Error: could not load object <br>      } <br>   } <br> <br>   if (lpRectWBounds) { <br>      rclHimWBounds.left      = (long) lpRectWBounds-&gt;left; <br>      rclHimWBounds.bottom    = (long) lpRectWBounds-&gt;bottom; <br>      rclHimWBounds.top       = (long) lpRectWBounds-&gt;top; <br>      rclHimWBounds.right     = (long) lpRectWBounds-&gt;right; <br>   } <br> <br>   /* construct bounds rectangle for the object. <br>   **  offset origin for object to correct tab indentation <br>   */ <br>   rclHim.left     = (long) lpRect-&gt;left; <br>   rclHim.bottom   = (long) lpRect-&gt;bottom; <br>   rclHim.top      = (long) lpRect-&gt;top; <br>   rclHim.right    = (long) lpRect-&gt;right; <br> <br>   rclHim.left += (long) ((LPLINE)lpContainerLine)-&gt;m_nTabWidthInHimetric; <br>   rclHim.right += (long) ((LPLINE)lpContainerLine)-&gt;m_nTabWidthInHimetric; <br> <br>#if defined( INPLACE_CNTR ) <br>   /* NOTE: if the OLE object currently has a visible in-place <br>   **    window, then we do NOT want to draw on top of its window. <br>   **    this could interfere with the object's display. <br>   */ <br>   if ( !lpContainerLine-&gt;m_fIpVisible ) <br>#endif <br>   { <br>   hrErr = lpContainerLine-&gt;m_lpViewObj2-&gt;lpVtbl-&gt;Draw( <br>         lpContainerLine-&gt;m_lpViewObj2, <br>         lpContainerLine-&gt;m_dwDrawAspect, <br>         -1, <br>         NULL, <br>         NULL, <br>         NULL, <br>         hDC, <br>         (LPRECTL)&amp;rclHim, <br>         (lpRectWBounds ? (LPRECTL)&amp;rclHimWBounds : NULL), <br>         NULL, <br>         0 <br>   ); <br>   if (hrErr != NOERROR) <br>      OleDbgOutHResult("IViewObject::Draw returned", hrErr); <br> <br>   if (lpContainerLine-&gt;m_fObjWinOpen) <br>      { <br>      rcHim.left      = (int) rclHim.left; <br>      rcHim.top       = (int) rclHim.top; <br>      rcHim.right     = (int) rclHim.right; <br>      rcHim.bottom    = (int) rclHim.bottom; <br> <br>      /* NOTE: if the object servers window is Open (ie. not active <br>      **    in-place) then we must shade the object in our document to <br>      **    indicate to the user that the object is open elsewhere. <br>      */ <br>      OleUIDrawShading((LPRECT)&amp;rcHim, hDC, OLEUI_SHADE_FULLRECT, 0); <br>      } <br>   } <br> <br>   /* if the object associated with the ContainerLine is an automatic <br>   **    link then try to connect it with its LinkSource if the <br>   **    LinkSource is already running. we do not want to force the <br>   **    LinkSource to run. <br>   ** <br>   **    NOTE: a sophistocated container will want to continually <br>   **    attempt to connect its automatic links. OLE does NOT <br>   **    automatically connect links when link sources become <br>   **    available. some containers will want to attempt to connect <br>   **    its links as part of idle time processing. another strategy <br>   **    is to attempt to connect an automatic link every time it is <br>   **    drawn on the screen. (this is the strategy used by this <br>   **    CntrOutl sample application.) <br>   */ <br>   if (lpContainerLine-&gt;m_dwLinkType == OLEUPDATE_ALWAYS) <br>      ContainerLine_BindLinkIfLinkSrcIsRunning(lpContainerLine); <br> <br>   return; <br>} <br> <br> <br>void ContainerLine_DrawSelHilight( <br>      LPCONTAINERLINE lpContainerLine, <br>      HDC             hDC,            // MM_TEXT mode <br>      LPRECT          lprcPix,        // listbox rect <br>      UINT            itemAction, <br>      UINT            itemState <br>) <br>{ <br>   LPLINE  lpLine = (LPLINE)lpContainerLine; <br>   RECT    rcObj; <br>   DWORD   dwFlags = OLEUI_HANDLES_INSIDE | OLEUI_HANDLES_USEINVERSE; <br>   int     nHandleSize; <br>   LPCONTAINERDOC lpContainerDoc; <br> <br>   if (!lpContainerLine || !hDC || !lprcPix) <br>      return; <br> <br>   lpContainerDoc = lpContainerLine-&gt;m_lpDoc; <br> <br>   // Get size of OLE object <br>   ContainerLine_GetOleObjectRectInPixels(lpContainerLine, (LPRECT)&amp;rcObj); <br> <br>   nHandleSize = GetProfileInt("windows", "oleinplaceborderwidth", <br>         DEFAULT_HATCHBORDER_WIDTH) + 1; <br> <br>   OleUIDrawHandles((LPRECT)&amp;rcObj, hDC, dwFlags, nHandleSize, TRUE); <br>} <br> <br>/* InvertDiffRect <br>** -------------- <br>** <br>**    Paint the surrounding of the Obj rect black but within lprcPix <br>**      (similar to the lprcPix minus lprcObj) <br>*/ <br>static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC) <br>{ <br>   RECT rcBlack; <br> <br>   // draw black in all space outside of object's rectangle <br>   rcBlack.top = lprcPix-&gt;top; <br>   rcBlack.bottom = lprcPix-&gt;bottom; <br> <br>   rcBlack.left = lprcPix-&gt;left + 1; <br>   rcBlack.right = lprcObj-&gt;left - 1; <br>   InvertRect(hDC, (LPRECT)&amp;rcBlack); <br> <br>   rcBlack.left = lprcObj-&gt;right + 1; <br>   rcBlack.right = lprcPix-&gt;right - 1; <br>   InvertRect(hDC, (LPRECT)&amp;rcBlack); <br> <br>   rcBlack.top = lprcPix-&gt;top; <br>   rcBlack.bottom = lprcPix-&gt;top + 1; <br>   rcBlack.left = lprcObj-&gt;left - 1; <br>   rcBlack.right = lprcObj-&gt;right + 1; <br>   InvertRect(hDC, (LPRECT)&amp;rcBlack); <br> <br>   rcBlack.top = lprcPix-&gt;bottom; <br>   rcBlack.bottom = lprcPix-&gt;bottom - 1; <br>   rcBlack.left = lprcObj-&gt;left - 1; <br>   rcBlack.right = lprcObj-&gt;right + 1; <br>   InvertRect(hDC, (LPRECT)&amp;rcBlack); <br>} <br> <br> <br>/* Edit the ContainerLine line object. <br>**      returns TRUE if line was changed <br>**              FALSE if the line was NOT changed <br>*/ <br>BOOL ContainerLine_Edit(LPCONTAINERLINE lpContainerLine, HWND hWndDoc,HDC hDC) <br>{ <br>   ContainerLine_DoVerb(lpContainerLine, OLEIVERB_PRIMARY, NULL, TRUE, TRUE); <br> <br>   /* assume object was NOT changed, if it was obj will send Changed <br>   **    or Saved notification. <br>   */ <br>   return FALSE; <br>} <br> <br> <br> <br>/* ContainerLine_SetHeightInHimetric <br>** --------------------------------- <br>** <br>** Set the height of a ContainerLine object. The widht will be changed <br>** to keep the aspect ratio <br>*/ <br>void ContainerLine_SetHeightInHimetric(LPCONTAINERLINE lpContainerLine, int nHeight) <br>{ <br>   LPLINE  lpLine = (LPLINE)lpContainerLine; <br>   SIZEL   sizelOleObject; <br>   HRESULT hrErr; <br> <br>   if (!lpContainerLine) <br>      return; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--Fail to set the Height <br>      return; <br>   } <br> <br>   if (nHeight != -1) { <br>      BOOL    fMustClose = FALSE; <br>      BOOL    fMustRun   = FALSE; <br> <br>      /* if object is not already loaded, then load it now. objects are <br>      **    loaded lazily in this manner. <br>      */ <br>      if (! lpContainerLine-&gt;m_lpOleObj) <br>         ContainerLine_LoadOleObject(lpContainerLine); <br> <br>      // the height argument specifies the desired height for the Line. <br>      sizelOleObject.cy = nHeight; <br> <br>      // we will calculate the corresponding width for the object by <br>      // maintaining the current aspect ratio of the object. <br>      sizelOleObject.cx = (int)(sizelOleObject.cy * <br>            lpContainerLine-&gt;m_sizeInHimetric.cx / <br>            lpContainerLine-&gt;m_sizeInHimetric.cy); <br> <br>      /* NOTE: if the OLE object is already running then we can <br>      **    immediately call SetExtent. But, if the object is NOT <br>      **    currently running then we will check if the object <br>      **    indicates that it is normally recomposes itself on <br>      **    resizing. ie. that the object does not simply scale its <br>      **    display when it it resized. if so then we will force the <br>      **    object to run so that we can call IOleObject::SetExtent. <br>      **    SetExtent does not have any effect if the object is only <br>      **    loaded. if the object does NOT indicate that it <br>      **    recomposes on resize (OLEMISC_RECOMPOSEONRESIZE) then we <br>      **    will wait till the next time that the object is run to <br>      **    call SetExtent. we will store a flag in the ContainerLine <br>      **    to indicate that a SetExtent is necessary. It is <br>      **    necessary to persist this flag. <br>      */ <br>      if (! OleIsRunning(lpContainerLine-&gt;m_lpOleObj)) { <br>         DWORD dwStatus; <br> <br>         OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n") <br>         hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetMiscStatus( <br>               lpContainerLine-&gt;m_lpOleObj, <br>               lpContainerLine-&gt;m_dwDrawAspect, <br>               (LPDWORD)&amp;dwStatus <br>         ); <br>         OLEDBG_END2 <br>         if (hrErr == NOERROR &amp;&amp; (dwStatus &amp; OLEMISC_RECOMPOSEONRESIZE)) { <br>            // force the object to run <br>            ContainerLine_RunOleObject(lpContainerLine); <br>            fMustClose = TRUE; <br>         } else { <br>            /*  the OLE object is NOT running and does NOT <br>            **    recompose on resize. simply scale the object now <br>            **    and do the SetExtent the next time the object is <br>            **    run. we set the Line to the new size even though <br>            **    the object's extents have not been changed. <br>            **    this has the result of scaling the object's <br>            **    display to the new size. <br>            */ <br>            lpContainerLine-&gt;m_fDoSetExtent = TRUE; <br>            ContainerLine_SetLineHeightFromObjectExtent( <br>                  lpContainerLine, (LPSIZEL)&amp;sizelOleObject); <br>            return; <br>         } <br>      } <br> <br>      OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n") <br>      hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;SetExtent( <br>            lpContainerLine-&gt;m_lpOleObj, <br>            lpContainerLine-&gt;m_dwDrawAspect, <br>            (LPSIZEL)&amp;sizelOleObject); <br>      OLEDBG_END2 <br> <br>      if (hrErr != NOERROR) { <br>         /* OLE Object refuses to take on the new extents. Set the <br>         **    Line to the new size even though the object refused <br>         **    the new extents. this has the result of scaling the <br>         **    object's display to the new size. <br>         ** <br>         **    if the object HAD accepted the new extents, then it <br>         **    will send out an OnViewChange/OnDataChange <br>         **    notification. this results in our container receiving <br>         **    an OnViewChange notification; the line height will be <br>         **    reset when this notification is received. <br>         */ <br>         ContainerLine_SetLineHeightFromObjectExtent( <br>               lpContainerLine, (LPSIZEL)&amp;sizelOleObject); <br>      } <br> <br>      if (fMustClose) <br>         ContainerLine_CloseOleObject( <br>               lpContainerLine, OLECLOSE_SAVEIFDIRTY); <br>   } <br>   else { <br>      /* Set the line to default height given the natural (unscaled) <br>      **    extents of the OLE object. <br>      */ <br>      ContainerLine_SetLineHeightFromObjectExtent( <br>            lpContainerLine,(LPSIZEL)&amp;lpContainerLine-&gt;m_sizeInHimetric); <br>   } <br>} <br> <br> <br>/*  ContainerLine_SetLineHeightFromObjectExtent <br> * <br> *  Purpose: <br> *      Calculate the corresponding line height from the OleObject size <br> *      Scale the line height to fit the limit if necessary <br> * <br> *  Parameters: <br> *      lpsizelOleObject        pointer to size of OLE Object <br> * <br> *  Returns: <br> *      nil <br> */ <br>void ContainerLine_SetLineHeightFromObjectExtent( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSIZEL                 lpsizelOleObject <br>) <br>{ <br>   LPLINE lpLine = (LPLINE)lpContainerLine; <br> <br>   UINT uMaxObjectHeight = XformHeightInPixelsToHimetric(NULL, <br>         LISTBOX_HEIGHT_LIMIT); <br> <br>   if (!lpContainerLine || !lpsizelOleObject) <br>      return; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--Fail to set the Height <br>      return; <br>   } <br> <br>   lpLine-&gt;m_nWidthInHimetric = (int)lpsizelOleObject-&gt;cx; <br>   lpLine-&gt;m_nHeightInHimetric = (int)lpsizelOleObject-&gt;cy; <br> <br>   // Rescale the object if height is greater than the limit <br>   if (lpLine-&gt;m_nHeightInHimetric &gt; (UINT)uMaxObjectHeight) { <br> <br>      lpLine-&gt;m_nWidthInHimetric = (UINT) <br>            ((long)lpLine-&gt;m_nWidthInHimetric * <br>            (long)uMaxObjectHeight / <br>            (long)lpLine-&gt;m_nHeightInHimetric); <br> <br>      lpLine-&gt;m_nHeightInHimetric = uMaxObjectHeight; <br>   } <br> <br>} <br> <br> <br>/* ContainerLine_SaveToStg <br>** ----------------------- <br>**    Save a given ContainerLine and associated OLE object to an IStorage*. <br>*/ <br>BOOL ContainerLine_SaveToStm( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSTREAM                lpLLStm <br>) <br>{ <br>   CONTAINERLINERECORD_ONDISK objLineRecord; <br>   ULONG nWritten; <br>   HRESULT hrErr; <br>   //  Compilers should handle alignment correctly <br> <br>   OLESTRCPY(objLineRecord.m_szStgName, lpContainerLine-&gt;m_szStgName); <br>   objLineRecord.m_fMonikerAssigned = (USHORT)lpContainerLine-&gt;m_fMonikerAssigned; <br>   objLineRecord.m_dwDrawAspect = lpContainerLine-&gt;m_dwDrawAspect; <br>   objLineRecord.m_sizeInHimetric = lpContainerLine-&gt;m_sizeInHimetric; <br>   objLineRecord.m_dwLinkType = lpContainerLine-&gt;m_dwLinkType; <br>   objLineRecord.m_fDoSetExtent = (USHORT) lpContainerLine-&gt;m_fDoSetExtent; <br> <br>   /* write line record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>         lpLLStm, <br>         (LPVOID)&amp;objLineRecord, <br>         sizeof(objLineRecord), <br>         &amp;nWritten <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr == NOERROR,"Could not write to LineList stream"); <br>    { <br>      return FALSE; <br>    } <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* ContainerLine_SaveOleObjectToStg <br>** -------------------------------- <br>**    Save the OLE object associated with the ContainerLine to an IStorage*. <br>*/ <br>BOOL ContainerLine_SaveOleObjectToStg( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTORAGE               lpDestStg, <br>      BOOL                    fRemember <br>) <br>{ <br>   HRESULT         hrErr; <br>   SCODE           sc = S_OK; <br>   BOOL            fStatus; <br>   BOOL            fSameAsLoad = (lpSrcStg==lpDestStg ? TRUE : FALSE); <br>   LPSTORAGE       lpObjDestStg; <br> <br>   if (lpContainerLine-&gt;m_fGuardObj) { <br>      // object in process of creation--Fail to save <br>      return FALSE; <br>   } <br> <br>   if (! lpContainerLine-&gt;m_lpOleObj) { <br> <br>      /***************************************************************** <br>      ** CASE 1: object is NOT loaded. <br>      *****************************************************************/ <br> <br>      if (fSameAsLoad) { <br>         /************************************************************* <br>         ** CASE 1A: we are saving to the current storage. because <br>         **    the object is not loaded, it is up-to-date <br>         **    (ie. nothing to do). <br>         *************************************************************/ <br> <br>         ; <br> <br>      } else { <br>         /************************************************************* <br>         ** CASE 1B: we are saving to a new storage. because <br>         **    the object is not loaded, we can simply copy the <br>         **    object's current storage to the new storage. <br>         *************************************************************/ <br> <br>         /* if current object storage is not already open, then open it */ <br>         if (! lpContainerLine-&gt;m_lpStg) { <br>            lpContainerLine-&gt;m_lpStg = OleStdOpenChildStorage( <br>                  lpSrcStg, <br>                  lpContainerLine-&gt;m_szStgName, <br>                  STGM_READWRITE <br>               ); <br>            if (lpContainerLine-&gt;m_lpStg == NULL) { <br>#if defined( _DEBUG ) <br>               OleDbgAssertSz( <br>                     lpContainerLine-&gt;m_lpStg != NULL, <br>                     "Error opening child stg" <br>               ); <br>#endif <br>               return FALSE; <br>            } <br>         } <br> <br>         /* Create a child storage inside the destination storage. */ <br>         lpObjDestStg = OleStdCreateChildStorage( <br>               lpDestStg, <br>               lpContainerLine-&gt;m_szStgName <br>         ); <br> <br>         if (lpObjDestStg == NULL) { <br>#if defined( _DEBUG ) <br>            OleDbgAssertSz( <br>                  lpObjDestStg != NULL, <br>                  "Could not create obj storage!" <br>            ); <br>#endif <br>            return FALSE; <br>         } <br> <br>         hrErr = lpContainerLine-&gt;m_lpStg-&gt;lpVtbl-&gt;CopyTo( <br>               lpContainerLine-&gt;m_lpStg, <br>               0, <br>               NULL, <br>               NULL, <br>               lpObjDestStg <br>         ); <br>         // REVIEW: should we handle error here? <br>         fStatus = OleStdCommitStorage(lpObjDestStg); <br> <br>         /* if we are supposed to remember this storage as the new <br>         **    storage for the object, then release the old one and <br>         **    save the new one. else, throw away the new one. <br>         */ <br>         if (fRemember) { <br>            OleStdVerifyRelease( <br>                  (LPUNKNOWN)lpContainerLine-&gt;m_lpStg, <br>                  OLESTR("Original object stg not released") <br>            ); <br>            lpContainerLine-&gt;m_lpStg = lpObjDestStg; <br>         } else { <br>            OleStdVerifyRelease( <br>                  (LPUNKNOWN)lpObjDestStg, <br>                  OLESTR("Copied object stg not released") <br>            ); <br>         } <br>      } <br> <br>   } else { <br> <br>      /***************************************************************** <br>      ** CASE 2: object IS loaded. <br>      *****************************************************************/ <br> <br>      if (fSameAsLoad) { <br>         /************************************************************* <br>         ** CASE 2A: we are saving to the current storage. if the object <br>         **    is not dirty, then the current storage is up-to-date <br>         **    (ie. nothing to do). <br>         *************************************************************/ <br> <br>         LPPERSISTSTORAGE lpPersistStg = lpContainerLine-&gt;m_lpPersistStg; <br>         OleDbgAssert(lpPersistStg); <br> <br>         hrErr = lpPersistStg-&gt;lpVtbl-&gt;IsDirty(lpPersistStg); <br> <br>         /* NOTE: we will only accept an explicit "no i <br>         **    am NOT dirty statement" (ie. S_FALSE) as an <br>         **    indication that the object is clean. eg. if <br>         **    the object returns E_NOTIMPL we must <br>         **    interpret it as the object IS dirty. <br>         */ <br>         if (hrErr != S_FALSE) { <br> <br>            /* OLE object IS dirty */ <br> <br>            OLEDBG_BEGIN2("OleSave called\r\n") <br>            hrErr = OleSave( <br>                  lpPersistStg, lpContainerLine-&gt;m_lpStg, fSameAsLoad); <br>            OLEDBG_END2 <br> <br>            if (hrErr != NOERROR) { <br>               OleDbgOutHResult("WARNING: OleSave returned", hrErr); <br>               sc = hrErr; <br>            } <br> <br>            // NOTE: if OleSave fails, SaveCompleted must be called. <br>            OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n") <br>            hrErr=lpPersistStg-&gt;lpVtbl-&gt;SaveCompleted(lpPersistStg,NULL); <br>            OLEDBG_END2 <br> <br>            if (hrErr != NOERROR) { <br>               OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr); <br>               if (sc == S_OK) <br>                  sc = hrErr; <br>            } <br> <br>            if (sc != S_OK) <br>            { <br>               return FALSE; <br>            } <br>         } <br> <br>      } else { <br>         /************************************************************* <br>         ** CASE 2B: we are saving to a new storage. we must <br>         **    tell the object to save into the new storage. <br>         *************************************************************/ <br> <br>         LPPERSISTSTORAGE lpPersistStg = lpContainerLine-&gt;m_lpPersistStg; <br> <br>         if (! lpPersistStg) return FALSE; <br> <br>         /* Create a child storage inside the destination storage. */ <br>         lpObjDestStg = OleStdCreateChildStorage( <br>               lpDestStg, <br>               lpContainerLine-&gt;m_szStgName <br>         ); <br> <br>         if (lpObjDestStg == NULL) { <br>#if defined( _DEBUG ) <br>            OleDbgAssertSz( <br>                  lpObjDestStg != NULL, <br>                  "Could not create object storage!" <br>            ); <br>#endif <br>            return FALSE; <br>         } <br> <br>         OLEDBG_BEGIN2("OleSave called\r\n") <br>         hrErr = OleSave(lpPersistStg, lpObjDestStg, fSameAsLoad); <br>         OLEDBG_END2 <br> <br>         // NOTE: even if OleSave fails, must still call SaveCompleted <br>         if (hrErr != NOERROR) { <br>            OleDbgOutHResult("WARNING: OleSave returned", hrErr); <br>            sc = hrErr; <br>         } <br> <br>         /* NOTE: a root level container should immediately <br>         **    call IPersistStorage::SaveCompleted after calling <br>         **    OleSave. a nested level container should not call <br>         **    SaveCompleted now, but must wait until SaveCompleted <br>         **    is call on it by its container. since our container <br>         **    is not a container/server, then we always call <br>         **    SaveComplete here. <br>         ** <br>         **    if this is a SaveAs operation, then we need to pass <br>         **    the lpStg back in SaveCompleted to inform the object <br>         **    of its new storage that it may hold on to. if this is <br>         **    a Save or a SaveCopyAs operation, then we simply pass <br>         **    NULL in SaveCompleted; the object can continue to hold <br>         **    its current storage. if an error occurs during the <br>         **    OleSave call we must still call SaveCompleted but we <br>         **    must pass NULL. <br>         */ <br>         OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n") <br>         hrErr = lpPersistStg-&gt;lpVtbl-&gt;SaveCompleted( <br>               lpPersistStg, <br>               ((FAILED(sc) || !fRemember) ? NULL : lpObjDestStg) <br>         ); <br>         OLEDBG_END2 <br> <br>         if (hrErr != NOERROR) { <br>            OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr); <br>            if (sc == S_OK) <br>               sc = hrErr; <br>         } <br> <br>         if (sc != S_OK) { <br>            OleStdVerifyRelease( <br>                  (LPUNKNOWN)lpObjDestStg, <br>                  OLESTR("Copied object stg not released") <br>            ); <br>            return FALSE; <br>         } <br> <br>         /* if we are supposed to remember this storage as the new <br>         **    storage for the object, then release the old one and <br>         **    save the new one. else, throw away the new one. <br>         */ <br>         if (fRemember) { <br>            OleStdVerifyRelease( <br>                  (LPUNKNOWN)lpContainerLine-&gt;m_lpStg, <br>                  OLESTR("Original object stg not released") <br>            ); <br>            lpContainerLine-&gt;m_lpStg = lpObjDestStg; <br>         } else { <br>            OleStdVerifyRelease( <br>                  (LPUNKNOWN)lpObjDestStg, <br>                  OLESTR("Copied object stg not released") <br>            ); <br>         } <br>      } <br>   } <br> <br>   /* NOTE: after saving an OLE object it is possible that it sent <br>   **    an OnViewChange notification because it had been modified. in <br>   **    this situation it is possible that the extents of the object <br>   **    have changed. if so we want to relayout the space for the <br>   **    object immediately so that the extent information saved with <br>   **    the ContainerLine match the data saved with the OLE object <br>   **    itself. <br>   */ <br>   if (lpContainerLine-&gt;m_fDoGetExtent) { <br>      BOOL fSizeChanged = ContainerLine_UpdateExtent(lpContainerLine, NULL); <br>#if defined( INPLACE_CNTR ) <br>      /* if the extents of this ContainerLine have changed, then we <br>      **    need to reset the fDoGetExtent flag to TRUE so that later <br>      **    when ContainerDoc_UpdateExtentOfAllOleObjects is called <br>      **    (when the WM_U_UPDATEOBJECTEXTENT message is processed), <br>      **    it is recognized that the extents of this line have <br>      **    changed. if any line changes size, then any in-place <br>      **    active object below this line must be told to update the <br>      **    position of their windows (via SetObjectRects -- see <br>      **    ContainerDoc_UpdateInPlaceObjectRects function). <br>      */ <br>      lpContainerLine-&gt;m_fDoGetExtent = fSizeChanged; <br>#endif <br>   } <br> <br>   return TRUE; <br>} <br> <br> <br>/* ContainerLine_LoadFromStg <br>** ------------------------- <br>**    Create a ContainerLine object and initialize it with data that <br>**    was previously writen to an IStorage*. this function does not <br>**    immediately OleLoad the associated OLE object, only the data of <br>**    the ContainerLine object itself is loaded from the IStorage*. <br>*/ <br>LPLINE ContainerLine_LoadFromStg( <br>      LPSTORAGE               lpSrcStg, <br>      LPSTREAM                lpLLStm, <br>      LPOUTLINEDOC            lpDestDoc <br>) <br>{ <br>   HDC         hDC; <br>   LPLINELIST  lpDestLL = &amp;lpDestDoc-&gt;m_LineList; <br>   ULONG nRead; <br>   HRESULT hrErr; <br>   LPCONTAINERLINE lpContainerLine; <br>   CONTAINERLINERECORD_ONDISK objLineRecord; <br> <br>   lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE)); <br>   if (lpContainerLine == NULL) { <br>      OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine"); <br>      return NULL; <br>   } <br> <br>   hDC = LineList_GetDC(lpDestLL); <br>   ContainerLine_Init(lpContainerLine, 0, hDC); <br>   LineList_ReleaseDC(lpDestLL, hDC); <br> <br>   /* NOTE: In order to have a stable ContainerLine object we must <br>   **    AddRef the object's refcnt. this will be later released when <br>   **    the ContainerLine is deleted. <br>   */ <br>   ContainerLine_AddRef(lpContainerLine); <br> <br>   lpContainerLine-&gt;m_lpDoc = (LPCONTAINERDOC) lpDestDoc; <br> <br>   /* read line record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>         lpLLStm, <br>         (LPVOID)&amp;objLineRecord, <br>         sizeof(objLineRecord), <br>         &amp;nRead <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgAssertSz(hrErr==NOERROR, "Could not read from LineList stream"); <br>      goto error; <br>   } <br> <br>   //  Compilers should handle alignment correctly <br>   OLESTRCPY(lpContainerLine-&gt;m_szStgName, objLineRecord.m_szStgName); <br>   lpContainerLine-&gt;m_fMonikerAssigned = (BOOL) objLineRecord.m_fMonikerAssigned; <br>   lpContainerLine-&gt;m_dwDrawAspect = objLineRecord.m_dwDrawAspect; <br>   lpContainerLine-&gt;m_sizeInHimetric = objLineRecord.m_sizeInHimetric; <br>   lpContainerLine-&gt;m_dwLinkType = objLineRecord.m_dwLinkType; <br>   lpContainerLine-&gt;m_fDoSetExtent = (BOOL) objLineRecord.m_fDoSetExtent; <br> <br>   return (LPLINE)lpContainerLine; <br> <br>error: <br>   // destroy partially created ContainerLine <br>   if (lpContainerLine) <br>      ContainerLine_Delete(lpContainerLine); <br>   return NULL; <br>} <br> <br> <br>/* ContainerLine_GetTextLen <br> * ------------------------ <br> * <br> * Return length of the string representation of the ContainerLine <br> *  (not considering the tab level). we will use the following as the <br> *  string representation of a ContainerLine: <br> *      "&lt;" + user type name of OLE object + "&gt;" <br> *  eg: <br> *      &lt;Microsoft Excel Worksheet&gt; <br> */ <br>int ContainerLine_GetTextLen(LPCONTAINERLINE lpContainerLine) <br>{ <br>   LPOLESTR   lpszUserType = NULL; <br>   HRESULT hrErr; <br>   int     nLen; <br>   BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine); <br> <br>   /* if object is not already loaded, then load it now. objects are <br>   **    loaded lazily in this manner. <br>   */ <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_LoadOleObject(lpContainerLine); <br> <br>   OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n") <br>   hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         USERCLASSTYPE_FULL, <br>         &amp;lpszUserType <br>   ); <br>   OLEDBG_END2 <br> <br>   if (hrErr != NOERROR)   { <br>      // user type is NOT available <br>      nLen = sizeof(UNKNOWN_OLEOBJ_TYPE) + 2; // allow space for '&lt;' + '&gt;' <br>      nLen += lstrlen((LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)) + 1; <br>   } else { <br>      nLen = OLESTRLEN(lpszUserType) + 2;   // allow space for '&lt;' + '&gt;' <br>      nLen += OLESTRLEN(/*(LPOLESTR)*/(fIsLink ? szOLELINK : szOLEOBJECT)) + 1; <br> <br>      /* NOTE: we must free the string that was allocated by the <br>      **    IOleObject::GetUserType method. <br>      */ <br>      OleStdFreeString(lpszUserType, NULL); <br>   } <br> <br>   return nLen; <br>} <br> <br> <br>/* ContainerLine_GetTextData <br> * ------------------------- <br> * <br> * Return the string representation of the ContainerLine <br> *  (not considering the tab level). we will use the following as the <br> *  string representation of a ContainerLine: <br> *      "&lt;" + user type name of OLE object + "&gt;" <br> *  eg: <br> *      &lt;Microsoft Excel Worksheet&gt; <br> */ <br>void ContainerLine_GetTextData(LPCONTAINERLINE lpContainerLine, LPOLESTR lpszBuf) <br>{ <br>   LPOLESTR   lpszUserType = NULL; <br>   BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine); <br>   HRESULT hrErr; <br>   char    szAnsiBuf[256], szAnsiUserType[256], szAnsiString[256]; <br>   LPOLESTR lpszUniStr; <br> <br>   /* if object is not already loaded, then load it now. objects are <br>   **    loaded lazily in this manner. <br>   */ <br>   if (! lpContainerLine-&gt;m_lpOleObj) <br>      ContainerLine_LoadOleObject(lpContainerLine); <br> <br>   hrErr = lpContainerLine-&gt;m_lpOleObj-&gt;lpVtbl-&gt;GetUserType( <br>         lpContainerLine-&gt;m_lpOleObj, <br>         USERCLASSTYPE_FULL, <br>         &amp;lpszUserType <br>   ); <br> <br>   W2A (lpszUserType, szAnsiUserType, 256); <br>   lpszUniStr = (fIsLink ? szOLELINK : szOLEOBJECT); <br>   W2A (lpszUniStr, szAnsiString, 256); <br>   if (hrErr != NOERROR)   { <br>      // user type is NOT available <br>      wsprintf( <br>            szAnsiBuf, <br>            "&lt;%s %s&gt;", <br>            UNKNOWN_OLEOBJ_TYPE, <br>            (LPSTR)szAnsiString <br>      ); <br>   } else { <br>      wsprintf( <br>            szAnsiBuf, <br>            "&lt;%s %s&gt;", </code></pre>
<p>
</p>
<pre><code>szAnsiUserType, <br>            (LPSTR)szAnsiString <br>      ); <br> <br>      /* NOTE: we must free the string that was allocated by the <br>      **    IOleObject::GetUserType method. <br>      */ <br>      OleStdFreeString(lpszUserType, NULL); <br>   } <br>   A2W (szAnsiBuf, lpszBuf, 256); // lpszBuf should be big enough <br>} <br> <br> <br>/* ContainerLine_GetOutlineData <br> * ---------------------------- <br> * <br> * Return the CF_OUTLINE format data for the ContainerLine. <br> */ <br>BOOL ContainerLine_GetOutlineData( <br>      LPCONTAINERLINE         lpContainerLine, <br>      LPTEXTLINE              lpBuf <br>) <br>{ <br>   LPLINE      lpLine = (LPLINE)lpContainerLine; <br>   LPLINELIST  lpLL = &amp;((LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc)-&gt;m_LineList; <br>   HDC         hDC; <br>   OLECHAR     szTmpBuf[MAXSTRLEN+1]; <br>   char        szAnsiStr[256]; <br>   LPTEXTLINE  lpTmpTextLine; <br> <br>   // Create a TextLine with the Text representation of the ContainerLine. <br>   ContainerLine_GetTextData(lpContainerLine, /*(LPOLESTR)*/szTmpBuf); <br> <br>   hDC = LineList_GetDC(lpLL); <br>   W2A (szTmpBuf, szAnsiStr, 256); <br>   lpTmpTextLine = TextLine_Create(hDC, lpLine-&gt;m_nTabLevel, szAnsiStr); <br>   LineList_ReleaseDC(lpLL, hDC); <br> <br>   TextLine_Copy(lpTmpTextLine, lpBuf); <br> <br>   // Delete the temporary TextLine <br>   TextLine_Delete(lpTmpTextLine); <br>   return TRUE; <br>} <br> <br> <br>/* ContainerLine_GetPosRect <br>** ----------------------- <br>**    Get the PosRect in client coordinates for the OLE object's window. <br>** <br>** NOTE: the PosRect must take into account the scroll postion of <br>**    the document window. <br>*/ <br>void ContainerLine_GetPosRect( <br>      LPCONTAINERLINE     lpContainerLine, <br>      LPRECT              lprcPosRect <br>) <br>{ <br>   ContainerLine_GetOleObjectRectInPixels(lpContainerLine,lprcPosRect); <br> <br>   // shift rect for left margin <br>   lprcPosRect-&gt;left += lpContainerLine-&gt;m_nHorizScrollShift; <br>   lprcPosRect-&gt;right += lpContainerLine-&gt;m_nHorizScrollShift; <br>} <br> <br> <br>/* ContainerLine_GetOleObjectRectInPixels <br>** -------------------------------------- <br>**    Get the extent of the OLE Object contained in the given Line in <br>**    client coordinates after scaling. <br>*/ <br>void ContainerLine_GetOleObjectRectInPixels(LPCONTAINERLINE lpContainerLine, LPRECT lprc) <br>{ <br>   LPOUTLINEDOC lpOutlineDoc; <br>   LPSCALEFACTOR lpscale; <br>   LPLINELIST lpLL; <br>   LPLINE lpLine; <br>   int nIndex; <br>   HDC hdcLL; <br> <br>   if (!lpContainerLine || !lprc) <br>      return; <br> <br>   lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine-&gt;m_lpDoc; <br>   lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc); <br>   lpLL = OutlineDoc_GetLineList(lpOutlineDoc); <br>   lpLine = (LPLINE)lpContainerLine; <br>   nIndex = LineList_GetLineIndex(lpLL, lpLine); <br> <br>   LineList_GetLineRect(lpLL, nIndex, lprc); <br> <br>   hdcLL = GetDC(lpLL-&gt;m_hWndListBox); <br> <br>   /* lprc is set to be size of Line Object (including the boundary) */ <br>   lprc-&gt;left += (int)( <br>         (long)XformWidthInHimetricToPixels(hdcLL, <br>               lpLine-&gt;m_nTabWidthInHimetric + <br>               LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) * <br>         lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br>   lprc-&gt;right = (int)( <br>         lprc-&gt;left + (long) <br>         XformWidthInHimetricToPixels(hdcLL, lpLine-&gt;m_nWidthInHimetric) * <br>         lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br> <br>   ReleaseDC(lpLL-&gt;m_hWndListBox, hdcLL); <br>} <br> <br> <br>/* ContainerLine_GetOleObjectSizeInHimetric <br>** ---------------------------------------- <br>**    Get the size of the OLE Object contained in the given Line <br>*/ <br>void ContainerLine_GetOleObjectSizeInHimetric(LPCONTAINERLINE lpContainerLine, LPSIZEL lpsizel) <br>{ <br>   if (!lpContainerLine || !lpsizel) <br>      return; <br> <br>   *lpsizel = lpContainerLine-&gt;m_sizeInHimetric; <br>} <br> <br> <br>/* ContainerLine_BindLinkIfLinkSrcIsRunning <br>** ---------------------------------------- <br>**    Try to connect the OLE link object associated with the <br>**    ContainerLine with its LinkSource if the LinkSource is already <br>**    running and the link is an automatic link. we do not want to <br>**    force the LinkSource to run. <br>** <br>**    NOTE: a sophistocated container will want to continually <br>**    attempt to connect its automatic links. OLE does NOT <br>**    automatically connect links when link source become available. some <br>**    containers will want to attempt to connect its links as part of <br>**    idle time processing. another strategy is to attempt to connect <br>**    an automatic link every time it is drawn on the screen. (this is <br>**    the strategy used by this CntrOutl sample application.) <br>*/ <br>void ContainerLine_BindLinkIfLinkSrcIsRunning(LPCONTAINERLINE lpContainerLine) <br>{ <br>   LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp; <br>   HRESULT hrErr; <br>   BOOL fPrevEnable1; <br>   BOOL fPrevEnable2; <br> <br>   // if the link source is known to be un-bindable, then don't even try <br>   if (lpContainerLine-&gt;m_fLinkUnavailable) <br>      return; <br> <br>   /* NOTE: we do not want to ever give the Busy/NotResponding <br>   **    dialogs when we are attempting to BindIfRunning to the link <br>   **    source. if the link source is currently busy, this could <br>   **    cause the Busy dialog to come up. even if the link source is <br>   **    busy, we do not want put up the busy dialog. thus we will <br>   **    disable the dialog and later re-enable them <br>   */ <br>   OleApp_DisableBusyDialogs(lpOleApp, &amp;fPrevEnable1, &amp;fPrevEnable2); <br> <br>   OLEDBG_BEGIN2("IOleLink::BindIfRunning called\r\n") <br>   hrErr = lpContainerLine-&gt;m_lpOleLink-&gt;lpVtbl-&gt;BindIfRunning( <br>         lpContainerLine-&gt;m_lpOleLink); <br>   OLEDBG_END2 <br> <br>   // re-enable the Busy/NotResponding dialogs <br>   OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
