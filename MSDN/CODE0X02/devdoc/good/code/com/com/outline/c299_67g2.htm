<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OUTLLIST.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context302"></a>OUTLLIST.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    outldata.c <br>** <br>**    This file contains LineList and NameTable functions <br>**    and related support functions. <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br>OLECHAR ErrMsgListBox[] = OLESTR("Can't create ListBox!"); <br> <br>static int g_iMapMode; <br> <br>/* LineList_Init <br> * ------------- <br> * <br> *      Create and Initialize the LineList (owner-drawn listbox) <br> */ <br>BOOL LineList_Init(LPLINELIST lpLL, LPOUTLINEDOC lpOutlineDoc) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br> <br>#if defined( INPLACE_CNTR ) <br>   lpLL-&gt;m_hWndListBox = CreateWindow( <br>               "listbox",              /* Window class name           */ <br>               NULL,                   /* Window's title              */ <br> <br>               /* NOTE: an in-place contanier MUST use <br>               **    WS_CLIPCHILDREN window style for the window <br>               **    that it uses as the parent for the server's <br>               **    in-place active window so that its <br>               **    painting does NOT interfere with the painting <br>               **    of the server's in-place active child window. <br>               */ <br> <br>               WS_CLIPCHILDREN | <br>               WS_CHILDWINDOW | <br>               WS_VISIBLE | <br>               WS_VSCROLL | <br>               WS_HSCROLL | <br>               LBS_EXTENDEDSEL | <br>               LBS_NOTIFY | <br>               LBS_OWNERDRAWVARIABLE | <br>               LBS_NOINTEGRALHEIGHT | <br>               LBS_USETABSTOPS, <br>               0, 0,                   /* Use default X, Y            */ <br>               0, 0,                   /* Use default X, Y            */ <br>               lpOutlineDoc-&gt;m_hWndDoc,/* Parent window's handle      */ <br>               (HMENU)IDC_LINELIST,    /* Child Window ID             */ <br>               lpOutlineApp-&gt;m_hInst,  /* Instance of window          */ <br>               NULL);                  /* Create struct for WM_CREATE */ <br>#else <br>   lpLL-&gt;m_hWndListBox = CreateWindow( <br>               "listbox",              /* Window class name           */ <br>               NULL,                   /* Window's title              */ <br>               WS_CHILDWINDOW | <br>               WS_VISIBLE | <br>               WS_VSCROLL | <br>               WS_HSCROLL | <br>               LBS_EXTENDEDSEL | <br>               LBS_NOTIFY | <br>               LBS_OWNERDRAWVARIABLE | <br>               LBS_NOINTEGRALHEIGHT | <br>               LBS_USETABSTOPS, <br>               0, 0,                   /* Use default X, Y            */ <br>               0, 0,                   /* Use default X, Y            */ <br>               lpOutlineDoc-&gt;m_hWndDoc,/* Parent window's handle      */ <br>               (HMENU)IDC_LINELIST,    /* Child Window ID             */ <br>               lpOutlineApp-&gt;m_hInst,  /* Instance of window          */ <br>               NULL);                  /* Create struct for WM_CREATE */ <br> <br>#endif <br> <br> <br>   if(! lpLL-&gt;m_hWndListBox) { <br>      OutlineApp_ErrorMessage(g_lpApp, ErrMsgListBox); <br>      return FALSE; <br>   } <br> <br>   lpOutlineApp-&gt;m_ListBoxWndProc = <br>         (FARPROC) GetWindowLong ( lpLL-&gt;m_hWndListBox, GWL_WNDPROC ); <br>   SetWindowLong (lpLL-&gt;m_hWndListBox, GWL_WNDPROC, (LONG) LineListWndProc); <br> <br>#if defined ( USE_DRAGDROP ) <br>   /* m_iDragOverLine saves index of line that has drag/drop target <br>   **    feedback. we currently use our focus rectangle feedback for <br>   **    this. it would be better to have a different visual feedback <br>   **    for potential target of the pending drop. <br>   */ <br>   lpLL-&gt;m_iDragOverLine = -1; <br>#endif <br> <br>   lpLL-&gt;m_nNumLines = 0; <br>   lpLL-&gt;m_nMaxLineWidthInHimetric = 0; <br>   lpLL-&gt;m_lpDoc = lpOutlineDoc; <br>   _fmemset(&amp;lpLL-&gt;m_lrSaveSel, 0, sizeof(LINERANGE)); <br> <br>   return TRUE; <br>} <br> <br> <br>/* LineList_Destroy <br> * ---------------- <br> * <br> *      Clear (delete) all Line objects from the list and free supporting <br> *      memory (ListBox Window) used by the LineList object itself. <br> */ <br>void LineList_Destroy(LPLINELIST lpLL) <br>{ <br>   int i; <br>   int linesTotal = lpLL-&gt;m_nNumLines; <br> <br>   // Delete all Line objects <br>   for (i = 0; i &lt; linesTotal; i++) <br>      LineList_DeleteLine(lpLL, 0);   // NOTE: always delete line 0 <br> <br>   // Remove all Lines from the ListBox <br>   SendMessage(lpLL-&gt;m_hWndListBox,LB_RESETCONTENT,0,0L); <br> <br>   lpLL-&gt;m_nNumLines=0; <br>   DestroyWindow(lpLL-&gt;m_hWndListBox); <br>   lpLL-&gt;m_hWndListBox = NULL; <br>} <br> <br> <br>/* LineList_AddLine <br> * ---------------- <br> * <br> *      Add one line to the list box. The line is added following the <br> * line with index "nIndex". If nIndex is larger than the number of lines <br> * in the ListBox, then the line is appended to the end. The selection <br> * is set to the newly added line. <br> */ <br>void LineList_AddLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex) <br>{ <br>   int nAddIndex = (lpLL-&gt;m_nNumLines == 0 ? <br>         0 : <br>         (nIndex &gt;= lpLL-&gt;m_nNumLines ? lpLL-&gt;m_nNumLines : nIndex+1)); <br>   LINERANGE lrSel; <br> <br>#if defined( USE_HEADING ) <br>   int nHeight = Line_GetHeightInHimetric(lpLine); <br> <br>   nHeight = XformHeightInHimetricToPixels(NULL, nHeight); <br> <br>   // Add a dummy string to the row heading <br>   Heading_RH_SendMessage(OutlineDoc_GetHeading(lpLL-&gt;m_lpDoc), <br>         LB_INSERTSTRING, (WPARAM)nAddIndex, MAKELPARAM(nHeight, 0)); <br>#endif <br> <br> <br>   lrSel.m_nStartLine = nAddIndex; <br>   lrSel.m_nEndLine =   nAddIndex; <br> <br>   if (!lpLine) { <br>      OutlineApp_ErrorMessage(g_lpApp, OLESTR("Could not create line.")); <br>      return; <br>   } <br> <br>   SendMessage(lpLL-&gt;m_hWndListBox, LB_INSERTSTRING, (WPARAM)nAddIndex, <br>         (DWORD)lpLine); <br> <br>   LineList_SetMaxLineWidthInHimetric( <br>         lpLL, <br>         Line_GetTotalWidthInHimetric(lpLine) <br>   ); <br> <br>   lpLL-&gt;m_nNumLines++; <br> <br>   LineList_SetSel(lpLL, &amp;lrSel); <br>} <br> <br> <br>/* LineList_DeleteLine <br> * ------------------- <br> * <br> *      Delete one line from listbox and memory <br> */ <br>void LineList_DeleteLine(LPLINELIST lpLL, int nIndex) <br>{ <br>   LPLINE lpLine = LineList_GetLine(lpLL, nIndex); <br>   BOOL fResetSel; <br> <br>   fResetSel = (BOOL)SendMessage(lpLL-&gt;m_hWndListBox, LB_GETSEL, (WPARAM)nIndex, 0L); <br> <br>   if (lpLine) <br>      Line_Delete(lpLine);    // free memory of Line <br> <br>   // Remove the Line from the ListBox <br>   SendMessage(lpLL-&gt;m_hWndListBox, LB_DELETESTRING, (WPARAM)nIndex, 0L); <br>   lpLL-&gt;m_nNumLines--; <br> <br>   if (fResetSel) { <br>      if (nIndex &gt; 0) { <br>#if defined( WIN32 ) <br>         SendMessage( <br>               lpLL-&gt;m_hWndListBox, <br>               LB_SETSEL, <br>               (WPARAM)TRUE, <br>               (LPARAM)nIndex-1 <br>         ); <br>#else <br>         SendMessage( <br>               lpLL-&gt;m_hWndListBox, <br>               LB_SETSEL, <br>               (WPARAM)TRUE, <br>               MAKELPARAM(nIndex-1,0) <br>         ); <br>#endif <br>      } else { <br>         if (lpLL-&gt;m_nNumLines &gt; 0) { <br>#if defined( WIN32 ) <br>            SendMessage( <br>                  lpLL-&gt;m_hWndListBox, <br>                  LB_SETSEL, <br>                  (WPARAM)TRUE, <br>                  (LPARAM)0 <br>            ); <br>#else <br>            SendMessage( <br>                  lpLL-&gt;m_hWndListBox, <br>                  LB_SETSEL, <br>                  (WPARAM)TRUE, <br>                  MAKELPARAM(0,0) <br>            ); <br>#endif <br>         } <br>      } <br>   } <br> <br>#if defined( USE_HEADING ) <br>   // Remove the dummy string from the row heading <br>   Heading_RH_SendMessage(OutlineDoc_GetHeading(lpLL-&gt;m_lpDoc), <br>         LB_DELETESTRING, (WPARAM)nIndex, 0L); <br>#endif <br> <br>} <br> <br> <br>/* LineList_ReplaceLine <br> * -------------------- <br> * <br> *      Replace the line at a given index in the list box with a new <br> * line. <br> */ <br>void LineList_ReplaceLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex) <br>{ <br>   LPLINE lpOldLine = LineList_GetLine(lpLL, nIndex); <br> <br>   if (lpOldLine) <br>      Line_Delete(lpOldLine);    // free memory of Line <br>   else <br>      return;     // if no previous line then invalid index <br> <br>   SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_SETITEMDATA, <br>         (WPARAM)nIndex, <br>         (LPARAM)lpLine <br>   ); <br>} <br> <br> <br>/* LineList_GetLineIndex <br> * --------------------- <br> * <br> *      Return the index of the Line given a pointer to the line. <br> *      Return -1 if the line is not found. <br> */ <br>int LineList_GetLineIndex(LPLINELIST lpLL, LPLINE lpLine) <br>{ <br>   LRESULT lRet; <br> <br>   if (! lpLine) return -1; <br> <br>   lRet = SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_FINDSTRING, <br>         (WPARAM)-1, <br>         (LPARAM)(LPCSTR)lpLine <br>      ); <br> <br>   return ((lRet == LB_ERR) ? -1 : (int)lRet); <br>} <br> <br> <br>/* LineList_GetLine <br> * ---------------- <br> * <br> *      Retrieve the pointer to the Line given its index in the LineList <br> */ <br>LPLINE LineList_GetLine(LPLINELIST lpLL, int nIndex) <br>{ <br>   DWORD dWord; <br>   LRESULT lRet; <br> <br>   if (lpLL-&gt;m_nNumLines == 0 || nIndex &gt; lpLL-&gt;m_nNumLines || nIndex &lt; 0) <br>      return NULL; <br> <br>   lRet = SendMessage( <br>         lpLL-&gt;m_hWndListBox,LB_GETTEXT,nIndex,(LPARAM)(LPCSTR)&amp;dWord); <br> <br>   return ((lRet == LB_ERR || lRet == 0) ? NULL : (LPLINE)dWord); <br>} <br> <br> <br>/* LineList_SetFocusLine <br> * --------------------- <br> * <br> */ <br> <br>void LineList_SetFocusLine ( LPLINELIST lpLL, WORD wIndex ) <br>{ <br> <br>   SendMessage(lpLL-&gt;m_hWndListBox, LB_SETCARETINDEX, (WPARAM)wIndex, 0L ); <br> <br>} <br> <br> <br>/* LineList_GetLineRect <br> * -------------------- <br> * <br> * Retrieve the rectangle of a Line given its index in the LineList <br> */ <br>BOOL LineList_GetLineRect(LPLINELIST lpLL, int nIndex, LPRECT lpRect) <br>{ <br>   DWORD iReturn = (DWORD)LB_ERR; <br> <br>   if ( !(lpLL-&gt;m_nNumLines == 0 || nIndex &gt; lpLL-&gt;m_nNumLines || nIndex &lt; 0) ) <br>      iReturn = SendMessage(lpLL-&gt;m_hWndListBox,LB_GETITEMRECT,nIndex,(LPARAM)lpRect); <br> <br>   return (iReturn == LB_ERR ? FALSE : TRUE ); <br>} <br> <br> <br>/* LineList_GetFocusLineIndex <br> * -------------------------- <br> * <br> * Get the index of the line that currently has focus (the active line). <br> */ <br>int LineList_GetFocusLineIndex(LPLINELIST lpLL) <br>{ <br>   return (int)SendMessage(lpLL-&gt;m_hWndListBox,LB_GETCARETINDEX,0,0L); <br>} <br> <br> <br>/* LineList_GetCount <br> * ----------------- <br> * <br> *      Return number of line objects <br> */ <br>int LineList_GetCount(LPLINELIST lpLL) <br>{ <br>   if (lpLL) <br>      return lpLL-&gt;m_nNumLines; <br>   else { <br>      OleDbgAssert(lpLL!=NULL); <br>      return 0; <br>   } <br>} <br> <br> <br>/* LineList_SetMaxLineWidthInHimetric <br> * ---------------------------------- <br> * <br> *  Adjust the maximum line width for the listbox. The max line width is <br> *  used to determine if a horizontal scroll bar is needed. <br> * <br> *  Parameters: <br> *      nWidthInHimetric - if +ve, width of an additional line <br> *                       - if -ve, reset Max to be the value <br> * <br> *  Returns: <br> *      TRUE is max line width of LineList changed <br> *      FALSE if no change <br> */ <br>BOOL LineList_SetMaxLineWidthInHimetric(LPLINELIST lpLL, int nWidthInHimetric) <br>{ <br>   int nWidthInPix; <br>   BOOL fSizeChanged = FALSE; <br>   LPSCALEFACTOR lpscale; <br> <br>   if (!lpLL) <br>      return FALSE; <br> <br>   lpscale = OutlineDoc_GetScaleFactor(lpLL-&gt;m_lpDoc); <br> <br>   if (nWidthInHimetric &lt; 0) { <br>      lpLL-&gt;m_nMaxLineWidthInHimetric = -1; <br>      nWidthInHimetric *= -1; <br>   } <br> <br>   if (nWidthInHimetric &gt; lpLL-&gt;m_nMaxLineWidthInHimetric) { <br>      lpLL-&gt;m_nMaxLineWidthInHimetric = nWidthInHimetric; <br>      nWidthInPix = XformWidthInHimetricToPixels(NULL, nWidthInHimetric + <br>            LOWORD(OutlineDoc_GetMargin(lpLL-&gt;m_lpDoc)) + <br>            HIWORD(OutlineDoc_GetMargin(lpLL-&gt;m_lpDoc))); <br> <br>      nWidthInPix = (int)(nWidthInPix * lpscale-&gt;dwSxN / lpscale-&gt;dwSxD); <br>      SendMessage( <br>            lpLL-&gt;m_hWndListBox, <br>            LB_SETHORIZONTALEXTENT, <br>            nWidthInPix, <br>            0L <br>      ); <br>      fSizeChanged = TRUE; <br> <br>#if defined( USE_HEADING ) <br>      Heading_CH_SetHorizontalExtent( <br>            OutlineDoc_GetHeading(lpLL-&gt;m_lpDoc), lpLL-&gt;m_hWndListBox); <br>#endif <br> <br>   } <br>   return fSizeChanged; <br>} <br> <br> <br>/* LineList_GetMaxLineWidthInHimetric <br> * ---------------------------------- <br> * <br> *      Return the width of the widest line <br> */ <br>int LineList_GetMaxLineWidthInHimetric(LPLINELIST lpLL) <br>{ <br>   return lpLL-&gt;m_nMaxLineWidthInHimetric; <br>} <br> <br> <br>/* LineList_RecalcMaxLineWidthInHimetric <br> * ------------------------------------- <br> * <br> *  Recalculate the maximum line width in the entire list. <br> * <br> *  Parameters: <br> *      nWidthInHimetric should be set to the width of line being removed. <br> *      nWidthInHimetric == 0 forces list to recalculate in all cases. <br> *      nWidthInHimetric == current max width =&gt; forces recalc. <br> * <br> *  Returns: <br> *      TRUE is max line width of LineList changed <br> *      FALSE if no change <br> */ <br>BOOL LineList_RecalcMaxLineWidthInHimetric( <br>      LPLINELIST          lpLL, <br>   int                 nWidthInHimetric <br>) <br>{ <br>   int i; <br>   LPLINE lpLine; <br>   BOOL fSizeChanged = FALSE; <br>   int nOrgMaxLineWidthInHimetric = lpLL-&gt;m_nMaxLineWidthInHimetric; <br> <br>   if (nWidthInHimetric == 0 || <br>      nWidthInHimetric == lpLL-&gt;m_nMaxLineWidthInHimetric) { <br> <br>      lpLL-&gt;m_nMaxLineWidthInHimetric = -1; <br> <br>      LineList_SetMaxLineWidthInHimetric(lpLL, 0); <br> <br>      for(i = 0; i &lt; lpLL-&gt;m_nNumLines; i++) { <br>         lpLine=LineList_GetLine(lpLL, i); <br>         LineList_SetMaxLineWidthInHimetric( <br>               lpLL, <br>               Line_GetTotalWidthInHimetric(lpLine) <br>         ); <br>      } <br>   } <br> <br>   if (nOrgMaxLineWidthInHimetric != lpLL-&gt;m_nMaxLineWidthInHimetric) <br>      fSizeChanged = TRUE; <br> <br>   return fSizeChanged; <br>} <br> <br> <br>/* LineList_CalcSelExtentInHimetric <br> * -------------------------------- <br> * <br> *      Calculate the extents (widht and height) of a selection of lines. <br> * <br> * if lplrSel == NULL, calculate extent of all lines. <br> */ <br>void LineList_CalcSelExtentInHimetric( <br>      LPLINELIST          lpLL, <br>      LPLINERANGE         lplrSel, <br>      LPSIZEL             lpsizel <br>) <br>{ <br>   int i; <br>   int nEndLine; <br>   int nStartLine; <br>   LPLINE lpLine; <br>   long lWidth; <br> <br>   if (lplrSel) { <br>      nEndLine = lplrSel-&gt;m_nEndLine; <br>      nStartLine = lplrSel-&gt;m_nStartLine; <br>   } else { <br>      nEndLine = LineList_GetCount(lpLL) - 1; <br>      nStartLine = 0; <br>   } <br> <br>   lpsizel-&gt;cx = 0; <br>   lpsizel-&gt;cy = 0; <br> <br>   for(i = nStartLine; i &lt;= nEndLine; i++) { <br>      lpLine=LineList_GetLine(lpLL,i); <br>      if (lpLine) { <br>         lWidth = (long)Line_GetTotalWidthInHimetric(lpLine); <br>         lpsizel-&gt;cx = max(lpsizel-&gt;cx, lWidth); <br>         lpsizel-&gt;cy += lpLine-&gt;m_nHeightInHimetric; <br>      } <br>   } <br>} <br> <br> <br>/* LineList_GetWindow <br> * ------------------ <br> * <br> * Return handle of list box <br> */ <br>HWND LineList_GetWindow(LPLINELIST lpLL) <br>{ <br>   return lpLL-&gt;m_hWndListBox; <br>} <br> <br> <br>/* LineList_GetDC <br> * -------------- <br> * <br> * Return DC handle of list box <br> */ <br>HDC LineList_GetDC(LPLINELIST lpLL) <br>{ <br>   HFONT hfontOld; <br>   HDC hDC = GetDC(lpLL-&gt;m_hWndListBox); <br>   int     iXppli;     //* pixels per logical inch along width <br>   int     iYppli;     //* pixels per logical inch along height <br>   SIZE    size; <br> <br>   // Setup a mapping mode for the DC which maps physical pixel <br>   // coordinates to HIMETRIC units. The standard MM_HIMETRIC mapping <br>   // mode does not work correctly because it does not take into <br>   // account that a logical inch on the display screen is drawn <br>   // physically larger than 1 inch. We will setup an anisotropic <br>   // mapping mode which will perform the transformation properly. <br> <br>   g_iMapMode = SetMapMode(hDC, MM_ANISOTROPIC); <br>   iXppli = GetDeviceCaps (hDC, LOGPIXELSX); <br>   iYppli = GetDeviceCaps (hDC, LOGPIXELSY); <br>   SetViewportExtEx(hDC, iXppli, iYppli, &amp;size); <br>   SetWindowExtEx(hDC, HIMETRIC_PER_INCH, HIMETRIC_PER_INCH, &amp;size); <br> <br>   // Set the default font size, and font face name <br>   hfontOld = SelectObject(hDC, OutlineApp_GetActiveFont(g_lpApp)); <br> <br>   return hDC; <br>} <br> <br> <br>/* LineList_ReleaseDC <br> * ------------------ <br> * <br> *      Release DC of list box returned from previous LineList_GetDC call. <br> */ <br>void LineList_ReleaseDC(LPLINELIST lpLL, HDC hDC) <br>{ <br>   SetMapMode(hDC, g_iMapMode); <br>   ReleaseDC(lpLL-&gt;m_hWndListBox, hDC); <br>} <br> <br> <br>/* LineList_SetLineHeight <br> * ---------------------- <br> * <br> *      Set the height of a line in the LineList list box <br> */ <br>void LineList_SetLineHeight(LPLINELIST lpLL,int nIndex,int nHeightInHimetric) <br>{ <br>   LPARAM          lParam; <br>   LPOUTLINEDOC    lpDoc; <br>   LPSCALEFACTOR   lpscale; <br>   UINT            uHeightInPix; <br>   LPHEADING       lphead; <br> <br>   if (!lpLL) <br>      return; <br> <br>   lpDoc = lpLL-&gt;m_lpDoc; <br>   lphead = OutlineDoc_GetHeading(lpDoc); <br>   lpscale = OutlineDoc_GetScaleFactor(lpDoc); <br> <br>   uHeightInPix = XformHeightInHimetricToPixels(NULL, nHeightInHimetric); <br> <br>   Heading_RH_SendMessage(lphead, LB_SETITEMDATA, (WPARAM)nIndex, <br>         MAKELPARAM(uHeightInPix, 0)); <br> <br>   uHeightInPix = (UINT)(uHeightInPix * lpscale-&gt;dwSyN / lpscale-&gt;dwSyD); <br> <br>   if (uHeightInPix &gt; LISTBOX_HEIGHT_LIMIT) <br>      uHeightInPix = LISTBOX_HEIGHT_LIMIT; <br> <br> <br>   lParam = MAKELPARAM(uHeightInPix, 0); <br>   SendMessage(lpLL-&gt;m_hWndListBox,LB_SETITEMHEIGHT,(WPARAM)nIndex, lParam); <br>   Heading_RH_SendMessage(lphead, LB_SETITEMHEIGHT, (WPARAM)nIndex, lParam); <br>   Heading_RH_ForceRedraw(lphead, TRUE); <br>} <br> <br> <br>/* LineList_ReScale <br> * ---------------- <br> * <br> *      Re-scale the LineList list box <br> */ <br>void LineList_ReScale(LPLINELIST lpLL, LPSCALEFACTOR lpscale) <br>{ <br>   int nIndex; <br>   LPLINE lpLine; <br>   UINT uWidthInHim; <br> <br>   if (!lpLL) <br>      return; <br> <br>   for (nIndex = 0; nIndex &lt; lpLL-&gt;m_nNumLines; nIndex++) { <br>      lpLine = LineList_GetLine(lpLL, nIndex); <br>      if (lpLine) { <br>         LineList_SetLineHeight( <br>               lpLL, <br>               nIndex, <br>               Line_GetHeightInHimetric(lpLine) <br>         ); <br>      } <br>   } <br> <br>   uWidthInHim = LineList_GetMaxLineWidthInHimetric(lpLL); <br>   LineList_SetMaxLineWidthInHimetric(lpLL, -(int)uWidthInHim); <br>} <br> <br>/* LineList_SetSel <br> * --------------- <br> * <br> *      Set the selection in list box <br> */ <br>void LineList_SetSel(LPLINELIST lpLL, LPLINERANGE lplrSel) <br>{ <br>   DWORD dwSel; <br> <br>   if (lpLL-&gt;m_nNumLines &lt;= 0 || lplrSel-&gt;m_nStartLine &lt; 0) <br>      return;     // no lines in list; can't set a selection <br> <br>   dwSel = MAKELPARAM(lplrSel-&gt;m_nStartLine, lplrSel-&gt;m_nEndLine); <br> <br>   lpLL-&gt;m_lrSaveSel = *lplrSel; <br> <br>   /* remove previous selection */ <br>#if defined( WIN32 ) <br>   SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_SETSEL, <br>         (WPARAM)FALSE, <br>         (LPARAM)-1 <br>   ); <br>#else <br>   SendMessage( <br>         lpLL-&gt;m_hWndListBox, <br>         LB_SETSEL, <br>         (WPARAM)FALSE, <br>         MAKELPARAM(-1,0) <br>   ); <br>#endif <br> <br>   /* mark selection */ <br>   SendMessage(lpLL-&gt;m_hWndListBox,LB_SELITEMRANGE, (WPARAM)TRUE, (LPARAM)dwSel); <br>   /* set focus line (caret) */ <br>   LineList_SetFocusLine ( lpLL, (WORD)lplrSel-&gt;m_nStartLine ); <br> <br>} <br> <br> <br>/* LineList_GetSel <br> * --------------- <br> * <br> * Get the selection in list box. <br> * <br> * Returns the count of items selected <br> */ <br>int LineList_GetSel(LPLINELIST lpLL, LPLINERANGE lplrSel) <br>{ <br>   int nNumSel=(int)SendMessage(lpLL-&gt;m_hWndListBox,LB_GETSELCOUNT,0,0L); <br> <br>   if (nNumSel) { <br>      SendMessage(lpLL-&gt;m_hWndListBox,LB_GETSELITEMS, <br>         (WPARAM)1,(LPARAM)(int FAR*)&amp;(lplrSel-&gt;m_nStartLine)); <br>      lplrSel-&gt;m_nEndLine = lplrSel-&gt;m_nStartLine + nNumSel - 1; <br>   } else { <br>      _fmemset(lplrSel, 0, sizeof(LINERANGE)); <br>   } <br>   return nNumSel; <br>} <br> <br> <br>/* LineList_RemoveSel <br> * ------------------ <br> * <br> * Remove the selection in list box but save the selection state so that <br> * it can be restored by calling LineList_RestoreSel <br> * LineList_RemoveSel is called when the LineList window looses focus. <br> */ <br>void LineList_RemoveSel(LPLINELIST lpLL) <br>{ <br>   LINERANGE lrSel; <br>   if (LineList_GetSel(lpLL, &amp;lrSel) &gt; 0) { <br>      lpLL-&gt;m_lrSaveSel = lrSel; <br>#if defined( WIN32 ) <br>      SendMessage( <br>            lpLL-&gt;m_hWndListBox, <br>            LB_SETSEL, <br>            (WPARAM)FALSE, <br>            (LPARAM)-1 <br>      ); <br>#else <br>      SendMessage( <br>            lpLL-&gt;m_hWndListBox, <br>            LB_SETSEL, <br>            (WPARAM)FALSE, <br>            MAKELPARAM(-1,0) <br>      ); <br>#endif <br>   } <br>} <br> <br> <br>/* LineList_RestoreSel <br> * ------------------ <br> * <br> * Restore the selection in list box that was previously saved by a call to <br> * LineList_RemoveSel. <br> * LineList_RestoreSel is called when the LineList window gains focus. <br> */ <br>void LineList_RestoreSel(LPLINELIST lpLL) <br>{ <br>   LineList_SetSel(lpLL, &amp;lpLL-&gt;m_lrSaveSel); <br>} <br> <br> <br>/* LineList_SetRedraw <br> * ------------------ <br> * <br> *      Enable/Disable the redraw of the linelist (listbox) on screen <br> * <br> *  fEnbaleDraw = TRUE      - enable redraw <br> *                FALSE     - disable redraw <br> */ <br>void LineList_SetRedraw(LPLINELIST lpLL, BOOL fEnableDraw) <br>{ <br>   SendMessage(lpLL-&gt;m_hWndListBox,WM_SETREDRAW,(WPARAM)fEnableDraw,0L); <br>} <br> <br> <br>/* LineList_ForceRedraw <br> * -------------------- <br> * <br> *      Force redraw of the linelist (listbox) on screen <br> */ <br>void LineList_ForceRedraw(LPLINELIST lpLL, BOOL fErase) <br>{ <br>   InvalidateRect(lpLL-&gt;m_hWndListBox, NULL, fErase); <br>} <br> <br> <br>/* LineList_ForceLineRedraw <br> * ------------------------ <br> * <br> *      Force a particular line of the linelist (listbox) to redraw. <br> */ <br>void LineList_ForceLineRedraw(LPLINELIST lpLL, int nIndex, BOOL fErase) <br>{ <br>   RECT   rect; <br> <br>   LineList_GetLineRect( lpLL, nIndex, (LPRECT)&amp;rect ); <br>   InvalidateRect( lpLL-&gt;m_hWndListBox, (LPRECT)&amp;rect, fErase ); <br>} <br> <br> <br>/* LineList_ScrollLineIntoView <br> * --------------------------- <br> *  Make sure that the specified line is in view; if necessary scroll <br> *      the listbox. if any portion of the line is visible, then no <br> *      scrolling will occur. <br> */ <br>void LineList_ScrollLineIntoView(LPLINELIST lpLL, int nIndex) <br>{ <br>   RECT rcWindow; <br>   RECT rcLine; <br>   RECT rcInt; <br> <br>   if ( lpLL-&gt;m_nNumLines == 0 ) <br>      return; <br> <br>   if (! LineList_GetLineRect( lpLL, nIndex, (LPRECT)&amp;rcLine ) ) <br>      return; <br> <br>   GetClientRect( lpLL-&gt;m_hWndListBox, (LPRECT) &amp;rcWindow ); <br> <br>   if (! IntersectRect((LPRECT)&amp;rcInt, (LPRECT)&amp;rcWindow, (LPRECT)&amp;rcLine)) <br>      SendMessage( <br>            lpLL-&gt;m_hWndListBox, <br>            LB_SETTOPINDEX, <br>            (WPARAM)nIndex, <br>            (LPARAM)NULL <br>      ); <br>} <br> <br> <br>/* LineList_CopySelToDoc <br> * --------------------- <br> * <br> *      Copy the selection of the linelist to another document <br> * <br> *  RETURNS: number of lines copied. <br> */ <br>int LineList_CopySelToDoc( <br>      LPLINELIST              lpSrcLL, <br>      LPLINERANGE             lplrSel, <br>      LPOUTLINEDOC            lpDestDoc <br>) <br>{ <br>   int             nEndLine; <br>   int             nStartLine; <br>   LPLINELIST      lpDestLL = &amp;lpDestDoc-&gt;m_LineList; <br>   signed short    nDestIndex = LineList_GetFocusLineIndex(lpDestLL); <br>   LPLINE          lpSrcLine; <br>   int             nCopied = 0; <br>   int             i; <br> <br>   if (lplrSel) { <br>      nEndLine = lplrSel-&gt;m_nEndLine; <br>      nStartLine = lplrSel-&gt;m_nStartLine; <br>   } else { <br>      nEndLine = LineList_GetCount(lpSrcLL) - 1; <br>      nStartLine = 0; <br>   } <br> <br>   for(i = nStartLine; i &lt;= nEndLine; i++) { <br>      lpSrcLine = LineList_GetLine(lpSrcLL, i); <br>      if (lpSrcLine &amp;&amp; Line_CopyToDoc(lpSrcLine, lpDestDoc, nDestIndex)) { <br>         nDestIndex++; <br>         nCopied++; <br>      } <br>   } <br> <br>   return nCopied; <br>} <br> <br> <br>/* LineList_SaveSelToStg <br> * --------------------- <br> * <br> *      Save lines in selection into lpDestStg. <br> * <br> *      Return TRUE if ok, FALSE if error <br> */ <br>BOOL LineList_SaveSelToStg( <br>      LPLINELIST              lpLL, <br>      LPLINERANGE             lplrSel, <br>      UINT                    uFormat, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTORAGE               lpDestStg, <br>      LPSTREAM                lpLLStm, <br>      BOOL                    fRemember <br>) <br>{ <br>   int nEndLine; <br>   int nStartLine; <br>   int nNumLinesWritten = 0; <br>   HRESULT hrErr = NOERROR; <br>   ULONG nWritten; <br>   LPLINE lpLine; <br>   LINELISTHEADER_ONDISK llhRecord; <br>   int i; <br>   LARGE_INTEGER dlibSaveHeaderPos; <br>   LARGE_INTEGER dlibZeroOffset; <br>   LISet32( dlibZeroOffset, 0 ); <br> <br>   if (lplrSel) { <br>      nEndLine = lplrSel-&gt;m_nEndLine; <br>      nStartLine = lplrSel-&gt;m_nStartLine; <br>   } else { <br>      nEndLine = LineList_GetCount(lpLL) - 1; <br>      nStartLine = 0; <br>   } <br> <br>   _fmemset(&amp;llhRecord,0,sizeof(llhRecord)); <br> <br>   /* save seek position for LineList header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Seek( <br>         lpLLStm, <br>         dlibZeroOffset, <br>         STREAM_SEEK_CUR, <br>         (ULARGE_INTEGER FAR*)&amp;dlibSaveHeaderPos <br>   ); <br>   if (hrErr != NOERROR) goto error; <br> <br>   /* write LineList header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>         lpLLStm, <br>         (LPVOID)&amp;llhRecord, <br>         sizeof(llhRecord), <br>         &amp;nWritten <br>    ); <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Write LineList header returned", hrErr); <br>      goto error; <br>    } <br> <br>   for(i = nStartLine; i &lt;= nEndLine; i++) { <br>      lpLine = LineList_GetLine(lpLL, i); <br>      if(lpLine &amp;&amp; <br>         Line_SaveToStg(lpLine, uFormat, lpSrcStg, lpDestStg, lpLLStm, <br>                                                fRemember)) <br>         llhRecord.m_nNumLines++; <br>   } <br> <br>   /* retore seek position for LineList header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Seek( <br>         lpLLStm, <br>         dlibSaveHeaderPos, <br>         STREAM_SEEK_SET, <br>         NULL <br>   ); <br>   if (hrErr != NOERROR) goto error; <br> <br>   /* write LineList header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Write( <br>         lpLLStm, <br>         (LPVOID)&amp;llhRecord, <br>         sizeof(llhRecord), <br>         &amp;nWritten <br>   ); <br>   if (hrErr != NOERROR) goto error; <br> <br>   /* reset seek position to end of stream */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Seek( <br>         lpLLStm, <br>         dlibZeroOffset, <br>         STREAM_SEEK_END, <br>         NULL <br>   ); <br>   if (hrErr != NOERROR) goto error; <br> <br>   return TRUE; <br> <br>error: <br>#if defined( _DEBUG ) <br>   OleDbgAssertSz( <br>         hrErr == NOERROR, <br>         "Could not write LineList header to LineList stream" <br>   ); <br>#endif <br>   return FALSE; <br>} <br> <br> <br>/* LineList_LoadFromStg <br> * -------------------- <br> * <br> *      Load lines into linelist from storage. <br> * <br> *      Return TRUE if ok, FALSE if error <br> */ <br>BOOL LineList_LoadFromStg( <br>      LPLINELIST              lpLL, <br>      LPSTORAGE               lpSrcStg, <br>      LPSTREAM                lpLLStm <br>) <br>{ <br>   HRESULT hrErr; <br>   ULONG nRead; <br>   LPLINE lpLine; <br>   int i; <br>   int nNumLines; <br>   LINELISTHEADER_ONDISK llineRecord; <br> <br>   /* write LineList header record */ <br>   hrErr = lpLLStm-&gt;lpVtbl-&gt;Read( <br>         lpLLStm, <br>         (LPVOID)&amp;llineRecord, <br>         sizeof(llineRecord), <br>         &amp;nRead <br>   ); <br> <br>   if (hrErr != NOERROR) { <br>      OleDbgOutHResult("Read LineList header returned", hrErr); <br>      goto error; <br>    } <br> <br>   nNumLines = (int) llineRecord.m_nNumLines; <br> <br>   for(i = 0; i &lt; nNumLines; i++) { <br>      lpLine = Line_LoadFromStg(lpSrcStg, lpLLStm, lpLL-&gt;m_lpDoc); <br>      if (! lpLine) <br>         goto error; <br> <br>      // Directly add lines to LineList without trying to update a NameTbl <br>      LineList_AddLine(lpLL, lpLine, i-1); <br>   } <br> <br>   return TRUE; <br> <br>error: <br>   // Delete any Line objects that were created <br>   if (lpLL-&gt;m_nNumLines &gt; 0) { <br>      int nNumLines = lpLL-&gt;m_nNumLines; <br>      for (i = 0; i &lt; nNumLines; i++) <br>         LineList_DeleteLine(lpLL, i); <br>   } <br> <br>   return FALSE; <br>} <br> <br> <br>#if defined( USE_DRAGDROP ) <br> <br> <br>/* LineList_SetFocusLineFromPointl <br> * ------------------------------- <br> * <br> */ <br> <br>void LineList_SetFocusLineFromPointl( LPLINELIST lpLL, POINTL pointl ) <br>{ <br>   int i = LineList_GetLineIndexFromPointl( lpLL, pointl ); <br> <br>   if ( i == (int)-1) <br>      return ; <br>   else <br>      LineList_SetFocusLine( lpLL, (WORD)i ); <br>} <br> <br> <br>/* LineList_SetDragOverLineFromPointl <br> * ---------------------------------- <br> * <br> */ <br> <br>void LineList_SetDragOverLineFromPointl ( LPLINELIST lpLL, POINTL pointl ) <br>{ <br>   int    nIndex = LineList_GetLineIndexFromPointl( lpLL, pointl ); <br>   LPLINE lpline = LineList_GetLine( lpLL, nIndex ); <br> <br>   if (!lpline) <br>      return; <br> <br>   if (! lpline-&gt;m_fDragOverLine) { <br>      /* user has dragged over a new line. force new drop target line <br>      **    to repaint so that drop feedback will be drawn. <br>      */ <br>      lpline-&gt;m_fDragOverLine = TRUE; <br>      LineList_ForceLineRedraw( lpLL, nIndex, TRUE /*fErase*/); <br> <br>      if (lpLL-&gt;m_iDragOverLine!= -1 &amp;&amp; lpLL-&gt;m_iDragOverLine!=nIndex) { <br> <br>         /* force previous drop target line to repaint so that drop <br>         **    feedback will be undrawn <br>         */ <br>         lpline = LineList_GetLine( lpLL, lpLL-&gt;m_iDragOverLine ); <br>         if (lpline) <br>            lpline-&gt;m_fDragOverLine = FALSE; <br> <br>         LineList_ForceLineRedraw( <br>               lpLL,lpLL-&gt;m_iDragOverLine,TRUE /*fErase*/); </code></pre>
<p>
</p>
<pre><code>} <br> <br>      lpLL-&gt;m_iDragOverLine = nIndex; <br> <br>      // Force repaint immediately <br>      UpdateWindow(lpLL-&gt;m_hWndListBox); <br>   } <br>} <br> <br> <br>/* LineList_Scroll <br> * --------------- <br> * <br> * Scroll the LineList list box in the desired direction by one line. <br> * <br> *      this function is called during a drag operation. <br> */ <br> <br>void LineList_Scroll(LPLINELIST lpLL, DWORD dwScrollDir) <br>{ <br>   switch (dwScrollDir) { <br>      case SCROLLDIR_UP: <br>         SendMessage( lpLL-&gt;m_hWndListBox, WM_VSCROLL, SB_LINEUP, 0L ); <br>         break; <br> <br>      case SCROLLDIR_DOWN: <br>         SendMessage( lpLL-&gt;m_hWndListBox, WM_VSCROLL, SB_LINEDOWN, 0L ); <br>         break; <br>   } <br>} <br> <br> <br>/* LineList_GetLineIndexFromPointl <br> * ------------------------------- <br> *   do hit test to get index of line corresponding to pointl <br> */ <br>int LineList_GetLineIndexFromPointl(LPLINELIST lpLL, POINTL pointl) <br>{ <br>   RECT  rect; <br>   POINT point; <br>   DWORD i; <br> <br>   point.x = (int)pointl.x; <br>   point.y = (int)pointl.y; <br> <br>   ScreenToClient( lpLL-&gt;m_hWndListBox, &amp;point); <br> <br>   if ( lpLL-&gt;m_nNumLines == 0 ) <br>      return -1; <br> <br>   GetClientRect( lpLL-&gt;m_hWndListBox, (LPRECT) &amp;rect ); <br> <br>   i = SendMessage( lpLL-&gt;m_hWndListBox, LB_GETTOPINDEX, (WPARAM)NULL, (LPARAM)NULL ); <br> <br>   for ( ;; i++){ <br> <br>      RECT rectItem; <br> <br>      if (!LineList_GetLineRect( lpLL, (int)i, (LPRECT)&amp;rectItem ) ) <br>         return -1; <br> <br>      if ( rectItem.top &gt; rect.bottom ) <br>         return -1; <br> <br>      if ( rectItem.top &lt;= point.y &amp;&amp; point.y &lt;= rectItem.bottom) <br>         return (int)i; <br> <br>   } <br> <br>} <br> <br> <br>/* LineList_RestoreDragFeedback <br> * ---------------------------- <br> * <br> * Retore the index of the line that currently has focus (the active line). <br> */ <br>void LineList_RestoreDragFeedback(LPLINELIST lpLL) <br>{ <br>   LPLINE lpLine; <br> <br>   if (lpLL-&gt;m_iDragOverLine &lt; 0 ) <br>      return; <br> <br>   lpLine = LineList_GetLine( lpLL, lpLL-&gt;m_iDragOverLine); <br> <br>   if (lpLine) { <br> <br>      lpLine-&gt;m_fDragOverLine = FALSE; <br>      LineList_ForceLineRedraw( lpLL,lpLL-&gt;m_iDragOverLine,TRUE /*fErase*/); <br> <br>      // Force repaint immediately <br>      UpdateWindow(lpLL-&gt;m_hWndListBox); <br>   } <br> <br>   lpLL-&gt;m_iDragOverLine = -1; <br> <br>} <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
