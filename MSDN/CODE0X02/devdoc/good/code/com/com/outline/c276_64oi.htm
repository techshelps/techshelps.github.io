<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIALOGS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context282"></a>DIALOGS.C</h2>
<pre><code>/************************************************************************* <br>** <br>**    OLE 2 Sample Code <br>** <br>**    dialogs.c <br>** <br>**    This file contains dialog functions and support function <br>** <br>**    (c) Copyright Microsoft Corp. 1992 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br> <br>#include "outline.h" <br> <br>OLEDBGDATA <br> <br>extern LPOUTLINEAPP g_lpApp; <br> <br>static OLECHAR  g_szBuf[MAXSTRLEN+1]; <br>static LPSTR g_lpszDlgTitle; <br> <br>// REVIEW: should use string resource for messages <br>static OLECHAR ErrMsgInvalidRange[] = OLESTR("Invalid Range entered!"); <br>static OLECHAR ErrMsgInvalidValue[] = OLESTR("Invalid Value entered!"); <br>static OLECHAR ErrMsgInvalidName[] = OLESTR("Invalid Name entered!"); <br>static OLECHAR ErrMsgNullName[] = OLESTR("NULL string disallowed!"); <br>static OLECHAR ErrMsgNameNotFound[] = OLESTR("Name doesn't exist!"); <br> <br>/* InputTextDlg <br> * ------------ <br> * <br> *      Put up a dialog box to allow the user to edit text <br> */ <br>BOOL InputTextDlg(HWND hWnd, LPSTR lpszText, LPSTR lpszDlgTitle) <br>{ <br>   int nResult; <br> <br>   g_lpszDlgTitle = lpszDlgTitle; <br>   A2W (lpszText, g_szBuf, MAXSTRLEN+1);  // preload dialog with input text <br> <br>   nResult = DialogBox(g_lpApp-&gt;m_hInst, (LPSTR)"AddEditLine", hWnd, <br>                  (DLGPROC)AddEditDlgProc); <br>   if (nResult) { <br>      W2A(g_szBuf, lpszText, MAXSTRLEN+1); <br>      return TRUE; <br>   } else { <br>      return FALSE; <br>   } <br>} <br> <br> <br> <br>/* AddEditDlgProc <br> * -------------- <br> * <br> * This procedure is associated with the dialog box that is included in <br> * the function name of the procedure. It provides the service routines <br> * for the events (messages) that occur because the end user operates <br> * one of the dialog box's buttons, entry fields, or controls. <br> */ <br>BOOL CALLBACK EXPORT AddEditDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   HWND hEdit; <br>   char szAnsiString[256]; <br> <br>   switch(Message) { <br>      case WM_INITDIALOG: <br>         /* initialize working variables */ <br>         hEdit=GetDlgItem(hDlg,IDD_EDIT); <br>         SendMessage(hEdit,EM_LIMITTEXT,(WPARAM)MAXSTRLEN,0L); <br>         SetWindowText(hDlg, g_lpszDlgTitle); <br>         W2A (g_szBuf, szAnsiString, 256); <br>         SetDlgItemText(hDlg,IDD_EDIT, szAnsiString); <br>         break; /* End of WM_INITDIALOG */ <br> <br>      case WM_CLOSE: <br>         /* Closing the Dialog behaves the same as Cancel */ <br>         PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L); <br>         break; /* End of WM_CLOSE */ <br> <br>      case WM_COMMAND: <br>         switch (wParam) { <br>            case IDOK: <br>               /* save data values entered into the controls <br>               ** and dismiss the dialog box returning TRUE <br>               */ <br>               GetDlgItemText(hDlg,IDD_EDIT,(LPSTR)g_szBuf,MAXSTRLEN+1); <br>               EndDialog(hDlg, TRUE); <br>               break; <br> <br>            case IDCANCEL: <br>               /* ignore data values entered into the controls <br>               ** and dismiss the dialog box returning FALSE <br>               */ <br>               EndDialog(hDlg, FALSE); <br>               break; <br>         } <br>         break;    /* End of WM_COMMAND */ <br> <br>      default: <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br>} /* End of AddEditDlgProc */ <br> <br> <br>/* SetLineHeightDlgProc <br> * -------------------- <br> * <br> *      Dialog procedure for set line height <br> */ <br>BOOL CALLBACK EXPORT SetLineHeightDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   BOOL    fTranslated; <br>   BOOL    fEnable; <br>   static LPINT    lpint; <br>   int     nHeight; <br>   static int nMaxHeight; <br> <br>   switch (Message) { <br>      case WM_INITDIALOG: <br>      { <br>         char cBuf[80]; <br> <br>         nMaxHeight = XformHeightInPixelsToHimetric(NULL, <br>                        LISTBOX_HEIGHT_LIMIT); <br>         lpint = (LPINT)lParam; <br>         SetDlgItemInt(hDlg, IDD_EDIT, *lpint, FALSE); <br>         wsprintf(cBuf, "Maximum value is %d units", nMaxHeight); <br>         SetDlgItemText(hDlg, IDD_LIMIT, (LPSTR)cBuf); <br>         break; <br>      } <br> <br>      case WM_COMMAND: <br>         switch (wParam) { <br>            case IDOK: <br>               if (IsDlgButtonChecked(hDlg, IDD_CHECK)) { <br>                  *lpint = -1; <br>               } <br>               else { <br>                  /* save the value in the edit control */ <br>                  nHeight = GetDlgItemInt(hDlg, IDD_EDIT, <br>                        (BOOL FAR*)&amp;fTranslated, FALSE); <br>                  if (!fTranslated || !nHeight || (nHeight&gt;nMaxHeight)){ <br>                     OutlineApp_ErrorMessage(g_lpApp, <br>                           ErrMsgInvalidValue); <br>                     break; <br>                  } <br>                  *lpint = nHeight; <br>               } <br>               EndDialog(hDlg, TRUE); <br>               break; <br> <br>            case IDCANCEL: <br>               *lpint = 0; <br>               EndDialog(hDlg, FALSE); <br>               break; <br> <br> <br>            case IDD_CHECK: <br>               fEnable = !IsDlgButtonChecked(hDlg, IDD_CHECK); <br>               EnableWindow(GetDlgItem(hDlg, IDD_EDIT), fEnable); <br>               EnableWindow(GetDlgItem(hDlg, IDD_TEXT), fEnable); <br>               break; <br>         } <br>         break;  /* WM_COMMAND */ <br> <br>      case WM_CLOSE:  /* Closing the Dialog behaves the same as Cancel */ <br>         PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L); <br>         break; /* End of WM_CLOSE */ <br> <br>      default: <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br> <br>} /* end of SetLineHeightProc */ <br> <br> <br> <br> <br> <br>/* DefineNameDlgProc <br> * ----------------- <br> * <br> *      Dialog procedure for define name <br> */ <br>BOOL CALLBACK EXPORT DefineNameDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   static HWND hCombo; <br>   static LPOUTLINEDOC lpOutlineDoc = NULL; <br>   static LPOUTLINENAMETABLE lpOutlineNameTable = NULL; <br>   LPOUTLINENAME lpOutlineName = NULL; <br>   UINT nIndex; <br>   LINERANGE lrSel; <br>   BOOL fTranslated; <br>   char szAnsiString[256]; <br> <br>   switch(Message) { <br>      case WM_INITDIALOG: <br>      /* initialize working variables */ <br>         hCombo=GetDlgItem(hDlg,IDD_COMBO); <br>         lpOutlineDoc = (LPOUTLINEDOC) lParam; <br>         lpOutlineNameTable = OutlineDoc_GetNameTable(lpOutlineDoc); <br> <br>         SendMessage(hCombo,CB_LIMITTEXT,(WPARAM)MAXNAMESIZE,0L); <br>         NameDlg_LoadComboBox(lpOutlineNameTable, hCombo); <br> <br>         OutlineDoc_GetSel(lpOutlineDoc, (LPLINERANGE)&amp;lrSel); <br>         lpOutlineName = OutlineNameTable_FindNamedRange( <br>               lpOutlineNameTable, <br>               &amp;lrSel <br>         ); <br> <br>         /* if current selection already has a name, hilight it */ <br>         if (lpOutlineName) { <br>            nIndex = (int) SendMessage( <br>                  hCombo, <br>                  CB_FINDSTRINGEXACT, <br>                  (WPARAM)0xffff, <br>                  (LPARAM)(LPCSTR)lpOutlineName-&gt;m_szName <br>            ); <br>            if (nIndex != CB_ERR) { <br>               SendMessage(hCombo, CB_SETCURSEL, (WPARAM)nIndex, 0L); <br>            } <br>         } <br> <br>         SetDlgItemInt(hDlg, IDD_FROM, (UINT)lrSel.m_nStartLine+1,FALSE); <br>         SetDlgItemInt(hDlg, IDD_TO, (UINT)lrSel.m_nEndLine+1, FALSE); <br> <br>         break; /* End of WM_INITDIALOG */ <br> <br>      case WM_CLOSE: <br>      /* Closing the Dialog behaves the same as Cancel */ <br>         PostMessage(hDlg, WM_COMMAND, IDD_CLOSE, 0L); <br>         break; /* End of WM_CLOSE */ <br> <br>      case WM_COMMAND: <br>         switch(wParam) { <br>            case IDOK: <br>               GetDlgItemText(hDlg,IDD_COMBO,(LPSTR)g_szBuf,MAXNAMESIZE); <br>               if(! SendMessage(hCombo,WM_GETTEXTLENGTH,0,0L)) { <br>                  W2A (ErrMsgNullName, szAnsiString, 256); <br>                  MessageBox( <br>                        hDlg, <br>                        szAnsiString, <br>                        NULL, <br>                        MB_ICONEXCLAMATION <br>                  ); <br>                  break; <br>               } else if(SendMessage(hCombo,CB_GETCURSEL,0,0L)==CB_ERR &amp;&amp; <br>                     wcschr(g_szBuf, ' ')) { <br>                  W2A (ErrMsgInvalidName, szAnsiString, 256); <br>                  MessageBox( <br>                        hDlg, <br>                        szAnsiString, <br>                        NULL, <br>                        MB_ICONEXCLAMATION <br>                  ); <br>                  break; <br>               } else { <br>                  nIndex = (int) SendMessage(hCombo,CB_FINDSTRINGEXACT, <br>                     (WPARAM)0xffff,(LPARAM)(LPCSTR)g_szBuf); <br> <br>                  /* Line indices are 1 less than the number in <br>                  **    the row heading <br>                  */ <br>                  lrSel.m_nStartLine = GetDlgItemInt(hDlg, IDD_FROM, <br>                        (BOOL FAR*)&amp;fTranslated, FALSE) - 1; <br>                  if(! fTranslated) { <br>                     OutlineApp_ErrorMessage(g_lpApp, <br>                           ErrMsgInvalidRange); <br>                     break; <br>                  } <br>                  lrSel.m_nEndLine = GetDlgItemInt(hDlg, IDD_TO, <br>                        (BOOL FAR*)&amp;fTranslated, FALSE) - 1; <br>                  if (!fTranslated || <br>                     (lrSel.m_nStartLine &lt; 0) || <br>                     (lrSel.m_nEndLine &lt; lrSel.m_nStartLine) || <br>                     (lrSel.m_nEndLine &gt;= OutlineDoc_GetLineCount( <br>                           lpOutlineDoc))) { <br>                     OutlineApp_ErrorMessage(g_lpApp, <br>                           ErrMsgInvalidRange); <br>                     break; <br>                  } <br> <br>                  if(nIndex != CB_ERR) { <br>                     NameDlg_UpdateName( <br>                           hCombo, <br>                           lpOutlineDoc, <br>                           nIndex, <br>                           g_szBuf, <br>                           &amp;lrSel <br>                     ); <br>                  } else { <br>                     NameDlg_AddName( <br>                           hCombo, <br>                           lpOutlineDoc, <br>                           g_szBuf, <br>                           &amp;lrSel <br>                     ); <br>                  } <br>               } <br>               // fall through <br> <br>            case IDD_CLOSE: <br>               /* Ignore data values entered into the controls */ <br>               /* and dismiss the dialog window returning FALSE */ <br>               EndDialog(hDlg,0); <br>               break; <br> <br>            case IDD_DELETE: <br>               GetDlgItemText(hDlg,IDD_COMBO,(LPSTR)szAnsiString,MAXNAMESIZE); <br>               if((nIndex=(int)SendMessage(hCombo,CB_FINDSTRINGEXACT, <br>               (WPARAM)0xffff,(LPARAM)(LPCSTR)szAnsiString))==CB_ERR) { <br>                  W2A (ErrMsgNameNotFound, szAnsiString, 256); <br>                  MessageBox(hDlg, szAnsiString, NULL, MB_ICONEXCLAMATION); <br>               } <br>               else { <br>                  NameDlg_DeleteName(hCombo, lpOutlineDoc, nIndex); <br>               } <br>               break; <br> <br>            case IDD_COMBO: <br>               if(HIWORD(lParam) == CBN_SELCHANGE) { <br>                  nIndex=(int)SendMessage(hCombo, CB_GETCURSEL, 0, 0L); <br>                  lpOutlineName = (LPOUTLINENAME)SendMessage( <br>                        hCombo, <br>                        CB_GETITEMDATA, <br>                        (WPARAM)nIndex, <br>                        0L <br>                  ); <br>                  SetDlgItemInt( <br>                        hDlg, <br>                        IDD_FROM, <br>                        (UINT) lpOutlineName-&gt;m_nStartLine + 1, <br>                        FALSE <br>                  ); <br>                  SetDlgItemInt( <br>                        hDlg, <br>                        IDD_TO, <br>                        (UINT) lpOutlineName-&gt;m_nEndLine + 1, <br>                        FALSE <br>                  ); <br>               } <br>         } <br>         break;    /* End of WM_COMMAND */ <br> <br>      default: <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br>} /* End of DefineNameDlgProc */ <br> <br> <br>/* GotoNameDlgProc <br> * --------------- <br> * <br> *      Dialog procedure for goto name <br> */ <br>BOOL CALLBACK EXPORT GotoNameDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   static HWND hLBName; <br>   static LPOUTLINEDOC lpOutlineDoc = NULL; <br>   static LPOUTLINENAMETABLE lpOutlineNameTable = NULL; <br>   UINT nIndex; <br>   LINERANGE lrLineRange; <br>   LPOUTLINENAME lpOutlineName; <br> <br>   switch(Message) { <br>      case WM_INITDIALOG: <br>      /* initialize working variables */ <br>         lpOutlineDoc = (LPOUTLINEDOC) lParam; <br>         lpOutlineNameTable = OutlineDoc_GetNameTable(lpOutlineDoc); <br> <br>         hLBName=GetDlgItem(hDlg,IDD_LINELISTBOX); <br>         NameDlg_LoadListBox(lpOutlineNameTable, hLBName); <br> <br>         // highlight 1st item <br>         SendMessage(hLBName, LB_SETCURSEL, 0, 0L); <br>         // trigger to initialize edit control <br>         SendMessage(hDlg, WM_COMMAND, (WPARAM)IDD_LINELISTBOX, <br>            MAKELONG(hLBName, LBN_SELCHANGE)); <br> <br>         break; /* End of WM_INITDIALOG */ <br> <br>      case WM_CLOSE: <br>      /* Closing the Dialog behaves the same as Cancel */ <br>         PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L); <br>         break; /* End of WM_CLOSE */ <br> <br>      case WM_COMMAND: <br>         switch(wParam) { <br>            case IDD_LINELISTBOX: <br>               if(HIWORD(lParam) == LBN_SELCHANGE) { <br>                  // update the line range display <br>                  nIndex=(int)SendMessage(hLBName, LB_GETCURSEL, 0, 0L); <br>                  lpOutlineName = (LPOUTLINENAME)SendMessage(hLBName, LB_GETITEMDATA, <br>                                 (WPARAM)nIndex,0L); <br>                  if (lpOutlineName) { <br>                     SetDlgItemInt( <br>                           hDlg, <br>                           IDD_FROM, <br>                           (UINT) lpOutlineName-&gt;m_nStartLine + 1, <br>                           FALSE <br>                     ); <br>                     SetDlgItemInt( <br>                           hDlg, <br>                           IDD_TO, <br>                           (UINT) lpOutlineName-&gt;m_nEndLine + 1, <br>                           FALSE <br>                     ); <br>                  } <br>                  break; <br>               } <br>               // double click will fall through <br>               else if(HIWORD(lParam) != LBN_DBLCLK) <br>                  break; <br> <br>            case IDOK: <br>               nIndex=(int)SendMessage(hLBName,LB_GETCURSEL,0,0L); <br>               if(nIndex!=LB_ERR) { <br>                  lpOutlineName = (LPOUTLINENAME)SendMessage(hLBName, <br>                        LB_GETITEMDATA, (WPARAM)nIndex, 0L); <br>                  lrLineRange.m_nStartLine=lpOutlineName-&gt;m_nStartLine; <br>                  lrLineRange.m_nEndLine = lpOutlineName-&gt;m_nEndLine; <br>                  OutlineDoc_SetSel(lpOutlineDoc, &amp;lrLineRange); <br>               }   // fall through <br> <br>            case IDCANCEL: <br>            /* Ignore data values entered into the controls */ <br>            /* and dismiss the dialog window returning FALSE */ <br>               EndDialog(hDlg,0); <br>               break; <br> <br>         } <br>         break;    /* End of WM_COMMAND */ <br> <br>      default: <br>         return FALSE; <br>   } <br> <br>   return TRUE; <br>} /* End of GotoNameDlgProc */ <br> <br> <br> <br>/* NameDlg_LoadComboBox <br> * -------------------- <br> * <br> *      Load defined names into combo box <br> */ <br>void NameDlg_LoadComboBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hCombo) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br>   int i, nIndex; <br>   int nCount; <br> <br>   nCount=OutlineNameTable_GetCount((LPOUTLINENAMETABLE)lpOutlineNameTable); <br>   if(!nCount) return; <br> <br>   SendMessage(hCombo,WM_SETREDRAW,(WPARAM)FALSE,0L); <br>   for(i=0; i&lt;nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName((LPOUTLINENAMETABLE)lpOutlineNameTable,i); <br>      nIndex = (int)SendMessage( <br>            hCombo, <br>            CB_ADDSTRING, <br>            0, <br>            (LPARAM)(LPCSTR)lpOutlineName-&gt;m_szName <br>      ); <br>      SendMessage(hCombo,CB_SETITEMDATA,(WPARAM)nIndex,(LPARAM)lpOutlineName); <br>   } <br>   SendMessage(hCombo,WM_SETREDRAW,(WPARAM)TRUE,0L); <br>} <br> <br> <br>/* NameDlg_LoadListBox <br> * ------------------- <br> * <br> *      Load defined names into list box <br> */ <br>void NameDlg_LoadListBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hListBox) <br>{ <br>   int i; <br>   int nCount; <br>   int nIndex; <br>   LPOUTLINENAME lpOutlineName; <br> <br>   nCount=OutlineNameTable_GetCount((LPOUTLINENAMETABLE)lpOutlineNameTable); <br> <br>   SendMessage(hListBox,WM_SETREDRAW,(WPARAM)FALSE,0L); <br>   for(i=0; i&lt;nCount; i++) { <br>      lpOutlineName=OutlineNameTable_GetName((LPOUTLINENAMETABLE)lpOutlineNameTable,i); <br>      nIndex = (int)SendMessage( <br>            hListBox, <br>            LB_ADDSTRING, <br>            0, <br>            (LPARAM)(LPCSTR)lpOutlineName-&gt;m_szName <br>      ); <br>      SendMessage(hListBox,LB_SETITEMDATA,(WPARAM)nIndex,(LPARAM)lpOutlineName); <br>   } <br>   SendMessage(hListBox,WM_SETREDRAW,(WPARAM)TRUE,0L); <br>} <br> <br> <br>/* NameDlg_AddName <br> * --------------- <br> * <br> *      Add a name to the name table corresponding to the name dialog <br> *      combo box. <br> */ <br>void NameDlg_AddName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, LPOLESTR lpszName, LPLINERANGE lplrSel) <br>{ <br>   LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp; <br>   LPOUTLINENAME lpOutlineName; <br> <br>   lpOutlineName = OutlineApp_CreateName(lpOutlineApp); <br> <br>   if (lpOutlineName) { <br>      OLESTRCPY(lpOutlineName-&gt;m_szName, lpszName); <br>      lpOutlineName-&gt;m_nStartLine = lplrSel-&gt;m_nStartLine; <br>      lpOutlineName-&gt;m_nEndLine = lplrSel-&gt;m_nEndLine; <br>      OutlineDoc_AddName(lpOutlineDoc, lpOutlineName); <br>   } else { <br>      // REVIEW: do we need error message here? <br>   } <br>} <br> <br> <br>/* NameDlg_UpdateName <br> * ------------------ <br> * <br> *      Update a name in the name table corresponding to a name in <br> *      the name dialog combo box. <br> */ <br>void NameDlg_UpdateName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, int nIndex, LPOLESTR lpszName, LPLINERANGE lplrSel) <br>{ <br>   LPOUTLINENAME lpOutlineName; <br> <br>   lpOutlineName = (LPOUTLINENAME)SendMessage( <br>         hCombo, <br>         CB_GETITEMDATA, <br>         (WPARAM)nIndex, <br>         0L <br>   ); <br> <br>   OutlineName_SetName(lpOutlineName, lpszName); <br>   OutlineName_SetSel(lpOutlineName, lplrSel, TRUE /* name modified */); <br>   OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE); <br>} <br> <br> <br>/* NameDlg_DeleteName <br> * ------------------ <br> * <br> *      Delete a name from the name dialog combo box and corresponding <br> *      name table. <br> */ <br>void NameDlg_DeleteName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, UINT nIndex) <br>{ <br>   SendMessage(hCombo,CB_DELETESTRING,(WPARAM)nIndex,0L); <br>   OutlineDoc_DeleteName(lpOutlineDoc, nIndex); <br>} <br> <br>/* PlaceBitmap <br> * ----------- <br> * <br> *      Places a bitmap centered in the specified control in the dialog on the <br> *      specified DC. <br> * <br> */ <br> <br>PlaceBitmap(HWND hDlg, int control, HDC hDC, HBITMAP hBitmap) <br>{ <br>   BITMAP bm; <br>   HDC hdcmem; <br>   HBITMAP hbmOld; <br>   RECT rcControl;     // Rect of dialog control <br>   int width, height; <br> <br>   GetObject(hBitmap, sizeof(BITMAP), &amp;bm); <br> <br>   hdcmem= CreateCompatibleDC(hDC); <br>   hbmOld = SelectObject(hdcmem, hBitmap); <br> <br>   // Get rect of control in screen coords, and translate to our dialog <br>   // box's coordinates <br>   GetWindowRect(GetDlgItem(hDlg, control), &amp;rcControl); <br>   MapWindowPoints(NULL, hDlg, (LPPOINT)&amp;rcControl, 2); <br> <br>   width  = rcControl.right - rcControl.left; <br>   height = rcControl.bottom - rcControl.top; <br> <br>   BitBlt(hDC, rcControl.left + (width - bm.bmWidth) / 2, <br>            rcControl.top + (height - bm.bmHeight) /2, <br>            bm.bmWidth, bm.bmHeight, <br>            hdcmem, 0, 0, SRCCOPY); <br> <br>   SelectObject(hdcmem, hbmOld); <br>   DeleteDC(hdcmem); <br>   return 1; <br>} <br> <br> <br> <br>/* AboutDlgProc <br> * ------------ <br> * <br> *      Dialog procedure for the About function <br> */ <br>BOOL CALLBACK EXPORT AboutDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam) <br>{ <br>   int  narrVersion[2]; <br>   static HBITMAP hbmLogo; <br>   char   szAnsiString[256]; <br>   char   szAppName[250]; <br> <br>   switch(Message) { <br> <br>      case WM_INITDIALOG: <br>         // get version number of app <br>         W2A (APPNAME, szAppName, 250); <br>         wsprintf(szAnsiString, "About %s", (LPSTR)szAppName); <br>         SetWindowText(hDlg, (LPCSTR)szAnsiString); <br>         OutlineApp_GetAppVersionNo(g_lpApp, narrVersion); <br>         wsprintf(szAnsiString, "%s version %d.%d", (LPSTR) APPDESC, <br>            narrVersion[0], narrVersion[1]); <br>         SetDlgItemText(hDlg, IDD_APPTEXT, (LPCSTR)szAnsiString); <br> <br>         // Load bitmap for displaying later <br>         hbmLogo = LoadBitmap(g_lpApp-&gt;m_hInst, "LogoBitmap"); <br>         TraceDebug(hDlg, IDD_BITMAPLOCATION); <br>         ShowWindow(GetDlgItem(hDlg, IDD_BITMAPLOCATION), SW_HIDE); <br>         break; <br> <br>      case WM_PAINT: <br>         { <br>         PAINTSTRUCT ps; <br>         BeginPaint(hDlg, &amp;ps); <br> <br>         // Display bitmap in IDD_BITMAPLOCATION control area <br>         PlaceBitmap(hDlg, IDD_BITMAPLOCATION, ps.hdc, hbmLogo); <br>         EndPaint(hDlg, &amp;ps); <br>         } <br>         break; <br> <br>      case WM_CLOSE : <br>         PostMessage(hDlg, WM_COMMAND, IDOK, 0L); <br>         break; <br> <br>      case WM_COMMAND : <br>         switch(wParam) { <br>            case IDOK: <br>            case IDCANCEL: <br>               if (hbmLogo) DeleteObject(hbmLogo); <br>               EndDialog(hDlg,0); <br>               break; <br>         } <br>         break; <br> <br>      default : <br>         return FALSE; <br> <br>   } <br>   return TRUE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
