<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>METHODSINK.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1289"></a>METHODSINK.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: MethodSink.cpp <br>* <br>* Description:  Sink for Method events <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "mtsspyctl.h" <br>#include "mtsevents.h" <br>#include "MtsSink.h" <br>#include "MtsAudit.h" <br>#include "MTSSpy.h" <br>#include "packagesink.h" <br>#include "PackageInfo.h" <br>#include "methodsink.h" <br> <br>extern LONGLONG PerformanceFrequency; <br> <br>STDMETHODIMP  CMethodSink::OnMethodCall(LONGLONG perfCount, MTS_OBJID oid,REFCLSID guidCid, REFIID guidRid, ULONG iMeth) <br>{ <br>TimeStack * pStack = m_map[oid]; <br>if (!pStack) <br>{ <br>pStack = new TimeStack; <br>m_map[oid] = pStack; <br>} <br>_ASSERTE(pStack); <br>pStack -&gt; push_front(perfCount); <br> <br>m_pSpy -&gt; AddEventToList(perfCount, _TEXT("OnMethodCall"), m_sPackageName); <br>WCHAR id[16]; <br>wsprintfW(id,L"0x%08X", oid); <br>m_pSpy -&gt; AddParamValueToList(L"ObjectID", id); <br> <br>    CComBSTR sCid = GuidToBstr(guidCid); <br>    CComBSTR sIid = GuidToBstr(guidRid); <br> <br>m_pSpy -&gt; AddParamValueToList(L"CLSID", sCid); <br>m_pSpy -&gt; AddParamValueToList(L"riid", sIid); <br> <br>TCHAR * pszGuidName = NULL; <br>HRESULT hr; <br>hr = GetMethodName(guidRid, iMeth, &amp;pszGuidName) ; <br>    if(hr == S_OK)  <br>{  <br>m_pSpy -&gt; AddParamValueToList(L"Method Name", pszGuidName); <br>} <br>else <br>{ <br>pszGuidName = new _TCHAR[8] ;  <br>wsprintf(pszGuidName, _T("%X"), iMeth) ;  <br>m_pSpy -&gt; AddParamValueToList(L"v-table index", pszGuidName); <br>} <br>   IF_AUDIT_DO(OnMethodCall)(perfCount, <br>  oid, <br>  sCid, <br>  sIid, <br>  pszGuidName); <br> <br> <br> <br>    delete pszGuidName ; <br>    pszGuidName = NULL ; <br>return S_OK; <br>} <br> <br>STDMETHODIMP  CMethodSink::OnMethodReturn(LONGLONG perfCount,  <br>  MTS_OBJID oid, <br>  REFCLSID guidCid,  <br>  REFIID guidRid,  <br>  ULONG iMeth,  <br>  HRESULT hrRet) <br>{ <br>m_pSpy -&gt; AddEventToList(perfCount, _TEXT("OnMethodReturn"), m_sPackageName); <br>WCHAR id[16]; <br>wsprintfW(id,L"0x%08X", oid); <br>m_pSpy -&gt; AddParamValueToList(L"ObjectID", id); <br> <br>    CComBSTR sCid = GuidToBstr(guidCid); <br>    CComBSTR sIid = GuidToBstr(guidRid); <br> <br>m_pSpy -&gt; AddParamValueToList(L"CLSID", sCid); <br>m_pSpy -&gt; AddParamValueToList(L"riid", sIid); <br> <br>TCHAR      * pszGuidName   =   NULL ; <br>HRESULT hr; <br>hr = GetMethodName(guidRid, iMeth, &amp;pszGuidName) ; <br>    if(hr != S_OK)  <br>{  <br>pszGuidName = new _TCHAR[8] ;  <br>wsprintf(pszGuidName, _T("%X"), iMeth) ;  <br>m_pSpy -&gt; AddParamValueToList(L"v-table index", pszGuidName); <br>} <br>else <br>{ <br>m_pSpy -&gt; AddParamValueToList(L"Method Name", pszGuidName); <br>} <br>     <br>   IF_AUDIT_DO(OnMethodReturn)(perfCount, <br>  oid, <br>  sCid, <br>  sIid, <br>  pszGuidName, <br>  hrRet); <br> <br> <br>    delete pszGuidName ; <br>    pszGuidName = NULL ; <br> <br> <br>wsprintf(id, L"0x%08X", hrRet); <br>    m_pSpy -&gt; AddParamValueToList(L"Return Value", id); <br> <br>TCHAR sTime[16]; <br>TimeStack * pStack = m_map[oid]; <br>LONGLONG oldTime  = pStack -&gt; front(); <br>pStack -&gt; pop_front(); <br>_ASSERTE(oldTime); <br> <br>    DWORD timeDiff = (DWORD)((1000*(perfCount-oldTime))/PerformanceFrequency); <br>wsprintf(sTime, _T("%d"), timeDiff); <br> <br>m_pSpy -&gt; AddParamValueToList(L"Call time (ms)", sTime); <br>if (pStack -&gt; empty()) <br>{ <br>delete pStack; <br>m_map.erase(oid); <br>} <br>return S_OK; <br>} <br> <br>STDMETHODIMP  CMethodSink::OnMethodException(LONGLONG perfCount, MTS_OBJID oid,REFCLSID guidCid, REFIID guidRid, ULONG iMeth) <br>{ <br>m_pSpy -&gt; AddEventToList(perfCount, _TEXT("OnInstanceException"), m_sPackageName); <br> <br>WCHAR id[16]; <br>wsprintfW(id,L"0x%08X", oid); <br>m_pSpy -&gt; AddParamValueToList(L"ObjectID", id); <br> <br>    CComBSTR sCid = GuidToBstr(guidCid); <br>    CComBSTR sIid = GuidToBstr(guidRid); <br> <br>m_pSpy -&gt; AddParamValueToList(L"CLSID", sCid); <br>m_pSpy -&gt; AddParamValueToList(L"riid", sIid); <br> <br>TCHAR      * pszGuidName   =   NULL ; <br>HRESULT hr; <br>hr = GetMethodName(guidRid, iMeth, &amp;pszGuidName) ; <br>    if(hr != S_OK) { pszGuidName = new _TCHAR[64] ; lstrcpy(pszGuidName, L"Unknown (no TypeLibrary)") ; } <br>    m_pSpy -&gt; AddParamValueToList(L"Method Name", pszGuidName); <br> <br>   IF_AUDIT_DO(OnMethodException)(perfCount, <br>  oid, <br>  sCid, <br>  sIid, <br>  pszGuidName); <br> <br> <br>    delete pszGuidName ; <br>    pszGuidName = NULL ; <br>return S_OK; <br>} <br> <br>STDMETHODIMP  CMethodSink::Advise() <br>{ <br>if (m_dwAdviseCookie) <br>return E_FAIL; <br> <br>_ASSERTE(m_pCPC); <br>HRESULT hr; <br>hr = m_pCPC -&gt; FindConnectionPoint(GetIID(), &amp;m_pConPt); <br>if (hr == S_OK) <br>{ <br>hr = m_pConPt -&gt; Advise((IUnknown *)(IMtsMethodEvents *)this, &amp;m_dwAdviseCookie); <br>_ASSERTE(hr == S_OK); <br>} <br> <br>return hr; <br>} <br> <br>HRESULT CMethodSink::GetClsidOfTypeLib2 (IID * piid, UUID * puuidClsid) <br>{ <br>WCHAR*pszBuffIID= 0x0; <br>HRESULThr= S_OK; <br>WCHARrgBufferIid [40]; <br>WCHARszBufferClsid[40]; <br>RPC_STATUSRpcStatus; <br>WCHARrgBufferKey [256]; <br>longlRetVal; <br>HKEYhkey; <br>longlcbszClsidBuff= 40 * sizeof(WCHAR) ; <br> <br>//------------------------------------------------------------------------- <br>//Convert the iid to it's string form <br>RpcStatus = UuidToString ( piid, &amp;pszBuffIID); <br> <br> <br>lstrcpy (rgBufferIid, pszBuffIID); <br>RpcStringFree (&amp;pszBuffIID); <br> <br> <br>//------------------------------------------------------------------------- <br>//Create the Registry key to do the lookup with <br>lstrcpy (rgBufferKey, L"Interface\\{"); <br>lstrcat (rgBufferKey, rgBufferIid); <br>lstrcat (rgBufferKey, L"}\\TypeLib"); <br> <br>//UNDONE -- gaganc Perhaps should handle the \interface\&lt;iid1&gt;\forward\&lt;iid2| <br>//case also. <br> <br>//------------------------------------------------------------------------- <br>//Open the appropriate registry key <br>//HKEY_CLASSES_ROOT\Interface\{&lt;...interface iid ...&gt;}\Typelib <br> <br>lRetVal = RegOpenKey( <br>HKEY_CLASSES_ROOT, <br>rgBufferKey, <br>&amp;hkey <br>); <br> <br>if (lRetVal != ERROR_SUCCESS) <br>{ <br>return E_FAIL; <br>} <br> <br> <br> <br>//------------------------------------------------------------------------- <br>//Obain the clsid from the open key <br>lRetVal = RegQueryValueEx( <br>hkey, <br>NULL, <br>NULL, <br>NULL, <br>(unsigned char *)szBufferClsid, <br>(unsigned long *)&amp;lcbszClsidBuff <br>); <br> <br> <br>    if(lRetVal != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkey) ; <br>        return E_FAIL ; <br>    } <br> <br> <br>//------------------------------------------------------------------------- <br>//Get rid of the braces in the begining and the end. <br> <br>//Remove the trailing brace <br>szBufferClsid[37] = '\0'; <br> <br>//convert the string form of the clsid to a binary form. Plus 1 will  <br>//remove the first brace. <br>lRetVal = UuidFromString ((szBufferClsid + 1), puuidClsid); <br> <br>    if(lRetVal != ERROR_SUCCESS) <br>    { <br>        RegCloseKey(hkey) ; <br>        return E_UNEXPECTED ; <br>    }         <br> <br>//------------------------------------------------------------------------- <br>//Prepare to return <br> <br>lRetVal = RegCloseKey (hkey); <br> <br>return hr; <br>} //end GetClsidOfTypeLib <br> <br> <br>//---------------------------------------------------------------------------- <br>// Function:GetMethodName (INTERNAL FUNCTION) <br>// Description:Takes an IID and a method index returns the corresponding  <br>//              method name. <br>//            <br>// Exceptions:n/a <br>// Process: <br>// Notes:ppszMethodName should be freed by the client using standard <br>//C++ delete.  If hr != S_OK, ppszMethodName will be set to <br>//NULL. <br>//---------------------------------------------------------------------------- <br>HRESULT CMethodSink::GetMethodName (REFIID riid, int iMeth, _TCHAR** ppszMethodName) <br>{ <br>BOOLfRet= FALSE; <br>HRESULThr; <br>UUIDuuidClsid; <br>LCIDlcid= 0x0; <br>ITypeLib*pITypeLib= 0x0; <br>ITypeInfo*pITypeInfo= 0x0; <br>    FUNCDESC    *   pFuncDesc   = 0x0; <br>    _TCHAR      *   pszMethod   = 0x0; <br>    BSTR            bstrName ; <br>    UINT            lcNames     = 0 ; <br> <br>    IID * piid = (IID *) &amp;riid; <br> <br>//Obtain the clsid of the typelib for this interface <br>hr = GetClsidOfTypeLib2 (piid, &amp;uuidClsid); <br> <br>if (hr != S_OK) goto errExit ; <br> <br>//------------------------------------------------------------------------- <br>//Obtain the ITypeLib interface on the typelib <br>hr = LoadRegTypeLib ( <br>uuidClsid,//CLSID <br>1,//Major version number <br>0,//Minor version number <br>0,//the locale id <br>&amp;pITypeLib <br>); <br> <br>// if the default system lcid (0) doesn't work, we try <br>// LCID 9 (standard english) and if that doesn't work, we failfast <br>if(FAILED(hr)) <br>{ <br>hr = LoadRegTypeLib (uuidClsid,1,0,9,&amp;pITypeLib); <br>} <br> <br> <br>    if(FAILED(hr)) goto errExit ; <br> <br>hr = pITypeLib-&gt;GetTypeInfoOfGuid (*piid, &amp;pITypeInfo); <br> <br>    if(FAILED(hr)) goto errExit ; <br> <br>hr = pITypeInfo-&gt;GetFuncDesc(iMeth, &amp;pFuncDesc) ; <br> <br>    if(FAILED(hr)) goto errExit ; <br> <br>    hr = pITypeInfo-&gt;GetNames(pFuncDesc-&gt;memid, &amp;bstrName, 1, &amp;lcNames) ; <br> <br>    if(FAILED(hr)) goto errExit ; <br> <br>    pszMethod = new _TCHAR[lstrlen(bstrName)+1] ; <br> <br>    if(! pszMethod) <br>    { <br>        hr = E_OUTOFMEMORY ; <br>        goto errExit ; <br>    } <br> <br>    lstrcpy(pszMethod, bstrName) ; <br> <br>    SysFreeString(bstrName) ; <br>     <br>errExit:     <br>     <br>    if (pFuncDesc) <br>{ <br>pITypeInfo-&gt;ReleaseFuncDesc(pFuncDesc) ; <br>} <br> <br> <br>if (pITypeInfo) <br>{ <br>pITypeInfo-&gt;Release(); <br>} <br> <br>    if (pITypeLib) <br>    { <br>        pITypeLib-&gt;Release() ; <br>    } <br> <br>    *ppszMethodName = pszMethod ; <br> <br>    return hr ; <br>}  <br> <br>/* ---------------------------------------------------------------------------- <br> @func Description <br>  <br> Usage:&lt;nl&gt; <br>----------------------------------------------------------------------------- */ </code></pre>
<p>&nbsp;</p></body>
</HTML>
