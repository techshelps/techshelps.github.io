<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILERM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1230"></a>FILERM.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: FileRm.cpp <br>* <br>* Description: Implementation of CFileRm <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br> <br>#include "stdafx.h" <br>#include "txdtc.h" <br>#include "txcoord.h" <br>#include "xolehlp.h" <br>#include "CopyFileRm.h" <br>#include "rmworker.h" <br>#include "simplelog.h" <br>#include "rmoptions.h" <br>#include "FileRm.h" <br>#include "rmdlg.h" <br>#define IID_DEFINED <br>#include "rmworker_i.c" <br> <br>#include "rmsink.h" <br>#include "RmOptionsDlg.h" <br> <br>#define CHECK_TM_DOWN() {if (IsTMDown()){if (InitializeRm() == S_OK)TmUp();else returnXACT_E_TMNOTAVAILABLE; }} <br> <br>// <br>//a worker thread function to check if the TM comes back up <br>// <br> <br>DWORD WINAPI TMDownWorkerThread( LPVOID pData); <br> <br> <br>// <br>//Normally if you want to have multiple instances of an RM, you would log a guid  <br>//for each RM instance and reuse it for recovery <br>// <br> <br>static GUID CopyFileRmGuid =  <br>{ 0xf3ffa31a, 0x860a, 0x11d0, { 0xb1, 0x71, 0x0, 0xaa, 0x0, 0xba, 0x32, 0x58 } }; <br> <br> <br>long glWorkers = 0; <br> <br>STDMETHODIMP CFileRm::Connect(BSTR sAppName, long * ulConnHandle) <br>{ <br> <br>CHECK_TM_DOWN(); <br> <br>HRESULT hr;  <br>IRmWorker * pWorker = NULL; <br>hr = CoCreateInstance(CLSID_CRmWorkerObj, NULL, CLSCTX_SERVER, IID_IRmWorker , (void **)&amp;pWorker); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br>hr = pWorker -&gt; Init((IUnknown *)m_pLog, (IUnknown *)m_pIResMgr, (IUnknown *)m_punkDTC, m_options.GetRecDir()); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>pWorker -&gt; Release(); <br>return hr; <br>} <br> <br>InterlockedIncrement(&amp;glWorkers); <br>if (_Module.m_dlg) <br>_Module.m_dlg-&gt;SetUsageCount(glWorkers); <br> <br>*ulConnHandle = (long) pWorker; <br>m_setWorkers.insert(*ulConnHandle); <br>return S_OK; <br>} <br>// <br>//Disconnect() works even if the TM is down, so we <br>//don't use the GetWorker() method <br>// <br>STDMETHODIMP CFileRm::Disconnect(long ulConnHandle) <br>{ <br> <br>IRmWorker * pWorker  = NULL; <br>pWorker = (IRmWorker *)(*m_setWorkers.find(ulConnHandle)); <br>if (!pWorker) <br>{ <br>return E_FAIL; <br>} <br>ULONG lRef = pWorker -&gt; Release(); <br>pWorker = NULL; <br>InterlockedDecrement(&amp;glWorkers); <br>if (_Module.m_dlg) <br>_Module.m_dlg-&gt;SetUsageCount(glWorkers); <br> <br>int nEraseCount = m_setWorkers.erase(ulConnHandle); <br>_ASSERTE(nEraseCount == 1); <br>return S_OK; <br>} <br>// <br>//the whereabouts is the same for every worker, and is fixed for every instance <br>//of the RM <br>// <br>STDMETHODIMP CFileRm::GetTmWhereabouts(long lConHandle, BYTE **rgbTmAddr, ULONG *pcbTmAddr) <br>{ <br> <br>// <br>//NOTE:  this is handle independent! <br>// <br> <br>CHECK_TM_DOWN(); <br>HRESULT hr = S_OK; <br>if (!m_cbTmAddr) <br>{ <br> <br>hr = GetMyTmWhereAbouts(); <br>if (FAILED(hr)) <br>return hr; <br>} <br> <br>*pcbTmAddr = m_cbTmAddr; <br>*rgbTmAddr = (BYTE *) CoTaskMemAlloc (m_cbTmAddr); <br>memcpy(*rgbTmAddr, m_rgbTmAddr, m_cbTmAddr); <br>return hr; <br>} <br>STDMETHODIMP CFileRm::ExportTx(long lConHandle, ULONG cbTranCookie, BYTE *rgbTranCookie) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br>HRESULT hr = pWorker -&gt;ExportTx(cbTranCookie, rgbTranCookie); <br>return  hr; <br>} <br> <br>STDMETHODIMP CFileRm::FileCopyTx(long lConHandle, BSTR sSource, BSTR sDestination, BOOL bFailIfExists) <br>{ <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =pWorker -&gt; FileCopyTx(sSource, sDestination, bFailIfExists); <br>return hr; <br>} <br> <br>STDMETHODIMP CFileRm::FileRenameTx(long lConHandle, BSTR sSource, BSTR sDestination) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =pWorker -&gt; FileRenameTx(sSource, sDestination); <br>return hr; <br>} <br> <br>STDMETHODIMP CFileRm::AddFile(long lConHandle, BSTR sSource, BSTR sDestination) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =pWorker -&gt; AddFile(sSource, sDestination); <br>return  hr; <br>} <br> <br>STDMETHODIMP CFileRm::CopyListTx(long lConHandle) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =  pWorker -&gt; CopyListTx(); <br>return  hr; <br>} <br> <br> <br> <br>STDMETHODIMP CFileRm::FileMoveTxt(long lConHandle, BSTR sSource, BSTR sDestination) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =  pWorker -&gt; FileMoveTxt(sSource, sDestination); <br>return  hr; <br>} <br> <br>STDMETHODIMP CFileRm::FileDeleteTx(long lConHandle, BSTR sFileName) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr =  pWorker -&gt; FileDeleteTx(sFileName); <br>return  hr; <br> <br>} <br> <br> <br>STDMETHODIMP CFileRm::ResetConnection(long lConHandle) <br>{ <br> <br>CHECK_TM_DOWN(); <br>IRmWorker * pWorker = GetWorker(lConHandle); <br>if (!pWorker) <br>{ <br>return E_INVALIDARG; <br>} <br> <br>return pWorker -&gt; Reset(); <br> <br>} <br>// <br>//FinalConstruct() <br>// <br>// <br>HRESULT CFileRm::FinalConstruct() <br>{ <br>HRESULT hRes; <br>hRes = OpenLog(); <br>if (hRes == S_OK) <br>{ <br>hRes = InitializeRm(); <br>{ <br>if (hRes == S_OK) <br>hRes = Recover(); <br>} <br>} <br>return hRes; <br>} <br> <br> <br>// <br>// Perform any required recovery. <br>// <br>HRESULT CFileRm::Recover() <br>{ <br>Lock(); <br>IStorage * pStorage = NULL; <br>long lCount = 0; <br>HRESULT hr; <br>hr = m_pLog -&gt; RecoveryInfo(&amp;pStorage); <br>if (FAILED(hr)) <br>{ <br>Unlock(); <br>return hr; <br>} <br> <br>IRmWorker * pWorker = NULL; <br>hr = CoCreateInstance(CLSID_CRmWorkerObj, NULL, CLSCTX_SERVER, IID_IRmWorker , (void **)&amp;pWorker); <br>if (FAILED(hr)) <br>{ <br>Unlock(); <br>return hr; <br>} <br> <br>BSTR sRecDir = m_options.GetRecDir(); <br>_ASSERTE(sRecDir); <br>hr = pWorker -&gt; Init(m_pLog, m_pIResMgr, m_punkDTC, sRecDir); <br>if (FAILED(hr)) <br>{ <br>Unlock(); <br>return hr; <br>} <br>hr = pWorker -&gt; Recover(pStorage); <br>Unlock(); <br>SafeRelease(pWorker); <br>return hr; <br>} <br> <br> <br>HRESULT CFileRm::InitializeRm() <br>{ <br>HRESULThr = E_FAIL; <br>IResourceManagerFactory*pIRmFactory= NULL; <br> <br>// <br>// we make have a call to this originating from the Resource Dispenser <br>// and while we are in the call, the worker thread wakes up and calls it again <br>// <br> <br>Lock();  <br> <br>if (m_punkDTC) <br>{ <br>Unlock(); <br>return S_OK;// while we were Locked, somebody successfully finished <br>} <br> <br>// <br>// Establish contact with the MS DTC transaction manager.   <br>//  <br> <br> <br>hr = DtcGetTransactionManager (NULL, <br>NULL, <br>IID_IUnknown, <br>0, <br>0, <br>0, <br>(LPVOID *) &amp;m_punkDTC); <br>if (S_OK != hr) <br>{ <br> <br>Unlock(); <br>return hr; <br> <br>}  <br> <br>// <br>//if I wan't caching the IUnknown * of DTC, I could ask for this <br>//interface directly from the DtcGetTransactionManager API, and  <br>//avoid the QI <br>// <br>hr = m_punkDTC-&gt;QueryInterface(IID_IResourceManagerFactory, <br>    (LPVOID *) &amp;pIRmFactory); <br> <br>_ASSERTE(hr == S_OK); // this can never fail <br> <br> <br>CComObject&lt;CResourceManagerSink&gt; * pSink = NULL; <br>hr = CComObject&lt;CResourceManagerSink&gt;::CreateInstance(&amp;pSink); <br> <br>pSink -&gt; SetRm((IFileRm *)this); <br> <br>IResourceManagerSink * pISink = NULL; <br>pSink -&gt; QueryInterface(IID_IResourceManagerSink, (void **)&amp;pISink); <br>_ASSERTE(pISink); <br> <br>// Create instance of the resource manager interface. <br>hr = pIRmFactory-&gt;Create (&amp;CopyFileRmGuid,  <br>   "CopyFileRm",  <br>   pISink,  <br>   &amp;m_pIResMgr ); <br>// <br>//DTC owns the reference (and lifetime) to the IResourceManagerSink interface <br>// <br> <br>SafeRelease(pSink); <br> <br>if (FAILED(hr)) <br>{ <br>SafeRelease(m_punkDTC); <br> <br>} <br> <br>SafeRelease(pIRmFactory); <br> <br>Unlock(); <br>return hr; <br> <br> <br> <br>} <br> <br> <br>HRESULT CFileRm::OpenLog() <br>{ <br> <br> <br>_Module.m_dlg = new CRmDlg(&amp;m_options); <br>_ASSERTE(_Module.m_dlg); <br>HWND hWnd = _Module.m_dlg -&gt; Create(NULL); <br>_Module.m_dlg-&gt;ShowWindow(SW_SHOWNORMAL); <br>_Module.m_dlg-&gt;SetUsageCount(1); <br>_ASSERTE(hWnd); <br> <br>m_pLog = NULL; <br>HRESULT hr;  <br>hr = CoCreateInstance(CLSID_CoSimpleLog, NULL, CLSCTX_SERVER, IID_ISimpleLog , (void **)&amp;m_pLog); <br>if (FAILED(hr)) <br>{ <br>return hr; <br>} <br> <br>CComBSTR sFileName = m_options.GetLogDir(); <br>_ASSERTE(sFileName.m_str); <br>sFileName += L"FileRmLog"; <br>hr = m_pLog -&gt; Init(sFileName); <br>if (FAILED(hr)) <br>return hr; <br> <br>return hr; <br>} <br> <br>HRESULT CFileRm::FinalRelease() <br>{ <br>SafeRelease(m_punkDTC); <br>SafeRelease(m_pIResMgr); <br>return S_OK; <br>} <br>// <br>//the resource Manager's TM goes down <br>// <br>//we need to  <br>//1. set a global variarable so we won't except any new connections <br>//2. free all RmWorkers (make sure they have a TMDown() event already <br>//3. start a worker thread and ping DTC until it comes up <br>//4. when DTC comes back up, do recovery and then accept new connections <br>// <br>//NOTE:  You should NEVER block a DTC thread! <br>// <br>STDMETHODIMP CFileRm::TMDown() <br>{ <br> <br> <br>m_bTMDown = TRUE; <br>WorkerSet::iterator item = m_setWorkers.begin(); <br>IRmWorker * pWorker; <br>while (item != m_setWorkers.end()) <br>{ <br>pWorker = (IRmWorker *)(*item); // get the value <br>// <br>//if the Worker object was enlisted in DTC, then we <br>//are GUARANTEED that they will have gotten the TMDown() <br>//before the RM gets the TMDown(), but I want to make sure <br>//that all Workers get the TMDown, not just the enlisted ones. <br>//my implementation of TMDown() doesn't care if it is called  <br>//twice, so rather than check the state and call TMDown on the <br>//ones that haven't gotten it yet, I'll call it for all workers <br>// <br> <br>if (pWorker) <br>pWorker -&gt; TMDown();  <br>else <br>m_setWorkers.erase(item++); <br> <br>item++; <br>} <br>if (m_cbTmAddr) <br>{ <br>delete m_rgbTmAddr; <br>m_cbTmAddr = 0; <br>} <br> <br>SafeRelease(m_punkDTC); <br>SafeRelease(m_pIResMgr); <br>SafeRelease(m_pLog); <br> <br>DWORD dwThreadID; <br>HANDLE hThread; <br>hThread = CreateThread(NULL, 0, TMDownWorkerThread, (LPVOID)this, NULL, &amp;dwThreadID); <br>return S_OK; <br>} <br> <br>// <br>//Worker Thread that waits for the RM to come back up <br>// <br>DWORD WINAPI TMDownWorkerThread( LPVOID pData) <br>{ <br> <br> <br>CFileRm * pRm = (CFileRm *)pData; <br>BOOL bGo= TRUE; <br>DWORD dwSleepTime = 1000 * 10;  <br> <br> <br>while (bGo) <br>{ <br> <br>if (pRm -&gt; InitializeRm() == S_OK) <br>bGo = FALSE; <br> <br>Sleep(dwSleepTime); <br> <br>} <br> <br> <br>HRESULT hRes; <br>hRes = pRm -&gt; TmUp(); <br>return hRes; <br> <br>} <br>// <br>//called after the TM goes down -- resets everything to a good state <br>// <br>// <br>HRESULT CFileRm::TmUp() <br>{ <br> <br> <br>HRESULT hRes; <br>hRes = OpenLog(); <br>if (SUCCEEDED(hRes)) <br>{ <br>hRes = Recover(); <br>} <br>if (SUCCEEDED(hRes)) <br>{ <br>_ASSERTE(GetLog()); <br>_ASSERTE(GetIResourceManager()); <br>_ASSERTE(GetDTCUnknown()); <br> <br>SetTMDown(FALSE); <br>WorkerSet::iterator item = m_setWorkers.begin(); <br>IRmWorker * pWorker; <br>while (item != m_setWorkers.end()) <br>{ <br>pWorker = (IRmWorker *)(*item); // get the value <br>hRes = pWorker -&gt; Init((IUnknown *)GetLog(), (IUnknown *)GetIResourceManager(), GetDTCUnknown(), m_options.GetRecDir()); <br>_ASSERTE(hRes == S_OK);//this really can't fail... <br>item++; <br>} <br> <br>} <br> <br>hRes = GetMyTmWhereAbouts(); <br> <br>return hRes; <br> <br>} <br> <br> <br>HRESULT CFileRm::GetMyTmWhereAbouts() <br>{ <br> <br>_ASSERTE(GetLog()); <br>_ASSERTE(GetIResourceManager()); <br>_ASSERTE(GetDTCUnknown()); <br>ULONGcbUsed = 0; <br> <br>ITransactionImportWhereabouts*pITxWhere = 0; <br> <br>// Ensure that the resource manager is initializing <br> <br>// Get a pointer to the ITransactionWhereabouts interface. <br>HRESULT hRc = m_punkDTC-&gt;QueryInterface (IID_ITransactionImportWhereabouts, <br> (LPVOID *) &amp;pITxWhere); <br>_ASSERTE (S_OK == hRc); <br>if (S_OK != hRc) <br>{ <br>pITxWhere = 0; <br>return hRc; <br>} // if <br> <br>// Get the size of the whereabouts blob for the TM <br>pITxWhere-&gt;GetWhereaboutsSize (&amp;m_cbTmAddr); <br>m_rgbTmAddr = new BYTE[m_cbTmAddr]; <br>// Get the whereabouts blob <br>hRc = pITxWhere-&gt;GetWhereabouts (m_cbTmAddr, m_rgbTmAddr, &amp;cbUsed); <br>SafeRelease(pITxWhere); <br>return hRc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
