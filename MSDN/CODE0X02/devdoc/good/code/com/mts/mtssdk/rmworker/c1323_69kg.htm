<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RMWORKEROBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1330"></a>RMWORKEROBJ.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: RmWorkerObj.cpp <br>* <br>* Description: Implementation of CRmWorkerObj -- main worker object <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br> <br>#include "stdafx.h" <br>#include "RmWorker.h" <br>#defineINITGUID <br>#include "txdtc.h" <br>#include "txcoord.h" <br>#include "xolehlp.h" <br>#define IID_DEFINED <br>#include "SimpleLog.h" <br>#include "SimpleLog_i.c" <br>#include "action.h" <br>#include "copyfilerm.h" <br>#include "RmWorkerObj.h" <br>#pragma warning( disable : 4786) // disable the warning "identifier was truncated to '255' characters in the debug information" generated by STL <br> <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CRmWorkerObj <br> <br>//--------------------------------------------------------------------- <br>// CRmWorkerObj::CRmWorkerObj <br>// Constructor for a resource manager file operation object.  This <br>// constructor performs three major fuctions: <br>//(1) Create and initialize log object. <br>//(2) Establish a connection with DTC transaction manager. <br>//(3) Get an RM interface object. <br>// <br> <br>CRmWorkerObj::CRmWorkerObj () :  CActionList() <br>{ <br> <br>m_pLog = NULL; <br>m_pIResMgr = NULL; <br>SetState (TX_UNINITIALIZED); <br>m_punkDTC = NULL; <br>m_pEnlist = NULL; <br>m_restartList = NULL; <br>m_hFinishedTxEvent = CreateEvent(NULL, FALSE, TRUE, NULL); <br> <br> <br> <br> <br>} // CRmWorkerObj:CRmWorkerObj() <br> <br>CRmWorkerObj::~CRmWorkerObj(void) <br>{ <br>// Set the state to uninitialized <br>SetState (TX_UNINITIALIZED); <br> <br>if (m_pLog) // not initialized for Recover <br>{ <br>ULONG lLogRefCount = m_pLog -&gt; Release(); <br>m_pLog = NULL; <br>} <br>// Disconnect from DTC <br>if (0 != m_punkDTC) <br>{ <br>m_punkDTC-&gt;Release (); <br>m_punkDTC = 0; <br>} // if <br> <br>// Release IResourceManager interface <br>if (0 != m_pIResMgr) <br>{ <br>m_pIResMgr-&gt;Release (); <br>m_pIResMgr = 0; <br>} // if <br> <br> <br>if (m_pEnlist) <br>{ <br>m_pEnlist -&gt; Release(); <br>m_pEnlist = 0; <br>} <br> <br>if (m_hFinishedTxEvent) <br>{ <br>CloseHandle(m_hFinishedTxEvent); <br>m_hFinishedTxEvent = NULL; <br>} <br> <br>FILECPY*cpy; <br>BOOLfRc = FALSE; <br>FILECPYLIST::iterator i; <br> for (i=m_lstFiles.begin();i != m_lstFiles.end(); ++i) <br> { <br> <br>cpy = *i; <br>delete cpy; <br> <br> } <br> <br> <br>m_lstFiles.clear(); <br> <br>} // CRmWorkerObj::~CRmWorkerObj <br> <br> <br>STDMETHODIMP CRmWorkerObj::AddFile(BSTR sSource, BSTR sDestination) <br>{ <br> <br>FILECPY * cpy = new FILECPY; <br>cpy -&gt; sSource = sSource; <br>cpy -&gt; sDest = sDestination; <br>m_lstFiles.insert(m_lstFiles.end(), cpy); <br> <br>return S_OK; <br>} <br>// <br>//interate through our list of files and copy each of them. <br>//if any copy fails, return an error, which will abort the tx <br>// <br>STDMETHODIMP CRmWorkerObj::CopyListTx() <br>{ <br> <br> <br>FILECPYLIST::iterator item; <br>HRESULT hr; <br>FILECPY * cpy; <br>// Scan the list and recover incomplete transactions -- there should only <br>// be one in the single threaded case. <br>for (item=m_lstFiles.begin();item != m_lstFiles.end(); ++item) <br>{ <br> <br>cpy = *item; <br>hr = FileCopyTx(cpy -&gt; sSource.m_str, cpy -&gt; sDest.m_str, FALSE); <br>if (FAILED(hr)) <br>return hr; <br> <br>} <br>return S_OK; <br>} <br> <br> <br> <br> <br>STDMETHODIMP CRmWorkerObj::Init(IUnknown * pUnkLog, IUnknown * pUnkDtcResMgr, IUnknown *pUnkDtc, BSTR sRecDir) <br>{ <br> <br>//----------------------------------------------------------------- <br>// Set the state of the resource manager as unitialized <br>// <br> <br>SetState (TX_UNINITIALIZED); <br> <br>m_sRecoverDir = sRecDir; <br> <br> <br>// make sure I have a log... <br>_ASSERTE(pUnkLog); <br>HRESULT hr; <br>hr = pUnkLog -&gt; QueryInterface(IID_ISimpleLog, (void **)&amp;m_pLog); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return E_UNEXPECTED; <br>} <br> <br> <br> <br>hr = pUnkDtcResMgr -&gt; QueryInterface(IID_IResourceManager, (void**)&amp;m_pIResMgr); <br>_ASSERTE(hr == S_OK); <br> <br> <br> <br> <br>m_punkDTC = pUnkDtc; <br>m_punkDTC -&gt; AddRef(); <br> <br>// Change the state of the resource manager to reflect that it is  <br>// initialized. <br> <br>SetState (TX_INITIALIZING); <br> <br>return hr; <br>} <br> <br>STDMETHODIMP CRmWorkerObj::GetTransactionId(BSTR * guidTx) <br>{ <br> <br>LPOLESTR sTemp[64]; <br>HRESULT hr = StringFromCLSID(m_guidTx, sTemp); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br> <br>*guidTx = SysAllocString(sTemp[0]); <br>return hr; <br> <br>} // CRmWorkerObj::GetTransactionId() <br> <br> <br>//--------------------------------------------------------------------- <br>// CRmWorkerObj class implementation: <br>//--------------------------------------------------------------------- <br>STDMETHODIMP CRmWorkerObj::FileCopyTx(BSTR sFromFile, BSTR sToFile, BOOL bFailIfExists) <br>{ <br>TXSTATEeTxState; <br>HANDLEhFind; <br>WIN32_FIND_DATAfindData; <br>BOOLfReturn; <br> <br> <br> <br> <br> <br>// Get the current state of the transaction. <br> GetState (&amp;eTxState); <br> <br>// Check if TM is down <br>if (TX_TMDOWN == eTxState) <br>{ <br>SetStatus (RM_STATUS_TM_DOWN); <br>_ASSERTE(0); <br>return E_FAIL; <br>} // if  <br> <br>// Ensure that a transaction is enlisted <br>if (TX_ENLISTED != eTxState) <br>{ <br>SetStatus (RM_STATUS_INVALID_STATE); <br>return E_FAIL; <br> <br>} // if <br> <br> <br>// Source of copy does not exist -- copy is erroneous. <br>hFind = FindFirstFile (sFromFile, &amp;findData); <br>if (INVALID_HANDLE_VALUE == hFind) <br>{ <br>FindClose (hFind); <br>SetStatus (RM_STATUS_FILE_NOT_FOUND); <br>return E_FAIL; <br>} // if <br>FindClose (hFind); <br> <br>// a copy over itself is a NOOP <br>if (lstrcmpi(sFromFile, sToFile) == 0)  <br>{ <br> <br>return S_OK; <br> <br>} <br> <br> <br>hFind = FindFirstFile (sToFile, &amp;findData); <br>if (INVALID_HANDLE_VALUE != hFind) <br>{ <br> <br> <br>// The target file exists.  if bFailIfExists, return an error <br>// TODO: add GetLastError() information <br>if (bFailIfExists) <br>{ <br>FindClose (hFind); <br>return E_FAIL; <br>} <br> <br>// do a transactional delete of the target file so that <br>// the file destruction is recorded in the log, then copy. <br>if (S_OK != FileDeleteTx (sToFile)) <br>{ <br>// File delete not successful -- therefore copy is not  <br>// successful. <br> <br>return E_FAIL; <br>} // if <br>} // if  <br>FindClose (hFind); <br> <br>CAction * pAction = new CAction(LOG_RM_PRIVATE, RM_COPY,  sFromFile, sToFile); <br>fReturn = PushAction (pAction); <br>_ASSERTE (TRUE == fReturn); <br>if (FALSE == fReturn) <br>{ <br>SetStatus (RM_STATUS_IN_MEMORY_LIST); <br>return E_FAIL; <br>} // if <br> <br>HRESULT hr = WriteLog (m_guidTx, pAction); <br> <br>if (hr != S_OK) <br>{ <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>SetStatus (RM_STATUS_LOG_ERROR); <br>return E_FAIL; <br>} // if <br> <br>fReturn = CopyFile (sFromFile, sToFile, bFailIfExists); <br>if (TRUE != fReturn) <br>{ <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>HRESULT hr = WriteLog  (m_guidTx, LOG_RM_PRIVATE, RM_FORGET, 0, 0); <br>_ASSERTE (hr == S_OK); <br> <br>// Undo the delete action <br>hr = UndoDelete ((TCHAR *)pAction -&gt; m_sPath1, (TCHAR *)pAction -&gt; m_sPath2); <br>_ASSERTE (S_OK == hr); <br> <br>// Log the UNDO as a forget action. <br>hr = WriteLog  (m_guidTx,  LOG_RM_PRIVATE, RM_FORGET, 0, 0); <br>_ASSERTE (hr == S_OK); <br> <br>// Remove the delete log action from the in-memory action list. <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>SetStatus (RM_STATUS_COPY_FAILURE); <br>return E_FAIL; <br> <br>} // if <br> <br>// copy succeeded -- open the file to create a lock on the file <br> <br>pAction -&gt; LockFile(sToFile); <br>_ASSERTE(pAction -&gt; m_hLock); <br> <br>return(S_OK); <br> <br>} // CRmWorkerObj::FileCopy <br> <br>// <br>//built up fromt he FileCopyTx and FileDeleteTx primitives <br>// <br>STDMETHODIMP CRmWorkerObj::FileMoveTxt(BSTR sSource, BSTR sDestination) <br>{ <br> <br>HRESULT hr; <br> <br>// copy the file <br>hr = FileCopyTx(sSource, sDestination, FALSE); <br>if (FAILED(hr)) <br>return hr; <br> <br>// delete the file <br>return FileDeleteTx(sSource); <br> <br>} // CRmWorkerObj::FileMoveTx <br> <br> <br>STDMETHODIMP CRmWorkerObj::FileDeleteTx(BSTR sFileName) <br>{ <br> <br>BOOLfReturn; <br>TXSTATE eTxState; <br>TCHAR*pszFileName = 0; <br>TCHARsTmpFile[MAX_PATH]; <br>  <br> <br>// Get transaction state. <br>GetState (&amp;eTxState); <br> <br>// Check if TM is down return with TM Down status. <br>if (TX_TMDOWN == eTxState) <br>{ <br>SetStatus (RM_STATUS_TM_DOWN); <br>return E_FAIL; <br>} // if <br> <br>// Ensure that a transaction is enlisted <br>if (TX_ENLISTED != eTxState) <br>{ <br>SetStatus (RM_STATUS_INVALID_STATE); <br>return E_FAIL; <br>} // if <br> <br>memset(sTmpFile, NULL, MAX_PATH); <br>GetTempFile(sTmpFile); <br>_ASSERTE (0 != sTmpFile); <br> <br>CAction * pAction = new CAction(LOG_RM_PRIVATE,RM_DELETE,  sFileName, sTmpFile); <br>fReturn = PushAction (pAction); <br>_ASSERTE (TRUE == fReturn); <br> <br>HRESULT hr = WriteLog (m_guidTx, LOG_RM_PRIVATE, RM_DELETE, sFileName, sTmpFile); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE (0); <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br>SetStatus (RM_STATUS_LOG_ERROR); <br>return E_FAIL; <br>} // if <br> <br> <br>fReturn = MoveFileEx (sFileName,  <br>  sTmpFile, <br>  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED); <br>if (TRUE != fReturn) <br>{ <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>hr = WriteLog (m_guidTx, LOG_RM_PRIVATE,RM_FORGET, 0, 0); <br>_ASSERTE(hr == S_OK); <br>SetStatus (RM_STATUS_MOVE_FAILURE); <br>return E_FAIL; <br>} // if <br> <br>#ifdef _DEBUG // testing PeekAction <br>pAction  = NULL;  <br>PeekAction(&amp;pAction); <br>_ASSERTE(pAction); <br>_ASSERTE(pAction -&gt; m_eFileOp == RM_DELETE); <br>#endif <br>pAction -&gt; LockFile(sTmpFile); <br> <br>_ASSERTE(pAction -&gt; m_hLock); <br> <br>return S_OK; <br> <br> <br>} // CRmWorkerObj::FileDelete <br> <br> <br>STDMETHODIMP CRmWorkerObj::FileRenameTx(BSTR sFromFile, BSTR sToFile) <br>{ <br>TXSTATEeTxState; <br>HANDLEhFind; <br>WIN32_FIND_DATA findData; <br>BOOLfReturn; <br> <br>// Get transaction state. <br>GetState (&amp;eTxState); <br> <br>// Check if TM is down return with TM Down status. <br>if (TX_TMDOWN == eTxState) <br>{ <br>SetStatus (RM_STATUS_TM_DOWN); <br>return E_FAIL; <br>} // if <br> <br>// Ensure that a transaction is enlisted <br>if (TX_ENLISTED != eTxState) <br>{ <br>SetStatus (RM_STATUS_INVALID_STATE); <br>return E_FAIL; <br>} // if <br> <br>// Check if target path exists. <br>hFind = FindFirstFile (sToFile, &amp;findData); <br>if (INVALID_HANDLE_VALUE != hFind) <br>{ <br>FindClose (hFind); <br>SetStatus (RM_STATUS_OVERWRITE_EXISTING); <br>return E_FAIL; <br>} // if <br>FindClose (hFind); <br> <br>CAction * pAction = new CAction(LOG_RM_PRIVATE, RM_RENAME, sFromFile, sToFile); <br>fReturn = PushAction (pAction); <br>_ASSERTE (TRUE == fReturn); <br> <br>HRESULT hr = WriteLog  (m_guidTx, pAction); <br>if (hr != S_OK) <br>{ <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>SetStatus (RM_STATUS_LOG_ERROR); <br>return E_FAIL; <br>} // if <br> <br>fReturn = MoveFileEx( sFromFile, <br>  sToFile,  <br>  MOVEFILE_COPY_ALLOWED ); <br>if (TRUE != fReturn) <br>{ <br>fReturn = RemoveAction (); <br>_ASSERTE (TRUE == fReturn); <br> <br>HRESULT hr = WriteLog  (m_guidTx, RM_FORGET, RM_NONE, 0, 0); <br>_ASSERTE (hr == S_OK); <br> <br>SetStatus (RM_STATUS_RENAME_FAILURE); <br>return E_FAIL; <br>} // if <br> <br>return S_OK; <br> <br>} // CRmWorkerObj::FileRename <br> <br> <br> <br> <br> <br>// <br>//called by the RM when it is time to enlist in a Tx <br>// <br>//this can be called with multiple tx's in the same instance <br>// <br>STDMETHODIMP  CRmWorkerObj::ExportTx(ULONG cbTranCookie, BYTE *rgbTranCookie) <br>{ <br>HRESULThRc; <br>ITransactionImport*pTxImport; <br> <br>// if this worker is in the process of aborting, wait until it is done <br>WaitTxDone(); <br> <br>TXSTATEeTxState; <br>GetState (&amp;eTxState); <br> <br>// Ensure that the resource manager is initializing <br>// it is possible that everything was OK up to this point <br>// but we blocked waiting for an Commit or an Abort to complete <br>// and then the TM went down <br>if (TX_INITIALIZING != eTxState) <br>{ <br>SetStatus (RM_STATUS_INVALID_STATE); <br>return E_FAIL; <br>} // if <br> <br> <br>// Create and initialize transaction completion event handle. <br> <br>// Get a pointer to the ITransactionImport interface. <br>hRc = m_punkDTC-&gt;QueryInterface (IID_ITransactionImport, <br>     (LPVOID *) &amp;pTxImport); <br>if (S_OK != hRc) <br>{ <br>pTxImport = 0; <br> <br>SetStatus (RM_STATUS_INTERFACE); <br>return E_FAIL; <br>} // if <br> <br>m_pITx = 0; <br>hRc = pTxImport-&gt;Import (cbTranCookie,  <br> rgbTranCookie, <br> (GUID *) &amp;IID_ITransaction, <br> (void **) &amp;m_pITx); <br>_ASSERTE (0 != m_pITx); <br>if (S_OK != hRc) <br>{ <br>pTxImport-&gt;Release (); <br>pTxImport = 0; <br> <br>SetStatus (RM_STATUS_IMPORT_ERROR); <br>return E_FAIL; <br>} // if <br> <br>SafeRelease(pTxImport); <br>// The resource manager is initialized for the transaction. <br>SetState (TX_INITIALIZED); <br>return EnlistTx(); <br> <br> <br>} // CRmWorkerObj::ExportTx <br> <br> <br> <br>HRESULT CRmWorkerObj::EnlistTx() <br>{ <br>HRESULThRc; <br>BOOLfRc; <br> <br> <br>// Ensure that the resource manager is initialized before enlisting <br>// transaction. <br>TXSTATEeTxState; <br>GetState (&amp;eTxState); <br>if (TX_INITIALIZED != eTxState) <br>{ <br>SetStatus (RM_STATUS_INVALID_STATE); <br>return E_FAIL; <br>} // if <br> <br>// Create a transaction resource async object for hadling 2PC <br>// requests. <br> <br>ITransactionResourceAsync * ptxRmAsync = NULL; <br>GetUnknown() -&gt; QueryInterface(IID_ITransactionResourceAsync, (void**)&amp;ptxRmAsync);// does an AddRef that DTC should Release() <br>_ASSERTE (0 != ptxRmAsync); <br> <br>// <br>// Enlist on the transaction  <br>// <br>//if m_pEnlist != NULL, that means that we are reinlisting on a new  <br>//tx -- so we are going to get rid of this m_pEnlist and get a new one <br>// <br>if (m_pEnlist) <br>{ <br>m_pEnlist -&gt; Release(); <br>m_pEnlist = 0; <br>} <br> <br>hRc = m_pIResMgr-&gt;Enlist (m_pITx,  <br>  ptxRmAsync, <br>  &amp;m_guidTx,  <br>  &amp;m_isoLevel,  <br>  &amp;m_pEnlist); <br> <br>if (S_OK != hRc) <br>{ <br>_ASSERTE(0); <br>// Transaction enlistment failed -- release resource async object <br>//and return enlistment failure <br> <br>ptxRmAsync-&gt;Release(); <br>ptxRmAsync = NULL; <br>SetStatus (RM_STATUS_ENLIST_ERROR); <br>return E_FAIL; <br>} // if <br> <br> <br>// Update log and in-memory list <br>CAction * pAction = new CAction(LOG_RM_XACT_BEGIN, RM_NONE, 0, 0); <br>fRc = PushAction(pAction); <br>_ASSERTE (TRUE == fRc); <br> <br>hRc = WriteLog  (m_guidTx, pAction); <br>_ASSERTE (hRc == S_OK); <br> <br>// Set current state to reflect enlistment <br>SetState (TX_ENLISTED); <br> <br> <br>// release our Async interface -- DTC did an AddRef for us <br>SafeRelease(ptxRmAsync); <br>return S_OK; <br> <br>} // CRmWorkerObj::EnlistTx <br> <br> <br>HRESULT CRmWorkerObj::UndoCopy(TCHAR *sFromFile, TCHAR *sToFile) <br>{ <br>BOOLfReturn; <br> <br>fReturn = DeleteFile( sToFile ); <br>if (TRUE != fReturn) <br>{ <br>SetStatus (RM_STATUS_UNDO_ERROR); <br>return E_FAIL; <br>} // if <br> <br>return S_OK; <br> <br>} // CRmWorkerObj::UndoCopy <br> <br> <br>HRESULT CRmWorkerObj::UndoMove(TCHAR *sFromFile, TCHAR *sToFile) <br>{ <br>BOOLfReturn; <br> <br>fReturn = MoveFileEx( sToFile, <br>  sFromFile,  <br>  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED); <br>if (TRUE != fReturn) <br>{ <br>SetStatus (RM_STATUS_UNDO_ERROR); <br>return E_FAIL; <br>} // if <br> <br>return S_OK; <br>} // CRmWorkerObj::UndoMove <br> <br>// <br>//move the file frome the temporary location back to its original, <br>//  and then delete the temp file <br>// <br>HRESULT CRmWorkerObj::UndoDelete(TCHAR *sFileName, TCHAR *sTmpFile) <br>{ <br> <br>BOOLfReturn; <br> <br>fReturn = MoveFileEx (sTmpFile, <br>  sFileName,  <br>  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED); <br>if (TRUE != fReturn) <br>{ <br>_ASSERTE(0); <br>SetStatus (RM_STATUS_UNDO_ERROR); <br>return E_FAIL; <br>} // if <br> <br>return S_OK; <br> <br>} // CRmWorkerObj::UndoDelete() <br> <br> <br>HRESULT CRmWorkerObj::UndoRename(TCHAR *sFromFile, TCHAR *sToFile) <br>{ <br>BOOLfReturn; <br> <br>fReturn = MoveFileEx (sToFile, <br>  sFromFile,  <br>  MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED); <br>if (TRUE != fReturn) <br>{ <br>SetStatus (RM_STATUS_UNDO_ERROR); <br>return E_FAIL; <br>} // if <br> <br>return S_OK; <br>} // CRmWorkerObj::UndoRename() <br> <br> <br> <br> <br>HRESULT CRmWorkerObj::RollbackTx (void) <br>{ <br>BOOLfReturn = FALSE; <br>HRESULThr; <br>CAction*pAction = NULL; <br> <br>ACTIONLIST::iterator item; <br>  <br> // scan through the list and undo each operation <br>// for (item = m_plistAction -&gt; begin();item != m_plistAction -&gt; end(); ++item) <br>for (item = begin();item != end(); ++item) <br>{ <br> <br>pAction = *item; <br>pAction -&gt; ReleaseLock(); // we need to close the destination so that we can delete it if we have to  <br>switch (pAction -&gt; m_eFileOp) <br>{ // For each RM command take undo action. <br>case RM_COPY: <br>hr = UndoCopy (pAction -&gt; m_sPath1, pAction -&gt; m_sPath2); <br>break; <br>case RM_DELETE: <br>hr = UndoDelete (pAction -&gt; m_sPath1, pAction -&gt; m_sPath2); <br>break; <br>case RM_RENAME: <br>hr = UndoRename (pAction -&gt; m_sPath1, pAction -&gt; m_sPath2); <br>break; <br>case RM_MOVE: <br>hr = UndoMove (pAction -&gt; m_sPath1, pAction -&gt; m_sPath2); <br>break; <br>case RM_NONE:  // it is a TX oriented item (such as BEING_TX, and no rollback needed <br>hr = S_OK; <br>break; <br>default: <br>_ASSERTE (FALSE); <br>SetStatus (RM_STATUS_LOG_ERROR); <br>hr = E_FAIL; <br>} // switch <br> <br>if (S_OK == hr) <br>{ <br>HRESULT hr = WriteLog  (m_guidTx, LOG_RM_PRIVATE, RM_UNDO, 0, 0); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>SetStatus (RM_STATUS_LOG_ERROR); <br>hr = E_FAIL; <br>break; <br>} // if <br> <br>} // if <br>else <br>{ <br>OutputDebugString(_TEXT("RMWORKER: RollbackTx failed!\n")); <br>_ASSERTE(0); <br>} <br> <br>} // for  <br> <br>if (S_OK == hr) <br>{ <br>// Write undo end record. <br>HRESULT hr = WriteLog  (m_guidTx, LOG_RM_PRIVATE, RM_UNDO_END, 0, 0);  <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>SetStatus (RM_STATUS_LOG_ERROR); <br>hr = E_FAIL; <br>} // if <br>} // if  <br> <br>return hr; <br> <br>} // CRmWorkerObj::RollbackTx() <br> <br>// <br>// <br>// <br>// <br>RECOVERYRC CRmWorkerObj::RecoverTx (IStream * pStream) <br>{ <br> <br>RECOVERYRCeRecoverRc; <br>RECOVERY_RECORD*precTxn; <br>CAction*pAction; <br>XACTSTATxactOutcome; <br>ULONGulTimeout = XACTCONST_TIMEOUTINFINITE; <br>ULONGcbPrepareInfo; <br>BYTE*pbPrepareInfo; <br>HRESULThRc; <br>HRESULTret; <br>HRESULThr; <br> <br>eRecoverRc = RecMapTransactions (pStream); <br>if (REC_S_SUCCESS != eRecoverRc) <br>{ <br>return eRecoverRc; <br>} // if <br> <br>// Create a list iterator <br> RECOVERY_LIST::iterator crecIter; <br> // Scan the list and recover incomplete transactions -- there should only <br>// be one in the single threaded case. <br> for (crecIter=m_restartList -&gt; begin();crecIter != m_restartList -&gt; end(); ++crecIter) <br> { <br>precTxn = *crecIter; <br>switch (precTxn-&gt;eRecState) <br>{ <br>case REC_STATE_ACTIVE: <br>m_guidTx = precTxn-&gt;guidTxn; <br>ResetActions (precTxn-&gt;actionList); <br>ret = AbortTx (); <br>if (REC_S_SUCCESS != ret) <br>{ <br>_ASSERTE(0); <br>return REC_E_UNDO_INCOMPLETE; <br>} // if <br>break; <br>case REC_STATE_ABORTING: <br>m_guidTx = precTxn-&gt;guidTxn; <br>ResetActions (precTxn-&gt;actionList); <br>ret = RollbackTx(); <br>if (REC_S_SUCCESS != ret) <br>{ <br>_ASSERTE(0); <br>return REC_E_UNDO_INCOMPLETE; <br>} // if <br>CleanupAction (); <br>break; <br>case REC_STATE_DORMANT: <br>hr = WriteLog  (precTxn-&gt;guidTxn, LOG_RM_XACT_END, RM_NONE, 0, 0); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>return REC_E_LOG_FAILURE; <br>} // if <br>break; <br>case REC_STATE_INDOUBT: <br>// Must re-enlist with MS-DTC to determine the transaction outcome. <br>precTxn-&gt;actionList-&gt;PeekAction (&amp;pAction); <br>if (LOG_RM_XACT_PREPARE != pAction -&gt; m_eRmCommand) <br>{ <br>_ASSERTE(0); <br>return REC_E_INDOUBT_INVALID; <br>} // if <br> <br>// Reenlist with MS DTC to determine the outcome of the  <br>// in-doubt transaction. <br>swscanf ((TCHAR *)pAction -&gt; m_sPath1, L"%ld", &amp;cbPrepareInfo); <br>pbPrepareInfo = (BYTE *) pAction -&gt; m_sPath2; <br>hRc = m_pIResMgr-&gt;Reenlist (pbPrepareInfo,  <br>cbPrepareInfo,  <br>ulTimeout,  <br>&amp;xactOutcome); <br> <br>if (S_OK != hRc) <br>{ <br>return REC_E_REENLIST; <br>} // if <br> <br>// Reenlistment is successful -- act on transaction outcome. <br>m_guidTx = precTxn-&gt;guidTxn; <br>precTxn-&gt;actionList-&gt;RemoveAction (); <br>// delete the prepare action. <br>ResetActions (precTxn-&gt;actionList); <br>if (XACTSTAT_ABORTED == xactOutcome) <br>{ <br>ret = AbortTx (); <br>} <br>else if (XACTSTAT_COMMITTED == xactOutcome) <br>{ <br>ret = CommitTx (); <br>}  <br>else if (XACT_E_CONNECTION_DOWN == hRc) <br>{ <br>// Lost connection with MS DTC return TM down exception. <br>return REC_E_TM_DOWN; <br>}  <br>else if (E_UNEXPECTED == hRc) <br>{ <br>// Something unexpected happened -- presume abort. <br>ret = AbortTx (); <br>} <br>else <br>{// Problems during re-enlistment. <br>return REC_E_REENLIST; <br>} // if <br> <br>// Check outcome of transaction commit and abort. <br>if (REC_S_SUCCESS != ret) <br>{ <br>return REC_E_OUTCOMEACTION; <br>} // if <br> <br>// Everything is OK. <br>hr =  WriteLog  (precTxn-&gt;guidTxn, LOG_RM_XACT_END, RM_NONE, 0, 0); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>return REC_E_LOG_FAILURE; <br>} // if <br> <br>// End the re-enlistment on the resource manager. <br>hRc = m_pIResMgr-&gt;ReenlistmentComplete (); <br>_ASSERTE (S_OK == hRc); <br>break; <br>case REC_STATE_COMPLETED: <br>break; <br>default: <br>_ASSERTE (FALSE); <br>return REC_E_STATE_UNKNOWN; <br>} // switch <br> <br>} // for -- iteration through recover node list. <br> <br>return REC_S_SUCCESS; <br> <br>} // CRmWorkerObj::RecoverTx <br> <br> <br> <br>// <br>//scan the stream and build an action list of actions to recover from <br>//the stream contains the GUID that is the TxID followed by n LOG_RM_ACTIONs <br>// <br>RECOVERYRC CRmWorkerObj::RecMapTransactions (IStream * pStream) <br>{ <br> <br>BOOLfRc = TRUE; <br>RECOVERY_RECORD *precTxn; <br> <br>m_restartList = new RECOVERY_LIST; <br>_ASSERTE (0 != m_restartList); <br>if (0 == m_restartList) <br>{ <br>return REC_E_NO_MEMORY; <br>} // if <br> <br>CAction * pAction; <br>ULONG ulActionSize; <br>ULONG cbBytesRead; <br>HRESULT hr; <br>GUID guidTx; <br>LARGE_INTEGER liOff; <br>ULARGE_INTEGER liNewPosition; <br> <br>LOG_RM_COMMAND eOp; <br> <br>BYTE * pByte = NULL; <br> <br>// get the Tx for this stream <br>LISet32(liOff,  0); <br>// seek to the end of the stream, and back up sizeof(LOG_RM_ACTION) <br>hr = pStream -&gt; Seek(liOff, STREAM_SEEK_CUR, &amp;liNewPosition); <br> <br>hr = pStream -&gt; Read(&amp;guidTx, sizeof(guidTx), &amp;cbBytesRead); <br> <br>// read in the actions <br>do <br>{ <br> <br>hr = pStream -&gt; Read(&amp;eOp, sizeof(eOp), &amp;cbBytesRead); <br>hr = pStream -&gt; Read(&amp;ulActionSize, sizeof(ULONG), &amp;cbBytesRead); <br>_ASSERTE(hr == S_OK); <br>if (hr == S_OK &amp;&amp; cbBytesRead) <br>{ <br>pAction = new CAction; // we'll delete it if we do NOT push the action <br>_ASSERTE(sizeof(ulActionSize) == cbBytesRead); <br>pByte = new BYTE[ulActionSize]; <br>hr = pStream -&gt; Read(pByte, ulActionSize, &amp;cbBytesRead); <br>_ASSERTE(cbBytesRead == ulActionSize); <br>hr = pAction -&gt; Load(pByte, ulActionSize); <br>_ASSERTE(hr == S_OK); <br>delete [] pByte; <br>pByte = NULL; <br> <br>precTxn = 0; <br>precTxn = RecGetTransaction (guidTx); <br> <br>// Transaction should be on list. <br>if (0 == precTxn &amp;&amp; LOG_RM_XACT_BEGIN != pAction -&gt; m_eRmCommand) <br>{ <br>// Ghost transaction on transaction list. <br>return REC_E_ORPHANED_TRANSACTION; <br>} // if <br> <br>// Update action list for the transaction. <br>switch (pAction -&gt; m_eFileOp) <br>{ <br>case RM_COPY: <br>case RM_DELETE: <br>case RM_RENAME: <br>case RM_MOVE: <br>// Transaction must be active. <br>if (REC_STATE_ACTIVE != precTxn-&gt;eRecState) <br>{ <br>return REC_E_INVALID_STATE; <br>} // if <br>fRc = precTxn-&gt;actionList-&gt;PushAction (pAction); <br>_ASSERTE (TRUE == fRc); <br>break; <br>case RM_UNDO: <br>// Transaction must be aborting for an undo to occur. <br>if (REC_STATE_ABORTING != precTxn-&gt;eRecState) <br>{ <br>// Transaction end sequence error. <br>return REC_E_UNDO_SEQUENCE; <br>} // if <br>fRc = precTxn-&gt;actionList-&gt;RemoveAction (); // removes LAST action <br>delete pAction; <br>_ASSERTE (TRUE == fRc); <br>break; <br>case RM_FORGET: <br>// Transaction must be active for a forget to occur. <br>if (REC_STATE_ACTIVE != precTxn-&gt;eRecState) <br>{ <br>// Transaction end sequence error. <br>return REC_E_FORGET_SEQUENCE; <br>} // if <br>fRc = precTxn-&gt;actionList-&gt;RemoveAction (); <br>delete pAction; <br>_ASSERTE (TRUE == fRc); <br>break; <br>case RM_UNDO_BEGIN: <br>if (REC_STATE_INDOUBT == precTxn-&gt;eRecState) <br>{ <br>// Transaction not in-doubt remove the prepared record <br>// from the action list. <br>fRc = precTxn-&gt;actionList-&gt;RemoveAction (); <br>_ASSERTE (TRUE == fRc); <br>} <br>else if (REC_STATE_ACTIVE != precTxn-&gt;eRecState) <br>{ <br>// Transaction end sequence error. <br>return REC_E_BEGINUNDO_SEQUENCE; <br>} // if <br>precTxn-&gt;eRecState = REC_STATE_ABORTING; <br>delete pAction; <br>break; <br>case RM_UNDO_END: <br>if (REC_STATE_ABORTING != precTxn-&gt;eRecState) <br>{ <br>// Transaction transaction end undo error. <br>return REC_E_ENDUNDO_SEQUENCE; <br>} // if  <br>precTxn-&gt;eRecState = REC_STATE_DORMANT; <br>delete pAction; <br>break; <br>    case RM_NONE: <br>switch (pAction -&gt; m_eRmCommand) <br>{ <br>case LOG_RM_XACT_PREPARE: <br>// Transaction must be active. <br>if (REC_STATE_ACTIVE != precTxn-&gt;eRecState) <br>{ <br>// Prepare sequence error. <br>return REC_E_PREPARE_SEQUENCE; <br>} // if <br>precTxn-&gt;eRecState = REC_STATE_INDOUBT; <br>fRc = precTxn-&gt;actionList-&gt;PushAction (pAction); <br>_ASSERTE (TRUE == fRc); <br>break; <br>case LOG_RM_XACT_BEGIN: <br>if (0 != precTxn) <br>{ <br>// Starting a duplicate transaction. <br>return REC_E_TRANSACTION_DUPLICATED; <br>} // if <br> <br>precTxn = new RECOVERY_RECORD; <br>_ASSERTE (0 != precTxn); <br>if (0 == precTxn) <br>{ <br>// Space not allocated, return with a no memory error. <br>return REC_E_NO_MEMORY; <br>} //  if <br> <br>precTxn-&gt;guidTxn      = guidTx; <br>precTxn-&gt;eRecState  = REC_STATE_ACTIVE; <br>precTxn-&gt;actionList   = new CActionList; <br>_ASSERTE (0 != precTxn-&gt;actionList); <br>if (0 == precTxn-&gt;actionList) <br>{ <br>// Space not allocated for action list; return with no memory error. <br>return REC_E_NO_MEMORY; <br>} // if <br>fRc = precTxn-&gt;actionList-&gt;PushAction (pAction); <br> <br>_ASSERTE (TRUE == fRc); <br>m_restartList-&gt;insert (m_restartList-&gt;begin(), precTxn); <br> <br>break; <br>case LOG_RM_XACT_END: <br>// Transaction must be dormant -- either committed or aborted. <br>if (REC_STATE_DORMANT != precTxn-&gt;eRecState) <br>{ <br>// Transaction end sequence error. <br>return REC_E_END_TRANSACTION_SEQUENCE; <br>} // if <br>precTxn-&gt;eRecState = REC_STATE_COMPLETED; <br>RecDiscardTransaction (guidTx); <br>delete pAction; <br>break; <br>case LOG_RM_XACT_COMMIT: <br>if (REC_STATE_INDOUBT == precTxn-&gt;eRecState) <br>{ <br>// Transaction not in doubt -- remove prepare <br>// action from the action list. <br>fRc = precTxn-&gt;actionList-&gt;RemoveAction (); <br>_ASSERTE (TRUE == fRc); <br>} <br>else if (REC_STATE_ACTIVE != precTxn-&gt;eRecState) <br>{ <br>// Transaction commit sequence error. <br>return REC_E_COMMIT_SEQUENCE; <br>} // if <br>precTxn-&gt;eRecState = REC_STATE_DORMANT; <br>delete pAction; <br>break; <br>default: <br>return REC_E_INVALID_LOG_RECORD; <br>} // inner switch <br>break; <br>default: <br>_ASSERTE(0); // invalid log <br>delete pAction; <br>return REC_E_INVALID_LOG_RECORD; <br>} // outer switch <br>} <br>} while ((hr == S_OK) &amp;&amp; (cbBytesRead)); // while <br> <br>// Transaction remapping successful return to recovery manager. <br>return REC_S_SUCCESS; <br> <br>} // CRmWorkerObj::RecMapTransactions() <br> <br> <br> <br>RECOVERY_RECORD *CRmWorkerObj::RecGetTransaction (GUID&amp; guidTxn) <br>{ <br>RECOVERY_LIST::iterator crecIter; <br>RECOVERY_RECORD*precTxn; <br>LONGuuidStatus; <br> <br>for (crecIter=m_restartList-&gt;begin();crecIter != m_restartList -&gt; end(); ++crecIter) <br>{ <br>precTxn = *crecIter; <br>if (UuidEqual (&amp;precTxn-&gt;guidTxn, &amp;guidTxn, &amp;uuidStatus)) <br>{ <br>return precTxn; <br>} // if <br>} // for <br> <br>precTxn = 0; </code></pre>
<p>
</p>
<pre><code>return precTxn; <br>} // CRmWorkerObj::RecGetTransaction () <br> <br> <br>void CRmWorkerObj::RecDiscardTransaction (GUID&amp; guidTxn) <br>{ <br> <br>RECOVERY_LIST::iterator crecIter; <br>RECOVERY_RECORD*precTxn; <br>LONGuuidStatus; <br> <br>for (crecIter=m_restartList -&gt; begin();crecIter != m_restartList -&gt; end(); ++crecIter) <br>{ <br>if (UuidEqual (&amp;(*crecIter)-&gt;guidTxn, &amp;guidTxn, &amp;uuidStatus)) <br>{ <br>precTxn = *crecIter; <br>m_restartList -&gt;remove(precTxn); <br>delete precTxn-&gt;actionList; <br>delete precTxn; <br>return; <br>} // if <br>} // for   <br>} // CRmWorkerObj::RecDiscardTransaction() <br> <br> <br>void CRmWorkerObj::RecoverCleanup (void) <br>{ <br>RECOVERY_RECORD*precTxn = 0; <br>if (!m_restartList) <br>return; <br>while (TRUE != m_restartList-&gt;empty()) <br>{ <br>// get the first element <br>precTxn = m_restartList-&gt;front(); <br>// delete it <br>delete precTxn; <br>// remove it from our list <br>m_restartList-&gt;pop_front(); <br>precTxn = 0; <br>} // while <br>} // CRmWorkerObj::RecoverCleanup <br> <br>void CRmWorkerObj::SetStatus (RMSTATUS ermStatus) <br>{ <br>m_eStatus = ermStatus; <br>} // CRmWorkerObj::SetStatus() <br> <br> <br>RMSTATUS CRmWorkerObj::GetStatus (void) <br>{ <br>return m_eStatus; <br>} // CRmWorkerObj::GetStatus() <br> <br> <br> <br> <br> <br>//--------------------------------------------------------------------- <br>// End of $Workfile: RmWorkerObj.cpp $ <br>//--------------------------------------------------------------------- <br> <br> <br> <br> <br> <br> <br>STDMETHODIMP CRmWorkerObj::PrepareRequest(BOOL fRetaining, <br>DWORD grfRM, <br>BOOL fWantMoniker, <br>BOOL fSinglePhase) <br>{ <br>HRESULThr = S_OK; <br> <br>TXSTATEeTxState; <br>GetState (&amp;eTxState); <br> <br>if (TX_ENLISTED != eTxState) <br>{ <br>_ASSERTE(0); <br>// Set the state of the transaction as invalid. <br>SetState (TX_INVALID_STATE); <br> <br>// Transaction is in an invalid state -- return error <br>hr = m_pEnlist-&gt;PrepareRequestDone (E_UNEXPECTED,NULL,NULL); <br>    _ASSERTE (S_OK == hr); <br>if (S_OK != hr) <br>{ <br>// TO DO: Print error message. <br>return E_FAIL; <br>} // if <br> <br>return E_UNEXPECTED; <br>} // if <br> <br> <br>//----------------------------------------------------------------- <br>// Transaction is in its correct state -- indicate preparing <br>// <br>SetState (TX_PREPARING); <br> <br>//----------------------------------------------------------------- <br>// SINGLE PHASE handling. <br>// Check if the MS DTC coordinator specifies single-phase  <br>// optimization.  If so, attempt to commit the transaction and  <br>// respond with S_OK. <br>// <br>// If the commit fails, rollback the transaction and respond with <br>// E_FAIL. <br>// <br>if (TRUE == fSinglePhase) <br>{ <br>hr = CommitTx (); <br>if (S_OK != hr) <br>{ <br>hr = AbortTx(); <br>_ASSERTE (S_OK == hr); <br> <br>hr = m_pEnlist-&gt;PrepareRequestDone (E_FAIL,NULL,NULL); <br>_ASSERTE (S_OK == hr); <br> <br>CleanupTx (); <br>SetState (TX_INVALID_STATE); <br> <br>return E_FAIL; <br>} // if -- Commit unsuccessful <br> <br> <br>CleanupTx (); <br> <br>_ASSERTE(m_pEnlist); <br>hr = m_pEnlist-&gt;PrepareRequestDone (XACT_S_SINGLEPHASE, <br>NULL, <br>NULL); <br>_ASSERTE (S_OK == hr); <br>if (S_OK != hr) <br>{ <br>// Print error message <br>return E_FAIL; <br>} // if <br>return S_OK; <br> <br>} // if -- Single Phase <br> <br> <br>//----------------------------------------------------------------- <br>// NORMAL PREPARE REQUEST: <br>//  <br> <br>hr = PrepareTx (); <br>if (S_OK != hr) <br>{ <br>hr = AbortTx (); <br>_ASSERTE (S_OK == hr); <br> <br>SetState (TX_ABORTED); <br>hr = m_pEnlist-&gt;PrepareRequestDone (E_FAIL, NULL, NULL); <br>_ASSERTE (S_OK == hr); <br> <br>CleanupTx (); <br>return E_FAIL; <br>} // if -- Prepare failed. <br> <br>// we MUST set the state to PREPARED before calling PrepareRequestDone <br>// otherwise you could get the second phase notification before the  <br>// PrepareRequestDone() returns <br> <br>SetState (TX_PREPARED); <br> <br>// Prepare was successful -- return success <br>hr = m_pEnlist-&gt;PrepareRequestDone (S_OK, NULL, NULL); <br>_ASSERTE (S_OK == hr); <br> <br> <br>return S_OK; <br> <br>} // CRmWorkerObj::PrepareRequest() <br> <br> <br> <br>STDMETHODIMP CRmWorkerObj::CommitRequest(DWORD grfRM, <br>   XACTUOW *pNewUOW) <br>{ <br>HRESULThr = S_OK; <br>TXSTATEeTxState; <br>GetState (&amp;eTxState); <br> <br>    if (TX_PREPARED != eTxState) <br>{ <br>_ASSERTE(0); <br>hr = E_UNEXPECTED; <br>} // if <br> <br>SetState (TX_COMMITTING); <br> <br>hr = CommitTx (); <br>_ASSERTE (S_OK == hr); <br>if (S_OK != hr) <br>{ <br>// TO DO: report heuristic damage - print error message <br>hr = E_FAIL; <br>} // if <br> <br>SetState (TX_COMMITTED); <br>CleanupTx (); <br>_ASSERTE(m_pEnlist); <br>hr = m_pEnlist-&gt;CommitRequestDone (S_OK); <br>_ASSERTE (S_OK == hr); <br>// <br>//indicate we are done with the transaction <br>// <br>SetEvent(m_hFinishedTxEvent); <br> <br>return S_OK; <br>} // CRmWorkerObj::CommitRequest() <br> <br> <br>STDMETHODIMP CRmWorkerObj::AbortRequest(BOID *pboidReason, <br>  BOOL fRetaining, <br>  XACTUOW *pNewUOW) <br>{ <br>HRESULThr   = S_OK; <br>TXSTATEeTxState; <br>GetState (&amp;eTxState); <br>    if (TX_PREPARED != eTxState &amp;&amp; <br>TX_ENLISTED != eTxState ) <br>{ <br>// TO DO: print warning message <br>_ASSERTE (0); <br>hr = E_UNEXPECTED; <br>} // if <br> <br>SetState (TX_ABORTING); <br> <br>hr = AbortTx (); <br>_ASSERTE (S_OK == hr); <br>if (S_OK != hr) <br>{ <br>// TO DO: print error message <br>//printf("Abort failure!\n"); <br>hr = E_FAIL; <br>} // if <br> <br> <br>SetState (TX_ABORTED); <br> <br>CleanupTx (); <br> <br>hr = m_pEnlist-&gt;AbortRequestDone (S_OK); <br>_ASSERTE (S_OK == hr); <br>// <br>//indicate we are done with the transaction <br>// <br>SetEvent(m_hFinishedTxEvent); <br>return  S_OK; <br> <br>} // CRmWorkerObj::AbortRequest() <br> <br>// <br>//in this case we ignore this TMDown (which is the ITransactionEnlistmentAsync::TmDown()) <br>//because there is exactly 1 and only 1 Tx per worker object, and we will be notified of <br>//this event in IResourceManagerSink::TmDown().  Normally, you do cleanup for this enlistment <br>//in this method <br>//   <br>STDMETHODIMP CRmWorkerObj::TMDown(void) <br>{ <br>SetState (TX_TMDOWN); <br>SafeRelease(m_punkDTC); <br>SafeRelease(m_pIResMgr); <br>SafeRelease(m_pITx); <br>SafeRelease(m_pLog); <br>SafeRelease(m_pEnlist); <br>SetEvent(m_hFinishedTxEvent); // if anybody is blocked on the event, they will return with the TX_TMDOWN state <br>return S_OK; <br>} // CRmWorkerObj::TMDown <br> <br>// <br>//pLog:a pointer to the log <br>// <br>// <br>#define ENUM_GRANULARITY 10 <br>STDMETHODIMP CRmWorkerObj::Recover(IStorage * pStorage) <br>{ <br> <br>_ASSERTE(pStorage); <br>IEnumSTATSTG * pEnum = NULL; <br>IStream * pStream = NULL; <br>HRESULT hr; <br>hr = pStorage -&gt; EnumElements(NULL, NULL, NULL, &amp;pEnum); <br>_ASSERTE(hr == S_OK); <br>STATSTG statstg[ENUM_GRANULARITY]; <br>ULONG lFetched = 0; <br>ULONG i = 0; <br>RECOVERYRC eRecRc = REC_S_SUCCESS; <br> <br>do <br>{ <br>hr = pEnum -&gt; Next(ENUM_GRANULARITY, statstg, &amp;lFetched); <br>for (i=0; i&lt;lFetched; i++) <br>{ <br> <br>// get the stream <br>pStream = NULL; <br>hr =  pStorage -&gt; OpenStream( <br>statstg[i].pwcsName, //Pointer to string containing name of stream to open <br>NULL, //Reserved <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, //Access mode for the new stream <br>NULL, //Reserved <br>&amp;pStream//Indirect pointer to opened stream object <br>   ); <br> <br>_ASSERTE(hr == S_OK); <br>eRecRc = RecoverTx (pStream); <br>if (REC_S_SUCCESS != eRecRc) <br>{ <br>_ASSERTE(0); <br>RecoverCleanup (); <br> <br>SetStatus (RM_STATUS_RECOVERY_FAILURE); <br>return E_FAIL; <br>} // if <br> <br> <br>pStream -&gt; Release(); <br> <br> <br>} // end for <br> <br>}while (lFetched == ENUM_GRANULARITY); <br> <br>pEnum -&gt; Release(); <br>pStorage -&gt; Release(); <br>RecoverCleanup (); <br>return S_OK; <br> <br>} <br>// <br>//"dust off" the Worker -- make sure that it is ready to go <br>//the next call we expect is an ExportTx() <br>//  <br>STDMETHODIMP CRmWorkerObj::Reset() <br>{ <br> <br> <br>#if 0 <br>SafeRelease(m_pEnlist); <br>SafeRelease(m_pITx); <br>SetState (TX_INITIALIZING); <br>#endif <br>return S_OK; <br> <br> <br>} <br> <br> <br>HRESULT CRmWorkerObj::GetTempFile(TCHAR * pFileName) <br>{ <br>GUID guid; <br>HRESULT hr; <br> <br>hr = CoCreateGuid(&amp;guid); <br>_ASSERTE(hr == S_OK); <br>OLECHAR szGUID[40]; <br>int nRet = StringFromGUID2(guid, szGUID, 39); <br>    _ASSERTE(nRet &gt; 0); <br> <br> <br>lstrcat(pFileName, m_sRecoverDir.m_str); <br>lstrcat(pFileName, szGUID); <br>return S_OK; <br>} <br> <br>// <br>//we write the LOG_RM_ACTION to the log <br>// <br>HRESULT CRmWorkerObj::WriteLog(GUID guidTx, LOG_RM_COMMAND eOp, FILE_OPERATION fOp, BSTR sFromFile, BSTR sToFile) <br>{ <br> <br>CAction action(eOp, fOp, sFromFile, sToFile); <br>return WriteLog(guidTx, &amp;action); <br> <br> <br> <br>} <br> <br>HRESULT CRmWorkerObj::WriteLog(GUID txID, CAction * pAction) <br>{ <br>BYTE * pByte = NULL; <br>ULONG cbSize = 0; <br>HRESULT hr = pAction -&gt; Save(&amp;pByte, &amp;cbSize); <br>if (FAILED(hr)) <br>return hr; <br> <br> <br>hr = m_pLog -&gt; WriteLog(txID, pAction -&gt; m_eRmCommand, pByte, cbSize); <br>delete [] pByte; <br>return hr; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
