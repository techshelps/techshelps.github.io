<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SELECTEVENTSDLG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1305"></a>SELECTEVENTSDLG.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: SelectEventsDlg.cpp <br>* <br>* Description:  Dialog to select which events to sink to.  Selecting a sink <br>causes the sink to be established. <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>// SelectEventsDlg.cpp : Implementation of CSelectEventsDlg <br>#include "stdafx.h" <br>#include "mtsspyctl.h" <br>#include "mtsevents.h" <br>#include "MtsAudit.h" <br>#include "MTSSpy.h" <br>#include "MtsSink.h" <br>#include "TxSink.h" <br>#include "objsink.h" <br>#include "threadsink.h" <br>#include "instancesink.h" <br>#include "resourcesink.h" <br>#include "packagesink.h" <br>#include "usersink.h" <br>#include "PackageInfo.h" <br>#include "SelectEventsDlg.h" <br>#include &lt;algorithm&gt; <br>#include "methodsink.h" <br>#include "MtsGrp.h" <br>#include "MtsGrp_i.c" <br>#include "eventcpts.h" <br>#include "securitysink.h" <br> <br> <br>typedef struct _EVENT_SINK_INFO <br>{ <br>TCHAR * sDisplayName; <br>EventEnum eEvent; <br>}EVENT_SINK_INFO; <br> <br>EVENT_SINK_INFO EventInfo[] ={ <br>_T("Package"),Package,  <br>_T("Thread"),Thread,  <br>_T("Instance"),Instance, <br>_T("Transaction"),Transaction, <br>_T("Method"),Method, <br>_T("Object"),Object, <br>_T("Resource"),Resource, <br>    _T("UserDefined"),User, <br>_T("Security"),Security <br>}; <br> <br>CSelectEventsDlg::CSelectEventsDlg() <br>{ <br> <br>} <br> <br>CSelectEventsDlg::~CSelectEventsDlg() <br>{ <br>} <br> <br>LRESULT CSelectEventsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>ResetEventList(); <br>GetRunningAsps(); <br>return 1;  // Let the system set the focus <br>} <br> <br>LRESULT CSelectEventsDlg::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>EndDialog(wID); <br>return 0; <br>} <br> <br>LRESULT CSelectEventsDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>EndDialog(wID); <br>return 0; <br>} <br> <br>LRESULT CSelectEventsDlg::OnDestroyDlg(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br> <br>bHandled = FALSE; <br>return 0; <br>} <br> <br>// <br>// <br>//get the IMtsEvents interface, get the Package Name <br>//and add it to the combo box <br>// <br>BOOL CSelectEventsDlg::GetRunningAsps() <br>{ <br>HRESULT hr = E_FAIL; <br>IMtsGrp * pMtsGrp = NULL; <br>hr = CoCreateInstance (CLSID_MtsGrp, NULL, CLSCTX_ALL, IID_IMtsGrp, (void **)&amp;pMtsGrp); <br>if (!pMtsGrp) <br>{ <br>_ASSERTE(0); <br>return FALSE; <br>} <br> <br>long lPackages; <br>pMtsGrp -&gt; get_Count(&amp;lPackages); <br>IUnknown * pUnk = NULL; <br>IMtsEvents * pEvents = NULL; <br>USES_CONVERSION; <br>int nIndex; <br>for (int i=0; i&lt;lPackages; i++) <br>{ <br> <br>pMtsGrp -&gt; Item(i, &amp;pUnk); <br>pEvents = NULL; <br>pUnk -&gt; QueryInterface(IID_IMtsEvents, (void **)&amp;pEvents); <br>_ASSERTE(pEvents); <br>CComBSTR sName; <br>CPackageInfo * pInfo = NULL; <br>pEvents -&gt; get_PackageName(&amp;sName.m_str); <br>IConnectionPointContainer * pContainer=NULL; <br>hr = pEvents -&gt; QueryInterface(IID_IConnectionPointContainer, (void **)&amp;pContainer); <br>_ASSERTE(hr == S_OK); <br>if (SUCCEEDED(hr)) <br>{ <br>LPSTR p = W2A(sName.m_str); <br>pInfo = (*m_map)[p]; <br>if (!pInfo) <br>{ <br>_ASSERTE(m_pSpyObj); <br>pInfo = new CPackageInfo(pContainer, sName.m_str, m_pSpyObj); // this will register for the package events <br>_ASSERTE(pInfo); <br>(*m_map)[p] = pInfo; <br>} <br>nIndex = SendDlgItemMessage(IDC_PACKAGES, CB_ADDSTRING, 0, (LPARAM)sName.m_str); <br>if (nIndex != CB_ERR) <br>{ <br>SendDlgItemMessage(IDC_PACKAGES, CB_SETITEMDATA, nIndex, (DWORD)pInfo); <br>} <br>else <br>_ASSERTE(0); <br>} <br> <br>SafeRelease(pEvents); <br>SafeRelease(pUnk); <br>SafeRelease(pContainer); <br>} <br> <br>SafeRelease(pMtsGrp); <br> <br>SendDlgItemMessage(IDC_PACKAGES, CB_SETCURSEL, 0); <br>int bHandled = TRUE; <br>OnSelectPackages(CBN_SELCHANGE,0,NULL, bHandled); <br>return TRUE; <br> <br>} <br>// <br>//the user selects a package from the drop down list box. <br>// <br>LRESULT CSelectEventsDlg::OnSelectPackages(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>if (wNotifyCode == CBN_SELCHANGE) <br>{ <br> <br>// get the package name <br>int nSel = SendDlgItemMessage(IDC_PACKAGES, CB_GETCURSEL, 0, 0L);    <br>if (nSel != CB_ERR) <br>{ <br> <br>// we store the CPackageInfo structure in the item data... <br>CPackageInfo * pInfo = NULL; <br>pInfo = (CPackageInfo *)SendDlgItemMessage(IDC_PACKAGES, CB_GETITEMDATA, nSel); <br>_ASSERTE(pInfo); <br> <br>// update the list of sinks <br>ResetEventList(); <br> <br>// interate through the list and make sure that the list boxes reflects what's going on <br>SinkList::iterator item; <br>EventEnum nType; <br>IMtsSink * pSink; <br>int nIndex; <br>DWORD dwItemData; <br>TCHAR sz[32]; <br>CComBSTR sDisplayName; <br>for (item = pInfo -&gt; List() -&gt; begin(); item != pInfo -&gt; List() -&gt; end(); item++) <br>{ <br> <br>pSink = *item; <br>if (pSink) <br>{ <br>pSink -&gt; GetSinkType(&amp;nType); <br>GetDisplayName(nType, &amp;sDisplayName); <br>nIndex = SendDlgItemMessage(IDC_EVENTS, LB_FINDSTRING, 0,  (LPARAM)sDisplayName.m_str); <br>if (nIndex != LB_ERR) <br>{ <br>// move it to the other list <br>memset(&amp;sz[0], NULL, 32*sizeof(TCHAR)); <br>SendDlgItemMessage(IDC_EVENTS, LB_GETTEXT, nIndex, (LPARAM)sz); <br>dwItemData = SendDlgItemMessage(IDC_EVENTS, LB_GETITEMDATA, nIndex); <br>SendDlgItemMessage(IDC_EVENTS, LB_DELETESTRING, nIndex); <br>nIndex = SendDlgItemMessage(IDC_SINKS, LB_ADDSTRING, 0, (LPARAM)sz); <br>SendDlgItemMessage(IDC_SINKS, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); <br> <br>} <br>else <br>_ASSERTE(0); <br>} <br> <br>} <br> <br> <br>// we do special processing for the package event, since we are always sinked to it <br> <br> if (pInfo -&gt; GetShowPackageEvent()) <br> { <br>nIndex = SendDlgItemMessage(IDC_EVENTS, LB_FINDSTRING, 0,  (LPARAM)_T("Package")); <br>// move it to the other list <br>memset(&amp;sz[0], NULL, 32*sizeof(TCHAR)); <br>SendDlgItemMessage(IDC_EVENTS, LB_GETTEXT, nIndex, (LPARAM)sz); <br>dwItemData = SendDlgItemMessage(IDC_EVENTS, LB_GETITEMDATA, nIndex); <br>SendDlgItemMessage(IDC_EVENTS, LB_DELETESTRING, nIndex); <br>nIndex = SendDlgItemMessage(IDC_SINKS, LB_ADDSTRING, 0, (LPARAM)sz); <br>SendDlgItemMessage(IDC_SINKS, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); <br> } <br> <br>// if the count on the left hand side == 0, disable the add sink button <br>::EnableWindow(GetDlgItem(IDC_ADD_SINK), SendDlgItemMessage(IDC_EVENTS, LB_GETCOUNT)); <br>// if there are no sinks, don't enable the remove sink button <br>::EnableWindow(GetDlgItem(IDC_REMOVE_FROM_SINK), SendDlgItemMessage(IDC_SINKS, LB_GETCOUNT)); <br> <br> <br>} <br>else <br>{ <br> <br>::EnableWindow(GetDlgItem(IDC_ADD_SINK), FALSE); <br>::EnableWindow(GetDlgItem(IDC_REMOVE_FROM_SINK), FALSE); <br>} <br> <br>} <br> <br>return 0; <br>} <br> <br>// <br>//the user is adding one or more sinks for the selected (running) package <br>// <br>LRESULT CSelectEventsDlg::OnAddSink(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>if (wNotifyCode == BN_CLICKED) <br>{ <br>//we are a multi-select list box... <br>int nCount = SendDlgItemMessage(IDC_EVENTS, LB_GETSELCOUNT); <br>if (nCount != LB_ERR &amp;&amp; nCount) <br>{ <br> <br>int nSel = SendDlgItemMessage(IDC_PACKAGES, CB_GETCURSEL, 0, 0L);    <br>if (nSel == CB_ERR) <br>{ <br>_ASSERTE(0); <br>return 0; <br>} <br> <br>// get the information for the current package <br>CPackageInfo * pInfo = NULL; <br>pInfo = (CPackageInfo *)SendDlgItemMessage(IDC_PACKAGES, CB_GETITEMDATA, nSel); <br>_ASSERTE(pInfo); <br> <br>int * nSelItems = new int[nCount]; <br>SendDlgItemMessage(IDC_EVENTS,LB_GETSELITEMS, nCount, (LPARAM)nSelItems); <br>int i; <br>WCHAR sz[16]; <br>DWORD dwItemData; <br>int nItem; <br>MapStringToPackageInfo::iterator iter; <br>HRESULT hr; <br>USES_CONVERSION; <br>IMtsSink * pMtsSink = NULL; <br>for (i=0;i&lt;nCount;i++) <br>{ <br> <br>// move string and item data to the other list box <br>memset(&amp;sz[0], NULL, 16*sizeof(TCHAR)); <br>SendDlgItemMessage(IDC_EVENTS, LB_GETTEXT, nSelItems[i], (LPARAM)sz); <br>dwItemData = SendDlgItemMessage(IDC_EVENTS, LB_GETITEMDATA, nSelItems[i]); <br>nItem = SendDlgItemMessage(IDC_SINKS, LB_ADDSTRING, 0, (LPARAM)sz); <br>SendDlgItemMessage(IDC_SINKS, LB_SETITEMDATA, nItem, (LPARAM)dwItemData); <br> <br>// find out what type of sink has been requested, and create the appropriate object <br>EventEnum  event = (EventEnum) dwItemData; <br>switch (event) <br>{ <br>case Security: <br>{ <br> <br>CComObject &lt;CSecuritySink&gt; * pSink = NULL; <br>hr = CComObject&lt;CSecuritySink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br> <br>} <br>break; <br>case Transaction: <br>{ <br>CComObject &lt;CTxSink&gt; * pSink; <br>hr = CComObject&lt;CTxSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>break; <br>} <br>case Resource: <br>{ <br>CComObject &lt;CResourceSink&gt; * pSink; <br>hr = CComObject&lt;CResourceSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>} <br>break; <br>case Object: <br>{ <br>CComObject &lt;CObjSink&gt; * pSink; <br>hr = CComObject&lt;CObjSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>break; <br>} <br>break; <br>case Thread: <br>{ <br>CComObject &lt;CThreadSink&gt; * pSink; <br>hr = CComObject&lt;CThreadSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>} <br>break; <br>case Instance: <br>{ <br>CComObject &lt;CInstanceSink&gt; * pSink; <br>hr = CComObject&lt;CInstanceSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>break; <br>} <br>break; <br>// <br>// package events are "special" -- we've already sinked to them <br>// <br>case Package: <br>{ <br>pInfo -&gt; SetShowPackageEvent(TRUE); <br>break; <br>} <br>case Method: <br>{ <br>CComObject &lt;CMethodSink&gt; * pSink; <br>hr = CComObject&lt;CMethodSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>} <br>break; <br>case User: <br>{ <br>CComObject &lt;CUserSink&gt; * pSink; <br>hr = CComObject&lt;CUserSink&gt;::CreateInstance(&amp;pSink); <br>pSink -&gt; SetSpyObj(m_pSpyObj); <br>_ASSERTE(pSink); <br>pSink -&gt; QueryInterface(IID_IMtsSink, (void **)&amp;pMtsSink); <br>_ASSERTE(pSink); <br>} <br>break; <br>default: <br>pMtsSink = NULL; <br>ATLTRACE(L"Object type not implemented yet\n"); <br>_ASSERTE(0); <br>break; <br>} <br>if (pMtsSink) // we've successfully created the sink <br>{ <br> <br>// initialize it <br>pMtsSink -&gt; Init(pInfo -&gt; CPContainer(), pInfo -&gt; PackageName()); <br>pMtsSink -&gt; Advise(); <br>_ASSERTE(pInfo); <br>pInfo -&gt; List() -&gt; insert (pInfo -&gt; List() -&gt;end(), pMtsSink); <br>pMtsSink = NULL; <br>} <br> <br> <br>} <br>// remove from listbox in reverse order <br>for (i=nCount-1;i&gt;=0;i--) <br>{ <br>SendDlgItemMessage(IDC_EVENTS, LB_DELETESTRING, nSelItems[i]); <br>} <br> <br> <br>delete [] nSelItems; <br> <br> <br>// if the count on the left hand side == 0, disable the add sink button <br>::EnableWindow(GetDlgItem(IDC_ADD_SINK), SendDlgItemMessage(IDC_EVENTS, LB_GETCOUNT)); <br>// if there are no sinks, don't enable the remove sink button <br>::EnableWindow(GetDlgItem(IDC_REMOVE_FROM_SINK), SendDlgItemMessage(IDC_SINKS, LB_GETCOUNT)); <br> <br>} <br> <br>} <br> <br>return 0; <br> <br>} <br>// <br>//remove one or more sinks <br>// <br>LRESULT CSelectEventsDlg::OnRemoveSink(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>if (wNotifyCode == BN_CLICKED) <br>{ <br> <br>int nCount = SendDlgItemMessage(IDC_SINKS, LB_GETSELCOUNT); <br>if (nCount != LB_ERR &amp;&amp; nCount) <br>{ <br> <br>// get package name <br>int nSel = SendDlgItemMessage(IDC_PACKAGES, CB_GETCURSEL, 0, 0L);    <br>if (nSel == CB_ERR) <br>{ <br>_ASSERTE(0); <br>return 0; <br>} <br> <br>CPackageInfo * pInfo = NULL; <br>pInfo = (CPackageInfo *)SendDlgItemMessage(IDC_PACKAGES, CB_GETITEMDATA, nSel); <br>_ASSERTE(pInfo); <br> <br>MapStringToPackageInfo::iterator iter; <br>int * nSelItems = new int[nCount]; <br> SendDlgItemMessage(IDC_SINKS,LB_GETSELITEMS, nCount, (LPARAM)nSelItems); <br>int i; <br>WCHAR sz[16]; <br>DWORD dwItemData; <br>int nItem; <br>SinkList::iterator iterSink; <br>IMtsSink * pSink; <br>EventEnum eSinkType; <br>for (i=0;i&lt;nCount;i++) <br>{ <br> <br>memset(&amp;sz[0], NULL, 16*sizeof(TCHAR)); <br>SendDlgItemMessage(IDC_SINKS, LB_GETTEXT, nSelItems[i], (LPARAM)sz); <br>dwItemData = SendDlgItemMessage(IDC_SINKS, LB_GETITEMDATA, nSelItems[i]); <br>if (dwItemData == Package) // package sink <br>pInfo -&gt; SetShowPackageEvent(FALSE); <br>nItem  = SendDlgItemMessage(IDC_EVENTS, LB_ADDSTRING, 0, (LPARAM)sz); <br>SendDlgItemMessage(IDC_EVENTS, LB_SETITEMDATA, nItem, (LPARAM)dwItemData); <br>//iterate through the list looking for matching item data and sink id <br>for (iterSink=pInfo -&gt; List() -&gt; begin(); iterSink != pInfo -&gt; List() -&gt; end(); ++iterSink) <br>{ <br>pSink = *iterSink; <br>if (pSink) <br>{ <br>pSink -&gt; GetSinkType(&amp;eSinkType); <br>if (eSinkType == (EventEnum)dwItemData) <br>{ <br>pSink -&gt; DAdvise(); <br>pSink -&gt; Release(); <br>pInfo -&gt; List() -&gt; erase(iterSink++); <br>break; <br> <br>} <br> <br>} <br> <br>} <br> <br>} <br>// remove strings from list in reverse order <br>for (i=nCount-1;i &gt;= 0;i--) <br>{ <br>SendDlgItemMessage(IDC_SINKS, LB_DELETESTRING, nSelItems[i]); <br>} <br> <br> <br>delete [] nSelItems; <br> <br> <br> <br>// if the count on the left hand side == 0, disable the add sink button <br>::EnableWindow(GetDlgItem(IDC_ADD_SINK), SendDlgItemMessage(IDC_EVENTS, LB_GETCOUNT)); <br>// if there are no sinks, don't enable the remove sink button <br>::EnableWindow(GetDlgItem(IDC_REMOVE_FROM_SINK), SendDlgItemMessage(IDC_SINKS, LB_GETCOUNT)); <br> <br>} <br> <br>} <br> <br>return 0; <br>} <br> <br>void CSelectEventsDlg::ResetEventList() <br>{ <br>SendDlgItemMessage(IDC_EVENTS, LB_RESETCONTENT); <br>SendDlgItemMessage(IDC_SINKS, LB_RESETCONTENT); <br> <br>int i; <br>// fill the Possible Events list <br>int nIndex; <br>for (i=0; i&lt;sizeof(EventInfo)/sizeof(EventInfo[0]); i++) <br>{ <br>nIndex = SendDlgItemMessage(IDC_EVENTS, LB_ADDSTRING, 0,  (LPARAM)EventInfo[i].sDisplayName); <br>SendDlgItemMessage(IDC_EVENTS, LB_SETITEMDATA, nIndex,  (LPARAM)EventInfo[i].eEvent); <br>} <br>} <br> <br>// <br>//do the right thing when the user double clicks on the list box <br>// <br>LRESULT CSelectEventsDlg::EventListHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>if (wNotifyCode == LBN_DBLCLK) <br>{ <br>HWND hWndAddSinkButton = GetDlgItem(IDC_ADD_SINK); <br>if (::IsWindowEnabled( hWndAddSinkButton )) <br>OnAddSink(BN_CLICKED, IDC_ADD_SINK, hWndAddSinkButton, bHandled); <br> <br>} <br> <br>bHandled = FALSE; <br>return 0; <br>} <br>// <br>//do the right thing when the user double clicks on the list box <br>// <br>LRESULT CSelectEventsDlg::SinkListHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>if (wNotifyCode == LBN_DBLCLK) <br>{ <br>HWND hWndRemoveSinkButton = GetDlgItem(IDC_REMOVE_FROM_SINK); <br>if (::IsWindowEnabled( hWndRemoveSinkButton )) <br>OnRemoveSink(BN_CLICKED, IDC_REMOVE_FROM_SINK, hWndRemoveSinkButton, bHandled); <br> <br>} <br> <br>bHandled = FALSE; <br>return 0; <br>} <br>//  <br>//given an EventEnum, get the display Name <br>HRESULT CSelectEventsDlg::GetDisplayName(EventEnum e, BSTR * sDisplayName) <br>{ <br>int i; <br>for (i = 0; i&lt; sizeof(EventInfo)/sizeof(EventInfo[0]); i++) <br>{ <br> <br>if (EventInfo[i].eEvent == e) <br>{ <br>*sDisplayName = ::SysAllocString(EventInfo[i].sDisplayName); <br>return S_OK; <br>} <br>} <br>return E_FAIL; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
