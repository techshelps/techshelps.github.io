<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SPYCON.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1284"></a>SPYCON.CPP</h2>
<pre><code>// SpyCon.cpp : Implementation of CSpyCon <br>#include "stdafx.h" <br>#include "MtsSpy.h" <br>#include "MtsSpyCtl.h" <br>#include "SpyCon.h" <br> <br>static LPTSTR gsSubKey = _T("Software\\Microsoft\\Transaction Server\\MtsSpy"); <br>///////////////////////////////////////////////////////////////////////////// <br>// CSpyCon <br> <br> <br>STDMETHODIMP CSpyCon::Run() <br>{ <br>RECT rcPos = { CW_USEDEFAULT, 0, 0, 0 }; <br>HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_MENU1)); <br>Create(GetDesktopWindow(), rcPos, _T("MTS Spy"), WS_VISIBLE | WS_OVERLAPPEDWINDOW, 0, (UINT)hMenu); <br>// <br>//Set the right icon <br>// <br>HICON hIcon = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_MAIN)); <br>if (hIcon) <br>SetIcon(hIcon, TRUE); <br> <br>// create the spy control <br>CoCreateInstance(CLSID_MtsSpy, NULL, CLSCTX_INPROC, IID_IOleObject, (void**)&amp;m_pOleObject); <br>if (!m_pOleObject) <br>{ <br>MessageBox(_T("CoCreateInstance failed")); <br>return 0; <br>} <br>m_pOleObject-&gt;SetClientSite(this); <br>m_pOleObject -&gt; QueryInterface(IID_IMtsSpy, (void **)&amp;m_pSpy); <br>_ASSERTE(m_pSpy); <br> <br>// get our window state from the registry <br>HKEY hKey = NULL; <br>DWORD dwDisp; <br>LONG lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE, gsSubKey, NULL, NULL, REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,  NULL,  &amp;hKey, &amp;dwDisp); <br>if (hKey) <br>{ <br> <br>DWORD dwType = REG_DWORD; <br>DWORD dwSize = sizeof(m_wp.rcNormalPosition.left); <br>lRes = RegQueryValueEx(hKey, _T("Left"), NULL, &amp;dwType, (BYTE *)&amp;m_wp.rcNormalPosition.left, &amp;dwSize); <br>lRes = RegQueryValueEx(hKey, _T("Top"), NULL, &amp;dwType, (BYTE *)&amp;m_wp.rcNormalPosition.top, &amp;dwSize); <br>lRes = RegQueryValueEx(hKey, _T("Right"), NULL, &amp;dwType, (BYTE *)&amp;m_wp.rcNormalPosition.right, &amp;dwSize); <br>lRes = RegQueryValueEx(hKey, _T("Bottom"), NULL, &amp;dwType, (BYTE *)&amp;m_wp.rcNormalPosition.bottom, &amp;dwSize); <br>lRes = RegQueryValueEx(hKey, _T("ShowWindow"), NULL, &amp;dwType, (BYTE *)&amp;m_wp.showCmd, &amp;dwSize); <br>//always on top option <br>lRes = RegQueryValueEx(hKey, _T("AlwaysOnTop"), NULL, &amp;dwType, (BYTE *)&amp;m_bTopmost, &amp;dwSize); <br>m_bTopmost = 1 - m_bTopmost; <br>BOOL bHandled; <br>OnAlwaysOnTop(0,0,0,bHandled); <br> <br>// save on exit <br>lRes = RegQueryValueEx(hKey, _T("SaveOnExit"), NULL, &amp;dwType, (BYTE *)&amp;m_bSaveOnExit, &amp;dwSize); <br> <br>// get the stream from the registry <br>dwType = REG_BINARY; <br>lRes = RegQueryValueEx(hKey, _T("ControlProperties"), NULL, &amp;dwType, NULL, &amp;dwSize); <br>if (lRes == ERROR_SUCCESS) <br>{ <br>HGLOBAL hGlobal = GlobalAlloc(GPTR, dwSize); <br>BYTE * pByte = (BYTE *)GlobalLock(hGlobal); <br>lRes = RegQueryValueEx(hKey, _T("ControlProperties"), NULL, &amp;dwType, (BYTE *)pByte, &amp;dwSize); <br>GlobalUnlock(hGlobal); <br>IStream * pStream; <br>CreateStreamOnHGlobal(hGlobal, TRUE, &amp;pStream); <br> <br>CComQIPtr&lt;IPersistStreamInit, &amp;IID_IPersistStreamInit&gt; pPersist(m_pSpy); <br>_ASSERTE(pPersist.p); <br> <br>if (pPersist != NULL) <br>{ <br>pPersist -&gt; Load(pStream); <br> <br>} <br>pStream -&gt; Release(); <br>} <br>} <br> <br> <br>if (!( ( m_wp.rcNormalPosition.right - m_wp.rcNormalPosition.left &lt; 10) &amp;&amp; (m_wp.rcNormalPosition.bottom - m_wp.rcNormalPosition.top &lt; 10))) <br>SetWindowPlacement(&amp;m_wp); <br>else <br>ShowWindow(SW_SHOWNORMAL); <br> <br>GetClientRect(&amp;rcPos); <br>MSG msg; <br>m_pOleObject-&gt;DoVerb(OLEIVERB_INPLACEACTIVATE, &amp;msg, this, 0, m_hWnd, &amp;rcPos); <br>return S_OK; <br>} <br> <br>// <br>//show the select packages dialog <br>// <br>LRESULT CSpyCon::OnSelectPackages(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>_ASSERTE(m_pSpy); <br>m_pSpy -&gt; SelectPackages(); <br>return 0; <br>} <br>// <br>//the user clicks on the system menu <br>// <br>LRESULT CSpyCon::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br> <br>bHandled = FALSE; // always do default processing <br> <br>if (wParam == SC_CLOSE) <br>OnExit(NULL, NULL, NULL, bHandled); <br> <br> <br>return 0; <br>} <br>// <br>//sets a glog to log to file <br>//if the user hasn't chosen a log file, show the common dialog to allow them to select one <br>// <br>LRESULT CSpyCon::OnLogToFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>_ASSERTE(m_pSpy); <br>BOOL bVal; <br>m_pSpy -&gt; get_LogToFile(&amp;bVal); <br>bVal = 1 - bVal; <br>m_pSpy -&gt; put_LogToFile(bVal); <br>return 0; <br>} <br>// <br>//User wants to choose a log file -- show the common dialog <br>// <br>LRESULT CSpyCon::OnChooseLogFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>CComBSTR sFileName; <br>BOOL bCanceled; <br>m_pSpy -&gt; ChooseLogFile(&amp;sFileName, &amp;bCanceled); <br>return 0; <br> <br>} <br>// <br>//toggle the save on exit flag <br>// <br>LRESULT CSpyCon::OnToggleSaveOnExit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br> <br>{ <br>m_bSaveOnExit = 1 - m_bSaveOnExit; <br>// <br>//the UI semantics are odd here...if you have this selected, and deselect it <br>//  the fact you deselected it won't be saved (you have to click on "Save Now" <br>//so I'm going to always write what you choose to the registry if you deselect it <br> <br>if (FALSE == m_bSaveOnExit) <br>{ <br>HKEY hKey = NULL; <br>DWORD dwDisp; <br>LONG lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE, gsSubKey, NULL, NULL, REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,  NULL,  &amp;hKey, &amp;dwDisp); <br>if (hKey) <br>{ <br>lRes = RegSetValueEx(hKey, _T("SaveOnExit"), NULL, REG_DWORD, (BYTE *)&amp;m_bSaveOnExit, sizeof(BOOL)); <br>RegCloseKey(hKey); <br>} <br>} <br> <br>return 0; <br> <br>} <br>// <br>//toggle the show on screen flag <br>// <br>LRESULT CSpyCon::OnToggleShowOnScreen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>_ASSERTE(m_pSpy); <br>BOOL bVal; <br>m_pSpy -&gt; get_ShowOnScreen(&amp;bVal); <br>bVal = 1 - bVal; <br>m_pSpy -&gt; put_ShowOnScreen(bVal); <br>return 0; <br> <br>} <br>// <br>//update the UI in menus <br>// <br>LRESULT CSpyCon::OnInitMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br> <br>HMENU hMenu = (HMENU)wParam; <br>CComBSTR temp = "&amp;Log to File "; <br>CComBSTR sFileName; <br>m_pSpy -&gt; get_LogFile(&amp;sFileName); <br>if (sFileName.Length() &gt; 5) <br>temp += sFileName; <br>else <br>temp = "&amp;Log To file..."; <br> <br>USES_CONVERSION; <br>ModifyMenu(hMenu, ID_LOG, MF_BYCOMMAND|MF_STRING, ID_LOG, OLE2T(temp)); <br>BOOL bVal; <br>m_pSpy -&gt; get_LogToFile(&amp;bVal); <br>CheckMenuItem(hMenu, ID_LOG,   bVal ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>m_pSpy -&gt; get_ShowGridLines(&amp;bVal); <br>CheckMenuItem(hMenu, ID_OPTIONS_GRID_LINES,  bVal ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>m_pSpy -&gt; get_ShowOnScreen(&amp;bVal); <br>CheckMenuItem(hMenu, ID_SHOW_ON_SCREEN,  bVal ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>CheckMenuItem(hMenu, IDM_ON_TOP,  m_bTopmost ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>CheckMenuItem(hMenu, ID_SAVE_ON_EXIT,  m_bSaveOnExit ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br> <br>return 0; <br>} <br> <br>// <br>//show/hide gridlines in the list <br>// <br>//NOTE:  This will only work if the user has installed IE 3.0 or greater <br>// <br>LRESULT CSpyCon::OnToggleGridLines(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>_ASSERTE(m_pSpy); <br>BOOL bVal; <br>m_pSpy -&gt; get_ShowGridLines(&amp;bVal); <br>bVal = 1 - bVal; <br>m_pSpy -&gt; put_ShowGridLines(bVal); <br>return 0; <br>} <br>// <br>//Toggle the Always on top option <br>// <br>LRESULT CSpyCon::OnAlwaysOnTop(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>m_bTopmost = 1 - m_bTopmost; <br>if (m_bTopmost) <br>SetWindowPos(HWND_TOPMOST, 0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); <br>else <br>SetWindowPos(HWND_NOTOPMOST, 0,0,0,0,SWP_NOMOVE|SWP_NOSIZE); <br>return 0; <br>} <br>// <br>//show the standard Shell About box <br>// <br>LRESULT CSpyCon::OnAbout(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>m_pSpy -&gt; About(); <br>return 0; <br>} <br>// <br>//pick the font to use in the list <br>// <br>LRESULT CSpyCon::OnChooseFont(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>m_pSpy -&gt; ChooseFont(); <br>return 0; <br>} <br>// <br>//called on a WM_CLOSE &amp; WM_SYSCOMMAND (SC_CLOSE) message.  If appropriate, save settings <br>//and then destroy the window <br>// <br>LRESULT CSpyCon::OnExit(WORD /*wNotifyCode*/, WORD /* wID */, HWND /*hWndCtl*/, BOOL&amp; /*bHandled*/) <br>{ <br>if (m_bSaveOnExit) <br>SaveSettings(); <br>m_pOleObject-&gt;Close(OLECLOSE_NOSAVE); <br>SafeRelease(m_pOleObject); <br>SafeRelease(m_pSpy); <br>DestroyWindow(); <br>return 0; <br>} <br> <br>// <br>//save current settings to the registyr <br>// <br>LRESULT CSpyCon::OnSaveNow(WORD /*wNotifyCode*/, WORD /* wID */, HWND /*hWndCtl*/, BOOL&amp; /*bHandled*/) <br>{ <br>SaveSettings(); <br>return 0; <br>} <br> <br> <br>// <br>//clear the list box <br>// <br>LRESULT CSpyCon::OnClear(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>m_pSpy -&gt; ClearAllEvents(); <br>return 0; <br>} <br> <br> <br>// <br>//save the items in the list box to the log file <br>// <br>LRESULT CSpyCon::OnSave(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>m_pSpy -&gt; SaveToFile(); <br>return 0; <br> <br>} <br>// <br>//saves settings.  asks the control fro a stream to save its state <br>// <br>HRESULT CSpyCon::SaveSettings() <br>{ <br>_ASSERTE(m_pSpy); <br>if(!m_pSpy) <br>return E_UNEXPECTED; <br>HKEY hKey = NULL; <br>DWORD dwDisp; <br>LONG lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE, gsSubKey, NULL, NULL, REG_OPTION_NON_VOLATILE,KEY_ALL_ACCESS,  NULL,  &amp;hKey, &amp;dwDisp); <br>if (hKey) <br>{ <br>lRes = RegSetValueEx(hKey, _T("Left"), NULL, REG_DWORD, (BYTE *)&amp;m_wp.rcNormalPosition.left, sizeof(m_wp.rcNormalPosition.left)); <br>lRes = RegSetValueEx(hKey, _T("Top"), NULL, REG_DWORD, (BYTE *)&amp;m_wp.rcNormalPosition.top, sizeof(m_wp.rcNormalPosition.left)); <br>lRes = RegSetValueEx(hKey, _T("Right"), NULL, REG_DWORD, (BYTE *)&amp;m_wp.rcNormalPosition.right, sizeof(m_wp.rcNormalPosition.left)); <br>lRes = RegSetValueEx(hKey, _T("Bottom"), NULL, REG_DWORD, (BYTE *)&amp;m_wp.rcNormalPosition.bottom, sizeof(m_wp.rcNormalPosition.left)); <br>lRes = RegSetValueEx(hKey, _T("ShowWindow"), NULL, REG_DWORD, (BYTE *)&amp;m_wp.showCmd, sizeof(BOOL)); <br>lRes = RegSetValueEx(hKey, _T("AlwaysOnTop"), NULL, REG_DWORD, (BYTE *)&amp;m_bTopmost, sizeof(BOOL)); <br>lRes = RegSetValueEx(hKey, _T("SaveOnExit"), NULL, REG_DWORD, (BYTE *)&amp;m_bSaveOnExit, sizeof(BOOL)); <br> <br> <br>CComQIPtr&lt;IPersistStreamInit, &amp;IID_IPersistStreamInit&gt; pPersist(m_pSpy); <br>_ASSERTE(pPersist.p); <br>IStream * pStream; <br>CreateStreamOnHGlobal(NULL, TRUE, &amp;pStream); <br>if (pPersist != NULL) <br>{ <br>pPersist -&gt; Save(pStream, TRUE); <br>HGLOBAL hGlobal; <br>GetHGlobalFromStream(pStream, &amp;hGlobal); <br>BYTE * pStByte = (BYTE *)GlobalLock(hGlobal); <br>DWORD dwSize = GlobalSize(hGlobal); <br>lRes = RegSetValueEx(hKey, _T("ControlProperties"), NULL, REG_BINARY, (BYTE *)pStByte, dwSize); <br>GlobalUnlock(hGlobal); <br> <br>} <br>pStream -&gt; Release(); <br>RegCloseKey(hKey); <br>} <br>return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
