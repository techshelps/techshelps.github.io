<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILERMCLIENTDLG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1251"></a>FILERMCLIENTDLG.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: FileRmClientDlg.cpp <br>* <br>* Description:  Main UI for test app <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br> <br>#include "stdafx.h" <br>#include "FileRmClient.h" <br>#include "FileRmClientDlg.h" <br>#define IID_DEFINED <br>#include "cpyimage.h" <br>#include "cpyimage_i.c" <br>#ifdef _DEBUG <br>#define new DEBUG_NEW <br>#undef THIS_FILE <br>static char THIS_FILE[] = __FILE__; <br>#endif <br> <br>#include "afxpriv.h" <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CAboutDlg dialog used for App About <br> <br>class CAboutDlg : public CDialog <br>{ <br>public: <br>CAboutDlg(); <br> <br>// Dialog Data <br>//{{AFX_DATA(CAboutDlg) <br>enum { IDD = IDD_ABOUTBOX }; <br>//}}AFX_DATA <br> <br>// ClassWizard generated virtual function overrides <br>//{{AFX_VIRTUAL(CAboutDlg) <br>protected: <br>virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support <br>//}}AFX_VIRTUAL <br> <br>// Implementation <br>protected: <br>//{{AFX_MSG(CAboutDlg) <br>//}}AFX_MSG <br>DECLARE_MESSAGE_MAP() <br>}; <br> <br>CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD) <br>{ <br>//{{AFX_DATA_INIT(CAboutDlg) <br>//}}AFX_DATA_INIT <br>} <br> <br>void CAboutDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CAboutDlg) <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CAboutDlg, CDialog) <br>//{{AFX_MSG_MAP(CAboutDlg) <br>// No message handlers <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFileRmClientDlg dialog <br> <br>CFileRmClientDlg::CFileRmClientDlg(CWnd* pParent /*=NULL*/) <br>: CDialog(CFileRmClientDlg::IDD, pParent) <br>{ <br>//{{AFX_DATA_INIT(CFileRmClientDlg) <br>m_sSource = _T("c:\\test"); <br>m_sImgFileName = _T(""); <br>m_sMainColor = _T("&lt;main color&gt;"); <br>m_sTheme = _T("&lt;theme&gt;"); <br>m_sDescription = _T("&lt;description&gt;"); <br>m_sMsg = _T(""); <br>m_sDest = _T("c:\\images"); <br>//}}AFX_DATA_INIT <br>// Note that LoadIcon does not require a subsequent DestroyIcon in Win32 <br>m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME); <br>; <br>} <br> <br>void CFileRmClientDlg::DoDataExchange(CDataExchange* pDX) <br>{ <br>CDialog::DoDataExchange(pDX); <br>//{{AFX_DATA_MAP(CFileRmClientDlg) <br>DDX_Text(pDX, IDC_IMG_FILENAME, m_sImgFileName); <br>DDV_MaxChars(pDX, m_sImgFileName, 118); <br>DDX_Text(pDX, IDC_MAINCOLOR, m_sMainColor); <br>DDV_MaxChars(pDX, m_sMainColor, 255); <br>DDX_Text(pDX, IDC_THEME, m_sTheme); <br>DDV_MaxChars(pDX, m_sTheme, 255); <br>DDX_Text(pDX, IDC_DESCRIPTION, m_sDescription); <br>DDV_MaxChars(pDX, m_sDescription, 255); <br>DDX_Text(pDX, IDC_MSG, m_sMsg); <br>DDX_Text(pDX, IDC_DESTINATION, m_sDest); <br>//}}AFX_DATA_MAP <br>} <br> <br>BEGIN_MESSAGE_MAP(CFileRmClientDlg, CDialog) <br>//{{AFX_MSG_MAP(CFileRmClientDlg) <br>ON_WM_SYSCOMMAND() <br>ON_WM_PAINT() <br>ON_WM_QUERYDRAGICON() <br>ON_BN_CLICKED(IDC_COPY, OnCopy) <br>ON_BN_CLICKED(IDC_COPY_DIRECTORY, OnCopyDirectory) <br>ON_BN_CLICKED(IDC_INSERT_DATA, OnInsertData) <br>ON_BN_CLICKED(IDC_SELECT_PICTURE, OnSelectPicture) <br>//}}AFX_MSG_MAP <br>END_MESSAGE_MAP() <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CFileRmClientDlg message handlers <br> <br>BOOL CFileRmClientDlg::OnInitDialog() <br>{ <br>CDialog::OnInitDialog(); <br> <br>// Add "About..." menu item to system menu. <br> <br>// IDM_ABOUTBOX must be in the system command range. <br>ASSERT((IDM_ABOUTBOX &amp; 0xFFF0) == IDM_ABOUTBOX); <br>ASSERT(IDM_ABOUTBOX &lt; 0xF000); <br> <br>CMenu* pSysMenu = GetSystemMenu(FALSE); <br>CString strAboutMenu; <br>strAboutMenu.LoadString(IDS_ABOUTBOX); <br>if (!strAboutMenu.IsEmpty()) <br>{ <br>pSysMenu-&gt;AppendMenu(MF_SEPARATOR); <br>pSysMenu-&gt;AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu); <br>} <br> <br>// Set the icon for this dialog.  The framework does this automatically <br>//  when the application's main window is not a dialog <br>SetIcon(m_hIcon, TRUE);// Set big icon <br>SetIcon(m_hIcon, FALSE);// Set small icon <br> <br> <br>CRect rect; <br> <br>CWnd * pWnd = GetDlgItem(IDC_PICT_SPOT); <br>pWnd -&gt; GetWindowRect(&amp;rect); <br>ScreenToClient(rect); <br>pWnd -&gt; ShowWindow(SW_HIDE); <br>BOOL bRet = m_ctlPict.Create("", WS_VISIBLE|WS_CHILD, rect, this, IDC_PICTURECTL); <br>if (!bRet) <br>AfxMessageBox("Failed to create PictureCtl!", MB_ICONSTOP); <br>return TRUE;  // return TRUE  unless you set the focus to a control <br>} <br> <br>void CFileRmClientDlg::OnSysCommand(UINT nID, LPARAM lParam) <br>{ <br>if ((nID &amp; 0xFFF0) == IDM_ABOUTBOX) <br>{ <br>CAboutDlg dlgAbout; <br>dlgAbout.DoModal(); <br>} <br>else <br>{ <br>CDialog::OnSysCommand(nID, lParam); <br>} <br>} <br> <br>// If you add a minimize button to your dialog, you will need the code below <br>//  to draw the icon.  For MFC applications using the document/view model, <br>//  this is automatically done for you by the framework. <br> <br>void CFileRmClientDlg::OnPaint()  <br>{ <br>if (IsIconic()) <br>{ <br>CPaintDC dc(this); // device context for painting <br> <br>SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0); <br> <br>// Center icon in client rectangle <br>int cxIcon = GetSystemMetrics(SM_CXICON); <br>int cyIcon = GetSystemMetrics(SM_CYICON); <br>CRect rect; <br>GetClientRect(&amp;rect); <br>int x = (rect.Width() - cxIcon + 1) / 2; <br>int y = (rect.Height() - cyIcon + 1) / 2; <br> <br>// Draw the icon <br>dc.DrawIcon(x, y, m_hIcon); <br>} <br>else <br>{ <br>CDialog::OnPaint(); <br>} <br>} <br> <br>// The system calls this to obtain the cursor to display while the user drags <br>//  the minimized window. <br>HCURSOR CFileRmClientDlg::OnQueryDragIcon() <br>{ <br>return (HCURSOR) m_hIcon; <br>} <br> <br>void CFileRmClientDlg::OnCopy()  <br>{ <br>#if 0 <br>CWaitCursor wait; <br>ITransactionDispenser*pTransactionDispenser; <br>ITransaction*pTransaction; <br>HRESULThr = S_OK ; <br>BOOLtf = 0 ; <br> <br>// Obtain the ITransactionDispenser Interface pointer <br>// by calling DtcGetTransactionManager() <br>hr = DtcGetTransactionManager( <br>NULL,// LPTSTR pszHost, <br>NULL,// LPTSTR pszTmName, <br>IID_ITransactionDispenser,// /* in  */ REFIID rid, <br>0,// /* in  */ DWORDdwReserved1, <br>0, // /* in  */ WORDwcbReserved2, <br>NULL,// /* in  */ void FAR * pvReserved2, <br>(void **)&amp;pTransactionDispenser // /* out */ void** ppvObject <br>); <br> <br>if (FAILED (hr)) <br>{ <br>CString s; <br>s.Format("DtcGetTransactionManager failed: %x\n", hr); <br>AfxMessageBox(s); <br>return; <br>} <br> <br> <br>hr = pTransactionDispenser-&gt;BeginTransaction(  <br>NULL,///* [in]  */ IUnknown __RPC_FAR *punkOuter, <br>ISOLATIONLEVEL_ISOLATED,///* [in]  */ ISOLEVEL isoLevel, <br>ISOFLAG_RETAIN_DONTCARE,// /* [in]  */ ULONG isoFlags, <br>NULL,///* [in]  */ ITransactionOptions *pOptions  <br>&amp;pTransaction///* [out] */ ITransaction **ppTransaction <br>) ; <br> <br>if (FAILED (hr)) <br>{ <br>pTransactionDispenser-&gt; Release(); <br> <br>CString s; <br>s.Format("BeginTransaction failed: %x\n",hr); <br>AfxMessageBox(s); <br>return; <br>} <br> <br>// create our filerm proxy <br> <br>IFileRmPxy * pPxy = NULL; <br> <br>hr = CoCreateInstance(CLSID_CoFileRmPxy, NULL, CLSCTX_ALL, IID_IFileRmPxy, (void **)&amp;pPxy); <br>ASSERT(hr==S_OK); <br> <br>BSTR sFileName = ::SysAllocString(L"FileRmClient"); <br>ULONG ul = 0; <br> <br>hr = pPxy -&gt; Init(sFileName, &amp;ul); <br>::SysFreeString(sFileName); <br>if (FAILED(hr)) <br>{ <br>pTransactionDispenser-&gt; Release(); <br>AfxMessageBox("Failed to initialize the Resource manager"); <br>return; <br>} <br> <br>//IUnknown * pUnk = NULL; <br>//hr = pTransaction -&gt; QueryInterface(IID_IUnknown, (void **)&amp;pUnk); <br>//ASSERT(hr == S_OK); <br>hr = pPxy -&gt; EnlistTx((IUnknown *)pTransaction); <br>//pUnk -&gt; Release(); <br>ASSERT(hr == S_OK); <br>if (SUCCEEDED(hr)) <br>{ <br>// copy the file <br>UpdateData(TRUE); <br> <br>BSTR sSource = m_sSource.AllocSysString(); <br>BSTR sDest = m_sDest.AllocSysString(); <br> <br>hr = pPxy -&gt; FileCopyTx(sSource, sDest); <br> <br>::SysFreeString(sSource); <br>::SysFreeString(sDest); <br> <br>if (FAILED(hr)) <br>{ <br>pTransaction -&gt; Abort(NULL, FALSE, FALSE); <br>} <br>else <br>{ <br>pTransaction -&gt; Commit(0,0,0); <br>} <br> <br> <br>} <br> <br>// Commit the transaction  <br>pPxy -&gt; Release(); <br>pTransactionDispenser-&gt; Release(); <br>#endif <br>} <br> <br>void CFileRmClientDlg::OnCopyDirectory()  <br>{ <br>#if 0 <br>CWaitCursor wait; <br>IFileRmPxy * pPxy = NULL; <br>HRESULT hr; <br>hr = CoCreateInstance(CLSID_CoFileRmPxy, NULL, CLSCTX_ALL, IID_IFileRmPxy, (void **)&amp;pPxy); <br>ASSERT(hr==S_OK); <br>if (SUCCEEDED(hr)) <br>{ <br>// copy the file <br>UpdateData(TRUE); <br> <br>//BSTR sSource = m_sSource.AllocSysString(); <br>//BSTR sDest = m_sDest.AllocSysString(); <br>pPxy -&gt; ConfirmCommit(TRUE, (long)GetSafeHwnd()); <br>hr = pPxy -&gt; CopyDirTx(sSource, sDest); <br> <br>::SysFreeString(sSource); <br>::SysFreeString(sDest); <br>pPxy -&gt; Release(); <br>} <br>#endif <br>} <br> <br>void CFileRmClientDlg::OnInsertData()  <br>{ <br>CWaitCursor wait; <br>UpdateData(TRUE); <br>m_sMsg.Empty(); <br>UpdateData(FALSE); <br>USES_CONVERSION; <br>ICpyImage * pCpyImage; <br>CString sDestination = m_sDest; <br>// <br>//make sure the last char in the destination is a "\" <br>// <br> <br>if (sDestination.Right(1) != "\\") <br>sDestination += "\\"; <br> <br>HRESULT hr; <br>hr = CoCreateInstance(CLSID_CpyImage, NULL, CLSCTX_ALL, IID_ICpyImage, (void **)&amp;pCpyImage); <br>if (FAILED(hr)) <br>{ <br>AfxMessageBox("Failed to Create the CopyImage component (cpyimage.dll).\nMake sure that it is built and properly registered.", MB_ICONSTOP); <br>return; <br>} <br> <br> <br>CString sSourceFile; <br>sSourceFile = m_ctlPict.GetPictureFileName(); <br>LPSTR p; <br>LPSTR q; <br>p = sSourceFile.GetBuffer(118); <br>q = p+lstrlen(p) - 1; <br>while (q != p) // scan backwards <br>{ <br>q--; <br>if (*q == '\\') <br>{ <br>q++; <br>break; <br>} <br>} <br> <br>// q points to the file name <br> <br> <br>sDestination += q; <br>sSourceFile.ReleaseBuffer(); <br> <br>BSTR sSource = sSourceFile.AllocSysString(); <br>BSTR sDest = sDestination.AllocSysString(); <br>BSTR sDescr = m_sDescription.AllocSysString(); <br>BSTR sMain = m_sMainColor.AllocSysString(); <br>BSTR sThem = m_sTheme.AllocSysString(); <br>BSTR msg; <br> <br>// have the middle tier object do some work for us <br>hr = pCpyImage -&gt; InsertData(sSource,sDest ,sDescr ,sMain , sThem, &amp;msg); <br> <br>::SysFreeString(sSource); <br>::SysFreeString(sDest); <br>::SysFreeString(sDescr); <br>::SysFreeString(sMain); <br>::SysFreeString(sThem); <br> <br>if (hr == S_OK) <br>{ <br>SetDlgItemTextW(GetSafeHwnd(), IDC_MSG, msg); <br> <br>if (::MessageBox(GetSafeHwnd(), "Do you wish to commit the tx?", "FileRmClient", MB_YESNO|MB_ICONQUESTION) == IDYES) <br>pCpyImage -&gt; SetComplete(); <br>else <br>pCpyImage -&gt; SetAbort(); <br>} <br>else <br>{ <br>USES_CONVERSION; <br>m_sMsg.Format("Tx Aborted!\r\nCause: %s", OLE2T(msg)); <br>UpdateData(FALSE); <br>int nLen = SysStringLen(msg); <br>if (nLen != 0) <br>{ <br>::SysFreeString(msg); <br>} <br> <br>pCpyImage -&gt; SetAbort(); <br>} <br> <br>pCpyImage -&gt; Release(); <br> <br> <br>} <br> <br> <br>BEGIN_EVENTSINK_MAP(CFileRmClientDlg, CDialog) <br>    //{{AFX_EVENTSINK_MAP(CFileRmClientDlg) <br>ON_EVENT(CFileRmClientDlg, IDC_PICTURECTL, 1 /* PictureChanged */, OnPictureChanged, VTS_PBSTR) <br>//}}AFX_EVENTSINK_MAP <br>END_EVENTSINK_MAP() <br> <br>void CFileRmClientDlg::OnPictureChanged(BSTR FAR* PictureFileName)  <br>{ <br>m_sImgFileName = *PictureFileName; <br>UpdateData(FALSE); <br> <br>} <br> <br>void CFileRmClientDlg::OnSelectPicture()  <br>{ <br>static char BASED_CODE szFilter[] = "All image files (*.bmp, *.wmf; *.gif)|*.bmp;*.gif;*.wmf|Bitmap Files (*.bmp)|*.bmp|GIF Files (*.gif)|*.giv|Windows Meta files (*.wmf)|*.wmf|All Files (*.*)|*.*||"; <br>  <br> <br>CFileDialog dlg(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT, szFilter, this); <br>if (dlg.DoModal() == IDCANCEL) <br>return; <br> <br>m_sImgFileName = dlg.GetPathName( ); <br>m_ctlPict.SetPictureFileName(m_sImgFileName); <br>UpdateData(FALSE); <br> <br> <br>} <br> <br>#if 0 <br>void ShowError(HENV henv, HDBC hdbc, HSTMT hstmt) <br>{ <br>UCHAR szSqlState[64]; <br>SDWORD NativeError; <br>UCHAR szErr[512]; <br>SWORD cbErrorMsg; <br>SQLError(henv, hdbc, hstmt, szSqlState, &amp;NativeError, szErr, 511, &amp;cbErrorMsg); <br>AfxMessageBox((LPCSTR)szErr); <br>} <br> <br> <br>{ <br>RETCODE                  rc = 0; <br>    RETCODE                  rc1 = 0; <br>    HENV                     henv = NULL; <br>    HDBC                     hdbc = NULL; <br>    HSTMT                    hstmt = NULL; <br>long hPxyCon = 0; <br>    CString sSQL; <br>CString sDestination = "c:\\images\\"; <br>CString sSourceFile; <br>LPSTR p, q; <br> <br>BSTR sSource; <br>BSTR sDest; <br> <br>CWaitCursor wait; <br> <br>    HRESULT                  hr; <br>    ITransactionDispenser   *pITransDisp = NULL; <br>    ITransaction            *pITransaction = NULL; <br>USES_CONVERSION; <br>UpdateData(TRUE); <br> <br>sSourceFile = m_ctlPict.GetPictureFileName(); <br>p = sSourceFile.GetBuffer(118); <br>q = p+lstrlen(p) - 1; <br>while (q != p) // scan backwards <br>{ <br>q--; <br>if (*q == '\\') <br>{ <br>q++; <br>break; <br>} <br>} <br> <br>// q points to the file name <br> <br> <br>sDestination += q; <br>sSourceFile.ReleaseBuffer(); <br> <br>// create the Proxy <br>   IFileRmPxy * pPxy = NULL; <br> <br>hr = CoCreateInstance(CLSID_FileRmPxy, NULL, CLSCTX_ALL, IID_IFileRmPxy, (void **)&amp;pPxy); <br>ASSERT(hr==S_OK); <br> <br> <br> <br> <br>    //--------------------------------------------------------------- <br>    //Obtain the transaction dispenser from DTC Proxy <br>    hr = DtcGetTransactionManager( 0x0, <br>                                   0x0, <br>                                   IID_ITransactionDispenser, <br>                                   0x0, <br>                                   0x0, <br>                                   0x0, <br>                                   (void **) &amp;pITransDisp ); <br> <br>    if (hr != S_OK) <br>    { <br>          <br>        AfxMessageBox("Couldn't get the Tx Dispenser!  Make sure DTC is running!");  <br>goto Exit; <br>    } <br>     <br> <br> <br>    //--------------------------------------------------------------- <br>    //Obtain a new transaction from the dispenser <br>    hr = pITransDisp-&gt;BeginTransaction( NULL, <br>                                        ISOLATIONLEVEL_ISOLATED, <br>                                        0x0, <br>                                        NULL, <br>                                        &amp;pITransaction ); <br> <br> <br>pITransDisp -&gt; Release(); <br>pITransDisp = NULL; <br>    if (hr != S_OK) <br>    { <br>          <br>         goto Exit; <br>    } <br>     <br> <br>    /* Allocate the Environment handle */ <br>    rc = SQLAllocEnv( &amp;henv ); <br>    if( rc ) <br>    { <br>         <br>        goto Exit; <br>    } <br>     <br> <br>    /* Allocate the Connection handle */ <br>    rc = SQLAllocConnect( henv, &amp;hdbc ); <br>    if( rc ) <br>    { <br>         <br>        goto Exit; <br>    } <br>     <br> <br>SQLSetConnectOption(hdbc, SQL_LOGIN_TIMEOUT, 5); <br> <br>    /* Establish the database connection */ <br>    rc = SQLConnect( hdbc, (UCHAR *)"FileRmTest", SQL_NTS,  <br>(UCHAR *)"sa", SQL_NTS, <br>(UCHAR *)"", SQL_NTS ); <br> <br>    if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>        //printError( henv, hdbc, hstmt, SqlState ); <br>        goto Exit; <br>    } <br>#if 0 <br>rc = SQLSetConnectOption( hdbc, SQL_TXN_ISOLATION_OPTION, (DWORD )SQL_TXN_READ_UNCOMMITTED);     <br>if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>      <br>UCHAR szSqlState[64]; <br>SDWORD NativeError; <br>UCHAR szErr[512]; <br>SWORD cbErrorMsg; <br>SQLError(henv, hdbc, hstmt, szSqlState, &amp;NativeError, szErr, 511, &amp;cbErrorMsg); <br> <br>/* note: use SQLError from here on */ <br>        //printError( henv, hdbc, hstmt, SqlState ); <br>        goto Exit; <br>    } <br>#endif <br>rc = SQLSetConnectOption( hdbc, SQL_COPT_SS_ENLIST_IN_DTC, (DWORD )pITransaction ); <br>if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>      <br> <br>ShowError(henv, hdbc, hstmt); <br>goto Exit; <br>    } <br> <br>rc = SQLSetConnectOption( hdbc, SQL_AUTOCOMMIT, SQL_AUTOCOMMIT_OFF ); <br>    if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>        ShowError(henv, hdbc, hstmt); <br>goto Exit; <br>    } <br>     <br>     <br> <br> <br>hr = pPxy -&gt; Connect(&amp;hPxyCon); <br>_ASSERTE(hr == S_OK); <br>hr = pPxy -&gt; Enlist(hPxyCon, (IUnknown *)pITransaction); <br>_ASSERTE(hr == S_OK); <br> <br>    <br> <br>    /* Allocate the statement handle */ <br>    rc = SQLAllocStmt( hdbc, &amp;hstmt ); <br>    if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>        ShowError(henv, hdbc, hstmt); <br>        goto Exit; <br>    } <br> <br>     /* Execute to Insert */ <br> <br>sSQL.Format("insert into image values ('%s', '%s', '%s', '%s')",  <br>m_sDescription, m_sMainColor, m_sTheme, sDestination); <br> <br>// insert the row into the database <br>    rc = SQLExecDirect( hstmt, ( UCHAR * )(LPCSTR)sSQL, SQL_NTS ); <br> <br>    if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>ShowError(henv, hdbc, hstmt); <br>pITransaction -&gt; Abort(NULL, FALSE, FALSE); <br>        goto Exit; <br>    } <br> <br>sSource = ::SysAllocString(T2OLE(sSourceFile)); <br>sDest = ::SysAllocString(T2OLE(sDestination)); <br>     <br>// copy the image to the images directory <br> <br>hr = pPxy -&gt; CopyFileTx(hPxyCon, sSource, sDest, TRUE); <br>::SysFreeString(sSource); <br>::SysFreeString(sDest); <br>if (FAILED(hr)) <br>{ <br>pITransaction -&gt; Abort(NULL, FALSE, FALSE); <br>goto Exit; <br>} <br>    <br>/* Commit the DTC transaction */ <br>if (::MessageBox(GetSafeHwnd(), "Commit Transaction?", "File Resource Manager", MB_YESNO) == IDYES) <br>        hr = pITransaction-&gt;Commit( FALSE, XACTTC_SYNC_PHASEONE, 0x0 ); <br>else <br>hr = pITransaction-&gt;Abort( 0,0,0); <br> <br>    if (hr != S_OK) <br>    { <br>         <br>        goto Exit; <br>    } <br> <br>    /* Free the statement handle */ <br>    rc = SQLFreeStmt( hstmt, SQL_DROP ); <br>    if( rc != SQL_SUCCESS &amp;&amp; rc != SQL_SUCCESS_WITH_INFO ) <br>    { <br>        goto Exit; <br>    } <br> <br>     <br>    Exit: <br>if (pITransaction) <br>   pITransaction -&gt; Release(); <br> <br>if (pPxy) <br>{ <br>hr = pPxy -&gt; Disconnect(hPxyCon); <br>    pPxy -&gt; Release(); <br>} <br> <br>    if (hdbc) <br>{ <br>rc1 = SQLDisconnect( hdbc ); <br>   SQLFreeConnect( hdbc ); <br>       SQLFreeEnv( henv ); <br>} <br> <br>      <br>if( rc1 != SQL_SUCCESS &amp;&amp; rc1 != SQL_SUCCESS_WITH_INFO ) <br>       { <br>// print message <br>   } <br> <br>     <br>     <br>       if( rc == 0 ) <br>       { <br>   // success <br>       } <br>       else <br>       { <br>   // failed <br>   } <br> <br>} <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
