<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPIMPL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1340"></a>DISPIMPL.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: dispimpl.cpp <br>* <br>* Description: main implementation of IDispenserDriver <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "TxFileDisp.h" <br>#include "copyfilerm.h" <br>#include "mtxdm.h" <br>#include "txcoord.h" <br>#include "FileRmPxy.h" <br>#include "txdtc.h" <br>#include "xolehlp.h" <br> <br> <br>// <br>//called by RDM (Resource Dispenser Manager) when it is time to create <br>//a new resource, in this case a connection to the CopyFileRM <br>// <br>STDMETHODIMP CFileRmPxy::CreateResource <br>( <br>/*[in]*/  const RESTYPID ResTypId, <br>/*[out]*/ RESID* pResId,  <br>/*[out]*/ TIMEINSECS* pSecsFreeBeforeDestroy <br>) <br>{ <br> <br>ATLTRACE(_T("Creating TxFile Resource\n")); <br>CComBSTR sAppName = L"TxFileDispenser"; <br>long lHandle; <br>HRESULT hr; <br> <br> <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>{ <br>_ASSERTE(0); <br>return E_UNEXPECTED; <br>} <br>hr = pRm -&gt; Connect(sAppName.m_str, (long *)&amp;lHandle); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>SafeRelease(pRm); <br>return hr; <br>} <br> <br>*pResId = (RESID)lHandle; <br>// <br>//set a 60 second time out <br>// <br>*pSecsFreeBeforeDestroy = 60;  <br> <br>// <br>//save the connection in our set of connections <br>// <br>m_set.insert(lHandle); <br> <br>SafeRelease(pRm); <br>return S_OK; <br>} <br>// <br>//called by RDM (Resource Dispenser Manager) when it is time <br>//to rate an already created resource <br>// <br>STDMETHODIMP CFileRmPxy::RateResource <br>( <br>/*[in]*/  const RESTYPID ResTypId, <br>/*[in]*/  const RESID ResId, <br>/*[in]*/  const BOOL fRequiresTransactionEnlistment, <br>/*[out]*/ RESOURCERATING* pRating <br>) <br>{ <br>ATLTRACE(_T("Rating resource\n")); <br> <br>// if it is already enlisted on the right transaction, use it <br>if (fRequiresTransactionEnlistment == FALSE)  <br>{ <br>*pRating = 100; <br>} <br>else <br>{ <br>// not enlisted <br>*pRating = 50; <br>} <br>return S_OK; <br>} <br> <br>// <br>//called by RDM (Resource Dispenser Manager) when it is time <br>//when it is time to enlist a connection on a resource <br>// <br>STDMETHODIMP CFileRmPxy::EnlistResource <br>( <br>/*[in]*/  const RESID ResId, <br>/*[in]*/  const TRANSID TransId <br>) <br>{ <br> <br>// <br>//there are 3 kinds of resources in the pool: <br>//1. Enlisted resources <br>//2. Un-enlisted resources <br>//3. previously enlisted resources <br>// <br>//type (3) resources require Re-enlistment or "Unenlistment" to be used <br>//again.  Dispman asks us to Unenlist a resource by passing in a NULL <br>//TransId <br>// <br>//The CopyFileRm ALWAYS resets the state for the Worker (ie the resource being <br>//dispensed)to an "uninitialized" state -- and any work on a uninitialized worker object <br>//immediately fails.  so "Unenlistement" is a noop for us (SQL Server, btw, allows work to be done  <br>//  with or without a tx, so their implementation is different)  <br>//   <br> <br> <br>if (!TransId) <br>return S_OK; <br> <br> <br>ATLTRACE(_T("Enlisting Resource\n")); <br>ITransaction * pTransaction = (ITransaction *)TransId; <br> <br> <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br>HRESULT hr; <br>ITransactionExport *pExport; <br> <br> <br>pExport = m_mapExport[ResId]; <br>if (pExport == NULL) <br>{ <br> <br>hr = GetExportObject(ResId, pTransaction, &amp;pExport); <br>if (FAILED(hr)) <br>{ <br>SafeRelease(pRm); <br>return hr; <br>} <br> <br>m_mapExport[ResId] = pExport; <br>} <br> <br>ULONGcbTransactionCookie = 0; <br>BYTE*rgbTransactionCookie; <br>ULONGcbUsed; <br> <br> <br>// Get transaction cookie <br>hr = pExport-&gt;Export (pTransaction, &amp;cbTransactionCookie); <br>_ASSERTE(hr == S_OK); <br> <br> <br>rgbTransactionCookie = (BYTE *) CoTaskMemAlloc (cbTransactionCookie); <br>_ASSERTE (0 != rgbTransactionCookie); <br>if (0 == rgbTransactionCookie) <br>{ <br>SafeRelease(pRm); <br>_ASSERTE(0); <br>return E_FAIL; <br>} // if <br> <br>hr = pExport-&gt;GetTransactionCookie (pTransaction,  <br>cbTransactionCookie, <br>rgbTransactionCookie, <br>&amp;cbUsed); <br> <br>// <br>//ExportTx will also enlist in the Tx <br>// <br>// <br>//NOTE:  There is a functionaly requirement that makes this call block <br>//   if the connection is not completely finished committing or aborting <br>//the previous transaction <br>// <br>hr = pRm-&gt;ExportTx (ResId, cbUsed, rgbTransactionCookie); <br> <br>CoTaskMemFree (rgbTransactionCookie); <br>SafeRelease(pRm); <br> return hr; <br> <br>} <br> <br>// <br>//called by RDM (Resource Dispenser Manager) when it is time <br>//to reset the resouce -- ie it is being returned to the inactive <br>//pool.  you should generally clean up connection specific state <br>//here. <br>// <br>STDMETHODIMP CFileRmPxy::ResetResource <br>( <br>/*[in]*/  const RESID ResId <br>) <br>{ <br>ATLTRACE(_T("Resetting resource\n")); <br>HRESULT hr = E_FAIL; <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br>hr = pRm -&gt; ResetConnection((long)ResId); <br>SafeRelease(pRm); <br>_ASSERTE(hr == S_OK); <br> <br>// <br>//if you return S_FALSE, then the resource <br>//is destroyed emmediately <br>// <br>return hr; <br>} <br>// <br>//called by RDM (Resource Dispenser Manager) when it is time <br>//to destroy the resource <br>// <br>STDMETHODIMP CFileRmPxy::DestroyResource  <br>( <br>/*[in]*/  const RESID ResId <br>) <br>{ <br> <br>ATLTRACE(_T("Destroying a resource\n")); <br>HRESULT hr = E_FAIL; <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br>hr = pRm -&gt; Disconnect((long )ResId); <br>ULONG ulRefcount  = pRm -&gt; Release(); <br>pRm = NULL; <br> <br>ITransactionExport*pExport; <br>pExport = m_mapExport[ResId]; <br>int nElements = m_mapExport.erase(ResId); <br>_ASSERTE(nElements == 1); <br>SafeRelease(pExport); <br> <br>// remove it from our set <br>m_set.erase(ResId); <br>_ASSERTE(hr == S_OK); <br>return hr; <br>} <br> <br>STDMETHODIMP CFileRmPxy::DestroyResourceS <br>( <br>/*[in]*/  constSRESID ResId <br>) <br>{ <br>return E_NOTIMPL; <br>} <br> <br>// <br>//called by the framework during the IClassFactory::CreateInstance() <br>//method...this is a good place to initialize because the object is <br>//fully created, and you can propagate an error code back to the user <br>// <br>HRESULT CFileRmPxy::FinalConstruct() <br>{ <br>HRESULT hr; <br> <br>hr = GetDispenserManager(&amp;m_pDispMan); <br>if (SUCCEEDED(hr)) <br>{ <br> <br>// we are running under MTS <br>IDispenserDriver * pDriver; <br>hr = GetUnknown()-&gt;QueryInterface(IID_IDispenserDriver, (void **)&amp;pDriver); <br>_ASSERTE(hr == S_OK); <br>hr = m_pDispMan -&gt; RegisterDispenser(pDriver, L"TxFileDispenser", &amp;m_pHolder); <br>_ASSERTE(hr == S_OK); <br>// <br>//WATCH OUT HERE!!!!!!!! <br>// <br>//there is a bug in MTS 1.x that was found post ship where the pDriver isn't  <br>//properly AddRef()'d.  In a future version of MTS, we will have a new  <br>//RegisterDispenser() API (e.g. something like RegisterDispenser2() <br>//that will do this correctly.  In the meantime, treat <br>//this as a "moved" reference, and do not release the pDriver pointer! <br>//(all future versions of RegisterDispenser() will behave this way for <br>//backward compatiblity) <br> <br>} <br>// <br>// get a connection to the RM -- the RM is a singleton object, so we will always get the same <br>// pointer back from CoCreateInstance <br>// <br>hr = CoCreateInstance(CLSID_CoFileRm, NULL, CLSCTX_LOCAL_SERVER, IID_IFileRm , (void **)&amp;m_pRm); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br> <br>// <br>//NT SP3 has added support for the "Global Interface Table" <br>//which we use to get a proxy valid on any thread (see the WIN32 <br>//SDK docs for more info) <br>// <br>m_dwRmPtrCookie = 0; <br>hr = CoCreateInstance(CLSID_StdGlobalInterfaceTable, <br>                                NULL, <br>                                CLSCTX_INPROC_SERVER, <br>                                IID_IGlobalInterfaceTable, <br>                                (void **)&amp;m_pGIT); <br>_ASSERT(SUCCEEDED(hr)); <br>if (m_pGIT) <br>    { <br>        // register our interface and get a cookie <br>hr = m_pGIT-&gt;RegisterInterfaceInGlobal(m_pRm, IID_IFileRm, &amp;m_dwRmPtrCookie); <br>_ASSERT(SUCCEEDED(hr)); <br>    } <br> <br>// <br>//aggregate in the free threaded marshaler <br>//this is ABSOLUTELY CRITICAL to do in a resource dispenser! <br>//if we take a thread switch because we switched apartments,  <br>//we will loose the object context and the resource dispenser  <br>//manager will think that there is notransaction,  <br>//and EnlistResource() will not be called. <br>// <br>//NOTE:you should mark all resource dispensers as "Both" in the registy <br>//(see the FileRmPxy.rgs files) <br>// <br> <br>hr = CoCreateFreeThreadedMarshaler(GetUnknown(), &amp;m_pFreeThreadedMarshaler); <br>_ASSERTE(hr == S_OK); <br> <br>return hr; <br>} <br>// <br>//this is called by the framework when my reference count is going from 1 to 0 <br>// <br>void CFileRmPxy::FinalRelease() <br>{ <br> <br>ATLTRACE(_T("\nCFileRmPxy::FinalRelease()\n")); <br>HRESULT hr; <br>if (m_pGIT &amp;&amp; m_dwRmPtrCookie) <br>{ <br>hr =m_pGIT-&gt;RevokeInterfaceFromGlobal(m_dwRmPtrCookie); <br>if (FAILED(hr)) <br>{ <br>USES_CONVERSION; <br>char * szFile = __FILE__; <br>ATLTRACE(_T("RevokeInterfaceFromGlobal() failed on line %ld of file %s.\n\nError Code %lx"), __LINE__, A2W(szFile) , hr); <br>} <br>SafeRelease(m_pGIT); <br>m_dwRmPtrCookie = 0; <br>} <br>m_dwRmPtrCookie = 0; <br>SafeRelease(m_pDispMan); <br>SafeRelease(m_pHolder); <br>SafeRelease(m_pRm); <br>SafeRelease(m_pFreeThreadedMarshaler); <br> <br>} <br>// <br>//GetFileRmPointer: <br>// <br>//use the Global Interface Table to get a proxy valid on any thread <br>// <br>IFileRm * CFileRmPxy::GetFileRmPointer() <br>{ <br> <br>IFileRm * pRm =NULL; <br>HRESULT hr; <br>hr = m_pGIT-&gt;GetInterfaceFromGlobal(m_dwRmPtrCookie, IID_IFileRm, (void **)&amp;pRm); <br>_ASSERTE(pRm); <br>return pRm; <br> <br>} <br>// <br>//helper function to get an ITransactionExport pointer <br>// <br>HRESULT CFileRmPxy::GetExportObject(long ResId, ITransaction * pTransaction, ITransactionExport **ppExport) <br>{ <br>*ppExport = NULL; <br> <br> <br>ULONGcbWhereabouts = 0; <br>BYTE*rgbWhereabouts = NULL; <br>HRESULThr; <br>ITransactionExportFactory*pTxExpFac; <br>IGetDispenser*pIDispenser; <br> <br> <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br>// <br>//GetTmWhereabouts finds the PHYSICAL location of the RM..if you know that <br>//you will only ever be connecting to one RM, you can get the Whereabouts ONCE <br>//and store it to be used with multiple connections. <br>// <br>//here we actually get it each time, in order to show the generalized process <br>// <br> <br>hr = pRm-&gt;GetTmWhereabouts (ResId, &amp;rgbWhereabouts, &amp;cbWhereabouts); <br>if (S_OK != hr) <br>{ <br>SafeRelease(pRm); <br>_ASSERTE(hr == S_OK); <br>return hr; <br>} // if <br> <br>hr = pTransaction-&gt;QueryInterface (IID_IGetDispenser, (LPVOID *) &amp;pIDispenser); <br>if (S_OK != hr) <br>{ <br>SafeRelease(pRm); <br>_ASSERTE(0); <br>return hr; <br>} // if <br> <br>hr = pIDispenser-&gt;GetDispenser (IID_ITransactionExportFactory,  <br> (LPVOID *) &amp;pTxExpFac ); <br>SafeRelease(pIDispenser); <br>if (S_OK != hr) <br>{ <br>_ASSERTE(0); <br>SafeRelease(pRm); <br>return hr; <br>} // if <br> <br> <br>hr = pTxExpFac-&gt;Create (cbWhereabouts, rgbWhereabouts, ppExport); <br>SafeRelease(pTxExpFac); <br>if (S_OK != hr) <br>{ <br>SafeRelease(pRm); <br>_ASSERTE(0); <br>return hr; <br>} // if <br> <br>CoTaskMemFree (rgbWhereabouts); <br>SafeRelease(pRm); <br>return hr; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
