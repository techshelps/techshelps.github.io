<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRMWORKERPRIV.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1325"></a>IRMWORKERPRIV.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: irmworkerpriv.cpp <br>* <br>* Description:  Contains the "Private" interface that the RM uses to communicate <br>with the worker <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "RmWorker.h" <br>#include "txdtc.h" <br>#include "txcoord.h" <br>#include "xolehlp.h" <br>#include "simplelog.h" <br>#include "action.h" <br>#include "copyfilerm.h" <br>#include "RmWorkerObj.h" <br> <br> <br> <br> <br>STDMETHODIMP CRmWorkerObj::SetState(TXSTATE eState) <br>{ <br>m_eTxState = eState; <br>return S_OK; <br> <br>} // CRmWorkerObj:SetState <br> <br> <br>STDMETHODIMP CRmWorkerObj::GetState(TXSTATE *eState) <br>{ <br>*eState = m_eTxState; <br>return S_OK; <br> <br>} // CRmWorkerObj::GetState() <br> <br>STDMETHODIMP CRmWorkerObj::CleanupTx(void) <br>{ <br>BOOLfReturn; <br> <br>// Set state to initializing new transaction <br>SetState (TX_INITIALIZING); <br> <br>// Cleanup all interfaces and objects used by transaction <br>if (m_pITx) <br>m_pITx-&gt;Release (); <br> <br>m_pITx = NULL; <br> <br> <br>fReturn = RemoveAction(); <br>  <br>HRESULT hr = WriteLog (m_guidTx, LOG_RM_XACT_END, RM_NONE, 0, 0); <br>_ASSERTE(hr == S_OK); <br>return S_OK; <br> <br>} // CRmWorkerObj::CleanupTx() <br> <br>// <br>//if we get a request to enlist on a tx, and we haven't finished <br>//the privious tx (usually do to an async abort), then we have <br>//to wait until the tx is done <br>// <br>STDMETHODIMP CRmWorkerObj::WaitTxDone(void) <br>{ <br>_ASSERTE(m_hFinishedTxEvent); <br>DWORDdwWaitRc = 0; <br>dwWaitRc = WaitForSingleObject (m_hFinishedTxEvent, INFINITE); <br>_ASSERTE (WAIT_FAILED != dwWaitRc); <br>return S_OK; <br> <br>} // CRmWorkerObj::WaitTxDone() <br> <br> <br>STDMETHODIMP CRmWorkerObj::PrepareTx (void) <br>{ <br>BOOLfRc= TRUE; <br>HRESULThRc= S_OK; <br>IPrepareInfo*pIPrepareInfo= 0; <br>BYTE*rgbPrepareInfo= 0; <br>ULONGcbPrepareInfo= 0; <br>TCHARrgbSizeBuf[sizeof(ULONG)+1]; <br> <br> <br>hRc = m_pEnlist-&gt;QueryInterface (IID_IPrepareInfo, <br> (LPVOID *) &amp;pIPrepareInfo); <br>_ASSERTE (S_OK == hRc); <br>_ASSERTE (0 != pIPrepareInfo); <br>if (S_OK != hRc) <br>{ <br>SetStatus (RM_STATUS_INTERFACE); <br>return E_FAIL; <br>} // if -- QueryInterface failed <br>else <br>{ <br>pIPrepareInfo-&gt;GetPrepareInfoSize (&amp;cbPrepareInfo); <br>_ASSERTE (0 != cbPrepareInfo); <br> <br>// Allocate storage for prepare info <br>rgbPrepareInfo = (BYTE *) CoTaskMemAlloc (cbPrepareInfo); <br>_ASSERTE (0 != rgbPrepareInfo); <br>if (0 == rgbPrepareInfo) <br>{ <br>// Error message -- no memory <br>pIPrepareInfo-&gt;Release (); <br>pIPrepareInfo = 0; <br> <br>SetStatus (RM_STATUS_NO_MEMORY); <br>return E_FAIL; <br>} // if <br> <br>memset( (LPVOID) rgbPrepareInfo, '\0', cbPrepareInfo); <br>pIPrepareInfo-&gt;GetPrepareInfo ( (UCHAR *) rgbPrepareInfo); <br> <br>pIPrepareInfo-&gt;Release (); <br>pIPrepareInfo = 0; <br> <br>// CAUTION:  The rgbPrepareInfo byte stream is assumed to be a null terminated <br>// character string.  If this is not so the log write will fail. <br>wsprintf (rgbSizeBuf, L"%ld", cbPrepareInfo); <br>HRESULT hr = WriteLog (m_guidTx, LOG_RM_XACT_PREPARE, RM_NONE, (TCHAR *) rgbSizeBuf, (TCHAR *) rgbPrepareInfo); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>// Error message -- could not write prepare record <br>CoTaskMemFree ((LPVOID) rgbPrepareInfo); <br> <br>SetStatus (RM_STATUS_LOG_ERROR); <br>return E_FAIL; <br>} // <br>} // if -- QueryInterface succeeded. <br> <br>CoTaskMemFree ((LPVOID) rgbPrepareInfo); <br>return S_OK; <br> <br>} // CRmWorkerObj::PrepareTx() <br> <br> <br> <br>STDMETHODIMP CRmWorkerObj::CommitTx (void) <br>{ <br> <br>HRESULT hr = WriteLog (m_guidTx, LOG_RM_XACT_COMMIT, RM_NONE, 0, 0); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>SetStatus (RM_STATUS_LOG_ERROR); <br>return E_FAIL; <br>} // if <br> <br>// <br>//we need to go through the action list to see if we  <br>//created any temp files and if we need, we delete them <br>// <br> <br>CleanupAction (TRUE); <br>return S_OK; <br> <br>} // CRmWorkerObj::CommitTx() <br> <br> <br>STDMETHODIMP CRmWorkerObj::AbortTx (void) <br>{ <br>HRESULThr = S_OK; <br> <br>// Write begin undo record to the log <br>hr = WriteLog (m_guidTx, LOG_RM_PRIVATE, RM_UNDO_BEGIN, 0, 0); <br>if (hr != S_OK) <br>{ <br>_ASSERTE(0); <br>return E_FAIL; <br>} // if <br> <br>// Undo all action for the current transaction. <br>hr = RollbackTx (); <br>_ASSERTE (S_OK == hr); <br>if (S_OK == hr) <br>{ <br>CleanupAction (); <br>} // if <br>return hr; <br> <br>} // CRmWorkerObj::AbortTx() <br> <br>STDMETHODIMP CRmWorkerObj::GetDTCUnknown(IUnknown ** pUnk) <br>{ <br>*pUnk = NULL; <br>if (!m_pEnlist) <br>{ <br>_ASSERTE(0); <br>return E_UNEXPECTED; <br>} <br>HRESULT hr = m_pEnlist -&gt; QueryInterface(IID_IUnknown, (void **)pUnk); <br>_ASSERTE(*pUnk); <br>return hr; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
