<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ACTION.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1323"></a>ACTION.CPP</h2>
<pre><code>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: action.cpp <br>* <br>* Description:  abstracts a RM "Action" <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "SimpleLog.h" <br>#include "action.h" <br> <br> <br> <br> <br>CAction::CAction() <br>{ <br>m_sPath1 = NULL; <br>m_sPath2 = NULL; <br>m_hLock=NULL; <br>*m_pszLockedFile = NULL; <br>} <br>CAction::~CAction() <br>{ <br>ReleaseLock(); <br>if (m_sPath1) <br>delete [] m_sPath1; <br>if (m_sPath2) <br>delete [] m_sPath2; <br>} <br> <br>CAction::CAction (CAction * pAction) <br>{ <br>m_sPath1 = NULL; <br>m_sPath2 = NULL; <br>m_hLock=NULL; <br>m_eFileOp = pAction -&gt; m_eFileOp; <br>m_eRmCommand = pAction -&gt; m_eRmCommand; <br>*m_pszLockedFile = NULL; <br>if (pAction -&gt; m_sPath1) <br>{ <br>m_sPath1 = new TCHAR[lstrlen(pAction -&gt; m_sPath1)+1]; <br>lstrcpy(m_sPath1, pAction -&gt; m_sPath1); <br>} <br> <br>if (pAction -&gt; m_sPath2) <br>{ <br>m_sPath2 = new TCHAR[lstrlen(pAction -&gt; m_sPath2)+1]; <br>lstrcpy(m_sPath1, pAction -&gt; m_sPath2); <br>} <br>} <br> <br>CAction::CAction(LOG_RM_COMMAND rmCommand, FILE_OPERATION eOpIn,  LPTSTR pszInParm1, LPTSTR pszInParm2) <br>{ <br>m_sPath1 = NULL; <br>m_sPath2 = NULL; <br>m_hLock=NULL; <br>m_eFileOp = eOpIn; <br>m_eRmCommand = rmCommand; <br>*m_pszLockedFile = NULL; <br>if (pszInParm1) <br>{ <br>m_sPath1 = new TCHAR[lstrlen(pszInParm1) + 1]; <br>*m_sPath1 = NULL; <br>lstrcpy(m_sPath1, pszInParm1); <br>} <br> <br>if (pszInParm2) <br>{ <br>m_sPath2 = new TCHAR[lstrlen(pszInParm2)+1]; <br>*m_sPath2 = NULL; <br>lstrcpy(m_sPath2, pszInParm2); <br>} <br>} <br> <br>BOOL CAction::LockFile(TCHAR * pFile) <br>{ <br> <br>lstrcpy(m_pszLockedFile, pFile); <br>m_hLock = CreateFile(   pFile,// pointer to name of the file  <br>GENERIC_WRITE|GENERIC_READ,// access (read-write) mode  <br>0L,// share mode  <br>NULL,// pointer to security descriptor  <br>OPEN_EXISTING,// how to create  <br>FILE_ATTRIBUTE_NORMAL,// file attributes  <br>NULL); // handle to file with attributes to copy   <br> <br>_ASSERTE(m_hLock); <br>BOOL bRet; <br>memset(&amp;m_attrFile, NULL, sizeof(m_attrFile)); <br> <br>// store the file attributes for later user <br>bRet = GetFileAttributesEx(pFile, GetFileExInfoStandard, &amp;m_attrFile); <br>_ASSERTE(bRet); <br> <br>// set the file to Hidden (the file is Read only because it is open) <br>bRet = SetFileAttributes(pFile, FILE_ATTRIBUTE_HIDDEN); <br>_ASSERTE(bRet); <br>return m_hLock ? TRUE : FALSE; <br> <br> <br>} <br> <br>void CAction::ReleaseLock() <br>{ <br>if (m_hLock) <br>{ <br> <br>if (!CloseHandle(m_hLock)) <br>_ASSERTE(0); <br> <br>m_hLock = NULL; <br>BOOL bRet = SetFileAttributes(m_pszLockedFile, m_attrFile.dwFileAttributes); <br>_ASSERTE(bRet); <br>} <br>} <br>// <br>//save the data into a byte stream <br>// <br> <br>HRESULT CAction::Save(BYTE **ppByte, ULONG * cbByte) <br>{ <br>LPSTR sPath1, sPath2; <br>#ifdef _UNICODE // convert to ANSI <br>USES_CONVERSION; <br>sPath1  = W2A(m_sPath1); <br>sPath2 = W2A(m_sPath2); <br>#else <br>sPath1 = m_sPath1; <br>sPath2 = m_sPath2; <br>#endif <br> <br>int lPath1Size = 1;  <br>if (sPath1) <br>lPath1Size += lstrlenA(sPath1); <br> <br>int lPath2Size = 1; <br>if (sPath2) <br>lPath2Size += lstrlenA(sPath2)+1; <br> <br>*cbByte =sizeof(m_eFileOp)+ <br>lPath1Size +  <br>sizeof(DWORD) + // string len <br>lPath2Size +  <br>sizeof(DWORD) + // string len <br>sizeof(m_eRmCommand); <br> <br> <br> <br>*ppByte = new BYTE[*cbByte]; <br>_ASSERTE(*ppByte); <br>if (!*ppByte) <br>return E_OUTOFMEMORY; <br>ULONG lOffset = 0; <br>memset(*ppByte, NULL, (int)*cbByte); <br> <br>*(FILE_OPERATION *)(*ppByte + lOffset) =  m_eFileOp; <br>lOffset += sizeof(m_eFileOp); <br> <br>*(LOG_RM_COMMAND *)(*ppByte + lOffset) =  m_eRmCommand; <br>lOffset += sizeof(m_eRmCommand); <br> <br>*(ULONG *)(*ppByte + lOffset) = lPath1Size; <br>lOffset +=sizeof(ULONG); <br> <br>if (m_sPath1) <br>lstrcatA((LPSTR)(*ppByte + lOffset), sPath1); <br> <br>lOffset += lPath1Size; <br> <br>*(ULONG *)(*ppByte + lOffset) = lPath2Size; <br>lOffset +=sizeof(ULONG); <br> <br>if (m_sPath2) <br>lstrcatA((LPSTR)(*ppByte + lOffset), sPath2); <br> <br>lOffset += lPath2Size; <br>_ASSERTE(lOffset == *cbByte); <br> <br>return S_OK; <br> <br>} <br>HRESULT CAction::Load(BYTE * pByte, long cbByte) <br>{ <br> <br>LPSTR p1, p2; <br>p1 = p2 = NULL; <br>ULONG lOffset = 0; <br>m_eFileOp=  *(FILE_OPERATION *)(pByte) ; <br>lOffset += sizeof(m_eFileOp); <br>m_eRmCommand=*(LOG_RM_COMMAND *)(pByte + lOffset); <br>lOffset += sizeof(m_eRmCommand); <br> <br>ULONG cbStringLen; <br>cbStringLen = *(ULONG *)(pByte + lOffset); <br>lOffset +=sizeof(ULONG); <br>m_sPath1 = NULL; <br>if (cbStringLen) <br>{ <br>p1  = new CHAR[cbStringLen]; <br>memset(p1, NULL, cbStringLen); <br>memcpy(p1, (LPCSTR)(pByte + lOffset), cbStringLen); <br>} <br>lOffset += cbStringLen; <br> <br>cbStringLen = *(ULONG *)(pByte + lOffset); <br>lOffset +=sizeof(ULONG); <br>m_sPath2 = NULL; <br>if (cbStringLen) <br>{ <br>p2  = new CHAR[cbStringLen]; <br>memset(p2, NULL, cbStringLen); <br>memcpy(p2, (LPCSTR)(pByte + lOffset), cbStringLen); <br>} <br>lOffset += cbStringLen; <br>_ASSERTE(lOffset == cbByte); <br> <br>#ifdef _UNICODE <br>USES_CONVERSION; <br>m_sPath1 = new WCHAR[lstrlenA(p1)+1]; <br>*m_sPath1 = NULL; <br>lstrcpy(m_sPath1, A2W(p1)); <br>delete [] p1; <br> <br>m_sPath2 = new WCHAR[lstrlenA(p2)+1]; <br>*m_sPath2 = NULL; <br>lstrcpy(m_sPath2, A2W(p2)); <br>delete [] p2; <br>#else <br>m_sPath1 = p1; <br>m_sPath2 = p2; <br>#endif <br>return S_OK; <br> <br>} <br>//----------------------------------------------------------------------------- <br>// CActionList Implementation: <br>// Method implementations for the CActionList class. <br>//----------------------------------------------------------------------------- <br> <br> <br>CActionList::CActionList (void) <br>{ <br> <br>} // CActionList::CActionList <br> <br> <br>CActionList::~CActionList (void) <br>{ <br>CleanupAction (); <br> <br>} // CActionList::~CActionList <br> <br>// <br>//if bCommit == TRUE then we check to see if we have  <br>//a temp file in the recovery directory, and if we do <br>//we delete it <br>// <br>void CActionList::CleanupAction (BOOL bCommit /* = FALSE */) <br>{ <br>// Iterate through the list and recover storage for list items. <br>while (!empty()) <br>{ <br>// Remove the first item and reclaim storage for action. <br>RemoveAction (bCommit); <br>} // while -- end traversal of action list. <br>}// CActionList::CleanupAction <br> <br>BOOL CActionList::PushAction (LOG_RM_COMMAND rmCommand,FILE_OPERATION eFileOp, TCHAR *pszParm1,TCHAR *pszParm2) <br>{ <br>CAction*pAction = new CAction(rmCommand, eFileOp, pszParm1, pszParm2); <br> <br>_ASSERTE (0 != pAction); <br>if (0 == pAction) <br>{ <br>return FALSE; <br>} // if <br> <br>insert(begin(), pAction); <br> <br>return TRUE; <br> <br>} // CActionList::PushAction <br> <br> <br>BOOL CActionList::PushAction(CAction * pAction) <br>{ <br>_ASSERTE (0 != pAction); <br>if (0 == pAction) <br>{ <br>return FALSE; <br>} // if <br>  <br>insert(begin(), pAction); <br>return TRUE; <br> <br> <br>} <br> <br>// <br>//returns a pointer to the first element in the list <br>// <br>BOOL CActionList::PeekAction (CAction ** pprmAction) <br>{ <br>if (empty()) <br>return FALSE; <br> <br>CAction*prmAction = NULL; <br>*pprmAction = front(); <br>return TRUE; <br>} // CActionList::GetAction <br> <br> <br>// <br>//if bCommit is true, we delete any temporary files <br>//created during the tx (the only temp file that will <br>//still be around are files that were replaced during <br>//a copy <br>// <br>BOOL CActionList::RemoveAction (BOOL bCommit /* = FALSE */) <br>{ <br>if (empty()) <br>return FALSE; <br> <br>CAction*pAction; <br>PeekAction(&amp;pAction); // get the pointer <br> <br>// if we committed the tx, then we need to remove <br>// the recover file, if it exists <br>if (bCommit) <br>{ <br>if (pAction -&gt; m_eFileOp == RM_DELETE) <br>{ <br>pAction -&gt; ReleaseLock(); <br>// delete the recover file <br>DeleteFile(pAction -&gt; m_pszLockedFile); <br>} <br> <br>} <br>delete pAction; <br>pAction = 0; <br>// remove it from the list <br>pop_front(); <br>return TRUE; <br>} // CActionList::RemoveAction <br> <br> <br> <br>BOOL CActionList::PopAction (CAction&amp; rmAction) <br>{ <br>if (empty()) <br>return FALSE; <br>// <br>//CODEREVIEW: <br>//is this a correct dereference? <br>// <br>rmAction  = *front(); <br>pop_front(); <br>return TRUE; <br>} // CActionList::PopAction <br> <br> <br> <br>void CActionList::ResetActions (CActionList *actionList) <br>{ <br>// List of actions not empty. <br>ACTIONLIST::iterator item; <br>CAction * pAction; <br>for (item = begin(); item != end(); ++item) <br>{ <br>pAction = *item; <br>delete pAction; <br>} <br> <br>clear(); <br>// Set the current action list to the actionList <br>Clone (actionList); <br> <br>} // CActionList::ResetActions() <br> <br>// <br>//iterate through the list of actions <br>//and copy the CAction* to the local list <br>// <br>void CActionList::Clone (CActionList * pList) <br>{ <br> if (!pList) <br> return; <br> <br> if (pList -&gt; empty()) <br> return; <br> <br> ACTIONLIST::iterator item; <br> for (item=pList -&gt; begin();item != pList -&gt; end(); ++item) <br> { <br>push_back(*item); // mainttain the order <br> } <br> <br> <br>} // CActionList::Clone <br> <br> <br>//--------------------------------------------------------------------- <br>// End of $Workfile: ACTION.CPP $ <br>//--------------------------------------------------------------------- <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
