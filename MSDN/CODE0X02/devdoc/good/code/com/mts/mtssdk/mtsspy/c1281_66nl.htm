<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MTSSPY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1281"></a>MTSSPY.CPP</h2>
<pre><code>// MtsSpy.cpp : Implementation of WinMain <br> <br> <br>// Note: Proxy/Stub Information <br>//To build a separate proxy/stub DLL,  <br>//run nmake -f MtsSpyps.mk in the project directory. <br> <br>#include "stdafx.h" <br>#include "resource.h" <br>#include "initguid.h" <br>#include "MtsSpy.h" <br>#include "MtsSpyCtl.h" <br>#include "MtsSpyCtl_i.c" <br>#include "MtsSpy_i.c" <br>#include "SpyCon.h" <br> <br> <br>LONG CExeModule::Unlock() <br>{ <br>LONG l = CComModule::Unlock(); <br>if (l == 0) <br>{ <br>#if _WIN32_WINNT &gt;= 0x0400 <br>if (CoSuspendClassObjects() == S_OK) <br>PostThreadMessage(dwThreadID, WM_QUIT, 0, 0); <br>#else <br>PostThreadMessage(dwThreadID, WM_QUIT, 0, 0); <br>#endif <br>} <br>return l; <br>} <br> <br>CExeModule _Module; <br> <br>BEGIN_OBJECT_MAP(ObjectMap) <br>OBJECT_ENTRY(CLSID_SpyCon, CSpyCon) <br>END_OBJECT_MAP() <br> <br> <br>LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2) <br>{ <br>while (*p1 != NULL) <br>{ <br>LPCTSTR p = p2; <br>while (*p != NULL) <br>{ <br>if (*p1 == *p++) <br>return p1+1; <br>} <br>p1++; <br>} <br>return NULL; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,  <br>HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/) <br>{ <br>lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT <br>HRESULT hRes = CoInitialize(NULL); <br>//  If you are running on NT 4.0 or higher you can use the following call <br>//instead to make the EXE free threaded. <br>//  This means that calls come in on a random RPC thread <br>//HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>_ASSERTE(SUCCEEDED(hRes)); <br>_Module.Init(ObjectMap, hInstance); <br>_Module.dwThreadID = GetCurrentThreadId(); <br>TCHAR szTokens[] = _T("-/"); <br> <br>int nRet = 0; <br>BOOL bRun = TRUE; <br>LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens); <br>while (lpszToken != NULL) <br>{ <br>if (lstrcmpi(lpszToken, _T("UnregServer"))==0) <br>{ <br>_Module.UpdateRegistryFromResource(IDR_MtsSpy, FALSE); <br>nRet = _Module.UnregisterServer(); <br>bRun = FALSE; <br>break; <br>} <br>if (lstrcmpi(lpszToken, _T("RegServer"))==0) <br>{ <br>_Module.UpdateRegistryFromResource(IDR_MtsSpy, TRUE); <br>nRet = _Module.RegisterServer(TRUE); <br>bRun = FALSE; <br>break; <br>} <br>lpszToken = FindOneOf(lpszToken, szTokens); <br>} <br> <br>if (bRun) <br>{ <br>hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,  <br>REGCLS_MULTIPLEUSE); <br>_ASSERTE(SUCCEEDED(hRes)); <br> <br>ISpyCon * pApp; <br>CoCreateInstance(CLSID_SpyCon, NULL, CLSCTX_INPROC_SERVER, IID_ISpyCon, (void**)&amp;pApp); <br>if (pApp) <br>{ <br>pApp-&gt;Run(); <br>MSG msg; <br>while (GetMessage(&amp;msg, 0, 0, 0)) <br>{ <br>TranslateMessage(&amp;msg); <br>DispatchMessage(&amp;msg); <br>} <br> <br>ULONG ul = pApp -&gt; Release(); <br>_ASSERTE(ul==0); <br>} <br>else <br>_ASSERTE(0); <br> <br>_Module.RevokeClassObjects(); <br>} <br> <br>CoUninitialize(); <br>return nRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
