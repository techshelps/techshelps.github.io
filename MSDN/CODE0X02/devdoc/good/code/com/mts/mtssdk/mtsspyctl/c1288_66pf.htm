<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MTSSPY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1293"></a>MTSSPY.CPP</h2>
<pre><code>// MtsSpy.cpp : Implementation of CMtsSpy <br>#include "stdafx.h" <br>#include "MtsSpyCtl.h" <br>#include "MtsAudit.h" <br>#include "MtsSpy.h" <br>#include "mtsevents.h" <br>#include "MtsSink.h" <br>#include "objsink.h" <br>#include "PackageSink.h" <br>#include "PackageInfo.h" <br>#include "TxSink.h" <br>#include "resourcesink.h" <br>#include "selecteventsdlg.h" <br>#include "commdlg.h" <br>#include &lt;time.h&gt; <br>#include "shellapi.h" <br>#include "MtsGrp.h" <br> <br> <br>LONGLONG PerformanceFrequency = 0; <br> <br>// <br>//for some reason this define isn't being included <br>// <br> <br>const GUID CLSID_StockFontPage = {0x7ebdaae0, 0x8120, 0x11cf, { 0x89, 0x9f, 0x0, 0xaa, 0x0, 0x68, 0x8b, 0x10}};         <br> <br> <br>// <br>//  given a GUID, return its string representation <br>// <br>CComBSTR GuidToBstr(REFGUID guid) <br>{ <br>    CComBSTR b(40, L""); <br>    int nRet = StringFromGUID2(guid, b.m_str, 40); <br>    _ASSERTE(nRet); <br>    return b; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// CMtsSpy <br> <br>#define MAX_MSG_LENGTH (1024*sizeof(TCHAR)) <br>static LPTSTR sColNames[] = {_TEXT("Count"),_TEXT("Event"),_TEXT("Tick Count"), <br>_TEXT("Package"),_TEXT("Parameter"),TEXT("Value")}; <br> <br> <br>HRESULT CMtsSpy::OnDrawAdvanced(ATL_DRAWINFO&amp; di) <br>{ <br>return S_OK; <br>} <br>LRESULT CMtsSpy::OnRButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>HMENU hMenu = LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_SPYMENU)); <br>if (!hMenu) <br>{ <br>_ASSERTE(0); <br>return 0; <br>} <br>POINT local; <br>local.x = LOWORD(lParam); <br>local.y = HIWORD(lParam); <br>    ClientToScreen(&amp;local); <br>HMENU hPopup = GetSubMenu(hMenu, 0); <br>    _ASSERTE(hPopup != NULL); <br>TrackPopupMenu(hPopup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, local.x, local.y, NULL, m_hWndList, NULL);  <br> <br>return 0; <br>} <br> <br>LRESULT CMtsSpy::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>RECT rc; <br>GetWindowRect(&amp;rc); <br>rc.right -= rc.left; <br>rc.bottom -= rc.top; <br>rc.top = rc.left = 0; <br>DWORD dwStyle = WS_VISIBLE|WS_CHILD|LVS_REPORT|LVS_SINGLESEL|WS_BORDER; <br>if (!m_hWndList)  <br>m_hWndList = m_ctlSysListView32.Create(m_hWnd, rc, _T(""), dwStyle); <br> <br>_ASSERTE(m_hWndList); <br>put_ShowGridLines(m_bShowGridLines); <br> <br>// <br>//we always want the list to be Full Row Select -- <br>//note: this only works if the user has IE 3.0 installed <br>// <br>dwStyle = ListView_GetExtendedListViewStyle(m_hWndList); <br>dwStyle |= LVS_EX_FULLROWSELECT; <br>ListView_SetExtendedListViewStyle(m_hWndList, dwStyle); <br> <br>// <br>//create the columns in our list  <br>// <br>LV_COLUMN col; <br>memset(&amp;col,NULL, sizeof(col)); <br>col.mask = LVCF_TEXT|LVCF_WIDTH; <br>col.fmt = LVCFMT_LEFT; <br>int i; <br>for (i=0;i&lt;NUMBER_COLUMNS;i++) <br>{ <br>col.cx = m_nWidth[i]; <br>col.pszText = sColNames[i]; <br>col.cchTextMax  = lstrlen(col.pszText); <br>ListView_InsertColumn(m_hWndList, i, &amp;col); <br>} <br> <br>    QueryPerformanceFrequency((LARGE_INTEGER *)&amp;PerformanceFrequency); <br> <br>if (m_hFont) <br>{ <br>// this is set if the container app has set our properties using the property bag <br>::SendMessage(m_hWndList, WM_SETFONT, (WPARAM)m_hFont, MAKELPARAM(TRUE,0)); <br>} <br> <br>return 0; <br>} <br> <br> <br>// <br>//update the UI in menus <br>// <br>LRESULT CMtsSpy::OnInitMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>HMENU hMenu = (HMENU)wParam; <br>CComBSTR temp = "Log to File "; <br>if (m_sLogFile.Length() &gt; 5) <br>temp += m_sLogFile; <br>else <br>temp += "..."; <br> <br>USES_CONVERSION; <br>ModifyMenu(hMenu, ID_LOG, MF_BYCOMMAND|MF_STRING, ID_LOG, OLE2T(temp)); <br>CheckMenuItem(hMenu, ID_LOG,  m_bLogToFile ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>CheckMenuItem(hMenu, ID_OPTIONS_GRID_LINES,  m_bShowGridLines ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>CheckMenuItem(hMenu, ID_SHOW_ON_SCREEN,  m_bShowOnScreen ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br>CheckMenuItem(hMenu, ID_AUDIT,  m_bAudit ? MF_BYCOMMAND|MF_CHECKED : MF_BYCOMMAND|MF_UNCHECKED);  <br> <br>m_hMenuDebug = GetSubMenu(hMenu, 5); <br>_ASSERTE(m_hMenuDebug); <br>AddRunningAspsToDebugMenu(m_hMenuDebug); <br> <br>return 0; <br>} <br> <br> <br>// <br>//sets a glog to log to file <br>//if the user hasn't chosen a log file, show the common dialog to allow them to select one <br>// <br>LRESULT CMtsSpy::OnLogToFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br> <br>m_bLogToFile = 1 - m_bLogToFile; <br>if (m_bLogToFile) <br>{ <br>if (m_sLogFile.Length() == 0) <br>{ <br>BOOL bHandled = TRUE; <br>OnChooseLogFile(0,0,0,bHandled); <br>if (m_sLogFile.Length() == 0) <br>return 0; <br>} <br>m_hFile = CreateFile(m_sLogFile, GENERIC_WRITE, <br>0, (LPSECURITY_ATTRIBUTES) NULL, <br>OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <br>(HANDLE) NULL); <br> <br>if (!m_hFile) <br>{ <br>m_bLogToFile = FALSE; <br>return 0; <br>} <br> <br>} <br>else <br>{ <br>if (m_hFile) <br>{ <br>CloseHandle(m_hFile); <br>m_hFile = NULL; <br>} <br> <br>} <br> <br>return 0; <br>} <br>// <br>//User wants to choose a log file -- show the common dialog <br>// <br>LRESULT CMtsSpy::OnChooseLogFile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>USES_CONVERSION; <br>OPENFILENAME OpenFileName; <br>TCHAR         szFile[MAX_PATH]; <br>memset(szFile, NULL, MAX_PATH * sizeof(TCHAR)); <br>if (m_sLogFile.Length() &gt; 2) <br>lstrcpy(szFile, OLE2T(m_sLogFile.m_str)); <br>else <br>lstrcpy(szFile, _T("MTSSpy.Log")); <br> <br>    // Fill in the OPENFILENAME structure to support a template and hook. <br>OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = m_hWndList; <br>    OpenFileName.hInstance         = _Module.GetModuleInstance( ); <br>    OpenFileName.lpstrFilter       = _T("TAB seperated Files (*.log)\0*.log\0CSV Files (*.csv)\0*.csv\0"); <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = 0; <br>    OpenFileName.nFilterIndex      = 0; <br>    OpenFileName.lpstrFile          = szFile; <br>    OpenFileName.nMaxFile          = sizeof(szFile); <br>    OpenFileName.lpstrFileTitle    = NULL; <br>    OpenFileName.nMaxFileTitle     = 0; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = _T("Choose Log File"); <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL; <br>    OpenFileName.lCustData         = 0; <br>OpenFileName.lpfnHook    = NULL; <br>OpenFileName.lpTemplateName    = NULL; <br>    OpenFileName.Flags             = OFN_EXPLORER | OFN_HIDEREADONLY |OFN_NOREADONLYRETURN |OFN_CREATEPROMPT; <br> <br>// Call the common dialog function. <br>    if (GetSaveFileName(&amp;OpenFileName)) <br>    { <br>m_sLogFile = OpenFileName.lpstrFile; <br>if (lstrcmpi(OpenFileName.lpstrFile + OpenFileName.nFileExtension, _T("csv")) == 0) <br>m_bCSV = TRUE; <br> <br>} <br>  <br>return 0; <br> <br>} <br> <br> <br>// <br>//show/hide gridlines in the list <br>// <br>//NOTE:  This will only work if the user has installed IE 3.0 or greater <br>// <br>LRESULT CMtsSpy::OnToggleGridLines(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>m_bShowGridLines = 1 - m_bShowGridLines; <br> <br>DWORD dwStyle = ListView_GetExtendedListViewStyle(m_hWndList); <br>(m_bShowGridLines) ? dwStyle |= LVS_EX_GRIDLINES :  <br> dwStyle &amp;= ~LVS_EX_GRIDLINES; <br> <br>ListView_SetExtendedListViewStyle(m_hWndList, dwStyle); <br> <br>return 0; <br>} <br> <br>// <br>//enable/disable auditing <br>// <br>// <br>LRESULT CMtsSpy::OnToggleAudit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>m_bAudit = 1 - m_bAudit; <br>HRESULT hr = EnableAudit(m_bAudit); <br>if (hr != S_OK) <br>m_bAudit = FALSE; <br>return 0; <br>} <br> <br> <br>LRESULT CMtsSpy::OnToggleShowOnScreen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>m_bShowOnScreen = 1-m_bShowOnScreen; <br>return 0; <br> <br>} <br> <br>// <br>//show the standard Shell About box <br>// <br>LRESULT CMtsSpy::OnAbout(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>HICON hIcon =  LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_MAIN)); <br> <br>ShellAbout(m_hWnd, _T("MTS Spy"), _T("Version 1.00"), hIcon); <br>return 0; <br>} <br> <br>// <br>//clear the list box <br>// <br>LRESULT CMtsSpy::OnClear(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>ListView_DeleteAllItems(m_hWndList); <br>m_cEvents = 0; <br>return 0; <br>} <br> <br> <br>// <br>//save the items in the list box to the log file <br>// <br>LRESULT CMtsSpy::OnSave(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>USES_CONVERSION; <br>OPENFILENAME OpenFileName; <br>TCHAR         szFile[MAX_PATH]; <br>memset(szFile, NULL, MAX_PATH * sizeof(TCHAR)); <br>if (m_sLogFile.Length() &gt; 2) <br>lstrcpy(szFile, OLE2T(m_sLogFile.m_str)); <br>else <br>lstrcpy(szFile, _T("MTSSpy.Log")); <br> <br>OpenFileName.lStructSize       = sizeof(OPENFILENAME); <br>    OpenFileName.hwndOwner         = m_hWndList; <br>    OpenFileName.hInstance         = _Module.GetModuleInstance( ); <br>    OpenFileName.lpstrFilter       = NULL; <br>    OpenFileName.lpstrCustomFilter = NULL; <br>    OpenFileName.nMaxCustFilter    = 0; <br>    OpenFileName.nFilterIndex      = 0; <br>    OpenFileName.lpstrFile          = szFile; <br>    OpenFileName.nMaxFile          = sizeof(szFile); <br>    OpenFileName.lpstrFileTitle    = NULL; <br>    OpenFileName.nMaxFileTitle     = 0; <br>    OpenFileName.lpstrInitialDir   = NULL; <br>    OpenFileName.lpstrTitle        = _T("Log ToFile"); <br>    OpenFileName.nFileOffset       = 0; <br>    OpenFileName.nFileExtension    = 0; <br>    OpenFileName.lpstrDefExt       = NULL; <br>    OpenFileName.lCustData         = 0; <br>OpenFileName.lpfnHook    = NULL; <br>OpenFileName.lpTemplateName    = NULL; <br>    OpenFileName.Flags             = OFN_EXPLORER | OFN_HIDEREADONLY |OFN_NOREADONLYRETURN; <br> <br>// Call the common dialog function. <br>    if (GetSaveFileName(&amp;OpenFileName)) <br>    { <br> <br>FILE* f = _tfopen(OpenFileName.lpstrFile, _T("a+")); <br>if (f) <br>{ <br>int nCount = ListView_GetItemCount(m_hWndList); <br>int i, j; <br>TCHAR buf[MAX_MSG_LENGTH];  <br>for (i=0; i&lt;nCount; i++) <br>{ <br>for (j=0; j &lt; 4; j++) <br>{ <br>ListView_GetItemText(m_hWndList, i, j, buf, MAX_MSG_LENGTH); <br>_ftprintf(f, _T("%s\t"),buf); <br>} <br>while ( i &lt; nCount - 1) <br>{ <br>i++; // move to next column <br> <br>// now get the name/value pairs <br>ListView_GetItemText(m_hWndList, i, 4, buf, MAX_MSG_LENGTH); <br>if (*buf) <br>{ <br> <br>_ftprintf(f, _T("\n\t\t\t\t%s\t"), buf); <br>ListView_GetItemText(m_hWndList, i, 5, buf, MAX_MSG_LENGTH); <br>_ftprintf(f, _T("%s"),buf); <br>} <br>else <br>{ <br>i--; <br>_ftprintf(f, _T("\n"), NULL); <br>break; <br>} <br>} <br>} <br> <br>fclose(f); <br>} <br> <br> <br>} <br>  <br>return 0; <br> <br> <br>} <br> <br>// <br>//given the index to the list, we return TRUE if the index <br>//should scroll -- this occurs when the user is looking <br>//at the last element in the list.  If they have scrolled <br>//up to look at a previous element in the list, then we <br>//don't scroll when an event is added <br>// <br>BOOL CMtsSpy::ShouldScroll(int nIndex) <br>{ <br>BOOL bRet = FALSE; <br>int nCountPage = ListView_GetCountPerPage(m_hWndList); <br>int nTopIndex = ListView_GetTopIndex(m_hWndList); <br>if (nTopIndex + nCountPage&gt;= nIndex) <br>bRet = TRUE; <br>return bRet; <br>} <br> <br>// <br>//disconnect &amp; destroy all sinks associated with the given package <br>// <br>HRESULT CMtsSpy::ShutdownPackage(LPCOLESTR sPackageName) <br>{ <br> <br>USES_CONVERSION; <br>CPackageInfo * pInfo = m_map[W2A(sPackageName)]; <br>if (!pInfo) <br>{ <br>_ASSERTE(0); // we should never get this unless we have a sink for (at least) the Package events <br>return E_FAIL; <br>} <br> <br>int nElementsRemoved = m_map.erase(W2A(sPackageName)); <br>_ASSERTE(nElementsRemoved == 1); <br>delete pInfo; <br>return S_OK; <br>} <br> <br>// <br>//this method is called by all of the sinks to add an item to the list box <br>// <br>BOOL CMtsSpy::AddEventToList(LONGLONG perfCount, LPCOLESTR sEvent, LPCOLESTR sPackage) <br>{ <br>    long TickCount = 0; <br>    if (PerformanceFrequency != 0) <br>        TickCount = (long)((1000 * perfCount) / PerformanceFrequency); <br> <br>BOOL bRet; <br>if (m_bLogToFile) <br>{ <br>TCHAR sSep[2]; <br>ZeroMemory(sSep,2 * sizeof(TCHAR)); <br>(m_bCSV) ? lstrcat(sSep, _T(",")) : lstrcat(sSep, _T("\t")); <br>sSep[1] = NULL; <br>_ASSERTE(m_hFile); <br>TCHAR sBuf[MAX_MSG_LENGTH]; <br>ZeroMemory(sBuf, MAX_MSG_LENGTH*sizeof(TCHAR)); <br> <br>wsprintf(sBuf, _T("%s%s%d%s%s\n"), sEvent, sSep, TickCount, sSep, sPackage); <br> <br>if (m_hFile) <br>{ <br> <br>DWORD cbWritten; <br>bRet = WriteFile(m_hFile, sBuf, lstrlen(sBuf) * sizeof(TCHAR), &amp;cbWritten, NULL);  <br> <br>} <br>} <br>if (m_bShowOnScreen) <br>{ <br>int nCount = ListView_GetItemCount(m_hWndList);  <br>LV_ITEM item; <br>TCHAR sz[8]; <br>wsprintf(sz,_TEXT("%ld"), m_cEvents++); <br>memset(&amp;item, NULL, sizeof(item)); <br>item.mask = LVIF_TEXT; <br>item.iItem = nCount; <br>item.pszText = sz; <br>item.cchTextMax = lstrlen(sz); <br> <br>ListView_InsertItem(m_hWndList, &amp;item); <br>ListView_SetItemText(m_hWndList, nCount, 1, (LPWSTR)sEvent); <br> <br>TCHAR szTick[16]; <br>wsprintf(szTick, _T("%ld"), TickCount); <br>ListView_SetItemText(m_hWndList, nCount, 2, szTick); <br>ListView_SetItemText(m_hWndList, nCount, 3, (LPWSTR)sPackage); <br>if (ShouldScroll(nCount)) <br>ListView_EnsureVisible(m_hWndList, nCount, FALSE); <br>} <br>return TRUE; <br>} <br>// <br>//this method is called by all the sinks to add a Named/Value pair to the  <br>//list <br>// <br>BOOL CMtsSpy::AddParamValueToList(LPCOLESTR sParamName, LPCOLESTR sValue) <br>{ <br>BOOL bRet; <br>if (m_bLogToFile) <br>{ <br>TCHAR sSep[2]; <br>ZeroMemory(sSep,2 * sizeof(TCHAR)); <br>(m_bCSV) ? lstrcat(sSep, _T(",")) : lstrcat(sSep, _T("\t")); <br>sSep[1] = NULL; <br>_ASSERTE(m_hFile); <br>TCHAR sBuf[MAX_MSG_LENGTH]; <br>ZeroMemory(sBuf, MAX_MSG_LENGTH*sizeof(TCHAR)); <br>wsprintf(sBuf, _T("%s%s%s%s%s%s\n"), sSep, sSep, sSep, sParamName,sSep, sValue); <br>if (m_hFile) <br>{ <br> <br>DWORD cbWritten; <br>bRet = WriteFile(m_hFile, sBuf, lstrlen(sBuf) * sizeof(TCHAR), &amp;cbWritten, NULL);  <br>} <br>} <br>if (m_bShowOnScreen) <br>{ <br>int nCount = ListView_GetItemCount(m_hWndList);  <br>LV_ITEM item; <br>item.mask = LVIF_TEXT; <br>item.iItem = nCount; <br>item.pszText = _T(""); <br>item.cchTextMax = 1; <br>item.iSubItem = 0; <br>int nItem; <br>nItem = ListView_InsertItem(m_hWndList, &amp;item); <br>ListView_SetItemText(m_hWndList, nItem, 4, (LPWSTR)sParamName); <br>ListView_SetItemText(m_hWndList, nItem, 5, (LPWSTR)sValue); <br>if (ShouldScroll(nCount)) <br>ListView_EnsureVisible(m_hWndList, nItem, FALSE); <br>} <br> <br> <br>return TRUE; <br>} <br> <br>// <br>//show the select packages dialog <br>// <br>LRESULT CMtsSpy::OnSelectPackages(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>CSelectEventsDlg dlg(&amp;m_map, this); <br>dlg.DoModal(); <br>return 0; <br>} <br> <br> <br>LRESULT CMtsSpy::OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&amp; bHandled) <br>{ <br>bHandled = FALSE; // continue processing <br> <br>// <br>//clean up our package information <br>// <br>MapStringToPackageInfo::iterator iter; <br>CPackageInfo * pInfo; <br>for (iter = m_map.begin(); iter != m_map.end(); ++iter) <br>{ <br> <br>pInfo = (*iter).second; <br>delete pInfo; <br>} <br>m_map.clear(); <br>if (m_hFont) <br>{ <br>DeleteObject(m_hFont); <br>m_hFont = NULL; <br>} <br> <br>m_bLogToFile = FALSE; <br>if (m_hFile) <br>{ <br>CloseHandle(m_hFile); <br>m_hFile = NULL; <br>} <br> <br>m_cEvents = 0; <br>m_bShowGridLines = TRUE; <br>return 0; <br>} <br>// <br>//show only the ChooseFont property page <br>// <br>LRESULT CMtsSpy::OnChooseFont(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br>HRESULT hr = S_OK; <br>CComPtr&lt;IUnknown&gt; pUnk; <br>ControlQueryInterface(IID_IUnknown, (void**)&amp;pUnk); <br>_ASSERTE(pUnk != NULL); <br>LPOLESTR szTitle = _T("MTS Spy - Choose Font"); <br>hr = OleCreatePropertyFrame(m_hWnd, m_rcPos.top, m_rcPos.left, szTitle, <br>1, &amp;pUnk.p, 1, (GUID *)&amp;CLSID_StockFontPage, LOCALE_USER_DEFAULT, 0, 0); <br> <br>return 0; <br>} <br> <br>STDMETHODIMP CMtsSpy::get_LogFile(BSTR * pVal) <br>{ <br>*pVal = m_sLogFile.Copy(); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_LogFile(BSTR newVal) <br>{ <br> <br>HANDLE hTemp; <br>hTemp = CreateFile(newVal, GENERIC_WRITE, <br>0, (LPSECURITY_ATTRIBUTES) NULL, <br>OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <br>(HANDLE) NULL); <br> <br> <br>if (hTemp) <br>{ <br>if (m_hFile) <br>{ <br>CloseHandle(m_hFile); <br>} <br> <br>m_hFile = hTemp; <br>} <br>else <br>return E_INVALIDARG; <br> <br> <br>m_sLogFile = newVal; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::get_ShowGridLines(BOOL * pVal) <br>{ <br>*pVal = m_bShowGridLines; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_ShowGridLines(BOOL newVal) <br>{ <br> <br>m_bShowGridLines = newVal; <br>DWORD dwStyle = ListView_GetExtendedListViewStyle(m_hWndList); <br>(m_bShowGridLines) ? dwStyle |= LVS_EX_GRIDLINES :  <br> dwStyle &amp;= ~LVS_EX_GRIDLINES; <br> <br>ListView_SetExtendedListViewStyle(m_hWndList, dwStyle); <br>FireViewChange(); <br>return S_OK; <br>} <br> <br> <br>STDMETHODIMP CMtsSpy::get_Audit(BOOL * pVal) <br>{ <br>*pVal = m_bAudit; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_Audit(BOOL newVal) <br>{ <br> <br>m_bAudit = newVal; <br>EnableAudit(m_bAudit); <br>return S_OK; <br>} <br> <br> <br>STDMETHODIMP CMtsSpy::get_ColWidth(short nColumn, long * pVal) <br>{ <br>_ASSERTE(m_hWndList); <br>_ASSERTE(nColumn &gt;= 0 &amp;&amp; nColumn &lt;= NUMBER_COLUMNS); <br>*pVal = ListView_GetColumnWidth(m_hWndList, nColumn); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_ColWidth(short nColumn, long newVal) <br>{ <br>if (nColumn &gt;= NUMBER_COLUMNS) <br>return E_INVALIDARG; <br> <br>m_nWidth[nColumn] = newVal; <br>ListView_SetColumnWidth(m_hWndList, nColumn, newVal); <br>FireViewChange(); <br>return S_OK; <br>} <br> <br> <br>HRESULT CMtsSpy::IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap) <br>{ <br> <br>ULONG cbRead; <br> <br>// read in the version <br>UINT nVersion; <br>pStm -&gt; Read((void *)&amp;nVersion, sizeof(UINT), &amp;cbRead); <br>if (nVersion != 3) <br>{ <br>::MessageBox(m_hWndList, _T("The saved information is from a different version of the control.\n\nThe saved state will have to be discarded."), _T("MTS Spy"), MB_ICONINFORMATION); <br>return S_OK; <br>} <br> <br>// get log file size <br>long lLen; <br>pStm -&gt; Read((void *)&amp;lLen, sizeof(long), &amp;cbRead); <br> <br>// read in the chars for the log name <br>char * pLog = new char[lLen+1]; <br>ZeroMemory(pLog, lLen+1); <br>pStm -&gt; Read((void*)pLog, lLen, &amp;cbRead); <br> <br>m_sLogFile = pLog; <br>delete [] pLog; <br> <br>// gridlines <br>pStm -&gt; Read((void *)&amp;m_bShowGridLines, sizeof(BOOL),&amp;cbRead); <br>put_ShowGridLines(m_bShowGridLines); <br> <br>// show on screen <br>pStm -&gt; Read((void *)&amp;m_bShowOnScreen, sizeof(BOOL),&amp;cbRead); <br>put_ShowOnScreen(m_bShowOnScreen); <br> <br>// log to file <br>pStm -&gt; Read((void *)&amp;m_bLogToFile, sizeof(BOOL),&amp;cbRead); <br>put_LogToFile(m_bLogToFile); <br> <br>// csv files <br>pStm -&gt; Read((void *)&amp;m_bCSV, sizeof(BOOL), &amp;cbRead); <br> <br>// csv files <br>pStm -&gt; Read((void *)&amp;m_bAudit, sizeof(BOOL), &amp;cbRead); <br>EnableAudit(m_bAudit); <br> <br>// read the col widths <br>int i; <br>long nWidth; <br>for (i=0;i&lt;NUMBER_COLUMNS;i++) <br>{ <br>pStm -&gt; Read((void *)&amp;nWidth, sizeof(long), &amp;cbRead); <br>put_ColWidth(i, nWidth); <br>} <br> <br>BOOL bCustomFont = FALSE; <br>pStm -&gt; Read((void *)&amp;bCustomFont, sizeof(BOOL),&amp;cbRead); <br>if (bCustomFont) <br>{ <br>if (!m_pFont) <br>{ <br>//create an IFontDisp <br>HRESULT hr= CoCreateInstance(CLSID_StdFont, NULL, CLSCTX_ALL, IID_IFontDisp, (void **)&amp;m_pFont); <br>_ASSERTE(SUCCEEDED(hr)); <br>} <br>if (m_pFont) <br>{ <br>IPersistStream * pFontSt = NULL; <br>m_pFont -&gt; QueryInterface(IID_IPersistStream, (void **)&amp;pFontSt); <br>pFontSt -&gt; Load(pStm); <br>pFontSt -&gt; Release(); <br>if (m_hFont) // should I tell the list that I deleted its font? <br>DeleteObject(m_hFont); <br>IFont * pFont = NULL; <br>m_pFont -&gt; QueryInterface(IID_IFont, (void **)&amp;pFont); <br>_ASSERTE(pFont); <br>m_hFont = CreateHFontFromIFont(pFont); <br>pFont -&gt; Release(); <br>} <br>} <br> <br> <br>return S_OK; <br>} <br>HRESULT CMtsSpy::IPersistStreamInit_Save(LPSTREAM pStm, BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap) <br>{ <br>_ASSERTE(this); <br>_ASSERTE(m_hWndList); <br> <br>ULONG cbWritten = 0; <br>// write a version <br>UINT nVersion  = 3; <br>pStm -&gt; Write((void *)&amp;nVersion, sizeof(UINT), &amp;cbWritten); <br> <br>// write the log file size <br>long nChars = m_sLogFile.Length(); <br>pStm -&gt; Write((void *)&amp;nChars, sizeof(long), &amp;cbWritten); <br>_ASSERTE(cbWritten == sizeof(long)); <br> <br>// write the log file name (in ANSI!) <br>USES_CONVERSION; <br>char * sFile = W2A((BSTR)m_sLogFile); <br>pStm -&gt; Write((void *)sFile, m_sLogFile.Length(), &amp;cbWritten); <br> <br>// write the BOOL if gridlines should be shown <br>pStm -&gt; Write((void *)&amp;m_bShowGridLines, sizeof(BOOL), &amp;cbWritten); <br> <br>// write the BOOL if the user wants to see the messages  <br>pStm -&gt; Write((void *)&amp;m_bShowOnScreen, sizeof(BOOL), &amp;cbWritten); <br> <br>// write the BOOL if the user wants to log the messages <br>pStm -&gt; Write((void *)&amp;m_bLogToFile, sizeof(BOOL), &amp;cbWritten); <br> <br>// write the BOOL if we have CSV files <br>pStm -&gt; Write((void *)&amp;m_bCSV, sizeof(BOOL), &amp;cbWritten); <br> <br>// write the BOOL if Auditing is enabled <br>pStm -&gt; Write((void *)&amp;m_bAudit, sizeof(BOOL), &amp;cbWritten); <br> <br>// write the col widths <br>int i; <br>long nWidth; <br>for (i=0;i&lt;NUMBER_COLUMNS;i++) <br>{ <br>get_ColWidth(i, &amp;nWidth); <br>_ASSERTE(nWidth); <br>pStm -&gt; Write((void *)&amp;nWidth, sizeof(long), &amp;cbWritten); <br>} <br> <br>// ask the font to persist itself in the stream <br>BOOL bCustomFont; <br>if (m_pFont) <br>{ <br>bCustomFont = TRUE; <br>pStm -&gt; Write((void *)&amp;bCustomFont, sizeof(BOOL), &amp;cbWritten); <br>IPersistStream * pSt = NULL; <br>m_pFont -&gt; QueryInterface(IID_IPersistStream, (void **)&amp;pSt); <br>_ASSERTE(pSt); <br>pSt -&gt; Save(pStm, FALSE); <br>pSt -&gt; Release(); <br>} <br>else <br>{ <br>bCustomFont = FALSE; <br>pStm -&gt; Write((void *)&amp;bCustomFont, sizeof(BOOL), &amp;cbWritten); <br>} <br> <br>return S_OK; <br>} <br> <br> <br> <br>HRESULT CMtsSpy::Close( DWORD dwSaveOption ) <br>{ <br>return IOleObject_Close(dwSaveOption); <br>} <br> <br>HFONT CMtsSpy::CreateHFontFromIFont(IFont * pFont) <br>{ <br> <br>_ASSERTE(pFont); <br>HFONT hFont; <br>LOGFONT lf; <br>ZeroMemory(&amp;lf, sizeof(lf)); <br>CComBSTR bstr; <br>pFont -&gt; get_Name(&amp;bstr); <br>lstrcpy(lf.lfFaceName, bstr.m_str); <br>CY cy; <br>pFont -&gt; get_Size(&amp;cy); <br>HDC hDC = ::GetDC(NULL); <br>_ASSERTE(hDC); <br>long lCaps = GetDeviceCaps(hDC, LOGPIXELSY); <br>lf.lfHeight =  -MulDiv(cy.Hi, lCaps, 72);  <br>lf.lfHeight += -MulDiv(cy.Lo, lCaps, 720000);  <br>::ReleaseDC(NULL, hDC); <br>short sVal; <br>pFont -&gt; get_Weight(&amp;sVal); <br>lf.lfWeight  = sVal;  <br>BOOL bFlag; <br>pFont -&gt; get_Italic(&amp;bFlag); <br>lf.lfItalic = bFlag;  <br>pFont -&gt; get_Underline(&amp;bFlag); <br>lf.lfUnderline = bFlag;  <br>pFont -&gt; get_Strikethrough(&amp;bFlag); <br>lf.lfStrikeOut = bFlag;  <br>pFont -&gt; get_Charset(&amp;sVal); <br>lf.lfCharSet = sVal;  <br>hFont = CreateFontIndirect(&amp;lf); <br>return hFont; <br> <br>} <br> <br>STDMETHODIMP CMtsSpy::SelectPackages() <br>{ <br>BOOL bHandled; <br>OnSelectPackages(0,0,0,bHandled); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::SaveToFile() <br>{ <br> <br>BOOL bHandled; <br>OnSave(0,0,0,bHandled); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::ClearAllEvents() <br>{ <br> <br>BOOL bHandled; <br>OnClear(0,0,0,bHandled); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::About() <br>{ <br>BOOL bHandled; <br>OnAbout(0,0,0,bHandled); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::get_LogToFile(BOOL * pVal) <br>{ <br>*pVal = m_bLogToFile; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_LogToFile(BOOL newVal) <br>{ <br>m_bLogToFile = newVal; <br>if (m_bLogToFile) <br>{ <br>if (m_sLogFile.Length() == 0) <br>{ <br>BOOL bHandled = TRUE; <br>OnChooseLogFile(0,0,0,bHandled); <br>if (m_sLogFile.Length() == 0) <br>return 0; <br>} <br> <br>if (m_hFile) <br>{ <br>CloseHandle(m_hFile); <br>m_hFile = NULL; <br>} <br> <br>m_hFile = CreateFile(m_sLogFile, GENERIC_WRITE, <br>0, (LPSECURITY_ATTRIBUTES) NULL, <br>OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, <br>(HANDLE) NULL); <br> <br>if (!m_hFile) <br>{ <br>m_bLogToFile = FALSE; <br>return E_FAIL; <br>} <br> <br>} <br>else <br>{ <br>if (m_hFile) <br>{ <br>CloseHandle(m_hFile); <br>m_hFile = NULL; <br>} <br> <br>} <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::ChooseFont() <br>{ <br>BOOL bHandled; <br>OnChooseFont(0,0,0,bHandled); <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::get_ShowOnScreen(BOOL * pVal) <br>{ <br>*pVal = m_bShowOnScreen; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::put_ShowOnScreen(BOOL newVal) <br>{ <br>m_bShowOnScreen = newVal; <br>return S_OK; <br>} <br> <br>STDMETHODIMP CMtsSpy::ChooseLogFile(BSTR * sLogFileName, BOOL * bCanceled) <br>{ <br>*bCanceled = TRUE; <br>BOOL bHandled = TRUE; <br>OnChooseLogFile(0,0,0,bHandled); <br>if (m_sLogFile.Length() == 0) <br>{ <br>return S_OK; <br>} <br> <br>*sLogFileName = ::SysAllocString(m_sLogFile.m_str); <br>*bCanceled = FALSE; <br>return S_OK; <br>} <br>// <br>//loop through the ROT and add package names <br>//to the debug menu <br>// <br>BOOL CMtsSpy::AddRunningAspsToDebugMenu(HMENU hMenu) <br>{ <br> <br>// <br>//remove the &lt;No Running Packages&gt; menu item <br>// <br> <br>RemoveMenu(hMenu, 0, MF_BYPOSITION); <br> <br>HRESULT hr = E_FAIL; <br>IMtsGrp * pMtsGrp = NULL; <br>hr = CoCreateInstance (CLSID_MtsGrp, NULL, CLSCTX_ALL, IID_IMtsGrp, (void **)&amp;pMtsGrp); <br>if (!pMtsGrp) <br>{ <br>_ASSERTE(0); <br>return FALSE; <br>} <br> <br>long lPackages; <br>pMtsGrp -&gt; Refresh(); // its important to call this! <br>pMtsGrp -&gt; get_Count(&amp;lPackages); <br> <br>IUnknown * pUnk = NULL; <br>IMtsEvents * pEvents = NULL; <br>USES_CONVERSION; <br>long lPID; <br>TCHAR szBuf[128]; <br>for (int i=0; i&lt;lPackages; i++) <br>{ <br> <br>pMtsGrp -&gt; Item(i, &amp;pUnk); <br>_ASSERTE(pUnk); <br>pUnk -&gt; QueryInterface(IID_IMtsEvents, (void **)&amp;pEvents); <br>_ASSERTE(pEvents); <br>if (SUCCEEDED(hr)) <br>{ <br> <br>CComBSTR sName; <br>pEvents -&gt; get_PackageName(&amp;sName.m_str); <br>pEvents -&gt; GetProcessID(&amp;lPID); <br>ZeroMemory(szBuf, 128*sizeof(TCHAR)); <br>if (sName.m_str) <br>{ <br>wsprintf(szBuf, _T("%s - PID: %ld"), sName.m_str, lPID); <br>int nRet = InsertMenu(hMenu, -1, MF_BYPOSITION|MF_STRING, ID_DEBUG_BEGIN + i, szBuf); <br>} <br>SafeRelease(pEvents); <br> <br>} <br> <br>SafeRelease(pEvents); <br>SafeRelease(pUnk); <br>} <br> <br>SafeRelease(pMtsGrp); <br>return TRUE; <br>} <br> <br>// <br>//user wants to debug a package -- <br>// <br>//NOTE:   This is designed to work with Microsoft Developer Studio <br>//if you want to add support for another tool, modify the  <br>//ShellExecute() line below.  This is alson non-robust in  <br>//the sense that it requires MSDEV.EXE to be in the path <br>//and set up correctly. <br>// <br>LRESULT CMtsSpy::OnDebugPackage(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL&amp; bHandled) <br>{ <br> <br>HCURSOR hBusy = LoadCursor(NULL, IDC_WAIT); <br>HCURSOR hOldCur = SetCursor(hBusy); <br>TCHAR szBuf[128]; <br>ZeroMemory(szBuf, 128 * sizeof(TCHAR)); <br>int nChars; <br>_ASSERTE(m_hMenuDebug); <br>nChars = GetMenuString(m_hMenuDebug, wID, szBuf, 128, MF_BYCOMMAND); <br>if (nChars) <br>{ <br>int nCount = lstrlen(szBuf); <br>LPTSTR p = szBuf + nCount; <br>while (*p-- != ':' &amp;&amp; nCount) <br>{ <br>nCount --; <br>} <br> <br>if (nCount == 0) <br>{ <br>SetCursor(hOldCur); <br>return 0; <br>} <br> <br>p+=3; <br>TCHAR buf[MAX_PATH]; <br>wsprintf(buf, _T("-p %s -e %s"), p, p); <br>HINSTANCE hInst = ShellExecute( NULL, _T("open"), _T("msdev"), buf, NULL, SW_SHOWNORMAL); <br>} <br>SetCursor(hOldCur); <br>return 0; <br>} <br>// <br>//Enable/Disable auditing <br>// <br>HRESULT CMtsSpy::EnableAudit(BOOL bEnable) <br>{ <br> <br>if (!bEnable) <br>{ <br>SafeRelease(m_pSqlAudit); <br>return S_OK; <br>} <br> <br>if (m_pSqlAudit)// make EnableAudit() idempotent -- we are already enabled <br>return S_OK; <br> <br>HRESULT hr; <br>hr = CoCreateInstance(CLSID_MtsSqlAudit, NULL, CLSCTX_ALL, IID_IMtsSqlAudit, (void **)&amp;m_pSqlAudit); <br>if (SUCCEEDED(hr)) <br>{ <br>// <br>//these hard coded strings (user and pw) should be looked up in the registry for a production <br>//app <br>hr = m_pSqlAudit -&gt; Init(L"MtsAudit", L"sa", L""); <br>if (FAILED(hr)) <br>{ <br>LPTSTR sMsg = _T("Unable to connect to DSN 'MtsAudit'. Make sure the DSN\nexists, that has it \ <br>the schema contained in MtsAudit.SQL,\nand that you have permission to the database."); <br> <br>::MessageBox(m_hWndList, sMsg,  _T("MtsSpy"), MB_ICONSTOP); <br>SafeRelease(m_pSqlAudit); <br>} <br>} <br>else <br>{ <br> <br>::MessageBox(m_hWndList, _T("Unable to create the MtsAudit component!"),  _T("MtsSpy"), MB_ICONSTOP); <br>} <br> <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
