<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SIMPLELOGOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1336"></a>SIMPLELOGOBJ.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: SimpleLogObj.cpp <br>* <br>* Description:  <br> <br>*implementation of a structured storage based log. <br>*each transaction is written to its own stream, where the name of the stream <br>*is the GUID of the transaction <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "SimpleLog.h" <br>#include "SimpleLogObj.h" <br> <br>// <br>// the name of a stream in OLE Structured storage is limited to 37 <br>// chars -- we want to name streams with GUIDs (as strings), which <br>// are 39 chars -- to get around this, we will 64bit encode the name <br>// of the GUID <br>// <br>// These characters are the legal digits, in order, that are <br>// used in Base64 encoding <br>// <br>const WCHAR rgwchBase64[] = <br>    L"ABCDEFGHIJKLMNOPQ" <br>    L"RSTUVWXYZabcdefgh" <br>    L"ijklmnopqrstuvwxy" <br>    L"z0123456789+*"; <br> <br> <br>STDMETHODIMP CSimpleLogObj::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>static const IID* arr[] =  <br>{ <br>&amp;IID_ISimpleLog, <br>}; <br>for (int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++) <br>{ <br>if (InlineIsEqualGUID(*arr[i],riid)) <br>return S_OK; <br>} <br>return S_FALSE; <br>} <br>CSimpleLogObj::CSimpleLogObj() <br>{ <br>m_pStorage = NULL; <br>m_bInRecovery = FALSE; <br> <br>} // CSimpleLogObj:CSimpleLogObj() <br> <br>CSimpleLogObj::~CSimpleLogObj(void) <br>{ <br>// Realocate space for the recovery directory path name. <br>if (NULL != m_pStorage) <br>{ <br>m_pStorage -&gt; Release(); <br>} <br> <br>} // CSimpleLogObj::~CSimpleLogObj <br> <br>// <br>//Init() <br>// <br>//Pass in the filename of the log (pszLogFileName)  <br>//read the registery to find the log dir, and open <br>//the file using structured storage.  if the file doesn't <br>//exit, create it <br>// <br>HRESULT CSimpleLogObj::Init(BSTR pszLogFileName) <br>{ <br>BOOLfNew = FALSE; <br> <br> <br>HRESULT hr = StgOpenStorage( <br>pszLogFileName, //Pointer to the path of the file containing storage object <br>NULL, //Pointer to a previous opening of a root storage object <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, //Access mode for the object <br>NULL, //String name block specifying elements to be excluded <br>0, //Reserved; must be zero <br>&amp;m_pStorage//Indirect pointer to the storage object <br>   ); <br> <br>if (FAILED(hr)) <br>{ <br> <br> <br>if (hr == STG_E_FILENOTFOUND) <br>{ <br>hr =  StgCreateDocfile(pszLogFileName, //Pointer to path of compound file to create <br>STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE | STGM_READWRITE ,//Access mode for the new storage object <br>NULL, <br>&amp;m_pStorage//Indirect pointer to the new storage object <br>); <br>} <br>if (FAILED(hr)) <br>{ <br>::MessageBox(NULL, _T("Failed to open log.  Make sure you don't have another instance running."), _T("CopyFileRm"), MB_ICONSTOP); <br>return hr; <br>} <br> <br>} <br> <br>_ASSERTE(m_pStorage); <br>return S_OK; <br>} <br>// <br>//Write the specified info to the log. <br>// <br>//1. we Create (or Open) a stream with the name representing the GUID <br>//2. we write the Command into it <br>//3. we close the stream <br>// <br>STDMETHODIMP CSimpleLogObj::WriteLog(GUID guidTx,LOG_RM_COMMAND eOp, BYTE * pByte, long cbBytes) <br>{  <br>//if (m_bInRecovery) <br>//return E_FAIL; <br> <br> <br>HRESULT hr; <br>IStream * pStream; <br>hr = GetStream(&amp;pStream, guidTx, TRUE); <br> <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br>ULONG cbWritten; <br>// seek to the end of the stream; <br>LARGE_INTEGER liOff; <br>ULARGE_INTEGER liNewPosition; <br>LISet32(liOff,  0); <br>hr = pStream -&gt; Seek(liOff, STREAM_SEEK_END, &amp;liNewPosition); <br> <br>if (eOp != LOG_RM_PRIVATE) <br>{ <br>// write the command <br>hr = pStream -&gt; Write((void *)&amp;eOp, sizeof(eOp), &amp;cbWritten); <br>_ASSERTE(hr==S_OK); <br>} <br> <br> <br>// if the structure exists, and it is not the end of the xact <br>// don't write the rest of the info if it  <br>if (cbBytes &amp;&amp; eOp != LOG_RM_XACT_END)  <br>{ <br>// write the struct size <br>hr = pStream -&gt; Write((void *)&amp;cbBytes, sizeof(cbBytes), &amp;cbWritten); <br>_ASSERTE(hr==S_OK); <br> <br>// write the byte stream <br>hr = pStream -&gt; Write((void *)pByte, cbBytes, &amp;cbWritten); <br> <br>_ASSERTE((long)cbWritten == cbBytes); <br>} <br> <br> <br>// commit the write  <br>hr = pStream -&gt; Commit(STGC_DEFAULT); <br> <br>// commit the storage <br>hr = m_pStorage -&gt; Commit(STGC_DEFAULT); <br>_ASSERTE(hr == S_OK); <br> <br>// release (close) the stream; <br>pStream -&gt; Release(); <br> <br>return S_OK; <br>} <br>// <br>//gets a storage that has all of the streams that need to be recovered <br>// <br>//the stream starts with the GUID that is the TxId, followed by RM_BEGIN_TX <br>//and then the rest of the information  <br>// <br>#define ENUM_GRANULARITY 10 <br>STDMETHODIMP CSimpleLogObj::RecoveryInfo(IStorage **ppStorage) <br>{ <br>m_bInRecovery = TRUE; <br>_ASSERTE(m_pStorage); <br>IEnumSTATSTG * pEnum = NULL; <br> <br>*ppStorage = NULL; <br> <br>HRESULT hr; <br>ILockBytes *pLkbyte = NULL; <br>hr = CreateILockBytesOnHGlobal(NULL,TRUE, &amp;pLkbyte); <br> <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br> <br>hr = StgCreateDocfileOnILockBytes(pLkbyte, STGM_SHARE_EXCLUSIVE|STGM_CREATE|STGM_READWRITE, NULL, ppStorage); <br>if (FAILED(hr)) <br>{ <br>pLkbyte -&gt; Release(); <br>_ASSERTE(0); <br>return hr; <br>} <br> <br>//enumate through the existing streams, looking for streams that DO NOT end in LOG_RM_XACT_END <br>// these are the ones that need to be recovered... <br> <br>hr = m_pStorage -&gt; EnumElements(NULL, NULL, NULL, &amp;pEnum); <br>_ASSERTE(hr == S_OK); <br>STATSTG statstg[ENUM_GRANULARITY]; <br>ULONG lFetched = 0; <br>ULONG i = 0; <br>IStream * pStream = NULL; <br>LARGE_INTEGER liOff; <br>ULARGE_INTEGER liNewPosition; <br>long lSizeCommand = sizeof(LOG_RM_COMMAND); <br>ULARGE_INTEGER MaxInt; <br>MaxInt.HighPart = (ULONG)-1; <br>MaxInt.LowPart = (ULONG)-1; <br>LOG_RM_COMMAND eOp; <br>ULONG cbBytesRead; <br>do <br>{ <br>hr = pEnum -&gt; Next(ENUM_GRANULARITY, statstg, &amp;lFetched); <br>for (i=0; i&lt;lFetched; i++) <br>{ <br> <br>// get the stream <br>pStream = NULL; <br>hr =  m_pStorage -&gt; OpenStream( <br>statstg[i].pwcsName, //Pointer to string containing name of stream to open <br>NULL, //Reserved <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, //Access mode for the new stream <br>NULL, //Reserved <br>&amp;pStream//Indirect pointer to opened stream object <br>   ); <br> <br>_ASSERTE(hr == S_OK); <br>LISet32(liOff,  -1 * lSizeCommand); <br>// seek to the end of the stream, and back up sizeof(LOG_RM_ACTION) <br>hr = pStream -&gt; Seek(liOff, STREAM_SEEK_END, &amp;liNewPosition); <br>// read the value <br>hr = pStream -&gt; Read(&amp;eOp, sizeof(eOp), &amp;cbBytesRead); <br>_ASSERTE(cbBytesRead == sizeof(eOp)); <br> <br>if (eOp != LOG_RM_XACT_END) <br>{ <br> <br>IStream * pNewStream; <br>pNewStream = NULL; <br> <br> <br>hr = (*ppStorage) -&gt; CreateStream( <br>statstg[i].pwcsName, <br>STGM_CREATE|STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,  <br>NULL, NULL,  <br>&amp;pNewStream <br>   ); <br>// seek back to the beginning <br>LISet32(liOff,  0); <br>pStream -&gt; Seek(liOff, STREAM_SEEK_SET, &amp;liNewPosition); <br>_ASSERTE(liNewPosition.LowPart == 0); <br>// tx need to be recovered, copy the stream from the file to the storage <br>hr = pStream -&gt; CopyTo(pNewStream,  <br>MaxInt, <br>NULL, NULL); <br>   <br> <br>pStream -&gt; Release(); <br>pNewStream -&gt; Release(); <br>} <br>else <br>{ <br>pStream -&gt; Release(); <br>// <br>//the transaction has been completed, we can remove it <br>//  from our log... <br>// <br>hr = m_pStorage -&gt; DestroyElement(statstg[i].pwcsName); <br>_ASSERTE(hr == S_OK); <br>} <br> <br>} // end for <br> <br>}while (lFetched == ENUM_GRANULARITY); <br> <br>pEnum -&gt; Release(); <br>m_bInRecovery = FALSE; <br>return S_OK; <br>} <br> <br> <br>// <br>//64 bit encodes the guidTx and opens the stream with that name. <br>//if the stream does not exist, it creates the stream (if bCreate is TRUE) <br>//and then writes the GUID to the stream <br>// <br>HRESULT CSimpleLogObj::GetStream(IStream **pStream, GUID &amp;guidTx,  BOOL bCreate) <br>{ <br> <br>HRESULT hr; <br>CComBSTR sStreamName; <br>hr = ToBase64((void *)&amp;guidTx, sizeof(GUID), &amp;sStreamName.m_str); <br>_ASSERTE(hr == S_OK); <br>_ASSERTE(sStreamName.m_str); <br> <br>hr =  m_pStorage -&gt; OpenStream( <br>sStreamName.m_str, //Pointer to string containing name of stream to open <br>NULL, //Reserved <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE, //Access mode for the new stream <br>NULL, //Reserved <br>pStream//Indirect pointer to opened stream object <br>   ); <br> <br> <br>if (FAILED(hr)) <br>{ <br>if (hr == STG_E_FILENOTFOUND &amp;&amp; bCreate) <br>{ <br>// create the stream <br>hr = m_pStorage -&gt; CreateStream( <br>sStreamName.m_str, <br>STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_READWRITE,  <br>NULL, NULL,  <br>pStream <br>   ); <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br> <br>DWORD cbWritten; <br>hr = (*pStream) -&gt; Write(&amp;guidTx, sizeof(guidTx), &amp;cbWritten); <br>} <br>} <br> <br>return hr; <br>} <br>// <br>//Streams in IStorage are limited to &lt;39 chars, which is how long <br>//a GUID as a string is...so we are going to encode them in base64 <br>// <br>HRESULT CSimpleLogObj::ToBase64(LPVOID pv, ULONG cbStart, BSTR* pbstr) <br>// <br>// Encode and return the bytes in base 64 <br>// <br>    { <br>    ULONG cb = cbStart; <br>    *pbstr = NULL; <br>    HRESULT hr = S_OK; <br>    int cchPerLine = 72;                        // conservative, must be mult of 4 for us <br>    int cbPerLine  = cchPerLine / 4 * 3; <br>    int cbSafe     = cb + 3;                    // allow for padding <br>    int cLine      = cbSafe / cbPerLine + 2;    // conservative <br>    int cchNeeded  = cLine * (cchPerLine + 2 /*CRLF*/) + 1 /*NULL*/; <br>    int cbNeeded   = cchNeeded * sizeof(WCHAR); <br>    LPWSTR wsz = (LPWSTR)CoTaskMemAlloc(cbNeeded); <br>    if (wsz) <br>        { <br>        BYTE*  pb   = (BYTE*)pv; <br>        WCHAR* pch  = wsz; <br>        int cchLine = 0; <br>        // <br>        // Main encoding loop <br>        // <br>        while (cb &gt;= 3) <br>            { <br>            BYTE b0 =                     ((pb[0]&gt;&gt;2) &amp; 0x3F); <br>            BYTE b1 = ((pb[0]&amp;0x03)&lt;&lt;4) | ((pb[1]&gt;&gt;4) &amp; 0x0F); <br>            BYTE b2 = ((pb[1]&amp;0x0F)&lt;&lt;2) | ((pb[2]&gt;&gt;6) &amp; 0x03); <br>            BYTE b3 = ((pb[2]&amp;0x3F)); <br> <br>            *pch++ = rgwchBase64[b0]; <br>            *pch++ = rgwchBase64[b1]; <br>            *pch++ = rgwchBase64[b2]; <br>            *pch++ = rgwchBase64[b3]; <br> <br>            pb += 3; <br>            cb -= 3; <br>             <br>            // put in line breaks <br>            cchLine += 4; <br>            if (cchLine &gt;= cchPerLine) <br>                { <br>                *pch++ = L'\r'; <br>                *pch++ = L'\n'; <br>                cchLine = 0; <br>                } <br>            } <br>        // <br>        // Account for gunk at the end <br>        // <br>        *pch++ = L'\r';     // easier than keeping track <br>        *pch++ = L'\n'; <br>        if (cb==0) <br>            { <br>            // nothing to do <br>            } <br>        else if (cb==1) <br>            { <br>            BYTE b0 =                     ((pb[0]&gt;&gt;2) &amp; 0x3F); <br>            BYTE b1 = ((pb[0]&amp;0x03)&lt;&lt;4) | 0; <br>            *pch++ = rgwchBase64[b0]; <br>            *pch++ = rgwchBase64[b1]; <br>            *pch++ = L'='; <br>            *pch++ = L'='; <br>            } <br>        else if (cb==2) <br>            { <br>            BYTE b0 =                     ((pb[0]&gt;&gt;2) &amp; 0x3F); <br>            BYTE b1 = ((pb[0]&amp;0x03)&lt;&lt;4) | ((pb[1]&gt;&gt;4) &amp; 0x0F); <br>            BYTE b2 = ((pb[1]&amp;0x0F)&lt;&lt;2) | 0; <br>            *pch++ = rgwchBase64[b0]; <br>            *pch++ = rgwchBase64[b1]; <br>            *pch++ = rgwchBase64[b2]; <br>            *pch++ = L'='; <br>            } <br>         <br>        // <br>        // NULL terminate the string <br>        // <br>        *pch = NULL; <br> <br>        // <br>        // Allocate our final output <br>        // <br>        *pbstr = SysAllocString(wsz); <br>        if (*pbstr==NULL) <br>            hr = E_OUTOFMEMORY; <br> <br>        CoTaskMemFree(wsz); <br>        } <br>    else <br>        hr = E_OUTOFMEMORY; <br> <br>    #ifdef _DEBUG <br>    if (hr==S_OK) <br>        { <br>        BLOB b; <br>        FromBase64(*pbstr, &amp;b); <br>        _ASSERTE(b.cbSize == cbStart); <br>        _ASSERTE(memcmp(b.pBlobData, pv, cbStart) == 0); <br>        CoTaskMemFree(b.pBlobData); <br>        } <br>    #endif <br> <br>    return hr; <br>    } <br> <br> <br> <br>HRESULT CSimpleLogObj::FromBase64(BSTR bstr, BLOB* pblob) <br>// <br>// Decode and return the Base64 encoded bytes <br>// <br>    { <br>    HRESULT hr = S_OK; <br>    int cbNeeded = lstrlenW(bstr);      // an upper bound <br>    BYTE* rgb = (BYTE*)CoTaskMemAlloc(cbNeeded); <br>    if (rgb) <br>        { <br>        BYTE  mpwchb[256]; <br>        BYTE  bBad = (BYTE)-1; <br>        int   i; <br>        // <br>        // Initialize our decoding array <br>        // <br>        memset(&amp;mpwchb[0], bBad, 256); <br>        for (i = 0; i &lt; 64; i++) <br>            { <br>            WCHAR wch = rgwchBase64[i]; <br>            mpwchb[wch] = i; <br>            } <br> <br>        // <br>        // Loop over the entire input buffer <br>        // <br>        ULONG bCurrent = 0;         // what we're in the process of filling up <br>        int  cbitFilled = 0;        // how many bits in it we've filled <br>        BYTE* pb = rgb;             // current destination (not filled) <br>        // <br>        for (WCHAR* pwch=bstr; *pwch; pwch++) <br>            { <br>            WCHAR wch = *pwch; <br>            // <br>            // Ignore white space <br>            // <br>            if (wch==0x0A || wch==0x0D || wch==0x20 || wch==0x09) <br>                continue; <br>            // <br>            // Have we reached the end? <br>            // <br>            if (wch==L'=') <br>                break; <br>            // <br>            // How much is this character worth? <br>            // <br>            BYTE bDigit = mpwchb[wch]; <br>            if (bDigit==bBad) <br>                { <br>                hr = E_INVALIDARG; <br>                break; <br>                } <br>            // <br>            // Add in its contribution <br>            // <br>            bCurrent &lt;&lt;= 6; <br>            bCurrent |= bDigit; <br>            cbitFilled += 6; <br>            // <br>            // If we've got enough, output a byte <br>            // <br>            if (cbitFilled &gt;= 8) <br>                { <br>                ULONG b = (bCurrent &gt;&gt; (cbitFilled-8));     // get's top eight valid bits <br>                *pb++ = (BYTE)(b&amp;0xFF);                     // store the byte away <br>                cbitFilled -= 8; <br>                } <br>            } <br> <br>        if (hr==S_OK) <br>            { <br>            pblob-&gt;pBlobData = rgb; <br>            pblob-&gt;cbSize = pb-rgb; <br>            } <br>        else <br>            { <br>            CoTaskMemFree(rgb); <br>            pblob-&gt;pBlobData = NULL; <br>            } <br>        } <br>    else <br>        hr = E_OUTOFMEMORY; <br>    return hr; <br>} <br> <br>STDMETHODIMP CSimpleLogObj::WriteStreamToLog(GUID guidTx, LOG_RM_COMMAND eOp, IStream * pStreamIn) <br>{ <br>HRESULT hr; <br>IStream * pStream; <br>hr = GetStream(&amp;pStream, guidTx, TRUE); <br> <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br>ULONG cbWritten; <br>// seek to the end of the stream; <br>LARGE_INTEGER liOff; <br>ULARGE_INTEGER liNewPosition; <br>LISet32(liOff,  0); <br>hr = pStream -&gt; Seek(liOff, STREAM_SEEK_END, &amp;liNewPosition); <br> <br>if (eOp != LOG_RM_PRIVATE) <br>{ <br>// write the command <br>hr = pStream -&gt; Write((void *)&amp;eOp, sizeof(eOp), &amp;cbWritten); <br>_ASSERTE(hr==S_OK); <br>} <br> <br> <br> <br>if (pStreamIn) <br>{ <br>// get info from the stream <br> <br>STATSTG stat; <br>ZeroMemory(&amp;stat, sizeof(stat)); <br> <br>hr = pStreamIn -&gt; Stat(&amp;stat, STATFLAG_NONAME); <br>_ASSERTE(hr==S_OK); <br>_ASSERTE(stat.cbSize.HighPart == 0); <br>ULONG cbBytes = stat.cbSize.LowPart; <br> <br>// if the structure exists, and it is not the end of the xact <br>// don't write the rest of the info if it  <br>if (cbBytes &amp;&amp; eOp != LOG_RM_XACT_END)  <br>{ <br>// write the struct size <br>hr = pStream -&gt; Write((void *)&amp;cbBytes, sizeof(cbBytes), &amp;cbWritten); <br>_ASSERTE(hr==S_OK); <br> <br>// write the byte stream <br>hr = pStreamIn -&gt; CopyTo(pStream, stat.cbSize, NULL, NULL); <br>_ASSERTE(hr == S_OK); <br>LARGE_INTEGER li; <br>li.LowPart = -1 * stat.cbSize.LowPart; <br>li.HighPart = 0; // limits our size... <br>hr = pStreamIn -&gt; Seek(li, STREAM_SEEK_CUR, NULL); <br>_ASSERTE(hr == S_OK); <br>} <br>} <br> <br> <br>// commit the write  <br>hr = pStream -&gt; Commit(STGC_DEFAULT); <br> <br>// commit the storage <br>hr = m_pStorage -&gt; Commit(STGC_DEFAULT); <br>_ASSERTE(hr == S_OK); <br> <br>// release (close) the stream; <br>pStream -&gt; Release(); <br> <br>return S_OK; <br> <br>} <br> <br>STDMETHODIMP CSimpleLogObj::RemoveTxStream(GUID guidTx) <br>{ <br>HRESULT hr; <br>CComBSTR sStreamName; <br>hr = ToBase64((void *)&amp;guidTx, sizeof(GUID), &amp;sStreamName.m_str); <br>_ASSERTE(hr == S_OK); <br>_ASSERTE(sStreamName.m_str); <br>hr = m_pStorage -&gt; DestroyElement(sStreamName); <br> <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>} <br> <br>return hr; <br>} <br> <br>STDMETHODIMP CSimpleLogObj::WriteVariantToLog(GUID guidTx, VARIANT * pVariant) <br>{ <br>HRESULT hr; <br>IStream * pStream; <br>hr = GetStream(&amp;pStream, guidTx, TRUE); <br> <br>if (FAILED(hr)) <br>{ <br>_ASSERTE(0); <br>return hr; <br>} <br>// <br>//Seek to the end <br>// <br> <br>LARGE_INTEGER liOff; <br>ULARGE_INTEGER liNewPosition; <br>liOff.QuadPart = 0; <br>hr = pStream -&gt; Seek(liOff, STREAM_SEEK_END, &amp;liNewPosition); <br>_ASSERTE(hr==S_OK); <br>CComVariant var(*pVariant); <br>hr = var.WriteToStream(pStream); <br>if (SUCCEEDED(hr)) <br>{ <br>// commit the write  <br>hr = pStream -&gt; Commit(STGC_DEFAULT); <br> <br>// commit the storage <br>hr = m_pStorage -&gt; Commit(STGC_DEFAULT); <br>_ASSERTE(hr == S_OK); <br>} <br> <br>pStream -&gt; Release(); <br>return hr; <br>} <br> <br>STDMETHODIMP CSimpleLogObj::GetStream(GUID guidTx, IStream * * ppStream) <br>{ <br>HRESULT hr; <br>hr = GetStream(ppStream, guidTx, FALSE); <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
