<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COPYFILERM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1228"></a>COPYFILERM.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: CopyFileRm.cpp <br>* <br>* Description: Implementation of WinMain <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br> <br>#include "stdafx.h" <br>#include "resource.h" <br>#include "initguid.h" <br>#include "txdtc.h" <br>#define INITGUID <br>#include "txcoord.h" <br>#include "xolehlp.h" <br> <br>#include "CopyFileRm.h" <br>#define IID_DEFINED <br>#include "CopyFileRm_i.c" <br>#include "SimpleLog.h" <br>#include "simplelog_i.c" <br>#include "rmworker.h" <br>#include "rmoptions.h" <br>#include "FileRm.h" <br>#include "rmdlg.h" <br> <br> <br> <br> <br> <br>LONG CExeModule::Lock() <br>{ <br>LONG l = CComModule::Lock(); <br>if (_Module.m_dlg) <br>_Module.m_dlg-&gt;SetLockCount(l); <br> <br>return l; <br>} <br> <br> <br> <br>LONG CExeModule::Unlock() <br>{ <br>LONG l = CComModule::Unlock(); <br>if (_Module.m_dlg) <br>_Module.m_dlg-&gt;SetLockCount(l); <br>if (l == 0) <br>{ <br>#if _WIN32_WINNT &gt;= 0x0400 <br>if (CoSuspendClassObjects() == S_OK) <br>PostThreadMessage(dwThreadID, WM_QUIT, 0, 0); <br>#else <br>PostThreadMessage(dwThreadID, WM_QUIT, 0, 0); <br>#endif <br>} <br>return l; <br>} <br> <br>CExeModule _Module; <br> <br>BEGIN_OBJECT_MAP(ObjectMap) <br>OBJECT_ENTRY(CLSID_CoFileRm, CFileRm) <br>END_OBJECT_MAP() <br> <br> <br>LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2) <br>{ <br>while (*p1 != NULL) <br>{ <br>LPCTSTR p = p2; <br>while (*p != NULL) <br>{ <br>if (*p1 == *p++) <br>return p1+1; <br>} <br>p1++; <br>} <br>return NULL; <br>} <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br>extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,  <br>HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/) <br>{ <br> <br> <br> <br>lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT <br>HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>_ASSERTE(SUCCEEDED(hRes)); <br>_Module.Init(ObjectMap, hInstance); <br>_Module.dwThreadID = GetCurrentThreadId(); <br>TCHAR szTokens[] = _T("-/"); <br> <br>int nRet = 0; <br>BOOL bRun = TRUE; <br>LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens); <br>while (lpszToken != NULL) <br>{ <br>if (lstrcmpi(lpszToken, _T("UnregServer"))==0) <br>{ <br>_Module.UpdateRegistryFromResource(IDR_CopyFileRm, FALSE); <br>nRet = _Module.UnregisterServer(); <br>bRun = FALSE; <br>break; <br>} <br>if (lstrcmpi(lpszToken, _T("RegServer"))==0) <br>{ <br>_Module.UpdateRegistryFromResource(IDR_CopyFileRm, TRUE); <br>nRet = _Module.RegisterServer(TRUE); <br>bRun = FALSE; <br>break; <br>} <br>lpszToken = FindOneOf(lpszToken, szTokens); <br>} <br> <br>if (bRun) <br>{ <br>// <br>//to make it easier to demo, I am always going to register the server when <br>//it is launched <br>// <br> <br>_Module.UpdateRegistryFromResource(IDR_CopyFileRm, TRUE); <br>nRet = _Module.RegisterServer(TRUE); <br>_ASSERTE(SUCCEEDED(nRet )); <br> <br> <br>hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE); <br>_ASSERTE(SUCCEEDED(hRes)); <br> <br>if (SUCCEEDED(hRes)) <br>{ <br> <br>if (_Module.m_dlg) <br>_Module.m_dlg -&gt; SetUsageCount(0); <br>MSG msg; <br>while (GetMessage(&amp;msg, 0, 0, 0)) <br>DispatchMessage(&amp;msg); <br> <br>_Module.RevokeClassObjects(); <br>} <br> <br>} <br> <br> <br>CoUninitialize(); <br>return nRet; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
