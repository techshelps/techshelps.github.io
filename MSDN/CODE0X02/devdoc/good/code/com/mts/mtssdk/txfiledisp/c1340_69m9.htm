<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILERMPXY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1341"></a>FILERMPXY.CPP</h2>
<pre><code><br>/******************************************************************************\ <br>******************************************************************************** <br>* Filename: FileRmPxy.cpp <br>* <br>* Description:  Implementation of the RM Proxy. Also registers <br>the resource dispenser <br>* <br>* This file is provided as part of the Microsoft Transaction Server <br>* Software Development Kit <br>* <br>*THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>*WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>*INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>*OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>*PURPOSE. <br>* <br>* Copyright (C) 1997 Microsoft Corporation, All rights reserved <br>******************************************************************************** <br>\******************************************************************************/ <br>#include "stdafx.h" <br>#include "TxFileDisp.h" <br>#include "copyfilerm.h" <br>#include "mtxdm.h" <br>#include "txcoord.h" <br>#include "FileRmPxy.h" <br>#include "txdtc.h" <br>#include "xolehlp.h" <br>#include "eh.h" <br> <br> <br>CFileRmPxy::CFileRmPxy() <br>{ <br>m_pRm = NULL; <br>m_pDispMan = NULL; <br>m_pHolder = NULL; <br>m_pFreeThreadedMarshaler = NULL; <br>m_pGIT = NULL; <br> <br>} <br>CFileRmPxy::~CFileRmPxy()  <br>{ <br> <br>ATLTRACE(_T("FileRmPxy is being destroyed.\n")); <br> <br> <br>} <br> <br>STDMETHODIMP CFileRmPxy::CopyDirTx(long hConnection, BSTR sSource, BSTR sDestination) <br>{ <br> <br>HRESULT hr; <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br> <br>// Do Work <br>WIN32_FIND_DATA fd; <br>memset(&amp;fd, NULL, sizeof(fd)); <br>HANDLE hFile; <br>CComBSTR sFileSource; <br>CComBSTR sFileDest; <br>LPTSTR lpSource = sSource; <br>LPTSTR lpDest = sDestination; <br>TCHAR sTemp[MAX_PATH]; <br>TCHAR lpFileSpec[MAX_PATH]; <br>memset(lpFileSpec, NULL, MAX_PATH); <br>memset(sTemp, NULL, MAX_PATH); <br>wsprintf(lpFileSpec, L"%s\\*.*", lpSource); <br>BOOL bFound = TRUE; <br>DWORD dwTest; <br> <br>hFile = FindFirstFile(lpFileSpec, &amp;fd); <br>while (hFile != INVALID_HANDLE_VALUE &amp;&amp; bFound) <br>{ <br>dwTest = fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY; <br>if (dwTest == 0) // copy if not a dir <br>{ <br>wsprintf(sTemp, L"%s\\%s", lpSource, fd.cFileName); <br>sFileSource = sTemp; <br>wsprintf(sTemp, L"%s\\%s", lpDest, fd.cFileName); <br>sFileDest = sTemp; <br>pRm -&gt; AddFile(hConnection, sFileSource, sFileDest); <br>} <br> <br>memset(&amp;fd, NULL, sizeof(fd)); <br>bFound = FindNextFile(hFile, &amp;fd); <br>} <br> <br>FindClose(hFile); <br>hr = pRm -&gt; CopyListTx(hConnection); <br>SafeRelease(pRm); <br>return hr; <br>} <br> <br>#ifdef _DEBUG <br>void CFileRmPxy::ShowMessage() <br>{ <br> <br>LPTSTR lpMsgBuf = NULL; <br>FormatMessage(  <br>FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, <br>GetLastError(), <br>MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language <br>(LPTSTR) &amp;lpMsgBuf, <br>0, <br>NULL  <br>); <br> <br> <br>if (lpMsgBuf) <br>{ <br>// Display the string. <br>MessageBox( NULL, lpMsgBuf, L"GetLastError", MB_OK|MB_ICONINFORMATION ); <br> <br> <br>// Free the buffer. <br>LocalFree( lpMsgBuf ); <br>} <br>} <br>#endif <br> <br>STDMETHODIMP CFileRmPxy::AddFile(long hConnection, BSTR sSource, BSTR sDestination) <br>{ <br>HRESULT hr; <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br> <br>hr = pRm -&gt; AddFile(hConnection, sSource, sDestination); <br>SafeRelease(pRm); <br>return hr; <br>} <br> <br>STDMETHODIMP CFileRmPxy::CopyFilesInCopyList(long hConnection) <br>{ <br> <br>HRESULT hr; <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br> <br> <br>hr = pRm -&gt; CopyListTx(hConnection); <br>SafeRelease(pRm); <br>return hr; <br> <br>} <br> <br> <br>STDMETHODIMP CFileRmPxy::Connect(long *hConnection) <br>{ <br>if (m_pDispMan) <br>{ <br>if (!m_pHolder) <br>{ <br>_ASSERTE(0); <br>return E_INVALIDARG; <br>} <br>} <br> <br>if (!m_pRm) <br>{ <br>_ASSERTE(0); <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr; <br>if (m_pDispMan) <br>{ <br>*hConnection = NULL; <br>hr = m_pHolder -&gt; AllocResource((RESID)1, (RESID *)hConnection); <br>if (FAILED(hr)) <br>{ <br>AtlTrace(_T("AllocResource failed! Error code %x\n"), hr); <br>} <br>} <br>else  // not running under MTS, we must create our own resource <br>{ <br>TIMEINSECS timeout; <br>hr = CreateResource((RESID)1,(RESID *)hConnection,&amp;timeout); <br>} <br>return hr; <br>} <br>STDMETHODIMP CFileRmPxy::Disconnect(long hConnection) <br>{ <br> <br> <br>if (m_pDispMan) <br>{ <br>if (!m_pHolder) <br>{ <br>_ASSERTE(0); <br>return E_INVALIDARG; <br>} <br>} <br> <br>if (!m_pRm) <br>{ <br>_ASSERTE(0); <br>return E_INVALIDARG; <br>} <br> <br>HRESULT hr; <br>if (m_pDispMan) <br>{ <br>hr = m_pHolder -&gt; FreeResource(hConnection); <br>} <br>else <br>{ <br>hr = DestroyResource(hConnection); <br>} <br> <br>_ASSERTE(hr == S_OK); <br>return hr; <br>} <br>STDMETHODIMP CFileRmPxy::CopyFileTx(long hConnection,BSTR sSource,BSTR sDestination,  BOOL bFailIfExists) <br>{ <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br>HRESULT hr = pRm -&gt; FileCopyTx(hConnection, sSource, sDestination, bFailIfExists); <br>SafeRelease(pRm); <br>return hr; <br> <br>} <br>STDMETHODIMP CFileRmPxy::MoveFileTx(long hConnection,BSTR sSource,BSTR sDestination) <br>{ <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br>HRESULT hr = pRm -&gt; FileMoveTxt(hConnection, sSource, sDestination); <br>SafeRelease(pRm); <br>return hr; <br>} <br>STDMETHODIMP CFileRmPxy::DeleteFileTx(long hConnection,BSTR sFileName) <br>{ <br>IFileRm * pRm = GetFileRmPointer(); <br>if (!pRm) <br>return E_UNEXPECTED; <br>HRESULT hr = pRm -&gt; FileDeleteTx(hConnection, sFileName); <br>SafeRelease(pRm); <br>return hr; <br> <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
