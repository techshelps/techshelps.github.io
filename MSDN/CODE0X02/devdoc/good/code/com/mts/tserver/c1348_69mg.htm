<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPUTER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1348"></a>COMPUTER.CPP</h2>
<pre><code>// Filename: Computer.cpp <br>// <br>// Description:  Implementation of CComputer <br>// This file contains the code that handles the interaction between a human <br>// player and a computer player. <br>// <br>// This file is provided as part of the Microsoft Transaction Server Samples <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>// WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>// INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>// OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>// PURPOSE. <br>// <br>// Copyright (C) 1997 Microsoft Corporation, All rights reserved <br> <br>#include "stdafx.h" <br>#include "tServer.h" <br>#include "Computer.h" <br> <br>#include &lt;mtx.h&gt; <br>#include &lt;mtxspm.h&gt; <br>#include &lt;time.h&gt; <br> <br>///////////////////////////////////////////////////////////////////////////// <br>// <br> <br>STDMETHODIMP CComputer::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>static const IID* arr[] =  <br>{ <br>&amp;IID_IComputer, <br>}; <br> <br>for (int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++) <br>{ <br>if (InlineIsEqualGUID(*arr[i],riid)) <br>return S_OK; <br>} <br>return S_FALSE; <br>} <br> <br> <br>STDMETHODIMP CComputer::AddNewGame (IN VARIANT_BOOL bEasy, OUT VARIANT* pvGameID, OUT VARIANT* pvOrder, <br>OUT VARIANT* pvX, OUT VARIANT* pvY) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br> <br>ISharedProperty* spmPropCounter = NULL; <br>ISharedProperty* spmPropState = NULL; <br> <br>pvGameID-&gt;vt = VT_I4; <br>pvOrder-&gt;vt = VT_I4; <br>pvX-&gt;vt = VT_I4; <br>pvY-&gt;vt = VT_I4; <br> <br>long lGameID = 0; <br>long lOrder = 0; <br>long lNewX = 0; <br>long lNewY = 0; <br> <br> <br>try { <br> <br>// Get the object context <br>THROW_ERR ( hr = GetObjectContext(&amp;pObjectContext) ); <br>if (pObjectContext == NULL) { <br>THROW_ERR ( E_FAIL ); <br>} <br> <br>// Create the SharedPropertyGroupManager <br>THROW_ERR ( pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr) ); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>THROW_ERR ( spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup) ); <br> <br>// Create the counter properties <br>THROW_ERR ( spmGroup-&gt;CreateProperty (L"Counter", &amp;bExists, &amp;spmPropCounter) ); <br> <br>// Obtain the current value of the counter <br>CComVariant vCounter; <br>THROW_ERR ( spmPropCounter-&gt;get_Value (&amp;vCounter) ); <br> <br>// Assign gameID <br>if (vCounter.lVal == 0) <br>vCounter.lVal = 1; <br> <br>lGameID = vCounter.lVal; <br> <br>// Update the counter <br>vCounter.lVal ++; <br>THROW_ERR ( spmPropCounter-&gt;put_Value (vCounter) ); <br> <br>// Set the state variable <br>TCHAR szBuf [512]; <br>BSTR bstrState; <br> <br>wsprintf (szBuf, _T("%dState"), lGameID); <br>bstrState = TCHAR2BSTR (szBuf); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrState, &amp;bExists, &amp;spmPropState) ); <br> <br>CComVariant vState; <br>vState.vt = VT_I4; <br>vState.lVal = 4; <br>THROW_ERR ( spmPropState-&gt;put_Value (vState) ); <br> <br>// Initialize the array <br>InitArray(); <br>THROW_ERR ( SaveArray(lGameID) ); <br> <br>// Assign order randomly <br>srand ((unsigned) time (NULL)); <br>lOrder = rand() % 2 + 1; <br> <br>// Get computer's first move if player's order is 2 <br>if (lOrder == 2) { <br>GetMove (lGameID, bEasy, lNewX, lNewY); <br>plField [lNewX][lNewY] = 2; <br>SaveArray(lGameID); <br>} <br> <br>// Prepare return values <br>pvX-&gt;lVal = lNewX; <br>pvY-&gt;lVal = lNewY; <br>pvOrder-&gt;lVal = lOrder; <br>pvGameID-&gt;lVal = lGameID; <br> <br>// We're finished and happy <br>pObjectContext-&gt;SetComplete(); <br> <br>} catch (HRESULT hr) { <br> <br>// Create an ErrorInfo object <br>ICreateErrorInfo* pCreateErrInfo = NULL; <br>IErrorInfo* pErrInfo = NULL; <br> <br>CreateErrorInfo (&amp;pCreateErrInfo); <br>pCreateErrInfo-&gt;QueryInterface (IID_IErrorInfo, (LPVOID FAR*) &amp;pErrInfo); <br> <br>// Fill in error information <br>TCHAR szErr [512]; <br>wsprintf (szErr, _T("Error %d occurred in Computer::AddNewGame()"), hr); <br>BSTR bstrDesc = TCHAR2BSTR (szErr); <br>pCreateErrInfo-&gt;SetGUID (IID_IComputer); <br>pCreateErrInfo-&gt;SetSource (L"Computer"); <br>pCreateErrInfo-&gt;SetDescription (bstrDesc); <br>::SysFreeString (bstrDesc); <br> <br>// Confirm error information <br>SetErrorInfo (0, pErrInfo); <br> <br>// Clean up the error objects <br>if (pCreateErrInfo) <br>pCreateErrInfo-&gt;Release(); <br> <br>if (pErrInfo) <br>pErrInfo-&gt;Release(); <br> <br>// Indicate our unhappiness <br>if (pObjectContext) <br>pObjectContext-&gt;SetAbort(); <br> <br>hr = E_FAIL; <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>if (spmPropCounter) <br>spmPropCounter-&gt;Release(); <br> <br>if (spmPropState) <br>spmPropState-&gt;Release(); <br> <br>return hr; <br>} <br> <br> <br>STDMETHODIMP CComputer::NewMove (IN long lGameID, IN VARIANT_BOOL bEasy, IN long lX, IN long lY, <br> OUT VARIANT* pvMyX, OUT VARIANT* pvMyY, OUT VARIANT* pvWin) { <br>// Win protocol <br>// ============ <br>// 0  -&gt; moves did not end game <br>// 1  -&gt; player won <br>// -1 -&gt; computer won <br>// 2  -&gt; player's move tied the game <br>// -2 -&gt; computer's move tied the game <br> <br>HRESULT hr = S_OK; <br> <br>pvMyX-&gt;vt = VT_I4; <br>pvMyY-&gt;vt = VT_I4; <br>pvWin-&gt;vt = VT_I4; <br> <br>long lTurns = 0; <br>long lWin = 0; <br>long lNewX = 0; <br>long lNewY = 0; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br> <br>try { <br> <br>// Get the object context <br>THROW_ERR ( hr = GetObjectContext(&amp;pObjectContext) ); <br>if (pObjectContext == NULL) { <br>THROW_ERR ( E_FAIL ); <br>} <br> <br>THROW_ERR ( LoadArray(lGameID) );  <br> <br>// Enter new move <br>plField [lX][lY] = 1; <br> <br>// Check for player's win <br>if (IsWin (1)) { <br> <br>// Player won <br>lWin = 1; <br> <br>} else { <br> <br>// Check for fullness <br>lTurns = HowManyTurns(); <br> <br>if (lTurns == 9) { <br> <br>// Tie <br>lWin = - 2; <br> <br>} else { <br> <br>// Get computer's move <br>GetMove (lGameID, bEasy, lNewX, lNewY); <br>plField[lNewX][lNewY] = 2; <br> <br>// Check for computer win <br>if (IsWin(2)) <br> <br>lWin = - 1; <br> <br>else <br> <br>// Check for fullness <br>if (lTurns == 8) <br>lWin = 2; <br>} <br>} <br> <br>// Save array <br>THROW_ERR ( SaveArray(lGameID) ); <br> <br>// Set return values <br>pvMyX-&gt;lVal = lNewX; <br>pvMyY-&gt;lVal = lNewY; <br>pvWin-&gt;lVal = lWin; <br> <br>// We're finished and happy <br>pObjectContext-&gt;SetComplete(); <br> <br>} catch (HRESULT hr) { <br> <br>// Create an ErrorInfo object <br>ICreateErrorInfo* pCreateErrInfo = NULL; <br>IErrorInfo* pErrInfo = NULL; <br> <br>CreateErrorInfo (&amp;pCreateErrInfo); <br>pCreateErrInfo-&gt;QueryInterface (IID_IErrorInfo, (LPVOID FAR*) &amp;pErrInfo); <br> <br>// Fill in error information <br>TCHAR szErr[512]; <br>wsprintf (szErr, _T("Error %d occurred in Computer::NewMove()"), hr); <br>BSTR bstrDesc = TCHAR2BSTR (szErr); <br>pCreateErrInfo-&gt;SetGUID (IID_IComputer); <br>pCreateErrInfo-&gt;SetSource (L"Computer"); <br>pCreateErrInfo-&gt;SetDescription (bstrDesc); <br>::SysFreeString (bstrDesc); <br> <br>// Confirm error information <br>SetErrorInfo (0, pErrInfo); <br> <br>// Clean up the error objects <br>if (pCreateErrInfo) <br>pCreateErrInfo-&gt;Release(); <br> <br>if (pErrInfo) <br>pErrInfo-&gt;Release(); <br> <br>// Indicate our unhappiness <br>if (pObjectContext) <br>pObjectContext-&gt;SetAbort(); <br> <br>hr = E_FAIL; <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>return hr; <br>} <br> <br> <br>void CComputer::GetMove (long lGameID, VARIANT_BOOL bEasy, long&amp; lX, long&amp; lY) { <br> <br>long lFlag = 0; <br>long lNewX = 0; <br>long lNewY = 0; <br> <br>// Perhaps there's only possible move <br>if (HowManyTurns() == 8) { <br> <br>// Scan for open tile <br>long i,j; <br>for (i = 0; i &lt; 3; i ++) { <br>for (j = 0; j &lt; 3; j ++) { <br>if (plField[i][j] == 0) { <br>lNewX = i; <br>lNewY = j; <br>lFlag = 1; <br>} <br>} <br>} <br>} <br> <br>// Check for win <br>if (lFlag == 0) <br>lFlag = LineScan (2, lNewX, lNewY); <br> <br>// Check for block <br>if (lFlag == 0) <br>lFlag = LineScan (1, lNewX, lNewY); <br> <br>// Else create a new move <br>if (lFlag == 0) { <br> <br>// Prepare random seed <br>srand ((unsigned) time (NULL)); <br> <br>// Decide intelligence level <br>if (!bEasy) { <br> <br>// Place in center if it's open <br>if (plField[1][1] == 0) { <br>lNewX = 1; <br>lNewY = 1; <br>lFlag = 1; <br> <br>} else { <br> <br>// Place on corner, if opponent placed first move in center <br>long lTurns = HowManyTurns(); <br>if (lTurns == 1 &amp;&amp; plField[1][1] &gt; 0) { <br>lNewX = (rand() % 2 == 0) ? 0:2; <br>lNewY = (rand() % 2 == 0) ? 0:2; <br>lFlag = 1; <br>} else { <br> <br>// Place on opposite tile, if opponent's second <br>// move was placed on diagonal <br>if (lTurns == 2) { <br>if (plField[0][0] == 1) { <br>lNewX = 2; <br>lNewY = 2; <br>lFlag = 1; <br>} <br> <br>if (plField[0][2] == 1) { <br>lNewX = 2; <br>lNewY = 0; <br>lFlag = 1; <br>} <br> <br>if (plField[2][0] == 1) { <br>lNewX = 0; <br>lNewY = 2; <br>lFlag = 1; <br>} <br> <br>if (plField[2][2] == 1) { <br>lNewX = 0; <br>lNewY = 0; <br>lFlag = 1; <br>} <br>} <br>} <br>} <br> <br>// Else find most intelligent move <br>if (lFlag == 0) { <br> <br>float value = 0; <br>float maxValue = 0; <br> <br>for (long i = 0; i &lt; 3; i ++) { <br>for (long j = 0; j &lt; 3; j ++) { <br> <br>// Evaluate tile <br>value = Evaluate (i, j); <br> <br>// Randomize equal choices <br>if (value == maxValue &amp;&amp; rand() % 2 == 0) { <br> <br>lNewX = i; <br>lNewY = j; <br> <br>} else { <br> <br>if (value &gt; maxValue) { <br>maxValue = value; <br>lNewX = i; <br>lNewY = j; <br>} <br>} <br>} <br>} <br>} <br> <br>} else { <br> <br>// Choose a random slot <br>while (lFlag == 0) { <br> <br>lNewX = rand() % 3; <br>lNewY = rand() % 3; <br> <br>if (plField [lNewX][lNewY] == 0) <br>lFlag = 1; <br>} <br>} <br>} <br> <br>// Prepare return values <br>lX = lNewX; <br>lY = lNewY; <br>} <br> <br>float CComputer::Evaluate (long lX, long lY) { <br> <br>long lNewX, lNewY, lNewX2, lNewY2; <br>float fEval1, fEval2, fEval3; <br> <br>if (plField[lX][lY] != 0) { <br> <br>lX = - 100; <br>lY = - 100; <br>return - 100; <br>} else { <br> <br>// Evaluate defensive options <br>plField[lX][lY] = 1; <br>fEval2 = (float) (LineScan (1, lNewX, lNewY) / 3); <br> <br>// Evaluate offensive options <br>plField[lX][lY] = 2; <br>fEval1 = (float) LineScan (2, lNewX, lNewY); <br> <br>// Evaluate opponent's follow-up <br>if (fEval1 &gt; 0) { <br>plField[lNewX][lNewY] = 1; <br>fEval3 = (float) (LineScan (1, lNewX2, lNewY2) * 0.9); <br>plField[lNewX][lNewY] = 0; <br>} else <br>fEval3 = 0; <br> <br>// Restore tiles and return final evaluation <br>plField[lX][lY] = 0; <br>return fEval1 + fEval2 - fEval3; <br>} <br>} <br> <br> <br>bool CComputer::IsWin (long lPlayer) { <br> <br>bool bWin = false; <br> <br>for (int i = 0; i &lt; 3; i ++) { <br>if (plField [i][0] == plField [i][1] &amp;&amp; plField [i][1] == plField [i][2] &amp;&amp; plField [i][0] == lPlayer) <br>bWin = true; <br>if (plField [0][i] == plField [1][i] &amp;&amp; plField [1][i] == plField [2][i] &amp;&amp; plField [0][i] == lPlayer) <br>bWin = true; <br>} <br> <br>if (plField [0][0] == plField [1][1] &amp;&amp; plField [1][1] == plField [2][2] &amp;&amp; plField [1][1] == lPlayer) <br>bWin = true; <br>if (plField [2][0] == plField [1][1] &amp;&amp; plField [1][1] == plField [0][2] &amp;&amp; plField [1][1] == lPlayer) <br>bWin = true; <br> <br>return bWin; <br>} <br> <br> <br>long CComputer::HowManyTurns () { <br> <br>long lTurns = 0; <br> <br>for (int i = 0; i &lt; 3; i ++) { <br>for (int j = 0; j &lt; 3; j ++) { <br>if (plField[i][j] &gt; 0) { <br>lTurns ++; <br>} <br>} <br>} <br> <br>return lTurns; <br>} <br> <br> <br>long CComputer::LineScan (long lPlayer, long&amp; lX, long&amp; lY) { <br> <br>long lCounter = 0; <br>lX = - 100; <br>lY = - 100; <br> <br>// Horizontal lines <br>for (int i = 0; i &lt; 3; i ++) { <br> <br>if (plField [1][i] == lPlayer &amp;&amp; plField [0][i] == lPlayer &amp;&amp; plField[2][i] == 0) { <br>lX = 2; <br>lY = i; <br>lCounter ++; <br>} <br> <br>if (plField [0][i] == lPlayer &amp;&amp; plField [2][i] == lPlayer &amp;&amp; plField[1][i] == 0) { <br>lX = 1; <br>lY = i; <br>lCounter ++; <br>} <br> <br>if (plField [1][i] == lPlayer &amp;&amp; plField [2][i] == lPlayer &amp;&amp; plField[0][i] == 0) { <br>lX = 0; <br>lY = i; <br>lCounter ++; <br>} <br>} <br> <br>// Vertical lines <br>for (i = 0; i &lt; 3; i ++) { <br> <br>if (plField [i][1] == lPlayer &amp;&amp; plField [i][0] == lPlayer &amp;&amp; plField[i][2] == 0) { <br>lX = i; <br>lY = 2; <br>lCounter ++; <br>} <br> <br>if (plField [i][0] == lPlayer &amp;&amp; plField [i][2] == lPlayer &amp;&amp; plField[i][1] == 0) { <br>lX = i; <br>lY = 1; <br>lCounter ++; <br>} <br> <br>if (plField [i][1] == lPlayer &amp;&amp; plField [i][2] == lPlayer &amp;&amp; plField[i][0] == 0) { <br>lX = i; <br>lY = 0; <br>lCounter ++; <br>} <br>} <br> <br>// Diagonals <br>if (plField [1][1] == lPlayer &amp;&amp; plField [0][0] == lPlayer &amp;&amp; plField[2][2] == 0) { <br>lX = 2; <br>lY = 2; <br>lCounter ++; <br>} <br> <br>if (plField [1][1] == lPlayer &amp;&amp; plField [2][0] == lPlayer &amp;&amp; plField[0][2] == 0) { <br>lX = 0; <br>lY = 2; <br>lCounter ++; <br>} <br> <br>if (plField [1][1] == lPlayer &amp;&amp; plField [0][2] == lPlayer &amp;&amp; plField[2][0] == 0) { <br>lX = 2; <br>lY = 0; <br>lCounter ++; <br>} <br> <br>if (plField [1][1] == lPlayer &amp;&amp; plField [2][2] == lPlayer &amp;&amp; plField[0][0] == 0) { <br>lX = 0; <br>lY = 0; <br>lCounter ++; <br>} <br> <br>if (plField [0][0] == lPlayer &amp;&amp; plField [2][2] == lPlayer &amp;&amp; plField[1][1] == 0) { <br>lX = 1; <br>lY = 1; <br>lCounter ++; <br>} <br>if (plField [0][2] == lPlayer &amp;&amp; plField [2][0] == lPlayer &amp;&amp; plField[1][1] == 0) { <br>lX = 1; <br>lY = 1; <br>lCounter ++; <br>} <br> <br>return lCounter; <br>} <br> <br> <br>HRESULT CComputer::LoadArray (long lGameID) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br>ISharedProperty* spmPropField[3][3]; <br> <br>// Get context <br>hr = GetObjectContext(&amp;pObjectContext); <br> <br>// Create the SharedPropertyGroupManager <br>hr = pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>hr = spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup); <br> <br>// Load the field SharedProperties <br>TCHAR szBuf [512]; <br>BSTR bstrField; <br>CComVariant vField; <br> <br>for (long i = 0; i &lt; 3; i ++ ) { <br>for (long j = 0; j &lt; 3; j ++) { <br> <br>wsprintf (szBuf, _T("%dField%d%d"), lGameID, i, j); <br>bstrField = TCHAR2BSTR (szBuf); <br>hr = spmGroup-&gt;CreateProperty (bstrField, &amp;bExists, &amp;spmPropField[i][j]); <br>::SysFreeString (bstrField); <br> <br>hr = spmPropField[i][j]-&gt;get_Value (&amp;vField); <br>plField[i][j] = vField.lVal; <br>} <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>for (i = 0; i &lt; 3; i ++) { <br>for (long j = 0; j &lt; 3; j ++) { <br>if (spmPropField[i][j]) { <br>spmPropField[i][j]-&gt;Release(); <br>} <br>} <br>} <br> <br>return hr; <br>} <br> <br> <br>HRESULT CComputer::SaveArray (long lGameID) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br>ISharedProperty* spmPropField[3][3]; <br> <br>// Get context <br>hr = GetObjectContext(&amp;pObjectContext); <br> <br>// Create the SharedPropertyGroupManager <br>hr = pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>hr = spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup); <br> <br>// Save the field SharedProperties <br>TCHAR szBuf [512]; <br>BSTR bstrField; <br>CComVariant vField; <br>vField.vt = VT_I4; <br> <br>for (long i = 0; i &lt; 3; i ++ ) { <br>for (long j = 0; j &lt; 3; j ++) { <br> <br>wsprintf (szBuf, _T("%dField%d%d"), lGameID, i, j); <br>bstrField = TCHAR2BSTR (szBuf); <br>hr = spmGroup-&gt;CreateProperty (bstrField, &amp;bExists, &amp;spmPropField[i][j]); <br>::SysFreeString (bstrField); <br> <br>vField.lVal = plField[i][j]; <br>hr = spmPropField[i][j]-&gt;put_Value (vField); <br>} <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>for (i = 0; i &lt; 3; i ++) { <br>for (long j = 0; j &lt; 3; j ++) { <br>if (spmPropField[i][j]) { <br>spmPropField[i][j]-&gt;Release(); <br>} <br>} <br>} <br> <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
