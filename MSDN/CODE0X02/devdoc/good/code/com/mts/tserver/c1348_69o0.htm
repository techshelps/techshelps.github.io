<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HUMAN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1350"></a>HUMAN.CPP</h2>
<pre><code>// Filename: Human.cpp <br>// <br>// Description:  Implementation of CHuman <br>// This file contains the code that handles the interaction between two <br>// human players. <br>// <br>// This file is provided as part of the Microsoft Transaction Server Samples <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT  <br>// WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,  <br>// INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES  <br>// OF MERCHANTABILITY AND/OR FITNESS FOR A  PARTICULAR  <br>// PURPOSE. <br>// <br>// Copyright (C) 1997 Microsoft Corporation, All rights reserved <br> <br>#include "stdafx.h" <br>#include "tServer.h" <br>#include "Human.h" <br> <br>#include &lt;mtx.h&gt; <br>#include &lt;mtxspm.h&gt; <br> <br> <br>STDMETHODIMP CHuman::InterfaceSupportsErrorInfo(REFIID riid) <br>{ <br>static const IID* arr[] =  <br>{ <br>&amp;IID_IHuman, <br>}; <br> <br>for (int i=0;i&lt;sizeof(arr)/sizeof(arr[0]);i++) <br>{ <br>if (InlineIsEqualGUID(*arr[i],riid)) <br>return S_OK; <br>} <br>return S_FALSE; <br>} <br> <br> <br>STDMETHODIMP CHuman::EnterNewGame (IN BSTR bstrLocalName, OUT VARIANT* pvGameID, OUT VARIANT* pvName, <br>   OUT VARIANT* pvOrder) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br> <br>ISharedProperty* spmPropCounter = NULL; <br>ISharedProperty* spmPropFirstName = NULL; <br>ISharedProperty* spmPropSecondName = NULL; <br>ISharedProperty* spmPropState = NULL; <br> <br>pvGameID-&gt;vt = VT_I4; <br>pvName-&gt;vt = VT_BSTR; <br>pvOrder-&gt;vt = VT_I4; <br> <br>long lGameID = 0; <br>long lOrder = 0; <br> <br>try { <br> <br>// Get the object context <br>THROW_ERR ( hr = GetObjectContext (&amp;pObjectContext) ); <br>if (pObjectContext == NULL) { <br>THROW_ERR ( E_FAIL ); <br>} <br> <br>// Create the SharedPropertyGroupManager <br>THROW_ERR ( pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr) ); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>THROW_ERR ( spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup) ); <br> <br>// Create SharedProperties <br>CComVariant vCounter; <br> <br>THROW_ERR ( spmGroup-&gt;CreateProperty (L"Counter", &amp;bExists, &amp;spmPropCounter) ); <br>THROW_ERR ( spmPropCounter-&gt;get_Value (&amp;vCounter) ); <br> <br>CComVariant vSecondName; <br>CComVariant vState; <br> <br>TCHAR szBuf [512]; <br>BSTR bstrSecondName; <br>BSTR bstrFirstName; <br>BSTR bstrState; <br> <br>// Find first open two-human game <br>if (vCounter.lVal == 0) { <br>vCounter.lVal = 1; <br>} else { <br>long lScan = 1; <br>bool bFlag = false; <br>while (lScan &lt; vCounter.lVal &amp;&amp; !bFlag) { <br> <br>wsprintf (szBuf, _T("%dState"), lScan); <br>bstrState = TCHAR2BSTR (szBuf); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrState, &amp;bExists, &amp;spmPropState) ); <br>::SysFreeString (bstrState); <br> <br>THROW_ERR ( spmPropState-&gt;get_Value (&amp;vState) ); <br> <br>if (vState.lVal &lt; 2) { <br> <br>// Found a game <br>bFlag = true; <br>} else <br>lScan ++; <br> <br>THROW_ERR ( spmPropState-&gt;Release() ); <br>} <br> <br>vCounter.lVal = lGameID = lScan; <br>} <br> <br>wsprintf (szBuf, _T("%dSecondName"), vCounter.lVal); <br>bstrSecondName = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dState"), vCounter.lVal); <br>bstrState = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dFirstName"), vCounter.lVal); <br>bstrFirstName = TCHAR2BSTR (szBuf); <br> <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrFirstName, &amp;bExists, &amp;spmPropFirstName) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrSecondName, &amp;bExists, &amp;spmPropSecondName) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrState, &amp;bExists, &amp;spmPropState) ); <br> <br>::SysFreeString (bstrFirstName); <br>::SysFreeString (bstrSecondName); <br>::SysFreeString (bstrState); <br> <br>// Get current state <br>THROW_ERR ( spmPropState-&gt;get_Value (&amp;vState) ); <br> <br>// State table <br>// =========== <br>// 0 - No one in game <br>// 1 - One player lurking <br>// 2 - Second player joined <br>// 3 - First player's turn <br>// 4 - Second player's turn <br> <br>// Is this the first time this property has been accessed? <br>if (!bExists) <br>vState.lVal = 0; <br> <br>// Is there someone lurking already? <br>if (vState.lVal == 1) { <br> <br>CComVariant vFirstName; <br> <br>// Get opponent's name <br>THROW_ERR ( spmPropFirstName-&gt;get_Value (&amp;vFirstName) ); <br> <br>// Submit own name <br>CComVariant vSecondName2; <br>vSecondName2.vt = VT_BSTR; <br> <br>vSecondName2.bstrVal = ::SysAllocString (bstrLocalName); <br>THROW_ERR ( spmPropSecondName-&gt;put_Value (vSecondName2) ); <br>::SysFreeString (vSecondName2.bstrVal); <br> <br>// Update state <br>vState.lVal = 2; <br>THROW_ERR ( spmPropState-&gt;put_Value (vState) ); <br> <br>// Assign gameID <br>lGameID = vCounter.lVal; <br> <br>// Initialize the game screen array <br>InitArray(); <br>THROW_ERR ( SaveArray(lGameID) ); <br> <br>// Prepare return values <br>pvName-&gt;bstrVal = ::SysAllocString (vFirstName.bstrVal); <br>pvOrder-&gt;lVal = 2; <br>pvGameID-&gt;lVal = lGameID; <br> <br>} else { <br> <br>CComVariant vFirstName; <br>vFirstName.vt = VT_BSTR; <br> <br>// Update first name <br>vFirstName.bstrVal = ::SysAllocString (bstrLocalName); <br>THROW_ERR ( spmPropFirstName-&gt;put_Value (vFirstName) ); <br>::SysFreeString (vFirstName.bstrVal); <br> <br>// Update counter for next game <br>vCounter.lVal = vCounter.lVal + 1; <br>THROW_ERR ( spmPropCounter-&gt;put_Value (vCounter) ); <br> <br>// Update state <br>vState.lVal = 1; <br>THROW_ERR ( spmPropState-&gt;put_Value (vState) ); <br> <br>// Assign gameID <br>lGameID = vCounter.lVal - 1; <br> <br>// Prepare return values <br>pvName-&gt;bstrVal = ::SysAllocString (L"No one"); <br>pvOrder-&gt;lVal = 1; <br>pvGameID-&gt;lVal = lGameID; <br>} <br> <br>// We're finished and happy <br>pObjectContext-&gt;SetComplete(); <br> <br>} catch (HRESULT hr) { <br> <br>// Create an ErrorInfo object <br>ICreateErrorInfo* pCreateErrInfo = NULL; <br>IErrorInfo* pErrInfo = NULL; <br> <br>CreateErrorInfo (&amp;pCreateErrInfo); <br>pCreateErrInfo-&gt;QueryInterface (IID_IErrorInfo, (LPVOID FAR*) &amp;pErrInfo); <br> <br>// Fill in error information <br>TCHAR szErr [512]; <br>wsprintf (szErr, _T("Error %d occurred in Human::EnterNewGame()"), hr); <br>BSTR bstrDesc = TCHAR2BSTR (szErr); <br> <br>pCreateErrInfo-&gt;SetGUID (IID_IComputer); <br>pCreateErrInfo-&gt;SetSource (L"Computer"); <br>pCreateErrInfo-&gt;SetDescription (bstrDesc); <br>::SysFreeString (bstrDesc); <br> <br>// Confirm error information <br>SetErrorInfo (0, pErrInfo); <br> <br>// Clean up the error objects <br>if (pCreateErrInfo) <br>pCreateErrInfo-&gt;Release(); <br> <br>if (pErrInfo) <br>pErrInfo-&gt;Release(); <br> <br>// Indicate our unhappiness <br>if (pObjectContext) <br>pObjectContext-&gt;SetAbort(); <br> <br>hr = E_FAIL; <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>if (spmPropCounter) <br>spmPropCounter-&gt;Release(); <br> <br>if (spmPropFirstName) <br>spmPropFirstName-&gt;Release(); <br> <br>if (spmPropSecondName) <br>spmPropSecondName-&gt;Release(); <br> <br>if (spmPropState) <br>spmPropState-&gt;Release(); <br> <br>return hr; <br>} <br> <br> <br>STDMETHODIMP CHuman::NewMove (IN long lGameID, IN long lOrder, IN long lX, IN long lY, OUT VARIANT* pvWin) { <br> <br>// Win protocol <br>// ============ <br>// 0  -&gt; move did not end game <br>// 1  -&gt; player won <br>// -1 -&gt; remote player won (won't occur in this function) <br>// 2  -&gt; player's move tied the game <br>// -2 -&gt; remote player's move tied the game (won't occur in this function) <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br> <br>ISharedProperty* spmPropState = NULL; <br>ISharedProperty* spmPropX = NULL; <br>ISharedProperty* spmPropY = NULL; <br>ISharedProperty* spmPropWin = NULL; <br> <br>pvWin-&gt;vt = VT_I4; <br> <br>long lWin = 0; <br> <br> <br>try { <br> <br>// Get the object context <br>THROW_ERR ( hr = GetObjectContext(&amp;pObjectContext) ); <br>if (pObjectContext == NULL) { <br>THROW_ERR ( E_FAIL ); <br>} <br> <br>// Create the SharedPropertyGroupManager <br>THROW_ERR ( pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager,  <br>IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr) ); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>THROW_ERR ( spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, <br>&amp;bExists, &amp;spmGroup) ); <br> <br>// Create SharedProperties <br>BSTR bstrState; <br>BSTR bstrX; <br>BSTR bstrY; <br>BSTR bstrWin; <br>TCHAR szBuf[512]; <br>wsprintf (szBuf, _T("%dState"), lGameID); <br>bstrState = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dX"), lGameID); <br>bstrX = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dY"), lGameID); <br>bstrY = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dWin"), lGameID); <br>bstrWin = TCHAR2BSTR (szBuf); <br> <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrState, &amp;bExists, &amp;spmPropState) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrX, &amp;bExists, &amp;spmPropX) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrY, &amp;bExists, &amp;spmPropY) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrWin, &amp;bExists, &amp;spmPropWin) ); <br> <br>::SysFreeString (bstrState); <br>::SysFreeString (bstrX); <br>::SysFreeString (bstrY); <br>::SysFreeString (bstrWin); <br> <br>CComVariant vState; <br>CComVariant vX; <br>CComVariant vY; <br>CComVariant vWin; <br>vState.vt = VT_I4; <br>vX.vt = VT_I4; <br>vY.vt = VT_I4; <br>vWin.vt = VT_I4; <br> <br>// Load screen data <br>THROW_ERR ( LoadArray(lGameID) ); <br> <br>// Save player's move to local storage and to Spam <br>plField[lX][lY] = lOrder; <br> <br>vX.lVal = lX; <br>vY.lVal = lY; <br>THROW_ERR ( spmPropX-&gt;put_Value (vX) ); <br>THROW_ERR ( spmPropY-&gt;put_Value (vY) ); <br> <br>// Submit new state <br>if (lOrder == 1) <br>vState.lVal = 4; <br>else <br>vState.lVal = 3; <br> <br>THROW_ERR ( spmPropState-&gt;put_Value (vState) ); <br> <br>// Commit move to global storage <br>THROW_ERR ( SaveArray (lGameID) ); <br> <br>// Check for win <br>if (IsWin (lOrder)) { <br> <br>// Player wins <br>lWin = 1; <br> <br>// Other player loses <br>vWin.lVal = - 1; <br>THROW_ERR ( spmPropWin-&gt;put_Value (vWin) ); <br>} <br> <br>else if (HowManyTurns() == 9) { <br> <br>// Player ties on his move <br>lWin = 2; <br> <br>// Other player ties on opponent's move <br>vWin.lVal = - 2; <br>THROW_ERR ( spmPropWin-&gt;put_Value (vWin) ); <br>} <br> <br>// Prepare return values <br>pvWin-&gt;lVal = lWin; <br> <br>// We're happy and finished <br>pObjectContext-&gt;SetComplete(); <br> <br>} catch (HRESULT hr) { <br> <br>// Create an ErrorInfo object <br>ICreateErrorInfo* pCreateErrInfo = NULL; <br>IErrorInfo* pErrInfo = NULL; <br> <br>CreateErrorInfo (&amp;pCreateErrInfo); <br>pCreateErrInfo-&gt;QueryInterface (IID_IErrorInfo, (LPVOID FAR*) &amp;pErrInfo); <br> <br>// Fill in error information <br>TCHAR szErr [512]; <br>wsprintf (szErr, _T("Error %d occurred in Human::NewMove()"), hr); <br>BSTR bstrDesc = TCHAR2BSTR (szErr); <br>pCreateErrInfo-&gt;SetGUID (IID_IComputer); <br>pCreateErrInfo-&gt;SetSource (L"Computer"); <br>pCreateErrInfo-&gt;SetDescription (bstrDesc); <br>::SysFreeString (bstrDesc); <br> <br>// Confirm error information <br>SetErrorInfo (0, pErrInfo); <br> <br>// Clean up the error objects <br>if (pCreateErrInfo) <br>pCreateErrInfo-&gt;Release(); <br> <br>if (pErrInfo) <br>pErrInfo-&gt;Release(); <br> <br>// Indicate our unhappiness <br>if (pObjectContext) <br>pObjectContext-&gt;SetAbort(); <br> <br>hr = E_FAIL; <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>if (spmPropState) <br>spmPropState-&gt;Release(); <br> <br>if (spmPropX) <br>spmPropX-&gt;Release(); <br> <br>if (spmPropY) <br>spmPropY-&gt;Release(); <br> <br>if (spmPropWin) <br>spmPropWin-&gt;Release(); <br> <br>return hr; <br> <br>} <br> <br> <br>STDMETHODIMP CHuman::GetNewMove (IN long lGameID, IN long lOrder, OUT VARIANT* pvName, <br> OUT VARIANT* pvFoeX, OUT VARIANT* pvFoeY, OUT VARIANT* pvWin, <br> OUT VARIANT* pvUpdate) { <br> <br>// Win protocol <br>// ============ <br>// 0  -&gt; move did not end game <br>// 1  -&gt; player won (won't occur in this function) <br>// -1 -&gt; remote player won  <br>// 2  -&gt; player's move tied the game (won't occur in this function) <br>// -2 -&gt; remote player's move tied the game  <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br>ISharedProperty* spmPropState = NULL; <br>ISharedProperty* spmPropX = NULL; <br>ISharedProperty* spmPropY = NULL; <br>ISharedProperty* spmPropWin = NULL; <br>ISharedProperty* spmPropSecondName = NULL; <br> <br>pvName-&gt;vt = VT_BSTR; <br>pvFoeX-&gt;vt = VT_I4; <br>pvFoeY-&gt;vt = VT_I4; <br>pvWin-&gt;vt = VT_I4; <br>pvUpdate-&gt;vt = VT_I4; <br> <br>long lWin = 0; <br>long lUpdate = 0; <br>long lX = 0; <br>long lY = 0; <br> <br> <br>try { <br> <br>// Get the object context <br>THROW_ERR ( hr = GetObjectContext(&amp;pObjectContext) ); <br>if (pObjectContext == NULL) { <br>THROW_ERR ( E_FAIL ); <br>} <br> <br>// Create the SharedPropertyGroupManager <br>THROW_ERR ( pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, <br>IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr) ); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>THROW_ERR ( spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, <br>&amp;bExists, &amp;spmGroup) ); <br> <br>// Create SharedProperties <br>BSTR bstrState; <br>BSTR bstrX; <br>BSTR bstrY; <br>BSTR bstrWin; <br>BSTR bstrSecondName; <br>TCHAR szBuf[512]; <br>wsprintf (szBuf, _T("%dState"), lGameID); <br>bstrState = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dX"), lGameID); <br>bstrX = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dY"), lGameID); <br>bstrY = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dWin"), lGameID); <br>bstrWin = TCHAR2BSTR (szBuf); <br>wsprintf (szBuf, _T("%dSecondName"), lGameID); <br>bstrSecondName = TCHAR2BSTR (szBuf); <br> <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrState, &amp;bExists, &amp;spmPropState) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrX, &amp;bExists, &amp;spmPropX) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrY, &amp;bExists, &amp;spmPropY) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrWin, &amp;bExists, &amp;spmPropWin) ); <br>THROW_ERR ( spmGroup-&gt;CreateProperty (bstrSecondName, &amp;bExists, &amp;spmPropSecondName) ); <br> <br>::SysFreeString (bstrState); <br>::SysFreeString (bstrX); <br>::SysFreeString (bstrY); <br>::SysFreeString (bstrWin); <br>::SysFreeString (bstrSecondName); <br> <br>// Get state and move parameters <br>CComVariant vState; <br>CComVariant vX; <br>CComVariant vY; <br>CComVariant vWin; <br>CComVariant vSecondName; <br>THROW_ERR ( spmPropState-&gt;get_Value (&amp;vState) ); <br>THROW_ERR ( spmPropX-&gt;get_Value (&amp;vX) ); <br>THROW_ERR ( spmPropY-&gt;get_Value (&amp;vY) ); <br>THROW_ERR ( spmPropWin-&gt;get_Value (&amp;vWin) ); <br>THROW_ERR ( spmPropSecondName-&gt;get_Value (&amp;vSecondName) ); <br> <br>switch (vState.lVal) { <br> <br>case (0): <br> <br>// Shouldn't happen <br>THROW_ERR ( E_FAIL); <br>break; <br> <br>case (1): <br> <br>// Still waiting for next player to join <br>lUpdate = 0; <br>break; <br> <br>case (2): <br> <br>// Other player just joined <br>if (lOrder == 1) { <br>lUpdate = 2; <br>pvName-&gt;bstrVal = ::SysAllocString (vSecondName.bstrVal); <br> <br>// It's now the first player's turn <br>vState.lVal = 3; <br>THROW_ERR ( spmPropState-&gt;put_Value (vState) ); <br>} <br> <br>break; <br> <br>case (3): <br>case (4): <br> <br>long lTemp; <br>if (vState.lVal == 3) <br>lTemp = 1; <br>else <br>lTemp = 2; <br> <br>// Has other player moved? <br>if (lOrder == lTemp) { <br> <br>// Other player has moved <br>lX = vX.lVal; <br>lY = vY.lVal; <br>lWin = vWin.lVal; <br>lUpdate = 1; <br> <br>} else { <br> <br>// Waiting for other player to move <br>lUpdate = 0; <br>} <br> <br>break; <br> <br>default: <br> <br>// Shouldn't happen <br>THROW_ERR ( E_FAIL ); <br>break; <br>} <br> <br>// Prepare return values <br>pvFoeX-&gt;lVal = lX; <br>pvFoeY-&gt;lVal = lY; <br>pvWin-&gt;lVal = lWin; <br>pvUpdate-&gt;lVal = lUpdate; <br> <br>// We are finished and happy <br>pObjectContext-&gt;SetComplete(); <br> <br>} catch (HRESULT hr) { <br> <br>// Create an ErrorInfo object <br>ICreateErrorInfo* pCreateErrInfo = NULL; <br>IErrorInfo* pErrInfo = NULL; <br> <br>CreateErrorInfo (&amp;pCreateErrInfo); <br>pCreateErrInfo-&gt;QueryInterface (IID_IErrorInfo, (LPVOID FAR*) &amp;pErrInfo); <br> <br>// Fill in error information <br>TCHAR szErr [512]; <br>wsprintf (szErr, _T("Error %d occurred in Human::GetNewMove()"), hr); <br>BSTR bstrDesc = TCHAR2BSTR (szErr); <br>pCreateErrInfo-&gt;SetGUID (IID_IComputer); <br>pCreateErrInfo-&gt;SetSource (L"Computer"); <br>pCreateErrInfo-&gt;SetDescription (bstrDesc); <br>::SysFreeString (bstrDesc); <br> <br>// Confirm error information <br>SetErrorInfo (0, pErrInfo); <br> <br>// Clean up the error objects <br>if (pCreateErrInfo) <br>pCreateErrInfo-&gt;Release(); <br> <br>if (pErrInfo) <br>pErrInfo-&gt;Release(); <br> <br>// Indicate our unhappiness <br>if (pObjectContext) <br>pObjectContext-&gt;SetAbort(); <br> <br>hr = E_FAIL; <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>if (spmPropState) <br>spmPropState-&gt;Release(); <br> <br>if (spmPropX) <br>spmPropX-&gt;Release(); <br> <br>if (spmPropY) <br>spmPropY-&gt;Release(); <br> <br>if (spmPropWin) <br>spmPropWin-&gt;Release(); <br> <br>if (spmPropSecondName) <br>spmPropSecondName-&gt;Release(); <br> <br>return hr; <br>} <br> <br> <br>bool CHuman::IsWin (long lPlayer) { <br> <br>bool bWin = false; <br> <br>for (int i = 0; i &lt; 3; i ++) { <br>if (plField [i][0] == plField [i][1] &amp;&amp; plField [i][1] == plField [i][2] &amp;&amp; plField [i][0] == lPlayer) <br>bWin = true; <br>if (plField [0][i] == plField [1][i] &amp;&amp; plField [1][i] == plField [2][i] &amp;&amp; plField [0][i] == lPlayer) <br>bWin = true; <br>} <br> <br>if (plField [0][0] == plField [1][1] &amp;&amp; plField [1][1] == plField [2][2] &amp;&amp; plField [1][1] == lPlayer) <br>bWin = true; <br>if (plField [2][0] == plField [1][1] &amp;&amp; plField [1][1] == plField [0][2] &amp;&amp; plField [1][1] == lPlayer) <br>bWin = true; <br> <br>return bWin; <br>} <br> <br> <br>long CHuman::HowManyTurns () { <br> <br>long lTurns = 0; <br> <br>for (int i = 0; i &lt; 3; i ++) { <br>for (int j = 0; j &lt; 3; j ++) { <br>if (plField[i][j] &gt; 0) { <br>lTurns ++; <br>} <br>} <br>} <br> <br>return lTurns; <br>} <br> <br> <br>HRESULT CHuman::LoadArray (long lGameID) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br>ISharedProperty* spmPropField[3][3]; <br> <br>// Get context <br>hr = GetObjectContext(&amp;pObjectContext); <br> <br>// Create the SharedPropertyGroupManager <br>hr = pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>hr = spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup); <br> <br>// Load the field SharedProperties <br>TCHAR szBuf [512]; <br>BSTR bstrField; <br>CComVariant vField; <br> <br>for (long i = 0; i &lt; 3; i ++ ) { <br>for (long j = 0; j &lt; 3; j ++) { <br> <br>wsprintf (szBuf, _T("%dField%d%d"), lGameID, i, j); <br>bstrField = TCHAR2BSTR (szBuf); <br>hr = spmGroup-&gt;CreateProperty (bstrField, &amp;bExists, &amp;spmPropField[i][j]); <br>::SysFreeString (bstrField); <br> <br>hr = spmPropField[i][j]-&gt;get_Value (&amp;vField); <br>plField[i][j] = vField.lVal; <br>} <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>for (i = 0; i &lt; 3; i ++) { <br>for (long j = 0; j &lt; 3; j ++) { <br>if (spmPropField[i][j]) { <br>spmPropField[i][j]-&gt;Release(); <br>} <br>} <br>} <br> <br>return hr; <br>} <br> <br> <br>HRESULT CHuman::SaveArray (long lGameID) { <br> <br>HRESULT hr = S_OK; <br> <br>IObjectContext* pObjectContext = NULL; <br> <br>ISharedPropertyGroupManager* spmMgr = NULL; <br>ISharedPropertyGroup* spmGroup = NULL; <br>ISharedProperty* spmPropField[3][3]; <br> <br>// Get context <br>hr = GetObjectContext(&amp;pObjectContext); <br> <br>// Create the SharedPropertyGroupManager <br>hr = pObjectContext-&gt;CreateInstance (CLSID_SharedPropertyGroupManager, IID_ISharedPropertyGroupManager, (void**)&amp;spmMgr); <br> <br>// Create the SharedPropertyGroup <br>LONG lIsolationMode = LockMethod; <br>LONG lReleaseMode = Process; <br>VARIANT_BOOL bExists = VARIANT_FALSE; <br>hr = spmMgr-&gt;CreatePropertyGroup (L"TicTacToe", &amp;lIsolationMode, &amp;lReleaseMode, &amp;bExists, &amp;spmGroup); <br> <br>// Save the field shared properties <br>TCHAR szBuf [512]; <br>BSTR bstrField; <br>CComVariant vField; <br>vField.vt = VT_I4; <br> <br>for (long i = 0; i &lt; 3; i ++ ) { <br>for (long j = 0; j &lt; 3; j ++) { <br> <br>wsprintf (szBuf, _T("%dField%d%d"), lGameID, i, j); <br>bstrField = TCHAR2BSTR (szBuf); <br>hr = spmGroup-&gt;CreateProperty (bstrField, &amp;bExists, &amp;spmPropField[i][j]); <br>::SysFreeString (bstrField); <br> <br>vField.lVal = plField[i][j]; <br>hr = spmPropField[i][j]-&gt;put_Value (vField); <br>} <br>} <br> <br>if (pObjectContext) <br>pObjectContext-&gt;Release(); <br> <br>if (spmMgr) <br>spmMgr-&gt;Release(); <br> <br>if (spmGroup) <br>spmGroup-&gt;Release(); <br> <br>for (i = 0; i &lt; 3; i ++) { <br>for (long j = 0; j &lt; 3; j ++) { <br>if (spmPropField[i][j]) { <br>spmPropField[i][j]-&gt;Release(); <br>} <br>} <br>} <br> <br>return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
