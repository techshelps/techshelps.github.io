<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPERSTOR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1172"></a>IPERSTOR.CPP</h2>
<pre><code>/* <br> * IPERSTOR.CPP <br> * <br> * Template IPersistStorage interface implementation. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "iperstor.h" <br> <br> <br>/* <br> * CImpIPersistStorage:CImpIPersistStorage <br> * CImpIPersistStorage::~CImpIPersistStorage <br> * <br> * Constructor Parameters: <br> *  pObj            LPVOID pointing to the object we live in. <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> */ <br> <br>CImpIPersistStorage::CImpIPersistStorage(LPVOID pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    m_psState=PSSTATE_UNINIT; <br>    return; <br>    } <br> <br> <br>CImpIPersistStorage::~CImpIPersistStorage(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::QueryInterface <br> * CImpIPersistStorage::AddRef <br> * CImpIPersistStorage::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for CImpIPersistStorage. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistStorage::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistStorage::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::GetClassID <br> * <br> * Purpose: <br> *  Returns the CLSID of the object represented by this interface. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store our CLSID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID) <br>    { <br>    if (PSSTATE_UNINIT==m_psState) <br>        return E_UNEXPECTED; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::IsDirty <br> * <br> * Purpose: <br> *  Tells the caller if we have made changes to this object since <br> *  it was loaded or initialized new. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if <br> *                  NOT dirty. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::IsDirty(void) <br>    { <br>    if (PSSTATE_UNINIT==m_psState) <br>        return E_UNEXPECTED; <br> <br>    return S_FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::InitNew <br> * <br> * Purpose: <br> *  Provides the object with the IStorage to hold on to while the <br> *  object is running.  Here we initialize the structure of the <br> *  storage and AddRef it for incremental access. This function will <br> *  only be called once in the object's lifetime in lieu of Load. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE for the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::InitNew(LPSTORAGE pIStorage) <br>    { <br>    if (PSSTATE_UNINIT!=m_psState) <br>        return E_UNEXPECTED; <br> <br>    m_psState=PSSTATE_SCRIBBLE; <br> <br>    //Hold on to pIStorage for Save(..., TRUE) <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::Load <br> * <br> * Purpose: <br> *  Instructs the object to load itself from a previously saved <br> *  IStorage that was handled by Save in another object lifetime. <br> *  This function will only be called once in the object's lifetime <br> *  in lieu of InitNew. The object should hold on to pIStorage here <br> *  for incremental access and low-memory saves in Save. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE from which to load. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage) <br>    { <br>    if (PSSTATE_UNINIT!=m_psState) <br>        return E_UNEXPECTED; <br> <br>    m_psState=PSSTATE_SCRIBBLE; <br> <br>    //Hold on to pIStorage for Save(..., TRUE) <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::Save <br> * <br> * Purpose: <br> *  Saves the data for this object to an IStorage which may <br> *  or may not be the same as the one previously passed to <br> *  Load, indicated with fSameAsLoad.  After this call we may <br> *  not write into the storage again until SaveCompleted is <br> *  called, although we may still read. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE in which to save our data. <br> *  fSameAsLoad     BOOL indicating if this is the same pIStorage <br> *                  that was passed to Load.  If TRUE, then the <br> *                  object should write whatever it has *without <br> *                  *using any extra memory* as this may be a low <br> *                  memory save attempt.  That means that you must <br> *                  not try to open or create streams.  If FALSE <br> *                  you need to regenerate your whole storage <br> *                  structure, being sure to also release any <br> *                  pointers held from InitNew and Load. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage <br>    , BOOL fSameAsLoad) <br>    { <br>    //Have to come here from scribble state. <br>    if (PSSTATE_SCRIBBLE!=m_psState) <br>        return E_UNEXPECTED; <br> <br>    /* <br>     * Save your data to your open storages and streams if <br>     * fSameAsLoad is FALSE, otherwise save to the new pIStorage <br>     * but don't change your held pointers--you only do that in <br>     * SaveCompleted if given a different pIStorage. <br>     * <br>     * Also, do not call pIStorage-&gt;Commit.  That's the caller's <br>     * responsibility. <br>     */ <br> <br>    m_psState=PSSTATE_ZOMBIE; <br> <br>    //Clear your dirty flag. <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::SaveCompleted <br> * <br> * Purpose: <br> *  Notifies the object that the storage in pIStorage has been <br> *  completely saved now.  This is called when the user of this <br> *  object wants to save us in a completely new storage, and if <br> *  we normally hang on to the storage we have to reinitialize <br> *  ourselves here for this new one that is now complete. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE of the new storage in which we live. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::SaveCompleted(LPSTORAGE pIStorage) <br>    { <br>    //Must be called in no-scribble or hands-off state <br>    if (PSSTATE_ZOMBIE!=m_psState || PSSTATE_HANDSOFF!=m_psState) <br>        return E_UNEXPECTED; <br> <br>    /If we're coming from Hands-Off, we'd better get a storage <br>    if (NULL==pIStorage &amp;&amp; PSSTATE_HANDSOFF==m_psState) <br>        return E_UNEXPECTED; <br> <br>    /* <br>     * If in Hands-Off state and pIStorage is non-NULL, then <br>     * reopen storages and streams and hold the pointers, <br>     * returning to scribble state. <br>     * <br>     * If in no-scribble state and pIStorage is non-NULL, then <br>     * release currently held pointers and reopen pointers <br>     * in pIStorage. <br>     * <br>     * If in no-scribble state and pIStorage is NULL, do not <br>     * change your held pointers. <br>     */ <br> <br>    //Return to scribble if there are no errors <br>    m_psState=PSSTATE_SCRIBBLE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::HandsOffStorage <br> * <br> * Purpose: <br> *  Instructs the object that another agent is interested in having <br> *  total access to the storage we might be hanging on to from <br> *  InitNew or SaveCompleted.  In this case we must release our hold <br> *  and await another call to SaveCompleted before we have a hold <br> *  again.  Therefore we cannot read or write after this call until <br> *  SaveCompleted. <br> * <br> *  Situations where this might happen arise in compound document <br> *  scenarios where this object might be in-place active but the <br> *  application wants to rename and commit the root storage. <br> *  Therefore we are asked to close our hold, let the container <br> *  party on the storage, then call us again later to tell us the <br> *  new storage we can hold. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::HandsOffStorage(void) <br>    { <br>    /* <br>     * Must come from scribble or no-scribble.  A repeated call <br>     * to HandsOffStorage is an unexpected error (bug in client). <br>     */ <br>    if (PSSTATE_UNINIT==m_psState || PSSTATE_HANDSOFF==m_psState) <br>        return E_UNEXPECTED; <br> <br> <br>    /* <br>     * Release all held pointers regardless. <br>     */ <br> <br>    m_psState=PSSTATE_HANDSOFF; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
