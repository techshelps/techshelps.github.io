<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICONNPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1110"></a>ICONNPT.CPP</h2>
<pre><code>/* <br> * ICONNPT.CPP <br> * <br> * Template implemenation of a connection point object.  Usually <br> * these objects will be stand-alone objects contained within <br> * a connection point container. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "iconnpt.h" <br> <br> <br>/* <br> * CConnectionPoint::CConnectionPoint <br> * CConnectionPoint::~CConnectionPoint <br> * <br> * Parameters (Constructor): <br> *  pObj            LPVOID of the object we're in. <br> */ <br> <br>CConnectionPoint::CConnectionPoint(LPVOID pObj) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    return; <br>    } <br> <br>CConnectionPoint::~CConnectionPoint(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::QueryInterface <br> * CConnectionPoint::AddRef <br> * CConnectionPoint::Release <br> * <br> * Purpose: <br> *  Non-delegating IUnknown members for CConnectionPoint. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IConnectionPoint==riid) <br>        *ppv=(LPVOID)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionInterface <br> * <br> * Purpose: <br> *  Returns the IID of the outgoing interface supported through <br> *  this connection point. <br> * <br> * Parameters: <br> *  pIID            IID * in which to store the IID. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionPointContainer <br> * <br> * Purpose: <br> *  Returns a pointer to the IConnectionPointContainer that <br> *  is manageing this connection point. <br> * <br> * Parameters: <br> *  ppCPC           IConnectionPointContainer ** in which to return <br> *                  the pointer after calling AddRef. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionPointContainer <br>    (IConnectionPointContainer **ppCPC) <br>    { <br>    *ppCPC=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Advise <br> * <br> * Purpose: <br> *  Provides this connection point with a notification sink to <br> *  call whenever the appropriate outgoing function/event occurs. <br> * <br> * Parameters: <br> *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection <br> *                  point must QueryInterface on this pointer to obtain <br> *                  the proper interface to call.  The connection <br> *                  point must also insure that any pointer held has <br> *                  a reference count (QueryInterface will do it). <br> *  pdwCookie       DWORD * in which to store the connection key for <br> *                  later calls to Unadvise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Advise(LPUNKNOWN pUnkSink <br>    , DWORD *pdwCookie) <br>    { <br>    *pdwCookie=0; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Unadvise <br> * <br> * Purpose: <br> *  Terminates the connection to the notification sink identified <br> *  with dwCookie (that was returned from Advise).  The connection <br> *  point has to Release any held pointers for that sink. <br> * <br> * Parameters: <br> *  dwCookie        DWORD connection key from Advise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br>/* <br> * CConnectionPoint::EnumConnections <br> * <br> * Purpose: <br> *  Creates and returns an enumerator object with the <br> *  IEnumConnections interface that will enumerate the IUnknown <br> *  pointers of each connected sink. <br> * <br> * Parameters: <br> *  ppEnum          LPENUMCONNECTIONS in which to store the <br> *                  IEnumConnections pointer. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::EnumConnections <br>    (LPENUMCONNECTIONS *ppEnum) <br>    { <br>    *ppEnum=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
