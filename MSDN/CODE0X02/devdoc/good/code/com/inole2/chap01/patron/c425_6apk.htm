<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGES.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context428"></a>PAGES.CPP</h2>
<pre><code>/* <br> * PAGES.CPP <br> * Patron Chapter 1 <br> * <br> * Implementation of the CPages class.  See PAGEWIN.CPP and PRINT.CPP <br> * for additional member functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CPages:CPages <br> * CPages::~CPages <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application we're in. <br> */ <br> <br>CPages::CPages(HINSTANCE hInst) <br>    : CWindow(hInst) <br>    { <br>    m_iPageCur=NOVALUE;  //Pages are 0 indexed, this is one before <br>    m_cPages=0; <br>    m_hWndPageList=NULL; <br>    m_hFont=NULL; <br>    m_fSystemFont=FALSE; <br> <br>    //Initialize to 8.5*11 inch with .25 inch margins as a default. <br>    m_cx=(LOMETRIC_PER_INCH*17)/2; <br>    m_cy=LOMETRIC_PER_INCH*11; <br> <br>    m_xMarginLeft=LOMETRIC_PER_INCH/4; <br>    m_xMarginRight=LOMETRIC_PER_INCH/4; <br>    m_yMarginTop=LOMETRIC_PER_INCH/4; <br>    m_yMarginBottom=LOMETRIC_PER_INCH/4; <br> <br>    m_xPos=0L; <br>    m_yPos=0L; <br> <br>    m_dwIDNext=0; <br>    m_hDevMode=NULL; <br>    return; <br>    } <br> <br> <br>CPages::~CPages(void) <br>    { <br>    //Ensure memory is cleaned up in the list <br>    New(); <br> <br>    if (NULL!=m_hFont &amp;&amp; !m_fSystemFont) <br>        DeleteObject(m_hFont); <br> <br>    if (NULL!=m_hWndPageList) <br>        DestroyWindow(m_hWndPageList); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::Init <br> * <br> * Purpose: <br> *  Instantiates a pages window within a given parent.  The <br> *  parent may be a main application window, could be an MDI child <br> *  window. We really do not care. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  pRect           LPRECT that this window should occupy <br> *  dwStyle         DWORD containing the window's style flags. <br> *                  Should contain WS_CHILD | WS_VISIBLE in <br> *                  typical circumstances. <br> *  uID             UINT ID to associate with this window <br> *  pv              LPVOID unused for now. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::Init(HWND hWndParent, LPRECT pRect, DWORD dwStyle <br>    , UINT uID, LPVOID pv) <br>    { <br>    int     cy; <br> <br>    m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, SZCLASSPAGES <br>        , SZCLASSPAGES, dwStyle, pRect-&gt;left, pRect-&gt;top <br>        , pRect-&gt;right-pRect-&gt;left, pRect-&gt;bottom-pRect-&gt;top <br>        , hWndParent, (HMENU)uID, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    /* <br>     * Create the hidden listbox we'll use to track pages.  We give <br>     * it the owner-draw style so we can just store pointers in it. <br>     */ <br>    m_hWndPageList=CreateWindow(TEXT("listbox"), TEXT("Page List") <br>        , WS_POPUP | LBS_OWNERDRAWFIXED, 0, 0, 100, 100 <br>        , HWND_DESKTOP, NULL, m_hInst, NULL); <br> <br>    if (NULL==m_hWndPageList) <br>        return FALSE; <br> <br>    //Create a 14 point Arial font, or use the system variable font. <br>    cy=MulDiv(-14, LOMETRIC_PER_INCH, 72); <br>    m_hFont=CreateFont(cy, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE <br>        , ANSI_CHARSET, OUT_TT_PRECIS, CLIP_TT_ALWAYS, PROOF_QUALITY <br>        , VARIABLE_PITCH | FF_SWISS, TEXT("Arial")); <br> <br>    if (NULL==m_hFont) <br>        { <br>        m_hFont=(HFONT)GetStockObject(ANSI_VAR_FONT); <br>        m_fSystemFont=TRUE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::New <br> * <br> * Purpose: <br> *  Cleans out and reinitializes the data to defaults. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::New(void) <br>    { <br>    PCPage      pPage; <br>    UINT        i; <br> <br>    //First walk the page list and clean out the allocations. <br>    for (i=0; i &lt; m_cPages; i++) <br>        { <br>        if (PageGet(i, &amp;pPage, FALSE)) <br>            delete pPage; <br>        } <br> <br>    if (NULL!=m_hWndPageList) <br>        SendMessage(m_hWndPageList, LB_RESETCONTENT, 0, 0L); <br> <br>    if (NULL!=m_hDevMode) <br>        GlobalFree(m_hDevMode); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectGet <br> * <br> * Purpose: <br> *  Returns the rectangle of the Pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectGet(LPRECT pRect) <br>    { <br>    RECT        rc; <br>    POINT       pt; <br> <br>    //Retrieve the size of our rectangle in parent coordinates. <br>    GetWindowRect(m_hWnd, &amp;rc); <br>    pt.x=rc.left; <br>    pt.y=rc.top; <br>    ScreenToClient(GetParent(m_hWnd), &amp;pt); <br> <br>    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left) <br>        , pt.y+(rc.bottom-rc.top)); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectSet <br> * <br> * Purpose: <br> *  Sets a new rectangle for the Pages window which sizes to fit. <br> *  Coordinates are given in parent terms. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, pRect-&gt;left, pRect-&gt;top <br>        , (UINT)cx, (UINT)cy, SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::SizeGet <br> * <br> * Purpose: <br> *  Retrieves the size of the pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the size.  The right <br> *                  and bottom fields will contain the dimensions. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeGet(LPRECT pRect) <br>    { <br>    RectGet(pRect); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::SizeSet <br> * <br> * Purpose: <br> *  Sets a new size in parent coordinates for the Pages window. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy <br>        , SWP_NOMOVE | SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::ActivePage <br> * <br> * Purpose: <br> *  Returns a CPage pointer to the current page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCPage          Pointer to the current page. <br> */ <br> <br>PCPage CPages::ActivePage(void) <br>    { <br>    PCPage      pPage; <br>    BOOL        fRet; <br> <br>    fRet=PageGet(m_iPageCur, &amp;pPage, FALSE); <br>    return fRet ? pPage : NULL; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageInsert <br> * <br> * Purpose: <br> *  Creates a new page immediately after the current page.  If <br> *  there are no pages then this creates page 1. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index of the new page, 0 on failure. <br> */ <br> <br>UINT CPages::PageInsert(UINT uReserved) <br>    { <br>    //Create and open the new page. <br>    if (!PageAdd(m_iPageCur, m_dwIDNext, TRUE)) <br>        return 0; <br> <br>    m_dwIDNext++; <br>    m_iPageCur++; <br>    m_cPages++; <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageDelete <br> * <br> * Removes the current page from the page list. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index to the now current page from the page <br> *                  list, NOVALUE on error. <br> */ <br> <br>UINT CPages::PageDelete(UINT uReserved) <br>    { <br>    PCPage      pPage; <br> <br>    if (!PageGet(m_iPageCur, &amp;pPage, FALSE)) <br>        return NOVALUE; <br> <br>    //Delete the page in both the listbox and in memory. <br>    SendMessage(m_hWndPageList, LB_DELETESTRING, m_iPageCur, 0L); <br>    delete pPage; <br> <br> <br>    /* <br>     * If this is the last page then the current is one less.  If <br>     * it's the only page the current is zero.  Otherwise the <br>     * current is the next page. <br>     */ <br> <br>    if (m_iPageCur==m_cPages-1)   //Covers last or only page. <br>        m_iPageCur--; <br> <br>    m_cPages--; <br> <br>    if (0!=m_cPages) <br>        InvalidateRect(m_hWnd, NULL, FALSE); <br>    else <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    UpdateWindow(m_hWnd); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageGet <br> * <br> * Purpose: <br> *  Retrieves the index of the current page we're viewing. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the current page. <br> */ <br> <br>UINT CPages::CurPageGet(void) <br>    { <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageSet <br> * <br> * Purpose: <br> *  Sets the index of the current page to view. <br> * <br> * Parameters: <br> *  iPage           UINT index of the page to view. 0 means first <br> *                  page, NOVALUE means last page. <br> * <br> * Return Value: <br> *  UINT            Index of the previous current page, NOVALUE on <br> *                  error. <br> */ <br> <br>UINT CPages::CurPageSet(UINT iPage) <br>    { <br>    UINT    iPageNew; <br>    UINT    iPagePrev=m_iPageCur; <br> <br>    switch (iPage) <br>        { <br>        case 0: <br>            iPageNew=0; <br>            break; <br> <br>        case NOVALUE: <br>            iPageNew=m_cPages-1; <br>            break; <br> <br>        default: <br>            if (iPage &gt;= m_cPages) <br>                iPage=0; <br> <br>            iPageNew=iPage; <br>            break; <br>        } <br> <br>    //No reason to switch to the same page. <br>    if (iPagePrev==iPageNew) <br>        return iPage; <br> <br>    m_iPageCur=iPageNew; <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br>    return iPagePrev; <br>    } <br> <br> <br> <br>/* <br> * CPages::NumPagesGet <br> * <br> * Purpose: <br> *  Returns the number of pages this object current contains. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of pages we contain. <br> */ <br> <br>UINT CPages::NumPagesGet(void) <br>    { <br>    return m_cPages; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageGet <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a page of a given index returning a BOOL so it's simple <br> *  to use this function inside if statements. <br> * <br> * Parameters: <br> *  iPage           UINT page to retrieve. <br> *  ppPage          PCPage * in which to return the page <br> *                  pointer <br> *  fReserved       BOOL reserved for future use. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::PageGet(UINT iPage, PCPage *ppPage <br>    , BOOL fReserved) <br>    { <br>    if (NULL==ppPage) <br>        return FALSE; <br> <br>    if (LB_ERR!=SendMessage(m_hWndPageList, LB_GETTEXT <br>        , iPage, (LONG)ppPage)) <br>        return TRUE; <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageAdd <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new page initialized to the given values. <br> * <br> * Parameters: <br> *  iPage           UINT Location at which to insert page; new page <br> *                  is inserted after this position.  NOVALUE for <br> *                  the end. <br> *  cObjects        UINT number of objects on this page. <br> *  dwID            DWORD ID for this page. <br> *  fReserved       BOOL reserved for future use. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::PageAdd(UINT iPage, DWORD dwID, BOOL fReserved) <br>    { <br>    PCPage      pPage; <br>    LRESULT     lr; <br> <br>    pPage=new CPage(dwID); <br> <br>    if (NULL==pPage) <br>        return FALSE; <br> <br>    if (NOVALUE==iPage) <br>        iPage--; <br> <br>    //Now try to add to the listbox. <br>    lr=SendMessage(m_hWndPageList, LB_INSERTSTRING, iPage+1 <br>        , (LONG)pPage); <br> <br>    if (LB_ERRSPACE==lr) <br>        { <br>        delete pPage; <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
