<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context419"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Cosmo Chapter 1 <br> * <br> * Implementation of the CCosmoDoc derivation of CDocument as <br> * well as an implementation of CPolylineAdviseSink. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CCosmoDoc::CCosmoDoc <br> * CCosmoDoc::~CCosmoDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events <br> */ <br> <br>CCosmoDoc::CCosmoDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pPL=NULL; <br>    m_pPLAdv=NULL; <br>    m_uPrevSize=SIZE_RESTORED; <br>    return; <br>    } <br> <br> <br>CCosmoDoc::~CCosmoDoc(void) <br>    { <br>    //Clean up the allocations we did in Init <br>    if (NULL!=m_pPL) <br>        delete m_pPL; <br> <br>    if (NULL!=m_pPLAdv) <br>        delete m_pPLAdv; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Init <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Init(PDOCUMENTINIT pDI) <br>    { <br>    RECT        rc; <br> <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::Init(pDI)) <br>        return FALSE; <br> <br>    //Add the Polyline stuff we need. <br>    m_pPLAdv=new CPolylineAdviseSink(this); <br>    m_pPL   =new CPolyline(m_hInst); <br> <br>    //Attempt to create our contained Polyline. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    if (!m_pPL-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_POLYLINE, m_pPLAdv)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize <br> *  the Polyline. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    if (WM_SIZE==iMsg) <br>        { <br>        //Don't effect the Polyline size to or from minimized state. <br>        if (SIZE_MINIMIZED!=wParam &amp;&amp; SIZE_MINIMIZED !=m_uPrevSize) <br>            { <br>            //When we change size, resize any Polyline we hold. <br>            dx=LOWORD(lParam); <br>            dy=HIWORD(lParam); <br> <br>            /* <br>             * If we are getting WM_SIZE in response to a Polyline <br>             * notification, then don't resize the Polyline window <br>             * again. <br>             */ <br>            if (!m_fNoSize &amp;&amp; NULL!=m_pPL) <br>                { <br>                //Resize the polyline to fit the new client <br>                SetRect(&amp;rc, 8, 8, dx-8, dy-8); <br>                m_pPL-&gt;RectSet(&amp;rc, FALSE); <br> <br>                /* <br>                 * We consider sizing something that makes the file <br>                 * dirty, but not until we've finished the create <br>                 * process, which is why we set fNoDirty to FALSE <br>                 * in WM_CREATE since we get a WM_SIZE on the first <br>                 * creation. <br>                 */ <br>                if (!m_fNoDirty) <br>                    FDirtySet(TRUE); <br> <br>                SetRect(&amp;rc, 0, 0, dx, dy); <br> <br>                if (NULL!=m_pAdv) <br>                    m_pAdv-&gt;OnSizeChange(this, &amp;rc); <br> <br>                m_fNoDirty=FALSE; <br>                } <br>            } <br> <br>        m_uPrevSize=wParam; <br>        } <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with <br> *  no filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Clear(void) <br>    { <br>    //Completely reset the polyline <br>    m_pPL-&gt;New(); <br> <br>    CDocument::Clear(); <br>    m_lVer=0; <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the Polyline window.  We do this by <br> *  opening the file and telling the Polyline to load itself from <br> *  that file. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load, NULL if the file <br> *                  is new and untitled. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    if (NULL==pszFile) <br>        { <br>        //For a new untitled document, just rename ourselves. <br>        Rename(NULL); <br>        m_lVer=VERSIONCURRENT; <br>        return DOCERR_NONE; <br>        } <br> <br>    m_lVer=m_pPL-&gt;ReadFromFile(pszFile); <br> <br>    if (POLYLINE_E_READFAILURE==m_lVer) <br>        return DOCERR_READFAILURE; <br> <br>    if (POLYLINE_E_UNSUPPORTEDVERSION==m_lVer) <br>        return DOCERR_UNSUPPORTEDVERSION; <br> <br>    if (fChangeFile) <br>        Rename(pszFile); <br> <br>    //Importing a file makes things dirty <br>    FDirtySet(!fChangeFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Save <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user has <br> *  previously used FileOpen or FileSaveAs to provide a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Save(UINT uType, LPTSTR pszFile) <br>    { <br>    LONG        lVer, lRet; <br>    UINT        uTemp; <br>    BOOL        fRename=TRUE; <br> <br>    if (NULL==pszFile) <br>        { <br>        fRename=FALSE; <br>        pszFile=m_szFile; <br>        } <br> <br>    /* <br>     * Type 1 is the current version, type 2 is version 1.0 of the <br>     * Polyline so we use this to send the right version to <br>     * CPolyline::WriteToFile. <br>     */ <br> <br>    switch (uType) <br>        { <br>        case 0:         //From Save, use loaded version. <br>            lVer=m_lVer; <br>            break; <br> <br>        case 1: <br>            lVer=VERSIONCURRENT; <br>            break; <br> <br>        case 2: <br>            lVer=MAKELONG(0, 1);    //1.0 <br>            break; <br> <br>        default: <br>            return DOCERR_UNSUPPORTEDVERSION; <br>        } <br> <br>    /* <br>     * If the version the user wants to save is different from the <br>     * version that we loaded and m_lVer is not zero (new doc), <br>     * then inform the user of the version change and verify. <br>     */ <br>    if (0!=m_lVer &amp;&amp; m_lVer!=lVer) <br>        { <br>        TCHAR       szMsg[128]; <br> <br>        wsprintf(szMsg, PSZ(IDS_VERSIONCHANGE) <br>            , (UINT)HIWORD(m_lVer), (UINT)LOWORD(m_lVer) <br>            , (UINT)HIWORD(lVer), (UINT)LOWORD(lVer)); <br> <br>        uTemp=MessageBox(m_hWnd, szMsg, PSZ(IDS_DOCUMENTCAPTION) <br>            , MB_YESNOCANCEL); <br> <br>        if (IDCANCEL==uTemp) <br>            return DOCERR_CANCELLED; <br> <br>        //If the user won't upgrade, revert to loaded version. <br>        if (IDNO==uTemp) <br>            lVer=m_lVer; <br>        } <br> <br>    lRet=m_pPL-&gt;WriteToFile(pszFile, lVer); <br> <br>    if (POLYLINE_E_NONE!=lRet) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Saving makes us clean <br>    FDirtySet(FALSE); <br> <br>    //Update the known version of this document. <br>    m_lVer=lVer; <br> <br>    if (fRename) <br>        Rename(pszFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Undo <br> * <br> * Purpose: <br> *  Reverses a previous action. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Undo(void) <br>    { <br>    m_pPL-&gt;Undo(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Clip(HWND hWndFrame, BOOL fCut) <br>    { <br>    BOOL            fRet=TRUE; <br>    HGLOBAL         hMem; <br>    UINT            i; <br> <br>    //This array is so we can loop over the formats we provide. <br>    static UINT     rgcf[3]={0, CF_METAFILEPICT, CF_BITMAP}; <br>    const UINT      cFormats=3; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    //Clean out whatever junk is in the clipboard. <br>    EmptyClipboard(); <br> <br>    rgcf[0]=m_cf; <br> <br>    for (i=0; i &lt; cFormats; i++) <br>        { <br>        //Copy private data first. <br>        hMem=RenderFormat(rgcf[i]); <br> <br>        if (NULL!=hMem) <br>            SetClipboardData(rgcf[i], hMem); <br>        else <br>            fRet &amp;=FALSE; <br>        } <br> <br>    //Free clipboard ownership. <br>    CloseClipboard(); <br> <br>    //Delete our current data if "cut" succeeded. <br>    if (fRet &amp;&amp; fCut) <br>        { <br>        m_pPL-&gt;New(); <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::RenderFormat <br> * <br> * Purpose: <br> *  Renders a specific clipboard format into global memory. <br> * <br> * Parameters: <br> *  cf              UINT format to render. <br> * <br> * Return Value: <br> *  HGLOBAL         Global memory handle containing the data. <br> */ <br> <br>HGLOBAL CCosmoDoc::RenderFormat(UINT cf) <br>    { <br>    HGLOBAL     hMem; <br> <br>    if (cf==m_cf) <br>        { <br>        m_pPL-&gt;DataGetMem(VERSIONCURRENT, &amp;hMem); <br>        return hMem; <br>        } <br> <br>    switch (cf) <br>        { <br>        case CF_METAFILEPICT: <br>            return m_pPL-&gt;RenderMetafilePict(); <br> <br>        case CF_BITMAP: <br>            return (HGLOBAL)m_pPL-&gt;RenderBitmap(); <br>        } <br> <br>    return NULL; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPaste(void) <br>    { <br>    return IsClipboardFormatAvailable(m_cf); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Paste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Paste(HWND hWndFrame) <br>    { <br>    HGLOBAL         hMem; <br>    PPOLYLINEDATA   ppl; <br>    BOOL            fRet=FALSE; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    hMem=GetClipboardData(m_cf); <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br> <br>        //TRUE in wParam to cause PLN_SIZECHANGE notification <br>        m_pPL-&gt;DataSet(ppl, FALSE, TRUE); <br>        GlobalUnlock(hMem); <br> <br>        FDirtySet(TRUE); <br>        fRet=TRUE; <br>        } <br> <br>    CloseClipboard(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorSet <br> * <br> * Purpose: <br> *  Changes a color used in our contained Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color. <br> * <br> * Return Value: <br> *  COLORREF        Previous color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorSet(UINT iColor, COLORREF cr) <br>    { <br>    return m_pPL-&gt;ColorSet(iColor, cr); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorGet <br> * <br> * Purpose: <br> *  Retrieves a color currently in use in the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to retrieve. <br> * <br> * Return Value: <br> *  COLORREF        Current color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorGet(UINT iColor) <br>    { <br>    return m_pPL-&gt;ColorGet(iColor); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT index of the new line style to use. <br> * <br> * Return Value: <br> *  UINT            Previous line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleSet(UINT iStyle) <br>    { <br>    return m_pPL-&gt;LineStyleSet(iStyle); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Current line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleGet(void) <br>    { <br>    if (NULL==m_pPL)    //m_pPL might not be valid yet <br>        return 0L; <br> <br>    return m_pPL-&gt;LineStyleGet(); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::CPolylineAdviseSink <br> * CPolylineAdviseSink::~CPolylineAdviseSink <br> * <br> * Constructor Parameters: <br> *  pv              LPVOID to store in this object <br> */ <br> <br>CPolylineAdviseSink::CPolylineAdviseSink(LPVOID pv) <br>    { <br>    m_pv=pv; <br>    return; <br>    } <br> <br> <br>CPolylineAdviseSink::~CPolylineAdviseSink(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnPointChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline added or removed a point. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnPointChange(void) <br>    { <br>    PCDocument      pDoc=(PCDocument)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnSizeChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed size. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnSizeChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br>    RECT            rc; <br>    DWORD           dwStyle; <br> <br>    /* <br>     * Polyline window is informing us that it changed size in <br>     * response to setting it's data.  Therefore we have to <br>     * size ourselves accordingly but without moving the screen <br>     * position of the polyline window. <br>     */ <br> <br>    pDoc-&gt;m_fNoSize=TRUE; <br> <br>    //Set the document window size. <br>    GetWindowRect(pDoc-&gt;m_pPL-&gt;Window(), &amp;rc); <br>    InflateRect(&amp;rc, 8, 8); <br> <br>    //Adjust for a window sans menu <br>    dwStyle=GetWindowLong(pDoc-&gt;m_hWnd, GWL_STYLE); <br>    AdjustWindowRect(&amp;rc, dwStyle, FALSE); <br> <br>    SetWindowPos(pDoc-&gt;m_hWnd, NULL, 0, 0, rc.right-rc.left <br>        , rc.bottom-rc.top, SWP_NOMOVE | SWP_NOZORDER); <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnSizeChange(pDoc, &amp;rc); <br> <br>    pDoc-&gt;m_fNoSize=FALSE; <br>    pDoc-&gt;FDirtySet(TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnDataChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnDataChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnDataChange(pDoc); <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnColorChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed a color. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnColorChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnLineStyleChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed its line style. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnLineStyleChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
