<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRINT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context434"></a>PRINT.CPP</h2>
<pre><code>/* <br> * PRINT.CPP <br> * Patron Chapter 1 <br> * <br> * Implementation of printing functions for both CPatronDoc <br> * and CPages classes.  These functions are here to keep clutter <br> * down in document.cpp and pages.cpp. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br>#include "patron.h" <br> <br>static HWND g_hDlgPrint=NULL; <br>static BOOL g_fCancelPrint=FALSE; <br> <br> <br>/* <br> * CPatronDoc::Print <br> * <br> * Purpose: <br> *  Prints the current document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> * <br> * Return Value: <br> *  BOOL            TRUE if printing happened, FALSE if it didn't <br> *                  start or didn't complete. <br> */ <br> <br>BOOL CPatronDoc::Print(HWND hWndFrame) <br>    { <br>    PRINTDLG        pd; <br>    BOOL            fSuccess; <br> <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br>    pd.hwndOwner  =hWndFrame; <br>    pd.nCopies    =1; <br>    pd.nFromPage  =(USHORT)-1; <br>    pd.nToPage    =(USHORT)-1; <br>    pd.nMinPage   =1; <br>    pd.nMaxPage   =m_pPG-&gt;NumPagesGet(); <br> <br>    pd.lpfnPrintHook=PrintDlgHook; <br> <br>    //Get the current document printer settings <br>    pd.hDevMode=m_pPG-&gt;DevModeGet(); <br> <br>    pd.Flags=PD_RETURNDC | PD_ALLPAGES | PD_COLLATE <br>        | PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_ENABLEPRINTHOOK; <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (NULL!=pd.hDevMode) <br>        GlobalFree(pd.hDevMode); <br> <br>    if (NULL!=pd.hDevNames) <br>        GlobalFree(pd.hDevNames); <br> <br>    //Go do the actual printing. <br>    fSuccess=m_pPG-&gt;Print(pd.hDC, PSZ(IDS_DOCUMENTNAME), pd.Flags <br>        , pd.nFromPage, pd.nToPage, pd.nCopies); <br> <br>    if (!fSuccess) <br>        { <br>        MessageBox(m_hWnd, PSZ(IDS_PRINTERROR) <br>            , PSZ(IDS_DOCUMENTCAPTION), MB_OK); <br>        } <br> <br>    return fSuccess; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PrinterSetup <br> * <br> * Purpose: <br> *  Selects a new printer and options for this document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> *  fDefault        BOOL to avoid any dialog and just use the <br> *                  default. <br> * <br> * Return Value: <br> *  UINT            Undefined <br> */ <br> <br>UINT CPatronDoc::PrinterSetup(HWND hWndFrame, BOOL fDefault) <br>    { <br>    PRINTDLG        pd; <br> <br>    //Attempt to get printer metrics for the default printer. <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br> <br>    if (fDefault) <br>        pd.Flags=PD_RETURNDEFAULT; <br>    else <br>        { <br>        pd.hwndOwner=hWndFrame; <br>        pd.Flags=PD_PRINTSETUP; <br> <br>        //Get the current document printer settings <br>        pd.hDevMode=m_pPG-&gt;DevModeGet(); <br>        } <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (!m_pPG-&gt;DevModeSet(pd.hDevMode, pd.hDevNames)) <br>        { <br>        GlobalFree(pd.hDevNames); <br>        GlobalFree(pd.hDevMode); <br>        return FALSE; <br>        } <br> <br>    FDirtySet(TRUE); <br>    return 1; <br>    } <br> <br> <br> <br>/* <br> * PrintDlgHook <br> * <br> * Purpose: <br> *  Callback hook for the Print Dialog so we can hide the Setup <br> *  button.  Patron only allows Setup before anything exists on <br> *  the page, and is not written to handle setup at Print time. <br> */ <br> <br>UINT CALLBACK PrintDlgHook(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    if (WM_INITDIALOG==iMsg) <br>        { <br>        HWND        hWnd; <br> <br>        hWnd=GetDlgItem(hDlg, psh1); <br>        ShowWindow(hWnd, SW_HIDE); <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::DevModeSet <br> * <br> * Purpose: <br> *  Provides the Pages with the current printer information. <br> * <br> * Parameters: <br> *  hDevMode        HGLOBAL to the memory containing the DEVMODE. <br> *                  This function assumes responsibility for this <br> *                  handle. <br> *  hDevNames       HGLOBAL providing the driver name and device <br> *                  name from which we can create a DC for <br> *                  information. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we could accept this configuration, <br> *                  FALSE otherwise.  If we return TRUE we also <br> *                  delete the old memory we hold. <br> */ <br> <br>BOOL CPages::DevModeSet(HGLOBAL hDevMode, HGLOBAL hDevNames) <br>    { <br>    LPDEVNAMES      pdn; <br>    LPTSTR          psz; <br> <br>    if (NULL==hDevMode || NULL==hDevNames) <br>        return FALSE; <br> <br>    psz=(LPTSTR)GlobalLock(hDevNames); <br> <br>    if (NULL==psz) <br>        return FALSE; <br> <br>    pdn=(LPDEVNAMES)psz; <br>    lstrcpy(m_szDriver, psz+pdn-&gt;wDriverOffset); <br>    lstrcpy(m_szDevice, psz+pdn-&gt;wDeviceOffset); <br>    lstrcpy(m_szPort,   psz+pdn-&gt;wOutputOffset); <br>    GlobalUnlock(hDevNames); <br>    GlobalFree(hDevNames); <br> <br>    //Save this new memory and get rid of the old. <br>    if (NULL!=m_hDevMode) <br>        GlobalFree(m_hDevMode); <br> <br>    m_hDevMode=hDevMode; <br> <br>    return ConfigureForDevice(); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::DevModeGet <br> * <br> * Purpose: <br> *  Retrieves a copy of the current DEVMODE structure for this <br> *  Pages window.  The caller is responsible for this memory. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HGLOBAL         Handle to the memory containing the DEVMODE <br> *                  structure. <br> */ <br> <br>HGLOBAL CPages::DevModeGet(void) <br>    { <br>    HGLOBAL     hMem; <br>    DWORD       cb; <br>    DWORD       i; <br>    LPBYTE      pb1, pb2; <br> <br>    cb=GlobalSize(m_hDevMode); <br> <br>    if (0==cb) <br>        return NULL; <br> <br>    hMem=GlobalAlloc(GHND, cb); <br> <br>    if (NULL==hMem) <br>        return NULL; <br> <br>    pb1=(LPBYTE)GlobalLock(hMem); <br>    pb2=(LPBYTE)GlobalLock(m_hDevMode); <br> <br>    //Copy the existing DEVMODE structure <br>    for (i=0; i &lt; cb; i++) <br>        *pb1++=*pb2++; <br> <br>    GlobalUnlock(m_hDevMode); <br>    GlobalUnlock(hMem); <br> <br>    return hMem; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::ConfigureForDevice <br> * <br> * Purpose: <br> *  Recalculates our drawing configuration based on the contents of <br> *  an hDC.  If no HDC is given we use the contents of our DevMode <br> *  stream. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::ConfigureForDevice(void) <br>    { <br>    POINT           ptOffset, ptPaper; <br>    RECT            rc; <br>    HDC             hDC; <br>    LPDEVMODE       pdm; <br>    CHourglass      hg;     //Shows wait cursor, automatically destroyed <br> <br>    pdm=(LPDEVMODE)GlobalLock(m_hDevMode); <br> <br>    if (NULL==pdm) <br>        return FALSE; <br> <br>    //Get the DC then configure <br>    hDC=CreateIC(m_szDriver, m_szDevice, m_szPort, pdm); <br> <br>    GlobalUnlock(m_hDevMode); <br> <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    //Get usable page dimensions:  already sensitive to orientation <br>    m_cx=GetDeviceCaps(hDC, HORZSIZE)*10-16; //*10: mm to LOMETRIC <br>    m_cy=GetDeviceCaps(hDC, VERTSIZE)*10-16; //-16: for driver bugs. <br> <br>    //Calculate the printer-limited margins on sides in LOMETRIC. <br>    Escape(hDC, GETPRINTINGOFFSET, NULL, NULL, &amp;ptOffset); <br>    Escape(hDC, GETPHYSPAGESIZE,   NULL, NULL, &amp;ptPaper); <br> <br>    SetRect(&amp;rc, ptOffset.x, ptOffset.y, ptPaper.x, ptPaper.y); <br>    SetMapMode(hDC, MM_LOMETRIC); <br>    RectConvertMappings(&amp;rc, hDC, FALSE); <br> <br>    //Left and top margins are the printing offset. <br>    m_xMarginLeft= rc.left+8;   //+8 to match -16 above <br>    m_yMarginTop =-rc.top+8;    //LOMETRIC makes this negative. <br> <br>    //Right is (paper width)-(usable width)-(left margin) <br>    m_xMarginRight =rc.right-m_cx-m_xMarginLeft; <br> <br>    //Bottom is (paper height)-(usable height)-(top margin)+1 <br>    m_yMarginBottom=-rc.bottom-m_cy-m_yMarginTop+1; <br> <br>    UpdateScrollRanges(); <br> <br>    DeleteDC(hDC); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::Print <br> * <br> * Purpose: <br> *  Prints a specified range of pages to a given hDC.  Repeats for <br> *  a given number of copies. <br> * <br> * Parameters: <br> *  hDC             HDC to which we print. <br> *  pszDoc          LPTSTR providing the document name. <br> *  dwFlags         DWORD flags from PrintDlg <br> *  iPageStart      UINT starting page index (one based) <br> *  iPageEnd        UINT ending page index (one based).  Includes <br> *                  this page. <br> *  cCopies         UINT number of copies to print.  If PD_COLLATE <br> *                  in dwFlags is set, we print multiple copies of <br> *                  each page as we cycle through.  Otherwise we <br> *                  cycle multiple times. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::Print(HDC hDC, LPTSTR pszDoc, DWORD dwFlags <br>    , UINT iPageStart, UINT iPageEnd, UINT cCopies) <br>    { <br>    BOOL        fError=FALSE; <br>    int         iPage, iPageInc; <br>    int         iUserPage, cPages; <br>    UINT        iRepeat, cRepeat; <br>    UINT        iCycle, cCycles; <br>    UINT        iPageHold=m_iPageCur; <br>    HWND        hWndT, hWndTop=NULL; <br>    DOCINFO     di; <br>    PCDocument  pDoc; <br> <br>    //Validate hDC and page ranges <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    if ((PD_PAGENUMS &amp; dwFlags)) <br>        { <br>        if (-1==iPageStart) <br>            iPageStart=0; <br>        else <br>            iPageStart--;   //Switch to zero offset. <br> <br>        if (-1==iPageEnd) <br>            iPageEnd=m_cPages-1; <br>        else <br>            iPageEnd--;     //Switch to zero offset. <br>        } <br>    else //Can't test PD_ALLPAGES with &amp; since it's defined as 0L <br>        { <br>        iPageStart=0; <br>        iPageEnd=m_cPages-1; <br>        } <br> <br>    //Arrange cycles and repeats depending on cCopies and collating <br>    if (PD_COLLATE &amp; dwFlags) <br>        { <br>        cCycles=cCopies; <br>        cRepeat=1; <br>        } <br>    else <br>        { <br>        cCycles=1; <br>        cRepeat=cCopies; <br>        } <br> <br>    //Disable the frame window to prevent reentrancy while printing. <br>    hWndT=GetParent(m_hWnd); <br>    pDoc=(PCDocument)SendMessage(hWndT, DOCM_PDOCUMENT, 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        { <br>        PCFrame pFR; <br> <br>        pFR=pDoc-&gt;FrameGet(); <br>        hWndTop=pFR-&gt;Window(); <br>        EnableWindow(hWndTop, FALSE); <br>        } <br> <br>    SetAbortProc(hDC, AbortProc); <br>    g_fCancelPrint=FALSE; <br> <br>    //If these don't work then we'll just live without a dialog. <br>    g_hDlgPrint=CreateDialog(m_hInst, MAKEINTRESOURCE(IDD_PRINTING) <br>        , hWndTop, PrintDlgProc); <br> <br>    //Increment for either direction. <br>    iPageInc=(iPageStart &gt; iPageEnd) ? -1 : 1; <br> <br>    //Initial entries in dialog box. <br>    cPages=1+((int)(iPageEnd-iPageStart)*iPageInc); <br> <br>    SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE, 1, (LPARAM)cPages); <br>    SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, 1, (LPARAM)cRepeat); <br> <br>    di.cbSize=sizeof(DOCINFO); <br>    di.lpszDocName=pszDoc; <br>    di.lpszOutput=NULL; <br> <br>    if (StartDoc(hDC, &amp;di) &gt; 0) <br>        { <br>        /* <br>         * Iterate over the pages, repeating each page depending on <br>         * the copies we want and if we have collate enabled. <br>         */ <br> <br>        for (iCycle=1; iCycle &lt;= cCycles; iCycle++) <br>            { <br>            if (PD_COLLATE &amp; dwFlags) <br>                { <br>                SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, iCycle <br>                    , (LPARAM)cCycles); <br>                } <br> <br>            //iPageInc controls direction <br>            for (iPage=iPageStart; ; iPage+=iPageInc) <br>                { <br>                iUserPage=1+((iPage-(int)iPageStart)*iPageInc); <br> <br>                SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE <br>                    , iUserPage, (LPARAM)cPages); <br> <br>                m_iPageCur=iPage;   //We restore this later. <br> <br>                for (iRepeat=1; iRepeat &lt;= cRepeat; iRepeat++) <br>                    { <br>                    if (!(PD_COLLATE &amp; dwFlags)) <br>                        { <br>                        SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE <br>                            , iRepeat, (LPARAM)cRepeat); <br>                        } <br> <br>                    StartPage(hDC); <br>                    Draw(hDC, TRUE, TRUE); <br> <br>                    if (EndPage(hDC) &lt; 0) <br>                        fError=TRUE; <br> <br>                    if (fError || g_fCancelPrint) <br>                        break; <br>                    } <br> <br>                if (fError || g_fCancelPrint) <br>                    break; <br> <br>                //If we just printed the last page, time to quit. <br>                if (iPage==(int)iPageEnd) <br>                    break; <br>                } <br> <br>            if (fError || g_fCancelPrint) <br>                break; <br>            } <br> <br>        if (!fError) <br>            EndDoc(hDC); <br>        else <br>            AbortDoc(hDC); <br>        } <br>    else <br>        fError=TRUE; <br> <br>    //Set the page back to what it was before all this started. <br>    m_iPageCur=iPageHold; <br> <br>    EnableWindow(hWndTop, TRUE); <br>    SetFocus(hWndTop); <br>    DestroyWindow(g_hDlgPrint); <br>    DeleteDC(hDC); <br>    return !fError; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * AbortProc <br> * <br> * Purpose: <br> *  Abort procedure for printing the pages. <br> * <br> * Parameters: <br> *  hDC             HDC on which printing is happening. <br> *  iErr            int error code. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the print job, FALSE otherwise. <br> */ <br> <br>BOOL APIENTRY AbortProc(HDC hDC, int iErr) <br>    { <br>    MSG     msg; <br> <br>    while (!g_fCancelPrint <br>        &amp;&amp; PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>        if (NULL==g_hDlgPrint <br>            || !IsDialogMessage(g_hDlgPrint, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    return !g_fCancelPrint; <br>    } <br> <br> <br> <br> <br>/* <br> * PrintDlgProc <br> * <br> * Purpose: <br> *  Modeless dialog procedure for the dialog displayed while Patron <br> *  is printing pages. <br> */ <br> <br>BOOL APIENTRY PrintDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    TCHAR           szFormat[40]; <br>    TCHAR           szOutput[80]; <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE <br>                , MF_GRAYED); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            //Cancel button was pressed. <br>            g_fCancelPrint=TRUE; <br>            ShowWindow(hDlg, SW_HIDE); <br>            return TRUE; <br> <br>        case PRINTM_PAGEUPDATE: <br>            GetDlgItemText(hDlg, ID_PAGESTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTPAGE, szOutput); <br>            return TRUE; <br> <br>        case PRINTM_COPYUPDATE: <br>            GetDlgItemText(hDlg, ID_COPYSTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTCOPY, szOutput); <br>            return TRUE; <br>        } <br> <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
