<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context426"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Patron Chapter 1 <br> * <br> * Implementation of the CPatronDoc derivation of CDocument that <br> * manages pages for us. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br>#include &lt;memory.h&gt; <br>#include &lt;dlgs.h&gt;       //Pring Dlg button IDs <br> <br> <br>/* <br> * CPatronDoc::CPatronDoc <br> * CPatronDoc::~CPatronDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events. <br> */ <br> <br>CPatronDoc::CPatronDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pPG=NULL; <br>    m_lVer=VERSIONCURRENT; <br>    return; <br>    } <br> <br> <br>CPatronDoc::~CPatronDoc(void) <br>    { <br>    if (NULL!=m_pPG) <br>        delete m_pPG; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Init <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::Init(PDOCUMENTINIT pDI) <br>    { <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::Init(pDI)) <br>        return FALSE; <br> <br>    //Pages are created when we get a Load later. <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize the Pages <br> *  window. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    //Eat to prevent flickering <br>    if (WM_ERASEBKGND==iMsg) <br>        return TRUE; <br> <br>    if (WM_SIZE==iMsg &amp;&amp; NULL!=m_pPG) <br>        { <br>        dx=LOWORD(lParam); <br>        dy=HIWORD(lParam); <br> <br>        if (SIZE_MINIMIZED!=wParam) <br>            { <br>            //Resize Pages window to fit the new document size. <br>            GetClientRect(hWnd, &amp;rc); <br>            m_pPG-&gt;RectSet(&amp;rc, FALSE); <br>            } <br>        } <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with no <br> *  filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Clear(void) <br>    { <br>    //Completely reset the pages <br>    m_pPG-&gt;New(); <br> <br>    CDocument::Clear(); <br>    m_lVer=VERSIONCURRENT; <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the editor. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load.  Could be NULL <br> *                  for an untitled document. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CPatronDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    RECT        rc; <br> <br>    //We don't support opening anything yet. <br>    if (NULL!=pszFile) <br>        return DOCERR_NONE; <br> <br>    //Attempt to create our contained Pages window. <br>    m_pPG=new CPages(m_hInst); <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    if (!m_pPG-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_PAGES, NULL)) <br>        return DOCERR_NOFILE; <br> <br>    //Go initialize the Pages for the default printer. <br>    if (!PrinterSetup(NULL, TRUE)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    Rename(NULL); <br> <br>    //Go create an initial page. <br>    m_pPG-&gt;PageInsert(0); <br> <br>    FDirtySet(FALSE); <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NewPage <br> * <br> * Purpose: <br> *  Creates a new page in the document's pages control after the <br> *  current page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NewPage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageInsert(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::DeletePage <br> * <br> * Purpose: <br> *  Deletes the current page from the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the now current page. <br> */ <br> <br>UINT CPatronDoc::DeletePage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageDelete(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NextPage <br> * <br> * Purpose: <br> *  Shows the next page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NextPage(void) <br>    { <br>    UINT        iPage; <br> <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(++iPage); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PreviousPage <br> * <br> * Purpose: <br> *  Shows the previous page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::PreviousPage(void) <br>    { <br>    UINT        iPage; <br> <br>    //If iPage is zero, then we wrap around to the end. <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(--iPage); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FirstPage <br> * <br> * Purpose: <br> *  Shows the first page page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::FirstPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(0); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::LastPage <br> * <br> * Purpose: <br> *  Shows the last page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the last page. <br> */ <br> <br>UINT CPatronDoc::LastPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(NOVALUE); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
