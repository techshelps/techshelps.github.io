<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGEWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context430"></a>PAGEWIN.CPP</h2>
<pre><code>/* <br> * PAGEWIN.CPP <br> * Patron Chapter 1 <br> * <br> * Window procedure for the Pages window and support functions. <br> * This window manages its own scrollbars and viewport and provides <br> * printing capabilities as well. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * PagesWndProc <br> * <br> * Purpose: <br> *  Window procedure for the Pages window. <br> */ <br> <br>LRESULT APIENTRY PagesWndProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCPages         ppg; <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    int             iPos, iTmp; <br>    int             iMin, iMax; <br>    UINT            idScroll; <br> <br>    ppg=(PCPages)GetWindowLong(hWnd, PAGEWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            ppg=(PCPages)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, PAGEWL_STRUCTURE, (LONG)ppg); <br> <br>            ppg-&gt;m_hWnd=hWnd; <br>            ppg-&gt;New(); <br>            break; <br> <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br> <br>            //Draw only if we have a page to show. <br>            if (0!=ppg-&gt;m_cPages) <br>                ppg-&gt;Draw(hDC, FALSE, FALSE); <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br> <br>        case WM_HSCROLL: <br>        case WM_VSCROLL: <br>            idScroll=(WM_HSCROLL==iMsg) ? SB_HORZ : SB_VERT; <br> <br>            iPos=GetScrollPos(hWnd, idScroll); <br>            iTmp=iPos; <br>            GetScrollRange(hWnd, idScroll, &amp;iMin, &amp;iMax); <br> <br>            switch (LOWORD(wParam)) <br>                { <br>                case SB_LINEUP:     iPos -= 20;  break; <br>                case SB_PAGEUP:     iPos -=100;  break; <br>                case SB_LINEDOWN:   iPos += 20;  break; <br>                case SB_PAGEDOWN:   iPos +=100;  break; <br> <br>                case SB_THUMBPOSITION: <br>                    iPos=ScrollThumbPosition(wParam, lParam); <br>                    break; <br> <br>                //We don't want scrolling on this message. <br>                case SB_THUMBTRACK: <br>                    return 0L; <br>                } <br> <br>            iPos=max(iMin, min(iPos, iMax)); <br> <br>            if (iPos!=iTmp) <br>                { <br>                //Set the new position and scroll the window <br>                SetScrollPos(hWnd, idScroll, iPos, TRUE); <br> <br>                if (SB_HORZ==idScroll) <br>                    { <br>                    ppg-&gt;m_xPos=iPos; <br>                    ScrollWindow(hWnd, iTmp-iPos, 0, NULL, NULL); <br>                    } <br>                else <br>                    { <br>                    ppg-&gt;m_yPos=iPos; <br>                    ScrollWindow(hWnd, 0, iTmp-iPos, NULL, NULL); <br>                    } <br>                } <br> <br>            break; <br> <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * RectConvertMappings <br> * <br> * Purpose: <br> *  Converts the contents of a rectangle from device to logical <br> *  coordinates where the hDC defines the logical coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the rectangle to convert. <br> *  hDC             HDC describing the logical coordinate system. <br> *                  if NULL, uses a screen DC in MM_LOMETRIC. <br> *  fToDevice       BOOL TRUE to convert from uConv to device, <br> *                  FALSE to convert device to uConv. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void RectConvertMappings(LPRECT pRect, HDC hDC, BOOL fToDevice) <br>    { <br>    POINT   rgpt[2]; <br>    BOOL    fSysDC=FALSE; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    rgpt[0].x=pRect-&gt;left; <br>    rgpt[0].y=pRect-&gt;top; <br>    rgpt[1].x=pRect-&gt;right; <br>    rgpt[1].y=pRect-&gt;bottom; <br> <br>    if (NULL==hDC) <br>        { <br>        hDC=GetDC(NULL); <br>        SetMapMode(hDC, MM_LOMETRIC); <br>        fSysDC=TRUE; <br>        } <br> <br>    if (fToDevice) <br>        LPtoDP(hDC, rgpt, 2); <br>    else <br>        DPtoLP(hDC, rgpt, 2); <br> <br>    if (fSysDC) <br>        ReleaseDC(NULL, hDC); <br> <br>    pRect-&gt;left=rgpt[0].x; <br>    pRect-&gt;top=rgpt[0].y; <br>    pRect-&gt;right=rgpt[1].x; <br>    pRect-&gt;bottom=rgpt[1].y; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::Draw <br> * <br> * Purpose: <br> *  Paints the current page in the pages window. <br> * <br> * Parameters: <br> *  hDC             HDC to draw on, could be a metafile or printer <br> *                  DC or any other type of DC. <br> *  fNoColor        BOOL indicating if we should use screen colors <br> *                  or printer colors (B&amp;W).  Objects are printed <br> *                  as-is, however.  This is TRUE for printer DCs <br> *                  or print preview. <br> *  fPrinter        BOOL indicating if this is a printer DC in which <br> *                  case we eliminate some of the fancy drawing, <br> *                  like shadows on the page and so forth. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::Draw(HDC hDC, BOOL fNoColor, BOOL fPrinter) <br>    { <br>    RECT            rc, rcT; <br>    UINT            uMM; <br>    HPEN            hPen; <br>    HBRUSH          hBrush; <br>    HGDIOBJ         hObj1, hObj2; <br>    COLORREF        cr; <br>    TCHAR           szTemp[20]; <br>    UINT            cch; <br>    SIZE            sz; <br> <br>    //Make sure the DC is in LOMETRIC <br>    uMM=SetMapMode(hDC, MM_LOMETRIC); <br> <br>    if (!fPrinter) <br>        { <br>        /* <br>         * We maintain a 6mm border around the page on the screen <br>         * besides 12.7mm margins.  We also have to account for <br>         * the scroll position with m_*Pos which are in pixels so <br>         * we have to convert them. <br>         */ <br> <br>        SetRect(&amp;rcT, m_xPos, m_yPos, 0, 0); <br>        RectConvertMappings(&amp;rcT, hDC, FALSE); <br> <br>        rc.left  = LOMETRIC_BORDER-rcT.left; <br>        rc.top   =-LOMETRIC_BORDER-rcT.top; <br>        } <br>    else <br>        { <br>        /* <br>         * We define the corner of the printed paper at a negative <br>         * offset so rc.right and rc.bottom come out right below. <br>         */ <br>        SetRect(&amp;rc, -(int)m_xMarginLeft, m_yMarginTop, 0, 0); <br>        } <br> <br>    rc.right=rc.left+m_cx+(m_xMarginLeft+m_xMarginRight); <br>    rc.bottom=rc.top-m_cy-(m_yMarginTop+m_yMarginBottom); <br> <br>    //Draw a rect filled with the window color to show the page. <br>    if (!fPrinter) <br>        { <br>        if (fNoColor) <br>            { <br>            //Black frame, white box for printed colors. <br>            hPen  =CreatePen(PS_SOLID, 0, RGB(0,0,0)); <br>            hBrush=CreateSolidBrush(RGB(255, 255, 255)); <br>            } <br>        else <br>            { <br>            //Normal colors on display <br>            hPen=CreatePen(PS_SOLID, 0 <br>                , GetSysColor(COLOR_WINDOWFRAME)); <br>            hBrush=CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>            } <br> <br>        hObj1=SelectObject(hDC, hPen); <br>        hObj2=SelectObject(hDC, hBrush); <br> <br>        //Paper boundary <br>        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom+1); <br> <br>        /* <br>         * Draw a shadow on the *visual* bottom and right edges <br>         * .5mm wide.  If the button shadow color and workspace <br>         * colors match, then use black.  We always use black <br>         * when printing as well. <br>         */ <br>        if (fNoColor) <br>            cr=RGB(0,0,0); <br>        else <br>            { <br>            cr=GetSysColor(COLOR_BTNSHADOW); <br> <br>            if (GetSysColor(COLOR_APPWORKSPACE)==cr) <br>                cr=RGB(0,0,0); <br>            } <br> <br>        cr=SetBkColor(hDC, cr); <br>        SetRect(&amp;rcT, rc.left+5, rc.bottom, rc.right+5,rc.bottom-5); <br>        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rcT, NULL, 0, NULL); <br> <br>        SetRect(&amp;rcT, rc.right, rc.top-5, rc.right+5, rc.bottom-5); <br>        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rcT, NULL, 0, NULL); <br>        SetBkColor(hDC, cr); <br> <br>        SelectObject(hDC, hObj1); <br>        SelectObject(hDC, hObj2); <br>        DeleteObject(hBrush); <br>        DeleteObject(hPen); <br>        } <br> <br>    //Write the page number in the lower left corner <br>    if (!fNoColor) <br>        { <br>        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>        } <br> <br>    //Write the page number in our page font. <br>    cch=wsprintf(szTemp, TEXT("Page %d"), m_iPageCur+1); <br> <br>    hObj1=SelectObject(hDC, m_hFont); <br>    GetTextExtentPoint(hDC, szTemp, cch, &amp;sz); <br> <br>    TextOut(hDC, rc.left+m_xMarginLeft <br>        , rc.bottom+m_yMarginBottom+sz.cy, szTemp, cch); <br> <br>    SelectObject(hDC, hObj1); <br> <br>    //Rectangle to show border. <br>    MoveToEx(hDC, rc.left+m_xMarginLeft, rc.top-m_yMarginTop, NULL); <br>    LineTo(hDC, rc.left+m_xMarginLeft,   rc.bottom+m_yMarginBottom); <br>    LineTo(hDC, rc.right-m_xMarginRight, rc.bottom+m_yMarginBottom); <br>    LineTo(hDC, rc.right-m_xMarginRight, rc.top-m_yMarginTop); <br>    LineTo(hDC, rc.left+m_xMarginLeft,   rc.top-m_yMarginTop); <br> <br>    SetMapMode(hDC, uMM); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::UpdateScrollRanges <br> * <br> * Purpose: <br> *  Reset scrollbar ranges (horizontal and vertical) depending on <br> *  the window size and the page size.  This function may remove <br> *  the scrollbars altogether. <br> * <br> * Parameters: <br> *  None, but set m_cx, m_cy and size m_hWnd before calling. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::UpdateScrollRanges(void) <br>    { <br>    UINT        cxSB;   //Scrollbar width and height. <br>    UINT        cySB; <br>    UINT        cx, cy; <br>    UINT        dx, dy; <br>    UINT        u; <br>    int         iMin, iMax; <br>    RECT        rc; <br>    BOOL        fHScroll; <br>    BOOL        fVScroll; <br>    BOOL        fWasThere; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    cx=rc.right-rc.left; <br>    cy=rc.bottom-rc.top; <br> <br>    //Convert dimensions of the image in LOMETRIC to pixels. <br>    SetRect(&amp;rc, (m_cx+m_xMarginLeft+m_xMarginRight <br>        +LOMETRIC_BORDER*2), (m_cy+m_yMarginTop <br>        +m_yMarginBottom+LOMETRIC_BORDER*2), 0, 0); <br> <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br> <br>    dx=rc.left; <br>    dy=-rc.top; <br> <br>    //Assume that both scrollbars will be visible. <br>    fHScroll=TRUE; <br>    fVScroll=TRUE; <br> <br>    /* <br>     * Determine: <br>     *  1)  Which scrollbars are needed. <br>     *  2)  How many divisions to give scrollbars so as to <br>     *      only scroll as little as necessary. <br>     */ <br> <br>    //Scrollbar dimensions in our units. <br>    cxSB=GetSystemMetrics(SM_CXVSCROLL); <br>    cySB=GetSystemMetrics(SM_CYHSCROLL); <br> <br>    //Remove horizontal scroll if window &gt;= cxPage+borders <br>    if (cx &gt;= dx) <br>        fHScroll=FALSE; <br> <br> <br>    /* <br>     * If we still need a horizontal scroll, see if we need a <br>     * vertical taking the height of the horizontal scroll into <br>     * account. <br>     */ <br> <br>    u=fHScroll ? cySB : 0; <br> <br>    if ((cy-u) &gt;= dy) <br>        fVScroll=FALSE; <br> <br>    //Check if adding vert scrollbar necessitates a horz now. <br>    u=fVScroll ? cxSB : 0; <br>    fHScroll=((cx-u) &lt; dx); <br> <br>    /* <br>     * Modify cx,cy to reflect the new client area before scaling <br>     * scrollbars.  We only affect the client size if there is a <br>     * *change* in scrollbar status:  if the scrollbar was there <br>     * but is no longer, then add to the client size; if it was <br>     * not there but now is, then subtract. <br>     */ <br> <br>    //Change cx depending on vertical scrollbar change <br>    GetScrollRange(m_hWnd, SB_VERT, &amp;iMin, &amp;iMax); <br>    fWasThere=(0!=iMin || 0!=iMax); <br> <br>    if (fWasThere &amp;&amp; !fVScroll) <br>        cx+=cxSB; <br> <br>    if (!fWasThere &amp;&amp; fVScroll) <br>        cx-=cxSB; <br> <br>    //Change cy depending on horizontal scrollbar change <br>    GetScrollRange(m_hWnd, SB_HORZ, &amp;iMin, &amp;iMax); <br>    fWasThere=(0!=iMin || 0!=iMax); <br> <br>    if (fWasThere &amp;&amp; !fHScroll) <br>        cy+=cySB; <br> <br>    if (!fWasThere &amp;&amp; fHScroll) <br>        cy-=cySB; <br> <br> <br>    /* <br>     * Show/Hide the scrollbars if necessary and set the ranges. <br>     * The range is the number of units of the page we cannot see. <br>     */ <br>    if (fHScroll) <br>        { <br>        //Convert current scroll position to new range. <br>        u=GetScrollPos(m_hWnd, SB_HORZ); <br> <br>        if (0!=u) <br>            { <br>            GetScrollRange(m_hWnd, SB_HORZ, &amp;iMin, &amp;iMax); <br>            u=MulDiv(u, (dx-cx), (iMax-iMin)); <br>            } <br> <br>        SetScrollRange(m_hWnd, SB_HORZ, 0, dx-cx, FALSE); <br>        SetScrollPos(m_hWnd, SB_HORZ, u, TRUE); <br>        m_xPos=u; <br>        } <br>    else <br>        { <br>        SetScrollRange(m_hWnd, SB_HORZ, 0, 0, TRUE); <br>        m_xPos=0; <br>        } <br> <br>    if (fVScroll) <br>        { <br>        //Convert current scroll position to new range. <br>        u=GetScrollPos(m_hWnd, SB_VERT); <br> <br>        if (0!=u) <br>            { <br>            GetScrollRange(m_hWnd, SB_VERT, &amp;iMin, &amp;iMax); <br>            u=MulDiv(u, (dy-cy), (iMax-iMin)); <br>            } <br> <br>        SetScrollRange(m_hWnd, SB_VERT, 0, dy-cy, FALSE); <br>        SetScrollPos(m_hWnd, SB_VERT, u, TRUE); <br> <br>        m_yPos=u; <br>        } <br>    else <br>        { <br>        SetScrollRange(m_hWnd, SB_VERT, 0, 0, TRUE); <br>        m_yPos=0; <br>        } <br> <br>    //Repaint to insure that changes to m_x/yPos are reflected <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
