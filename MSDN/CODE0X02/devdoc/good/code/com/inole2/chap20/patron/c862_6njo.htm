<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DRAGDROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context864"></a>DRAGDROP.CPP</h2>
<pre><code>/* <br> * DRAGDROP.CPP <br> * Patron Chapter 20 <br> * <br> * Member functions of the CPages class concerned with drag-drop <br> * and other object-placement functionality.  Moved here to clean <br> * up CPAGES.CPP somewhat. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CPages::UTestDroppablePoint <br> * <br> * Purpose: <br> *  Returns if the point in pptl is on the paper in the current page <br> *  and alternately if it's within horizontal or vertical inset <br> *  regions. <br> * <br> * Parameters: <br> *  pptl            PPOINTL containing the point in screen <br> *                  coordinates. <br> * <br> * Return Value: <br> *  UINT            A UDROP_* value. <br> */ <br> <br>UINT CPages::UTestDroppablePoint(PPOINTL pptl) <br>    { <br>    POINT       pt; <br>    RECT        rc, rcT, rcC; <br>    UINT        uRet; <br> <br>    POINTFROMPOINTL(pt, *pptl); <br>    ScreenToClient(m_hWnd, &amp;pt); <br> <br>    CalcBoundingRect(&amp;rc, FALSE); <br> <br>    GetClientRect(m_hWnd, &amp;rcC); <br>    IntersectRect(&amp;rcT, &amp;rc, &amp;rcC); <br> <br>    //Check for at least a client area hit. <br>    if (!PtInRect(&amp;rcT, pt)) <br>        return UDROP_NONE; <br> <br>    uRet=UDROP_CLIENT; <br> <br>    //Scroll checks happen on client area, not document area <br>    if (PtInRect(&amp;rcC, pt)) <br>        { <br>        //Check horizontal inset <br>        if (pt.x &lt;= rcC.left+(int)m_uScrollInset) <br>            uRet |= UDROP_INSETLEFT; <br>        else if (pt.x &gt;= rcC.right-(int)m_uScrollInset) <br>            uRet |= UDROP_INSETRIGHT; <br> <br>        //Check vertical inset <br>        if (pt.y &lt;= rcC.top+(int)m_uScrollInset) <br>            uRet |= UDROP_INSETTOP; <br>        else if (pt.y &gt;= rcC.bottom-(int)m_uScrollInset) <br>            uRet |= UDROP_INSETBOTTOM; <br>        } <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::DrawDropTargetRect <br> * <br> * Purpose: <br> *  Draws a dotted rectangle on the Pages window to show where <br> *  a drop might occur.  This is a toggle function. <br> * <br> * Parameters: <br> *  pptl            PPOINTL containing the upper-left point <br> *                  in screen coordinates. <br> *  pszl            LPSIZEL containing the rect extents in device <br> *                  units. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::DrawDropTargetRect(PPOINTL pptl, LPSIZEL pszl) <br>    { <br>    POINT           pt; <br>    RECT            rc, rcT; <br>    HDC             hDC; <br> <br>    if (NULL==pptl &amp;&amp; NULL==pszl) <br>        { <br>        /* <br>         * This case is used from WM_PAINT in pagewin.cpp so we can <br>         * control the proper visibility of the drag rectangle when <br>         * we're scrolling.  If drag-drop happens between two apps, <br>         * then any ScrollWindow will cause a WM_PAINT after we <br>         * leave DragOver, so that paint would normally overwrite <br>         * the last drawn rectangle.  To alleviate that, WM_PAINT <br>         * will remove the last rect by sending us NULLs, paint, <br>         * then reinstate the rectangle. <br>         */ <br>        pptl=&amp;m_ptlRect; <br>        pszl=&amp;m_szlRect; <br>        } <br>    else <br>        { <br>        m_ptlRect.x=pptl-&gt;x; <br>        m_ptlRect.y=pptl-&gt;y; <br>        m_szlRect.cx=pszl-&gt;cx; <br>        m_szlRect.cy=pszl-&gt;cy; <br> <br>        //Flag is only affected from IDropTarget, not WM_PAINT calls <br>        m_fDragRectShown=!m_fDragRectShown; <br>        } <br> <br>    POINTFROMPOINTL(pt, *pptl); <br>    ScreenToClient(m_hWnd, &amp;pt); <br>    SetRect(&amp;rc, pt.x, pt.y, pt.x+(int)pszl-&gt;cx <br>        , pt.y+(int)pszl-&gt;cy); <br> <br>    CalcBoundingRect(&amp;rcT, FALSE); <br>    IntersectRect(&amp;rc, &amp;rc, &amp;rcT); <br> <br>    if (!IsRectEmpty(&amp;rc)) <br>        { <br>        hDC=GetDC(m_hWnd); <br>        DrawFocusRect(hDC, &amp;rc); <br>        ReleaseDC(m_hWnd, hDC); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::AdjustPosition <br> * <br> * Purpose: <br> *  Adjusts a point for the scrolling offset and then converts it <br> *  and a size from device into LOMETRIC units. <br> * <br> * Parameters: <br> *  pptl            PPOINTL to adjust and convert <br> *  pszl            LPSIZEL to convert <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::AdjustPosition(PPOINTL pptl, LPSIZEL pszl) <br>    { <br>    RECT        rc; <br> <br>    SetRect(&amp;rc, m_xPos+(int)pptl-&gt;x <br>        , m_yPos+(int)pptl-&gt;y, (int)pszl-&gt;cx, (int)pszl-&gt;cy); <br> <br>    RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>    pptl-&gt;x=rc.left; <br>    pptl-&gt;y=rc.top; <br> <br>    pszl-&gt;cx=rc.right; <br>    pszl-&gt;cy=rc.bottom; <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
