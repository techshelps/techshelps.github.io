<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LNKASSIS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context860"></a>LNKASSIS.CPP</h2>
<pre><code>/* <br> * LNKASSIS.CPP <br> * Links Assistant Chapter 20 <br> * <br> * Implementation of the CLinks object with the IOleUILinkContainer <br> * interface to assist handling the Links dialog for linking <br> * containers. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "lnkassis.h" <br> <br> <br>/* <br> * CLinks::CLinks <br> * CLinks::~CLinks <br> * <br> * Parameters (Constructor): <br> *  pfnDestroy      PFNDESTROYED to call when object is destroyed. <br> */ <br> <br>CLinks::CLinks(PFNDESTROYED pfnDestroy) <br>    { <br>    m_cRef=0; <br>    m_pfnDestroy=pfnDestroy; <br>    return; <br>    } <br> <br> <br>CLinks::~CLinks(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CLinks::QueryInterface <br> * CLinks::AddRef <br> * CLinks::Release <br> * <br> * Purpose: <br> *  IUnknown members for CLinks object. <br> */ <br> <br>STDMETHODIMP CLinks::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IOleUILinkContainer==riid) <br>        { <br>        *ppv=this; <br>        AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CLinks::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CLinks::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CLinks::GetNextLink <br> * <br> * Purpose: <br> *  Function to fill out the IOleUILinkContainer interface. <br> *  Does nothing. <br> * <br> * Parameters: <br> *  dwLink          DWORD ignored. <br> * <br> * Return Value: <br> *  DWORD           Alwaus 0L <br> * <br> */ <br> <br>STDMETHODIMP_(DWORD) CLinks::GetNextLink(DWORD dwLink) <br>    { <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CLinks::SetLinkUpdateOptions <br> * <br> * Purpose: <br> *  Calls IOleLink::SetUpdateOptions for the object identified by <br> *  dwLink. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> *  dwOptions       DWORD containing the new options. <br> * <br> * Return Value: <br> *  HRESULT         Return value of IOleLink::SetUpdateOptions. <br> */ <br> <br>STDMETHODIMP CLinks::SetLinkUpdateOptions(DWORD dwLink <br>    , DWORD dwOptions) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br> <br>    if (NULL==pIOleLink) <br>        return ResultFromScode(E_FAIL); <br> <br>    return pIOleLink-&gt;SetUpdateOptions(dwOptions); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CLinks::GetLinkUpdateOptions <br> * <br> * Purpose: <br> *  Call IOleLink::GetUpdateOptions for the object identified by <br> *  dwLink. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> *  pdwOptions      LPDWORD in which to store the options. <br> * <br> * Return Value: <br> *  HRESULT         Return value of IOleLink::GetUpdateOptions <br> */ <br> <br>STDMETHODIMP CLinks::GetLinkUpdateOptions(DWORD dwLink <br>    , LPDWORD pdwOptions) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br> <br>    if (NULL==pIOleLink) <br>        return ResultFromScode(E_FAIL); <br> <br>    return pIOleLink-&gt;GetUpdateOptions(pdwOptions); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CLinks::SetLinkSource <br> * <br> * Purpose: <br> *  Changes the moniker to which an object is linked. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> *  pszName         LPTSTR to the displayable name of the source. <br> *  cchName         ULONG length of the file portaion of pszName <br> *  pchEaten        ULONG * in which to return the number of <br> *                  characters used in parsing pszDisplayName. <br> *  fValidate       BOOL indicating if we're to validate that the <br> *                  source exists first. <br> * <br> * Return Value: <br> *  HRESULT         If successful, NOERROR indicates that the link <br> *                  is available, S_FALSE to indicate it's not. <br> *                  This information is later required in <br> *                  GetLinkSource.  E_FAIL on failure. <br> */ <br> <br>STDMETHODIMP CLinks::SetLinkSource(DWORD dwLink, LPTSTR pszName <br>    , ULONG cchName, ULONG *pchEaten, BOOL fValidate) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br>    HRESULT         hr; <br>    CLSID           clsID=CLSID_NULL; <br>    LPMONIKER       pmk=NULL; <br>    BOOL            fAvail=FALSE; <br> <br>    if (fValidate) <br>        { <br>        //Check things out and get a moniker and CLSID. <br>        if (!ValidateLinkSource(pszName, pchEaten, &amp;pmk, &amp;clsID)) <br>            return ResultFromScode(E_FAIL); <br> <br>        //If we got a CLSID, then we found the source. <br>        if (CLSID_NULL!=clsID) <br>            fAvail=TRUE; <br>        } <br>    else <br>        { <br>        if (!CreateNewSourceMoniker(pszName, cchName, &amp;pmk)) <br>            return ResultFromScode(E_FAIL); <br>        } <br> <br>    if (NULL==pIOleLink) <br>        { <br>        pmk-&gt;Release(); <br>        return ResultFromScode(E_FAIL); <br>        } <br> <br>    if (NULL!=pmk) <br>        { <br>        hr=pIOleLink-&gt;SetSourceMoniker(pmk, clsID); <br>        pmk-&gt;Release(); <br>        } <br>    else <br>       #ifdef WIN32ANSI <br>        { <br>        OLECHAR     szTemp[512]; <br> <br>        MultiByteToWideChar(CP_ACP, 0, pszName, -1, szTemp, 512); <br>        hr=pIOleLink-&gt;SetSourceDisplayName(szTemp); <br>        } <br>       #else <br>        hr=pIOleLink-&gt;SetSourceDisplayName(pszName); <br>       #endif <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    return fAvail ? NOERROR : ResultFromScode(S_FALSE); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CLinks::GetLinkSource <br> * <br> * Purpose: <br> *  Retrieves various strings and values for this link source. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> *  ppszName        LPTSTR * in which to return the new source <br> *                  name <br> *  pcchName        ULONG * in which to return the length of <br> *                  pszName <br> *  ppszFullLink    LPTSTR * in which to return the full name of <br> *                  the class of linked object. <br> *  ppszShortLink   LPTSTR * in which to return the short name of <br> *                  the class of linked object. <br> *  pfSourceAvail   BOOL * ignored. <br> *  pfSelected      BOOL * ignored. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, error code otherwise. <br> */ <br> <br>STDMETHODIMP CLinks::GetLinkSource(DWORD dwLink <br>    , LPTSTR *ppszName, ULONG *pcchName <br>    , LPTSTR *ppszFullLink, LPTSTR *ppszShortLink <br>    , BOOL *pfSourceAvail, BOOL *pfSelected) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br>    HRESULT         hr; <br>    LPOLEOBJECT     pIOleObject=NULL; <br>    LPMONIKER       pmk=NULL; <br>    LPMONIKER       pmkFirst=NULL; <br>    LPBC            pbc=NULL; <br>   #ifdef WIN32ANSI <br>    OLECHAR        *pszOut; <br>    TCHAR          *pszTemp; <br>   #endif <br> <br>    if (NULL==pIOleLink) <br>        return ResultFromScode(E_FAIL); <br> <br>    *ppszName=NULL; <br>    *pcchName=0; <br>    *ppszFullLink=NULL; <br>    *ppszShortLink=NULL; <br> <br>    hr=pIOleLink-&gt;GetSourceMoniker(&amp;pmk); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        hr=pIOleLink-&gt;QueryInterface(IID_IOleObject <br>            , (PPVOID)&amp;pIOleObject); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>           #ifdef WIN32ANSI <br>            pszTemp=(TCHAR *)CoTaskMemAlloc(80); <br>            pIOleObject-&gt;GetUserType(USERCLASSTYPE_FULL <br>                , &amp;pszOut); <br>            WideCharToMultiByte(CP_ACP, 0, pszOut, -1 <br>                , pszTemp, 80, NULL, NULL); <br>            CoTaskMemFree((void *)pszOut); <br>            *ppszFullLink=pszTemp; <br> <br>            pszTemp=(TCHAR *)CoTaskMemAlloc(80); <br>            pIOleObject-&gt;GetUserType(USERCLASSTYPE_SHORT <br>                , &amp;pszOut); <br>            WideCharToMultiByte(CP_ACP, 0, pszOut, -1 <br>                , pszTemp, 80, NULL, NULL); <br>            CoTaskMemFree((void *)pszOut); <br>            *ppszShortLink=pszTemp; <br>           #else <br>            pIOleObject-&gt;GetUserType(USERCLASSTYPE_FULL <br>                , ppszFullLink); <br>            pIOleObject-&gt;GetUserType(USERCLASSTYPE_SHORT <br>                , ppszShortLink); <br>           #endif <br>            pIOleObject-&gt;Release(); <br>            } <br> <br>        *pcchName=CchFilePrefix(pmk); <br>        pmk-&gt;Release(); <br>        } <br> <br>   #ifdef WIN32ANSI <br>    pszTemp=(TCHAR *)CoTaskMemAlloc(80); <br>    hr=pIOleLink-&gt;GetSourceDisplayName(&amp;pszOut); <br>    WideCharToMultiByte(CP_ACP, 0, pszOut, -1 <br>        , pszTemp, 80, NULL, NULL); <br>    CoTaskMemFree((void *)pszOut); <br>    *ppszName=pszTemp; <br>    return hr; <br>   #else <br>    return pIOleLink-&gt;GetSourceDisplayName(ppszName); <br>   #endif <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CLinks::OpenLinkSource <br> * <br> * Purpose: <br> *  Does nothing.  The container using this object is the only <br> *  one that knows how to activate an object properly. <br> * <br> * Parameters: <br> *  dwLink          DWORD ignored. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CLinks::OpenLinkSource(DWORD dwLink) <br>    { <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CLinks::UpdateLink <br> * <br> * Purpose: <br> *  Updates the link for this object. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> *  fErrorMessage   BOOL indicating if we can show errors. <br> *  fErrorAction    BOOL making no sense whatsoever. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, error code otherwise. If <br> *                  there is an error, the caller should set the <br> *                  link availability flag to FALSE.  Otherwise set <br> *                  to TRUE. <br> */ <br> <br>STDMETHODIMP CLinks::UpdateLink(DWORD dwLink <br>    , BOOL fErrorMessage, BOOL fErrorAction) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br>    HRESULT         hr; <br>    LPOLEOBJECT     pIOleObject; <br> <br>    if (NULL==pIOleLink) <br>        return ResultFromScode(E_FAIL); <br> <br>    hr=pIOleLink-&gt;QueryInterface(IID_IOleObject <br>        , (PPVOID)&amp;pIOleObject); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=pIOleObject-&gt;IsUpToDate(); <br> <br>    if (NOERROR!=hr) <br>        { <br>        hr=pIOleObject-&gt;Update(); <br> <br>        if (FAILED(hr)) <br>            return hr; <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CLinks::CancelLink <br> * <br> * Purpose: <br> *  Sets the source moniker in the link to NULL but does nothing <br> *  else.  How the container decides to convert this to static <br> *  is its choice. <br> * <br> * Parameters: <br> *  dwLink          DWORD, an IOleLink pointer to the object <br> *                  affected. <br> * <br> * Return Value: <br> *  HRESULT         Standard. <br> */ <br> <br>STDMETHODIMP CLinks::CancelLink(DWORD dwLink) <br>    { <br>    LPOLELINK       pIOleLink=(LPOLELINK)dwLink; <br> <br>    if (NULL!=pIOleLink) <br>        return pIOleLink-&gt;SetSourceMoniker(NULL, CLSID_NULL); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>//PROTECTED FUNCTIONS INTERNAL TO CLinks <br> <br>/* <br> * CLinks::ValidateLinkSource <br> * (Protected) <br> * <br> * Purpose: <br> *  Given a name of a link source retrieve a moniker for it and <br> *  a CLSID if we can bind. <br> * <br> * Parameters: <br> *  pszName         LPTSTR of the source <br> *  pchEaten        ULONG * into which to return how many <br> *                  characters we parse. <br> *  ppmk            LPMONIKER * into which to store the moniker <br> *  pclsID          LPCLSID into which to store the clsID. <br> * <br> * Return Value: <br> *  BOOL            TRUE if *ppmk has a valid moniker, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CLinks::ValidateLinkSource(LPTSTR pszName <br>    , ULONG *pchEaten, LPMONIKER *ppmk, LPCLSID pclsID) <br>    { <br>    HRESULT     hr; <br>    LPBC        pbc=NULL; <br>    LPOLEOBJECT pIOleObject; <br> <br>    *ppmk=NULL; <br>    *pclsID=CLSID_NULL; <br> <br>    if (FAILED(CreateBindCtx(0, &amp;pbc))) <br>        return FALSE; <br> <br>    hr=MkParseDisplayName(pbc, pszName, pchEaten, ppmk); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        /* <br>         * Now that we have a moniker for this new source, so try <br>         * binding to that source and get its CLSID. <br>         */ <br>        hr=(*ppmk)-&gt;BindToObject(pbc, NULL, IID_IOleObject <br>            , (PPVOID)&amp;pIOleObject); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            pIOleObject-&gt;GetUserClassID(pclsID); <br>            pIOleObject-&gt;Release(); <br>            } <br> <br>        return TRUE; <br>        } <br> <br>    pbc-&gt;Release(); <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CLinks::CreateNewSourceMoniker <br> * (Protected) <br> * <br> * Purpose: <br> *  Given a name of a link source create a moniker for it. <br> * <br> * Parameters: <br> *  pszName         LPTSTR of the source <br> *  cchName         ULONG length of the filename in pszName. <br> *  ppmk            LPMONIKER * into which to store the moniker <br> * <br> * Return Value: <br> *  BOOL            TRUE if *ppmk has a valid moniker, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CLinks::CreateNewSourceMoniker(LPTSTR pszName <br>    , ULONG cchName, LPMONIKER *ppmk) <br>    { <br>    TCHAR       szName[CCHPATHMAX]; <br>    LPMONIKER   pmkFile=NULL; <br>    LPMONIKER   pmkItem=NULL; <br> <br>    *ppmk=NULL; <br>    lstrcpyn(szName, pszName, (int)cchName+1); <br>    CreateFileMoniker(szName, &amp;pmkFile); <br> <br>    if (NULL==pmkFile) <br>        return FALSE; <br> <br>    if (lstrlen(pszName) &gt; (int)cchName) <br>        { <br>        lstrcpy(szName, pszName+cchName+1); <br>        CreateItemMoniker(TEXT("!"), szName, &amp;pmkItem); <br> <br>        if (NULL!=pmkItem) <br>            { <br>            CreateGenericComposite(pmkFile, pmkItem, ppmk); <br>            pmkItem-&gt;Release(); <br>            } <br> <br>        pmkFile-&gt;Release(); <br> <br>        if (NULL==*ppmk) <br>            return FALSE; <br>        } <br>    else <br>        *ppmk=pmkFile; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CLinks::CchFilePrefix <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns the length of a file moniker given that pmk is either <br> *  a file moniker or a composite containing a file moniker <br> *  as the first item. <br> * <br> * Parameters: <br> *  pmk             IMoniker * to check. <br> * <br> * Return Value: <br> *  UINT            Length of the file moniker text. <br> */ <br> <br>UINT CLinks::CchFilePrefix(LPMONIKER pmk) <br>    { <br>    LPMONIKER       pmkFirst=NULL; <br>    LPENUMMONIKER   pEnum; <br>    DWORD           dwMk; <br>    LPOLESTR        psz=NULL; <br>    LPBC            pbc=NULL; <br>    ULONG           cch=0; <br>    HRESULT         hr; <br> <br>    if (NULL==pmk) <br>       return 0; <br> <br>    hr=pmk-&gt;IsSystemMoniker(&amp;dwMk); <br> <br>    if (FAILED(hr) || MKSYS_GENERICCOMPOSITE!=dwMk) <br>        { <br>        //Already a single moniker <br>        pmkFirst=pmk; <br>        pmk-&gt;AddRef(); <br>        } <br>    else <br>        { <br>        //Pull off the first moniker in a composite <br>        hr=pmk-&gt;Enum(TRUE, &amp;pEnum); <br> <br>        if (FAILED(hr)) <br>            return NULL; <br> <br>        hr=pEnum-&gt;Next(1, &amp;pmkFirst, NULL); <br>        pEnum-&gt;Release(); <br>        } <br> <br>    if (NULL==pmkFirst) <br>        return 0; <br> <br>    hr=pmkFirst-&gt;IsSystemMoniker(&amp;dwMk); <br> <br>    if (SUCCEEDED(hr) &amp;&amp; MKSYS_FILEMONIKER==dwMk); <br>        { <br>        if (SUCCEEDED(CreateBindCtx(0, &amp;pbc))) <br>            { <br>            if (SUCCEEDED(pmkFirst-&gt;GetDisplayName(pbc, NULL <br>                , &amp;psz))) <br>                { <br>               #ifdef WIN32ANSI <br>                cch=wcslen(psz); <br>               #else <br>                cch=lstrlen(psz); <br>               #endif <br>                CoTaskMemFree((void *)psz); <br>                } <br> <br>            pbc-&gt;Release(); <br>            } <br>        } <br> <br>    pmkFirst-&gt;Release(); <br>    return cch; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
