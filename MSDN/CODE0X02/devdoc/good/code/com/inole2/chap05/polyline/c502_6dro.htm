<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPOLYLIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context504"></a>IPOLYLIN.CPP</h2>
<pre><code>/* <br> * IPOLYLIN.CPP <br> * Polyline Component Object Chapter 5 <br> * <br> * Implementation of the IPolyline interface that we expose on the <br> * CPolyline object. <br> * <br> * Copyright (c)1993-1997 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * CImpIPolyline:CImpIPolyline <br> * CImpIPolyline::~CImpIPolyline <br> * <br> * Constructor Parameters: <br> *  pObj            PCPolyline pointing to the object we live in. <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> */ <br> <br>CImpIPolyline::CImpIPolyline(PCPolyline pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br> <br>CImpIPolyline::~CImpIPolyline(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::QueryInterface <br> * CImpIPolyline::AddRef <br> * CImpIPolyline::Release <br> * <br> * Purpose: <br> *  Standard set of IUnknown members for this interface <br> */ <br> <br>STDMETHODIMP CImpIPolyline::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPolyline::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPolyline::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::Init <br> * <br> * Purpose: <br> *  Instantiates a polyline window within a given parent.  The <br> *  parent may be a main application window, could be an MDI child <br> *  window. We really do not care. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  pRect           LPRECT that this window should occupy <br> *  dwStyle         DWORD containing the window's style flags <br> *  uID             UINT ID to associate with this window <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise E_OUTOFMEMORY <br> */ <br> <br>STDMETHODIMP CImpIPolyline::Init(HWND hWndParent, LPRECT pRect <br>    , DWORD dwStyle, UINT uID) <br>    { <br>    SCODE           sc; <br> <br>    m_pObj-&gt;m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY <br>        , SZCLASSPOLYLINE, SZCLASSPOLYLINE, dwStyle, pRect-&gt;left <br>        , pRect-&gt;top, pRect-&gt;right-pRect-&gt;left <br>        , pRect-&gt;bottom-pRect-&gt;top, hWndParent, (HMENU)uID <br>        , m_pObj-&gt;m_hInst, m_pObj); <br> <br>    sc=(NULL!=m_pObj-&gt;m_hWnd) ? S_OK : E_OUTOFMEMORY; <br>    return sc; <br>    } <br> <br> <br> <br>//CHAPTER5MOD <br>/* <br> * ReadFromFile and WriteToFile are replaced by the IPersistStorage <br> * implementation.  We no longer read from files, instead we use <br> * storages. <br> */ <br>//End CHAPTER5MOD <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::DataSet <br> * <br> * Purpose: <br> *  Sets the current data in this Polyline to a given structure. <br> * <br> * Parameters: <br> *  pplIn           PPOLYLINEDATA to initialize to. <br> *  fSizeToData     BOOL indicating if we're to size to the data <br> *                  or scale it. <br> *  fNotify         BOOL indicating if we're to send an advise <br> *                  on this change. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::DataSet(PPOLYLINEDATA pplIn <br>    , BOOL fSizeToData, BOOL fNotify) <br>    { <br>    PPOLYLINEDATA   ppl=&amp;m_pObj-&gt;m_pl; <br>    RECT            rc; <br> <br>    /* <br>     * Copy the structure in pplIn and repaint to reflect the <br>     * new point set.  Note that unlike the RectSet message, we <br>     * do no scaling, assuming that the rect in the structure <br>     * is appropriate for the data. <br>     */ <br> <br>    if (NULL==pplIn) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    *ppl=*pplIn; <br> <br>    //Inform our parent of the data change <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        { <br>        m_pObj-&gt;m_fDirty=TRUE; <br>        m_pObj-&gt;m_pAdv-&gt;OnDataChange(); <br>        } <br> <br>    /* <br>     * If we're scaling the window to fit the data, then use <br>     * RectSet passing our current rectangle as the new one. <br>     * That makes sure that the data won't change but that the <br>     * window is resized. <br>     */ <br> <br>    if (fSizeToData) <br>        { <br>        POINT       pt; <br> <br>        /* <br>         * Get our offset in the parent window so we can RectSet <br>         * to the right place since RectSet expects rectangle in <br>         * parent coordinates and we get it in client coordinates. <br>         */ <br>        GetWindowRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>        pt.x=rc.left; <br>        pt.y=rc.top; <br>        ScreenToClient(GetParent(m_pObj-&gt;m_hWnd), &amp;pt); <br>        RECTSTORECT(ppl-&gt;rc, rc); <br>        OffsetRect(&amp;rc, pt.x, pt.y); <br> <br>        //This will also cause a repaint. <br>        RectSet(&amp;rc, fNotify); <br>        } <br>    else <br>        { <br>        //Make sure we're updated. <br>        InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_pObj-&gt;m_hWnd); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::DataGet <br> * <br> * Purpose: <br> *  Retrieves the Polyline's current data. <br> * <br> * Parameters: <br> *  pplIn           PPOLYLINEDATA into which we copy the data. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::DataGet(PPOLYLINEDATA pplIn) <br>    { <br>    if (NULL==pplIn) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    *pplIn=m_pObj-&gt;m_pl; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::DataSetMem <br> * <br> * Purpose: <br> *  Sets the Polyline's data using a global memory handle <br> *  instead of a pointer. <br> * <br> * Parameters: <br> *  hMem            HGLOBAL containing the data. <br> *  fFree           BOOL indicating if we're to free the data. <br> *                  The memory will be freed regardless of any <br> *                  error returned from here. <br> *  fSizeToData     BOOL indicating if we're to size to the data <br> *                  or scale it. <br> *  fNotify         BOOL indicating if we're to send an advise <br> *                  on this change. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::DataSetMem(HGLOBAL hMem, BOOL fFree <br>    , BOOL fSizeToData, BOOL fNotify) <br>    { <br>    PPOLYLINEDATA   ppl; <br>    HRESULT         hr=POLYLINE_E_INVALIDPOINTER; <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br> <br>        hr=DataSet(ppl, fSizeToData, fNotify); <br> <br>        GlobalUnlock(hMem); <br> <br>        if (fFree) <br>            GlobalFree(hMem); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::DataGetMem <br> * <br> * Purpose: <br> *  Retrieves the Polyline's data in a global memory handle. <br> * <br> * Parameters: <br> *  phMem           HGLOBAL * in which to store the handle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::DataGetMem(HGLOBAL *phMem) <br>    { <br>    HGLOBAL         hMem; <br>    PPOLYLINEDATA   ppl; <br>    HRESULT         hr=POLYLINE_E_INVALIDPOINTER; <br> <br>    if (NULL==phMem) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, CBPOLYLINEDATA); <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br>        hr=DataGet(ppl); <br> <br>        GlobalUnlock(hMem); <br> <br>        if (FAILED(hr)) <br>            { <br>            GlobalFree(hMem); <br>            hMem=NULL; <br>            } <br>        } <br> <br>    *phMem=hMem; <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::RenderBitmap <br> * <br> * Purpose: <br> *  Creates a bitmap image of the current Polyline. <br> * <br> * Parameters: <br> *  phBmp           HBITMAP * in which to return the bitmap. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::RenderBitmap(HBITMAP *phBmp) <br>    { <br>    HDC             hDC; <br>    HDC             hMemDC; <br>    HBITMAP         hBmp; <br>    RECT            rc; <br>    HGDIOBJ         hObj; <br> <br>    if (NULL==phBmp) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    //Render a bitmap the size of the current rectangle. <br>    hDC=GetDC(m_pObj-&gt;m_hWnd); <br>    hMemDC=CreateCompatibleDC(hDC); <br> <br>    GetClientRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>    hBmp=CreateCompatibleBitmap(hDC, rc.right, rc.bottom); <br> <br>    if (NULL!=hBmp) <br>        { <br>        //Draw the POLYLINEDATA into the bitmap. <br>        hObj=SelectObject(hMemDC, hBmp); <br>        m_pObj-&gt;Draw(hMemDC, FALSE, TRUE); <br>        SelectObject(hMemDC, hObj); <br>        } <br> <br>    DeleteDC(hMemDC); <br>    ReleaseDC(m_pObj-&gt;m_hWnd, hDC); <br> <br>    *phBmp=hBmp; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::RenderMetafile <br> * <br> * Purpose: <br> *  Renders the current image of the Polyline into a metafile. <br> * <br> * Parameters: <br> *  phMF            HMETAFILE * in which to return the <br> *                  new metafile. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::RenderMetafile(HMETAFILE *phMF) <br>    { <br>    HDC             hDC; <br>    HMETAFILE       hMF; <br>    RECT            rc; <br> <br>    if (NULL==phMF) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    //Create a memory metafile and return its handle. <br>    hDC=(HDC)CreateMetaFile(NULL); <br>    hMF=NULL; <br> <br>    if (NULL!=hDC) <br>        { <br>        /* <br>         * This is absolutely essential to the metafile so it <br>         * can be scaled in the clipboard and any destination <br>         * application. <br>         */ <br>        SetMapMode(hDC, MM_ANISOTROPIC); <br>        GetClientRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>        SetWindowOrgEx(hDC, 0, 0, NULL); <br>        SetWindowExtEx(hDC, rc.right, rc.bottom, NULL); <br> <br>        m_pObj-&gt;Draw(hDC, TRUE, TRUE); <br>        hMF=CloseMetaFile(hDC); <br>        } <br> <br>    *phMF=hMF; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::RenderMetafilePict <br> * <br> * Purpose: <br> *  Renders the current Polyline into a METAFILEPICT structure in <br> *  global memory. <br> * <br> * Parameters: <br> *  phMem           HGLOBAL * in which to return the <br> *                  METAFILEPICT. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::RenderMetafilePict(HGLOBAL * phMem) <br>    { <br>    HGLOBAL         hMem; <br>    HMETAFILE       hMF; <br>    LPMETAFILEPICT  pMF; <br>    RECT            rc; <br>    HRESULT         hr; <br> <br>    if (NULL==phMem) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    //Get the metafile <br>    hr=RenderMetafile(&amp;hMF); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    //Allocate the METAFILEPICT structure. <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE <br>        , sizeof(METAFILEPICT)); <br> <br>    if (NULL==hMem) <br>        { <br>        DeleteMetaFile(hMF); <br>        return E_FAIL; <br>        } <br> <br>    /* <br>     * Global lock only fails in PMODE if the selector is invalid <br>     * (like it was discarded) or references a 0 length segment, <br>     * neither of which can happen here. <br>     */ <br>    pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>    pMF-&gt;hMF=hMF; <br>    pMF-&gt;mm=MM_ANISOTROPIC; <br> <br>    //Insert the extents in MM_HIMETRIC units. <br>    GetClientRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>    m_pObj-&gt;RectConvertMappings(&amp;rc, FALSE); <br>    pMF-&gt;xExt=rc.right; <br>    pMF-&gt;yExt=rc.bottom; <br> <br>    GlobalUnlock(hMem); <br> <br>    *phMem=hMem; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::New <br> * <br> * Purpose: <br> *  Cleans out and reinitializes the data to defaults. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always <br> */ <br> <br>STDMETHODIMP CImpIPolyline::New(void) <br>    { <br>    PPOLYLINEDATA   ppl=&amp;m_pObj-&gt;m_pl; <br>    UINT            i; <br>    RECT            rc; <br> <br>    ppl-&gt;wVerMaj=VERSIONMAJOR; <br>    ppl-&gt;wVerMin=VERSIONMINOR; <br> <br>    //Our rectangle is the size of our window's client area. <br>    GetClientRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>    RECTTORECTS(rc, ppl-&gt;rc); <br> <br>    //Clean out the POLYLINEDATA structure and repaint the window. <br>    for (i=0; i&lt; CPOLYLINEPOINTS; i++) <br>        { <br>        ppl-&gt;rgpt[i].x=0; <br>        ppl-&gt;rgpt[i].y=0; <br>        } <br> <br>    ppl-&gt;cPoints      =0; <br>    ppl-&gt;rgbBackground=GetSysColor(COLOR_WINDOW); <br>    ppl-&gt;rgbLine      =GetSysColor(COLOR_WINDOWTEXT); <br>    ppl-&gt;iLineStyle   =PS_SOLID; <br> <br>    InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br>    UpdateWindow(m_pObj-&gt;m_hWnd); <br> <br>    //Inform the advise sink of this data change. <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        { <br>        m_pObj-&gt;m_fDirty=TRUE; <br>        m_pObj-&gt;m_pAdv-&gt;OnDataChange(); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::Undo <br> * <br> * Purpose: <br> *  Reverses previous actions in a Polyline. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         S_OK if we can Undo more, S_FALSE otherwise. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::Undo(void) <br>    { <br>    SCODE           sc; <br> <br>    //Decrement the number of active points and repaint. <br>    if (m_pObj-&gt;m_pl.cPoints &gt; 0) <br>        { <br>        m_pObj-&gt;m_pl.cPoints--; <br>        InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_pObj-&gt;m_hWnd); <br>        } <br> <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        { <br>        m_pObj-&gt;m_fDirty=TRUE; <br>        m_pObj-&gt;m_pAdv-&gt;OnPointChange(); <br>        } <br> <br>    //Return if we can undo any more. <br>    sc=(0!=m_pObj-&gt;m_pl.cPoints) ? S_OK : S_FALSE; <br>    return sc; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::Window <br> * <br> * Purpose: <br> *  Returns the window handle associated with this polyline. <br> * <br> * Parameters: <br> *  phWnd           HWND * in which to return the window handle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::Window(HWND *phWnd) <br>    { <br>    *phWnd=m_pObj-&gt;m_hWnd; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::SetAdvise <br> * <br> * Purpose: <br> *  Provides this object with an IPolylineAdviseSink that's <br> *  interested in our notifications.  We AddRef and store this <br> *  pointer, Releasing the old one. <br> * <br> * Parameters: <br> *  pAdv            PPOLYLINEADVISESINK to notify. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::SetAdvise(PPOLYLINEADVISESINK pAdv) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        m_pObj-&gt;m_pAdv-&gt;Release(); <br> <br>    m_pObj-&gt;m_pAdv=pAdv; <br> <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        m_pObj-&gt;m_pAdv-&gt;AddRef(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::GetAdvise <br> * <br> * Purpose: <br> *  Returns the IPolylineAdviseSink that was last passed to <br> *  SetAdvise. <br> * <br> * Parameters: <br> *  ppAdv           PPOLYLINEADVISESINK * in which to return <br> *                  the pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::GetAdvise(PPOLYLINEADVISESINK *ppAdv) <br>    { <br>    *ppAdv=m_pObj-&gt;m_pAdv; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::RectGet <br> * <br> * Purpose: <br> *  Returns the rectangle of the Polyline in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the rectangle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always <br> */ <br> <br>STDMETHODIMP CImpIPolyline::RectGet(LPRECT pRect) <br>    { <br>    RECT            rc; <br>    POINT           pt; <br> <br>    //Retrieve the size of our rectangle in parent coordinates. <br>    GetWindowRect(m_pObj-&gt;m_hWnd, &amp;rc); <br>    pt.x=rc.left; <br>    pt.y=rc.top; <br>    ScreenToClient(GetParent(m_pObj-&gt;m_hWnd), &amp;pt); <br> <br>    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left) <br>        , pt.y+(rc.bottom-rc.top)); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::SizeGet <br> * <br> * Purpose: <br> *  Retrieves the size of the Polyline in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the size.  The right <br> *                  and bottom fields will contain the dimensions. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always <br> */ <br> <br>STDMETHODIMP CImpIPolyline::SizeGet(LPRECT pRect) <br>    { <br>    RectGet(pRect); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::RectSet <br> * <br> * Purpose: <br> *  Sets a new rectangle for the Polyline which sizes to fit. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always <br> */ <br> <br>STDMETHODIMP CImpIPolyline::RectSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT            cx, cy; <br>    RECT            rc; <br> <br>    //Scale the points from our current size to the new size <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_pObj-&gt;m_hWnd, NULL, pRect-&gt;left, pRect-&gt;top <br>        , cx, cy, SWP_NOZORDER); <br> <br>    SetRect(&amp;rc, 0, 0, cx, cy); <br>    RECTTORECTS(rc, m_pObj-&gt;m_pl.rc); <br> <br>    if (fNotify &amp;&amp; NULL!=m_pObj-&gt;m_pAdv) <br>        { <br>        m_pObj-&gt;m_fDirty=TRUE; <br>        m_pObj-&gt;m_pAdv-&gt;OnSizeChange(); <br>        } <br> <br>    InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::SizeSet <br> * <br> * Purpose: <br> *  Sets a new size for the Polyline which sizes to fit. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always <br> */ <br> <br>STDMETHODIMP CImpIPolyline::SizeSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT            cx, cy; <br> <br>    //Scale the points from our current size to the new size <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_pObj-&gt;m_hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy <br>        , SWP_NOMOVE | SWP_NOZORDER); <br> <br>    if (fNotify &amp;&amp; NULL!=m_pObj-&gt;m_pAdv) <br>        { <br>        m_pObj-&gt;m_fDirty=TRUE; <br>        m_pObj-&gt;m_pAdv-&gt;OnSizeChange(); <br>        } <br> <br>    InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::ColorSet <br> * <br> * Purpose: <br> *  Changes for background or line color in the Polyline <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color to use. <br> *  pcrPrev         COLORREF * in whch to store the <br> *                  previous color. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::ColorSet(UINT iColor, COLORREF cr <br>    , COLORREF *pcrPrev) <br>    { <br>    COLORREF        crRet; <br> <br>    if (NULL==pcrPrev) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    switch (iColor) <br>        { <br>        case POLYLINECOLOR_BACKGROUND: <br>            crRet=m_pObj-&gt;m_pl.rgbBackground; <br>            m_pObj-&gt;m_pl.rgbBackground=cr; <br>            break; <br> <br>        case POLYLINECOLOR_LINE: <br>            crRet=m_pObj-&gt;m_pl.rgbLine; <br>            m_pObj-&gt;m_pl.rgbLine=cr; <br>            break; <br>        } <br> <br>    //If the color changed, repaint <br>    if (crRet!=cr) <br>        { <br>        if (NULL!=m_pObj-&gt;m_pAdv) <br>            { <br>            m_pObj-&gt;m_fDirty=TRUE; <br>            m_pObj-&gt;m_pAdv-&gt;OnColorChange(); <br>            } <br> <br>        InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_pObj-&gt;m_hWnd); <br>        } <br> <br>    *pcrPrev=crRet; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::ColorGet <br> * <br> * Purpose: <br> *  Retrieves one of the colors currently in use by the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT identifying the color of interest. <br> *  pcr             COLORREF * in which to return the color. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::ColorGet(UINT iColor, COLORREF *pcr) <br>    { <br>    COLORREF        crRet; <br> <br>    if (NULL==pcr) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    crRet=(POLYLINECOLOR_BACKGROUND==iColor) <br>        ? m_pObj-&gt;m_pl.rgbBackground : m_pObj-&gt;m_pl.rgbLine; <br> <br>    *pcr=crRet; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style in use by the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT style of the line to use. <br> *  piPrev          UINT * in which to store the previous style. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::LineStyleSet(UINT iStyle, UINT *piPrev) <br>    { <br>    UINT            uRet; <br> <br>    uRet=(UINT)m_pObj-&gt;m_pl.iLineStyle; <br> <br>    if (NULL==piPrev) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    //Validate the line style <br>    if (PS_SOLID==iStyle || PS_DASH==iStyle || PS_DOT==iStyle <br>        || PS_DASHDOT==iStyle || PS_DASHDOTDOT==iStyle) <br>        { <br>        m_pObj-&gt;m_pl.iLineStyle=iStyle; <br> <br>        if (uRet!=(UINT)m_pObj-&gt;m_pl.iLineStyle) <br>            { <br>            if (NULL!=m_pObj-&gt;m_pAdv) <br>                { <br>                m_pObj-&gt;m_fDirty=TRUE; <br>                m_pObj-&gt;m_pAdv-&gt;OnLineStyleChange(); <br>                } <br> <br>            InvalidateRect(m_pObj-&gt;m_hWnd, NULL, TRUE); <br>            UpdateWindow(m_pObj-&gt;m_hWnd); <br>            } <br>        } <br> <br>    *piPrev=uRet; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPolyline::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the current line style in use in the Polyline <br> * <br> * Parameters: <br> *  piStyle         UINT * in which to store the style. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CImpIPolyline::LineStyleGet(UINT *piStyle) <br>    { <br>    if (NULL==piStyle) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    *piStyle=m_pObj-&gt;m_pl.iLineStyle; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
