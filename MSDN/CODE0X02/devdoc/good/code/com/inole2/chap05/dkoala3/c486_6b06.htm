<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DKOALA3.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context486"></a>DKOALA3.CPP</h2>
<pre><code>/* <br> * DKOALA3.CPP <br> * Koala Object DLL Licensed Server Chapter 5 <br> * <br> * Example object structured in a DLL server. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "dkoala3.h" <br> <br> <br>//Count number of objects and number of locks. <br>ULONG       g_cObj=0; <br>ULONG       g_cLock=0; <br> <br>HINSTANCE   g_hInst=NULL; <br> <br> <br>//License key string, stored in ANSI to match contents of LIC file <br>char    g_szLic[]="Koala Object #3 Copyright (c)1993-1995 Microsoft Corp."; <br>BOOL    g_fMachineLicensed=FALSE; <br> <br> <br>/* <br> * LibMain(32) <br> * <br> * Purpose: <br> *  Entry point conditionally compiled for Win32 and Win16. <br> *  Provides the proper structure for each environment. <br> */ <br> <br>#ifdef WIN32 <br>BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason <br>    , LPVOID pvReserved) <br>    { <br>    if (DLL_PROCESS_DETACH==ulReason) <br>        { <br>        return TRUE; <br>        } <br>    else <br>        { <br>        if (DLL_PROCESS_ATTACH!=ulReason) <br>            return TRUE; <br>        } <br> <br>    g_fMachineLicensed=CheckForLicenseFile(hInstance <br>        , TEXT("DKOALA3.LIC"), (BYTE *)g_szLic, lstrlenA(g_szLic)); <br> <br>    g_hInst=hInstance; <br>    return TRUE; <br>    } <br>#else <br>int PASCAL LibMain(HINSTANCE hInstance, WORD wDataSeg <br>    , WORD cbHeapSize, LPSTR lpCmdLine) <br>    { <br>    if (0!=cbHeapSize) <br>        UnlockData(0); <br> <br>    g_fMachineLicensed=CheckForLicenseFile(hInstance <br>        , TEXT("DKOALA3.LIC"), (BYTE *)g_szLic, lstrlen(g_szLic)); <br> <br>    g_hInst=hInstance; <br>    return (int)hInstance; <br>    } <br>#endif <br> <br> <br> <br> <br>/* <br> * CheckForLicenseFile <br> * <br> * Purpose: <br> *  Attempts to load DKOALA3.LIC from the same directory as <br> *  this DLL, attempting to match the first part of that file <br> *  with our license string (typical licensing scheme).  If <br> *  the match is successful, then this DLL can create any <br> *  instances of Koala objects without additional trouble. <br> *  Otherwise the client has to call IClassFactory2::CreateInstance- <br> *  Lic to instantiate anything. <br> * <br> * Parameters: <br> *  hInst           HINSTANCE of the module describing the <br> *                  directory in which we expect to find the <br> *                  license file. <br> *  pszFile         LPTSTR to the name of the file to look for. <br> *  pbLic           LPBYTE to the expected contents of the file. <br> *  cb              UINT number of butes to compare. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file is available, FALSE otherwise. <br> */ <br> <br>BOOL CheckForLicenseFile(HINSTANCE hInst, LPTSTR pszFile <br>    , LPBYTE pbLic, UINT cb) <br>    { <br>    BOOL        fFound=FALSE; <br>    TCHAR       szPath[_MAX_PATH]; <br>    LPTSTR      pszTemp; <br>    LPBYTE      pbCompare; <br>   #ifdef WIN32 <br>    HANDLE      hFile; <br>   #else <br>    OFSTRUCT    of; <br>    HFILE       hFile; <br>   #endif <br>    UINT        cbRead; <br>    ULONG       cbWasRead; <br> <br>    //Get the module path, then replace DLL name with LIC filename <br>GetModuleFileName(hInst, szPath, _MAX_PATH); <br>pszTemp=_tcsrchr(szPath, '\\')+1; <br>    lstrcpy(pszTemp, pszFile); <br> <br>    /* <br>     * Now open the file and read contents into an allocated <br>     * pbCompare.  The check if the contents of that file and <br>     * pbLic match.  If so, then return success, otherwise <br>     * failure. <br>     */ <br>   #ifdef WIN32 <br>    hFile=CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ <br>        , NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); <br>   #else <br>    hFile=OpenFile(szPath, &amp;of, OF_READ); <br>   #endif <br> <br>    /* <br>     * NOTE:  INVALID_HANDLE_VALUE, ReadFile, and CloseHandle <br>     * are macros in INC\book1632.h when compiling for Win16. <br>     */ <br>    if (INVALID_HANDLE_VALUE==hFile) <br>        return FALSE; <br> <br>    cbRead=cb*sizeof(BYTE); <br>    pbCompare=(LPBYTE)malloc(cbRead+4); <br> <br>    if (NULL!=pbCompare) <br>        { <br>        ReadFile(hFile, pbCompare, cbRead, &amp;cbWasRead, NULL); <br>    fFound=(0==memcmp(pbLic, pbCompare, cb)); <br>    free(pbCompare); <br>        } <br> <br>    CloseHandle(hFile); <br>    return fFound; <br>    } <br> <br> <br> <br>/* <br> * DllGetClassObject <br> * <br> * Purpose: <br> *  Provides an IClassFactory for a given CLSID that this DLL is <br> *  registered to support.  This DLL is placed under the CLSID <br> *  in the registration database as the InProcServer. <br> * <br> * Parameters: <br> *  clsID           REFCLSID that identifies the class factory <br> *                  desired.  Since this parameter is passed this <br> *                  DLL can handle any number of objects simply <br> *                  by returning different class factories here <br> *                  for different CLSIDs. <br> * <br> *  riid            REFIID specifying the interface the caller wants <br> *                  on the class object, usually IID_ClassFactory. <br> * <br> *  ppv             PPVOID in which to return the interface <br> *                  pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, otherwise an error code. <br> */ <br> <br>STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv) <br>    { <br>    HRESULT             hr; <br>    CKoalaClassFactory *pObj; <br> <br>    if (CLSID_Koala!=rclsid) <br>        return ResultFromScode(E_FAIL); <br> <br>    pObj=new CKoalaClassFactory(); <br> <br>    if (NULL==pObj) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    hr=pObj-&gt;QueryInterface(riid, ppv); <br> <br>    if (FAILED(hr)) <br>        delete pObj; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DllCanUnloadNow <br> * <br> * Purpose: <br> *  Answers if the DLL can be freed, that is, if there are no <br> *  references to anything this DLL provides. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if nothing is using us, FALSE otherwise. <br> */ <br> <br>STDAPI DllCanUnloadNow(void) <br>    { <br>    SCODE   sc; <br> <br>    //Our answer is whether there are any object or locks <br>    sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE; <br>    return ResultFromScode(sc); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ObjectDestroyed <br> * <br> * Purpose: <br> *  Function for the Koala object to call when it gets destroyed. <br> *  Since we're in a DLL we only track the number of objects here, <br> *  letting DllCanUnloadNow take care of the rest. <br> */ <br> <br>void ObjectDestroyed(void) <br>    { <br>    g_cObj--; <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::CKoalaClassFactory <br> * CKoalaClassFactory::~CKoalaClassFactory <br> * <br> * Constructor Parameters: <br> *  None <br> */ <br> <br>CKoalaClassFactory::CKoalaClassFactory(void) <br>    { <br>    m_cRef=0L; <br>    return; <br>    } <br> <br>CKoalaClassFactory::~CKoalaClassFactory(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::QueryInterface <br> * CKoalaClassFactory::AddRef <br> * CKoalaClassFactory::Release <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IClassFactory==riid <br>        || IID_IClassFactory2==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoalaClassFactory::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoalaClassFactory::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    ObjectDestroyed(); <br>    return 0L; <br>    } <br> <br> <br> <br>/* <br> * CKoalaClassFactory::CreateAnObject <br> * (Private) <br> * <br> * Purpose: <br> *  Central function to create instances of objects that is called <br> *  from CreateInstance and CreateInstanceLic.  This takes the same <br> *  parameters as CreateInstance below. <br> */ <br> <br>HRESULT CKoalaClassFactory::CreateAnObject(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    PCKoala             pObj; <br>    HRESULT             hr; <br> <br>    //Verify that a controlling unknown asks for IUnknown <br>    if (NULL!=pUnkOuter &amp;&amp; IID_IUnknown!=riid) <br>        return ResultFromScode(CLASS_E_NOAGGREGATION); <br> <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    //Create the object passing function to notify on destruction. <br>    pObj=new CKoala(pUnkOuter, ObjectDestroyed); <br> <br>    if (NULL==pObj) <br>        return hr; <br> <br>    if (pObj-&gt;Init()) <br>        hr=pObj-&gt;QueryInterface(riid, ppvObj); <br> <br>    //Kill the object if initial creation or Init failed. <br>    if (FAILED(hr)) <br>        delete pObj; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::CreateInstance <br> * <br> * Purpose: <br> *  Instantiates a Koala object returning an interface pointer. <br> * <br> * Parameters: <br> *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are <br> *                  being used in an aggregation. <br> *  riid            REFIID identifying the interface the caller <br> *                  desires to have for the new object. <br> *  ppvObj          PPVOID in which to store the desired <br> *                  interface pointer for the new object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE <br> *                  if we cannot support the requested interface. <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::CreateInstance(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    *ppvObj=NULL; <br> <br>    /* <br>     * The license file *must* be around for this simple <br>     * CreateInstance to work.  One we've checked, call the central <br>     * creation function. <br>     */ <br>    if (!g_fMachineLicensed) <br>        return ResultFromScode(CLASS_E_NOTLICENSED); <br> <br>    return CreateAnObject(pUnkOuter, riid, ppvObj); <br>    } <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::LockServer <br> * <br> * Purpose: <br> *  Increments or decrements the lock count of the DLL.  If the <br> *  lock count goes to zero and there are no objects, the DLL <br> *  is allowed to unload.  See DllCanUnloadNow. <br> * <br> * Parameters: <br> *  fLock           BOOL specifying whether to increment or <br> *                  decrement the lock count. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always. <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::LockServer(BOOL fLock) <br>    { <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        g_cLock--; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::GetLicInfo <br> * <br> * Purpose: <br> *  Fills a LICINFO structure with license information for <br> *  this class factory. <br> * <br> * Parameters: <br> *  pLicInfo        LPLICINFO to the structure to fill <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::GetLicInfo(LPLICINFO pLicInfo) <br>    { <br>    if (NULL==pLicInfo) <br>        return ResultFromScode(E_POINTER); <br> <br>    pLicInfo-&gt;cbLicInfo=sizeof(LICINFO); <br> <br>    //This says whether RequestLicKey will work <br>    pLicInfo-&gt;fRuntimeKeyAvail=g_fMachineLicensed; <br> <br>    //This says whether the standard CreateInstance will work <br>    pLicInfo-&gt;fLicVerified=g_fMachineLicensed; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::RequestLicKey <br> * <br> * Purpose: <br> *  Retrieves a license key from this class factory for use with <br> *  CreateInstanceLic. <br> * <br> * Parameters: <br> *  dwReserved      DWORD reserved for future use with multiple <br> *                  licenses. <br> *  pbstrKey        BSTR * in which to return the key. <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::RequestLicKey(DWORD dwReserved <br>    , BSTR *pbstrKey) <br>    { <br>    OLECHAR     szTemp[256]; <br> <br>    //Can't give away a key on an unlicensed machine <br>    if (!g_fMachineLicensed) <br>        return ResultFromScode(CLASS_E_NOTLICENSED); <br> <br>   #ifndef WIN32 <br>    lstrcpy(g_szLic, szTemp); <br>   #else <br>    mbstowcs(szTemp, g_szLic, sizeof(g_szLic)); <br>   #endif <br>    *pbstrKey=SysAllocString(szTemp); <br>    return (NULL!=*pbstrKey) ? NOERROR : ResultFromScode(E_OUTOFMEMORY); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CKoalaClassFactory::CreateInstanceLic <br> * <br> * Purpose: <br> *  Creates and instance of the object given a license key. <br> *  Same as CreateInstance, and implementations of this function <br> *  will typically just validate the key and call CreateInstance. <br> * <br> * Parameters: <br> *  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are <br> *                  being used in an aggregation. <br> *  pUnkReserved    LPUNKNOWN reserved. <br> *  riid            REFIID identifying the interface the caller <br> *                  desires to have for the new object. <br> *  bstrKey         BSTR key used to validate creation. <br> *  ppvObj          PPVOID in which to store the desired <br> *                  interface pointer for the new object. <br> */ <br> <br>STDMETHODIMP CKoalaClassFactory::CreateInstanceLic(LPUNKNOWN pUnkOuter <br>    , LPUNKNOWN pUnkReserved, REFIID riid, BSTR bstrKey <br>    , PPVOID ppvObj) <br>    { <br>    BOOL        fMatch; <br>    BSTR        bstrTemp; <br>    UINT        cch; <br>    OLECHAR     szLic[256]; <br>   #ifdef WIN32ANSI <br>    char        szTemp[256]; <br>   #endif <br> <br>    *ppvObj=NULL; <br> <br>    /* <br>     * Get our own license key that should match bstrKey exactly. <br>     * This code is coped from RequestLicKey. <br>     */ <br>   #ifndef WIN32 <br>    lstrcpy(g_szLic, szLic); <br>   #else <br>    mbstowcs(szLic, g_szLic, sizeof(g_szLic)); <br>   #endif <br>    bstrTemp=SysAllocString(szLic); <br> <br>    if (NULL==bstrTemp) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>   #ifdef WIN32ANSI <br>    WideCharToMultiByte(CP_ACP, 0, bstrTemp, -1, szTemp <br>        , 256, NULL, NULL); <br>    cch=lstrlen(szTemp); <br>   #else <br>    cch=lstrlen(bstrTemp); <br>   #endif <br>    fMatch=(0==memcmp(bstrTemp, bstrKey, cch*sizeof(OLECHAR))); <br>    SysFreeString(bstrTemp); <br> <br>    if (!fMatch) <br>        return ResultFromScode(CLASS_E_NOTLICENSED); <br> <br>    return CreateAnObject(pUnkOuter, riid, ppvObj); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
