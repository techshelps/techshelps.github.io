<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context475"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Component Cosmo Chapter 5 <br> * <br> * Implementation of the CCosmoDoc derivation of CDocument as <br> * well as an implementation of CPolylineAdviseSink. <br> * <br> * Copyright (c)1993-1997 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cocosmo.h" <br> <br> <br> <br>/* <br> * CCosmoDoc::CCosmoDoc <br> * CCosmoDoc::~CCosmoDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> */ <br> <br>CCosmoDoc::CCosmoDoc(HINSTANCE hInst, PCFrame pFR) <br>    : CDocument(hInst, pFR) <br>    { <br>    m_uPrevSize=SIZE_RESTORED; <br>    m_pPL=NULL; <br>    m_pPLAdv=NULL; <br> <br>    //CHAPTER5MOD <br>    m_pIStorage=NULL; <br>    m_pIPersistStorage=NULL; <br>    //End CHAPTER5MOD <br>    return; <br>    } <br> <br> <br>CCosmoDoc::~CCosmoDoc(void) <br>    { <br>    //The client takes care of destroying document windows. <br> <br>    //CHAPTER5MOD <br>    if (NULL!=m_pIPersistStorage) <br>        m_pIPersistStorage-&gt;Release(); <br> <br>    if (NULL!=m_pIStorage) <br>        m_pIStorage-&gt;Release(); <br>    //End CHAPTER5MOD <br> <br>    if (NULL!=m_pPL) <br>        m_pPL-&gt;Release(); <br> <br>    if (NULL!=m_pPLAdv) <br>        m_pPLAdv-&gt;Release; <br> <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FInit <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FInit(PDOCUMENTINIT pDI) <br>    { <br>    RECT        rc; <br>    HRESULT     hr; <br> <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::FInit(pDI)) <br>        return FALSE; <br> <br>    //CHAPTER5MOD <br>    //Create the Polyline Component Object via COMPOBJ.DLL functions <br>    hr=CoCreateInstance(CLSID_Polyline5, NULL, CLSCTX_INPROC_SERVER <br>        , IID_IPolyline5, (PPVOID)&amp;m_pPL); <br>    //End CHAPTER5MOD <br> <br>    if (FAILED(hr)) <br>        { <br>        //Warn that we could not load the Polyline <br>        MessageBox(pDI-&gt;hWndDoc, PSZ(IDS_NOPOLYLINE) <br>            , PSZ(IDS_CAPTION), MB_OK); <br>        return FALSE; <br>        } <br> <br>    //Initialize the contained Polyline which creates a window. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    if (FAILED(m_pPL-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_POLYLINE))) <br>        return FALSE; <br> <br>    //Set up an advise on the Polyline. <br>    m_pPLAdv=new CPolylineAdviseSink(this); <br>    m_pPL-&gt;SetAdvise(m_pPLAdv); <br> <br>    //CHAPTER5MOD <br>    hr=m_pPL-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;m_pIPersistStorage); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br>    //End CHAPTER5MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize <br> *  the Polyline. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    if (WM_SIZE==iMsg) <br>        { <br>        //Don't effect the Polyline size to or from minimized state. <br>        if (SIZE_MINIMIZED!=wParam &amp;&amp; SIZE_MINIMIZED !=m_uPrevSize) <br>            { <br>            //When we change size, resize any Polyline we hold. <br>            dx=LOWORD(lParam); <br>            dy=HIWORD(lParam); <br> <br>            /* <br>             * If we are getting WM_SIZE in response to a Polyline <br>             * notification, then don't resize the Polyline window <br>             * again. <br>             */ <br>            if (!m_fNoSize &amp;&amp; NULL!=m_pPL) <br>                { <br>                //Resize the polyline to fit the new client <br>                SetRect(&amp;rc, 8, 8, dx-8, dy-8); <br>                m_pPL-&gt;RectSet(&amp;rc, FALSE); <br> <br>                /* <br>                 * We consider sizing something that makes the file <br>                 * dirty, but not until we've finished the create <br>                 * process, which is why we set fNoDirty to FALSE <br>                 * in WM_CREATE since we get a WM_SIZE on the first <br>                 * creation. <br>                 */ <br>                if (!m_fNoDirty) <br>                    FDirtySet(TRUE); <br> <br>                SetRect(&amp;rc, 0, 0, dx, dy); <br> <br>                if (NULL!=m_pAdv) <br>                    m_pAdv-&gt;OnSizeChange(this, &amp;rc); <br> <br>                m_fNoDirty=FALSE; <br>                } <br>            } <br> <br>        m_uPrevSize=wParam; <br>        } <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with <br> *  no filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Clear(void) <br>    { <br>    //Completely reset the polyline <br>    m_pPL-&gt;New(); <br> <br>    CDocument::Clear(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ULoad <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the Polyline window.  We do this by <br> *  opening the file and telling the Polyline to load itself from <br> *  that file. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load, NULL if the file <br> *                  is new and untitled. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::ULoad(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    HRESULT             hr; <br>    //CHAPTER5MOD <br>    LPSTORAGE           pIStorage; <br> <br>    if (NULL==pszFile) <br>        { <br>        //CHAPTER5MOD <br>        /* <br>         * As a user of an IPersistStorage we have to provide all <br>         * objects with an IStorage they can use for incremental <br>         * access passing that storage to InitNew.  Here we create <br>         * a temporary file that we don't bother holding on to. <br>         * If the object doesn't use it, then our Release destroys <br>         * it immediately. <br>         */ <br> <br>        hr=StgCreateDocfile(NULL, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_DELETEONRELEASE <br>            | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        m_pIPersistStorage-&gt;InitNew(pIStorage); <br>        m_pIStorage=pIStorage; <br>        //End CHAPTER5MOD <br> <br>        Rename(NULL); <br>        return DOCERR_NONE; <br>        } <br> <br>    //CHAPTER5MOD <br>    /* <br>     * Open a storage and pass it to the Polyline via <br>     * IPersistStorage.  We do not remain compatible with <br>     * previous files saved with Component Cosmo. <br>     */ <br> <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    OLECHAR pwcsFile[MAX_PATH]; <br>    mbstowcs(pwcsFile, pszFile, MAX_PATH); <br>    hr=StgOpenStorage(pwcsFile, NULL, STGM_DIRECT | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage); <br>#else <br>    hr=StgOpenStorage(pszFile, NULL, STGM_DIRECT | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage); <br>#endif <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    hr=m_pIPersistStorage-&gt;Load(pIStorage); <br>    m_pIStorage=pIStorage; <br>    //End CHAPTER5MOD <br> <br>    if (FAILED(hr)) <br>        return DOCERR_READFAILURE; <br> <br>    if (fChangeFile) <br>        Rename(pszFile); <br> <br>    //Importing a file makes things dirty <br>    FDirtySet(!fChangeFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::USave <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user <br> *  has previously used FileOpen or FileSaveAs in order to have <br> *  a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::USave(UINT uType, LPTSTR pszFile) <br>    { <br>    BOOL                fRename=TRUE; <br>    HRESULT             hr; <br>    //CHAPTER5MOD <br>    LPSTORAGE           pIStorage; <br>    BOOL                fSameAsLoad; <br> <br>    //If Save or Save As under the same name, do Save. <br>    if (NULL==pszFile || 0==lstrcmpi(pszFile, m_szFile)) <br>        { <br>        fRename=FALSE; <br>        pszFile=m_szFile; <br> <br>        /* <br>         * If we're saving to an existing storage, just pass <br>         * the IStorage we have from ULoad along with TRUE <br>         * in fSameAsLoad. <br>         */ <br> <br>        fSameAsLoad=TRUE; <br>        } <br>    else <br>        { <br>        /* <br>         * In Component Cosmo, we only deal with one version of <br>         * data; all the code in Chapter 2 Cosmo that dealt with <br>         * 1.0 and 2.0 files has been removed. <br>         */ <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsFile[MAX_PATH]; <br>        mbstowcs(pwcsFile,pszFile,MAX_PATH); <br>        hr=StgCreateDocfile(pwcsFile, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br>#else <br>        hr=StgCreateDocfile(pszFile, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br>#endif <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        //Tell the object to save into this new storage <br>        fSameAsLoad=FALSE; <br> <br>        //Update our variable <br>        m_pIStorage-&gt;Release(); <br>        m_pIStorage=pIStorage; <br>        } <br> <br>    hr=m_pIPersistStorage-&gt;Save(m_pIStorage, fSameAsLoad); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        hr=m_pIPersistStorage-&gt;SaveCompleted(fSameAsLoad <br>            ? NULL : m_pIStorage); <br>        } <br>    //End CHAPTER5MOD <br> <br>    if (FAILED(hr)) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Saving makes us clean <br>    FDirtySet(FALSE); <br> <br>    if (fRename) <br>        Rename(pszFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Undo <br> * <br> * Purpose: <br> *  Reverses a previous action. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Undo(void) <br>    { <br>    m_pPL-&gt;Undo(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FClip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FClip(HWND hWndFrame, BOOL fCut) <br>    { <br>    BOOL            fRet=TRUE; <br>    HGLOBAL         hMem; <br>    UINT            i; <br> <br>    //This array is so we can loop over the formats we provide. <br>    static UINT     rgcf[3]={0, CF_METAFILEPICT, CF_BITMAP}; <br>    const UINT      cFormats=3; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    //Clean out whatever junk is in the clipboard. <br>    EmptyClipboard(); <br> <br>    rgcf[0]=m_cf; <br> <br>    for (i=0; i &lt; cFormats; i++) <br>        { <br>        //Copy private data first. <br>        hMem=RenderFormat(rgcf[i]); <br> <br>        if (NULL!=hMem) <br>            SetClipboardData(rgcf[i], hMem); <br>        else <br>            fRet &amp;=FALSE; <br>        } <br> <br>    //Free clipboard ownership. <br>    CloseClipboard(); <br> <br>    //Delete our current data if copying succeeded. <br>    if (fRet &amp;&amp; fCut) <br>        { <br>        m_pPL-&gt;New(); <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::RenderFormat <br> * <br> * Purpose: <br> *  Renders a specific clipboard format into global memory. <br> * <br> * Parameters: <br> *  cf              UINT format to render. <br> * <br> * Return Value: <br> *  HGLOBAL         Global memory handle containing the data. <br> */ <br> <br>HGLOBAL CCosmoDoc::RenderFormat(UINT cf) <br>    { <br>    HGLOBAL     hMem; <br> <br>    if (cf==m_cf) <br>        { <br>        m_pPL-&gt;DataGetMem(&amp;hMem); <br>        return hMem; <br>        } <br> <br>    switch (cf) <br>        { <br>        case CF_METAFILEPICT: <br>            m_pPL-&gt;RenderMetafilePict(&amp;hMem); <br>            return hMem; <br> <br>        case CF_BITMAP: <br>            m_pPL-&gt;RenderBitmap((HBITMAP *)&amp;hMem); <br>            return hMem; <br>        } <br> <br>    return NULL; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPaste(void) <br>    { <br>    return IsClipboardFormatAvailable(m_cf); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FPaste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FPaste(HWND hWndFrame) <br>    { <br>    HGLOBAL         hMem; <br>    PPOLYLINEDATA   ppl; <br>    BOOL            fRet=FALSE; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    hMem=GetClipboardData(m_cf); <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br> <br>        //TRUE in wParam to cause PLN_SIZECHANGE notification <br>        m_pPL-&gt;DataSet(ppl, FALSE, TRUE); <br>        GlobalUnlock(hMem); <br> <br>        FDirtySet(TRUE); <br>        fRet=TRUE; <br>        } <br> <br>    CloseClipboard(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorSet <br> * <br> * Purpose: <br> *  Changes a color used in our contained Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color. <br> * <br> * Return Value: <br> *  COLORREF        Previous color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorSet(UINT iColor, COLORREF cr) <br>    { <br>    COLORREF    crRet; <br> <br>    m_pPL-&gt;ColorSet(iColor, cr, &amp;crRet); <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorGet <br> * <br> * Purpose: <br> *  Retrieves a color currently in use in the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to retrieve. <br> * <br> * Return Value: <br> *  COLORREF        Current color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorGet(UINT iColor) <br>    { <br>    COLORREF    crRet; <br> <br>    m_pPL-&gt;ColorGet(iColor, &amp;crRet); <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT index of the new line style to use. <br> * <br> * Return Value: <br> *  UINT            Previous line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleSet(UINT iStyle) <br>    { <br>    UINT    i; <br> <br>    m_pPL-&gt;LineStyleSet(iStyle, &amp;i); <br>    return i; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Current line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleGet(void) <br>    { <br>    UINT    i; <br> <br>    m_pPL-&gt;LineStyleGet(&amp;i); <br>    return i; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::CPolylineAdviseSink <br> * <br> * Parameters: <br> *  pv              LPVOID to store in this object <br> */ <br> <br>CPolylineAdviseSink::CPolylineAdviseSink(LPVOID pv) <br>    { <br>    m_pv=pv; <br>    m_cRef=0; <br>    AddRef(); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::~CPolylineAdviseSink <br> * <br> * Purpose: <br> *  Destructor. <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>CPolylineAdviseSink::~CPolylineAdviseSink(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::QueryInterface <br> * CPolylineAdviseSink::AddRef <br> * CPolylineAdviseSink::Release <br> * <br> * Purpose: <br> *  IUnknown members for this IPolylineAdviseSink implementations. <br> */ <br> <br>STDMETHODIMP CPolylineAdviseSink::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    //CHAPTER5MOD <br>    //Any interface on this object is the object pointer. <br>    if (IID_IUnknown==riid || IID_IPolylineAdviseSink5==riid) <br>        *ppv=this; <br>    //End CHAPTER5MOD <br> <br>    /* <br>     * If we actually assign an interface to ppv we need to AddRef <br>     * it since we're returning a new pointer. <br>     */ <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return S_FALSE; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolylineAdviseSink::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolylineAdviseSink::Release(void) <br>    { <br>    ULONG   cRefT; <br> <br>    cRefT=--m_cRef; <br> <br>    if (0L==m_cRef) <br>        delete this; <br> <br>    return cRefT; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnPointChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline added or removed a point. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDMETHODIMP_(void) CPolylineAdviseSink::OnPointChange(void) <br>    { <br>    PCDocument      pDoc=(PCDocument)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnSizeChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed size. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDMETHODIMP_(void) CPolylineAdviseSink::OnSizeChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br>    RECT            rc; <br>    DWORD           dwStyle; <br>    HWND            hWnd; <br> <br>    /* <br>     * Polyline window is informing us that it changed size in <br>     * response to setting it's data.  Therefore we have to <br>     * size ourselves accordingly but without moving the screen <br>     * position of the polyline window. <br>     */ <br> <br>    pDoc-&gt;m_fNoSize=TRUE; <br> <br>    //Set the document window size. <br>    pDoc-&gt;m_pPL-&gt;Window(&amp;hWnd); <br>    GetWindowRect(hWnd, &amp;rc); <br>    InflateRect(&amp;rc, 8, 8); <br> <br>    //Adjust for a window sans menu <br>    dwStyle=GetWindowLong(pDoc-&gt;m_hWnd, GWL_STYLE); <br>    AdjustWindowRect(&amp;rc, dwStyle, FALSE); <br> <br>    SetWindowPos(pDoc-&gt;m_hWnd, NULL, 0, 0, rc.right-rc.left <br>        , rc.bottom-rc.top, SWP_NOMOVE | SWP_NOZORDER); <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnSizeChange(pDoc, &amp;rc); <br> <br>    pDoc-&gt;m_fNoSize=FALSE; <br>    pDoc-&gt;FDirtySet(TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnDataChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDMETHODIMP_(void) CPolylineAdviseSink::OnDataChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnDataChange(pDoc); <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnColorChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed a color. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDMETHODIMP_(void) CPolylineAdviseSink::OnColorChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnLineStyleChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed its line style. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDMETHODIMP_(void) CPolylineAdviseSink::OnLineStyleChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
