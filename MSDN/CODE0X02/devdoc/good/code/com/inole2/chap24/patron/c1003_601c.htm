<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1020"></a>PAGE.CPP</h2>
<pre><code>/* <br> * PAGE.CPP <br> * Patron Chapter 24 <br> * <br> * Implementation of parts of the CPage class; those member <br> * functions dealing with mouse events are in PAGEMOUS.CPP. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CPage::CPage <br> * CPage::~CPage <br> * <br> * Constructor Parameters: <br> *  dwID            DWORD identifier for this page. <br> *  hWnd            HWND of the pages window (for repaints, etc). <br> *  pPG             PCPages to the Pages window. <br> */ <br> <br>CPage::CPage(DWORD dwID, HWND hWnd, PCPages pPG) <br>    { <br>    m_dwID     =dwID; <br>    m_pIStorage=NULL; <br> <br>    m_cOpens=0; <br>    m_hWnd=hWnd; <br>    m_pPG=pPG; <br> <br>    m_dwIDNext      =0; <br>    m_cTenants      =0; <br>    m_hWndTenantList=NULL; <br>    m_iTenantCur    =NOVALUE;   //Tenants are zero indexed. <br>    m_pTenantCur    =NULL; <br> <br>    m_uHTCode=HTNOWHERE; <br>    m_uSizingFlags=0; <br>    m_fTracking=FALSE; <br>    m_hDC=NULL; <br> <br>    m_fDragPending=FALSE; <br>    m_fSizePending=FALSE; <br>    m_fTimer=FALSE; <br> <br>    //Get WIN.INI distance and delay values, with OLE defaults. <br>    m_cxyDist=GetProfileInt(TEXT("windows"), TEXT("DragMinDist") <br>        , DD_DEFDRAGMINDIST); <br>    m_cDelay=GetProfileInt(TEXT("windows"), TEXT("DragDelay") <br>        , DD_DEFDRAGDELAY); <br> <br>    m_fReopen=FALSE; <br>    m_pmkFile=m_pPG-&gt;m_pmkFile; <br> <br>    if (NULL!=m_pmkFile) <br>        m_pmkFile-&gt;AddRef(); <br> <br>    m_cRef=0L; <br>    m_dwRegROTWild=0L; <br>    m_pImpIOleItemContainer=NULL; <br> <br>    m_fFirstUIActivate=TRUE;  //We haven't UIActivated anyone yet <br>    return; <br>    } <br> <br> <br>CPage::~CPage(void) <br>    { <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROTWild); <br> <br>    if (m_fTimer) <br>        KillTimer(m_hWnd, IDTIMER_DEBOUNCE); <br> <br>    m_hWnd=NULL; <br>    Close(FALSE); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPage::QueryInterface <br> * CPage::AddRef <br> * CPage::Release <br> * <br> * Purpose: <br> *  IUnknown members for CPage object. <br> */ <br> <br>STDMETHODIMP CPage::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IOleItemContainer==riid || IID_IOleContainer==riid <br>        || IID_IParseDisplayName==riid) <br>        *ppv=m_pImpIOleItemContainer; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPage::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CPage::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::GetID <br> * <br> * Return Value: <br> *  DWORD           dwID field in this page. <br> */ <br> <br>DWORD CPage::GetID(void) <br>    { <br>    return m_dwID; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::Open <br> * <br> * Purpose: <br> *  Retrieves the IStorage associated with this page.  The IStorage <br> *  is owned by the page and thus the page always holds a reference <br> *  count.  The caller should call Close or delete this page to <br> *  match this open. <br> * <br> *  This function may be called multiple times resulting in <br> *  additional reference counts on the storage each of which must be <br> *  matched with a call to Close.  The last Close can be done <br> *  through delete. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE in which this page lives. <br> * <br> * Return Value: <br> *  BOOL            TRUE if opening succeeds, FALSE otherwise. <br> */ <br> <br>BOOL CPage::Open(LPSTORAGE pIStorage) <br>    { <br>    HRESULT                 hr=NOERROR; <br>    LPSTREAM                pIStream; <br>    DWORD                   dwMode; <br>    OLECHAR                 szTemp[32]; <br>    TCHAR                   szCap[32]; <br>    BOOL                    fNew; <br>    BOOL                    fCreated=FALSE; <br>    TENANTLIST              tl; <br>    PTENANTINFO             pti; <br>    ULONG                   cb; <br>    LPMALLOC                pIMalloc; <br>    UINT                    i; <br>    PCTenant                pTenant; <br>    UINT                    cLinks; <br>    LPOLELINK               pIOleLink; <br>    LPUNKNOWN               pIUnknown; <br>    UINT                    uRet; <br>    OLEUIEDITLINKS          el; <br>    PCIOleUILinkContainer   pIUILinks; <br>    HWND                    hWndDoc; <br> <br>    fNew=(NULL==m_pIStorage); <br> <br>    if (!fNew) <br>        { <br>        m_cOpens++; <br>        m_pIStorage-&gt;AddRef(); <br>        return TRUE; <br>        } <br> <br>    if (NULL==pIStorage) <br>        return FALSE; <br> <br>    /* <br>     * Attempt to open the storage under this ID.  If none, <br>     * create one.  In either case, the IStorage is either <br>     * saved in pPage or released. <br>     */ <br> <br>    GetStorageName(szTemp); <br>    dwMode=STGM_TRANSACTED | STGM_READWRITE | STGM_SHARE_EXCLUSIVE; <br> <br>    hr=pIStorage-&gt;OpenStorage(szTemp, NULL, dwMode, NULL, 0 <br>        , &amp;m_pIStorage); <br> <br>    if (FAILED(hr)) <br>        { <br>        hr=pIStorage-&gt;CreateStorage(szTemp, dwMode, 0, 0 <br>            , &amp;m_pIStorage); <br>        fCreated=TRUE; <br>        } <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    m_cOpens++; <br> <br>    if (NULL==m_hWndTenantList) <br>        { <br>        /* <br>         * The first time we open this page, create the hidden <br>         * listbox we'll use to track tenants.  We give it the <br>         * owner-draw style so we can just store pointers in it. <br>         */ <br>        m_hWndTenantList=CreateWindow(TEXT("listbox") <br>            , TEXT("Tenant List"), WS_POPUP | LBS_OWNERDRAWFIXED <br>            , 0, 0, 100, 100, HWND_DESKTOP, NULL <br>            , m_pPG-&gt;m_hInst, NULL); <br> <br>        if (NULL==m_hWndTenantList) <br>            return FALSE; <br>        } <br> <br>    m_pImpIOleItemContainer=new CImpIOleItemContainer(this, this <br>        , FALSE); <br> <br>    if (NULL==m_pImpIOleItemContainer) <br>        return FALSE; <br> <br>    //If this is brand-new, we're done. <br>    if (fCreated) <br>        return TRUE; <br> <br> <br>    /* <br>     * Now open the stream we saved in Close and load all the <br>     * tenants listed in there.  If there are none, then we don't <br>     * have to load squat. <br>     */ <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMTENANTLIST, NULL, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        pIStream-&gt;Read(&amp;tl, sizeof(tl), NULL); <br>        m_cTenants=tl.cTenants; <br>        m_dwIDNext=tl.dwIDNext; <br>        m_iTenantCur=0; <br> <br>        cb=tl.cTenants*sizeof(TENANTINFO); <br> <br>        if (0!=cb) <br>            { <br>            pti=(PTENANTINFO)pIMalloc-&gt;Alloc(cb); <br> <br>            if (NULL!=pti) <br>                { <br>                pIStream-&gt;Read(pti, cb, NULL); <br> <br>                for (i=0; i &lt; m_cTenants; i++) <br>                    { <br>                    if (TenantAdd(NOVALUE, (pti+i)-&gt;dwID, &amp;pTenant)) <br>                        { <br>                        pTenant-&gt;Load(m_pIStorage, (pti+i)); <br> <br>                        //Make sure it knows about the show state. <br>                        pTenant-&gt;ShowObjectType(m_pPG-&gt;m_fShowTypes); <br>                        } <br>                    } <br> <br>                pIMalloc-&gt;Free(pti); <br>                } <br>            } <br> <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    //Get and select the first tenant <br>    if (TenantGet(0, &amp;m_pTenantCur, FALSE)) <br>        m_pTenantCur-&gt;Select(TRUE, TRUE); <br> <br>    //If we just saved and closed, don't bother with updating links <br>    if (m_fReopen) <br>        { <br>        m_fReopen=FALSE; <br>        return TRUE; <br>        } <br> <br>    /* <br>     * Update all the links in this page, showing the progress <br>     * indicator as it's happening.  We use the same <br>     * IOlUILinkContainer implementation as we do for the links <br>     * dialog, passing it to OleUIUpdateLinks which does everything <br>     * for us. <br>     * <br>     * We might also optimize this to not do anything if there are <br>     * no automatic links, but it's not a big concern. <br>     */ <br> <br>    //First, count the number of automatic links. <br>    cLinks=0; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            { <br>            DWORD       dw; <br> <br>            pTenant-&gt;ObjectGet(&amp;pIUnknown); <br>            hr=pIUnknown-&gt;QueryInterface(IID_IOleLink <br>                , (PPVOID)&amp;pIOleLink); <br>            pIUnknown-&gt;Release(); <br> <br>            if (FAILED(hr)) <br>                continue; <br> <br>            pIOleLink-&gt;GetUpdateOptions(&amp;dw); <br>            pIOleLink-&gt;Release(); <br> <br>            if (OLEUPDATE_ALWAYS==dw) <br>                cLinks++; <br>            } <br>        } <br> <br>    //If we have any automatic links, invoke the update dialog. <br>    if (0==cLinks) <br>        return TRUE; <br> <br>    //Create an IOleUILinkContainer instantiation. <br>    if (!m_pPG-&gt;GetUILinkContainer(&amp;pIUILinks)) <br>        return TRUE;    //Guess we can't update, oh well. <br> <br>    hWndDoc=GetParent(m_hWnd); <br>    LoadString(m_pPG-&gt;m_hInst, IDS_CAPTION, szCap, sizeof(szCap)); <br> <br>    if (!OleUIUpdateLinks(pIUILinks, hWndDoc, szCap, cLinks)) <br>        { <br>        /* <br>         * If updating failed, ask to show the links dialog.  NOTE: <br>         * OleUIPromptUser has a variable wsprintf argument list <br>         * after the hWnd parameter!  Use appropriate typecasting! <br>         */ <br>        uRet=OleUIPromptUser(IDD_CANNOTUPDATELINK, hWndDoc, szCap); <br> <br>       #ifdef IDC_PU_LINKS <br>        if (IDC_PU_LINKS==uRet) <br>       #else <br>        if (ID_PU_LINKS==uRet) <br>       #endif <br>            { <br>            //Throw up the links dialog. <br>            memset(&amp;el, 0, sizeof(el)); <br>            el.cbStruct=sizeof(el); <br>            el.hWndOwner=hWndDoc; <br>            el.lpOleUILinkContainer=pIUILinks; <br>            OleUIEditLinks(&amp;el); <br>            } <br>        } <br> <br>    m_pPG-&gt;m_fDirty=pIUILinks-&gt;m_fDirty; <br>    pIUILinks-&gt;Release(); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::Close <br> * <br> * Purpose: <br> *  Possibly commits the storage, then releases it reversing the <br> *  reference count from Open. <br> * <br> * Parameters: <br> *  fCommit         BOOL indicating if we're to commit. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::Close(BOOL fCommit) <br>    { <br>    if (NULL==m_pIStorage) <br>        return; <br> <br>    if (fCommit) <br>        Update(); <br> <br>    m_pIStorage-&gt;Release(); <br> <br>    //If this was the last close, make all tenants loaded-&gt;passive <br>    if (0==--m_cOpens) <br>        { <br>        UINT        i; <br>        PCTenant    pTenant; <br> <br>        m_pIStorage=NULL; <br> <br>        for (i=0; i &lt; m_cTenants; i++) <br>            { <br>            if (TenantGet(i, &amp;pTenant, FALSE)) <br>                { <br>                if (NULL!=m_hWnd) <br>                    { <br>                    //Open may select again, so this repaints. <br>                    pTenant-&gt;Select(FALSE, TRUE); <br>                    } <br> <br>                pTenant-&gt;Close(FALSE); <br>                pTenant-&gt;Release(); <br>                } <br>            } <br> <br>        DestroyWindow(m_hWndTenantList); <br>        m_hWndTenantList=NULL; <br>        m_fReopen=TRUE; <br> <br>        if (NULL!=m_pmkFile) <br>            m_pmkFile-&gt;Release(); <br> <br>        m_pmkFile=NULL; <br> <br>        DeleteInterfaceImp(m_pImpIOleItemContainer); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::Update <br> * <br> * Purpose: <br> *  Forces a common on the page if it's open. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if there are any open objects on this page, <br> *                  that is, we should remain open. <br> */ <br> <br>BOOL CPage::Update(void) <br>    { <br>    BOOL            fOpen=FALSE; <br>    UINT            i; <br>    PCTenant        pTenant; <br>    HRESULT         hr; <br>    LPSTREAM        pIStream; <br>    TENANTLIST      tl; <br>    PTENANTINFO     pti; <br>    ULONG           cb; <br>    LPMALLOC        pIMalloc; <br> <br>    //Walk the list of objects and update them all as well. <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            fOpen |= pTenant-&gt;Update(); <br>        } <br> <br>    //Now write our own stream containing the tenant list. <br>    hr=m_pIStorage-&gt;CreateStream(SZSTREAMTENANTLIST, STGM_CREATE <br>        | STGM_WRITE| STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, 0 <br>        , &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return fOpen; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        tl.cTenants=m_cTenants; <br>        tl.dwIDNext=m_dwIDNext; <br> <br>        pIStream-&gt;Write(&amp;tl, sizeof(TENANTLIST), &amp;cb); <br> <br>        cb=m_cTenants*sizeof(TENANTINFO); <br>        pti=(PTENANTINFO)pIMalloc-&gt;Alloc(cb); <br> <br>        if (NULL!=pti) <br>            { <br>            for (i=0; i &lt; m_cTenants; i++) <br>                { <br>                TenantGet(i, &amp;pTenant, FALSE); <br>                pTenant-&gt;GetInfo((pti+i)); <br>                } <br> <br>            pIStream-&gt;Write(pti, cb, &amp;cb); <br>            pIMalloc-&gt;Free(pti); <br>            } <br> <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    //Now commit the whole mess and we're done <br>    if (NULL!=m_pIStorage) <br>        m_pIStorage-&gt;Commit(STGC_DEFAULT); <br> <br>    return fOpen; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::Destroy <br> * <br> * Purpose: <br> *  Removes this page from the given storage.  The caller should <br> *  eventually delete this Page object to free the storage. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE contianing this page on which to call <br> *                  DestroyElement <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::Destroy(LPSTORAGE pIStorage) <br>    { <br>    if (NULL!=pIStorage) <br>        { <br>        OLECHAR szTemp[32]; <br> <br>        Close(FALSE); <br>        GetStorageName(szTemp); <br>        pIStorage-&gt;DestroyElement(szTemp); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::GetStorageName <br> * <br> * Parameters: <br> *  pszName         LPOLESTR to a buffer in which to store the <br> *                  storage name for this page. <br> * <br> * Return Value: <br> *  UINT            Number of characters stored. <br> */ <br> <br>UINT CPage::GetStorageName(LPOLESTR pszName) <br>    { <br>   #ifdef WIN32ANSI <br>    char        szTemp[32]; <br>    UINT        cch; <br> <br>    cch=wsprintf(szTemp, "Page %lu", m_dwID); <br>    MultiByteToWideChar(CP_ACP, 0, szTemp, -1, pszName, 32); <br>    return cch; <br>   #else <br>    return wsprintf(pszName, TEXT("Page %lu"), m_dwID); <br>   #endif <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::Draw <br> * <br> * Purpose: <br> *  Draws the objects on this page to the given hDC. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> *  xOff, yOff      int offsets for the page. <br> *  fNoColor        BOOL indicating black &amp; white screen rendering. <br> *  fPrinter        BOOL indicating hDC is on the printer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::Draw(HDC hDC, int xOff, int yOff, BOOL fNoColor <br>    , BOOL fPrinter) <br>    { <br>    int                 i; <br>    PCTenant            pTenant; <br>    HDC                 hIC=NULL; <br>    PCOMBINEDEVICE      pcd=NULL; <br>    DVTARGETDEVICE     *ptd=NULL; <br> <br>    /* <br>     * If printing, tell the tenant to forget the borders. Otherwise <br>     * we leave xOff and yOff the same to account for scrolling. <br>     */ <br>    if (fPrinter) <br>        { <br>        xOff=LOMETRIC_BORDER+m_pPG-&gt;m_xMarginLeft; <br>        yOff=-LOMETRIC_BORDER-m_pPG-&gt;m_yMarginTop; <br> <br>        /* <br>         * Get device information.  If this fails, ptd is <br>         * NULL which is acceptable. <br>         */ <br>        if (m_pPG-&gt;DevReadConfig(&amp;pcd, &amp;hIC)) <br>            ptd=&amp;(pcd-&gt;td); <br>        } <br> <br>    for (i=(int)m_cTenants-1; i &gt;=0; i--) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            { <br>            RECT        rc, rcWin; <br>            RECTL       rcl; <br> <br>            //Paint this tenant only if visible. <br>            pTenant-&gt;RectGet(&amp;rcl, TRUE); <br>            RECTFROMRECTL(rc, rcl); <br>            OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos <br>                , -(int)m_pPG-&gt;m_yPos); <br>            GetClientRect(m_hWnd, &amp;rcWin); <br> <br>            if (IntersectRect(&amp;rc, &amp;rc, &amp;rcWin)) <br>                { <br>                pTenant-&gt;Draw(hDC, ptd, hIC, xOff, yOff <br>                    , fNoColor, fPrinter); <br>                } <br>            } <br>        } <br> <br>    //Free whatever CPages::DevReadConfig returned. <br>    if (NULL!=pcd) <br>        { <br>        LPMALLOC    pIMalloc; <br> <br>        if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>            { <br>            pIMalloc-&gt;Free(pcd); <br>            pIMalloc-&gt;Release(); <br>            } <br>        } <br> <br>    if (NULL!=hIC) <br>        DeleteDC(hIC); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantCreate <br> * <br> * Purpose: <br> *  Creates a new tenant of a specific type. <br> * <br> * Parameters: <br> *  tType           TENANTTYPE to create. <br> *  pv              LPVOID providing information for the new <br> *                  object creation. <br> *  pFE             LPFORMATETC describing how we want this <br> *                  rendered. <br> *  ppo             PPATRONOBJECT with placement data. <br> *  dwData          DWORD extra data to pass to the tenant. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPage::TenantCreate(TENANTTYPE tType, LPVOID pv <br>    , LPFORMATETC pFE, PPATRONOBJECT ppo, DWORD dwData) <br>    { <br>    PCTenant    pTenant; <br>    UINT        uRet; <br>    int         x, y; <br>    int         h, v; <br>    POINTL      ptl; <br>    SIZEL       szl; <br>    RECTL       rcl; <br>    RECT        rc; <br> <br>    //New tenants go at top of the pile; zero index to TenantAdd. <br>    if (!TenantAdd(0, m_dwIDNext, &amp;pTenant)) <br>        return FALSE; <br> <br>    uRet=pTenant-&gt;Create(tType, pv, pFE, &amp;ptl, &amp;szl, m_pIStorage <br>        , ppo, dwData); <br> <br>    if (CREATE_FAILED==uRet) <br>        { <br>        //Reverse Create AND TenantAdd <br>        SendMessage(m_hWndTenantList, LB_DELETESTRING, 0, 0L); <br>        pTenant-&gt;Destroy(m_pIStorage); <br> <br>        pTenant-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    m_dwIDNext++; <br>    m_cTenants++; <br> <br>    if (NULL!=m_pTenantCur) <br>        m_pTenantCur-&gt;Select(FALSE, TRUE); <br> <br>    m_iTenantCur=0;             //First one in the list now. <br>    m_pTenantCur=pTenant; <br> <br>    //Tell the tenant where it lives, default is (0,0) in print area <br>    x=LOMETRIC_BORDER+m_pPG-&gt;m_xMarginLeft; <br>    y=-LOMETRIC_BORDER-m_pPG-&gt;m_yMarginTop; <br> <br>    h=x; <br>    v=y; <br> <br>    if (CREATE_PLACEDOBJECT==uRet) <br>        { <br>        SetRect(&amp;rc, 3*CXYHANDLE, 3*CXYHANDLE, 0, 0); <br>        RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>        //Make sure place point is on page, otherwise go to (0,0) <br>        if (((int)ptl.x &gt; x) <br>            &amp;&amp; ((int)ptl.x &lt; x+(int)m_pPG-&gt;m_cx-rc.left)) <br>            x=(int)ptl.x; <br> <br>        //m_pPG-&gt;m_cy is absolute <br>        if (((int)ptl.y &lt; y) <br>            &amp;&amp; ((int)ptl.y &gt; y-(int)m_pPG-&gt;m_cy-rc.top)) <br>            y=(int)ptl.y; <br>        } <br> <br>    //Bounds check size of the object and fit to page as necessary. <br>    if (x+(int)szl.cx &gt; (int)(h+m_pPG-&gt;m_cx)) <br>        szl.cx=h+m_pPG-&gt;m_cx-x; <br> <br>    //Remember that szl we get from Create is absolute <br>    if (y-(int)szl.cy &lt; (int)(v-m_pPG-&gt;m_cy)) <br>        szl.cy=-(int)(v-m_pPG-&gt;m_cy-y); <br> <br>    SETRECTL(rcl, x, y, x+szl.cx, y-szl.cy); <br>    m_pTenantCur-&gt;RectSet(&amp;rcl, FALSE, TRUE); <br> <br>    //Force a repaint on this new guy <br>    m_pTenantCur-&gt;Invalidate(); <br>    UpdateWindow(m_hWnd); <br> <br>    m_pTenantCur-&gt;Select(TRUE, TRUE); <br> <br>    //Make sure this new tenant knows about showing it's type. <br>    m_pTenantCur-&gt;ShowObjectType(m_pPG-&gt;m_fShowTypes); <br> <br>    //New tenants must know the available monikers <br>    if (NULL!=m_pmkFile) <br>        { <br>        LPBC        pbc; <br>        LPMONIKER   pmkPage; <br>        TCHAR       szTemp[32]; <br>        LPTSTR      pszFile; <br> <br>       #ifdef WIN32ANSI <br>        OLECHAR     szW[32]; <br> <br>        GetStorageName(szW); <br>        WideCharToMultiByte(CP_ACP, 0, szW, -1, szTemp, 32 <br>           , NULL, NULL); <br>       #else <br>        GetStorageName(szTemp); <br>       #endif <br>        CreateItemMoniker(TEXT("!"), szTemp, &amp;pmkPage); <br> <br>        //We can get the filename from our file moniker <br>        CreateBindCtx(0, &amp;pbc); <br>       #ifdef WIN32ANSI <br>        LPOLESTR    pszTemp; <br>        m_pmkFile-&gt;GetDisplayName(pbc, NULL, &amp;pszTemp); <br>        pszFile=(LPTSTR)CoTaskMemAlloc(512); <br>        WideCharToMultiByte(CP_ACP, 0, pszTemp, -1, pszFile <br>           , 512, NULL, NULL); <br>        CoTaskMemFree((void *)pszTemp); <br>       #else <br>        m_pmkFile-&gt;GetDisplayName(pbc, NULL, &amp;pszFile); <br>       #endif <br>        pbc-&gt;Release(); <br> <br>        pTenant-&gt;NotifyOfRename(pszFile, m_pmkFile, pmkPage); <br>        pmkPage-&gt;Release(); <br>        CoTaskMemFree((void *)pszFile); <br>        } <br> <br>    //Activate new objects immediately and force a save on them <br>    if (TENANTTYPE_EMBEDDEDOBJECT==tType) <br>        { <br>        //CHAPTER24MOD <br>        DWORD       dwFlags; <br> <br>        /* <br>         * A control, by virtue of being a control, will already <br>         * be in-place active except in design mode.  In any case, <br>         * the only thing a control can do is draw on our page, <br>         * so there's little point in activating a control here. <br>         */ <br>        dwFlags=m_pTenantCur-&gt;GetControlFlags(); <br> <br>        if (!(TENANTSTATE_CONTROL &amp; dwFlags)) <br>            { <br>            m_pTenantCur-&gt;Activate(OLEIVERB_SHOW, NULL); <br>            m_pTenantCur-&gt;Update(); <br>            } <br>        //End CHAPTER24MOD <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantDestroy <br> * <br> * Purpose: <br> *  Destroys the currently selected tenant on this page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPage::TenantDestroy(void) <br>    { <br>    if (NULL==m_pTenantCur) <br>        { <br>        MessageBeep(0); <br>        return FALSE; <br>        } <br> <br>    SendMessage(m_hWndTenantList, LB_DELETESTRING <br>        , m_iTenantCur, 0L); <br> <br>    m_pTenantCur-&gt;Invalidate(); <br>    m_pTenantCur-&gt;Destroy(m_pIStorage); <br>    m_pTenantCur-&gt;Release(); <br>    m_pTenantCur=NULL; <br> <br>    //Update counts, etc., and select the next tenant in the list. <br>    if (m_iTenantCur==m_cTenants-1) <br>        m_iTenantCur--; <br> <br>    if (0==--m_cTenants) <br>        m_pTenantCur=NULL; <br>    else <br>        { <br>        TenantGet(m_iTenantCur, &amp;m_pTenantCur, TRUE); <br>        m_pTenantCur-&gt;Select(TRUE, TRUE); <br>        } <br> <br>    UpdateWindow(m_hWnd); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantClip <br> * <br> * Purpose: <br> *  Copies or cuts the currently selected tenant to the clipoard. <br> * <br> * Parameters: <br> *  fCut            BOOL TRUE to cut the object, FALSE to copy. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPage::TenantClip(BOOL fCut) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet=FALSE; <br> <br>    if (NULL==m_pTenantCur) <br>        return FALSE; <br> <br>    /* <br>     * To perform a data transfer operation, we need to create a <br>     * data object with the selected object's data inside. To do <br>     * this we CoCreateInstance on CLSID_DataTransferObject <br>     * (Also implemented in this chapter), retrieve data from the <br>     * object we have, stuff that data into the transfer object, <br>     * then stick that object on the clipboard. <br>     * <br>     * Since we'll want an identical object at other times, like for <br>     * drag-drop, we use a private function to actually create it. <br>     */ <br> <br>    pIDataObject=TransferObjectCreate(NULL); <br> <br>    if (NULL!=pIDataObject) <br>        { <br>        if (SUCCEEDED(OleSetClipboard(pIDataObject))) <br>            { <br>            if (fCut) <br>                TenantDestroy(); <br> <br>            fRet=TRUE; <br>            } <br> <br>        pIDataObject-&gt;Release(); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::FQueryObjectSelected <br> * <br> * Purpose: <br> *  Returns whether or not there is an object selected on this <br> *  page for Cut, Copy, Delete functions. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the Edit menu. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have an object, FALSE otherwise. <br> */ <br> <br>BOOL CPage::FQueryObjectSelected(HMENU hMenu) <br>    { <br>    HMENU       hMenuTemp; <br> <br>    /* <br>     * This will only be called on WM_INITMENUPOPUP, we'll also <br>     * use this function to create the Verb menu for this object. <br>     */ <br>    if (NULL!=m_pTenantCur) <br>        { <br>        m_pTenantCur-&gt;AddVerbMenu(hMenu, MENUPOS_OBJECT); <br>        return TRUE; <br>        } <br> <br>    OleUIAddVerbMenu(NULL, NULL, hMenu, MENUPOS_OBJECT <br>        , IDM_VERBMIN, IDM_VERBMAX, FALSE, 0, &amp;hMenuTemp); <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::ActivateObject <br> * <br> * Purpose: <br> *  Executes a verb on the currently selected object. <br> * <br> * Parameters: <br> *  iVerb           LONG of the selected verb. <br> *  pMSG            LPMSG that caused the invocation of the verb. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::ActivateObject(LONG iVerb, LPMSG pMSG) <br>    { <br>    if (NULL==m_pTenantCur) <br>        return; <br> <br>    m_pTenantCur-&gt;Activate(iVerb, pMSG); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::ShowObjectTypes <br> * <br> * Purpose: <br> *  Loops through all the tenants and tells each one to turn on or <br> *  off the Show Objects features. <br> * <br> * Parameters: <br> *  fShow           BOOL indicating to show the type or not. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::ShowObjectTypes(BOOL fShow) <br>    { <br>    PCTenant    pTenant; <br>    UINT        i; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            pTenant-&gt;ShowObjectType(fShow); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::NotifyTenantsOfRename <br> * <br> * Purpose: <br> *  Loops through all the tenants and informs each of the new <br> *  document name. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of the new filename. <br> *  pmk             LPMONKIER for the new filename. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::NotifyTenantsOfRename(LPTSTR pszFile, LPMONIKER pmk) <br>    { <br>    PCTenant    pTenant; <br>    UINT        i; <br>    LPMONIKER   pmkPage; <br>    LPMONIKER   pmkAll; <br>    TCHAR       szTemp[32]; <br> <br>    //Save the file moniker <br>    ReleaseInterface(m_pmkFile); <br>    m_pmkFile=pmk; <br>    m_pmkFile-&gt;AddRef(); <br> <br>    //Create a page moniker to send to the tenants. <br>   #ifdef WIN32ANSI <br>    OLECHAR     szW[32]; <br> <br>    GetStorageName(szW); <br>    WideCharToMultiByte(CP_ACP, 0, szW, -1, szTemp, 32 <br>       , NULL, NULL); <br>   #else <br>    GetStorageName(szTemp); <br>   #endif <br>    CreateItemMoniker(TEXT("!"), szTemp, &amp;pmkPage); <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            pTenant-&gt;NotifyOfRename(pszFile, pmk, pmkPage); <br>        } <br> <br>    /* <br>     * Register a File!Page!"\" wildcard moniker as well. <br>     * Note that the page is already marked as running <br>     * with the document's wildcard moniker. <br>     */ <br>    CreateItemMoniker(TEXT("!"), TEXT("\\"), &amp;pmkAll); <br> <br>    if (NULL!=pmkAll) <br>        { <br>        LPMONIKER   pmkWild=NULL; <br>        LPMONIKER   pmkTemp=NULL; <br> <br>        INOLE_RevokeAsRunning(&amp;m_dwRegROTWild); <br>        pmk-&gt;ComposeWith(pmkPage, FALSE, &amp;pmkTemp); <br> <br>        if (NULL!=pmkTemp) <br>            { <br>            pmkTemp-&gt;ComposeWith(pmkAll, FALSE, &amp;pmkWild); <br>            pmkTemp-&gt;Release(); <br>            } <br> <br>        if (NULL!=pmkWild) <br>            { <br>            INOLE_RegisterAsRunning(this, pmk, 0 <br>                , &amp;m_dwRegROTWild); <br>            pmkWild-&gt;Release(); <br>            } <br> <br>        pmkAll-&gt;Release(); <br>        } <br> <br>    //If anything held onto this, they AddRef'd <br>    pmkPage-&gt;Release(); <br>    return; <br>    } <br> <br> <br>/* <br> * CPage::ConvertObject <br> * <br> * Purpose: <br> *  Invokes and handles the results of the Convert dialog <br> * <br> * Parameters: <br> *  hWndFrame       HWND to use as the parent of the dialog. <br> *  fNoServer       BOOL indicating if this was called because <br> *                  ActivateObject failed. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPage::ConvertObject(HWND hWndFrame, BOOL fNoServer) <br>    { <br>    HRESULT         hr; <br>    OLEUICONVERT    ct; <br>    TENANTTYPE      tType; <br>    TENANTINFO      ti; <br>    UINT            uRet; <br>    HCURSOR         hCur; <br>    BOOL            fActivate=fNoServer; <br>    SIZEL           szl; <br> <br>    if (NULL==m_pTenantCur) <br>        return FALSE; <br> <br>    tType=m_pTenantCur-&gt;TypeGet(); <br> <br>    if (TENANTTYPE_STATIC==tType) <br>        { <br>        MessageBeep(0); <br>        return FALSE; <br>        } <br> <br>    //Get object information we may want. <br>    m_pTenantCur-&gt;GetInfo(&amp;ti); <br> <br>    //Fill the structure. <br>    memset(&amp;ct, 0, sizeof(ct)); <br>    ct.cbStruct=sizeof(OLEUICONVERT); <br>    ct.hWndOwner=hWndFrame; <br>    ct.fIsLinkedObject=(TENANTTYPE_LINKEDOBJECT==tType); <br>    ct.dvAspect=ti.fe.dwAspect; <br> <br>    m_pTenantCur-&gt;ObjectClassFormatAndIcon(&amp;ct.clsid, &amp;ct.wFormat </code></pre>
<p>
</p>
<pre><code>, &amp;ct.lpszUserType, &amp;ct.hMetaPict, &amp;ct.lpszDefLabel); <br> <br>    uRet=OleUIConvert(&amp;ct); <br> <br>    if (OLEUI_OK==uRet) <br>        { <br>        //Potentially a long operation. <br>        hCur=SetCursor(LoadCursor(NULL, IDC_WAIT)); <br> <br>        //Prevent multiple repaints. <br>        m_pTenantCur-&gt;EnableRepaint(FALSE); <br> <br>        //First, let's bother with the iconic aspect switch. <br>        if ((DVASPECT_ICON==ct.dvAspect &amp;&amp; ct.fObjectsIconChanged) <br>            || ct.dvAspect!=ti.fe.dwAspect) <br>            { <br>            HGLOBAL     hMem=NULL; <br> <br>            //Only pass non-NULL handle for icon aspects. <br>            if (DVASPECT_ICON==ct.dvAspect) <br>                hMem=ct.hMetaPict; <br> <br>            m_pPG-&gt;m_fDirty=m_pTenantCur-&gt;SwitchOrUpdateAspect(hMem <br>                , FALSE); <br>            } <br> <br>        //Now change types around. <br>        if ((CF_SELECTCONVERTTO &amp; ct.dwFlags) <br>            &amp;&amp; ct.clsid!=ct.clsidNew) <br>            { <br>            LPSTORAGE   pIStorage; <br> <br>            /* <br>             * User selected convert, so: <br>             *  1.  Unload the object (back to passive state) <br>             *  2.  Call INOLE_DoConvert, which calls WriteClassStg, <br>             *      WriteFmtUserTypeStg, and SetConvertStg. <br>             *  3.  Reload the object and force an update. <br>             */ <br> <br>            //This should be the only close necessary. <br>            m_pTenantCur-&gt;StorageGet(&amp;pIStorage); <br>            m_pTenantCur-&gt;Close(TRUE); <br> <br>            hr=INOLE_DoConvert(pIStorage, ct.clsidNew); <br> <br>            //Need to commit the new type and format <br>            pIStorage-&gt;Commit(STGC_DEFAULT); <br>            pIStorage-&gt;Release(); <br> <br>            if (SUCCEEDED(hr)) <br>                { <br>                LPUNKNOWN   pObj; <br>                LPOLEOBJECT pIOleObject; <br> <br>                //Reload and update. <br>                m_pTenantCur-&gt;Load(m_pIStorage, &amp;ti); <br> <br>                m_pTenantCur-&gt;ObjectGet(&amp;pObj); <br>                pObj-&gt;QueryInterface(IID_IOleObject <br>                    , (PPVOID)&amp;pIOleObject); <br>                pIOleObject-&gt;Update(); <br>                pIOleObject-&gt;Release(); <br>                pObj-&gt;Release(); <br>                } <br> <br>            m_pPG-&gt;m_fDirty=TRUE; <br>            } <br> <br> <br>        if (CF_SELECTACTIVATEAS &amp; ct.dwFlags) <br>            { <br>            /* <br>             * User selected Activate As, so: <br>             *  1.  Add the TreatAs entry in the registry <br>             *      through CoTreatAsClass <br>             *  2.  Unload all objects of the old CLSID that you <br>             *      have loaded. <br>             *  3.  Reload objects as desired <br>             *  4.  Activate the current object. <br>             */ <br> <br>            hr=CoTreatAsClass(ct.clsid, ct.clsidNew); <br> <br>            if (SUCCEEDED(hr)) <br>                { <br>                PCTenant    pTenant; <br>                UINT        i; <br> <br>                for (i=0; i &lt; m_cTenants; i++) <br>                    { <br>                    if (TenantGet(i, &amp;pTenant, FALSE)) <br>                        { <br>                        pTenant-&gt;GetInfo(&amp;ti); <br>                        pTenant-&gt;Close(FALSE); <br>                        pTenant-&gt;Load(m_pIStorage, &amp;ti); <br>                        } <br>                    } <br> <br>                fActivate=TRUE; <br>                } <br>            } <br> <br>        //These two steps insure the object knows of the size. <br>        m_pTenantCur-&gt;SizeGet(&amp;szl, FALSE); <br>        m_pTenantCur-&gt;SizeSet(&amp;szl, FALSE, TRUE); <br> <br>        m_pTenantCur-&gt;EnableRepaint(TRUE); <br>        m_pTenantCur-&gt;Repaint(); <br> <br>        if (fActivate) <br>            m_pTenantCur-&gt;Activate(OLEIVERB_SHOW, NULL); <br> <br>        SetCursor(hCur); <br>        } <br> <br>    CoTaskMemFree((void*)ct.lpszUserType); <br>    INOLE_MetafilePictIconFree(ct.hMetaPict); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FQueryLinksInPage <br> * <br> * Purpose: <br> *  Pass through to current page to see if there are any linked <br> *  objects. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPage::FQueryLinksInPage() <br>    { <br>    PCTenant    pTenant; <br>    UINT        i; <br>    BOOL        fRet=FALSE; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            fRet |= (pTenant-&gt;TypeGet()==TENANTTYPE_LINKEDOBJECT); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::ScrolledWindow <br> * <br> * Purpose: <br> *  Instructs the page to call CTenant::UpdateInPlaceObjectRects <br> *  for the current tenant when the window is scrolled. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::ScrolledWindow(void) <br>    { <br>    UINT        i; <br>    PCTenant    pTenant; <br> <br>    /* <br>     * Tell all tenants to update the position of in-place objects. <br>     * If you do not support inside-out, only the selected object <br>     * need be notified. <br>     */ <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (!TenantGet(i, &amp;pTenant, FALSE)) <br>            continue; <br> <br>        pTenant-&gt;UpdateInPlaceObjectRects(NULL, TRUE); <br>        } <br> <br>    return; <br>    } <br> <br> <br>/* <br> * CPage::SwitchActiveTenant <br> * <br> * Purpose: <br> *  Changes the activation of in-place objects from the current <br> *  one known to the page to the new one passed to this function. <br> *  This is called from IOleInPlaceSite::OnUIDeactivate. <br> * <br> * Parameters: <br> *  pTenant         PCTenant that is becoming active. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::SwitchActiveTenant(PCTenant pTenant) <br>    { <br>    BOOL        fSelect; <br> <br>    /* <br>     * If we're UI activating the selected tenant, don't <br>     * bother changing selection--just so activation. <br>     */ <br>    fSelect=(pTenant!=m_pTenantCur); <br> <br>    /* <br>     * The first time we UI Activate we're not switching <br>     * anything so avoid the whole sequence. <br>     */ <br>    if (m_fFirstUIActivate) <br>        { <br>        m_fFirstUIActivate=FALSE; <br>        return; <br>        } <br> <br>    if (NULL!=m_pTenantCur &amp;&amp; fSelect) <br>        m_pTenantCur-&gt;Select(FALSE, TRUE); <br> <br>    m_pTenantCur=pTenant; <br> <br>    //Select the new tenant, but don't activate it again <br>    if (NULL!=m_pTenantCur) <br>        { <br>        UINT        i; <br> <br>        if (fSelect) <br>            m_pTenantCur-&gt;Select(TRUE, FALSE); <br> <br>        //Find the new tenant in our list and move to the top <br>        for (i=0; i &lt; m_cTenants; i++) <br>            { <br>            PCTenant        pTenList; <br> <br>            if (TenantGet(i, &amp;pTenList, FALSE)) <br>                { <br>                if (pTenList==m_pTenantCur) <br>                    { <br>                    HWND        hWndObj; <br> <br>                    m_iTenantCur=0; <br> <br>                    //Remove the tenant and add to the top again. <br>                    SendMessage(m_hWndTenantList, LB_DELETESTRING <br>                        , i, 0L); <br>                    SendMessage(m_hWndTenantList, LB_INSERTSTRING <br>                        , 0, (LONG)pTenant); <br> <br>                    hWndObj=pTenant-&gt;ObjectWindow(); <br> <br>                    if (NULL!=hWndObj) <br>                        { <br>                        SetWindowPos(hWndObj, HWND_TOP, 0, 0, 0, 0 <br>                            , SWP_NOMOVE | SWP_NOSIZE <br>                            | SWP_NOACTIVATE); <br>                        } <br>                    break; <br>                    } <br>                } <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>//CHAPTER24MOD <br>/* <br> * CPage::ToggleDesignMode <br> * CPage::ToggleUIDead <br> * CPage::ToggleHatchHandles <br> * <br> * Purpose: <br> *  Loops through all the tenants and toggles a state. <br> */ <br> <br>void CPage::ToggleDesignMode(BOOL fDesign) <br>    { <br>    PCTenant    pTenant; <br>    int         i; <br> <br>    /* <br>     * We do this in reverse order such that when we reactivate <br>     * objects coming out of design mode we reactivate the <br>     * visible "top" tenant last, therefore it's in-place window <br>     * will be top of the z-order in the container and will overlap <br>     * other objects correctly. <br>     */ <br>    for (i=(int)m_cTenants-1; i &gt;=0; i--) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            pTenant-&gt;ToggleDesignMode(fDesign); <br>        } <br> <br>    return; <br>    } <br> <br> <br>void CPage::ToggleUIDead(BOOL fUIDead) <br>    { <br>    PCTenant    pTenant; <br>    UINT        i; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            pTenant-&gt;ToggleUIDead(fUIDead); <br>        } <br> <br>    return; <br>    } <br> <br> <br>void CPage::ToggleHatchHandles(BOOL fHatchHandles) <br>    { <br>    PCTenant    pTenant; <br>    UINT        i; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            pTenant-&gt;ToggleHatchHandles(fHatchHandles); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPage::FQueryEnableEvents <br> * <br> * Purpose: <br> *  Returns whether to enable events for the current tenant. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE to enable the item, FALSE otherwise. <br> */ <br> <br>BOOL CPage::FQueryEnableEvents(void) <br>    { <br>    DWORD   dwFlags; <br> <br>    if (NULL==m_pTenantCur) <br>        return FALSE; <br> <br>    dwFlags=m_pTenantCur-&gt;GetControlFlags(); <br>    return 0!=(TENANTSTATE_EVENTS &amp; dwFlags); <br>    } <br> <br> <br> <br>/* <br> * CPage::AssignEvents <br> * <br> * Purpose: <br> *  Invokes a dialog in which the user can assign actions to <br> *  control events. <br> * <br> * Parameters: <br> *  hWndParent      HWND to use as the dialog parent. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::AssignEvents(HWND hWndParent) <br>    { <br>    DialogBoxParam(m_pPG-&gt;m_hInst, MAKEINTRESOURCE(IDD_EVENTS) <br>        , hWndParent, EventsDlgProc <br>        , (LONG)m_pTenantCur-&gt;EventMap()); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::TryMnemonic <br> * <br> * Purpose: <br> *  Loops through all the tenants checking each for a match <br> *  with a keybord mnemonic. <br> * <br> * Parameters: <br> *  pMsg            LPMSG containing the message to check. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the mnemonic was a match with any <br> *                  tenant, FALSE otherwise. <br> */ <br> <br>BOOL CPage::TryMnemonic(LPMSG pMsg) <br>    { <br>    BOOL    fRet=FALSE; <br>    UINT    i; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        PCTenant    pTenant; <br> <br>        if (TenantGet(i, &amp;pTenant, FALSE)) <br>            { <br>            fRet=pTenant-&gt;TryMnemonic(pMsg); <br> <br>            if (fRet) <br>                break; <br>            } <br>        else <br>            break; <br>        } <br> <br>    return fRet; <br>    } <br>//End CHAPTER24MOD <br> <br> <br> <br> <br>/* <br> * CPage::TenantGet <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a tenant of a given index returning a BOOL so it's <br> *  simple to use this function inside if statements. <br> * <br> * Parameters: <br> *  iTenant         UINT tenant to retrieve 0 based. <br> *  ppTenant        PCPage * in which to return the tenant <br> *                  pointer <br> *  fOpen           BOOL indicating if we should open this <br> *                  tenant as well. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPage::TenantGet(UINT iTenant, PCTenant *ppTenant <br>    , BOOL fOpen) <br>    { <br>    if (NULL==ppTenant) <br>        return FALSE; <br> <br>    if (LB_ERR!=SendMessage(m_hWndTenantList, LB_GETTEXT <br>        , iTenant, (LONG)ppTenant)) <br>        { <br>        if (fOpen) <br>            (*ppTenant)-&gt;Open(m_pIStorage); <br> <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantGetFromID <br> * (Protected) <br> * <br> * Purpose: <br> *  Finds a tenant pointer from an ID for use from <br> *  IOleItemContainer::GetObject <br> * <br> * Parameters: <br> *  dwID            DWORD identifier of the tenant to find. <br> *  ppTenant        PCTenant * in which to return the tenant <br> *                  pointer <br> *  fOpen           BOOL indicating if we should open this tenant as <br> *                  well. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPage::TenantGetFromID(DWORD dwID, PCTenant *ppTenant <br>    , BOOL fOpen) <br>    { <br>    UINT        i; <br>    PCTenant    pTenant; <br> <br>    if (NULL==ppTenant) <br>        return FALSE; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (!TenantGet(i, &amp;pTenant, FALSE)) <br>            continue; <br> <br>        if (pTenant-&gt;GetID()==dwID) <br>            { <br>            if (fOpen) <br>                pTenant-&gt;Open(m_pIStorage); <br> <br>            *ppTenant=pTenant; <br>            return TRUE; <br>            } <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantAdd <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new tenant initialized to the given values.  The new <br> *  tenants's storage is created if it does not already exist.  If <br> *  fOpenStorage is set the the tenants's storage is opened and left <br> *  opened. <br> * <br> * Parameters: <br> *  iTenant         UINT Location at which to insert tenant; new <br> *                  tenant is inserted after this position.  NOVALUE <br> *                  for the end. <br> *  dwID            DWORD ID for this tenant. <br> *  ppNew           PCTenant * in which to store the new tenant. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPage::TenantAdd(UINT iTenant, DWORD dwID <br>    , PCTenant *ppNew) <br>    { <br>    PCTenant    pTenant; <br>    LRESULT     lr; <br> <br>    if (NULL!=ppNew) <br>        *ppNew=NULL; <br> <br>    pTenant=new CTenant(dwID, m_hWnd, m_pPG); <br> <br>    if (NULL==pTenant) <br>        return FALSE; <br> <br>    //The constructor doesn't AddRef, so we need to. <br>    pTenant-&gt;AddRef(); <br> <br>    //Now try to add to the listbox. <br>    lr=SendMessage(m_hWndTenantList, LB_INSERTSTRING, iTenant <br>        , (LONG)pTenant); <br> <br>    if (lr &lt; 0) <br>        { <br>        pTenant-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    *ppNew=pTenant; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::TransferObjectCreate <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a DataTransferObject and stuff the current selection's <br> *  data into it. <br> * <br> * Parameters: <br> *  pptl            PPOINTL containing the pick point in device <br> *                  units applicable only to drag-drop; since <br> *                  drag-drop is inherently mouse oriented, we use <br> *                  device units for the point.  Ignored if NULL. <br> * <br> * Return Value: <br> *  LPDATAOBJECT    Pointer to the object created, NULL on failure <br> */ <br> <br>LPDATAOBJECT CPage::TransferObjectCreate(PPOINTL pptl) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    LPDATAOBJECT    pIDataT; <br>    PPATRONOBJECT   ppo; <br>    RECTL           rcl; <br>    LPUNKNOWN       pObj; <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br>    HRESULT         hr; <br>    HGLOBAL         hMem; <br> <br>    m_pTenantCur-&gt;ObjectGet(&amp;pObj); <br> <br>    hr=CoCreateInstance(CLSID_DataTransferObject, NULL <br>        , CLSCTX_INPROC_SERVER, IID_IDataObject <br>        , (PPVOID)&amp;pIDataObject); <br> <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    //Go get the data we should hold on to. <br>    hr=pObj-&gt;QueryInterface(IID_IDataObject, (PPVOID)&amp;pIDataT); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIDataObject-&gt;Release(); <br>        pObj-&gt;Release(); <br>        return NULL; <br>        } <br> <br>    //Copy from known obj into transfer obj.  Ordering is important! <br> <br>    //Generate placeable object structure <br>    stm.tymed=TYMED_HGLOBAL; <br>    stm.pUnkForRelease=NULL; <br>    stm.hGlobal=GlobalAlloc(GHND, sizeof(PATRONOBJECT)); <br> <br>    if (NULL==stm.hGlobal) <br>        { <br>        pIDataObject-&gt;Release(); <br>        pObj-&gt;Release(); <br>        return NULL; <br>        } <br> <br>    ppo=(PPATRONOBJECT)GlobalLock(stm.hGlobal); <br> <br>    m_pTenantCur-&gt;SizeGet(&amp;ppo-&gt;szl, FALSE); <br>    ppo-&gt;szl.cy=-ppo-&gt;szl.cy; //Negate to make absolute size <br> <br>    m_pTenantCur-&gt;RectGet(&amp;rcl, FALSE); <br>    ppo-&gt;ptl.x=rcl.left; <br>    ppo-&gt;ptl.y=rcl.top; <br> <br>    if (NULL==pptl) <br>        { <br>        ppo-&gt;ptlPick.x=0; <br>        ppo-&gt;ptlPick.y=0; <br>        } <br>    else <br>        ppo-&gt;ptlPick=*pptl; <br> <br>    m_pTenantCur-&gt;FormatEtcGet(&amp;ppo-&gt;fe, FALSE); <br> <br>    //If this is a linked object, just copy a presentation <br>    if (TENANTTYPE_LINKEDOBJECT==m_pTenantCur-&gt;TypeGet()) <br>        m_pTenantCur-&gt;FormatEtcGet(&amp;ppo-&gt;fe, TRUE); <br> <br>    SETDefFormatEtc(fe, m_pPG-&gt;m_cf, TYMED_HGLOBAL); <br>    pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br> <br>    /* <br>     * Here now we have to include CFSTR_EMBEDDEDOBJECT and <br>     * CFSTR_OBJECTDESCRIPTOR when what we have selected is, in <br>     * fact, a compound document object.  We'll just ask the tenant <br>     * to set these in pIDataObject since it knows what the object. <br>     * If we copy embedded object data, make sure the PATRONOBJECT <br>     * structure has the right format in it as well. <br>     */ <br>    m_pTenantCur-&gt;CopyEmbeddedObject(pIDataObject, &amp;ppo-&gt;fe, pptl); <br>    hMem=stm.hGlobal; <br> <br>    //Copy the actual presentation. <br>    m_pTenantCur-&gt;FormatEtcGet(&amp;fe, TRUE); <br>    pIDataT-&gt;GetData(&amp;fe, &amp;stm); <br>    pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br> <br>    //Copy a link to this tenant if it's embedded <br>    m_pTenantCur-&gt;CopyLinkedObject(pIDataObject, &amp;ppo-&gt;fe, pptl); <br>    GlobalUnlock(hMem); //ppo <br> <br>    pIDataT-&gt;Release(); <br>    pObj-&gt;Release(); <br>    return pIDataObject;    //Caller now responsible <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
