<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1051"></a>POLYPROP.CPP</h2>
<pre><code>/* <br> * POLYPROP.CPP <br> * Polyline Property Page Chapter 24 <br> * <br> * Server module code and class code CPolyPropertyPage class. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "polyprop.h" <br> <br> <br>//Count number of objects and number of locks. <br>ULONG       g_cObj=0; <br>ULONG       g_cLock=0; <br>HINSTANCE   g_hInst=NULL;   //For resources <br> <br>#ifdef WIN32 <br>TCHAR       g_szObj[]=TEXT("Object"); <br>#else <br>TCHAR       g_szObjHi[]=TEXT("ObjectHi"); <br>TCHAR       g_szObjLo[]=TEXT("ObjectLo"); <br>#endif <br> <br>/* <br> * LibMain(32) <br> * <br> * Purpose: <br> *  Entry point conditionally compiled for Win32 and Windows <br> *  3.1.  Provides the proper structure for each environment. <br> */ <br> <br>#ifdef WIN32 <br>BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason <br>    , LPVOID pvReserved) <br>    { <br>    g_hInst=hInstance; <br> <br>    if (DLL_PROCESS_DETACH==ulReason) <br>        { <br>        return TRUE; <br>        } <br>    else <br>        { <br>        if (DLL_PROCESS_ATTACH!=ulReason) <br>            return TRUE; <br>        } <br> <br>    return TRUE; <br>    } <br>#else <br>int PASCAL LibMain(HINSTANCE hInstance, WORD wDataSeg <br>    , WORD cbHeapSize, LPSTR lpCmdLine) <br>    { <br>    if (0!=cbHeapSize) <br>        UnlockData(0); <br> <br>    g_hInst=hInstance; <br>    return (int)hInstance; <br>    } <br>#endif <br> <br> <br> <br>/* <br> * DllGetClassObject <br> * DllCanUnloadNow <br> * Standard COM exports for DLL servers. <br> */ <br> <br>HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid <br>    , PPVOID ppv) <br>    { <br>    CPolyPPFactory *pPF; <br>    HRESULT         hr; <br> <br>    if (CLSID_PolylinePropPage!=rclsid) <br>        return ResultFromScode(E_FAIL); <br> <br>    //Check that we can provide the interface <br>    if (IID_IUnknown!=riid &amp;&amp; IID_IClassFactory!=riid) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    //Return our factory's IClassFactory <br>    pPF=new CPolyPPFactory(); <br> <br>    if (NULL==pPF) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //If the factory hasn't the interface, delete it <br>    hr=pPF-&gt;QueryInterface(riid, ppv); <br> <br>    if (FAILED(hr)) <br>        delete pPF; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br>STDAPI DllCanUnloadNow(void) <br>    { <br>    SCODE   sc; <br> <br>    //Our answer is whether there are any object or locks <br>    sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE; <br>    return ResultFromScode(sc); <br>    } <br> <br> <br> <br>/* <br> * CPolyPPFactory::CPolyPPFactory <br> * CPolyPPFactory::~CPolyPPFactory <br> * CPolyPPFactory::QueryInterface <br> * CPolyPPFactory::AddRef <br> * CPolyPPFactory::Release <br> */ <br> <br>CPolyPPFactory::CPolyPPFactory(void) <br>    { <br>    m_cRef=0L; <br>    return; <br>    } <br> <br>CPolyPPFactory::~CPolyPPFactory(void) <br>    { <br>    return; <br>    } <br> <br>STDMETHODIMP CPolyPPFactory::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IClassFactory==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyPPFactory::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyPPFactory::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    g_cObj--; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CPolyPPFactory::CreateInstance <br> * CPolyPPFactory::LockServer <br> */ <br> <br>STDMETHODIMP CPolyPPFactory::CreateInstance(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    PCPolyPropPage      pObj; <br>    HRESULT             hr; <br> <br>    *ppvObj=NULL; <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    //No aggregation supported <br>    if (NULL!=pUnkOuter) <br>        return ResultFromScode(CLASS_E_NOAGGREGATION); <br> <br>    //Create the object passing function to notify on destruction. <br>    pObj=new CPolyPropPage(g_hInst); <br> <br>    if (NULL==pObj) <br>        return hr; <br> <br>    if (pObj-&gt;Init()) <br>        hr=pObj-&gt;QueryInterface(riid, ppvObj); <br> <br>    //Kill the object if initial creation or Init failed. <br>    if (FAILED(hr)) <br>        delete pObj; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br>STDMETHODIMP CPolyPPFactory::LockServer(BOOL fLock) <br>    { <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        g_cLock--; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/*** <br> *** CPolyPropPage implementation <br> ***/ <br> <br> <br>/* <br> * CPolyPropPage::CPolyPropPage <br> * CPolyPropPage::~CPolyPropPage <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the module <br> */ <br> <br>CPolyPropPage::CPolyPropPage(HINSTANCE hInst) <br>    { <br>    m_cRef=0L; <br> <br>    m_hInst=hInst; <br>    m_hDlg=NULL; <br> <br>    //Default sizes <br>    m_cx=300; <br>    m_cy=100; <br> <br>    m_pIPropertyPageSite=NULL; <br>    m_ppObj=NULL; <br>    m_cObjects=0; <br> <br>    m_uIDLastLine=ID_LINESOLID; <br>    m_crLastBack=0; <br>    m_crLastLine=0; <br> <br>    m_fDirty=FALSE; <br>    return; <br>    } <br> <br>CPolyPropPage::~CPolyPropPage(void) <br>    { <br>    if (NULL!=m_hDlg) <br>        DestroyWindow(m_hDlg); <br> <br>    FreeAllObjects(); <br>    ReleaseInterface(m_pIPropertyPageSite); <br>    return; <br>    } <br> <br> <br>/* <br> * CPolyPropPage::QueryInterface <br> * CPolyPropPage::AddRef <br> * CPolyPropPage::Release <br> */ <br> <br>STDMETHODIMP CPolyPropPage::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IPropertyPage==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyPropPage::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyPropPage::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    g_cObj--; <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyPropPage::Init <br> * <br> * Purpose: <br> *  Performs initialization operations that might fail. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization successful, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CPolyPropPage::Init(void) <br>    { <br>    //Nothing to do <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyPropPage::FreeAllObjects <br> * <br> * Purpose: <br> *  Releases all the objects from IPropertyPage::SetObjects <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>void CPolyPropPage::FreeAllObjects(void) <br>    { <br>    UINT        i; <br> <br>    if (NULL==m_ppObj) <br>        return; <br> <br>    for (i=0; i &lt; m_cObjects; i++) <br>        ReleaseInterface(m_ppObj[i]); <br> <br>    delete [] m_ppObj; <br>    m_ppObj=NULL; <br>    m_cObjects=0; <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::SetPageSite <br> * <br> * Purpose: <br> *  Provides the property page with the IPropertyPageSite <br> *  that contains it.  SetPageSite(NULL) will be called as <br> *  part of the close sequence. <br> * <br> * Parameters: <br> *  pPageSite       LPPROPERTYPAGESITE pointer to the site. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::SetPageSite <br>    (LPPROPERTYPAGESITE pPageSite) <br>    { <br>    if (NULL==pPageSite) <br>        ReleaseInterface(m_pIPropertyPageSite) <br>    else <br>        { <br>        HWND        hDlg; <br>        RECT        rc; <br> <br>        m_pIPropertyPageSite=pPageSite; <br>        m_pIPropertyPageSite-&gt;AddRef(); <br> <br>        //We ignore locales <br> <br>        /* <br>         * Load the dialog and determine the size it will be to <br>         * return through GetPageSize.  We just create the dialog <br>         * here and destroy it again to retrieve the size, <br>         * leaving Activate to create it for real. <br>         */ <br>        hDlg=CreateDialogParam(m_hInst <br>            , MAKEINTRESOURCE(IDD_POLYLINEPROPS), GetDesktopWindow() <br>            , (DLGPROC)PolyPropPageProc, 0L); <br> <br>        //If creation fails, use default values set in constructor <br>        if (NULL!=hDlg) <br>            { <br>            GetWindowRect(hDlg, &amp;rc); <br>            m_cx=rc.right-rc.left; <br>            m_cy=rc.bottom-rc.top; <br> <br>            DestroyWindow(hDlg); <br>            } <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::Activate <br> * <br> * Purpose: <br> *  Instructs the property page to create a window in which to <br> *  display its contents, using the given parent window and <br> *  rectangle.  The window should be initially visible. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent window. <br> *  prc             LPCRECT of the rectangle to use. <br> *  fModal          BOOL indicating whether the frame is modal. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Activate(HWND hWndParent <br>    , LPCRECT prc, BOOL fModal) <br>    { <br>    if (NULL!=m_hDlg) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    m_hDlg=CreateDialogParam(m_hInst <br>        , MAKEINTRESOURCE(IDD_POLYLINEPROPS) <br>        , hWndParent, PolyPropPageProc, (LPARAM)this); <br> <br>    if (NULL==m_hDlg) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //Move the page into position and show it. <br>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top <br>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0); <br> <br>return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::Deactivate <br> * <br> * Purpose: <br> *  Instructs the property page to destroy its window that was <br> *  created in Activate. <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Deactivate(void) <br>    { <br>    if (NULL==m_hDlg) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    DestroyWindow(m_hDlg); <br>    m_hDlg=NULL; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::GetPageInfo <br> * <br> * Purpose: <br> *  Fills a PROPPAGEINFO structure describing the page's size, <br> *  contents, and help information. <br> * <br> * Parameters: <br> *  pPageInfo       LPPROPPAGEINFO to the structure to fill. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::GetPageInfo(LPPROPPAGEINFO pPageInfo) <br>    { <br>    IMalloc     *pIMalloc; <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        return ResultFromScode(E_FAIL); <br> <br>    pPageInfo-&gt;pszTitle=(LPOLESTR)pIMalloc-&gt;Alloc(80*sizeof(TCHAR)); <br> <br>    if (NULL!=pPageInfo-&gt;pszTitle) <br>       #ifdef WIN32ANSI <br>        wcscpy(pPageInfo-&gt;pszTitle, OLETEXT("General")); <br>       #else <br>        lstrcpy(pPageInfo-&gt;pszTitle, TEXT("General")); <br>       #endif <br> <br>    pIMalloc-&gt;Release(); <br> <br>pPageInfo-&gt;size.cx      = m_cx; <br>    pPageInfo-&gt;size.cy      = m_cy; <br>pPageInfo-&gt;pszDocString = NULL; <br>pPageInfo-&gt;pszHelpFile  = NULL; <br>pPageInfo-&gt;dwHelpContext= 0; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::SetObjects <br> * <br> * Purpose: <br> *  Identifies the objects that are being affected by this property <br> *  page (and all other pages in the frame).  These are the object <br> *  to which to send new property values in the Apply member. <br> * <br> * Parameters: <br> *  cObjects        ULONG number of objects <br> *  ppUnk           IUnknown ** to the array of objects being <br> *                  passed to the page. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::SetObjects(ULONG cObjects <br>    , IUnknown **ppUnk) <br>    { <br>    BOOL        fRet=TRUE; <br> <br>    FreeAllObjects(); <br> <br>    if (0!=cObjects) <br>        { <br>        UINT        i; <br>        HRESULT     hr; <br> <br>        m_ppObj=new IPolylineControl * [(UINT)cObjects]; <br> <br>    for (i=0; i &lt; cObjects; i++) <br>        { <br>            hr=ppUnk[i]-&gt;QueryInterface(IID_IPolylineControl <br>                , (void **)&amp;m_ppObj[i]); <br> <br>            if (FAILED(hr)) <br>                fRet=FALSE; <br>        } <br>    } <br> <br>    //If we didn't get one of our objects, fail this call. <br>    if (!fRet) <br>        return ResultFromScode(E_FAIL); <br> <br>    m_cObjects=cObjects; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::Show <br> * <br> * Purpose: <br> *  Instructs the page to show or hide its window created in <br> *  Activate. <br> * <br> * Parameters: <br> *  nCmdShow        UINT to pass to ShowWindow. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Show(UINT nCmdShow) <br>    { <br>    if (NULL==m_hDlg) <br>        ResultFromScode(E_UNEXPECTED); <br> <br>    ShowWindow(m_hDlg, nCmdShow); <br> <br>    //Take the focus <br>    if (SW_SHOWNORMAL==nCmdShow || SW_SHOW==nCmdShow) <br>SetFocus(m_hDlg); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::Move <br> * <br> * Purpose: <br> *  Instructs the property page to change its position. <br> * <br> * Parameters: <br> *  prc             LPCRECT containing the new position. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Move(LPCRECT prc) <br>    { <br>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top <br>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::IsPageDirty <br> * <br> * Purpose: <br> *  Asks the page if anything's changed in it, that is, if the <br> *  property values in the page are out of sync with the objects <br> *  under consideration. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if dirty, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::IsPageDirty(void) <br>    { <br>    return ResultFromScode(m_fDirty ? S_OK : S_FALSE); <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyPropPage::Apply <br> * <br> * Purpose: <br> *  Instructs the page to send changes in its page to whatever <br> *  objects it knows about through SetObjects.  This is the only <br> *  time the page should change the objects' properties, and not <br> *  when the value is changed on the page. <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Apply(void) <br>    { <br>    UINT        i; <br>    UINT        iLine, iLineNew; <br>    COLORREF    crNew; <br>    BOOL        fChanged; <br> <br>    if (0==m_cObjects) <br>        return NOERROR; <br> <br>    /* <br>     * The dialog's last known line selection is in m_uIDLastLine, <br>     * colors in m_crLastBack and m_crLastLine, so we can just <br>     * send these to IPolylineControl member functions. <br>     * We the test if the change took place to determine whether <br>     * we set our dirty flag. <br>     */ <br> <br>    iLine=m_uIDLastLine-ID_LINEMIN; <br>    fChanged=FALSE; <br> <br>    for (i=0; i &lt; m_cObjects; i++) <br>        { <br>        m_ppObj[i]-&gt;put_LineStyle(iLine); <br>        iLineNew=m_ppObj[i]-&gt;get_LineStyle(); <br> <br>        fChanged |= (iLine!=iLineNew); <br> <br>        m_ppObj[i]-&gt;put_BackColor(m_crLastBack); <br>        crNew=m_ppObj[i]-&gt;get_BackColor(); <br> <br>        fChanged |= (m_crLastBack!=crNew); <br> <br>        m_ppObj[i]-&gt;put_LineColor(m_crLastLine); <br>        crNew=m_ppObj[i]-&gt;get_LineColor(); <br> <br>        fChanged |= (m_crLastLine!=crNew); <br>        } <br> <br>    m_fDirty=!fChanged; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyPropPage::Help <br> * <br> * Purpose: <br> *  Invokes help for this property page when the user presses <br> *  the Help button.  If you return NULLs for the help file <br> *  in GetPageInfo, the button will be grayed.  Otherwise the <br> *  page can perform its own help here. <br> * <br> * Parameters: <br> *  pszHelpDir      LPCOLESTR identifying the default location of <br> *                  the help information <br> * <br> * Return Value: <br> *  HRESULT         NOERROR to tell the frame that we've done our <br> *                  own help.  Returning an error code or S_FALSE <br> *                  causes the frame to use any help information <br> *                  in PROPPAGEINFO. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::Help(LPCOLESTR pszHelpDir) <br>    { <br>    /* <br>     * We can either provide help ourselves, or rely on the <br>     * information in PROPPAGEINFO. <br>     */ <br>    return ResultFromScode(S_FALSE); <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyPropPage::TranslateAccelerator <br> * <br> * Purpose: <br> *  Provides the page with the messages that occur in the frame. <br> *  This gives the page to do whatever it wants with the message, <br> *  such as handle keyboard mnemonics. <br> * <br> * Parameters: <br> *  pMsg            LPMSG containing the keyboard message. <br> */ <br> <br>STDMETHODIMP CPolyPropPage::TranslateAccelerator(LPMSG lpMsg) <br>    { <br>    //No keyboard interface supported here <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * PolyPropPageProc <br> * <br> * Purpose: <br> *  Dialog procedure for the Polyline Property Page. <br> */ <br> <br>BOOL APIENTRY PolyPropPageProc(HWND hDlg, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCPolyPropPage      pObj; <br>    WORD                wID; <br>    UINT                i; <br>    COLORREF            rgColors[16]; <br>    CHOOSECOLOR         cc; <br> <br>   #ifdef WIN32 <br>    pObj=(PCPolyPropPage)(ULONG)GetProp(hDlg, g_szObj); <br>   #else <br>    pObj=(PCPolyPropPage)MAKELONG((WORD)GetProp(hDlg, g_szObjLo) <br>       , (WORD)GetProp(hDlg, g_szObjHi)); <br>   #endif <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            pObj=(PCPolyPropPage)(ULONG)lParam; <br>           #ifdef WIN32 <br>            SetProp(hDlg, g_szObj, (HANDLE)lParam); <br>           #else <br>            SetProp(hDlg, g_szObjHi, (HANDLE)HIWORD(lParam)); <br>            SetProp(hDlg, g_szObjLo, (HANDLE)LOWORD(lParam)); <br>           #endif <br> <br>            if (NULL==pObj) <br>                return TRUE; <br> <br>            /* <br>             * If we have one object then we can try to set the <br>             * right field in the dialog box.  Otherwise we could <br>             * ask for the value from all of the objects and see <br>             * if they all match. <br>             */ <br>            if (1==pObj-&gt;m_cObjects) <br>                { <br>                UINT        iLine; <br> <br>                iLine=pObj-&gt;m_ppObj[0]-&gt;get_LineStyle(); <br> <br>                CheckRadioButton(hDlg, ID_LINESOLID <br>                    , ID_LINEDASHDOTDOT, iLine+ID_LINEMIN); <br> <br>                SetFocus(GetDlgItem(hDlg, iLine+ID_LINEMIN)); <br> <br>                pObj-&gt;m_uIDLastLine=iLine; <br> <br>                pObj-&gt;m_crLastBack=pObj-&gt;m_ppObj[0]-&gt;get_BackColor(); <br>                pObj-&gt;m_crLastLine=pObj-&gt;m_ppObj[0]-&gt;get_LineColor(); <br>                } <br> <br>            return FALSE; <br> <br>        case WM_DESTROY: <br>           #ifdef WIN32 <br>            RemoveProp(hDlg, g_szObj); <br>           #else <br>            RemoveProp(hDlg, g_szObjHi); <br>            RemoveProp(hDlg, g_szObjLo); <br>           #endif <br>            return FALSE; <br> <br>        case WM_COMMAND: <br>            wID=LOWORD(wParam); <br> <br>            switch (wID) <br>                { <br>                case ID_LINESOLID: <br>                case ID_LINEDASH: <br>                case ID_LINEDOT: <br>                case ID_LINEDASHDOT: <br>                case ID_LINEDASHDOTDOT: <br>                    if (NULL==pObj) <br>                        break; <br> <br>                    //Selecting the same one doesn't dirty <br>                    if (pObj-&gt;m_uIDLastLine==wID) <br>                        break; <br> <br>                    //Save the most recently selected <br>                    pObj-&gt;m_uIDLastLine=LOWORD(wParam); <br>                    pObj-&gt;m_fDirty=TRUE; <br> <br>                    if (NULL!=pObj-&gt;m_pIPropertyPageSite) <br>                        { <br>                        pObj-&gt;m_pIPropertyPageSite <br>                            -&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>                        } <br> <br>                    break; <br> <br> <br>                case ID_COLORLINE: <br>                case ID_COLORBACK: <br>                    if (NULL==pObj) <br>                        break; <br> <br>                    for (i=0; i&lt;16; i++) <br>                        rgColors[i]=RGB(0, 0, i*16); <br> <br>                    memset(&amp;cc, 0, sizeof(CHOOSECOLOR)); <br>                    cc.lStructSize=sizeof(CHOOSECOLOR); <br>                    cc.lpCustColors=rgColors; <br>                    cc.hwndOwner=GetParent(hDlg); <br>                    cc.Flags=CC_RGBINIT; <br>                    cc.rgbResult=(ID_COLORBACK==wID) <br>                        ? pObj-&gt;m_crLastBack <br>                        : pObj-&gt;m_crLastLine; <br> <br>                    if (ChooseColor(&amp;cc)) <br>                        { <br>                        COLORREF    cr; <br>                        ; <br>                        if (ID_COLORBACK==wID) <br>                            { <br>                            cr=pObj-&gt;m_crLastBack; <br>                            pObj-&gt;m_crLastBack=cc.rgbResult; <br>                            } <br>                        else <br>                            { <br>                            cr=pObj-&gt;m_crLastLine; <br>                            pObj-&gt;m_crLastLine=cc.rgbResult; <br>                            } <br> <br>                        pObj-&gt;m_fDirty=(cr!=cc.rgbResult); <br> <br>                        if (pObj-&gt;m_fDirty <br>                            &amp;&amp; NULL!=pObj-&gt;m_pIPropertyPageSite) <br>                            { <br>                            pObj-&gt;m_pIPropertyPageSite <br>                                -&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>                            } <br>                        } <br>                    break; <br> <br>                } <br>            break; <br>        } <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
