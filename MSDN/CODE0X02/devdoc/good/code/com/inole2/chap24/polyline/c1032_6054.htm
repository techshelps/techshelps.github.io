<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1048"></a>POLYWIN.CPP</h2>
<pre><code>/* <br> * POLYWIN.CPP <br> * Polyline Component Chapter 24 <br> * <br> * Window procedure for the polyline drawing window and support <br> * functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * PolylineWndProc <br> * <br> * Purpose: <br> *  Window procedure for the polyline drawing window. <br> */ <br> <br>LRESULT APIENTRY PolylineWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCPolyline      ppl; <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    POINTS          pt; <br>    RECT            rc; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    ppl=(PCPolyline)GetWindowLong(hWnd, PLWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            ppl=(PCPolyline)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, PLWL_STRUCTURE, (LONG)ppl); <br>            ppl-&gt;m_hWnd=hWnd; <br>            break; <br> <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br>            GetClientRect(hWnd, &amp;rc); <br>            ppl-&gt;Draw(hDC, FALSE, TRUE, &amp;rc, NULL); <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br> <br>        case WM_LBUTTONDOWN: <br>            //CHAPTER24MOD <br>            //If the UI is dead, we ignore all mouse clicks. <br>            if (ppl-&gt;m_fUIDead) <br>                break; <br>            //End CHAPTER24MOD <br> <br>            //We become UI Active with mouse action <br>            if (!ppl-&gt;m_fUIActive &amp;&amp; NULL!=ppl-&gt;m_pIOleIPSite) <br>                ppl-&gt;UIActivate(); <br> <br>            //Stop if we are already at the limit. <br>            if (CPOLYLINEPOINTS==ppl-&gt;m_pl.cPoints) <br>                { <br>                MessageBeep(0); <br>                break; <br>                } <br> <br>            //Convert the points into 0-32767 range <br>            GetClientRect(hWnd, &amp;rc); <br>            pt=MAKEPOINTS(lParam); <br>            ppl-&gt;PointScale(&amp;rc, &amp;pt, FALSE); <br> <br>            ppl-&gt;m_pl.rgpt[ppl-&gt;m_pl.cPoints++]=pt; <br> <br>            //Draw the lines to this new point only. <br>            hDC=GetDC(hWnd); <br>            ppl-&gt;Draw(hDC, FALSE, FALSE, &amp;rc, NULL); <br>            ReleaseDC(hWnd, hDC); <br> <br>            if (NULL!=ppl-&gt;m_pAdv) <br>                ppl-&gt;m_pAdv-&gt;OnPointChange(); <br> <br>            ppl-&gt;SendAdvise(OBJECTCODE_DATACHANGED); <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            //CHAPTER24MOD <br>            //Ignore Open commands when we're UIDead <br>            if (ppl-&gt;m_fUIDead) <br>                break; <br>            //End CHAPTER24MOD <br> <br>            if (ID_HATCHWINDOW==wID <br>                &amp;&amp; HWN_BORDERDOUBLECLICKED==wCode) <br>                { <br>                ppl-&gt;m_pImpIOleObject-&gt;DoVerb(OLEIVERB_OPEN, NULL <br>                    , ppl-&gt;m_pIOleClientSite, -1, NULL, NULL); <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::Draw <br> * <br> * Purpose: <br> *  Paints the current line in the polyline window. <br> * <br> * Parameters: <br> *  hDC             HDC to draw on, a metafile or printer DC. <br> *  fMetafile       BOOL indicating if hDC is a metafile or not, <br> *                  so we can avoid operations that RIP. <br> *  fEntire         BOOL indicating if we should draw the entire <br> *                  figure or not. <br> *  pRect           LPRECT defining the bounds in which to draw. <br> *  ppl             PPOLYLINEDATA to draw.  If NULL, use current. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::Draw(HDC hDC, BOOL fMetafile, BOOL fEntire <br>    , LPRECT pRect, PPOLYLINEDATA ppl) <br>    { <br>    HBRUSH          hBrush; <br>    HPEN            hPen; <br>    HGDIOBJ         hObj1, hObj2; <br>    UINT            i, j; <br>    int             nDC; <br>    POINTS          pt1,pt2; <br>    POINT           rgpt[CPOLYLINEPOINTS]; <br> <br>    if (NULL==ppl) <br>        ppl=&amp;m_pl; <br> <br>    nDC=SaveDC(hDC); <br> <br>    for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>        { <br>        rgpt[i].x=ppl-&gt;rgpt[i].x; <br>        rgpt[i].y=ppl-&gt;rgpt[i].y; <br>        } <br> <br>    //Printer and frozen differences handled in IViewObject::Draw <br> <br>    hPen=CreatePen(ppl-&gt;iLineStyle, 1, ppl-&gt;rgbLine); <br>    hObj1=SelectObject(hDC, hPen); <br> <br>    hBrush=CreateSolidBrush(ppl-&gt;rgbBackground); <br>    hObj2=SelectObject(hDC, hBrush); <br>    SetBkColor(hDC, ppl-&gt;rgbBackground); <br> <br>    /* <br>     * Either draw the entire figure or just a single point.  The <br>     * entire figure also includes erasing the background completely, <br>     * since hDC may be a metafile DC.  Drawing a single point just <br>     * updates the figure for that new point. <br>     */ <br>    if (fEntire || 0==ppl-&gt;cPoints) <br>        { <br>        //Erase the background for bitmaps and metafiles. <br>        SelectObject(hDC, GetStockObject(NULL_PEN)); <br>        Rectangle(hDC, pRect-&gt;left, pRect-&gt;top, pRect-&gt;right+1 <br>            , pRect-&gt;bottom+1); <br>        SelectObject(hDC, hPen); <br> <br>        /* <br>         * If we are drawing the entire figure, then loop through <br>         * each point drawing a line to each successive point. <br>         */ <br> <br>        for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>            { <br>            for (j=i; j &lt; ppl-&gt;cPoints; j++) <br>                { <br>                pt1.x=(short)rgpt[i].x; <br>                pt1.y=(short)rgpt[i].y; <br>                pt2.x=(short)rgpt[j].x; <br>                pt2.y=(short)rgpt[j].y; <br> <br>                PointScale(pRect, &amp;pt1, TRUE); <br>                PointScale(pRect, &amp;pt2, TRUE); <br>                MoveToEx(hDC, pt1.x, pt1.y, NULL); <br>                LineTo(hDC, pt2.x, pt2.y); <br>                } <br>            } <br>        } <br>    else <br>        { <br>        /* <br>         * If we are only drawing the last point, just cycle once <br>         * through previous points. <br>         */ <br> <br>        //Get the last point entered in the array. <br>        j=ppl-&gt;cPoints-1; <br>        pt1.x=(short)rgpt[j].x; <br>        pt1.y=(short)rgpt[j].y; <br>        PointScale(pRect, &amp;pt1, TRUE); <br> <br>        for (i=0; i &lt; j; i++) <br>            { <br>            pt2.x=(short)rgpt[i].x; <br>            pt2.y=(short)rgpt[i].y; <br>            PointScale(pRect, &amp;pt2, TRUE); <br> <br>            MoveToEx(hDC, pt1.x, pt1.y, NULL); <br>            LineTo(hDC, pt2.x, pt2.y); <br>            } <br>        } <br> <br>    //If we have one point, draw a dot to indicate it's position. <br>    if (1==ppl-&gt;cPoints) <br>        { <br>        pt1.x=(short)rgpt[0].x; <br>        pt1.y=(short)rgpt[0].y; <br>        PointScale(pRect, &amp;pt1, TRUE); <br>        SetPixel(hDC, pt1.x, pt1.y, m_pl.rgbLine); <br>        } <br> <br>    SelectObject(hDC, hObj1); <br>    SelectObject(hDC, hObj2); <br>    DeleteObject(hBrush); <br>    DeleteObject(hPen); <br> <br>    RestoreDC(hDC, nDC); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::PointScale <br> * <br> * Purpose: <br> *  Scales a point to or from a relative window coordinate to a <br> *  0-32767 coordinate. <br> * <br> * Parameters: <br> *  pRect           LPRECT of the window. <br> *  ppt             LPPOINTS to convert <br> *  fScaleToWindow  BOOL indicating direction of scaling. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::PointScale(LPRECT pRect, LPPOINTS ppt <br>    , BOOL fScaleToWindow) <br>    { <br>    DWORD   cx, cy; <br> <br>    //Window size <br>    cx=(DWORD)(pRect-&gt;right-pRect-&gt;left); <br>    cy=(DWORD)(pRect-&gt;bottom-pRect-&gt;top); <br> <br>    //Prevent crashes <br>    if (0L==cx) cx=1; <br>    if (0L==cy) cy=1; <br> <br>    //Must use DWORD to insure proper scaling. <br> <br>    /* <br>     * As an in-proc server we may not have a rectangle where the <br>     * top left was (0,0) which was always true when we drew to <br>     * a Polyline window.  But this may be a container's hDC in <br>     * which case we'd better place the points in the container's <br>     * rectangle.  That is, we have to add/subtract pRect-&gt;left <br>     * and -&gt;top in these calculations. <br>     */ <br> <br>    if (fScaleToWindow) <br>        { <br>        ppt-&gt;x=pRect-&gt;left+(UINT)(((DWORD)ppt-&gt;x*cx) &gt;&gt; 15); <br>        ppt-&gt;y=pRect-&gt;top+(UINT)(((DWORD)ppt-&gt;y*cy)  &gt;&gt; 15); <br>        } <br>    else <br>        { <br>        ppt-&gt;x=(UINT)(((DWORD)(ppt-&gt;x - pRect-&gt;left) &lt;&lt; 15)/cx); <br>        ppt-&gt;y=(UINT)(((DWORD)(ppt-&gt;y - pRect-&gt;top)  &lt;&lt; 15)/cy); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * PolyDlgProc <br> * <br> * Purpose: <br> *  Dialog procedure for a window in which to display the Polyline <br> *  for editing.  This pretty much handles all editing functionality <br> *  for the embedded object. <br> */ <br> <br>BOOL APIENTRY PolyDlgProc(HWND hDlg, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCPolyline      ppl=NULL; <br>    RECT            rc; <br>    UINT            uID, uTemp; <br>    UINT            cx, cy; <br> <br>   #ifdef WIN32 <br>    ppl=(PCPolyline)GetProp(hDlg, PROP_POINTER); <br>   #else <br>    WORD            w1, w2; <br> <br>    w1=(WORD)GetProp(hDlg, PROP_SELECTOR); <br>    w2=(WORD)GetProp(hDlg, PROP_OFFSET); <br> <br>    ppl=(PCPolyline)MAKELP(w1, w2); <br>   #endif <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            ppl=(PCPolyline)lParam; <br>            ppl-&gt;m_hDlg=hDlg; <br> <br>           #ifdef WIN32 <br>            //Properties are 32-bits in Win32 <br>            SetProp(hDlg, PROP_POINTER, (HANDLE)ppl); <br>           #else <br>            SetProp(hDlg, PROP_SELECTOR, (HANDLE)SELECTOROF(ppl)); <br>            SetProp(hDlg, PROP_OFFSET,   (HANDLE)OFFSETOF(ppl)); <br>           #endif <br> <br>            //Get the rectangle that Polyline occupies <br>            CalcPolyRectInDialog(hDlg, &amp;rc); <br> <br>            //Try to create the window. <br>            ppl-&gt;m_pImpIPolyline-&gt;Init(hDlg, &amp;rc, WS_CHILD | WS_VISIBLE <br>                , ID_POLYLINE); <br> <br>            //Set the initial line style radiobutton. <br>            ppl-&gt;m_pImpIPolyline-&gt;LineStyleGet(&amp;uTemp); <br>            CheckRadioButton(hDlg, ID_LINESOLID, ID_LINEDASHDOTDOT <br>                , uTemp+ID_LINEMIN); <br> <br>            return FALSE; <br> <br> <br>        case WM_SHOWWINDOW: <br>            if (LOWORD(wParam)) <br>                { <br>                //Center the dialog on the screen <br>                cx=GetSystemMetrics(SM_CXSCREEN); <br>                cy=GetSystemMetrics(SM_CYSCREEN); <br>                GetWindowRect(hDlg, &amp;rc); <br>                SetWindowPos(hDlg, NULL, (cx-(rc.right-rc.left))/2 <br>                    , (cy-(rc.bottom-rc.top))/2, 0, 0, SWP_NOZORDER <br>                    | SWP_NOSIZE); <br> <br>                //We didn't SetFocus from WM_INITDIALOG.  Do it now. <br>                SetFocus(GetDlgItem(hDlg, IDOK)); <br>                } <br> <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            uID=LOWORD(wParam); <br> <br>            switch (uID) <br>                { <br>                case IDOK: <br>                    //Close the dialog, but save first. <br>                    if (NULL!=ppl) <br>                        { <br>                        HRESULT     hr; <br> <br>                        /* <br>                         * Instead of just closing, see if we can <br>                         * activate in-place again--we know we're an <br>                         * inside out object and want to be activated <br>                         * when we can be.  If we can't activate <br>                         * in-place, then close like we normally <br>                         * would.  Note that this makes sense only <br>                         * with an inside-out supporting container, <br>                         * which we determine from whether it ever <br>                         * used OLEIVERB_INPLACEACTIVATE. <br>                         */ <br> <br>                        hr=ResultFromScode(E_FAIL); <br> <br>                        if (ppl-&gt;m_fContainerKnowsInsideOut) <br>                            { <br>                            hr=ppl-&gt;InPlaceActivate <br>                                (ppl-&gt;m_pIOleClientSite, FALSE); <br>                            } <br> <br>                        if (FAILED(hr)) <br>                            { <br>                            ppl-&gt;m_pImpIOleObject-&gt;Close <br>                                (OLECLOSE_SAVEIFDIRTY); <br>                            } <br>                        } <br> <br>                    break; <br> <br>                case ID_UNDO: <br>                    if (NULL!=ppl) <br>                        ppl-&gt;m_pImpIPolyline-&gt;Undo(); <br>                    break; <br> <br>                case ID_COLORLINE: <br>                case ID_COLORBACK: <br>                    if (NULL!=ppl) <br>                        { <br>                        UINT            i; <br>                        COLORREF        rgColors[16]; <br>                        CHOOSECOLOR     cc; <br> <br>                        //Invoke the color chooser for either color <br>                        uTemp=(ID_COLORBACK==uID) <br>                            ? POLYLINECOLOR_BACKGROUND <br>                            : POLYLINECOLOR_LINE; <br> <br>                        for (i=0; i&lt;16; i++) <br>                            rgColors[i]=RGB(0, 0, i*16); <br> <br>                        memset(&amp;cc, 0, sizeof(CHOOSECOLOR)); <br>                        cc.lStructSize=sizeof(CHOOSECOLOR); <br>                        cc.lpCustColors=rgColors; <br>                        cc.hwndOwner=hDlg; <br>                        cc.Flags=CC_RGBINIT; <br>                        ppl-&gt;m_pImpIPolyline-&gt;ColorGet(uTemp <br>                            , &amp;cc.rgbResult); <br> <br>                        if (ChooseColor(&amp;cc)) <br>                            { <br>                            //rgColor is just some COLORREF pointer <br>                            ppl-&gt;m_pImpIPolyline-&gt;ColorSet(uTemp <br>                                , cc.rgbResult, rgColors); <br>                            } <br>                        } <br>                    break; <br> <br>                case ID_LINESOLID: <br>                case ID_LINEDASH: <br>                case ID_LINEDOT: <br>                case ID_LINEDASHDOT: <br>                case ID_LINEDASHDOTDOT: <br>                    if (NULL!=ppl) <br>                        { <br>                        ppl-&gt;m_pImpIPolyline <br>                            -&gt;LineStyleSet(uID-ID_LINEMIN, &amp;uTemp); <br>                        } <br> <br>                    break; <br>                } <br>            break; <br> <br>        case WM_DESTROY: <br>           #ifdef WIN32 <br>            RemoveProp(hDlg, PROP_POINTER); <br>           #else <br>            RemoveProp(hDlg, PROP_SELECTOR); <br>            RemoveProp(hDlg, PROP_OFFSET); <br>           #endif <br>            break; <br> <br>        case WM_CLOSE: <br>            //This will do the IDOK handling, then send POLYM_CLOSE <br>            SendCommand(hDlg, IDOK, 0, NULL); <br>            break; <br> <br>        case POLYM_CLOSE: <br>            ShowWindow(hDlg, SW_HIDE); <br>            ppl-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW); <br>            break; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br>/* <br> * CalcPolyRectInDialog <br> * <br> * Purpose: <br> *  Calculates the rectangle that the Polyline should occupy in the <br> *  dialog box.  This is separated for in-place handling because <br> *  when we open the dialog from an in-place active situation we <br> *  have to move the Polyline window from the container into the <br> *  dialog and position it properly. <br> * <br> * Parameters: <br> *  hDlg            HWND of the dialog. <br> *  prc             LPRECT in which to store the rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CalcPolyRectInDialog(HWND hDlg, LPRECT prc) <br>    { <br>    HWND        hWnd; <br>    POINT       pt; <br> <br>    hWnd=GetDlgItem(hDlg, ID_POLYLINERECT); <br>    GetWindowRect(hWnd, prc); <br>    SETPOINT(pt, prc-&gt;left, prc-&gt;top); <br>    ScreenToClient(hDlg, &amp;pt); <br> <br>    //Set the polyline just within the black frame <br>    SetRect(prc, pt.x, pt.y, pt.x+(prc-&gt;right-prc-&gt;left) <br>        , pt.y+(prc-&gt;bottom-prc-&gt;top)); <br>    InflateRect(prc, -1, -1); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
