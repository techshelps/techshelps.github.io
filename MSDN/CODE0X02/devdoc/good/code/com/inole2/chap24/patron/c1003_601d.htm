<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGEMOUS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1021"></a>PAGEMOUS.CPP</h2>
<pre><code>/* <br> * PAGEMOUS.CPP <br> * Patron Chapter 24 <br> * <br> * Implementation of mouse-related member functions of CPage. <br> * The remainder is in PAGE.CPP.  This separate file keeps this <br> * grungy hit-testing/drawing code out of our way. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>//Lookups into the array using g_rgHTCode[x+y*3] in PAGEMOUS.CPP <br>#define YTOP            0 <br>#define YMID            1 <br>#define YBOT            2 <br>#define XLEFT           0 <br>#define XMID            1 <br>#define XRIGHT          2 <br> <br>//Values to restrict sizing in CPage::OnMouseMove <br>#define SIZINGTOP       0x0001 <br>#define SIZINGBOTTOM    0x0002 <br>#define SIZINGLEFT      0x0004 <br>#define SIZINGRIGHT     0x0008 <br> <br> <br>//This array is for hit-testing lookups <br>static UINT g_rgHTCode[9]={HTTOPLEFT, HTTOP, HTTOPRIGHT <br>    , HTLEFT, HTCLIENT, HTRIGHT, HTBOTTOMLEFT, HTBOTTOM <br>    , HTBOTTOMRIGHT}; <br> <br> <br>//This is for restricting tracking based on the hit-test <br>static UINT g_rguSizingFlags[9]={SIZINGTOP | SIZINGLEFT, SIZINGTOP <br>    , SIZINGTOP | SIZINGRIGHT, SIZINGLEFT, 0, SIZINGRIGHT <br>    , SIZINGBOTTOM | SIZINGLEFT, SIZINGBOTTOM <br>    , SIZINGBOTTOM | SIZINGRIGHT}; <br> <br> <br> <br>/* <br> * CPage::OnRightDown <br> * <br> * Purpose: <br> *  Called when the user clicks with the right button on this <br> *  page.  If there is an object here, determined by the last <br> *  hit-test code, the we'll make a popup-menu for it. <br> * <br> * Parameters: <br> *  uKeys           UINT carrying the key state. <br> *  x, y            UINT coordinates of the click in device units. <br> * <br> * Return Value: <br> *  BOOL            Indicates if the action changed the object. <br> */ <br> <br>BOOL CPage::OnRightDown(UINT uKeys, UINT x, UINT y) <br>    { <br>    HMENU       hMenu; <br>    HMENU       hMenuRes; <br>    HINSTANCE   hInst; <br>    HWND        hWndFrame, hWndT; <br>    POINT       pt; <br>    UINT        i, cItems; <br> <br>    //Select the tenant under the mouse, if there is one. <br>    if (!SelectTenantAtPoint(x, y)) <br>        return FALSE; <br> <br>    /* <br>     * Get the top-level window to which menu command will go.  This <br>     * will be whatever parent doesn't have a parent itself... <br>     */ <br>    hWndT=GetParent(m_hWnd); <br> <br>    while (NULL!=hWndT) <br>        { <br>        hWndFrame=hWndT; <br>        hWndT=GetParent(hWndT); <br>        } <br> <br>    /* <br>     * Build a popup menu for this object with Cut, Copy, Delete, <br>     * and object verbs. <br>     */ <br>    hInst=GETWINDOWINSTANCE(m_hWnd);    //Macro in BOOK1632.H <br>    hMenuRes=LoadMenu(hInst, MAKEINTRESOURCE(IDR_RIGHTPOPUPMENU)); <br> <br>    if (NULL==hMenuRes) <br>        return FALSE; <br> <br>    hMenu=CreatePopupMenu(); <br>    cItems=GetMenuItemCount(hMenuRes); <br> <br>    for (i=0; i &lt; cItems; i++) <br>        { <br>        TCHAR       szTemp[80]; <br>        int         id, uFlags; <br> <br>        GetMenuString(hMenuRes, i, szTemp, sizeof(szTemp) <br>            , MF_BYPOSITION); <br>        id=GetMenuItemID(hMenuRes, i); <br> <br>        uFlags=(0==id) ? MF_SEPARATOR : MF_STRING | MF_ENABLED; <br>        AppendMenu(hMenu, uFlags, id, szTemp); <br>        } <br> <br>    DestroyMenu(hMenuRes); <br> <br>    //Munge the Object menu item <br>    m_pTenantCur-&gt;AddVerbMenu(hMenu, MENUPOS_OBJECTONPOPUP); <br> <br>    //Enable or disable the Links item. <br>    i=FQueryLinksInPage() ? MF_ENABLED : MF_DISABLED | MF_GRAYED; <br>    EnableMenuItem(hMenu, IDM_EDITLINKS, i | MF_BYCOMMAND); <br> <br>    //CHAPTER24MOD <br>    i=FQueryEnableEvents() ? MF_ENABLED : MF_DISABLED | MF_GRAYED; <br>    EnableMenuItem(hMenu, IDM_EDITOBJECTEVENTS, i | MF_BYCOMMAND); <br>    //End CHAPTER24MOD <br> <br>    SETPOINT(pt, x, y); <br>    ClientToScreen(m_hWnd, &amp;pt); <br> <br>    TrackPopupMenu(hMenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON <br>        , pt.x, pt.y, 0, hWndFrame, NULL); <br> <br>    DestroyMenu(hMenu); <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::SelectTenantAtPoint <br> * <br> * Purpose: <br> *  Selects whatever tenant is at the point (x,y) if there is one, <br> *  deselecting the previously selected tenant. <br> * <br> * Parameters: <br> *  x, y            UINT coordinates of the mouse. <br> * <br> * Return Value: <br> *  BOOL            TRUE if there is a tenant here, FALSE otherwise. <br> */ <br> <br>BOOL CPage::SelectTenantAtPoint(UINT x, UINT y) <br>    { <br>    UINT            iTenant; <br>    PCTenant        pTenant; <br>    PCDocument      pDoc; <br> <br>    iTenant=TenantFromPoint(x, y, &amp;pTenant); <br> <br>    //Make the document window active in any case <br>    pDoc=(PCDocument)SendMessage(GetParent(m_hWnd), DOCM_PDOCUMENT <br>        , 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        BringWindowToTop(pDoc-&gt;Window()); <br> <br>    if (NULL==pTenant) <br>        { <br>        //Deactivate any in-place object, if one exists. <br>        if (NULL!=m_pTenantCur) <br>            m_pTenantCur-&gt;DeactivateInPlaceObject(FALSE); <br> <br>        return FALSE; <br>        } <br> <br>    //The m_pTenantCur-&gt;Select(FALSE, TRUE) deactivates as well. <br> <br>    //If this one is already current, we might be now sizing. <br>    if (pTenant==m_pTenantCur) <br>        return TRUE; <br> <br>    //Deselect the current tenant <br>    if (NULL!=m_pTenantCur) <br>        //CHAPTER24MOD <br>        m_pTenantCur-&gt;Select(FALSE, !m_pPG-&gt;m_fDesignMode); <br>        //End CHAPTER24MOD <br> <br>    //Move this tenant to the top of the list <br>    m_iTenantCur=0; <br> <br>    SendMessage(m_hWndTenantList, LB_DELETESTRING, iTenant, 0L); <br>    SendMessage(m_hWndTenantList, LB_INSERTSTRING, 0 <br>        , (LONG)pTenant); <br> <br>    //Select and repaint the new tenant to show it up front <br>    m_pTenantCur=pTenant; <br> <br>    m_pTenantCur-&gt;Repaint(); <br>    //CHAPTER24MOD <br>    m_pTenantCur-&gt;Select(TRUE, !m_pPG-&gt;m_fDesignMode); <br>    //End CHAPTER24MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::OnLeftDown <br> * <br> * Purpose: <br> *  Called when the user clicks with the left button on this page. <br> *  We find the object under that position that is visibly on top <br> *  (always the first one under this location in the page list since <br> *  we paint in reverse order) and select it. <br> * <br> * Parameters: <br> *  uKeys           UINT carrying the key state. <br> *  x, y            UINT coordinates of the click in device units. <br> * <br> * Return Value: <br> *  BOOL            Indicates if the action changed the object. <br> */ <br> <br>BOOL CPage::OnLeftDown(UINT uKeys, UINT x, UINT y) <br>    { <br>    /* <br>     * If the mouse is in a position to start dragging, <br>     * start the timer as with sizing below. <br>     */ <br>    if (HTCAPTION==m_uHTCode) <br>        { <br>        m_fDragPending=TRUE; <br> <br>        //Save down point and start timer. <br>        m_ptDown.x=x; <br>        m_ptDown.y=y; <br> <br>        m_uKeysDown=uKeys; <br> <br>        m_fTimer=TRUE; <br>        SetTimer(m_hWnd, IDTIMER_DEBOUNCE, m_cDelay, NULL); <br>        return FALSE; <br>        } <br> <br>    /* <br>     * If the mouse is in a position to start sizing, start <br>     * the debounce timer and note the condition.  The sizing <br>     * will start in OnTimer or OnMouseMove.  This will always <br>     * happen on the currently selected tenant, and m_uHTCode is <br>     * set in OnNCHitTest below. <br>     */ <br>    if (HTNOWHERE!=m_uHTCode &amp;&amp; HTCLIENT!=m_uHTCode) <br>        { <br>        m_fSizePending=TRUE; <br> <br>        //Save down point and start timer. <br>        m_ptDown.x=x; <br>        m_ptDown.y=y; <br> <br>        m_fTimer=TRUE; <br>        SetTimer(m_hWnd, IDTIMER_DEBOUNCE, m_cDelay, NULL); <br>        return FALSE; <br>        } <br> <br>    SelectTenantAtPoint(x, y); <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::OnLeftUp <br> * <br> * Purpose: <br> *  Called when the user clicks up with the left button on this <br> *  page. We stop tracking on this message, if necessary, and <br> *  resize the object. <br> * <br> * Parameters: <br> *  uKeys           UINT carrying the key state. <br> *  x, y            UINT coordinates of the click in device units. <br> * <br> * Return Value: <br> *  BOOL            Indicates if this action changed the object. <br> */ <br> <br>BOOL CPage::OnLeftUp(UINT uKeys, UINT x, UINT y) <br>    { <br>    RECT    rc, rcT; <br> <br>    if (m_fSizePending || m_fDragPending) <br>        { <br>        m_fSizePending=FALSE; <br>        m_fDragPending=FALSE; <br> <br>        if (m_fTimer) <br>            { <br>            KillTimer(m_hWnd, IDTIMER_DEBOUNCE); <br>            m_fTimer=FALSE; <br>            } <br> <br>        return FALSE; <br>        } <br> <br>    if (!m_fTracking) <br>        return FALSE; <br> <br>    //Remove the dotted rectangle. <br>    RECTFROMRECTL(rc, m_rcl) <br>    DrawFocusRect(m_hDC, &amp;rc); <br>    ReleaseDC(m_hWnd, m_hDC); <br> <br>    ReleaseCapture(); <br>    m_fTracking=FALSE; <br> <br>    //If the original and new rects are the same, nothing happened. <br>    RECTFROMRECTL(rcT, m_rclOrg); <br> <br>    if (EqualRect(&amp;rc, &amp;rcT)) <br>        return FALSE; <br> <br>    RECTFROMRECTL(rcT, m_rclOrg); <br>    InvalidateRect(m_hWnd, &amp;rcT, TRUE); <br> <br>    //Invalidate on the screen before accounting for scrolling <br>    InvalidateRect(m_hWnd, &amp;rc, TRUE); <br> <br>    //Factor in scrolling and tell the tenant where it now stands. <br>    OffsetRect(&amp;rc, (int)m_pPG-&gt;m_xPos, (int)m_pPG-&gt;m_yPos); <br>    RECTLFROMRECT(m_rcl, rc); <br>    m_pTenantCur-&gt;RectSet(&amp;m_rcl, TRUE, TRUE); <br> <br>    UpdateWindow(m_hWnd); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::OnLeftDoubleClick <br> * <br> * Purpose: <br> *  Called when the user double-clicks with the left button on this <br> *  page.  We find the object under that position that is visibly on <br> *  top (always the first one under this location in the page list <br> *  since we paint in reverse order) and activate it. <br> * <br> * Parameters: <br> *  uKeys           UINT carrying the key state. <br> *  x, y            UINT coordinates of the click in device units. <br> * <br> * Return Value: <br> *  BOOL            Indicates if the action changed the object. <br> */ <br> <br>BOOL CPage::OnLeftDoubleClick(UINT uKeys, UINT x, UINT y) <br>    { <br>    /* <br>     * The current tenant is the only one that can be activated, so <br>     * we just have to make sure the mouse is there.  For that we <br>     * can use the last hit-test code we saw since it's updated on <br>     * every mouse move. <br>     */ <br> <br>    if (HTNOWHERE!=m_uHTCode) <br>        { <br>        MSG     msg; <br>        DWORD   dw; <br> <br>        //Include a message for in-place objects. <br>        msg.hwnd=NULL; <br>        msg.message=WM_LBUTTONDBLCLK; <br>        msg.wParam=(WPARAM)uKeys; <br>        msg.lParam=MAKELONG(x, y); <br>        msg.time=GetMessageTime(); <br> <br>        dw=GetMessagePos(); <br>        SETPOINT(msg.pt, LOWORD(dw), HIWORD(dw)); <br> <br>        return m_pTenantCur-&gt;Activate(OLEIVERB_PRIMARY, &amp;msg); <br>        } <br> <br>    //If we've been waiting to add UI, now's the time to do all of it. <br>    if (m_pPG-&gt;m_fAddUI) <br>        { <br>        g_pFR-&gt;ShowUIAndTools(TRUE, TRUE); <br>        m_pPG-&gt;m_fAddUI=FALSE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::OnMouseMove <br> * <br> * Purpose: <br> *  Processes WM_MOUSEMOVE on a page so we can handle tracking <br> *  resize of a tenant. <br> * <br> * Parameters: <br> *  x, y            int device coordinates to check. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::OnMouseMove(UINT uKeys, int x, int y) <br>    { <br>    RECT        rc, rcO, rcB; <br>    int         cxy; <br> <br>    if (m_fSizePending || m_fDragPending) <br>        { <br>        int     dx, dy; <br> <br>        dx=(x &gt; m_ptDown.x) ? (x-m_ptDown.x) : (m_ptDown.x-x); <br>        dy=(y &gt; m_ptDown.y) ? (y-m_ptDown.y) : (m_ptDown.y-y); <br> <br>        /* <br>         * Has the mouse moved outside the debounce distance?  If <br>         * so, we can start sizing.  Note that this happens <br>         * regardless of the timer state. <br>         */ <br>        if (dx &gt; m_cxyDist || dy &gt; m_cxyDist) <br>            { <br>            POINT       pt; <br>            BOOL        fSize=m_fSizePending; <br>            BOOL        fDrag=m_fDragPending; <br> <br>            m_fSizePending=FALSE; <br>            m_fDragPending=FALSE; <br> <br>            if (m_fTimer) <br>                { <br>                KillTimer(m_hWnd, IDTIMER_DEBOUNCE); <br>                m_fTimer=FALSE; <br>                } <br> <br>            if (fDrag) <br>                { <br>                //Set dirty flag if drag &amp; drop changed things. <br>                m_pPG-&gt;m_fDirty |= DragDrop(m_uKeysDown, x, y); <br>                return; <br>                } <br> <br>            if (fSize) <br>                StartSizeTracking(); <br> <br>            /* <br>             * Since we might have moved out of the sizing handle <br>             * in order to start the operation, we need to set the <br>             * m_uSizingFlags field based on the original down point <br>             * for subsequent mouse moves to function properly. <br>             * Note that OnNCHitTest expects screen coordinates. <br>             */ <br>            SETPOINT(pt, m_ptDown.x, m_ptDown.y); <br>            ClientToScreen(m_hWnd, &amp;pt); <br>            OnNCHitTest(pt.x, pt.y); <br>            OnSetCursor(m_uHTCode); <br>            return; <br>            } <br>        } <br> <br>    if (!m_fTracking) <br>        return; <br> <br>    //Get rid of the old rectangle. <br>    RECTFROMRECTL(rc, m_rcl) <br>    DrawFocusRect(m_hDC, &amp;rc); <br> <br>    /* <br>     * Calculate the new.  The flags in m_uSizingFlags tell us what <br>     * to change.  We limit the object by the page margins and a <br>     * minimum size of 3*CXYHANDLE in either dimension. <br>     */ <br>    cxy=3*CXYHANDLE; <br> <br>    RECTFROMRECTL(rcO, m_rclOrg); <br>    RECTFROMRECTL(rcB, m_rclBounds); <br> <br>    if (m_uSizingFlags &amp; SIZINGTOP) <br>        { <br>        if (y &gt;= rcO.bottom-cxy) <br>            y=rcO.bottom-cxy; <br> <br>        if (y &lt;= rcB.top)           //Limit to top of page. <br>            y=rcB.top; <br> <br>        m_rcl.top=y; <br>        } <br> <br>    if (m_uSizingFlags &amp; SIZINGBOTTOM) <br>        { <br>        if (y &lt;= rcO.top+cxy) <br>            y=rcO.top+cxy; <br> <br>        if (y &gt;= rcB.bottom)         //Limit to bottom of page. <br>            y=rcB.bottom; <br> <br>        m_rcl.bottom=y; <br>        } <br> <br>    if (m_uSizingFlags &amp; SIZINGLEFT) <br>        { <br>        if (x &gt;= rcO.right-cxy) <br>            x=rcO.right-cxy; <br> <br>        if (x &lt;= rcB.left)           //Limit to left of page. <br>            x=rcB.left; <br> <br>        m_rcl.left=x; <br>        } <br> <br>    if (m_uSizingFlags &amp; SIZINGRIGHT) <br>        { <br>        if (x &lt;= rcO.left+cxy) <br>            x=rcO.left+cxy; <br> <br>        if (x &gt;= rcB.right)          //Limit to right of page. <br>            x=rcB.right; <br> <br>        m_rcl.right=x; <br>        } <br> <br> <br>    //Draw the new <br>    RECTFROMRECTL(rc, m_rcl) <br>    DrawFocusRect(m_hDC, &amp;rc); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPage::OnTimer <br> * <br> * Purpose: <br> *  Processes WM_TIMER messages to a page used to perform mouse <br> *  debouncing. <br> * <br> * Parameters: <br> *  uID             UINT timer ID. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::OnTimer(UINT uID) <br>    { <br>    if (m_fSizePending || m_fDragPending) <br>        { <br>        BOOL        fSize=m_fSizePending; <br>        BOOL        fDrag=m_fDragPending; <br> <br>        /* <br>         * Having this function called means the delay requirement <br>         * is satisfied.  Start tracking for sizing or dragging. <br>         */ <br> <br>        m_fSizePending=FALSE; <br>        m_fDragPending=FALSE; <br> <br>        KillTimer(m_hWnd, IDTIMER_DEBOUNCE); <br>        m_fTimer=FALSE; <br> <br>        if (fDrag) <br>            { <br>            POINT       pt; <br> <br>            GetCursorPos(&amp;pt); <br>            m_pPG-&gt;m_fDirty |= DragDrop(m_uKeysDown <br>                , m_ptDown.x, m_ptDown.y); <br>            return; <br>            } <br> <br>        if (fSize) <br>            StartSizeTracking(); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::StartSizeTracking <br> * <br> * Purpose: <br> *  Begins sizing of a tenant when mouse debounce conditions are <br> *  met. <br> * <br> * Parameters: <br> *  uID             UINT timer ID. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::StartSizeTracking(void) <br>    { <br>    RECT        rc; <br> <br>    m_pTenantCur-&gt;RectGet(&amp;m_rcl, TRUE); <br>    SetCapture(m_hWnd); <br>    m_fTracking=TRUE; <br> <br>    m_hDC=GetDC(m_hWnd); <br> <br>    //Place the rectangle exactly where it is on the screen. <br>    RECTFROMRECTL(rc, m_rcl) <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br>    RECTLFROMRECT(m_rcl, rc); <br>    m_rclOrg=m_rcl; <br> <br>    DrawFocusRect(m_hDC, &amp;rc); <br> <br>    m_pPG-&gt;CalcBoundingRect(&amp;rc, TRUE); <br>    RECTLFROMRECT(m_rclBounds, rc); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::OnNCHitTest <br> * <br> * Purpose: <br> *  Processes WM_NCHITTEST on a page so we can check for hits on the <br> *  handles of the selected object for resizing.  We only save <br> *  information for ourselves and do not interfere with normal <br> *  hit-testing. <br> * <br> * Parameters: <br> *  x, y            UINT device coordinates to check. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPage::OnNCHitTest(UINT x, UINT y) <br>    { <br>    RECT        rc; <br>    RECTL       rcl; <br>    int         iMid1, iMid2; <br>    int         xHit, yHit; <br>    POINT       pt; <br>    int         x0, y0; <br> <br>    /* <br>     * Ignore this message if it occurs during tracking to adjust <br>     * for the behavior of oddball mouse drivers. <br>     */ <br>    if (m_fSizePending || m_fTracking) <br>        return; <br> <br>    //Default: don't start sizing on a click, don't hit an object. <br>    m_uSizingFlags=0; <br>    m_uHTCode=HTNOWHERE; <br> <br>    if (NULL==m_pTenantCur) <br>        return; <br> <br>    //Convert device points to our coordinates <br>    m_pTenantCur-&gt;RectGet(&amp;rcl, FALSE); <br>    RECTFROMRECTL(rc, rcl); <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>    SETPOINT(pt, x, y); <br>    ScreenToClient(m_hWnd, &amp;pt); <br>    x0=pt.x; <br>    y0=pt.y; <br> <br>    if (x0 &lt; rc.left || x0 &gt; rc.right) <br>        return; <br> <br>    if (y0 &lt; rc.top || y0 &gt; rc.bottom) <br>        return; <br> <br>    //It's at least in the object. <br>    m_uHTCode=HTCLIENT; <br> <br>    //Check for hits in horizontal regions <br>    xHit=NOVALUE; <br>    iMid1=rc.left+((rc.right-rc.left-CXYHANDLE) &gt;&gt; 1); <br>    iMid2=rc.left+((rc.right-rc.left+CXYHANDLE) &gt;&gt; 1); <br> <br>    if (x0 &gt;= rc.left &amp;&amp; x0 &lt;= rc.left+CXYHANDLE) <br>        xHit=XLEFT; <br>    else if (x0 &gt;= iMid1 &amp;&amp; x0 &lt;= iMid2) <br>        xHit=XMID; <br>    else if (x0 &gt;= rc.right-CXYHANDLE &amp;&amp; x0 &lt;= rc.right) <br>        xHit=XRIGHT; <br> <br>    //Don't exit yet if we didn't hit a handle--might hit a y edge. <br> <br>    //Check for hits in vertical regions <br>    yHit=NOVALUE; <br>    iMid1=rc.top+((rc.bottom-rc.top-CXYHANDLE) &gt;&gt; 1); <br>    iMid2=rc.top+((rc.bottom-rc.top+CXYHANDLE) &gt;&gt; 1); <br> <br>    if (y0 &gt;= rc.top &amp;&amp; y0 &lt;= rc.top+CXYHANDLE) <br>        yHit=YTOP; <br>    else if (y0 &gt;= iMid1 &amp;&amp; y0 &lt;= iMid2) <br>        yHit=YMID; <br>    else if (y0 &gt;= rc.bottom-CXYHANDLE &amp;&amp; y0 &lt;= rc.bottom) <br>        yHit=YBOT; <br> <br>    /* <br>     * If we hit any edge, but didn't hit a handle, then one of xHit <br>     * and yHit will be NOVALUE and the other something else.  When <br>     * we hit an edge on the 'something else' then we're on a drag <br>     * point. <br>     */ <br> <br>    if ((NOVALUE==xHit &amp;&amp; NOVALUE==yHit) <br>        || (XMID==xHit &amp;&amp; YMID==yHit) <br>        || (NOVALUE==xHit &amp;&amp; YMID==yHit) <br>        || (XMID==xHit &amp;&amp; NOVALUE==yHit)) <br>        return; <br> <br>    if ((NOVALUE==xHit &amp;&amp; (YTOP==yHit || YBOT==yHit)) <br>        || ((XLEFT==xHit || XRIGHT==xHit) &amp;&amp; NOVALUE==yHit)) <br>        { <br>        m_uHTCode=HTCAPTION; <br>        return; <br>        } <br> <br>    //We hit a handle, so save our HT code <br>    m_uSizingFlags=g_rguSizingFlags[xHit+(yHit*3)]; <br>    m_uHTCode=g_rgHTCode[xHit+(yHit*3)]; <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::SetCursor <br> * <br> * Purpose: <br> *  Processes WM_SETCURSOR using the code from OnNCHitTest. <br> * <br> * Parameters: <br> *  x, y            UINT device coordinates to check. <br> * <br> * Return Value: <br> *  LRESULT         HT* code for Windows. <br> */ <br> <br>BOOL CPage::OnSetCursor(UINT uHTCode) <br>    { <br>    HCURSOR     hCur; <br>    UINT        iCur; <br> <br>    /* <br>     * We really just ignore uHTCode and use the one we saved <br>     * in OnNCHitTest. <br>     */ <br> <br>    switch (m_uHTCode) <br>        { <br>        case HTTOP: <br>        case HTBOTTOM: <br>            iCur=IDC_VARROWS; <br>            break; <br> <br>        case HTLEFT: <br>        case HTRIGHT: <br>            iCur=IDC_HARROWS; <br>            break; <br> <br> <br>        case HTTOPLEFT: <br>        case HTBOTTOMRIGHT: <br>            iCur=IDC_NWSEARROWS; <br>            break; <br> <br>        case HTTOPRIGHT: <br>        case HTBOTTOMLEFT: <br>            iCur=IDC_NESWARROWS; <br>            break; <br> <br>        case HTCAPTION: <br>            iCur=IDC_SMALLARROWS; <br>            break; <br> <br>        default: <br>            return FALSE; <br>        } <br> <br>    hCur=UICursorLoad(iCur); <br>    SetCursor(hCur); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPage::TenantFromPoint <br> * (Protected) <br> * <br> * Purpose: <br> *  Finds the tenant under the given device coordinates on this <br> *  page. <br> * <br> * Parmeters: <br> *  x, y            UINT coordinates. <br> *  ppTenant        PCTenant * in which to return the pointer. <br> * <br> * Return Value: <br> *  UINT            Index of the matched tenant, NOVALUE if not <br> *                  found. <br> */ <br> <br>UINT CPage::TenantFromPoint(UINT x, UINT y, PCTenant *ppTenant) <br>    { <br>    PCTenant    pTenant; <br>    RECTL       rcl; <br>    UINT        i; <br>    int         x0, y0; <br> <br>    x0=x+m_pPG-&gt;m_xPos; <br>    y0=y+m_pPG-&gt;m_yPos; <br> <br>    for (i=0; i &lt; m_cTenants; i++) <br>        { <br>        if (!TenantGet(i, &amp;pTenant, FALSE)) <br>            continue; <br> <br>        pTenant-&gt;RectGet(&amp;rcl, TRUE); <br> <br>        //Essentially Perform PointInRECTL <br>        if (x0 &gt;= rcl.left &amp;&amp; x0 &lt;= rcl.right) <br>            { <br>            if (y0 &lt;=rcl.bottom &amp;&amp; y0 &gt;=rcl.top) <br>                { <br>                *ppTenant=pTenant; <br>                return i; <br>                } <br>            } <br>        } <br> <br>    *ppTenant=NULL; <br>    return NOVALUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPage::DragDrop <br> * <br> * Purpose: <br> *  Performs drag-drop operations from the page window <br> * <br> * Parmeters: <br> *  uKeys           UINT state of the keyboard <br> *  x, y            UINT mouse coordinates of the starting click. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we modified the page, FALSE otherwise. <br> */ <br> <br>BOOL CPage::DragDrop(UINT uKeys, UINT x, UINT y) <br>    { <br>    LPDROPSOURCE    pIDropSource; <br>    LPDATAOBJECT    pIDataObject; <br>    HRESULT         hr; <br>    DWORD           dwEffect; <br>    POINTL          ptl; <br>    SIZEL           szl; <br>    RECTL           rcl; <br>    RECT            rc, rcT; <br> <br>    pIDropSource=new CDropSource(); <br> <br>    if (NULL==pIDropSource) <br>        return FALSE; <br> <br>    pIDropSource-&gt;AddRef(); <br>    m_pPG-&gt;m_fDragSource=TRUE; <br> <br> <br>    /* <br>     * Store a pick point with the data indicating the offset from <br>     * the upper left of the rectangle where we grabbed it.  This is <br>     * so the UI feedback in IDropTarget lines up with this tenant. <br>     */ <br> <br>    m_pTenantCur-&gt;RectGet(&amp;rcl, TRUE); <br>    ptl.x=x+m_pPG-&gt;m_xPos-rcl.left; <br>    ptl.y=y+m_pPG-&gt;m_yPos-rcl.top; <br>    pIDataObject=TransferObjectCreate(&amp;ptl); <br> <br>    if (NULL==pIDataObject) <br>        { <br>        pIDropSource-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    m_pPG-&gt;m_fMoveInPage=FALSE; <br> <br>    dwEffect=DROPEFFECT_COPY | DROPEFFECT_MOVE; <br>    hr=DoDragDrop(pIDataObject, pIDropSource <br>        , DROPEFFECT_COPY | DROPEFFECT_MOVE, &amp;dwEffect); <br> <br>    pIDataObject-&gt;Release(); <br>    pIDropSource-&gt;Release(); <br> <br>    m_pPG-&gt;m_fDragSource=FALSE; <br> <br>    //No drop-no action. <br>    if (DRAGDROP_S_DROP!=GetScode(hr) || DROPEFFECT_NONE==dwEffect) <br>        return FALSE; <br> <br>    /* <br>     * If m_pPG-&gt;m_fMoveInPage is set, then we just change the <br>     * coordinates on m_pTenantCur and we're done. <br>     */ <br>    if (m_pPG-&gt;m_fMoveInPage) <br>        { <br>        m_pTenantCur-&gt;Invalidate(); <br> <br>        /* <br>         * Clip to page boundaries.  We know that ptDrop has to be <br>         * in the page somewhere or we would not have dropped <br>         * (effect was NONE).  So first make sure that ptDrop is <br>         * within 3*CXYHANDLE of the right or bottom, and if so, <br>         * pull it out to 3*CXYHANDLE.  Then we can just clip the <br>         * size to the page rectangle and we'll always be sure to <br>         * have at least a sizeable object. <br>         */ <br>        m_pTenantCur-&gt;SizeGet(&amp;szl, TRUE); <br>        SetRect(&amp;rc, (int)m_pPG-&gt;m_ptDrop.x, (int)m_pPG-&gt;m_ptDrop.y <br>            , 0, 0); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br> <br>        m_pPG-&gt;CalcBoundingRect(&amp;rcT, FALSE); <br>        OffsetRect(&amp;rcT, (int)m_pPG-&gt;m_xPos, (int)m_pPG-&gt;m_yPos); <br> <br>        if (rc.left &gt;= rcT.right-3*CXYHANDLE) <br>            rc.left=rcT.right-3*CXYHANDLE; <br> <br>        if (rc.top &gt;= rcT.bottom-3*CXYHANDLE) <br>            rc.top=rcT.bottom-3*CXYHANDLE; <br> <br>        rc.right=rc.left+(int)szl.cx; <br>        rc.bottom=rc.top+(int)szl.cy; <br>        IntersectRect(&amp;rc, &amp;rc, &amp;rcT); <br> <br>        RECTLFROMRECT(rcl, rc); <br> <br>        m_pTenantCur-&gt;RectSet(&amp;rcl, TRUE, FALSE); <br>        m_pTenantCur-&gt;Repaint(); <br>        return TRUE; <br>        } <br> <br>    /* <br>     * Otherwise we may have to delete the old tenant if the effect <br>     * was move.  This will not happen in the move in page case. <br>     */ <br> <br>    if (DROPEFFECT_MOVE==dwEffect) <br>        { <br>        TenantDestroy(); <br>        return TRUE; <br>        } <br> <br>    //Copy is a clean operation <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
