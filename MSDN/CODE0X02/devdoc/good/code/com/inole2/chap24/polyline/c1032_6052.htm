<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYLINE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1046"></a>POLYLINE.CPP</h2>
<pre><code>/* <br> * POLYLINE.CPP <br> * Polyline Component Chapter 24 <br> * <br> * Implementation of the CPolyline class that we expose as a <br> * component object. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * CPolyline:CPolyline <br> * CPolyline::~CPolyline <br> * <br> * Constructor Parameters: <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> *  pfnDestroy      PFNDESTROYED to call when an object is <br> *                  destroyed. <br> *  hInst           HINSTANCE of the application we're in. <br> */ <br> <br>CPolyline::CPolyline(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy <br>    , HINSTANCE hInst) <br>    { <br>    m_hWnd=NULL; <br>    m_hInst=hInst; <br> <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pfnDestroy=pfnDestroy; <br>    m_fDirty=FALSE; <br> <br>    m_pImpIPolyline=NULL; <br>    m_pImpIConnPtCont=NULL; <br> <br>    m_pAdv=NULL; <br>    m_pConnPt=NULL; <br> <br>    m_pST  =NULL; <br>    m_cf   =0; <br>    m_clsID=CLSID_Polyline19; <br> <br>    m_pIStorage=NULL; <br>    m_pIStream =NULL; <br> <br>    m_pImpIPersistStorage=NULL; <br>    m_pImpIPersistStreamInit=NULL; <br> <br>    m_pImpIDataObject   =NULL; <br>    m_pIDataAdviseHolder=NULL; <br> <br>    m_pDefIUnknown       =NULL; <br>    m_pDefIDataObject    =NULL; <br>    m_pDefIViewObject    =NULL; <br>    m_pDefIPersistStorage=NULL; <br> <br>    m_pIOleAdviseHolder =NULL; <br>    m_pImpIOleObject    =NULL; <br>    m_pIOleClientSite   =NULL; <br>    m_pImpIViewObject   =NULL; <br>    m_pIAdviseSink      =NULL; <br> <br>    m_dwFrozenAspects   =0; <br>    m_dwAdviseAspects   =0; <br>    m_dwAdviseFlags     =0; <br> <br>    m_pImpIRunnableObject=NULL; <br>    m_hDlg=NULL; <br> <br>    m_pImpIExternalConnection=NULL; <br>    m_fLockContainer=FALSE; <br>    m_dwRegROT=0L; <br> <br>    m_pIOleIPSite=NULL; <br>    m_pIOleIPFrame=NULL; <br>    m_pIOleIPUIWindow=NULL; <br>    m_pImpIOleIPObject=NULL; <br>    m_pImpIOleIPActiveObject=NULL; <br>    m_hMenuShared=NULL; <br>    m_hOLEMenu=NULL; <br>    m_pHW=NULL; <br>    m_fAllowInPlace=TRUE; <br>    m_fUIActive=FALSE; <br> <br>    m_fContainerKnowsInsideOut=FALSE; <br> <br>    //CHAPTER24MOD <br>    m_pImpISpecifyPP=NULL; <br>    m_pImpIProvideClassInfo=NULL; <br>    m_pImpIDispatch=NULL; <br>    m_pImpIPolylineControl=NULL; <br>    m_pImpIOleControl=NULL; <br> <br>    m_pITypeLib=NULL; <br>    m_pIOleControlSite=NULL; <br>    m_pIDispatchAmbients=NULL; <br>    m_fFreezeEvents=FALSE; <br> <br>    m_fHatch=TRUE; <br>    m_fUIDead=FALSE; <br>    //End CHAPTER24MOD <br> <br>    return; <br>    } <br> <br> <br>CPolyline::~CPolyline(void) <br>    { <br>    LPUNKNOWN       pIUnknown=this; <br> <br>    if (NULL!=m_pUnkOuter) <br>        pIUnknown=m_pUnkOuter; <br> <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    if (NULL!=m_hDlg) <br>        DestroyWindow(m_hDlg); <br> <br>    /* <br>     * In aggregation, release cached pointers but <br>     * AddRef the controlling unknown first.  The  <br>     * extra reference count protects from reentrancy. <br>     */ <br> <br>    m_cRef++; <br> <br>    pIUnknown-&gt;AddRef(); <br>    pIUnknown-&gt;AddRef(); <br>    pIUnknown-&gt;AddRef(); <br> <br>    ReleaseInterface(m_pDefIViewObject); <br>    ReleaseInterface(m_pDefIDataObject); <br>    ReleaseInterface(m_pDefIPersistStorage); <br> <br>    m_cRef--; <br> <br>    //Cached pointer rules do not apply to IUnknown <br>    ReleaseInterface(m_pDefIUnknown); <br> <br>    ReleaseInterface(m_pIAdviseSink); <br>    ReleaseInterface(m_pIOleClientSite); <br>    ReleaseInterface(m_pIOleAdviseHolder); <br> <br>    DeleteInterfaceImp(m_pImpIOleObject); <br>    DeleteInterfaceImp(m_pImpIViewObject); <br>    DeleteInterfaceImp(m_pImpIRunnableObject); <br> <br>    //Other in-place interfaces released in deactivation. <br>    DeleteInterfaceImp(m_pImpIOleIPObject); <br>    DeleteInterfaceImp(m_pImpIOleIPActiveObject); <br> <br>    //CHAPTER24MOD <br>    ReleaseInterface(m_pIDispatchAmbients); <br>    ReleaseInterface(m_pIOleControlSite); <br>    ReleaseInterface(m_pITypeLib); <br> <br>    DeleteInterfaceImp(m_pImpISpecifyPP); <br>    DeleteInterfaceImp(m_pImpIProvideClassInfo); <br>    DeleteInterfaceImp(m_pImpIDispatch); <br>    DeleteInterfaceImp(m_pImpIPolylineControl); <br>    DeleteInterfaceImp(m_pImpIOleControl); <br>    //End CHAPTER24MOD <br> <br>    //Anything we might have registered in IRunnableObject::Run <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br> <br>    DeleteInterfaceImp(m_pImpIExternalConnection); <br>    ReleaseInterface(m_pIDataAdviseHolder); <br>    DeleteInterfaceImp(m_pImpIDataObject); <br> <br>    DeleteInterfaceImp(m_pImpIPersistStreamInit); <br>    DeleteInterfaceImp(m_pImpIPersistStorage); <br>    ReleaseInterface(m_pIStream); <br>    ReleaseInterface(m_pIStorage); <br> <br>    DeleteInterfaceImp(m_pImpIConnPtCont); <br>    DeleteInterfaceImp(m_pImpIPolyline); <br> <br>    ReleaseInterface(m_pAdv); <br>    ReleaseInterface(m_pConnPt); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::Init <br> * <br> * Purpose: <br> *  Performs any intiailization of a CPolyline that's prone to <br> *  failure that we also use internally before exposing the <br> *  object outside this DLL. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPolyline::Init(void) <br>    { <br>    LPUNKNOWN       pIUnknown=this; <br>    HRESULT         hr; <br> <br>    if (NULL!=m_pUnkOuter) <br>        pIUnknown=m_pUnkOuter; <br> <br>    m_pST=new CStringTable(m_hInst); <br> <br>    if (!m_pST-&gt;Init(IDS_POLYLINEMIN, IDS_POLYLINEMAX)) <br>        return FALSE; <br> <br>    m_cf=RegisterClipboardFormat(SZPOLYLINECLIPFORMAT); <br> <br>    m_pImpIPersistStorage=new CImpIPersistStorage(this, pIUnknown); <br> <br>    if (NULL==m_pImpIPersistStorage) <br>        return FALSE; <br> <br>    m_pImpIPersistStreamInit=new CImpIPersistStreamInit(this <br>        , pIUnknown); <br> <br>    if (NULL==m_pImpIPersistStreamInit) <br>        return FALSE; <br> <br>    m_pImpIPolyline=new CImpIPolyline(this, pIUnknown); <br> <br>    if (NULL==m_pImpIPolyline) <br>        return FALSE; <br> <br>    m_pImpIConnPtCont=new CImpIConnPtCont(this, pIUnknown); <br> <br>    if (NULL==m_pImpIConnPtCont) <br>        return FALSE; <br> <br>    m_pConnPt=new CConnectionPoint(this); <br> <br>    if (NULL==m_pConnPt) <br>        return FALSE; <br> <br>    m_pConnPt-&gt;AddRef();    //Reversed in destructor <br> <br>    m_pImpIDataObject=new CImpIDataObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIDataObject) <br>        return FALSE; <br> <br>    m_pImpIOleObject=new CImpIOleObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIOleObject) <br>        return FALSE; <br> <br>    m_pImpIViewObject=new CImpIViewObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIViewObject) <br>        return FALSE; <br> <br>    m_pImpIRunnableObject=new CImpIRunnableObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIRunnableObject) <br>        return FALSE; <br> <br>    m_pImpIExternalConnection=new CImpIExternalConnection(this <br>        , pIUnknown); <br> <br>    if (NULL==m_pImpIExternalConnection) <br>        return FALSE; <br> <br>    m_pImpIOleIPObject=new CImpIOleInPlaceObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIOleIPObject) <br>        return FALSE; <br> <br>    m_pImpIOleIPActiveObject=new CImpIOleInPlaceActiveObject(this <br>        , pIUnknown); <br> <br>    if (NULL==m_pImpIOleIPActiveObject) <br>        return FALSE; <br> <br>    //CHAPTER24MOD <br>    m_pImpISpecifyPP=new CImpISpecifyPP(this, pIUnknown); <br> <br>    if (NULL==m_pImpISpecifyPP) <br>        return FALSE; <br> <br>    m_pImpIProvideClassInfo=new CImpIProvideClassInfo(this, pIUnknown); <br> <br>    if (NULL==m_pImpIProvideClassInfo) <br>        return FALSE; <br> <br>    m_pImpIDispatch=new CImpIDispatch(this, pIUnknown); <br> <br>    if (NULL==m_pImpIDispatch) <br>        return FALSE; <br> <br>    m_pImpIPolylineControl=new CImpIPolylineControl(this, pIUnknown); <br> <br>    if (NULL==m_pImpIPolylineControl) <br>        return FALSE; <br> <br>    m_pImpIOleControl=new CImpIOleControl(this, pIUnknown); <br> <br>    if (NULL==m_pImpIOleControl) <br>        return FALSE; <br>    //End CHAPTER24MOD <br> <br>    /* <br>     * We're sitting at ref count 0 and the next call will AddRef a <br>     * few times and Release a few times.  This insures we don't <br>     * delete ourselves prematurely. <br>     */ <br>    m_cRef++; <br> <br>    //Aggregate OLE's cache for IOleCache* interfaces. <br>    hr=CreateDataCache(pIUnknown, CLSID_Polyline19 <br>        , IID_IUnknown, (PPVOID)&amp;m_pDefIUnknown); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * NOTE:  The spec specifically states that any interfaces <br>     * besides IUnknown that we obtain on an aggregated object <br>     * should be Released immediately after we QueryInterface for <br>     * them because the QueryInterface will AddRef us, and since <br>     * we would not release these interfaces until we were <br>     * destroyed, we'd never go away because we'd never get a zero <br>     * ref count. <br>     */ <br> <br>    //Now try to get other interfaces to which we delegate <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IViewObject2 <br>        , (PPVOID)&amp;m_pDefIViewObject); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IDataObject <br>        , (PPVOID)&amp;m_pDefIDataObject); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;m_pDefIPersistStorage); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    m_cRef--; <br>    m_pImpIPolyline-&gt;New(); <br> <br>    //CHAPTER24MOD <br>    /* <br>     * Go load our own type information and save its ITypeLib <br>     * pointer that will be used be CImpIDispatch and <br>     * CImpIProvideClassInfo. <br>     */ <br> <br>    hr=LoadRegTypeLib(LIBID_PolylineTypeLibrary, 1, 0 <br>        , LANG_NEUTRAL, &amp;m_pITypeLib); <br> <br>    if (FAILED(hr)) <br>        hr=LoadTypeLib(OLETEXT("POLYLINE.TLB"), &amp;m_pITypeLib); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    //Set up our CONTROLINFO structure (we have two mnemonics) <br>    m_ctrlInfo.cb=sizeof(CONTROLINFO); <br>    m_ctrlInfo.dwFlags=0; <br>    m_ctrlInfo.hAccel=NULL; <br>    m_ctrlInfo.cAccel=0; <br> <br>    /* <br>     * Note:  we cannot initialize ambients until we get <br>     * a container interface pointer in IOleObject::SetClientSite. <br>     */ <br>    //End CHAPTER24MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::QueryInterface <br> * CPolyline::AddRef <br> * CPolyline::Release <br> * <br> * Purpose: <br> *  IUnknown members for CPolyline object. <br> */ <br> <br>STDMETHODIMP CPolyline::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IConnectionPointContainer==riid) <br>        *ppv=m_pImpIConnPtCont; <br> <br>    if (IID_IPolyline10==riid) <br>        *ppv=m_pImpIPolyline; <br> <br>    if (IID_IPersistStorage==riid) <br>        *ppv=m_pImpIPersistStorage; <br> <br>    if (IID_IPersist==riid || IID_IPersistStream==riid <br>        || IID_IPersistStreamInit==riid) <br>        *ppv=m_pImpIPersistStreamInit; <br> <br>    if (IID_IDataObject==riid) <br>        *ppv=m_pImpIDataObject; <br> <br>    if (IID_IOleObject==riid) <br>        *ppv=m_pImpIOleObject; <br> <br>    if (IID_IViewObject==riid || IID_IViewObject2==riid) <br>        *ppv=m_pImpIViewObject; <br> <br>    if (IID_IRunnableObject==riid) <br>        *ppv=m_pImpIRunnableObject; <br> <br>    if (IID_IExternalConnection==riid) <br>        *ppv=m_pImpIExternalConnection; <br> <br>    //IOleWindow will be the InPlaceObject <br>    if (IID_IOleWindow==riid || IID_IOleInPlaceObject==riid) <br>        *ppv=m_pImpIOleIPObject; <br> <br>    //CHAPTER24MOD <br>    if (IID_ISpecifyPropertyPages==riid) <br>        *ppv=m_pImpISpecifyPP; <br> <br>    if (IID_IProvideClassInfo==riid) <br>        *ppv=m_pImpIProvideClassInfo; <br> <br>    if (IID_IDispatch==riid || DIID_DIPolylineControl==riid) <br>        *ppv=m_pImpIDispatch; <br> <br>    if (IID_IPolylineControl==riid) <br>        *ppv=m_pImpIPolylineControl; <br> <br>    if (IID_IOleControl==riid) <br>        *ppv=m_pImpIOleControl; <br>    //End CHAPTER24MOD <br> <br> <br>    //Use the default handler's cache. <br>    if (IID_IOleCache==riid || IID_IOleCache2==riid) <br>        return m_pDefIUnknown-&gt;QueryInterface(riid, ppv); <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyline::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPolyline::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    delete this; <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RectConvertMappings <br> * <br> * Purpose: <br> *  Converts the contents of a rectangle from device (MM_TEXT) or <br> *  HIMETRIC to the other. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the rectangle to convert. <br> *  fToDevice       BOOL TRUE to convert from HIMETRIC to device, <br> *                  FALSE to convert device to HIMETRIC. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::RectConvertMappings(LPRECT pRect, BOOL fToDevice) <br>    { <br>    HDC      hDC; <br>    int      iLpx, iLpy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    hDC=GetDC(NULL); <br>    iLpx=GetDeviceCaps(hDC, LOGPIXELSX); <br>    iLpy=GetDeviceCaps(hDC, LOGPIXELSY); <br>    ReleaseDC(NULL, hDC); <br> <br>    if (fToDevice) <br>        { <br>        pRect-&gt;left=MulDiv(iLpx, pRect-&gt;left, HIMETRIC_PER_INCH); <br>        pRect-&gt;top =MulDiv(iLpy, pRect-&gt;top , HIMETRIC_PER_INCH); <br> <br>        pRect-&gt;right =MulDiv(iLpx, pRect-&gt;right, HIMETRIC_PER_INCH); <br>        pRect-&gt;bottom=MulDiv(iLpy, pRect-&gt;bottom,HIMETRIC_PER_INCH); <br>        } <br>    else <br>        { <br>        pRect-&gt;left=MulDiv(pRect-&gt;left, HIMETRIC_PER_INCH, iLpx); <br>        pRect-&gt;top =MulDiv(pRect-&gt;top , HIMETRIC_PER_INCH, iLpy); <br> <br>        pRect-&gt;right =MulDiv(pRect-&gt;right, HIMETRIC_PER_INCH, iLpx); <br>        pRect-&gt;bottom=MulDiv(pRect-&gt;bottom,HIMETRIC_PER_INCH, iLpy); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPolyline::DataSet <br> * <br> * Purpose: <br> *  Sets the current data in this Polyline to a given structure. <br> * <br> * Parameters: <br> *  pplIn           PPOLYLINEDATA to initialize to. <br> *  fSizeToData     BOOL indicating if we're to size to the data <br> *                  or scale it. <br> *  fNotify         BOOL indicating if we're to send an advise <br> *                  on this change. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CPolyline::DataSet(PPOLYLINEDATA pplIn <br>    , BOOL fSizeToData, BOOL fNotify) <br>    { <br>    RECT            rc; <br> <br>    /* <br>     * Copy the structure in pplIn and repaint to reflect the <br>     * new point set.  Note that unlike the RectSet message, we <br>     * do no scaling, assuming that the rect in the structure <br>     * is appropriate for the data. <br>     */ <br> <br>    if (NULL==pplIn) <br>        return ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    m_pl=*pplIn; <br>    m_fDirty=TRUE; <br> <br>    /* <br>     * If we're scaling the window to fit the data, then use <br>     * RectSet passing our current rectangle as the new one. <br>     * That makes sure that the data won't change but that the <br>     * window is resized. <br>     */ <br> <br>    if (fSizeToData) <br>        { <br>        POINT       pt; <br> <br>        /* <br>         * Get our offset in the parent window so we can RectSet <br>         * to the right place since RectSet expects rectangle in <br>         * parent coordinates and we get it in client coordinates. <br>         */ <br>        if (NULL!=m_hWnd) <br>            { <br>            GetWindowRect(m_hWnd, &amp;rc); <br>            pt.x=rc.left; <br>            pt.y=rc.top; <br>            ScreenToClient(GetParent(m_hWnd), &amp;pt); <br>            RECTSTORECT(m_pl.rc, rc); <br>            OffsetRect(&amp;rc, pt.x, pt.y); <br> <br>            //This will also cause a repaint. <br>            m_pImpIPolyline-&gt;RectSet(&amp;rc, fNotify); <br>            } <br>        } <br>    else <br>        { <br>        if (NULL!=m_hWnd) <br>            { <br>            //Make sure we're updated. <br>            InvalidateRect(m_hWnd, NULL, TRUE); <br>            UpdateWindow(m_hWnd); <br>            } <br>        } <br> <br>    SendAdvise(OBJECTCODE_DATACHANGED); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::DataGet <br> * <br> * Purpose: <br> *  Retrieves the Polyline's current data. <br> * <br> * Parameters: <br> *  pplIn           PPOLYLINEDATA into which we copy the data. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CPolyline::DataGet(PPOLYLINEDATA pplIn) <br>    { <br>    if (NULL==pplIn) <br>        return ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    *pplIn=m_pl; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RenderNative <br> * <br> * Purpose: <br> *  Retrieves the Polyline's data in a global memory handle. <br> * <br> * Parameters: <br> *  phMem           HGLOBAL * in which to store the handle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CPolyline::RenderNative(HGLOBAL *phMem) <br>    { <br>    HGLOBAL         hMem; <br>    PPOLYLINEDATA   ppl; <br>    HRESULT         hr=ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    if (NULL==phMem) <br>        return ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, CBPOLYLINEDATA); <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br>        hr=DataGet(ppl); <br> <br>        GlobalUnlock(hMem); <br> <br>        if (FAILED(hr)) <br>            { <br>            GlobalFree(hMem); <br>            hMem=NULL; <br>            } <br>        } <br> <br>    *phMem=hMem; <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::RenderBitmap <br> * <br> * Purpose: <br> *  Creates a bitmap image of the current Polyline. <br> * <br> * Parameters: <br> *  phBmp           HBITMAP * in which to return the bitmap. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CPolyline::RenderBitmap(HBITMAP *phBmp) <br>    { <br>    HDC             hDC; <br>    HDC             hMemDC; <br>    HBITMAP         hBmp; <br>    RECT            rc; <br>    HGDIOBJ         hObj; <br> <br>    if (NULL==phBmp) <br>        return ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    //Render a bitmap the size of the current rectangle. <br>    hDC=GetDC(m_hWnd); <br>    hMemDC=CreateCompatibleDC(hDC); <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br>    hBmp=CreateCompatibleBitmap(hDC, rc.right, rc.bottom); <br> <br>    if (NULL!=hBmp) <br>        { <br>        //Draw the POLYLINEDATA into the bitmap. <br>        hObj=SelectObject(hMemDC, hBmp); <br>        Draw(hMemDC, FALSE, TRUE, &amp;rc, NULL); <br>        SelectObject(hMemDC, hObj); <br>        } <br> <br>    DeleteDC(hMemDC); <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    *phBmp=hBmp; <br>    return NOERROR; <br>    } <br> <br> <br> <br>//RenderMetafile not necessary--now part of RenderMetafilePict. <br> <br> <br> <br>/* <br> * CPolyline::RenderMetafilePict <br> * <br> * Purpose: <br> *  Renders the current Polyline into a METAFILEPICT structure in <br> *  global memory. <br> * <br> * Parameters: <br> *  phMem           HGLOBAL * in which to return the <br> *                  METAFILEPICT. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, otherwise a <br> *                  POLYLINE_E_ value. <br> */ <br> <br>STDMETHODIMP CPolyline::RenderMetafilePict(HGLOBAL *phMem) <br>    { <br>    HGLOBAL         hMem; <br>    HMETAFILE       hMF; <br>    LPMETAFILEPICT  pMF; <br>    RECT            rc; <br>    HDC             hDC; <br> <br>    if (NULL==phMem) <br>        return ResultFromScode(POLYLINE_E_INVALIDPOINTER); <br> <br>    //Create a memory metafile and return its handle. <br>    hDC=(HDC)CreateMetaFile(NULL); <br> <br>    if (NULL==hDC) <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br> <br>    SetMapMode(hDC, MM_ANISOTROPIC); <br>    GetClientRect(m_hWnd, &amp;rc); <br>    SetWindowOrgEx(hDC, 0, 0, NULL); <br>    SetWindowExtEx(hDC, rc.right, rc.bottom, NULL); <br> <br>    Draw(hDC, TRUE, TRUE, &amp;rc, NULL); <br>    hMF=CloseMetaFile(hDC); <br> <br>    if (NULL==hMF) <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br> <br>    //Allocate the METAFILEPICT structure. <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE <br>        , sizeof(METAFILEPICT)); <br> <br>    if (NULL==hMem) <br>        { <br>        DeleteMetaFile(hMF); <br>        return ResultFromScode(E_FAIL); <br>        } <br> <br>    /* <br>     * Global lock only fails in PMODE if the selector is invalid <br>     * (like it was discarded) or references a 0 length segment, <br>     * neither of which can happen here. <br>     */ <br>    pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>    pMF-&gt;hMF=hMF; <br>    pMF-&gt;mm=MM_ANISOTROPIC; <br> <br>    //Insert the extents in MM_HIMETRIC units. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    RectConvertMappings(&amp;rc, FALSE); <br>    pMF-&gt;xExt=rc.right; <br>    pMF-&gt;yExt=rc.bottom; <br> <br>    GlobalUnlock(hMem); <br> <br>    *phMem=hMem; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPolyline::Instance <br> * <br> * Purpose: <br> *  Provides access to the module instance. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HINSTANCE       The instance handle of the module. <br> */ <br> <br>HINSTANCE CPolyline::Instance(void) <br>    { <br>    return m_hInst; <br>    } <br> <br> <br> <br>/* <br> * CPolyline::String <br> * <br> * Purpose: <br> *  Provides string lookup in the Polyline string table. <br> * <br> * Parameters: <br> *  uID             UINT of the string to return. <br> * <br> * Return Value: <br> *  LPTSTR          Pointer to the string. <br> */ <br> <br>LPTSTR CPolyline::String(UINT uID) <br>    { <br>    return PSZ(uID); <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::SendAdvise <br> * <br> * Purpose: <br> *  Calls the appropriate IOleClientSite or IAdviseSink member <br> *  function for various events such as closure, renaming, etc. <br> * <br> * Parameters: <br> *  uCode           UINT OBJECTCODE_* identifying the notification. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::SendAdvise(UINT uCode) <br>    { <br>    DWORD       dwAspect=DVASPECT_CONTENT | DVASPECT_THUMBNAIL; <br> <br>    switch (uCode) <br>        { <br>        case OBJECTCODE_SAVED: <br>            if (NULL!=m_pIOleAdviseHolder) <br>                m_pIOleAdviseHolder-&gt;SendOnSave(); <br>            break; <br> <br>        case OBJECTCODE_CLOSED: <br>            if (NULL!=m_pIOleAdviseHolder) <br>                m_pIOleAdviseHolder-&gt;SendOnClose(); <br> <br>            break; <br> <br>        case OBJECTCODE_RENAMED: <br>            //Call IOleAdviseHolder::SendOnRename (later) <br>            break; <br> <br>        case OBJECTCODE_SAVEOBJECT: <br>            if (m_fDirty &amp;&amp; NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;SaveObject(); <br> <br>            m_fDirty=FALSE; <br>            break; <br> <br>        case OBJECTCODE_DATACHANGED: <br>            m_fDirty=TRUE; <br> <br>            //No flags are necessary here. <br>            if (NULL!=m_pIDataAdviseHolder) <br>                { <br>                m_pIDataAdviseHolder-&gt;SendOnDataChange <br>                    (m_pImpIDataObject, 0, 0); <br>                } <br> <br>            if (NULL!=m_pIAdviseSink <br>                &amp; (dwAspect &amp; m_dwAdviseAspects)) <br>                { <br>                m_pIAdviseSink-&gt;OnViewChange(dwAspect <br>                    &amp; m_dwAdviseAspects, 0); <br>                } <br> <br>            break; <br> <br>        case OBJECTCODE_SHOWWINDOW: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;OnShowWindow(TRUE); <br> <br>            break; <br> <br>        case OBJECTCODE_HIDEWINDOW: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;OnShowWindow(FALSE); <br> <br>            break; <br> <br>        case OBJECTCODE_SHOWOBJECT: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;ShowObject(); <br> <br>            break; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::InPlaceActivate <br> * <br> * Purpose: <br> *  Goes through all the steps of activating the Polyline as an <br> *  in-place object. <br> * <br> * Parameters: <br> *  pActiveSite     LPOLECLIENTSITE of the active site we show in. <br> *  fIncludeUI      BOOL controls whether we call UIActivate too. <br> * <br> * Return Value: <br> *  HRESULT         Whatever error code is appropriate. <br> */ <br> <br>HRESULT CPolyline::InPlaceActivate(LPOLECLIENTSITE pActiveSite <br>    , BOOL fIncludeUI) <br>    { <br>    HRESULT                 hr; <br>    HWND                    hWnd; <br>    HWND                    hWndHW; <br>    RECT                    rcPos; <br>    RECT                    rcClip; <br>    OLEINPLACEFRAMEINFO     frameInfo; <br> <br>    if (NULL==pActiveSite) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    if (NULL!=m_pIOleIPSite) <br>        { <br>        if (fIncludeUI) <br>            UIActivate(); <br> <br>        return NOERROR; <br>        } <br> <br> <br>    //1.  Initialization, obtaining interfaces, OnInPlaceActivate. <br>    hr=pActiveSite-&gt;QueryInterface(IID_IOleInPlaceSite <br>        , (PPVOID)&amp;m_pIOleIPSite); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=m_pIOleIPSite-&gt;CanInPlaceActivate(); <br> <br>    if (NOERROR!=hr) <br>        { <br>        m_pIOleIPSite-&gt;Release(); <br>        m_pIOleIPSite=NULL; <br>        return ResultFromScode(E_FAIL); <br>        } <br> <br>    m_pIOleIPSite-&gt;OnInPlaceActivate(); <br> <br> <br>    //2.  Get the window context and create a window. <br>    m_pIOleIPSite-&gt;GetWindow(&amp;hWnd); <br>    frameInfo.cb=sizeof(OLEINPLACEFRAMEINFO); <br> <br>    m_pIOleIPSite-&gt;GetWindowContext(&amp;m_pIOleIPFrame <br>        , &amp;m_pIOleIPUIWindow, &amp;rcPos, &amp;rcClip, &amp;frameInfo); <br> <br> <br>    /* <br>     * Create the hatch window after we get a parent window.  We <br>     * could not create the hatch window sooner because had nothing <br>     * to use for the parent. <br>     */ <br>    m_pHW=new CHatchWin(m_hInst); <br> <br>    if (NULL==m_pHW) <br>        { <br>        InPlaceDeactivate(); <br>        return ResultFromScode(E_OUTOFMEMORY); <br>        } <br> <br>    if (!m_pHW-&gt;Init(hWnd, ID_HATCHWINDOW, NULL)) <br>        { <br>        InPlaceDeactivate(); <br>        return ResultFromScode(E_OUTOFMEMORY); <br>        } <br> <br> <br>    //Make sure dialog is hidden <br>    if (NULL!=m_hDlg) <br>        { <br>        ShowWindow(m_hDlg, SW_HIDE); <br>        SendAdvise(OBJECTCODE_HIDEWINDOW); <br>        } <br> <br>    //Move the hatch window to the container window. <br>    hWndHW=m_pHW-&gt;Window(); <br>    SetParent(hWndHW, hWnd); <br> <br>    //Move the Polyline window from the hidden dialog to hatch window <br>    m_pHW-&gt;HwndAssociateSet(m_hWnd); <br>    m_pHW-&gt;ChildSet(m_hWnd); <br>    m_pHW-&gt;RectsSet(&amp;rcPos, &amp;rcClip);   //Positions polyline <br> <br>    ///CHAPTER24MOD <br>    //This might be off when we get to here. <br>    if (!m_fHatch) <br>        m_pHW-&gt;ShowHatch(FALSE); <br>    //End CHAPTER24MOD <br> <br>    ShowWindow(hWndHW, SW_SHOW); <br>    SendAdvise(OBJECTCODE_SHOWOBJECT); <br> <br>    //Critical for accelerators to work initially. <br>    SetFocus(hWndHW); <br> <br>    //3, 4, 5.  Do UI things: active object, shared menu, tools <br>    hr=NOERROR; <br> <br>    if (fIncludeUI) <br>        hr=UIActivate(); <br> <br>    /* <br>     * Since we don't have an Undo while in-place, tell the continer <br>     * to free it's undo state immediately. <br>     */ <br>    m_pIOleIPSite-&gt;DiscardUndoState(); <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::InPlaceDeactivate <br> * <br> * Purpose: <br> *  Reverses all the activation steps from InPlaceActivate. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::InPlaceDeactivate(void) <br>    { <br>    UIDeactivate(); <br> <br>    if (NULL!=m_pHW) <br>        { <br>        RECT        rc; <br> <br>        ShowWindow(m_pHW-&gt;Window(), SW_HIDE); <br> <br>        //Reposition the polyline window in the dialog box. <br>        SetParent(m_hWnd, m_hDlg); <br>        CalcPolyRectInDialog(m_hDlg, &amp;rc); <br> <br>        SetWindowPos(m_hWnd, NULL, rc.left, rc.top <br>            , rc.right-rc.left, rc.bottom-rc.top, SWP_NOZORDER); <br> <br>        m_pHW-&gt;ChildSet(NULL); <br> <br>        delete m_pHW; <br>        m_pHW=NULL; <br>        } <br> <br>    ReleaseInterface(m_pIOleIPFrame); <br>    ReleaseInterface(m_pIOleIPUIWindow) <br> <br>    if (NULL!=m_pIOleIPSite) <br>        { <br>        m_pIOleIPSite-&gt;OnInPlaceDeactivate(); <br>        ReleaseInterface(m_pIOleIPSite); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPolyline::UIActivate <br> * <br> * Purpose: <br> *  Goes through all the steps of activating the user interface of <br> *  Polyline as an in-place object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or error code. <br> */ <br> <br>HRESULT CPolyline::UIActivate(void) <br>    { <br>    //1.  Call IOleInPlaceSite::UIActivate <br>    if (NULL!=m_pIOleIPSite) <br>        m_pIOleIPSite-&gt;OnUIActivate(); <br> <br>    //2.  Set the active object <br>   #ifdef WIN32ANSI <br>    OLECHAR     szTemp[40]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, PSZ(IDS_USERTYPE) <br>        , -1, szTemp, 40); <br>   #endif <br> <br>    if (NULL!=m_pIOleIPFrame) <br>        { <br>        m_pIOleIPFrame-&gt;SetActiveObject(m_pImpIOleIPActiveObject <br>           #ifdef WIN32ANSI <br>            , szTemp); <br>           #else <br>            , PSZ(IDS_USERTYPE)); <br>           #endif <br>        } <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        { <br>        m_pIOleIPUIWindow-&gt;SetActiveObject(m_pImpIOleIPActiveObject <br>           #ifdef WIN32ANSI <br>            , szTemp); <br>           #else <br>            , PSZ(IDS_USERTYPE)); </code></pre>
<p>
</p>
<pre><code>#endif <br>        } <br> <br>    //3.  Critical for accelerators to work initially. <br>    SetFocus(m_pHW-&gt;Window()); <br> <br>    //4.  Negotiate border space.  Polyline doesn't need any. <br>    if (NULL!=m_pIOleIPFrame) <br>        m_pIOleIPFrame-&gt;SetBorderSpace(NULL); <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        m_pIOleIPUIWindow-&gt;SetBorderSpace(NULL); <br> <br> <br>    /* <br>     * 5.  Create the shared menu.  We don't have any, so tell <br>     *     the container to use its own menu. <br>     */ <br> <br>    if (NULL!=m_pIOleIPFrame) <br>        m_pIOleIPFrame-&gt;SetMenu(NULL, NULL, m_hWnd); <br> <br>    m_fUIActive=TRUE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::UIDeactivate <br> * <br> * Purpose: <br> *  Reverses all the user interface activation steps from <br> *  UIActivate. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::UIDeactivate(void) <br>    { <br>    m_fUIActive=FALSE; <br> <br>    //We don't have any shared menu or tools to clean up. <br> <br>    //Clear out the active objects <br>    if (NULL!=m_pIOleIPFrame) <br>        m_pIOleIPFrame-&gt;SetActiveObject(NULL, NULL); <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        m_pIOleIPUIWindow-&gt;SetActiveObject(NULL, NULL); <br> <br>    if (NULL!=m_pIOleIPSite) <br>        m_pIOleIPSite-&gt;OnUIDeactivate(FALSE); <br> <br>    return; <br>    } <br> <br> <br>//CHAPTER24MOD <br> <br>/* <br> * AmbientGet <br> * <br> * Purpose: <br> *  Retrieves a specific ambient property into a VARIANT. <br> * <br> * Parameters: <br> *  dispID          DISPID of the property to retrieve. <br> *  pva             VARIANT * to fill with the new value. <br> * <br> * Return value <br> *  BOOL            TRUE if the ambient was retrieved, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CPolyline::AmbientGet(DISPID dispID, VARIANT *pva) <br>    { <br>    HRESULT         hr; <br>    DISPPARAMS      dp; <br> <br>    if (NULL==pva) <br>        return FALSE; <br> <br>    if (NULL==m_pIDispatchAmbients) <br>        return FALSE; <br> <br>    SETNOPARAMS(dp); <br>    hr=m_pIDispatchAmbients-&gt;Invoke(dispID, IID_NULL <br>        , LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET <br>        , &amp;dp, pva, NULL, NULL); <br> <br>    return SUCCEEDED(hr); <br>    } <br> <br> <br>/* <br> * AmbientsInitialize <br> * <br> * Purpose: <br> *  Attempts to retrieve the container's ambient properties <br> *  and initialize (or reinitialize) Polyline accordingly. <br> * <br> * Parameters: <br> *  dwWhich         DWORD containing INITAMBIENT_... flags <br> *                  describing which ambients to initialize. <br> *                  This can be any combination. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::AmbientsInitialize(DWORD dwWhich) <br>    { <br>    VARIANT     va; <br>    COLORREF    cr; <br> <br>    if (NULL==m_pIDispatchAmbients) <br>        return; <br> <br>    /* <br>     * We need to retrieve these ambients into these variables: <br>     * <br>     *  Ambient Property:               Variable: <br>     *  ----------------------------------------------- <br>     *  DISPID_AMBIENT_SHOWHATCHING     m_fHatch <br>     *  DISPID_AMBIENT_UIDEAD           m_fUIDead <br>     *  DISPID_AMBIENT_BACKCOLOR        m_pl.rgbBackground <br>     *  DISPID_AMBIENT_FORECOLOR        m_pl.rgbLine <br>     */ <br> <br>    if ((INITAMBIENT_SHOWHATCHING &amp; dwWhich) <br>        &amp;&amp;AmbientGet(DISPID_AMBIENT_SHOWHATCHING, &amp;va)) <br>        { <br>        m_fHatch=V_BOOL(&amp;va); <br> <br>        if (NULL!=m_pHW) <br>            m_pHW-&gt;ShowHatch(m_fHatch); <br>        } <br> <br>    if ((INITAMBIENT_UIDEAD &amp; dwWhich) <br>        &amp;&amp; AmbientGet(DISPID_AMBIENT_UIDEAD, &amp;va)) <br>        { <br>        //This affects our detection of mouse clicks <br>        m_fUIDead=V_BOOL(&amp;va); <br>        } <br> <br>    if ((INITAMBIENT_BACKCOLOR &amp; dwWhich) <br>        &amp;&amp; AmbientGet(DISPID_AMBIENT_BACKCOLOR, &amp;va)) <br>        { <br>        cr=V_I4(&amp;va); <br> <br>        if (0x80000000 &amp; cr) <br>            cr=GetSysColor(cr &amp; 0x7FFFFFFF); <br> <br>        m_pl.rgbBackground=cr; <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        } <br> <br>    if ((INITAMBIENT_FORECOLOR &amp; dwWhich) <br>        &amp;&amp; AmbientGet(DISPID_AMBIENT_FORECOLOR, &amp;va)) <br>        { <br>        cr=V_I4(&amp;va); <br> <br>        if (0x80000000 &amp; cr) <br>            cr=GetSysColor(cr &amp; 0x7FFFFFFF); <br> <br>        m_pl.rgbLine=cr; <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        } <br> <br>    return; <br>    } <br> <br>//End CHAPTER24MOD </code></pre>
<p>&nbsp;</p></body>
</HTML>
