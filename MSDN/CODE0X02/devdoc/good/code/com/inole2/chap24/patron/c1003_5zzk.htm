<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EVENTS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1010"></a>EVENTS.CPP</h2>
<pre><code>/* <br> * EVENTS.CPP <br> * Patron Chapter 24 <br> * <br> * Implementation of the Events dialog box, the CEventMap class, <br> * and the events IDispatch on a tenant control site. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * EventsDlgProc <br> * <br> * Purpose: <br> *  Dialog procedure for the dialog in which the user can assign <br> *  actions to events. <br> */ <br> <br>BOOL APIENTRY EventsDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCEventMap      pEM=NULL; <br>    HWND            hList; <br>    UINT            i, iEvent; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>   #ifdef WIN32 <br>    pEM=(PCEventMap)GetProp(hDlg, PROP_POINTER); <br>   #else <br>    WORD            w1, w2; <br> <br>    w1=(WORD)GetProp(hDlg, PROP_SELECTOR); <br>    w2=(WORD)GetProp(hDlg, PROP_OFFSET); <br> <br>    pEM=(PCEventMap)MAKELP(w1, w2); <br>   #endif <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            pEM=(PCEventMap)lParam; <br> <br>           #ifdef WIN32 <br>            SetProp(hDlg, PROP_POINTER, (HANDLE)pEM); <br>           #else <br>            SetProp(hDlg, PROP_SELECTOR, (HANDLE)SELECTOROF(pEM)); <br>            SetProp(hDlg, PROP_OFFSET,   (HANDLE)OFFSETOF(pEM)); <br>           #endif <br> <br>            /* <br>             * Fill the listbox with events and select the first <br>             * one.  The selection will cause an LBN_SELCHANGE <br>             * notification which will set the appropriate <br>             * radiobutton for the action. <br>             */ <br> <br>            hList=GetDlgItem(hDlg, IDC_EVENTLIST); <br> <br>            for (i=0; i &lt; pEM-&gt;m_cEvents; i++) <br>                { <br>                //Add the name of the event to the list <br>               #ifdef WIN32ANSI <br>                char        szTemp[40]; <br> <br>                WideCharToMultiByte(CP_ACP, 0 <br>                    , pEM-&gt;m_pEventMap[i].bstrName, -1, szTemp <br>                    , 40, NULL, NULL); <br>                iEvent=(UINT)SendMessage(hList, LB_ADDSTRING, 0 <br>                    , (LONG)(LPSTR)szTemp); <br>               #else <br>                iEvent=(UINT)SendMessage(hList, LB_ADDSTRING, 0 <br>                    , (LONG)(LPSTR)pEM-&gt;m_pEventMap[i].bstrName); <br>               #endif <br> <br>                if (LB_ERR!=iEvent) <br>                    { <br>                    //Give that item a pointer to the map data <br>                    SendMessage(hList, LB_SETITEMDATA, iEvent <br>                        , (LONG)&amp;pEM-&gt;m_pEventMap[i]); <br>                    } <br>                } <br> <br>            //Set the initial action for the first item <br>            SendMessage(hList, LB_SETCURSEL, 0, 0L); <br>            CheckAction(hDlg, hList); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            hList=GetDlgItem(hDlg, IDC_EVENTLIST); <br> <br>            switch (wID) <br>                { <br>                case IDOK: <br>                    EndDialog(hDlg, 1); <br>                    break; <br> <br>                case ID_TEST: <br>                    TestSelection(hList); <br>                    break; <br> <br>                case IDC_EVENTLIST: <br>                    //Update the radiobuttons <br>                    if (LBN_SELCHANGE==wCode) <br>                        CheckAction(hDlg, hWndMsg); <br> <br>                    //Double-click, same as hitting Test button <br>                    if (LBN_DBLCLK==wCode) <br>                        TestSelection(GetDlgItem(hDlg, IDC_EVENTLIST)); <br>                    break; <br> <br>                case IDC_BEEPNONE: <br>                case IDC_BEEPDEFAULT: <br>                case IDC_BEEPEXCLAMATION: <br>                case IDC_BEEPASTERISK: <br>                case IDC_BEEPHAND: <br>                case IDC_BEEPQUESTION: <br>                    UpdateAction(hList, wID); <br>                    break; <br>                } <br>            return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br>/* <br> * CheckAction <br> * <br> * Purpose: <br> *  Sets the appropriate radiobutton for the current listbox <br> *  selection <br> * <br> * Parameters: <br> *  hDlg            HWND of the dialog. <br> *  hList           HWND of the event list. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CheckAction(HWND hDlg, HWND hList) <br>    { <br>    UINT        i, idControl; <br>    PEVENTMAP   pMap; <br> <br>    i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L); <br>    pMap=(PEVENTMAP)SendMessage(hList, LB_GETITEMDATA, i, 0L); <br> <br>    if (LB_ERR==(LONG)pMap) <br>        return; <br> <br>    //Map the action to the button <br>    switch (pMap-&gt;iAction) <br>        { <br>        case ACTION_NONE:            idControl=IDC_BEEPNONE; break; <br>        case ACTION_BEEPDEFAULT:     idControl=IDC_BEEPDEFAULT; break; <br>        case ACTION_BEEPASTERISK:    idControl=IDC_BEEPASTERISK; break; <br>        case ACTION_BEEPEXCLAMATION: idControl=IDC_BEEPEXCLAMATION; break; <br>        case ACTION_BEEPHAND:        idControl=IDC_BEEPHAND; break; <br>        case ACTION_BEEPQUESTION:    idControl=IDC_BEEPQUESTION; break; <br>        default:                     idControl=IDC_BEEPNONE; break; <br>        } <br> <br>    CheckRadioButton(hDlg, IDC_BEEPNONE, IDC_BEEPQUESTION, idControl); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * UpdateAction <br> * <br> * Purpose: <br> *  Sets the appropriate action in the event map for the <br> *  selected radiobutton. <br> * <br> * Parameters: <br> *  hList           HWND of the event list. <br> *  idControl       UINT identifier of the selected action control <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void UpdateAction(HWND hList, UINT idControl) <br>    { <br>    UINT        i; <br>    PEVENTMAP   pMap; <br> <br>    i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L); <br>    pMap=(PEVENTMAP)SendMessage(hList, LB_GETITEMDATA, i, 0L); <br> <br>    if (LB_ERR==(LONG)pMap) <br>        return; <br> <br>    //Map the button to the action <br>    switch (idControl) <br>        { <br>        case IDC_BEEPNONE:        pMap-&gt;iAction=ACTION_NONE; break; <br>        case IDC_BEEPDEFAULT:     pMap-&gt;iAction=ACTION_BEEPDEFAULT; break; <br>        case IDC_BEEPASTERISK:    pMap-&gt;iAction=ACTION_BEEPASTERISK; break; <br>        case IDC_BEEPEXCLAMATION: pMap-&gt;iAction=ACTION_BEEPEXCLAMATION; break; <br>        case IDC_BEEPHAND:        pMap-&gt;iAction=ACTION_BEEPHAND; break; <br>        case IDC_BEEPQUESTION:    pMap-&gt;iAction=ACTION_BEEPQUESTION; break; <br>        default:                  pMap-&gt;iAction=ACTION_NONE; break; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * TestSelection <br> * <br> * Purpose: <br> *  Executes the action associated with the currently selected <br> *  event. <br> * <br> * Parameters: <br> *  hList           HWND of the event list. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void TestSelection(HWND hList) <br>    { <br>    UINT        i; <br>    PEVENTMAP   pMap; <br> <br>    i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L); <br>    pMap=(PEVENTMAP)SendMessage(hList, LB_GETITEMDATA, i, 0L); <br> <br>    //Event values corresond to MessageBeep values. <br>    if (LB_ERR!=(LONG)pMap) <br>        MessageBeep(pMap-&gt;iAction); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CEventMap implementations <br> <br> <br>/* <br> * CEventMap::CEventMap <br> * CEventMap::~CEventMap <br> * <br> * Parameters (Constructor): <br> *  pITypeInfo      LPTYPEINFO from which to read event names. <br> */ <br> <br>CEventMap::CEventMap(LPTYPEINFO pITypeInfo) <br>    { <br>    m_cEvents=0; <br>    m_pITypeInfo=pITypeInfo; <br>     <br>    if (NULL!=m_pITypeInfo) <br>        m_pITypeInfo-&gt;AddRef(); <br> <br>    m_pEventMap=NULL; <br>    return; <br>    } <br> <br> <br> <br> <br>CEventMap::~CEventMap(void) <br>    { <br>    if (NULL!=m_pITypeInfo) <br>        m_pITypeInfo-&gt;Release(); <br> <br>    if (NULL!=m_pEventMap) <br>        { <br>        UINT        i; <br> <br>        //Be sure to clean up allocated BSTRs <br>        for (i=0; i &lt; m_cEvents; i++) <br>            SysFreeString(m_pEventMap[i].bstrName); <br> <br>        delete [] m_pEventMap; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CEventMap::Init <br> * <br> * Purpose: <br> *  Initializes the event map with any operation prone to failure. <br> *  If this function fails, the caller should delete this object <br> *  immediately as it is unusable. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, FALSE otherwise <br> */ <br> <br>BOOL CEventMap::Init(void) <br>    { <br>    LPTYPEATTR      pTA; <br>    UINT            i; <br> <br>    if (NULL==m_pITypeInfo) <br>        return FALSE; <br> <br>    if (FAILED(m_pITypeInfo-&gt;GetTypeAttr(&amp;pTA))) <br>        return FALSE; <br> <br>    m_cEvents=pTA-&gt;cFuncs; <br>    m_pITypeInfo-&gt;ReleaseTypeAttr(pTA); <br> <br>    m_pEventMap=new EVENTMAP[m_cEvents]; <br> <br>    if (NULL==m_pEventMap) <br>        { <br>        m_cEvents=0; <br>        return FALSE; <br>        } <br> <br>    for (i=0; i &lt; m_cEvents; i++) <br>        { <br>        LPFUNCDESC     pFD; <br> <br>        m_pEventMap[i].id=0; <br>        m_pEventMap[i].bstrName=NULL; <br>        m_pEventMap[i].iAction=ACTION_NONE; <br> <br>        /* <br>         * The only piece of information we want from for each <br>         * event is the function name using ITypeInfo::GetNames. <br>         * <br>         * A more sophisticated container will probably save <br>         * more information about each event here (such as <br>         * parameter names and so forth) or access it dynamically <br>         * when the end user wants to write code for events. <br>         */ <br> <br>        if (SUCCEEDED(m_pITypeInfo-&gt;GetFuncDesc(i, &amp;pFD))) <br>            { <br>            UINT        cNames; <br>            HRESULT     hr; <br> <br>            /* <br>             * Since we only want the function name, we ask <br>             * ITypeInfo::GetNames for only one function and pass <br>             * the address of our one BSTR to it.  If we wanted all <br>             * the names from ITypeInfo, then we'd allocate an <br>             * array of BSTRs with "new BSTR[pFD-&gt;cParams+1]" <br>             * and pass pFD-&gt;cParams+1 to GetNames below instead <br>             * of just 1.  In either case, GetNames allocates <br>             * the string and stores the pointer to it in our <br>             * variable. <br>             */ <br> <br>            m_pEventMap[i].id=pFD-&gt;memid; <br> <br>            hr=m_pITypeInfo-&gt;GetNames(pFD-&gt;memid <br>                , &amp;m_pEventMap[i].bstrName, 1, &amp;cNames); <br> <br>            m_pITypeInfo-&gt;ReleaseFuncDesc(pFD); <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CEventMap::Set <br> * <br> * Purpose: <br> *  Sets the event mapping of a specific ID to a given action. <br> *  To clear an event, call this function with the ID and <br> *  ACTION_NONE. <br> * <br> * Parameters: <br> *  id              DISPID of the event ID. <br> *  iAction         EVENTACTION to assign. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the assignment happened, FALSE otherwise. <br> */ <br> <br>BOOL CEventMap::Set(DISPID id, EVENTACTION iAction) <br>    { <br>    BOOL        fRet=FALSE; <br> <br>    if (NULL!=m_pEventMap) <br>        { <br>        UINT        i; <br> <br>        for (i=0; i &lt; m_cEvents; i++) <br>            { <br>            if (m_pEventMap[i].id==id) <br>                { <br>                m_pEventMap[i].iAction=iAction; <br>                fRet=TRUE; <br>                } <br>            } <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CEventMap::Get <br> * <br> * Purpose: <br> *  Retrieves the event assignment for a given ID. <br> * <br> * Parameters: <br> *  id              DISPID of the event ID. <br> * <br> * Return Value: <br> *  EVENTACTION     The action assigned to this ID.  ACTION_NONE <br> *                  if the ID is invalid. <br> */ <br> <br>EVENTACTION CEventMap::Get(DISPID id) <br>    { <br>    EVENTACTION iAction=ACTION_NONE; <br> <br>    if (NULL!=m_pEventMap) <br>        { <br>        UINT        i; <br> <br>        //Scan the list looking for the event <br>        for (i=0; i &lt; m_cEvents; i++) <br>            { <br>            if (m_pEventMap[i].id==id) <br>                { <br>                iAction=m_pEventMap[i].iAction; <br>                break; <br>                } <br>            } <br>        } <br> <br>    return iAction; <br>    } <br> <br> <br> <br> <br>/* <br> * CEventMap::Serialize <br> * CEventMap::Deserialize <br> * <br> * Purpose: <br> *  Writes or reads the mappings from DISPID to actions <br> *  into or from a stream. <br> * <br> * Parameters: <br> *  pIStream        LPSTREAM into which to write or from which to <br> *                  read. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CEventMap::Serialize(LPSTREAM pIStream) <br>    { <br>    EVENTMAP        emTemp; <br>    ULONG           cbWrite=sizeof(DISPID)+sizeof(EVENTACTION); <br> <br>    if (NULL==pIStream) <br>        return; <br> <br>    /* <br>     * Loop through all the IDs and write the ID and the action <br>     * mapping only.  We don't need the event name because that <br>     * will be retrieved when the control is again loaded. <br>     * <br>     * Writing these pieces of info means writing the first <br>     * so many bytes of each EVENTMAP structure, ignoring the <br>     * BSTR of the name. <br>     */ <br> <br>    if (NULL!=m_pEventMap) <br>        { <br>        UINT        i; <br> <br>        for (i=0; i &lt; m_cEvents; i++) <br>            pIStream-&gt;Write(&amp;m_pEventMap[i], cbWrite, NULL); <br>        } <br> <br>    /* <br>     * Finish off by writing a terminating EVENTMAP structure <br>     * where the action is ACTION_TAILING which only have <br>     * meaning here.  The ID is ignored in this tail. <br>     */ <br> <br>    emTemp.id=0; <br>    emTemp.iAction=ACTION_TAILING; <br>    pIStream-&gt;Write(&amp;emTemp, cbWrite, NULL); <br> <br>    return; <br>    } <br> <br> <br> <br>void CEventMap::Deserialize(LPSTREAM pIStream) <br>    { <br>    if (NULL==pIStream) <br>        return; <br> <br>    /* <br>     * When reading back the event mappings we have to be <br>     * careful:  the control's event set might have changed <br>     * in the meantime so some events may no longer exist and <br>     * there may be new events.  Therefore we read each mapping <br>     * one at a time (until we hit the tailing map) and find <br>     * the ID in the current memory event map.  When we find <br>     * a match we update the action in memory. <br>     */ <br> <br>    if (NULL==m_pEventMap) <br>        return; <br> <br>    while (TRUE) <br>        { <br>        ULONG       cbRead=sizeof(DISPID)+sizeof(EVENTACTION); <br>        HRESULT     hr; <br>        EVENTMAP    em; <br> <br>        hr=pIStream-&gt;Read(&amp;em, cbRead, NULL); <br> <br>        //Failure to read means a stream problem, to abort <br>        if (FAILED(hr)) <br>            break; <br> <br>        //If we hit the tail, we're done <br>        if (ACTION_TAILING==em.iAction) <br>            break; <br> <br>        //Assign the action to the ID, if it exists <br>        Set(em.id, em.iAction); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>//Events IDispatch <br> <br>/* <br> * CDispatchEvents::CDispatchEvents <br> * CDispatchEvents::~CDispatchEvents <br> * <br> * Parameters (Constructor): <br> *  pTen            PCTenant of the tenant we're in. <br> */ <br> <br>CDispatchEvents::CDispatchEvents(PCTenant pTen) <br>    { <br>    m_cRef=0; <br>    m_pTen=pTen; <br>    return; <br>    } <br> <br>CDispatchEvents::~CDispatchEvents(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CDispatchEvents::QueryInterface <br> * CDispatchEvents::AddRef <br> * CDispatchEvents::Release <br> * <br> * Purpose: <br> *  IUnknown members for CDispatchEvents object. <br> */ <br> <br>STDMETHODIMP CDispatchEvents::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IDispatch==riid <br>        || m_pTen-&gt;m_iidEvents==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CDispatchEvents::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CDispatchEvents::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDispatchEvents::GetTypeInfoCount <br> * CDispatchEvents::GetTypeInfo <br> * CDispatchEvents::GetIDsOfNames <br> * <br> * Purpose: <br> *  These type-information functions are not implemented.  The <br> *  only caller of this interface is a control which is the source <br> *  of the type information itself.  A control will not have a <br> *  need to call these functions. <br> * <br> * Return Value: <br> *  HRESULT         E_NOTIMPL in all cases. <br> */ <br> <br>STDMETHODIMP CDispatchEvents::GetTypeInfoCount(UINT *pctInfo) <br>    { <br>    *pctInfo=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br>STDMETHODIMP CDispatchEvents::GetTypeInfo(UINT itinfo <br>    , LCID lcid, ITypeInfo **pptInfo) <br>    { <br>    *pptInfo=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br>STDMETHODIMP CDispatchEvents::GetIDsOfNames(REFIID riid <br>    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID) <br>    { <br>    *rgszNames=NULL; <br>    *rgDispID=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br>/* <br> * CDispatchEvents::Invoke <br> * <br> * Purpose: <br> *  Notifies the container of the event in the control.  In this <br> *  container we look in the event mapping for this particular <br> *  site and execute the appropriate action recorded in that <br> *  mapping.  If there is no event handler set up, then nothing <br> *  happens. <br> * <br> * Parameters: <br> *  dispIDMember    DISPID of the method or property of interest. <br> *  riid            REFIID reserved, must be NULL. <br> *  lcid            LCID of the locale. <br> *  wFlags          USHORT describing the context of the invocation. <br> *  pDispParams     DISPPARAMS * to the array of arguments. <br> *  pVarResult      VARIANT * in which to store the result.  Is <br> *                  NULL if the caller is not interested. <br> *  pExcepInfo      EXCEPINFO * to exception information. <br> *  puArgErr        UINT * in which to store the index of an <br> *                  invalid parameter if DISP_E_TYPEMISMATCH <br> *                  is returned. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error code. <br> */ <br> <br> <br>STDMETHODIMP CDispatchEvents::Invoke(DISPID dispIDMember, REFIID riid <br>    , LCID lcid, unsigned short wFlags, DISPPARAMS * pDispParams <br>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) <br>    { <br>    HRESULT     hr; <br>    VARIANT     varResult; <br>    EVENTACTION iAction; <br>    UINT        i; <br>    PEVENTMAP  pEM; <br> <br>    ODSlu("Events IDispatch called with ID=%lu", dispIDMember); <br> <br>    if (IID_NULL!=riid) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    /* <br>     * We ignore lcid in this function.  A multilingual application <br>     * might use it to determine the meaning of certain parameters <br>     * or perhaps as an indication of how to format data like <br>     * time, date, and currency or any other language or locale- <br>     * sensitive data. <br>     */ <br> <br>    /* <br>     * Variable handling:  we don't actually do anything with any <br>     * of the variables from the control's events, so we don't have <br>     * any VARIANTARG variables to initialize. <br>     */ <br> <br>    /* <br>     * We don't handle the return value of any events if <br>     * events have them.  We should, however, initialize an <br>     * empty return value just so it's not garbage. <br>     */ <br>    if(NULL==pVarResult) <br>      pVarResult=&amp;varResult; <br> <br>    VariantInit(pVarResult); <br>    V_VT(pVarResult)=VT_EMPTY; <br> <br> <br>    //Only method calls are valid. <br>    if (!(DISPATCH_METHOD &amp; wFlags)) <br>        return ResultFromScode(DISP_E_MEMBERNOTFOUND); <br> <br>    /* <br>     * Process the event by looking for dispIDMember in the <br>     * list maintained in the tenant that maps event IDs to <br>     * actions.  If we find the ID, then we execute the action, <br>     * otherwise we do nothing. <br>     * <br>     * Control containers that allow more sophisticated programming <br>     * for events would do something on the same order but process <br>     * parameters and call user-implemented functions instead of <br>     * something simple like MessageBeep. <br>     */ <br> <br>    iAction=ACTION_NONE; <br>    pEM=m_pTen-&gt;m_pEventMap-&gt;m_pEventMap; <br> <br>    for (i=0; i &lt; m_pTen-&gt;m_pEventMap-&gt;m_cEvents; i++) <br>        { <br>        if (dispIDMember==pEM[i].id) <br>            { <br>            iAction=pEM[i].iAction; <br>            break; <br>            } <br>        } <br> <br>    if (ACTION_NONE==iAction) <br>        hr=ResultFromScode(DISP_E_MEMBERNOTFOUND); <br>    else <br>        { <br>        MessageBeep((UINT)iAction); <br>        hr=NOERROR; <br>        } <br> <br>    return hr; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
