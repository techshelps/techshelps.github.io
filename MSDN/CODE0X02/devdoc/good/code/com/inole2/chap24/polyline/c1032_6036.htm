<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONTROL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1032"></a>CONTROL.CPP</h2>
<pre><code>/* <br> * CONTROL.CPP <br> * Polyline Chapter 24 <br> * <br> * Additional interfaces above the Chapter 23 version of Polyline <br> * to make it an OLE Control, specifically ISpecifyPropertyPages, <br> * IProvideClassInfo, IOleControl, and IDispatch, none of which <br> * are terribly complex. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>//ISpecifyPropertyPages implementation <br>/* <br> * CImpISpecifyPP::CImpISpecifyPP <br> * CImpISpecifyPP::~CImpISpecifyPP <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpISpecifyPP::CImpISpecifyPP(PCPolyline pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpISpecifyPP::~CImpISpecifyPP(void) <br>    { <br>    return; <br>    } <br> <br> <br>/* <br> * CImpISpecifyPP::QueryInterface <br> * CImpISpecifyPP::AddRef <br> * CImpISpecifyPP::Release <br> */ <br> <br>STDMETHODIMP CImpISpecifyPP::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpISpecifyPP::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpISpecifyPP::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpISpecifyPP::GetPages <br> * <br> * Purpose: <br> *  Returns an array of GUIDs identifying the indivudual property <br> *  pages used for this object. <br> * <br> * Parameters: <br> *  pPages          CAUUID * pointing to a counted array of GUIDs. <br> *                  This function allocates the array elements <br> *                  and stores them in this structure. <br> */ <br> <br>STDMETHODIMP CImpISpecifyPP::GetPages(CAUUID *pPages) <br>    { <br>    IMalloc *pIMalloc; <br>    GUID    *pGUID; <br> <br>    pPages-&gt;cElems=0; <br>    pPages-&gt;pElems=NULL; <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    pGUID=(GUID *)pIMalloc-&gt;Alloc(CPROPPAGES * sizeof(GUID)); <br> <br>    if (NULL!=pGUID) <br>        { <br>        //We use our own page plus the standard color page. <br>        pGUID[0]=CLSID_PolylinePropPage; <br> <br>        //Fill the structure and return. <br>        pPages-&gt;cElems=CPROPPAGES; <br>        pPages-&gt;pElems=pGUID; <br>        } <br> <br>    pIMalloc-&gt;Release(); <br>    return (NULL!=pGUID) ? NOERROR <br>        : ResultFromScode(E_OUTOFMEMORY); <br>    } <br> <br> <br> <br> <br>//IProvideClassInfo interface implementation <br>/* <br> * CImpIProvideClassInfo::CImpIProvideClassInfo <br> * CImpIProvideClassInfo::~CImpIProvideClassInfo <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIProvideClassInfo::CImpIProvideClassInfo(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIProvideClassInfo::~CImpIProvideClassInfo(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIProvideClassInfo::QueryInterface <br> * CImpIProvideClassInfo::AddRef <br> * CImpIProvideClassInfo::Release <br> */ <br> <br>STDMETHODIMP CImpIProvideClassInfo::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIProvideClassInfo::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIProvideClassInfo::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIProvideClassInfo::GetClassInfo <br> * <br> * Purpose: <br> *  Returns the ITypeInfo through which the caller can retrieve <br> *  information about the entire object. <br> * <br> * Parameters: <br> *  ppTI            LPTYPEINFO * in which to store the ITypeInfo <br> *                  pointer. <br> */ <br> <br>STDMETHODIMP CImpIProvideClassInfo::GetClassInfo(LPTYPEINFO *ppTI) <br>    { <br>    if (NULL==ppTI) <br>        return ResultFromScode(E_POINTER); <br> <br>    *ppTI=NULL; <br> <br>    return m_pObj-&gt;m_pITypeLib-&gt;GetTypeInfoOfGuid(CLSID_Polyline19 <br>        , ppTI); <br>    } <br> <br> <br> <br> <br>//IDispatch interface implementation <br> <br>/* <br> * CImpIDispatch::CImpIDispatch <br> * CImpIDispatch::~CImpIDispatch <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIDispatch::CImpIDispatch(PCPolyline pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIDispatch::~CImpIDispatch(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::QueryInterface <br> * CImpIDispatch::AddRef <br> * CImpIDispatch::Release <br> */ <br> <br>STDMETHODIMP CImpIDispatch::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CImpIDispatch::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIDispatch::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::GetTypeInfoCount <br> * CImpIDispatch::GetTypeInfo <br> * CImpIDispatch::GetIDsOfNames <br> * <br> * The usual <br> */ <br> <br>STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo) <br>    { <br>    //We implement GetTypeInfo so return 1 <br>    *pctInfo=1; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid <br>    , ITypeInfo **ppITypeInfo) <br>    { <br>    if (0!=itInfo) <br>        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND); <br> <br>    if (NULL==ppITypeInfo) <br>        return ResultFromScode(E_POINTER); <br> <br>    *ppITypeInfo=NULL; <br> <br>    //We ignore the LCID <br>    return m_pObj-&gt;m_pITypeLib-&gt;GetTypeInfoOfGuid <br>        (DIID_DIPolylineControl, ppITypeInfo); <br>    } <br> <br> <br>STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid <br>    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID) <br>    { <br>    HRESULT     hr; <br>    ITypeInfo  *pTI; <br> <br>    if (IID_NULL!=riid) <br>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE); <br> <br>    hr=GetTypeInfo(0, lcid, &amp;pTI); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID); <br>        pTI-&gt;Release(); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::Invoke <br> * <br> * Purpose: <br> *  Calls a method in the dispatch interface or manipulates a <br> *  property. <br> * <br> * Parameters: <br> *  dispID          DISPID of the method or property of interest. <br> *  riid            REFIID reserved, must be IID_NULL. <br> *  lcid            LCID of the locale. <br> *  wFlags          USHORT describing the context of the invocation. <br> *  pDispParams     DISPPARAMS * to the array of arguments. <br> *  pVarResult      VARIANT * in which to store the result.  Is <br> *                  NULL if the caller is not interested. <br> *  pExcepInfo      EXCEPINFO * to exception information. <br> *  puArgErr        UINT * in which to store the index of an <br> *                  invalid parameter if DISP_E_TYPEMISMATCH <br> *                  is returned. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error code. <br> */ <br> <br>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid <br>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams <br>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) <br>    { <br>    HRESULT     hr; <br>    ITypeInfo  *pTI; <br> <br>    //riid is supposed to be IID_NULL always <br>    if (IID_NULL!=riid) <br>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE); <br> <br>    //Get the ITypeInfo for lcid <br>    hr=GetTypeInfo(0, lcid, &amp;pTI); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=pTI-&gt;Invoke(m_pObj-&gt;m_pImpIPolylineControl, dispID, wFlags <br>        , pDispParams, pVarResult, pExcepInfo, puArgErr); <br> <br>    pTI-&gt;Release(); <br>    return hr; <br>    } <br> <br> <br> <br>//IPolylineControl interface implementation <br> <br>/* <br> * CImpIPolylineControl::CImpIPolylineControl <br> * CImpIPolylineControl::~CImpIPolylineControl <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIPolylineControl::CImpIPolylineControl(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIPolylineControl::~CImpIPolylineControl(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIPolylineControl::QueryInterface <br> * CImpIPolylineControl::AddRef <br> * CImpIPolylineControl::Release <br> */ <br> <br>STDMETHODIMP CImpIPolylineControl::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPolylineControl::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPolylineControl::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIPolylineControl::BackColor <br> * CImpIPolylineControl::LineColor <br> * CImpIPolylineControl::LineStyle <br> * CImpIPolylineControl::Clear <br> * CImpIPolylineControl::RemoveLastPoint <br> * <br> * Purpose: <br> *  Dispatch interface entry points that map to IPolyline <br> *  members. <br> */ <br> <br>STDMETHODIMP_(void) CImpIPolylineControl::put_BackColor <br>    (OLE_COLOR cr) <br>    { <br>    COLORREF        crOld; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;ColorSet(POLYLINECOLOR_BACKGROUND <br>        , cr, &amp;crOld); <br>    return; <br>    } <br> <br>STDMETHODIMP_(OLE_COLOR) CImpIPolylineControl::get_BackColor(void) <br>    { <br>    COLORREF        cr; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;ColorGet(POLYLINECOLOR_BACKGROUND <br>        , &amp;cr); <br> <br>    return cr; <br>    } <br> <br>STDMETHODIMP_(void) CImpIPolylineControl::put_LineColor <br>    (OLE_COLOR cr) <br>    { <br>    COLORREF        crOld; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;ColorSet(POLYLINECOLOR_LINE <br>        , cr, &amp;crOld); <br> <br>    return; <br>    } <br> <br>STDMETHODIMP_(OLE_COLOR) CImpIPolylineControl::get_LineColor(void) <br>    { <br>    COLORREF        cr; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;ColorGet(POLYLINECOLOR_LINE, &amp;cr); <br>    return cr; <br>    } <br> <br>STDMETHODIMP_(void) CImpIPolylineControl::put_LineStyle <br>    (short iStyle) <br>    { <br>    UINT    i; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;LineStyleSet(iStyle, &amp;i); <br>    return; <br>    } <br> <br>STDMETHODIMP_(short) CImpIPolylineControl::get_LineStyle(void) <br>    { <br>    UINT    iStyle; <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;LineStyleGet(&amp;iStyle); <br>    return (short)iStyle; <br>    } <br> <br>STDMETHODIMP CImpIPolylineControl::Clear(void) <br>    { <br>    return m_pObj-&gt;m_pImpIPolyline-&gt;New(); <br>    } <br> <br>STDMETHODIMP CImpIPolylineControl::RemoveLastPoint(void) <br>    { <br>    return m_pObj-&gt;m_pImpIPolyline-&gt;Undo(); <br>    } <br> <br> <br> <br> <br> <br> <br>//IOleControl interface implementation <br> <br>/* <br> * CImpIOleControl::CImpIOleControl <br> * CImpIOleControl::~CImpIOleControl <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIOleControl::CImpIOleControl(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIOleControl::~CImpIOleControl(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIOleControl::QueryInterface <br> * CImpIOleControl::AddRef <br> * CImpIOleControl::Release <br> */ <br> <br>STDMETHODIMP CImpIOleControl::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleControl::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleControl::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIOleControl::GetControlInfo <br> * <br> * Purpose: <br> *  Fills a CONTROLINFO structure containing information about <br> *  the controls mnemonics and other behavioral aspects. <br> * <br> * Parameters: <br> *  pCI             LPCONTROLINFO to the structure to fill <br> */ <br> <br>STDMETHODIMP CImpIOleControl::GetControlInfo(LPCONTROLINFO pCI) <br>    { <br>    if (NULL==pCI) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    *pCI=m_pObj-&gt;m_ctrlInfo; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleControl::OnMnemonic <br> * <br> * Purpose: <br> *  Notifies the control that a mnemonic was activated. <br> * <br> * Parameters: <br> *  pMsg            LPMSG containing the message that matches one of <br> *                  the control's mnemonics.  The control uses this <br> *                  to distinguish which mnemonic was pressed. <br> */ <br> <br>STDMETHODIMP CImpIOleControl::OnMnemonic(LPMSG pMsg) <br>    { <br>    //No mnemonics <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleControl::OnAmbientPropertyChange <br> * <br> * Purpose: <br> *  Notifies the control that one or more of the container's ambient <br> *  properties changed. <br> * <br> * Parameters: <br> *  dispID          DISPID identifying the property, which can <br> *                  be DISPID_UNKNOWN indicating that more than <br> *                  one changed. <br> */ <br> <br>STDMETHODIMP CImpIOleControl::OnAmbientPropertyChange(DISPID dispID) <br>    { <br>    /* <br>     * We detect any change in UIDead or ShowHatching.  Changes <br>     * in container colors do not affect us as we only use those <br>     * for initial values. <br>     */ <br> <br>    switch (dispID) <br>        { <br>        case DISPID_UNKNOWN: <br>            m_pObj-&gt;AmbientsInitialize(INITAMBIENT_SHOWHATCHING <br>                | INITAMBIENT_UIDEAD); <br>            break; <br> <br>        case DISPID_AMBIENT_SHOWHATCHING: <br>            m_pObj-&gt;AmbientsInitialize(INITAMBIENT_SHOWHATCHING); <br>            break; <br> <br>        case DISPID_AMBIENT_UIDEAD: <br>            m_pObj-&gt;AmbientsInitialize(INITAMBIENT_UIDEAD); <br>            break; <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleControl::FreezeEvents <br> * <br> * Purpose: <br> *  Instructs the control to stop firing events or to continue <br> *  firing them. <br> * <br> * Parameters: <br> *  fFreeze         BOOL indicating to freeze (TRUE) or thaw (FALSE) <br> *                  events from this control. <br> */ <br> <br>STDMETHODIMP CImpIOleControl::FreezeEvents(BOOL fFreeze) <br>    { <br>    m_pObj-&gt;m_fFreezeEvents=fFreeze; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>//CAdviseRouter class implementation <br>/* <br> * CAdviseRouter::CAdviseRouter <br> * CAdviseRouter::~CAdviseRouter <br> * <br> * Constructor Parameters: <br> *  pIDispatch      IDispatch * to which we route notifications. <br> *  pObj            PCPolyline to the control itself. <br> */ <br> <br>CAdviseRouter::CAdviseRouter(IDispatch *pIDispatch <br>    , PCPolyline pObj) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pIDispatch=pIDispatch; <br>    return; <br>    } <br> <br> <br>CAdviseRouter::~CAdviseRouter(void) <br>    { <br>    ReleaseInterface(m_pIDispatch); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAdviseRouter::QueryInterface <br> * CAdviseRouter::AddRef <br> * CAdviseRouter::Release <br> * <br> * Purpose: <br> *  IUnknown members for this IPolylineAdviseSink implementations. <br> */ <br> <br>STDMETHODIMP CAdviseRouter::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IPolylineAdviseSink10==riid) <br>        { <br>        *ppv=this; <br>        AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CAdviseRouter::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CAdviseRouter::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br>/* <br> * CAdviseRouter::OnPointChange <br> * CAdviseRouter::OnSizeChange <br> * CAdviseRouter::OnColorChange <br> * CAdviseRouter::OnLineStyleChange <br> * <br> * Purpose: <br> *  Invokes the same member in the IDispatch pointer we hold. <br> */ <br> <br>STDMETHODIMP_(void) CAdviseRouter::OnPointChange(void) <br>    { <br>    Invoke(EVENT_ONPOINTCHANGE); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CAdviseRouter::OnSizeChange(void) <br>    { <br>    Invoke(EVENT_ONSIZECHANGE); <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(void) CAdviseRouter::OnColorChange(void) <br>    { <br>    Invoke(EVENT_ONCOLORCHANGE); <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(void) CAdviseRouter::OnLineStyleChange(void) <br>    { <br>    Invoke(EVENT_ONLINESTYLECHANGE); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAdviseRouter::Invoke <br> * <br> * Purpose: <br> *  Calls IDispatch::Invoke for any of the events we handle. <br> *  None of these have any arguments. <br> * <br> * Parameters: <br> *  dispID          DISPID of the event to fire. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CAdviseRouter::Invoke(DISPID dispID) <br>    { <br>    DISPPARAMS  dp; <br>    VARIANT     va; <br> <br>    if (m_pObj-&gt;m_fFreezeEvents) <br>        return; <br> <br>    m_pIDispatch-&gt;Invoke(dispID, IID_NULL <br>        , LOCALE_USER_DEFAULT, DISPATCH_METHOD, &amp;dp <br>        , &amp;va, NULL, NULL); <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
