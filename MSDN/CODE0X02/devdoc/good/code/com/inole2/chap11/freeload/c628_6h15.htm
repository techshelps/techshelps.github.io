<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context629"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Freeloader Chapter 11 <br> * <br> * Implementation of the CFreeloaderDoc derivation of CDocument. <br> * We create a default handler object and use it for drawing, data <br> * caching, and serialization. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "freeload.h" <br> <br> <br>/* <br> * CFreeloaderDoc::CFreeloaderDoc <br> * CFreeloaderDoc::~CFreeloaderDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events <br> */ <br> <br>CFreeloaderDoc::CFreeloaderDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pIStorage=NULL; <br>    m_pIUnknown=NULL; <br>    m_dwConn=0; <br>    m_clsID=CLSID_NULL; <br>    return; <br>    } <br> <br> <br>CFreeloaderDoc::~CFreeloaderDoc(void) <br>    { <br>    ReleaseObject(); <br>    ReleaseInterface(m_pIStorage); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::ReleaseObject <br> * <br> * Purpose: <br> *  Centralizes cleanup code for the object and its cache. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFreeloaderDoc::ReleaseObject(void) <br>    { <br>    LPOLECACHE      pIOleCache; <br>    HRESULT         hr; <br> <br>    if (0!=m_dwConn) <br>        { <br>        hr=m_pIUnknown-&gt;QueryInterface(IID_IOleCache <br>            , (PPVOID)&amp;pIOleCache); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            pIOleCache-&gt;Uncache(m_dwConn); <br>            pIOleCache-&gt;Release(); <br>            } <br>        } <br> <br>    ReleaseInterface(m_pIUnknown); <br>    CoFreeUnusedLibraries(); <br>    m_dwConn=0; <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CFreeloaderDoc::FInit <br> * <br> * Purpose: <br> *  Initializes an already created document window.  Here we <br> *  only change the stringtable bounds. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::FInit(PDOCUMENTINIT pDI) <br>    { <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    return CDocument::Init(pDI); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_PAINT for the document so we can draw the object. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::FMessageHook(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam, LRESULT *pLRes) <br>    { <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    RECT            rc; <br>    RECTL           rcl; <br>    LPVIEWOBJECT2   pIViewObject2; <br>    HRESULT         hr; <br> <br>    if (WM_PAINT!=iMsg) <br>        return FALSE; <br> <br>    hDC=BeginPaint(hWnd, &amp;ps); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    //Draw the object with IViewObject2::Draw, allowing ESC <br>    if (NULL!=m_pIUnknown) <br>        { <br>        hr=m_pIUnknown-&gt;QueryInterface(IID_IViewObject2 <br>            , (PPVOID)&amp;pIViewObject2); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Put "Hit Esc to stop" in the status line <br>            m_pFR-&gt;StatusLine()-&gt;MessageSet(PSZ(IDS_HITESCTOSTOP)); <br> <br>            RECTLFROMRECT(rcl, rc); <br>            pIViewObject2-&gt;Draw(DVASPECT_CONTENT, -1, NULL, NULL <br>                , 0, hDC, &amp;rcl, NULL, ContinuePaint, 0); <br>            pIViewObject2-&gt;Release(); <br> <br>            m_pFR-&gt;StatusLine()-&gt;MessageDisplay(ID_MESSAGEREADY); <br>            } <br>        } <br> <br>    EndPaint(hWnd, &amp;ps); <br>    return FALSE; <br>    } <br> <br> <br> <br>/* <br> * ContinuePaint <br> * <br> * Purpose: <br> *  Callback function for IViewObject2::Draw that allows us to <br> *  abort a long repaint.  This implementation watches the <br> *  Esc key through GetAsyncKeyState. <br> * <br> * Parameters: <br> *  dwContinue      DWORD custom data passed to IViewObject::Draw <br> *                  which in our case holds the document pointer. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue painting, FALSE to stop it. <br> */ <br> <br>BOOL CALLBACK ContinuePaint(DWORD dwContinue) <br>    { <br>    return !(GetAsyncKeyState(VK_ESCAPE) &lt; 0); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the window. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load, NULL if the file <br> *                  is new and untitled. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_... <br> */ <br> <br>UINT CFreeloaderDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    HRESULT             hr; <br>    LPSTORAGE           pIStorage; <br>    LPUNKNOWN           pIUnknown; <br>    LPPERSISTSTORAGE    pIPersistStorage; <br>    DWORD               dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                            | STGM_SHARE_EXCLUSIVE; <br>    CLSID               clsID; <br> <br>    if (NULL==pszFile) <br>        { <br>        //Create a new temp file. <br>        hr=StgCreateDocfile(NULL, dwMode | STGM_CREATE <br>            | STGM_DELETEONRELEASE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        m_pIStorage=pIStorage; <br> <br>        FDirtySet(FALSE); <br>        Rename(NULL); <br>        return DOCERR_NONE; <br>        } <br> <br>    //Attempt to open the storage. <br>    hr=StgOpenStorage(pszFile, NULL, dwMode, NULL, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    /* <br>     * When we previously called IPersistStorage::Save, we saved <br>     * the class of this object type with WriteClassStg.  Now <br>     * we read that CLSID, create a data cache for it, then <br>     * have it reload its data into the cache through <br>     * IPersistStorage::Load. <br>     */ <br> <br>    hr=ReadClassStg(pIStorage, &amp;clsID); <br> <br>    hr=CreateDataCache(NULL, clsID, IID_IUnknown <br>        , (PPVOID)&amp;pIUnknown); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //Get IPersistStorage for the data we hold. <br>    pIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;pIPersistStorage); <br> <br>    //Load might fail because the object is already open... <br>    hr=pIPersistStorage-&gt;Load(pIStorage); <br>    pIPersistStorage-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIUnknown-&gt;Release(); <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    m_pIStorage=pIStorage; <br>    m_pIUnknown=pIUnknown; <br> <br>    Rename(pszFile); <br>    SizeToGraphic(FALSE); <br>    FDirtySet(FALSE); <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::Save <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user <br> *  has previously used FileOpen or FileSaveAs in order to have <br> *  a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_... <br> */ <br> <br>UINT CFreeloaderDoc::Save(UINT uType, LPTSTR pszFile) <br>    { <br>    HRESULT             hr; <br>    LPSTORAGE           pIStorage; <br>    LPPERSISTSTORAGE    pIPersistStorage; <br>    CLSID               clsID; <br> <br>    //If we have no data object, there's nothing to save. <br>    if (NULL==m_pIUnknown) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Get IPersistStorage for the data we hold. <br>    hr=m_pIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;pIPersistStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Save or Save As with the same file is just a commit. <br>    if (NULL==pszFile || (NULL!=pszFile <br>        &amp;&amp; 0==lstrcmpi(pszFile, m_szFile))) <br>        { <br>        pIPersistStorage-&gt;Save(m_pIStorage, TRUE); <br>        m_pIStorage-&gt;Commit(STGC_ONLYIFCURRENT); <br> <br>        pIPersistStorage-&gt;SaveCompleted(NULL); <br>        pIPersistStorage-&gt;Release(); <br> <br>        FDirtySet(FALSE); <br>        return DOCERR_NONE; <br>        } <br> <br>    /* <br>     * When we're given a name, open the storage, creating it new <br>     * ifit does not exist or overwriting the old one.  Then CopyTo <br>     * from the current to the new, Commit the new, then Release <br>     * the old. <br>     */ <br> <br>    hr=StgCreateDocfile(pszFile, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    //Insure the image is up to date, then tell it we're changing <br>    pIPersistStorage-&gt;Save(m_pIStorage, TRUE); <br>    pIPersistStorage-&gt;HandsOffStorage(); <br> <br>    //Save the class, bitmap or metafile <br>    if (FAILED(pIPersistStorage-&gt;GetClassID(&amp;clsID))) <br>        clsID=m_clsID; <br> <br>    hr=WriteClassStg(m_pIStorage, clsID); <br> <br>    hr=m_pIStorage-&gt;CopyTo(NULL, NULL, NULL, pIStorage); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIPersistStorage-&gt;SaveCompleted(m_pIStorage); <br>        pIPersistStorage-&gt;Release(); <br>        pIStorage-&gt;Release(); <br>        return DOCERR_WRITEFAILURE; <br>        } <br> <br>    pIStorage-&gt;Commit(STGC_ONLYIFCURRENT); <br> <br>    /* <br>     * Revert changes on the original storage.  If this was a temp <br>     * file, it's deleted since we used STGM_DELETEONRELEASE. <br>     */ <br>    m_pIStorage-&gt;Release(); <br> <br>    //Make this new storage current <br>    m_pIStorage=pIStorage; <br>    pIPersistStorage-&gt;SaveCompleted(m_pIStorage); <br>    pIPersistStorage-&gt;Release(); <br> <br>    Rename(pszFile); <br>    FDirtySet(FALSE); <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::Clip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::Clip(HWND hWndFrame, BOOL fCut) <br>    { <br>    BOOL            fRet=TRUE; <br>    static UINT     rgcf[3]={CF_METAFILEPICT, CF_DIB, CF_BITMAP}; <br>    const UINT      cFormats=3; <br>    UINT            i; <br>    HGLOBAL         hMem; <br> <br>    if (NULL==m_pIUnknown) <br>        return FALSE; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    //Clean out whatever junk is in the clipboard. <br>    EmptyClipboard(); <br> <br>    for (i=0; i &lt; cFormats; i++) <br>        { <br>        hMem=RenderFormat(rgcf[i]); <br> <br>        if (NULL!=hMem) <br>            { <br>            SetClipboardData(rgcf[i], hMem); <br>            fRet=TRUE; <br>            break; <br>            } <br>        } <br> <br>    //Free clipboard ownership. <br>    CloseClipboard(); <br> <br>    //If we're cutting, clean out the cache and the object we hold. <br>    if (fRet &amp;&amp; fCut) <br>        { <br>        ReleaseObject(); <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::RenderFormat <br> * <br> * Purpose: <br> *  Renders a specific clipboard format into global memory. <br> * <br> * Parameters: <br> *  cf              UINT format to render. <br> * <br> * Return Value: <br> *  HGLOBAL         Global memory handle containing the data. <br> */ <br> <br>HGLOBAL CFreeloaderDoc::RenderFormat(UINT cf) <br>    { <br>    LPDATAOBJECT        pIDataObject; <br>    FORMATETC           fe; <br>    STGMEDIUM           stm; <br> <br>    if (NULL==m_pIUnknown) <br>        return NULL; <br> <br>    //We only have to ask the data object (cache) for the data. <br>    switch (cf) <br>        { <br>        case CF_METAFILEPICT: <br>            stm.tymed=TYMED_MFPICT; <br>            break; <br> <br>       case CF_DIB: <br>            stm.tymed=TYMED_HGLOBAL; <br>            break; <br> <br>       case CF_BITMAP: <br>            stm.tymed=TYMED_GDI; <br>            break; <br> <br>        default: <br>            return NULL; <br>        } <br> <br>    stm.hGlobal=NULL; <br>    SETDefFormatEtc(fe, cf, stm.tymed); <br> <br>    m_pIUnknown-&gt;QueryInterface(IID_IDataObject <br>        , (PPVOID)&amp;pIDataObject); <br>    pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br>    pIDataObject-&gt;Release(); <br> <br>    return stm.hGlobal; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::FQueryPaste(void) <br>    { <br>    return IsClipboardFormatAvailable(CF_BITMAP) <br>        || IsClipboardFormatAvailable(CF_DIB) <br>        || IsClipboardFormatAvailable(CF_METAFILEPICT); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFreeloaderDoc::Paste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::Paste(HWND hWndFrame) <br>    { <br>    UINT                cf=0; <br>    HGLOBAL             hMem; <br>    HRESULT             hr; <br>    DWORD               dwConn; <br>    LPUNKNOWN           pIUnknown; <br>    LPOLECACHE          pIOleCache; <br>    LPPERSISTSTORAGE    pIPersistStorage; <br>    FORMATETC           fe; <br>    STGMEDIUM           stm; <br>    CLSID               clsID; <br> <br>    if (!OpenClipboard(hWndFrame)) <br>        return FALSE; <br> <br>    /* <br>     * Try to get data in order of metafile, dib, bitmap.  We set <br>     * stm.tymed up front so if we actually get something a call <br>     * to ReleaseStgMedium will clean it up for us. <br>     */ <br> <br>    stm.pUnkForRelease=NULL; <br>    stm.tymed=TYMED_MFPICT; <br>    hMem=GetClipboardData(CF_METAFILEPICT); <br> <br>    if (NULL!=hMem) <br>        cf=CF_METAFILEPICT; <br> <br>    if (0==cf) <br>        { <br>        stm.tymed=TYMED_HGLOBAL; <br>        hMem=GetClipboardData(CF_DIB); <br> <br>        if (NULL!=hMem) <br>            cf=CF_DIB; <br>        } <br> <br>    if (0==cf) <br>        { <br>        stm.tymed=TYMED_GDI; <br>        hMem=GetClipboardData(CF_BITMAP); <br> <br>        if (NULL!=hMem) <br>            cf=CF_BITMAP; <br>        } <br> <br>    stm.hGlobal=OleDuplicateData(hMem, cf, NULL); <br>    CloseClipboard(); <br> <br>    //Didn't get anything?  Then we're finished. <br>    if (0==cf) <br>        return FALSE; <br> <br>    //This now describes the data we have. <br>    SETDefFormatEtc(fe, cf, stm.tymed); <br> <br> <br>    /* <br>     * Create a data cache to deal with this data using <br>     * either CoCreateInstance for an OLE-supported CLSID or <br>     * CreateDataCache.  The first will go through all the <br>     * exercises of looking up the CLSID in the regDB, finding <br>     * the OLE DLL (registered for these classes), getting a class <br>     * factory, and using IClassFactory::CreateInstance.  The <br>     * second goes into OLE directly, creating the same object <br>     * with less overhead.  Thus we use CreateDataCache. <br>     */ <br> <br>    if (CF_METAFILEPICT==cf) <br>        clsID=CLSID_Picture_Metafile; <br>    else <br>        clsID=CLSID_Picture_Dib; <br> <br>    hr=CreateDataCache(NULL, clsID, IID_IUnknown <br>        , (PPVOID)&amp;pIUnknown); <br> <br>    if (FAILED(hr)) <br>        { <br>        ReleaseStgMedium(&amp;stm); <br>        return FALSE; <br>        } <br> <br>    /* <br>     * Our contract says we provide storage through <br>     * IPersistStorage::InitNew.  We know that the object we're <br>     * dealing with supports IPersistStorage and IOleCache, so <br>     * we don't bother to check return values.  I guess we're <br>     * living dangerously... <br>     */ <br>    pIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;pIPersistStorage); <br>    pIPersistStorage-&gt;InitNew(m_pIStorage); <br>    pIPersistStorage-&gt;Release(); <br> <br>    /* <br>     * Now that we have the cache object, shove the data into it. <br>     * No advise flags are necessary for static data. <br>     */ <br>    pIUnknown-&gt;QueryInterface(IID_IOleCache, (PPVOID)&amp;pIOleCache); <br>    pIOleCache-&gt;Cache(&amp;fe, ADVF_PRIMEFIRST, &amp;dwConn); <br> <br>    hr=pIOleCache-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br>    pIOleCache-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        { <br>        ReleaseStgMedium(&amp;stm); <br>        pIUnknown-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    //Now that that's all done, replace our current with the new. <br>    ReleaseObject(); <br>    m_pIUnknown=pIUnknown; <br>    m_dwConn=dwConn; <br>    m_clsID=clsID; <br> <br>    FDirtySet(TRUE); <br> <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br>    UpdateWindow(m_hWnd); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CFreeloaderDoc::SizeToGraphic <br> * <br> * Purpose: <br> *  Determines if we can size the window to the contained <br> *  graphic and alternately performs the operation. <br> * <br> * Parameters: <br> *  fQueryOnly      BOOL indicating if we just want to know <br> *                  if sizing is possible (TRUE) or that we <br> *                  want to perform the sizing (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CFreeloaderDoc::SizeToGraphic(BOOL fQueryOnly) <br>    { <br>    HRESULT             hr; <br>    LPVIEWOBJECT2       pIViewObject2; <br>    SIZEL               szl; <br>    RECT                rc; <br>    UINT                cx, cy; <br>    HDC                 hDC; <br>    DWORD               dwStyle; <br> <br>    if (NULL==m_pIUnknown) <br>        return FALSE; <br> <br>    m_pIUnknown-&gt;QueryInterface(IID_IViewObject2 <br>        , (PPVOID)&amp;pIViewObject2); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (fQueryOnly) <br>        { <br>        pIViewObject2-&gt;Release(); <br>        return TRUE; <br>        } <br> <br>    hr=pIViewObject2-&gt;GetExtent(DVASPECT_CONTENT, -1, NULL, &amp;szl); <br>    pIViewObject2-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    //Calculate new doc rectangle based on these extents. <br> <br>    hDC=GetDC(NULL); <br>    cx=MulDiv((int)szl.cx, GetDeviceCaps(hDC, LOGPIXELSX) <br>        , HIMETRIC_PER_INCH); <br>    cy=MulDiv((int)szl.cy, GetDeviceCaps(hDC, LOGPIXELSY) <br>        , HIMETRIC_PER_INCH); <br>    ReleaseDC(NULL, hDC); <br> <br>    SetRect(&amp;rc, 0, 0, cx, cy); <br>    dwStyle=GetWindowLong(m_hWnd, GWL_STYLE); <br>    AdjustWindowRect(&amp;rc, dwStyle, FALSE); <br> <br>    /* <br>     * If the window is currently maximized, then we have to <br>     * restore it first before sizing. <br>     */ <br>    if (IsZoomed(m_hWnd)) <br>        ShowWindow(m_hWnd, SW_RESTORE); <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0 <br>        , rc.right-rc.left , rc.bottom-rc.top <br>        , SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE); <br> <br>    return TRUE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
