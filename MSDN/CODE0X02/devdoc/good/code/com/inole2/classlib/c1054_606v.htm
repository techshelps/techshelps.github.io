<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CHATCH.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1057"></a>CHATCH.CPP</h2>
<pre><code>/* <br> * CHATCH.CPP <br> * <br> * Implementation of a class to manage a hatch border around an <br> * in-place editing window.  This is a modification of the OLESTD <br> * hatch window because we want to use this window to forward <br> * messages. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Right Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br> <br>#define SHADE_FULLRECT        1 <br>#define SHADE_BORDERIN        2 <br>#define SHADE_BORDEROUT       3 <br> <br>/* <br> * DrawShading <br> * <br> * Purpose: <br> *  Shade the object when it is in in-place editing. Borders are drawn <br> *  on the Object rectangle. The right and bottom edge of the rectangle <br> *  are excluded in the drawing. <br> * <br> * Parameters: <br> *  lpRect      Dimensions of Container Object <br> *  hdc         HDC for drawing <br> *  dwFlags- <br> *      Exclusive flags <br> *          SHADE_FULLRECT    Shade the whole rectangle <br> *          SHADE_BORDERIN    Shade cWidth pixels inside rect <br> *          SHADE_BORDEROUT   Shade cWidth pixels outside rect <br> *      Optional flags <br> *          SHADE_USEINVERSE <br> *              use PATINVERT instead of the hex value <br> *  cWidth      width of border in pixel <br> * <br> * Return Value: null <br> * <br> * Copied from OBJFDBK.C <br> * <br> */ <br>void DrawShading(LPRECT lpRect, HDC hdc, DWORD dwFlags, UINT cWidth) <br>{ <br>        HBRUSH  hbr; <br>        HBRUSH  hbrOld; <br>        HBITMAP hbm; <br>        RECT    rc; <br>        WORD    wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88}; <br>        COLORREF cvText; <br>        COLORREF cvBk; <br> <br>        hbm = CreateBitmap(8, 8, 1, 1, wHatchBmp); <br>        hbr = CreatePatternBrush(hbm); <br>        hbrOld = (HBRUSH) SelectObject(hdc, hbr); <br> <br>        rc = *lpRect; <br> <br>        if (dwFlags == SHADE_FULLRECT) { <br>                cvText = SetTextColor(hdc, RGB(255, 255, 255)); <br>                cvBk = SetBkColor(hdc, RGB(0, 0, 0)); <br>                PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top, <br>                        0x00A000C9L /* DPa */ ); <br> <br>        } else {    // either inside or outside rect <br> <br>                if (dwFlags == SHADE_BORDEROUT) <br>                        InflateRect((LPRECT)&amp;rc, cWidth - 1, cWidth - 1); <br> <br>                cvText = SetTextColor(hdc, RGB(255, 255, 255)); <br>                cvBk = SetBkColor(hdc, RGB(0, 0, 0)); <br>                PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, <br>                        cWidth, 0x00A000C9L /* DPa */); <br>                PatBlt(hdc, rc.left, rc.top, cWidth, rc.bottom - rc.top, <br>                        0x00A000C9L /* DPa */); <br>                PatBlt(hdc, rc.right - cWidth, rc.top, cWidth, <br>                        rc.bottom - rc.top, 0x00A000C9L /* DPa */); <br>                PatBlt(hdc, rc.left, rc.bottom - cWidth, rc.right-rc.left, <br>                        cWidth, 0x00A000C9L /* DPa */); <br>        } <br> <br>        SetTextColor(hdc, cvText); <br>        SetBkColor(hdc, cvBk); <br>        SelectObject(hdc, hbrOld); <br>        DeleteObject(hbr); <br>        DeleteObject(hbm); <br>} <br> <br> <br>#include "classlib.h" <br> <br> <br>/* <br> * FHatchWindowRegister <br> * <br> * Purpose: <br> *  Registers the hatch window class for use with CHatchWin. <br> * <br> * Parameters: <br> *  hInst           HINSTANCE under which to register. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL FHatchWindowRegister(HINSTANCE hInst) <br>    { <br>    WNDCLASS    wc; <br> <br>    //Must have CS_DBLCLKS for border! <br>    wc.style         = CS_HREDRAW | CS_VREDRAW | CS_DBLCLKS; <br>    wc.hInstance     = hInst; <br>    wc.cbClsExtra    = 0; <br>    wc.lpfnWndProc   = HatchWndProc; <br>    wc.cbWndExtra    = CBHATCHWNDEXTRA; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = SZCLASSHATCHWIN; <br> <br>    return RegisterClass(&amp;wc); <br>        return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CHatchWin:CHatchWin <br> * CHatchWin::~CHatchWin <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application we're in. <br> */ <br> <br>CHatchWin::CHatchWin(HINSTANCE hInst) <br>    : CWindow(hInst) <br>    { <br>    m_hWnd=NULL; <br>    m_hWndKid=NULL; <br>    m_hWndAssociate=NULL; <br>    m_uID=0; <br> <br>    m_dBorder=GetProfileInt(TEXT("windows") <br>        , TEXT("OleInPlaceBorderWidth"), HATCHWIN_BORDERWIDTHDEFAULT); <br> <br>    return; <br>    } <br> <br> <br>CHatchWin::~CHatchWin(void) <br>    { <br>    /* <br>     * Chances are this was already destroyed when a document <br>     * was destroyed. <br>     */ <br>    if (NULL!=m_hWnd &amp;&amp; IsWindow(m_hWnd)) <br>        DestroyWindow(m_hWnd); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CHatchWin::FInit <br> * <br> * Purpose: <br> *  Instantiates a hatch window within a given parent with a <br> *  default rectangle.  This is not initially visible. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  uID             UINT identifier for this window (send in <br> *                  notifications to associate window). <br> *  hWndAssoc       HWND of the initial associate. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CHatchWin::FInit(HWND hWndParent, UINT uID, HWND hWndAssoc) <br>    { <br>    m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, SZCLASSHATCHWIN <br>        , SZCLASSHATCHWIN, WS_CHILD | WS_CLIPSIBLINGS <br>        | WS_CLIPCHILDREN, 0, 0, 100, 100, hWndParent, (HMENU)uID <br>        , m_hInst, this); <br> <br>    m_uID=uID; <br>    m_hWndAssociate=hWndAssoc; <br> <br>    return (NULL!=m_hWnd); <br>    } <br> <br> <br> <br> <br>/* <br> * CHatchWin::HwndAssociateSet <br> * CHatchWin::HwndAssociateGet <br> * <br> * Purpose: <br> *  Sets (Set) or retrieves (Get) the associate window of the <br> *  hatch window. <br> * <br> * Parameters: (Set only) <br> *  hWndAssoc       HWND to set as the associate. <br> * <br> * Return Value: <br> *  HWND            Previous (Set) or current (Get) associate <br> *                  window. <br> */ <br> <br>HWND CHatchWin::HwndAssociateSet(HWND hWndAssoc) <br>    { <br>    HWND    hWndT=m_hWndAssociate; <br> <br>    m_hWndAssociate=hWndAssoc; <br>    return hWndT; <br>    } <br> <br>HWND CHatchWin::HwndAssociateGet(void) <br>    { <br>    return m_hWndAssociate; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CHatchWin::RectsSet <br> * <br> * Purpose: <br> *  Changes the size and position of the hatch window and the child <br> *  window within it using a position rectangle for the child and <br> *  a clipping rectangle for the hatch window and child.  The hatch <br> *  window occupies prcPos expanded by the hatch border and clipped <br> *  by prcClip.  The child window is fit to prcPos to give the <br> *  proper scaling, but it clipped to the hatch window which <br> *  therefore clips it to prcClip without affecting the scaling. <br> * <br> * Parameters: <br> *  prcPos          LPRECT providing the position rectangle. <br> *  prcClip         LPRECT providing the clipping rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CHatchWin::RectsSet(LPRECT prcPos, LPRECT prcClip) <br>    { <br>    RECT    rc; <br>    RECT    rcPos; <br> <br>    //Calculate the rectangle for the hatch window, then clip it. <br>    rcPos=*prcPos; <br>    InflateRect(&amp;rcPos, m_dBorder, m_dBorder); <br>    IntersectRect(&amp;rc, &amp;rcPos, prcClip); <br> <br>    SetWindowPos(m_hWnd, NULL, rc.left, rc.top, rc.right-rc.left <br>        , rc.bottom-rc.top, SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    /* <br>     * Set the rectangle of the child window to be at m_dBorder <br>     * from the top and left but with the same size as prcPos <br>     * contains.  The hatch window will clip it. <br>     */ <br> <br>    SetWindowPos(m_hWndKid, NULL, rcPos.left-rc.left+m_dBorder <br>        , rcPos.top-rc.top+m_dBorder, prcPos-&gt;right-prcPos-&gt;left <br>        , prcPos-&gt;bottom-prcPos-&gt;top, SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CHatchWin::ChildSet <br> * <br> * Purpose: <br> *  Assigns a child window to this hatch window. <br> * <br> * Parameters: <br> *  hWndKid         HWND of the child window. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CHatchWin::ChildSet(HWND hWndKid) <br>    { <br>    m_hWndKid=hWndKid; <br> <br>    if (NULL!=hWndKid) <br>        { <br>        SetParent(hWndKid, m_hWnd); <br> <br>        //Insure this is visible when the hatch window becomes visible. <br>        ShowWindow(hWndKid, SW_SHOW); <br>        } <br> <br>    return; <br>    } <br> <br> <br>/* <br> * HatchWndProc <br> * <br> * Purpose: <br> *  Standard window procedure for the Hatch Window <br> */ <br> <br>LRESULT APIENTRY HatchWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCHatchWin  phw; <br>    int         d; <br>    HDC         hDC; <br>    PAINTSTRUCT ps; <br>    RECT        rc; <br> <br>    phw=(PCHatchWin)GetWindowLong(hWnd, HWWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            phw=(PCHatchWin)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, HWWL_STRUCTURE, (LONG)phw); <br>            break; <br> <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br>            GetClientRect(hWnd, &amp;rc); <br> <br>            d=phw-&gt;m_dBorder; <br> <br>            //Always draw the hatching. <br>            DrawShading(&amp;rc, hDC, SHADE_BORDERIN, d); <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br> <br>        case WM_SETFOCUS: <br>            //We need this since the container will SetFocus to us. <br>            if (NULL!=phw-&gt;m_hWndKid) <br>                SetFocus(phw-&gt;m_hWndKid); <br> <br>            break; <br> <br> <br>        case WM_LBUTTONDBLCLK: <br>            /* <br>             * If the double click was within m_dBorder of an <br>             * edge, send the HWN_BORDERDOUBLECLICKED notification. <br>             * <br>             * Because we're always sized just larger than our child <br>             * window by the border width, we can only *get* this <br>             * message when the mouse is on the border.  So we can <br>             * just send the notification. <br>             */ <br> <br>            if (NULL!=phw-&gt;m_hWndAssociate) <br>                { <br>                SendCommand(phw-&gt;m_hWndAssociate, phw-&gt;m_uID <br>                    , HWN_BORDERDOUBLECLICKED, hWnd); <br>                } <br> <br>            break; <br> <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
