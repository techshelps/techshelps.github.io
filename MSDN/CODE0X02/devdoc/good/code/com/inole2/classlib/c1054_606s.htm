<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CCLIENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1054"></a>CCLIENT.CPP</h2>
<pre><code>/* <br> * CCLIENT.CPP <br> * Sample Code Class Libraries <br> * <br> * Implementation of the CClient class that handles an SDI or MDI <br> * client area window. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include "classlib.h" <br>#include &lt;dbgout.h&gt; <br> <br> <br>/* <br> * CClient::CClient <br> * CClient::~CClient <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> */ <br> <br>CClient::CClient(HINSTANCE hInst) <br>    : CWindow(hInst) <br>    { <br>    m_pFR=NULL; <br>    m_cDoc=0; <br>    m_pDocLast=NULL; <br> <br>    return; <br>    } <br> <br> <br>CClient::~CClient(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::FInit <br> * <br> * Purpose: <br> *  Creates a client area window sensitive to SDI or MDI <br> *  (compile-time). <br> * <br> * Parameters: <br> *  hMenuWindow     HWND of the Window menu on the frame. <br> *  pRect           LPRECT containing the desired window rectangle. <br> *  pFR             PCFrame to which this client belongs. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CClient::FInit(HMENU hMenuWindow, LPRECT pRect, PCFrame pFR) <br>    { <br>    HWND                hWndFrame; <br>   #ifdef MDI <br>    CLIENTCREATESTRUCT  ccs; <br>   #endif <br> <br>    m_pFR=pFR; <br> <br>    hWndFrame=m_pFR-&gt;Window(); <br> <br>   #ifdef MDI <br> <br>    ccs.hWindowMenu =hMenuWindow; <br>    ccs.idFirstChild=ID_MDICHILDMIN; <br> <br>    //Create the MDI client filling the client area <br>    m_hWnd=CreateWindow(TEXT("mdiclient"), TEXT("mdiclient") <br>        , MDIS_ALLCHILDSTYLES | WS_CHILD | WS_CLIPCHILDREN <br>        | WS_VISIBLE | WS_CLIPSIBLINGS <br>        , pRect-&gt;left, pRect-&gt;top, pRect-&gt;right-pRect-&gt;left <br>        , pRect-&gt;bottom-pRect-&gt;top, hWndFrame, NULL, m_hInst <br>        , &amp;ccs); <br> <br>   #else <br> <br>    //SDI case, create out own SDI Client window <br>    m_hWnd=CreateWindow(SZCLASSSDICLIENT, SZCLASSSDICLIENT <br>        , WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_CLIPSIBLINGS <br>        , pRect-&gt;left, pRect-&gt;top,  pRect-&gt;right-pRect-&gt;left <br>        , pRect-&gt;bottom-pRect-&gt;top, hWndFrame, NULL, m_hInst, 0L); <br> <br>   #endif <br> <br>    return (NULL!=m_hWnd); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CClient::CreateDoc (Internal) <br> * CClient::CreateCDocument (Virtual) <br> * <br> * Purpose: <br> *  Constructs a new document.  This function is overridable so an <br> *  app can use the default CClient but create a derived document <br> *  class. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCDocument      Pointer to the new document object. <br> */ <br> <br>PCDocument CClient::CreateDoc(void) <br>    { <br>    PCDocument  pDoc; <br> <br>    pDoc=CreateCDocument(); <br>    m_pDocLast=pDoc; <br> <br>    return pDoc; <br>    } <br> <br>PCDocument CClient::CreateCDocument(void) <br>    { <br>    return new CDocument(m_hInst, m_pFR); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::TranslateAccelerator <br> * <br> * Purpose: <br> *  Provides an isolated system accelerator translation as necessary <br> *  for the client window.  In MDI this calls TranslateMDISysAccel <br> *  but is a NOP in SDI. <br> * <br> * Parameters: <br> *  pMsg            LPMSG to the message from GetMessage <br> * <br> * Return Value: <br> *  BOOL            TRUE if the accelerator was translated and <br> *                  processed, FALSE otherwise. <br> */ <br> <br>BOOL CClient::TranslateAccelerator(LPMSG pMsg) <br>    { <br>   #ifdef MDI <br>    return TranslateMDISysAccel(m_hWnd, pMsg); <br>   #else <br>    return FALSE; <br>   #endif <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CClient::DefFrameProc <br> * <br> * Purpose: <br> *  Encapsulates which default message procedure to call for a frame <br> *  window: SDI (DefWindowProc) or MDI (DefFrameProc). <br> * <br> * Parameters: <br> *  hWnd            HWND of the frame <br> *  iMsg            UINT of the message <br> *  wParam          WPARAM of the message <br> *  lParam          LPARAM of the message <br> * <br> * Return Value: <br> *  LRESULT         Return value for the message. <br> */ <br> <br>LRESULT CClient::DefaultFrameProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>   #ifdef MDI <br>    return (DefFrameProc(hWnd, m_hWnd, iMsg, wParam, lParam)); <br>   #else <br>    return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>   #endif <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CClient::OnWindowCommand <br> * <br> * Purpose: <br> *  Handles Window menu commands for MDI situations.  This is a NOP <br> *  in SDI. <br> * <br> * Parameters: <br> *  uCommand        UINT command to execute: <br> *                      WM_MDICASCADE <br> *                      WM_MDITILE <br> *                      WM_MDIICONARRANGE <br> * <br> *  uOption         UINT optional parameter for WM_MDITILE, either <br> *                  MDITILE_HORIZONTAL or MDITILE_VERTICAL. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CClient::OnWindowCommand(UINT uCommand, UINT uOption) <br>    { <br>    SendMessage(m_hWnd, uCommand, (WPARAM)uOption, 0L); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::OnSize <br> * <br> * Purpose: <br> *  Handles resizing the client window when the frame is resized. <br> * <br> * Parameters: <br> *  x, y            UINT new location of the window. <br> *  cx, cy          UINT new dimensions of the window. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CClient::OnSize(UINT x, UINT y, UINT cx, UINT cy) <br>    { <br>    SetWindowPos(m_hWnd, NULL, x, y, cx, cy <br>        , SWP_NOZORDER | SWP_NOACTIVATE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::NewDocument <br> * <br> * Purpose: <br> *  Creates a new blank document in the client space.  See <br> *  CloseDocument for the opposite effect. <br> * <br> * Parameters: <br> *  fVisible        BOOL indicating if the document is to be visible <br> *                  or not. <br> *  pAdv            PCDocumentAdviseSink to set with the new document <br> *                  for notifications.  Can be NULL. <br> * <br> * Return Value: <br> *  PCDocument      Pointer to the new document object. <br> */ <br> <br>PCDocument CClient::NewDocument(BOOL fVisible <br>    , PCDocumentAdviseSink pAdv) <br>    { <br>    MDICREATESTRUCT mcs; <br>    HWND            hWndDoc; <br>    PCDocument      pDoc; <br>    DOCUMENTINIT    di; <br>    BOOL            fCreate=TRUE; <br>   #ifdef MDI <br>    DWORD           dw; <br>   #endif <br> <br>   #ifdef MDI <br>    //In MDI we create a new CDocument <br>    pDoc=CreateDoc();  //This could create a derived class... <br>   #else <br>    //In SDI we close the one we have and create a new one. <br>    pDoc=ActiveDocument(); <br> <br>    if (NULL!=pDoc) <br>        CloseDocument(pDoc); <br> <br>    pDoc=CreateDoc(); <br>   #endif <br> <br>    if (fCreate) <br>        { <br>        /* <br>         * We implement this by having the client window actually <br>         * create the windows instead of using the CDocument <br>         * initializer.  Reason being is that we ask the client to <br>         * actually create the window using WM_MDICREATE (which works <br>         * for our SDI client as well. Since we need to conditionally <br>         * compile for MDI or SDI here, we create a window before <br>         * calling the document constructor. <br>         */ <br> <br>        mcs.szTitle=TEXT(""); <br>        mcs.szClass=SZCLASSDOCUMENT; <br>        mcs.hOwner =m_hInst; <br>        mcs.lParam =(LPARAM)pDoc; <br> <br>        mcs.x =CW_USEDEFAULT; <br>        mcs.cx=CW_USEDEFAULT; <br>        mcs.y =CW_USEDEFAULT; <br>        mcs.cy=CW_USEDEFAULT; <br> <br>        /* <br>         * Set the style of the window, controlling visiblity. <br>         * WS_CLIPCHILDREN is important to prevent unnecessary <br>         * flashing of document contents that we'll usually fill <br>         * with some editor window. <br>         */ <br>       #ifdef MDI <br>        mcs.style=WS_CHILD | WS_SYSMENU | WS_CAPTION <br>            | WS_CLIPSIBLINGS| WS_THICKFRAME | WS_MINIMIZEBOX <br>            | WS_MAXIMIZEBOX| WS_CLIPCHILDREN <br>            | ((fVisible) ? WS_VISIBLE : 0L); <br> <br>        //If the current document is maxmized, maximize this one <br>       #ifdef WIN32 <br>        dw=GetWindowLong(m_hWnd, GWL_STYLE); <br>        mcs.style |= (dw &amp; WS_MAXIMIZE); <br>       #else <br>        dw=SendMessage(m_hWnd, WM_MDIGETACTIVE, 0, 0L); <br> <br>        if (HIWORD(dw)) <br>            mcs.style |= WS_MAXIMIZE; <br>       #endif //WIN32 <br> <br>       #else <br>        mcs.style=WS_CHILD | WS_CLIPCHILDREN <br>            | ((fVisible) ? WS_VISIBLE : 0L); <br>       #endif //MDI <br> <br>        //Tell the Client window to create the child <br>        hWndDoc=(HWND)(UINT)SendMessage(m_hWnd, WM_MDICREATE, 0 <br>            , (LONG)&amp;mcs); <br> <br> <br>        di.idsMin=IDS_STANDARDDOCMIN; <br>        di.idsMax=IDS_STANDARDDOCMAX; <br>        di.hWndDoc=hWndDoc; <br>        di.pAdv=pAdv; <br> <br>        if (!pDoc-&gt;FInit(&amp;di)) <br>            { <br>            SendMessage(m_hWnd, WM_MDIDESTROY, (WPARAM)hWndDoc, 0L); <br>            delete pDoc; <br>            return NULL; <br>            } <br>        } <br> <br>    m_cDoc++; <br> <br>    //Update menus and gizmos for the new document if visible <br>    if (fVisible) <br>        m_pFR-&gt;UpdateGizmos(); <br> <br>    return pDoc; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::ActiveDocument <br> * <br> * Purpose: <br> *  Returns the active document window (encapsulates WM_MDIGETACTIVE) <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCDocument      Pointer to the active document object. <br> */ <br> <br>PCDocument CClient::ActiveDocument(void) <br>    { <br>    PCDocument  pDoc=NULL; <br>    HWND        hWnd; <br> <br>    hWnd=(HWND)(UINT)SendMessage(m_hWnd, WM_MDIGETACTIVE, 0, 0L); <br> <br>    if (NULL!=hWnd) <br>        pDoc=(PCDocument)SendMessage(hWnd, DOCM_PDOCUMENT, 0, 0L); <br>    else <br>        pDoc=m_pDocLast; <br> <br>    return pDoc; <br>    } <br> <br> <br> <br> <br>/* <br> * CClient::ShowDocument <br> * <br> * Purpose: <br> *  Shows or hides a document. <br> * <br> * Parameters: <br> *  pDoc            PCDocument to show or hide. <br> *  fShow           BOOL indicating whether to show or hide the <br> *                  document. <br> * <br> * Return Value: <br> *  BOOL            Previous shown state of the document. <br> */ <br> <br>BOOL CClient::ShowDocument(PCDocument pDoc, BOOL fShow) <br>    { <br>    BOOL        fRet; <br> <br>    if (NULL==pDoc) <br>        return FALSE; <br> <br>    fRet=IsWindowVisible(pDoc-&gt;Window()); <br> <br>    ShowWindow(pDoc-&gt;Window(), fShow ? SW_SHOW : SW_HIDE); <br> <br>    MDIREFRESHMENU(m_hWnd);     //Macro in book1632.h <br>    DrawMenuBar(m_pFR-&gt;Window()); <br> <br>    SendMessage(m_hWnd, WM_MDIACTIVATE, (WPARAM)pDoc-&gt;Window(), 0L); <br> <br>    //Update gizmos if we're *changing* a document's visibility <br>    if (fShow != fRet) <br>        m_pFR-&gt;UpdateGizmos(); <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::SDIVerify <br> * <br> * Purpose: <br> *  In MDI, this is a NOP, but in SDI checks if the user has dirtied <br> *  and wants to save the current document before blasting it away. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the operation calling us can proceed, <br> *                  FALSE to abort the operation. <br> */ <br> <br>BOOL CClient::SDIVerify(void) <br>    { <br>   #ifdef MDI <br>    return TRUE; <br>   #else <br>    PCDocument      pDoc; <br> <br>    pDoc=ActiveDocument(); <br> <br>    /* <br>     * In SDI, we'll erase the current, so verify if we have one <br>     * before continuing.  If we don't have any document, then we <br>     * don't have a problem. <br>     */ <br> <br>    if (NULL==pDoc) <br>        return TRUE; <br> <br>    return FCleanVerify(pDoc); <br>   #endif <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::CloseDocument <br> * <br> * Purpose: <br> *  Closes a document created with NewDocument. <br> * <br> * Parameters: <br> *  pDoc            PCDocument of the document to close. <br> * <br> * Return Value: <br> *  UINT            New count of open documents. <br> */ <br> <br>UINT CClient::CloseDocument(PCDocument pDoc) <br>    { <br>    HWND        hWndT; <br> <br>    if (NULL==pDoc) <br>        return m_cDoc; <br> <br>    /* <br>     * Again, since the client window controlled document creation <br>     * we destroy the document window here instead of asking the <br>     * document to do it for us.  Once we're rid of the window then <br>     * we can use the destructor. <br>     */ <br> <br>    hWndT=pDoc-&gt;Window(); <br> <br>    //Don't delete unowned windows. <br>    if (GetParent(hWndT)!=m_hWnd) <br>        return m_cDoc; <br> <br>    m_cDoc--; <br> <br>    //Update window text.  Maxed MDI windows handled automatically. <br>   #ifdef MDI <br>    m_pFR-&gt;WindowTitleSet(NULL, TRUE); <br>   #else <br>    m_pFR-&gt;WindowTitleSet(NULL, FALSE); <br>   #endif <br> <br>    if (m_pDocLast==pDoc) <br>        m_pDocLast=NULL; <br> <br>    //Let the document clean up first, then we can nuke the window. <br>    SendMessage(m_hWnd, WM_MDIDESTROY, (WPARAM)hWndT, 0L); <br>    delete pDoc; <br> <br>    return m_cDoc; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::QueryCloseAllDocuments <br> * <br> * Purpose: <br> *  Ask every document window we have in us if we can close them <br> *  down.  We use this when exiting the entire application. <br> * <br> * Parameters: <br> *  fClose          BOOL indicating if we should query close on the <br> *                  documents or acutally close them. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we can close, FALSE otherwise. <br> */ <br> <br>BOOL CClient::QueryCloseAllDocuments(BOOL fClose) <br>    { <br>    PCDocument   pDoc; <br>    HWND         hWndT; <br>    HWND         hPrevClose=NULL; <br> <br>    hWndT=GetWindow(m_hWnd, GW_CHILD); <br> <br>    while (NULL!=hWndT) <br>        { <br>        //Cache these: hWndT might be destroyed in closing hPrevClose <br>        HWND    hWndOwner=GetWindow(hWndT, GW_OWNER); <br>        HWND    hWndNext =GetWindow(hWndT, GW_HWNDNEXT); <br> <br>        if (NULL!=hPrevClose) <br>            { <br>            pDoc=(PCDocument)SendMessage(hPrevClose, DOCM_PDOCUMENT <br>                , 0, 0L); <br>            CloseDocument(pDoc); <br>            hPrevClose=NULL; <br>            } <br> <br>        //Skip icon title windows when saving hPrevClose. <br>        if (NULL==hWndOwner) <br>            { <br>            pDoc=(PCDocument)SendMessage(hWndT, DOCM_PDOCUMENT <br>                , 0, 0L); <br> <br>            if (fClose) <br>                { <br>                if (!FCleanVerify(pDoc)) <br>                    return FALSE; <br> <br>                //Delay closing this. <br>                hPrevClose=hWndT; <br>                } <br>            else <br>                { <br>                if (0==SendMessage(hWndT, WM_QUERYENDSESSION, 0, 0L)) <br>                    return FALSE; <br>                } <br>            } <br> <br>        hWndT=hWndNext; <br>        } <br> <br>    //Close the last window as necessary. <br>    if (fClose &amp;&amp; IsWindow(hPrevClose)) <br>        { <br>        pDoc=(PCDocument)SendMessage(hPrevClose, DOCM_PDOCUMENT <br>            , 0, 0L); <br>        CloseDocument(pDoc); <br>        hPrevClose=NULL; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CClient::FCleanVerify <br> * <br> * Purpose: <br> *  Checks if the document under scrutiny is dirty or not.  If so, <br> *  then we ask the user if they want to save it.  If not, then we <br> *  just return TRUE. <br> * <br> * Parameters: <br> *  pDoc            PCDocument under consideration. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the document is clean, saved, or the user <br> *                  doesn't want to save it.  FALSE if the user <br> *                  presses Cancel or the document was not saved. <br> */ <br> <br>BOOL CClient::FCleanVerify(PCDocument pDoc) <br>    { <br>    TCHAR           szFile[CCHPATHMAX]; <br>    LPTSTR          psz=szFile; <br> <br>    if (NULL==pDoc) <br>        return TRUE; <br> <br>    //Nothing to do if we're clean. <br>    if (!pDoc-&gt;FDirtyGet()) <br>        return TRUE; <br> <br>    //Get the filename and send to the frame for asking the question. <br>    *psz=0; <br>    pDoc-&gt;FilenameGet(psz, CCHPATHMAX); <br> <br>    return m_pFR-&gt;FAskAndSave(psz); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * SDIClientWndProc <br> * <br> * Purpose: <br> *  SDI client window class that will create one document for us, <br> *  emulating the functions of an MDI client but with only one doc. <br> */ <br> <br>LRESULT APIENTRY SDIClientWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    HWND                hWndDoc; <br>    LPMDICREATESTRUCT   pMCS; <br>    RECT                rc; <br> <br>    hWndDoc=(HWND)GetWindowLong(hWnd, CLIENTWL_HWNDDOC); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            SetWindowLong(hWnd, CLIENTWL_HWNDDOC, 0L); <br>            break; <br> <br>        case WM_SIZE: <br>            if (NULL!=hWndDoc) <br>                { <br>                //Change the document window to match <br>                SetWindowPos(hWndDoc, NULL, 0,  0, LOWORD(lParam) <br>                    , HIWORD(lParam), SWP_NOMOVE | SWP_NOZORDER <br>                    | SWP_NOACTIVATE); <br>                } <br>            break; <br> <br> <br>        case WM_MDICREATE: <br>            pMCS=(LPMDICREATESTRUCT)lParam; <br> <br>            //We only ate one *visible* document in SDI cases. <br>            if (NULL!=hWndDoc &amp;&amp; (WS_VISIBLE &amp; pMCS-&gt;style)) <br>                return (LONG)(UINT)hWndDoc; <br> <br>            /* <br>             * For our one visible window, we set this as the active <br>             * window.  For hidden windows, we return their window <br>             * handle but don't change the 'active' window we store. <br>             * <br>             * Note that we force SDI documents to fill the client <br>             * area. <br>             */ <br> <br>            GetClientRect(hWnd, &amp;rc); <br> <br>            hWndDoc=CreateWindowEx(WS_EX_NOPARENTNOTIFY <br>                , pMCS-&gt;szClass, pMCS-&gt;szTitle, pMCS-&gt;style <br>                , rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top <br>                , hWnd, (HMENU)ID_DOCUMENT, (HINSTANCE)pMCS-&gt;hOwner <br>                , pMCS); <br> <br> <br>            if (WS_VISIBLE &amp; pMCS-&gt;style) <br>                { <br>                ShowWindow(hWndDoc, SW_SHOW); <br>                SetWindowLong(hWnd, CLIENTWL_HWNDDOC <br>                    , (LONG)(UINT)hWndDoc); <br>                } <br> <br>            return (LONG)(UINT)hWndDoc; <br> <br> <br>        case WM_MDIACTIVATE: <br>            /* <br>             * Make the new window the active one.  The NEWMDIACTIVE <br>             * macro is wParam in Win16, lParam in Win32. <br>             */ <br>            SetWindowLong(hWnd, CLIENTWL_HWNDDOC,(LONG)NEWMDIACTIVE); <br>            break; <br> <br> <br>        case WM_MDIGETACTIVE: <br>            return (LONG)(UINT)hWndDoc; <br> <br> <br>        case WM_MDIDESTROY: <br>            //The only windows we should destroy are children of us. <br>            if (GetParent((HWND)wParam)==hWnd) <br>                { <br>                DestroyWindow((HWND)wParam); <br> <br>                /* <br>                 * If this is the visible window, clear out the <br>                 * window word. <br>                 */ <br>                if ((HWND)wParam==hWndDoc) <br>                    SetWindowLong(hWnd, CLIENTWL_HWNDDOC, 0L); <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
