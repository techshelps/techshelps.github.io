<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRAMEWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1066"></a>FRAMEWIN.CPP</h2>
<pre><code>/* <br> * FRAMEWIN.CPP <br> * Sample Code Class Libraries <br> * <br> * Frame window procedure used with the CFrame class as well as <br> * the implementation of CDocumentAdviseSink that the frame is <br> * interested in. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include "classlib.h" <br> <br> <br> <br> <br>/* <br> * FrameWndProc <br> * <br> * Purpose: <br> *  Frame window class procedure that allows a derivation of these <br> *  classes to hook and process any messages desired.  Otherwise this <br> *  handles standard commands as well as the status line and menus. <br> */ <br> <br>LRESULT APIENTRY FrameWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCFrame         pFR; <br>    PCClient        pCL=NULL; <br>    WORD            dx, dy; <br>    LRESULT         lRet; <br> <br>    pFR=(PCFrame)GetWindowLong(hWnd, FRAMEWL_STRUCTURE); <br> <br>    if (NULL!=pFR) <br>        { <br>        //Call the hook and return its value if it tells us to. <br>        if (pFR-&gt;FMessageHook(hWnd, iMsg, wParam, lParam, &amp;lRet)) <br>            return lRet; <br> <br>        //Otherwise copy the CClient pointer and continue. <br>        pCL=pFR-&gt;m_pCL; <br>        } <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pFR=(PCFrame)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br> <br>            SetWindowLong(hWnd, FRAMEWL_STRUCTURE, (LONG)pFR); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_CLOSE: <br>            //Don't close if any children cancel the operation. <br>            pFR-&gt;m_fClosing=TRUE; <br> <br>            if (!pCL-&gt;QueryCloseAllDocuments(TRUE)) <br>                { <br>                pFR-&gt;m_fClosing=FALSE; <br>                break; <br>                } <br> <br>            //Destroy everything. <br>            DestroyWindow(hWnd); <br>            break; <br> <br> <br>        case WM_QUERYENDSESSION: <br>            return pCL-&gt;QueryCloseAllDocuments(TRUE); <br> <br> <br>        case WM_ERASEBKGND: <br>            //Our client area is never visible, so don't flash <br>            return TRUE; <br> <br> <br>        case WM_SIZE: <br>            pFR-&gt;m_fSizing=TRUE; <br>            dx=LOWORD(lParam); <br>            dy=HIWORD(lParam); <br> <br>            //Change the gizmobar and StatStrip widths to match <br>            pFR-&gt;m_pGB-&gt;OnSize(hWnd); <br>            pFR-&gt;m_pSS-&gt;OnSize(hWnd); <br> <br>            pCL-&gt;OnSize(0, pFR-&gt;m_cyBar, dx <br>                , dy-pFR-&gt;m_cyBar-CYSTATSTRIP); <br> <br>            pFR-&gt;m_fSizing=FALSE; <br>            break; <br> <br> <br>        case WM_INITMENUPOPUP: <br>            //Skip the system menu <br>            if (TRUE==(BOOL)HIWORD(lParam)) <br>                break; <br> <br>            //Go handle graying menu items appropriately. <br>            pFR-&gt;UpdateMenus((HMENU)wParam, (UINT)LOWORD(lParam)); <br>            break; <br> <br> <br>        case WM_MENUSELECT: <br>            pFR-&gt;m_pSS-&gt;MenuSelect(wParam, lParam); <br>            break; <br> <br> <br>        case WM_DESTROYCLIPBOARD: <br>            //When we empty contents, disable the paste button <br>            pFR-&gt;m_pGB-&gt;Enable(IDM_EDITPASTE, FALSE); <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            return pFR-&gt;OnCommand(hWnd, wParam, lParam); <br> <br> <br>        default: <br>            //Don't try using CClient unless we have one. <br>            if (NULL!=pCL) <br>                { <br>                return pCL-&gt;DefaultFrameProc(hWnd, iMsg, wParam <br>                    , lParam); <br>                } <br>            else <br>                return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * AboutProc <br> * <br> * Purpose: <br> *  Dialog procedure for the omnipresent About box. <br> * <br> * Parameters: <br> *  The standard. <br> * <br> * Return Value: <br> *  The value to be returned through the DialogBox call that <br> *  created the dialog. <br> * <br> */ <br> <br>BOOL APIENTRY AboutProc(HWND hDlg, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog(hDlg, TRUE); <br>                } <br>            break; <br>        } <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>//CDocumentAdviseSink implementation for the frame window. <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::CDocumentAdviseSink <br> * <br> * Purpose: <br> *  Constructs an advise object storing a pointer for the caller's <br> *  use. <br> * <br> * Parameters: <br> *  pv              LPVOID to store in this object <br> */ <br> <br>CDocumentAdviseSink::CDocumentAdviseSink(LPVOID pv) <br>    { <br>    m_pv=pv; <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::OnDataChange <br> * <br> * Purpose: <br> *  Informs the frame that document data changed so we may need to <br> *  update some of our UI. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying us. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocumentAdviseSink::OnDataChange(PCDocument pDoc) <br>    { <br>    PCFrame     pFR=(PCFrame)m_pv; <br> <br>    pFR-&gt;OnDocumentDataChange(pDoc); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::OnCloseRequest <br> * <br> * Purpose: <br> *  A document was closed by the user so we have to effect it here. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying us. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocumentAdviseSink::OnCloseRequest(PCDocument pDoc) <br>    { <br>    PCFrame     pFR=(PCFrame)m_pv; <br> <br>    //Ask if you want to save. <br>    if (!pFR-&gt;m_pCL-&gt;FCleanVerify(pDoc)) <br>        return; <br> <br>    pFR-&gt;m_pCL-&gt;CloseDocument(pDoc); <br>    pFR-&gt;UpdateGizmos(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::OnSizeChange <br> * <br> * Purpose: <br> *  Notifies us that the document was resized. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying us. <br> *  pRect           LPRECT of the new document window size. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocumentAdviseSink::OnSizeChange(PCDocument pDoc, LPRECT pRect) <br>    { <br>    PCFrame     pFR=(PCFrame)m_pv; <br>   #ifndef MDI <br>    RECT        rc; <br>    DWORD       dwStyle; <br>   #endif <br> <br>    //MDI, do nothing.  In SDI, resize the frame to match <br>   #ifdef MDI <br>    return; <br>   #else <br>    //If we caused this from our own WM_SIZE, skip out. <br>    if (pFR-&gt;m_fSizing) <br>        return; <br> <br>    //Get the document's screen rectangle. <br>    GetWindowRect(pDoc-&gt;Window(), &amp;rc); <br> <br>    //Adjust for GizmoBar <br>    rc.top-=pFR-&gt;m_cyBar; <br> <br>    //Adjust for StatStrip <br>    rc.bottom+=CYSTATSTRIP; <br> <br>    //Adjust for our window <br>    dwStyle=GetWindowLong(pFR-&gt;m_hWnd, GWL_STYLE); <br>    AdjustWindowRect(&amp;rc, dwStyle, TRUE); <br> <br>    //This causes sizing of all other tools. <br>    SetWindowPos(pFR-&gt;m_hWnd, NULL, rc.left, rc.top, rc.right-rc.left <br>        , rc.bottom-rc.top, SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    return; <br>   #endif <br>    } <br> <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::OnCaptionChange <br> * <br> * Purpose: <br> *  Notifies us that we should update the caption bars used on this <br> *  document. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying us. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocumentAdviseSink::OnCaptionChange(PCDocument pDoc) <br>    { <br>    PCFrame     pFR=(PCFrame)m_pv; <br> <br>   #ifdef MDI <br>    pFR-&gt;WindowTitleSet(pDoc, TRUE); <br>   #else <br>    pFR-&gt;WindowTitleSet(pDoc, FALSE); <br>   #endif <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocumentAdviseSink::OnActivate <br> * <br> * Purpose: <br> *  Notifies us that we should update any user interface that <br> *  depends on the active document. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying us. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocumentAdviseSink::OnActivate(PCDocument pDoc) <br>    { <br>    PCFrame     pFR=(PCFrame)m_pv; <br> <br>    pFR-&gt;OnDocumentActivate(pDoc); <br>    return; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
