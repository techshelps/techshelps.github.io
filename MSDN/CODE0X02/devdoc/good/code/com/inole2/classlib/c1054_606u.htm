<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CFRAME.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1056"></a>CFRAME.CPP</h2>
<pre><code>/* <br> * CFRAME.CPP <br> * Sample Code Class Libraries <br> * <br> * Generic CFrame class that manages either SDI or MDI clients as <br> * well as typical File, Edit, Window, and Help commands. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;memory.h&gt; <br> <br>extern "C" <br>    { <br>    #include &lt;commdlg.h&gt; <br>    } <br> <br>#include "classlib.h" <br> <br> <br> <br>/* <br> * CFrame::CFrame <br> * CFrame::~CFrame <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE from WinMain <br> *  hInstPrev       HINSTANCE from WinMain <br> *  pszCmdLine      LPSTR from WinMain <br> *  nCmdShow        int from WinMain <br> */ <br> <br>CFrame::CFrame(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    : CWindow(hInst) <br>    { <br>    m_hInstPrev =hInstPrev; <br>    m_nCmdShow  =nCmdShow; <br> <br>   #ifdef WIN32 <br>    //This gives us the Unicode version if necessary <br>    m_pszCmdLine=GetCommandLine(); <br>   #else <br>    m_pszCmdLine=pszCmdLine; <br>   #endif <br> <br>    m_fLastEnable=(BOOL)-1; //Uninitialized <br>    m_fLastPaste =(BOOL)-1; //Uninitialized <br> <br>    m_phMenu=NULL; <br>    m_hBmp  =NULL; <br>    m_pST   =NULL; <br> <br>    m_pGB   =NULL; <br>    m_pSS   =NULL; <br>    m_pCL   =NULL; <br>    m_pAdv  =NULL; <br>    return; <br>    } <br> <br> <br> <br>CFrame::~CFrame(void) <br>    { <br>    m_fClosing=TRUE; <br> <br>    if (NULL!=m_pAdv) <br>        delete m_pAdv; <br> <br>    //Accelerators freed automatically. <br> <br>    //Free the GizmoBar bitmaps <br>    if (NULL!=m_hBmp) <br>        DeleteObject(m_hBmp); <br> <br>    if (NULL!=m_pCL) <br>        delete m_pCL; <br> <br>    if (NULL!=m_pSS) <br>        delete m_pSS; <br> <br>    if (NULL!=m_pGB) <br>        delete m_pGB; <br> <br>    //Free the menu handle array <br>    if (NULL!=m_phMenu) <br>        delete []((UINT *)m_phMenu); <br> <br>    //Free the stringtable. <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    m_fClosing=FALSE; <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::FInit <br> * <br> * Purpose: <br> *  Initializer for a CFrame object containing anything prone to <br> *  failure. <br> * <br> * Parameters: <br> *  pFI             PFRAMEINIT containing initialization parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, FALSE <br> *                  otherwise. If FALSE is returned, the caller must <br> *                  guarantee that the destructor is called promptly <br> *                  to insure cleanup. <br> */ <br> <br>BOOL CFrame::FInit(PFRAMEINIT pFI) <br>    { <br>    RECT                rc; <br>    HMENU               hMenu; <br>    UINT                uTemp; <br>    TOOLDISPLAYDATA     tdd; <br> <br>    m_fInit=TRUE; <br> <br>    //1.  Create our stringtable <br>    m_pST=new CStringTable(m_hInst); <br> <br>    if (!m_pST-&gt;FInit(pFI-&gt;idsMin, pFI-&gt;idsMax)) <br>        return FALSE; <br> <br> <br>    /* <br>     * 2.  Register the classes we need for this application. <br>     *     We have our main (frame) window, document windows (for <br>     *     either MDI or SDI, and Polyline windows which are the <br>     *     editing controls.  This separate virtual function allows <br>     *     applications to add additional classes. <br>     */ <br>    if (NULL==m_hInstPrev) <br>        { <br>        if (!FRegisterAllClasses()) <br>            return FALSE; <br>        } <br> <br> <br>    /* <br>     * 3.  Create the main window, the gizmobar, the StatStrip, <br>     *     and a client that owns documents. <br>     */ <br>    m_pCL=NULL; <br> <br>    m_hWnd=CreateWindow(SZCLASSFRAME, PSZ(IDS_CAPTION) <br>        , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN <br>        , pFI-&gt;x, pFI-&gt;y, pFI-&gt;cx, pFI-&gt;cy <br>        , NULL, NULL, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    UIToolConfigureForDisplay(&amp;tdd); <br>    m_dxB=tdd.cxButton; <br>    m_dyB=tdd.cyButton; <br>    m_cyBar=tdd.cyBar; <br> <br>    m_pGB=new CGizmoBar(m_hInst); <br> <br>    if (!m_pGB-&gt;FInit(m_hWnd, ID_GIZMOBAR, m_cyBar)) <br>        return FALSE; <br> <br> <br>    m_pSS=new CStatStrip(m_hInst); <br> <br>    if (!m_pSS-&gt;FInit(m_hWnd, ID_STATSTRIP, CYSTATSTRIP)) <br>        return FALSE; <br> <br> <br>    //Initialize the StatStrip for automated WM_MENUSELECT processing <br>    if (!m_pSS-&gt;MessageMap(m_hWnd, m_hInst, IDR_STATMESSAGEMAP <br>        , pFI-&gt;idsStatMin, pFI-&gt;idsStatMax, CCHMESSAGEMAX <br>        , pFI-&gt;idStatMenuMin, pFI-&gt;idStatMenuMax, ID_MESSAGEREADY <br>        , ID_MESSAGEEMPTY, ID_MENUSYS)) <br>        return FALSE; <br> <br> <br>    rc.top+=m_cyBar; <br> <br>    m_pCL=CreateCClient(); <br> <br>    /* <br>     * 4.  Allocate space for the menu handle array and store the <br>     *     popup handles.  Get the menu handle of the Window menu <br>     *     specifically for later processing. <br>     */ <br> <br>    hMenu=GetMenu(m_hWnd); <br>    m_phMenu=new HMENU[pFI-&gt;cMenus]; <br> <br>    for (uTemp=0; uTemp &lt; pFI-&gt;cMenus; uTemp++) <br>        m_phMenu[uTemp]=GetSubMenu(hMenu, uTemp); <br> <br>   #ifdef MDI <br>    //Save this for UpdateMenus.  Stays NULL in SDI <br>    m_hMenuWindow=GetSubMenu(hMenu, pFI-&gt;iPosWindowMenu); <br>   #endif <br> <br>    if (!m_pCL-&gt;FInit(m_hMenuWindow, &amp;rc, this)) <br>        return FALSE; <br> <br> <br>    /* <br>     * 5.  Initialize fancy things like the gizmobar.  If a derived <br>     *     class wants more gizmo images, they can copy the first <br>     *     two in the standard image set and this code will still <br>     *     load it.  This code just won't reference it. <br>     */ <br> <br>    m_hBmp=LoadBitmap(m_hInst, MAKEINTRESOURCE(tdd.uIDImages)); <br> <br>    if (NULL==m_hBmp) <br>        return FALSE; <br> <br>    //Create all the gizmos on the gizmobar <br>    CreateGizmos(); <br>    UpdateGizmos(); <br> <br>    m_hAccel=LoadAccelerators(m_hInst <br>        , MAKEINTRESOURCE(IDR_ACCELERATORS)); <br> <br>    if (NULL==m_hAccel) <br>        return FALSE; <br> <br> <br> <br>    /* <br>     * 6.  Before we possibly create any new documents, create an <br>     *     AdviseSink for document notifications. <br>     */ <br> <br>    m_pAdv=new CDocumentAdviseSink(this); <br> <br> <br>    /* <br>     * 7.  In the default implementation FPreShowInit does not do <br>     *     anything, but is called here to allow derivations to <br>     *     hook the function and modify m_nCmdShow before we <br>     *     call ShowWindow.  This is one such place where OLE affects <br>     *     a derivation, because servers will change m_nCmdShow to <br>     *     SW_HIDE if started with -Embedding. <br>     */ <br>    if (!FPreShowInit()) <br>        return FALSE; <br> <br> <br>    /* <br>     * 8.  Handle window visibility appropriately after giving <br>     *     FPreShowInit a chance to modify it. <br>     */ <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br> <br>    /* <br>     * 9.  Parse the command line and take appropriate action. Again, <br>     *     this virtual function is here for apps to override. <br>     */ <br>    ParseCommandLine(); <br> <br>    m_fInit=FALSE; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::CreateCClient <br> * <br> * Purpose: <br> *  Creates a CClient object for use in this frame.  This function <br> *  is overrided by derived classes to create a different type of <br> *  CClient. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCClient         Pointer to the new CClient object. <br> */ <br> <br>PCClient CFrame::CreateCClient() <br>    { <br>    return new CClient(m_hInst); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::FRegisterAllClasses <br> * <br> * Purpose: <br> *  Registers all classes used in this application. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if registration succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CFrame::FRegisterAllClasses(void) <br>    { <br>    WNDCLASS        wc; <br> <br>    //Field that are the same for all windows. <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.hInstance     = m_hInst; <br>    wc.cbClsExtra    = 0; <br> <br>    //Register the Frame window <br>    wc.lpfnWndProc   = FrameWndProc; <br>    wc.cbWndExtra    = CBFRAMEWNDEXTRA; <br>    wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon")); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = SZCLASSFRAME; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>   #ifndef MDI <br>    wc.lpfnWndProc   = SDIClientWndProc; <br>    wc.cbWndExtra    = CBCLIENTWNDEXTRA; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = SZCLASSSDICLIENT; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br>   #endif <br> <br>    wc.lpfnWndProc   = DocumentWndProc; <br>    wc.cbWndExtra    = CBDOCUMENTWNDEXTRA; <br>    wc.hIcon         = LoadIcon(m_hInst <br>                           , MAKEINTRESOURCE(IDR_DOCUMENTICON)); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = SZCLASSDOCUMENT; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::FPreShowInit <br> * <br> * Purpose: <br> *  Called from FInit before intially showing the window.  We do <br> *  whatever else we want here, modifying nCmdShow as necessary <br> *  which affects ShowWindow in FInit. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if this initialization succeeded, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CFrame::FPreShowInit(void) <br>    { <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::ParseCommandLine <br> * <br> * Purpose: <br> *  Allows the application to parse the command line and take action <br> *  after the window has possibly been shown. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if this function succeeded, FALSE otherwise. <br> */ <br> <br>void CFrame::ParseCommandLine(void) <br>    { <br>    LPTSTR      psz; <br>    UINT        uTemp; <br>    PCDocument  pDoc; <br> <br>    psz=PszWhiteSpaceScan(m_pszCmdLine, TRUE); <br> <br>   #ifdef WIN32 <br>    //Skip the first argument which is the EXE name. <br>    psz=PszWhiteSpaceScan(psz, FALSE); <br>    psz=PszWhiteSpaceScan(psz, TRUE); <br>   #endif <br> <br>    if ((TCHAR)0!=*psz) <br>        { <br>        pDoc=m_pCL-&gt;NewDocument(TRUE, m_pAdv); <br> <br>        //If loading fails, we'll just sit around with a new document <br>        uTemp=pDoc-&gt;ULoad(TRUE, psz); <br>        pDoc-&gt;ErrorMessage(uTemp); <br>        } <br>   #ifndef MDI <br>    else <br>        { <br>        /* <br>         * In SDI we always want to have an initial document visible, <br>         * so if there was no command line we'll create a new <br>         * untitled document here. <br>         */ <br>        pDoc=m_pCL-&gt;NewDocument(TRUE, m_pAdv); <br> <br>        if (NULL!=pDoc) <br>            pDoc-&gt;ULoad(TRUE, NULL); <br>        } <br>   #endif <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::CreateGizmos <br> * <br> * Purpose: <br> *  Procedure to create all the necessary gizmobar buttons. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of gizmos added to the bar. <br> */ <br> <br>UINT CFrame::CreateGizmos(void) <br>    { <br>    UINT            uState=GIZMO_NORMAL; <br>    UINT            utCmd =GIZMOTYPE_BUTTONCOMMAND; <br>    UINT            utEx  =GIZMOTYPE_BUTTONATTRIBUTEEX; <br> <br>    //File New, Open, Close, Save, Import <br>    m_pGB-&gt;Add(utCmd, 0, IDM_FILENEW,   m_dxB, m_dyB, NULL, NULL <br>        , 3, uState); <br>    m_pGB-&gt;Add(utCmd, 1, IDM_FILEOPEN,  m_dxB, m_dyB, NULL, NULL <br>        , 4, uState); <br>    m_pGB-&gt;Add(utCmd, 2, IDM_FILECLOSE, m_dxB, m_dyB, NULL, m_hBmp <br>        , 0, uState); <br>    m_pGB-&gt;Add(utCmd, 3, IDM_FILESAVE,  m_dxB, m_dyB, NULL, NULL <br>        , 5, uState); <br> <br>    //Separator <br>    m_pGB-&gt;Add(GIZMOTYPE_SEPARATOR,   4, 0, 6, m_dyB, NULL, NULL <br>        , 0, uState); <br> <br>    //Edit Undo, Cut, Copy, Paste <br>    m_pGB-&gt;Add(utCmd, 5, IDM_EDITUNDO,  m_dxB, m_dyB, NULL, m_hBmp <br>        , 1, uState); <br>    m_pGB-&gt;Add(utCmd, 6, IDM_EDITCUT,   m_dxB, m_dyB, NULL, NULL <br>        , 0, uState); <br>    m_pGB-&gt;Add(utCmd, 7, IDM_EDITCOPY,  m_dxB, m_dyB, NULL, NULL <br>        , 1, uState); <br>    m_pGB-&gt;Add(utCmd, 8, IDM_EDITPASTE, m_dxB, m_dyB, NULL, NULL <br>        , 2, uState); <br> <br>    return 9; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::MessageLoop <br> * <br> * Purpose: <br> *  Spins in a standard message loop (with accelerators) until <br> *  WM_QUIT is found after which it returns. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  WPARAM          Contents of msg.wParam from WM_QUIT. <br> */ <br> <br>WPARAM CFrame::MessageLoop(void) <br>    { <br>    MSG     msg; <br> <br>    while (GetMessage(&amp;msg, NULL, 0,0 )) <br>        { <br>        if (!m_pCL-&gt;TranslateAccelerator(&amp;msg)) <br>            { <br>            if (!TranslateAccelerator(m_hWnd, m_hAccel, &amp;msg)) <br>                { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>                } <br>            } <br>        } <br> <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::FMessageHook <br> * <br> * Purpose: <br> *  Provides a derivation of the base CFrame class to hook all <br> *  messages to the window procedure for special processing. <br> *  WM_COMMAND is NOT sent here as that goes through OnCommand <br> *  instead. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return value <br> *                  for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CFrame::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    *pLRes=0; <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::OnCommand <br> * <br> * Purpose: <br> *  WM_COMMAND handler for the frame window so derivations can <br> *  process their messages and then pass the standard commands (like <br> *  file open and save) on to the base class. <br> * <br> * Parameters: <br> *  hWnd            HWND of the frame window. <br> *  wParam          WPARAM of the message. <br> *  lParam          LPARAM of the message. <br> * <br> * Return Value: <br> *  LRESULT         Return value for the message. <br> */ <br> <br>LRESULT CFrame::OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>    { <br>    PCDocument      pDoc; <br>    TCHAR           szFile[CCHPATHMAX]; <br>    BOOL            fOK; <br>    UINT            uTemp; <br>    UINT            uType; <br>    PCHourglass     pHour; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    /* <br>     * Don't bother with anything during first initialization, <br>     * skipping many GizmoBar notifications. <br>     */ <br>    if (m_fInit) <br>        return 0L; <br> <br>    pDoc=m_pCL-&gt;ActiveDocument(); <br> <br> <br>    switch (wID) <br>        { <br>        case IDM_FILENEW: <br>            if (!m_pCL-&gt;SDIVerify()) <br>                break; <br> <br>            pHour=new CHourglass; <br>            pDoc=m_pCL-&gt;NewDocument(TRUE, m_pAdv); <br> <br>            //Insure the document is untitled. <br>            if (NULL!=pDoc) <br>                pDoc-&gt;ULoad(TRUE, NULL); <br> <br>            delete pHour; <br>            break; <br> <br> <br>        case IDM_FILEOPEN: <br>            if (!m_pCL-&gt;SDIVerify()) <br>                break; <br> <br>            szFile[0]=0; <br>            fOK=FSaveOpenDialog(szFile, CCHPATHMAX, IDS_FILEOPEN <br>                , TRUE, &amp;uType); <br> <br>            if (!fOK) <br>                return 0L; <br> <br>            pDoc=m_pCL-&gt;NewDocument(FALSE, m_pAdv); <br> <br>            if (NULL==pDoc) <br>                return 0L; <br> <br>            pHour=new CHourglass; <br>            uTemp=pDoc-&gt;ULoad(TRUE, szFile); <br>            delete pHour; <br> <br>            pDoc-&gt;ErrorMessage(uTemp); <br> <br>            //Close the new doc on failure, show on success. <br>            if (DOCERR_NONE!=uTemp) <br>                m_pCL-&gt;CloseDocument(pDoc); <br>            else <br>                m_pCL-&gt;ShowDocument(pDoc, TRUE); <br> <br>            return (DOCERR_NONE==uTemp); <br> <br> <br>        case IDM_FILECLOSE: <br>            //Ask if you want to save. <br>            if (!m_pCL-&gt;FCleanVerify(pDoc)) <br>                return 0L; <br> <br>            m_pCL-&gt;CloseDocument(pDoc); <br>            UpdateGizmos(); <br>            break; <br> <br> <br>        case IDM_FILESAVE: <br>            //If we get this from the gizmobar, we may need Save As <br>            fOK=pDoc-&gt;FQuerySave(); <br> <br>            if (fOK) <br>                { <br>                //Save using current document name and version <br>                pHour=new CHourglass; <br>                uTemp=pDoc-&gt;USave(0, NULL); <br>                delete pHour; <br> <br>                pDoc-&gt;ErrorMessage(uTemp); <br> <br>                //This return code is for CFrame::FAskAndSave <br>                return (DOCERR_NONE==uTemp); <br>                } <br> <br>            //FALL through to File/Save As for no name documents. <br> <br> <br>        case IDM_FILESAVEAS: <br>            //Go get a filename, then save it. <br>            pDoc-&gt;FilenameGet(szFile, CCHPATHMAX); <br> <br>            fOK=FSaveOpenDialog(szFile, CCHPATHMAX, IDS_FILESAVEAS <br>                , FALSE, &amp;uType); <br> <br>            if (!fOK) <br>                return 0L; <br> <br>            uTemp=pDoc-&gt;USave(uType, szFile); <br>            pDoc-&gt;ErrorMessage(uTemp); <br> <br>            return (DOCERR_NONE==uTemp); <br> <br> <br>        case IDM_FILEEXIT: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>            break; <br> <br> <br>        case IDM_EDITCUT: <br>        case IDM_EDITCOPY: <br>            pDoc-&gt;FClip(hWnd, (IDM_EDITCUT==wID)); <br> <br>            //Update the gizmobar as appropriate. <br>            m_pGB-&gt;Enable(IDM_EDITPASTE, pDoc-&gt;FQueryPaste()); <br>            break; <br> <br> <br>        case IDM_EDITUNDO: <br>            pDoc-&gt;Undo(); <br>            break; <br> <br>        case IDM_EDITPASTE: <br>            pDoc-&gt;FPaste(hWnd); <br>            break; <br> <br> <br>        //These commands don't happen in SDI builds; not on the menu <br>        case IDM_WINDOWCASCADE: <br>            m_pCL-&gt;OnWindowCommand(WM_MDICASCADE, 0); <br>            break; <br> <br>        case IDM_WINDOWTILEHORZ: <br>            m_pCL-&gt;OnWindowCommand(WM_MDITILE, MDITILE_HORIZONTAL); <br>            break; <br> <br>        case IDM_WINDOWTILEVERT: <br>            m_pCL-&gt;OnWindowCommand(WM_MDITILE, MDITILE_VERTICAL); <br>            break; <br> <br>        case IDM_WINDOWICONS: <br>            m_pCL-&gt;OnWindowCommand(WM_MDIICONARRANGE, 0); <br>            break; <br> <br>        case IDM_HELPABOUT: <br>            DialogBox(m_hInst, MAKEINTRESOURCE(IDD_ABOUT) <br>                , m_hWnd, AboutProc); <br>            break; <br> <br>        default: <br>           return m_pCL-&gt;DefaultFrameProc(hWnd, WM_COMMAND, wParam <br>               , lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::OnDocumentDataChange <br> * <br> * Purpose: <br> *  Most of the CDocumentAdviseSink notifications we get are fairly <br> *  standard implementations.  When data in the document changes, <br> *  however, there's probably more special things we can do, so we <br> *  keep this simple case simple with this hook, not forcing a <br> *  derived class to reimplement CDocumentAdviseSink. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::OnDocumentDataChange(PCDocument pDoc) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::OnDocumentActivate <br> * <br> * Purpose: <br> *  Most of the CDocumentAdviseSink notifications we get are fairly <br> *  standard implementations.  When the current document changes, <br> *  however, there's probably more UI that frame derivations need <br> *  to do, so we allow the hook here. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::OnDocumentActivate(PCDocument pDoc) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::FSaveOpenDialog <br> * <br> * Purpose: <br> *  Invokes the COMMDLG.DLL GetOpenFileName dialog and retrieves <br> *  a filename for saving or opening. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR buffer to receive the entered filename. <br> *  cchFile         UINT length of pszFile <br> *  idsCaption      UINT of  string to use in the caption bar. <br> *  fOpen           BOOL indicating if we want file open or save. <br> *  puType          UINT * in which we store the selected type. <br> *                  Can be NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function retrieved a filename, <br> *                  FALSE if the user pressed CANCEL. <br> */ <br> <br>BOOL CFrame::FSaveOpenDialog(LPTSTR pszFile, UINT cchFile <br>    , UINT idsCaption, BOOL fOpen, UINT *puType) <br>    { <br>    OPENFILENAME        ofn; <br>    TCHAR               szFilter[80]; <br>    UINT                cch; <br>    BOOL                fRet; <br>   #ifdef DEBUG <br>    DWORD               dwErr; <br>   #endif <br> <br>    if (NULL==pszFile) <br>        return FALSE; <br> <br>    memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>    ofn.lStructSize      =sizeof(OPENFILENAME); <br>    ofn.hwndOwner        =m_hWnd; <br> <br>    if (fOpen) <br>        lstrcpy(szFilter, PSZ(IDS_FILEOPENFILTER)); <br>    else <br>        lstrcpy(szFilter, PSZ(IDS_FILESAVEFILTER)); <br> <br>    cch=lstrlen(szFilter); <br>    ReplaceCharWithNull(szFilter, szFilter[cch-1]); <br> <br>    ofn.lpstrFilter      =szFilter; <br>    ofn.nFilterIndex     =1L; <br> <br>    ofn.lpstrTitle       =PSZ(idsCaption); <br>    ofn.lpstrFile        =pszFile; <br>    ofn.nMaxFile         =cchFile; <br> <br>    ofn.lpstrDefExt      =PSZ(IDS_DEFEXT); <br> <br>    if (fOpen) <br>        { <br>        ofn.Flags=OFN_HIDEREADONLY | OFN_FILEMUSTEXIST; <br>        fRet=GetOpenFileName(&amp;ofn); <br>        } <br>    else <br>        { <br>        ofn.Flags=OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT; <br>        fRet=GetSaveFileName(&amp;ofn); <br>        } <br> <br>    if (fRet || NULL!=puType) <br>        *puType=(UINT)ofn.nFilterIndex; <br> <br>   #ifdef DEBUG <br>    dwErr=CommDlgExtendedError(); <br>   #endif <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::ReplaceCharWithNull <br> * <br> * Purpose: <br> *  Walks a null-terminated string and replaces a given character <br> *  with a zero for use with the FSaveOpenDialog member. <br> * <br> * Parameters: <br> *  psz             LPTSTR to the string to process. <br> *  ch              int character to replace. <br> * <br> * Return Value: <br> *  int             Number of characters replaced.  -1 if psz is NULL <br> */ <br> <br>UINT CFrame::ReplaceCharWithNull(LPTSTR psz, int ch) <br>    { <br>    UINT            cChanged=0; <br> <br>    if (NULL==psz) <br>        return 0; <br> <br>    while ((TCHAR)0!=*psz) <br>        { <br>        if (ch==*psz) <br>            { <br>            *psz=0; <br>            cChanged++; <br>            } <br> <br>        psz++; <br>        } <br> <br>    return cChanged; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::PszWhiteSpaceScan <br> * <br> * Purpose: <br> *  Skips characters in a string until a whitespace or non-whitespace <br> *  character is seen.  Whitespace is defined as \n, \r, \t, or ' '. <br> * <br> * Parameters: <br> *  psz             LPTSTR to string to manipulate <br> *  fSkip           BOOL  TRUE if we want to skip whitespace. <br> *                  FALSE if we want to skip anything but whitespace. <br> * <br> * Return Value: <br> *  LPTSTR          Pointer to first character in the string that <br> *                  either non-whitespace (fSkip=TRUE) or <br> *                  whitespace (fSkip=FALSE), which may be the <br> *                  null terminator. <br> */ <br> <br>LPTSTR CFrame::PszWhiteSpaceScan(LPTSTR psz, BOOL fSkip) <br>    { <br>    TCHAR       ch; <br>    BOOL        fWhite; <br> <br>    while (ch=*psz) <br>        { <br>        //Not too sure how this localizes... <br>        fWhite=(TEXT('\n')==ch || TEXT('\r')==ch <br>            || TEXT('\t')==ch || TEXT(' ')==ch); <br> <br>        //Too bad C doesn't have a logical XOR (^^) operator. <br>        if ((fSkip &amp;&amp; !fWhite) || (!fSkip &amp;&amp; fWhite)) <br>            break; <br> <br>        psz++; <br>        } <br> <br>    return psz; <br>    } <br> <br> <br> <br> <br> <br> <br>//PUBLIC FUNCTIONS <br> <br> <br> <br> <br>/* <br> * CFrame::FAskAndSave <br> * <br> * Purpose: <br> *  If a document is closed and is dirty the client window we own <br> *  will get the document's filename and call us here.  We will <br> *  ask the user if they want to save that file and if so, send a <br> *  message to our frame window to execute the Save command. <br> * <br> * Parameters: <br> *  pszDoc          LPTSTR name of the document.  If the first <br> *                  character is 0 then we use (Untitled). <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file was saved, FALSE otherwise. <br> */ <br> <br>BOOL CFrame::FAskAndSave(LPTSTR pszDoc) <br>    { <br>    BOOL            fRet=TRUE; <br>    UINT            uRet; <br>    TCHAR           szTemp[CCHFILENAMEMAX+100]; <br> <br>    if (NULL==pszDoc) <br>        return FALSE; <br> <br>    if ((TCHAR)0==*pszDoc) <br>        pszDoc=PSZ(IDS_UNTITLED); <br>    else <br>        { <br>        GetFileTitle(pszDoc, szTemp, CCHFILENAMEMAX); <br>        lstrcpy(pszDoc, szTemp); <br>        } <br> <br>    wsprintf(szTemp, PSZ(IDS_FILEDIRTY), pszDoc); <br> <br>    uRet=MessageBox(m_hWnd, szTemp, PSZ(IDS_CAPTION) <br>        , MB_YESNOCANCEL | MB_ICONEXCLAMATION); <br> <br>    /* <br>     * If the user wants to save, tell the window to execute the <br>     * command. <br>     */ <br>    if (IDYES==uRet) <br>        return (BOOL)SendCommand(m_hWnd, IDM_FILESAVE, 0, 0); <br> <br>    //TRUE for No, False for Cancel <br>    return (IDCANCEL!=uRet); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::UpdateMenus <br> * <br> * Purpose: <br> *  Handles the WM_INITMENU message for the frame window.  Depending <br> *  on the existence of an active window, menu items are selectively <br> *  enabled and disabled. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the menu to intialize <br> *  iMenu           UINT position of the menu. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::UpdateMenus(HMENU hMenu, UINT iMenu) <br>    { <br>    PCDocument  pDoc; <br>    BOOL        fOK=FALSE; <br>    UINT        uTemp; <br>    UINT        uTempE; <br>    UINT        uTempD; <br> <br>    pDoc=m_pCL-&gt;ActiveDocument(); <br> <br>    uTempE=MF_ENABLED | MF_BYCOMMAND; <br>    uTempD=MF_DISABLED | MF_GRAYED | MF_BYCOMMAND; <br>    uTemp=((NULL!=pDoc) ? uTempE : uTempD); <br> <br>    /* <br>     * File menu:  If there is no current document window, disable <br>     * Close, Save, and Save As.  If there is a document but <br>     * it doesn't have a filename, disable save. <br>     */ <br>    if (m_phMenu[0]==hMenu) <br>        { <br>        EnableMenuItem(hMenu, IDM_FILECLOSE,  uTemp); <br>        EnableMenuItem(hMenu, IDM_FILESAVE,   uTemp); <br>        EnableMenuItem(hMenu, IDM_FILESAVEAS, uTemp); <br> <br>        if (NULL!=pDoc) <br>            fOK=pDoc-&gt;FQuerySave(); <br> <br>        EnableMenuItem(hMenu, IDM_FILESAVE, (fOK) ? uTempE : uTempD); <br>        } <br> <br> <br>    /* <br>     * Edit menus:  If there's no document, disable all of it. <br>     * If there's a document but no clipboard format available, <br>     * disable paste only. <br>     */ <br>    if (m_phMenu[1]==hMenu) <br>        { <br>        EnableMenuItem(hMenu, IDM_EDITUNDO,  uTemp); <br>        EnableMenuItem(hMenu, IDM_EDITCOPY,  uTemp); <br>        EnableMenuItem(hMenu, IDM_EDITCUT,   uTemp); <br> <br>        /* <br>         * Paste has two dependencies; format available and an open <br>         * document <br>         */ <br>        if (NULL!=pDoc) <br>            fOK=pDoc-&gt;FQueryPaste(); <br> <br>        fOK &amp;=(uTemp==uTempE); <br>        EnableMenuItem(hMenu,IDM_EDITPASTE, (fOK) ? uTempE : uTempD); <br>        } <br> <br> <br>   #ifdef MDI <br>    //Window menu:  no document, no commands <br>    if (m_hMenuWindow==hMenu) <br>        { <br>        EnableMenuItem(hMenu, IDM_WINDOWCASCADE,  uTemp); <br>        EnableMenuItem(hMenu, IDM_WINDOWTILEHORZ, uTemp); <br>        EnableMenuItem(hMenu, IDM_WINDOWTILEVERT, uTemp); <br>        EnableMenuItem(hMenu, IDM_WINDOWICONS,    uTemp); <br>        } <br>   #endif <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::UpdateGizmos <br> * <br> * Purpose: <br> *  Enables and disables gizmos depending on whether we have <br> *  a document or not and depending on clipboard format availability. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::UpdateGizmos(void) <br>    { <br>    PCDocument  pDoc; <br>    BOOL        fEnable; <br> <br>    pDoc=m_pCL-&gt;ActiveDocument(); <br>    fEnable=(NULL!=pDoc); <br> <br>    if (m_fLastEnable!=fEnable) <br>        { <br>        m_fLastEnable=fEnable; <br> <br>        //No document, disable just about everything <br>        m_pGB-&gt;Enable(IDM_FILECLOSE,  fEnable); <br>        m_pGB-&gt;Enable(IDM_FILESAVE,   fEnable); <br> <br>        m_pGB-&gt;Enable(IDM_EDITUNDO,  fEnable); <br>        m_pGB-&gt;Enable(IDM_EDITCUT,   fEnable); <br>        m_pGB-&gt;Enable(IDM_EDITCOPY,  fEnable); <br>        } <br> <br>    //Special handling:  clipboard format available, enable paste <br>    if (NULL!=pDoc) <br>        fEnable &amp;= pDoc-&gt;FQueryPaste(); <br> <br>    //Paste is not enabled unless there's a document too <br>    if (m_fLastPaste!=fEnable) <br>        { <br>        m_fLastPaste=fEnable; <br>        m_pGB-&gt;Enable(IDM_EDITPASTE, fEnable); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFrame::WindowTitleSet <br> * <br> * Purpose: <br> *  Handles changing the caption bar of a document window. <br> * <br> * Parameters: <br> *  pDoc            PCDocument of the document affected.  If NULL, <br> *                  then we remove titles. </code></pre>
<p>
</p>
<pre><code>*  fDocTitle       BOOL indicating to set the document or the main <br> *                  window captions.  In MDI we may do either, this <br> *                  is ignored in SDI. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::WindowTitleSet(PCDocument pDoc, BOOL fDocTitle) <br>    { <br>    TCHAR       szTitle[CCHPATHMAX]; <br>    TCHAR       szFile[CCHPATHMAX]; <br> <br>    /* <br>     * Go grab the filename.  If we get an emtpy file back, then <br>     * we'll use (Untitled).  If we have a NULL document, then we'll <br>     * just set the title of the app back to having no filename. <br>     */ <br>    if (NULL!=pDoc) <br>        { <br>        pDoc-&gt;FilenameGet(szTitle, CCHPATHMAX); <br> <br>        if ((TCHAR)0==szTitle[0]) <br>            lstrcpy(szFile, PSZ(IDS_UNTITLED)); <br>        else <br>            { <br>            GetFileTitle(szTitle, szFile, sizeof(szFile)); <br>           #ifndef WIN32 <br>            AnsiUpper(szFile); <br>           #endif <br>            } <br>        } <br>    else <br>        szFile[0]=0; <br> <br>   #ifndef MDI <br>    //SDI always titles the application window <br>    fDocTitle=FALSE; <br>   #endif <br> <br>    if (fDocTitle) <br>        { <br>        if (NULL!=pDoc) <br>            SetWindowText(pDoc-&gt;Window(), szFile); <br>        } <br>    else <br>        { <br>        if ((TCHAR)0!=szFile[0]) <br>            { <br>            wsprintf(szTitle, TEXT("%s - %s"), PSZ(IDS_CAPTION) <br>                , (LPTSTR)szFile); <br>            SetWindowText(m_hWnd, szTitle); <br>            } <br>        else <br>            SetWindowText(m_hWnd, PSZ(IDS_CAPTION)); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::GetStatusControl (inline) <br> * <br> * Purpose: <br> *  Returns the StatStrip object pointer to the caller so they can <br> *  display status messages. <br> * <br> * Parameters: <br> *  None <br> * <br> * <br> * Return Value: <br> *  PCStatStrip     Pointer to the status strip object. <br> */ <br> <br>PCStatStrip inline CFrame::GetStatusControl(void) <br>    { <br>    return m_pSS; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
