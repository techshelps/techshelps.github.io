<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDOCUMNT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1055"></a>CDOCUMNT.CPP</h2>
<pre><code>/* <br> * CDOCUMNT.CPP <br> * Sample Code Class Libraries <br> * <br> * Implementation of the CDocument class. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;string.h&gt; <br>#include "classlib.h" <br> <br> <br> <br>/* <br> * CDocument::CDocument <br> * CDocument::~CDocument <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame, a back pointer to the frame window. <br> */ <br> <br>CDocument::CDocument(HINSTANCE hInst, PCFrame pFR) <br>    : CWindow(hInst) <br>    { <br>    m_pFR=pFR; <br>    m_pST=NULL; <br>    m_pAdv=NULL; <br>    return; <br>    } <br> <br> <br>CDocument::~CDocument(void) <br>    { <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FInit <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window then passes that here for further <br> *  initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization params <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FInit(PDOCUMENTINIT pDI) <br>    { <br>    if (NULL==pDI) <br>        return FALSE; <br> <br>    if (NULL==pDI-&gt;hWndDoc) <br>        return FALSE; <br> <br>    //Create our stringtable <br>    m_pST=new CStringTable(m_hInst); <br> <br>    if (!m_pST-&gt;FInit(pDI-&gt;idsMin, pDI-&gt;idsMax)) <br>        return FALSE; <br> <br>    m_hWnd=pDI-&gt;hWndDoc; <br>    m_pAdv=pDI-&gt;pAdv; <br>    m_cf  =RegisterClipboardFormat(PSZ(IDS_CLIPBOARDFORMAT)); <br> <br>    m_fDirty=FALSE; <br>    m_fNoDirty=FALSE; <br>    m_fNoSize=FALSE; <br> <br>    m_fFileKnown=FALSE; <br>    m_szFile[0]=0; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FMessageHook <br> * <br> * Purpose: <br> *  Provides a derivation of the base CDocument class to hook all <br> *  messages to the window procedure for special processing, <br> *  including WM_COMMAND since that is much less common for a <br> *  document than for a frame (see CFrame::OnCommand). <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return value <br> *                  for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CDocument::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    *pLRes=0; <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FDirtySet <br> * <br> * Purpose: <br> *  Sets or clears the document 'dirty' flag returning the previous <br> *  state of that same flag. <br> * <br> * Parameters: <br> *  fDirty          BOOL indicating the new contents of the dirty <br> *                  flag. <br> * <br> * Return Value: <br> *  BOOL            Previous value of the dirty flag. <br> */ <br> <br>BOOL CDocument::FDirtySet(BOOL fDirty) <br>    { <br>    BOOL        fPrevious; <br> <br>    /* <br>     * If we are a hidden window, then there's nothing that could <br>     * make us dirty since there cannot be any user interaction here. <br>     */ <br>    if (!IsWindowVisible(m_hWnd)) <br>        return m_fDirty; <br> <br>    //Ignore the initial WM_SIZE on creation. <br>    if (m_fNoDirty) <br>        return m_fDirty; <br> <br>    fPrevious=m_fDirty; <br>    m_fDirty=fDirty; <br> <br>    return fPrevious; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FDirtyGet <br> * <br> * Purpose: <br> *  Returns the current dirty status of the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file is clean, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FDirtyGet() <br>    { <br>    return m_fDirty; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocument::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with no <br> *  filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocument::Clear() <br>    { <br>    FDirtySet(FALSE); <br>    Rename(NULL); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::ULoad <br> * <br> * Purpose: <br> *  Function that derived classes override.  Does nothing in base <br> *  class. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load.  If NULL then this <br> *                  is a new, untitled file, so perform any <br> *                  initialization for such a case. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_.  Always <br> *                  DOCERR_NOFILE here. <br> */ <br> <br>UINT CDocument::ULoad(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    Rename(NULL); <br>    return DOCERR_NOFILE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::USave <br> * <br> * Purpose: <br> *  Function that derived classes override.  Does nothing in base <br> *  class. <br> * <br> * Parameters: <br> *  uType           UINT type of file to save (from Save As dialog). <br> *  pszFile         LPTSTR providing the name under which we should <br> *                  save.  If NULL, then use the current name.  If <br> *                  non-NULL, then call Rename if save is successful <br> *                  and the name has changed. <br> * Return Value: <br> *  UINT            An error value from DOCERR_.  Always <br> *                  DOCERR_NOFILE here. <br> */ <br> <br>UINT CDocument::USave(UINT uType, LPTSTR pszFile) <br>    { <br>    return DOCERR_NOFILE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocument::ErrorMessage <br> * <br> * Purpose: <br> *  Displays an error message to the user appropriate for a given <br> *  error code.  If the code is DOCERR_NONE then this is a NOP. <br> * <br> * Parameters: <br> *  uErr            UINT identifying the error code. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocument::ErrorMessage(UINT uErr) <br>    { <br>    LPTSTR      psz; <br> <br>    switch (uErr) <br>        { <br>        case DOCERR_NONE: <br>            psz=NULL; <br>            break; <br> <br>        case DOCERR_NOFILE: <br>            psz=PSZ(IDS_FILEDOESNOTEXIST); <br>            break; <br> <br>        case DOCERR_COULDNOTOPEN: <br>            psz=PSZ(IDS_FILEOPENERROR); <br>            break; <br> <br>        case DOCERR_READFAILURE: <br>            psz=PSZ(IDS_FILELOADERROR); <br>            break; <br> <br>        case DOCERR_UNSUPPORTEDVERSION: <br>            psz=PSZ(IDS_VERSIONMISMATCH); <br>            break; <br> <br>        case DOCERR_WRITEFAILURE: <br>            psz=PSZ(IDS_FILESAVEERROR); <br>            break; <br> <br>        case DOCERR_CANCELLED: <br>            //No message on this. <br>            return; <br> <br>        default: <br>            psz=PSZ(IDS_UNKNOWNERROR); <br>            break; <br>        } <br> <br>    if (NULL!=psz) <br>        MessageBox(m_hWnd, psz, PSZ(IDS_DOCUMENTCAPTION), MB_OK); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FClip <br> * <br> * Purpose: <br> *  Places document data on the clipboard, optionally implementing <br> *  Cut by deleting the data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FClip(HWND hWndFrame, BOOL fCut) <br>    { <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CDocument::RenderFormat <br> * <br> * Purpose: <br> *  Returns a global memory handle containing a specific clipboard <br> *  format. <br> * <br> * Parameters: <br> *  cf              UINT format to render <br> * <br> * Return Value: <br> *  HGLOBAL         Memory handle of the rendering. <br> */ <br> <br>HGLOBAL CDocument::RenderFormat(UINT cf) <br>    { <br>    return NULL; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FQueryPaste(void) <br>    { <br>    return IsClipboardFormatAvailable(m_cf); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FPaste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  as the current data. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FPaste(HWND hWndFrame) <br>    { <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::Undo <br> * <br> * Purpose: <br> *  Reverses a previous action. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocument::Undo(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FQuerySave <br> * <br> * Purpose: <br> *  Returns whether or not a call to FSave will work. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have a known file, FALSE otherwise. <br> */ <br> <br>BOOL CDocument::FQuerySave(void) <br>    { <br>    return m_fFileKnown; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDocument::Rename <br> * <br> * Purpose: <br> *  Changes the name of the current file we're dealing with but <br> *  does no disk action.  FSave should be used after this <br> *  call to implement a Save As operation. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR to the filename to save ourselves under. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CDocument::Rename(LPTSTR pszFile) <br>    { <br>    //Clear out the filename on pszFile==NULL. <br>    if (NULL==pszFile) <br>        { <br>        m_szFile[0]=0; <br>        m_fFileKnown=FALSE; <br> <br>        //Tell the associate window to change captions. <br>        if (NULL!=m_pAdv) <br>            m_pAdv-&gt;OnCaptionChange(this); <br>        } <br> <br>    //First, check if anything changed <br>    if (NULL!=pszFile &amp;&amp; 0!=lstrcmpi(m_szFile, pszFile)) <br>        { <br>        /* <br>         * Copy the new filename to the document structure and inform <br>         * associate <br>         */ <br>        lstrcpyn(m_szFile, pszFile, CCHPATHMAX); <br> <br>        if (NULL!=m_pAdv) <br>            m_pAdv-&gt;OnCaptionChange(this); <br> <br>        m_fFileKnown=TRUE; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CDocument::FilenameGet <br> * <br> * Purpose: <br> *  Retrieves the current filename used in the document. <br> * <br> * Parameters: <br> *  psz             LPTSTR in which to store the filename. <br> *  cchMax          UINT maximum number of characters to copy. <br> * <br> * Return Value: <br> *  UINT            Number of characters copied. <br> */ <br> <br>UINT CDocument::FilenameGet(LPTSTR psz, UINT cchMax) <br>    { <br>    UINT        uRet=0; <br> <br>    if (NULL!=psz) <br>        { <br>        lstrcpyn(psz, m_szFile, cchMax); <br>        uRet=lstrlen(m_szFile); <br>        } <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CDocument::FrameGet <br> * <br> * Purpose: <br> *  Returns the CFrame pointer of the application frame. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCFrame         Pointer to the frame object. <br> */ <br> <br>PCFrame CDocument::FrameGet(void) <br>    { <br>    return m_pFR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
