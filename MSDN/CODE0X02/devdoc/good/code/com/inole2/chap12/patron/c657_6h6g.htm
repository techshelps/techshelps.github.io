<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context658"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Patron Chapter 12 <br> * <br> * Implementation of the CPatronDoc derivation of CDocument that <br> * manages pages for us. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br>#include &lt;memory.h&gt; <br>#include &lt;dlgs.h&gt;       //Pring Dlg button IDs <br> <br> <br> <br>/* <br> * CPatronDoc::CPatronDoc <br> * CPatronDoc::~CPatronDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> */ <br> <br>CPatronDoc::CPatronDoc(HINSTANCE hInst, PCFrame pFR) <br>    : CDocument(hInst, pFR) <br>    { <br>    m_pPG=NULL; <br>    m_lVer=VERSIONCURRENT; <br>    m_pIStorage=NULL; <br>    m_fPrintSetup=TRUE; <br>    m_pDropTarget=NULL; <br> <br>    m_cfEmbeddedObject=RegisterClipboardFormat(CF_EMBEDDEDOBJECT); <br>    m_cfObjectDescriptor=RegisterClipboardFormat <br>        (CF_OBJECTDESCRIPTOR); <br> <br>    //CHAPTER12MOD <br>    m_cfLinkSource=RegisterClipboardFormat(CF_LINKSOURCE); <br>    m_cfLinkSrcDescriptor=RegisterClipboardFormat <br>        (CF_LINKSRCDESCRIPTOR); <br> <br>    m_fShowTypes=FALSE; <br>    //End CHAPTER12MOD <br>    return; <br>    } <br> <br> <br>CPatronDoc::~CPatronDoc(void) <br>    { <br>    if (NULL!=m_pPG) <br>        delete m_pPG; <br> <br>    if (NULL!=m_pIStorage) <br>        m_pIStorage-&gt;Release(); <br> <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FInit <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FInit(PDOCUMENTINIT pDI) <br>    { <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::FInit(pDI)) <br>        return FALSE; <br> <br>    //Pages are created when we get a ULoad later. <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize the Pages <br> *  window. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    //Eat to prevent flickering <br>    if (WM_ERASEBKGND==iMsg) <br>        return TRUE; <br> <br>    if (WM_SIZE==iMsg &amp;&amp; NULL!=m_pPG) <br>        { <br>        dx=LOWORD(lParam); <br>        dy=HIWORD(lParam); <br> <br>        if (SIZE_MINIMIZED!=wParam) <br>            { <br>            //Resize Pages window to fit the new document size. <br>            GetClientRect(hWnd, &amp;rc); <br>            m_pPG-&gt;RectSet(&amp;rc, FALSE); <br>            } <br>        } <br> <br>    if (WM_DESTROY==iMsg) <br>        { <br>        /* <br>         * We have to revoke the drop target here because the window <br>         * will be destroyed and the property forcefully removed <br>         * before we could do this in the destructor. <br>         */ <br>        if (NULL!=m_pDropTarget) <br>            { <br>            RevokeDragDrop(m_hWnd); <br>            CoLockObjectExternal(m_pDropTarget, FALSE, TRUE); <br>            m_pDropTarget-&gt;Release(); <br>            } <br> <br>        return FALSE; <br>        } <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with no <br> *  filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Clear(void) <br>    { <br>    //Completely reset the pages <br>    if (NULL!=m_pPG) <br>        m_pPG-&gt;FIStorageSet(NULL, FALSE, FALSE); <br> <br>    CDocument::Clear(); <br>    m_lVer=VERSIONCURRENT; <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FDirtyGet <br> * <br> * Purpose: <br> *  Returns the current dirty status of the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file is clean, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FDirtyGet() <br>    { <br>    BOOL    fPageDirty; <br> <br>    fPageDirty=m_pPG-&gt;FIsDirty(); <br>    return m_fDirty | fPageDirty; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Delete <br> * <br> * Purpose: <br> *  Removed the current object from the document. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Delete(void) <br>    { <br>    if (NULL!=m_pPG) <br>        m_pPG-&gt;TenantDestroy(); <br> <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPrinterSetup <br> * <br> * Purpose: <br> *  Returns whether or not the Printer Setup menu item can be <br> *  enabled.  Once you create a tenant in any page, Printer Setup <br> *  is voided simply to keep this sample simple, that is, we don't <br> *  have to worry about reorganizing potentially large amounts <br> *  of layout after we start plopping down objects. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE to enable the menu, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPrinterSetup(void) <br>    { <br>    return m_fPrintSetup; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryObjectSelected <br> * <br> * Purpose: <br> *  Returns whether or not there is an object selected in this <br> *  document for Cut, Copy, Delete functions. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the Edit menu. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have an object, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryObjectSelected(HMENU hMenu) <br>    { <br>    return m_pPG-&gt;FQueryObjectSelected(hMenu); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::ULoad <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the editor. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load.  Could be NULL <br> *                  for an untitled document. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_... <br> */ <br> <br>UINT CPatronDoc::ULoad(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    RECT        rc; <br>    LPSTORAGE   pIStorage; <br>    HRESULT     hr; <br>    CLSID       clsID; <br>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                    | STGM_SHARE_EXCLUSIVE; <br> <br>    if (NULL==pszFile) <br>        { <br>        //Create a new temp file. <br>        hr=StgCreateDocfile(NULL, dwMode | STGM_CREATE <br>            | STGM_DELETEONRELEASE, 0, &amp;pIStorage); <br> <br>        //Mark this our class since we check with ReadClassStg. <br>        if (SUCCEEDED(hr)) <br>            WriteClassStg(pIStorage, CLSID_PatronPages); <br>        } <br>    else <br>        { <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsFile[MAX_PATH]; <br>        mbstowcs(pwcsFile, pszFile, MAX_PATH); <br>        hr=StgOpenStorage(pwcsFile, NULL, dwMode, NULL, 0, &amp;pIStorage); <br>#else <br>        hr=StgOpenStorage(pszFile, NULL, dwMode, NULL, 0, &amp;pIStorage); <br>#endif <br>        } <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    //Check if this is our type of file and exit if not. <br>    hr=ReadClassStg(pIStorage, &amp;clsID); <br> <br>    if (FAILED(hr) || CLSID_PatronPages!=clsID) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //Attempt to create our contained Pages window. <br>    m_pPG=new CPages(m_hInst, m_cf); <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    if (!m_pPG-&gt;FInit(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_PAGES, NULL)) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    if (!m_pPG-&gt;FIStorageSet(pIStorage, FALSE <br>        , (BOOL)(NULL==pszFile))) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //Open the window up for drag-drop <br>    m_pDropTarget=new CDropTarget(this); <br> <br>    if (NULL!=m_pDropTarget) <br>        { <br>        m_pDropTarget-&gt;AddRef(); <br>        CoLockObjectExternal(m_pDropTarget, TRUE, FALSE); <br>        RegisterDragDrop(m_hWnd, m_pDropTarget); <br>        } <br> <br>    m_pIStorage=pIStorage; <br>    Rename(pszFile); <br> <br>    //Do initial setup if new file, otherwise Pages handles things. <br>    if (NULL==pszFile) <br>        { <br>        //Go initialize the Pages for the default printer. <br>        if (!PrinterSetup(NULL, TRUE)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        //Go create an initial page. <br>        m_pPG-&gt;PageInsert(0); <br>        } <br>    else <br>        { <br>        //Can't change an already saved configuration <br>        m_fPrintSetup=FALSE; <br>        } <br> <br>    FDirtySet(FALSE); <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::USave <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user <br> *  has previously used FileOpen or FileSaveAs in order to have <br> *  a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_... <br> */ <br> <br>UINT CPatronDoc::USave(UINT uType, LPTSTR pszFile) <br>    { <br>    HRESULT     hr; <br>    LPSTORAGE   pIStorage; <br> <br>    //Save or Save As with the same file is just a commit. <br>    if (NULL==pszFile <br>        || (NULL!=pszFile &amp;&amp; 0==lstrcmpi(pszFile, m_szFile))) <br>        { <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsTemp[256]; <br>        mbstowcs(pwcsTemp, PSZ(IDS_CLIPBOARDFORMAT), 256); <br>        WriteFmtUserTypeStg(m_pIStorage, m_cf, pwcsTemp); <br>#else <br>        WriteFmtUserTypeStg(m_pIStorage, m_cf <br>            , PSZ(IDS_CLIPBOARDFORMAT)); <br>#endif <br>        //Insure pages are up to date. <br>        m_pPG-&gt;FIStorageUpdate(FALSE); <br> <br>        //Commit everyting <br>        m_pIStorage-&gt;Commit(STGC_ONLYIFCURRENT); <br> <br>        FDirtySet(FALSE); <br>        return DOCERR_NONE; <br>        } <br> <br>    /* <br>     * When we're given a name, open the storage, creating it new <br>     * if it does not exist or overwriting the old one.  Then CopyTo <br>     * from the current to the new, Commit the new, Release the old. <br>     */ <br> <br>    OLECHAR pwcsFile[MAX_PATH]; <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    mbstowcs(pwcsFile, pszFile, MAX_PATH); <br>#else <br>    pwcsFile = pszFile; <br>#endif <br>    hr=StgCreateDocfile(pwcsFile, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    WriteClassStg(pIStorage, CLSID_PatronPages); <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    OLECHAR pwcsTemp[256]; <br>    mbstowcs(pwcsTemp, PSZ(IDS_CLIPBOARDFORMAT), 256); <br>    WriteFmtUserTypeStg(pIStorage, m_cf, pwcsTemp); <br>#else <br>    WriteFmtUserTypeStg(pIStorage, m_cf, PSZ(IDS_CLIPBOARDFORMAT)); <br>#endif <br> <br>    //Insure all pages are up-to-date. <br>    m_pPG-&gt;FIStorageUpdate(TRUE); <br> <br>    //This also copies the CLSID we stuff in here on file creation. <br>    hr=m_pIStorage-&gt;CopyTo(NULL, NULL, NULL, pIStorage); <br> <br>    if (FAILED(hr)) <br>        { <br>        SCODE       sc; <br> <br>        pIStorage-&gt;Release(); <br>        sc=hr; <br> <br>        /* <br>         * If we failed because of low memory, use IRootStorage <br>         * to switch into the new file. <br>         */ <br>        if (E_OUTOFMEMORY==sc) <br>            { <br>            LPROOTSTORAGE        pIRoot; <br> <br>            //Delete file we already created <br>            DeleteFile(pszFile); <br> <br>            if (FAILED(m_pIStorage-&gt;QueryInterface <br>                (IID_IRootStorage, (PPVOID)&amp;pIRoot))) <br>                return DOCERR_WRITEFAILURE; <br>            hr=pIRoot-&gt;SwitchToFile(pwcsFile); <br>            pIRoot-&gt;Release(); <br> <br>            if (FAILED(hr)) <br>                return DOCERR_WRITEFAILURE; <br> <br>            //If successful, the Commit below finishes the save. <br>            pIStorage=m_pIStorage; <br>            m_pIStorage-&gt;AddRef();    //Matches Release below <br>            } <br>        } <br> <br>    pIStorage-&gt;Commit(STGC_ONLYIFCURRENT); <br> <br>    /* <br>     * Revert changes on the original storage.  If this was a temp <br>     * file, it's deleted since we used STGM_DELETEONRELEASE. <br>     */ <br>    m_pIStorage-&gt;Release(); <br> <br>    //Make this new storage current <br>    m_pIStorage=pIStorage; <br>    m_pPG-&gt;FIStorageSet(pIStorage, TRUE, FALSE); <br> <br>    FDirtySet(FALSE); <br>    Rename(pszFile);    //Update caption bar. <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FClip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FClip(HWND hWndFrame, BOOL fCut) <br>    { <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    return m_pPG-&gt;TenantClip(fCut); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FPaste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FPaste(HWND hWndFrame) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet=FALSE; <br>    FORMATETC       fe; <br>    TENANTTYPE      tType; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    //Go get type and format we *can* paste, then actually paste it. <br>    if (FQueryPasteFromData(pIDataObject, &amp;fe, &amp;tType)) <br>        { <br>        fRet=FPasteFromData(pIDataObject, &amp;fe, tType, NULL <br>            , 0L, TRUE); <br>        } <br> <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPaste(void) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    fRet=FQueryPasteFromData(pIDataObject, NULL, NULL); <br> <br>    //CHAPTER12MOD <br>    fRet |= FQueryPasteLinkFromData(pIDataObject, NULL, NULL); <br>    //End CHAPTER12MOD <br> <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FPasteSpecial <br> * <br> * Purpose: <br> *  Retrieves a specific data format from the clipboard and sends <br> *  it to the editor window appropriately. <br> * <br> *  Note that if this function is called, then the appropriate <br> *  format is available because the Paste menu item is only <br> *  enabled if the format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FPasteSpecial(HWND hWndFrame) <br>    { <br>    OLEUIPASTESPECIAL   ps; <br>    //CHAPTER12MOD <br>    OLEUIPASTEENTRY     rgPaste[6]; <br>    UINT                rgcf[1];        //For ps.m_arrLinkTypes <br>    //End CHAPTER12MOD <br>    DWORD               dwData=0; <br>    UINT                uTemp; <br>    BOOL                fRet=FALSE; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    memset(&amp;ps, 0, sizeof(ps)); <br> <br>    if (FAILED(OleGetClipboard(&amp;ps.lpSrcDataObj))) <br>        return FALSE; <br> <br>    ps.cbStruct=sizeof(ps); <br>    ps.hWndOwner=hWndFrame; <br> <br>    ps.dwFlags=PSF_SELECTPASTE; <br> <br>    ps.arrPasteEntries=rgPaste; <br>    //CHAPTER12MOD <br>    ps.cPasteEntries=6; <br>    //End CHAPTER12MOD <br> <br>    //Set up Paste Special descriptor arrays. <br>    SETDefFormatEtc(rgPaste[0].fmtetc, m_cf, TYMED_HGLOBAL); <br>    rgPaste[0].lpstrFormatName=PSZ(IDS_CLIPBOARDFORMAT); <br>    rgPaste[0].lpstrResultText=PSZ(IDS_PASTEASPATRON); <br>    rgPaste[0].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    //Embedded objects can be iconic displays if the user wants. <br>    SETDefFormatEtc(rgPaste[1].fmtetc, m_cfEmbeddedObject <br>        , TYMED_ISTORAGE); <br>    rgPaste[1].lpstrFormatName=PSZ(IDS_PASTEOBJECT); <br>    rgPaste[1].lpstrResultText=PSZ(IDS_PASTEASOBJECT); <br> <br>    /* <br>     * CAUTION:  Use OLEUI_PASTE with embedded objects or else <br>     * this item will not show up in the dialog.  I learned this the <br>     * hard way (that is, after about 6 hours of pulling hair!). <br>     */ <br>    rgPaste[1].dwFlags=OLEUIPASTE_PASTE | OLEUIPASTE_ENABLEICON; <br> <br> <br>    SETDefFormatEtc(rgPaste[2].fmtetc,CF_METAFILEPICT,TYMED_MFPICT); <br>    rgPaste[2].lpstrFormatName=PSZ(IDS_PASTEMETAFILE); <br>    rgPaste[2].lpstrResultText=PSZ(IDS_PASTEASMETAFILE); <br>    rgPaste[2].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    SETDefFormatEtc(rgPaste[3].fmtetc, CF_DIB, TYMED_HGLOBAL); <br>    rgPaste[3].lpstrFormatName=PSZ(IDS_PASTEDIB); <br>    rgPaste[3].lpstrResultText=PSZ(IDS_PASTEASDIB); <br>    rgPaste[3].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    SETDefFormatEtc(rgPaste[4].fmtetc, CF_BITMAP, TYMED_GDI); <br>    rgPaste[4].lpstrFormatName=PSZ(IDS_PASTEBITMAP); <br>    rgPaste[4].lpstrResultText=PSZ(IDS_PASTEASBITMAP); <br>    rgPaste[4].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    //CHAPTER12MOD <br>    SETDefFormatEtc(rgPaste[5].fmtetc,m_cfLinkSource,TYMED_ISTREAM); <br>    rgPaste[5].lpstrFormatName=PSZ(IDS_PASTELINK); <br>    rgPaste[5].lpstrResultText=PSZ(IDS_PASTEASLINK); <br>    rgPaste[5].dwFlags=OLEUIPASTE_LINKTYPE1 | OLEUIPASTE_ENABLEICON; <br> <br>    //Types we can Paste Link from the clipboard. <br>    rgcf[0]=m_cfLinkSource; <br>    ps.arrLinkTypes=rgcf; <br>    ps.cLinkTypes=1; <br>    //End CHAPTER12MOD <br> <br>    uTemp=OleUIPasteSpecial(&amp;ps); <br> <br>    if (OLEUI_OK==uTemp) <br>        { <br>        UINT        i=ps.nSelectedIndex; <br>        TENANTTYPE  tType; <br> <br>        //CHAPTER12MOD <br>        if (ps.fLink) <br>            tType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br>        else <br>            { <br>            if (1==ps.nSelectedIndex) <br>                tType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br>            else <br>                tType=TENANTTYPE_STATIC; <br>            } <br>        //End CHAPTER12MOD <br> <br>        //CHAPTER12MOD <br>        //Handle iconic aspects...from links as well <br>        if ((1==i || ps.fLink) &amp;&amp; (PSF_CHECKDISPLAYASICON <br>            &amp; ps.dwFlags) &amp;&amp; NULL!=ps.hMetaPict) <br>        //End CHAPTER12MOD <br>            { <br>            rgPaste[i].fmtetc.dwAspect=DVASPECT_ICON; <br>            dwData=(DWORD)(UINT)ps.hMetaPict; <br>            } <br> <br>        fRet=FPasteFromData(ps.lpSrcDataObj, &amp;rgPaste[i].fmtetc <br>            , tType, NULL, dwData, FALSE); <br> <br>        //Always free this regardless of what we do with it. <br>        if (NULL!=ps.hMetaPict) <br>            OleUIMetafilePictIconFree(ps.hMetaPict); <br>        } <br> <br>    ps.lpSrcDataObj-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste data from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> *  pFE             LPFORMATETC in which to return the first format <br> *                  we can use.  Ignored if NULL. <br> *  ptType          PTENANTTYPE in which to store the type of <br> *                  object we can paste.  Ignored if NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, PTENANTTYPE ptType) <br>    { <br>    FORMATETC       fe; <br>    HRESULT         hr, hr2; <br> <br>    if (NULL!=(LPVOID)ptType) <br>        *ptType=TENANTTYPE_STATIC; <br> <br>    //Any of our specific data here? <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>    //If embedded object data is available, set the appropriate type <br>    hr2=OleQueryCreateFromData(pIDataObject); <br> <br>    if (NOERROR==hr2) <br>        { <br>        if (NULL!=pFE) <br>            { <br>            /* <br>             * Default to content.  FPaste will use <br>             * CF_OBJECTDESCRIPTOR to figure the actual aspect. <br>             */ <br>            SETDefFormatEtc(*pFE, m_cfEmbeddedObject <br>                , TYMED_ISTORAGE); <br>            } <br> <br>        if (NULL!=(LPVOID)ptType) <br>            *ptType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br> <br>        /* <br>         * Return now if PatronObject wasn't available, otherwise <br>         * break out so that pFE gets PatronObject format. <br>         */ <br>        if (NOERROR!=hr) <br>            return TRUE; <br>        } <br> <br> <br>    if (NOERROR!=hr &amp;&amp; NOERROR!=hr2) <br>        { <br>        //Try metafile, DIB, then bitmap, setting fe each time <br>        SETDefFormatEtc(fe, CF_METAFILEPICT, TYMED_MFPICT); <br>        hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>        if (NOERROR!=hr) <br>            { <br>            SETDefFormatEtc(fe, CF_DIB, TYMED_HGLOBAL); <br>            hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>            if (NOERROR!=hr) <br>                { <br>                SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI); <br>                hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br>                } <br>            } <br>        } <br> <br>    if (NOERROR==hr &amp;&amp; NULL!=pFE) <br>        *pFE=fe; <br> <br>    return (NOERROR==hr); <br>    } <br> <br> <br> <br> <br> <br>//CHAPTER12MOD <br>/* <br> * CPatronDoc::FQueryPasteLinkFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste link from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> *  pFE             LPFORMATETC in which to return the first format <br> *                  we can use.  Ignored if NULL. <br> *  ptType          PTENANTTYPE in which to store the type of object <br> *                  we can paste.  Ignored if NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPasteLinkFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, PTENANTTYPE ptType) <br>    { <br>    HRESULT         hr; <br> <br>    if (NULL==pIDataObject) <br>        return FALSE; <br> <br>    hr=OleQueryLinkFromData(pIDataObject); <br> <br>    if (NOERROR!=hr) <br>        return FALSE; <br> <br>    if (NULL!=pFE) <br>        SETDefFormatEtc(*pFE, m_cfLinkSource, TYMED_ISTREAM); <br> <br>    if (NULL!=(LPVOID)ptType) <br>        *ptType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br> <br>    return TRUE; <br>    } <br> <br> <br>//End CHAPTER12MOD <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FPasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Retrieves the private data format from a data object and sets <br> *  it to the current figure in the editor window. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> *  pFE             LPFORMATETC to use in the paste. Cannot be NULL. <br> *  tType           TENANTTYPE to paste. <br> *  ppo             PPATRONOBJECT containing placement data. <br> *  dwData          DWORD extra data sensitive to tType <br> *  fUseObjDesc     BOOL indicating to use CF_OBJECTDESCRIPTOR <br> *                  format for determining the aspect of the object <br> *                  if the format is available. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FPasteFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, TENANTTYPE tType, PPATRONOBJECT ppo <br>    , DWORD dwData, BOOL fUseObjDesc) <br>    { <br>    BOOL                fRet; <br>    HRESULT             hr; <br>    PATRONOBJECT        po; <br>    STGMEDIUM           stm; <br>    LPOBJECTDESCRIPTOR  pOD; <br>    FORMATETC           fe; <br>    BOOL                fRelease=FALSE; <br> <br>    if (NULL==pFE) <br>        return FALSE; <br> <br>    //If not given any placement data, see if we can retrieve it <br>    if (pFE-&gt;cfFormat==m_cf &amp;&amp; NULL==ppo) <br>        { <br>        hr=pIDataObject-&gt;GetData(pFE, &amp;stm); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            ppo=(PPATRONOBJECT)GlobalLock(stm.hGlobal); <br> <br>            po=*ppo; <br>            ppo=&amp;po; <br> <br>            //If there's an object here, make sure type is right. <br>            if (ppo-&gt;fe.cfFormat==m_cfEmbeddedObject) <br>                tType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br> <br>            //CHAPTER12MOD <br>            if (ppo-&gt;fe.cfFormat==m_cfLinkSource) <br>                tType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br>            //End CHAPTER12MOD <br> <br>            GlobalUnlock(stm.hGlobal); <br>            ReleaseStgMedium(&amp;stm); <br>            } <br>        } <br> <br>    /* <br>     * If we're told to look at CF_OBJECTDESCRIPTOR, then try to get <br>     * the data and copy the aspect out of it.  We're not interested <br>     * in any other part of it, however. <br>     */ <br>    if (fUseObjDesc) <br>        { <br>        SETDefFormatEtc(fe, m_cfObjectDescriptor, TYMED_HGLOBAL); <br> <br>        //CHAPTER12MOD <br>        hr=pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br> <br>        if (FAILED(hr)) <br>            { <br>            SETDefFormatEtc(fe, m_cfLinkSrcDescriptor <br>                , TYMED_HGLOBAL); <br>            hr=pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br>            } <br> <br>        if (SUCCEEDED(hr)) <br>        //End CHAPTER12MOD <br>            { <br>            pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stm.hGlobal); <br>            pFE-&gt;dwAspect=pOD-&gt;dwDrawAspect; <br> <br>            if (NULL!=ppo) <br>                ppo-&gt;fe.dwAspect=pFE-&gt;dwAspect; <br> <br>            GlobalUnlock(stm.hGlobal); <br>            ReleaseStgMedium(&amp;stm); <br> <br>            /* <br>             * Furthermore, if pFE-&gt;dwAspect is DVASPECT_ICON, get <br>             * the metafile which will always be the icon <br>             * representation. <br>             */ <br>            SETFormatEtc(fe, CF_METAFILEPICT, DVASPECT_ICON, NULL <br>                , TYMED_MFPICT, -1); <br> <br>            if (SUCCEEDED(pIDataObject-&gt;GetData(&amp;fe, &amp;stm))) <br>                { <br>                dwData=(DWORD)(UINT)stm.hGlobal; <br>                fRelease=TRUE; <br>                } <br>            } <br>        } <br> <br>    fRet=m_pPG-&gt;TenantCreate(tType, pIDataObject, pFE, ppo, dwData); <br> <br>    //Release the stm from the last GetData <br>    if (fRelease) <br>        ReleaseStgMedium(&amp;stm); <br> <br>    if (fRet) <br>        { <br>        //Disable Printer Setup once we've created a tenant. <br>        m_fPrintSetup=FALSE; <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>//CHAPTER12MOD <br>/* <br> * CPatronDoc::FQueryEnableEditLinks <br> * <br> * Purpose: <br> *  Determines whether or not the Edit Links menu item should be <br> *  enabled on the frame window menu. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE to enable the item, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryEnableEditLinks(void) <br>    { <br>    return m_pPG-&gt;FQueryLinksInPage(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FEditLinks <br> * <br> * Purpose: <br> *  Invokes the links dialog in which the end-user can manipulate <br> *  all the links in the current page. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame window to use as the dialog <br> *                  parent. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function was successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FEditLinks(HWND hWndFrame) <br>    { <br>    UINT                    uRet; <br>    OLEUIEDITLINKS          el; <br>    PCIOleUILinkContainer   pIUILinks; <br> <br>    memset(&amp;el, 0, sizeof(el)); <br>    el.cbStruct=sizeof(el); <br>    el.hWndOwner=hWndFrame; <br> <br>    if (!m_pPG-&gt;FGetUILinkContainer(&amp;pIUILinks)) <br>        return FALSE; <br> <br>    el.lpOleUILinkContainer=pIUILinks; <br>    uRet=OleUIEditLinks(&amp;el); <br> <br>    //Only the IOleUILinkContainer interface will know dirtying. <br>    m_fDirty=pIUILinks-&gt;m_fDirty; <br> <br>    el.lpOleUILinkContainer-&gt;Release(); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CPatronDoc::FShowOrQueryObjectTypes <br> * <br> * Purpose: <br> *  If querying, we return whether or not ShowObjects is active <br> *  in this document.  Otherwise pass-through to <br> *  CPages::ShowObjectTypes. <br> * <br> * Parameters: <br> *  fShow           BOOL indicating to show the type or not. <br> * <br> * Return Value: <br> *  None <br> */ </code></pre>
<p>
</p>
<pre><code><br>BOOL CPatronDoc::FShowOrQueryObjectTypes(BOOL fQuery, BOOL fShow) <br>    { <br>    if (fQuery) <br>        return m_fShowTypes; <br> <br>    m_fShowTypes=fShow; <br>    m_pPG-&gt;ShowObjectTypes(fShow); <br>    return TRUE; <br>    } <br> <br>//End CHAPTER12MOD <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Print <br> * <br> * Purpose: <br> *  Prints the current document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> * <br> * Return Value: <br> *  BOOL            TRUE if printing happened, FALSE if it didn't <br> *                  start or didn't complete. <br> */ <br> <br>BOOL CPatronDoc::Print(HWND hWndFrame) <br>    { <br>    PRINTDLG        pd; <br>    BOOL            fSuccess; <br> <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br>    pd.hwndOwner  =hWndFrame; <br>    pd.nCopies    =1; <br>    pd.nFromPage  =(USHORT)-1; <br>    pd.nToPage    =(USHORT)-1; <br>    pd.nMinPage   =1; <br>    pd.nMaxPage   =m_pPG-&gt;NumPagesGet(); <br> <br>    pd.lpfnPrintHook=PrintDlgHook; <br> <br>    //Get the current document printer settings <br>    pd.hDevMode=m_pPG-&gt;DevModeGet(); <br> <br>    pd.Flags=PD_RETURNDC | PD_ALLPAGES | PD_COLLATE <br>        | PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_ENABLEPRINTHOOK; <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (NULL!=pd.hDevMode) <br>        GlobalFree(pd.hDevMode); <br> <br>    if (NULL!=pd.hDevNames) <br>        GlobalFree(pd.hDevNames); <br> <br>    //Go do the actual printing. <br>    fSuccess=m_pPG-&gt;Print(pd.hDC, PSZ(IDS_DOCUMENTNAME), pd.Flags <br>        , pd.nFromPage, pd.nToPage, pd.nCopies); <br> <br>    if (!fSuccess) <br>        { <br>        MessageBox(m_hWnd, PSZ(IDS_PRINTERROR) <br>            , PSZ(IDS_DOCUMENTCAPTION), MB_OK); <br>        } <br> <br>    return fSuccess; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PrinterSetup <br> * <br> * Purpose: <br> *  Selects a new printer and options for this document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> *  fDefault        BOOL to avoid any dialog and just use the <br> *                  default. <br> * <br> * Return Value: <br> *  UINT            Undefined <br> * <br> */ <br> <br>UINT CPatronDoc::PrinterSetup(HWND hWndFrame, BOOL fDefault) <br>    { <br>    PRINTDLG        pd; <br> <br>    //Attempt to get printer metrics for the default printer. <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br> <br>    if (fDefault) <br>        pd.Flags=PD_RETURNDEFAULT; <br>    else <br>        { <br>        pd.hwndOwner=hWndFrame; <br>        pd.Flags=PD_PRINTSETUP; <br> <br>        //Get the current document printer settings <br>        pd.hDevMode=m_pPG-&gt;DevModeGet(); <br>        } <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (!m_pPG-&gt;DevModeSet(pd.hDevMode, pd.hDevNames)) <br>        { <br>        GlobalFree(pd.hDevNames); <br>        GlobalFree(pd.hDevMode); <br>        return FALSE; <br>        } <br> <br>    FDirtySet(TRUE); <br>    return 1; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NewPage <br> * <br> * Purpose: <br> *  Creates a new page in the document's pages control after the <br> *  current page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NewPage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageInsert(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::DeletePage <br> * <br> * Purpose: <br> *  Deletes the current page from the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the now current page. <br> */ <br> <br>UINT CPatronDoc::DeletePage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageDelete(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NextPage <br> * <br> * Purpose: <br> *  Shows the next page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NextPage(void) <br>    { <br>    UINT        iPage; <br> <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(++iPage); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PreviousPage <br> * <br> * Purpose: <br> *  Shows the previous page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::PreviousPage(void) <br>    { <br>    UINT        iPage; <br> <br>    //If iPage is zero, then we wrap around to the end. <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(--iPage); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FirstPage <br> * <br> * Purpose: <br> *  Shows the first page page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::FirstPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(0); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::LastPage <br> * <br> * Purpose: <br> *  Shows the last page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the last page. <br> */ <br> <br>UINT CPatronDoc::LastPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(NOVALUE); <br>    } <br> <br> <br> <br>/* <br> * PrintDlgHook <br> * <br> * Purpose: <br> *  Callback hook for the Print Dialog so we can hide the Setup <br> *  button.  Patron only allows Setup before anything exists on <br> *  the page, and is not written to handle setup at Print time. <br> */ <br> <br>UINT CALLBACK PrintDlgHook(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    if (WM_INITDIALOG==iMsg) <br>        { <br>        HWND        hWnd; <br> <br>        hWnd=GetDlgItem(hDlg, psh1); <br>        ShowWindow(hWnd, SW_HIDE); <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Rename <br> * <br> * Purpose: <br> *  Overrides the normal rename to include notification of tenants <br> *  in this document of the new name.  This is so embedded objects <br> *  are told the correct name through IOleObject::SetHostNames. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR to the new filename. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Rename(LPTSTR pszFile) <br>    { <br>    //CHAPTER12MOD <br>    LPMONIKER   pmk; <br> <br>    //We don't need to change the base class, just augment... <br>    CDocument::Rename(pszFile); <br> <br>    //Give a moniker to linked objects in tenants. <br>    if (NULL!=pszFile) <br>        { <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsFile[MAX_PATH]; <br>        mbstowcs(pwcsFile, pszFile, MAX_PATH); <br>        CreateFileMoniker(pwcsFile, &amp;pmk); <br>#else <br>        CreateFileMoniker(pszFile, &amp;pmk); <br>#endif <br>        m_pPG-&gt;NotifyTenantsOfRename(pszFile, pmk); <br> <br>        //No need for us to hold on to this. <br>        pmk-&gt;Release(); <br>        } <br> <br>    //End CHAPTER12MOD <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FInsertObject <br> * <br> * Purpose: <br> *  Retrieves a CLSID or a filename from the Insert Object dialog <br> *  box and creates an object using those identifiers. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FInsertObject(HWND hWndFrame) <br>    { <br>    OLEUIINSERTOBJECT   io; <br>    DWORD               dwData=0; <br>    TCHAR               szFile[CCHPATHMAX]; <br>    UINT                uTemp; <br>    BOOL                fRet=FALSE; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    memset(&amp;io, 0, sizeof(io)); <br> <br>    io.cbStruct=sizeof(io); <br>    io.hWndOwner=hWndFrame; <br>    szFile[0]=0; <br>    io.lpszFile=szFile; <br>    io.cchFile=CCHPATHMAX; <br> <br>    //CHAPTER12MOD <br>    //We now support linking, so remove the IOF_DISABLELINK flag. <br>    io.dwFlags=IOF_SELECTCREATENEW; <br>    //End CHAPTER12MOD <br> <br>    uTemp=OleUIInsertObject(&amp;io); <br> <br>    if (OLEUI_OK==uTemp) <br>        { <br>        TENANTTYPE      tType; <br>        LPVOID          pv; <br>        FORMATETC       fe; <br> <br>        SETDefFormatEtc(fe, 0, TYMED_NULL); <br> <br>        if (io.dwFlags &amp; IOF_SELECTCREATENEW) <br>            { <br>            tType=TENANTTYPE_EMBEDDEDOBJECT; <br>            pv=&amp;io.clsid; <br>            } <br>        else <br>            { <br>            //CHAPTER12MOD <br>            if (io.dwFlags &amp; IOF_CHECKLINK) <br>                tType=TENANTTYPE_LINKEDFILE; <br>            else <br>                tType=TENANTTYPE_EMBEDDEDFILE; <br>            //End CHAPTER12MOD <br>            pv=szFile; <br>            } <br> <br>        if ((io.dwFlags &amp; IOF_CHECKDISPLAYASICON) <br>            &amp;&amp; NULL!=io.hMetaPict) <br>            { <br>            fe.dwAspect=DVASPECT_ICON; <br>            dwData=(DWORD)(UINT)io.hMetaPict; <br>            } <br> <br>        fRet=m_pPG-&gt;TenantCreate(tType, pv, &amp;fe, NULL, dwData); <br> <br>        //Free this regardless of what we do with it. <br>        if (NULL!=io.hMetaPict) <br>            OleUIMetafilePictIconFree(io.hMetaPict); <br> <br>        if (fRet) <br>            { <br>            //Disable Printer Setup once we've created a tenant. <br>            m_fPrintSetup=FALSE; <br>            FDirtySet(TRUE); <br>            } <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::ActivateObject <br> * <br> * Purpose: <br> *  Executes a verb on the currently selected object. <br> * <br> * Parameters: <br> *  iVerb           LONG of the selected verb. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::ActivateObject(LONG iVerb) <br>    { <br>    m_pPG-&gt;ActivateObject(iVerb); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
