<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYLINE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context645"></a>POLYLINE.CPP</h2>
<pre><code>/* <br> * POLYLINE.CPP <br> * Cosmo Chapter 12 <br> * <br> * Implementation of the CPolyline class. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CPolyline:CPolyline <br> * CPolyline::~CPolyline <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application we're in. <br> */ <br> <br>CPolyline::CPolyline(HINSTANCE hInst) <br>    : CWindow(hInst) <br>    { <br>    m_pAdv=NULL; <br>    m_hWnd=NULL; <br>    return; <br>    } <br> <br> <br>CPolyline::~CPolyline(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::Init <br> * <br> * Purpose: <br> *  Instantiates a polyline window within a given parent.  The <br> *  parent may be a main application window, could be an MDI child <br> *  window. We really do not care. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  pRect           LPRECT that this window should occupy <br> *  dwStyle         DWORD containing the window's style flags <br> *  uID             UINT ID to associate with this window <br> *  pAdv            PCPolylineAdviseSink of the sink wanting our <br> *                  notifications. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPolyline::Init(HWND hWndParent, LPRECT pRect, DWORD dwStyle <br>    , UINT uID, PCPolylineAdviseSink pAdv) <br>    { <br>    m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, SZCLASSPOLYLINE <br>        , SZCLASSPOLYLINE, dwStyle, pRect-&gt;left, pRect-&gt;top <br>        , pRect-&gt;right-pRect-&gt;left, pRect-&gt;bottom-pRect-&gt;top <br>        , hWndParent, (HMENU)uID, m_hInst, this); <br> <br>    if (NULL!=m_hWnd) <br>        m_pAdv=pAdv; <br> <br>    return (NULL!=m_hWnd); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::New <br> * <br> * Purpose: <br> *  Cleans out and reinitializes the data to defaults. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::New(void) <br>    { <br>    UINT        i; <br>    RECT        rc; <br> <br>    m_pl.wVerMaj=VERSIONMAJOR; <br>    m_pl.wVerMin=VERSIONMINOR; <br> <br>    //Our rectangle is the size of our window's client area. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    RECTTORECTS(rc, m_pl.rc); <br> <br>    //Clean out the POLYLINE structure and repaint the window. <br>    for (i=0; i&lt; CPOLYLINEPOINTS; i++) <br>        { <br>        m_pl.rgpt[i].x=0; <br>        m_pl.rgpt[i].y=0; <br>        } <br> <br>    m_pl.cPoints      =0; <br>    m_pl.rgbBackground=GetSysColor(COLOR_WINDOW); <br>    m_pl.rgbLine      =GetSysColor(COLOR_WINDOWTEXT); <br>    m_pl.iLineStyle   =PS_SOLID; <br> <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br>    UpdateWindow(m_hWnd); <br> <br>    //Inform the advise sink of this data change. <br>    if (NULL!=m_pAdv) <br>        m_pAdv-&gt;OnDataChange(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPolyline::Undo <br> * <br> * Purpose: <br> *  Reverses previous actions in a Polyline. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if we can Undo more, FALSE otherwise. <br> */ <br> <br>BOOL CPolyline::Undo(void) <br>    { <br>    //Decrement the number of active points and repaint. <br>    if (m_pl.cPoints &gt; 0) <br>        { <br>        m_pl.cPoints--; <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        } <br> <br>    if (NULL!=m_pAdv) <br>        m_pAdv-&gt;OnPointChange(); <br> <br>    //Return if we can undo any more. <br>    return (0!=m_pl.cPoints); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::ReadFromStorage <br> * <br> * Purpose: <br> *  Loads our data (any known version) from an IStorage returning <br> *  the version number of the data or an error value. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE from which we'll read. <br> * <br> * Return Value: <br> *  LONG            Version number or negative POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::ReadFromStorage(LPSTORAGE pIStorage) <br>    { <br>    POLYLINEDATA    pl; <br>    ULONG           cb=(ULONG)-1; <br>    ULONG           cbExpect=0; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br>    LARGE_INTEGER   li; <br> <br>    if (NULL==pIStorage) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //Open the CONTENTS stream <br>    hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT | STGM_READ <br>        | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //Read version numbers and seek back to file beginning. <br>    hr=pIStream-&gt;Read(&amp;pl, 2*sizeof(WORD), &amp;cb); <br> <br>    LISet32(li, 0); <br>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br> <br>    if (FAILED(hr) || 2*sizeof(WORD)!=cb) <br>        { <br>        pIStream-&gt;Release(); <br>        return POLYLINE_E_READFAILURE; <br>        } <br> <br>    /* <br>     * For version 2.0, read the entire file.  For version 1.0 read <br>     * the file up to CBPOLYLINEDATAVER10.  For anything else, give <br>     * an error. <br>     */ <br> <br>    switch (pl.wVerMaj) <br>        { <br>        case VERSIONMAJOR:  //2.x <br>            switch (pl.wVerMin) <br>                { <br>                case VERSIONMINOR:  //2.0 <br>                    cbExpect=CBPOLYLINEDATA; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        case 1: //1.x <br>            switch (pl.wVerMin) <br>                { <br>                case 0:  //1.0 <br>                    cbExpect=CBPOLYLINEDATA10; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    if (0==cbExpect) <br>        { <br>        pIStream-&gt;Release(); <br>        return POLYLINE_E_UNSUPPORTEDVERSION; <br>        } <br> <br>    hr=pIStream-&gt;Read(&amp;pl, cbExpect, &amp;cb); <br>    pIStream-&gt;Release(); <br> <br>    if (cbExpect!=cb) <br>        return POLYLINE_E_READFAILURE; <br> <br>    /* <br>     * If we loaded successfully, make the data current.  By using <br>     * DataSet we centralize our version upgrading.  We size the <br>     * polyline window to the data AND notify the document so it <br>     * sizes to the polyline. <br>     */ <br>    DataSet(&amp;pl, TRUE, TRUE); <br> <br>    //Return what version we just loaded. <br>    return MAKELONG(pl.wVerMin, pl.wVerMaj); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::WriteToStorage <br> * <br> * Purpose: <br> *  Ignorantly writes our current data into a storage in a <br> *  particular version. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE in which to save. <br> *  lVer            LONG providing version number Major (HI) and <br> *                  Minor (Low) <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::WriteToStorage(LPSTORAGE pIStorage, LONG lVer) <br>    { <br>    ULONG           cb; <br>    ULONG           cbExpect=0; <br>    WORD            wVerMaj=HIWORD(lVer); <br>    WORD            wVerMin=LOWORD(lVer); <br>    POLYLINEDATA    pl; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br> <br>    if (NULL==pIStorage) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //Get a copy of our data in the version we're going to save. <br>    DataGet(&amp;pl, lVer); <br> <br>    switch (wVerMaj) <br>        { <br>        case VERSIONMAJOR:  //2.x <br>            switch (wVerMin) <br>                { <br>                case VERSIONMINOR:  //2.0 <br>                    cbExpect=CBPOLYLINEDATA; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        case 1: //1.x <br>            switch (wVerMin) <br>                { <br>                case 0:  //1.0 <br>                    cbExpect=CBPOLYLINEDATA10; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    if (0==cbExpect) <br>        return POLYLINE_E_UNSUPPORTEDVERSION; <br> <br>    hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT | STGM_CREATE <br>        | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 0, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return POLYLINE_E_WRITEFAILURE; <br> <br>    hr=pIStream-&gt;Write(&amp;pl, cbExpect, &amp;cb); <br>    pIStream-&gt;Release(); <br> <br>    if (FAILED(hr) || cbExpect!=cb) <br>        return POLYLINE_E_WRITEFAILURE; <br> <br>    return POLYLINE_E_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::ReadFromFile <br> * <br> * Purpose: <br> *  Loads our data (any known version) from a file handle returning <br> *  the version number of the data or an error value. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of the file to open. <br> * <br> * Return Value: <br> *  LONG            Version number or negative POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::ReadFromFile(LPTSTR pszFile) <br>    { <br>    OFSTRUCT        of; <br>    HFILE           hFile; <br>    POLYLINEDATA    pl; <br>    UINT            cb=(UINT)-1; <br>    UINT            cbExpect=0; <br> <br>    if (NULL==pszFile) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //OpenFileW is a member of CPolyline. <br>    hFile=OpenFileW(pszFile, &amp;of, OF_READ); <br> <br>    if (HFILE_ERROR==hFile) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //Read version numbers and seek back to file beginning. <br>    cb=_lread(hFile, &amp;pl, 2*sizeof(WORD)); <br>    _llseek(hFile, 0L, 0); <br> <br>    if (2*sizeof(WORD)!=cb) <br>        { <br>        _lclose(hFile); <br>        return POLYLINE_E_READFAILURE; <br>        } <br> <br>    /* <br>     * For version 2.0, read the entire file.  For version 1.0 read <br>     * the file up to CBPOLYLINEDATAVER10.  For anything else, give <br>     * an error. <br>     */ <br> <br>    switch (pl.wVerMaj) <br>        { <br>        case VERSIONMAJOR:  //2.x <br>            switch (pl.wVerMin) <br>                { <br>                case VERSIONMINOR:  //2.0 <br>                    cbExpect=CBPOLYLINEDATA; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        case 1: //1.x <br>            switch (pl.wVerMin) <br>                { <br>                case 0:  //1.0 <br>                    cbExpect=CBPOLYLINEDATA10; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    if (0==cbExpect) <br>        { <br>        _lclose(hFile); <br>        return POLYLINE_E_UNSUPPORTEDVERSION; <br>        } <br> <br>    cb=_lread(hFile, &amp;pl, cbExpect); <br>    _lclose(hFile); <br> <br>    if (cbExpect!=cb) <br>        return POLYLINE_E_READFAILURE; <br> <br>    /* <br>     * If we loaded successfully, make the data current.  By using <br>     * DataSet we centralize our version upgrading.  We size the <br>     * polyline window to the data AND notify the document so it <br>     * sizes to the polyline. <br>     */ <br>    DataSet(&amp;pl, TRUE, TRUE); <br> <br>    //Return what version we just loaded. <br>    return MAKELONG(pl.wVerMin, pl.wVerMaj); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::WriteToFile <br> * <br> * Purpose: <br> *  Ignorantly writes our current data into an opened file in a <br> *  particular version. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR filename in which to store the data. <br> *  lVer            LONG providing version number Major (HI) <br> *                  and Minor (Low) <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::WriteToFile(LPTSTR pszFile, LONG lVer) <br>    { <br>    OFSTRUCT        of; <br>    HFILE           hFile; <br>    UINT            cb; <br>    UINT            cbExpect=0; <br>    WORD            wVerMaj=HIWORD(lVer); <br>    WORD            wVerMin=LOWORD(lVer); <br>    POLYLINEDATA    pl; <br> <br>    if (NULL==pszFile) <br>        return POLYLINE_E_READFAILURE; <br> <br>    //Get a copy of our data in the version we're going to save. <br>    DataGet(&amp;pl, lVer); <br> <br>    switch (wVerMaj) <br>        { <br>        case VERSIONMAJOR:  //2.x <br>            switch (wVerMin) <br>                { <br>                case VERSIONMINOR:  //2.0 <br>                    cbExpect=CBPOLYLINEDATA; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        case 1: //1.x <br>            switch (wVerMin) <br>                { <br>                case 0:  //1.0 <br>                    cbExpect=CBPOLYLINEDATA10; <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    if (0==cbExpect) <br>        return POLYLINE_E_UNSUPPORTEDVERSION; <br> <br>    hFile=OpenFileW(pszFile, &amp;of, OF_CREATE | OF_WRITE); <br> <br>    if (HFILE_ERROR==hFile) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    cb=_lwrite(hFile, (LPCSTR)&amp;pl, cbExpect); <br>    _lclose(hFile); <br> <br>    return (cbExpect==cb) ? POLYLINE_E_NONE <br>        : POLYLINE_E_WRITEFAILURE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::OpenFileW (Private) <br> * <br> * Purpose: <br> *  Under Win32, OpenFile does not take Unicode strings.  This <br> *  function converts a Unicode string into an ANSI string and <br> *  calls OpenFile.  This just maps to OpenFile without Unicode. <br> * <br> * Parameters, Return Value: <br> *  Same as OpenFile. <br> */ <br> <br>HFILE CPolyline::OpenFileW(LPTSTR pszFile, LPOFSTRUCT pof <br>    , UINT uFlags) <br>    { <br>   #ifdef UNICODE <br>    CHAR        szTemp[CCHPATHMAX]; <br> <br>    UNICODETOANSI(pszFile, szTemp, CCHPATHMAX); <br>    return OpenFile(szTemp, pof, uFlags); <br>   #else <br>    return OpenFile(pszFile, pof, uFlags); <br>   #endif <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::DataSet <br> * <br> * Purpose: <br> *  Sets the current data in this Polyline to a given structure. <br> * <br> * Parameters: <br> *  ppl             PPOLYLINEDATA to initialize to. <br> *  fSizeToData     BOOL indicating if we're to size to the data or <br> *                  scale it. <br> *  fNotify         BOOL indicating if we're to send an advise on <br> *                  this change. <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::DataSet(PPOLYLINEDATA ppl, BOOL fSizeToData <br>    , BOOL fNotify) <br>    { <br>    RECTS       rcs; <br>    RECT        rc; <br>    UINT        i; <br> <br>    /* <br>     * Copy the structure in ppl and repaint to reflect the new <br>     * point set.  Note that unlike the RectSet message, we do no <br>     * scaling, assuming that the rect in the structure is <br>     * appropriate for the data. <br>     */ <br> <br>    if (NULL==ppl) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    //Preserve the old rectangle <br>    rcs=m_pl.rc; <br> <br>    /* <br>     * For version 2.0 we perform a straight copy.  For version <br>     * 1.0 we copy the 1.0 structure and fill in defaults for <br>     * the 2.0 additions. <br>     */ <br> <br>    switch (ppl-&gt;wVerMaj) <br>        { <br>        case VERSIONMAJOR:          //2.x <br>            switch (ppl-&gt;wVerMin) <br>                { <br>                case VERSIONMINOR:  //2.0 <br>                    m_pl=*ppl; <br>                    break; <br> <br>                default: <br>                    return POLYLINE_E_UNSUPPORTEDVERSION; <br>                } <br>            break; <br> <br>        case 1:                     //1.x <br>            switch (ppl-&gt;wVerMin) <br>                { <br>                case 0:             //1.0 <br>                    *((PPOLYLINEDATA10)&amp;m_pl)= <br>                        *((PPOLYLINEDATA10)ppl); <br> <br>                    /* <br>                     * Update this structure to 2.0.  Note that we <br>                     * assume whoever loaded us to save the loaded <br>                     * version so it can later ask what version <br>                     * the user wants to save. <br>                     */ <br>                    m_pl.wVerMaj=VERSIONMAJOR; <br>                    m_pl.wVerMin=VERSIONMINOR; <br> <br>                    /* <br>                     * Version 1.0 stored rc in parent coordinates. <br>                     * We need those now in our client coodinates. <br>                     */ <br>                    RECTSTORECT(m_pl.rc, rc); <br>                    OffsetRect(&amp;rc, -m_pl.rc.left, -m_pl.rc.top); <br> <br>                    /* <br>                     * 1.0 data had points relative to size of the <br>                     * rectangle.  We need to scale these to 0-32767 <br>                     * independent of the rectangle for the version <br>                     * upgrade. <br>                     */ <br>                    for (i=0; i &lt; m_pl.cPoints; i++) <br>                        PointScale(&amp;rc, &amp;m_pl.rgpt[i], FALSE); <br> <br>                    RECTTORECTS(rc, m_pl.rc); <br> <br>                    //New 2.0 features <br>                    m_pl.rgbBackground=GetSysColor(COLOR_WINDOW); <br>                    m_pl.rgbLine=GetSysColor(COLOR_WINDOWTEXT); <br>                    m_pl.iLineStyle=PS_SOLID; <br>                    break; <br> <br>                default: <br>                    return POLYLINE_E_UNSUPPORTEDVERSION; <br>                } <br>            break; <br> <br>        default: <br>            return POLYLINE_E_UNSUPPORTEDVERSION; <br>        } <br> <br> <br>    //Inform our parent of the data change <br>    if (NULL!=m_pAdv) <br>        m_pAdv-&gt;OnDataChange(); <br> <br>    /* <br>     * If we're scaling the window to fit the data, then use <br>     * RectSet passing our current rectangle as the new one. <br>     * That makes sure that the data won't change but that the <br>     * window is resized. <br>     */ <br> <br>    if (fSizeToData) <br>        { <br>        POINT       pt; <br> <br>        /* <br>         * Get our offset in the parent window so we can RectSet <br>         * to the right place since RectSet expects rectangle in <br>         * parent coordinates and we get it in client coordinates. <br>         */ <br>        GetWindowRect(m_hWnd, &amp;rc); <br>        pt.x=rc.left; <br>        pt.y=rc.top; <br>        ScreenToClient(GetParent(m_hWnd), &amp;pt); <br>        RECTSTORECT(m_pl.rc, rc); <br>        OffsetRect(&amp;rc, pt.x, pt.y); <br> <br>        //This will also cause a repaint. <br>        RectSet(&amp;rc, fNotify); <br>        } <br>    else <br>        { <br>        //Make sure we're updated. <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        } <br> <br>    return POLYLINE_E_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::DataGet <br> * <br> * Purpose: <br> *  Retrieves the Polyline's current data. <br> * <br> * Parameters: <br> *  ppl             PPOLYLINEDATA into which we copy the data. <br> *  lVer            LONG version of the data to retrieve.  Use <br> *                  VERSIONCURRENT to retrieve the most current. <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value <br> */ <br> <br>LONG CPolyline::DataGet(PPOLYLINEDATA ppl, LONG lVer) <br>    { <br>    UINT        i; <br>    RECT        rc; <br> <br>    //Retieve the current version <br>    if (lVer==MAKELONG(VERSIONMINOR, VERSIONMAJOR) <br>        || VERSIONCURRENT==lVer) <br>        { <br>        *ppl=m_pl; <br>        return POLYLINE_E_NONE; <br>        } <br> <br>    //Check for versions we support, 1.x <br>    if (HIWORD(lVer)!=1) <br>        return POLYLINE_E_UNSUPPORTEDVERSION; <br> <br>    if (LOWORD(lVer)==0)    //Check for 1.0 <br>        { <br>        //Do 2.0 to 1.0 conversion <br>        *((PPOLYLINEDATA10)ppl)=*((PPOLYLINEDATA10)&amp;m_pl); <br> <br>        RECTSTORECT(ppl-&gt;rc, rc); <br> <br>        //Get the parent coordinates of our rectangle <br>        if (!IsWindow(m_hWnd)) <br>            OffsetRect(&amp;rc, 8, 8); //This is always the offset. <br>        else <br>            RectGet(&amp;rc); <br> <br>        /* <br>         * 1.0 data has points relative to size of the rectangle. <br>         * We need to scale these from 0-32767 so we have the <br>         * right values. <br>         */ <br>        for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>            PointScale(&amp;rc, &amp;ppl-&gt;rgpt[i], TRUE); <br> <br>        RECTTORECTS(rc, ppl-&gt;rc); <br> <br>        //Insure old version numbers. <br>        ppl-&gt;wVerMaj=1; <br>        ppl-&gt;wVerMin=0; <br> <br>        ((PPOLYLINEDATA10)ppl)-&gt;fDrawEntire=TRUE; <br>        return POLYLINE_E_NONE; <br>        } <br> <br>    return POLYLINE_E_UNSUPPORTEDVERSION; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::DataSetMem <br> * <br> * Purpose: <br> *  Sets the Polyline's data using a global memory handle <br> *  instead of a pointer. <br> * <br> * Parameters: <br> *  hMem            HGLOBAL containing the data. <br> *  fFree           BOOL indicating if we're to free the data. <br> *                  The memory will be freed regardless of any <br> *                  error returned from here. <br> *  fSizeToData     BOOL indicating if we're to size to the data <br> *                  or scale it. <br> *  fNotify         BOOL indicating if we're to send an advise <br> *                  on this change. <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::DataSetMem(HGLOBAL hMem, BOOL fFree <br>    , BOOL fSizeToData, BOOL fNotify) <br>    { <br>    PPOLYLINEDATA   ppl; <br>    LONG            lRet=POLYLINE_E_INVALIDPOINTER; <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br>        lRet=DataSet(ppl, fSizeToData, fNotify); <br> <br>        GlobalUnlock(hMem); <br> <br>        if (fFree) <br>            GlobalFree(hMem); <br>        } <br> <br>    return lRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::DataGetMem <br> * <br> * Purpose: <br> *  Retrieves the Polyline's data in a global memory handle. <br> * <br> * Parameters: <br> *  lVer            LONG version of data to retrieve. <br> *  phMem           HGLOBAL * in which to store the handle. <br> * <br> * Return Value: <br> *  LONG            A POLYLINE_E_* value. <br> */ <br> <br>LONG CPolyline::DataGetMem(LONG lVer, HGLOBAL *phMem) <br>    { <br>    HGLOBAL         hMem; <br>    PPOLYLINEDATA   ppl; <br>    LONG            lRet; <br> <br>    if (NULL==phMem) <br>        return POLYLINE_E_INVALIDPOINTER; <br> <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE <br>        , CBPOLYLINEDATA); <br> <br>    if (NULL!=hMem) <br>        { <br>        ppl=(PPOLYLINEDATA)GlobalLock(hMem); <br>        lRet=DataGet(ppl, lVer); <br>        GlobalUnlock(hMem); <br> <br>        if (POLYLINE_E_NONE!=lRet) <br>            { <br>            GlobalFree(hMem); <br>            hMem=NULL; <br>            } <br>        } <br> <br>    *phMem=hMem; <br>    return lRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RectGet <br> * <br> * Purpose: <br> *  Returns the rectangle of the Polyline in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::RectGet(LPRECT pRect) <br>    { <br>    RECT        rc; <br>    POINT       pt; <br> <br>    //Retrieve the size of our rectangle in parent coordinates. <br>    GetWindowRect(m_hWnd, &amp;rc); <br>    pt.x=rc.left; <br>    pt.y=rc.top; <br>    ScreenToClient(GetParent(m_hWnd), &amp;pt); <br> <br>    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left) <br>        , pt.y+(rc.bottom-rc.top)); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::SizeGet <br> * <br> * Purpose: <br> *  Retrieves the size of the Polyline in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the size.  The right <br> *                  and bottom fields will contain the dimensions. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::SizeGet(LPRECT pRect) <br>    { <br>    RectGet(pRect); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RectSet <br> * <br> * Purpose: <br> *  Sets a new rectangle for the Polyline which sizes to fit. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::RectSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br>    RECT        rc; <br> <br>    //Scale the points from our current size to the new size <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, pRect-&gt;left, pRect-&gt;top <br>        , cx, cy, SWP_NOZORDER); <br> <br>    SetRect(&amp;rc, 0, 0, cx, cy); <br>    RECTTORECTS(rc, m_pl.rc); <br> <br>    if (fNotify &amp;&amp; NULL!=m_pAdv) <br>        m_pAdv-&gt;OnSizeChange(); <br> <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::SizeSet <br> * <br> * Purpose: <br> *  Sets a new size for the Polyline which sizes to fit. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::SizeSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    //Scale the points from our current size to the new size <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy <br>        , SWP_NOMOVE | SWP_NOZORDER); <br> <br>    if (fNotify &amp;&amp; NULL!=m_pAdv) <br>        m_pAdv-&gt;OnSizeChange(); <br> <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::ColorSet <br> * <br> * Purpose: <br> *  Changes for background or line color in the Polyline <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color to use. <br> * <br> * Return Value: <br> *  COLORREF        Previous color for the index iColor. <br> */ <br> <br>COLORREF CPolyline::ColorSet(UINT iColor, COLORREF cr) <br>    { <br>    COLORREF    crRet; <br> <br>    switch (iColor) <br>        { <br>        case POLYLINECOLOR_BACKGROUND: <br>            crRet=m_pl.rgbBackground; <br>            m_pl.rgbBackground=cr; <br>            break; <br> <br>        case POLYLINECOLOR_LINE: <br>            crRet=m_pl.rgbLine; <br>            m_pl.rgbLine=cr; <br>            break; <br>        } <br> <br>    //If the color changed, repaint <br>    if (crRet!=cr) <br>        { <br>        if (NULL!=m_pAdv) <br>            m_pAdv-&gt;OnColorChange(); <br> <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br>        UpdateWindow(m_hWnd); <br>        } <br> <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::ColorGet <br> * <br> * Purpose: <br> *  Retrieves one of the colors currently in use by the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT identifying the color of interest. <br> * <br> * Return Value: <br> *  COLORREF        Current color for iColor. <br> */ <br> <br>COLORREF CPolyline::ColorGet(UINT iColor) <br>    { <br>    COLORREF    crRet; <br> <br>    crRet=(POLYLINECOLOR_BACKGROUND==iColor) <br>        ? m_pl.rgbBackground : m_pl.rgbLine; <br> <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style in use by the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT style of the line to use. <br> * <br> * Return Value: <br> *  UINT            Previous style. <br> */ <br> <br>UINT CPolyline::LineStyleSet(UINT iStyle) <br>    { <br>    UINT        uRet=(UINT)m_pl.iLineStyle; <br> <br>    //Validate the line style <br>    if (PS_SOLID==iStyle || PS_DASH==iStyle || PS_DOT==iStyle <br>        || PS_DASHDOT==iStyle || PS_DASHDOTDOT==iStyle) <br>        { <br>        m_pl.iLineStyle=iStyle; <br> <br>        if (uRet!=(UINT)m_pl.iLineStyle) <br>            { <br>            if (NULL!=m_pAdv) <br>                m_pAdv-&gt;OnLineStyleChange(); <br> <br>            InvalidateRect(m_hWnd, NULL, TRUE); <br>            UpdateWindow(m_hWnd); <br>            } <br>        } <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the current line style in use in the Polyline <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Current line style. <br> */ <br> <br>UINT CPolyline::LineStyleGet(void) <br>    { <br>    return m_pl.iLineStyle; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RenderBitmap <br> * <br> * Purpose: <br> *  Creates a bitmap image of the current Polyline. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HBITMAP         Handle to the newly rendered bitmap. <br> */ <br> <br>HBITMAP CPolyline::RenderBitmap(void) <br>    { <br>    HDC         hDC; <br>    HDC         hMemDC; <br>    HBITMAP     hBmp; <br>    RECT        rc; <br>    HGDIOBJ     hObj; <br> <br>    //Render a bitmap the size of the current rectangle. <br>    hDC=GetDC(m_hWnd); <br>    hMemDC=CreateCompatibleDC(hDC); <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br>    hBmp=CreateCompatibleBitmap(hDC, rc.right, rc.bottom); <br> <br>    if (NULL!=hBmp) <br>        { <br>        //Draw the POLYLINEDATA into the bitmap. <br>        hObj=SelectObject(hMemDC, hBmp); <br>        Draw(hMemDC, FALSE, TRUE); <br>        SelectObject(hMemDC, hObj); <br>        } <br> <br>    DeleteDC(hMemDC); <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    return hBmp; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RenderMetafile <br> * <br> * Purpose: <br> *  Renders the current image of the Polyline into a metafile. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HMETAFILE       Handle to the newly created metafile. <br> */ <br> <br>HMETAFILE CPolyline::RenderMetafile(void) <br>    { <br>    HDC         hDC; <br>    HMETAFILE   hMF; <br>    RECT        rc; <br> <br>    //Create a memory metafile and return its handle. <br>    hDC=(HDC)CreateMetaFile(NULL); <br>    hMF=NULL; <br> <br>    if (NULL!=hDC) <br>        { <br>        /* <br>         * This is absolutely essential to the metafile so it <br>         * can be scaled in the clipboard and any destination <br>         * application. <br>         */ </code></pre>
<p>
</p>
<pre><code>SetMapMode(hDC, MM_ANISOTROPIC); <br>        GetClientRect(m_hWnd, &amp;rc); <br>        SetWindowOrgEx(hDC, 0, 0, NULL); <br>        SetWindowExtEx(hDC, rc.right, rc.bottom, NULL); <br> <br>        Draw(hDC, TRUE, TRUE); <br>        hMF=CloseMetaFile(hDC); <br>        } <br> <br>    return hMF; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RenderMetafilePict <br> * <br> * Purpose: <br> *  Renders the current Polyline into a METAFILEPICT structure in <br> *  global memory. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HGLOBAL         Memory containing the METAFILEPICT structure. <br> */ <br> <br>HGLOBAL CPolyline::RenderMetafilePict(void) <br>    { <br>    HGLOBAL         hMem; <br>    HMETAFILE       hMF; <br>    LPMETAFILEPICT  pMF; <br>    RECT            rc; <br> <br> <br>    //Get the metafile <br>    hMF=RenderMetafile(); <br> <br>    if (NULL==hMF) <br>        return NULL; <br> <br>    //Allocate the METAFILEPICT structure. <br>    hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE <br>        , sizeof(METAFILEPICT)); <br> <br>    if (NULL==hMem) <br>        { <br>        DeleteMetaFile(hMF); <br>        return NULL; <br>        } <br> <br>    /* <br>     * Global lock only fails in PMODE if the selector is invalid <br>     * (like it was discarded) or references a 0 length segment, <br>     * neither of which can happen here. <br>     */ <br>    pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>    pMF-&gt;hMF=hMF; <br>    pMF-&gt;mm=MM_ANISOTROPIC; <br> <br>    //Insert the extents in MM_HIMETRIC units. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    RectConvertMappings(&amp;rc, FALSE); <br>    pMF-&gt;xExt=rc.right; <br>    pMF-&gt;yExt=rc.bottom; <br> <br>    GlobalUnlock(hMem); <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::RectConvertMappings <br> * <br> * Purpose: <br> *  Converts the contents of a rectangle from device (MM_TEXT) or <br> *  HIMETRIC to the other. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the rectangle to convert. <br> *  fToDevice       BOOL TRUE to convert from HIMETRIC to device, <br> *                  FALSE to convert device to HIMETRIC. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::RectConvertMappings(LPRECT pRect, BOOL fToDevice) <br>    { <br>    HDC      hDC; <br>    int      iLpx, iLpy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    hDC=GetDC(NULL); <br>    iLpx=GetDeviceCaps(hDC, LOGPIXELSX); <br>    iLpy=GetDeviceCaps(hDC, LOGPIXELSY); <br>    ReleaseDC(NULL, hDC); <br> <br>    if (fToDevice) <br>        { <br>        pRect-&gt;left=MulDiv(iLpx, pRect-&gt;left, HIMETRIC_PER_INCH); <br>        pRect-&gt;top =MulDiv(iLpy, pRect-&gt;top , HIMETRIC_PER_INCH); <br> <br>        pRect-&gt;right=MulDiv(iLpx, pRect-&gt;right,  HIMETRIC_PER_INCH); <br>        pRect-&gt;bottom=MulDiv(iLpy, pRect-&gt;bottom,HIMETRIC_PER_INCH); <br> <br>       #ifdef NEVER <br>        /* <br>         * In this conversion we may get situations where the top <br>         * coordinate is larger than the bottom, which messes us up. <br>         */ <br>        if (pRect-&gt;bottom &lt; pRect-&gt;top) <br>            { <br>            iLpy=pRect-&gt;top; <br>            pRect-&gt;top=pRect-&gt;bottom; <br>            pRect-&gt;bottom=iLpy; <br>            } <br>       #endif <br>        } <br>    else <br>        { <br>        pRect-&gt;left=MulDiv(pRect-&gt;left, HIMETRIC_PER_INCH, iLpx); <br>        pRect-&gt;top =MulDiv(pRect-&gt;top , HIMETRIC_PER_INCH, iLpy); <br> <br>        pRect-&gt;right =MulDiv(pRect-&gt;right, HIMETRIC_PER_INCH, iLpx); <br>        pRect-&gt;bottom=MulDiv(pRect-&gt;bottom,HIMETRIC_PER_INCH, iLpy); <br>        } <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
