<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BEEPPROP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context773"></a>BEEPPROP.CPP</h2>
<pre><code>/* <br> * BEEPPROP.CPP <br> * Beeper Property Page Chapter 16 <br> * <br> * Server module code and class code CBeeperPropertyPage class. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "beepprop.h" <br> <br> <br>//Count number of objects and number of locks. <br>ULONG       g_cObj=0; <br>ULONG       g_cLock=0; <br>HINSTANCE   g_hInst=NULL;   //For resources <br> <br>#ifdef WIN32 <br>TCHAR       g_szObj[]=TEXT("Object"); <br>#else <br>TCHAR       g_szObjHi[]=TEXT("ObjectHi"); <br>TCHAR       g_szObjLo[]=TEXT("ObjectLo"); <br>#endif <br> <br>/* <br> * LibMain(32) <br> * <br> * Purpose: <br> *  Entry point conditionally compiled for Win32 and Windows <br> *  3.1.  Provides the proper structure for each environment. <br> */ <br> <br>#ifdef WIN32 <br>BOOL WINAPI LibMain32(HINSTANCE hInstance, ULONG ulReason <br>    , LPVOID pvReserved) <br>    { <br>    g_hInst=hInstance; <br> <br>    if (DLL_PROCESS_DETACH==ulReason) <br>        { <br>        return TRUE; <br>        } <br>    else <br>        { <br>        if (DLL_PROCESS_ATTACH!=ulReason) <br>            return TRUE; <br>        } <br> <br>    return TRUE; <br>    } <br>#else <br>int PASCAL LibMain(HINSTANCE hInstance, WORD wDataSeg <br>    , WORD cbHeapSize, LPSTR lpCmdLine) <br>    { <br>    if (0!=cbHeapSize) <br>        UnlockData(0); <br> <br>    g_hInst=hInstance; <br>    return (int)hInstance; <br>    } <br>#endif <br> <br> <br> <br>/* <br> * DllGetClassObject <br> * DllCanUnloadNow <br> * Standard COM exports for DLL servers. <br> */ <br> <br>HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid <br>    , PPVOID ppv) <br>    { <br>    CBeeperPPFactory *pBF; <br>    HRESULT         hr; <br> <br>    if (CLSID_BeeperPropertyPage!=rclsid) <br>        return ResultFromScode(E_FAIL); <br> <br>    //Check that we can provide the interface <br>    if (IID_IUnknown!=riid &amp;&amp; IID_IClassFactory!=riid) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    //Return our beeper factory's IClassFactory <br>    pBF=new CBeeperPPFactory(); <br> <br>    if (NULL==pBF) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //If the factory hasn't the interface, delete it <br>    hr=pBF-&gt;QueryInterface(riid, ppv); <br> <br>    if (FAILED(hr)) <br>        delete pBF; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br>STDAPI DllCanUnloadNow(void) <br>    { <br>    SCODE   sc; <br> <br>    //Our answer is whether there are any object or locks <br>    sc=(0L==g_cObj &amp;&amp; 0L==g_cLock) ? S_OK : S_FALSE; <br>    return ResultFromScode(sc); <br>    } <br> <br> <br> <br>/* <br> * CBeeperPPFactory::CBeeperPPFactory <br> * CBeeperPPFactory::~CBeeperPPFactory <br> * CBeeperPPFactory::QueryInterface <br> * CBeeperPPFactory::AddRef <br> * CBeeperPPFactory::Release <br> */ <br> <br>CBeeperPPFactory::CBeeperPPFactory(void) <br>    { <br>    m_cRef=0L; <br>    return; <br>    } <br> <br>CBeeperPPFactory::~CBeeperPPFactory(void) <br>    { <br>    return; <br>    } <br> <br>STDMETHODIMP CBeeperPPFactory::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IClassFactory==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CBeeperPPFactory::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CBeeperPPFactory::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    g_cObj--; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPPFactory::CreateInstance <br> * CBeeperPPFactory::LockServer <br> */ <br> <br>STDMETHODIMP CBeeperPPFactory::CreateInstance(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    PCBeeperPropPage    pObj; <br>    HRESULT             hr; <br> <br>    *ppvObj=NULL; <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    //No aggregation supported <br>    if (NULL!=pUnkOuter) <br>        return ResultFromScode(CLASS_E_NOAGGREGATION); <br> <br>    //Create the object passing function to notify on destruction. <br>    pObj=new CBeeperPropPage(g_hInst); <br> <br>    if (NULL==pObj) <br>        return hr; <br> <br>    if (pObj-&gt;Init()) <br>        hr=pObj-&gt;QueryInterface(riid, ppvObj); <br> <br>    //Kill the object if initial creation or Init failed. <br>    if (FAILED(hr)) <br>        delete pObj; <br>    else <br>        g_cObj++; <br> <br>    return hr; <br>    } <br> <br> <br>STDMETHODIMP CBeeperPPFactory::LockServer(BOOL fLock) <br>    { <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        g_cLock--; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/*** <br> *** CBeeperPropPage implementation <br> ***/ <br> <br> <br>/* <br> * CBeeperPropPage::CBeeperPropPage <br> * CBeeperPropPage::~CBeeperPropPage <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the module <br> */ <br> <br>CBeeperPropPage::CBeeperPropPage(HINSTANCE hInst) <br>    { <br>    m_cRef=0L; <br> <br>    m_hInst=hInst; <br>    m_uIDTemplate=IDD_BEEPERPROPS_0; <br>    m_hDlg=NULL; <br> <br>    //Default sizes <br>    m_cx=300; <br>    m_cy=100; <br> <br>    m_pIPropertyPageSite=NULL; <br>    m_ppIBeeper=NULL; <br>    m_cObjects=0; <br> <br>    m_uIDLastSound=IDC_BEEPDEFAULT; <br>    m_fDirty=FALSE; <br> <br>    m_lcid=LOCALE_USER_DEFAULT; <br>    return; <br>    } <br> <br>CBeeperPropPage::~CBeeperPropPage(void) <br>    { <br>    if (NULL!=m_hDlg) <br>        DestroyWindow(m_hDlg); <br> <br>    FreeAllObjects(); <br>    ReleaseInterface(m_pIPropertyPageSite); <br>    return; <br>    } <br> <br> <br>/* <br> * CBeeperPropPage::QueryInterface <br> * CBeeperPropPage::AddRef <br> * CBeeperPropPage::Release <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IPropertyPage==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CBeeperPropPage::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CBeeperPropPage::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    g_cObj--; <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br>/* <br> * CBeeperPropPage::Init <br> * <br> * Purpose: <br> *  Performs initialization operations that might fail. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization successful, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CBeeperPropPage::Init(void) <br>    { <br>    //Nothing to do <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CBeeperPropPage::FreeAllObjects <br> * <br> * Purpose: <br> *  Releases all the objects from IPropertyPage::SetObjects <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>void CBeeperPropPage::FreeAllObjects(void) <br>    { <br>    UINT        i; <br> <br>    if (NULL==m_ppIBeeper) <br>        return; <br> <br>    for (i=0; i &lt; m_cObjects; i++) <br>        ReleaseInterface(m_ppIBeeper[i]); <br> <br>    delete [] m_ppIBeeper; <br>    m_ppIBeeper=NULL; <br>    m_cObjects=0; <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::SetPageSite <br> * <br> * Purpose: <br> *  Provides the property page with the IPropertyPageSite <br> *  that contains it.  SetPageSite(NULL) will be called as <br> *  part of the close sequence. <br> * <br> * Parameters: <br> *  pPageSite       LPPROPERTYPAGESITE pointer to the site. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::SetPageSite <br>    (LPPROPERTYPAGESITE pPageSite) <br>    { <br>    if (NULL==pPageSite) <br>        ReleaseInterface(m_pIPropertyPageSite) <br>    else <br>        { <br>        HWND        hDlg; <br>        RECT        rc; <br>        LCID        lcid; <br> <br>        m_pIPropertyPageSite=pPageSite; <br>        m_pIPropertyPageSite-&gt;AddRef(); <br> <br>        if (SUCCEEDED(m_pIPropertyPageSite-&gt;GetLocaleID(&amp;lcid))) <br>            m_lcid=lcid; <br> <br>        /* <br>         * Now that we know the locale we're running under, we can <br>         * load the dialog and determine the size it will be to <br>         * return through GetPageSize.  We just create the dialog <br>         * here and destroy it again to retrieve the size, <br>         * leaving Activate to create it for real. <br>         */ <br> <br>        switch (PRIMARYLANGID(m_lcid)) <br>            { <br>            case LANG_GERMAN: <br>                m_uIDTemplate=IDD_BEEPERPROPS_7; <br>                break; <br> <br>            case LANG_NEUTRAL: <br>            case LANG_ENGLISH: <br>            default: <br>                m_uIDTemplate=IDD_BEEPERPROPS_0; <br>                break; <br>            } <br> <br>        hDlg=CreateDialogParam(m_hInst <br>            , MAKEINTRESOURCE(m_uIDTemplate), GetDesktopWindow() <br>            , (DLGPROC)BeepPropPageProc, 0L); <br> <br>        //If creation fails, use default values set in constructor <br>        if (NULL!=hDlg) <br>            { <br>            GetWindowRect(hDlg, &amp;rc); <br>            m_cx=rc.right-rc.left; <br>            m_cy=rc.bottom-rc.top; <br> <br>            DestroyWindow(hDlg); <br>            } <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::Activate <br> * <br> * Purpose: <br> *  Instructs the property page to create a window in which to <br> *  display its contents, using the given parent window and <br> *  rectangle.  The window should be initially visible. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent window. <br> *  prc             LPCRECT of the rectangle to use. <br> *  fModal          BOOL indicating whether the frame is modal. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Activate(HWND hWndParent <br>    , LPCRECT prc, BOOL fModal) <br>    { <br>    if (NULL!=m_hDlg) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    m_hDlg=CreateDialogParam(m_hInst, MAKEINTRESOURCE(m_uIDTemplate) <br>        , hWndParent, BeepPropPageProc, (LPARAM)this); <br> <br>    if (NULL==m_hDlg) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //Move the page into position and show it. <br>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top <br>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0); <br> <br>return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::Deactivate <br> * <br> * Purpose: <br> *  Instructs the property page to destroy its window that was <br> *  created in Activate. <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Deactivate(void) <br>    { <br>    if (NULL==m_hDlg) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    DestroyWindow(m_hDlg); <br>    m_hDlg=NULL; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::GetPageInfo <br> * <br> * Purpose: <br> *  Fills a PROPPAGEINFO structure describing the page's size, <br> *  contents, and help information. <br> * <br> * Parameters: <br> *  pPageInfo       LPPROPPAGEINFO to the structure to fill. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::GetPageInfo(LPPROPPAGEINFO pPageInfo) <br>    { <br>    IMalloc     *pIMalloc; <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        return ResultFromScode(E_FAIL); <br> <br>    pPageInfo-&gt;pszTitle=(LPOLESTR)pIMalloc-&gt;Alloc(CCHSTRINGMAX); <br> <br>    if (NULL!=pPageInfo-&gt;pszTitle) <br>        { <br>        UINT        ids=IDS_0_PAGETITLE; <br> <br>        if (PRIMARYLANGID(m_lcid)==LANG_GERMAN) <br>            ids=IDS_7_PAGETITLE; <br> <br>       #ifdef WIN32ANSI <br>        char        szTemp[80]; <br> <br>        LoadString(m_hInst, ids, szTemp, CCHSTRINGMAX); <br>        MultiByteToWideChar(CP_ACP, 0, szTemp, -1 <br>           , pPageInfo-&gt;pszTitle, 80); <br>       #else <br>        LoadString(m_hInst, ids, pPageInfo-&gt;pszTitle, CCHSTRINGMAX); <br>       #endif <br>        } <br> <br>    pIMalloc-&gt;Release(); <br> <br>pPageInfo-&gt;size.cx      = m_cx; <br>    pPageInfo-&gt;size.cy      = m_cy; <br>pPageInfo-&gt;pszDocString = NULL; <br>pPageInfo-&gt;pszHelpFile  = NULL; <br>pPageInfo-&gt;dwHelpContext= 0; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::SetObjects <br> * <br> * Purpose: <br> *  Identifies the objects that are being affected by this property <br> *  page (and all other pages in the frame).  These are the object <br> *  to which to send new property values in the Apply member. <br> * <br> * Parameters: <br> *  cObjects        ULONG number of objects <br> *  ppUnk           IUnknown ** to the array of objects being <br> *                  passed to the page. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::SetObjects(ULONG cObjects <br>    , IUnknown **ppUnk) <br>    { <br>    BOOL        fRet=TRUE; <br> <br>    FreeAllObjects(); <br> <br>    if (0!=cObjects) <br>        { <br>        UINT        i; <br>        HRESULT     hr; <br> <br>        m_ppIBeeper=new IBeeper * [(UINT)cObjects]; <br> <br>    for (i=0; i &lt; cObjects; i++) <br>        { <br>            hr=ppUnk[i]-&gt;QueryInterface(IID_IBeeper <br>                , (void **)&amp;m_ppIBeeper[i]); <br> <br>            if (FAILED(hr)) <br>                fRet=FALSE; <br>        } <br>    } <br> <br>    //If we didn't get one of our objects, fail this call. <br>    if (!fRet) <br>        return ResultFromScode(E_FAIL); <br> <br>    m_cObjects=cObjects; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::Show <br> * <br> * Purpose: <br> *  Instructs the page to show or hide its window created in <br> *  Activate. <br> * <br> * Parameters: <br> *  nCmdShow        UINT to pass to ShowWindow. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Show(UINT nCmdShow) <br>    { <br>    if (NULL==m_hDlg) <br>        ResultFromScode(E_UNEXPECTED); <br> <br>    ShowWindow(m_hDlg, nCmdShow); <br> <br>    //Take the focus <br>    if (SW_SHOWNORMAL==nCmdShow || SW_SHOW==nCmdShow) <br>SetFocus(m_hDlg); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::Move <br> * <br> * Purpose: <br> *  Instructs the property page to change its position. <br> * <br> * Parameters: <br> *  prc             LPCRECT containing the new position. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Move(LPCRECT prc) <br>    { <br>    SetWindowPos(m_hDlg, NULL, prc-&gt;left, prc-&gt;top <br>        , prc-&gt;right-prc-&gt;left, prc-&gt;bottom-prc-&gt;top, 0); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::IsPageDirty <br> * <br> * Purpose: <br> *  Asks the page if anything's changed in it, that is, if the <br> *  property values in the page are out of sync with the objects <br> *  under consideration. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if dirty, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::IsPageDirty(void) <br>    { <br>    return ResultFromScode(m_fDirty ? S_OK : S_FALSE); <br>    } <br> <br> <br> <br> <br>/* <br> * CBeeperPropPage::Apply <br> * <br> * Purpose: <br> *  Instructs the page to send changes in its page to whatever <br> *  objects it knows about through SetObjects.  This is the only <br> *  time the page should change the objects' properties, and not <br> *  when the value is changed on the page. <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Apply(void) <br>    { <br>    UINT        i; <br>    UINT        lSound, lSoundNew; <br>    BOOL        fChanged; <br> <br>    if (0==m_cObjects) <br>        return NOERROR; <br> <br>    /* <br>     * The dialog's last known Sound selection is in <br>     * m_uIDLastSound, so we can just send it via <br>     * IBeeper::put_Sound.  Since this method has no <br>     * return value, we have to ask for it again to <br>     * see if it really changed because the client may <br>     * be blocking changes through IPropertyNotifySink, <br>     * in which case we do not clear the dirty flag. <br>     */ <br> <br>    lSound=(IDC_BEEPDEFAULT==m_uIDLastSound) ? 0L : m_uIDLastSound; <br>    fChanged=TRUE; <br> <br>    for (i=0; i &lt; m_cObjects; i++) <br>        { <br>        m_ppIBeeper[i]-&gt;put_Sound(lSound); <br>        lSoundNew=m_ppIBeeper[i]-&gt;get_Sound(); <br> <br>        fChanged &amp;= (lSound==lSoundNew); <br>        } <br> <br>    m_fDirty=!fChanged; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CBeeperPropPage::Help <br> * <br> * Purpose: <br> *  Invokes help for this property page when the user presses <br> *  the Help button.  If you return NULLs for the help file <br> *  in GetPageInfo, the button will be grayed.  Otherwise the <br> *  page can perform its own help here. <br> * <br> * Parameters: <br> *  pszHelpDir      LPCOLESTR identifying the default location of <br> *                  the help information <br> * <br> * Return Value: <br> *  HRESULT         NOERROR to tell the frame that we've done our <br> *                  own help.  Returning an error code or S_FALSE <br> *                  causes the frame to use any help information <br> *                  in PROPPAGEINFO. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::Help(LPCOLESTR pszHelpDir) <br>    { <br>    /* <br>     * We can either provide help ourselves, or rely on the <br>     * information in PROPPAGEINFO. <br>     */ <br>    return ResultFromScode(S_FALSE); <br>    } <br> <br> <br> <br> <br>/* <br> * CBeeperPropPage::TranslateAccelerator <br> * <br> * Purpose: <br> *  Provides the page with the messages that occur in the frame. <br> *  This gives the page to do whatever it wants with the message, <br> *  such as handle keyboard mnemonics. <br> * <br> * Parameters: <br> *  pMsg            LPMSG containing the keyboard message. <br> */ <br> <br>STDMETHODIMP CBeeperPropPage::TranslateAccelerator(LPMSG lpMsg) <br>    { <br>    //No keyboard interface supported here <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * BeepPropPageProc <br> * <br> * Purpose: <br> *  Dialog procedure for the Beeper Property Page. <br> */ <br> <br>BOOL APIENTRY BeepPropPageProc(HWND hDlg, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCBeeperPropPage    pObj; <br>    WORD                wID; <br> <br>   #ifdef WIN32 <br>    pObj=(PCBeeperPropPage)(ULONG)GetProp(hDlg, g_szObj); <br>   #else <br>    pObj=(PCBeeperPropPage)MAKELONG((WORD)GetProp(hDlg, g_szObjLo) <br>       , (WORD)GetProp(hDlg, g_szObjHi)); <br>   #endif <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            pObj=(PCBeeperPropPage)(ULONG)lParam; <br>           #ifdef WIN32 <br>            SetProp(hDlg, g_szObj, (HANDLE)lParam); <br>           #else <br>            SetProp(hDlg, g_szObjHi, (HANDLE)HIWORD(lParam)); <br>            SetProp(hDlg, g_szObjLo, (HANDLE)LOWORD(lParam)); <br>           #endif <br> <br>            if (NULL==pObj) <br>                return TRUE; <br> <br>            SetFocus(GetDlgItem(hDlg, IDOK)); <br> <br>            /* <br>             * If we have one object then we can try to set the <br>             * right field in the dialog box.  Otherwise we could <br>             * ask for the value from all of the objects and see <br>             * if they all match. <br>             */ <br>            if (1==pObj-&gt;m_cObjects) <br>                { <br>                UINT        iButton; <br> <br>                iButton=(UINT)pObj-&gt;m_ppIBeeper[0]-&gt;get_Sound(); <br> <br>                if (0==iButton) <br>                    iButton=IDC_BEEPDEFAULT; <br> <br>                CheckRadioButton(hDlg, IDC_BEEPDEFAULT <br>                    , IDC_BEEPASTERISK, iButton); <br> <br>                pObj-&gt;m_uIDLastSound=iButton; <br>                } <br> <br>            return FALSE; <br> <br>        case WM_DESTROY: <br>           #ifdef WIN32 <br>            RemoveProp(hDlg, g_szObj); <br>           #else <br>            RemoveProp(hDlg, g_szObjHi); <br>            RemoveProp(hDlg, g_szObjLo); <br>           #endif <br>            return FALSE; <br> <br>        case WM_COMMAND: <br>            wID=LOWORD(wParam); <br> <br>            switch (wID) <br>                { <br>                case IDC_BEEPDEFAULT: <br>                case IDC_BEEPHAND: <br>                case IDC_BEEPQUESTION: <br>                case IDC_BEEPEXCLAMATION: <br>                case IDC_BEEPASTERISK: <br>                    if (NULL==pObj) <br>                        break; <br> <br>                    //Selecting the same one doesn't dirty <br>                    if (pObj-&gt;m_uIDLastSound==wID) <br>                        break; <br> <br>                    //Save the most recently selected <br>                    pObj-&gt;m_uIDLastSound=LOWORD(wParam); <br>                    pObj-&gt;m_fDirty=TRUE; <br> <br>                    if (NULL!=pObj-&gt;m_pIPropertyPageSite) <br>                        { <br>                        pObj-&gt;m_pIPropertyPageSite <br>                            -&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>                        } <br> <br>                    break; <br> <br> <br>                case IDOK: <br>                    /* <br>                     * We could call the object's Beep, but <br>                     * as it's property page, we know what <br>                     * it will do so we can just do it. <br>                     */ <br>                    if (NULL!=pObj) <br>                        MessageBeep(pObj-&gt;m_uIDLastSound); <br> <br>                    break; <br>                } <br>            break; <br>        } <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
