<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOCLI2.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context764"></a>AUTOCLI2.CPP</h2>
<pre><code>/* <br> * AUTOCLI2.CPP <br> * Automation Client with Property Pages Chapter 16 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "autocli2.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG         msg; <br>    PCApp       pApp; <br> <br>    SETMESSAGEQUEUE; <br> <br>    pApp=new CApp(hInst, hInstPrev, nCmdShow); <br> <br>    if (NULL==pApp) <br>        return -1; <br> <br>    if (pApp-&gt;Init()) <br>        { <br>        while (GetMessage(&amp;msg, NULL, 0,0 )) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    delete pApp; <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * AutoClientWndProc <br> * <br> * Purpose: <br> *  Window class procedure.  Standard callback. <br> */ <br> <br>LRESULT APIENTRY AutoClientWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCApp           pApp; <br>    WORD            wID; <br>    DISPID          dispID, dispIDParam; <br>    DISPPARAMS      dp; <br>    VARIANTARG      va; <br>    EXCEPINFO       exInfo; <br>    UINT            uErr; <br>    HRESULT         hr; <br>    TCHAR           szMsg[80]; <br> <br>    pApp=(PCApp)GetWindowLong(hWnd, AUTOCLI2WL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pApp=(PCApp)(((LPCREATESTRUCT)lParam)-&gt;lpCreateParams); <br>            SetWindowLong(hWnd, AUTOCLI2WL_STRUCTURE, (LONG)pApp); <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_COMMAND: <br>            wID=LOWORD(wParam); <br> <br>            switch (wID) <br>                { <br>                case IDM_GETSOUND: <br>                    //Find the dispID we need <br>                    hr=pApp-&gt;NameToID(OLETEXT("Sound"), &amp;dispID); <br> <br>                    if (FAILED(hr)) <br>                        break; <br> <br>                    //Get the property <br>                    SETNOPARAMS(dp); <br>                    hr=pApp-&gt;Invoke(dispID, DISPATCH_PROPERTYGET <br>                        , &amp;dp, &amp;va, &amp;exInfo, NULL); <br> <br>                    if (SUCCEEDED(hr)) <br>                        { <br>                        wsprintf(szMsg, TEXT("Current 'Sound' is 0x%lX") <br>                            , va.lVal); <br>                        } <br>                    else <br>                        { <br>                        wsprintf(szMsg <br>                            , TEXT("Get 'Sound' failed with 0x%lX") <br>                            , hr); <br>                        } <br> <br>                    pApp-&gt;Message(szMsg); <br>                    break; <br> <br>                case IDM_SETSOUNDDEFAULT: <br>                case IDM_SETSOUNDHAND: <br>                case IDM_SETSOUNDQUESTION: <br>                case IDM_SETSOUNDEXCLAMATION: <br>                case IDM_SETSOUNDASTERISK: <br>                case IDM_SETSOUNDBOGUS: <br>                    //Find the dispID we need <br>                    hr=pApp-&gt;NameToID(OLETEXT("Sound"), &amp;dispID); <br> <br>                    if (FAILED(hr)) <br>                        break; <br> <br>                    /* <br>                     * Call IDispatch::Invoke passing wID which <br>                     * is a sound identifier (IDM_SETSOUNDDEFAULT <br>                     * has to set the sound to zero).  The "bogus" <br>                     * sound should cause an exception. <br>                     */ <br> <br>                    //Initialize arguments <br>                    VariantInit(&amp;va); <br>                    va.vt=VT_I4; <br>                    va.lVal=(IDM_SETSOUNDDEFAULT==wID) <br>                        ? 0L : (long)(wID); <br> <br>                    /* <br>                     * Passing a named DISPID_PROPERTYPUT <br>                     * is required when setting properties. <br>                     */ <br>                    dispIDParam=DISPID_PROPERTYPUT; <br>                    SETDISPPARAMS(dp, 1, &amp;va, 1, &amp;dispIDParam); <br> <br>                    hr=pApp-&gt;Invoke(dispID, DISPATCH_PROPERTYPUT <br>                        , &amp;dp, NULL, &amp;exInfo, NULL); <br> <br>                    /* <br>                     * Success messages come through <br>                     * IPropertyNotifySink::OnChanged. <br>                     */ <br>                    if (FAILED(hr)) <br>                        { <br>                        wsprintf(szMsg <br>                            , TEXT("Set 'Sound' failed with 0x%lX"), hr); <br>                        } <br> <br>                    break; <br> <br>                case IDM_BEEP: <br>                    if (NULL==pApp-&gt;m_pIDispatch) <br>                        break; <br> <br>                    hr=pApp-&gt;NameToID(OLETEXT("Beep"), &amp;dispID); <br> <br>                    if (FAILED(hr)) <br>                        break; <br> <br>                    SETNOPARAMS(dp); <br>                    hr=pApp-&gt;Invoke(dispID, DISPATCH_METHOD, &amp;dp <br>                        , &amp;va, &amp;exInfo, &amp;uErr); <br> <br>                    /* <br>                     * va will have the sound played as the return <br>                     * value of the Beep method. <br>                     */ <br>                    if (SUCCEEDED(hr)) <br>                        { <br>                        wsprintf(szMsg, TEXT("'Beep' played 0x%lX") <br>                            , va.lVal); <br>                        } <br>                    else <br>                        { <br>                        wsprintf(szMsg <br>                            , TEXT("'Beep' failed with 0x%lX"), hr); <br>                        } <br> <br>                    pApp-&gt;Message(szMsg); <br>                    break; <br> <br>                //CHAPTER16MOD <br>                case IDM_PROPERTIES: <br>                    pApp-&gt;ShowProperties(); <br>                    break; <br> <br>                case IDM_ENFORCEREADONLY: <br>                    pApp-&gt;m_fReadOnly=!pApp-&gt;m_fReadOnly; <br>                    CheckMenuItem(GetMenu(hWnd), wID <br>                        , pApp-&gt;m_fReadOnly <br>                        ? MF_CHECKED : MF_UNCHECKED); <br>                    break; <br>                //End CHAPTER16MOD <br> <br>                case IDM_EXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::CApp <br> * CApp::~CApp <br> * <br> * Constructor Parameters: (from WinMain) <br> *  hInst           HINSTANCE of the application. <br> *  hInstPrev       HINSTANCE of a previous instance. <br> *  nCmdShow        UINT specifying how to show the app window. <br> * <br> */ <br> <br>CApp::CApp(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , UINT nCmdShow) <br>    { <br>    m_hInst=hInst; <br>    m_hInstPrev=hInstPrev; <br>    m_nCmdShow=nCmdShow; <br> <br>    m_hWnd=NULL; <br>    m_fInitialized=FALSE; <br>    m_lcid=GetUserDefaultLCID(); <br> <br>    m_szHelpDir[0]=(TCHAR)0; <br>    m_pIDispatch=NULL; <br> <br>    //CHAPTER16MOD <br>    m_fReadOnly=FALSE; <br>    m_pSink=NULL; <br>    m_pIConnPt=NULL; <br>    m_dwConn=0L; <br>    //End CHAPTER16MOD <br> <br>    return; <br>    } <br> <br> <br>CApp::~CApp(void) <br>    { <br>    //CHAPTER16MOD <br>    if (0!=m_dwConn &amp;&amp; NULL!=m_pIConnPt) <br>        { <br>        m_pIConnPt-&gt;Unadvise(m_dwConn); <br>        ReleaseInterface(m_pIConnPt); <br>        } <br> <br>    ReleaseInterface(m_pSink); <br>    //End CHAPTER16MOD <br> <br>    if (NULL!=m_pIDispatch) <br>        { <br>        m_pIDispatch-&gt;Release(); <br>        m_pIDispatch=NULL; <br>        } <br> <br>    if (IsWindow(m_hWnd)) <br>        DestroyWindow(m_hWnd); <br> <br>    if (m_fInitialized) <br>        CoUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure such as calling CoInitialize.  If this function fails <br> *  the caller should insure that the destructor is called. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::Init(void) <br>    { <br>    WNDCLASS    wc; <br>    HRESULT     hr; <br> <br>    CHECKVER_OLE; <br> <br>    if (FAILED(CoInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    if (!m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = AutoClientWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = CBWNDEXTRA; <br>        wc.hInstance      = m_hInst; <br>        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon")); <br>        wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU); <br>        wc.lpszClassName  = TEXT("AUTOCLI"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>        } <br> <br>    m_hWnd=CreateWindow(TEXT("AUTOCLI") <br>        , TEXT("Property Page Client"), WS_OVERLAPPEDWINDOW <br>        , 35, 35, 450, 250, NULL, NULL, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    //Create the beeper object we want to manipulate. <br>    hr=CoCreateInstance(CLSID_Beeper, NULL, CLSCTX_INPROC_SERVER <br>        , IID_IDispatch, (PPVOID)&amp;m_pIDispatch); <br> <br>    if (FAILED(hr)) <br>        { <br>        Message(TEXT("Failed to create object--terminating"), MB_OK); <br>        return FALSE; <br>        } <br> <br>    //Try to get the help directory for the object's type information <br>    HelpDirFromCLSID(CLSID_Beeper, m_szHelpDir); <br> <br>    //CHAPTER16MOD <br>    /* <br>     * Try to hook up our IPropertyNotifySink to the object. <br>     * On failure, we'll just gray out "Enforce Read-Only" on <br>     * the menu, but otherwise we continue to run. <br>     */ <br>    m_pSink=new CPropertyNotifySink(this); <br> <br>    if (NULL!=m_pSink) <br>        { <br>        IConnectionPointContainer  *pICPC; <br>        HRESULT                     hr; <br> <br>        m_pSink-&gt;AddRef();  //Release destroys it <br> <br>        hr=m_pIDispatch-&gt;QueryInterface(IID_IConnectionPointContainer <br>            , (void **)&amp;pICPC); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            if (SUCCEEDED(pICPC-&gt;FindConnectionPoint <br>                (IID_IPropertyNotifySink, &amp;m_pIConnPt))) <br>                { <br>                /* <br>                 * This is the only way m_dwConn is set to non- <br>                 * zero.  We hold onto m_pIConnPt until we close. <br>                 */ <br>                m_pIConnPt-&gt;Advise(m_pSink, &amp;m_dwConn); <br>                } <br> <br>            pICPC-&gt;Release(); <br>            } <br>        } <br> <br>    if (0==m_dwConn) <br>        { <br>        EnableMenuItem(GetMenu(m_hWnd), IDM_ENFORCEREADONLY <br>            , MF_DISABLED | MF_GRAYED | MF_BYCOMMAND); <br>        } <br>    //End CHAPTER16MOD <br> <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CApp::NameToID <br> * <br> * Purpose: <br> *  Calls IDispatch::GetIDsOfNames for a single name to determine <br> *  the DISPID to pass to IDispatch::Invoke. <br> * <br> * Parameters: <br> *  pszName         OLECHAR * to the name to map. <br> *  pDispID         DISPID * in which to store the dispID. <br> * <br> * Return Value: <br> *  HRESULT         Return value of GetIDsOfNames <br> */ <br> <br>HRESULT CApp::NameToID(OLECHAR *pszName, DISPID *pDispID) <br>    { <br>    HRESULT     hr; <br>    TCHAR       szMsg[80]; <br> <br>    hr=m_pIDispatch-&gt;GetIDsOfNames(IID_NULL, &amp;pszName, 1 <br>        , m_lcid, pDispID); <br> <br>    if (FAILED(hr)) <br>        { <br>        wsprintf(szMsg <br>            , TEXT("GetIDsOfNames on '%s' failed with 0x%lX") <br>            , pszName, hr); <br>        Message(szMsg); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Invoke <br> * <br> * Purpose: <br> *  Calls IDispatch::Invoke using the interface pointer we hold <br> *  and using some default parameters.  All the other parameters <br> *  to this function are passed straight to Invoke <br> * <br> * Return Value: <br> *  HRESULT         Return value of Invoke.  If DISP_E_EXCEPTION, <br> *                  this function generates the appropriate <br> *                  message box. <br> */ <br> <br>HRESULT CApp::Invoke(DISPID dispID, WORD wFlags, DISPPARAMS *pdp <br>    , VARIANT *pva, EXCEPINFO *pExInfo, UINT *puErr) <br>    { <br>    HRESULT     hr; <br>    LPTSTR      pszMsg=NULL; <br>    LPTSTR      pszFmt=NULL; <br>    UINT        uRet; <br>    UINT        uStyle; <br>    TCHAR       szSource[80]; <br> <br>    if (NULL==m_pIDispatch) <br>        return ResultFromScode(E_POINTER); <br> <br>    hr=m_pIDispatch-&gt;Invoke(dispID, IID_NULL, m_lcid, wFlags <br>        , pdp, pva, pExInfo, puErr); <br> <br>    if (DISP_E_EXCEPTION!=GetScode(hr)) <br>        return hr; <br> <br>    //If we're given a deferred filling function, fill now. <br>    if (NULL!=pExInfo-&gt;pfnDeferredFillIn) <br>        (*pExInfo-&gt;pfnDeferredFillIn)(pExInfo); <br> <br>    /* <br>     * To handle the exception, display a message box with the <br>     * controller's name in the caption and a message: <br>     * <br>     *      "Error &lt;code&gt; in &lt;source&gt;:  &lt;description&gt;" <br>     * <br>     * where &lt;error&gt; is the exception code in pExInfo-&gt;wCode or <br>     * pExInfo-&gt;scode, &lt;source&gt; is the value of the ProdID <br>     * in pExInfo-&gt;bstrSource and &lt;description&gt; is in <br>     * pExInfo-&gt;bstrDescription. <br>     * <br>     * For simplicity, we assume that if description is set, so is <br>     * source. <br>     * <br>     * To be complete, if pExInfo-&gt;bstrHelpFile is non-NULL, <br>     * display a Help button.  If Help is pressed, launch WinHelp <br>     * with that filename and pExInfo-&gt;dwHelpContext. <br>     */ <br> <br>    //Go get the real source name from the ProgID <br>    lstrcpy(szSource, TEXT("Unknown")); <br> <br>    if (NULL!=pExInfo-&gt;bstrSource) <br>        { <br>        LONG    lRet; <br> <br>        //If this doesn't work, we'll have "Unknown" anyway <br>       #ifdef WIN32ANSI <br>        char        szTemp[80]; <br>        WideCharToMultiByte(CP_ACP, 0, pExInfo-&gt;bstrSource, -1 <br>            , szTemp, 80, NULL, NULL); <br>        RegQueryValue(HKEY_CLASSES_ROOT, szTemp, szSource, &amp;lRet); <br>       #else <br>        RegQueryValue(HKEY_CLASSES_ROOT, pExInfo-&gt;bstrSource <br>            , szSource, &amp;lRet); <br>       #endif <br> <br>        SysFreeString(pExInfo-&gt;bstrSource); <br>        } <br> <br>    if (NULL!=pExInfo-&gt;bstrDescription) <br>        { <br>        pszFmt=(LPTSTR)malloc(CCHSTRINGMAX*sizeof(TCHAR)); <br> <br>       #ifdef WIN32ANSI <br>        UINT    cch; <br>        char   *pszDesc; <br> <br>        cch=wcslen(pExInfo-&gt;bstrDescription); <br>        pszDesc=(LPSTR)malloc(cch); <br> <br>        WideCharToMultiByte(CP_ACP, 0, pExInfo-&gt;bstrDescription, -1 <br>            , pszDesc, cch, NULL, NULL); <br> <br>        pszMsg=(LPTSTR)malloc(CCHSTRINGMAX+lstrlen(szSource)+cch); <br>       #else <br>        pszMsg=(LPTSTR)malloc((CCHSTRINGMAX+lstrlen(szSource) <br>            +lstrlen(pExInfo-&gt;bstrDescription))*sizeof(TCHAR)); <br>       #endif <br> <br>        if (0==pExInfo-&gt;wCode) <br>            { <br>            //Formatting for SCODE errors <br>            LoadString(m_hInst, IDS_MESSAGEEXCEPTIONSCODE, pszFmt <br>                , CCHSTRINGMAX); <br>            wsprintf(pszMsg, pszFmt, (long)pExInfo-&gt;scode <br>                , (LPTSTR)szSource <br>               #ifdef WIN32ANSI <br>                , pszDesc); <br>               #else <br>                , (LPTSTR)pExInfo-&gt;bstrDescription); <br>               #endif <br> <br>            } <br>        else <br>            { <br>            //Formatting for wCode errors <br>            LoadString(m_hInst, IDS_MESSAGEEXCEPTION, pszFmt <br>                , CCHSTRINGMAX); <br>            wsprintf(pszMsg, pszFmt, (UINT)pExInfo-&gt;wCode <br>                , (LPTSTR)szSource <br>               #ifdef WIN32ANSI <br>                , pszDesc); <br>               #else <br>                , (LPTSTR)pExInfo-&gt;bstrDescription); <br>               #endif <br>            } <br> <br>        free(pszFmt); <br>        } <br>    else <br>        { <br>        pszMsg=(LPTSTR)malloc(CCHSTRINGMAX*sizeof(TCHAR)); <br>        LoadString(m_hInst, IDS_MESSAGEUNKNOWNEXCEPTION, pszMsg <br>            , CCHSTRINGMAX); <br>        } <br> <br>    /* <br>     * In Windows 95 there is an MB_HELP style that we use in the <br>     * exception message if pExInfo-&gt;bstrHelpFile is non-NULL.  For <br>     * Windows NT 3.5 and Windows 3.1x, we'll just use a Cancel <br>     * button to demonstrate since making a Help button is too much <br>     * effort for this sample (requires a custom dialog box and code <br>     * to resize the dialog based on the length of the description <br>     * string which MessageBox does automatically...) <br>     */ <br>    uStyle=MB_OK | MB_ICONEXCLAMATION; <br> <br>   #ifdef MB_HELP <br>    uStyle |=(NULL!=pExInfo-&gt;bstrHelpFile) ? MB_HELP : 0; <br>   #else <br>    uStyle |=(NULL!=pExInfo-&gt;bstrHelpFile) ? MB_OKCANCEL : 0; <br>   #endif <br> <br>    uRet=Message(pszMsg, uStyle); <br> <br>    if (NULL!=pszMsg) <br>        free(pszMsg); <br> <br>   #ifdef MB_HELP <br>    if (IDHELP==uRet) <br>   #else <br>    if (IDCANCEL==uRet) <br>   #endif <br>        { <br>        TCHAR       szHelp[512]; <br> <br>        /* <br>         * If we read a HELPDIR, prepend it to the file.  Otherwise <br>         * just use the string we got since that's all we have. <br>         */ <br>        if ((TCHAR)0!=m_szHelpDir[0]) <br>            { <br>   #ifdef WIN32ANSI <br>    char    szTemp[256]; <br> <br>            WideCharToMultiByte(CP_ACP, 0, pExInfo-&gt;bstrHelpFile <br>                , -1, szTemp, 256, NULL, NULL); <br>            wsprintf(szHelp, TEXT("%s\\%s"), m_szHelpDir, szTemp); <br>           #else <br>            wsprintf(szHelp, TEXT("%s\\%s"), m_szHelpDir <br>                , pExInfo-&gt;bstrHelpFile); <br>   #endif <br>            } <br>        else <br>           #ifdef WIN32ANSI <br>            WideCharToMultiByte(CP_ACP, 0, pExInfo-&gt;bstrHelpFile <br>                , -1, szHelp, 512, NULL, NULL); <br>           #else <br>            lstrcpy(szHelp, pExInfo-&gt;bstrHelpFile); <br>           #endif <br> <br>        WinHelp(NULL, szHelp, HELP_CONTEXT, pExInfo-&gt;dwHelpContext); <br>        } <br> <br>    //We're responsible for cleaning up the strings. <br>    SysFreeString(pExInfo-&gt;bstrDescription); <br>    SysFreeString(pExInfo-&gt;bstrHelpFile); <br> <br>    return ResultFromScode(DISP_E_EXCEPTION); <br>    } <br> <br> <br> <br>/* <br> * CApp::Message (overloaded) <br> * <br> * Purpose: <br> *  Scribbles a message onto the client area of the window <br> *  or displays the message in a message box if a message <br> *  box style is given. <br> * <br> * Parameters: <br> *  pszMsg          LPTSTR to the message string. <br> *  uStyle          (message box only) UINT style bits <br> * <br> * Return Value: <br> *  UINT            Return value of MessageBox (MessageBox version <br> *                  only) <br> */ <br> <br>void CApp::Message(LPTSTR pszMsg) <br>    { <br>    HDC     hDC; <br>    RECT    rc; <br> <br>    hDC=GetDC(m_hWnd); <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>    /* <br>     * We'll just be sloppy and clear the whole window as <br>     * well as write the string with one ExtTextOut call. <br>     * No word wrapping here... <br>     */ <br> <br>    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, pszMsg <br>        , lstrlen(pszMsg), NULL); <br> <br>    ReleaseDC(m_hWnd, hDC); <br>    return; <br>    } <br> <br> <br>UINT CApp::Message(LPTSTR pszMsg, UINT uStyle) <br>    { <br>    return MessageBox(m_hWnd, pszMsg, TEXT("Automation Client") <br>        , uStyle); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * HelpDirFromCLSID <br> * <br> * Purpose: <br> *  Given a CLSID, looks up the TypeLib entry in the registry then <br> *  extracts the HELPDIR entry for that type information, storing <br> *  the path in pszPath. <br> * <br> * Parameters: <br> *  clsID           CLSID of the object we're looking up. <br> *  pszPath         LPTSTR buffer in which to store the directory. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void HelpDirFromCLSID(CLSID clsID, LPTSTR pszPath) <br>    { <br>    TCHAR       szCLSID[80]; <br>    TCHAR       szKey[512]; <br>    UINT        cch; <br>    long        lRet; <br> <br>    if (NULL==pszPath) <br>        return; <br> <br>    *pszPath=0; <br> <br>    cch=sizeof(szCLSID)/sizeof(TCHAR); <br>    StringFromGUID2(clsID, szCLSID, cch); <br>    wsprintf(szKey, TEXT("CLSID\\%s\\TypeLib"), szCLSID); <br> <br>    //Get LIBID from under CLSID <br>    if (ERROR_SUCCESS==RegQueryValue(HKEY_CLASSES_ROOT, szKey <br>        , szCLSID, &amp;lRet)) <br>        { <br>        //Get HELPDIR from under TypeLib <br>        wsprintf(szKey, TEXT("TypeLib\\%s\\HELPDIR"), szCLSID); <br>        RegQueryValue(HKEY_CLASSES_ROOT, szKey, pszPath, &amp;lRet); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CApp::ShowProperties <br> * <br> * Purpose: <br> *  Invokes the standard property page frame using the <br> *  property pages specified by the object we maintain <br> *  (only a single one). <br> */ <br> <br>void CApp::ShowProperties(void) <br>    { <br>    ISpecifyPropertyPages  *pISPP; <br>    CAUUID                  caGUID; <br>    HRESULT                 hr; <br> <br>    if (FAILED(m_pIDispatch-&gt;QueryInterface <br>        (IID_ISpecifyPropertyPages, (void **)&amp;pISPP))) <br>        { <br>        Message(TEXT("Object has no property pages")); <br>        return; <br>        } <br> <br>    hr=pISPP-&gt;GetPages(&amp;caGUID); <br>    pISPP-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        { <br>        Message(TEXT("Failed to retrieve property page GUIDs")); <br>        return; <br>        } <br> <br>    hr=OleCreatePropertyFrame(m_hWnd, 10, 10, OLETEXT("Beeper") <br>        , 1, (IUnknown **)&amp;m_pIDispatch, caGUID.cElems <br>        , caGUID.pElems, m_lcid, 0L, NULL); <br> <br>    if (FAILED(hr)) <br>        Message(TEXT("OleCreatePropertyFrame failed")); <br> <br>    //Free the GUIDs <br>    CoTaskMemFree((void *)caGUID.pElems); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/*** <br> *** IPropertyNotifySink Object <br> ***/ <br> <br>/* <br> * CPropertyNotifySink::CPropertyNotifySink <br> * CPropertyNotifySink::~CPropertyNotifySink <br> * <br> * Constructor Parameters: <br> *  pApp            PCApp of the application. <br> */ <br> <br>CPropertyNotifySink::CPropertyNotifySink(PCApp pApp) <br>    { <br>    m_cRef=0; <br>    m_pApp=pApp; <br>    return; <br>    } <br> <br>CPropertyNotifySink::~CPropertyNotifySink(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPropertyNotifySink::QueryInterface <br> * CPropertyNotifySink::AddRef <br> * CPropertyNotifySink::Release <br> */ <br> <br>STDMETHODIMP CPropertyNotifySink::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IPropertyNotifySink==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CPropertyNotifySink::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CPropertyNotifySink::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CPropertyNotifySink::OnChanged <br> * <br> * Purpose: <br> *  Notifies this sink that the property identified with dispID <br> *  has changed in whatever object this sink is connected to. <br> * <br> * Parameters: <br> *  dispID          DISPID of the property that changed, <br> *                  which can be DISPID_UNKNOWN for unspecified <br> *                  changes to multiple properties. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR always. <br> */ <br> <br>STDMETHODIMP CPropertyNotifySink::OnChanged(DISPID dispID) <br>    { <br>    TCHAR       szTemp[200]; <br> <br>    wsprintf(szTemp <br>        , TEXT("OnChanged notification received for DISPID=%lu") <br>        , dispID); <br> <br>    m_pApp-&gt;Message(szTemp); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CPropertyNotifySink::OnRequestEdit <br> * <br> * Purpose: <br> *  Notifies this sink that the property identified with dispID <br> *  is about to change and that the sink can prevent the change <br> *  if desired.  This can be used to enforce read-only states or <br> *  to save prior states before the change occurs. <br> * <br> * Parameters: <br> *  dispID          DISPID of the property that is changing <br> *                  which can be DISPID_UNKNOWN for multiple <br> *                  properties. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the property can change, S_FALSE <br> *                  if it cannot change, error code otherwise. <br> */ <br> <br>STDMETHODIMP CPropertyNotifySink::OnRequestEdit(DISPID dispID) <br>    { <br>    TCHAR       szTemp[200]; <br> <br>    wsprintf(szTemp <br>        , TEXT("OnRequestEdit received for DISPID=%lu"), dispID); <br>    m_pApp-&gt;Message(szTemp); <br> <br>    return ResultFromScode(m_pApp-&gt;m_fReadOnly ? S_FALSE : S_OK); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
