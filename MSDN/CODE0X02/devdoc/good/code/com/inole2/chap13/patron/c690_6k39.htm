<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TENANT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context705"></a>TENANT.CPP</h2>
<pre><code>/* <br> * TENANT.CPP <br> * Patron Chapter 13 <br> * <br> * Implementation of the CTentant class which holds information <br> * for a single object on a page.  It maintains position, references <br> * to data, and a storage. <br> * <br> * Copyright (c)1993-1997 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CTenant::CTenant <br> * CTenant::~CTenant <br> * <br> * Constructor Parameters: <br> *  dwID            DWORD identifier for this page. <br> *  hWnd            HWND of the pages window. <br> *  pPG             PCPages to the parent structure. <br> */ <br> <br>CTenant::CTenant(DWORD dwID, HWND hWnd, PCPages pPG) <br>    { <br>    m_hWnd=hWnd; <br>    m_dwID=dwID; <br> <br>    m_fInitialized=0; <br>    m_pIStorage=NULL; <br>    m_cOpens=0; <br> <br>    m_pObj=NULL; <br>    m_pPG =pPG; <br>    m_clsID=CLSID_NULL; <br>    m_fSetExtent=FALSE; <br> <br>    m_cRef=0; <br>    m_pIOleObject=NULL; <br>    m_pIViewObject2=NULL; <br> <br>    m_pIOleClientSite=NULL; <br>    m_pIAdviseSink=NULL; <br> <br>    m_pmkFile=NULL; <br>    m_fLinkAvail=TRUE;          //Checked on FLoad <br> <br>    //CHAPTER13MOD <br>    m_pmk=NULL; <br>    //End CHAPTER13MOD <br>    return; <br>    } <br> <br> <br>CTenant::~CTenant(void) <br>    { <br>    //CHAPTER13MOD <br>    if (NULL!=m_pmk) <br>        m_pmk-&gt;Release(); <br>    //End CHAPTER13MOD <br> <br>    if (NULL!=m_pmkFile) <br>        m_pmkFile-&gt;Release(); <br> <br>    //Object pointers cleaned up in Close. <br> <br>    //We delete our own interfaces since we control them <br>    if (NULL!=m_pIAdviseSink) <br>        delete m_pIAdviseSink; <br> <br>    if (NULL!=m_pIOleClientSite) <br>        delete m_pIOleClientSite; <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::QueryInterface <br> * CTenant::AddRef <br> * CTenant::Release <br> * <br> * Purpose: <br> *  IUnknown members for CTenant object. <br> */ <br> <br>STDMETHODIMP CTenant::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IOleClientSite==riid) <br>        *ppv=m_pIOleClientSite; <br> <br>    if (IID_IAdviseSink2==riid || IID_IAdviseSink==riid) <br>        *ppv=m_pIAdviseSink; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return E_NOINTERFACE; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CTenant::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CTenant::Release(void) <br>    { <br>    ULONG           cRefT; <br> <br>    cRefT=--m_cRef; <br> <br>    if (0L==m_cRef) <br>        delete this; <br> <br>    return cRefT; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::GetID <br> * <br> * Return Value: <br> *  DWORD           dwID field in this tenant.  This function is <br> *                  only here to avoid hiding inline implementations <br> *                  in tenant.h. <br> */ <br> <br>DWORD CTenant::GetID(void) <br>    { <br>    return m_dwID; <br>    } <br> <br> <br> <br>/* <br> * CTenant::GetStorageName <br> * <br> * Parameters: <br> *  pszName         LPTSTR to a buffer in which to store the storage <br> *                  name for this tenant. <br> * <br> * Return Value: <br> *  UINT            Number of characters stored. <br> */ <br> <br>UINT CTenant::GetStorageName(LPTSTR pszName) <br>    { <br>    return wsprintf(pszName, TEXT("Tenant %lu"), m_dwID); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::UCreate <br> * <br> * Purpose: <br> *  Creates a new tenant of the given CLSID, which can be either a <br> *  static bitmap or metafile or any compound document object. <br> * <br> * Parameters: <br> *  tType           TENANTTYPE to create, either a static metafile, <br> *                  bitmap, or some kind of compound document object <br> *                  This determines which OleCreate* call we use. <br> *  pvType          LPVOID providing the relevant pointer from which <br> *                  to create the tenant, depending on iType. <br> *  pFE             LPFORMATETC specifying the type of renderings <br> *                  to use. <br> *  pptl            LPPOINTL in which we store offset coordinates. <br> *  pszl            LPSIZEL where this object should store its <br> *                  lometric extents. <br> *  pIStorage       LPSTORAGE of the page we live in.  We have to <br> *                  create another storage in this for the tenant. <br> *  ppo             PPATRONOBJECT containing placement data. <br> *  dwData          DWORD with extra data, sensitive to iType. <br> * <br> * Return Value: <br> *  UINT            A UCREATE_* value depending on what we <br> *                  actually do. <br> */ <br> <br>UINT CTenant::UCreate(TENANTTYPE tType, LPVOID pvType <br>    , LPFORMATETC pFE, LPPOINTL pptl, LPSIZEL pszl <br>    , LPSTORAGE pIStorage, PPATRONOBJECT ppo, DWORD dwData) <br>    { <br>    HRESULT             hr; <br>    LPUNKNOWN           pObj; <br>    UINT                uRet=UCREATE_GRAPHICONLY; <br> <br>    if (NULL==pvType || NULL==pIStorage) <br>        return UCREATE_FAILED; <br> <br>    //Fail if this is called for an already living tenant. <br>    if (m_fInitialized) <br>        return UCREATE_FAILED; <br> <br>    m_fInitialized=TRUE; <br> <br>    //Create a new storage for this tenant. <br>    if (!FOpen(pIStorage)) <br>        return UCREATE_FAILED; <br> <br>    /* <br>     * Get the placement info if it's here.  We either have a non- <br>     * NULL PPATRONOBJECT in ppo or we have to use default <br>     * placement and retrieve the size from the object itself. <br>     */ <br>    pszl-&gt;cx=0; <br>    pszl-&gt;cy=0; <br> <br>    if (NULL!=ppo) <br>        { <br>        *pFE=ppo-&gt;fe; <br>        *pptl=ppo-&gt;ptl; <br>        *pszl=ppo-&gt;szl;     //Could be 0,0 , so we ask object <br> <br>        uRet=UCREATE_PLACEDOBJECT; <br>        } <br> <br>    hr=E_FAIL; <br> <br>    //Now create an object based specifically for the type. <br>    switch (tType) <br>        { <br>        case TENANTTYPE_NULL: <br>            break; <br> <br>        case TENANTTYPE_STATIC: <br>            /* <br>             * We could use OleCreateStaticFromData here which does <br>             * pretty much what we're doing below.  However, it does <br>             * not allow us to control whether we paste a bitmap or <br>             * a metafile--it uses metafile first, bitmap second. <br>             * For this reason we'll use code developed in Chapter <br>             * 6's FreeLoader to affect the paste. <br>             */ <br>            hr=CreateStatic((LPDATAOBJECT)pvType, pFE, &amp;pObj); <br>            break; <br> <br>        case TENANTTYPE_EMBEDDEDOBJECT: <br>            hr=OleCreate(*((LPCLSID)pvType), IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>            break; <br> <br>        case TENANTTYPE_EMBEDDEDFILE: <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>            OLECHAR pwcsFile[MAX_PATH]; <br>            mbstowcs(pwcsFile, (LPTSTR)pvType, MAX_PATH); <br>            hr=OleCreateFromFile(CLSID_NULL, pwcsFile <br>                , IID_IUnknown, OLERENDER_DRAW, NULL, NULL <br>                , m_pIStorage, (PPVOID)&amp;pObj); <br>#else <br>            hr=OleCreateFromFile(CLSID_NULL, (LPTSTR)pvType <br>                , IID_IUnknown, OLERENDER_DRAW, NULL, NULL <br>                , m_pIStorage, (PPVOID)&amp;pObj); <br>#endif <br>            break; <br> <br>        case TENANTTYPE_EMBEDDEDOBJECTFROMDATA: <br>            hr=OleCreateFromData((LPDATAOBJECT)pvType, IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>            break; <br> <br>        case TENANTTYPE_LINKEDFILE: <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>            OLECHAR pwcsType[256]; <br>            mbstowcs(pwcsType, (LPTSTR)pvType, 256); <br>            hr=OleCreateLinkToFile(pwcsType, IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>#else <br>            hr=OleCreateLinkToFile((LPTSTR)pvType, IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>#endif <br>            break; <br> <br>        case TENANTTYPE_LINKEDOBJECTFROMDATA: <br>            hr=OleCreateLinkFromData((LPDATAOBJECT)pvType <br>                , IID_IUnknown, OLERENDER_DRAW, NULL, NULL <br>                , m_pIStorage, (PPVOID)&amp;pObj); <br>            break; <br> <br>        default: <br>            break; <br>        } <br> <br>    //If creation didn't work, get rid of the element FOpen created. <br>    if (FAILED(hr)) <br>        { <br>        Destroy(pIStorage); <br>        return UCREATE_FAILED; <br>        } <br> <br>    //We don't get the size if PatronObject data was seen already. <br>    if (!FObjectInitialize(pObj, pFE, dwData)) <br>        { <br>        Destroy(pIStorage); <br>        return UCREATE_FAILED; <br>        } <br> <br>    if (0==pszl-&gt;cx &amp;&amp; 0==pszl-&gt;cy) <br>        { <br>        SIZEL   szl; <br> <br>        //Try to get the real size of the object, default to 2"*2" <br>        SETSIZEL((*pszl), 2*LOMETRIC_PER_INCH, 2*LOMETRIC_PER_INCH); <br>        hr=E_FAIL; <br> <br>        //Try IViewObject2 first, then IOleObject as a backup. <br>        if (NULL!=m_pIViewObject2) <br>            { <br>            hr=m_pIViewObject2-&gt;GetExtent(m_fe.dwAspect, -1, NULL <br>                , &amp;szl); <br>            } <br>        else <br>            { <br>            if (NULL!=m_pIOleObject) <br>                hr=m_pIOleObject-&gt;GetExtent(m_fe.dwAspect, &amp;szl); <br>            } <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Convert HIMETRIC to our LOMETRIC mapping <br>            SETSIZEL((*pszl), szl.cx/10, szl.cy/10); <br>            } <br>        } <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::FLoad <br> * <br> * Purpose: <br> *  Recreates the object living in this tenant in place of calling <br> *  FCreate.  This is used in loading as opposed to new creation. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE of the page we live in. <br> *  pti             PTENTANTINFO containing persistent information. <br> *                  The ID value in this structure is ignored. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::FLoad(LPSTORAGE pIStorage, PTENANTINFO pti) <br>    { <br>    HRESULT         hr; <br>    LPUNKNOWN       pObj; <br> <br>    if (NULL==pIStorage || NULL==pti) <br>        return FALSE; <br> <br>    //Fail if this is called for an already living tenant. <br>    if (m_fInitialized) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    //Open the storage for this tenant. <br>    if (!FOpen(pIStorage)) <br>        return FALSE; <br> <br>    /* <br>     * NOTE:  If you do not pass an IOleClientSite to OleLoad <br>     * it will not automatically reconnect a linked object to <br>     * the running source via IOleLink::BindIfRunning.  Since <br>     * we do not pass m_pIOleClientSite here, we'll call <br>     * BindIfRunning ourselves in FObjectInitialize. <br>     */ <br>    hr=OleLoad(m_pIStorage, IID_IUnknown, NULL, (PPVOID)&amp;pObj); <br> <br>    if (FAILED(hr)) <br>        { <br>        Destroy(pIStorage); <br>        return FALSE; <br>        } <br> <br>    m_fSetExtent=pti-&gt;fSetExtent; <br>    FObjectInitialize(pObj, &amp;pti-&gt;fe, NULL); <br> <br>    RectSet(&amp;pti-&gt;rcl, FALSE, FALSE); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::GetInfo <br> * <br> * Purpose: <br> *  Retrieved a TENANTINFO structure for this tenant. <br> * <br> * Parameters: <br> *  pti             PTENANTINFO structure to fill <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::GetInfo(PTENANTINFO pti) <br>    { <br>    if (NULL!=pti) <br>        { <br>        pti-&gt;dwID=m_dwID; <br>        pti-&gt;rcl=m_rcl; <br>        pti-&gt;fe=m_fe; <br>        pti-&gt;fSetExtent=m_fSetExtent; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::FObjectInitialize <br> * (Protected) <br> * <br> * Purpose: <br> *  Performs operations necessary after creating an object or <br> *  reloading one from storage. <br> * <br> * Parameters: <br> *  pObj            LPUNKNOWN of the object in this tenant. <br> *  pFE             LPFORMATETC describing the graphic here. <br> *  dwData          DWORD extra data.  If pFE-&gt;dwAspect== <br> *                  DVASPECT_ICON then this is the iconic metafile. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::FObjectInitialize(LPUNKNOWN pObj, LPFORMATETC pFE <br>    , DWORD dwData) <br>    { <br>    HRESULT         hr; <br>    LPPERSIST       pIPersist=NULL; <br>    DWORD           dw; <br>    PCDocument      pDoc; <br>    TCHAR           szFile[CCHPATHMAX]; <br>    LPOLELINK       pIOleLink=NULL; <br> <br>    if (NULL==pObj || NULL==pFE) <br>        return FALSE; <br> <br>    m_pObj=pObj; <br>    m_fe=*pFE; <br>    m_fe.ptd=NULL; <br>    m_dwState=TENANTSTATE_DEFAULT; <br> <br>    /* <br>     * Determine the type:  Static or Embedded.  If Static, <br>     * this will have CLSID_Picture_Metafile or CLSID_Picture_Dib. <br>     * Otherwise it's embedded.  Later we'll add a case for links. <br>     */ <br>    m_tType=TENANTTYPE_EMBEDDEDOBJECT; <br> <br>    if (SUCCEEDED(pObj-&gt;QueryInterface(IID_IPersist <br>        , (PPVOID)&amp;pIPersist))) <br>        { <br>        CLSID   clsid=CLSID_NULL; <br> <br>        hr=pIPersist-&gt;GetClassID(&amp;clsid); <br> <br>        //If we don't have a CLSID, default to static <br>        if (FAILED(hr) || CLSID_Picture_Metafile==clsid <br>            || CLSID_Picture_Dib==clsid) <br>            m_tType=TENANTTYPE_STATIC; <br> <br>        pIPersist-&gt;Release(); <br>        } <br> <br>    //Check if this is a linked object. <br>    if (SUCCEEDED(pObj-&gt;QueryInterface(IID_IOleLink <br>        , (PPVOID)&amp;pIOleLink))) <br>        { <br>        LPMONIKER   pmk; <br> <br>        hr=pIOleLink-&gt;GetSourceMoniker(&amp;pmk); <br> <br>        if (FAILED(hr) || NULL==pmk) <br>            m_tType=TENANTTYPE_STATIC; <br>        else <br>            { <br>            m_tType=TENANTTYPE_LINKEDOBJECT; <br>            pmk-&gt;Release(); <br> <br>            //Connect to the object if the source is running. <br>            pIOleLink-&gt;BindIfRunning(); <br>            } <br> <br>        pIOleLink-&gt;Release(); <br>        } <br> <br>    m_pIViewObject2=NULL; <br>    hr=pObj-&gt;QueryInterface(IID_IViewObject2 <br>        , (PPVOID)&amp;m_pIViewObject2); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, m_pIAdviseSink); <br> <br>    //We need an IOleObject most of the time, so get one here. <br>    m_pIOleObject=NULL; <br>    hr=pObj-&gt;QueryInterface(IID_IOleObject <br>         , (PPVOID)&amp;m_pIOleObject); <br> <br>    /* <br>     * Follow up object creation with advises and so forth.  If <br>     * we cannot get IOleObject here, then we know we can't do <br>     * any IOleObject actions from here on--object is static. <br>     */ <br>    if (FAILED(hr)) <br>        return TRUE; <br> <br>    /* <br>     * Get the MiscStatus bits and check for OLEMISC_ONLYICONIC. <br>     * If set, force dwAspect in m_fe to DVASPECT_ICON so we <br>     * remember to draw it properly and do extents right. <br>     */ <br>    m_pIOleObject-&gt;GetMiscStatus(m_fe.dwAspect, &amp;m_grfMisc); <br> <br>    if (OLEMISC_ONLYICONIC &amp; m_grfMisc) <br>        m_fe.dwAspect=DVASPECT_ICON; <br> <br>    /* <br>     * We could pass m_pIOleClientSite in an OleCreate* call, but <br>     * since this function could be called after OleLoad, we still <br>     * need to do this here, so it's always done here... <br>     */ <br>    m_pIOleObject-&gt;SetClientSite(m_pIOleClientSite); <br>    m_pIOleObject-&gt;Advise(m_pIAdviseSink, &amp;dw); <br> <br>    OleSetContainedObject(m_pIOleObject, TRUE); <br> <br>    /* <br>     * For IOleObject::SetHostNames we need the application name <br>     * and the document name (which is passed in the object <br>     * parameter).  The design of Patron doesn't give us nice <br>     * structured access to the name of the document we're in, so <br>     * I grab the parent of the Pages window (the document) and <br>     * send it DOCM_PDOCUMENT which returns us the pointer. <br>     * Roundabout, but it works. <br>     */ <br> <br>    pDoc=(PCDocument)SendMessage(GetParent(m_hWnd), DOCM_PDOCUMENT <br>        , 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        pDoc-&gt;FilenameGet(szFile, CCHPATHMAX); <br>    else <br>        szFile[0]=0; <br> <br>    //CHAPTER13MOD <br>    NotifyOfRename(szFile, NULL, NULL); <br>    //End CHAPTER13MOD <br> <br>    /* <br>     * This might have been Display as Icon (or the <br>     * OLEMISC_ONLYICONIC flag was set) in which case <br>     * m_fe.dwAspect=DVASPECT_ICON.  If this is coming from <br>     * a Display As Icon choice, then then dwData is a handle <br>     * to a metafile with the iconic aspect.  We take this and shove <br>     * it into the cache for this aspect, releasing the content <br>     * aspect.  OLESTD has a nice function that does this: <br>     * OleStdSwitchDisplayAspect, which also handles a later case <br>     * (Chapter 14) when we might want to switch BACK to content. <br>     * That, however, requires the Change Type dialog... <br>     * <br>     * If the object is marked as OLEMISC_ONLYICONIC, then it <br>     * is responsible for rendering the iconic image--not us. <br>     */ <br> <br>    if ((DVASPECT_ICON &amp; m_fe.dwAspect) &amp;&amp; NULL!=dwData) <br>        { <br>        //Temps to give to OleStdSwitchDisplayAspect <br>        DWORD       dw=DVASPECT_CONTENT; <br>        BOOL        fUpdate; <br> <br>        OleStdSwitchDisplayAspect(m_pIOleObject, &amp;dw, DVASPECT_ICON <br>            , (HGLOBAL)(UINT)dwData, TRUE, FALSE, NULL, &amp;fUpdate); <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CTenant::FOpen <br> * <br> * Purpose: <br> *  Retrieves the IStorage associated with this tenant.  The <br> *  IStorage is owned by the tenant and thus the tenant always <br> *  holds a reference count. <br> * <br> *  If the storage is already open for this tenant, then this <br> *  function will AddRef it; therefore the caller must always <br> *  match an FOpen with a Close. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE above this tenant (which has its <br> *                  own storage). <br> * <br> * Return Value: <br> *  BOOL            TRUE if opening succeeds, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::FOpen(LPSTORAGE pIStorage) <br>    { <br>    HRESULT     hr=NOERROR; <br>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                    | STGM_SHARE_EXCLUSIVE; <br>    TCHAR       szTemp[32]; <br> <br>    if (NULL==m_pIStorage) <br>        { <br>        if (NULL==pIStorage) <br>            return FALSE; <br> <br>        /* <br>         * Attempt to open the storage under this ID.  If there is <br>         * none, then create it.  In either case we end up with an <br>         * IStorage that we either save in pPage or release. <br>         */ <br> <br>        GetStorageName(szTemp); <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsTemp[32]; <br>        mbstowcs(pwcsTemp, szTemp, 32); <br>#else <br>        OLECHAR * pwcsTemp = szTemp; <br>#endif <br>        hr=pIStorage-&gt;OpenStorage(pwcsTemp, NULL, dwMode, NULL, 0 <br>            , &amp;m_pIStorage); <br> <br>        if (FAILED(hr)) <br>            { <br>            hr=pIStorage-&gt;CreateStorage(pwcsTemp, dwMode, 0, 0 <br>                , &amp;m_pIStorage); <br>            } <br>        } <br>    else <br>        m_pIStorage-&gt;AddRef(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    m_cOpens++; <br> <br>    m_pIOleClientSite=new CImpIOleClientSite(this, this); <br>    m_pIAdviseSink=new CImpIAdviseSink(this, this); <br> <br>    if (NULL==m_pIOleClientSite || NULL==m_pIAdviseSink) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Close <br> * <br> * Purpose: <br> *  Possibly commits the storage, then releases it reversing the <br> *  reference count from FOpen.  If the reference on the storage <br> *  goes to zero, the storage is forgotten.  However, the object we <br> *  contain is still held and as long as it's active the storage <br> *  remains alive. <br> * <br> * Parameters: <br> *  fCommit         BOOL indicating if we're to commit. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Close(BOOL fCommit) <br>    { <br>    if (fCommit) <br>        Update(); <br> <br>    if (NULL!=m_pIStorage) <br>        { <br>        m_pIStorage-&gt;Release(); <br> <br>        /* <br>         * We can't use a zero reference count to know when to NULL <br>         * this since other things might have AddRef'd the storage. <br>         */ <br>        if (0==--m_cOpens) <br>            { <br>            m_pIStorage=NULL; <br> <br>            //Close the object saving if necessary <br>            if (NULL!=m_pIOleObject) <br>                { <br>                m_pIOleObject-&gt;Close(OLECLOSE_SAVEIFDIRTY); <br>                m_pIOleObject-&gt;Release(); <br>                m_pIOleObject=NULL; <br>                } <br> <br>            //Release all other held pointers <br>            if (NULL!=m_pIViewObject2) <br>                { <br>                m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, NULL); <br>                m_pIViewObject2-&gt;Release(); <br>                m_pIViewObject2=NULL; <br>                } <br> <br>            if (NULL!=m_pObj) <br>                { <br>                //We know we only hold one ref from UCreate or FLoad <br>                m_pObj-&gt;Release(); <br>                m_pObj=NULL; <br>                } <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Update <br> * <br> * Purpose: <br> *  Forces a common on the page if it's open. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the object is open, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::Update(void) <br>    { <br>    LPPERSISTSTORAGE    pIPS; <br> <br>    if (NULL!=m_pIStorage) <br>        { <br>        /* <br>         * We need to OleSave again because we might have changed <br>         * the size or position of this tenant.  We also need to <br>         * save the rectangle on the page, since that's not known <br>         * to OLE. <br>         */ <br>        m_pObj-&gt;QueryInterface(IID_IPersistStorage, (PPVOID)&amp;pIPS); <br> <br>        //This fails for static objects...so we improvise if so <br>        if (FAILED(OleSave(pIPS, m_pIStorage, TRUE))) <br>            { <br>            //This is essentially what OleSave does. <br>            WriteClassStg(m_pIStorage, m_clsID); <br>            pIPS-&gt;Save(m_pIStorage, TRUE); <br>            } <br> <br>        pIPS-&gt;SaveCompleted(NULL); <br>        pIPS-&gt;Release(); <br> <br>        m_pIStorage-&gt;Commit(STGC_ONLYIFCURRENT); <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Destroy <br> * <br> * Purpose: <br> *  Removes this page from the given storage.  The caller should <br> *  eventually delete this CTenant object to free the object herein. <br> *  Nothing is committed when being destroyed. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE contianing this page on which to call <br> *                  DestroyElement <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Destroy(LPSTORAGE pIStorage) <br>    { <br>    TCHAR       szTemp[32]; <br> <br>    if (NULL!=pIStorage) <br>        { <br>        if (NULL!=m_pIOleObject) <br>            m_pIOleObject-&gt;Close(OLECLOSE_NOSAVE); <br> <br>        if (NULL!=m_pIStorage) <br>            { <br>            //Remove all reference/open counts on this storage. <br>            while (0!=m_cOpens) <br>                { <br>                m_pIStorage-&gt;Release(); <br>                m_cOpens--; <br>                } <br>            } <br> <br>        GetStorageName(szTemp); <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsTemp[32]; <br>        mbstowcs(pwcsTemp, szTemp, 32); <br>        pIStorage-&gt;DestroyElement(pwcsTemp); <br>#else <br>        pIStorage-&gt;DestroyElement(szTemp); <br>#endif <br>        m_pIStorage=NULL; <br>        } <br> <br>    //m_pObj is released in destructor. <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Select <br> * <br> * Purpose: <br> *  Selects or deselects the tenant. <br> * <br> * Parameters: <br> *  fSelect         BOOL indicating the new state of the tenant. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Select(BOOL fSelect) <br>    { <br>    BOOL        fWasSelected; <br>    DWORD       dwState; <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    fWasSelected=(BOOL)(TENANTSTATE_SELECTED &amp; m_dwState); <br> <br>    //Nothing to do when there's no change. <br>    if (fWasSelected==fSelect) <br>        return; <br> <br>    dwState=m_dwState &amp; ~TENANTSTATE_SELECTED; <br>    m_dwState=dwState | ((fSelect) ? TENANTSTATE_SELECTED : 0); <br> <br>    /* <br>     * Draw sizing handles to show the selection state.  We convert <br>     * things to MM_TEXT since that's what this function expects. <br>     */ <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>    hDC=GetDC(m_hWnd); <br> <br>    OleUIDrawHandles(&amp;rc, hDC, OLEUI_HANDLES_INSIDE <br>        | OLEUI_HANDLES_NOBORDER| OLEUI_HANDLES_USEINVERSE <br>        , CXYHANDLE, !fWasSelected); <br> <br>    ReleaseDC(m_hWnd, hDC); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::ShowAsOpen <br> * <br> * Purpose: <br> *  Draws or removes the hatch pattern over an object. <br> * <br> * Parameters: <br> *  fOpen           BOOL indicating the open state of this tenant. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ShowAsOpen(BOOL fOpen) <br>    { <br>    BOOL        fWasOpen; <br>    DWORD       dwState; <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    fWasOpen=(BOOL)(TENANTSTATE_OPEN &amp; m_dwState); <br> <br>    dwState=m_dwState &amp; ~TENANTSTATE_OPEN; <br>    m_dwState=dwState | ((fOpen) ? TENANTSTATE_OPEN : 0); <br> <br>    //If this was not open, then just hatch, otherwise repaint. <br>    if (!fWasOpen &amp;&amp; fOpen) <br>        { <br>        RECTFROMRECTL(rc, m_rcl); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>        hDC=GetDC(m_hWnd); <br>        OleUIDrawShading(&amp;rc, hDC, OLEUI_SHADE_FULLRECT, 0); <br>        ReleaseDC(m_hWnd, hDC); <br>        } <br> <br>    if (fWasOpen &amp;&amp; !fOpen) <br>        Repaint(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::ShowYourself <br> * <br> * Purpose: <br> *  Function that really just implements IOleClientSite::ShowObject. <br> *  Here we first check if the tenant is fully visible, and if so, <br> *  then nothing needs to happen.  Otherwise, if the upper left <br> *  corner of the tenant is in the upper left visible quadrant of <br> *  the window, we'll also consider ourselves done.  Otherwise <br> *  we'll put the upper left corner of the object at the upper left <br> *  corner of the window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ShowYourself(void) <br>    { <br>    RECTL       rcl; <br>    RECT        rc; <br>    POINT       pt1, pt2; <br> <br>    //Scrolling deals in device units; get our rectangle in those. <br>    RectGet(&amp;rcl, TRUE); <br> <br>    //Get the window rectangle offset for the current scroll pos. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    OffsetRect(&amp;rc, m_pPG-&gt;m_xPos, m_pPG-&gt;m_yPos); <br> <br>    //Check if the object is already visible. (macro in bookguid.h) <br>    SETPOINT(pt1, (int)rcl.left,  (int)rcl.top); <br>    SETPOINT(pt2, (int)rcl.right, (int)rcl.bottom); <br> <br>    if (PtInRect(&amp;rc, pt1) &amp;&amp; PtInRect(&amp;rc, pt2)) <br>        return; <br> <br>    //Check if the upper left is within the upper left quadrant <br>    if (((int)rcl.left &gt; rc.left <br>        &amp;&amp; (int)rcl.left &lt; ((rc.right+rc.left)/2)) <br>        &amp;&amp; ((int)rcl.top &gt; rc.top <br>        &amp;&amp; (int)rcl.top &lt; ((rc.bottom+rc.top)/2))) <br>        return; <br> <br>    //These are macros in INC\BOOK1632.H <br>    SendScrollPosition(m_hWnd, WM_HSCROLL, rcl.left-8); <br>    SendScrollPosition(m_hWnd, WM_VSCROLL, rcl.top-8); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CTenant::AddVerbMenu <br> * <br> * Purpose: <br> *  Creates the variable verb menu item for the object in this <br> *  tenant. <br> * <br> * Parmeters: <br> *  hMenu           HMENU on which to add items. <br> *  iPos            UINT position on that menu to add items. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::AddVerbMenu(HMENU hMenu, UINT iPos) <br>    { <br>    HMENU       hMenuTemp; <br>    LPOLEOBJECT pObj=m_pIOleObject; <br> <br>    //If we're static, say we have no object. <br>    if (TENANTTYPE_STATIC==m_tType) <br>        pObj=NULL; <br> <br>    OleUIAddVerbMenu(pObj, NULL, hMenu, iPos, IDM_VERBMIN <br>        , IDM_VERBMAX, FALSE, 0, &amp;hMenuTemp); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::CopyEmbeddedObject <br> * <br> * Purpose: <br> *  Copies an embedded object to the given data object (via SetData, <br> *  assuming this is a data transfer object for clipboard/drag-drop) <br> *  if that's what we're holding. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT in which to store the copy. <br> *  pFE             LPFORMATETC into which to copy CF_EMBEDDEDOBJECT <br> *                  if we put that in the data object. <br> *  pptl            LPPOINTL to the pick point (NULL outside of <br> *                  drag-drop); <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::CopyEmbeddedObject(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, LPPOINTL pptl) <br>    { <br>    LPPERSISTSTORAGE    pIPS; <br>    STGMEDIUM           stm; <br>    FORMATETC           fe; <br>    HRESULT             hr; <br>    UINT                cf; <br>    POINTL              ptl; <br>    SIZEL               szl; <br> <br>    //Can only copy embeddings. <br>    if (TENANTTYPE_EMBEDDEDOBJECT!=m_tType || NULL==m_pIOleObject) <br>        return; <br> <br>    if (NULL==pptl) <br>        { <br>        SETPOINTL(ptl, 0, 0); <br>        pptl=&amp;ptl; <br>        } <br> <br>    /* <br>     * Create CF_EMBEDDEDOBJECT.  This is simply an IStorage with a <br>     * copy of the embedded object in it.  The not-so-simple part is <br>     * getting an IStorage to stuff it in.  For this operation we'll <br>     * use a temporary compound file. <br>     */ <br> <br>    stm.pUnkForRelease=NULL; <br>    stm.tymed=TYMED_ISTORAGE; <br>    hr=StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_CREATE| STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE <br>        , 0, &amp;stm.pstg); <br> <br>    if (FAILED(hr)) <br>        return; <br> <br>    m_pObj-&gt;QueryInterface(IID_IPersistStorage, (PPVOID)&amp;pIPS); </code></pre>
<p>
</p>
<pre><code><br>    if (NOERROR==pIPS-&gt;IsDirty()) <br>        { <br>        OleSave(pIPS, stm.pstg, FALSE); <br>        pIPS-&gt;SaveCompleted(NULL); <br>        } <br>    else <br>        m_pIStorage-&gt;CopyTo(0, NULL, NULL, stm.pstg); <br> <br>    pIPS-&gt;Release(); <br> <br>    //stm.pstg now has a copy, so stuff it away. <br>    cf=RegisterClipboardFormat(CF_EMBEDDEDOBJECT); <br>    SETDefFormatEtc(fe, cf, TYMED_ISTORAGE); <br> <br>    if (SUCCEEDED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        *pFE=fe; <br>    else <br>        ReleaseStgMedium(&amp;stm); <br> <br>    stm.tymed=TYMED_HGLOBAL; <br> <br>    /* <br>     * You want to make sure that if this object is iconic, that you <br>     * create the object descriptor with DVASPECT_ICON instead of <br>     * the more typical DVASPECT_CONTENT.  Also remember that <br>     * the pick point is in HIMETRIC. <br>     */ <br>    XformSizeInPixelsToHimetric(NULL, (LPSIZEL)pptl, (LPSIZEL)&amp;ptl); <br> <br>    SETSIZEL(szl, (10*(m_rcl.right-m_rcl.left)) <br>        , (10 * (m_rcl.bottom-m_rcl.top))); <br> <br>    stm.hGlobal=OleStdGetObjectDescriptorDataFromOleObject <br>        (m_pIOleObject, NULL, m_fe.dwAspect, ptl, &amp;szl); <br> <br>    cf=RegisterClipboardFormat(CF_OBJECTDESCRIPTOR); <br>    SETDefFormatEtc(fe, cf, TYMED_HGLOBAL); <br> <br>    if (FAILED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        ReleaseStgMedium(&amp;stm); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER13MOD <br>/* <br> * CTenant::CopyLinkedObject <br> * <br> * Purpose: <br> *  Copies an linked object to the given data object (via SetData, <br> *  assuming this is a data transfer object for clipboard/drag-drop) <br> *  if that's what we're holding. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT in which to store the copy. <br> *  pFE             LPFORMATETC into which to copy CF_LINKSOURCE <br> *                  if we put that in the data object. <br> *  pptl            LPPOINTL to the pick point (NULL outside of <br> *                  drag-drop); <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::CopyLinkedObject(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, LPPOINTL pptl) <br>    { <br>    STGMEDIUM           stm; <br>    FORMATETC           fe; <br>    HRESULT             hr; <br>    UINT                cf; <br>    POINTL              ptl; <br>    LPMONIKER           pmk; <br>    CLSID               clsID; <br>    LPTSTR              psz=NULL; <br>    SIZEL               szl; <br> <br>    //Can only copy links to embeddings from here. <br>    if (TENANTTYPE_EMBEDDEDOBJECT!=m_tType || NULL==m_pIOleObject) <br>        return; <br> <br>    //If we don't have a full moniker, no linking allowed <br>    if (NULL==m_pmk) <br>        return; <br> <br>    //If the object doesn't support this, return. <br>    if (OLEMISC_CANTLINKINSIDE &amp; m_grfMisc) <br>        return; <br> <br>    if (NULL==pptl) <br>        { <br>        SETPOINTL(ptl, 0, 0); <br>        pptl=&amp;ptl; <br>        } <br> <br>    /* <br>     * We need to get CF_LINKSOURCE, but the server may not be <br>     * running, in which case we just grab the moniker and CLSID <br>     * for this object and call OleStdGetLinkSrcData. <br>     */ <br> <br>    m_pIOleObject-&gt;GetUserClassID(&amp;clsID); <br>    hr=m_pIOleObject-&gt;GetMoniker(0, OLEWHICHMK_OBJFULL, &amp;pmk); <br> <br>    if (FAILED(hr)) <br>        return; <br> <br>    //Set these tymeds or brain-dead OleStdGetLinkSourceData fails. <br>    stm.pUnkForRelease=NULL; <br>    stm.tymed=TYMED_NULL; <br>    cf=RegisterClipboardFormat(CF_LINKSOURCE); <br>    SETDefFormatEtc(fe, cf, TYMED_ISTREAM); <br>    hr=OleStdGetLinkSourceData(pmk, &amp;clsID, &amp;fe, &amp;stm); <br> <br>    if (FAILED(hr)) <br>        { <br>        pmk-&gt;Release(); <br>        return; <br>        } <br> <br>    //Send it to the data object for transfer <br>    if (SUCCEEDED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        *pFE=fe; <br>    else <br>        ReleaseStgMedium(&amp;stm); <br> <br>    XformSizeInPixelsToHimetric(NULL, (LPSIZEL)pptl, (LPSIZEL)&amp;ptl); <br> <br>    SETSIZEL(szl, (10*(m_rcl.right-m_rcl.left)) <br>        , (10 * (m_rcl.bottom-m_rcl.top))); <br> <br>    stm.hGlobal=OleStdGetObjectDescriptorDataFromOleObject <br>        (m_pIOleObject, NULL, m_fe.dwAspect, ptl, &amp;szl); <br> <br>    //Better set these properly or errors occur. <br>    stm.tymed=TYMED_HGLOBAL; <br>    stm.pUnkForRelease=NULL; <br> <br>    cf=RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR); <br>    SETDefFormatEtc(fe, cf, TYMED_HGLOBAL); <br> <br>    if (FAILED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        ReleaseStgMedium(&amp;stm); <br> <br>    return; <br>    } <br>//End CHAPTER13MOD <br> <br> <br> <br> <br> <br>/* <br> * CTenant::ShowObjectType <br> * <br> * Purpose: <br> *  Tells the object to switch on or off an indication of whether <br> *  it is linked or embedded. <br> * <br> * Parameters: <br> *  fShow           BOOL indicating to show the type (TRUE) or <br> *                  not (FALSE) <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ShowObjectType(BOOL fShow) <br>    { <br>    BOOL        fWasShow; <br>    DWORD       dwState; <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    fWasShow=(BOOL)(TENANTSTATE_SHOWTYPE &amp; m_dwState); <br> <br>    dwState=m_dwState &amp; ~TENANTSTATE_SHOWTYPE; <br>    m_dwState=dwState | ((fShow) ? TENANTSTATE_SHOWTYPE : 0); <br> <br>    /* <br>     * If this wasn't previously shown, just add the line, <br>     * otherwise repaint. <br>     */ <br>    if (!fWasShow &amp;&amp; fShow) <br>        { <br>        RECTFROMRECTL(rc, m_rcl); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>        hDC=GetDC(m_hWnd); <br>        OleUIShowObject(&amp;rc, hDC <br>            , (TENANTTYPE_LINKEDOBJECT==m_tType)); <br>        ReleaseDC(m_hWnd, hDC); <br>        } <br> <br>    if (fWasShow &amp;&amp; !fShow) <br>        Repaint(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::NotifyOfRename <br> * <br> * Purpose: <br> *  Instructs the tenant that the document was saved under a <br> *  different name.  In order to keep the right compound document <br> *  user interface, this tenant needs to tell its object through <br> *  IOleObject::SetHostNames. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of filename. <br> *  pmkFile         LPMONIKER of the new filename.  If this and <br> *                  pmkPage are NULL then nothing happens with <br> *                  monikers. <br> *  pmkPage         LPMONIKER of the page we're in. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>//CHAPTER13MOD <br>void CTenant::NotifyOfRename(LPTSTR pszFile, LPMONIKER pmkFile <br>    , LPMONIKER pmkPage) <br>//End CHAPTER13MOD <br>    { <br>    TCHAR       szObj[40]; <br>    TCHAR       szApp[40]; <br> <br>    if (NULL==m_pIOleObject) <br>        return; <br> <br>    if (TEXT('\0')==*pszFile) <br>        { <br>        LoadString(m_pPG-&gt;m_hInst, IDS_UNTITLED, szObj <br>            , sizeof(szObj)); <br>        } <br>    else <br>        { <br>        GetFileTitle(pszFile, szObj, sizeof(szObj)); <br> <br>       #ifndef WIN32 <br>        //Force filenames to uppercase in DOS versions. <br>        AnsiUpper(szObj); <br>       #endif <br>        } <br> <br>    LoadString(m_pPG-&gt;m_hInst, IDS_CAPTION, szApp, sizeof(szApp)); <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    OLECHAR pwcsObj[40]; <br>    OLECHAR pwcsApp[40]; <br>    mbstowcs(pwcsObj, szObj, 40); <br>    mbstowcs(pwcsApp, szApp, 40); <br>    m_pIOleObject-&gt;SetHostNames(pwcsApp, pwcsObj); <br>#else <br>    m_pIOleObject-&gt;SetHostNames(szApp, szObj); <br>#endif <br>    //CHAPTER13MOD <br>    if (NULL!=pmkFile) <br>        { <br>        if (NULL!=m_pmkFile) <br>            m_pmkFile-&gt;Release(); <br> <br>        m_pmkFile=pmkFile; <br>        m_pmkFile-&gt;AddRef(); <br> <br>        m_pIOleObject-&gt;SetMoniker(OLEWHICHMK_CONTAINER, pmkFile); <br>        } <br> <br>    if (NULL!=pmkFile &amp;&amp; NULL!=pmkPage) <br>        { <br>        LPMONIKER   pmkTenant=NULL; <br>        LPMONIKER   pmkRel=NULL; <br>        HRESULT     hr; <br> <br>        //Create the moniker for this tenant. <br>        GetStorageName(szObj); <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>        OLECHAR pwcsObj[40]; <br>        mbstowcs(pwcsObj, szObj, 40); <br>        hr=CreateItemMoniker(OLESTR("!"), pwcsObj, &amp;pmkTenant); <br>#else <br>        hr=CreateItemMoniker(OLESTR("!"), szObj, &amp;pmkTenant); <br>#endif <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Create the relative moniker, i.e. no pathname. <br>            hr=CreateGenericComposite(pmkPage, pmkTenant, &amp;pmkRel); <br>            pmkTenant-&gt;Release(); <br> <br>            if (SUCCEEDED(hr)) <br>                m_pIOleObject-&gt;SetMoniker(OLEWHICHMK_OBJREL, pmkRel); <br> <br>            //Hold on to the relative moniker <br>            if (NULL!=m_pmk) <br>                m_pmk-&gt;Release(); <br> <br>            m_pmk=pmkRel; <br>            } <br>        } <br>    //End CHAPTER13MOD <br> <br>    return; <br>    } <br> <br> <br> <br>//CHAPTER13MOD <br>/* <br> * CTenant::StorageGet <br> * <br> * Purpose: <br> *  Returns the IStorage pointer maintained by this tenant, <br> *  AddRef'd of course. <br> * <br> * Parameters: <br> *  ppStg           LPSTORAGE * in which to return the pointer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::StorageGet(LPSTORAGE *ppStg) <br>    { <br>    if (NULL==ppStg) <br>        return; <br> <br>    *ppStg=m_pIStorage; <br> <br>    if (NULL!=*ppStg) <br>        (*ppStg)-&gt;AddRef(); <br> <br>    return; <br>    } <br>//End CHAPTER13MOD <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Activate <br> * <br> * Purpose: <br> *  Activates a verb on the object living in the tenant.  Does <br> *  nothing for static objects. <br> * <br> * Parameters: <br> *  iVerb           LONG of the verb to execute. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the object changed due to this verb <br> *                  execution. <br> */ <br> <br>BOOL CTenant::Activate(LONG iVerb) <br>    { <br>    RECT        rc, rcH; <br>    CHourglass *pHour; <br>    SIZEL       szl; <br> <br>    //Can't activate statics. <br>    if (TENANTTYPE_STATIC==m_tType || NULL==m_pIOleObject) <br>        { <br>        MessageBeep(0); <br>        return FALSE; <br>        } <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    XformRectInPixelsToHimetric(NULL, &amp;rc, &amp;rcH); <br> <br>    pHour=new CHourglass; <br> <br>    //Get the server running first, then do a SetExtent, then show it <br>    OleRun(m_pIOleObject); <br> <br>    if (m_fSetExtent) <br>        { <br>        SETSIZEL(szl, rcH.right-rcH.left, rcH.bottom-rcH.top); <br>        m_pIOleObject-&gt;SetExtent(m_fe.dwAspect, &amp;szl); <br>        m_fSetExtent=FALSE; <br>        } <br> <br>    m_pIOleObject-&gt;DoVerb(iVerb, NULL, m_pIOleClientSite, 0 <br>        , m_hWnd, &amp;rcH); <br> <br>    delete pHour; <br> <br>    //If object changes, IAdviseSink::OnViewChange will see it. <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Draw <br> * <br> * Purpose: <br> *  Draws the tenant in its rectangle on the given hDC.  We assume <br> *  the DC is already set up for the mapping mode in which our <br> *  rectangle is expressed, since the Page we're in tells us both <br> *  the rect and the hDC. <br> * <br> * Parameters: <br> *  hDC             HDC in which to draw.  Could be a metafile, <br> *                  memory DC, screen, or printer. <br> *  ptd             DVTARGETDEVICE * describing the device. <br> *  hIC             HDC holding an information context (printing). <br> *  xOff, yOff      int offsets for the page in lometric <br> *  fNoColor        BOOL indicating if we should do B &amp; W <br> *  fPrinter        BOOL indicating if we should render for a <br> *                  printer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Draw(HDC hDC, DVTARGETDEVICE *ptd, HDC hIC <br>    , int xOff, int yOff, BOOL fNoColor, BOOL fPrinter) <br>    { <br>    HRESULT         hr; <br>    RECT            rc; <br>    RECTL           rcl; <br>    UINT            uMM; <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    OffsetRect(&amp;rc, -xOff, -yOff); <br>    RECTLFROMRECT(rcl, rc); <br> <br>    //Repaint erases the rectangle to insure full object cleanup <br>    if (!fNoColor &amp;&amp; !fPrinter) <br>        { <br>        COLORREF    cr; <br>        cr=SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>        ExtTextOut(hDC, rc.left, rc.top, ETO_OPAQUE, &amp;rc, NULL <br>            , 0, NULL); <br>        SetBkColor(hDC, cr); <br>        } <br> <br>    //We have to use Draw since we have a target device and IC. <br>    hr=m_pIViewObject2-&gt;Draw(m_fe.dwAspect, -1, NULL, ptd, hIC, hDC <br>        , &amp;rcl, NULL, NULL, 0); <br> <br> <br>    /* <br>     * If Draw failed, then perhaps it couldn't work for the device, <br>     * so try good old OleDraw as a last resort.  The code will <br>     * generally be OLE_E_BLANK. <br>     */ <br>    if (FAILED(hr)) <br>        OleDraw(m_pObj, m_fe.dwAspect, hDC, &amp;rc); <br> <br>    if (!fPrinter) <br>        { <br>        /* <br>         * Draw sizing handles to show the selection state.  We <br>         * convert things to MM_TEXT since that's what this <br>         * function expects. <br>         */ <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        uMM=SetMapMode(hDC, MM_TEXT); <br> <br>        if (TENANTSTATE_SELECTED &amp; m_dwState) <br>            { <br>            OleUIDrawHandles(&amp;rc, hDC, OLEUI_HANDLES_INSIDE <br>                | OLEUI_HANDLES_NOBORDER | OLEUI_HANDLES_USEINVERSE <br>                , CXYHANDLE, TRUE); <br>            } <br> <br>        if (TENANTSTATE_OPEN &amp; m_dwState) <br>            OleUIDrawShading(&amp;rc, hDC, OLEUI_SHADE_FULLRECT, 0); <br> <br>        //Distinguish linked and embedded objects. <br>        if (TENANTSTATE_SHOWTYPE &amp; m_dwState) <br>            { <br>            OleUIShowObject(&amp;rc, hDC <br>                , (TENANTTYPE_LINKEDOBJECT==m_tType)); <br>            } <br> <br>        uMM=SetMapMode(hDC, uMM); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Repaint <br> * CTenant::Invalidate <br> * <br> * Purpose: <br> *  Repaints the tenant where it lies or invalidates its area <br> *  for later repainting. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Repaint(void) <br>    { <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    /* <br>     * We might be asked to repaint from <br>     * IOleClientSite::OnShowWindow after we've switched pages if <br>     * our server was runnnig. This check on m_cOpens prevents that. <br>     */ <br>    if (0==m_cOpens) <br>        return; <br> <br>    hDC=GetDC(m_hWnd); <br>    SetRect(&amp;rc, m_pPG-&gt;m_xPos, m_pPG-&gt;m_yPos, 0, 0); <br>    RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>    SetMapMode(hDC, MM_LOMETRIC); <br>    Draw(hDC, NULL, NULL, rc.left, rc.top, FALSE, FALSE); <br> <br>    ReleaseDC(m_hWnd, hDC); <br>    return; <br>    } <br> <br> <br>void CTenant::Invalidate(void) <br>    { <br>    RECTL       rcl; <br>    RECT        rc; <br> <br>    RectGet(&amp;rcl, TRUE); <br>    RECTFROMRECTL(rc, rcl); <br> <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br>    InvalidateRect(m_hWnd, &amp;rc, FALSE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::TypeGet <br> * <br> * Purpose: <br> *  Returns the type of this tenant <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  TENANTTYPE      Type of the tenant. <br> */ <br> <br>TENANTTYPE CTenant::TypeGet(void) <br>    { <br>    return m_tType; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::FIsSelected <br> * <br> * Purpose: <br> *  Returns the selection state of this tenant. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if selected, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::FIsSelected(void) <br>    { <br>    return (BOOL)(m_dwState &amp; TENANTSTATE_SELECTED); <br>    } <br> <br> <br> <br>/* <br> * CTenant::FConvertToStatic <br> * <br> * Purpose: <br> *  Changes the object that lives in this tenant to a static one. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::FConvertToStatic(void) <br>    { <br>    /* <br>     * If you SetSourceMoniker in IOleLink to NULL, then the link is <br>     * gone as far as OLE is concerned.  You only need to make sure <br>     * the user doesn't have access to other functionality for this <br>     * object, which we insure by changing our internal type.  We <br>     * set this on loading if GetSourceMoniker returns NULL. <br>     */ <br>    m_tType=TENANTTYPE_STATIC; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::ObjectGet <br> * <br> * Purpose: <br> *  Retrieves the LPUNKNOWN of the object in use by this tenant <br> * <br> * Parameters: <br> *  ppUnk           LPUNKNOWN * in which to return the object <br> *                  pointer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ObjectGet(LPUNKNOWN *ppUnk) <br>    { <br>    if (NULL!=ppUnk) <br>        { <br>        *ppUnk=m_pObj; <br>        m_pObj-&gt;AddRef(); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::FormatEtcGet <br> * <br> * Purpose: <br> *  Retrieves the FORMATETC in use by this tenant <br> * <br> * Parameters: <br> *  pFE             LPFORMATETC in which to store the information. <br> *  fPresentation   BOOL indicating if we want the real format or <br> *                  that of the presentation. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::FormatEtcGet(LPFORMATETC pFE, BOOL fPresentation) <br>    { <br>    if (NULL!=pFE) <br>        { <br>        *pFE=m_fe; <br> <br>        //If there is no format, use metafile (for embedded objects) <br>        if (fPresentation || 0==pFE-&gt;cfFormat) <br>            { <br>            //Don't mess with dwAspect; might be icon or content. <br>            pFE-&gt;cfFormat=CF_METAFILEPICT; <br>            pFE-&gt;tymed=TYMED_MFPICT; <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::SizeGet <br> * CTenant::SizeSet <br> * CTenant::RectGet <br> * CTenant::RectSet <br> * <br> * Purpose: <br> *  Returns or sets the size/position of the object contained here. <br> * <br> * Parameters: <br> *  pszl/prcl       LPSIZEL (Size) or LPRECTL (Rect) with the <br> *                  extents of interest.  In Get situations, <br> *                  this will receive the extents; in Set it <br> *                  contains the extents. <br> *  fDevice         BOOL indicating that pszl/prcl is expressed <br> *                  in device units.  Otherwise it's LOMETRIC. <br> *  fInformObj      (Set Only) BOOL indicating if we need to inform <br> *                  the object all. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::SizeGet(LPSIZEL pszl, BOOL fDevice) <br>    { <br>    if (!fDevice) <br>        { <br>        pszl-&gt;cx=m_rcl.right-m_rcl.left; <br>        pszl-&gt;cy=m_rcl.bottom-m_rcl.top; <br>        } <br>    else <br>        { <br>        RECT        rc; <br> <br>        SetRect(&amp;rc, (int)(m_rcl.right-m_rcl.left) <br>            , (int)(m_rcl.bottom-m_rcl.top), 0, 0); <br> <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br> <br>        pszl-&gt;cx=(long)rc.left; <br>        pszl-&gt;cy=(long)rc.top; <br>        } <br> <br>    return; <br>    } <br> <br> <br>void CTenant::SizeSet(LPSIZEL pszl, BOOL fDevice, BOOL fInformObj) <br>    { <br>    SIZEL           szl; <br> <br>    if (!fDevice) <br>        { <br>        szl=*pszl; <br>        m_rcl.right =pszl-&gt;cx+m_rcl.left; <br>        m_rcl.bottom=pszl-&gt;cy+m_rcl.top; <br>        } <br>    else <br>        { <br>        RECT        rc; <br> <br>        SetRect(&amp;rc, (int)pszl-&gt;cx, (int)pszl-&gt;cy, 0, 0); <br>        RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>        m_rcl.right =(long)rc.left+m_rcl.left; <br>        m_rcl.bottom=(long)rc.top+m_rcl.top; <br> <br>        SETSIZEL(szl, (long)rc.left, (long)rc.top); <br>        } <br> <br> <br>    //Tell OLE that this object was resized. <br>    if (NULL!=m_pIOleObject &amp;&amp; fInformObj) <br>        { <br>        HRESULT     hr; <br>        BOOL        fRun=FALSE; <br> <br>        //Convert our LOMETRIC into HIMETRIC by *=10 <br>        szl.cx*=10; <br>        szl.cy*=-10;    //Our size is stored negative. <br> <br>        /* <br>         * If the MiscStatus bit of OLEMISC_RECOMPOSEONRESIZE <br>         * is set, then we need to run the object before calling <br>         * SetExtent to make sure it has a real chance to <br>         * re-render the object.  We have to update and close <br>         * the object as well after this happens. <br>         */ <br> <br>        if (OLEMISC_RECOMPOSEONRESIZE &amp; m_grfMisc) <br>            { <br>            if (!OleIsRunning(m_pIOleObject)) <br>                { <br>                OleRun(m_pIOleObject); <br>                fRun=TRUE; <br>                } <br>            } <br> <br>        hr=m_pIOleObject-&gt;SetExtent(m_fe.dwAspect, &amp;szl); <br> <br>        /* <br>         * If the object is not running and it does not have <br>         * RECOMPOSEONRESIZE, then SetExtent fails.  Make <br>         * sure that we call SetExtent again (by just calling <br>         * SizeSet here again) when we next run the object. <br>         */ <br>        if (SUCCEEDED(hr)) <br>            { <br>            m_fSetExtent=FALSE; <br> <br>            if (fRun) <br>                { <br>                m_pIOleObject-&gt;Update(); <br>                m_pIOleObject-&gt;Close(OLECLOSE_SAVEIFDIRTY); <br>                } <br>            } <br>        else <br>            { <br>            if (OLE_E_NOTRUNNING==hr) <br>                m_fSetExtent=TRUE; <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br>void CTenant::RectGet(LPRECTL prcl, BOOL fDevice) <br>    { <br>    if (!fDevice) <br>        *prcl=m_rcl; <br>    else <br>        { <br>        RECT        rc; <br> <br>        RECTFROMRECTL(rc, m_rcl); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        RECTLFROMRECT(*prcl, rc); <br>        } <br> <br>    return; <br>    } <br> <br> <br>void CTenant::RectSet(LPRECTL prcl, BOOL fDevice, BOOL fInformObj) <br>    { <br>    SIZEL   szl; <br>    LONG    cx, cy; <br> <br>    cx=m_rcl.right-m_rcl.left; <br>    cy=m_rcl.bottom-m_rcl.top; <br> <br>    if (!fDevice) <br>        m_rcl=*prcl; <br>    else <br>        { <br>        RECT        rc; <br> <br>        RECTFROMRECTL(rc, *prcl); <br>        RectConvertMappings(&amp;rc, NULL, FALSE); <br>        RECTLFROMRECT(m_rcl, rc); <br>        } <br> <br>    /* <br>     * Tell ourselves that the size changed, if it did.  SizeSet <br>     * will call IOleObject::SetExtent for us. <br>     */ <br>    if ((m_rcl.right-m_rcl.left)!=cx || (m_rcl.bottom-m_rcl.top)!=cy) <br>        { <br>        SETSIZEL(szl, m_rcl.right-m_rcl.left, m_rcl.bottom-m_rcl.top); <br>        SizeSet(&amp;szl, FALSE, fInformObj); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::CreateStatic <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new static bitmap or metafile object for this tenant <br> *  using a freeloading method allowing us to specify exactly which <br> *  type of data we want to paste since OleCreateStaticFromData <br> *  doesn't. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> *  pFE             LPFORMATETC describing the format to paste. <br> *  ppObj           LPUNKNOWN * into which we store the <br> *                  object pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, error code otherwise. <br> */ <br> <br>HRESULT CTenant::CreateStatic(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, LPUNKNOWN *ppObj) <br>    { <br>    HRESULT             hr; <br>    STGMEDIUM           stm; <br>    LPUNKNOWN           pIUnknown; <br>    LPOLECACHE          pIOleCache; <br>    LPPERSISTSTORAGE    pIPersistStorage; <br>    CLSID               clsID; <br> <br>    *ppObj=NULL; <br> <br>    //Try to get the data desired as specified in pFE-&gt;cfFormat <br>    hr=pIDataObject-&gt;GetData(pFE, &amp;stm); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    //Create the object to handle this data. <br>    if (CF_METAFILEPICT==pFE-&gt;cfFormat) <br>        clsID=CLSID_Picture_Metafile; <br>    else <br>        clsID=CLSID_Picture_Dib; <br> <br>    hr=CreateDataCache(NULL, clsID, IID_IUnknown <br>        , (PPVOID)&amp;pIUnknown); <br> <br>    if (FAILED(hr)) <br>        { <br>        ReleaseStgMedium(&amp;stm); <br>        return hr; <br>        } <br> <br>    m_clsID=clsID; <br> <br>    //Stuff the data into the object <br>    pIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;pIPersistStorage); <br>    pIPersistStorage-&gt;InitNew(m_pIStorage); <br> <br>    //Now that we have the cache object, shove the data into it. <br>    pIUnknown-&gt;QueryInterface(IID_IOleCache, (PPVOID)&amp;pIOleCache); <br>    pIOleCache-&gt;Cache(pFE, ADVF_PRIMEFIRST, NULL); <br> <br>    hr=pIOleCache-&gt;SetData(pFE, &amp;stm, TRUE); <br>    pIOleCache-&gt;Release(); <br> <br>    //Insure there is a persistent copy on the disk <br>    WriteClassStg(m_pIStorage, m_clsID); <br>    pIPersistStorage-&gt;Save(m_pIStorage, TRUE); <br>    pIPersistStorage-&gt;SaveCompleted(NULL); <br>    pIPersistStorage-&gt;Release(); <br> <br>    //The cache owns this now. <br>    ReleaseStgMedium(&amp;stm); <br> <br>    if (FAILED(hr)) <br>        pIUnknown-&gt;Release(); <br>    else <br>        *ppObj=pIUnknown; <br> <br>    return hr; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
