<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGES.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context697"></a>PAGES.CPP</h2>
<pre><code>/* <br> * PAGES.CPP <br> * Patron Chapter 13 <br> * <br> * Implementation of the CPages class.  See PAGEWIN.CPP for <br> * additional member functions. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br> <br>#include "patron.h" <br> <br> <br> <br>/* <br> * CPages:CPages <br> * CPages::~CPages <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application we're in. <br> *  cf              UINT application clipboard format. <br> */ <br> <br>CPages::CPages(HINSTANCE hInst, UINT cf) <br>    : CWindow(hInst) <br>    { <br>    m_pPageCur=NULL; <br>    m_iPageCur=NOVALUE;  //Pages are 0 indexed, this is one before <br>    m_cPages=0; <br>    m_hWndPageList=NULL; <br>    m_fSystemFont=FALSE; <br> <br>    //Initialize to 8.5*11 inch with .25 inch margins as a default. <br>    m_cx=(LOMETRIC_PER_INCH*17)/2; <br>    m_cy=LOMETRIC_PER_INCH*11; <br> <br>    m_xMarginLeft=LOMETRIC_PER_INCH/4; <br>    m_xMarginRight=LOMETRIC_PER_INCH/4; <br>    m_yMarginTop=LOMETRIC_PER_INCH/4; <br>    m_yMarginBottom=LOMETRIC_PER_INCH/4; <br> <br>    m_xPos=0L; <br>    m_yPos=0L; <br> <br>    m_dwIDNext=0; <br>    m_pIStorage=NULL; <br> <br>    m_fDirty=FALSE; <br>    m_cf=cf; <br> <br>    m_fDragSource=FALSE; <br>    m_fMoveInPage=FALSE; <br>    m_fLinkAllowed=FALSE; <br> <br>    m_fDragRectShown=FALSE; <br> <br>    m_uScrollInset=GetProfileInt(TEXT("windows") <br>        , TEXT("DragScrollInset"), DD_DEFSCROLLINSET); <br> <br>    m_uScrollDelay=GetProfileInt(TEXT("windows") <br>        , TEXT("DragScrollDelay"), DD_DEFSCROLLDELAY); <br> <br>    m_uHScrollCode=0; <br>    m_uVScrollCode=0; <br>    m_fShowTypes=FALSE; <br> <br>    //CHAPTER13MOD <br>    m_pmkFile=NULL; <br>    //End CHAPTER13MOD <br>    return; <br>    } <br> <br> <br>CPages::~CPages(void) <br>    { <br>    //Ensure memory cleaned up in list; do final IStorage::Release <br>    FIStorageSet(NULL, FALSE, FALSE); <br> <br>    //CHAPTER13MOD <br>    if (NULL!=m_pmkFile) <br>        m_pmkFile-&gt;Release(); <br>    //End CHAPTER13MOD <br> <br>    if (NULL!=m_hFont &amp;&amp; !m_fSystemFont) <br>        DeleteObject(m_hFont); <br> <br>    if (NULL!=m_hWndPageList) <br>        DestroyWindow(m_hWndPageList); <br> <br>    //m_hWnd destroyed with the document. <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPages::FIsDirty <br> * <br> * Purpose: <br> *  Tells the caller (document) if anything's happened to dirty us. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::FIsDirty(void) <br>    { <br>    return m_fDirty; <br>    } <br> <br> <br> <br>/* <br> * CPages::FInit <br> * <br> * Purpose: <br> *  Instantiates a pages window within a given parent.  The <br> *  parent may be a main application window, could be an MDI child <br> *  window. We really do not care. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  pRect           LPRECT that this window should occupy <br> *  dwStyle         DWORD containing the window's style flags. <br> *                  Should contain WS_CHILD | WS_VISIBLE in <br> *                  typical circumstances. <br> *  uID             UINT ID to associate with this window <br> *  pv              LPVOID unused for now. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FInit(HWND hWndParent, LPRECT pRect, DWORD dwStyle <br>    , UINT uID, LPVOID pv) <br>    { <br>    int     cy; <br> <br>    m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, SZCLASSPAGES <br>        , SZCLASSPAGES, dwStyle, pRect-&gt;left, pRect-&gt;top <br>        , pRect-&gt;right-pRect-&gt;left, pRect-&gt;bottom-pRect-&gt;top <br>        , hWndParent, (HMENU)uID, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    /* <br>     * Create the hidden listbox we'll use to track pages.  We give <br>     * it the owner-draw style so we can just store pointers in it. <br>     * We have to set the parent to NULL such that the window hangs <br>     * around after the pages window is destroyed so that we can <br>     * clean up the memory stored in it from the CPages destructor. <br>     */ <br>    m_hWndPageList=CreateWindow(TEXT("listbox"), TEXT("Page List") <br>        , WS_POPUP | LBS_OWNERDRAWFIXED, 0, 0, 100, 100 <br>        , HWND_DESKTOP, NULL, m_hInst, NULL); <br> <br>    if (NULL==m_hWndPageList) <br>        return FALSE; <br> <br>    //Create a 14 point Arial font, or use the system variable font. <br>    cy=MulDiv(-14, LOMETRIC_PER_INCH, 72); <br>    m_hFont=CreateFont(cy, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE <br>        , ANSI_CHARSET, OUT_TT_PRECIS, CLIP_TT_ALWAYS, PROOF_QUALITY <br>        , VARIABLE_PITCH | FF_SWISS, TEXT("Arial")); <br> <br>    if (NULL==m_hFont) <br>        { <br>        m_hFont=(HFONT)GetStockObject(ANSI_VAR_FONT); <br>        m_fSystemFont=TRUE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FIStorageSet <br> * <br> * Purpose: <br> *  Provides the document's IStorage to the pages for its own use. <br> *  If this is a new storage, we initalize it with streams that we <br> *  want to always exists.  If this is an open, then we create <br> *  our page list from the PageList string we wrote before. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE to the new or opened storage.  If <br> *                  NULL, we just clean up and exit. <br> *  fChange         BOOL indicating is this was a Save As operation, <br> *                  meaning that we have the structure already and <br> *                  just need to change the value of m_pIStorage. <br> *  fInitNew        BOOL indicating if this is a new storage or one <br> *                  opened from a previous save. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::FIStorageSet(LPSTORAGE pIStorage, BOOL fChange <br>    , BOOL fInitNew) <br>    { <br>    DWORD           dwMode=STGM_DIRECT | STGM_READWRITE <br>                        | STGM_SHARE_EXCLUSIVE; <br>    HRESULT         hr; <br>    PCPage          pPage; <br>    BOOL            fRet=FALSE; <br>    ULONG           cbRead; <br>    PAGELIST        pgList; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    LPDWORD         pdwID; <br>    UINT            i; <br> <br>    //If we're changing saved roots, simply open current page again <br>    if (fChange) <br>        { <br>        if (NULL==pIStorage) <br>            return FALSE; <br> <br>        m_pIStorage-&gt;Release(); <br>        m_pIStorage=pIStorage; <br>        m_pIStorage-&gt;AddRef(); <br> <br>        FPageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br>        return TRUE; <br>        } <br> <br>    if (NULL!=m_hWndPageList) <br>        { <br>        //On new or open, clean out whatever it is we have. <br>        for (i=0; i &lt; m_cPages; i++) <br>            { <br>            //CHAPTER13MOD <br>            if (FPageGet(i, &amp;pPage, FALSE)) <br>                pPage-&gt;Release(); <br>            //End CHAPTER13MOD <br>            } <br> <br>        SendMessage(m_hWndPageList, LB_RESETCONTENT, 0, 0L); <br>        } <br> <br>    if (NULL!=m_pIStorage) <br>        m_pIStorage-&gt;Release(); <br> <br>    m_pIStorage=NULL; <br> <br>    //If we're just cleaning up, then we're done. <br>    if (NULL==pIStorage) <br>        return TRUE; <br> <br>    m_pIStorage=pIStorage; <br>    m_pIStorage-&gt;AddRef(); <br> <br>    //If this is a new storage, create the streams we require <br>    if (fInitNew) <br>        { <br>        //Page list header. <br>        hr=m_pIStorage-&gt;CreateStream(SZSTREAMPAGELIST, dwMode <br>            | STGM_CREATE, 0, 0, &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br> <br>        pIStream-&gt;Release(); <br> <br>        //Device Configuration <br>        hr=m_pIStorage-&gt;CreateStream(SZSTREAMDEVICECONFIG, dwMode <br>            | STGM_CREATE, 0, 0, &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br> <br>        pIStream-&gt;Release(); <br>        return TRUE; <br>        } <br> <br> <br>    /* <br>     * We're opening an existing file: <br>     *  1)  Configure for the device we're on <br>     *  2)  Read the Page List and create page entries for each. <br>     */ <br> <br>    ConfigureForDevice(); <br> <br>    //Read the page list. <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMPAGELIST, NULL, dwMode, 0 <br>        , &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        pIStream-&gt;Read(&amp;pgList, sizeof(PAGELIST), &amp;cbRead); <br>        m_cPages  =(UINT)pgList.cPages; <br>        m_iPageCur=(UINT)pgList.iPageCur; <br>        m_dwIDNext=pgList.dwIDNext; <br> <br>        fRet=TRUE; <br>        cbRead=pgList.cPages*sizeof(DWORD); <br> <br>        if (0!=cbRead) <br>            { <br>            pdwID=(LPDWORD)pIMalloc-&gt;Alloc(cbRead); <br> <br>            if (NULL!=pdwID) <br>                { <br>                pIStream-&gt;Read(pdwID, cbRead, &amp;cbRead); <br> <br>                for (i=0; i &lt; m_cPages; i++) <br>                    fRet &amp;=FPageAdd(NOVALUE, *(pdwID+i), FALSE); <br> <br>                pIMalloc-&gt;Free(pdwID); <br>                } <br>            } <br> <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    if (!fRet) <br>        return FALSE; <br> <br>    FPageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::FIStorageUpdate <br> * <br> * Purpose: <br> *  Insures that all pages are committed before a root save. <br> * <br> * Parameters: <br> *  fCloseAll       BOOL directing us to close all open storages <br> *                  and streams. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FIStorageUpdate(BOOL fCloseAll) <br>    { <br>    PCPage          pPage; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    LPDWORD         pdwID; <br>    ULONG           cb; <br>    HRESULT         hr; <br>    PAGELIST        pgList; <br>    BOOL            fRet=FALSE; <br>    UINT            i; <br> <br>    //We only need to close the current page--nothing else is open. <br>    if (NULL!=m_pPageCur) <br>        { <br>        m_pPageCur-&gt;Update(); <br> <br>        if (fCloseAll) <br>            m_pPageCur-&gt;Close(FALSE); <br>        } <br> <br>    //We don't hold anything else open, so write the page list. <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMPAGELIST, NULL, STGM_DIRECT <br>        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        pgList.cPages=m_cPages; <br>        pgList.iPageCur=m_iPageCur; <br>        pgList.dwIDNext=m_dwIDNext; <br> <br>        pIStream-&gt;Write(&amp;pgList, sizeof(PAGELIST), &amp;cb); <br> <br>        cb=m_cPages*sizeof(DWORD); <br>        pdwID=(LPDWORD)pIMalloc-&gt;Alloc(cb); <br> <br>        if (NULL!=pdwID) <br>            { <br>            for (i=0; i &lt; m_cPages; i++) <br>                { <br>                FPageGet(i, &amp;pPage, FALSE); <br>                *(pdwID+i)=pPage-&gt;GetID(); <br>                } <br> <br>            pIStream-&gt;Write(pdwID, cb, &amp;cb); <br>            pIMalloc-&gt;Free(pdwID); <br>            fRet=TRUE; <br>            } <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    //Don't forget to clean up the dirty flag when we do an update. <br>    m_fDirty=!fRet; <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectGet <br> * <br> * Purpose: <br> *  Returns the rectangle of the Pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectGet(LPRECT pRect) <br>    { <br>    RECT        rc; <br>    POINT       pt; <br> <br>    //Retrieve the size of our rectangle in parent coordinates. <br>    GetWindowRect(m_hWnd, &amp;rc); <br>    SETPOINT(pt, rc.left, rc.top); <br>    ScreenToClient(GetParent(m_hWnd), &amp;pt); <br> <br>    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left) <br>        , pt.y+(rc.bottom-rc.top)); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectSet <br> * <br> * Purpose: <br> *  Sets a new rectangle for the Pages window which sizes to fit. <br> *  Coordinates are given in parent terms. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, pRect-&gt;left, pRect-&gt;top <br>        , (UINT)cx, (UINT)cy, SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::SizeGet <br> * <br> * Purpose: <br> *  Retrieves the size of the pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the size.  The right <br> *                  and bottom fields will contain the dimensions. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeGet(LPRECT pRect) <br>    { <br>    RectGet(pRect); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::SizeSet <br> * <br> * Purpose: <br> *  Sets a new size in parent coordinates for the Pages window. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy <br>        , SWP_NOMOVE | SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageInsert <br> * <br> * Purpose: <br> *  Creates a new page immediately after the current page.  If <br> *  there are no pages then this creates page 1. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index of the new page, 0 on failure. <br> */ <br> <br>UINT CPages::PageInsert(UINT uReserved) <br>    { <br>    if (0!=m_cPages &amp;&amp; NULL!=m_pPageCur) <br>        { <br>        //Close the current page, committing changes. <br>        m_pPageCur-&gt;Close(TRUE); <br>        } <br> <br>    //Create and open the new page. <br>    if (!FPageAdd(m_iPageCur, m_dwIDNext, TRUE)) <br>        return 0; <br> <br>    m_dwIDNext++; <br>    m_iPageCur++; <br>    m_cPages++; <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br> <br>    FPageGet(m_iPageCur, &amp;m_pPageCur, FALSE); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageDelete <br> * <br> * Removes the current page from the page list. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index to the now current page from the page <br> *                  list, NOVALUE on error. <br> */ <br> <br>UINT CPages::PageDelete(UINT uReserved) <br>    { <br>    PCPage      pPage; <br> <br>    if (!FPageGet(m_iPageCur, &amp;pPage, FALSE)) <br>        return NOVALUE; <br> <br>    //Delete the page in both the storage and in memory. <br>    SendMessage(m_hWndPageList, LB_DELETESTRING, m_iPageCur, 0L); <br> <br>    m_pPageCur-&gt;Destroy(m_pIStorage); <br> <br>    //CHAPTER13MOD <br>    m_pPageCur-&gt;Release();   //Does final pPage-&gt;Close <br>    //End CHAPTER13MOD <br>    m_pPageCur=NULL; <br> <br>    /* <br>     * If this is the last page then the current is one less.  If <br>     * it's the only page the current is zero.  Otherwise the <br>     * current is the next page. <br>     */ <br> <br>    if (m_iPageCur==m_cPages-1)   //Covers last or only page. <br>        m_iPageCur--; <br> <br>    m_cPages--; <br> <br>    //Insure the new visible page is open. <br>    if (0!=m_cPages) <br>        { <br>        FPageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br>        InvalidateRect(m_hWnd, NULL, FALSE); <br>        } <br>    else <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    UpdateWindow(m_hWnd); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageGet <br> * <br> * Purpose: <br> *  Retrieves the index of the current page we're viewing. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the current page. <br> */ <br> <br>UINT CPages::CurPageGet(void) <br>    { <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageSet <br> * <br> * Purpose: <br> *  Sets the index of the current page to view. <br> * <br> * Parameters: <br> *  iPage           UINT index of the page to view. 0 means first <br> *                  page, NOVALUE means last page. <br> * <br> * Return Value: <br> *  UINT            Index of the previous current page, NOVALUE on <br> *                  error. <br> */ <br> <br>UINT CPages::CurPageSet(UINT iPage) <br>    { <br>    UINT    iPageNew; <br>    UINT    iPagePrev=m_iPageCur; <br>    PCPage  pPage; <br> <br>    switch (iPage) <br>        { <br>        case 0: <br>            iPageNew=0; <br>            break; <br> <br>        case NOVALUE: <br>            iPageNew=m_cPages-1; <br>            break; <br> <br>        default: <br>            if (iPage &gt;= m_cPages) <br>                iPage=0; <br> <br>            iPageNew=iPage; <br>            break; <br>        } <br> <br>    //No reason to switch to the same page. <br>    if (iPagePrev==iPageNew) <br>        return iPage; <br> <br>    //Close the old page committing changes. <br>    if (!FPageGet(iPagePrev, &amp;pPage, FALSE)) <br>        return NOVALUE; <br> <br>    pPage-&gt;Close(TRUE); <br> <br>    m_iPageCur=iPageNew; <br> <br>    //Open the new page. <br>    FPageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br>    return iPagePrev; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::NumPagesGet <br> * <br> * Purpose: <br> *  Returns the number of pages this object current contains. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of pages we contain. <br> */ <br> <br>UINT CPages::NumPagesGet(void) <br>    { <br>    return m_cPages; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::DevModeSet <br> * <br> * Purpose: <br> *  Provides the Pages with the current printer information. <br> * <br> * Parameters: <br> *  hDevMode        HGLOBAL to the memory containing the DEVMODE. <br> *                  This function assumes responsibility for this <br> *                  handle. <br> *  hDevNames       HGLOBAL providing the driver name and device <br> *                  name from which we can create a DC for <br> *                  information. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we could accept this configuration, <br> *                  FALSE otherwise.  If we return TRUE we also <br> *                  delete the old memory we hold. <br> */ <br> <br>BOOL CPages::DevModeSet(HGLOBAL hDevMode, HGLOBAL hDevNames) <br>    { <br>    LPDEVNAMES      pdn; <br>    LPTSTR          psz; <br>    HGLOBAL         hMem; <br>    PDEVICECONFIG   pdc; <br>    LPDEVMODE       pdm; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br>    ULONG           cbDevMode, cbWrite; <br>    BOOL            fRet=FALSE; <br> <br>    if (NULL==hDevMode || NULL==hDevNames) <br>        return FALSE; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * DEVMODE is variable length--total length in hDevMode, so the <br>     * amount to write is that plus string space.  We subtract <br>     * sizeof(DEVMODE) as that is already included from GlobalSize. <br>     */ <br>    cbDevMode=GlobalSize(hDevMode); <br>    cbWrite=cbDevMode+sizeof(DEVICECONFIG)-sizeof(DEVMODE); <br> <br>    hMem=GlobalAlloc(GHND, cbWrite); <br> <br>    if (NULL==hMem) <br>        { <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    pdc=(PDEVICECONFIG)GlobalLock(hMem);    //This always works <br>    pdm=(LPDEVMODE)GlobalLock(hDevMode);    //This might not <br> <br>    if (NULL!=pdm) <br>        { <br>        pdc-&gt;cb=cbWrite; <br>        pdc-&gt;cbDevMode=cbDevMode; <br>        memcpy(&amp;pdc-&gt;dm, pdm, (int)cbDevMode); <br>        GlobalUnlock(hDevMode); <br> <br>        psz=(LPTSTR)GlobalLock(hDevNames); <br> <br>        if (NULL!=psz) <br>            { <br>            pdn=(LPDEVNAMES)psz; <br>            lstrcpy(pdc-&gt;szDriver, psz+pdn-&gt;wDriverOffset); <br>            lstrcpy(pdc-&gt;szDevice, psz+pdn-&gt;wDeviceOffset); <br>            lstrcpy(pdc-&gt;szPort,   psz+pdn-&gt;wOutputOffset); <br> <br>            pIStream-&gt;Write(pdc, cbWrite, &amp;cbWrite); <br>            GlobalUnlock(hDevNames); <br>            fRet=TRUE; <br>            } <br>        } <br> <br>    GlobalUnlock(hMem); <br>    GlobalFree(hMem); <br> <br>    pIStream-&gt;Release(); <br> <br>    if (!fRet) <br>        return FALSE; <br> <br>    GlobalFree(hDevNames); <br>    GlobalFree(hDevMode); <br> <br>    return ConfigureForDevice(); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::DevModeGet <br> * <br> * Purpose: <br> *  Retrieves a copy of the current DEVMODE structure for this <br> *  Pages window.  The caller is responsible for this memory. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HGLOBAL         Handle to the memory containing the DEVMODE <br> *                  structure. <br> */ <br> <br>HGLOBAL CPages::DevModeGet(void) <br>    { <br>    HGLOBAL         hMem; <br>    LPVOID          pv; <br>    ULONG           cbDevMode, cbRead; <br>    LARGE_INTEGER   li; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    //Read how much to allocate for the DEVMODE structure <br>    LISet32(li, CBSEEKOFFSETCBDEVMODE); <br>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br>    pIStream-&gt;Read(&amp;cbDevMode, sizeof(ULONG), &amp;cbRead); <br> <br>    hMem=GlobalAlloc(GHND, cbDevMode); <br> <br>    if (NULL!=hMem) <br>        { <br>        pv=(LPVOID)GlobalLock(hMem); <br>        pIStream-&gt;Read(pv, cbDevMode, &amp;cbRead); <br>        GlobalUnlock(hMem); <br>        } <br> <br>    pIStream-&gt;Release(); <br>    return hMem; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::DevReadConfig <br> * <br> * Purpose: <br> *  Public function to read the current device configuration and <br> *  optionally return an information context for it. <br> * <br> * <br> * Parameters: <br> *  ppcd            PCOMBINEDEVICE * in which to return a pointer <br> *                  to an allocated structure that has all the <br> *                  device information we want.  Ignored if NULL. <br> *                  This is allocated with the task allocator. <br> *  phDC            HDC * in which to return the information <br> *                  context.  If NULL, no IC is created.  Caller <br> *                  becomes responsible for the returned IC. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::DevReadConfig(PCOMBINEDEVICE *ppcd, HDC *phDC) <br>    { <br>    HRESULT         hr; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    PCOMBINEDEVICE  pcd; <br>    ULONG           cb, cbRead; <br>    LARGE_INTEGER   li; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * Allocate the COMBINEDEVICE structure including the variable <br>     * information past the DEVMODE part. <br>     */ <br> <br>    hr=CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    /* <br>     * Read size of the DEVICECONFIG structure including variable <br>     * portion of DEVMODE.  We need to load all this information <br>     * for CreateIC.  To this size we'll add the size of <br>     * DVTARGETDEVICE in order to allocate a COMBINEDEVICE. <br>     */ <br> <br>    pIStream-&gt;Read(&amp;cb, sizeof(DWORD), &amp;cbRead); <br> <br>    pcd=(PCOMBINEDEVICE)pIMalloc-&gt;Alloc(cb+sizeof(DVTARGETDEVICE)); <br> <br>    if (NULL==pcd) <br>        { <br>        pIMalloc-&gt;Release(); <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    //Now get the real information. <br>    LISet32(li, 0); <br>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br>    pIStream-&gt;Read(&amp;(pcd-&gt;dc), cb, &amp;cbRead); <br>    pIStream-&gt;Release(); <br> <br> <br>    /* <br>     * If requested, complete the DVTARGETDEVICE structure in <br>     * pcd and store pcd in *ppcd for return. <br>     */ <br> <br>    if (NULL!=ppcd) <br>        { <br>        WORD    cb=sizeof(DVTARGETDEVICE); <br> <br>        pcd-&gt;td.tdSize=cb; <br>        pcd-&gt;td.tdExtDevmodeOffset=cb; <br>        pcd-&gt;td.tdDriverNameOffset=cb+sizeof(DEVMODE); <br>        pcd-&gt;td.tdDeviceNameOffset=cb+sizeof(DEVMODE) <br>            +(CCHDEVICENAME*sizeof(TCHAR)); <br>        pcd-&gt;td.tdPortNameOffset  =cb+sizeof(DEVMODE) <br>            +(CCHDEVICENAME*2*sizeof(TCHAR)); <br> <br>        *ppcd=pcd; <br>        } <br> <br>    //Create an IC if requested. <br>    if (NULL!=phDC) <br>        { <br>        //Get the DC then configure <br>        *phDC=CreateIC(pcd-&gt;dc.szDriver, pcd-&gt;dc.szDevice <br>            , pcd-&gt;dc.szPort, &amp;(pcd-&gt;dc.dm)); <br> <br>        if (NULL==*phDC) <br>            return FALSE; <br>        } <br> <br>    //pcd is a temporary allocation in this case <br>    if (NULL==ppcd) <br>        pIMalloc-&gt;Free(pcd); <br> <br>    pIMalloc-&gt;Release(); <br>    return (NULL!=*phDC); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::ConfigureForDevice <br> * <br> * Purpose: <br> *  Recalculates our drawing configuration based on the contents of <br> *  an hDC.  If no HDC is given we use the contents of our DevMode <br> *  stream. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::ConfigureForDevice(void) <br>    { <br>    POINT           ptOffset, ptPaper; <br>    RECT            rc; <br>    HDC             hDC; <br> <br>    if (!DevReadConfig(NULL, &amp;hDC)) <br>        return FALSE; <br> <br>    //Get usable page dimensions:  already sensitive to orientation <br>    m_cx=GetDeviceCaps(hDC, HORZSIZE)*10-16; //*10: mm to LOMETRIC <br>    m_cy=GetDeviceCaps(hDC, VERTSIZE)*10-16; //-16: for driver bugs. <br> <br>    //Calculate the printer-limited margins on each side in LOMETRIC <br>    Escape(hDC, GETPRINTINGOFFSET, NULL, NULL, &amp;ptOffset); <br>    Escape(hDC, GETPHYSPAGESIZE,   NULL, NULL, &amp;ptPaper); <br> <br>    SetRect(&amp;rc, ptOffset.x, ptOffset.y, ptPaper.x, ptPaper.y); <br>    SetMapMode(hDC, MM_LOMETRIC); <br>    RectConvertMappings(&amp;rc, hDC, FALSE); <br> <br>    //Left and top margins are the printing offset. <br>    m_xMarginLeft= rc.left+8;   //+8 to match -16 above <br>    m_yMarginTop =-rc.top+8;    //LOMETRIC makes this negative. <br> <br>    //Right is (paper width)-(usable width)-(left margin) <br>    m_xMarginRight =rc.right-m_cx-m_xMarginLeft; <br> <br>    //Bottom is (paper height)-(usable height)-(top margin)+1 <br>    m_yMarginBottom=-rc.bottom-m_cy-m_yMarginTop+1; <br> <br>    UpdateScrollRanges(); <br> <br>    DeleteDC(hDC); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CPages::TenantCreate <br> * CPages::TenantDestroy <br> * <br> * Purpose: <br> *  Pass-throughs for CPage members on the current page. <br> */ <br> <br>BOOL CPages::TenantCreate(TENANTTYPE tType, LPVOID pv <br>    , LPFORMATETC pFE, PPATRONOBJECT ppo, DWORD dwData) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantCreate(tType, pv, pFE, ppo, dwData); <br>    m_fDirty |= fRet; <br>    return fRet; <br>    } <br> <br> <br>BOOL CPages::TenantDestroy(void) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantDestroy(); <br>    m_fDirty |= fRet; <br>    return fRet; <br>    } <br> <br> <br> <br>/* <br> * CPages::TenantClip <br> * <br> * Purpose: <br> *  Copies or cuts the currently selected tenant to the clipoard. <br> * <br> * Parameters: <br> *  fCut            BOOL TRUE to cut the object, FALSE to copy. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::TenantClip(BOOL fCut) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantClip(fCut); <br>    m_fDirty |= (fRet &amp;&amp; fCut); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FQueryObjectSelected <br> * <br> * Purpose: <br> *  Returns whether or not there is an object selected on this <br> *  page for Cut, Copy, Delete functions. <br> * <br> * Parameters: <br> *  hMenu           HMENU on which object related items live. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have an object, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FQueryObjectSelected(HMENU hMenu) <br>    { <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    return m_pPageCur-&gt;FQueryObjectSelected(hMenu); <br>    } <br> <br> <br> <br>/* <br> * CPages::ActivateObject <br> * <br> * Purpose: <br> *  Executes a verb on the currently selected object. <br> * <br> * Parameters: <br> *  iVerb           LONG of the selected verb. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::ActivateObject(LONG iVerb) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    m_pPageCur-&gt;ActivateObject(iVerb); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::ShowObjectTypes <br> * <br> * Purpose: <br> *  Pass-through to CPage::ShowObjectTypes <br> * <br> * Parameters: <br> *  fShow           BOOL indicating to show the type or not. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::ShowObjectTypes(BOOL fShow) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    m_fShowTypes=fShow; <br>    m_pPageCur-&gt;ShowObjectTypes(fShow); <br>    return; <br>    } <br> <br> <br> <br> <br>/* </code></pre>
<p>
</p>
<pre><code>* CPages::NotifyTenantsOfRename <br> * <br> * Purpose: <br> *  Pass-through to CPage to tell tenants that the document <br> *  changes names. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of the new filename. <br> *  pmk             LPMONKIER to the new file moniker. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::NotifyTenantsOfRename(LPTSTR pszFile, LPMONIKER pmk) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    if (NULL!=m_pmkFile) <br>        m_pmkFile-&gt;Release(); <br> <br>    m_pmkFile=pmk; <br>    m_pmkFile-&gt;AddRef(); <br>    m_pPageCur-&gt;NotifyTenantsOfRename(pszFile, pmk); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::FQueryLinksInPage <br> * <br> * Purpose: <br> *  Pass through to current page to see if there are any <br> *  linked objects <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::FQueryLinksInPage() <br>    { <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    return m_pPageCur-&gt;FQueryLinksInPage(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::FGetUILinkContainer <br> * <br> * Purpose: <br> *  Creates an object with the IOleUILinkContainer interface for <br> *  the links dialog.  We know the current page which is what <br> *  we need to create this thing, so we can create it here instead <br> *  of bugging the page for it. <br> * <br> * Parameters: <br> *  ppObj           PCIOleUILinkContainer * in which we return <br> *                  the pointer. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FGetUILinkContainer(PCIOleUILinkContainer *ppObj) <br>    { <br>    PCIOleUILinkContainer   pObj; <br> <br>    *ppObj=NULL; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    pObj=new CIOleUILinkContainer(m_pPageCur); <br> <br>    if (NULL==pObj) <br>        return FALSE; <br> <br>    if (!pObj-&gt;FInit()) <br>        { <br>        delete pObj; <br>        return FALSE; <br>        } <br> <br>    pObj-&gt;AddRef(); <br>    *ppObj=pObj; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::CalcBoundingRect <br> * (Protected) <br> * <br> * Purpose: <br> *  Calculates a rectangle that bounds the printed page and the <br> *  current scroll state of the window. <br> * <br> * Parameters: <br> *  prc             LPRECT to fill with window (device) coordinates. <br> *  fWindow         BOOL indicating to include the window in this <br> *                  calculation or return only the printed page <br> *                  coordinates. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::CalcBoundingRect(LPRECT prc, BOOL fWindow) <br>    { <br>    RECT        rc, rcT; <br> <br>    if (NULL==prc) <br>        return; <br> <br>    //Calculate the boundaries for sizing: intersect page &amp; screen <br>    rc.left=LOMETRIC_BORDER+m_xMarginLeft; <br>    rc.top =-LOMETRIC_BORDER-m_yMarginTop; <br>    rc.right =rc.left+(UINT)m_cx; <br>    rc.bottom=rc.top -(UINT)m_cy; <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    OffsetRect(&amp;rc, -(int)m_xPos, -(int)m_yPos); <br> <br>    if (!fWindow) <br>        { <br>        *prc=rc; <br>        return; <br>        } <br> <br>    //Intersect with window to make the size bounds. <br>    GetClientRect(m_hWnd, &amp;rcT); <br>    IntersectRect(prc, &amp;rc, &amp;rcT); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FPageGet <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a page of a given index returning a BOOL so it's simple <br> *  to use this function inside if statements. <br> * <br> * Parameters: <br> *  iPage           UINT page to retrieve 0 based. <br> *  ppPage          PCPage * in which to return the page pointer <br> *  fOpen           BOOL indicating if we should open this page as <br> *                  well. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FPageGet(UINT iPage, PCPage *ppPage, BOOL fOpen) <br>    { <br>    if (NULL==ppPage) <br>        return FALSE; <br> <br>    if (LB_ERR!=SendMessage(m_hWndPageList, LB_GETTEXT <br>        , iPage, (LONG)ppPage)) <br>        { <br>        if (fOpen) <br>            (*ppPage)-&gt;FOpen(m_pIStorage); <br> <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FPageAdd <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new page initialized to the given values.  The new <br> *  page's storage is created if it does not already exist.  If <br> *  fOpenStorage is set the page's storage is opened and left <br> *  opened. <br> * <br> * Parameters: <br> *  iPage           UINT Location at which to insert page; new page <br> *                  is inserted after this position.  NOVALUE for <br> *                  the end. <br> *  dwID            DWORD ID for this page. <br> *  fOpenStorage    BOOL indicating if we're to leave the storage <br> *                  open. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FPageAdd(UINT iPage, DWORD dwID, BOOL fOpenStorage) <br>    { <br>    PCPage      pPage; <br>    LRESULT     lr; <br> <br>    pPage=new CPage(dwID, m_hWnd, this); <br> <br>    if (NULL==pPage) <br>        return FALSE; <br> <br>    //CHAPTER13MOD <br>    pPage-&gt;AddRef(); <br>    //End CHAPTER13MOD <br> <br>    if (fOpenStorage) <br>        pPage-&gt;FOpen(m_pIStorage); <br> <br>    if (NOVALUE==iPage) <br>        iPage--; <br> <br>    //Now try to add to the listbox. <br>    lr=SendMessage(m_hWndPageList, LB_INSERTSTRING, iPage+1 <br>        , (LONG)pPage); <br> <br>    if (LB_ERRSPACE==lr) <br>        { <br>        if (fOpenStorage) <br>            pPage-&gt;Close(FALSE); <br> <br>        //CHAPTER13MOD <br>        pPage-&gt;Release(); <br>        //End CHAPTER13MOD <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>//CHAPTER13MOD <br>/* <br> * CPages::IPageGetFromID <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a page of a given identifier <br> * <br> * Parameters: <br> *  dwID            DWORD identifier of the page to retrieve.  If <br> *                  NOVALUE, then we return the current page. <br> *  ppPage          PCPage * in which to return the page <br> *                  pointer <br> *  fOpen           BOOL indicating if we should open this page as <br> *                  well. <br> * <br> * Return Value: <br> *  UINT            Index of the page if successful, NOVALUE <br> *                  otherwise. <br> */ <br> <br>UINT CPages::IPageGetFromID(DWORD dwID, PCPage *ppPage <br>    , BOOL fOpen) <br>    { <br>    UINT        i; <br>    PCPage      pPage; <br> <br>    if (NULL==ppPage) <br>        return FALSE; <br> <br>    if ((LONG)-1==(LONG)dwID) <br>        { <br>        *ppPage=m_pPageCur; <br>        return m_iPageCur; <br>        } <br> <br>    *ppPage=NULL; <br> <br>    for (i=0; i &lt; m_cPages; i++) <br>        { <br>        if (!FPageGet(i, &amp;pPage, FALSE)) <br>            continue; <br> <br>        if (pPage-&gt;GetID()==dwID) <br>            { <br>            if (fOpen) <br>                pPage-&gt;FOpen(m_pIStorage); <br> <br>            *ppPage=pPage; <br>            return i; <br>            } <br>        } <br> <br>    return NOVALUE; <br>    } <br> <br>//End CHAPTER13MOD </code></pre>
<p>&nbsp;</p></body>
</HTML>
