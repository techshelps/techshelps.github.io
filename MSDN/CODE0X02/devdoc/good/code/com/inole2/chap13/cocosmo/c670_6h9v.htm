<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context673"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Component Cosmo Chapter 13 <br> * <br> * Implementation of the CCosmoDoc derivation of CDocument <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cocosmo.h" <br> <br> <br>/* <br> * CCosmoDoc::CCosmoDoc <br> * CCosmoDoc::~CCosmoDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events <br> */ <br> <br>CCosmoDoc::CCosmoDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pPL=NULL; <br>    m_pPLAdv=NULL; <br>    m_uPrevSize=SIZE_RESTORED; <br>    m_pIConnectPt=NULL; <br>    m_dwCookie=0; <br> <br>    m_pIStorage=NULL; <br>    m_pp.psModel=PERSIST_UNKNOWN; <br>    m_pp.pIP.pIPersistStorage=NULL; //Affects all pointers <br> <br>    m_pImpIAdviseSink=NULL; <br>    m_dwConn=0; <br>    m_pIDataClip=NULL; <br> <br>    //CHAPTER13MOD <br>    m_pDropTarget=NULL; <br>    m_fDragSource=FALSE; <br>    //End CHAPTER13MOD <br> <br>    return; <br>    } <br> <br> <br>CCosmoDoc::~CCosmoDoc(void) <br>    { <br>    LPDATAOBJECT        pIDataObject; <br>    HRESULT             hr; <br> <br>    if (NULL!=m_pIDataClip) <br>        m_pIDataClip-&gt;Release(); <br> <br>    //Turn off the advise. <br>    if (NULL!=m_pPL &amp;&amp; 0!=m_dwConn) <br>        { <br>        hr=m_pPL-&gt;QueryInterface(IID_IDataObject <br>            , (PPVOID)&amp;pIDataObject); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            pIDataObject-&gt;DUnadvise(m_dwConn); <br>            pIDataObject-&gt;Release(); <br>            } <br>        } <br> <br>    DeleteInterfaceImp(m_pImpIAdviseSink); <br>    ReleaseInterface(m_pp.pIP.pIPersistStorage); <br>    ReleaseInterface(m_pIStorage); <br> <br>    if (NULL!=m_pIConnectPt) <br>        { <br>        m_pIConnectPt-&gt;Unadvise(m_dwCookie); <br>        ReleaseInterface(m_pIConnectPt); <br>        } <br> <br>    ReleaseInterface(m_pPL); <br>    ReleaseInterface(m_pPLAdv); <br> <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Init <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Init(PDOCUMENTINIT pDI) <br>    { <br>    RECT                        rc; <br>    HRESULT                     hr; <br>    IConnectionPointContainer  *pCPC; <br>    FORMATETC                   fe; <br>    LPDATAOBJECT                pIDataObject; <br> <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::Init(pDI)) <br>        return FALSE; <br> <br>    //Create the Polyline Component <br>    hr=CoCreateInstance(CLSID_Polyline10, NULL, CLSCTX_INPROC_SERVER <br>        , IID_IPolyline10, (PPVOID)&amp;m_pPL); <br> <br>    if (FAILED(hr)) <br>        { <br>        //Warn that we could not load the Polyline <br>        MessageBox(pDI-&gt;hWndDoc, PSZ(IDS_NOPOLYLINE) <br>            , PSZ(IDS_CAPTION), MB_OK); <br>        return FALSE; <br>        } <br> <br>    //Initialize the contained Polyline which creates a window. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    if (FAILED(m_pPL-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_POLYLINE))) <br>        return FALSE; <br> <br>    //Set up an advise on the Polyline. <br>    m_pPLAdv=new CPolylineAdviseSink(this); <br>    m_pPLAdv-&gt;AddRef(); <br> <br>    if (SUCCEEDED(m_pPL-&gt;QueryInterface(IID_IConnectionPointContainer <br>        , (PPVOID)&amp;pCPC))) <br>        { <br>        //CHAPTER10MOD <br>        if (SUCCEEDED(pCPC-&gt;FindConnectionPoint <br>            (IID_IPolylineAdviseSink10, &amp;m_pIConnectPt))) <br>        //End CHAPTER10MOD <br>            { <br>            m_pIConnectPt-&gt;Advise((LPUNKNOWN)m_pPLAdv, &amp;m_dwCookie); <br>            } <br> <br>        pCPC-&gt;Release(); <br>        } <br> <br>    /* <br>     * Check for the storage model being used in Polyline. <br>     * Any InitNew member will be called from CCosmoDoc::Load. <br>     */ <br>    hr=m_pPL-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;m_pp.pIP.pIPersistStorage); <br> <br>    if (SUCCEEDED(hr)) <br>        m_pp.psModel=PERSIST_STORAGE; <br>    else <br>        { <br>        hr=m_pPL-&gt;QueryInterface(IID_IPersistStreamInit <br>            , (PPVOID)&amp;m_pp.pIP.pIPersistStreamInit); <br> <br>        if (SUCCEEDED(hr)) <br>            m_pp.psModel=PERSIST_STREAMINIT; <br>        else <br>            { <br>            hr=m_pPL-&gt;QueryInterface(IID_IPersistStream <br>            , (PPVOID)&amp;m_pp.pIP.pIPersistStream); <br> <br>            if (SUCCEEDED(hr)) <br>                m_pp.psModel=PERSIST_STREAM; <br>            else <br>                return FALSE; <br>            } <br>        } <br> <br> <br>    /* <br>     * Create an IAdviseSink and send it to the Polyline's <br>     * IDataObject with the clipboard format for the Polyline <br>     * (as in IPOLY10.H). <br>     */ <br> <br>    //This is a private macro. <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br> <br>    m_pImpIAdviseSink=new CImpIAdviseSink(this, this); <br> <br>    if (NULL==m_pImpIAdviseSink) <br>        return FALSE; <br> <br>    //Set up an advise for the Polyline format <br>    hr=m_pPL-&gt;QueryInterface(IID_IDataObject, (PPVOID)&amp;pIDataObject); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIDataObject-&gt;DAdvise(&amp;fe, ADVF_NODATA, m_pImpIAdviseSink <br>        , &amp;m_dwConn); <br>    pIDataObject-&gt;Release(); <br> <br>    //CHAPTER13MOD <br>    m_pDropTarget=new CDropTarget(this); <br> <br>    if (NULL!=m_pDropTarget) <br>        { <br>        m_pDropTarget-&gt;AddRef(); <br>        CoLockObjectExternal(m_pDropTarget, TRUE, FALSE); <br>        RegisterDragDrop(m_hWnd, m_pDropTarget); <br>        } <br>    //End CHAPTER13MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>//IUnknown interface for all others we implement in the document <br> <br>/* <br> * CCosmoDoc::QueryInterface <br> * CCosmoDoc::AddRef <br> * CCosmoDoc::Release <br> * <br> * Purpose: <br> *  IUnknown members for the CCosmoDoc implementation. <br> */ <br> <br>STDMETHODIMP CCosmoDoc::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    //The document is the unknown <br>    if (IID_IUnknown==riid) <br>        *ppv=(LPUNKNOWN)this; <br> <br>    //Return contained interfaces for others. <br>    if (IID_IPolylineAdviseSink10==riid) <br>        *ppv=m_pPLAdv; <br> <br>    if (IID_IAdviseSink==riid) <br>        *ppv=m_pImpIAdviseSink; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(S_FALSE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CCosmoDoc::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CCosmoDoc::Release(void) <br>    { <br>    return --m_cRef; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize <br> *  the Polyline. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    if (WM_DESTROY==iMsg) <br>        { <br>        /* <br>         * Flush the clipboard data object if it's still on the <br>         * clipboard before the document window is destroyed which <br>         * also destroys the polyline, which is a child.  Flushing <br>         * now avoid errors that would occur if flushing happened <br>         * at application shutdown, for the Polyline would still be <br>         * alive but without a valid window. <br>         */ <br>        if (NULL!=m_pIDataClip) <br>            { <br>            if (NOERROR==OleIsCurrentClipboard(m_pIDataClip)) <br>                OleFlushClipboard(); <br>            } <br> <br>        //CHAPTER13MOD <br>        /* <br>         * We have to revoke the drop target here because the window <br>         * will be destroyed and the property forcefully removed <br>         * before we could do this in the destructor. <br>         */ <br>        if (NULL!=m_pDropTarget) <br>            { <br>            RevokeDragDrop(m_hWnd); <br>            CoLockObjectExternal(m_pDropTarget, FALSE, TRUE); <br>            m_pDropTarget-&gt;Release(); <br>            } <br>        //End CHAPTER13MOD <br>        } <br> <br>    if (WM_SIZE==iMsg) <br>        { <br>        //Don't effect the Polyline size to or from minimized state. <br>        if (SIZE_MINIMIZED!=wParam &amp;&amp; SIZE_MINIMIZED !=m_uPrevSize) <br>            { <br>            //When we change size, resize any Polyline we hold. <br>            dx=LOWORD(lParam); <br>            dy=HIWORD(lParam); <br> <br>            /* <br>             * If we are getting WM_SIZE in response to a Polyline <br>             * notification, then don't resize the Polyline window <br>             * again. <br>             */ <br>            if (!m_fNoSize &amp;&amp; NULL!=m_pPL) <br>                { <br>                //Resize the polyline to fit the new client <br>                SetRect(&amp;rc, 8, 8, dx-8, dy-8); <br>                m_pPL-&gt;RectSet(&amp;rc, FALSE); <br> <br>                /* <br>                 * We consider sizing something that makes the file <br>                 * dirty, but not until we've finished the create <br>                 * process, which is why we set fNoDirty to FALSE <br>                 * in WM_CREATE since we get a WM_SIZE on the first <br>                 * creation. <br>                 */ <br>                if (!m_fNoDirty) <br>                    FDirtySet(TRUE); <br> <br>                SetRect(&amp;rc, 0, 0, dx, dy); <br> <br>                if (NULL!=m_pAdv) <br>                    m_pAdv-&gt;OnSizeChange(this, &amp;rc); <br> <br>                m_fNoDirty=FALSE; <br>                } <br>            } <br> <br>        m_uPrevSize=wParam; <br>        } <br> <br>    //CHAPTER13MOD <br>    if (WM_LBUTTONDOWN==iMsg) <br>        { <br>        LPDROPSOURCE    pIDropSource; <br>        LPDATAOBJECT    pIDataObject; <br>        HRESULT         hr; <br>        SCODE           sc; <br>        DWORD           dwEffect; <br> <br>        pIDropSource=new CDropSource(this); <br> <br>        if (NULL==pIDropSource) <br>            return FALSE; <br> <br>        pIDropSource-&gt;AddRef(); <br>        m_fDragSource=TRUE; <br> <br>        //Go get the data and start the ball rolling. <br>        pIDataObject=TransferObjectCreate(); <br> <br>        if (NULL!=pIDataObject) <br>            { <br>            hr=DoDragDrop(pIDataObject, pIDropSource <br>                , DROPEFFECT_COPY | DROPEFFECT_MOVE, &amp;dwEffect); <br> <br>            pIDataObject-&gt;Release(); <br>            sc=GetScode(hr); <br>            } <br>        else <br>            sc=E_FAIL; <br> <br>        pIDropSource-&gt;Release(); <br>        m_fDragSource=FALSE; <br> <br>        if (DRAGDROP_S_DROP==sc &amp;&amp; DROPEFFECT_MOVE==dwEffect) <br>            { <br>            m_pPL-&gt;New(); <br>            FDirtySet(TRUE); <br>            } <br> <br>        return TRUE; <br>        } <br>    //End CHAPTER13MOD <br> <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with <br> *  no filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Clear(void) <br>    { <br>    //Completely reset the polyline <br>    m_pPL-&gt;New(); <br> <br>    CDocument::Clear(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the Polyline window.  We do this by <br> *  opening the file and telling the Polyline to load itself from <br> *  that file. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load, NULL if the file <br> *                  is new and untitled. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    HRESULT             hr; <br>    LPSTORAGE           pIStorage; <br> <br>    if (NULL==pszFile) <br>        { <br>        /* <br>         * As a user of an IPersistStorage we have to provide all <br>         * objects with an IStorage they can use for incremental <br>         * access passing that storage to InitNew.  Here we create <br>         * a temporary file that we don't bother holding on to. <br>         * If the object doesn't use it, then our Release destroys <br>         * it immediately. <br>         */ <br> <br>        hr=StgCreateDocfile(NULL, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_DELETEONRELEASE <br>            | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        if (PERSIST_STORAGE==m_pp.psModel) <br>            m_pp.pIP.pIPersistStorage-&gt;InitNew(pIStorage); <br>        else <br>            { <br>            if (PERSIST_STREAMINIT==m_pp.psModel) <br>                m_pp.pIP.pIPersistStreamInit-&gt;InitNew(); <br>            } <br> <br>        m_pIStorage=pIStorage; <br> <br>        Rename(NULL); <br>        return DOCERR_NONE; <br>        } <br> <br>    /* <br>     * Open a storage and have the Polyline read its data <br>     * using whatever persistence model it employs. <br>     */ <br>    hr=StgOpenStorage(pszFile, NULL, STGM_DIRECT | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    if (PERSIST_STORAGE==m_pp.psModel) <br>        hr=m_pp.pIP.pIPersistStorage-&gt;Load(pIStorage); <br>    else <br>        { <br>        LPSTREAM    pIStream; <br> <br>        hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT <br>            | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //This also works for PERSIST_STREAMINIT <br>            hr=m_pp.pIP.pIPersistStream-&gt;Load(pIStream); <br>            pIStream-&gt;Release(); <br>            } <br>        } <br> <br>    m_pIStorage=pIStorage; <br> <br>    if (FAILED(hr)) <br>        return DOCERR_READFAILURE; <br> <br>    if (fChangeFile) <br>        Rename(pszFile); <br> <br>    //Importing a file makes things dirty <br>    FDirtySet(!fChangeFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Save <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user <br> *  has previously used FileOpen or FileSaveAs in order to have <br> *  a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Save(UINT uType, LPTSTR pszFile) <br>    { <br>    BOOL                fRename=TRUE; <br>    HRESULT             hr; <br>    LPSTORAGE           pIStorage; <br>    BOOL                fSameAsLoad; <br> <br>    //If Save or Save As under the same name, do Save. <br>    if (NULL==pszFile || 0==lstrcmpi(pszFile, m_szFile)) <br>        { <br>        fRename=FALSE; <br>        pszFile=m_szFile; <br> <br>        /* <br>         * If we're saving to an existing storage, just pass <br>         * the IStorage we have from Load along with TRUE <br>         * in fSameAsLoad. <br>         */ <br> <br>        fSameAsLoad=TRUE; <br>        } <br>    else <br>        { <br>        /* <br>         * In Component Cosmo, we only deal with one version of <br>         * data; all the code in Chapter 1 Cosmo that dealt with <br>         * 1.0 and 2.0 files has been removed. <br>         */ <br> <br>        hr=StgCreateDocfile(pszFile, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        //Tell the object to save into this new storage <br>        fSameAsLoad=FALSE; <br> <br>        //Update our variable <br>        m_pIStorage-&gt;Release(); <br>        m_pIStorage=pIStorage; <br>        } <br> <br>    if (PERSIST_STORAGE==m_pp.psModel) <br>        { <br>        hr=m_pp.pIP.pIPersistStorage-&gt;Save(m_pIStorage, fSameAsLoad); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            hr=m_pp.pIP.pIPersistStorage-&gt;SaveCompleted(fSameAsLoad <br>                ? NULL : m_pIStorage); <br>            } <br>        } <br>    else <br>        { <br>        LPSTREAM    pIStream; <br> <br>        hr=m_pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT <br>            | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE <br>            , 0, 0, &amp;pIStream); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //This also works for PERSIST_STREAMINIT <br>            hr=m_pp.pIP.pIPersistStream-&gt;Save(pIStream, TRUE); <br>            pIStream-&gt;Release(); <br>            } <br>        } <br> <br> <br>    if (FAILED(hr)) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Saving makes us clean <br>    FDirtySet(FALSE); <br> <br>    if (fRename) <br>        Rename(pszFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Undo <br> * <br> * Purpose: <br> *  Reverses a previous action. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Undo(void) <br>    { <br>    m_pPL-&gt;Undo(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Clip(HWND hWndFrame, BOOL fCut) <br>    { <br>    //CHAPTER13MOD <br>    BOOL            fRet=TRUE; <br>    LPDATAOBJECT    pIDataObject; <br> <br>    pIDataObject=TransferObjectCreate(); <br> <br>    if (NULL==pIDataObject) <br>        return FALSE; <br>    //CHAPTER13MOD <br> <br>    fRet=SUCCEEDED(OleSetClipboard(pIDataObject)); <br> <br>    if (NULL!=m_pIDataClip) <br>        m_pIDataClip-&gt;Release(); <br> <br>    m_pIDataClip=pIDataObject; <br> <br>    //Delete our current data if a "cut" succeeded. <br>    if (fRet &amp;&amp; fCut) <br>        { <br>        m_pPL-&gt;New(); <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPaste(void) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    //CHAPTER13MOD <br>    fRet=FQueryPasteFromData(pIDataObject); <br>    //End CHAPTER13MOD <br> <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br>//CHAPTER13MOD <br>/* <br> * CCosmoDoc::FQueryPasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste data from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject) <br>    { <br>    FORMATETC       fe; <br> <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    return (NOERROR==pIDataObject-&gt;QueryGetData(&amp;fe)); <br>    } <br>//End CHAPTER13MOD <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Paste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Paste(HWND hWndFrame) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    //CHAPTER13MOD <br>    fRet=PasteFromData(pIDataObject); <br>    //End CHAPTER13MOD <br> <br>    pIDataObject-&gt;Release(); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>//CHAPTER13MOD <br>/* <br> * CCosmoDoc::PasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Retrieves the private data format from a data object and sets <br> *  it to the current figure in the editor window. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::PasteFromData(LPDATAOBJECT pIDataObject) <br>    { <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br>    BOOL            fRet; <br> <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    fRet=SUCCEEDED(pIDataObject-&gt;GetData(&amp;fe, &amp;stm)); <br> <br>    if (!fRet || NULL==stm.hGlobal) <br>        return FALSE; <br> <br>    if (fRet &amp;&amp; NULL!=stm.hGlobal) <br>        { <br>        m_pPL-&gt;QueryInterface(IID_IDataObject <br>            , (PPVOID)&amp;pIDataObject); <br>        pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br>        pIDataObject-&gt;Release(); <br> <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::TransferObjectCreate <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a DataTransferObject and stuffs the current Polyline <br> *  data into it, used for both clipboard and drag-drop operations. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  LPDATAOBJECT    Pointer to the object created, NULL on failure <br> */ <br> <br>LPDATAOBJECT CCosmoDoc::TransferObjectCreate(void) <br>    { <br>    UINT            i; <br>    HRESULT         hr; <br>    STGMEDIUM       stm; <br>    FORMATETC       fe; <br>    LPDATAOBJECT    pIDataSrc; <br>    LPDATAOBJECT    pIDataObject=NULL; <br>    const UINT      cFormats=3; <br>    static UINT     rgcf[3]={0, CF_METAFILEPICT, CF_BITMAP}; <br>    static DWORD    rgtm[3]={TYMED_HGLOBAL, TYMED_MFPICT <br>                        , TYMED_GDI}; <br> <br>    hr=CoCreateInstance(CLSID_DataTransferObject, NULL <br>        , CLSCTX_INPROC_SERVER, IID_IDataObject <br>        , (PPVOID)&amp;pIDataObject); <br> <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    rgcf[0]=m_cf; <br> <br>    hr=m_pPL-&gt;QueryInterface(IID_IDataObject, (PPVOID)&amp;pIDataSrc); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIDataObject-&gt;Release(); <br>        return NULL; <br>        } <br> <br>    for (i=0; i &lt; cFormats; i++) <br>        { <br>        //Copy private data first. <br>        SETDefFormatEtc(fe, rgcf[i], rgtm[i]); <br> <br>        if (SUCCEEDED(pIDataSrc-&gt;GetData(&amp;fe, &amp;stm))) <br>            pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br>        } <br> <br>    pIDataSrc-&gt;Release(); <br>    return pIDataObject;    //Caller now responsible <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::DropSelectTargetWindow <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a thin inverted frame around a window that we use to <br> *  show the window as a drop target.  This is a toggle function: <br> *  it uses XOR to create the effect so it must be called twice <br> *  to leave the window as it was. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::DropSelectTargetWindow(void) <br>    { <br>    HDC         hDC; <br>    RECT        rc; <br>    UINT        dd=3; <br>    HWND        hWnd; <br> <br>    m_pPL-&gt;Window(&amp;hWnd); <br>    hDC=GetWindowDC(hWnd); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    //Frame this window with inverted pixels <br> <br>    //Top <br>    PatBlt(hDC, rc.left, rc.top, rc.right-rc.left, dd, DSTINVERT); <br> <br>    //Bottom <br>    PatBlt(hDC, rc.left, rc.bottom-dd, rc.right-rc.left, dd <br>        , DSTINVERT); <br> <br>    //Left excluding regions already affected by top and bottom <br>    PatBlt(hDC, rc.left, rc.top+dd, dd, rc.bottom-rc.top-(2*dd) <br>        , DSTINVERT); <br> <br>    //Right excluding regions already affected by top and bottom <br>    PatBlt(hDC, rc.right-dd, rc.top+dd, dd, rc.bottom-rc.top-(2*dd) <br>        , DSTINVERT); <br> <br>    ReleaseDC(hWnd, hDC); <br>    return; <br>    } <br> <br>//End CHAPTER13MOD <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorSet <br> * <br> * Purpose: <br> *  Changes a color used in our contained Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color. <br> * <br> * Return Value: <br> *  COLORREF        Previous color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorSet(UINT iColor, COLORREF cr) <br>    { <br>    COLORREF    crRet; <br> <br>    m_pPL-&gt;ColorSet(iColor, cr, &amp;crRet); <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorGet <br> * <br> * Purpose: <br> *  Retrieves a color currently in use in the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to retrieve. <br> * <br> * Return Value: <br> *  COLORREF        Current color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorGet(UINT iColor) <br>    { <br>    COLORREF    crRet; <br> <br>    m_pPL-&gt;ColorGet(iColor, &amp;crRet); <br>    return crRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT index of the new line style to use. <br> * <br> * Return Value: <br> *  UINT            Previous line style. <br> */ <br> <br>UINT CCosmoDoc::LineStyleSet(UINT iStyle) <br>    { <br>    UINT    i; <br> <br>    m_pPL-&gt;LineStyleSet(iStyle, &amp;i); <br>    return i; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Current line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleGet(void) <br>    { <br>    UINT    i=0; <br> <br>    //m_pPL might not be valid yet. <br>    if (NULL!=m_pPL) <br>        m_pPL-&gt;LineStyleGet(&amp;i); <br> <br>    return i; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
