<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGEWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context699"></a>PAGEWIN.CPP</h2>
<pre><code>/* <br> * PAGEWIN.CPP <br> * Patron Chapter 13 <br> * <br> * Window procedure for the Pages window and support functions. <br> * This window manages its own scrollbars and viewport and provides <br> * printing capabilities as well.  The public CPages::Print <br> * function lives here. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br> <br>#include "patron.h" <br> <br>static HWND g_hDlgPrint=NULL; <br>static BOOL g_fCancelPrint=FALSE; <br> <br> <br>/* <br> * PagesWndProc <br> * <br> * Purpose: <br> *  Window procedure for the Pages window. <br> */ <br> <br>LRESULT APIENTRY PagesWndProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCPages         ppg; <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    int             iPos, iTmp; <br>    int             iMin, iMax; <br>    UINT            idScroll; <br>    BOOL            fDirty=FALSE; <br> <br>    ppg=(PCPages)GetWindowLong(hWnd, PAGEWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            ppg=(PCPages)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, PAGEWL_STRUCTURE, (LONG)ppg); <br> <br>            ppg-&gt;m_hWnd=hWnd; <br>            break; <br> <br> <br>        case WM_PAINT: <br>            /* <br>             * If there is currently a drag-rectangle showing, then <br>             * remove it before painting.  This insures that <br>             * painting doesn't blast part of that rectangle away so <br>             * that when we draw it next, garbage is left around. <br>             */ <br>            if (ppg-&gt;m_fDragRectShown) <br>                ppg-&gt;DrawDropTargetRect(NULL, NULL); <br> <br>            hDC=BeginPaint(hWnd, &amp;ps); <br> <br>            //Draw only if we have a page to show. <br>            if (0!=ppg-&gt;m_cPages) <br>                ppg-&gt;Draw(hDC, FALSE, FALSE); <br> <br>            EndPaint(hWnd, &amp;ps); <br> <br>            //Turn the rectangle back on, if necessary. <br>            if (ppg-&gt;m_fDragRectShown) <br>                ppg-&gt;DrawDropTargetRect(NULL, NULL); <br>            break; <br> <br> <br>        case WM_HSCROLL: <br>        case WM_VSCROLL: <br>            idScroll=(WM_HSCROLL==iMsg) ? SB_HORZ : SB_VERT; <br> <br>            iPos=GetScrollPos(hWnd, idScroll); <br>            iTmp=iPos; <br>            GetScrollRange(hWnd, idScroll, &amp;iMin, &amp;iMax); <br> <br>            switch (LOWORD(wParam)) <br>                { <br>                case SB_LINEUP:     iPos -= 20;  break; <br>                case SB_PAGEUP:     iPos -=100;  break; <br>                case SB_LINEDOWN:   iPos += 20;  break; <br>                case SB_PAGEDOWN:   iPos +=100;  break; <br> <br>                case SB_THUMBPOSITION: <br>                    iPos=ScrollThumbPosition(wParam, lParam); <br>                    break; <br> <br>                //We don't want scrolling on this message. <br>                case SB_THUMBTRACK: <br>                    return 0L; <br>                } <br> <br>            iPos=max(iMin, min(iPos, iMax)); <br> <br>            if (iPos!=iTmp) <br>                { <br>                //Set the new position and scroll the window <br>                SetScrollPos(hWnd, idScroll, iPos, TRUE); <br> <br>                if (SB_HORZ==idScroll) <br>                    { <br>                    ppg-&gt;m_xPos=iPos; <br>                    ScrollWindow(hWnd, iTmp-iPos, 0, NULL, NULL); <br>                    } <br>                else <br>                    { <br>                    ppg-&gt;m_yPos=iPos; <br>                    ScrollWindow(hWnd, 0, iTmp-iPos, NULL, NULL); <br>                    } <br>                } <br> <br>            break; <br> <br>        case WM_RBUTTONDOWN: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            fDirty=ppg-&gt;m_pPageCur-&gt;OnRightDown(wParam <br>                , LOWORD(lParam), HIWORD(lParam)); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            fDirty=ppg-&gt;m_pPageCur-&gt;OnLeftDown(wParam <br>                , LOWORD(lParam), HIWORD(lParam)); <br>            break; <br> <br>        case WM_LBUTTONUP: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            fDirty=ppg-&gt;m_pPageCur-&gt;OnLeftUp(wParam <br>                , LOWORD(lParam), HIWORD(lParam)); <br>            break; <br> <br>        case WM_LBUTTONDBLCLK: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            fDirty=ppg-&gt;m_pPageCur-&gt;OnLeftDoubleClick(wParam, LOWORD(lParam) <br>                , HIWORD(lParam)); <br>            break; <br> <br>        case WM_MOUSEMOVE: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            ppg-&gt;m_pPageCur-&gt;OnMouseMove(wParam, LOWORD(lParam) <br>                , HIWORD(lParam)); <br>            break; <br> <br>        case WM_TIMER: <br>            if (NULL==ppg-&gt;m_pPageCur) <br>                break; <br> <br>            ppg-&gt;m_pPageCur-&gt;OnTimer(wParam); <br>            break; <br> <br>        case WM_NCHITTEST: <br>            if (NULL!=ppg-&gt;m_pPageCur) <br>                { <br>                /* <br>                 * This just saves information in the page for <br>                 * OnSetCursor <br>                 */ <br>                ppg-&gt;m_pPageCur-&gt;OnNCHitTest(LOWORD(lParam) <br>                    , HIWORD(lParam)); <br>                } <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_SETCURSOR: <br>            if (NULL!=ppg-&gt;m_pPageCur) <br>                { <br>                if (ppg-&gt;m_pPageCur-&gt;OnSetCursor(LOWORD(lParam))) <br>                    break; <br>                } <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    ppg-&gt;m_fDirty |= fDirty; <br>    return 0L; <br>    } <br> <br> <br> <br>/* <br> * RectConvertMappings <br> * <br> * Purpose: <br> *  Converts the contents of a rectangle from device to logical <br> *  coordinates where the hDC defines the logical coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the rectangle to convert. <br> *  hDC             HDC describing the logical coordinate system. <br> *                  if NULL, uses a screen DC in MM_LOMETRIC. <br> *  fToDevice       BOOL TRUE to convert from uConv to device, <br> *                  FALSE to convert device to uConv. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void RectConvertMappings(LPRECT pRect, HDC hDC, BOOL fToDevice) <br>    { <br>    POINT   rgpt[2]; <br>    BOOL    fSysDC=FALSE; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    rgpt[0].x=pRect-&gt;left; <br>    rgpt[0].y=pRect-&gt;top; <br>    rgpt[1].x=pRect-&gt;right; <br>    rgpt[1].y=pRect-&gt;bottom; <br> <br>    if (NULL==hDC) <br>        { <br>        hDC=GetDC(NULL); <br>        SetMapMode(hDC, MM_LOMETRIC); <br>        fSysDC=TRUE; <br>        } <br> <br>    if (fToDevice) <br>        LPtoDP(hDC, rgpt, 2); <br>    else <br>        DPtoLP(hDC, rgpt, 2); <br> <br>    if (fSysDC) <br>        ReleaseDC(NULL, hDC); <br> <br>    pRect-&gt;left=rgpt[0].x; <br>    pRect-&gt;top=rgpt[0].y; <br>    pRect-&gt;right=rgpt[1].x; <br>    pRect-&gt;bottom=rgpt[1].y; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::Draw <br> * <br> * Purpose: <br> *  Paints the current page in the pages window. <br> * <br> * Parameters: <br> *  hDC             HDC to draw on, could be a metafile or printer <br> *                  DC or any other type of DC. <br> *  fNoColor        BOOL indicating if we should use screen colors <br> *                  or printer colors (B&amp;W).  Objects are printed <br> *                  as-is, however.  This is TRUE for printer DCs <br> *                  or print preview. <br> *  fPrinter        BOOL indicating if this is a printer DC in which <br> *                  case we eliminate some of the fancy drawing, <br> *                  like shadows on the page and so forth. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::Draw(HDC hDC, BOOL fNoColor, BOOL fPrinter) <br>    { <br>    RECT            rc, rcT; <br>    UINT            uMM; <br>    HPEN            hPen; <br>    HBRUSH          hBrush; <br>    HGDIOBJ         hObj1, hObj2; <br>    COLORREF        cr; <br>    TCHAR           szTemp[20]; <br>    UINT            cch; <br>    SIZE            sz; <br>    PCPage          pPage; <br>    RECT            rcPos; <br> <br>    //Make sure the DC is in LOMETRIC <br>    uMM=SetMapMode(hDC, MM_LOMETRIC); <br> <br>    if (!fPrinter) <br>        { <br>        /* <br>         * We maintain a 6mm border around the page on the screen <br>         * besides 12.7mm margins.  We also have to account for <br>         * the scroll position with m_*Pos which are in pixels so <br>         * we have to convert them. <br>         */ <br> <br>        SetRect(&amp;rcPos, m_xPos, m_yPos, 0, 0); <br>        RectConvertMappings(&amp;rcPos, hDC, FALSE); <br> <br>        rc.left  = LOMETRIC_BORDER-rcPos.left; <br>        rc.top   =-LOMETRIC_BORDER-rcPos.top; <br>        } <br>    else <br>        { <br>        /* <br>         * We define the corner of the printed paper at a negative <br>         * offset so rc.right and rc.bottom come out right below. <br>         */ <br>        SetRect(&amp;rc, -(int)m_xMarginLeft, m_yMarginTop, 0, 0); <br>        } <br> <br>    rc.right=rc.left+m_cx+(m_xMarginLeft+m_xMarginRight); <br>    rc.bottom=rc.top-m_cy-(m_yMarginTop+m_yMarginBottom); <br> <br>    //Draw a rect filled with the window color to show the page. <br>    if (!fPrinter) <br>        { <br>        if (fNoColor) <br>            { <br>            //Black frame, white box for printed colors. <br>            hPen  =CreatePen(PS_SOLID, 0, RGB(0,0,0)); <br>            hBrush=CreateSolidBrush(RGB(255, 255, 255)); <br>            } <br>        else <br>            { <br>            //Normal colors on display <br>            hPen=CreatePen(PS_SOLID, 0 <br>                , GetSysColor(COLOR_WINDOWFRAME)); <br>            hBrush=CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>            } <br> <br>        hObj1=SelectObject(hDC, hPen); <br>        hObj2=SelectObject(hDC, hBrush); <br> <br>        //Paper boundary <br>        Rectangle(hDC, rc.left, rc.top, rc.right, rc.bottom+1); <br> <br>        /* <br>         * Draw a shadow on the *visual* bottom and right edges <br>         * .5mm wide.  If the button shadow color and workspace <br>         * colors match, then use black.  We always use black <br>         * when printing as well. <br>         */ <br>        if (fNoColor) <br>            cr=RGB(0,0,0); <br>        else <br>            { <br>            cr=GetSysColor(COLOR_BTNSHADOW); <br> <br>            if (GetSysColor(COLOR_APPWORKSPACE)==cr) <br>                cr=RGB(0,0,0); <br>            } <br> <br>        cr=SetBkColor(hDC, cr); <br>        SetRect(&amp;rcT, rc.left+5, rc.bottom, rc.right+5,rc.bottom-5); <br>        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rcT, NULL, 0, NULL); <br> <br>        SetRect(&amp;rcT, rc.right, rc.top-5, rc.right+5, rc.bottom-5); <br>        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rcT, NULL, 0, NULL); <br>        SetBkColor(hDC, cr); <br> <br>        SelectObject(hDC, hObj1); <br>        SelectObject(hDC, hObj2); <br>        DeleteObject(hBrush); <br>        DeleteObject(hPen); <br>        } <br> <br>    //Write the page number in the lower left corner <br>    if (!fNoColor) <br>        { <br>        SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>        SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>        } <br> <br>    //Write the page number in our page font. <br>    cch=wsprintf(szTemp, TEXT("Page %d"), m_iPageCur+1); <br> <br>    hObj1=SelectObject(hDC, m_hFont); <br>    GetTextExtentPoint(hDC, szTemp, cch, &amp;sz); <br> <br>    TextOut(hDC, rc.left+m_xMarginLeft <br>        , rc.bottom+m_yMarginBottom+sz.cy, szTemp, cch); <br> <br>    SelectObject(hDC, hObj1); <br> <br>    //Rectangle to show border. <br>    MoveToEx(hDC, rc.left+m_xMarginLeft, rc.top-m_yMarginTop, NULL); <br>    LineTo(hDC, rc.left+m_xMarginLeft,   rc.bottom+m_yMarginBottom); <br>    LineTo(hDC, rc.right-m_xMarginRight, rc.bottom+m_yMarginBottom); <br>    LineTo(hDC, rc.right-m_xMarginRight, rc.top-m_yMarginTop); <br>    LineTo(hDC, rc.left+m_xMarginLeft,   rc.top-m_yMarginTop); <br> <br>    /* <br>     * Go draw the objects on this page.  If the page is not open, <br>     * we open it anyway.  If it is already open, then opening again <br>     * will bump it's reference count, so the Close in ineffectual. <br>     */ <br>    if (FPageGet(m_iPageCur, &amp;pPage, TRUE)) <br>        { <br>        if (!fPrinter) <br>            { <br>            pPage-&gt;Draw(hDC, rcPos.left, rcPos.top, fNoColor <br>                , fPrinter); <br>            } <br>        else <br>            pPage-&gt;Draw(hDC, 0, 0, fNoColor, fPrinter); <br> <br>        pPage-&gt;Close(FALSE); <br>        } <br> <br>    SetMapMode(hDC, uMM); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::UpdateScrollRanges <br> * <br> * Purpose: <br> *  Reset scrollbar ranges (horizontal and vertical) depending on <br> *  the window size and the page size.  This function may remove <br> *  the scrollbars altogether. <br> * <br> * Parameters: <br> *  None, but set m_cx, m_cy and size m_hWnd before calling. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::UpdateScrollRanges(void) <br>    { <br>    UINT        cxSB;   //Scrollbar width and height. <br>    UINT        cySB; <br>    UINT        cx, cy; <br>    UINT        dx, dy; <br>    UINT        u; <br>    int         iMin, iMax; <br>    RECT        rc; <br>    BOOL        fHScroll; <br>    BOOL        fVScroll; <br>    BOOL        fWasThere; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    cx=rc.right-rc.left; <br>    cy=rc.bottom-rc.top; <br> <br>    //Convert dimensions of the image in LOMETRIC to pixels. <br>    SetRect(&amp;rc, (m_cx+m_xMarginLeft+m_xMarginRight <br>        +LOMETRIC_BORDER*2), (m_cy+m_yMarginTop <br>        +m_yMarginBottom+LOMETRIC_BORDER*2), 0, 0); <br> <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br> <br>    dx=rc.left; <br>    dy=-rc.top; <br> <br>    //Assume that both scrollbars will be visible. <br>    fHScroll=TRUE; <br>    fVScroll=TRUE; <br> <br>    /* <br>     * Determine: <br>     *  1)  Which scrollbars are needed. <br>     *  2)  How many divisions to give scrollbars so as to <br>     *      only scroll as little as necessary. <br>     */ <br> <br>    //Scrollbar dimensions in our units. <br>    cxSB=GetSystemMetrics(SM_CXVSCROLL); <br>    cySB=GetSystemMetrics(SM_CYHSCROLL); <br> <br>    //Remove horizontal scroll if window &gt;= cxPage+borders <br>    if (cx &gt;= dx) <br>        fHScroll=FALSE; <br> <br> <br>    /* <br>     * If we still need a horizontal scroll, see if we need a <br>     * vertical taking the height of the horizontal scroll into <br>     * account. <br>     */ <br> <br>    u=fHScroll ? cySB : 0; <br> <br>    if ((cy-u) &gt;= dy) <br>        fVScroll=FALSE; <br> <br>    //Check if adding vert scrollbar necessitates a horz now. <br>    u=fVScroll ? cxSB : 0; <br>    fHScroll=((cx-u) &lt; dx); <br> <br>    /* <br>     * Modify cx,cy to reflect the new client area before scaling <br>     * scrollbars.  We only affect the client size if there is a <br>     * *change* in scrollbar status:  if the scrollbar was there <br>     * but is no longer, then add to the client size; if it was <br>     * not there but now is, then subtract. <br>     */ <br> <br>    //Change cx depending on vertical scrollbar change <br>    GetScrollRange(m_hWnd, SB_VERT, &amp;iMin, &amp;iMax); <br>    fWasThere=(0!=iMin || 0!=iMax); <br> <br>    if (fWasThere &amp;&amp; !fVScroll) <br>        cx+=cxSB; <br> <br>    if (!fWasThere &amp;&amp; fVScroll) <br>        cx-=cxSB; <br> <br>    //Change cy depending on horizontal scrollbar change <br>    GetScrollRange(m_hWnd, SB_HORZ, &amp;iMin, &amp;iMax); <br>    fWasThere=(0!=iMin || 0!=iMax); <br> <br>    if (fWasThere &amp;&amp; !fHScroll) <br>        cy+=cySB; <br> <br>    if (!fWasThere &amp;&amp; fHScroll) <br>        cy-=cySB; <br> <br> <br>    /* <br>     * Show/Hide the scrollbars if necessary and set the ranges. <br>     * The range is the number of units of the page we cannot see. <br>     */ <br>    if (fHScroll) <br>        { <br>        //Convert current scroll position to new range. <br>        u=GetScrollPos(m_hWnd, SB_HORZ); <br> <br>        if (0!=u) <br>            { <br>            GetScrollRange(m_hWnd, SB_HORZ, &amp;iMin, &amp;iMax); <br>            u=MulDiv(u, (dx-cx), (iMax-iMin)); <br>            } <br> <br>        SetScrollRange(m_hWnd, SB_HORZ, 0, dx-cx, FALSE); <br>        SetScrollPos(m_hWnd, SB_HORZ, u, TRUE); <br>        m_xPos=u; <br>        } <br>    else <br>        { <br>        SetScrollRange(m_hWnd, SB_HORZ, 0, 0, TRUE); <br>        m_xPos=0; <br>        } <br> <br>    if (fVScroll) <br>        { <br>        //Convert current scroll position to new range. <br>        u=GetScrollPos(m_hWnd, SB_VERT); <br> <br>        if (0!=u) <br>            { <br>            GetScrollRange(m_hWnd, SB_VERT, &amp;iMin, &amp;iMax); <br>            u=MulDiv(u, (dy-cy), (iMax-iMin)); <br>            } <br> <br>        SetScrollRange(m_hWnd, SB_VERT, 0, dy-cy, FALSE); <br>        SetScrollPos(m_hWnd, SB_VERT, u, TRUE); <br> <br>        m_yPos=u; <br>        } <br>    else <br>        { <br>        SetScrollRange(m_hWnd, SB_VERT, 0, 0, TRUE); <br>        m_yPos=0; <br>        } <br> <br>    //Repaint to insure that changes to m_x/yPos are reflected <br>    InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::Print <br> * <br> * Purpose: <br> *  Prints a specified range of pages to a given hDC.  Repeats for <br> *  a given number of copies. <br> * <br> * Parameters: <br> *  hDC             HDC to which we print. <br> *  pszDoc          LPTSTR providing the document name. <br> *  dwFlags         DWORD flags from PrintDlg <br> *  iPageStart      UINT starting page index (one based) <br> *  iPageEnd        UINT ending page index (one based).  Includes <br> *                  this page. <br> *  cCopies         UINT number of copies to print.  If PD_COLLATE <br> *                  in dwFlags is set, we print multiple copies of <br> *                  each page as we cycle through.  Otherwise we <br> *                  cycle multiple times. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::Print(HDC hDC, LPTSTR pszDoc, DWORD dwFlags <br>    , UINT iPageStart, UINT iPageEnd, UINT cCopies) <br>    { <br>    BOOL        fError=FALSE; <br>    int         iPage, iPageInc; <br>    int         iUserPage, cPages; <br>    UINT        iRepeat, cRepeat; <br>    UINT        iCycle, cCycles; <br>    UINT        iPageHold=m_iPageCur; <br>    HWND        hWndT, hWndTop=NULL; <br>    DOCINFO     di; <br>    PCDocument  pDoc; <br> <br>    //Validate hDC and page ranges <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    if ((PD_PAGENUMS &amp; dwFlags)) <br>        { <br>        if (-1==iPageStart) <br>            iPageStart=0; <br>        else <br>            iPageStart--;   //Switch to zero offset. <br> <br>        if (-1==iPageEnd) <br>            iPageEnd=m_cPages-1; <br>        else <br>            iPageEnd--;     //Switch to zero offset. <br>        } <br>    else //Can't test PD_ALLPAGES with &amp; since it's defined as 0L <br>        { <br>        iPageStart=0; <br>        iPageEnd=m_cPages-1; <br>        } <br> <br>    //Arrange cycles and repeats depending on cCopies and collating <br>    if (PD_COLLATE &amp; dwFlags) <br>        { <br>        cCycles=cCopies; <br>        cRepeat=1; <br>        } <br>    else <br>        { <br>        cCycles=1; <br>        cRepeat=cCopies; <br>        } <br> <br>    //Disable the frame window to prevent reentrancy while printing. <br>    hWndT=GetParent(m_hWnd); <br>    pDoc=(PCDocument)SendMessage(hWndT, DOCM_PDOCUMENT, 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        { <br>        PCFrame pFR; <br> <br>        pFR=pDoc-&gt;FrameGet(); <br>        hWndTop=pFR-&gt;Window(); <br>        EnableWindow(hWndTop, FALSE); <br>        } <br> <br>    SetAbortProc(hDC, AbortProc); <br>    g_fCancelPrint=FALSE; <br> <br>    //If these don't work then we'll just live without a dialog. <br>    g_hDlgPrint=CreateDialog(m_hInst, MAKEINTRESOURCE(IDD_PRINTING) <br>        , hWndTop, PrintDlgProc); <br> <br>    //Increment for either direction. <br>    iPageInc=(iPageStart &gt; iPageEnd) ? -1 : 1; <br> <br>    //Initial entries in dialog box. <br>    cPages=1+((int)(iPageEnd-iPageStart)*iPageInc); <br> <br>    SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE, 1, (LPARAM)cPages); <br>    SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, 1, (LPARAM)cRepeat); <br> <br>    di.cbSize=sizeof(DOCINFO); <br>    di.lpszDocName=pszDoc; <br>    di.lpszOutput=NULL; <br> <br>    if (StartDoc(hDC, &amp;di) &gt; 0) <br>        { <br>        /* <br>         * Iterate over the pages, repeating each page depending on <br>         * the copies we want and if we have collate enabled. <br>         */ <br> <br>        for (iCycle=1; iCycle &lt;= cCycles; iCycle++) <br>            { <br>            if (PD_COLLATE &amp; dwFlags) <br>                { <br>                SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, iCycle <br>                    , (LPARAM)cCycles); <br>                } <br> <br>            //iPageInc controls direction <br>            for (iPage=iPageStart; ; iPage+=iPageInc) <br>                { <br>                iUserPage=1+((iPage-(int)iPageStart)*iPageInc); <br> <br>                SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE <br>                    , iUserPage, (LPARAM)cPages); <br> <br>                m_iPageCur=iPage;   //We restore this later. <br> <br>                for (iRepeat=1; iRepeat &lt;= cRepeat; iRepeat++) <br>                    { <br>                    if (!(PD_COLLATE &amp; dwFlags)) <br>                        { <br>                        SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE <br>                            , iRepeat, (LPARAM)cRepeat); <br>                        } <br> <br>                    StartPage(hDC); <br>                    Draw(hDC, TRUE, TRUE); <br> <br>                    if (EndPage(hDC) &lt; 0) <br>                        fError=TRUE; <br> <br>                    if (fError || g_fCancelPrint) <br>                        break; <br>                    } <br> <br>                if (fError || g_fCancelPrint) <br>                    break; <br> <br>                //If we just printed the last page, time to quit. <br>                if (iPage==(int)iPageEnd) <br>                    break; <br>                } <br> <br>            if (fError || g_fCancelPrint) <br>                break; <br>            } <br> <br>        if (!fError) <br>            EndDoc(hDC); <br>        else <br>            AbortDoc(hDC); <br>        } <br>    else <br>        fError=TRUE; <br> <br>    //Set the page back to what it was before all this started. <br>    m_iPageCur=iPageHold; <br> <br>    EnableWindow(hWndTop, TRUE); <br>    SetFocus(hWndTop); <br>    DestroyWindow(g_hDlgPrint); <br>    DeleteDC(hDC); <br>    return !fError; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * AbortProc <br> * <br> * Purpose: <br> *  Abort procedure for printing the pages. <br> * <br> * Parameters: <br> *  hDC             HDC on which printing is happening. <br> *  iErr            int error code. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the print job, FALSE otherwise. <br> */ <br> <br>BOOL APIENTRY AbortProc(HDC hDC, int iErr) <br>    { <br>    MSG     msg; <br> <br>    while (!g_fCancelPrint <br>        &amp;&amp; PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>        if (NULL==g_hDlgPrint <br>            || !IsDialogMessage(g_hDlgPrint, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    return !g_fCancelPrint; <br>    } <br> <br> <br> <br> <br>/* <br> * PrintDlgProc <br> * <br> * Purpose: <br> *  Modeless dialog procedure for the dialog displayed while Patron <br> *  is printing pages. <br> */ <br> <br>BOOL APIENTRY PrintDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    TCHAR           szFormat[40]; <br>    TCHAR           szOutput[80]; <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE <br>                , MF_GRAYED); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            //Cancel button was pressed. <br>            g_fCancelPrint=TRUE; <br>            ShowWindow(hDlg, SW_HIDE); <br>            return TRUE; <br> <br>        case PRINTM_PAGEUPDATE: <br>            GetDlgItemText(hDlg, ID_PAGESTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTPAGE, szOutput); <br>            return TRUE; <br> <br>        case PRINTM_COPYUPDATE: <br>            GetDlgItemText(hDlg, ID_COPYSTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTCOPY, szOutput); <br>            return TRUE; <br>        } <br> <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
