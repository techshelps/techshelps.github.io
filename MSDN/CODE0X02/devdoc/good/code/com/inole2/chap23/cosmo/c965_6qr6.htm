<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIGURE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context972"></a>FIGURE.CPP</h2>
<pre><code>/* <br> * FIGURE.CPP <br> * Cosmo Chapter 23 <br> * <br> * Implementation of the CFigure object for Cosmo. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CFigure::CFigure <br> * CFigure::~CFigure <br> * <br> * Parameters (Constructor): <br> *  pfnDestroy      PFNDESTROYED to call when object is destroyed. <br> *  pDoc            PCCosmoDoc we're associated with. <br> */ <br> <br>CFigure::CFigure(PFNDESTROYED pfnDestroy, PCCosmoDoc pDoc) <br>    { <br>    m_cRef=0; <br>    m_pfnDestroy=pfnDestroy; <br> <br>    m_pFR=NULL;     //We get this later through FrameSet. <br>    m_pDoc=pDoc; <br>    m_pPL=pDoc-&gt;m_pPL; <br> <br>    m_fEmbedded=FALSE; <br> <br>    //NULL any contained interfaces initially. <br>    m_pImpIPersistStorage=NULL; <br>    m_pIStorage=NULL; <br>    m_pIStream=NULL; <br>    m_pImpIDataObject=NULL; <br>    m_pIDataAdviseHolder=NULL; <br>    m_pImpIOleObject=NULL; <br>    m_pIOleAdviseHolder=NULL; <br>    m_pIOleClientSite=NULL; <br> <br>    m_clsID=CLSID_CosmoFigure; <br>    m_cf=pDoc-&gt;m_cf; <br> <br>    //These are for IDataObject::QueryGetData <br>    m_cfeGet=CFORMATETCGET; <br> <br>    SETDefFormatEtc(m_rgfeGet[0], pDoc-&gt;m_cf, TYMED_HGLOBAL); <br>    SETDefFormatEtc(m_rgfeGet[1], pDoc-&gt;m_cfEmbedSource <br>        , TYMED_ISTORAGE); <br>    SETDefFormatEtc(m_rgfeGet[2], pDoc-&gt;m_cfObjectDescriptor <br>        , TYMED_HGLOBAL); <br>    SETDefFormatEtc(m_rgfeGet[3], CF_METAFILEPICT, TYMED_MFPICT); <br>    SETDefFormatEtc(m_rgfeGet[4], CF_BITMAP, TYMED_GDI); <br> <br>    m_pST=NULL; <br> <br>    m_pImpIPersistFile=NULL; <br> <br>    //We live in the document's lifetime, so no need to AddRef here. <br>    m_pMoniker=m_pDoc-&gt;m_pMoniker; <br>    m_dwRegROT=0L; <br> <br>    //CHAPTER23MOD <br>    m_pIOleIPSite=NULL; <br>    m_pIOleIPFrame=NULL; <br>    m_pIOleIPUIWindow=NULL; <br>    m_pImpIOleIPObject=NULL; <br>    m_pImpIOleIPActiveObject=NULL; <br>    m_hMenuShared=NULL; <br>    m_hOLEMenu=NULL; <br>    m_hAccel=NULL; <br>    m_pHW=NULL; <br>    m_pTB=NULL; <br>    m_cyBar=0; <br>    m_fUndoDeactivates=FALSE; <br>    m_fAllowInPlace=TRUE; <br>    m_fForceSave=FALSE; <br>    //End CHAPTER23MOD <br> <br>    return; <br>    } <br> <br> <br>CFigure::~CFigure(void) <br>    { <br>    ReleaseInterface(m_pIOleClientSite); <br>    ReleaseInterface(m_pIDataAdviseHolder); <br>    ReleaseInterface(m_pIOleAdviseHolder); <br> <br>    //CHAPTER23MOD <br>    if (NULL!=m_pHW) <br>        delete m_pHW; <br> <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    /* <br>     * Free contained interfaces. <br>     * Container in-place interfaces released during deactivation. <br>     */ <br> <br>    if (NULL!=m_pTB)    //Safety-net <br>        delete m_pTB; <br> <br>    DeleteInterfaceImp(m_pImpIOleIPObject); <br>    DeleteInterfaceImp(m_pImpIOleIPActiveObject); <br>    //End CHAPTER23MOD <br> <br>    //Make sure no one thinks we're still running <br>    if (0L!=m_dwRegROT) <br>        INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br> <br>    ReleaseInterface(m_pIStorage) <br>    ReleaseInterface(m_pIStream) <br> <br>    DeleteInterfaceImp(m_pImpIPersistFile); <br>    DeleteInterfaceImp(m_pImpIOleObject) <br>    DeleteInterfaceImp(m_pImpIDataObject) <br>    DeleteInterfaceImp(m_pImpIPersistStorage); <br> <br>    //Free strings. <br>    if (NULL!=m_pST) <br>        delete m_pST; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFigure::QueryInterface <br> * CFigure::AddRef <br> * CFigure::Release <br> * <br> * Purpose: <br> *  IUnknown members for CFigure object. <br> */ <br> <br>STDMETHODIMP CFigure::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IPersist==riid || IID_IPersistStorage==riid) <br>        *ppv=m_pImpIPersistStorage; <br> <br>    if (IID_IDataObject==riid) <br>        *ppv=m_pImpIDataObject; <br> <br>    if (IID_IOleObject==riid) <br>        *ppv=m_pImpIOleObject; <br> <br>    if (IID_IPersistFile==riid) <br>        *ppv=m_pImpIPersistFile; <br> <br>    //CHAPTER23MOD <br>    if (IID_IOleWindow==riid || IID_IOleInPlaceObject==riid) <br>        *ppv=m_pImpIOleIPObject; <br>    //End CHAPTER23MOD <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CFigure::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CFigure::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    //Document deletes us <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFigure::Init <br> * <br> * Purpose: <br> *  Performs any initialization of a CFigure that's prone to failure <br> *  that we also use internally before exposing the object outside. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CFigure::Init(void) <br>    { <br>    m_pST=new CStringTable(m_pDoc-&gt;m_hInst); <br> <br>    if (NULL==m_pST) <br>        return FALSE; <br> <br>    if (!m_pST-&gt;Init(IDS_FIGUREMIN, IDS_FIGUREMAX)) <br>        return FALSE; <br> <br>    //Allocate contained interfaces. <br>    m_pImpIPersistStorage=new CImpIPersistStorage(this, this); <br> <br>    if (NULL==m_pImpIPersistStorage) <br>        return FALSE; <br> <br>    m_pImpIDataObject=new CImpIDataObject(this, this); <br> <br>    if (NULL==m_pImpIDataObject) <br>        return FALSE; <br> <br>    m_pImpIOleObject=new CImpIOleObject(this, this); <br> <br>    if (NULL==m_pImpIOleObject) <br>        return FALSE; <br> <br>    m_pImpIPersistFile=new CImpIPersistFile(this, this); <br> <br>    if (NULL==m_pImpIPersistFile) <br>        return FALSE; <br> <br>    //CHAPTER23MOD <br>    m_pImpIOleIPObject=new CImpIOleInPlaceObject(this, this); <br> <br>    if (NULL==m_pImpIOleIPObject) <br>        return FALSE; <br> <br>    m_pImpIOleIPActiveObject=new CImpIOleInPlaceActiveObject(this <br>        , this); <br> <br>    if (NULL==m_pImpIOleIPActiveObject) <br>        return FALSE; <br> <br>    m_pHW=new CHatchWin(m_pDoc-&gt;m_hInst); <br> <br>    if (NULL==m_pHW) <br>        return FALSE; <br> <br>    //We don't have m_pFR yet from which to get the frame window. <br>    if (!m_pHW-&gt;Init(m_pDoc-&gt;Window(), ID_HATCHWINDOW, NULL)) <br>        return FALSE; <br>    //End CHAPTER23MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CFigure::FrameSet <br> * <br> * Purpose: <br> *  Provides the compound document object with access to the frame <br> *  of this application for UI purposes. <br> * <br> * Parameters: <br> *  pFR             PCCosmoFrame of the frame window. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::FrameSet(PCCosmoFrame pFR) <br>    { <br>    m_pFR=pFR; <br> <br>    //CHAPTER23MOD <br>    //We need this in IOleInPlaceActiveObject::ResizeBorder <br>    m_cyBar=m_pFR-&gt;m_cyBar; <br> <br>    //We need this in IOleInPlaceActiveObject::TranslateAccelerator <br>    m_hAccel=m_pFR-&gt;m_hAccel; <br>    //End CHAPTER23MOD <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::FIsDirty <br> * <br> * Purpose: <br> *  Checks if the document is dirty.  This can be called from <br> *  IPersistStorage::IsDirty which doesn't have access to CCosmoDoc. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if dirty, FALSE if clean. <br> */ <br> <br>BOOL CFigure::FIsDirty(void) <br>    { <br>    //CHAPTER23MOD <br>    //Force a save if we opened after being in-place. <br>    return m_pDoc-&gt;m_fDirty || m_fForceSave; <br>    //End CHAPTER23MOD <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::FIsEmbedded <br> * <br> * Purpose: <br> *  Answers if the object is embedded or not. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the object is embedded, FALSE otherwise. <br> */ <br> <br>BOOL CFigure::FIsEmbedded(void) <br>    { <br>    return m_fEmbedded; <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::SendAdvise <br> * <br> * Purpose: <br> *  Calls the appropriate IOleClientSite or IAdviseSink member <br> *  function for various events such as closure, saving, etc. <br> * <br> * Parameters: <br> *  uCode           UINT OBJECTCODE_* identifying the notification. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::SendAdvise(UINT uCode) <br>    { <br>    switch (uCode) <br>        { <br>        case OBJECTCODE_SAVED: <br>            if (NULL!=m_pIOleAdviseHolder) <br>                m_pIOleAdviseHolder-&gt;SendOnSave(); <br> <br>break; <br> <br>        case OBJECTCODE_CLOSED: <br>            if (NULL!=m_pIOleAdviseHolder) <br>                m_pIOleAdviseHolder-&gt;SendOnClose(); <br> <br>break; <br> <br>        case OBJECTCODE_RENAMED: <br>            m_pMoniker=m_pDoc-&gt;m_pMoniker;  //For IOleObject::GetMoniker <br>            m_dwRegROT=m_pDoc-&gt;m_dwRegROT; <br> <br>            if (NULL!=m_pIOleAdviseHolder) <br>                m_pIOleAdviseHolder-&gt;SendOnRename(m_pMoniker); <br> <br>            break; <br> <br>        case OBJECTCODE_SAVEOBJECT: <br>            if (FIsDirty() &amp;&amp; NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;SaveObject(); <br> <br>            break; <br> <br>        case OBJECTCODE_DATACHANGED: <br>            //No flags are necessary here. <br>            if (NULL!=m_pIDataAdviseHolder) <br>                { <br>                m_pIDataAdviseHolder-&gt;SendOnDataChange <br>                    (m_pImpIDataObject, 0, 0); <br>                } <br> <br>            //Tell the running object table of the change <br>            if (0!=m_dwRegROT) <br>                INOLE_NoteChangeTime(m_dwRegROT, NULL, NULL); <br> <br>            //CHAPTER23MOD <br>            /* <br>             * If this is the first change after activation, tell the <br>             * container to free any undo information it's holding. <br>             */ <br>            if (NULL!=m_pIOleIPSite &amp;&amp; m_fUndoDeactivates) <br>                m_pIOleIPSite-&gt;DiscardUndoState(); <br> <br>            m_fUndoDeactivates=FALSE; <br>            //End CHAPTER23MOD <br> <br>            break; <br> <br>        case OBJECTCODE_SHOWWINDOW: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;OnShowWindow(TRUE); <br> <br>            break; <br> <br>        case OBJECTCODE_HIDEWINDOW: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;OnShowWindow(FALSE); <br> <br>            break; <br> <br>        case OBJECTCODE_SHOWOBJECT: <br>            if (NULL!=m_pIOleClientSite) <br>                m_pIOleClientSite-&gt;ShowObject(); <br> <br>            break; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER23MOD <br>/* <br> * CFigure::InPlaceActivate <br> * <br> * Purpose: <br> *  Goes through all the steps of activating the Figure as an <br> *  in-place object. <br> * <br> * Parameters: <br> *  pActiveSite     LPOLECLIENTSITE of the active site we show in. <br> *  fIncludeUI      BOOL indicating if we should do UI as well. <br> * <br> * Return Value: <br> *  HRESULT         Whatever error code is appropriate. <br> */ <br> <br>HRESULT CFigure::InPlaceActivate(LPOLECLIENTSITE pActiveSite <br>    , BOOL fIncludeUI) <br>    { <br>    HRESULT                 hr; <br>    HWND                    hWnd, hWndHW; <br>    RECT                    rcPos; <br>    RECT                    rcClip; <br> <br>    if (NULL==pActiveSite) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    //If we're already active, do the UI and we're done. <br>    if (NULL!=m_pIOleIPSite) <br>        { <br>        if (fIncludeUI) <br>            UIActivate(); <br> <br>        return NOERROR; <br>        } <br> <br>    /* <br>     * 1.  Initialization, obtaining interfaces, calling <br>     *     OnInPlaceActivate. <br>     */ <br>    hr=pActiveSite-&gt;QueryInterface(IID_IOleInPlaceSite <br>        , (PPVOID)&amp;m_pIOleIPSite); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=m_pIOleIPSite-&gt;CanInPlaceActivate(); <br> <br>    if (NOERROR!=hr) <br>        { <br>        m_pIOleIPSite-&gt;Release(); <br>        m_pIOleIPSite=NULL; <br>        return ResultFromScode(E_FAIL); <br>        } <br> <br>    m_pIOleIPSite-&gt;OnInPlaceActivate(); <br>    m_fUndoDeactivates=TRUE; <br> <br>    /* <br>     * 2.  Get the window context and create a window or change the <br>     *     parent and position of an existing window.  Servers are <br>     *     required to full cb in the OLEINPLACEFRAMEINFO structure. <br>     */ <br>    m_pIOleIPSite-&gt;GetWindow(&amp;hWnd); <br>    m_pFR-&gt;m_frameInfo.cb=sizeof(OLEINPLACEFRAMEINFO); <br> <br>    m_pIOleIPSite-&gt;GetWindowContext(&amp;m_pIOleIPFrame <br>        , &amp;m_pIOleIPUIWindow, &amp;rcPos, &amp;rcClip <br>        , &amp;m_pFR-&gt;m_frameInfo); <br> <br>    /* <br>     * Copy container frame pointer to CCosmoFrame for accelerators. <br>     * No AddRef because frame never messes with it.  Note also that <br>     * we don't do anything special with our own accelerators here <br>     * because we just use the same ones as always. <br>     */ <br>    m_pFR-&gt;m_pIOleIPFrame=m_pIOleIPFrame; <br> <br>    /* <br>     * We'll use a hatch window as the child of the container and the <br>     * editing window as a child of the hatch window.  We already <br>     * created the hatch window, so now all we have to do is put it <br>     * in the right place and stick the Polyline in it. <br>     */ <br> <br>    m_pHW-&gt;HwndAssociateSet(m_pFR-&gt;Window()); <br> <br>    m_pHW-&gt;ChildSet(m_pPL-&gt;Window());   //Calls SetParent <br>    m_pHW-&gt;RectsSet(&amp;rcPos, &amp;rcClip);   //Positions polyline <br> <br>    hWndHW=m_pHW-&gt;Window(); <br>    SetParent(hWndHW, hWnd);            //Move the hatch window <br>    ShowWindow(hWndHW, SW_SHOW);        //Make us visible. <br>    SendAdvise(OBJECTCODE_SHOWOBJECT); <br> <br>    if (fIncludeUI) <br>        return UIActivate(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::InPlaceDeactivate <br> * <br> * Purpose: <br> *  Reverses all the activation steps from InPlaceActivate. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::InPlaceDeactivate(void) <br>    { <br>    RECT        rc; <br> <br>    UIDeactivate(); <br> <br>    /* <br>     * When setting the parent back to the normal document, <br>     * reposition the Polyline to be at (8,8) instead of at wherever <br>     * it was in the container's window or our hatch window.  This <br>     * is so if we are deactivating to open in our own window the <br>     * Polyline appears in the proper place in the document window. <br>     */ <br> <br>    SetParent(m_pPL-&gt;Window(), m_pDoc-&gt;m_hWnd); <br>    m_pHW-&gt;ChildSet(NULL); <br> <br>    //Make sure the hatch window is invisible and owned by Cosmo <br>    ShowWindow(m_pHW-&gt;Window(), SW_HIDE); <br>    SetParent(m_pHW-&gt;Window(), m_pDoc-&gt;m_hWnd); <br> <br>    GetClientRect(m_pDoc-&gt;m_hWnd, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    SetWindowPos(m_pPL-&gt;Window(), NULL, rc.left, rc.top <br>        , rc.right-rc.left, rc.bottom-rc.top <br>        , SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    if (NULL!=m_pIOleIPSite) <br>        m_pIOleIPSite-&gt;OnInPlaceDeactivate(); <br> <br>    m_pFR-&gt;m_pIOleIPFrame=NULL; <br>    ReleaseInterface(m_pIOleIPFrame); <br>    ReleaseInterface(m_pIOleIPUIWindow); <br>    ReleaseInterface(m_pIOleIPSite); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CFigure::UIActivate <br> * <br> * Purpose: <br> *  Goes through all the steps of activating the user interface of <br> *  the Figure as an in-place object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or error code. <br> */ <br> <br>HRESULT CFigure::UIActivate(void) <br>    { <br>    //1.  Call IOleInPlaceSite::UIActivate <br>    if (NULL!=m_pIOleIPSite) <br>        m_pIOleIPSite-&gt;OnUIActivate(); <br> <br>    //2.  Critical for accelerators to work initially. <br>    SetFocus(m_pHW-&gt;Window()); <br> <br>    //3.  Set the active object <br> <br>   #ifdef WIN32ANSI <br>    OLECHAR     szTemp[40]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, PSZ(IDS_INPLACETITLE) <br>        , -1, szTemp, 40); <br>   #endif <br> <br>    if (NULL!=m_pIOleIPFrame) <br>        { <br>        m_pIOleIPFrame-&gt;SetActiveObject(m_pImpIOleIPActiveObject <br>           #ifdef WIN32ANSI <br>            , szTemp); <br>           #else <br>            , PSZ(IDS_INPLACETITLE)); <br>           #endif <br>        } <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        { <br>        m_pIOleIPUIWindow-&gt;SetActiveObject(m_pImpIOleIPActiveObject <br>           #ifdef WIN32ANSI <br>            , szTemp); <br>           #else <br>            , PSZ(IDS_INPLACETITLE)); <br>           #endif <br>        } <br> <br>    //4.  Create frame tools <br>    InPlaceToolsCreate(); <br> <br>    //5.  Create the shared menu. <br>    InPlaceMenuCreate(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFigure::UIDeactivate <br> * <br> * Purpose: <br> *  Reverses all the user interface activation steps from <br> *  UIActivate. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::UIDeactivate(void) <br>    { <br>    //1.  Remove the in-place tools <br>    InPlaceToolsDestroy(); <br> <br>    //2.  Remove the shared menu. <br>    InPlaceMenuDestroy(); <br> <br>    //3.  Set active obejcts to NULL <br>    if (NULL!=m_pIOleIPFrame) <br>        m_pIOleIPFrame-&gt;SetActiveObject(NULL, NULL); <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        m_pIOleIPUIWindow-&gt;SetActiveObject(NULL, NULL); <br> <br>    //3.  Call IOleInPlaceSite::OnUIDeactivate <br>    if (NULL!=m_pIOleIPSite) <br>        m_pIOleIPSite-&gt;OnUIDeactivate(FALSE); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CFigure::InPlaceMenuCreate <br> * <br> * Purpose: <br> *  Creates and sets a menu for an in-place embedded object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if everything is well, FALSE on error. <br> */ <br> <br>BOOL CFigure::InPlaceMenuCreate(void) <br>    { <br>    HMENU               hMenu, hMenuT; <br>    UINT                uTemp=MF_BYPOSITION | MF_POPUP; <br>    UINT                i; <br>    OLEMENUGROUPWIDTHS  mgw; <br> <br>    for (i=0; i&lt;6; i++) <br>        mgw.width[i]=0; <br> <br>    //We already have popup menu handles in m_pFR-&gt;m_phMenu[] <br> <br>    //Create the new shared menu and let container do its thing <br>    hMenu=CreateMenu(); <br>    m_pIOleIPFrame-&gt;InsertMenus(hMenu, &amp;mgw); <br> <br>    /* <br>     * Add our menus remembering that the container has added its <br>     * already. <br>     */ <br>    InsertMenu(hMenu, (UINT)mgw.width[0] <br>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[1], PSZ(IDS_MENUEDIT)); <br> <br>    /* <br>     * Add the Open item to the edit menu. <br>     * NOTE:  If you are a multiple-use server, this sort of code <br>     * will also modify the menu on the server window as well as <br>     * this shared menu in which case you need a separate popup menu <br>     * altogether. <br>     */ <br>    AppendMenu(m_pFR-&gt;m_phMenu[1], MF_SEPARATOR, 0, NULL); <br>    AppendMenu(m_pFR-&gt;m_phMenu[1], MF_STRING, IDM_EDITOPEN <br>        , PSZ(IDS_MENUOPEN)); <br> <br>    InsertMenu(hMenu, (UINT)mgw.width[0]+1+(UINT)mgw.width[2] <br>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[2], PSZ(IDS_MENUCOLOR)); <br> <br>    InsertMenu(hMenu, (UINT)mgw.width[0]+1+(UINT)mgw.width[2]+1 <br>       , uTemp, (UINT)m_pFR-&gt;m_phMenu[3], PSZ(IDS_MENULINE)); <br> <br>    //Window menu position changes between MDI and SDI <br>   #ifdef MDI <br>    hMenuT=m_pFR-&gt;m_phMenu[5]; <br>   #else <br>    hMenuT=m_pFR-&gt;m_phMenu[4]; <br>   #endif <br> <br>    InsertMenu(hMenu, (UINT)mgw.width[0]+1+(UINT)mgw.width[2]+2 <br>        + (UINT)mgw.width[4], uTemp, (UINT)hMenuT <br>        , PSZ(IDS_MENUHELP)); <br> <br>    //Tell OLE how many items in each group are ours. <br>    mgw.width[1]=1; <br>    mgw.width[3]=2; <br>    mgw.width[5]=1; <br> <br>    m_hMenuShared=hMenu; <br>    m_hOLEMenu=OleCreateMenuDescriptor(m_hMenuShared, &amp;mgw); <br> <br>    m_pIOleIPFrame-&gt;SetMenu(m_hMenuShared, m_hOLEMenu <br>        , m_pFR-&gt;Window()); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::InPlaceMenuDestroy <br> * <br> * Purpose: <br> *  Performs opposite actions from InPlaceMenuCreate <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if all is well, FALSE otherwise. <br> */ <br> <br>BOOL CFigure::InPlaceMenuDestroy(void) <br>    { <br>    int         cItems, i, j; <br>    HMENU       hMenuT; <br> <br>    //If we don't have a shared menu, nothing to do. <br>    if (NULL==m_hMenuShared) <br>        return TRUE; <br> <br>    //Stop the container frame from using this menu. <br>    m_pIOleIPFrame-&gt;SetMenu(NULL, NULL, NULL); <br> <br>    //Clean up what we got from OleCreateMenuDescriptor. <br>    OleDestroyMenuDescriptor(m_hOLEMenu); <br>    m_hOLEMenu=NULL; <br> <br>    cItems=GetMenuItemCount(m_hMenuShared); <br> <br>    /* <br>     * Walk backwards down the menu.  For each popup, see if it <br>     * matches any other popup we know about, and if so, remove <br>     * it from the shared menu. <br>     */ <br>    for (i=cItems; i &gt;=0; i--) <br>        { <br>        hMenuT=GetSubMenu(m_hMenuShared, i); <br> <br>        for (j=0; j &lt;= CMENUS; j++) <br>            { <br>            /* <br>             * If the submenu matches any we have, remove, don't <br>             * delete. Since we're walking backwards this only <br>             * affects the positions of those menus after us so the <br>             * GetSubMenu call above is not affected. <br>             */ <br>            if (hMenuT==m_pFR-&gt;m_phMenu[j]) <br>                RemoveMenu(m_hMenuShared, i, MF_BYPOSITION); <br>            } <br>        } <br> <br>    /* <br>     * Remove the Open item and separator from the Edit menu. <br>     * NOTE:  If you are a multiple-user server, this affects the <br>     * menu on the server window as well as the shared menu in which <br>     * case you need to use a separate popup menu altogether. <br>     */ <br>    RemoveMenu(m_pFR-&gt;m_phMenu[1], MPOS_OPEN, MF_BYPOSITION); <br>    RemoveMenu(m_pFR-&gt;m_phMenu[1], MPOS_SEP,  MF_BYPOSITION); <br> <br>    if (NULL!=m_pIOleIPFrame) <br>        m_pIOleIPFrame-&gt;RemoveMenus(m_hMenuShared); <br> <br>    DestroyMenu(m_hMenuShared); <br>    m_hMenuShared=NULL; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFigure::InPlaceToolsCreate <br> * <br> * Purpose: <br> *  Creates a toolbar for in-place activation and negotiates the <br> *  border space for the toolbar. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if we could allocate the space and create <br> *                  the tools.  FALSE if we fail, meaning that we <br> *                  just do in-place with menus only, since we can <br> *                  do without the tools.  We could fail and attempt <br> *                  to reverse what we might have done already, but <br> *                  since we don't really *need* the toolbar, we <br> *                  keep going. <br> */ <br> <br>BOOL CFigure::InPlaceToolsCreate(void) <br>    { <br>    BORDERWIDTHS    bw; <br>    HWND            hWnd; <br>    UINT            uState=GIZMO_NORMAL; <br>    UINT            utCmd =GIZMOTYPE_BUTTONCOMMAND; <br>    UINT            utEx  =GIZMOTYPE_BUTTONATTRIBUTEEX; <br>    UINT            i; <br>    HBITMAP         hBmp; <br>    RECT            rc; <br>    UINT            dxB, dyB; <br> <br>    //We don't need anything on the document, so send zeros. <br>    SetRectEmpty((LPRECT)&amp;bw); <br> <br>    if (NULL!=m_pIOleIPUIWindow) <br>        m_pIOleIPUIWindow-&gt;SetBorderSpace(&amp;bw); <br> <br>    if (NULL==m_pIOleIPFrame) <br>        return FALSE; <br> <br>    /* <br>     * 1.  Make sure we can reserve space for what we need.  If this <br>     *     fails then we just do without because the menu has <br>     *     everything we really need.  A more willing server could <br>     *     put tools in popup windows as well. <br>     */ <br> <br>    if (!InPlaceToolsRenegotiate()) <br>        { <br>        //If the container doesn't allow us any, don't ask for any. <br>        m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw); <br>        return FALSE; <br>        } <br> <br>    /* <br>     * 2.  Create the toolbar window using the container window as <br>     *     the parent.  In order to get messages from it, we use <br>     *     it's AssociateSet ability directly after creation and <br>     *     before we add any tools to the bar. <br>     */ <br> <br>    m_pIOleIPFrame-&gt;GetWindow(&amp;hWnd); <br> <br>    //If we already have a toolbar, just show it again. <br>    if (NULL!=m_pTB) <br>        { <br>        ShowWindow(m_pTB-&gt;Window(), SW_SHOW); <br>        return TRUE; <br>        } <br> <br>    m_pTB=new CToolBar(m_pFR-&gt;m_hInst); <br> <br>    if (NULL==m_pTB) <br>        { <br>        SetRectEmpty((LPRECT)&amp;bw); <br>        m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw); <br>        return FALSE; <br>        } <br> <br>    m_pTB-&gt;Init(hWnd, ID_GIZMOBAR, m_cyBar); <br>    g_pInPlaceTB=m_pTB; <br> <br>    //Insure the tools are initially invisible <br>    ShowWindow(m_pTB-&gt;Window(), SW_HIDE); <br> <br>    //Tell the toolbar who to send messages to. <br>    m_pTB-&gt;HwndAssociateSet(m_pFR-&gt;m_hWnd); <br> <br>    /* <br>     * Add tools to the bar, setting CFrame::fInit to avoid <br>     * command processing <br>     */ <br>    m_pFR-&gt;m_fInit=TRUE; <br> <br>    hBmp=m_pFR-&gt;m_hBmp; <br>    dxB=m_pFR-&gt;m_dxB; <br>    dyB=m_pFR-&gt;m_dyB; <br> <br>    //Edit Undo, Cut, Copy, Paste <br>    m_pTB-&gt;Add(utCmd, 1, IDM_EDITUNDO,  dxB, dyB, NULL, hBmp, 1, uState); <br>    m_pTB-&gt;Add(utCmd, 2, IDM_EDITCUT,   dxB, dyB, NULL, NULL, 0, uState); <br>    m_pTB-&gt;Add(utCmd, 3, IDM_EDITCOPY,  dxB, dyB, NULL, NULL, 1, uState); <br>    m_pTB-&gt;Add(utCmd, 4, IDM_EDITPASTE, dxB, dyB, NULL, NULL, 2, uState); <br> <br>    //Separator <br>    m_pTB-&gt;Add(GIZMOTYPE_SEPARATOR, 5, 0, 6, dyB, NULL, NULL, 0, uState); <br> <br>    //Color Background and Color Line <br>    m_pTB-&gt;Add(utCmd, 6, IDM_COLORBACKGROUND, dxB, dyB, NULL, hBmp, 3 <br>               , GIZMO_NORMAL | PRESERVE_BLACK); <br> <br>    m_pTB-&gt;Add(utCmd, 7, IDM_COLORLINE, dxB, dyB, NULL, hBmp, 4, uState); <br> <br>    //Separator <br>    m_pTB-&gt;Add(GIZMOTYPE_SEPARATOR, 8, 0, 6, dyB, NULL, NULL, 0, uState); <br> <br>    //Line styles. <br>    m_pTB-&gt;Add(utEx, 19, IDM_LINESOLID, dxB, dyB, NULL, hBmp, 5, uState); <br>    m_pTB-&gt;Add(utEx, 10, IDM_LINEDASH, dxB, dyB, NULL, hBmp, 6, uState); <br>    m_pTB-&gt;Add(utEx, 11, IDM_LINEDOT, dxB, dyB, NULL, hBmp, 7, uState); <br>    m_pTB-&gt;Add(utEx, 12, IDM_LINEDASHDOT, dxB, dyB, NULL, hBmp, 8 <br>        , uState); <br>    m_pTB-&gt;Add(utEx, 13, IDM_LINEDASHDOTDOT, dxB, dyB, NULL, hBmp, 9 <br>        , uState); <br> <br>    //Check the current line style. <br>    i=m_pPL-&gt;LineStyleGet()+IDM_LINEMIN; <br>    m_pTB-&gt;Check(i, TRUE); <br> <br>    m_pFR-&gt;m_fInit=FALSE; <br> <br>    /* <br>     * Before making the toolbar visible, resize it to the <br>     * container's GetBorder rectangle.  By default the toolbar <br>     * sizes itself to the client area of the parent, but we can't <br>     * assume that's the same as GetBorder returns, so we do the <br>     * extra work here. <br>     */ <br> <br>    m_pIOleIPFrame-&gt;GetBorder(&amp;rc); <br>    SetWindowPos(m_pTB-&gt;Window(), NULL, rc.left, rc.top <br>        , rc.right-rc.left, rc.top+m_cyBar, SWP_NOZORDER); <br> <br> <br>    //3.  Make the tools visible. <br>    ShowWindow(m_pTB-&gt;Window(), SW_SHOW); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CFigure::InPlaceToolsDestroy <br> * <br> * Purpose: <br> *  Reverses the process of InPlaceToolsCreate <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br> <br>BOOL CFigure::InPlaceToolsDestroy(void) <br>    { <br>    //Nothing to do if we never created anything. <br>    if (NULL==m_pTB) <br>        return TRUE; <br> <br>    /* <br>     * No reason to call SetBorderSpace with an empty rectangle <br>     * since you call IOleInPlaceSite::OnUIDeactivate.  The <br>     * container will restore its own tools appropriately. <br>     */ <br> <br>    //Destroy the toolbar. <br>    if (NULL!=m_pTB) <br>        { <br>        delete m_pTB; <br>        m_pTB=NULL; <br>        g_pInPlaceTB=NULL; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CFigure::InPlaceToolsRenegotiate <br> * <br> * Purpose: <br> *  Calls IOleInPlaceFrame::RequestBorderSpace and SetBorderSpace <br> *  to reserve space for our toolbar. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if all is well, FALSE otherwise. <br> */ <br> <br>BOOL CFigure::InPlaceToolsRenegotiate(void) <br>    { <br>    HRESULT         hr; <br>    BORDERWIDTHS    bw; <br> <br>    SetRect((LPRECT)&amp;bw, 0, m_pFR-&gt;m_cyBar, 0, 0); <br> <br>    hr=m_pIOleIPFrame-&gt;RequestBorderSpace(&amp;bw); <br> <br>    if (NOERROR!=hr) <br>        return FALSE; <br> <br>    //Safety net:  RequestBorderSpace may modify values in bw <br>    SetRect((LPRECT)&amp;bw, 0, m_pFR-&gt;m_cyBar, 0, 0); <br>    m_pIOleIPFrame-&gt;SetBorderSpace(&amp;bw); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CFigure::OpenIntoWindow <br> * <br> * Purpose: <br> *  If we're current open in-place, send ourselves the OPEN verb to <br> *  show into a full window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::OpenIntoWindow(void) <br>    { <br>    if (NULL!=m_pIOleIPSite) <br>        { <br>        //Make sure we don't try to do this. <br>        m_fUndoDeactivates=FALSE; <br> <br>        /* <br>         * We can get away with passing a lot of NULLs since we know <br>         * how we implemented DoVerb. <br>         */ <br>        m_pImpIOleObject-&gt;DoVerb(OLEIVERB_OPEN, NULL <br>            , m_pIOleClientSite, -1, NULL, NULL); <br> <br>        //This makes sure we save ourselves when closing. <br>        m_fForceSave=TRUE; <br> <br>        //Repaint the container immediately <br>        SendAdvise(OBJECTCODE_DATACHANGED); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * Undo <br> * <br> * Purpose: <br> *  If we have not done anything else in this object then call <br> *  IOleInPlaceSite::DeactivateAndUndo and return TRUE, otherwise <br> *  just return FALSE.  Note that the m_fUndoDeactivates is set <br> *  to FALSE in CFigure::SendAdvise for OBJECTCODE_DATACHANGED. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if we deactivated, FALSE otherwise. <br> */ <br> <br>BOOL CFigure::Undo(void) <br>    { <br>    if (!m_fUndoDeactivates) <br>        return FALSE; <br> <br>    m_fUndoDeactivates=FALSE; <br>    m_pIOleIPSite-&gt;DeactivateAndUndo(); <br>    return TRUE; <br>    } <br> <br>//End CHAPTER23MOD </code></pre>
<p>&nbsp;</p></body>
</HTML>
