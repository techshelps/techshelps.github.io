<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context969"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Cosmo Chapter 23 <br> * <br> * Implementation of the CCosmoDoc derivation of CDocument as <br> * well as an implementation of CPolylineAdviseSink. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CCosmoDoc::CCosmoDoc <br> * CCosmoDoc::~CCosmoDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events <br> */ <br> <br>CCosmoDoc::CCosmoDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pPL=NULL; <br>    m_pPLAdv=NULL; <br>    m_uPrevSize=SIZE_RESTORED; <br> <br>    m_pDropTarget=NULL; <br>    m_fDragSource=FALSE; <br> <br>    m_cfEmbedSource=RegisterClipboardFormat(CFSTR_EMBEDSOURCE); <br>    m_cfObjectDescriptor=RegisterClipboardFormat <br>        (CFSTR_OBJECTDESCRIPTOR); <br> <br>    m_pFigure=NULL; <br>    m_pMoniker=NULL; <br>    m_dwRegROT=0L; <br> <br>    m_cfLinkSource=RegisterClipboardFormat(CFSTR_LINKSOURCE); <br>    m_cfLinkSrcDescriptor=RegisterClipboardFormat <br>        (CFSTR_LINKSRCDESCRIPTOR); <br> <br>    return; <br>    } <br> <br> <br>CCosmoDoc::~CCosmoDoc(void) <br>    { <br>    //Make sure the object is saved <br>    m_pFigure-&gt;SendAdvise(OBJECTCODE_SAVEOBJECT); <br>    m_pFigure-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW); <br>    m_pFigure-&gt;SendAdvise(OBJECTCODE_CLOSED); <br> <br>    //If the document is reg'd as running, revoke and free the moniker <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br> <br>    if (NULL!=m_pMoniker) <br>        m_pMoniker-&gt;Release(); <br> <br>    if (NULL!=m_pFigure) <br>        { <br>        m_pFigure-&gt;AddRef(); <br>        CoDisconnectObject(m_pFigure, 0L); <br>        m_pFigure-&gt;Release();   //Starts shutdown if necessary. <br>        delete m_pFigure; <br>        } <br> <br>    //Clean up the allocations we did in Init <br>    if (NULL!=m_pPL) <br>        delete m_pPL; <br> <br>    if (NULL!=m_pPLAdv) <br>        delete m_pPLAdv; <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Init <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Init(PDOCUMENTINIT pDI) <br>    { <br>    RECT        rc; <br> <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::Init(pDI)) <br>        return FALSE; <br> <br>    //Add the Polyline stuff we need. <br>    m_pPLAdv=new CPolylineAdviseSink(this); <br>    m_pPL   =new CPolyline(m_hInst); <br> <br>    //Attempt to create our contained Polyline. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    if (!m_pPL-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_POLYLINE, m_pPLAdv)) <br>        return FALSE; <br> <br>    m_pDropTarget=new CDropTarget(this); <br> <br>    if (NULL!=m_pDropTarget) <br>        { <br>        m_pDropTarget-&gt;AddRef(); <br>        CoLockObjectExternal(m_pDropTarget, TRUE, FALSE); <br>        RegisterDragDrop(m_hWnd, m_pDropTarget); <br>        } <br> <br>    m_pFigure=new CFigure(ObjectDestroyed, this); <br> <br>    if (NULL==m_pFigure) <br>        return FALSE; <br> <br>    //We created an object, so count it. <br>    g_cObj++; <br> <br>    if (!m_pFigure-&gt;Init()) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize <br> *  the Polyline. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    if (WM_SIZE==iMsg) <br>        { <br>        //Don't effect the Polyline size to or from minimized state. <br>        if (SIZE_MINIMIZED!=wParam &amp;&amp; SIZE_MINIMIZED !=m_uPrevSize) <br>            { <br>            //When we change size, resize any Polyline we hold. <br>            dx=LOWORD(lParam); <br>            dy=HIWORD(lParam); <br> <br>            /* <br>             * If we are getting WM_SIZE in response to a Polyline <br>             * notification, then don't resize the Polyline window <br>             * again. <br>             */ <br>            if (!m_fNoSize &amp;&amp; NULL!=m_pPL) <br>                { <br>                //Resize the polyline to fit the new client <br>                SetRect(&amp;rc, 8, 8, dx-8, dy-8); <br>                m_pPL-&gt;RectSet(&amp;rc, FALSE); <br> <br>                /* <br>                 * We consider sizing something that makes the file <br>                 * dirty, but not until we've finished the create <br>                 * process, which is why we set fNoDirty to FALSE <br>                 * in WM_CREATE since we get a WM_SIZE on the first <br>                 * creation. <br>                 */ <br>                if (!m_fNoDirty) <br>                    FDirtySet(TRUE); <br> <br>                SetRect(&amp;rc, 0, 0, dx, dy); <br> <br>                if (NULL!=m_pAdv) <br>                    m_pAdv-&gt;OnSizeChange(this, &amp;rc); <br> <br>                m_fNoDirty=FALSE; <br>                } <br>            } <br> <br>        m_uPrevSize=wParam; <br>        } <br> <br>    if (WM_LBUTTONDOWN==iMsg) <br>        { <br>        LPDROPSOURCE    pIDropSource; <br>        LPDATAOBJECT    pIDataObject; <br>        HRESULT         hr; <br>        SCODE           sc; <br>        DWORD           dwEffect; <br> <br>        /* <br>         * The document has an 8 pixel border around the polyline <br>         * window where we'll see mouse clicks.  A left mouse button <br>         * click here means the start of a drag-drop operation. <br>         * <br>         * Since this is a modal operation, this IDropSource <br>         * is entirely local. <br>         */ <br> <br>        pIDropSource=new CDropSource(this); <br> <br>        if (NULL==pIDropSource) <br>            return FALSE; <br> <br>        pIDropSource-&gt;AddRef(); <br>        m_fDragSource=TRUE; <br> <br>        //Go get the data and start the ball rolling. <br>        pIDataObject=TransferObjectCreate(FALSE); <br> <br>        if (NULL!=pIDataObject) <br>            { <br>            hr=DoDragDrop(pIDataObject, pIDropSource <br>                , DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK <br>                , &amp;dwEffect); <br> <br>            pIDataObject-&gt;Release(); <br>            sc=GetScode(hr); <br>            } <br>        else <br>            sc=E_FAIL; <br> <br>        /* <br>         * When we return from DoDragDrop, either cancel or drop. <br>         * First toss the IDropSource we have here, then bail out <br>         * on cancel, and possibly clear our data on a move drop. <br>         */ <br> <br>        pIDropSource-&gt;Release(); <br> <br>        /* <br>         * If dropped on the same document (determined using <br>         * this flag, then dwEffect will be DROPEFFECT_NONE (see <br>         * IDropTarget::Drop in DROPTGT.CPP).  In any case, <br>         * reset this since the operation is done. <br>         */ <br> <br>        m_fDragSource=FALSE; <br> <br>        if (DRAGDROP_S_DROP==sc &amp;&amp; DROPEFFECT_MOVE==dwEffect) <br>            { <br>            m_pPL-&gt;New(); <br>            FDirtySet(TRUE); <br>            } <br> <br>        //On a canceled drop or a copy we don't do anything else <br>        return TRUE; <br>        } <br> <br>    if (WM_DESTROY==iMsg) <br>        { <br>        /* <br>         * We have to revoke the drop target here because the window <br>         * will be destroyed and the property forcefully removed <br>         * before we could do this in the destructor. <br>         */ <br>        if (NULL!=m_pDropTarget) <br>            { <br>            RevokeDragDrop(m_hWnd); <br>            CoLockObjectExternal(m_pDropTarget, FALSE, TRUE); <br>            ReleaseInterface(m_pDropTarget); <br>            } <br> <br>        return FALSE; <br>        } <br> <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with <br> *  no filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Clear(void) <br>    { <br>    //Completely reset the polyline <br>    m_pPL-&gt;New(); <br> <br>    CDocument::Clear(); <br>    m_lVer=0; <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CCosmoDoc::FDirtySet <br> * <br> * Purpose: <br> *  Sets or clears the document 'dirty' flag returning the previous <br> *  state of that same flag.  We override this in Cosmo server to <br> *  send the OnDataChange notification as necessary. <br> * <br> * Parameters: <br> *  fDirty          BOOL indicating the new contents of the dirty <br> *                  flag. <br> * <br> * Return Value: <br> *  BOOL            Previous value of the dirty flag. <br> */ <br> <br>BOOL CCosmoDoc::FDirtySet(BOOL fDirty) <br>    { <br>    BOOL        fRet; <br> <br>    fRet=CDocument::FDirtySet(fDirty); <br>    m_pFigure-&gt;SendAdvise(OBJECTCODE_DATACHANGED); <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FDirtyGet <br> * <br> * Purpose: <br> *  Override of the normal FDirtyGet such that we never return dirty <br> *  for an embedded object we're serving since updates constantly <br> *  happen and since the object will be saved on closure.  This then <br> *  prevents any message boxes asking the user to save. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the document is dirty, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FDirtyGet(void) <br>    { <br>    if (m_pFigure-&gt;FIsEmbedded()) <br>        return FALSE; <br> <br>    return m_fDirty; <br>    } <br> <br> <br> <br>/* <br> * CCosmoDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the Polyline window.  We do this by <br> *  opening the file and telling the Polyline to load itself from <br> *  that file. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load, NULL if the file <br> *                  is new and untitled. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    HRESULT         hr; <br>    LPSTORAGE       pIStorage; <br> <br>    if (NULL==pszFile) <br>        { <br>        //For a new untitled document, just rename ourselves. <br>        Rename(NULL); <br>        m_lVer=VERSIONCURRENT; <br>        return DOCERR_NONE; <br>        } <br> <br>    /* <br>     * If not a Compound File, open the file using STGM_CONVERT in <br>     * transacted mode to see old files as a storage with one stream <br>     * called "CONTENTS" (which is conveniently the name we use <br>     * in the new files).  We must use STGM_TRANSACTED here or else <br>     * the old file will be immediately converted on disk:  we only <br>     * want a converted image in memory from which to read.  In <br>     * addition, note that we need STGM_READWRITE as well since <br>     * conversion is inherently a write operation. <br>     */ <br> <br>    pIStorage=NULL; <br> <br>    if (NOERROR!=StgIsStorageFile(pszFile)) <br>        { <br>        hr=StgCreateDocfile(pszFile,STGM_TRANSACTED | STGM_READWRITE <br>            | STGM_CONVERT | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            { <br>            //If denied write access, try to load the old way <br>            if (STG_E_ACCESSDENIED==GetScode(hr)) <br>                m_lVer=m_pPL-&gt;ReadFromFile(pszFile); <br>            else <br>                return DOCERR_COULDNOTOPEN; <br>            } <br>        } <br>    else <br>        { <br>        hr=StgOpenStorage(pszFile, NULL, STGM_DIRECT | STGM_READ <br>            | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br>        } <br> <br>    if (NULL!=pIStorage) <br>        { <br>        m_lVer=m_pPL-&gt;ReadFromStorage(pIStorage); <br>        pIStorage-&gt;Release(); <br>        } <br> <br>    if (POLYLINE_E_READFAILURE==m_lVer) <br>        return DOCERR_READFAILURE; <br> <br>    if (POLYLINE_E_UNSUPPORTEDVERSION==m_lVer) <br>        return DOCERR_UNSUPPORTEDVERSION; <br> <br>    if (fChangeFile) <br>        Rename(pszFile); <br> <br>    //Importing a file makes things dirty <br>    FDirtySet(!fChangeFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Save <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user has <br> *  previously used FileOpen or FileSaveAs to provide a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CCosmoDoc::Save(UINT uType, LPTSTR pszFile) <br>    { <br>    LONG        lVer, lRet; <br>    UINT        uTemp; <br>    BOOL        fRename=TRUE; <br>    HRESULT     hr; <br>    LPSTORAGE   pIStorage; <br>    BOOL        fEmbedding; <br> <br>    fEmbedding=m_pFigure-&gt;FIsEmbedded(); <br> <br>    if (NULL==pszFile) <br>        { <br>        fRename=FALSE; <br>        pszFile=m_szFile; <br>        } <br> <br>    /* <br>     * Type 1 is the current version, type 2 is version 1.0 of the <br>     * Polyline so we use this to send the right version to <br>     * CPolyline::WriteToFile/WriteToStorage. <br>     */ <br> <br>    switch (uType) <br>        { <br>        case 0:         //From Save, use loaded version. <br>            lVer=m_lVer; <br>            break; <br> <br>        case 1: <br>            lVer=VERSIONCURRENT; <br>            break; <br> <br>        case 2: <br>            lVer=MAKELONG(0, 1);    //1.0 <br>            break; <br> <br>        default: <br>            return DOCERR_UNSUPPORTEDVERSION; <br>        } <br> <br>    /* <br>     * If the version the user wants to save is different from the <br>     * version that we loaded and m_lVer is not zero (new doc), <br>     * then inform the user of the version change and verify. <br>     */ <br> <br>    //For embedding, this is Save Copy As, so don't ask about versions. <br>    if (0!=m_lVer &amp;&amp; m_lVer!=lVer &amp;&amp; !fEmbedding) <br>        { <br>        TCHAR       szMsg[128]; <br> <br>        wsprintf(szMsg, PSZ(IDS_VERSIONCHANGE) <br>            , (UINT)HIWORD(m_lVer), (UINT)LOWORD(m_lVer) <br>            , (UINT)HIWORD(lVer), (UINT)LOWORD(lVer)); <br> <br>        uTemp=MessageBox(m_hWnd, szMsg, PSZ(IDS_DOCUMENTCAPTION) <br>            , MB_YESNOCANCEL); <br> <br>        if (IDCANCEL==uTemp) <br>            return DOCERR_CANCELLED; <br> <br>        //If the user won't upgrade, revert to loaded version. <br>        if (IDNO==uTemp) <br>            lVer=m_lVer; <br>        } <br> <br>    /* <br>     * For 1.0 files, still use the old code.  For new files, use <br>     * storages instead <br>     */ <br>    if (lVer==MAKELONG(0, 1)) <br>        lRet=m_pPL-&gt;WriteToFile(pszFile, lVer); <br>    else <br>        { <br>        hr=StgCreateDocfile(pszFile, STGM_DIRECT | STGM_READWRITE <br>            | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>        if (FAILED(hr)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        //Mark this as one of our class <br>        WriteClassStg(pIStorage, CLSID_CosmoFigure); <br> <br>        //Write user-readable class information <br>        WriteFmtUserTypeStg(pIStorage, m_cf <br>            , PSZ(IDS_CLIPBOARDFORMAT)); <br> <br>        lRet=m_pPL-&gt;WriteToStorage(pIStorage, lVer); <br>        pIStorage-&gt;Release(); <br>        } <br> <br>    if (POLYLINE_E_NONE!=lRet) <br>        return DOCERR_WRITEFAILURE; <br> <br>    //Saving makes us clean, but this doesn't apply to embedding. <br>    if (!fEmbedding) <br>        FDirtySet(FALSE); <br> <br>    //Update the known version of this document. <br>    m_lVer=lVer; <br> <br>    /* <br>     * If we're embedding, this is Save Copy As, so no rename. <br>     * Note that we also don't care about having been set to clean <br>     * since we're always 'clean' as an embedded object from <br>     * the user's perspective. <br>     */ <br>    if (fRename &amp;&amp; !fEmbedding) <br>        Rename(pszFile); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Rename <br> * <br> * Purpose: <br> *  Overrides the normal rename to manage a moniker for the open <br> *  file.  We maintain no moniker for untitled documents, and <br> *  therefore do not allow linking to such documents. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR to the new filename. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Rename(LPTSTR pszFile) <br>    { <br>    LPMONIKER   pmk; <br> <br>    //We don't need to change the base class, just augment... <br>    CDocument::Rename(pszFile); <br> <br>    //Unregister the old moniker (m_dwRegROT set to zero). <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br> <br>    ReleaseInterface(m_pMoniker); <br> <br>    if (NULL!=pszFile) <br>        { <br>        CreateFileMoniker(pszFile, &amp;pmk); <br> <br>        if (NULL!=pmk) <br>            { <br>            m_pMoniker=pmk;     //pmk AddRef'd in CreateFileMoniker <br>            INOLE_RegisterAsRunning(m_pFigure, m_pMoniker <br>                , 0, &amp;m_dwRegROT); <br> <br>            m_pFigure-&gt;SendAdvise(OBJECTCODE_RENAMED); <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Undo <br> * <br> * Purpose: <br> *  Reverses a previous action. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::Undo(void) <br>    { <br>    //CHAPTER23MOD <br>    //Give the in-place object a chance for DeactivateAndUndo. <br>    if (m_pFigure-&gt;Undo()) <br>        return; <br>    //End CHAPTER23MOD <br> <br>    m_pPL-&gt;Undo(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Clip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Clip(HWND hWndFrame, BOOL fCut) <br>    { <br>    BOOL            fRet=TRUE; <br>    LPDATAOBJECT    pIDataObject; <br> <br>    pIDataObject=TransferObjectCreate(fCut); <br> <br>    if (NULL==pIDataObject) <br>        return FALSE; <br> <br>    fRet=SUCCEEDED(OleSetClipboard(pIDataObject)); <br>    pIDataObject-&gt;Release(); <br> <br>    //Delete our current data if "cut" succeeded. <br>    if (fRet &amp;&amp; fCut) <br>        { <br>        m_pPL-&gt;New(); <br>        FDirtySet(TRUE); <br>        } <br> <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::RenderFormat <br> * <br> * Purpose: <br> *  Renders a specific clipboard format into global memory. <br> * <br> * Parameters: <br> *  cf              UINT format to render. <br> * <br> * Return Value: <br> *  HGLOBAL         Global memory handle containing the data. <br> */ <br> <br>HGLOBAL CCosmoDoc::RenderFormat(UINT cf) <br>    { <br>    HGLOBAL     hMem; <br> <br>    if (cf==m_cf) <br>        { <br>        m_pPL-&gt;DataGetMem(VERSIONCURRENT, &amp;hMem); <br>        return hMem; <br>        } <br> <br>    switch (cf) <br>        { <br>        case CF_METAFILEPICT: <br>            return m_pPL-&gt;RenderMetafilePict(); <br> <br>        case CF_BITMAP: <br>            return (HGLOBAL)m_pPL-&gt;RenderBitmap(); <br>        } <br> <br>    return NULL; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::RenderMedium <br> * <br> * Purpose: <br> *  Like RenderFormat, this function creates a specific data format <br> *  based on the cf parameter.  Unlike RenderFormat, we store the <br> *  result in a STGMEDIUM in case it has a medium other than <br> *  TYMED_HGLOBAL.  For conveniece we'll centralize all compound <br> *  document formats here, hGlobal or not. <br> * <br> * Parameters: <br> *  cf              UINT clipboard format of interest. <br> *  pSTM            LSTGMEDIUM to fill.  We only fill the union <br> *                  and tymed. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we could render the format, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::RenderMedium(UINT cf, LPSTGMEDIUM pSTM) <br>    { <br>    if (NULL==pSTM) <br>        return FALSE; <br> <br>    if (cf==m_cfEmbedSource) <br>        { <br>        /* <br>         * Embed Source data is an IStorage containing the native <br>         * data (same as Embedded Object).  Since our data is small, <br>         * it makes the most sense to create an IStorage in memory <br>         * and put transfer that instead of a disk-based IStorage. <br>         */ <br> <br>        pSTM-&gt;pstg=INOLE_CreateStorageOnHGlobal(STGM_DIRECT <br>            | STGM_READWRITE | STGM_SHARE_EXCLUSIVE); <br> <br>        if (NULL==pSTM-&gt;pstg) <br>            return FALSE; <br> <br>        //Now save the data to the storage. <br>        WriteClassStg(pSTM-&gt;pstg, CLSID_CosmoFigure); <br>        WriteFmtUserTypeStg(pSTM-&gt;pstg, m_cf <br>            , PSZ(IDS_CLIPBOARDFORMAT)); <br> <br>        if (POLYLINE_E_NONE!=m_pPL-&gt;WriteToStorage(pSTM-&gt;pstg <br>            , VERSIONCURRENT)) <br>            { <br>            /* <br>             * When someone releases the IStorage, STORAGE.DLL will <br>             * release the ILockBytes which, having fDeleteOnRelease <br>             * TRUE (second parameter) will release the memory. <br>             * That's why we don't have STGM_DELETEONRELEASE on the <br>             * IStorage. <br>             */ <br>            pSTM-&gt;pstg-&gt;Release(); <br>            return FALSE; <br>            } <br> <br>        pSTM-&gt;tymed=TYMED_ISTORAGE; <br>        return TRUE; <br>        } <br> <br>    /* <br>     * CFSTR_OBJECTDESCRIPTOR and CFSTR_LINKSRCDESCRIPTOR are the <br>     * same formats, but only copy link source if we have a moniker. <br>     */ <br>    if (cf==m_cfLinkSrcDescriptor &amp;&amp; NULL==m_pMoniker) <br>        return FALSE; <br> <br>    if (cf==m_cfObjectDescriptor || cf==m_cfLinkSrcDescriptor) <br>        { <br>        SIZEL   szl, szlT; <br>        POINTL  ptl; <br>        RECT    rc; <br>        LPTSTR  psz=NULL; <br> <br>        m_pPL-&gt;SizeGet(&amp;rc); <br>        SETSIZEL(szlT, rc.right, rc.bottom); <br>        XformSizeInPixelsToHimetric(NULL, &amp;szlT, &amp;szl); <br> <br>        SETPOINTL(ptl, 0, 0); <br> <br>        //Include the moniker display name now, if we have one. <br>        if (m_pMoniker) <br>            { <br>            LPBC    pbc; <br> <br>            CreateBindCtx(0, &amp;pbc); <br>           #ifdef WIN32ANSI <br>            LPOLESTR    pszW; <br> <br>            m_pMoniker-&gt;GetDisplayName(pbc, NULL, &amp;pszW); <br>            psz=(LPTSTR)CoTaskMemAlloc(512); <br>            WideCharToMultiByte(CP_ACP, 0, pszW, -1, psz, 512 <br>                , NULL, NULL); <br>            CoTaskMemFree((void *)pszW); <br>           #else <br>            m_pMoniker-&gt;GetDisplayName(pbc, NULL, &amp;psz); <br>           #endif <br>            pbc-&gt;Release(); <br>            } <br> <br>        pSTM-&gt;hGlobal=INOLE_AllocObjectDescriptor <br>            (CLSID_CosmoFigure, DVASPECT_CONTENT, szl, ptl <br>            , OLEMISC_RECOMPOSEONRESIZE, PSZ(IDS_OBJECTDESCRIPTION) <br>            , psz); <br> <br>        CoTaskMemFree((void *)psz); <br>        pSTM-&gt;tymed=TYMED_HGLOBAL; <br>        return (NULL!=pSTM-&gt;hGlobal); <br>        } <br> <br>    if (cf==m_cfLinkSource) <br>        { <br>        if (NULL!=m_pMoniker) <br>            { <br>            FORMATETC   fe; <br>            HRESULT     hr; <br> <br>            pSTM-&gt;tymed=TYMED_NULL; <br>            SETDefFormatEtc(fe, cf, TYMED_ISTREAM); <br>            hr=INOLE_GetLinkSourceData(m_pMoniker <br>                , (LPCLSID)&amp;CLSID_CosmoFigure, &amp;fe, pSTM); <br> <br>            return SUCCEEDED(hr); <br>            } <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPaste(void) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    fRet=FQueryPasteFromData(pIDataObject); <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br>/* <br> * CCosmoDoc::FQueryPasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste data from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject) <br>    { <br>    FORMATETC       fe; <br> <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    return (NOERROR==pIDataObject-&gt;QueryGetData(&amp;fe)); <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::Paste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::Paste(HWND hWndFrame) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    fRet=PasteFromData(pIDataObject); <br>    pIDataObject-&gt;Release(); <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::PasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Retrieves the private data format from a data object and sets <br> *  it to the current figure in the editor window. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoDoc::PasteFromData(LPDATAOBJECT pIDataObject) <br>    { <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br>    BOOL            fRet; <br> <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    fRet=SUCCEEDED(pIDataObject-&gt;GetData(&amp;fe, &amp;stm)); <br> <br>    if (fRet &amp;&amp; NULL!=stm.hGlobal) <br>        { <br>        m_pPL-&gt;DataSetMem(stm.hGlobal, FALSE, FALSE, TRUE); <br>        ReleaseStgMedium(&amp;stm); <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::TransferObjectCreate <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a DataTransferObject and stuffs the current Polyline <br> *  data into it, used for both clipboard and drag-drop operations. <br> * <br> * Parameters: <br> *  fCut            BOOL TRUE if we're cutting, FALSE if we're <br> *                  copying. <br> * <br> * Return Value: <br> *  LPDATAOBJECT    Pointer to the object created, NULL on failure <br> */ <br> <br>LPDATAOBJECT CCosmoDoc::TransferObjectCreate(BOOL fCut) <br>    { <br>    UINT            i; <br>    HRESULT         hr; <br>    STGMEDIUM       stm; <br>    FORMATETC       fe; <br>    LPDATAOBJECT    pIDataObject=NULL; <br>    const UINT      cFormats=7; <br>    static UINT     rgcf[7]={0, 0, 0, CF_METAFILEPICT, CF_BITMAP, 0, 0}; <br>    static DWORD    rgtm[7]={TYMED_HGLOBAL, TYMED_ISTORAGE, TYMED_HGLOBAL <br>        , TYMED_MFPICT, TYMED_GDI, TYMED_ISTREAM, TYMED_HGLOBAL}; <br> <br>    hr=CoCreateInstance(CLSID_DataTransferObject, NULL <br>        , CLSCTX_INPROC_SERVER, IID_IDataObject <br>        , (PPVOID)&amp;pIDataObject); <br> <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    rgcf[0]=m_cf; <br>    rgcf[1]=m_cfEmbedSource; <br>    rgcf[2]=m_cfObjectDescriptor; <br> <br>    //Don't include link stuff for cutting (0 format always fails) <br>    if (!fCut) <br>        { <br>        rgcf[5]=m_cfLinkSource; <br>        rgcf[6]=m_cfLinkSrcDescriptor; <br>        } <br> <br>    for (i=0; i &lt; cFormats; i++) <br>        { <br>        /* <br>         * RenderFormat handles memory handles, but for compound doc <br>         * formats we need something more.  So if RenderFormat fails <br>         * (which it will for i=1, try our latest addition which <br>         * writes to a different field in the STGMEDIUM. <br>         */ <br>        stm.hGlobal=RenderFormat(rgcf[i]); <br> <br>        if (NULL==stm.hGlobal) <br>            { <br>            if (!RenderMedium(rgcf[i], &amp;stm)) <br>                continue; <br>            } <br> <br>        stm.tymed=rgtm[i]; <br>        stm.pUnkForRelease=NULL; <br>        SETDefFormatEtc(fe, rgcf[i], rgtm[i]); <br>        pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE); <br>        } <br> <br>    return pIDataObject;    //Caller now responsible <br>    } <br> <br> <br> <br>/* <br> * CCosmoDoc::DropSelectTargetWindow <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a thin inverted frame around a window that we use to <br> *  show the window as a drop target.  This is a toggle function: <br> *  It uses XOR to create the effect so it must be called twice to <br> *  leave the window as it was. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::DropSelectTargetWindow(void) <br>    { <br>    HDC         hDC; <br>    RECT        rc; </code></pre>
<p>
</p>
<pre><code>UINT        dd=3; <br>    HWND        hWnd; <br> <br>    hWnd=m_pPL-&gt;Window(); <br>    hDC=GetWindowDC(hWnd); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    //Frame this window with inverted pixels <br> <br>    //Top <br>    PatBlt(hDC, rc.left, rc.top, rc.right-rc.left, dd, DSTINVERT); <br> <br>    //Bottom <br>    PatBlt(hDC, rc.left, rc.bottom-dd, rc.right-rc.left, dd <br>        , DSTINVERT); <br> <br>    //Left excluding regions already affected by top and bottom <br>    PatBlt(hDC, rc.left, rc.top+dd, dd, rc.bottom-rc.top-(2*dd) <br>        , DSTINVERT); <br> <br>    //Right excluding regions already affected by top and bottom <br>    PatBlt(hDC, rc.right-dd, rc.top+dd, dd, rc.bottom-rc.top-(2*dd) <br>        , DSTINVERT); <br> <br>    ReleaseDC(hWnd, hDC); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>//CHAPTER23MOD <br>/* <br> * CCosmoDoc::OpenInPlaceObject <br> * <br> * Purpose: <br> *  Instructs the current figure object to open into a window from <br> *  in-place active state, if applicable. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoDoc::OpenInPlaceObject(void) <br>    { <br>    if (NULL!=m_pFigure) <br>        m_pFigure-&gt;OpenIntoWindow(); <br> <br>    return; <br>    } <br> <br>//End CHAPTER23MOD <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorSet <br> * <br> * Purpose: <br> *  Changes a color used in our contained Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to change. <br> *  cr              COLORREF new color. <br> * <br> * Return Value: <br> *  COLORREF        Previous color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorSet(UINT iColor, COLORREF cr) <br>    { <br>    return m_pPL-&gt;ColorSet(iColor, cr); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::ColorGet <br> * <br> * Purpose: <br> *  Retrieves a color currently in use in the Polyline. <br> * <br> * Parameters: <br> *  iColor          UINT index of the color to retrieve. <br> * <br> * Return Value: <br> *  COLORREF        Current color for the given index. <br> */ <br> <br>COLORREF CCosmoDoc::ColorGet(UINT iColor) <br>    { <br>    return m_pPL-&gt;ColorGet(iColor); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleSet <br> * <br> * Purpose: <br> *  Changes the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  iStyle          UINT index of the new line style to use. <br> * <br> * Return Value: <br> *  UINT            Previous line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleSet(UINT iStyle) <br>    { <br>    return m_pPL-&gt;LineStyleSet(iStyle); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoDoc::LineStyleGet <br> * <br> * Purpose: <br> *  Retrieves the line style currently used in the Polyline <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Current line style. <br> */ <br> <br> <br>UINT CCosmoDoc::LineStyleGet(void) <br>    { <br>    if (NULL==m_pPL)    //m_pPL might not be valid yet <br>        return 0L; <br> <br>    return m_pPL-&gt;LineStyleGet(); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::CPolylineAdviseSink <br> * CPolylineAdviseSink::~CPolylineAdviseSink <br> * <br> * Constructor Parameters: <br> *  pv              LPVOID to store in this object <br> */ <br> <br>CPolylineAdviseSink::CPolylineAdviseSink(LPVOID pv) <br>    { <br>    m_pv=pv; <br>    return; <br>    } <br> <br> <br>CPolylineAdviseSink::~CPolylineAdviseSink(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnPointChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline added or removed a point. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnPointChange(void) <br>    { <br>    PCDocument      pDoc=(PCDocument)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnSizeChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed size. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnSizeChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br>    RECT            rc; <br>    DWORD           dwStyle; <br> <br>    /* <br>     * Polyline window is informing us that it changed size in <br>     * response to setting it's data.  Therefore we have to <br>     * size ourselves accordingly but without moving the screen <br>     * position of the polyline window. <br>     */ <br> <br>    pDoc-&gt;m_fNoSize=TRUE; <br> <br>    //Set the document window size. <br>    GetWindowRect(pDoc-&gt;m_pPL-&gt;Window(), &amp;rc); <br>    InflateRect(&amp;rc, 8, 8); <br> <br>    //Adjust for a window sans menu <br>    dwStyle=GetWindowLong(pDoc-&gt;m_hWnd, GWL_STYLE); <br>    AdjustWindowRect(&amp;rc, dwStyle, FALSE); <br> <br>    SetWindowPos(pDoc-&gt;m_hWnd, NULL, 0, 0, rc.right-rc.left <br>        , rc.bottom-rc.top, SWP_NOMOVE | SWP_NOZORDER); <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnSizeChange(pDoc, &amp;rc); <br> <br>    pDoc-&gt;m_fNoSize=FALSE; <br>    pDoc-&gt;FDirtySet(TRUE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnDataChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnDataChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    if (NULL!=pDoc-&gt;m_pAdv) <br>        pDoc-&gt;m_pAdv-&gt;OnDataChange(pDoc); <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnColorChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline data changed a color. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnColorChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPolylineAdviseSink::OnLineStyleChange <br> * <br> * Purpose: <br> *  Informs the document that the polyline changed its line style. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolylineAdviseSink::OnLineStyleChange(void) <br>    { <br>    PCCosmoDoc      pDoc=(PCCosmoDoc)m_pv; <br> <br>    pDoc-&gt;FDirtySet(TRUE); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
