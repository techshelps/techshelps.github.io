<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQUARE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context756"></a>SQUARE.CPP</h2>
<pre><code>/* <br> * SQUARE.CPP <br> * Square Rendering/Calculation Automation Object Chapter 15 <br> * <br> * An automation object that draws a square in various rotational <br> * states and provides access to it through IDispatch. <br> * <br> * This file contains all the code for this sample. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "square.h" <br> <br>ULONG       g_cObj=0; <br>ULONG       g_cLock=0; <br>HWND        g_hWnd=NULL; <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG         msg; <br>    PCApp       pApp; <br> <br>    SETMESSAGEQUEUE; <br> <br>    pApp=new CApp(hInst, hInstPrev, pszCmdLine, nCmdShow); <br> <br>    if (NULL==pApp) <br>        return -1; <br> <br>    if (pApp-&gt;Init()) <br>        { <br>        while (GetMessage(&amp;msg, NULL, 0,0 )) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    delete pApp; <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * MainWndProc <br> * <br> * Purpose: <br> *  Standard window class procedure. <br> */ <br> <br>LRESULT APIENTRY MainWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    switch (iMsg) <br>        { <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ObjectDestroyed <br> * <br> * Purpose: <br> *  Function for the object to call when it gets destroyed. <br> *  We destroy the main window if the proper conditions are met <br> *  for shutdown. <br> */ <br> <br>void ObjectDestroyed(void) <br>    { <br>    g_cObj--; <br> <br>    //No more objects and no locks, shut the app down. <br>    if (0L==g_cObj &amp;&amp; 0L==g_cLock &amp;&amp; IsWindow(g_hWnd)) <br>        PostMessage(g_hWnd, WM_CLOSE, 0, 0L); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::CApp <br> * CApp::~CApp <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the Application from WinMain <br> *  hInstPrev       HINSTANCE of a previous instance from WinMain <br> *  pszCmdLine      LPSTR of the command line. <br> *  nCmdShow        UINT specifying how to show the app window, <br> *                  from WinMain. <br> */ <br> <br>CApp::CApp(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, UINT nCmdShow) <br>    { <br>    //Initialize WinMain parameter holders. <br>    m_hInst     =hInst; <br>    m_hInstPrev =hInstPrev; <br>    m_pszCmdLine=pszCmdLine; <br>    m_nCmdShow  =nCmdShow; <br> <br>    m_dwRegCO=0; <br>    m_pIClassFactory=NULL; <br>    m_fInitialized=FALSE; <br>    return; <br>    } <br> <br> <br>CApp::~CApp(void) <br>    { <br>    //Opposite of CoRegisterClassObject; class factory ref is now 1 <br>    if (0L!=m_dwRegCO) <br>        CoRevokeClassObject(m_dwRegCO); <br> <br>    //The last Release, which frees the class factory. <br>    if (NULL!=m_pIClassFactory) <br>        m_pIClassFactory-&gt;Release(); <br> <br>    if (m_fInitialized) <br>        CoUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CApp::Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure.  If this function fails the caller should guarantee <br> *  that the destructor is called. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::Init(void) <br>    { <br>    WNDCLASS    wc; <br>    HRESULT     hr; <br>    HWND        hWnd; <br> <br>    if (lstrcmpiA(m_pszCmdLine, "-Embedding")) <br>        return FALSE; <br> <br>    CHECKVER_OLE; <br> <br>    if (FAILED(CoInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    if (!m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = MainWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = 0; <br>        wc.hInstance      = m_hInst; <br>        wc.hIcon          = NULL; <br>        wc.hCursor        = NULL; <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = NULL; <br>        wc.lpszClassName  = TEXT("SphereSquare"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br> <br>        //Child window in which to draw <br>        wc.lpfnWndProc    = SquareWndProc; <br>        wc.cbWndExtra     = CBSQUAREWNDEXTRA; <br>        wc.hCursor        = (HCURSOR)LoadCursor(NULL, IDC_ARROW); <br>        wc.lpszClassName  = SZCLASSSQUARE; <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br> <br>        } <br> <br>    //This window is never shown <br>    hWnd=CreateWindow(TEXT("SphereSquare"), TEXT("SphereSquare") <br>        , WS_OVERLAPPEDWINDOW, 100, 100, 400, 400 <br>        , NULL, NULL, m_hInst, NULL); <br> <br>    if (NULL==hWnd) <br>        return FALSE; <br> <br>    g_hWnd=hWnd; <br> <br>    m_pIClassFactory=new CSquareClassFactory(hWnd, m_hInst); <br> <br>    if (NULL==m_pIClassFactory) <br>        return FALSE; <br> <br>    m_pIClassFactory-&gt;AddRef(); <br> <br>    hr=CoRegisterClassObject(CLSID_SphereSquare, m_pIClassFactory <br>        , CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE, &amp;m_dwRegCO); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>//Class Factory implementation <br> <br> <br> <br>/* <br> * CSquareClassFactory::CSquareClassFactory <br> * CSquareClassFactory::~CSquareClassFactory <br> * <br> * Constructor Parameters: <br> *  hWnd            HWND of the application. <br> *  hInst           HINSTANCE to pass to objects we create. <br> */ <br> <br>CSquareClassFactory::CSquareClassFactory(HWND hWnd <br>    , HINSTANCE hInst) <br>    { <br>    m_cRef=0L; <br>    m_hWnd=hWnd; <br>    m_hInst=hInst; <br>    return; <br>    } <br> <br> <br>CSquareClassFactory::~CSquareClassFactory(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CSquareClassFactory::QueryInterface <br> * CSquareClassFactory::AddRef <br> * CSquareClassFactory::Release <br> */ <br> <br>STDMETHODIMP CSquareClassFactory::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IClassFactory==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CSquareClassFactory::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CSquareClassFactory::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br>/* <br> * CSquareClassFactory::CreateInstance <br> * CSquareClassFactory::LockServer <br> */ <br> <br>STDMETHODIMP CSquareClassFactory::CreateInstance(LPUNKNOWN pUnkOuter <br>    , REFIID riid, PPVOID ppvObj) <br>    { <br>    PCSquare    pObj; <br>    HRESULT     hr; <br> <br>    *ppvObj=NULL; <br> <br>    if (NULL!=pUnkOuter) <br>        return ResultFromScode(CLASS_E_NOAGGREGATION); <br> <br>    pObj=new CSquare(); <br> <br>    g_cObj++; <br>    hr=ResultFromScode(E_OUTOFMEMORY); <br> <br>    if (NULL!=pObj) <br>        { <br>        if (pObj-&gt;Init(m_hWnd, m_hInst)) <br>            { <br>            hr=pObj-&gt;QueryInterface(riid, ppvObj); <br>            } <br>        } <br> <br>    if (FAILED(hr)) <br>        { <br>        if (NULL!=pObj) <br>            delete pObj; <br> <br>        ObjectDestroyed(); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br>STDMETHODIMP CSquareClassFactory::LockServer(BOOL fLock) <br>    { <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        { <br>        g_cLock--; <br> <br>        //Centralizes shutdown in ObjectDestroyed <br>        g_cObj++; <br>        ObjectDestroyed(); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>//Object implementation <br> <br> <br>/* <br> * CSquare::CSquare <br> * CSquare::~CSquare <br> */ <br> <br>CSquare::CSquare(void) <br>    { <br>    m_cRef=0; <br>    m_hWnd=NULL; <br> <br>    m_pITypeInfo=NULL; <br>    m_pIUnkDisp=NULL; <br> <br>    m_cRadius=100.0; <br>    m_dDeclin=0.0; <br>    m_dTheta=0.0; <br> <br>    m_xOrg=(int)(1.5*m_cRadius); <br>    m_yOrg=m_xOrg; <br> <br>    m_crBack=GetSysColor(COLOR_WINDOW); <br>    m_crLinePos=RGB(255, 255, 0); <br>    m_crLineNeg=RGB(255, 0, 0); <br>    m_hPenPos=NULL; <br>    m_hPenNeg=NULL; <br> <br>    m_cx=200; <br>    m_cy=220; <br>    m_xPos=100; <br>    m_yPos=100; <br> <br>    return; <br>    } <br> <br> <br>CSquare::~CSquare(void) <br>    { <br>    ReleaseInterface(m_pITypeInfo); <br>    ReleaseInterface(m_pIUnkDisp); <br> <br>    if (NULL!=m_hPenPos) <br>        DeleteObject(m_hPenPos); <br> <br>    if (NULL!=m_hPenNeg) <br>        DeleteObject(m_hPenNeg); <br> <br>    if (NULL!=m_hWnd) <br>        DestroyWindow(m_hWnd); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CSquare::Init <br> * <br> * Purpose: <br> *  Creates the window in which we draw. <br> */ <br> <br>BOOL CSquare::Init(HWND hWndOwner, HINSTANCE hInst) <br>    { <br>    ITypeLib       *pITypeLib; <br>    HRESULT         hr; <br> <br>    //Create both default pens <br>    CreatePens(TRUE, TRUE); <br> <br>    m_hWnd=CreateWindow(SZCLASSSQUARE, SZCLASSSQUARE <br>        , WS_CAPTION | WS_POPUP, m_xPos, m_yPos, m_cx, m_cy <br>        , hWndOwner, NULL, hInst, this); <br> <br> <br>    if (NULL==m_hWnd) <br>        return NULL; <br> <br> <br>    if (FAILED(LoadRegTypeLib(LIBID_SphereSquareLibrary, 1, 0 <br>        , LANG_NEUTRAL, &amp;pITypeLib))) <br>        { <br>        if (FAILED(LoadTypeLib(OLETEXT("SQUARE.TLB"), &amp;pITypeLib))) <br>            return FALSE; <br>        } <br> <br>    hr=pITypeLib-&gt;GetTypeInfoOfGuid(IID_ISphereSquare, &amp;m_pITypeInfo); <br> <br>    if (FAILED(hr)) <br>        { <br>        pITypeLib-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    hr=CreateStdDispatch((IUnknown *)this, (ISphereSquare *)this <br>        , m_pITypeInfo, &amp;m_pIUnkDisp); <br> <br>    pITypeLib-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CSquare::CreatePens <br> * <br> * Purpose: <br> *  Creates one or both line color pens <br> * <br> * Parameters: <br> *  fPositive       BOOL instructing us to create positive line color. <br> *  fNegative       BOOL instructing us to create negative line color. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSquare::CreatePens(BOOL fPositive, BOOL fNegative) <br>    { <br>    if (fPositive) <br>        { <br>        if (NULL!=m_hPenPos) <br>            DeleteObject(m_hPenPos); <br> <br>        m_hPenPos=CreatePen(PS_SOLID, 1, m_crLinePos); <br> <br>        if (NULL==m_hPenPos) <br>            m_hPenPos=(HPEN)GetStockObject(BLACK_PEN); <br>        } <br> <br>    if (fNegative) <br>        { <br>        if (NULL!=m_hPenNeg) <br>            DeleteObject(m_hPenNeg); <br> <br>        m_hPenNeg=CreatePen(PS_SOLID, 1, m_crLineNeg); <br> <br>        if (NULL==m_hPenNeg) <br>            m_hPenNeg=(HPEN)GetStockObject(BLACK_PEN); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CSquare::Draw <br> * <br> * Purpose: <br> *  Draws the image of a square rotated according to m_dDeclin <br> *  and m_dTheta with an edge length of m_cRadius. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> * <br> * Return Value; <br> *  None <br> */ <br> <br>void CSquare::Draw(HDC hDC) <br>    { <br>    POINT           pt[5]; <br>    int             x, y; <br>    double          rad; <br>    RECT            rc; <br>    HGDIOBJ         hGDI; <br> <br>    SetBkColor(hDC, m_crBack); <br> <br>    //Erase the background <br>    SetRect(&amp;rc, 0, 0, m_xOrg*2, m_yOrg*2); <br>    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, NULL, 0, NULL); <br> <br>    rad=cos(m_dDeclin); <br> <br>    x=(int)(m_cRadius*cos(m_dTheta)); <br>    y=(int)(m_cRadius*rad*sin(m_dTheta)); <br> <br>    SETPOINT(pt[0], m_xOrg+x, m_yOrg+y); <br>    SETPOINT(pt[2], m_xOrg-x, m_yOrg-y); <br> <br>    x=(int)(m_cRadius*cos(m_dTheta+PI/2)); <br>    y=(int)(m_cRadius*rad*sin(m_dTheta+PI/2)); <br> <br>    SETPOINT(pt[3], m_xOrg+x, m_yOrg+y); <br>    SETPOINT(pt[1], m_xOrg-x, m_yOrg-y); <br> <br>    pt[4]=pt[0]; <br> <br>    /* <br>     * Set the line color according to which side of the square <br>     * is facing out of the screen.  We'll draw the positive <br>     * z lines a yellow (default), the negative face red <br>     * (default).  Both colors can be changed by the controller. <br>     * <br>     * To determine which side is out, we only have to look at <br>     * the rad value which is cos(m_dDeclin).  If positive, then <br>     * we're in the positive range. <br>     */ <br> <br>    hGDI=SelectObject(hDC, (rad &gt; 0) ? m_hPenPos : m_hPenNeg); <br>    Polyline(hDC, pt, sizeof(pt)/sizeof(POINT)); <br> <br>    SelectObject(hDC, GetStockObject(WHITE_PEN)); <br>    MoveToEx(hDC, m_xOrg, m_yOrg, NULL); <br>    LineTo(hDC, pt[0].x, pt[0].y); <br> <br>    SelectObject(hDC, hGDI); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * SquareWndProc <br> * <br> * Purpose: <br> *  Window procedure for the Square window. <br> */ <br> <br>LRESULT APIENTRY SquareWndProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCSquare    pcp; <br>    PAINTSTRUCT         ps; <br>    HDC                 hDC; <br>    RECT                rc; <br> <br>    pcp=(PCSquare)GetWindowLong(hWnd, SQWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            pcp=(PCSquare)((LPCREATESTRUCT)lParam) <br>                -&gt;lpCreateParams; <br>            SetWindowLong(hWnd, SQWL_STRUCTURE, (LONG)pcp); <br>            break; <br> <br>        case WM_ERASEBKGND: <br>            hDC=(HDC)wParam; <br>            SetBkColor(hDC, pcp-&gt;m_crBack); <br>            GetClientRect(hWnd, &amp;rc); <br>            ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, NULL, 0, NULL); <br>            break; <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br>            pcp-&gt;Draw(hDC); <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_CLOSE: <br>            /* <br>             * Eat this or Alt+F4 can destroy the window, even <br>             * though we don't have a system menu. <br>             */ <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CSquare::QueryInterface <br> * CSquare::AddRef <br> * CSquare::Release <br> * <br> * Purpose: <br> *  IUnknown members for CSquare object. <br> */ <br> <br>STDMETHODIMP CSquare::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_ISphereSquare==riid) <br>        *ppv=this; <br> <br>    if (IID_IDispatch==riid || DIID_DISphereSquare==riid) <br>        return m_pIUnkDisp-&gt;QueryInterface(IID_IDispatch, ppv); <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((IUnknown *)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CSquare::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CSquare::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    ObjectDestroyed(); <br>    delete this; <br>    return 0L; <br>    } <br> <br> <br> <br>//ISphereSquare members <br> <br>STDMETHODIMP_(double) CSquare::get_Radius(void) <br>    { <br>    return m_cRadius; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_Radius(double cRadius) <br>    { <br>    //Only use positive radii. <br>    if (cRadius &gt; 0.0) <br>        m_cRadius=cRadius; <br> <br>    //We'll be lazy and not throw exceptions. <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(double) CSquare::get_Theta(void) <br>    { <br>    return m_dTheta; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_Theta(double dTheta) <br>    { <br>    //Anything is valid when you do trig <br>    m_dTheta=dTheta; <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(double) CSquare::get_Declination(void) <br>    { <br>    return m_dDeclin; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_Declination(double dDeclin) <br>    { <br>    m_dDeclin=dDeclin; <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(long) CSquare::get_BackColor(void) <br>    { <br>    return m_crBack; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_BackColor(long crBack) <br>    { <br>    m_crBack=crBack; <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(long) CSquare::get_LineColorPositive(void) <br>    { <br>    return m_crLinePos; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_LineColorPositive(long crLinePos) <br>    { <br>    m_crLinePos=crLinePos; <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(long) CSquare::get_LineColorNegative(void) <br>    { <br>    return m_crLineNeg; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::put_LineColorNegative(long crLineNeg) <br>    { <br>    m_crLineNeg=crLineNeg; <br>    return; <br>    } <br> <br> <br>STDMETHODIMP_(void) CSquare::Draw(void) <br>    { <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::SetCenterPoint(int cx, int cy) <br>    { <br>    //No validation...we're deing lazy <br>    m_xOrg=cx; <br>    m_yOrg=cy; <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::ShowWindow(int nCmdShow) <br>    { <br>    ::ShowWindow(m_hWnd, nCmdShow); <br>    UpdateWindow(m_hWnd); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::SetWindowPosition(int xPos, int yPos) <br>    { <br>    m_xPos=xPos; <br>    m_yPos=yPos; <br> <br>    SetWindowPos(m_hWnd, NULL, m_xPos, m_yPos, 0, 0 <br>        , SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CSquare::SetWindowSize(int cx, int cy) <br>    { <br>    m_cx=cx; <br>    m_cy=cy; <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0, m_cx, m_cy <br>        , SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
