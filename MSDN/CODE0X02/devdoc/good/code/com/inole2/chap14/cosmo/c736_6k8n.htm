<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOBASE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context737"></a>AUTOBASE.CPP</h2>
<pre><code>/* <br> * AUTOBASE.CPP <br> * Cosmo Chapter 14 <br> * <br> * Base object for Cosmo's OLE Automation support.  This class <br> * provides the implementation of IDispatch as well as the code <br> * that loads the appropriate type information.  This leaves <br> * each specific object to implement it's specific interface and <br> * little else. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved. <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  INTERNET&gt;kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CAutoBase::CAutoBase <br> * CAutoBase::~CAutoBase <br> * <br> * Constructor Parameters: <br> *  pv              void * to the frame or document object that <br> *                  derived classes will use to access the functions <br> *                  they need to implemenet their interface. <br> *  hInst           HINSTANCE of the application (for loading <br> *                  resources) <br> *  riid            REFIID of the interface that this object <br> *                  should expose. <br> *  rdiid           REFIID of the dispinterface that this <br> *                  object should expose. <br> *  pfnDestroy      PFNDESTROYED to call when the object <br> *                  is destroyed. <br> */ <br> <br>CAutoBase::CAutoBase(void *pv, HINSTANCE hInst, REFIID riid <br>    , REFIID rdiid, PFNDESTROYED pfnDestroy) <br>    { <br>    m_cRef=0L; <br>    m_pfnDestroy=pfnDestroy; <br> <br>    m_pObj=pv; <br>    m_hInst=hInst; <br> <br>    m_iid=riid; <br>    m_diid=rdiid; <br> <br>    m_pImpIDispatch=NULL; <br>    m_pImpIExtConn=NULL; <br>    return; <br>    } <br> <br> <br>CAutoBase::~CAutoBase(void) <br>    { <br>    DeleteInterfaceImp(m_pImpIExtConn); <br>    DeleteInterfaceImp(m_pImpIDispatch); <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoBase::Init <br> * <br> * Purpose: <br> *  Performs any intiailization of CAutoBase that's prone to failure <br> *  that we also use internally before exposing the object outside. <br> * <br> * Parameters: <br> *  fExtConn        BOOL indicating if we care about external <br> *                  connections for shutdown. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CAutoBase::Init(BOOL fExtConn) <br>    { <br>    //The derived class has to supply the IUnknown implementation <br>    m_pImpIDispatch=new CImpIDispatch(this <br>        , (IUnknown *)VTableInterface()); <br> <br>    if (NULL==m_pImpIDispatch) <br>        return FALSE; <br> <br>    if (fExtConn) <br>        { <br>        m_pImpIExtConn=new CImpIExtConn <br>            ((IUnknown *)VTableInterface()); <br> <br>        if (NULL==m_pImpIExtConn) <br>            return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>//IDispatch interface implementation <br> <br>/* <br> * CImpIDispatch::CImpIDispatch <br> * CImpIDispatch::~CImpIDispatch <br> * <br> * Parameters (Constructor): <br> *  pObj            PCAutoBase to the containing object. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIDispatch::CImpIDispatch(PCAutoBase pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pITypeInfo=NULL; <br>    return; <br>    } <br> <br>CImpIDispatch::~CImpIDispatch(void) <br>    { <br>    ReleaseInterface(m_pITypeInfo); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::QueryInterface <br> * CImpIDispatch::AddRef <br> * CImpIDispatch::Release <br> * <br> * Purpose: <br> *  IUnknown members for CImpIDispatch object. <br> */ <br> <br>STDMETHODIMP CImpIDispatch::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CImpIDispatch::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIDispatch::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::GetTypeInfoCount <br> * CImpIDispatch::GetTypeInfo <br> */ <br> <br>STDMETHODIMP CImpIDispatch::GetTypeInfoCount(UINT *pctInfo) <br>    { <br>    //We implement GetTypeInfo so return 1 <br>    *pctInfo=1; <br>    return NOERROR; <br>    } <br> <br>STDMETHODIMP CImpIDispatch::GetTypeInfo(UINT itInfo, LCID lcid <br>    , ITypeInfo **ppITypeInfo) <br>    { <br>    HRESULT     hr; <br>    ITypeLib   *pITypeLib; <br>    ITypeInfo **ppITI=NULL; <br> <br>    if (0!=itInfo) <br>        return ResultFromScode(TYPE_E_ELEMENTNOTFOUND); <br> <br>    if (NULL==ppITypeInfo) <br>        return ResultFromScode(E_POINTER); <br> <br>    *ppITypeInfo=NULL; <br> <br>    /* <br>     * This switch statement is nicely extensible for other <br>     * languages and other m_pITypeInfo variables (such as it <br>     * was used in Beeper #2 (see ..\beeper2\beeper.cpp) <br>     */ <br>    switch (PRIMARYLANGID(lcid)) <br>        { <br>        case LANG_NEUTRAL: <br>        case LANG_ENGLISH: <br>            ppITI=&amp;m_pITypeInfo; <br>            break; <br> <br>        default: <br>            return ResultFromScode(DISP_E_UNKNOWNLCID); <br>        } <br> <br>    //Load a type lib if we don't have the information already. <br>    if (NULL==*ppITI) <br>        { <br>        hr=LoadRegTypeLib(LIBID_CosmoTypeLibrary, 1, 0 <br>            , PRIMARYLANGID(lcid), &amp;pITypeLib); <br> <br>        /* <br>         * If LoadRegTypeLib fails, try loading directly from <br>         * our module with LoadTypeLib. <br>         */ <br>        if (FAILED(hr)) <br>            { <br>            const int   cch=512; <br>            TCHAR       szModule[cch]; <br> <br>            GetModuleFileName(m_pObj-&gt;m_hInst, szModule, cch); <br> <br>            switch (PRIMARYLANGID(lcid)) <br>                { <br>                case LANG_NEUTRAL: <br>                case LANG_ENGLISH: <br>                   #ifdef WIN32ANSI <br>                    OLECHAR szTemp[512]; <br>                    MultiByteToWideChar(CP_ACP, 0, szModule, -1, szTemp, 512); <br>                    hr=LoadTypeLib(szTemp, &amp;pITypeLib); <br>                   #else <br>                    hr=LoadTypeLib(szModule, &amp;pITypeLib); <br>                   #endif <br>                    break; <br> <br>                /* <br>                 * Easily extensible with additional languages. <br>                 * Use LoadTypeLibFromResource or specify <br>                 * separate .TLB files instead of the module name. <br>                 * Be sure to use your DIR registry key to find <br>                 * the right path. <br>                 */ <br>                } <br>            } <br> <br>        if (FAILED(hr)) <br>            return hr; <br> <br>        //Got the type lib, get type info for the interface we want <br>        hr=pITypeLib-&gt;GetTypeInfoOfGuid(m_pObj-&gt;m_iid, ppITI); <br>        pITypeLib-&gt;Release(); <br> <br>        if (FAILED(hr)) <br>            return hr; <br>        } <br> <br>    //Ref on ITypeInfo holds type library in memory <br>    (*ppITI)-&gt;AddRef(); <br>    *ppITypeInfo=*ppITI; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIDispatch::GetIDsOfNames <br> * CImpIDispatch::Invoke <br> */ <br> <br>STDMETHODIMP CImpIDispatch::GetIDsOfNames(REFIID riid <br>    , OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgDispID) <br>    { <br>    HRESULT     hr; <br>    ITypeInfo  *pTI; <br> <br>    if (IID_NULL!=riid) <br>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE); <br> <br>    hr=GetTypeInfo(0, lcid, &amp;pTI); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        hr=DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID); <br>        pTI-&gt;Release(); <br>        } <br> <br>    return hr; <br>    } <br> <br>STDMETHODIMP CImpIDispatch::Invoke(DISPID dispID, REFIID riid <br>    , LCID lcid, unsigned short wFlags, DISPPARAMS *pDispParams <br>    , VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr) <br>    { <br>    HRESULT     hr; <br>    ITypeInfo  *pTI; <br> <br>    if (IID_NULL!=riid) <br>        return ResultFromScode(DISP_E_UNKNOWNINTERFACE); <br> <br>    //Get the ITypeInfo for lcid <br>    hr=GetTypeInfo(0, lcid, &amp;pTI); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    //Note:  this sample doesn't do anything with exceptions. <br> <br>    //The VTableInterface function gets us the right pointer <br>    hr=pTI-&gt;Invoke(m_pObj-&gt;VTableInterface(), dispID, wFlags <br>        , pDispParams, pVarResult, pExcepInfo, puArgErr); <br> <br>    pTI-&gt;Release(); <br>    return hr; <br>    } <br> <br> <br> <br> <br>//IExternalConnection implementation <br> <br>/* <br> * CImpIExtConn::CImpIExtConn <br> * CImpIExtConn::~CImpIExtConn <br> * <br> * Parameters (Constructor): <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIExtConn::CImpIExtConn(LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_cStrong=0; <br>    return; <br>    } <br> <br>CImpIExtConn::~CImpIExtConn(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIExtConn::QueryInterface <br> * CImpIExtConn::AddRef <br> * CImpIExtConn::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for CImpIExtConn. <br> */ <br> <br>STDMETHODIMP CImpIExtConn::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CImpIExtConn::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIExtConn::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIExtConn::AddConnection <br> * <br> * Purpose: <br> *  Informs the object that a connection has been made to it.  We <br> *  count only strong references. <br> * <br> * Parameters: <br> *  dwConn          DWORD identifying the type of connection, taken <br> *                  from the EXTCONN enumeration. <br> *  dwReserved      DWORD reserved.  This is used inside OLE and <br> *                  should not be validated. <br> * <br> * Return Value: <br> *  DWORD           The number of connection counts on the <br> *                  object, used for debugging purposes only. <br> */ <br> <br>STDMETHODIMP_(DWORD) CImpIExtConn::AddConnection <br>    (DWORD dwConn, DWORD dwReserved) <br>    { <br>    if (EXTCONN_STRONG==dwConn) <br>        { <br>        m_cStrong++; <br>        return m_cStrong; <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIExtConn::ReleaseConnection <br> * <br> * Purpose: <br> *  Informs an object that a connection has been taken away from <br> *  it in which case the object may need to shut down. <br> * <br> * Parameters: <br> *  dwConn              DWORD identifying the type of connection, <br> *                      taken from the EXTCONN enumeration. <br> *  dwReserved          DWORD reserved.  This is used inside OLE and <br> *                      should not be validated. <br> *  fLastReleaseCloses  BOOL indicating if the last call to this <br> *                      function should close the object. <br> * <br> * Return Value: <br> *  DWORD           The number of remaining connection counts on <br> *                  the object, used for debugging purposes only. <br> */ <br> <br>STDMETHODIMP_(DWORD) CImpIExtConn::ReleaseConnection <br>    (DWORD dwConn, DWORD dwReserved, BOOL fLastReleaseCloses) <br>    { <br>    DWORD       dw=0L; <br> <br>    if (EXTCONN_STRONG==dwConn) <br>        { <br>        dw=--m_cStrong; <br> <br>        /* <br>         * Note that in the way we're using this interface we <br>         * don't care about fLastReleaseCloses. <br>         */ <br>        if (0L==m_cStrong) <br>            m_pUnkOuter-&gt;Release();     //Closes app or doc <br>        } <br> <br>    return dw; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
