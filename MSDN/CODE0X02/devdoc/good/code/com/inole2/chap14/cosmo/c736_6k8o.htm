<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOFIG.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context738"></a>AUTOFIG.CPP</h2>
<pre><code>/* <br> * AUTOFIG.CPP <br> * Cosmo Chapter 14 <br> * <br> * "Figure" object for Cosmo's OLE Automation support, derived <br> * from CAutoBase. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved. <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  INTERNET&gt;kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CAutoFigure::CAutoFigure <br> * CAutoFigure::~CAutoFigure <br> * <br> * Constructor Parameters: <br> *  pDoc            PCCosmoDoc to the dpcument object that we <br> *                  use to implement much of this interface. <br> */ <br> <br>CAutoFigure::CAutoFigure(PCCosmoDoc pDoc) <br>    : CAutoBase(pDoc, pDoc-&gt;m_hInst, IID_ICosmoFigure <br>    , DIID_DICosmoFigure, ObjectDestroyed) <br>    { <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoFigure::QueryInterface <br> * CAutoFigure::AddRef <br> * CAutoFigure::Release <br> */ <br> <br>STDMETHODIMP CAutoFigure::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_ICosmoFigure==riid) <br>        *ppv=(IUnknown *)this; <br> <br>    if (IID_IDispatch==riid || m_diid==riid) <br>        *ppv=m_pImpIDispatch; <br> <br>    if (IID_IExternalConnection==riid) <br>        *ppv=m_pImpIExtConn; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CAutoFigure::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CAutoFigure::Release(void) <br>    { <br>    /* <br>     * Since this object might have come from a class factory, <br>     * we count it's existence (see NewFigure below) for <br>     * controlling shutdown of the application when we call <br>     * ObjectDestroyed.  Otherwise we always close the document. <br>     */ <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    put_Visible(FALSE); <br>    SendMessage(m_pDoc-&gt;Window(), WM_CLOSE, 0, 0L); <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    return 0L; <br>    } <br> <br> <br>/* <br> * CAutoFigure::VTableInterface <br> * <br> * Purpose: <br> *  Returns the right vtable pointer to use when calling <br> *  ITypeInfo::Invoke (see CImpIDispatch::Invoke in AUTOBASE.CPP). <br> */ <br>void *CAutoFigure::VTableInterface(void) <br>    { <br>    return (ICosmoFigure *)this; <br>    } <br> <br> <br> <br>//All that follows is the ICosmoFigure implementation <br> <br>/* <br> * CAutoFigure::Application <br> * CAutoFigure::Parent <br> * Properties, read-only <br> * <br> * The application object (CAutoApp) in which we're contained, <br> * which is stored in the frame object <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigure::get_Application(void) <br>    { <br>    PCCosmoFrame    pFR; <br> <br>    pFR=(PCCosmoFrame)m_pDoc-&gt;m_pFR; <br>    return pFR-&gt;AutoApp()-&gt;get_Application(); <br>    } <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigure::get_Parent(void) <br>    { <br>    return get_Application(); <br>    } <br> <br> <br>/* <br> * CAutoFigure::FullName, Name, Path <br> * Properties, read-only <br> * <br> * Retrieve the full pathname of the figure file (FullName), <br> * just the file name (Name), or just the path (Path). <br> * <br> * Note that these functions are very similar to the same <br> * ones in CAutoApp, and there is probably some code that could <br> * be shared between them, but this sample won't bother with <br> * such an optimization. <br> */ <br> <br>STDMETHODIMP_(BSTR) CAutoFigure::get_FullName(void) <br>    { <br>    if ((TCHAR)0==m_pDoc-&gt;m_szFile[0]) <br>        return NULL; <br> <br>   #ifdef WIN32ANSI <br>    OLECHAR     szTemp[512]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, m_pDoc-&gt;m_szFile, -1, szTemp, 512); <br>    return SysAllocString(szTemp); <br>   #else <br>    return SysAllocString(m_pDoc-&gt;m_szFile); <br>   #endif <br>    } <br> <br>STDMETHODIMP_(BSTR) CAutoFigure::get_Name(void) <br>    { <br>    BSTR        bstrFull=NULL; <br>    BSTR        bstrName=NULL; <br>    const int   cch=256; <br>    TCHAR       szName[256]; <br> <br>    //Get the full path <br>    bstrFull=get_FullName(); <br> <br>    if (NULL==bstrFull) <br>        return NULL; <br> <br>    //Now retrieve just the filename <br>   #ifdef WIN32ANSI <br>    char        szTemp[cch]; <br>    OLECHAR     szTempW[cch]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrFull, -1, szTemp <br>        , cch, NULL, NULL); <br>    if (0==GetFileTitle(szTemp, szName, cch)) <br>        { <br>        MultiByteToWideChar(CP_ACP, 0, szName, -1, szTempW, cch); <br>        bstrName=SysAllocString(szTempW); <br>        } <br>   #else <br>    if (0==GetFileTitle(bstrFull, szName, cch)) <br>        bstrName=SysAllocString(szName); <br>   #endif <br> <br>    SysFreeString(bstrFull); <br>    return bstrName; <br>    } <br> <br>STDMETHODIMP_(BSTR) CAutoFigure::get_Path(void) <br>    { <br>    BSTR        bstrFull=NULL; <br>    BSTR        bstrName=NULL; <br>    BSTR        bstrPath=NULL; <br> <br>    bstrFull=get_FullName(); <br> <br>    if (NULL==bstrFull) <br>        return NULL; <br> <br>    bstrName=get_Name(); <br> <br>    if (NULL!=bstrName) <br>        { <br>        LPOLESTR    psz; <br> <br>        /* <br>         * Find the position of bstrName in bstrFull then copy <br>         * only charaters up to that point into bstrPath. <br>         */ <br>       #ifdef WIN32ANSI <br>        psz=wcsstr(bstrFull, bstrName); <br>       #else <br>        psz=_tcsstr(bstrFull, bstrName); <br>       #endif <br> <br>        //The -1 accounts for the \ before the filename <br>        bstrPath=SysAllocStringLen(bstrFull <br>            , ((psz-bstrFull)/sizeof(TCHAR))-1); <br>        SysFreeString(bstrName); <br>        } <br> <br>    SysFreeString(bstrFull); <br>    return bstrPath; <br>    } <br> <br> <br>/* <br> * CAutoFigure::Saved <br> * Property, read-only <br> * <br> * TRUE if the document is clean, FALSE otherwise. <br> */ <br> <br>STDMETHODIMP_(VARIANT_BOOL) CAutoFigure::get_Saved(void) <br>    { <br>    return !m_pDoc-&gt;FDirtyGet(); <br>    } <br> <br> <br>/* <br> * CAutoFigure::NumberOfPoints <br> * Property, read-only <br> * <br> * Number of points in the current figure. <br> */ <br> <br>STDMETHODIMP_(short)CAutoFigure::get_NumberOfPoints(void) <br>    { <br>    POLYLINEDATA    pl; <br> <br>    m_pDoc-&gt;m_pPL-&gt;DataGet(&amp;pl, VERSIONCURRENT); <br>    return pl.cPoints; <br>    } <br> <br> <br>/* <br> * CAutoFigure::BackColor <br> * CAutoFigure::LineColor <br> * Properties, read-write <br> * <br> * Colors used in the figure. <br> */ <br> <br>STDMETHODIMP_(long) CAutoFigure::get_BackColor(void) <br>    { <br>    return m_pDoc-&gt;ColorGet(POLYLINECOLOR_BACKGROUND); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_BackColor(long clrBack) <br>    { <br>    m_pDoc-&gt;ColorSet(POLYLINECOLOR_BACKGROUND, clrBack); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoFigure::get_LineColor(void) <br>    { <br>    return m_pDoc-&gt;ColorGet(POLYLINECOLOR_LINE); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_LineColor(long clrLine) <br>    { <br>    m_pDoc-&gt;ColorSet(POLYLINECOLOR_LINE, clrLine); <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoFigure::LineStyle <br> * Property, read-write <br> * <br> * Line style used to draw the figure <br> */ <br> <br>STDMETHODIMP_(short)CAutoFigure::get_LineStyle(void) <br>    { <br>    return m_pDoc-&gt;LineStyleGet(); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_LineStyle(short iStyle) <br>    { <br>    m_pDoc-&gt;LineStyleSet(iStyle); <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoFigure::Left, Top, Width, Height <br> * Properties, read-write <br> * <br> * Horizontal (Left) and vertical (Top) positions of the frame <br> * window from the left and top edges of the application client <br> * area; horizontal (Width) and vertical (Height) dimensions of <br> * document window.  All of these functions call our private member <br> * MoveSize, a helper function. <br> */ <br> <br>STDMETHODIMP_(long) CAutoFigure::get_Left(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETLEFT, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_Left(long x) <br>    { <br>    MoveSize(MOVESIZEACTION_LEFT, x, 0, 0, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoFigure::get_Top(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETTOP, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_Top(long y) <br>    { <br>    MoveSize(MOVESIZEACTION_TOP, 0, y, 0, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoFigure::get_Width(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETWIDTH, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_Width(long cx) <br>    { <br>    MoveSize(MOVESIZEACTION_WIDTH, 0, 0, cx, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoFigure::get_Height(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETHEIGHT, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_Height(long cy) <br>    { <br>    MoveSize(MOVESIZEACTION_HEIGHT, 0, 0, 0, cy); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::Visible <br> * Properties, read-write <br> * <br> * Controls visibility of the figure window (which is hidden by <br> * default when created through automation). <br> */ <br> <br>STDMETHODIMP_(VARIANT_BOOL)  CAutoFigure::get_Visible(void) <br>    { <br>    return (VARIANT_BOOL)IsWindowVisible(m_pDoc-&gt;Window()); <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::put_Visible(VARIANT_BOOL fShow) <br>    { <br>    ShowWindow(m_pDoc-&gt;Window(), fShow ? SW_SHOW : SW_HIDE); <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoFigure::Activate <br> * Method <br> * <br> * Activate this window, that is, bring it to the foreground <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::Activate(void) <br>    { <br>    HWND        hWndDoc; <br> <br>    hWndDoc=m_pDoc-&gt;Window(); <br>    SendMessage(GetParent(hWndDoc), WM_MDIACTIVATE <br>        , (WPARAM)hWndDoc, 0L); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::Close <br> * Method <br> * <br> * Closes this document. <br> * <br> * Parameters (optional) <br> *  fSaveChanges        BOOL that indicates if we're to save <br> *                      changes or not.  If not, then we just nuke <br> *                      the figure. <br> *  bstrPath            BSTR with the filename into which to save <br> *                      the figure if fSaveChanges is TRUE.  Note that <br> *                      this overrides any other pathname we are <br> *                      already using. <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::Close(VARIANT varSave <br>    , VARIANT varPath) <br>    { <br>    //If we got varSave and it's TRUE, then save <br>    if (VT_ERROR!=varSave.vt &amp;&amp; varSave.boolVal) <br>        { <br>        /* <br>         * If we got a filename, call SaveAs.  Otherwise <br>         * call Save.  If we don't have a filename for <br>         * Save, then Save just fails and we don't have <br>         * to care. <br>         */ <br>        if (VT_ERROR!=varPath.vt) <br>            SaveAs(varPath.bstrVal); <br>        else <br>            Save(); <br>        } <br> <br>    //Hiding the document first suppresses any UI on closure. <br>    put_Visible(FALSE); <br>    SendMessage(m_pDoc-&gt;Window(), WM_CLOSE, 0, 0L); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::RevertToSaved <br> * Method <br> * <br> * Reloads the contents of the document from the saved state. <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::RevertToSaved(void) <br>    { <br>    //Can't do this if we don't have a file <br>    if ((TCHAR)0==m_pDoc-&gt;m_szFile[0]) <br>        return; <br> <br>    /* <br>     * Since we "open" a document by loading it and closing <br>     * it, then we can just "re-open" it with Load again. <br>     */ <br>    m_pDoc-&gt;Load(FALSE, m_pDoc-&gt;m_szFile); <br> <br>    /* <br>     * Load set the document as dirt when loading from a file <br>     * in this manner (the behavior of Import).  But this actually <br>     * makes the file clean, so we change the dirty flag here. <br>     */ <br>    m_pDoc-&gt;FDirtySet(FALSE); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::Save <br> * Method <br> * <br> * Saves the document to a known file if one exists. <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::Save(void) <br>    { <br>    if ((TCHAR)0==m_pDoc-&gt;m_szFile[0]) <br>        return; <br> <br>    m_pDoc-&gt;Save(0, (LPTSTR)NULL); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::SaveAs <br> * Method <br> * <br> * Saves the current figure to a new file. <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::SaveAs(BSTR bstrPath) <br>    { <br>    if (NULL==bstrPath) <br>        return; <br> <br>    //This also renames the document <br>   #ifdef WIN32ANSI <br>    char        szTemp[512]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrPath, -1, szTemp <br>        , 512, NULL, NULL); <br>    m_pDoc-&gt;Save(0, szTemp); <br>   #else <br>    m_pDoc-&gt;Save(0, bstrPath); <br>   #endif <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::Import <br> * Method <br> * <br> * Initializes the figure from the contents of a file <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::Import(BSTR bstrImportPath) <br>    { <br>    if (NULL==bstrImportPath) <br>        return; <br> <br>    /* <br>     * Like we have for RevertToSaved, we can just "open" <br>     * this file and the new information becomes current. <br>     */ <br>   #ifdef WIN32ANSI <br>    char        szTemp[512]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrImportPath, -1 <br>        , szTemp, 512, NULL, NULL); <br>    m_pDoc-&gt;Load(FALSE, szTemp); <br>   #else <br>    m_pDoc-&gt;Load(FALSE, bstrImportPath); <br>   #endif <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::Copy <br> * CAutoFigure::Cut <br> * CAutoFigure::Paste <br> * Methods <br> * <br> * Perform clipboard operations <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::Copy(void) <br>    { <br>    m_pDoc-&gt;Clip(m_pDoc-&gt;m_pFR-&gt;Window(), FALSE); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::Cut(void) <br>    { <br>    m_pDoc-&gt;Clip(m_pDoc-&gt;m_pFR-&gt;Window(), TRUE); <br>    return; <br>    } <br> <br>STDMETHODIMP_(void) CAutoFigure::Paste(void) <br>    { <br>    if (m_pDoc-&gt;FQueryPaste()) <br>        m_pDoc-&gt;Paste(m_pDoc-&gt;m_pFR-&gt;Window()); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoFigure::AddPoint <br> * Method <br> * <br> * Adds a new point, expressed on a 0-32767 scale, to the figure. <br> */ <br> <br>STDMETHODIMP_(VARIANT_BOOL) CAutoFigure::AddPoint(short x, short y) <br>    { <br>    RECT        rc; <br>    POINTS      pt; <br>    HWND        hWndPL; <br> <br>    /* <br>     * This is the only semi-tricky method to implement here because <br>     * normally this processing is done inside the Polyline's <br>     * WM_LBUTTONDOWN.  In order to get the same behavior, we'll <br>     * just send the same message to it.  However, we have to <br>     * convert from a 0-32767 range to a window coordinate range <br>     * which is nicely handled by CPolyline::PointScale (the only <br>     * small modification to CPolyline I had to make was to make <br>     * PointScale public instead of private). <br>     * <br>     * This is a non-invasive way to add Automation support. <br>     * The invasive way would require a change to the CPolyline <br>     * class and it's window procedure so both this function <br>     * and the WM_LBUTTONDOWN handling called the same function <br>     * with 0-32767 scaled points. <br>     */ <br> <br>    //See if we can add any more <br>    if (CPOLYLINEPOINTS==get_NumberOfPoints()) <br>        return FALSE; <br> <br>    hWndPL=m_pDoc-&gt;m_pPL-&gt;Window(); <br>    GetClientRect(hWndPL, &amp;rc); <br>    SETPOINT(pt, x, y); <br>    m_pDoc-&gt;m_pPL-&gt;PointScale(&amp;rc, &amp;pt, TRUE); <br>    SendMessage(hWndPL, WM_LBUTTONDOWN, 0, MAKELPARAM(pt.x, pt.y)); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigure::RemovePoint <br> * Method <br> * <br> * Removes the last point added to a figure <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigure::RemovePoint(void) <br>    { <br>    m_pDoc-&gt;Undo(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoFigure::MoveSize <br> * <br> * Purpose: <br> *  Helper function for the Left, Top, Width, and Height properties <br> *  that centralizes calls to GetWindowRect and SetWindowPos, <br> *  reducing overall code somewhat. <br> * <br> * Parameters: <br> *  iAction         MOVESIZEACTION enum value to indicate what <br> *                  type of moving/sizing to perform <br> *  x, y            long position coordinates;  x is only meaningful <br> *                  with MOVESIZEACTION_LEFT, y only with _TOP <br> *  cx, cy          long extents;  cx is only meaningful <br> *                  with MOVESIZEACTION_WIDTH, cy only with _HEIGHT <br> * <br> * Return Value: <br> *  long            The current x, y, cx, or cy value depending on <br> *                  iAction being _GETLEFT, _GETTOP, _GETWIDTH, or <br> *                  _GETHEIGHT. <br> */ <br> <br>long CAutoFigure::MoveSize(MOVESIZEACTION iAction, long x, long y <br>    , long cx, long cy) <br>    { <br>    RECT        rc; <br>    POINT       pt1, pt2; <br>    long        x1, y1, cx1, cy1; <br>    UINT        uFlags; <br> <br>    GetWindowRect(m_pDoc-&gt;Window(), &amp;rc); <br>    SETPOINT(pt1, rc.left, rc.top); <br>    ScreenToClient(GetParent(m_pDoc-&gt;Window()), &amp;pt1); <br>    SETPOINT(pt2, rc.right, rc.bottom); <br>    ScreenToClient(GetParent(m_pDoc-&gt;Window()), &amp;pt2); <br> <br>    //By default we'll do nothing <br>    x1=pt1.x; <br>    y1=pt1.y; <br>    cx1=pt2.x-pt1.x; <br>    cy1=pt2.y-pt1.y; <br>    uFlags=0L; <br> <br>    switch (iAction) <br>        { <br>        /* <br>         * Each individual property modifies the appropriate <br>         * variable x1, y1, cx1, cy1, as well as uFlags to set <br>         * up SetWindowPos call. <br>         */ <br>        case MOVESIZEACTION_LEFT: <br>            x1=x; <br>            uFlags=SWP_NOSIZE; <br>            break; <br> <br>        case MOVESIZEACTION_TOP: <br>            y1=y; <br>            uFlags=SWP_NOSIZE; <br>            break; <br> <br>        case MOVESIZEACTION_WIDTH: <br>            cx1=cx; <br>            uFlags=SWP_NOMOVE; <br>            break; <br> <br>        case MOVESIZEACTION_HEIGHT: <br>            cy1=cy; <br>            uFlags=SWP_NOMOVE; <br>            break; <br> <br> <br>        case MOVESIZEACTION_GETLEFT: <br>            return x1; <br> <br>        case MOVESIZEACTION_GETTOP: <br>            return y1; <br> <br>        case MOVESIZEACTION_GETWIDTH: <br>            return cx1; <br> <br>        case MOVESIZEACTION_GETHEIGHT: <br>            return cy1; <br> <br>        default: <br>            return 0; <br>        } <br> <br>    //We only get here on propety changes <br>    SetWindowPos(m_pDoc-&gt;Window(), NULL <br>        , (int)x1, (int)y1, (int)cx1, (int)cy1 <br>        , SWP_NOZORDER | SWP_NOACTIVATE | uFlags); <br> <br>    //Irrelevant for property changes. <br>    return 0; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
