<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOFIGS.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context739"></a>AUTOFIGS.CPP</h2>
<pre><code>/* <br> * AUTOFIGS.CPP <br> * Cosmo Chapter 14 <br> * <br> * "Figures" collection object for Cosmo's OLE Automation support, <br> * derived from CAutoBase. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved. <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  INTERNET&gt;kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CAutoFigures::CAutoFigures <br> * CAutoFigures::~CAutoFigures <br> * <br> * Constructor Parameters: <br> *  pCL             PCCosmoClient to the client object that we use <br> *                  to implement much of this interface. <br> */ <br> <br>CAutoFigures::CAutoFigures(PCCosmoClient pCL) <br>    : CAutoBase(pCL, pCL-&gt;m_hInst, IID_ICosmoFigures <br>    , DIID_DICosmoFigures, NULL) <br>    { <br>    return; <br>    } <br> <br> <br>CAutoFigures::~CAutoFigures(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoFigures::QueryInterface <br> * CAutoFigures::AddRef <br> * CAutoFigures::Release <br> */ <br> <br>STDMETHODIMP CAutoFigures::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_ICosmoFigures==riid) <br>        *ppv=(IUnknown *)this; <br> <br>    if (IID_IDispatch==riid || m_diid==riid) <br>        *ppv=m_pImpIDispatch; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CAutoFigures::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CAutoFigures::Release(void) <br>    { <br>    //CCosmoClient deletes this object during shutdown <br>    if (0==--m_cRef) <br>        { <br>        /* <br>         * Note:  This early release is to avoid a bug in <br>         * Beta Windows NT 3.51 at the time this code was <br>         * finalized.  Technically it should be fine to leave <br>         * the Release call in CImpIDispatch::~CImpIDispatch <br>         * (see autobase.cpp), but making the call here <br>         * avoids a crash on a null pointer. <br>         */ <br>        ReleaseInterface(m_pImpIDispatch-&gt;m_pITypeInfo); <br>        } <br>    return m_cRef; <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoFigures::VTableInterface <br> * <br> * Purpose: <br> *  Returns the right vtable pointer to use when calling <br> *  ITypeInfo::Invoke (see CImpIDispatch::Invoke in AUTOBASE.CPP). <br> */ <br>void *CAutoFigures::VTableInterface(void) <br>    { <br>    return (ICosmoFigures *)this; <br>    } <br> <br> <br> <br>//The ICosmoFigures implementation <br> <br>/* <br> * CAutoFigures::Application <br> * CAutoFigures::Parent <br> * Properties, read-only <br> * <br> * The application object (CAutoApp) in which we're contained, <br> * which is stored in the frame object.  Basically we walk <br> * up from the client to the frame to it's application object <br> * to get the IDispatch we need. <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigures::get_Application(void) <br>    { <br>    PCCosmoFrame    pFR; <br> <br>    pFR=(PCCosmoFrame)m_pCL-&gt;Frame(); <br>    return pFR-&gt;AutoApp()-&gt;get_Application(); <br>    } <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigures::get_Parent(void) <br>    { <br>    return get_Application(); <br>    } <br> <br> <br> <br>/* <br> * CAutoFigures::Count <br> * Property, read-only <br> * <br> * The number of figures in this collection <br> */ <br> <br>STDMETHODIMP_(long) CAutoFigures::get_Count(void) <br>    { <br>    //This is easy:  just the number of items in the listbox. <br>    return m_pCL-&gt;m_cDoc; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigures::Item <br> * Method <br> * <br> * This is essentially an array lookup operator for the collection. <br> * Collection.Item by itself the same as the collection itself. <br> * Otherwise you can refer to the item by index or by path, which <br> * shows up in the VARIANT parameter.  We have to check the type <br> * of the variant to see if it's VT_I4 (an index) or VT_BSTR (a <br> * path) and do the right thing. <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigures::Item(VARIANT index) <br>    { <br>    IDispatch  *pIDispatch=NULL; <br>    PCCosmoDoc  pDoc; <br>    const int   cch=512; <br>    TCHAR       szPath[cch]; <br>    UINT        i; <br>    HWND        hList=m_pCL-&gt;m_hListDocs; <br> <br>    /* <br>     * Each case in this switch gets at a different pointer <br>     * and stores it in pIDispatch for return. <br>     */ <br>    switch (index.vt) <br>        { <br>        case VT_ERROR: <br>            /* <br>             * No parameters, get the "Figures" collection <br>             * IDispatch, which we can easily retrieve with <br>             * our own QueryInterface. <br>             */ <br>            QueryInterface(IID_IDispatch, (PPVOID)&amp;pIDispatch); <br>            break; <br> <br>        case VT_I4: <br>            if (LB_ERR!=SendMessage(hList, LB_GETTEXT <br>                , (int)index.lVal, (LONG)&amp;pDoc)) <br>                { <br>                //Sets pIDispatch to NULL on failure. <br>                pDoc-&gt;AutoFigure()-&gt;QueryInterface(IID_IDispatch <br>                    , (PPVOID)&amp;pIDispatch); <br>                } <br> <br>            break; <br> <br>        case VT_BSTR: <br>            /* <br>             * First we'll iterate over the pages and check <br>             * for full path matches.  If that doesn't yield <br>             * anything, then we'll see if index.bstrVal is <br>             * just a filename inside one of the paths. <br>             */ <br>            for (i=0; i &lt; m_pCL-&gt;m_cDoc; i++) <br>                { <br>                if (LB_ERR!=SendMessage(hList, LB_GETTEXT <br>                    , i, (LONG)&amp;pDoc)) <br>                    { <br>                    pDoc-&gt;FilenameGet(szPath, cch); <br> <br>                   #ifdef WIN32ANSI <br>                    char    szTemp[512]; <br> <br>                    WideCharToMultiByte(CP_ACP, 0, index.bstrVal, -1 <br>                        , szTemp, 512, NULL, NULL); <br> <br>                    if (0==lstrcmpi(szPath, szTemp)) <br>                   #else <br>                    if (0==lstrcmpi(szPath, index.bstrVal)) <br>                   #endif <br>                        { <br>                        //Found it... <br>                        pDoc-&gt;AutoFigure()-&gt;QueryInterface <br>                            (IID_IDispatch, (PPVOID)&amp;pIDispatch); <br>                        } <br>                    } <br>                } <br> <br>            //Stop now if we found anything. <br>            if (NULL!=pIDispatch) <br>                break; <br> <br>            //Now look for portions of the path <br>            for (i=0; i &lt; m_pCL-&gt;m_cDoc; i++) <br>                { <br>                if (LB_ERR!=SendMessage(hList, LB_GETTEXT <br>                    , i, (LONG)&amp;pDoc)) <br>                    { <br>                    LPTSTR  psz; <br> <br>                    pDoc-&gt;FilenameGet(szPath, cch); <br> <br>                   #ifdef WIN32ANSI <br>                    char    szTemp[512]; <br> <br>                    WideCharToMultiByte(CP_ACP, 0, index.bstrVal, -1 <br>                        , szTemp, 512, NULL, NULL); <br>                    psz=_tcsstr(szPath, szTemp); <br>                   #else <br>                    psz=_tcsstr(szPath, index.bstrVal); <br>                   #endif <br> <br>                    if (NULL!=psz) <br>                        { <br>                        //Found it... <br>                        pDoc-&gt;AutoFigure()-&gt;QueryInterface <br>                            (IID_IDispatch, (PPVOID)&amp;pIDispatch); <br>                        } <br>                    } <br>                } <br> <br> <br>            break; <br> <br>        default: <br>            return NULL; <br>        } <br> <br>    return pIDispatch; <br>    } <br> <br> <br> <br>/* <br> * CAutoFigures::Add <br> * CAutoFigures::Open <br> * Methods <br> * <br> * Creates a new figure window with an empty figure (Add) or one <br> * with the contents of a file (Open), and adds it to the collection. <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigures::Add(void) <br>    { <br>    return NewFigure(NULL); <br>    } <br> <br>STDMETHODIMP_(IDispatch *) CAutoFigures::Open(BSTR bstrPath) <br>    { <br>   #ifdef WIN32ANSI <br>    char        szTemp[512]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrPath, -1, szTemp <br>        , 512, NULL, NULL); <br>    return NewFigure(szTemp); <br>   #else <br>    return NewFigure(bstrPath); <br>   #endif <br>    } <br> <br> <br> <br>/* <br> * CAutoFigures:NewFigure <br> * <br> * Purpose: <br> *  Internal helper function to centralize figure creation for <br> *  Add and Open. <br> * <br> * Parameters: <br> *  pszPath         LPTSTR to a file to open if this is an open. <br> *                  Should be NULL for Add. <br> * <br> * Return Value: <br> *  IDispatch *     Return value for Add and Open <br> */ <br> <br>IDispatch * CAutoFigures::NewFigure(LPTSTR pszPath) <br>    { <br>    PCCosmoDoc  pDoc; <br>    IDispatch  *pIDispatch=NULL; <br>    HRESULT     hr; <br> <br>    //Try creating a hidden document, which creates the object. <br>    pDoc=(PCCosmoDoc)m_pCL-&gt;NewDocument(FALSE); <br> <br>    if (NULL==pDoc) <br>        return NULL; <br> <br>    hr=ResultFromScode(E_FAIL); <br> <br>    //Try to load the file and get the IDispatch for the document <br>    if (DOCERR_NONE==pDoc-&gt;Load(TRUE, pszPath)) <br>        { <br>        hr=pDoc-&gt;AutoFigure()-&gt;QueryInterface(IID_IDispatch <br>            , (PPVOID)&amp;pIDispatch); <br>        } <br> <br>    if (FAILED(hr)) <br>        m_pCL-&gt;CloseDocument(pDoc); <br>    else <br>        g_cObj++; <br> <br>    return pIDispatch; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CAutoFigures::Close <br> * Method <br> * <br> * Closes all figure windows in the collection <br> */ <br> <br>STDMETHODIMP_(void) CAutoFigures::Close(void) <br>    { <br>    m_pCL-&gt;QueryCloseAllDocuments(TRUE, FALSE); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CAutoFigures::_NewEnum <br> * Method <br> * <br> * Creates and returns an enumerator of the current list of <br> * figures in this collection. <br> */ <br> <br>STDMETHODIMP_(IUnknown *) CAutoFigures::_NewEnum(void) <br>    { <br>    PCEnumFigures   pNew=NULL; <br>    BOOL            fRet=TRUE; <br> <br>    pNew=new CEnumFigures(m_pCL-&gt;Instance()); <br> <br>    if (NULL!=pNew) <br>        { <br>        if (!pNew-&gt;Init(m_pCL-&gt;m_hListDocs, FALSE)) <br>            { <br>            delete pNew; <br>            pNew=NULL; <br>            } <br>        else <br>            pNew-&gt;AddRef(); <br>        } <br> <br>    return (IUnknown *)pNew; <br>    } <br> <br> <br> <br> <br>//CEnumFigures implementation of IEnumVARIANT <br> <br> <br>/* <br> * CEnumFigures::CEnumFigures <br> * CEnumFigures::~CEnumFigures <br> * <br> * Parameters (Constructor): <br> *  hInst           HINSTANCE of the application. <br> */ <br> <br>CEnumFigures::CEnumFigures(HINSTANCE hInst) <br>    { <br>    m_cRef=0; <br>    m_hList=NULL; <br>    m_hInst=hInst; <br>    m_iCur=0; <br>    m_cItems=0; <br>    return; <br>    } <br> <br> <br>CEnumFigures::~CEnumFigures(void) <br>    { <br>    if (NULL!=m_hList) <br>        DestroyWindow(m_hList); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CEnumFigures::Init <br> * <br> * Purpose: <br> *  Initializes the enumeration with any operations that might fail. <br> * <br> * Parameters: <br> *  hListPDoc       HWND of the listbox containing the current <br> *                  set of document pointers. <br> *  fClone          BOOL indicating if this is a clone creation <br> *                  in which case hListPDoc already has what we want <br> *                  and we can just copy it directly. <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, <br> *                  FALSE otherwise. <br> */ <br>BOOL CEnumFigures::Init(HWND hListPDoc, BOOL fClone) <br>    { <br>    UINT        i; <br>    UINT        cDoc; <br>    PCDocument  pDoc; <br> <br>    //Create our own list <br>    m_hList=CreateWindow(TEXT("listbox"), TEXT("EnumList") <br>        , WS_POPUP | LBS_OWNERDRAWFIXED, 0, 0, 100, 100 <br>        , HWND_DESKTOP, NULL, m_hInst, NULL); <br> <br>    if (NULL==m_hList) <br>        return FALSE; <br> <br>    /* <br>     * An enumeration should not be attached to any sort of <br>     * dynamic list, so we have to initialize our own list here. <br>     * Furthermore, the hList we get here has document object <br>     * pointers which could possibly become invalid and we have <br>     * no way of knowing it.  So we take each pointer and copy <br>     * the window handle of that document into our own list.  If <br>     * the window is destroyed, then we have a way of checking <br>     * that condition and failing to return a valid pointer <br>     * in other partsof this enumerator. <br>     */ <br> <br>    cDoc=(UINT)SendMessage(hListPDoc, LB_GETCOUNT, 0, 0L); <br> <br>    for (i=0; i &lt; cDoc; i++) <br>        { <br>        if (LB_ERR!=SendMessage(hListPDoc, LB_GETTEXT, i <br>            , (LONG)&amp;pDoc)) <br>            { <br>            HWND    hWndDoc; <br> <br>            //When cloning we have the window handle already. <br>            if (fClone) <br>                hWndDoc=(HWND)(UINT)(LONG)pDoc; <br>            else <br>                hWndDoc=pDoc-&gt;Window(); <br> <br>            if (LB_ERR!=SendMessage(m_hList, LB_ADDSTRING, 0 <br>                , (LONG)(UINT)hWndDoc)) <br>                m_cItems++; <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CEnumFigures::QueryInterface <br> * CEnumFigures::AddRef <br> * CEnumFigures::Release <br> */ <br> <br>STDMETHODIMP CEnumFigures::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IEnumVARIANT==riid) <br>        *ppv=this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CEnumFigures::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CEnumFigures::Release(void) <br>    { <br>    ULONG       cRefT; <br> <br>    cRefT=--m_cRef; <br> <br>    if (0L==m_cRef) <br>        delete this; <br> <br>    return cRefT; <br>    } <br> <br> <br>/* <br> * CEnumFigures::Next <br> * CEnumFigures::Skip <br> * CEnumFigures::Reset <br> * CEnumFigures::Clone <br> * <br> * Standard enumerator members for IEnumVARIANT <br> */ <br> <br>STDMETHODIMP CEnumFigures::Next(ULONG cVar, VARIANT *pVar <br>    , ULONG *pulVar) <br>    { <br>    ULONG       cReturn=0L; <br>    PCCosmoDoc  pDoc; <br>    HRESULT     hr; <br>    void       *pv; <br>    LONG        l; <br> <br>    if (NULL==pulVar) <br>        { <br>        if (1L!=cVar) <br>            return ResultFromScode(E_POINTER); <br>        } <br>    else <br>        *pulVar=0L; <br> <br>    if (NULL==pVar || m_iCur &gt;= m_cItems) <br>        return ResultFromScode(S_FALSE); <br> <br>    while (m_iCur &lt; m_cItems &amp;&amp; cVar &gt; 0) <br>        { <br>        if (LB_ERR==SendMessage(m_hList, LB_GETTEXT, (UINT)m_iCur++ <br>            , (LONG)&amp;l)) <br>            continue; <br> <br>        /* <br>         * Try getting the document pointer.  If this fails <br>         * then the window is invalid (document is destroyed) <br>         * so remove it from the list for future enumerations. <br>         */ <br>        pDoc=(PCCosmoDoc)SendMessage((HWND)(UINT)l <br>            , DOCM_PDOCUMENT, 0, 0L); <br> <br>        if (NULL==pDoc) <br>            { <br>            SendMessage(m_hList, LB_DELETESTRING, (UINT)--m_iCur, 0L); <br>            continue; <br>            } <br> <br>        hr=pDoc-&gt;AutoFigure()-&gt;QueryInterface(IID_IDispatch, &amp;pv); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            *pVar-&gt;ppdispVal=(IDispatch *)pv; <br>            pVar++; <br>            cReturn++; <br>            cVar--; <br>            } <br>        } <br> <br> <br>    if (NULL!=pulVar) <br>        *pulVar=cReturn; <br> <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumFigures::Skip(ULONG cSkip) <br>    { <br>    if ((m_iCur+cSkip) &gt;= m_cItems) <br>        return ResultFromScode(S_FALSE); <br> <br>    m_iCur+=cSkip; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumFigures::Reset(void) <br>    { <br>    m_iCur=0; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumFigures::Clone(LPENUMVARIANT *ppEnum) <br>    { <br>    PCEnumFigures   pNew; <br> <br>    *ppEnum=NULL; <br> <br>    pNew=new CEnumFigures(m_hInst); <br> <br>    if (NULL!=pNew) <br>        { <br>        if (!pNew-&gt;Init(m_hList, TRUE)) <br>            { <br>            delete pNew; <br>            pNew=NULL; <br>            } <br>        else <br>            pNew-&gt;AddRef(); <br>        } <br> <br>    *ppEnum=(IEnumVARIANT *)pNew; <br>    return (NULL!=pNew) ? NOERROR : ResultFromScode(E_OUTOFMEMORY); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
