<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOAPP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context736"></a>AUTOAPP.CPP</h2>
<pre><code>/* <br> * AUTOAPP.CPP <br> * Cosmo Chapter 14 <br> * <br> * "Application" object for Cosmo's OLE Automation support, based <br> * on CAutoBase which handles the type information and IDispatch <br> * part of the object.  What is here are the specific properties <br> * and methods for the "Application" object. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Right Reserved. <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  INTERNET&gt;kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CAutoApp::CAutoApp <br> * <br> * Constructor Parameters: <br> *  pFR             PCCosmoFrame to the frame object that we use <br> *                  to implement much of this interface. <br> */ <br> <br>CAutoApp::CAutoApp(PCCosmoFrame pFR) <br>    : CAutoBase(pFR, pFR-&gt;m_hInst, IID_ICosmoApplication <br>    , DIID_DICosmoApplication, ObjectDestroyed) <br>    { <br>    m_fQuitCalled=FALSE; <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoApp::QueryInterface <br> * CAutoApp::AddRef <br> * CAutoApp::Release <br> */ <br> <br>STDMETHODIMP CAutoApp::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_ICosmoApplication==riid) <br>        *ppv=(IUnknown *)this; <br> <br>    if (IID_IDispatch==riid || m_diid==riid) <br>        *ppv=m_pImpIDispatch; <br> <br>    if (IID_IExternalConnection==riid) <br>        *ppv=m_pImpIExtConn; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CAutoApp::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CAutoApp::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    if (!m_fQuitCalled &amp;&amp; NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    delete this; <br>    return 0L; <br>    } <br> <br> <br>/* <br> * CAutoApp::VTableInterface <br> * <br> * Purpose: <br> *  Returns the right vtable pointer to use when calling <br> *  ITypeInfo::Invoke (see CImpIDispatch::Invoke in AUTOBASE.CPP). <br> */ <br> <br>void *CAutoApp::VTableInterface(void) <br>    { <br>    return (ICosmoApplication *)this; <br>    } <br> <br> <br>//All that follows is the ICosmoApplication implementation <br> <br>/* <br> * CAutoApp::Application <br> * Property, read-only <br> * <br> * Returns our own IDispatch for use with DISPID_VALUE. <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoApp::get_Application(void) <br>    { <br>    void       *pv; <br> <br>    //This will set pv to NULL on failure <br>    QueryInterface(IID_IDispatch, &amp;pv); <br>    return (IDispatch *)pv; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::ActiveFigure <br> * Property, read-only <br> * <br> * Returns the active document's IDispatch <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoApp::get_ActiveFigure(void) <br>    { <br>    void           *pv=NULL; <br>    PCCosmoDoc      pDoc; <br>    PCAutoFigure    pFig; <br> <br>    pDoc=(PCCosmoDoc)((PCCosmoClient)m_pFR-&gt;m_pCL)-&gt;ActiveDocument(); <br> <br>    if (NULL==pDoc) <br>        return NULL; <br> <br>    pFig=pDoc-&gt;AutoFigure(); <br> <br>    if (NULL!=pFig) <br>        pFig-&gt;QueryInterface(IID_IDispatch, &amp;pv); <br> <br>    return (IDispatch *)pv; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::Caption <br> * Property, read-only <br> * <br> * Retrieve the application's caption bar <br> */ <br> <br>STDMETHODIMP_(BSTR) CAutoApp::get_Caption(void) <br>    { <br>    const int   cch=256; <br>    TCHAR       szCaption[cch]; <br> <br>    GetWindowText(m_pFR-&gt;Window(), szCaption, cch); <br> <br>   #ifdef WIN32ANSI <br>    OLECHAR     szTemp[cch]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, szCaption, -1, szTemp, cch); <br>    return SysAllocString(szTemp); <br>   #else <br>    return SysAllocString(szCaption); <br>   #endif <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoApp::Figures <br> * Property, read-only <br> * <br> * Retrieve the collection object for figures (documents) <br> */ <br> <br>STDMETHODIMP_(IDispatch *) CAutoApp::get_Figures(void) <br>    { <br>    void            *pv=NULL; <br>    PCAutoFigures    pFigs; <br> <br>    pFigs=((PCCosmoClient)m_pFR-&gt;m_pCL)-&gt;AutoFigures(); <br> <br>    if (NULL!=pFigs) <br>        pFigs-&gt;QueryInterface(IID_IDispatch, &amp;pv); <br> <br>    return (IDispatch *)pv; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::FullName, Name, Path <br> * Properties, read-only <br> * <br> * Retrieve the full pathname of the application module (FullName), <br> * just the module name (Name), or just the path (Path). <br> */ <br> <br>STDMETHODIMP_(BSTR) CAutoApp::get_FullName(void) <br>    { <br>    const int   cch=512; <br>    TCHAR       szModule[cch]; <br> <br>    GetModuleFileName(m_pFR-&gt;Instance(), szModule, cch); <br> <br>   #ifdef WIN32ANSI <br>    OLECHAR     szTemp[cch]; <br>    MultiByteToWideChar(CP_ACP, 0, szModule, -1, szTemp, cch); <br>    return SysAllocString(szTemp); <br>   #else <br>    return SysAllocString(szModule); <br>   #endif <br>    } <br> <br> <br>STDMETHODIMP_(BSTR) CAutoApp::get_Name(void) <br>    { <br>    BSTR        bstrFull=NULL; <br>    BSTR        bstrName=NULL; <br>    const int   cch=256; <br>    TCHAR       szName[256]; <br> <br>    //Get the full path <br>    bstrFull=get_FullName(); <br> <br>    if (NULL==bstrFull) <br>        return NULL; <br> <br>    //Now retrieve just the filename <br>   #ifdef WIN32ANSI <br>    char        szTemp[cch]; <br>    OLECHAR     szTempW[cch]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrFull, -1, szTemp <br>        , cch, NULL, NULL); <br>    if (0==GetFileTitle(szTemp, szName, cch)) <br>        { <br>        MultiByteToWideChar(CP_ACP, 0, szName, -1, szTempW, cch); <br>        bstrName=SysAllocString(szTempW); <br>        } <br>   #else <br>    if (0==GetFileTitle(bstrFull, szName, cch)) <br>        bstrName=SysAllocString(szName); <br>   #endif <br> <br>    SysFreeString(bstrFull); <br>    return bstrName; <br>    } <br> <br> <br>STDMETHODIMP_(BSTR) CAutoApp::get_Path(void) <br>    { <br>    BSTR        bstrFull=NULL; <br>    BSTR        bstrName=NULL; <br>    BSTR        bstrPath=NULL; <br> <br>    bstrFull=get_FullName(); <br> <br>    if (NULL==bstrFull) <br>        return NULL; <br> <br>    bstrName=get_Name(); <br> <br>    if (NULL!=bstrName) <br>        { <br>        LPOLESTR    psz; <br> <br>        /* <br>         * Find the position of bstrName in bstrFull then copy <br>         * only charaters up to that point into bstrPath. <br>         */ <br>       #ifdef WIN32ANSI <br>        psz=wcsstr(bstrFull, bstrName); <br>       #else <br>        psz=_tcsstr(bstrFull, bstrName); <br>       #endif <br> <br>        //The -1 accounts for the \ before the filename <br>        bstrPath=SysAllocStringLen(bstrFull <br>            , ((DWORD)psz-(DWORD)bstrFull)/sizeof(OLECHAR)-1); <br>        SysFreeString(bstrName); <br>        } <br> <br>    SysFreeString(bstrFull); <br>    return bstrPath; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::Left, Top, Width, Height <br> * Properties, read-write <br> * <br> * Horizontal (Left) and vertical (Top) positions of the frame <br> * window from the left and top edges of the screen; horizontal <br> * (Width) and  vertical (Height) dimensions of the frame <br> * window.  All of these functions call our private member <br> * MoveSize, a helper function. <br> */ <br> <br>STDMETHODIMP_(long) CAutoApp::get_Left(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETLEFT, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_Left(long x) <br>    { <br>    MoveSize(MOVESIZEACTION_LEFT, x, 0, 0, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoApp::get_Top(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETTOP, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_Top(long y) <br>    { <br>    MoveSize(MOVESIZEACTION_TOP, 0, y, 0, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoApp::get_Width(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETWIDTH, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_Width(long cx) <br>    { <br>    MoveSize(MOVESIZEACTION_WIDTH, 0, 0, cx, 0); <br>    return; <br>    } <br> <br>STDMETHODIMP_(long) CAutoApp::get_Height(void) <br>    { <br>    return MoveSize(MOVESIZEACTION_GETHEIGHT, 0, 0, 0, 0); <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_Height(long cy) <br>    { <br>    MoveSize(MOVESIZEACTION_HEIGHT, 0, 0, 0, cy); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CAutoApp::Visible <br> * Properties, read-write <br> * <br> * Controls visibility of the frame window (which is hidden by <br> * default when the application is launched for Automation. <br> */ <br> <br>STDMETHODIMP_(VARIANT_BOOL) CAutoApp::get_Visible(void) <br>    { <br>    return (VARIANT_BOOL)IsWindowVisible(m_pFR-&gt;Window()); <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_Visible(VARIANT_BOOL fShow) <br>    { <br>    ShowWindow(m_pFR-&gt;Window(), fShow ? SW_SHOW : SW_HIDE); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::StatusBar <br> * Properties, read-write <br> * <br> * Retrieve or modify the status line text. <br> * default when the application is launched for Automation. <br> */ <br> <br>STDMETHODIMP_(BSTR) CAutoApp::get_StatusBar(void) <br>    { <br>    const int   cch=256; <br>    TCHAR       szText[cch]; <br>    BSTR        bstrText=NULL; <br> <br>   #ifdef WIN32ANSI <br>    if (0!=m_pFR-&gt;StatusLine()-&gt;MessageGet(szText, cch)) <br>        { <br>        OLECHAR szTemp[cch]; <br> <br>        MultiByteToWideChar(CP_ACP, 0, szText, -1, szTemp, cch); <br>        bstrText=SysAllocString(szTemp); <br>        } <br>   #else <br>    if (0!=m_pFR-&gt;StatusLine()-&gt;MessageGet(szText, cch)) <br>        bstrText=SysAllocString(szText); <br>   #endif <br> <br>    return bstrText; <br>    } <br> <br>STDMETHODIMP_(void) CAutoApp::put_StatusBar(BSTR bstrText) <br>    { <br>    if (NULL==bstrText) <br>        return; <br> <br>   #ifdef WIN32ANSI <br>    char    szTemp[256]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, bstrText, -1, szTemp, 256 <br>        , NULL, NULL); <br>    m_pFR-&gt;StatusLine()-&gt;MessageSet(szTemp); <br>   #else <br>    m_pFR-&gt;StatusLine()-&gt;MessageSet(bstrText); <br>   #endif <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CAutoApp::Quit <br> * Method <br> * <br> * Instructs the application to terminate.  This behaves as <br> * if the user closes the app directly. <br> */ <br> <br>STDMETHODIMP_(void) CAutoApp::Quit(void) <br>    { <br>    ObjectDestroyed(); <br>    m_fQuitCalled=TRUE; <br>    return; <br>    } <br> <br> <br>/* <br> * CAutoApp::MoveSize <br> * <br> * Purpose: <br> *  Helper function for the Left, Top, Width, and Height properties <br> *  that centralizes calls to GetWindowRect and SetWindowPos, <br> *  reducing overall code somewhat. <br> * <br> * Parameters: <br> *  iAction         MOVESIZEACTION enum value to indicate what <br> *                  type of moving/sizing to perform <br> *  x, y            long position coordinates;  x is only meaningful <br> *                  with MOVESIZEACTION_LEFT, y only with _TOP <br> *  cx, cy          long extents;  cx is only meaningful <br> *                  with MOVESIZEACTION_WIDTH, cy only with _HEIGHT <br> * <br> * Return Value: <br> *  long            The current x, y, cx, or cy value depending on <br> *                  iAction being _GETLEFT, _GETTOP, _GETWIDTH, or <br> *                  _GETHEIGHT. <br> */ <br> <br>long CAutoApp::MoveSize(MOVESIZEACTION iAction, long x, long y <br>    , long cx, long cy) <br>    { <br>    RECT        rc; <br>    long        x1, y1, cx1, cy1; <br>    UINT        uFlags; <br> <br>    GetWindowRect(m_pFR-&gt;Window(), &amp;rc); <br> <br>    //By default we'll do nothing <br>    x1=rc.left; <br>    y1=rc.top; <br>    cx1=rc.right-rc.left; <br>    cy1=rc.bottom-rc.top; <br>    uFlags=0L; <br> <br>    switch (iAction) <br>        { <br>        /* <br>         * Each individual property modifies the appropriate <br>         * variable x1, y1, cx1, cy1, as well as uFlags to set <br>         * up SetWindowPos call. <br>         */ <br>        case MOVESIZEACTION_LEFT: <br>            x1=x; <br>            uFlags=SWP_NOSIZE; <br>            break; <br> <br>        case MOVESIZEACTION_TOP: <br>            y1=y; <br>            uFlags=SWP_NOSIZE; <br>            break; <br> <br>        case MOVESIZEACTION_WIDTH: <br>            cx1=cx; <br>            uFlags=SWP_NOMOVE; <br>            break; <br> <br>        case MOVESIZEACTION_HEIGHT: <br>            cy1=cy; <br>            uFlags=SWP_NOMOVE; <br>            break; <br> <br> <br>        case MOVESIZEACTION_GETLEFT: <br>            return rc.left; <br> <br>        case MOVESIZEACTION_GETTOP: <br>            return rc.top; <br> <br>        case MOVESIZEACTION_GETWIDTH: <br>            return rc.right-rc.left; <br> <br>        case MOVESIZEACTION_GETHEIGHT: <br>            return rc.bottom-rc.top; <br> <br>        default: <br>            return 0; <br>        } <br> <br>    //We only get here on propety changes <br>    SetWindowPos(m_pFR-&gt;Window(), NULL <br>        , (int)x1, (int)y1, (int)cx1, (int)cy1 <br>        , SWP_NOZORDER | SWP_NOACTIVATE | uFlags); <br> <br>    //Irrelevant for property changes. <br>    return 0; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
