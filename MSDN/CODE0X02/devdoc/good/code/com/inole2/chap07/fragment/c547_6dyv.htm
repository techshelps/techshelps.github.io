<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRAGMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context547"></a>FRAGMENT.CPP</h2>
<pre><code>/* <br> * FRAGMENT.CPP <br> * Fragmented File Generator Chapter 7 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "fragment.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  This application does nothing <br> *  more than pump out garbage into storage as a framented file test. <br> *  It has no UI so does not process any messages. <br> * <br> *  The file created is always called FRAGMENT.BIN. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    CFragment  *pFrag; <br> <br>    pFrag=new CFragment(); <br> <br>    if (NULL==pFrag) <br>        return -1; <br> <br>    if (pFrag-&gt;Init()) <br>        { <br>        if (pFrag-&gt;AllocCharArrays()) <br>            { <br>            if (pFrag-&gt;CreateFragmentedFile()) <br>                { <br>                pFrag-&gt;FreeSpaceInFile(); <br>                pFrag-&gt;DefragmentFile(); <br>                } <br>            } <br>        } <br> <br>    delete pFrag; <br>    return 0; <br>    } <br> <br> <br> <br> <br>/* <br> * CFragment::CFragment <br> * CFragment::~CFragment <br> * <br> * Constructor and Destructor for this application.  The <br> * constructor does not have any parameters. <br> */ <br> <br>CFragment::CFragment(void) <br>    { <br>    m_fInitialized=FALSE; <br>    m_pIMalloc=NULL; <br>    m_pch=NULL; <br>    m_pszScratch=NULL; <br> <br>    m_cch=256; <br>    m_cStreams=CSTREAMS; <br> <br>    lstrcpy(m_szFile, TEXT("FRAGMENT.BIN")); <br>    m_hCur=NULL; <br> <br>    return; <br>    } <br> <br> <br>CFragment::~CFragment(void) <br>    { <br>    if (NULL!=m_hCur) <br>        SetCursor(m_hCur); <br> <br>    if (NULL!=m_pIMalloc) <br>        { <br>        if (NULL!=m_pch) <br>            m_pIMalloc-&gt;Free(m_pch); <br> <br>        if (NULL!=m_pszScratch) <br>            m_pIMalloc-&gt;Free(m_pszScratch); <br> <br>        m_pIMalloc-&gt;Release(); <br>        } <br> <br>    if (m_fInitialized) <br>        CoUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFragment::Init <br> * <br> * Purpose: <br> *  Calls CoInitialize and CoGetMalloc saving the task allocator. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization worked, FALSE otherwise. <br> */ <br> <br>BOOL CFragment::Init(void) <br>    { <br>    CHECKVER_COM; <br> <br>    if (FAILED(CoInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;m_pIMalloc))) <br>        return FALSE; <br> <br>    m_pszScratch=(TCHAR *)m_pIMalloc-&gt;Alloc(1024*sizeof(TCHAR)); <br> <br>    if (NULL==m_pszScratch) <br>        return FALSE; <br> <br>    m_hCur=SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT))); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CFragmet::AllocCharArrays <br> * <br> * Purpose: <br> *  Allocates CSTREAMS * 256 characters and initializes each 256 <br> *  charaters with 'A', 'B', etc.  (ANSI characters, not UNICODE). <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the memory was allocated and initialized <br> *                  otherwise FALSE. <br> */ <br> <br>BOOL CFragment::AllocCharArrays(void) <br>    { <br>    char *      pchT; <br>    UINT        i, j; <br> <br>    if (NULL==m_pIMalloc) <br>        return FALSE; <br> <br>    m_pch=(char *)m_pIMalloc-&gt;Alloc(m_cch*m_cStreams); <br> <br>    if (NULL==m_pch) <br>        return FALSE; <br> <br>    pchT=m_pch; <br> <br>    //Initialize Character Arrays <br>    for (i=0; i &lt; m_cStreams; i++) <br>        { <br>        char    ch=i+'A'; <br> <br>        for (j=0; j &lt; m_cch; j++) <br>            *pchT++=ch; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CFragment::CreateFragmentedFile <br> * <br> * Purpose: <br> *  Creates a file with numerous streams that we can fragment. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file was created, FALSE otherwise. <br> */ <br> <br>BOOL CFragment::CreateFragmentedFile(void) <br>    { <br>    HRESULT     hr; <br>    IStorage   *pIStorage; <br>    IStream    *rgpIStream[CSTREAMS]; <br>    UINT        i, j; <br> <br>    //Create the file to build <br>    hr=StgCreateDocfile(m_szFile, STGM_DIRECT | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE | STGM_CREATE, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    //Create streams in this file. <br>    for (i=0; i &lt; m_cStreams; i++) <br>        StreamCreate(pIStorage, i, &amp;rgpIStream[i]); <br> <br>    /* <br>     * Now fill "Stream A" with A's, Stream B with B's, etc., <br>     * doing it m_cch characters at a time, a total of 20 times for <br>     * each stream.  This will allow us to examine the binary <br>     * format of the file before and after defragmentation. <br>     * <br>     * This will create a number of streams that are internally <br>     * fragmented in the file. <br>     * <br>     * Some streams may be invalid, but checks for NULL below <br>     * avoid problems in such cases. <br>     */ <br> <br>    for (j=0; j &lt; 20; j++) <br>        { <br>        for (i=0; i &lt; m_cStreams; i++) <br>            { <br>            if (NULL!=rgpIStream[i]) <br>                rgpIStream[i]-&gt;Write((m_pch+(m_cch*i)), m_cch, NULL); <br>            } <br>        } <br> <br>    //Close all the streams <br>    for (i=0; i &lt; m_cStreams; i++) <br>        { <br>        if (NULL!=rgpIStream[i]) <br>            rgpIStream[i]-&gt;Release(); <br>        } <br> <br>    //Close the IStorage to close the file. <br>    pIStorage-&gt;Release(); <br> <br>    Message(TEXT("%s created.")); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFragment::FreeSpaceInFile <br> * <br> * Purpose: <br> *  Deletes some of the streams in the previously created file. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFragment::FreeSpaceInFile(void) <br>    { <br>    HRESULT     hr; <br>    IStorage   *pIStorage; <br> <br>    //Reopen the storage <br>    hr=StgOpenStorage(m_szFile, NULL, STGM_DIRECT | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE, NULL, 0, &amp;pIStorage); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        /* <br>         * Now create some extra space in the file by destroying <br>         * streams C E G H J M N T X. <br>         */ <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream C")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream E")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream G")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream H")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream J")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream M")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream N")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream T")); <br>        pIStorage-&gt;DestroyElement(OLETEXT("Stream X")); <br> <br>        /* <br>         * The file size will not have changed here, but there <br>         * will be unused space. <br>         */ <br> <br>        pIStorage-&gt;Release(); <br>        Message(TEXT("Space has been freed in %s.")); <br>        } <br>    else <br>        Message(TEXT("Could not reopen %s.")); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFragment::DefragmentFile <br> * <br> * Purpose: <br> *  Does an IStorage::CopyTo from the existing file to a temp <br> *  file then copies that temp file as binary back to the source <br> *  file. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFragment::DefragmentFile(void) <br>    { <br>    HRESULT     hr; <br>    IStorage   *pIStorageOld; <br>    IStorage   *pIStorageNew; <br>    STATSTG     st; <br>   #ifndef WIN32 <br>    OFSTRUCT    of; <br>   #endif <br>    TCHAR       szTemp[MAX_PATH]; <br> <br>    /* <br>     * Create a temporary file.  We don't use DELETEONRELEASE <br>     * in case we have to save it when copying over the old <br>     * file fails. <br>     */ <br>    hr=StgCreateDocfile(NULL, STGM_CREATE | STGM_READWRITE <br>        | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorageNew); <br> <br>    if (FAILED(hr)) <br>        { <br>        Message(TEXT("Failed to create temp file to copy %s.")); <br>        return; <br>        } <br> <br>    //Open the existing file as read-only <br>    hr=StgOpenStorage(m_szFile, NULL, STGM_DIRECT | STGM_READ <br>        | STGM_SHARE_DENY_WRITE, NULL, 0, &amp;pIStorageOld); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIStorageNew-&gt;Release(); <br>        Message(TEXT("Failed to open %s for CopyTo.")); <br>        return; <br>        } <br> <br>    /* <br>     * Compress with CopyTo.  Since the temp is opened in <br>     * direct mode, changes are immediate. <br>     */ <br>    hr=pIStorageOld-&gt;CopyTo(NULL, NULL, NULL, pIStorageNew); <br>    pIStorageOld-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIStorageNew-&gt;Release(); <br>        Message(TEXT("IStorage::CopyTo from %s failed.")); <br>        return; <br>        } <br> <br>    //Get the name of the temp file. <br>    pIStorageNew-&gt;Stat(&amp;st, 0); <br>    pIStorageNew-&gt;Release(); <br> <br>    //Delete the old file before copying back to insure truncation <br>   #ifdef WIN32 <br>    DeleteFile(m_szFile); <br> <br>   #ifdef WIN32ANSI <br>    WideCharToMultiByte(CP_ACP, 0, st.pwcsName, -1, szTemp <br>        , MAX_PATH, NULL, NULL); <br>   #else <br>    lstrcpy(szTemp, st.pwcsName); <br>   #endif <br> <br>    MoveFile(szTemp, m_szFile); <br>   #else <br>    OpenFile(m_szFile, &amp;of, OF_DELETE); <br>    MyMoveFile(st.pwcsName, m_szFile); <br>   #endif <br> <br>    Message(TEXT("Defragementation complete on %s.")); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFragment::StreamCreate <br> * <br> * Purpose: <br> *  Creates a stream with a given identifier in a given IStorage. <br> * <br> * Parameters: <br> *  pIStorage       IStorage * in which to create the stream <br> *  i               UINT ID of the stream <br> *  ppIStream       IStream ** in which to return the stream. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFragment::StreamCreate(IStorage *pIStorage, UINT i <br>    , IStream ** ppIStream) <br>    { <br>    OLECHAR  szName[40]; <br> <br>    //Name is "Stream A", "Stream B", etc. <br>   #ifdef WIN32ANSI <br>    char        szTemp[40]; <br> <br>    wsprintf(szTemp, "Stream %c", i+'A'); <br>    MultiByteToWideChar(CP_ACP, 0, szTemp, -1, szName, 40); <br>   #else <br>    wsprintf(szName, TEXT("Stream %c"), i+'A'); <br>   #endif <br> <br>    pIStorage-&gt;CreateStream(szName, STGM_DIRECT <br>        | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE <br>        , 0, 0, ppIStream); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CFragment::Message <br> * <br> * Purpose: <br> *  Outputs a message with the filename included. <br> * <br> * Parameters: <br> *  pszFmt          LPTSTR to a wsprintf format string. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFragment::Message(LPTSTR pszFmt) <br>    { <br>    wsprintf(m_pszScratch, pszFmt, m_szFile); <br>    MessageBox(NULL, m_pszScratch, TEXT("Fragmenter"), MB_OK); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>#ifndef WIN32 <br>/* <br> * CFragment::MyMoveFile <br> * <br> * Purpose: <br> *  Low-level MoveFile function for 16-bit Windows that lack <br> *  the MoveFile[Ex] API. <br> * <br> * Parameters: <br> *  pszSrc          char * of the source filename, <br> *  pszDst          char * of the destination filename, <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFragment::MyMoveFile(char *pszSrc, char *pszDst) <br>    { <br>    HFILE       hFile1, hFile2; <br>    ULONG       cbCopy; <br>    const UINT  cbBlock=4096; <br>    LPBYTE      pb; <br>    OFSTRUCT    of; <br> <br>    //Do a binary copy between files. <br>    hFile1=_lopen(pszSrc, READ | OF_SHARE_EXCLUSIVE); <br> <br>    if (HFILE_ERROR==hFile1) <br>        return; <br> <br>    //Recreate this file before copying. <br>    hFile2=_lcreat(m_szFile, 0); <br> <br>    if (HFILE_ERROR==hFile2) <br>        { <br>        _lclose(hFile1); <br>        return; <br>        } <br> <br>    //Seek to end of source file to find length <br>    cbCopy=_llseek(hFile1, 0, 2); <br>    _llseek(hFile1, 0, 0); <br> <br>    pb=(LPBYTE)m_pIMalloc-&gt;Alloc(cbBlock); <br> <br>    if (NULL!=pb) <br>        { <br>        //Copy in 4K increments <br>        while (cbCopy &gt;= (ULONG)cbBlock) <br>            { <br>            _lread(hFile1,  pb, cbBlock); <br>            _lwrite(hFile2, pb, cbBlock); <br>            cbCopy-=4096; <br>            } <br> <br>        _lread(hFile1,  pb, (UINT)cbCopy); <br>        _lwrite(hFile2, pb, (UINT)cbCopy); <br>        m_pIMalloc-&gt;Free(pb); <br>        } <br> <br>    _lclose(hFile2); <br>    _lclose(hFile1); <br> <br>    //Delete the temp file <br>    OpenFile(pszSrc, &amp;of, OF_DELETE); <br>    return; <br>    } <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
