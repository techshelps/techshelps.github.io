<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ANSI.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1085"></a>ANSI.CPP</h2>
<pre><code>/* <br> * ANSI.CPP <br> * <br> * Utility functions for dealing with OLE APIs that need <br> * Unicode strings.  These are only defined when UNICODE <br> * is not defined, otherwise INOLE.H simply redefines them <br> * as macro pass-throughs to the original OLE functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define NOMACROREDIRECT <br>#include "inoledll.h" <br> <br> <br>#ifdef WIN32ANSI <br> <br>/* <br> * ConvertStringAlloc <br> * <br> * Purpose: <br> *  Allocates memory using the task allocator.  Used internally <br> *  in this file. <br> */ <br> <br>HRESULT ConvertStringAlloc(ULONG ulSize, void **ppv) <br>    { <br>    HRESULT     hr; <br>    IMalloc    *pIMalloc; <br> <br>    if (NULL==ppv) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    hr=CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    *ppv=pIMalloc-&gt;Alloc(ulSize); <br>    pIMalloc-&gt;Release(); <br> <br>    return (NULL==*ppv) ? ResultFromScode(E_OUTOFMEMORY) : NOERROR; <br>    } <br> <br> <br> <br>/* <br> * INOLE_ConvertStringToANSI <br> * <br> * Purpose: <br> *  Converts the string in pszW to ANSI, allocating the <br> *  output buffer pointed to by *ppszA on output.  The <br> *  string is allocated with COM's task allocator. <br> * <br> */ <br> <br>STDAPI INOLE_ConvertStringToANSI(LPCWSTR pszW, LPSTR *ppszA) <br>    { <br>    ULONG   cch; <br>    HRESULT hr; <br> <br>    //If input is NULL then just return the same <br>    if (NULL==pszW) <br>        { <br>        *ppszA=NULL; <br>        return NOERROR; <br>        } <br> <br>    //This calculates the number of MBCS characters we'll need <br>    cch=1+WideCharToMultiByte(CP_ACP, 0, pszW, -1, NULL, 0, NULL, NULL); <br> <br>    hr=ConvertStringAlloc(cch, (void **)ppszA); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    WideCharToMultiByte(CP_ACP, 0, pszW, -1, *ppszA, cch, NULL, NULL); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * INOLE_StringFromCLSID <br> */ <br> <br>STDAPI INOLE_StringFromCLSID(REFCLSID clsID, LPSTR *ppszCLSID) <br>    { <br>    LPWSTR  psz; <br>    HRESULT hr; <br> <br>    if (NULL==ppszCLSID) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    hr=StringFromCLSID(clsID, &amp;psz); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=INOLE_ConvertStringToANSI(psz, ppszCLSID); <br>    CoTaskMemFree((void *)psz); <br>    return hr; <br>    } <br> <br> <br> <br>/* <br> * INOLE_StringFromGUID2 <br> */ <br> <br>STDAPI INOLE_StringFromGUID2(REFGUID guid, LPSTR pszGUID, int cch) <br>    { <br>    LPSTR   psz; <br>    HRESULT hr; <br> <br>    if (NULL==pszGUID) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    hr=INOLE_StringFromCLSID(guid, &amp;psz); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    lstrcpyn(pszGUID, psz, cch); <br>    CoTaskMemFree((void *)psz); <br>    return hr; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_ProgIDFromCLSID <br> */ <br> <br>STDAPI INOLE_ProgIDFromCLSID(REFCLSID clsID, LPSTR *ppszProgID) <br>    { <br>    LPWSTR  psz; <br>    HRESULT hr; <br> <br>    if (NULL==ppszProgID) <br>return ResultFromScode(E_INVALIDARG); <br> <br>    hr=ProgIDFromCLSID(clsID, &amp;psz); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    hr=INOLE_ConvertStringToANSI(psz, ppszProgID); <br>    CoTaskMemFree(psz); <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * INOLE_ReadFmtUserTypeStg <br> * INOLE_WriteFmtUserTypeStg <br> */ <br> <br>STDAPI INOLE_ReadFmtUserTypeStg(IStorage *pIStorage <br>    , CLIPFORMAT *pcf, LPSTR *ppszUserType) <br>    { <br>    HRESULT     hr; <br>    LPOLESTR    pszUserType; <br> <br>    if (NULL==ppszUserType) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    hr=ReadFmtUserTypeStg(pIStorage, pcf, &amp;pszUserType); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    if (ppszUserType) <br>        { <br>        hr=INOLE_ConvertStringToANSI(pszUserType, ppszUserType); <br>        CoTaskMemFree(pszUserType); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br>STDAPI INOLE_WriteFmtUserTypeStg(IStorage *pIStorage, CLIPFORMAT cf <br>    , LPSTR pszUserType) <br>    { <br>    OLECHAR     szType[512]; <br>    HRESULT     hr; <br> <br>    if (NULL==pszUserType) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszUserType, -1, szType, 512); <br>    hr=WriteFmtUserTypeStg(pIStorage, cf, szType); <br> <br>    return hr; <br>    } <br> <br> <br> <br>/* <br> * INOLE_StgIsStorageFile <br> * INOLE_StgCreateDocfile <br> * INOLE_StgOpenStorage <br> */ <br> <br>STDAPI INOLE_StgIsStorageFile(LPCSTR pszName) <br>    { <br>    OLECHAR     szTemp[MAX_PATH]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszName, -1 <br>        , szTemp, MAX_PATH); <br>    return StgIsStorageFile(szTemp); <br>    } <br> <br> <br> <br>STDAPI INOLE_StgCreateDocfile(LPCSTR pszNameA, DWORD grfMode <br>    , DWORD reserved, IStorage **ppIStorage) <br>    { <br>    OLECHAR     szTemp[MAX_PATH]; <br>    LPOLESTR    pszName; <br> <br>    *ppIStorage=NULL; <br> <br>    if (NULL!=pszNameA) <br>        { <br>        MultiByteToWideChar(CP_ACP, 0, pszNameA, -1 <br>            , szTemp, MAX_PATH); <br>        pszName=szTemp; <br>        } <br>else <br>        pszName=NULL; <br> <br>    return StgCreateDocfile(pszName, grfMode, reserved <br>        , ppIStorage); <br>    } <br> <br> <br> <br>STDAPI INOLE_StgOpenStorage(LPCSTR pszNameA, IStorage *pStgPri <br>    , DWORD grfMode, SNB snbEx, DWORD reserved <br>    , IStorage * *ppIStorage) <br>    { <br>    OLECHAR   szTemp[MAX_PATH]; <br>    LPOLESTR  pszName; <br> <br>    *ppIStorage=NULL; <br> <br>    if (NULL!=pszNameA) <br>        { <br>        MultiByteToWideChar(CP_ACP, 0, pszNameA, -1 <br>            , szTemp, MAX_PATH); <br>        pszName= szTemp; <br>        } <br>else <br>        pszName=NULL; <br> <br>    return StgOpenStorage(pszName, pStgPri, grfMode, snbEx <br>        , reserved, ppIStorage); <br>    } <br> <br> <br> <br> <br>/* <br> * INOLE_CreateFileMoniker <br> * INOLE_CreateItemMoniker <br> * INOLE_MkParseDisplayName <br> */ <br> <br>STDAPI INOLE_CreateFileMoniker(LPCSTR pszPathNameA, LPMONIKER *ppmk) <br>    { <br>    OLECHAR     szTemp[MAX_PATH]; <br> <br>    if (NULL==ppmk) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    *ppmk=NULL; <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszPathNameA, -1 <br>        , szTemp, MAX_PATH); <br> <br>    return CreateFileMoniker(szTemp, ppmk); <br>    } <br> <br> <br>STDAPI INOLE_CreateItemMoniker(LPCSTR pszDelimA, LPCSTR pszItemA <br>    , LPMONIKER *ppmk) <br>    { <br>    OLECHAR     szItem[MAX_PATH];   //Some assumptions about string length <br>    OLECHAR     szDelim[20]; <br> <br>    if (NULL==ppmk) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    *ppmk=NULL; <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszItemA, -1 <br>        , szItem, MAX_PATH); <br>    MultiByteToWideChar(CP_ACP, 0, pszDelimA, -1 <br>        , szDelim, 20); <br> <br>    return CreateItemMoniker(szDelim, szItem, ppmk); <br>    } <br> <br> <br>STDAPI INOLE_MkParseDisplayName(LPBC pbc, LPCSTR pszUserNameA <br>    , ULONG *pchEaten, LPMONIKER *ppmk) <br>    { <br>    OLECHAR     szTemp[512];    //Assumption on string length <br> <br>    if (NULL==ppmk) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    *ppmk=NULL; <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszUserNameA, -1 <br>        , szTemp, 512); <br> <br>    return MkParseDisplayName(pbc, szTemp, pchEaten, ppmk); <br>    } <br> <br> <br> <br>/* <br> * INOLE_OleCreateLinkToFile <br> * INOLE_OleCreateFromFile <br> */ <br> <br>STDAPI INOLE_OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid <br>    , DWORD renderopt, LPFORMATETC lpFormatEtc <br>    , LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj) <br>    { <br>    OLECHAR     szFile[512];    //Assumption on string length <br> <br>    MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1, szFile, 512); <br>    return OleCreateLinkToFile(szFile, riid, renderopt, lpFormatEtc <br>        , pClientSite, pStg, ppvObj); <br>    } <br> <br> <br> <br>STDAPI INOLE_OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName <br>    , REFIID riid, DWORD renderopt, LPFORMATETC lpFormatEtc <br>    , LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID *ppvObj) <br>    { <br>    OLECHAR     szFile[512];    //Assumption on string length <br> <br>    MultiByteToWideChar(CP_ACP, 0, lpszFileName, -1, szFile, 512); <br>    return OleCreateFromFile(rclsid, szFile, riid, renderopt, lpFormatEtc <br>        , pClientSite, pStg, ppvObj); <br>    } <br> <br>#else <br> <br>//Do-nothing functions so we can at least export them. <br> <br>#ifndef WIN32 <br>STDAPI INOLE_ConvertStringToANSI(LPCSTR a, LPSTR *b) {return NOERROR;} <br>#else <br>STDAPI INOLE_ConvertStringToANSI(LPCWSTR a, LPSTR *b) {return NOERROR;} <br>#endif <br>STDAPI INOLE_StringFromCLSID(REFCLSID a, LPSTR *b) {return NOERROR;} <br>STDAPI INOLE_StringFromGUID2(REFGUID a, LPSTR b, int c) {return NOERROR;} <br>STDAPI INOLE_ProgIDFromCLSID(REFCLSID a, LPSTR *b) {return NOERROR;} <br> <br>STDAPI INOLE_ReadFmtUserTypeStg(IStorage *a, CLIPFORMAT *b, LPSTR *c) {return NOERROR;} <br>STDAPI INOLE_WriteFmtUserTypeStg(IStorage *a, CLIPFORMAT b, LPSTR c) {return NOERROR;} <br> <br>STDAPI INOLE_StgIsStorageFile(LPCSTR a) {return NOERROR;} <br>STDAPI INOLE_StgCreateDocfile(LPCSTR a, DWORD b, DWORD c, IStorage ** d) {return NOERROR;} <br>STDAPI INOLE_StgOpenStorage(LPCSTR a, IStorage *b, DWORD c, SNB d <br>           , DWORD e, IStorage **f) {return NOERROR;} <br> <br>STDAPI INOLE_CreateFileMoniker(LPCSTR, LPMONIKER *) {return NOERROR;} <br>STDAPI INOLE_CreateItemMoniker(LPCSTR, LPCSTR, LPMONIKER *) {return NOERROR;} <br>STDAPI INOLE_MkParseDisplayName(LPBC, LPCSTR, ULONG *, LPMONIKER *) {return NOERROR;} <br> <br>STDAPI INOLE_OleCreateLinkToFile(LPCOLESTR, REFIID, DWORD, LPFORMATETC <br>    , LPOLECLIENTSITE, LPSTORAGE, LPVOID *) {return NOERROR;} <br> <br>STDAPI INOLE_OleCreateFromFile(REFCLSID, LPCOLESTR, REFIID <br>    , DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, LPVOID *) {return NOERROR;} <br> <br> <br>#endif </code></pre>
<p>&nbsp;</p></body>
</HTML>
