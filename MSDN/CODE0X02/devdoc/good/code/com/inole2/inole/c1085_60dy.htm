<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STASTRIP.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1096"></a>STASTRIP.C</h2>
<pre><code>/* <br> * STASTRIP.C <br> * StatStrip Control <br> * <br> * Window procedure and other functions that are frequently used in <br> * the life of a StatStrip. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br> <br>/* <br> * StatStripWndProc <br> * <br> * Purpose: <br> *  Window procedure for the StatStrip control. <br> */ <br> <br>LRESULT APIENTRY StatStripWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PSTATSTRIP      pST; <br>    int             cyFont; <br>    HDC             hDC; <br>    LRESULT         lRet; <br> <br>    pST=(PSTATSTRIP)GetWindowLong(hWnd, STATWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pST=(PSTATSTRIP)(void *)LocalAlloc(LPTR, CBSTATSTRIP); <br> <br>            if (NULL==pST) <br>                return -1L; <br> <br>            //Calc size of 0 point font, which we'll use as default. <br>            hDC=GetDC(NULL); <br>            cyFont=-MulDiv(10, GetDeviceCaps(hDC, LOGPIXELSY), 72); <br>            ReleaseDC(NULL, hDC); <br> <br>            pST-&gt;hFont=CreateFont(cyFont, 0, 0, 0, FW_NORMAL, FALSE <br>                , FALSE, FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS <br>                , CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY <br>                , VARIABLE_PITCH | FF_SWISS, TEXT("MS Sans Serif")); <br> <br>            /* <br>             * If we could create the font, remember that we own it. <br>             * If font creation failed, then we'll just do with the <br>             * system font. <br>             */ <br>            pST-&gt;fMyFont=(NULL!=pST-&gt;hFont); <br> <br>            SetWindowLong(hWnd, STATWL_STRUCTURE, (LONG)pST); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_DESTROY: <br>            StatStripClean(pST, TRUE); <br>            LocalFree((HLOCAL)(UINT)(LONG)pST); <br>            break; <br> <br> <br>        case WM_ERASEBKGND: <br>            /* <br>             * Eat this message to avoid erasing portions that we are <br>             * going to repaint in WM_PAINT.  Part of a change-state- <br>             * and-repaint strategy is to rely on WM_PAINT to do <br>             * anything visual, which includes erasing invalid <br>             * portions.  Letting WM_ERASEBKGND erase the background <br>             * is redundant. <br>             */ <br>            return TRUE; <br> <br> <br>        case WM_PAINT: <br>            StatStripPaint(hWnd, pST); <br>            break; <br> <br> <br>        case WM_SETFONT: <br>            if (!IsWindowEnabled(hWnd)) <br>                break; <br> <br>            /* <br>             * wParam has the new font.  Always repaint immediately. <br>             * First, delete the old font only if we own it. <br>             */ <br>            if (NULL!=pST-&gt;hFont &amp;&amp; pST-&gt;fMyFont) <br>                DeleteObject(pST-&gt;hFont); <br> <br>            //Save the new font but mark that we don't own it. <br>            pST-&gt;hFont=(HFONT)wParam; <br>            pST-&gt;fMyFont=FALSE; <br> <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case WM_GETFONT: <br>            return (LRESULT)(UINT)pST-&gt;hFont; <br> <br> <br>        case WM_SETTEXT: <br>            if (!IsWindowEnabled(hWnd)) <br>                break; <br> <br>            //This saves the text for us, so we only have to repaint. <br>            lRet=DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case WM_ENABLE: <br>            //Repaint on enabling or disabling either way. <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        //Control-specific messages <br>        case STATM_MESSAGEMAP: <br>            //lParam is an LPSTATMESSAGEMAPINIT <br>            if (0L!=lParam) <br>                { <br>                LPSTATMESSAGEMAPINIT  pMI=(LPSTATMESSAGEMAPINIT)lParam; <br> <br>                return (LRESULT)StatStripMessageMap(hWnd <br>                    , pMI-&gt;hWndOwner, pMI-&gt;hInst, pMI-&gt;uIDRMap <br>                    , pMI-&gt;idsMin, pMI-&gt;idsMax, pMI-&gt;cchMax <br>                    , pMI-&gt;uIDPopupMin, pMI-&gt;uIDPopupMax <br>                    , pMI-&gt;uIDStatic, pMI-&gt;uIDBlank <br>                    , pMI-&gt;uIDSysMenu); <br>                } <br>            break; <br> <br> <br>        case STATM_MENUSELECT: <br>            //wParam and lParam from caller's WM_MENUSELECT message <br>            StatStripMenuSelect(hWnd, wParam, lParam); <br>            break; <br> <br> <br>        case STATM_MESSAGEDISPLAY: <br>            //wParam is ID to display <br>            StatStripMessageDisplay(hWnd, (USHORT)wParam); <br>            break; <br> <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * StatStripPaint <br> * Internal <br> * <br> * Purpose: <br> *  Provides drawing the StatStrip window with the 3-D effect and the <br> *  current message and the current font. <br> * <br> * Parameters: <br> *  hWnd            HWND of the window; <br> *  pST             PSTATSTRIP containing control information. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void StatStripPaint(HWND hWnd, PSTATSTRIP pST) <br>    { <br>    int             y; <br>    HDC             hDC; <br>    RECT            rc; <br>    UINT            cch; <br>    TCHAR           szMsg[512]; <br>    HPEN            hPenFrame, hPenHigh; <br>    HFONT           hFontT; <br>    HBRUSH          hBr; <br>    COLORREF        crHighlight; <br>    TEXTMETRIC      tm; <br>    PAINTSTRUCT     ps; <br> <br>    hDC=BeginPaint(hWnd, &amp;ps); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    //Draw the top line using the frame color <br>    hPenFrame=CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME)); <br> <br>    if (NULL!=hPenFrame) <br>        { <br>        SelectObject(hDC, hPenFrame); <br>        MoveToEx(hDC, rc.left, rc.top, NULL); <br>        LineTo(hDC, rc.right, rc.top); <br>        } <br> <br>    //Draw the two highlight lines <br>    crHighlight=GetSysColor(COLOR_BTNHIGHLIGHT); <br> <br>    hPenHigh=CreatePen(PS_SOLID, 1, crHighlight); <br> <br>    if (NULL!=hPenHigh) <br>        { <br>        SelectObject(hDC, hPenHigh); <br>        MoveToEx(hDC, rc.left, rc.bottom, NULL); <br>        LineTo(hDC, rc.left, rc.top+1); <br>        LineTo(hDC, rc.right, rc.top+1); <br>        } <br> <br> <br>    //Draw the face color avoiding the frame and highlight <br>    rc.top +=2; <br>    rc.left+=1; <br> <br>    hBr=CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br>    FillRect(hDC, &amp;rc, hBr); <br>    DeleteObject(hBr); <br> <br> <br>    //Now write the text, color sensitive to the enabled state <br>    SetBkMode(hDC, TRANSPARENT); <br>    SetTextColor(hDC, GetSysColor(IsWindowEnabled(hWnd) <br>        ? COLOR_BTNTEXT : COLOR_BTNSHADOW)); <br> <br>    //Center the font vertically, accounting for borders on the rect. <br>    hFontT=SelectObject(hDC, pST-&gt;hFont); <br> <br>    GetTextMetrics(hDC, &amp;tm); <br>    y=rc.top+(((rc.bottom-rc.top)-tm.tmHeight) &gt;&gt; 1); <br>    y=max(y, rc.top); <br> <br>    cch=GetWindowText(hWnd, szMsg, sizeof(szMsg)); <br>    TextOut(hDC, 4, y, szMsg, cch); <br>    SelectObject(hDC, hFontT); <br> <br>    //Clean up <br>    EndPaint(hWnd, &amp;ps); <br> <br>    DeleteObject(hPenHigh); <br>    DeleteObject(hPenFrame); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * StatStripMenuSelect <br> * External <br> * <br> * Purpose: <br> *  Displays the appropriate message for whatever is in the <br> *  parameters of a WM_MENUSELECT message.  This can only be called <br> *  if StatStripMessageMap has already been called and must be used <br> *  with the same menu the owner window had at the time of that call. <br> * <br> *  Since we're unpacking an application's messages for it, the app <br> *  and this DLL must match 16-16 and 32-32 bits. <br> * <br> * Parameters: <br> *  hWnd            HWND of the StatStrip <br> *  wParam          WPARAM of the WM_MENUSELECT message. <br> *  lParam          LPARAM of the WM_MENUSELECT message. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void WINAPI StatStripMenuSelect(HWND hWnd, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PSTATSTRIP      pST; <br>    USHORT          uID; <br> <br>    MENUSELECTPARAMS(wItem, wMenuFlags, hMenu); <br> <br>    if (!IsWindow(hWnd) || !IsWindowEnabled(hWnd)) <br>        return; <br> <br>    pST=(PSTATSTRIP)GetWindowLong(hWnd, STATWL_STRUCTURE); <br> <br>    //Case 1:  Menu was cancelled, display static string <br>    if (0==wItem &amp;&amp; 0xFFFF==wMenuFlags) <br>        uID=pST-&gt;uIDStatic; <br>    else <br>        //Case 2:  System menu selected by itself. <br>        if (MF_POPUP &amp; wMenuFlags &amp;&amp; MF_SYSMENU &amp; wMenuFlags) <br>            uID=pST-&gt;uIDSysMenu; <br>        else <br>            /* <br>             * Case 3:  A popup menu was chosen:  Find the ID for <br>             * hMenu (in wItem) <br>             */ <br>            if (MF_POPUP &amp; wMenuFlags) <br>                uID=IDFromHMenu(pST, (HMENU)wItem); <br>            else <br>                //Case 4:  A menu item is selected <br>                if (0!=wItem) <br>                    uID=(UINT)wItem; <br>                else <br>                    //Case 5:  Nothing is selected (like a separator) <br>                    uID=pST-&gt;uIDBlank; <br> <br> <br>    /* <br>     * Go display the message.  Since all this function does extra <br>     * that we may not have to do here is a GetWindowLong, which <br>     * is quick, so by doing this we keep the code in one place and <br>     * only have to test this API to test the other. <br>     */ <br>    StatStripMessageDisplay(hWnd, uID); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * StatStripMessageDisplay <br> * External <br> * <br> * Purpose: <br> *  Displays the appropriate message for a given ID value.   This can <br> *  only be called if StatStripMessageMap has already been called. <br> * <br> * Parameters: <br> *  hWnd            HWND of the StatStrip <br> *  uID             USHORT of the message to display. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void WINAPI StatStripMessageDisplay(HWND hWnd, USHORT uID) <br>    { <br>    PSTATSTRIP      pST; <br>    UINT            idsMsg; <br> <br>    if (!IsWindow(hWnd) || !IsWindowEnabled(hWnd)) <br>        return; <br> <br>    pST=(PSTATSTRIP)GetWindowLong(hWnd, STATWL_STRUCTURE); <br> <br>    //Go look up the string ID to display. <br>    idsMsg=IStringFromID(pST-&gt;pSMM, pST-&gt;cMessages, uID); <br>    SetWindowText(hWnd, pST-&gt;ppsz[idsMsg-pST-&gt;idsMin]); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * IDFromHMenu <br> * <br> * Purpose: <br> *  Given a specific menu handle, searches through pST-&gt;pPMM for a <br> *  match and returns the ID associated with that menu. <br> * <br> * Parameters: <br> *  pST             PSTATSTRIP of the control <br> *  hMenu           HMENU to search for <br> * <br> * Return Value: <br> *  USHORT          ID associated with the menu handle. <br> */ <br> <br>USHORT IDFromHMenu(PSTATSTRIP pST, HMENU hMenu) <br>    { <br>    USHORT      uID=pST-&gt;uIDBlank;      //Default is empty <br>    UINT        i; <br> <br>   #ifdef WIN32 <br>    /* <br>     * Under Win32 the hMenu passed here from the WM_MENUSELECT <br>     * message will only be the index to the actual menu.  We <br>     * have to use GetSubMenu from the top-level menu using this <br>     * index to actually get the menu handle. <br>     */ <br> <br>    hMenu=GetSubMenu(GetMenu(pST-&gt;hWndOwner), (UINT)hMenu); <br>   #endif <br> <br>    for (i=0; i &lt; pST-&gt;cPopups; i++) <br>        { <br>        if (pST-&gt;pPMM[i].hMenu==hMenu) <br>            { <br>            uID=pST-&gt;pPMM[i].uID; <br>            break; <br>            } <br>        } <br> <br>    return uID; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * IStringFromID <br> * <br> * Purpose: <br> *  Performs a binary search in a STATMESSAGEMAP array looking for <br> *  a specific item ID returning the string ID for that item. <br> * <br> * Parameters: <br> *  pSMM            PSTATMESSAGEMAP to search <br> *  cItems          USHORT size of the map in elements <br> *  uID             USHORT item ID to locate. <br> * <br> * Return Value: <br> *  UINT            String ID associated with wItem. <br> */ <br> <br>UINT IStringFromID(PSTATMESSAGEMAP pSMM, USHORT cItems, USHORT uID) <br>    { <br>    UINT        iLow =0; <br>    UINT        iHigh=cItems-1; <br>    UINT        iMid; <br> <br>    while (TRUE) <br>        { <br>        iMid=(iLow+iHigh) &gt;&gt; 1; <br> <br>        if (uID &lt; pSMM[iMid].uID) <br>            iHigh=iMid-1; <br>        else <br>            { <br>            if (uID &gt; pSMM[iMid].uID) <br>                iLow=iMid+1; <br>            else <br>                break;    //Equality <br>            } <br> <br>        if (iHigh &lt; iLow) <br>            break; <br>        } <br> <br>    return pSMM[iMid].idsMsg; <br>    } <br> <br> <br> <br> <br>/* <br> * StatStripMessageMap <br> * <br> * Purpose: <br> *  Initializes the message mappings in the StatStrip for subsequent <br> *  use with StatMessageMenuSelect.  If this function is called more <br> *  than once then any previous initialization is cleaned up so <br> *  previous message IDs will then be invalid. <br> * <br> *  The total number of messages is inferred by (idsMax-idsMin+1). <br> *  The maximum number of popup menu items we'll hold is inferred by <br> *  (uIDPopupMax-uIDPopupMin+1). <br> * <br> * Parameters: <br> *  hWnd            HWND of the StatStrip control. <br> *  hWndOwner       HWND of the window owning menus. <br> *  hInst           HINSTANCE of the app from which to load resources <br> *  uIDRMap         UINT identifying a resource mapping ID values <br> *                  to string ID values. <br> *  idsMin          UINT specifying the lowest string ID to load. <br> *  idsMax          UINT specifying the hightest string ID to load. <br> *  cchMax          UINT maximum string length. <br> *  uIDPopupMin     USHORT lowest ID to assign to popup menus. <br> *  uIDPopupMax     USHORT highest ID to assign to popup menus. <br> *  uIDStatic       USHORT ID for the quiescent message. <br> *  uIDBlank        USHORT ID for a blank message. <br> *  uIDSysMenu      USHORT ID for the system menu. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function was successful, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI StatStripMessageMap(HWND hWnd, HWND hWndOwner <br>    , HINSTANCE hInst , UINT uIDRMap, UINT idsMin, UINT idsMax <br>    , UINT cchMax, USHORT uIDPopupMin, USHORT uIDPopupMax <br>    , USHORT uIDStatic, USHORT uIDBlank, USHORT uIDSysMenu) <br>    { <br>    PSTATSTRIP      pST; <br>    HMENU           hMenu; <br>    HRSRC           hRes; <br>    UINT            i; <br>    USHORT          uID; <br> <br>   #ifdef WIN32 <br>    DWORD           cbRes; <br>    DWORD           dwPrevProt; <br>   #endif <br> <br>    if (!IsWindow(hWnd)) <br>        return FALSE; <br> <br>    pST=(PSTATSTRIP)GetWindowLong(hWnd, STATWL_STRUCTURE); <br> <br>    if (NULL==pST) <br>        return FALSE; <br> <br>    //Parameter validation <br>    if (NULL==hInst || idsMax &lt; idsMin || uIDPopupMax &lt; uIDPopupMin) <br>        return FALSE; <br> <br>    //Clean ourselves out if we've already initialized. <br>    if (pST-&gt;fMapped) <br>        StatStripClean(pST, FALSE); <br> <br>    pST-&gt;hWndOwner  =hWndOwner; <br> <br>    pST-&gt;idsMin     =idsMin; <br>    pST-&gt;idsMax     =idsMax; <br>    pST-&gt;cMessages  =(USHORT)(idsMax-idsMin+1); <br> <br>    pST-&gt;uIDPopupMin=uIDPopupMin; <br>    pST-&gt;uIDPopupMax=uIDPopupMax; <br>    pST-&gt;cPopups    =(USHORT)(uIDPopupMax-uIDPopupMin+1); <br> <br>    pST-&gt;uIDStatic  =uIDStatic; <br>    pST-&gt;uIDBlank   =uIDBlank; <br>    pST-&gt;uIDSysMenu =uIDSysMenu; <br> <br>    //Load the STATMESSAGEMAP array from our resources. <br>    hRes=FindResource(hInst, MAKEINTRESOURCE(uIDRMap), RT_RCDATA); <br> <br>    if (NULL==hRes) <br>        return FALSE; <br> <br> <br>    pST-&gt;hMemSMM=LoadResource(hInst, hRes); <br> <br>    if (NULL==pST-&gt;hMemSMM) <br>        return FALSE; <br> <br>    pST-&gt;pSMM=(PSTATMESSAGEMAP)LockResource(pST-&gt;hMemSMM); <br> <br>    if (NULL==pST-&gt;pSMM) <br>        { <br>        StatStripClean(pST, FALSE); <br>        return FALSE; <br>        } <br> <br>   #ifdef WIN32 <br>    /* <br>     * In Win32 resource pages are read-only when loaded. <br>     * Change to read-write for the purposes of sorting <br>     * initially. <br>     */ <br>    cbRes=SizeofResource(hInst, hRes); <br>    VirtualProtect(pST-&gt;pSMM, cbRes, PAGE_READWRITE, &amp;dwPrevProt); <br>   #endif <br> <br>    //Sort these for binary search lookup. <br>    StatMessageMapSort(pST-&gt;pSMM, pST-&gt;cMessages); <br> <br>   #ifdef WIN32 <br>    VirtualProtect(pST-&gt;pSMM, cbRes, dwPrevProt, &amp;dwPrevProt); <br>   #endif <br> <br>    //Allocate space for string pointers <br>    pST-&gt;ppsz=(LPTSTR *)LocalAlloc(LPTR <br>        , sizeof(LPTSTR)*pST-&gt;cMessages); <br> <br>    if (NULL==pST-&gt;ppsz) <br>        { <br>        StatStripClean(pST, FALSE); <br>        return FALSE; <br>        } <br> <br>    //Load the stringtable for messages. <br>    pST-&gt;hMemSzStat=HStringCache(hInst, idsMin, idsMax, cchMax <br>        , pST-&gt;ppsz); <br> <br>    if (NULL==pST-&gt;hMemSzStat) <br>        { <br>        StatStripClean(pST, FALSE); <br>        return FALSE; <br>        } <br> <br>    //Allocate an array of POPUPMENUMAP structures <br>    pST-&gt;pPMM=(PPOPUPMENUMAP)(void *)LocalAlloc(LPTR <br>        , sizeof(POPUPMENUMAP)*pST-&gt;cPopups); <br> <br>    if (NULL==pST-&gt;pPMM) <br>        { <br>        StatStripClean(pST, FALSE); <br>        return FALSE; <br>        } <br> <br>    //Initialize the array mapping popup menus to specific IDs. <br>    uID=uIDPopupMin; <br>    hMenu=GetMenu(hWndOwner); <br> <br>    for (i=0; i &lt; pST-&gt;cPopups; i++) <br>        { <br>        pST-&gt;pPMM[i].hMenu=GetSubMenu(hMenu, i); <br>        pST-&gt;pPMM[i].uID  =uID++; <br>        } <br> <br>    pST-&gt;fMapped=TRUE; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * StatStripClean <br> * <br> * Purpose: <br> *  Cleans out any allocations in a STATSTRIP. <br> * <br> * Parameters: <br> *  pST             PSTATSTRIP to clean <br> *  fIncludeFont    BOOL indicates if we're to also clean the font. <br> *                  This is FALSE from StatMessageMap, TRUE from <br> *                  WM_DESTROY. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void StatStripClean(PSTATSTRIP pST, BOOL fIncludeFont) <br>    { <br>    //Free up anything from StatMessageMap <br>    if (NULL!=pST-&gt;pPMM) <br>        { <br>        LocalFree((HLOCAL)(UINT)(LONG)pST-&gt;pPMM); <br>        pST-&gt;pPMM=NULL; <br>        } <br> <br>    if (NULL!=pST-&gt;ppsz) <br>        { <br>        LocalFree((HLOCAL)(UINT)(LONG)pST-&gt;ppsz); <br>        pST-&gt;ppsz=NULL; <br>        } <br> <br>    if (NULL!=pST-&gt;hMemSzStat) <br>        { <br>        HStringCacheFree(pST-&gt;hMemSzStat); <br>        pST-&gt;hMemSzStat=NULL; <br>        } <br> <br>    if (NULL!=pST-&gt;pSMM) <br>        { <br>       #ifndef WIN32 <br>        UnlockResource(pST-&gt;hMemSMM); <br>       #endif <br>        pST-&gt;pSMM=NULL; <br>        } <br> <br>    if (NULL!=pST-&gt;hMemSMM) <br>        { <br>        FreeResource(pST-&gt;hMemSMM); <br>        pST-&gt;hMemSMM=NULL; <br>        } <br> <br>    //Delete the old font only if we own it. <br>    if (fIncludeFont) <br>        { <br>        if (NULL!=pST-&gt;hFont &amp;&amp; pST-&gt;fMyFont) <br>            { <br>            DeleteObject(pST-&gt;hFont); <br>            pST-&gt;hFont=NULL; <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * HStringCache <br> * <br> * Purpose: <br> *  Allocates memory and reads a stringtable into that memory. <br> *  Pointers to the strings in the memory are then stored at ppsz <br> *  which is assumed to be (idsMax-idsMin+1) strings long. <br> * <br> * Parameters: <br> *  hInst           HINSTANCE of the application <br> *  idsMin          UINT string index to start loading <br> *  idsMax          UINT maximum string index in this table. <br> *  cchMax          UINT length of the longest string in TCHARs. <br> *  ppsz            LPTSTR * to an array in which to store pointers. <br> * <br> * Return Value: <br> *  HGLOBAL         Handle to the memory.  NULL if memory could <br> *                  not be allocated. <br> */ <br> <br>HGLOBAL HStringCache(HINSTANCE hInst, UINT idsMin, UINT idsMax <br>    , UINT cchMax, LPTSTR *ppsz) <br>    { <br>    HANDLE      hMem; <br>    LPTSTR      pch; <br>    UINT        cchUsed=0; <br>    UINT        cch; <br>    UINT        i, cStrings; <br> <br>    cStrings=idsMax-idsMin+1; <br>    hMem=GlobalAlloc(GHND, cStrings * cchMax * sizeof(TCHAR)); <br> <br>    if (NULL!=hMem) <br>        { <br>        pch=GlobalLock(hMem); <br> <br>        /* <br>         * Load the strings into the memory and retain the specific <br>         * pointer to that string. <br>         */ <br>        for (i=0; i &lt; cStrings; i++) <br>            { <br>            cch=LoadString(hInst, i+idsMin, (LPTSTR)(pch+cchUsed) <br>                , cchMax-1); <br>            ppsz[i]=(LPTSTR)(pch+cchUsed); <br> <br>            /* <br>             * Add one char to cch to include a NULL.  The memory <br>             * was ZEROINITed on allocation so by skipping a TCHAR <br>             * we get the NULL. <br>             */ <br>            cchUsed+=cch+sizeof(TCHAR); <br>            } <br> <br>        /* <br>         * Memory is locked for the duration of the app.  Don't <br>         * bother reallocating since we might have to recalc <br>         * all the pointers to the strings again. <br>         */ <br>        } <br> <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * HStringCacheFree <br> * <br> * Purpose: <br> *  Frees up any memory associated with the string cache from <br> *  HStringCache. <br> * <br> * Parameters: <br> *  hMem            HGLOBAL to the memory containing the cahce. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void HStringCacheFree(HGLOBAL hMem) <br>    { <br>    if (NULL!=hMem) <br>        { <br>        GlobalUnlock(hMem); <br>        GlobalFree(hMem); <br>        } <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * StatMessageMapSort <br> * <br> * Purpose: <br> *  Performs a selection sort on the STATMESSAGEMAP array that we <br> *  load from our resource.  Since we expect that the data is <br> *  partially sorted (we tend to place things in resources in groups <br> *  of seqential values), since the number of messages is usually <br> *  &lt; 200, and since we're in startup (which takes a long time <br> *  anyway), selection sort is a better choice to implement over <br> *  qsort saving much code. <br> * <br> * Parameters: <br> *  pSMM            PSTATMESSAGEMAP to sort <br> *  n               USHORT number of elements in the array. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void StatMessageMapSort(PSTATMESSAGEMAP pSMM, USHORT n) <br>    { <br>    USHORT          i, j, k; <br>    STATMESSAGEMAP  smm; <br> <br>    for (j=0; j &lt; (UINT)(n-1); j++) <br>        { <br>        k=j; <br>        smm.uID   =pSMM[j].uID; <br>        smm.idsMsg=pSMM[j].idsMsg; <br> <br>        for (i=j+1; i &lt; (UINT)n; i++) <br>            { <br>            if (pSMM[i].uID &lt; smm.uID) <br>                { <br>                smm.uID   =pSMM[i].uID; <br>                smm.idsMsg=pSMM[i].idsMsg; <br>                k=i; <br>                } <br>            } <br> <br>        smm.uID       =pSMM[j].uID; <br>        smm.idsMsg    =pSMM[j].idsMsg; <br>        pSMM[j].uID   =pSMM[k].uID; <br>        pSMM[j].idsMsg=pSMM[k].idsMsg; <br>        pSMM[k].uID   =smm.uID; <br>        pSMM[k].idsMsg=smm.idsMsg; <br>        } <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
