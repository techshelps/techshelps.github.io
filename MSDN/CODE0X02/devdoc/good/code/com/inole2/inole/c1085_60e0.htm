<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UIEFFECT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1098"></a>UIEFFECT.CPP</h2>
<pre><code>/* <br> * UIEFFECT.CPP <br> * <br> * Utility functions for drawing various graphical effects. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br>//Hatch pattern brush bits <br>static WORD g_wHatchBmp[]={0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88}; <br> <br> <br>/* <br> * UIDrawHandles <br> * <br> * Purpose: <br> *  Draw handles or/and boundary around Container Object when selected <br> * <br> * Parameters: <br> *  pRect           Dimensions of Container Object <br> *  hDC             HDC of the site <br> *  dwFlags         DWORD specifying how to draw the handles. <br> *  cSize           UINT size of handle box <br> *  fDraw           BOOL draw if TRUE, erase if FALSE <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) UIDrawHandles(LPRECT pRect, HDC hDC, DWORD dwFlags, UINT cSize <br>    , BOOL fDraw) <br>    { <br>HBRUSH  hBR; <br>RECT    rc; <br>int     bkmodeOld; <br>BOOL    fInvert=(BOOL)(dwFlags &amp; UI_HANDLES_USEINVERSE); <br> <br>CopyRect((LPRECT)&amp;rc, pRect); <br> <br>bkmodeOld=SetBkMode(hDC, TRANSPARENT); <br> <br>if (dwFlags &amp; UI_HANDLES_OUTSIDE) <br>InflateRect((LPRECT)&amp;rc, cSize - 1, cSize - 1); <br> <br>//Draw the handles inside the rectangle boundary <br>DrawHandle(hDC, rc.left, rc.top, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.left, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.left, rc.bottom-cSize, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.left+(rc.right-rc.left-cSize)/2, rc.top, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.left+(rc.right-rc.left-cSize)/2, rc.bottom-cSize, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.right-cSize, rc.top, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.right-cSize, rc.top+(rc.bottom-rc.top-cSize)/2, cSize, fInvert, fDraw); <br>DrawHandle(hDC, rc.right-cSize, rc.bottom-cSize, cSize, fInvert, fDraw); <br> <br>if (!(dwFlags &amp; UI_HANDLES_NOBORDER)) <br>        { <br>if (fDraw) <br>hBR=(HBRUSH)GetStockObject(BLACK_BRUSH); <br>else <br>hBR=(HBRUSH)GetStockObject(WHITE_BRUSH); <br> <br>FrameRect(hDC, pRect, hBR); <br>    } <br> <br>SetBkMode(hDC, bkmodeOld); <br>    } <br> <br> <br> <br>/* <br> * DrawHandle <br> * <br> * Purpose: <br> *  Draw a handle box at the specified coordinate <br> * <br> * Parameters: <br> *  hDC             HDC to be drawn into <br> *  x, y            int upper left corner coordinate of the handle box <br> *  cSize           UINT size of handle box <br> *  fInvert         BOOL indicating to invert the rect or fill it <br> *  fDraw           BOOL draw if TRUE, erase if FALSE, <br> *                  ignored if fInvert is TRUE <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void DrawHandle(HDC hDC, int x, int y, UINT cSize, BOOL fInvert <br>    , BOOL fDraw) <br>    { <br>HBRUSH  hBR; <br>HBRUSH  hBROld; <br>HPEN    hPen; <br>HPEN    hPenOld; <br>RECT    rc; <br> <br>if (!fInvert) <br>        { <br>if (fDraw) <br>            { <br>hPen=(HPEN)GetStockObject(BLACK_PEN); <br>hBR=(HBRUSH)GetStockObject(BLACK_BRUSH); <br>    } <br>        else <br>            { <br>hPen=(HPEN)GetStockObject(WHITE_PEN); <br>hBR=(HBRUSH)GetStockObject(WHITE_PEN); <br>    } <br> <br>hPenOld=(HPEN)SelectObject(hDC, hPen); <br>hBROld=(HBRUSH)SelectObject(hDC, hBR); <br>Rectangle(hDC, x, y, x+cSize, y+cSize); <br>SelectObject(hDC, hPenOld); <br>SelectObject(hDC, hBROld); <br>    } <br>else <br>        { <br>rc.left=x; <br>rc.top=y; <br>rc.right=x + cSize; <br>rc.bottom=y + cSize; <br>InvertRect(hDC, (LPRECT)&amp;rc); <br>    } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * UIDrawShading <br> * <br> * Purpose: <br> *  Draw a hatching across a rectangle, inside a rectangle, or <br> *  outside a rectangle. <br> * <br> * Parameters: <br> *  prc             LPRECT containing the rectangle. <br> *  hDC             HDC on which to draw. <br> *  dwFlags         DWORD specifying how to draw the shading. <br> *  cWidth          UINT width of the border to draw.  Ignored <br> *                  if dwFlags has UI_SHADE_FULLRECT. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) UIDrawShading(LPRECT prc, HDC hDC, DWORD dwFlags, UINT cWidth) <br>    { <br>    HBRUSH      hBR; <br>    HBRUSH      hBROld; <br>    HBITMAP     hBM; <br>    RECT        rc; <br>    UINT        cx, cy; <br>    COLORREF    crText; <br>    COLORREF    crBk; <br>    const DWORD dwROP=0x00A000C9L;  //DPa <br> <br>    if (NULL==prc || NULL==hDC) <br>return; <br> <br>    hBM=CreateBitmap(8, 8, 1, 1, g_wHatchBmp); <br>    hBR=CreatePatternBrush(hBM); <br>    hBROld=(HBRUSH)SelectObject(hDC, hBR); <br> <br>    rc=*prc; <br>    cx=rc.right-rc.left; <br>    cy=rc.bottom-rc.top; <br> <br>    if (UI_SHADE_FULLRECT==dwFlags) <br>        { <br>        crText=SetTextColor(hDC, RGB(255, 255, 255)); <br>        crBk=SetBkColor(hDC, RGB(0, 0, 0)); <br>        PatBlt(hDC, rc.left, rc.top, cx, cy, dwROP); <br>        } <br>    else <br>        { <br>        if (UI_SHADE_BORDEROUT==dwFlags) <br>            InflateRect((LPRECT)&amp;rc, cWidth-1, cWidth-1); <br> <br>        crText=SetTextColor(hDC, RGB(255, 255, 255)); <br>        crBk=SetBkColor(hDC, RGB(0, 0, 0)); <br>        PatBlt(hDC, rc.left, rc.top, cx, cWidth, dwROP); <br>        PatBlt(hDC, rc.left, rc.top, cWidth, cy, dwROP); <br>        PatBlt(hDC, rc.right-cWidth, rc.top, cWidth, cy, dwROP); <br>        PatBlt(hDC, rc.left, rc.bottom-cWidth, cx, cWidth, dwROP); <br>        } <br> <br>    SetTextColor(hDC, crText); <br>    SetBkColor(hDC, crBk); <br>    SelectObject(hDC, hBROld); <br>    DeleteObject(hBR); <br>    DeleteObject(hBM); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * UIShowObject <br> * <br> * Purpose: <br> *  Draw the ShowObject effect around an embedded or linked <br> *  object. <br> * <br> * Parameters: <br> *  prc             LPRECT to draw around. <br> *  hDC             HDC on which to draw. <br> *  fLink           BOOL specifying a linked (TRUE) or <br> *                  embedded (FALSE) object <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) UIShowObject(LPCRECT prc, HDC hDC, BOOL fLink) <br>    { <br>HPEN    hPen; <br>HPEN    hPenOld; <br>HBRUSH  hBROld; <br> <br>if (NULL==prc || NULL==hDC) <br>return; <br> <br>hPen=fLink ? CreatePen(PS_DASH, 1, RGB(0,0,0)) <br>        : (HPEN)GetStockObject(BLACK_PEN); <br> <br>if (!hPen) <br>return; <br> <br>hPenOld=(HPEN)SelectObject(hDC, hPen); <br>hBROld=(HBRUSH)SelectObject(hDC, GetStockObject(NULL_BRUSH)); <br> <br>Rectangle(hDC, prc-&gt;left, prc-&gt;top, prc-&gt;right, prc-&gt;bottom); <br> <br>SelectObject(hDC, hPenOld); <br>SelectObject(hDC, hBROld); <br> <br>if (fLink) <br>DeleteObject(hPen); <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
