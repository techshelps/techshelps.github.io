<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GIZMOBAR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1091"></a>GIZMOBAR.C</h2>
<pre><code>/* <br> * GIZMOBAR.C <br> * <br> * Contains the main window procedure of the GizmoBar control <br> * that handles mouse logic and Windows messages. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br> <br>//In GIZMO.C <br>extern TOOLDISPLAYDATA g_tdd; <br> <br> <br>/* <br> * GizmoBarPAllocate <br> * <br> * Purpose: <br> *  Allocates and initializes the control's primary data structure <br> *  for each window that gets created. <br> * <br> * Parameters: <br> *  pfSuccess       int * indicating success of the function. <br> *  hWnd            HWND that is tied to this structure. <br> *  hInst           HINSTANCE of the DLL. <br> *  hWndAssociate   HWND to which we send messages. <br> *  dwStyle         DWORD initial style. <br> *  uState          UINT initial state. <br> *  uID             UINT identifier for this window. <br> * <br> * Return Value: <br> *  PGIZMOBAR       If NULL returned then GizmoBarPAllocate could not <br> *                  allocate memory.  If a non-NULL pointer is <br> *                  returned with *pfSuccess, then call GizmoBarPFree <br> *                  immediately.  If you get a non-NULL pointer and <br> *                  *pfSuccess==TRUE then the function succeeded. <br> */ <br> <br>PGIZMOBAR GizmoBarPAllocate(int *pfSuccess, HWND hWnd <br>    , HINSTANCE hInst, HWND hWndAssociate, DWORD dwStyle <br>    , UINT uState , UINT uID) <br>    { <br>    PGIZMOBAR     pGB; <br> <br>    if (NULL==pfSuccess) <br>        return NULL; <br> <br>    *pfSuccess=FALSE; <br> <br>    //Allocate the structure <br>    pGB=(PGIZMOBAR)(void *)LocalAlloc(LPTR, CBGIZMOBAR); <br> <br>    if (NULL==pGB) <br>        return NULL; <br> <br>    //Initialize LibMain parameter holders. <br>    pGB-&gt;hWnd         =hWnd; <br>    pGB-&gt;hInst        =hInst; <br>    pGB-&gt;hWndAssociate=hWndAssociate; <br>    pGB-&gt;dwStyle      =dwStyle; <br>    pGB-&gt;uState       =uState; <br>    pGB-&gt;uID          =uID; <br>    pGB-&gt;fEnabled     =TRUE; <br> <br>    pGB-&gt;crFace=GetSysColor(COLOR_BTNFACE); <br>    pGB-&gt;hBrFace=CreateSolidBrush(pGB-&gt;crFace); <br> <br>    if (NULL==pGB-&gt;hBrFace) <br>        return pGB; <br> <br>    pGB-&gt;hFont=GetStockObject(SYSTEM_FONT); <br> <br>    *pfSuccess=TRUE; <br>    return pGB; <br>    } <br> <br> <br> <br> <br>/* <br> * GizmoBarPFree <br> * <br> * Purpose: <br> *  Reverses all initialization done by GizmoBarPAllocate, cleaning <br> *  up any allocations including the application structure itself. <br> * <br> * Parameters: <br> *  pGB             PGIZMOBAR to the control's structure <br> * <br> * Return Value: <br> *  PGIZMOBAR       NULL if successful, pGB if not, meaning we <br> *                  couldn't free some allocation. <br> */ <br> <br>PGIZMOBAR GizmoBarPFree(PGIZMOBAR pGB) <br>    { <br>    if (NULL==pGB) <br>        return NULL; <br> <br>    /* <br>     * Free all the gizmos we own.  When we call GizmoPFree we always <br>     * free the first one in the list which updates pGB-&gt;pGizmos for <br>     * us, so we just have to keep going until pGizmos is NULL, <br>     * meaning we're at the end of the list. <br>     */ <br>    while (NULL!=pGB-&gt;pGizmos) <br>        GizmoPFree(&amp;pGB-&gt;pGizmos, pGB-&gt;pGizmos); <br> <br>    if (NULL!=pGB-&gt;hBrFace) <br>        DeleteObject(pGB-&gt;hBrFace); <br> <br>    /* <br>     * Notice that since we never create a font, we aren't <br>     * responsible for our hFont member. <br>     */ <br> <br>    return (PGIZMOBAR)(void *)LocalFree((HLOCAL)(UINT)(LONG)pGB); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * GizmoBarWndProc <br> * <br> * Purpose: <br> *  Window Procedure for the GizmoBar custom control.  Handles all <br> *  messages like WM_PAINT just as a normal application window would. <br> *  Any message not processed here should go to DefWindowProc. <br> * <br> * Parameters: <br> *  Standard <br> * <br> * Return Value: <br> *  Standard <br> */ <br> <br>LRESULT WINAPI GizmoBarWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    BOOL            fSuccess; <br>    BOOL            fTemp; <br>    LPCREATESTRUCT  pCreate; <br>    PGIZMOBAR       pGB; <br>    PGIZMO          pGizmo; <br>    RECT            rc; <br>    POINT           pt; <br>    short           x, y; <br>    COLORREF        cr; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    pGB=(PGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE); <br> <br>    //Pass control messages onto another function for processing. <br>    if (iMsg &gt;= WM_USER) <br>        return GBMessageHandler(hWnd, iMsg, wParam, lParam, pGB); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pCreate=(LPCREATESTRUCT)lParam; <br> <br>            pGB=GizmoBarPAllocate(&amp;fSuccess, hWnd <br>                , pCreate-&gt;hInstance, pCreate-&gt;hwndParent <br>                , pCreate-&gt;style, 0, (UINT)pCreate-&gt;hMenu); <br> <br>            if (!fSuccess) <br>                { <br>                GizmoBarPFree(pGB); <br>                return -1L; <br>                } <br>            else <br>                SetWindowLong(hWnd, GBWL_STRUCTURE, (LONG)pGB); <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_DESTROY: <br>            /* <br>             * We want to clean up before DestroyWindow nukes all the <br>             * children, so WM_DESTROY is a better to do it than <br>             * WM_NCDESTROY. <br>             */ <br>            GizmoBarPFree(pGB); <br>            break; <br> <br> <br>        case WM_ERASEBKGND: <br>            /* <br>             * Eat this message to avoid erasing portions that <br>             * we are going to repaint in WM_PAINT.  Part of a <br>             * change-state-and-repaint strategy is to rely on <br>             * WM_PAINT to do anything visual, which includes <br>             * erasing invalid portions.  Letting WM_ERASEBKGND <br>             * erase the background is redundant. <br>             */ <br>            return TRUE; <br> <br>       #ifdef WIN32 <br>        case WM_CTLCOLORBTN: <br>        case WM_CTLCOLORSTATIC: <br>            fTemp=TRUE; <br>       #else <br>        case WM_CTLCOLOR: <br>            //Change the color of static text on the GizmoBar. <br>            fTemp=(HIWORD(lParam)==CTLCOLOR_STATIC <br>                || HIWORD(lParam)==CTLCOLOR_BTN); <br>       #endif <br> <br>            if (fTemp) <br>                { <br>                cr=GetSysColor(COLOR_BTNFACE); <br>                SetTextColor((HDC)wParam <br>                    , GetSysColor(COLOR_BTNTEXT)); <br>                SetBkColor((HDC)wParam, cr); <br> <br>                /* <br>                 * If the system colors have changed, then crFace <br>                 * will not be equal to COLOR_BTNFACE, so we <br>                 * reinitialize the background brush.  This scheme <br>                 * handles system color changes appropriately <br>                 * without processing WM_WININICHANGE and without <br>                 * blindly creating a new brush on every WM_CTLCOLOR <br>                 * message. <br>                 */ <br>                if (cr!=pGB-&gt;crFace) <br>                    { <br>                    pGB-&gt;crFace=cr; <br> <br>                    if (NULL!=pGB-&gt;hBrFace) <br>                        DeleteObject(pGB-&gt;hBrFace); <br> <br>                    pGB-&gt;hBrFace=CreateSolidBrush(pGB-&gt;crFace); <br>                    } <br> <br>                return (LONG)(UINT)pGB-&gt;hBrFace; <br>                } <br> <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_PAINT: <br>            GizmoBarPaint(hWnd, pGB); <br>            break; <br> <br> <br>        case WM_SETFONT: <br>            /* <br>             * wParam has the new font that we now send to all other <br>             * windows controls in us.  We control repaints here to <br>             * prevent a lot of repainting for each control. <br>             */ <br>            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>            if ((WPARAM)NULL!=wParam) <br>                { <br>                pGB-&gt;hFont=(HFONT)wParam; <br>                GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumChangeFont <br>                    , (DWORD)(LPTSTR)pGB); <br> <br>                DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L); <br>                InvalidateRect(hWnd, NULL, FALSE); <br>                UpdateWindow(hWnd); <br>                } <br> <br>            break; <br> <br> <br>        case WM_GETFONT: <br>            return (LRESULT)(UINT)pGB-&gt;hFont; <br> <br> <br>        case WM_ENABLE: <br>            /* <br>             * wParam has the new enable flag that we use to enable <br>             * or disable ALL controls in us at one time.  We also <br>             * turn the redraw off to prevent a lot of flicker. <br>             */ <br>            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L); <br> <br>            pGB-&gt;fEnabled=(BOOL)wParam; <br>            GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumEnable <br>                , (DWORD)(LPTSTR)pGB); <br> <br>            DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L); <br>            InvalidateRect(hWnd, NULL, FALSE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case WM_CANCELMODE: <br>            pGizmo=pGB-&gt;pGizmoTrack; <br> <br>            pGB-&gt;fTracking=FALSE; <br>            pGB-&gt;fMouseOut=FALSE; <br> <br>            if (NULL!=pGizmo) <br>                GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP); <br> <br>            ReleaseCapture(); <br>            break; <br> <br> <br>        case WM_LBUTTONDBLCLK: <br>        case WM_LBUTTONDOWN: <br>            //Get the mouse coordinates. <br>            x=LOWORD(lParam); <br>            y=HIWORD(lParam); <br> <br> <br>            /* <br>             * See if we hit a command or attribute gizmo or not. <br>             * Anything else that is a control will get the message <br>             * instead of us anyway, so we don't have to check. <br>             * FEnumHitTest also validates drawn gizmos, enabled, and <br>             * visible, so we don't. <br>             */ <br>            pGizmo=GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumHitTest, lParam); <br> <br>            if (NULL==pGizmo) <br>                break;          //Didn't hit one matching our needs. <br> <br>            /* <br>             * Inform the associate that a command was hit like a <br>             * menu item. <br>             */ <br>            if (NULL!=pGB-&gt;hWndAssociate) <br>                { <br>                if (pGizmo-&gt;fNotify) <br>                    { <br>                    SendMenuSelect(pGB-&gt;hWndAssociate, pGizmo-&gt;uID <br>                        , 0, 0); <br>                    } <br>                } <br> <br>            /* <br>             * We hit a button.  If it's a command or attribute, <br>             * then change the state and start tracking. <br>             */ <br>            pGB-&gt;fTracking=TRUE; <br>            pGB-&gt;pGizmoTrack=pGizmo; <br>            pGB-&gt;fMouseOut=FALSE; <br>            SetCapture(hWnd); <br> <br>            pGizmo-&gt;uStateOrg=pGizmo-&gt;uState; <br>            GizmoPStateSet(hWnd, pGizmo, ATTRIBUTEBUTTON_MOUSEDOWN); <br> <br>            break; <br> <br> <br>        case WM_MOUSEMOVE: <br>            POINTFROMLPARAM(pt, lParam); <br> <br>            if (!pGB-&gt;fTracking) <br>                break; <br> <br>            pGizmo=pGB-&gt;pGizmoTrack; <br>            SetRect(&amp;rc, pGizmo-&gt;x, pGizmo-&gt;y, pGizmo-&gt;x+pGizmo-&gt;dx <br>                , pGizmo-&gt;y+pGizmo-&gt;dy); <br> <br>            fTemp=pGB-&gt;fMouseOut; <br>            pGB-&gt;fMouseOut=!PtInRect(&amp;rc, pt); <br> <br>            //If the mouse went out, change state to the original. <br>            if (!fTemp &amp;&amp; pGB-&gt;fMouseOut) <br>                { <br>                GizmoPStateSet(hWnd, pGizmo, pGizmo-&gt;uStateOrg); <br> <br>                if (NULL!=pGB-&gt;hWndAssociate) <br>                    { <br>                    //Notify that we left the button <br>                    if (pGizmo-&gt;fNotify) <br>                        SendMenuSelect(pGB-&gt;hWndAssociate, 0, ~0, 0); <br>                    } <br>                } <br> <br>            if (fTemp &amp;&amp; !pGB-&gt;fMouseOut) <br>                { <br>                GizmoPStateSet(hWnd, pGizmo <br>                    , ATTRIBUTEBUTTON_MOUSEDOWN); <br> <br>                if (NULL!=pGB-&gt;hWndAssociate) <br>                    { <br>                    //Notify that we pressed down again <br>                    if (pGizmo-&gt;fNotify) <br>                        { <br>                        SendMenuSelect(pGB-&gt;hWndAssociate <br>                            , pGizmo-&gt;uID , 0, 0); <br>                        } <br>                    } <br>                } <br> <br>            break; <br> <br> <br>        case WM_LBUTTONUP: <br>            if (!pGB-&gt;fTracking) <br>                break; <br> <br>            pGB-&gt;fTracking=FALSE; <br>            pGizmo=pGB-&gt;pGizmoTrack; <br>            ReleaseCapture(); <br> <br> <br>            /* <br>             * Repaint if we were actually below the mouse when this <br>             * occurred.  For command buttons, pop the button up. <br>             * For attributes, either toggle the state (inclusive <br>             * buttons) or check the selected one (exclusive buttons) <br>             */ <br> <br>            if (!pGB-&gt;fMouseOut) <br>                { <br>                //Command buttons always come up. <br>                if (GIZMOTYPE_BUTTONCOMMAND==pGizmo-&gt;iType) <br>                    GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP); <br> <br>                //Attribute inclusive buttons toggle <br>                if (GIZMOTYPE_BUTTONATTRIBUTEIN==pGizmo-&gt;iType) <br>                    { <br>                    GizmoPCheck(hWnd, pGizmo, !(BUTTONGROUP_DOWN <br>                        &amp; pGizmo-&gt;uStateOrg)); <br>                    } <br> <br>                //Attribure exclusive buttons are always checked. <br>                if (GIZMOTYPE_BUTTONATTRIBUTEEX==pGizmo-&gt;iType) <br>                    GizmoPCheck(hWnd, pGizmo, TRUE); <br> <br>                //Only send messages if notify is ON. <br>                if (NULL!=pGB-&gt;hWndAssociate &amp;&amp; pGizmo-&gt;fNotify) <br>                    { <br>                    SendMenuSelect(pGB-&gt;hWndAssociate, 0, ~0, 0); <br>                    SendCommand(pGB-&gt;hWndAssociate, pGizmo-&gt;uID <br>                        , BN_CLICKED, hWnd); <br>                    } <br>                } <br> <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            //Pass control messages on if the gizmo's notify is ON. <br>            if (NULL!=pGB-&gt;hWndAssociate) <br>                { <br>                pGizmo=PGizmoFromHwndID(hWnd, wID); <br> <br>                if (NULL!=pGizmo) <br>                    { <br>                    if (pGizmo-&gt;fNotify) <br>                        { <br>                        SendMessage(pGB-&gt;hWndAssociate, iMsg, wParam <br>                            , lParam); <br>                        } <br>                    } <br>                } <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br>/* <br> * GizmoBarPaint <br> * <br> * Purpose: <br> *  Handles all WM_PAINT messages for the control and paints either <br> *  the entire thing or just one GizmoBar button if pGB-&gt;pGizmoPaint <br> *  is non-NULL. <br> * <br> * Parameters: <br> *  hWnd            HWND Handle to the control. <br> *  pGB             PGIZMOBAR control data pointer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void GizmoBarPaint(HWND hWnd, PGIZMOBAR pGB) <br>    { <br>    RECT            rc; <br>    HDC             hDC; <br>    HBRUSH          hBr=NULL; <br>    HPEN            hPen=NULL; <br>    PAINTGIZMO      pg; <br> <br>    hDC=BeginPaint(hWnd, &amp;pg.ps); <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    /* <br>     * The only part of the frame we need to draw is the bottom line, <br>     * so we inflate the rectangle such that all other parts are <br>     * outside the visible region. <br>     */ <br>    hBr=CreateSolidBrush(GetSysColor(COLOR_BTNFACE)); <br> <br>    if (NULL!=hBr) <br>        SelectObject(hDC, hBr); <br> <br>    hPen=CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME)); <br> <br>    if (NULL!=hPen) <br>        SelectObject(hDC, hPen); <br> <br>    Rectangle(hDC, rc.left-1, rc.top-1, rc.right+1, rc.bottom); <br> <br> <br>    /* <br>     * All that we have to do to draw the controls is start through <br>     * the list, ignoring anything but buttons, and calling BTTNCUR's <br>     * UIToolButtonDraw for buttons.  Since we don't even have to <br>     * track positions of things, we can just use an enum. <br>     */ <br> <br>    UIToolConfigureForDisplay(&amp;pg.tdd); <br>    GizmoPEnum(&amp;pGB-&gt;pGizmos, FEnumPaintGizmos, (DWORD)(LPTSTR)&amp;pg); <br> <br>    //Clean up <br>    EndPaint(hWnd, &amp;pg.ps); <br> <br>    if (NULL!=hBr) <br>        DeleteObject(hBr); <br> <br>    if (NULL!=hPen) <br>        DeleteObject(hPen); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FEnumPaintGizmos <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  draw them. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case a pointer to a PAINTGIZMO structure. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI FEnumPaintGizmos(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    PPAINTGIZMO     ppg=(PPAINTGIZMO)dw; <br>    RECT            rc, rcI; <br> <br>    //Only draw those marked for repaint. <br>    if ((GIZMOTYPE_DRAWN &amp; pGizmo-&gt;iType)) <br>        { <br>        SetRect(&amp;rc, pGizmo-&gt;x, pGizmo-&gt;y <br>            , pGizmo-&gt;x+pGizmo-&gt;dx, pGizmo-&gt;y+pGizmo-&gt;dy); <br> <br>        //Only draw gizmos in the repaint area <br>        if (IntersectRect(&amp;rcI, &amp;rc, &amp;ppg-&gt;ps.rcPaint)) <br>            { <br>            UIToolButtonDraw(ppg-&gt;ps.hdc, pGizmo-&gt;x, pGizmo-&gt;y <br>                , pGizmo-&gt;dx, pGizmo-&gt;dy, pGizmo-&gt;hBmp <br>                , pGizmo-&gt;cxImage, pGizmo-&gt;cyImage, pGizmo-&gt;iBmp <br>                , (UINT)pGizmo-&gt;uState, &amp;ppg-&gt;tdd); <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FEnumChangeFont <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  send a new font to them that's stored in PGIZMOBAR in dw. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the GizmoBar's pGB. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE otherwise. <br> */ <br> <br>BOOL WINAPI FEnumChangeFont(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    PGIZMOBAR   pGB=(PGIZMOBAR)dw; <br> <br>    //Only need to change fonts in windowed controls using WM_SETFONT <br>    if (NULL!=pGizmo-&gt;hWnd) <br>        { <br>        SendMessage(pGizmo-&gt;hWnd, WM_SETFONT <br>            , (WPARAM)pGB-&gt;hFont, 1L); <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FEnumEnable <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  enable or disable them from the WM_ENABLE message. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the GizmoBar's pGB. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI FEnumEnable(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    PGIZMOBAR   pGB=(PGIZMOBAR)dw; <br>    BOOL        fEnable=pGB-&gt;fEnabled; <br> <br>    //NOTE:  This code is duplicated in GBGizmoEnable in API.C <br>    if (NULL!=pGizmo-&gt;hWnd) <br>        EnableWindow(pGizmo-&gt;hWnd, fEnable); <br>    else <br>        { <br>        //If we're not down, command and attribute buttons act same. <br>        if (!(BUTTONGROUP_DOWN &amp; pGizmo-&gt;uState)) <br>            { <br>            GizmoPStateSet(pGB-&gt;hWnd, pGizmo, fEnable <br>                ? COMMANDBUTTON_UP : COMMANDBUTTON_DISABLED); <br>            } <br>        else <br>            { <br>            /* <br>             * Attribute buttons are a little more sensitive <br>             * with DOWNDISABLED <br>             */ <br>            GizmoPStateSet(pGB-&gt;hWnd, pGizmo, fEnable <br>                ? ATTRIBUTEBUTTON_DOWN <br>                : ATTRIBUTEBUTTON_DOWNDISABLED); <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * FEnumHitTest <br> * <br> * Purpose: <br> *  Enumeration callback for all the gizmos we know about in order to <br> *  hit-test them. <br> * <br> * Parameters: <br> *  pGizmo          PGIZMO to draw. <br> *  iGizmo          UINT index on the GizmoBar of this gizmo. <br> *  dw              DWORD extra data passed to GizmoPEnum, in our <br> *                  case the hDC on which to draw. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the enumeration, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL WINAPI FEnumHitTest(PGIZMO pGizmo, UINT iGizmo, DWORD dw) <br>    { <br>    RECT  rc; <br>    POINT pt; <br> <br>    POINTFROMLPARAM(pt, dw); <br> <br>    /* <br>     * Hit tests have to happen on visible, enabled, and drawn <br>     * controls only. <br>     */ <br>    if (GIZMOTYPE_DRAWN &amp; pGizmo-&gt;iType &amp;&amp; !pGizmo-&gt;fHidden <br>        &amp;&amp; !(BUTTONGROUP_DISABLED &amp; pGizmo-&gt;uState)) <br>        { <br>        SetRect(&amp;rc, pGizmo-&gt;x, pGizmo-&gt;y <br>            , pGizmo-&gt;x+pGizmo-&gt;dx, pGizmo-&gt;y+pGizmo-&gt;dy); <br> <br>        //Stop enumeration if we have a hit. <br>        return !PtInRect(&amp;rc, pt); <br>        } <br> <br>    return TRUE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
