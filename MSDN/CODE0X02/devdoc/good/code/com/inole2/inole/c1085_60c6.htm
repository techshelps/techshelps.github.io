<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BTTNCUR.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1086"></a>BTTNCUR.C</h2>
<pre><code>/* <br> * BTTNCUR.C <br> * Buttons &amp; Cursors <br> * <br> * Public functions to generate different states of toolbar buttons <br> * from a single bitmap.  States are normal, pressed, checked, and <br> * disabled. <br> * <br> * Copyright (c)1992-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br>//Cache GDI objects to speed drawing. <br>HDC     g_hDCGlyphs    = NULL; <br>HDC     g_hDCMono      = NULL; <br>HBRUSH  g_hBrushDither = NULL; <br> <br>//Standard images to use in case caller doesn't provide them <br>HBITMAP g_rghBmpStandardImages[3]; <br> <br>//Standard button colors. <br>const COLORREF g_crStandard[4]={ RGB(0, 0, 0)      //STDCOLOR_BLACK <br>                   , RGB(128, 128, 128)            //STDCOLOR_DKGRAY <br>                   , RGB(192, 192, 192)            //STDCOLOR_LTGRAY <br>                   , RGB(255, 255, 255)};          //STDCOLOR_WHITE <br> <br> <br>COLORREF g_crSys[5]; <br> <br> <br> <br>/* <br> * Mapping from image identifier to button type (command/attribute). <br> * Version 1.00 of this DLL has no attribute images defined, so <br> * the code will only support three states for each command <br> * button.  Any state is, however, valid for an application <br> * defined image. <br> */ <br> <br>UINT mpButtonType[TOOLIMAGE_MAX-TOOLIMAGE_MIN+1]= <br>        { <br>        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, <br>        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, <br>        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND <br>        }; <br> <br> <br>/* <br> * UIToolConfigureForDisplay <br> * Public API <br> * <br> * Purpose: <br> *  Initializes the library to scale button images for the display <br> *  type.  Without calling this function the library defaults to 96 <br> *  DPI (VGA).  By calling this function an application acknowledges <br> *  that it must use the data returned from this function to <br> *  configure itself for the display. <br> * <br> * Parameters: <br> *  lpDD            LPTOOLDISPLAYDATA to fill with the display- <br> *                  sensitive size values. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the sizes were obtained, FALSE otherwise. <br> */ <br> <br>BOOL WINAPI UIToolConfigureForDisplay(LPTOOLDISPLAYDATA lpDD) <br>    { <br>    int         cy; <br>    HDC         hDC; <br> <br> <br>    if (NULL==lpDD || IsBadWritePtr(lpDD, sizeof(TOOLDISPLAYDATA))) <br>        return FALSE; <br> <br>    /* <br>     * Determine the aspect ratio of the display we're currently <br>     * running on and calculate the necessary information. <br>     * <br>     * By retrieving the logical Y extent of the display driver, you <br>     * only have limited possibilities: <br>     *      LOGPIXELSY      Display <br>     *      ---------------------------------------- <br>     *         48             CGA    (unsupported) <br>     *         72             EGA <br>     *         96             VGA <br>     *        120             8514/a (i.e. HiRes VGA) <br>     */ <br> <br>    hDC=GetDC(NULL); <br> <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    cy=GetDeviceCaps(hDC, LOGPIXELSY); <br>    ReleaseDC(NULL, hDC); <br> <br>    /* <br>     * Instead of single comparisons, check ranges instead, so in <br>     * case we get something funky, we'll act reasonable. <br>     */ <br>    if (72 &gt;=cy) <br>        { <br>        lpDD-&gt;uDPI     =72; <br>        lpDD-&gt;cyBar    =CYBUTTONBAR72; <br>        lpDD-&gt;cxButton =TOOLBUTTON_STD72WIDTH; <br>        lpDD-&gt;cyButton =TOOLBUTTON_STD72HEIGHT; <br>        lpDD-&gt;cxImage  =TOOLBUTTON_STD72IMAGEWIDTH; <br>        lpDD-&gt;cyImage  =TOOLBUTTON_STD72IMAGEHEIGHT; <br>        lpDD-&gt;uIDImages=IDB_STANDARDIMAGES72; <br>        } <br>    else <br>        { <br>        if (72 &lt; cy &amp;&amp; 120 &gt; cy) <br>            { <br>            lpDD-&gt;uDPI     =96; <br>            lpDD-&gt;cyBar    =CYBUTTONBAR96; <br>            lpDD-&gt;cxButton =TOOLBUTTON_STD96WIDTH; <br>            lpDD-&gt;cyButton =TOOLBUTTON_STD96HEIGHT; <br>            lpDD-&gt;cxImage  =TOOLBUTTON_STD96IMAGEWIDTH; <br>            lpDD-&gt;cyImage  =TOOLBUTTON_STD96IMAGEHEIGHT; <br>            lpDD-&gt;uIDImages=IDB_STANDARDIMAGES96; <br>            } <br>        else <br>            { <br>            lpDD-&gt;uDPI     =120; <br>            lpDD-&gt;cyBar    =CYBUTTONBAR120; <br>            lpDD-&gt;cxButton =TOOLBUTTON_STD120WIDTH; <br>            lpDD-&gt;cyButton =TOOLBUTTON_STD120HEIGHT; <br>            lpDD-&gt;cxImage  =TOOLBUTTON_STD120IMAGEWIDTH; <br>            lpDD-&gt;cyImage  =TOOLBUTTON_STD120IMAGEHEIGHT; <br>            lpDD-&gt;uIDImages=IDB_STANDARDIMAGES120; <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * ToolButtonInit <br> * Internal <br> * <br> * Purpose: <br> *  Initializes GDI objects for drawing images through <br> *  UIToolButtonDraw. If the function fails, the function has <br> *  already performed proper cleanup. <br> * <br> * Parameters: <br> *  hInst           HINSTANCE of the DLL <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded.  FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL ToolButtonInit(HINSTANCE hInst) <br>    { <br>    UINT        i; <br> <br>    //DC for BitBltting the image (the glyph) <br>    g_hDCGlyphs=CreateCompatibleDC(NULL); <br> <br>    //Create a monochrome DC and a brush for doing pattern dithering. <br>    g_hDCMono=CreateCompatibleDC(NULL); <br> <br>    g_hBrushDither=HBrushDitherCreate(GetSysColor(COLOR_BTNFACE) <br>        , GetSysColor(COLOR_BTNHIGHLIGHT)); <br> <br>    for (i=0; i &lt; 3; i++) <br>        { <br>        g_rghBmpStandardImages[i]=LoadBitmap(hInst <br>            , MAKEINTRESOURCE(IDB_STANDARDIMAGESMIN+i)); <br>        } <br> <br>    if (NULL==g_hDCGlyphs || NULL==g_hDCMono <br>        || NULL==g_hBrushDither || NULL==g_rghBmpStandardImages[0]) <br>        { <br>        //On failure, cleanup whatever might have been allocated. <br>        ToolButtonFree(); <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ToolButtonFree <br> * Internal <br> * <br> * Purpose: <br> *  Free all GDI allocations made during initialization. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void ToolButtonFree(void) <br>    { <br>    UINT        i; <br> <br>    if (NULL!=g_hDCMono) <br>        DeleteDC(g_hDCMono); <br> <br>    g_hDCMono=NULL; <br> <br>    if (NULL!=g_hDCGlyphs) <br>        DeleteDC(g_hDCGlyphs); <br> <br>    g_hDCGlyphs=NULL; <br> <br>    if (NULL!=g_hBrushDither) <br>        DeleteObject(g_hBrushDither); <br> <br>    g_hBrushDither=NULL; <br> <br>    for (i=0; i &lt; 3; i++) <br>        { <br>        if (NULL!=g_rghBmpStandardImages[i]) <br>            DeleteObject(g_rghBmpStandardImages[i]); <br> <br>        g_rghBmpStandardImages[i]=NULL; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * HBrushDitherCreate <br> * Internal <br> * <br> * Purpose: <br> *  Creates and returns a handle to a pattern brush created from <br> *  an 8*8 monochrome pattern bitmap.  We use the button face and <br> *  highlight colors to indicate the resulting colors of a PatBlt <br> *  using this brush. <br> * <br> * Parameters: <br> *  rgbFace         COLORREF of the button face color. <br> *  rgbHilight      COLORREF of the button highlight color. <br> * <br> * Return Value: <br> *  HBITMAP         Handle to the dither bitmap. <br> */ <br> <br>HBRUSH HBrushDitherCreate(COLORREF rgbFace, COLORREF rgbHilight) <br>    { <br>    struct  //BITMAPINFO with 16 colors <br>        { <br>        BITMAPINFOHEADER    bmiHeader; <br>        RGBQUAD             bmiColors[16]; <br>        } bmi; <br> <br>    HBRUSH          hBrush=NULL; <br>    DWORD           patGray[8]; <br>    HDC             hDC; <br>    HBITMAP         hBmp; <br>    static COLORREF rgbFaceOld   =0xFFFFFFFF;  //Initially impossible <br>    static COLORREF rgbHilightOld=0xFFFFFFFF;  //Initially impossible <br> <br>    /* <br>     * If the colors haven't changed from last time, just return the <br>     * existing brush. <br>     */ <br>    if (rgbFace==rgbFaceOld &amp;&amp; rgbHilight==rgbHilightOld) <br>        return g_hBrushDither; <br> <br>    rgbFaceOld=rgbFace; <br>    rgbHilightOld=rgbHilight; <br> <br>    /* <br>     * We're going to create an 8*8 brush for PatBlt using the <br>     * button face color and button highlight color.  We use this <br>     * brush to affect the pressed state and the disabled state. <br>     */ <br>    bmi.bmiHeader.biSize         = sizeof(BITMAPINFOHEADER); <br>    bmi.bmiHeader.biWidth        = 8; <br>    bmi.bmiHeader.biHeight       = 8; <br>    bmi.bmiHeader.biPlanes       = 1; <br>    bmi.bmiHeader.biBitCount     = 1; <br>    bmi.bmiHeader.biCompression  = BI_RGB; <br>    bmi.bmiHeader.biSizeImage    = 0; <br>    bmi.bmiHeader.biXPelsPerMeter= 0; <br>    bmi.bmiHeader.biYPelsPerMeter= 0; <br>    bmi.bmiHeader.biClrUsed      = 0; <br>    bmi.bmiHeader.biClrImportant = 0; <br> <br>    bmi.bmiColors[0].rgbBlue     = GetBValue(rgbFace); <br>    bmi.bmiColors[0].rgbGreen    = GetGValue(rgbFace); <br>    bmi.bmiColors[0].rgbRed      = GetRValue(rgbFace); <br>    bmi.bmiColors[0].rgbReserved = 0; <br> <br>    bmi.bmiColors[1].rgbBlue     = GetBValue(rgbHilight); <br>    bmi.bmiColors[1].rgbGreen    = GetGValue(rgbHilight); <br>    bmi.bmiColors[1].rgbRed      = GetRValue(rgbHilight); <br>    bmi.bmiColors[1].rgbReserved = 0; <br> <br>    //Create the byte array for CreateDIBitmap. <br>    patGray[6]=patGray[4]=patGray[2]=patGray[0]=0x5555AAAAL; <br>    patGray[7]=patGray[5]=patGray[3]=patGray[1]=0xAAAA5555L; <br> <br>    //Create the bitmap <br>    hDC=GetDC(NULL); <br>    hBmp=CreateDIBitmap(hDC, &amp;bmi.bmiHeader, CBM_INIT, patGray <br>                        , (LPBITMAPINFO)&amp;bmi, DIB_RGB_COLORS); <br>    ReleaseDC(NULL, hDC); <br> <br>    //Create the brush from the bitmap <br>    if (NULL!=hBmp) <br>        { <br>        hBrush=CreatePatternBrush(hBmp); <br>        DeleteObject(hBmp); <br>        } <br> <br>    /* <br>     * If we could recreate a brush, clean up and make it the current <br>     * pattern.  Otherwise the best we can do it return the old one, <br>     * which will be colored wrong, but at least it works. <br>     */ <br>    if (NULL!=hBrush) <br>        { <br>        if (NULL!=g_hBrushDither) <br>            DeleteObject(g_hBrushDither); <br> <br>        g_hBrushDither=hBrush; <br>        } <br> <br>    return g_hBrushDither; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * UIToolButtonDraw <br> * Public API <br> * <br> * Purpose: <br> *  Draws the complete image of a toolbar-style button with a given <br> *  image in the center and in a specific state.  The button is drawn <br> *  on a specified hDC at a given location, so this function is <br> *  useful on standard owner-draw buttons as well as on toolbar <br> *  controls that have only one window but show images of multiple <br> *  buttons. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw. <br> *  x, y            int coordinates at which to draw. <br> *  dx, dy          int dimensions of the *button*, not the image. <br> *  hBmp            HBITMAP from which to draw the image. <br> *  bmx, bmy        int dimensions of each bitmap in hBmp.  If hBmp <br> *                  is NULL then these are forced to the standard <br> *                  sizes. <br> *  iImage          int index to the image to draw in the button <br> *  uStateIn        UINT containing the state index for the button <br> *                  and the color control bits. <br> *  pTDD            LPTOOLDISPLAYDATA containing display <br> *                  configuration. Can be NULL if hBmp is non-NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if drawing succeeded, FALSE otherwise <br> *                  meaning that hDC is NULL or hBmp is NULL and <br> *                  iImage is not a valid index for a standard image. <br> */ <br> <br>BOOL WINAPI UIToolButtonDraw(HDC hDC, int x, int y, int dx, int dy <br>    , HBITMAP hBmp, int bmx, int bmy, int iImage, UINT uStateIn <br>    , LPTOOLDISPLAYDATA pTDD) <br>    { <br>    UINT            uState=(UINT)LOBYTE((WORD)uStateIn); <br>    UINT            uColors=(UINT)HIBYTE((WORD)uStateIn <br>                        &amp; PRESERVE_ALL); <br>    int             xOffsetGlyph, yOffsetGlyph; <br>    int             i, iSaveDC; <br>    HDC             hMemDC; <br>    HGDIOBJ         hObj; <br>    HBRUSH          hBR; <br>    HBITMAP         hBmpT; <br>    HBITMAP         hBmpMono; <br>    HBITMAP         hBmpMonoOrg; <br>    HBITMAP         hBmpSave=NULL; <br>    TOOLDISPLAYDATA tdd; <br> <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    if (NULL==pTDD) <br>        { <br>        pTDD=&amp;tdd; <br>        UIToolConfigureForDisplay(pTDD); <br>        } <br> <br>    /* <br>     * If we're given no image bitmap, then use the standard and <br>     * validate the image index.  We also enforce the standard <br>     * bitmap size and the size of the button (as requested by <br>     * User Interface designers). <br>     */ <br>    if (NULL==hBmp &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>        { <br>        i=pTDD-&gt;uIDImages-IDB_STANDARDIMAGESMIN; <br>        hBmp=g_rghBmpStandardImages[i]; <br> <br>        bmx=pTDD-&gt;cxImage;            //Force bitmap dimensions <br>        bmy=pTDD-&gt;cyImage; <br> <br>        dx=pTDD-&gt;cxButton;            //Force button dimensions <br>        dy=pTDD-&gt;cyButton; <br> <br>        if (iImage &gt; TOOLIMAGE_MAX) <br>            return FALSE; <br> <br>        /* <br>         * If we are using a standard command button, verify that <br>         * the state does not contain the LIGHTFACE group which <br>         * only applies to attribute buttons. <br>         */ <br>        if (BUTTONTYPE_COMMAND==mpButtonType[iImage] <br>            &amp;&amp; (uState &amp; BUTTONGROUP_LIGHTFACE)) <br>            return FALSE; <br>        } <br> <br>    //Create a dithered bitmap. <br>    hBmpMono=CreateBitmap(dx-2, dy-2, 1, 1, NULL); <br> <br>    if (NULL==hBmpMono) <br>        return FALSE; <br> <br>    hBmpMonoOrg=(HBITMAP)SelectObject(g_hDCMono,  hBmpMono); <br> <br> <br>    //Save the DC state before we munge on it. <br>    iSaveDC=SaveDC(hDC); <br> <br>    /* <br>     * Draw a button sans image.  This also fills g_crSys with the <br>     * system colors for us which has space for five colors. <br>     * We don't use the fifth, the frame color, in this function. <br>     */ <br>    DrawBlankButton(hDC, x, y, dx, dy <br>        , (BOOL)(uState &amp; BUTTONGROUP_DOWN), g_crSys); <br> <br>    //Shift coordinates to account for the button's border <br>    x++; <br>    y++; <br>    dx-=2; <br>    dy-=2; <br> <br>    /* <br>     * Determine the offset necessary to center the image but also <br>     * reflect the pushed-in state, which means just adding 1 to <br>     * the up state. <br>     */ <br>    i=(uState &amp; BUTTONGROUP_DOWN) ? 1 : 0; <br>    xOffsetGlyph=((dx-bmx) &gt;&gt; 1)+i; <br>    yOffsetGlyph=((dy-bmy) &gt;&gt; 1)+i; <br> <br> <br>    //Select given image into the glyph DC before calling MaskCreate <br>    if (NULL!=hBmp) <br>        hBmpSave=(HBITMAP)SelectObject(g_hDCGlyphs, hBmp); <br> <br> <br>    /* <br>     * Draw the face on the button.  If we have an up or [mouse]down <br>     * button then we can just draw it as-is.  For indeterminate, <br>     * disabled, or down disabled we have to gray the image and <br>     * possibly add a white shadow to it (disabled/down disabled). <br>     * <br>     * Also note that for the intermediate state we first draw the <br>     * normal up state, then proceed to add disabling looking <br>     * highlights. <br>     */ <br> <br>    //Up, mouse down, down, indeterminate <br>    if ((uState &amp; BUTTONGROUP_ACTIVE) <br>        &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>        { <br>        BOOL            fColorsSame=TRUE; <br> <br>        /* <br>         * In here we pay close attention to the system colors. <br>         * Where the source image is black, we paint COLOR_BTNTEXT. <br>         * Where light gray, we paint COLOR_BTNFACE.  Where dark gray <br>         * we paint COLOR_BTNSHADOW, and where white we paint <br>         * COLOR_BTNHILIGHT. <br>         * <br>         * The uColors variable contains flags to prevent color <br>         * conversion.  To do a little optimization, we just do a <br>         * single BitBlt if we're preserving all colors or if no <br>         * colors are different than the standards, which is by far <br>         * the most common case.  Otherwise, cycle through the four <br>         * colors we can convert and do a BitBlt that converts it to <br>         * the system color. <br>         */ <br> <br>        //See what colors are different. <br>        for (i=STDCOLOR_BLACK; i&lt;=STDCOLOR_WHITE; i++) <br>            fColorsSame &amp;= (g_crSys[i]==g_crStandard[i]); <br> <br>        if (PRESERVE_ALL==uColors || fColorsSame) <br>            { <br>            BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, bmx, bmy <br>                , g_hDCGlyphs, iImage*bmx, 0, SRCCOPY); <br>            } <br>        else <br>            { <br>            /* <br>             * Cycle through hard-coded colors and create a mask that <br>             * has all regions of that color in white and all other <br>             * regions black.  Then we select a pattern brush of the <br>             * color to convert to: if we aren't converting the color <br>             * then we use a brush of the standard hard-coded color, <br>             * otherwise we use the actual system color.  The <br>             * ROP_DSPDxax means that anything that's 1's in the mask <br>             * get the pattern, anything that's 0 is unchanged in <br>             * the destination. <br>             * <br>             * To prevent too many Blts to the screen, we use an <br>             * intermediate bitmap and DC. <br>             */ <br> <br>            hMemDC=CreateCompatibleDC(hDC); <br> <br>            //Make sure conversion of monochrome to color stays B&amp;W <br>            SetTextColor(hMemDC, 0L);                 //mono 0's-&gt;0 <br>            SetBkColor(hMemDC, (COLORREF)0x00FFFFFF); //mono 1's-&gt;1 <br> <br>            hBmpT=CreateCompatibleBitmap(hDC, bmx, bmy); <br>            SelectObject(hMemDC, hBmpT); <br> <br>            //Copy the unmodified bitmap to the temporary bitmap <br>            BitBlt(hMemDC, 0, 0, bmx, bmy, g_hDCGlyphs, iImage*bmx <br>                , 0, SRCCOPY); <br> <br>            for (i=STDCOLOR_BLACK; i&lt;=STDCOLOR_WHITE; i++) <br>                { <br>                //Convert pixels of convert color to 1's in the mask <br>                SetBkColor(g_hDCGlyphs, g_crStandard[i]); <br>                BitBlt(g_hDCMono, 0, 0, bmx, bmy, g_hDCGlyphs, iImage*bmx <br>                    , 0, SRCCOPY); <br> <br>                //Preserve or modify the color depending on the flag. <br>                hBR=CreateSolidBrush((uColors &amp; (1 &lt;&lt; i)) <br>                    ? g_crStandard[i] : g_crSys[i]); <br> <br>                if (NULL!=hBR) <br>                    { <br>                    hObj=SelectObject(hMemDC, hBR); <br> <br>                    if (NULL!=hObj) <br>                        { <br>                        BitBlt(hMemDC, 0, 0, dx-1, dy-1, g_hDCMono, 0 <br>                            , 0, ROP_DSPDxax); <br>                        SelectObject(hMemDC, hObj); <br>                        } <br> <br>                    DeleteObject(hBR); <br>                    } <br>                } <br> <br>            //Now put the final version on the display and clean up <br>            BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, dx-1, dy-1 <br>                   , hMemDC, 0, 0, SRCCOPY); <br> <br>            DeleteDC(hMemDC); <br>            DeleteObject(hBmpT); <br> <br>            } <br>        } <br> <br> <br>    //Disabled and indeterminate states (unless we're blank) <br>    if ((uState &amp; BUTTONGROUP_DISABLED <br>        || ATTRIBUTEBUTTON_INDETERMINATE==uState) <br>        &amp;&amp; !(uState &amp; BUTTONGROUP_BLANK)) <br>        { <br>        //Grayed state (up or down, no difference) <br>        MaskCreate(iImage, dx, dy, bmx, bmy, xOffsetGlyph <br>            , yOffsetGlyph, 0); <br> <br>        //Make sure conversion of monochrome to color stays B&amp;W <br>        SetTextColor(hDC, 0L);                     //0's in mono -&gt; 0 <br>        SetBkColor(hDC, (COLORREF)0x00FFFFFF);     //1's in mono -&gt; 1 <br> <br>        //If we're disabled, up or down, draw the highlighted shadow. <br>        if (uState &amp; BUTTONGROUP_DISABLED) <br>            { <br>            hBR=CreateSolidBrush(g_crSys[SYSCOLOR_HILIGHT]); <br> <br>            if (NULL!=hBR) <br>                { <br>                hObj=SelectObject(hDC, hBR); <br> <br>                if (NULL!=hObj) <br>                    { <br>                    //Draw hilight color where we have 0's in mask <br>                    BitBlt(hDC, x+1, y+1, dx-2, dy-2, g_hDCMono, 0, 0 <br>                        , ROP_PSDPxax); <br>                    SelectObject(hDC, hObj); <br>                    } <br>                DeleteObject(hBR); <br>                } <br>            } <br> <br>        //Draw the gray image. <br>        hBR=CreateSolidBrush(g_crSys[SYSCOLOR_SHADOW]); <br> <br>        if (NULL!=hBR) <br>            { <br>            hObj=SelectObject(hDC, hBR); <br> <br>            if (NULL!=hObj) <br>                { <br>                //Draw the shadow color where we have 0's in the mask <br>                BitBlt(hDC, x, y, dx-2, dy-2, g_hDCMono, 0, 0 <br>                    , ROP_PSDPxax); <br>                SelectObject(hDC, hObj); <br>                } <br> <br>            DeleteObject(hBR); <br>            } <br>        } <br> <br>    //If the button is selected do the dither brush avoiding glyph <br>    if (uState &amp; BUTTONGROUP_LIGHTFACE) <br>        { <br>        HBRUSH      hBRDither; <br> <br>        /* <br>         * Get the dither brush.  This function will recreate it if <br>         * necessary or return the global one if the colors already <br>         * match. <br>         */ <br>        hBRDither=HBrushDitherCreate(g_crSys[SYSCOLOR_FACE] <br>            , g_crSys[SYSCOLOR_HILIGHT]); <br>        hObj=SelectObject(hDC, hBRDither); <br> <br>        if (NULL!=hObj) <br>            { <br>            /* <br>             * The mask we create now determines where the dithering <br>             * ends up.  In the down disabled state, we have to <br>             * preserve the highlighted shadow, so the mask we create <br>             * must have two masks of the original glyph, one of them <br>             * offset by one pixel in both x &amp; y.  For the <br>             * indeterminate state, we have to mask all highlighted <br>             * areas.  The state passed to MaskCreate matters here <br>             * (we've used zero before). <br>             */ <br>            MaskCreate(iImage, dx, dy, bmx, bmy <br>                       , xOffsetGlyph-1, yOffsetGlyph-1, uState); <br> <br>            //Convert monochrome masks to B&amp;W color bitmap in BitBlt. <br>            SetTextColor(hDC, 0L); <br>            SetBkColor(hDC, (COLORREF)0x00FFFFFF); <br> <br>            /* <br>             * Only draw the dither brush where the mask is 1's.  For <br>             * the indeterminate state we have to not overdraw the <br>             * shadow highlight so we use dx-3, dy-3 instead of dx-1 <br>             * and dy-1.  We do this whether or not we're blank. <br>             */ <br>            i=(ATTRIBUTEBUTTON_INDETERMINATE==uState <br>               || BLANKBUTTON_INDETERMINATE==uState) ? 3 : 1; <br> <br>            BitBlt(hDC, x+1, y+1, dx-i, dy-i, g_hDCMono, 0, 0 <br>                , ROP_DSPDxax); <br>            SelectObject(hDC, hObj); <br>            } <br> <br>        //DO NOT delete hBRDither!  It's a shared global. <br>        } <br> <br>    //Cleanup g_hDCGlyphs:  Must do AFTER calling MaskCreate <br>    if (NULL!=hBmpSave) <br>        SelectObject(g_hDCGlyphs, hBmpSave); <br> <br>    SelectObject(g_hDCMono,   hBmpMonoOrg); <br>    DeleteObject(hBmpMono); <br> <br>    //Restore everything in the DC. <br>    RestoreDC(hDC, iSaveDC); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * DrawBlankButton <br> * <br> * Purpose: <br> *  Draws a button with no face using the current system colors in <br> *  either an up or down state. <br> * <br> * Parameters: <br> *  hDC             HDC on which to draw <br> *  x, y            int coordinates where we start drawing <br> *  dx,dy           int size of the button <br> *  fDown           BOOL indicating the up or down state of the <br> *                  button <br> *  pcr             COLORREF * to five colors in which we store text, <br> *                  shadow, face, highlight, and frame colors.  This <br> *                  is a matter of convenience for the caller, since <br> *                  we have to load these colors anyway we might as <br> *                  well send them back. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void DrawBlankButton(HDC hDC, int x, int y, int dx, int dy <br>    , BOOL fDown, COLORREF *pcr) <br>    { <br>    //Get the current system colors for buttons. <br>    pcr[0]=GetSysColor(COLOR_BTNTEXT); <br>    pcr[1]=GetSysColor(COLOR_BTNSHADOW); <br>    pcr[2]=GetSysColor(COLOR_BTNFACE); <br>    pcr[3]=GetSysColor(COLOR_BTNHIGHLIGHT); <br>    pcr[4]=GetSysColor(COLOR_WINDOWFRAME); <br> <br>    //Draw the border around the button. <br>    PatB(hDC, x+1,    y,      dx-2, 1,    pcr[4]); <br>    PatB(hDC, x+1,    y+dy-1, dx-2, 1,    pcr[4]); <br>    PatB(hDC, x,      y+1,    1,    dy-2, pcr[4]); <br>    PatB(hDC, x+dx-1, y+1,    1,    dy-2, pcr[4]); <br> <br>    //Shift coordinates to account for the border we just drew <br>    x++; <br>    y++; <br>    dx-=2; <br>    dy-=2; <br> <br>    //Paint the interior grey as a default. <br>    PatB(hDC, x, y, dx, dy, pcr[2]); <br> <br>    /* <br>     * Draw shadows and highlights.  The DOWN grouping that contains <br>     * down, mouse down, and down disabled are drawn depressed.  Up, <br>     * indeterminate, and disabled are drawn up. <br>     */ <br> <br>    if (fDown) <br>        { <br>        PatB(hDC, x, y, 1,  dy, pcr[1]); <br>        PatB(hDC, x, y, dx, 1,  pcr[1]); <br>        } <br>    else <br>        { <br>        //Normal button look. <br>        PatB(hDC, x, y, 1,    dy-1, pcr[3]); <br>        PatB(hDC, x, y, dx-1, 1,    pcr[3]); <br> <br>        PatB(hDC, x+dx-1, y,      1,  dy, pcr[1]); <br>        PatB(hDC, x,      y+dy-1, dx, 1,  pcr[1]); <br> <br>        PatB(hDC, x+1+dx-3, y+1,    1,    dy-2, pcr[1]); <br>        PatB(hDC, x+1,      y+dy-2, dx-2, 1,    pcr[1]); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * PatB <br> * Internal <br> * <br> * Purpose: <br> *  A more convenient PatBlt operation for drawing button borders and <br> *  highlights. <br> * <br> * Parameters: <br> *  hDC             HDC on which to paint. <br> *  x, y            int coordinates at which to paint. <br> *  dx, dy          int dimensions of rectangle to paint. <br> *  rgb             COLORREF to use as the background color. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void PatB(HDC hDC, int x, int y, int dx, int dy, COLORREF rgb) <br>    { <br>    RECT        rc; <br> <br>    SetBkColor(hDC, rgb); <br>    SetRect(&amp;rc, x, y, x+dx, y+dy); <br>    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, NULL, 0, NULL); <br>    } <br> <br> <br> <br> <br>/* <br> * MaskCreate <br> * Internal <br> * <br> * Purpose: <br> *  Creates a monochrome mask bitmap of the given image at the given <br> *  offset in the global g_hDCMono.  Anywhere in the image that you <br> *  have the light gray (STDCOLOR_LTGRAY) or the white highlight <br> *  (STDCOLOR_WHITE) you get get 1's.  All other pixels are 0's <br> * <br> * Parameters: <br> *  iImage          UINT index of the image for which to create a <br> *                  mask. <br> *  dx, dy          int dimensions of the button. <br> *  bmx, bmy        int dimensions of the bitmap to use. <br> *  xOffset         int offset for x inside g_hDCMono where we paint. <br> *  yOffset         int offset for y inside g_hDCMono where we paint. <br> *  uState          UINT state of the image.  Special cases are made <br> *                  for ATTRIBUTEBUTTON_DOWNDISABLED and <br> *                  ATTRIBUTEBUTTON_INDETERMINATE.  In any case <br> *                  where you do not want a special case, pass zero <br> *                  here, regardless of the true button state. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void MaskCreate(UINT iImage, int dx, int dy, int bmx, int bmy <br>    ,int xOffset, int yOffset, UINT uState) <br>    { <br>    //Initalize whole area with zeros <br>    PatBlt(g_hDCMono, 0, 0, dx, dy, WHITENESS); <br> <br>    if (uState &amp; BUTTONGROUP_BLANK) <br>        return; <br> <br>    //Convert face colored pixels to 1's. all others to black. <br>    SetBkColor(g_hDCGlyphs, g_crStandard[STDCOLOR_LTGRAY]); <br>    BitBlt(g_hDCMono, xOffset, yOffset, bmx, bmy, g_hDCGlyphs <br>        , iImage*bmx, 0, SRCCOPY); <br> <br>    //Indeterminate state, don't turn highlight's to 1's--leave black <br>    if (ATTRIBUTEBUTTON_INDETERMINATE!=uState) <br>        { <br>        //Convert highlight colored pixels to 1's, OR with previous. <br>        SetBkColor(g_hDCGlyphs, g_crStandard[STDCOLOR_WHITE]); <br>        BitBlt(g_hDCMono, xOffset, yOffset, bmx, bmy, g_hDCGlyphs <br>            , iImage*bmx, 0, SRCPAINT); <br>        } <br> <br>    /* <br>     * For the down disabled state, AND this same mask with itself at <br>     * an offset of 1, which accounts for the highlight shadow. <br>     */ <br>    if (ATTRIBUTEBUTTON_DOWNDISABLED==uState) <br>        BitBlt(g_hDCMono, 1, 1, dx-1, dy-1, g_hDCMono,  0, 0, SRCAND); <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
