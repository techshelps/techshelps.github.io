<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HELPERS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1093"></a>HELPERS.CPP</h2>
<pre><code>/* <br> * HELPERS.CPP <br> * <br> * Utility functions for drawing various graphical effects <br> * as well as coordinate conversion functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br> <br>/* <br> * INOLE_MetafilePictIconFree <br> * <br> * Purpose: <br> *  Deletes the metafile contained in a METAFILEPICT structure and <br> *  frees the memory for the structure itself. <br> * <br> * Parameters: <br> *  hMetaPict       HGLOBAL metafilepict structure created in <br> *                  OleMetafilePictFromIconAndLabel <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) INOLE_MetafilePictIconFree(HGLOBAL hMetaPict) <br>   { <br>   LPMETAFILEPICT      pMF; <br> <br>   if (NULL==hMetaPict) <br>      return; <br> <br>   pMF=(LPMETAFILEPICT)GlobalLock(hMetaPict); <br> <br>   if (NULL!=pMF) <br>      { <br>      if (NULL!=pMF-&gt;hMF) <br>         DeleteMetaFile(pMF-&gt;hMF); <br>      } <br> <br>   GlobalUnlock(hMetaPict); <br>   GlobalFree(hMetaPict); <br>   return; <br>   } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_SwitchDisplayAspect <br> * <br> * Purpose: <br> *  Switch the currently cached display aspect between DVASPECT_ICON <br> *  and DVASPECT_CONTENT.  When setting up icon aspect, any currently <br> *  cached content cache is discarded and any advise connections for <br> *  content aspect are broken. <br> * <br> * Parameters: <br> *  pObj            IUnknown * to the object in question <br> *  pdwCurAspect    DWORD * containing the current aspect which <br> *                  will contain the new aspect on output. <br> *  dwNewAspect     DWORD with the aspect to switch to. <br> *  hMetaPict       HGLOBAL containing the CF_METAFILEPICT with <br> *                  the icon. <br> *  fDeleteOld      BOOL indicating if we're to delete the old <br> *                  aspect from the cache. <br> *  fViewAdvise     BOOL indicating if we're to establish an <br> *                  advise with the object for this new aspect. <br> *  pSink           IAdviseSink * to the notification sink. <br> *  pfMustUpdate    BOOL * in which to return whether or not <br> *                  an update from a running server is necessary. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or an error code in which case the cache <br> *                  remains unchanged. <br> */ <br> <br>STDAPI INOLE_SwitchDisplayAspect(IUnknown *pObj, LPDWORD pdwCurAspect <br>    , DWORD dwNewAspect, HGLOBAL hMetaPict, BOOL fDeleteOld <br>    , BOOL fViewAdvise, IAdviseSink *pSink, BOOL *pfMustUpdate) <br>    { <br>    IOleCache      *pCache=NULL; <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br>    DWORD           dwAdvf; <br>    DWORD           dwNewConnection; <br>    DWORD           dwOldAspect=*pdwCurAspect; <br>    HRESULT         hr; <br> <br>    if (pfMustUpdate) <br>       *pfMustUpdate=FALSE; <br> <br>    hr=pObj-&gt;QueryInterface(IID_IOleCache, (void **)&amp;pCache); <br> <br>    if (FAILED(hr)) <br>       return ResultFromScode(E_FAIL); <br> <br>    //Establish new cache with the new aspect <br>    SETFormatEtc(fe, 0, dwNewAspect, NULL, TYMED_NULL, -1); <br> <br>    /* <br>     * If we are using a custom icon for the display aspect then <br>     * we won't want to establish notifications with the data <br>     * source, that is, we don't want to change the icon.  Otherwise <br>     * we link up the given advise sink. <br>     */ <br>    if (DVASPECT_ICON==dwNewAspect &amp;&amp; NULL!=hMetaPict) <br>       dwAdvf=ADVF_NODATA; <br>    else <br>       dwAdvf=ADVF_PRIMEFIRST; <br> <br>    hr=pCache-&gt;Cache(&amp;fe, dwAdvf, &amp;dwNewConnection); <br> <br>    if (FAILED(hr)) <br>        { <br>        pCache-&gt;Release(); <br>        return hr; <br>        } <br> <br>    *pdwCurAspect=dwNewAspect; <br> <br>    /* <br>     * Stuff the custom icon into the cache, or force an update <br>     * from the server. <br>     */ <br>    if (DVASPECT_ICON==dwNewAspect &amp;&amp; NULL!=hMetaPict) <br>        { <br>        SETFormatEtc(fe, CF_METAFILEPICT, DVASPECT_ICON, NULL <br>            , TYMED_MFPICT, -1); <br> <br>        stm.tymed=TYMED_MFPICT; <br>        stm.hGlobal=hMetaPict; <br>        stm.pUnkForRelease=NULL; <br> <br>        hr=pCache-&gt;SetData(&amp;fe, &amp;stm, FALSE); <br>        } <br>    else <br>        { <br>        if (pfMustUpdate) <br>           *pfMustUpdate=TRUE; <br>        } <br> <br>    if (fViewAdvise &amp;&amp; pSink) <br>        { <br>        IViewObject    *pView=NULL; <br> <br>        hr=pObj-&gt;QueryInterface(IID_IViewObject, (void **)&amp;pView); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            pView-&gt;SetAdvise(dwNewAspect, 0, pSink); <br>            pView-&gt;Release(); <br>            } <br>        } <br> <br>    /* <br>     * Remove existing caches for the old display aspect to cut <br>     * down on needless storage overhead.  If you want to switch <br>     * frequently between icon and content aspects, then it is <br>     * best to actually keep both presentations in the cache. <br>     */ <br>    if (fDeleteOld) <br>        { <br>        IEnumSTATDATA  *pEnum=NULL; <br>        STATDATA        sd; <br> <br>        hr=pCache-&gt;EnumCache(&amp;pEnum); <br> <br>        while(NOERROR==hr) <br>            { <br>            hr=pEnum-&gt;Next(1, &amp;sd, NULL); <br> <br>            if (NOERROR==hr) <br>                { <br>                //Remove old aspect caches <br>                if (sd.formatetc.dwAspect==dwOldAspect) <br>                    pCache-&gt;Uncache(sd.dwConnection); <br>                } <br>            } <br> <br>        if (NULL!=pEnum) <br>            pEnum-&gt;Release(); <br>        } <br> <br>    pCache-&gt;Release(); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * INOLE_SetIconInCache <br> * <br> * Purpose: <br> *  Stores an iconic presentation metafile in the cache. <br> * <br> * Parameters: <br> *  pObj            IUnknown * of the object. <br> *  hMetaPict       HGLOBAL containing the presentation. <br> * <br> * Return Value: <br> *  HRESULT         From IOleCache::SetData. <br> */ <br> <br>STDAPI INOLE_SetIconInCache(IUnknown *pObj, HGLOBAL hMetaPict) <br>    { <br>    IOleCache      *pCache; <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br>    HRESULT         hr; <br> <br>    if (NULL==hMetaPict) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    if (FAILED(pObj-&gt;QueryInterface(IID_IOleCache, (void **)&amp;pCache))) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    SETFormatEtc(fe, CF_METAFILEPICT, DVASPECT_ICON, NULL <br>        , TYMED_MFPICT, -1); <br> <br>    stm.tymed=TYMED_MFPICT; <br>    stm.hGlobal=hMetaPict; <br>    stm.pUnkForRelease=NULL; <br> <br>    hr=pCache-&gt;SetData(&amp;fe, &amp;stm, FALSE); <br>    pCache-&gt;Release(); <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_GetUserTypeOfClass <br> * <br> * Purpose: <br> *  Returns the user type (human readable class name) of the <br> *  specified class as stored in the registry. <br> * <br> * Parameters: <br> *  clsID           CLSID in question <br> *  iName           UINT index to the name to retrieve, where <br> *                  zero is the name found as the value of <br> *                  of the CLSID, anything else tries <br> *                  AuxUserType\iName. <br> *  pszUserType     LPTSTR in which to return the type <br> *  cch             UINT length of pszUserType <br> * <br> * Return Value: <br> *  UINT            Number of characters in returned string. <br> *                  0 on error. <br> */ <br> <br>STDAPI_(UINT) INOLE_GetUserTypeOfClass(REFCLSID clsID, UINT iName <br>    , LPTSTR pszUserType, UINT cch) <br>    { <br>    LPTSTR      pszCLSID; <br>    LPTSTR      pszProgID; <br>    TCHAR       szKey[300]; <br>    LONG        dw; <br>    LONG        lRet; <br> <br>    if (!pszUserType) <br>        return 0; <br> <br>    *pszUserType='\0'; <br> <br>    //Get a string containing the class name <br>    StringFromCLSID(clsID, &amp;pszCLSID); <br> <br>    if (0==iName) <br>        wsprintf(szKey, TEXT("CLSID\\%s"), pszCLSID); <br>    else <br>        { <br>        wsprintf(szKey, TEXT("CLSID\\%s\\AuxUserType\\%u") <br>            , pszCLSID, iName); <br>        } <br> <br>    CoTaskMemFree(pszCLSID); <br> <br>    dw=cch; <br>    lRet=RegQueryValue(HKEY_CLASSES_ROOT, szKey, pszUserType, &amp;dw); <br> <br>    if (ERROR_SUCCESS!=lRet) <br>        { <br>        lstrcpyn(pszUserType, TEXT("Unknown"), cch); <br> <br>        if (CoIsOle1Class(clsID)) <br>            { <br>            //Try to get ProgID value for OLE 1 class <br>            ProgIDFromCLSID(clsID, &amp;pszProgID); <br> <br>            dw=cch; <br>            lRet=RegQueryValue(HKEY_CLASSES_ROOT, pszProgID <br>                , pszUserType, &amp;dw); <br> <br>            CoTaskMemFree(pszProgID); <br> <br>            if (ERROR_SUCCESS!=lRet) <br>                dw=0; <br>            } <br>        } <br> <br>    return (UINT)dw; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_DoConvert <br> * <br> * Purpose: <br> *  Convert an embedded or linked object to another type, working <br> *  in conjunection with OleUIConvert. <br> * <br> * Parameters: <br> *  pIStorage       IStorage * to the object's data. <br> *  clsID           CLSID to which we convert the object. <br> * <br> * Return Value: <br> *  HRESULT         The usual. <br> */ <br> <br>STDAPI INOLE_DoConvert(IStorage *pIStorage, REFCLSID clsID) <br>    { <br>    HRESULT     hr; <br>    CLSID       clsIDOrg; <br>    CLIPFORMAT  cfOrg; <br>    LPTSTR      pszOrg=NULL; <br>    TCHAR       szNew[256]; <br> <br>    if (FAILED(ReadClassStg(pIStorage, &amp;clsIDOrg))) <br>        return ResultFromScode(E_FAIL); <br> <br>    //Read original format/user type <br>    hr=ReadFmtUserTypeStg(pIStorage, &amp;cfOrg, &amp;pszOrg); <br> <br>    //Get new user type <br>    if (0==INOLE_GetUserTypeOfClass(clsID, 0, szNew, 256)) <br>        lstrcpy(szNew, TEXT("")); <br> <br>    //Write new class into the storage <br>    if (SUCCEEDED(WriteClassStg(pIStorage, clsID))) <br>        { <br>        if (SUCCEEDED(WriteFmtUserTypeStg(pIStorage, cfOrg <br>            , szNew))) <br>            { <br>            SetConvertStg(pIStorage, TRUE); <br>            CoTaskMemFree((void *)pszOrg); <br>            return NOERROR; <br>            } <br> <br>        //Failed to write new type, restore the old class <br>        WriteClassStg(pIStorage, clsIDOrg); <br>        } <br> <br>    CoTaskMemFree((void *)pszOrg); <br>    return ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br>/* <br> * INOLE_CopyString <br> * <br> * Purpose: <br> *  Copies a string allocated with CoTaskMemAlloc. <br> * <br> * Parameters: <br> *  pszSrc          LPTSTR to the string to copy. <br> * <br> * Return Value: <br> *  LPTSTR          New string or a NULL. <br> */ <br> <br>STDAPI_(LPTSTR) INOLE_CopyString(LPTSTR pszSrc) <br>    { <br>    IMalloc    *pIMalloc; <br>    LPTSTR      pszDst; <br>    UINT        cch; <br> <br>    cch=lstrlen(pszSrc); <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        return NULL; <br> <br>    pszDst=(LPTSTR)pIMalloc-&gt;Alloc((cch+1)*sizeof(TCHAR)); <br> <br>    if (NULL!=pszDst) <br>       lstrcpy(pszDst, pszSrc); <br> <br>    pIMalloc-&gt;Release(); <br>    return pszDst; <br>    } <br> <br> <br> <br> <br>/* <br> * INOLE_ObjectDescriptorFromOleObject <br> * <br> * Purpose: <br> *  Fills and returns an OBJECTDESCRIPTOR structure. Information <br> *  for the structure is obtained from an IOleObject instance. <br> * <br> * Parameters: <br> *  pObj            IOleObject * from which to retrieve information. <br> *  dwAspect        DWORD with the display aspect <br> *  ptl             POINTL from upper-left corner of object where <br> *                  mouse went down for use with Drag &amp; Drop. <br> *  pszl            LPSIZEL (optional) if the object is being scaled in <br> *                  its container, then the container should pass the <br> *                  extents that it is using to display the object. <br> * <br> * Return Value: <br> *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure. <br> */ <br> <br>STDAPI_(HGLOBAL) INOLE_ObjectDescriptorFromOleObject <br>    (IOleObject *pObj, DWORD dwAspect, POINTL ptl, LPSIZEL pszl) <br>    { <br>    CLSID           clsID; <br>    LPTSTR          pszName=NULL; <br>    LPTSTR          pszSrc=NULL; <br>    BOOL            fLink=FALSE; <br>    IOleLink       *pLink; <br>    TCHAR           szName[512]; <br>    DWORD           dwMisc=0; <br>    SIZEL           szl; <br>    HGLOBAL         hMem; <br>    HRESULT         hr; <br>   #ifdef WIN32ANSI <br>   //#ifndef UNICODE <br>    LPWSTRpszw; <br>    char            szTemp[512]; <br>   #endif  <br> <br>    if (SUCCEEDED(pObj-&gt;QueryInterface(IID_IOleLink <br>        , (void **)&amp;pLink))) <br>        fLink=TRUE; <br> <br>    if (FAILED(pObj-&gt;GetUserClassID(&amp;clsID))) <br>        clsID=CLSID_NULL; <br> <br>    //Get user string, expand to "Linked %s" if this is link <br>   #ifndef WIN32ANSI <br>   //#ifdef UNICODE <br>    pObj-&gt;GetUserType(USERCLASSTYPE_FULL, &amp;pszName); <br>   #else <br>    pObj-&gt;GetUserType(USERCLASSTYPE_FULL, &amp;pszw); <br>    WideCharToMultiByte(CP_ACP, 0, pszw, -1, szTemp <br>        , sizeof(szTemp), NULL, NULL); <br>pszName=szTemp; <br>   #endif <br> <br>    if (fLink &amp;&amp; NULL!=pszName) <br>        wsprintf(szName, TEXT("Linked %s"), pszName); <br>    else <br>        lstrcpy(szName, pszName); <br> <br>   #ifndef WIN32ANSI <br>   //#ifdef UNICODE <br>    CoTaskMemFree(pszName); <br>   #else <br>CoTaskMemFree(pszw); <br>    pszw=NULL; <br>   #endif <br> <br>    /* <br>     * Get the source name of this object using either the <br>     * link display name (for link) or a moniker display <br>     * name. <br>     */ <br> <br>    if (fLink) <br>{ <br>       #ifndef WIN32ANSI <br>       //#ifdef UNICODE <br>        hr=pLink-&gt;GetSourceDisplayName(&amp;pszSrc); <br>   #else <br>        hr=pLink-&gt;GetSourceDisplayName(&amp;pszw); <br>        WideCharToMultiByte(CP_ACP, 0, pszw, -1, szTemp <br>            , sizeof(szTemp), NULL, NULL); <br>    pszSrc=szTemp; <br>   #endif <br>} <br>    else <br>        { <br>        IMoniker   *pmk; <br> <br>        hr=pObj-&gt;GetMoniker(OLEGETMONIKER_TEMPFORUSER <br>            , OLEWHICHMK_OBJFULL, &amp;pmk); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            IBindCtx  *pbc; <br>            CreateBindCtx(0, &amp;pbc); <br> <br>           #ifndef WIN32ANSI <br>           //#ifdef UNICODE <br>            pmk-&gt;GetDisplayName(pbc, NULL, &amp;pszSrc); <br>    #else <br>            pmk-&gt;GetDisplayName(pbc, NULL, &amp;pszw); <br>            WideCharToMultiByte(CP_ACP, 0, pszw, -1, szTemp <br>                , sizeof(szTemp), NULL, NULL); <br>        pszSrc=szTemp; <br>   #endif <br> <br>            pbc-&gt;Release(); <br> <br>            pmk-&gt;Release(); <br>            } <br>        } <br> <br>    if (fLink) <br>        pLink-&gt;Release(); <br> <br>    //Get MiscStatus bits <br>    hr=pObj-&gt;GetMiscStatus(dwAspect, &amp;dwMisc); <br> <br>    //Get OBJECTDESCRIPTOR <br>    hMem=INOLE_AllocObjectDescriptor(clsID, dwAspect, szl, ptl <br>        , dwMisc, szName, pszSrc); <br> <br>   #ifndef WIN32ANSI <br>   //#ifdef UNICODE <br>    CoTaskMemFree(pszSrc); <br>   #else <br>    if (NULL!=pszw) <br>    CoTaskMemFree(pszw); <br>   #endif <br> <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_AllocObjectDescriptor <br> * <br> * Purpose: <br> *  Allocated and fills an OBJECTDESCRIPTOR structure. <br> * <br> * Parameters: <br> *  clsID           CLSID to store. <br> *  dwAspect        DWORD with the display aspect <br> *  pszl            LPSIZEL (optional) if the object is being scaled in <br> *                  its container, then the container should pass the <br> *                  extents that it is using to display the object. <br> *  ptl             POINTL from upper-left corner of object where <br> *                  mouse went down for use with Drag &amp; Drop. <br> *  dwMisc          DWORD containing MiscStatus flags <br> *  pszName         LPTSTR naming the object to copy <br> *  pszSrc          LPTSTR identifying the source of the object. <br> * <br> * Return Value: <br> *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure. <br> */ <br> <br>STDAPI_(HGLOBAL) INOLE_AllocObjectDescriptor(CLSID clsID <br>    , DWORD dwAspect, SIZEL szl, POINTL ptl, DWORD dwMisc <br>    , LPTSTR pszName, LPTSTR pszSrc) <br>    { <br>    HGLOBAL              hMem=NULL; <br>    LPOBJECTDESCRIPTOR   pOD; <br>    DWORD                cb, cbStruct; <br>    DWORD                cchName, cchSrc; <br> <br>    cchName=lstrlen(pszName)+1; <br> <br>    if (NULL!=pszSrc) <br>        cchSrc=lstrlen(pszSrc)+1; <br>    else <br>        { <br>        cchSrc=cchName; <br>        pszSrc=pszName; <br>        } <br> <br>    /* <br>     * Note:  CFSTR_OBJECTDESCRIPTOR is an ANSI structure. <br>     * That means strings in it must be ANSI.  OLE will do <br>     * internal conversions back to Unicode as necessary, <br>     * but we have to put ANSI strings in it ourselves. <br>     */ <br>    cbStruct=sizeof(OBJECTDESCRIPTOR); <br>    cb=cbStruct+(sizeof(WCHAR)*(cchName+cchSrc));   //HACK <br> <br>    hMem=GlobalAlloc(GHND, cb); <br> <br>    if (NULL==hMem) <br>        return NULL; <br> <br>    pOD=(LPOBJECTDESCRIPTOR)GlobalLock(hMem); <br> <br>    pOD-&gt;cbSize=cb; <br>    pOD-&gt;clsid=clsID; <br>    pOD-&gt;dwDrawAspect=dwAspect; <br>    pOD-&gt;sizel=szl; <br>    pOD-&gt;pointl=ptl; <br>    pOD-&gt;dwStatus=dwMisc; <br> <br>    if (pszName) <br>        { <br>        pOD-&gt;dwFullUserTypeName=cbStruct; <br>       #ifdef WIN32ANSI <br>        MultiByteToWideChar(CP_ACP, 0, pszName, -1 <br>            , (LPWSTR)((LPBYTE)pOD+pOD-&gt;dwFullUserTypeName), cchName); <br>       #else <br>        lstrcpy((LPTSTR)((LPBYTE)pOD+pOD-&gt;dwFullUserTypeName) <br>            , pszName); <br>       #endif <br>        } <br>    else <br>        pOD-&gt;dwFullUserTypeName=0;  //No string <br> <br>    if (pszSrc) <br>        { <br>        pOD-&gt;dwSrcOfCopy=cbStruct+(cchName*sizeof(WCHAR)); <br> <br>       #ifdef WIN32ANSI <br>        MultiByteToWideChar(CP_ACP, 0, pszSrc, -1 <br>            , (LPWSTR)((LPBYTE)pOD+pOD-&gt;dwSrcOfCopy), cchSrc); <br>       #else <br>        lstrcpy((LPTSTR)((LPBYTE)pOD+pOD-&gt;dwSrcOfCopy), pszSrc); <br>       #endif <br>        } <br>    else <br>        pOD-&gt;dwSrcOfCopy=0;  //No string <br> <br>    GlobalUnlock(hMem); <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_CreateStorageOnHGlobal <br> * <br> * Purpose: <br> *  Create a memory based storage object on an memory lockbytes. <br> * <br> * Parameters: <br> *  grfMode --  flags passed to StgCreateDocfileOnILockBytes <br> * <br> *  NOTE: if hGlobal is NULL, then a new IStorage is created and <br> *              STGM_CREATE flag is passed to StgCreateDocfileOnILockBytes. <br> *        if hGlobal is non-NULL, then it is assumed that the hGlobal already <br> *              has an IStorage inside it and STGM_CONVERT flag is passed <br> *              to StgCreateDocfileOnILockBytes. <br> * <br> * Return Value: <br> *  IStorage *      Pointer to the storage we create. <br> */ <br> <br>STDAPI_(IStorage *) INOLE_CreateStorageOnHGlobal(DWORD grfMode) <br>    { <br>    DWORD           grfCreate=grfMode | STGM_CREATE; <br>    HRESULT         hr; <br>    ILockBytes     *pLB=NULL; <br>    IStorage       *pIStorage=NULL; <br> <br>    hr=CreateILockBytesOnHGlobal(NULL, TRUE, &amp;pLB); <br> <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    hr=StgCreateDocfileOnILockBytes(pLB, grfCreate, 0, &amp;pIStorage); <br> <br>    pLB-&gt;Release(); <br> <br>    return SUCCEEDED(hr) ? pIStorage : NULL; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * INOLE_GetLinkSourceData <br> * <br> * Purpose: <br> *  Creates a CFSTR_LINKSOURCE data format, that is, a serialized <br> *  moniker in a stream. <br> * <br> * Parameters: <br> *  pmk             IMoniker * of the link. <br> *  pClsID          CLSID * to write into the stream. <br> *  pFE             FORMATETC * describing the data which <br> *                  should have TYMED_ISTREAM in it. <br> *  pSTM            STGMEDIUM in which to return the data. <br> *                  If this has TYMED_NULL, then this function <br> *                  allocates the stream, otherwise it writes <br> *                  into the stream in pSTM-&gt;pstm. <br> */ <br> <br>STDAPI INOLE_GetLinkSourceData(IMoniker *pmk, LPCLSID pClsID <br>    , LPFORMATETC pFE, LPSTGMEDIUM pSTM) <br>    { <br>    LPSTREAM    pIStream = NULL; <br>    DWORD       reserved = 0; <br>    HRESULT     hr; <br> <br>    pSTM-&gt;pUnkForRelease=NULL; <br> <br>    if (TYMED_NULL==pSTM-&gt;tymed) <br>        { <br>        if (pFE-&gt;tymed &amp; TYMED_ISTREAM) <br>            { <br>            hr=CreateStreamOnHGlobal(NULL, TRUE, &amp;pIStream); <br> <br>            if (FAILED(hr)) <br>                return ResultFromScode(E_OUTOFMEMORY); <br> <br>            pSTM-&gt;pstm=pIStream; <br>            pSTM-&gt;tymed=TYMED_ISTREAM; <br>            } <br>        else <br>            return ResultFromScode(DATA_E_FORMATETC); <br>        } <br>    else <br>        { <br>        if (TYMED_ISTREAM==pSTM-&gt;tymed) <br>            { <br>            pSTM-&gt;tymed=TYMED_ISTREAM; <br>            pSTM-&gt;pstm=pSTM-&gt;pstm; <br>            } <br>        else <br>            return ResultFromScode(DATA_E_FORMATETC); <br>       } <br> <br>    hr=OleSaveToStream(pmk, pSTM-&gt;pstm); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    return WriteClassStm(pSTM-&gt;pstm, *pClsID); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * INOLE_RegisterAsRunning <br> * <br> * Purpose: <br> *  Registers a moniker as running in the running object <br> *  table, revoking any existing registration. <br> * <br> * Parameters: <br> *  pUnk            IUnknown * of the object. <br> *  pmk             IMoniker * naming the object. <br> *  dwFlags         DWORD flags to pass to IROT::Register <br> *  pdwReg          LPDWORD in which to store the registration key. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) INOLE_RegisterAsRunning(IUnknown *pUnk <br>    , IMoniker *pmk, DWORD dwFlags, LPDWORD pdwReg) <br>    { <br>    IRunningObjectTable    *pROT; <br>    HRESULT                 hr; <br>    DWORD                   dwReg=*pdwReg; <br> <br>    if (NULL==pmk || NULL==pUnk || NULL==pdwReg) <br>        return; <br> <br>    dwReg=*pdwReg; <br> <br>    if (FAILED(GetRunningObjectTable(0, &amp;pROT))) <br>        return; <br> <br>    hr=pROT-&gt;Register(dwFlags, pUnk, pmk, pdwReg); <br> <br>    if (MK_S_MONIKERALREADYREGISTERED==GetScode(hr)) <br>        { <br>        if (0!=dwReg) <br>            pROT-&gt;Revoke(dwReg); <br>        } <br> <br>    pROT-&gt;Release(); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * INOLE_RevokeAsRunning <br> * <br> * Purpose: <br> *  Wrapper for IRunningObjectTable::Revoke <br> * <br> * Parameters: <br> *  pdwReg          LPDWORD containing the key on input, zeroed <br> *                  on output. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) INOLE_RevokeAsRunning(LPDWORD pdwReg) <br>    { <br>    IRunningObjectTable    *pROT; <br> <br>    if (0==*pdwReg) <br>        return; <br> <br>    if (FAILED(GetRunningObjectTable(0, &amp;pROT))) <br>        return; <br> <br>    pROT-&gt;Revoke(*pdwReg); <br>    pROT-&gt;Release(); <br> <br>    *pdwReg=0; <br>    return; <br>    } <br> <br> <br> <br>/* <br> * INOLE_NoteChangeTime <br> * <br> * Purpose: <br> *  Wrapper for IRunningObjectTable::NoteChangeTime <br> * <br> * Parameters: <br> *  dwReg           DWORD identifying the running object to note. <br> *  pft             FILETIME * containing the new time.  If NULL, <br> *                  then we'll get it from CoFileTimeNow. <br> *  pszFile         LPTSTR to a filename.  If pft is NULL, we'll <br> *                  retrieve times from this file. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>STDAPI_(void) INOLE_NoteChangeTime(DWORD dwReg, FILETIME *pft <br>    , LPTSTR pszFile) <br>    { <br>    IRunningObjectTable    *pROT; <br>    FILETIME                ft; <br> <br>    if (NULL==pft) <br>        { <br>        CoFileTimeNow(&amp;ft); <br>        pft=&amp;ft; <br>        } <br> <br>    if (NULL!=pszFile) <br>        GetFileTimes(pszFile, pft); <br> <br>    if (FAILED(GetRunningObjectTable(0, &amp;pROT))) <br>        return; <br> <br>    pROT-&gt;NoteChangeTime(dwReg, pft); <br>    pROT-&gt;Release(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * GetFileTimes <br> * (Internal) <br> * <br> * Purpose: <br> *  Retrieve the FILETIME structure for a given file. <br> */ <br> <br>static BOOL GetFileTimes(LPTSTR pszFileName, FILETIME *pft) <br>    { <br>   #ifdef WIN32 <br>    WIN32_FIND_DATA fd; <br>    HANDLE          hFind; <br> <br>    hFind=FindFirstFile(pszFileName, &amp;fd); <br> <br>    if (NULL==hFind || INVALID_HANDLE_VALUE==hFind) <br>        return FALSE; <br> <br>    FindClose(hFind); <br>    *pft=fd.ftLastWriteTime; <br>    return TRUE; <br>   #else <br>    static char           sz[256]; <br>    static struct _find_t fileinfo; <br> <br>    lstrcpyn((LPSTR)sz, pszFileName, sizeof(sz)-1); <br>    sz[sizeof(sz)-1]= '\0'; <br>    AnsiToOem(sz, sz); <br> <br>    return (_dos_findfirst(sz,_A_NORMAL|_A_HIDDEN|_A_SUBDIR|_A_SYSTEM <br>        , (struct _find_t *)&amp;fileinfo) == 0 <br>        &amp;&amp; CoDosDateTimeToFileTime(fileinfo.wr_date, fileinfo.wr_time <br>        , pft)); <br>   #endif <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
