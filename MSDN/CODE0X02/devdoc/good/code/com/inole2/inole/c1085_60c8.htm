<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CURSORS.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1088"></a>CURSORS.C</h2>
<pre><code>/* <br> * CURSORS.C <br> * Buttons &amp; Cursors <br> * <br> * Public functions to retrieve cursors. <br> * <br> * Copyright (c)1992-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "inoledll.h" <br> <br> <br>/* <br> * The +1 is because MAX is the highest allowable number and MIN is <br> * not necessarily zero. <br> */ <br>HCURSOR rgHCursors[IDC_NEWUICURSORMAX-IDC_NEWUICURSORMIN+1]; <br> <br> <br> <br>/* <br> * CursorsCache <br> * Internal <br> * <br> * Purpose: <br> *  Loads all the cursors available through NewUICursorLoad into <br> *  a global array.  This way we can clean up all the cursors without <br> *  placing the burden on the application. <br> * <br> * Parameters: <br> *  hInst           HANDLE of the DLL instance. <br> * <br> * Return Value: <br> *  None. If any of the LoadCursor calls fail, then the corresponding <br> *  array entry is NULL and NewUICursorLoad will fail. Better to fail <br> *  an app getting a cursor than failing to load the app just for <br> *  that reason; and app can attempt to load the cursor on startup if <br> *  it's that important, and fail itself. <br> */ <br> <br>void CursorsCache(HINSTANCE hInst) <br>    { <br>    UINT            i; <br> <br>    for (i=IDC_NEWUICURSORMIN; i&lt;=IDC_NEWUICURSORMAX; i++) <br>        { <br>        rgHCursors[i-IDC_NEWUICURSORMIN]=LoadCursor(hInst <br>            , MAKEINTRESOURCE(i)); <br>        } <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CursorsFree <br> * Internal <br> * <br> * Purpose: <br> *  Frees all the cursors previously loaded through CursorsCache. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CursorsFree(void) <br>    { <br>    /* <br>     * Note that since cursors are discardable resources and should <br>     * not be used with DestroyCursor, there's nothing to do here. <br>     * We still provide this API for compatibility and to maintain <br>     * symmetry. <br>     */ <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * UICursorLoad <br> * Public API <br> * <br> * Purpose: <br> *  Loads and returns a handle to one of the new standard UI cursors <br> *  contained in UITOOLS.DLL.  The application must not call <br> *  DestroyCursor on this cursor as it is managed by the DLL. <br> * <br> * Parameters: <br> *  iCursor         UINT index to the cursor to load which must be one <br> *                  of the following values: <br> * <br> *      IDC_RIGHTARROW    Right pointing standard arrow <br> *      IDC_CONTEXTHELP   Arrow with a ? (context help) <br> *      IDC_MAGNIFY       Magnifying glass for zooming <br> *      IDC_NODROP        Circle with a slash <br> *      IDC_TABLETOP      Small arrow pointing down <br> * <br> *      IDC_SMALLARROWS   Thin four-headed arrow <br> *      IDC_LARGEARROWS   Wide four-headed arrow <br> *      IDC_HARROWS       Horizontal two-headed arrow <br> *      IDC_VARROWS       Vertical two-headed arrow <br> *      IDC_NESWARROWS    Two-headed arrow pointing NE&lt;-&gt;SW <br> *      IDC_NWSEHARROWS   Two-headed arrow pointing NW&lt;-&gt;SE <br> * <br> *      IDC_HSIZEBAR      Horizontal two-headed arrow with <br> *                        a single vertical bar down the <br> *                        middle <br> * <br> *      IDC_VSIZEBAR      Vertical two-headed arrow with a <br> *                        single horizontal bar down the <br> *                        middle <br> * <br> *      IDC_HSPLITBAR     Horizontal two-headed arrow with <br> *                        split double vertical bars down the <br> *                        middle <br> * <br> *      IDC_VSPLITBAR     Vertical two-headed arrow with split <br> *                        double horizontal bars down the <br> *                        middle <br> * <br> * Return Value: <br> *  HCURSOR         Handle to the loaded cursor if successful, NULL <br> *                  if iCursor is out of range or the function could <br> *                  not load the cursor. <br> */ <br> <br>HCURSOR WINAPI UICursorLoad(UINT iCursor) <br>    { <br>    HCURSOR     hCur=NULL; <br> <br>    if ((iCursor &gt;= IDC_NEWUICURSORMIN) <br>        &amp;&amp; (iCursor &lt;= IDC_NEWUICURSORMAX)) <br>        hCur=rgHCursors[iCursor-IDC_NEWUICURSORMIN]; <br> <br>    return hCur; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
