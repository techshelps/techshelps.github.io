<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPERSTOR.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context569"></a>IPERSTOR.CPP</h2>
<pre><code>/* <br> * IPERSTOR.CPP <br> * Polyline Component Chapter 8 <br> * <br> * Implementation of the IPersistStorage interface exposed on the <br> * Polyline object. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * CImpIPersistStorage:CImpIPersistStorage <br> * CImpIPersistStorage::~CImpIPersistStorage <br> * <br> * Constructor Parameters: <br> *  pObj            PCPolyline pointing to the object we live in. <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> */ <br> <br>CImpIPersistStorage::CImpIPersistStorage(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    m_psState=PSSTATE_UNINIT; <br>    return; <br>    } <br> <br> <br>CImpIPersistStorage::~CImpIPersistStorage(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::QueryInterface <br> * CImpIPersistStorage::AddRef <br> * CImpIPersistStorage::Release <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistStorage::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistStorage::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::GetClassID <br> * <br> * Purpose: <br> *  Returns the CLSID of the object represented by this interface. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store our CLSID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, error code otherwise. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::GetClassID(LPCLSID pClsID) <br>    { <br>    if (PSSTATE_UNINIT==m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    *pClsID=m_pObj-&gt;m_clsID; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::IsDirty <br> * <br> * Purpose: <br> *  Tells the caller if we have made changes to this object since <br> *  it was loaded or initialized new. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if <br> *                  NOT dirty. <br> * <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::IsDirty(void) <br>    { <br>    if (PSSTATE_UNINIT==m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    return ResultFromScode(m_pObj-&gt;m_fDirty ? S_OK : S_FALSE); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::InitNew <br> * <br> * Purpose: <br> *  Provides the object with the IStorage to hold on to while the <br> *  object is running.  Here we initialize the structure of the <br> *  storage and AddRef it for incremental access. This function will <br> *  only be called once in the object's lifetime in lieu of Load. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE for the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::InitNew(LPSTORAGE pIStorage) <br>    { <br>    HRESULT         hr; <br>    ULARGE_INTEGER  uli; <br> <br>    if (PSSTATE_UNINIT!=m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    if (NULL==pIStorage) <br>        return ResultFromScode(E_POINTER); <br> <br>    /* <br>     * The rules of IPersistStorage mean we hold onto the IStorage <br>     * and pre-create anything we'd need in Save(...,TRUE) for <br>     * low-memory situations.  For us this means creating our <br>     * "CONTENTS" stream and holding onto that IStream as <br>     * well as the IStorage here (requiring an AddRef call). <br>     */ <br> <br>    hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT <br>        | STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE <br>        , 0, 0, &amp;m_pObj-&gt;m_pIStream); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    //Preallocate stream space <br>    ULISet32(uli, CBPOLYLINEDATA); <br>    m_pObj-&gt;m_pIStream-&gt;SetSize(uli); <br> <br>    //We expect that the client has called WriteClassStg <br>    WriteFmtUserTypeStg(pIStorage, m_pObj-&gt;m_cf <br>        , (*m_pObj-&gt;m_pST)[IDS_USERTYPE]); <br> <br>    m_pObj-&gt;m_pIStorage=pIStorage; <br>    pIStorage-&gt;AddRef(); <br> <br>    m_psState=PSSTATE_SCRIBBLE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::Load <br> * <br> * Purpose: <br> *  Instructs the object to load itself from a previously saved <br> *  IStorage that was handled by Save in another object lifetime. <br> *  This function will only be called once in the object's lifetime <br> *  in lieu of InitNew. The object should hold on to pIStorage here <br> *  for incremental access and low-memory saves in Save. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE from which to load. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::Load(LPSTORAGE pIStorage) <br>    { <br>    POLYLINEDATA    pl; <br>    ULONG           cb; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br> <br>    if (PSSTATE_UNINIT!=m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    if (NULL==pIStorage) <br>        return ResultFromScode(E_POINTER); <br> <br>    //We don't check CLSID to remain compatible with other chapters. <br> <br>    hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT <br>        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return ResultFromScode(STG_E_READFAULT); <br> <br>    //Read all the data into the POLYLINEDATA structure. <br>    hr=pIStream-&gt;Read(&amp;pl, CBPOLYLINEDATA, &amp;cb); <br> <br>    if (FAILED(hr) || CBPOLYLINEDATA!=cb) <br>        { <br>        pIStream-&gt;Release(); <br>        return hr; <br>        } <br> <br>    /* <br>     * We don't call pIStream-&gt;Release here because we may need <br>     * it for a low-memory save in Save.  We also need to <br>     * hold onto a copy of pIStorage, meaning AddRef. <br>     */ <br>    m_pObj-&gt;m_pIStream=pIStream; <br>    m_pObj-&gt;m_pIStorage=pIStorage; <br>    pIStorage-&gt;AddRef(); <br> <br>    m_pObj-&gt;m_pImpIPolyline-&gt;DataSet(&amp;pl, TRUE, TRUE); <br>    m_psState=PSSTATE_SCRIBBLE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::Save <br> * <br> * Purpose: <br> *  Saves the data for this object to an IStorage which may <br> *  or may not be the same as the one previously passed to <br> *  Load, indicated with fSameAsLoad.  After this call we may <br> *  not write into the storage again until SaveCompleted is <br> *  called, although we may still read. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE in which to save our data. <br> *  fSameAsLoad     BOOL indicating if this is the same pIStorage <br> *                  that was passed to Load.  If TRUE, then the <br> *                  object should write whatever it has *without <br> *                  *using any extra memory* as this may be a low <br> *                  memory save attempt.  That means that you must <br> *                  not try to open or create streams.  If FALSE <br> *                  you need to regenerate your whole storage <br> *                  structure, being sure to also release any <br> *                  pointers held from InitNew and Load. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::Save(LPSTORAGE pIStorage <br>    , BOOL fSameAsLoad) <br>    { <br>    POLYLINEDATA    pl; <br>    ULONG           cb; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br> <br>    //Have to come here from scribble state. <br>    if (PSSTATE_SCRIBBLE!=m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    //Must have an IStorage if we're not in SameAsLoad <br>    if (NULL==pIStorage &amp;&amp; !fSameAsLoad) <br>        return ResultFromScode(E_POINTER); <br> <br> <br>    /* <br>     * If we're saving to a new storage, create a new stream. <br>     * If fSameAsLoad it TRUE, then we write to the <br>     * stream we already allocated.  We should NOT depends on <br>     * pIStorage with fSameAsLoad is TRUE. <br>     */ <br>    if (fSameAsLoad) <br>        { <br>        LARGE_INTEGER   li; <br> <br>        /* <br>         * Use pre-allocated streams to avoid failures due <br>         * to low-memory conditions.  Be sure to reset the <br>         * stream pointer if you used this stream before!! <br>         */ <br>        pIStream=m_pObj-&gt;m_pIStream; <br>        LISet32(li, 0); <br>        pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br> <br>        //This matches the Release below. <br>        pIStream-&gt;AddRef(); <br>        } <br>    else <br>        { <br>        hr=pIStorage-&gt;CreateStream(SZSTREAM, STGM_DIRECT <br>            | STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE <br>            , 0, 0, &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return hr; <br> <br>        //Only do this with new storages. <br>        WriteFmtUserTypeStg(pIStorage, m_pObj-&gt;m_cf <br>            , (*m_pObj-&gt;m_pST)[IDS_USERTYPE]); <br>        } <br> <br>    //DataGet makes not allocations; it's just a memory copy. <br>    m_pObj-&gt;m_pImpIPolyline-&gt;DataGet(&amp;pl); <br> <br>    hr=pIStream-&gt;Write(&amp;pl, CBPOLYLINEDATA, &amp;cb); <br>    pIStream-&gt;Release(); <br> <br>    if (FAILED(hr) || CBPOLYLINEDATA!=cb) <br>        return ResultFromScode(STG_E_WRITEFAULT); <br> <br>    m_psState=PSSTATE_ZOMBIE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::SaveCompleted <br> * <br> * Purpose: <br> *  Notifies the object that the storage in pIStorage has been <br> *  completely saved now.  This is called when the user of this <br> *  object wants to save us in a completely new storage, and if <br> *  we normally hang on to the storage we have to reinitialize <br> *  ourselves here for this new one that is now complete. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE of the new storage in which we live. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::SaveCompleted(LPSTORAGE pIStorage) <br>    { <br>    HRESULT     hr; <br>    LPSTREAM    pIStream; <br> <br>    //Must be called in no-scribble or hands-off state <br>    if (!(PSSTATE_ZOMBIE==m_psState || PSSTATE_HANDSOFF==m_psState)) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    //If we're coming from Hands-Off, we'd better get a storage <br>    if (NULL==pIStorage &amp;&amp; PSSTATE_HANDSOFF==m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br>    /* <br>     * If pIStorage is NULL, then we don't need to do anything <br>     * since we already have all the pointers we need for Save. <br>     * Otherwise we have to release any held pointers and <br>     * reinitialize them from pIStorage. <br>     */ <br> <br>    if (NULL!=pIStorage) <br>        { <br>        hr=pIStorage-&gt;OpenStream(SZSTREAM, 0, STGM_DIRECT <br>            | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0 <br>            , &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return hr; <br> <br>        if (NULL!=m_pObj-&gt;m_pIStream) <br>            m_pObj-&gt;m_pIStream-&gt;Release(); <br> <br>        m_pObj-&gt;m_pIStream=pIStream; <br> <br>        if (NULL!=m_pObj-&gt;m_pIStorage) <br>            m_pObj-&gt;m_pIStorage-&gt;Release(); <br> <br>        m_pObj-&gt;m_pIStorage=pIStorage; <br>        m_pObj-&gt;m_pIStorage-&gt;AddRef(); <br>        } <br> <br>    //Change state back to scribble. <br>    m_psState=PSSTATE_SCRIBBLE; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistStorage::HandsOffStorage <br> * <br> * Purpose: <br> *  Instructs the object that another agent is interested in having <br> *  total access to the storage we might be hanging on to from <br> *  InitNew or SaveCompleted.  In this case we must release our hold <br> *  and await another call to SaveCompleted before we have a hold <br> *  again.  Therefore we cannot read or write after this call until <br> *  SaveCompleted. <br> * <br> *  Situations where this might happen arise in compound document <br> *  scenarios where this object might be in-place active but the <br> *  application wants to rename and commit the root storage. <br> *  Therefore we are asked to close our hold, let the container <br> *  party on the storage, then call us again later to tell us the <br> *  new storage we can hold. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistStorage::HandsOffStorage(void) <br>    { <br>    /* <br>     * Must come from scribble or no-scribble.  A repeated call <br>     * to HandsOffStorage is an unexpected error (bug in client). <br>     */ <br>    if (PSSTATE_UNINIT==m_psState || PSSTATE_HANDSOFF==m_psState) <br>        return ResultFromScode(E_UNEXPECTED); <br> <br> <br>    //Release held pointers <br>    if (NULL!=m_pObj-&gt;m_pIStream) <br>        ReleaseInterface(m_pObj-&gt;m_pIStream); <br> <br>    if (NULL!=m_pObj-&gt;m_pIStorage) <br>        ReleaseInterface(m_pObj-&gt;m_pIStorage); <br> <br>    m_psState=PSSTATE_HANDSOFF; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
