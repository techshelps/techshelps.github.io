<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COCOSMO.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context561"></a>COCOSMO.CPP</h2>
<pre><code>/* <br> * COCOSMO.CPP <br> * Component Cosmo Chapter 8 <br> * <br> * WinMain and CCosmoFrame implementations. <br> * <br> * Copyright (c)1993-1996 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Software Design Engineer <br> * Microsoft Systems Developer Relations <br> * <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>//Must do this once or we can't define our own GUIDs (see compobj.h) <br>#define INITGUIDS <br> <br>#include "cocosmo.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  Should register the app class <br> *  if a previous instance has not done so and do any other one-time <br> *  initializations. <br> */ <br> <br>int PASCAL WinMain (HINSTANCE hInst, HINSTANCE hPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    PCCosmoFrame    pFR; <br>    FRAMEINIT       fi; <br>    WPARAM          wRet; <br> <br>    //Since we only use one DLL object, don't need SetMessageQueue <br> <br>    //Attempt to allocate and initialize the application <br>    pFR=new CCosmoFrame(hInst, hPrev, pszCmdLine, nCmdShow); <br> <br>    if (NULL==pFR) <br>        return -1; <br> <br>    fi.idsMin=IDS_FRAMEMIN; <br>    fi.idsMax=IDS_FRAMEMAX; <br>    fi.idsStatMin=IDS_STATMESSAGEMIN; <br>    fi.idsStatMax=IDS_STATMESSAGEMAX; <br>    fi.idStatMenuMin=ID_MENUFILE; <br>    fi.idStatMenuMax=ID_MENUHELP; <br>    fi.iPosWindowMenu=WINDOW_MENU; <br>    fi.cMenus=CMENUS; <br> <br>    fi.x=CW_USEDEFAULT; <br>    fi.y=CW_USEDEFAULT; <br>    fi.cx=440; <br>    fi.cy=460; <br> <br>    //If we can initialize pFR, start chugging messages <br>    if (pFR-&gt;FInit(&amp;fi)) <br>        wRet=pFR-&gt;MessageLoop(); <br> <br>    delete pFR; <br>    return wRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CCosmoFrame <br> * CCosmoFrame::~CCosmoFrame <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE from WinMain <br> *  hInstPrev       HINSTANCE from WinMain <br> *  pszCmdLine      LPSTR from WinMain <br> *  nCmdShow        int from WInMain <br> */ <br> <br>CCosmoFrame::CCosmoFrame(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    : CFrame(hInst, hInstPrev, pszCmdLine, nCmdShow) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i&lt;5; i++) <br>        m_hBmpLines[i]=NULL; <br> <br>    m_uIDCurLine=0; <br>    m_fInitialized=FALSE; <br>    return; <br>    } <br> <br> <br>CCosmoFrame::~CCosmoFrame(void) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i&lt;5; i++) <br>        { <br>        if (NULL!=m_hBmpLines[i]) <br>            DeleteObject(m_hBmpLines[i]); <br>        } <br> <br>    if (m_fInitialized) <br>        OleUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::FInit <br> * <br> * Purpose: <br> *  Call OleInitialize then calling down into the base class <br> *  initialization. <br> * <br> * Parameters: <br> *  pFI             PFRAMEINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::FInit(PFRAMEINIT pFI) <br>    { <br>    DWORD       dwVer; <br> <br>    //Make sure OLE, not just COM, is the right version <br>    dwVer=OleBuildVersion(); <br> <br>    if (rmm!=HIWORD(dwVer)) <br>        return FALSE; <br> <br>    if (FAILED(OleInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    return CFrame::FInit(pFI); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateCClient <br> * <br> * Purpose: <br> *  Constructs a new client specific to the application. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCClient        Pointer to the new client object. <br> */ <br> <br>PCClient CCosmoFrame::CreateCClient(void) <br>    { <br>    return (PCClient)(new CCosmoClient(m_hInst)); <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::FRegisterAllClasses <br> * <br> * Purpose: <br> *  Registers all classes used in this application. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if registration succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::FRegisterAllClasses(void) <br>    { <br>    WNDCLASS        wc; <br> <br>    //First let the standard frame do its thing <br>    if (!CFrame::FRegisterAllClasses()) <br>        return FALSE; <br> <br>    /* <br>     * We want a different background color for the document <br>     * because the Polyline we put in the document will paint <br>     * with COLOR_WINDOW which by default which is CLASSLIB's <br>     * default document color. <br>     */ <br> <br>    GetClassInfo(m_hInst, SZCLASSDOCUMENT, &amp;wc); <br>    UnregisterClass(SZCLASSDOCUMENT, m_hInst); <br> <br>    wc.hbrBackground=(HBRUSH)(COLOR_APPWORKSPACE+1); <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    //No need to register the Polyline window now... <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::FPreShowInit <br> * <br> * Purpose: <br> *  Called from FInit before intially showing the window.  We do <br> *  whatever else we want here, modifying nCmdShow as necessary <br> *  which affects ShowWindow in FInit. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if this initialization succeeded, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::FPreShowInit(void) <br>    { <br>    CreateLineMenu(); <br>    CheckLineSelection(IDM_LINESOLID); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateLineMenu <br> * <br> * Purpose: <br> *  Initializes the bitmaps used to create the Line menu and <br> *  replaces the text items defined in the application resources <br> *  with these bitmaps.  Note that the contents of m_hBmpLines <br> *  must be cleaned up when the application terminates. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::CreateLineMenu(void) <br>    { <br>    HMENU       hMenu; <br>    HDC         hDC, hMemDC; <br>    HPEN        hPen; <br>    HGDIOBJ     hObj; <br>    TEXTMETRIC  tm; <br>    UINT        i, cx, cy; <br> <br> <br>    hMenu=GetSubMenu(GetMenu(m_hWnd), 3);   //Line menu. <br>    hDC=GetDC(m_hWnd); <br> <br>    //Create each line in a menu item 8 chars wide, one char high. <br>    GetTextMetrics(hDC, &amp;tm); <br>    cx=tm.tmAveCharWidth*8; <br>    cy=tm.tmHeight; <br> <br>    /* <br>     * Create a memory DC in which to draw lines, and bitmaps <br>     * for each line. <br>     */ <br>    hMemDC=CreateCompatibleDC(hDC); <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    for (i=0; i&lt;5; i++) <br>        { <br>        m_hBmpLines[i]=CreateCompatibleBitmap(hMemDC, cx, cy); <br>        SelectObject(hMemDC, m_hBmpLines[i]); <br> <br>        PatBlt(hMemDC, 0, 0, cx, cy, WHITENESS); <br> <br>        hPen=CreatePen(i, 1, 0L);       //i=line style like PS_SOLID <br>        hObj=SelectObject(hMemDC, hPen); <br> <br>        MoveToEx(hMemDC, 0, cy/2, NULL); <br>        LineTo(hMemDC, cx, cy/2); <br> <br>        ModifyMenu(hMenu, IDM_LINEMIN+i, MF_BYCOMMAND | MF_BITMAP <br>            , IDM_LINEMIN+i, (LPTSTR)(LONG)(UINT)m_hBmpLines[i]); <br> <br>        SelectObject(hMemDC, hObj); <br>        DeleteObject(hPen); <br>        } <br> <br>    CheckMenuItem(hMenu, IDM_LINESOLID, MF_CHECKED); <br>    DeleteDC(hMemDC); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateGizmos <br> * <br> * Purpose: <br> *  Procedure to create all the necessary gizmobar buttons. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of gizmos added to the bar. <br> */ <br> <br>UINT CCosmoFrame::CreateGizmos(void) <br>    { <br>    UINT            iLast; <br>    UINT            uState=GIZMO_NORMAL; <br>    UINT            utCmd =GIZMOTYPE_BUTTONCOMMAND; <br>    UINT            utEx  =GIZMOTYPE_BUTTONATTRIBUTEEX; <br> <br>    //Insert the standard ones. <br>    iLast=CFrame::CreateGizmos(); <br> <br>    /* <br>     * Insert File Import in the 5th position and account for <br>     * it in iLast. <br>     */ <br>    m_pGB-&gt;Add(utCmd, 4, IDM_FILEIMPORT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 2, uState); <br>    iLast++; <br> <br>    //Separator <br>    m_pGB-&gt;Add(GIZMOTYPE_SEPARATOR, iLast++, 0, 6, m_dyB <br>        , NULL, NULL, 0, uState); <br> <br>    /* <br>     * For the Background bitmap, preserve our use of black <br>     * (part of the image) <br>     */ <br>    m_pGB-&gt;Add(utCmd, iLast++, IDM_COLORBACKGROUND, m_dxB, m_dyB <br>        , NULL, m_hBmp, 3, GIZMO_NORMAL | PRESERVE_BLACK); <br> <br>    m_pGB-&gt;Add(utCmd, iLast++, IDM_COLORLINE, m_dxB, m_dyB <br>        , NULL, m_hBmp, 4, uState); <br> <br>    //Separator <br>    m_pGB-&gt;Add(GIZMOTYPE_SEPARATOR, iLast++, 0, 6, m_dyB <br>        , NULL, NULL, 0, uState); <br> <br>    //Line styles. <br>    m_pGB-&gt;Add(utEx, iLast++, IDM_LINESOLID, m_dxB, m_dyB <br>        , NULL, m_hBmp, 5, uState); <br>    m_pGB-&gt;Add(utEx, iLast++, IDM_LINEDASH, m_dxB, m_dyB <br>        , NULL, m_hBmp, 6, uState); <br>    m_pGB-&gt;Add(utEx, iLast++, IDM_LINEDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 7, uState); <br>    m_pGB-&gt;Add(utEx, iLast++, IDM_LINEDASHDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 8, uState); <br>    m_pGB-&gt;Add(utEx, iLast++, IDM_LINEDASHDOTDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 9, uState); <br> <br>    return iLast; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnCommand <br> * <br> * Purpose: <br> *  WM_COMMAND handler for the Cosmo frame window that just <br> *  processes the line menu and the color menu leaving the <br> *  CFrame to do everything else. <br> * <br> * Parameters: <br> *  hWnd            HWND of the frame window. <br> *  wParam          WPARAM of the message. <br> *  lParam          LPARAM of the message. <br> * <br> * Return Value: <br> *  LRESULT         Return value for the message. <br> */ <br> <br>LRESULT CCosmoFrame::OnCommand(HWND hWnd, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCCosmoDoc      pDoc; <br>    TCHAR           szFile[CCHPATHMAX]; <br>    BOOL            fOK; <br>    UINT            i, uTemp; <br>    COLORREF        rgColors[16]; <br>    CHOOSECOLOR     cc; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    /* <br>     * Don't bother with anything during first initialization, <br>     * skipping many GizmoBar notifications. <br>     */ <br>    if (m_fInit) <br>        return 0L; <br> <br>    pDoc=(PCCosmoDoc)m_pCL-&gt;ActiveDocument(); <br> <br>    /* <br>     * Check for the line style commands which are <br>     * IDM_LINEMIN+&lt;style&gt;.  We handle this by changing the menu <br>     * and toolbar, then we pass it to the document for real <br>     * processing. <br>     */ <br>    if (NULL!=pDoc &amp;&amp; IDM_LINEMIN &lt;= wID &amp;&amp; IDM_LINEMAX &gt;=wID) <br>        { <br>        CheckLineSelection(wID); <br>        pDoc-&gt;LineStyleSet(wID-IDM_LINEMIN); <br>        return 0L; <br>        } <br> <br>    switch (wID) <br>        { <br>        case IDM_FILEIMPORT: <br>            szFile[0]=0; <br>            fOK=FSaveOpenDialog(szFile, CCHPATHMAX, IDS_FILEIMPORT <br>                , TRUE, &amp;i); <br> <br>            if (fOK) <br>                { <br>                uTemp=pDoc-&gt;ULoad(FALSE, szFile); <br>                pDoc-&gt;ErrorMessage(uTemp); <br>                } <br> <br>            return (LRESULT)fOK; <br> <br> <br>        case IDM_COLORBACKGROUND: <br>        case IDM_COLORLINE: <br>            //Invoke the color chooser for either color <br>            uTemp=(IDM_COLORBACKGROUND==wID) <br>                ? DOCCOLOR_BACKGROUND : DOCCOLOR_LINE; <br> <br>            for (i=0; i&lt;16; i++) <br>                rgColors[i]=RGB(0, 0, i*16); <br> <br>            memset(&amp;cc, 0, sizeof(CHOOSECOLOR)); <br>            cc.lStructSize=sizeof(CHOOSECOLOR); <br>            cc.lpCustColors=rgColors; <br>            cc.hwndOwner=hWnd; <br>            cc.Flags=CC_RGBINIT; <br>            cc.rgbResult=pDoc-&gt;ColorGet(uTemp); <br> <br>            if (ChooseColor(&amp;cc)) <br>                pDoc-&gt;ColorSet(uTemp, cc.rgbResult); <br> <br>            break; <br> <br> <br>        default: <br>           CFrame::OnCommand(hWnd, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnDocumentDataChange <br> * <br> * Purpose: <br> *  Update the Line menu and GizmoBar if the style in the data <br> *  changes. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::OnDocumentDataChange(PCDocument pDoc) <br>    { <br>    CheckLineSelection(IDM_LINEMIN <br>        +((PCCosmoDoc)pDoc)-&gt;LineStyleGet()); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnDocumentActivate <br> * <br> * Purpose: <br> *  Informs us that document activation changed, so update the UI <br> *  for that new document. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::OnDocumentActivate(PCDocument pDoc) <br>    { <br>    CheckLineSelection(IDM_LINEMIN <br>        +((PCCosmoDoc)pDoc)-&gt;LineStyleGet()); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::UpdateMenus <br> * <br> * Purpose: <br> *  Handles the WM_INITMENU message for the frame window.  Depending <br> *  on the existence of an active window, menu items are selectively <br> *  enabled and disabled. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the menu to intialize <br> *  iMenu           UINT position of the menu. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::UpdateMenus(HMENU hMenu, UINT iMenu) <br>    { <br>    PCDocument  pDoc; <br>    BOOL        fOK=FALSE; <br>    BOOL        fCallDefault=TRUE; <br>    UINT        i; <br>    UINT        uTemp; <br>    UINT        uTempE; <br>    UINT        uTempD; <br> <br>    pDoc=m_pCL-&gt;ActiveDocument(); <br> <br>    uTempE=MF_ENABLED | MF_BYCOMMAND; <br>    uTempD=MF_DISABLED | MF_GRAYED | MF_BYCOMMAND; <br>    uTemp=((NULL!=pDoc) ? uTempE : uTempD); <br> <br>    //File menu:  If there is document window, disable Import. <br>    if (m_phMenu[0]==hMenu) <br>        EnableMenuItem(hMenu, IDM_FILEIMPORT, uTemp); <br> <br>    //Color menu:  no document, no commands <br>    if (m_phMenu[2]==hMenu) <br>        { <br>        EnableMenuItem(hMenu, IDM_COLORBACKGROUND, uTemp); <br>        EnableMenuItem(hMenu, IDM_COLORLINE,       uTemp); <br>        fCallDefault=FALSE; <br>        } <br> <br>    //Line menu:  no document, no commands <br>    if (m_phMenu[3]==hMenu) <br>        { <br>        for (i=IDM_LINEMIN; i&lt;=IDM_LINEMAX; i++) <br>            EnableMenuItem(hMenu, i, uTemp); <br> <br>        fCallDefault=FALSE; <br>        } <br> <br>    if (fCallDefault) <br>        CFrame::UpdateMenus(hMenu, iMenu); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::UpdateGizmos <br> * <br> * Purpose: <br> *  Enables and disables gizmos depending on whether we have <br> *  a document or not. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::UpdateGizmos(void) <br>    { <br>    BOOL        fLast; <br>    UINT        i; <br> <br>    //Save the last enabled state before CFrame changes it <br>    fLast=m_fLastEnable; <br> <br>    //Let the default hack on its gizmos. <br>    CFrame::UpdateGizmos(); <br> <br>    /* <br>     * If CFrame::UpdateGizmos changed anything, then we neeed <br>     * to change as well--if nothing changes, nothing to do. <br>     */ <br>    if (fLast!=m_fLastEnable) <br>        { <br>        //No document, disable just about everything <br>        m_pGB-&gt;Enable(IDM_FILEIMPORT, m_fLastEnable); <br> <br>        m_pGB-&gt;Enable(IDM_COLORBACKGROUND, m_fLastEnable); <br>        m_pGB-&gt;Enable(IDM_COLORLINE,       m_fLastEnable); <br> <br>        for (i=IDM_LINEMIN; i &lt;= IDM_LINEMAX; i++) <br>            m_pGB-&gt;Enable(i, m_fLastEnable); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CheckLineSelection <br> * <br> * Purpose: <br> *  Maintains the bitmap menu and the gizmos for the line selection. <br> *  Both are mutially exclusive option lists where a selection in <br> *  one has to affect the other. <br> * <br> * Parameters: <br> *  uID             UINT ID of the item to be selected <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::CheckLineSelection(UINT uID) <br>    { <br>    UINT        i; <br>    HMENU       hMenu; <br> <br>    //Update menus and gizmo if the selection changes. <br>    if (uID!=m_uIDCurLine) <br>        { <br>        m_uIDCurLine=uID; <br>        hMenu=GetMenu(m_hWnd); <br> <br>        //Uncheck all lines initially. <br>        for (i=IDM_LINEMIN; i&lt;=IDM_LINEMAX; i++) <br>            CheckMenuItem(hMenu, i, MF_UNCHECKED | MF_BYCOMMAND); <br> <br>        CheckMenuItem(hMenu, uID, MF_CHECKED | MF_BYCOMMAND); <br>        m_pGB-&gt;Check(uID, TRUE); <br>        } <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
