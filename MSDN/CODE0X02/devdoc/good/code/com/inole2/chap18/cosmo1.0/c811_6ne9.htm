<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLESVR.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context831"></a>OLESVR.C</h2>
<pre><code>/* <br> * OLESVR.C <br> * <br> * Contains all callback functions in the OLESERVERVTBL struture: <br> *      ServerCreate <br> *      ServerCreateFromTemplate <br> *      ServerEdit <br> *      ServerExecute <br> *      ServerExit <br> *      ServerOpen <br> *      ServerRelease <br> * <br> * Also includes the constructor function PServerAllocate. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br> <br>#ifdef MAKEOLESERVER <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br> <br> <br> <br>/* <br> * PServerAllocate <br> * <br> * Purpose: <br> *  Allocates a COSMOSERVER structure and sets the defaults in its fields. <br> *  Used from application initialization. <br> * <br> * Parameters: <br> *  pVtblSvr        LPOLESERVERVTBL used to initialize the pvtbl field. <br> * <br> * Return Value: <br> *  LPCOSMOSERVER   Pointer to the allocated structure in local memory. <br> *                  The hMem field will contain a handle to the structure <br> *                  to pass to LocalFree. <br> * <br> */ <br> <br>LPCOSMOSERVER WINAPI PServerAllocate(LPOLESERVERVTBL pVtblSvr) <br>    { <br>    HLOCAL            hMem; <br>    LPCOSMOSERVER     pSvr; <br> <br>    hMem=LocalAlloc(LPTR, CBCOSMOSERVER); <br> <br>    if (NULL==hMem) <br>        return FALSE; <br> <br>    pSvr=(LPCOSMOSERVER)(PSTR)hMem; <br> <br>    //All fields are initially NULL from LMEM_ZEROINIT. <br>    pSvr-&gt;hMem=hMem; <br>    pSvr-&gt;pvtbl=pVtblSvr; <br>    pSvr-&gt;fRelease=TRUE;            //Indicate a released state. <br> <br>    return pSvr; <br>    } <br> <br> <br> <br>/* <br> * ServerCreate <br> * <br> * Purpose: <br> *  Creates a new object of the class in pszClass which will be <br> *  embedded in a client application document whose name is in <br> *  pszDoc. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER to structure identifying the server. <br> *  lhDoc           LHSERVERDOC identifying the document. <br> *  pszClass        OLE_LPCSTR specifying the class of document to create. <br> *  pszDoc          OLE_LPCSTR specifying the document for use in window titles. <br> *  ppServerDoc     LPLPOLESERVERDOC in which to store a pointer <br> *                  to the OLESERVERDOC structure for this new document. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerCreate(LPCOSMOSERVER pSvr, LHSERVERDOC lhDoc <br>    , OLE_LPCSTR pszClass, OLE_LPCSTR pszDoc, LPLPOLESERVERDOC ppServerDoc) <br>    { <br>    LPCOSMODOC      pDoc; <br> <br>    /* <br>     * 1.   Create a document of the specified class. <br>     * 2.   Allocate and initialize an OLESERVERDOC structure. <br>     * 3.   Store lhDoc in the OLESERVERDOC structure. <br>     * 4.   Store a pointer to the new OLESERVERDOC structure in ppServerDoc. <br>     * 5.   Return OLE_OK if successful, OLE_ERROR_NEW otherwise. <br>     */ <br> <br>    /* <br>     * If this were an MDI application, then we would want to create <br>     * a new window and a new document, including a new OLESERVERDOC <br>     * structure.  The protocol supports this, however, this application <br>     * is single-document. <br>     */ <br> <br>    pDoc=PDocumentAllocate(&amp;pOLE-&gt;vtblDoc); <br> <br>    if ((LPCOSMODOC)NULL==pDoc) <br>        return OLE_ERROR_NEW; <br> <br>    pSvr-&gt;pDoc=pDoc; <br> <br>    pDoc-&gt;lh=lhDoc; <br>    *ppServerDoc=(LPOLESERVERDOC)pDoc; <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br>/* <br> * ServerCreateFromTemplate <br> * <br> * Purpose: <br> *  Creates a new document initialized with the data in a specified <br> *  file.  Thw new document is opened for editing and is embedded <br> *  within the client when the server is updated or closed. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER to structure identifying the server. <br> *  lhDoc           LHSERVERDOC identifying the document. <br> *  pszClass        OLE_LPCSTR specifying the class of document to create. <br> *  pszDoc          OLE_LPCSTR to the permanent name of the document to open. <br> *  pszTemp         OLE_LPCSTR to the file to use as a template. <br> *  ppServerDoc     LPLPOLESERVERDOC in which to store a pointer <br> *                  to the OLESERVERDOC structure for this new document. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerCreateFromTemplate(LPCOSMOSERVER pSvr <br>    , LHSERVERDOC lhDoc, OLE_LPCSTR pszClass, OLE_LPCSTR pszDoc <br>    , OLE_LPCSTR pszTemp, LPLPOLESERVERDOC ppServerDoc) <br>    { <br>    POLYLINE        pl; <br>    LPCOSMODOC      pDoc; <br> <br>    /* <br>     * 1.   Create a document of the specified class. <br>     * 2.   Read the contents of the specified file and initialize the document. <br>     * 3.   Allocate and initialize an OLESERVERDOC structure. <br>     * 4.   Store lhDoc in the OLESERVERDOC structure. <br>     * 5.   Store a pointer to the new OLESERVERDOC structure in ppServerDoc. <br>     * 6.   Return OLE_OK if successful, OLE_ERROR_TEMPLATE otherwise. <br>     */ <br> <br>    //pszTemp contains a filename. <br>    if (!FCosFileRead(pGlob, (LPSTR)pszTemp, &amp;pl)) <br>        return OLE_ERROR_TEMPLATE; <br> <br>    pDoc=PDocumentAllocate(&amp;pOLE-&gt;vtblDoc); <br> <br>    if ((LPCOSMODOC)NULL==pDoc) <br>        return OLE_ERROR_TEMPLATE; <br> <br>    pSvr-&gt;pDoc=pDoc; <br> <br>    pDoc-&gt;lh=lhDoc; <br>    *ppServerDoc=(LPOLESERVERDOC)pDoc; <br> <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINESET, TRUE, (LONG)(LPSTR)&amp;pl); <br> <br>    //The titles in this window will be set later through SetHostNames. <br>    pGlob-&gt;fOpenFile=TRUE; <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br>/* <br> * ServerEdit <br> * <br> * Purpose: <br> *  Creates a document initialized with data from a subsequent call <br> *  to the SetData function.  The object is embedded in the client <br> *  application and the server is not visible. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER to structure identifying the server. <br> *  lhDoc           LHSERVERDOC identifying the document. <br> *  pszClass        OLE_LPCSTR specifying the class of document to create. <br> *  pszDoc          OLE_LPCSTR specifying the document for use in window titles. <br> *  ppServerDoc     LPLPOLESERVERDOC in which to store a pointer <br> *                  to the OLESERVERDOC structure for this new document. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerEdit(LPCOSMOSERVER pSvr, LHSERVERDOC lhDoc <br>    , OLE_LPCSTR pszClass, OLE_LPCSTR pszDoc, LPLPOLESERVERDOC ppServerDoc) <br>    { <br>    LPCOSMODOC      pDoc; <br> <br>    /* <br>     * This is the same as Open, but tells the server to expect <br>     * a SetData call and that the server is initially hidden. <br>     * <br>     * 1.   Create a document of the specified class. <br>     * 2.   Allocate and initialize an OLESERVERDOC structure. <br>     * 3.   Store lhDoc in the OLESERVERDOC structure. <br>     * 4.   Store pointer to the new OLESERVERDOC structure in ppServerDoc. <br>     * 5.   Return OLE_OK if successful, OLE_ERROR_EDIT otherwise. <br>     */ <br> <br>    pDoc=PDocumentAllocate(&amp;pOLE-&gt;vtblDoc); <br> <br>    if ((LPCOSMODOC)NULL==pDoc) <br>        return OLE_ERROR_EDIT; <br> <br>    pSvr-&gt;pDoc=pDoc; <br> <br>    pDoc-&gt;lh=lhDoc; <br>    *ppServerDoc=(LPOLESERVERDOC)pDoc; <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br>/* <br> * ServerExecute <br> * <br> * Purpose: <br> *  Handles DDE Execute commands sent from the server library <br> *  from the client application.  Not all applications need to support <br> *  DDE Execute. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER identifying the server closing. <br> *  hCommands       HGLOBAL to memory containing the DDE execute <br> *                  string. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> *                  This functions returns OLE_ERROR_COMMAND to indicate <br> *                  that it is not implemented. <br> */ <br> <br>OLESTATUS WINAPI ServerExecute(LPCOSMOSERVER pSvr, HGLOBAL hCommands) <br>    { <br>    /* <br>     * 1.   Lock the hCommands handle to access the execute strings. <br>     * 2.   Parse and execute the commands as necessary. <br>     * 3.   DO NOT FREE hCommands. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_COMMAND otherwise. <br>     */ <br> <br>    return OLE_ERROR_COMMAND; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ServerExit <br> * <br> * Purpose: <br> *  Instructs the server application to close documents and shut down. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER identifying the server closing. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerExit(LPCOSMOSERVER pSvr) <br>    { <br> <br>    /* <br>     * 1.   Hide the window to prevent any user interaction. <br>     * 2.   Call OleRevokeServer.  Ignore an OLE_WAIT_FOR_RELEASE return value. <br>     * 3.   Perform whatever action is necessary to cause the application <br>     *      to terminate, such as DestroyWindow. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     */ <br> <br>    ShowWindow(pGlob-&gt;hWnd, SW_HIDE); <br> <br>    pSvr-&gt;fRelease=FALSE; <br>    OleRevokeServer(pSvr-&gt;lh); <br> <br>    DestroyWindow(pGlob-&gt;hWnd); <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ServerOpen <br> * <br> * Purpose: <br> *  Opens an exiting file (document) and prepares the document for <br> *  editing, generally done when a user double-clicks a linked <br> *  object in the client.  Note that the server is hidden at this <br> *  point. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER to structure identifying the server. <br> *  lhDoc           LHSERVERDOC identifying the document. <br> *  pszDoc          OLE_LPCSTR to the permanent name of the document to <br> *                  be opened. <br> *  ppServerDoc     LPLPOLESERVERDOC in which to store a pointer <br> *                  to the OLESERVERDOC structure for this new document. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerOpen(LPCOSMOSERVER pSvr, LHSERVERDOC lhDoc <br>    , OLE_LPCSTR pszDoc, LPLPOLESERVERDOC ppServerDoc) <br>    { <br>    POLYLINE        pl; <br>    LPCOSMODOC      pDoc; <br> <br>    /* <br>     * 1.   Create a document of the specified class. <br>     * 2.   Read the contents of the specified file and initialize the document. <br>     * 3.   Save the filename of the loaded file with this document, <br>     *      if necessary. <br>     * 4.   Allocate and initialize an OLESERVERDOC structure. <br>     * 5.   Store lhDoc in the OLESERVERDOC structure. <br>     * 6.   Store a pointer to the new OLESERVERDOC structure in ppServerDoc. <br>     * 7.   Return OLE_OK if successful, OLE_ERROR_OPEN otherwise. <br>     */ <br> <br>    if (!FCosFileRead(pGlob, (LPSTR)pszDoc, &amp;pl)) <br>        return OLE_ERROR_OPEN; <br> <br>    pDoc=PDocumentAllocate(&amp;pOLE-&gt;vtblDoc); <br> <br>    if ((LPCOSMODOC)NULL==pDoc) <br>        return OLE_ERROR_OPEN; <br> <br>    //Save the document in the server for later access in ServerRelease. <br>    pSvr-&gt;pDoc=pDoc; <br> <br>    pDoc-&gt;lh=lhDoc; <br>    *ppServerDoc=(LPOLESERVERDOC)pDoc; <br> <br>    WindowTitleSet(pGlob-&gt;hWnd, (LPSTR)pszDoc); <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINESET, TRUE, (LONG)(LPSTR)&amp;pl); <br>    pGlob-&gt;fOpenFile=TRUE; <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ServerRelease <br> * <br> * Purpose: <br> *  Notifies a server that all connections to it have been closed and <br> *  that the server application can terminate.  This function should <br> *  change the state of a global flag that causes any PeekMessage <br> *  waiting loop to exit. <br> * <br> * Parameters: <br> *  pSvr            LPCOSMOSERVER identifying the server. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ServerRelease(LPCOSMOSERVER pSvr) <br>    { <br>    /* <br>     * 1.   Set a flag to indicate that Release has been called. <br>     * 2.   If the application is hidden, we must use ServerRelease to <br>     *      instruct the application to terminate, by posting a WM_CLOSE <br>     *      or otherwise effective message, then exit the method with OLE_OK. <br>     * 3.   Free any resources allocated for this server, like documents, <br>     *      but DO NOT free the OLESERVER structure itself. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     */ <br> <br>    pSvr-&gt;fRelease=TRUE; <br> <br>    /* <br>     * If we are invisible when we get ServerRelease, that's a flag <br>     * to us meaning exit.  Posting a WM_CLOSE takes care of all <br>     * this.  Note that even though WM_CLOSE processing in COSMO.C <br>     * checks for a dirty file and asks to save if necessary, the <br>     * file cannot be dirty because there has been no chance for <br>     * the user to make any changes. <br>     * <br>     * ServerRelease may be called twice when the server is opened invisible <br>     * for an update of a client object.  In this case, we'll get <br>     * ServerRelease once, where we should post a message to terminate the <br>     * application.  The second time around we need to handle free resources <br>     * associated with the server.  We detect this through the validity <br>     * pOLE-&gt;pSvr-&gt;lh which we set to 0L in FFileExit before calling <br>     * OleRevokeServer.  0L in lh signals us that we're in the final <br>     * revoke and we can free documents. <br>     * <br>     */ <br>    if (!IsWindowVisible(pGlob-&gt;hWnd) &amp;&amp; 0L!=pOLE-&gt;pSvr-&gt;lh) <br>        { <br>        PostMessage(pGlob-&gt;hWnd, WM_CLOSE, 0, 0L); <br>        return OLE_OK; <br>        } <br> <br>    /* <br>     * Free the document if we are closing from OleRevokeServer, not through <br>     * a client releasing the server. <br>     */ <br>    if (0L==pOLE-&gt;pSvr-&gt;lh) <br>        { <br>        //Free the document we're holding. <br>        if (NULL!=pSvr-&gt;pDoc) <br>            { <br>            if (NULL!=pSvr-&gt;pDoc-&gt;hMem) <br>                LocalFree(pSvr-&gt;pDoc-&gt;hMem); <br>            } <br> <br>        pSvr-&gt;pDoc=NULL; <br>        } <br> <br>    return OLE_OK; <br>    } <br> <br> <br>#endif //MAKEOLESERVER </code></pre>
<p>&nbsp;</p></body>
</HTML>
