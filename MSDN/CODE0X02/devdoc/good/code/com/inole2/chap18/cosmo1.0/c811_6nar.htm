<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COSMO.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context813"></a>COSMO.C</h2>
<pre><code>/* <br> * COSMO.C <br> * <br> * Basic Windows application code, with only a few specifics for handling <br> * blocking as far as OLE goes.  Most OLE interaction is directed through <br> * other functions in other source files that actually make the OLE library <br> * calls. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br> <br> <br> <br> <br> <br>/* <br> * Array of pointers to strings loaded from the resource file. <br> * Pointers can be near since we'll use LocalAlloc for <br> * the string space. <br> */ <br> <br>char NEAR   *rgpsz[CSTRINGS]; <br> <br>//Global variable block. <br>GLOBALS     stGlobals; <br>LPGLOBALS   pGlob=&amp;stGlobals; <br> <br> <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.   Should register the app class <br> *  if a previous instance has not done so and do any other one-time <br> *  initializations. <br> * <br> * Parameters: <br> *  See Windows SDK Guide to Programming, page 2-3 <br> * <br> * Return Value: <br> *  Value to return to Windows--termination code. <br> * <br> */ <br> <br>int PASCAL WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance <br>    , LPSTR lpszCmdLine, int nCmdShow) <br>    { <br>    HACCEL      hAccel; <br>    HWND        hWnd; <br>    MSG         msg; <br> <br> <br>    pGlob-&gt;hInst=hInstance; <br>    pGlob-&gt;pszCmdLine=lpszCmdLine; <br>    pGlob-&gt;nCmdShow=nCmdShow; <br> <br>    /* <br>     * Try to initialize; on failure, clean up anything that might have <br>     * been allocated. <br>     */ <br>    if (!FApplicationInit(pGlob, hPrevInstance)) <br>        { <br>        FApplicationExit(pGlob); <br>        return FALSE; <br>        } <br> <br>    hWnd=CreateWindow(rgpsz[IDS_CLASSCOSMO], rgpsz[IDS_CAPTION] <br>        , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW, CW_USEDEFAULT <br>        , CW_USEDEFAULT, 400, 350, NULL, NULL, hInstance, NULL); <br> <br>    if (NULL==hWnd) <br>        { <br>        FApplicationExit(pGlob); <br>        return FALSE; <br>        } <br> <br>    //Prevent the WM_SIZE from ShowWindow from making us dirty. <br>    pGlob-&gt;fNoDirty=TRUE; <br>    ShowWindow(hWnd, pGlob-&gt;nCmdShow); <br>    pGlob-&gt;fNoDirty=FALSE; <br> <br>    if (SW_HIDE != pGlob-&gt;nCmdShow) <br>        UpdateWindow(hWnd); <br> <br>    hAccel=LoadAccelerators(hInstance, MAKEINTRESOURCE(IDR_ACCELERATORS)); <br> <br>    //Non-OLE message loop. <br>    while (GetMessage(&amp;msg, NULL, 0,0 )) <br>        { <br>        if (!TranslateAccelerator(hWnd, hAccel, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    FApplicationExit(pGlob); <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CosmoWndProc <br> * <br> * Purpose: <br> *  Window class procedure.  Standard callback. <br> * <br> * Parameters: <br> *  The standard. <br> * <br> * Return Value: <br> *  The standard. <br> * <br> */ <br> <br>LRESULT WINAPI CosmoWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam) <br>    { <br>    static BOOL fNoSizePoly; <br>    RECT        rc; <br>    BOOL        fOK; <br>    UINT        uTemp; <br>    DWORD       dwStyle; <br>    WORD        wID=LOWORD(wParam); <br> <br>   #ifdef WIN32 <br>    WORD        wCode=HIWORD(wParam); <br>    HWND        hWndMsg=(HWND)(UINT)lParam; <br>   #else <br>    WORD        wCode=HIWORD(lParam); <br>    HWND        hWndMsg=(HWND)(UINT)lParam; <br>   #endif <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            //Set global variable defaults that pertain to this window. <br>            pGlob-&gt;hWnd=hWnd; <br>            pGlob-&gt;fOpenFile=FALSE; <br>            pGlob-&gt;fNoDirty=FALSE; <br> <br>            FDirtySet(FALSE); <br> <br>            //Create the secondary edit window. <br>            pGlob-&gt;hWndPolyline=HPolylineWindowCreate(hWnd, pGlob-&gt;hInst); <br> <br>            //Set the initial window title. <br>            WindowTitleSet(pGlob-&gt;hWnd, rgpsz[IDS_UNTITLED]); <br> <br>            if (!FFileInit(pGlob)) <br>                PostMessage(hWnd, WM_CLOSE, 0, 0L); <br> <br>            fNoSizePoly=FALSE; <br>            break; <br> <br> <br>        case WM_SIZE: <br>            /* If we are getting WM_SIZE in response to a Polyline <br>             * notification, then don't resize it again. <br>             */ <br> <br>            if (fNoSizePoly) <br>                break; <br> <br>            //Resize the polyline editor window to fit the new client area. <br>            GetClientRect(hWnd, &amp;rc); <br>            InflateRect(&amp;rc, -8, -8); <br> <br>            //Tell the Polyline window to resize without notifying us. <br>            SendMessage(pGlob-&gt;hWndPolyline, PLM_RECTSET, FALSE <br>                , (LONG)(LPSTR)&amp;rc); <br> <br>            /* <br>             * We consider sizing something that makes the file dirty, but <br>             * not until we've finished the create process, which is why <br>             * we set fDirty to FALSE after the ShowWindow above, because <br>             * ShowWindow sends a WM_SIZE when the window first appears. <br>             */ <br>            FDirtySet(TRUE); <br>            break; <br> <br>        case WM_GETMINMAXINFO: <br>            { <br>            //Limit the smallest tracking size allowable. <br>           #ifdef WIN32 <br>            LPMINMAXINFO    pmmi=(LPMINMAXINFO)lParam; <br> <br>            pmmi-&gt;ptMinTrackSize.x=158; <br>            pmmi-&gt;ptMinTrackSize.y=168; <br>           #else <br>            LPPOINT     ppt=(LPPOINT)lParam; <br> <br>            ppt[3].x=158; <br>            ppt[3].y=168; <br>           #endif <br>            } <br>            break; <br> <br>        case WM_CLOSE: <br>            if (!FFileExit(pGlob)) <br>                break; <br> <br>            DestroyWindow(hWnd);    //Same as DefWindowProc's action. <br>            break; <br> <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br> <br>        case WM_INITMENUPOPUP: <br>            /* <br>             * Check for Save possibility in File menu position 0. <br>             * In and OLE situation, this is always enabled. <br>             */ <br>            if (!pGlob-&gt;fOLE &amp;&amp; 0==LOWORD(lParam)) <br>                { <br>                uTemp=(pGlob-&gt;fOpenFile) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED); <br>                EnableMenuItem((HMENU)wParam, IDM_FILESAVE, uTemp | MF_BYCOMMAND); <br>                } <br> <br>            //Check for possibility of Paste for edit menu position 1 <br>            if (1==LOWORD(lParam)) <br>                { <br>                fOK=IsClipboardFormatAvailable(pGlob-&gt;cfCosmo); <br>                uTemp=(fOK) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED); <br>                EnableMenuItem((HMENU)wParam, IDM_EDITPASTE, uTemp | MF_BYCOMMAND); <br>                } <br> <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            switch (wID) <br>                { <br>                case ID_POLYLINE: <br>                    if (PLN_POINTCHANGE==wCode) <br>                        { <br>                        FDirtySet(TRUE); <br>                        break; <br>                        } <br> <br>                    /* <br>                     * Polyline window is informing us that it changed size <br>                     * in response to setting it's data.  Therefore we <br>                     * have to size ourselves accordingly. <br>                     */ <br>                    if (PLN_SIZECHANGE==wCode) <br>                        { <br>                        //Calculate new DIMENSIONS (we won't move) <br>                        GetWindowRect(pGlob-&gt;hWndPolyline, &amp;rc); <br>                        InflateRect(&amp;rc, 8, 8); <br> <br>                        dwStyle=GetWindowLong(pGlob-&gt;hWnd, GWL_STYLE); <br>                        AdjustWindowRect(&amp;rc, dwStyle, TRUE); <br> <br>                        fNoSizePoly=TRUE; <br>                        SetWindowPos(pGlob-&gt;hWnd, NULL, 0, 0 <br>                            , rc.right-rc.left, rc.bottom-rc.top <br>                            , SWP_NOMOVE | SWP_NOZORDER); <br> <br>                        fNoSizePoly=FALSE; <br>                        FDirtySet(TRUE); <br>                        } <br>                    break; <br> <br> <br>                case IDM_FILENEW: <br>                    FFileNew(pGlob); <br>                    break; <br> <br> <br>                case IDM_FILEOPEN: <br>                    FFileOpen(pGlob, FALSE); <br>                    break; <br> <br> <br>                case IDM_FILESAVE: <br>                    FFileSave(pGlob); <br>                    break; <br> <br> <br>                case IDM_FILESAVEAS: <br>                    fOK=FFileSaveAs(pGlob); <br>                    return MAKELONG(fOK, 0); <br> <br> <br>                case IDM_FILEIMPORT: <br>                    FFileOpen(pGlob, TRUE); <br>                    break; <br> <br> <br>                case IDM_FILEEXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br> <br> <br>                case IDM_EDITUNDO: <br>                    SendMessage(pGlob-&gt;hWndPolyline, PLM_BACKUPUNDO, 0, 0L); <br>                    break; <br> <br>                case IDM_EDITCUT: <br>                    FEditCut(pGlob); <br>                    break; <br> <br>                case IDM_EDITCOPY: <br>                    FEditCopy(pGlob, FALSE); <br>                    break; <br> <br>                case IDM_EDITPASTE: <br>                    FEditPaste(pGlob); <br>                    break; <br> <br> <br>                case IDM_HELPABOUT: <br>                   #ifdef WIN32 <br>                    DialogBox(pGlob-&gt;hInst, MAKEINTRESOURCE(IDD_ABOUT) <br>                        , pGlob-&gt;hWnd, AboutProc); <br>                   #else <br>                    { <br>                    DLGPROC     lpfn; <br> <br>                    lpfn=(DLGPROC)MakeProcInstance((FARPROC)AboutProc, pGlob-&gt;hInst); <br>                    DialogBox(pGlob-&gt;hInst, MAKEINTRESOURCE(IDD_ABOUT) <br>                        , pGlob-&gt;hWnd, lpfn); <br>                    FreeProcInstance((FARPROC)lpfn); <br>                    } <br>                   #endif <br> <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * AboutProc <br> * <br> * Purpose: <br> *  Dialog procedure for the omnipresent About box. <br> * <br> * Parameters: <br> *  The standard. <br> * <br> * Return Value: <br> *  The value to be returned through the DialogBox call that <br> *  created the dialog. <br> * <br> */ <br> <br>BOOL WINAPI AboutProc(HWND hDlg, UINT iMsg, UINT wParam, LONG lParam) <br>    { <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog(hDlg, TRUE); <br>                } <br>            break; <br>        } <br>    return FALSE; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
