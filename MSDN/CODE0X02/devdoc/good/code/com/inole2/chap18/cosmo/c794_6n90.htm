<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOLEOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context804"></a>IOLEOBJ.CPP</h2>
<pre><code>/* <br> * IOLEOBJ.CPP <br> * Cosmo Chapter 18 <br> * <br> * Implementation of the IOleObject interface for Polyline. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "cosmo.h" <br> <br> <br>/* <br> * CImpIOleObject::CImpIOleObject <br> * CImpIOleObject::~CImpIOleObject <br> * <br> * Parameters (Constructor): <br> *  pObj            PCFigure of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIOleObject::CImpIOleObject(PCFigure pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIOleObject::~CImpIOleObject(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIOleObject::QueryInterface <br> * CImpIOleObject::AddRef <br> * CImpIOleObject::Release <br> */ <br> <br>STDMETHODIMP CImpIOleObject::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleObject::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleObject::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetClientSite <br> * <br> * Purpose: <br> *  Provides the object with a pointer to the IOleClient site <br> *  representing the container in which this object resides. <br> * <br> * Parameters: <br> *  pIOleClientSite LPOLECLIENTSITE to the container's interface. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetClientSite <br>    (LPOLECLIENTSITE pIOleClientSite) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleClientSite) <br>        m_pObj-&gt;m_pIOleClientSite-&gt;Release(); <br> <br>    m_pObj-&gt;m_pIOleClientSite=pIOleClientSite; <br>    m_pObj-&gt;m_pIOleClientSite-&gt;AddRef(); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetClientSite <br> * <br> * Purpose: <br> *  Asks the object for the client site provided in SetClientSite. <br> *  If you have not seen SetClientSite yet, return a NULL in <br> *  ppIOleClientSite. <br> * <br> * Parameters: <br> *  ppSite          LPOLECLIENTSITE * in which to store the <br> *                  pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetClientSite(LPOLECLIENTSITE <br>    *ppSite) <br>    { <br>    //Be sure to AddRef the new pointer you are giving away. <br>    *ppSite=m_pObj-&gt;m_pIOleClientSite; <br>    m_pObj-&gt;m_pIOleClientSite-&gt;AddRef(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetHostNames <br> * <br> * Purpose: <br> *  Provides the object with names of the container application and <br> *  the object in the container to use in object user interface. <br> * <br> * Parameters: <br> *  pszApp          LPCOLESTR of the container application. <br> *  pszObj          LPCOLESTR of some name useful in window titles. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetHostNames(LPCOLESTR pszApp <br>    , LPCOLESTR pszObj) <br>    { <br>    m_pObj-&gt;m_fEmbedded=TRUE; <br>   #ifdef WIN32ANSI <br>    char        szApp[80], szObj[80]; <br> <br>    szApp[0]=0; <br>    szObj[0]=0; <br> <br>    if (NULL!=pszApp) <br>        { <br>        WideCharToMultiByte(CP_ACP, 0, pszApp, -1, szApp, 80 <br>            , NULL, NULL); <br>        } <br> <br>    if (NULL!=pszObj) <br>        { <br>        WideCharToMultiByte(CP_ACP, 0, pszObj, -1, szObj, 80 <br>            , NULL, NULL); <br>        } <br> <br>    m_pObj-&gt;m_pFR-&gt;UpdateEmbeddingUI(TRUE, m_pObj-&gt;m_pDoc <br>        , szApp, szObj); <br>   #else <br>    m_pObj-&gt;m_pFR-&gt;UpdateEmbeddingUI(TRUE, m_pObj-&gt;m_pDoc <br>        , pszApp, pszObj); <br>   #endif <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Close <br> * <br> * Purpose: <br> *  Forces the object to close down its user interface and unload. <br> * <br> * Parameters: <br> *  dwSaveOption    DWORD describing the circumstances under which <br> *                  the object is being saved and closed. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Close(DWORD dwSaveOption) <br>    { <br>    HWND        hWnd; <br>    BOOL        fSave=FALSE; <br> <br>    hWnd=m_pObj-&gt;m_pDoc-&gt;Window(); <br> <br>    //If object is dirty and we're asked to save, save it and close. <br>    if (OLECLOSE_SAVEIFDIRTY==dwSaveOption &amp;&amp; m_pObj-&gt;FIsDirty()) <br>        fSave=TRUE; <br> <br>    /* <br>     * If asked to prompt, only do so if dirty, then if we get a <br>     * YES, save as usual and close.  On NO, just close.  On <br>     * CANCEL return OLE_E_PROMPTSAVECANCELLED. <br>     */ <br>    if (OLECLOSE_PROMPTSAVE==dwSaveOption &amp;&amp; m_pObj-&gt;FIsDirty()) <br>        { <br>        UINT        uRet; <br> <br>        uRet=MessageBox(hWnd, (*m_pObj-&gt;m_pST)[IDS_CLOSECAPTION] <br>            , (*m_pObj-&gt;m_pST)[IDS_CLOSEPROMPT], MB_YESNOCANCEL); <br> <br>        if (IDCANCEL==uRet) <br>            return ResultFromScode(OLE_E_PROMPTSAVECANCELLED); <br> <br>        if (IDYES==uRet) <br>            fSave=TRUE; <br>        } <br> <br>    if (fSave) <br>        { <br>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVEOBJECT); <br>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVED); <br>        } <br> <br>    //We get directly here on OLECLOSE_NOSAVE. <br>    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetMoniker <br> * <br> * Purpose: <br> *  Informs the object of its moniker or its container's moniker <br> *  depending on dwWhich. <br> * <br> * Parameters: <br> *  dwWhich         DWORD describing whether the moniker is the <br> *                  object's or the container's. <br> *  pmk             LPMONIKER with the name. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetMoniker(DWORD dwWhich <br>    , LPMONIKER pmk) <br>    { <br>    //Uninteresting for embeddings only. <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetMoniker <br> * <br> * Purpose: <br> *  Asks the object for a moniker that can later be used to <br> *  reconnect to it. <br> * <br> * Parameters: <br> *  dwAssign        DWORD determining how to assign the moniker to <br> *                  to the object. <br> *  dwWhich         DWORD describing which moniker the caller wants. <br> *  ppmk            LPMONIKER * into which to store the moniker. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetMoniker(DWORD dwAssign <br>    , DWORD dwWhich, LPMONIKER * ppmk) <br>    { <br>    //Uninteresting for embeddings only. <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::InitFromData <br> * <br> * Purpose: <br> *  Initializes the object from the contents of a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT containing the data. <br> *  fCreation       BOOL indicating if this is part of a new <br> *                  creation. If FALSE, the container is trying <br> *                  to paste here. <br> *  dwReserved      DWORD reserved. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::InitFromData(LPDATAOBJECT pIDataObject <br>    , BOOL fCreation, DWORD dwReserved) <br>    { <br>    BOOL    fRet; <br> <br>    /* <br>     * If we get a data object here, try to paste from it.  If <br>     * you've written clipboard code already, this is a snap. <br>     * We don't really care about fCreation or not since pasting <br>     * in us blasts away whatever is already here. <br>     */ <br>    fRet=m_pObj-&gt;m_pDoc-&gt;PasteFromData(pIDataObject); <br>    return fRet ? NOERROR : ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetClipboardData <br> * <br> * Purpose: <br> *  Returns an IDataObject pointer to the caller representing what <br> *  would be on the clipboard if the server did an Edit/Copy using <br> *  OleSetClipboard. <br> * <br> * Parameters: <br> *  dwReserved      DWORD reserved. <br> *  ppIDataObj      LPDATAOBJECT * into which to store the <br> *                  pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetClipboardData(DWORD dwReserved <br>    , LPDATAOBJECT *ppIDataObj) <br>    { <br>    /* <br>     * Again, if you have a function to create a data object for the <br>     * clipboard, this is a simple implementation.  The one we have <br>     * does all the compound document formats already. <br>     */ <br>    *ppIDataObj=m_pObj-&gt;m_pDoc-&gt;TransferObjectCreate(FALSE); <br>    return (NULL!=*ppIDataObj) ? NOERROR : ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::DoVerb <br> * <br> * Purpose: <br> *  Executes an object-defined action. <br> * <br> * Parameters: <br> *  iVerb           LONG index of the verb to execute. <br> *  pMSG            LPMSG describing the event causing the <br> *                  activation. <br> *  pActiveSite     LPOLECLIENTSITE to the site involved. <br> *  lIndex          LONG the piece on which execution is happening. <br> *  hWndParent      HWND of window in which the object can play <br> *                  in-place. <br> *  pRectPos        LPRECT of the object in hWndParent where the <br> *                  object can play in-place if desired. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::DoVerb(LONG iVerb, LPMSG pMSG <br>    , LPOLECLIENTSITE pActiveSite, LONG lIndex, HWND hWndParent <br>    , LPCRECT pRectPos) <br>    { <br>    HWND            hWnd, hWndT; <br> <br>    //Find the upper most window <br>    hWndT=GetParent(m_pObj-&gt;m_pDoc-&gt;Window()); <br> <br>    while (NULL!=hWndT) <br>        { <br>        hWnd=hWndT; <br>        hWndT=GetParent(hWndT); <br>        } <br> <br>    switch (iVerb) <br>        { <br>        case OLEIVERB_HIDE: <br>            ShowWindow(hWnd, SW_HIDE); <br>            m_pObj-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW); <br>            break; <br> <br>        case OLEIVERB_PRIMARY: <br>        case OLEIVERB_OPEN: <br>        case OLEIVERB_SHOW: <br>            ShowWindow(hWnd, SW_SHOW); <br>            SetForegroundWindow(hWnd); <br>            SetFocus(hWnd); <br> <br>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWOBJECT); <br>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWWINDOW); <br>            break; <br> <br>        default: <br>            return ResultFromScode(OLEOBJ_S_INVALIDVERB); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::EnumVerbs <br> * <br> * Purpose: <br> *  Creates an enumerator that knows the object's verbs.  If you <br> *  need to change the verb list dynamically, then you'll need to <br> *  implement this, otherwise you can return OLE_S_USEREG. <br> * <br> * Parameters: <br> *  ppEnum          LPENUMOLEVERB * into which to return the <br> *                  enum. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::EnumVerbs(LPENUMOLEVERB *ppEnum) <br>    { <br>    //Trivial implementation if you fill the regDB. <br>    return ResultFromScode(OLE_S_USEREG); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Update <br> * <br> * Purpose: <br> *  Insures that the object is up to date.  This is mostly used for <br> *  caching but you must make sure that you recursively call all <br> *  nested objects you contain as well. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Update(void) <br>    { <br>    //We're always updated since we don't contain. <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::IsUpToDate <br> * <br> * Purpose: <br> *  Returns if the object is currently up to date, which involves <br> *  asking all contained object inside this object if they are up <br> *  to date as well. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE if dirty. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::IsUpToDate(void) <br>    { <br>    //We're always updated since we don't contain. <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetUserClassID <br> * <br> * Purpose: <br> *  Used for linked objects, this returns the class ID of what end <br> *  users think they are editing. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store the CLSID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetUserClassID(LPCLSID pClsID) <br>    { <br>    /* <br>     * If you are not registered to handle data other than yourself, <br>     * then you can just return your class ID here.  If you are <br>     * registered as usable from Treat-As dialogs, then you need <br>     * to return the CLSID of what you are really editing. <br>     */ <br> <br>    *pClsID=m_pObj-&gt;m_clsID; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetUserType <br> * <br> * Purpose: <br> *  Determines the user-presentable name of the object. <br> * <br> * Parameters: <br> *  dwForm          DWORD describing which form of the string is <br> *                  desired. <br> *  pszType         LPOLESTR * into which to return the pointer to <br> *                  the type string. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetUserType(DWORD dwForm <br>    , LPOLESTR *ppszType) <br>    { <br>    return ResultFromScode(OLE_S_USEREG); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetExtent <br> * <br> * Purpose: <br> *  Sets the size of the object in HIMETRIC units. <br> * <br> * Parameters: <br> *  dwAspect        DWORD of the aspect affected. <br> *  pszl            LPSIZEL containing the new size. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetExtent(DWORD dwAspect, LPSIZEL pszl) <br>    { <br>    RECT            rc; <br>    SIZEL           szl; <br> <br>    if (!(DVASPECT_CONTENT &amp; dwAspect)) <br>        return ResultFromScode(E_FAIL); <br> <br>    XformSizeInHimetricToPixels(NULL, pszl, &amp;szl); <br> <br>    //This resizes the window to match the container's size. <br>    SetRect(&amp;rc, 0, 0, (int)szl.cx, (int)szl.cy); <br>    m_pObj-&gt;m_pPL-&gt;SizeSet(&amp;rc, TRUE); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetExtent <br> * <br> * Purpose: <br> *  Retrieves the size of the object in HIMETRIC units. <br> * <br> * Parameters: <br> *  dwAspect        DWORD of the aspect requested <br> *  pszl            LPSIZEL into which to store the size. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetExtent(DWORD dwAspect, LPSIZEL pszl) <br>    { <br>    RECT            rc; <br>    SIZEL           szl; <br> <br>    if (!(DVASPECT_CONTENT &amp; dwAspect)) <br>        return ResultFromScode(E_FAIL); <br> <br>    m_pObj-&gt;m_pPL-&gt;RectGet(&amp;rc); <br>    szl.cx=rc.right-rc.left; <br>    szl.cy=rc.bottom-rc.top; <br> <br>    XformSizeInPixelsToHimetric(NULL, &amp;szl, pszl); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Advise <br> * <br> * Purpose: <br> *  Provides an IAdviseSink to the object for notifications. <br> * <br> * Parameters: <br> *  pIAdviseSink    LPADVISESINK to notify. <br> *  pdwConn         LPDWORD into which to store a connection key. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Advise(LPADVISESINK pIAdviseSink <br>    , LPDWORD pdwConn) <br>    { <br>    if (NULL==m_pObj-&gt;m_pIOleAdviseHolder) <br>        { <br>        HRESULT     hr; <br> <br>        hr=CreateOleAdviseHolder(&amp;m_pObj-&gt;m_pIOleAdviseHolder); <br> <br>        if (FAILED(hr)) <br>            return hr; <br>        } <br> <br>    return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Advise(pIAdviseSink <br>        , pdwConn); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Unadvise <br> * <br> * Purpose: <br> *  Terminates a previous advise connection from Advise. <br> * <br> * Parameters: <br> *  dwConn          DWORD connection key from Advise. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Unadvise(DWORD dwConn) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder) <br>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Unadvise(dwConn); <br> <br>    return ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::EnumAdvise <br> * <br> * Purpose: <br> *  Creates and returns a enumeration of the advises on this object. <br> * <br> * Parameters: <br> *  ppEnum          LPENUMSTATDATA * in which to return the <br> *                  enumerator. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::EnumAdvise(LPENUMSTATDATA *ppEnum) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder) <br>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;EnumAdvise(ppEnum); <br> <br>    return ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetMiscStatus <br> * <br> * Purpose: <br> *  Returns a set of miscellaneous status flags for the object. <br> * <br> * Parameters: <br> *  dwAspect        DWORD of the aspect in question. <br> *  pdwStatus       LPDWORD in which to store the flags. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetMiscStatus(DWORD dwAspect <br>    , LPDWORD pdwStatus) <br>    { <br>    return ResultFromScode(OLE_S_USEREG); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetColorScheme <br> * <br> * Purpose: <br> *  Provides the object with the color palette as recommended by <br> *  the container application that also knows the palettes of other <br> *  objects.  The object here is not required to use these colors. <br> * <br> * Parameters: <br> *  pLP             LPLOGPALETTE providing the colors. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetColorScheme(LPLOGPALETTE pLP) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
