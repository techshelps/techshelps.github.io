<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEMISC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context829"></a>OLEMISC.C</h2>
<pre><code>/* <br> * OLEMISC.C <br> * <br> * Functions without another approprate home: <br> *  MenuEmbeddingSet <br> *  OLEClientNotify <br> *  FOLEReleaseWait <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br>#ifdef MAKEOLESERVER <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br> <br> <br> <br>/* <br> * MenuEmbeddingSet <br> * <br> * Purpose: <br> *  Modifies the main menu of the application to change "Save" to "Update" <br> *  and to change "Exit" to "Exit &amp; return to xx."  Alternately, this <br> *  function can change the menus back to the original state, reverting <br> *  "Update" to "Save" and setting the Exit item back to plain "Exit." <br> * <br> * Parameters: <br> *  hWnd            HWND of the window with the menu. <br> *  pszClient       LPSTR to the client name. <br> *  fOLE            BOOL indiciating if we are to set for OLE or to normal. <br> *                  If setting to normal, pszClient can be NULL. <br> * <br> * Return Value: <br> *  None. <br> * <br> */ <br> <br>void WINAPI MenuEmbeddingSet(HWND hWnd, LPSTR pszClient, BOOL fOLE) <br>    { <br>    HMENU       hMenu; <br>    char        szTemp[130]; <br>    LPSTR       pszT; <br> <br>    hMenu=GetMenu(pGlob-&gt;hWnd); <br> <br>    //Change the File/Save menu to File/Update &lt;client&gt; or vice-versa <br>    if (fOLE) <br>        wsprintf(szTemp, rgpsz[IDS_UPDATE], pszClient); <br>    else <br>        lstrcpy(szTemp, rgpsz[IDS_SAVE]); <br> <br>    ModifyMenu(hMenu, IDM_FILESAVE, MF_STRING, IDM_FILESAVE, szTemp); <br> <br> <br>    //Change the File/Save As menu to File/Save Copy As or vice-versa. <br>    pszT=(fOLE) ? rgpsz[IDS_SAVECOPYAS] : rgpsz[IDS_SAVEAS]; <br>    ModifyMenu(hMenu, IDM_FILESAVEAS, MF_STRING, IDM_FILESAVEAS, pszT); <br> <br> <br>    //Change "Exit" to "Exit &amp; return to xx" or vice-versa. <br>    if (fOLE) <br>        wsprintf(szTemp, rgpsz[IDS_EXITANDRETURN], pszClient); <br>    else <br>        lstrcpy(szTemp, rgpsz[IDS_EXIT]); <br> <br>    ModifyMenu(hMenu, IDM_FILEEXIT, MF_STRING, IDM_FILEEXIT, szTemp); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * OLEClientNotify <br> * <br> * Purpose: <br> *  Performs a direct function call to the single callback in the <br> *  client that is communicating with this server application. <br> *  This is the only point where there is direct communication <br> *  between the two applciations. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT that contains a pClient pointer to an <br> *                  LPOLECLIENT that holds a pointer to the OLECLIENTVTBL <br> *                  that holds a pointer to the CallBack function. <br> *  iMsg            UINT, message to send, such as OLE_CLOSED. <br> * <br> * Return Value: <br> *  None. <br> */ <br> <br>void WINAPI OLEClientNotify(LPCOSMOOBJECT pObj, UINT iMsg) <br>    { <br>    LPOLECLIENT     pClient; <br>    LPOLECLIENTVTBL pvt; <br> <br>    if (NULL==pObj) <br>        return; <br> <br>    pClient=pObj-&gt;pClient; <br> <br>    if (NULL==pClient) <br>        return; <br> <br>    pvt=pClient-&gt;lpvtbl; <br> <br>    if (NULL==pvt) <br>        return; <br> <br>    (pvt-&gt;CallBack)(pClient, iMsg, (LPOLEOBJECT)pObj); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FOLEReleaseWait <br> * <br> * Purpose: <br> *  Enters a Peek/Translate/Dispatch message loop to process all messages <br> *  to the application until a release flag has been sent.  The application <br> *  calls this routine whenever it is required to wait until conversations <br> *  for OLE have terminated. <br> * <br> *  Some of the messages processed may be DDE messages (for OLE 1.x) that <br> *  are eventually passed to OLESVR which eventually calls the ServerRelease <br> *  function (see OLESVR.C).  ServerRelease modifies a BOOL flag indicating <br> *  that the server is released. <br> * <br> *  Therefore we can watch a particular memory location (*pf) <br> *  and only exit when that flag is set. <br> * <br> * Parameters: <br> *  pf              BOOL FAR * to the flag to wait on. <br> *  lhSvr           LONG for the OLE server <br> * <br> * Return Value: <br> *  BOOL            Contents of *pf. <br> * <br> */ <br> <br>BOOL WINAPI FOLEReleaseWait(BOOL FAR *pf, LONG lhSvr) <br>    { <br>    MSG        msg; <br> <br>    *pf=FALSE; <br> <br>    while (FALSE==*pf) <br>        { <br>        /* <br>         * We use PeekMessage here to make a point about power <br>         * management and ROM Windows--GetMessage, when there's <br>         * no more messages, will correctly let the system go into <br>         * a low-power idle state.  PeekMessage by itself will not. <br>         * If you do background processing in a PeekMessage loop like <br>         * this, and there's no background processing to be done, <br>         * then you MUST call WaitMessage to duplicate the idle <br>         * state like GetMessage. <br>         */ <br> <br>        if (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>            { <br>            /* <br>             * We will not see WM_QUIT in the middle of the <br>             * application since this application MUST call <br>             * PostQuitMessage to get it in the queue.  Therefore we <br>             * don't even worry about it. <br>             */ <br> <br>            TranslateMessage (&amp;msg); <br>            DispatchMessage (&amp;msg); <br>            } <br>        else <br>            { <br>            /* <br>             * If the application has some background processing <br>             * to do, it should perform a piece of it here.  Otherwise <br>             * you MUST call WaitMessage or you'll screw up ROM-Windows <br>             * power-management. <br>             */ <br> <br>            WaitMessage(); <br>            } <br>        } <br> <br>    return *pf; <br>    } <br> <br> <br> <br> <br> <br>#endif //MAKEOLESERVER </code></pre>
<p>&nbsp;</p></body>
</HTML>
