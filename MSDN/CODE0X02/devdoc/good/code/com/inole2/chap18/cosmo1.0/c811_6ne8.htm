<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEOBJ.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context830"></a>OLEOBJ.C</h2>
<pre><code>/* <br> * OLEOBJ.C <br> * <br> * Contains all callback functions in the OLEOBJECTVTBL struture: <br> *      ObjDoVerb <br> *      ObjEnumFormats <br> *      ObjGetData <br> *      ObjQueryProtocol <br> *      ObjRelease <br> *      ObjSetBounds <br> *      ObjSetColorScheme <br> *      ObjSetData <br> *      ObjSetTargetDevice <br> *      ObjShow <br> * <br> * There are additional callbacks in the OLEOBJECTVTBL. <br> * Also contains PObjectAllocate, a constructor for the object. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br>#ifdef MAKEOLESERVER <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br>#include "oleinst.h"    //OBJVERB_* defines for ObjDoVerb <br> <br>/* <br> * PObjectAllocate <br> * <br> * Purpose: <br> *  Allocates a COSMOOBJECT structure and sets the defaults in its fields. <br> *  Used from DocGetObject. <br> * <br> * Parameters: <br> *  pVtblObj        LPOLESERVERDOCVTBL used to initialize the pvtbl field. <br> * <br> * Return Value: <br> *  LPCOSMOOBJECT   Pointer to the allocated structure in local memory. <br> *                  The hMem field will contain a handle to the structure <br> *                  to pass to LocalFree. <br> */ <br> <br>LPCOSMOOBJECT WINAPI PObjectAllocate(LPOLEOBJECTVTBL pVtblObj) <br>    { <br>    HLOCAL          hMem; <br>    LPCOSMOOBJECT   pObj; <br> <br>    hMem=LocalAlloc(LPTR, sizeof(COSMOOBJECT)); <br>    pObj=(LPCOSMOOBJECT)(PSTR)hMem; <br> <br>    //Initialize the object. <br>    pObj-&gt;hMem=hMem; <br>    pObj-&gt;pvtbl=pVtblObj; <br>    pObj-&gt;fRelease=TRUE; <br> <br>    return pObj; <br>    } <br> <br> <br> <br> <br>/* <br> * ObjDoVerb <br> * <br> * Purpose: <br> *  Performs actions on an object when the user opens an object <br> *  according to the verb given. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  iVerb           UINT index to the verb chosen, zero based. <br> *  fShow           BOOL--TRUE if the application should show <br> *                  itself with ShowWindow.  FALSE means no change. <br> *  fFocus          BOOL--TRUE if the server should get the focus. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjDoVerb(LPCOSMOOBJECT pObj, UINT iVerb <br>    , BOOL fShow, BOOL fFocus) <br>    { <br>    /* <br>     * 1.   Execute the verb. <br>     *        a.  For a 'Play' verb, a server does not generally show <br>     *            its window or affect the focus. <br>     * <br>     *        b.  For an 'Edit' verb, show the server's window and the <br>     *            object if fShow is TRUE, and take the focus if fFocus <br>     *            is TRUE.  An ideal way to accomplish this is to call <br>     *            the ObjShow method through the OLEOBJECTVTBL since that <br>     *            method will handle showing the object and taking the <br>     *            focus itself. <br>     * <br>     *        c.  An 'Open' verb is not clearly defined; depending on the <br>     *            application it may mean the same as 'Play' or 'Edit.' <br>     *            The Cosmo server, if it had an 'Open' verb, would treat <br>     *            it like 'Edit.' <br>     * <br>     * 2.  Return OLE_OK if the verb was successfully executed, otherwise <br>     *     OLE_ERROR_DOVERB. <br>     */ <br> <br>    switch (iVerb) <br>        { <br>        case OBJVERB_EDIT: <br>            /* <br>             * On edit, simply show yourself and expect a SetData. <br>             * Best strategy is to use the Show method for this <br>             * object if necessary, reducing redundancy. <br>             */ <br>            if (fShow) <br>                return (pObj-&gt;pvtbl-&gt;Show)((LPOLEOBJECT)pObj, fShow); <br> <br>            //Return OLE_OK <br>            break; <br> <br> <br>        case OBJVERB_PLAY: <br>            //Unsupported at this time. <br>            return OLE_ERROR_DOVERB; <br> <br>        default: <br>            return OLE_ERROR_DOVERB; <br>        } <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ObjEnumFormats <br> * <br> * Purpose: <br> *  Requests the server to produce the 'next' supported clipboard <br> *  format.  Each format is returned in sequence until the terminator <br> *  (a NULL) is returned. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  cf              OLECLIPFORMAT the last clipboard format returned by <br> *                  this function.  0 indicates the first. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLECLIPFORMAT WINAPI ObjEnumFormats(LPCOSMOOBJECT pObj, OLECLIPFORMAT cf) <br>    { <br>    /* <br>     * 1.   Depending on cf, return the 'next' clipboard format in which <br>     *      the server can render the object's data. <br>     * 2.   If there are no more supported formats after the format in cf, <br>     *      return NULL. <br>     * <br>     * We must use multiple if's instead of a switch statement because <br>     * all the cf* values are not constants. <br>     */ <br> <br>    if (0==cf) <br>       return pOLE-&gt;cfNative; <br> <br>    if (pOLE-&gt;cfNative==cf) <br>       return pOLE-&gt;cfOwnerLink; <br> <br>    if (pOLE-&gt;cfOwnerLink==cf) <br>       return CF_METAFILEPICT; <br> <br>    if (CF_METAFILEPICT==cf) <br>       return CF_BITMAP; <br> <br>    if (CF_BITMAP==cf) <br>       return pOLE-&gt;cfObjectLink; <br> <br>    //This IF is here just to be explicit. <br>    if (pOLE-&gt;cfObjectLink==cf) <br>       return 0; <br> <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * ObjGetData <br> * <br> * Purpose: <br> *  Retrieves data from the object in a specified format, where the <br> *  server should allocate memory (GlobalAlloc with GMEM_DDESHARE), <br> *  fill the memory, and return the handle. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  cf              OLECLIPFORMAT format to return data in, may be "Native." <br> *  phData          HGLOBAL FAR * in which to store the allocated handle. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjGetData(LPCOSMOOBJECT pObj, OLECLIPFORMAT cf <br>    , HGLOBAL FAR * phData) <br>    { <br>    HGLOBAL             hMem; <br> <br>    /* <br>     * 1.   Allocate the requested data throguh GlobalAlloc (with <br>     *      GMEM_MOVEABLE and GMEM_DDESHARE).  The exception is data for <br>     *      CF_BITMAP which uses a call like CreateBitmap. <br>     * 2.   Lock and fill the memory with the appropriate data. <br>     * 3.   Unlock the memory and store the handle in *phData. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_MEMORY otherwise. <br>     */ <br> <br>    //Return Native, metafile, or bitmap as requested. <br>    if (pOLE-&gt;cfNative==cf) <br>        hMem=HGetPolyline(pGlob-&gt;hWndPolyline); <br> <br>    if (CF_METAFILEPICT==cf) <br>        hMem=HGetMetafilePict(pGlob-&gt;hWndPolyline); <br> <br>    if (CF_BITMAP==cf) <br>        hMem=HGetBitmap(pGlob-&gt;hWndPolyline); <br> <br> <br>    //Use filename <br>    if (pOLE-&gt;cfObjectLink==cf) <br>         hMem=HLinkConstruct(rgpsz[IDS_CLASSCOSMO], "", ""); <br> <br>    /* <br>     * Even though this is exactly like ObjectLink, this is coded as <br>     * a separate case just in case it changes in the future. <br>     */ <br>    if (pOLE-&gt;cfOwnerLink==cf) <br>        hMem=HLinkConstruct(rgpsz[IDS_CLASSCOSMO], "", ""); <br> <br> <br>    if (NULL==hMem) <br>        return OLE_ERROR_MEMORY; <br> <br>    *phData=hMem; <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ObjQueryProtocol <br> * <br> * Purpose: <br> *  Returns a pointer to an COSMOOBJECT with the appropriate VTBL for <br> *  the protocol, either StdFileEditing or StdExecute.  Returns NULL <br> *  if that protocol is not supported. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  pszProtocol     OLE_LPCSTR, the protocol name. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>LPVOID WINAPI ObjQueryProtocol(LPCOSMOOBJECT pObj, OLE_LPCSTR pszProtocol) <br>    { <br> <br>    /* <br>     * 1.   If the protocol in pszProtocol is supported, return a pointer <br>     *      to an object that contains an appropriate VTBL fot that protocol, <br>     *      such as the pObj passed to this method. <br>     * 2.   If the protocol is not supported, return NULL. <br>     */ <br> <br>    //Check if OLESVR is asking for "StdFileEditing" <br>    if (0==lstrcmp(pszProtocol, rgpsz[IDS_STDFILEEDITING])) <br>        return (LPVOID)pObj; <br> <br>    return (LPVOID)NULL; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * ObjRelease <br> * <br> * Purpose: <br> *  Notifies a server that is can free any resources associated with an <br> *  object. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjRelease(LPCOSMOOBJECT pObj) <br>    { <br>    /* <br>     * 1.   Free any resources allocated for this object, but <br>     *      DO NOT free the OLEOBJECT structure itself. <br>     * 2.   Set a flag to indicate that Release has been called. <br>     * 3.   NULL any saved LPOLECLIENT stores in the OLEOBJECT structure. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     * <br>     * Do not use the Release method to free the memory containing <br>     * the object since you still need to use its pClient and fRelease. <br>     * This method simply notifies the object that no one is using it <br>     * anymore so we don't try to send notifications. <br>     */ <br> <br>    pObj-&gt;fRelease=TRUE; <br>    pObj-&gt;pClient=NULL; <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * ObjSetBounds <br> * <br> * Purpose: <br> *  Specifies a new boundary rectangle for the object in MM_HIMETRIC <br> *  units.  Only useful for embedded objects since a linked object <br> *  depends on the file loaded. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  pRect           LPRECT containing the new bounds. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjSetBounds(LPCOSMOOBJECT pObj, OLE_CONST RECT FAR *pRect) <br>    { <br>    //Unused in OLE1.x <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br>/* <br> * ObjSetColorScheme <br> * <br> * Purpose: <br> *  Provides a color scheme that the client application recommends for <br> *  rendering graphical data. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMOOBJECT specifying the object affected. <br> *  pPal            LPLOGPALETTE describing the recommended palette. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjSetColorScheme(LPCOSMOOBJECT pObj <br>    , OLE_CONST LOGPALETTE FAR *pPal) <br>    { <br>    /* <br>     * Servers are not required to use this palette.  The LPLOGPALETTE <br>     * only is a convenient structure to contain the color scheme; IT DOES <br>     * not REPRESENT A PALETTE IN STRICT TERMS!  Do NOT call CreatePalette <br>     * and try to realize it. <br>     * <br>     * The color scheme contained in the LOGPALETTE structure contains <br>     * a number of colors where the first color is the suggested foreground, <br>     * the second the suggested background, then the first HALF of those <br>     * remaining are suggested fill colors and the last half suggested <br>     * line colors.  If there are an odd number of colors, give the extra <br>     * color to the fill colors, that is, there is one less line color than <br>     * fill colors. <br>     */ <br> <br>    return OLE_ERROR_PALETTE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * ObjSetData <br> * <br> * Purpose: <br> *  Instructs the object to take the given data as current and copy it <br> *  to the object's internal data, use when a client opens an embedded <br> *  object or if the client calls OleSetData. <br> * <br> *  *NOTE: This function MUST be supported even if the registration <br> *         database does not contain an entry for SetDataFormats for <br> *         this server, because the callback is still used when opening <br> *         an embedded object for editing. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  cf              OLECLIPFORMAT format to return data in, may be "Native." <br> *  hData           HGLOBAL to memory containing the data. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjSetData(LPCOSMOOBJECT pObj, OLECLIPFORMAT cf <br>    , HGLOBAL hData) <br>    { <br>    LPPOLYLINE          lppl; <br> <br>    /* <br>     * 1.   If the data format is not supported, return OLE_ERROR_FORMAT. <br>     * 2.   Attempt to GlobalLock the memory to get a pointer to the data. <br>     *      If GlobalLock returns NULL, return OLE_ERROR_MEMORY. <br>     * 3.   Copy the data to the object identified by pObj. <br>     * 4.   Unlock and GlobalFree the data handle.  The ObjSetData method <br>     *      is responsible for the memory. <br>     * 5.   Return OLE_OK. <br>     */ <br> <br>    //Check if we were given Native data.  We don't support anything else. <br>    if (pOLE-&gt;cfNative!=cf) <br>        return OLE_ERROR_FORMAT; <br> <br>    lppl=(LPPOLYLINE)GlobalLock(hData); <br> <br>    /* <br>     * CHECK the return from GlobalLock since we don't know where this <br>     * handle has been. <br>     */ <br>    if (NULL==lppl) <br>        return OLE_ERROR_MEMORY; <br> <br>    //Set the data through the editing window. <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINESET, TRUE, (LONG)lppl); <br> <br>    //Make sure we are not dirty--no updating is yet necessary. <br>    FDirtySet(FALSE); <br> <br>    //Server is responsible for freeing the data. <br>    GlobalUnlock(hData); <br>    GlobalFree(hData); <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * ObjSetTargetDevice <br> * <br> * Purpose: <br> *  Communicates information from the client application to the server <br> *  about the device on which the object is drawn. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  hData           HGLOBAL containing a STDTARGETDEVICE structure. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjSetTargetDevice(LPCOSMOOBJECT pObj, HGLOBAL hData) <br>    { <br> <br>    /* <br>     * The server is responsible for freeing the the data handle <br>     * once it has finished using that data. <br>     * <br>     * If NULL==hData, then rendering is necessary for the screen. <br>     */ <br> <br>    if (NULL!=hData) <br>        GlobalFree(hData); <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * ObjShow <br> * <br> * Purpose: <br> *  Causes the server to show an object, showing the window and <br> *  scrolling it's client area if necessary. <br> * <br> * Parameters: <br> *  pObj            LPCOSMOOBJECT specifying the object affected. <br> *  fTakeFocus      BOOL:  TRUE if the server should get the focus, <br> *                  FALSE if not. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI ObjShow(LPCOSMOOBJECT pObj, BOOL fTakeFocus) <br>    { <br>    /* <br>     * 1.   Show the application window(s) if not already visible. <br>     * 2.   Scroll the object identified by pObj into view, if necessary. <br>     * 3.   Select the object if possible. <br>     * 4.   If fTakeFocus is TRUE, call SetFocus with the main window handle. <br>     * 5.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     */ <br> <br>    //Keep WM_SIZE on the ShowWindow from making us dirty. <br>    pGlob-&gt;fNoDirty=TRUE; <br> <br>    //Since we only have one object, we don't care what's in pObj. <br>    ShowWindow(pGlob-&gt;hWnd, SW_NORMAL); <br> <br>    pGlob-&gt;fNoDirty=FALSE; <br> <br>    if (fTakeFocus) <br>        SetFocus(pGlob-&gt;hWnd); <br> <br>    return OLE_OK; <br>    } <br> <br> <br>#endif //MAKEOLESERVER </code></pre>
<p>&nbsp;</p></body>
</HTML>
