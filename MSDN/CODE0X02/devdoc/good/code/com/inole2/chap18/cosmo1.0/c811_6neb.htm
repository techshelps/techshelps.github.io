<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYLINE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context833"></a>POLYLINE.C</h2>
<pre><code>/* <br> * POLYLINE.C <br> * <br> * Window procedure for the polyline drawing window and support functions. <br> * This window is not complicated.  On creation it allocates a block of <br> * memory for a POLYLINE structure that contains 20 POINTs.  We do not <br> * attempt to reallocate this array at all just to maintain simplicity. <br> * This sample is to demonstrate OLE, not LocalReAlloc. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include "cosmo.h" <br> <br>/* <br> * HACK:  To fix some Invalid hDC rips, we need to supress certain <br> * operations on metafile DC's: GetMapMode, DPtoLP, LPtoDP. <br> * We use this flag to indicate supression. <br> */ <br>BOOL fMetaDC=FALSE; <br> <br> <br> <br>/* <br> * HPolylineWindowCreate <br> * <br> * Purpose: <br> *  Creates a Polyline window within the client area of hWndParent. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent window. <br> *  hInstance       HINSTANCE of the application instance. <br> * <br> * Return Value: <br> *  HWND            Result of the CreateWindowEx call. <br> * <br> */ <br> <br>HWND WINAPI HPolylineWindowCreate(HWND hWndParent, HINSTANCE hInstance) <br>    { <br>    RECT        rc; <br>    HWND        hWndT; <br> <br>    /* <br>     * Create the secondary window for this application in a <br>     * shrunk client area. <br>     */ <br>    GetClientRect(hWndParent, &amp;rc); <br>    InflateRect(&amp;rc, -8, -8); <br> <br>    //Create the editor window. <br>    hWndT=CreateWindowEx(WS_EX_NOPARENTNOTIFY, rgpsz[IDS_CLASSPOLYLINE] <br>        , rgpsz[IDS_CLASSPOLYLINE], WS_CHILD | WS_VISIBLE, rc.left <br>        , rc.top, rc.right-rc.left, rc.bottom-rc.top <br>        , hWndParent, (HMENU)ID_POLYLINE, hInstance, NULL); <br> <br>    return hWndT; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * PolylineWndProc <br> * <br> * Purpose: <br> *  Window procedure for the polyline drawing window. <br> * <br> * Parameters: <br> *  The standard. <br> * <br> * Return Value: <br> *  Standard. <br> */ <br> <br>LRESULT WINAPI PolylineWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    HWND            hWndParent; <br>    HLOCAL          hMem; <br>    LPPOLYLINE      ppl; <br>    RECT            rc; <br>    DWORD           dwRet=0L; <br> <br>   #ifdef WIN32 <br>    ppl=(LPPOLYLINE)(PSTR)GetWindowLong(hWnd, 0); <br>   #else <br>    ppl=(LPPOLYLINE)(PSTR)GetWindowWord(hWnd, 0); <br>   #endif <br> <br>    if (WM_USER &lt;= iMsg) <br>        return LPolylineUserMessage(hWnd, iMsg, wParam, lParam, ppl); <br> <br> <br>    switch (iMsg) <br>        { <br> <br>        case WM_NCCREATE: <br>            hMem=LocalAlloc(LPTR, CBPOLYLINE); <br> <br>            if (NULL==hMem) <br>                return 0L; <br> <br>           #ifdef WIN32 <br>            SetWindowLong(hWnd, 0, (LONG)hMem); <br>           #else <br>            SetWindowWord(hWnd, 0, (WORD)hMem); <br>           #endif <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_NCDESTROY: <br>           #ifdef WIN32 <br>            hMem=(HLOCAL)GetWindowLong(hWnd, 0); <br>           #else <br>            hMem=(HLOCAL)GetWindowWord(hWnd, 0); <br>           #endif <br>            LocalFree(hMem); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br> <br>        case WM_CREATE: <br>            //Stash away the current window rectangle. <br>            GetClientRect(hWnd, &amp;rc); <br>            RECTTORECTS(rc, ppl-&gt;rc); <br> <br>            ppl-&gt;wVerMaj=VERSIONMAJOR; <br>            ppl-&gt;wVerMin=VERSIONMINOR; <br>            ppl-&gt;cPoints=0; <br>            break; <br> <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br> <br>            if (0!=ppl-&gt;cPoints) <br>                { <br>                ppl-&gt;fDrawEntire=TRUE; <br>                PolylineDraw(hWnd, hDC, ppl); <br>                } <br> <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        case WM_LBUTTONDOWN: <br>            //Stop if we are already at the limit. <br>            if (CPOLYLINEPOINTS==ppl-&gt;cPoints) <br>                { <br>                MessageBeep(0); <br>                break; <br>                } <br> <br>            //Stuff the new point in the array. <br>            ppl-&gt;rgpt[ppl-&gt;cPoints].x=LOWORD(lParam); <br>            ppl-&gt;rgpt[ppl-&gt;cPoints].y=HIWORD(lParam); <br> <br>            ppl-&gt;cPoints++; <br> <br>            //Draw the lines to this new point only. <br>            hDC=GetDC(hWnd); <br> <br>            ppl-&gt;fDrawEntire=FALSE; <br>            PolylineDraw(hWnd, hDC, ppl); <br> <br>            ReleaseDC(hWnd, hDC); <br> <br>            hWndParent=GetParent(hWnd); <br> <br>           #ifdef WIN32 <br>            SendMessage(hWndParent, WM_COMMAND <br>                , MAKELONG(ID_POLYLINE, PLN_POINTCHANGE), (LPARAM)hWnd); <br>           #else <br>            SendMessage(hWndParent, WM_COMMAND <br>                , ID_POLYLINE, MAKELONG(hWnd, PLN_POINTCHANGE)); <br>           #endif <br>            break; <br> <br> <br>        default: <br>            dwRet=DefWindowProc(hWnd, iMsg, wParam, lParam); <br>            break; <br>        } <br> <br>    return dwRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * LPolylineUserMessage <br> * <br> * Purpose: <br> *  Handles all window-specific messages WM_USER and greater, <br> *  for the Polyline window: <br> * <br> *  PLM_RECTSET:        Changes the size of the window and scales the <br> *                      data points. <br> * <br> *  PLM_POLYLINESET:    Sets the current data points and the rectangle <br> *                      used to generate the figure. <br> * <br> *  PLM_POLYLINEGET:    Retrieves the current data points and rectangle <br> *                      used to generate the figure. <br> * <br> *  PLM_POLYLINENEW:    Resets the data points to defaults, meaning <br> *                      a blank figure. <br> * <br> *  PLM_BACKUPUNDO:     Backs the figure up one point. <br> * <br> *  PLM_BITMAPGET:      Retrieves a bitmap (DDB) of the current image. <br> * <br> *  PLM_METAFILEGET:    Retrieves a metafile for the current image. <br> * <br> *  PLM_METAFILEPICTGET:Retrieves a METAFILEPICT structure of the image for <br> *                      use in clipboard I/O. <br> * <br> * Parameters: <br> *  hWnd            HWND of the Polyline window. <br> *  iMsg            UINT message to process. <br> *  wParam          WPARAM parameter of the message. <br> *  lParam          LPARAM pameter of the message. <br> *  ppl             LPPOLYLINE to the window's extra data structure. <br> * <br> * Return Value: <br> *  DWORD           Value to return from the window procedure <br> *                  that recieved the message. <br> */ <br> <br>DWORD PASCAL LPolylineUserMessage(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LPPOLYLINE ppl) <br>    { <br>    DWORD           dwRet=0L; <br>    HWND            hWndParent; <br>    HBITMAP         hBmp, hBmpT; <br>    HDC             hDC, hMemDC; <br>    LPPOLYLINE      pplT; <br>    LPMETAFILEPICT  pMF; <br>    HGLOBAL         hMem; <br>    HMETAFILE       hMF; <br>    RECT            rc; <br>    LPRECT          pRect; <br>    UINT            i; <br>    LONG            l, cx, cy, cxT, cyT; <br> <br>    hWndParent=GetParent(hWnd); <br> <br>    switch (iMsg) <br>        { <br>        case PLM_RECTSET: <br>            /* <br>             * Resize the window to the given size, letting WM_SIZE handlers <br>             * take care of the rest. <br>             */ <br>            pRect=(LPRECT)lParam; <br> <br>            /* <br>             * Scale all the current points to new dimensions.  ppl-&gt;rc <br>             * has the old dimensions, pRect points to the new.  We <br>             * force each of cx and cy to 1 if they are zero to prevent <br>             * exceptions. <br>             */ <br> <br>            RECTSTORECT(ppl-&gt;rc, rc); <br>            cxT=rc.right  - rc.left; <br>            cyT=rc.bottom - rc.top; <br> <br>            RECTTORECTS(ppl-&gt;rc, *pRect); <br>            cx=pRect-&gt;right  - pRect-&gt;left; <br>            cy=pRect-&gt;bottom - pRect-&gt;top; <br> <br>            //Prevent crashes <br>            if (0L==cxT) <br>                cxT=1; <br> <br>            if (0L==cyT) <br>                cyT=1; <br> <br>            //Loop through each point, scaling if necessary. <br>            for (i=0; i&lt; ppl-&gt;cPoints; i++) <br>                { <br>                //Must use DWORD to insure proper scaling. <br>                if (cx!=cxT) <br>                    { <br>                    l=((LONG)ppl-&gt;rgpt[i].x*cx); <br>                    ppl-&gt;rgpt[i].x=(short)(l/cxT); <br>                    } <br> <br>                if (cy!=cyT) <br>                    { <br>                    l=((LONG)ppl-&gt;rgpt[i].y*cy); <br>                    ppl-&gt;rgpt[i].y=(short)(l/cyT); <br>                    } <br>                } <br> <br> <br>            SetWindowPos(hWnd, NULL, pRect-&gt;left, pRect-&gt;top, (int)cx <br>                , (int)cy, SWP_NOMOVE | SWP_NOZORDER); <br> <br> <br>            //Check if we need to notify the parent. <br>            if (0!=wParam) <br>                { <br>               #ifdef WIN32 <br>                SendMessage(hWndParent, WM_COMMAND <br>                    , MAKELONG(ID_POLYLINE, PLN_SIZECHANGE), (LPARAM)hWnd); <br>               #else <br>                SendMessage(hWndParent, WM_COMMAND <br>                    , ID_POLYLINE, MAKELONG(hWnd, PLN_SIZECHANGE)); <br>               #endif <br>                } <br> <br>            //Insure repaint <br>            InvalidateRect(hWnd, NULL, TRUE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case PLM_POLYLINESET: <br>            /* <br>             * Copy the structure in lParam to ppl and repaint to <br>             * reflect the new point set.  Note that unlike the <br>             * PLM_RECTSET message, we do no scaling, assuming that <br>             * the rectangle in the POLYLINE structure is appropriate <br>             * for the data. <br>             */ <br>            pplT=(LPPOLYLINE)lParam; <br>            *ppl=*pplT; <br> <br>            //Resize this window to fit the data and notify the parent. <br>            SetWindowPos(hWnd, NULL, ppl-&gt;rc.left, ppl-&gt;rc.top <br>                , ppl-&gt;rc.right-ppl-&gt;rc.left, ppl-&gt;rc.bottom-ppl-&gt;rc.top <br>                , SWP_NOMOVE | SWP_NOZORDER); <br> <br>            if (0!=wParam) <br>                { <br>               #ifdef WIN32 <br>                SendMessage(hWndParent, WM_COMMAND <br>                    , MAKELONG(ID_POLYLINE, PLN_SIZECHANGE), (LPARAM)hWnd); <br>               #else <br>                SendMessage(hWndParent, WM_COMMAND <br>                    , ID_POLYLINE, MAKELONG(hWnd, PLN_SIZECHANGE)); <br>               #endif <br>                } <br> <br>            //Insure a repaint. <br>            InvalidateRect(hWnd, NULL, TRUE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case PLM_POLYLINEGET: <br>            //Copy the structure in ppl to lParam.  No repaint needed. <br>            pplT=(LPPOLYLINE)lParam; <br>            *pplT=*ppl; <br>            break; <br> <br> <br>        case PLM_POLYLINENEW: <br>            //Clean out the POLYLINE structure and repaint the window. <br>            for (i=0; i&lt; CPOLYLINEPOINTS; i++) <br>                { <br>                ppl-&gt;rgpt[i].x=0; <br>                ppl-&gt;rgpt[i].y=0; <br>                } <br> <br>            ppl-&gt;cPoints=0; <br> <br>            InvalidateRect(hWnd, NULL, TRUE); <br>            UpdateWindow(hWnd); <br>            break; <br> <br> <br>        case PLM_BACKUPUNDO: <br>            //Decrement the number of active points and repaint. <br>            if (ppl-&gt;cPoints &gt; 0) <br>                { <br>                ppl-&gt;cPoints--; <br>                InvalidateRect(hWnd, NULL, TRUE); <br>                UpdateWindow(hWnd); <br>                } <br> <br>            //Notify parent window of the change. <br>           #ifdef WIN32 <br>            SendMessage(hWndParent, WM_COMMAND <br>                , MAKELONG(ID_POLYLINE, PLN_POINTCHANGE), (LPARAM)hWnd); <br>           #else <br>            SendMessage(hWndParent, WM_COMMAND <br>                , ID_POLYLINE, MAKELONG(hWnd, PLN_POINTCHANGE)); <br>           #endif <br>            break; <br> <br> <br>        case PLM_BITMAPGET: <br>            /* <br>             * Create and return a bitmap of the window contents. <br>             * The bitmap is the size of the POLYLINE edit window. <br>             */ <br> <br>            hDC=GetDC(hWnd); <br>            hMemDC=CreateCompatibleDC(hDC); <br> <br>            GetClientRect(hWnd, &amp;rc); <br>            hBmp=CreateCompatibleBitmap(hDC, rc.right, rc.bottom); <br> <br>            if (NULL!=hBmp) <br>                { <br>                //Draw the POLYLINE into the bitmap. <br>                hBmpT=SelectObject(hMemDC, hBmp); <br> <br>                ppl-&gt;fDrawEntire=TRUE; <br>                PolylineDraw(hWnd, hMemDC, ppl); <br>                ppl-&gt;fDrawEntire=FALSE; <br> <br>                SelectObject(hMemDC, hBmpT); <br>                } <br> <br>            DeleteDC(hMemDC); <br>            ReleaseDC(hWnd, hDC); <br> <br>            //Return the created bitmap handle. <br>            dwRet=(DWORD)(UINT)hBmp; <br>            break; <br> <br> <br>        case PLM_METAFILEGET: <br>            //Create a memory metafile and return its handle. <br>            hDC=(HDC)CreateMetaFile(NULL); <br>            hMF=NULL; <br> <br>            if (NULL!=hDC) <br>                { <br>                /* <br>                 * This is absolutely essential to the metafile so it <br>                 * can be scaled in the clipboard and any destination <br>                 * application. <br>                 */ <br>                fMetaDC=TRUE; <br>                SetMapMode(hDC, MM_ANISOTROPIC); <br>                GetClientRect(hWnd, &amp;rc); <br>                SetWindowOrgEx(hDC, 0, 0, NULL); <br>                SetWindowExtEx(hDC, rc.right, rc.bottom, NULL); <br> <br>                ppl-&gt;fDrawEntire=TRUE; <br>                PolylineDraw(hWnd, hDC, ppl); <br>                ppl-&gt;fDrawEntire=FALSE; <br> <br>                hMF=CloseMetaFile(hDC); <br>                fMetaDC=FALSE; <br>                } <br> <br>            dwRet=(DWORD)(UINT)hMF; <br>            break; <br> <br> <br>        case PLM_METAFILEPICTGET: <br>            /* <br>             * Create a METAFILEPICT structure for the clipboard. <br>             * First attempt to get a metafile. <br>             */ <br>            lParam=SendMessage(hWnd, PLM_METAFILEGET, 0, 0L); <br>            hMF=(HMETAFILE)(UINT)lParam; <br> <br>            if (NULL==hMF) <br>                break; <br> <br>            //Allocate the METAFILEPICT structure. <br>            hMem=GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE <br>                , sizeof(METAFILEPICT)); <br> <br>            if (NULL==hMem) <br>                { <br>                DeleteMetaFile(hMF); <br>                break; <br>                } <br> <br>            /* <br>             * Global lock only fails in PMODE if the selector is invalid <br>             * (like it was discarded) or references a 0 length segment, <br>             * neither of which can happen here. <br>             */ <br>            pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>            pMF-&gt;hMF=hMF; <br>            pMF-&gt;mm=MM_ANISOTROPIC;             //Required by OLE libraries. <br> <br>            //Insert the extents in MM_HIMETRIC units. <br>            GetClientRect(hWnd, &amp;rc); <br> <br>            RectConvertToHiMetric(hWnd, &amp;rc);     //Found in CLIP.C <br>            pMF-&gt;xExt=rc.right; <br>            pMF-&gt;yExt=rc.bottom; <br> <br>            GlobalUnlock(hMem); <br> <br>            dwRet=(DWORD)(UINT)hMem; <br>            break; <br> <br> <br>        default: <br>            break; <br>        } <br> <br>    return dwRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * PolylineDraw <br> * <br> * Purpose: <br> *  Paints the current line in the polyline window. <br> * <br> * Parameters: <br> *  hWnd            HWND of the polyline window. <br> *  hDC             HDC to draw on, could be a metafile or printer DC. <br> *  ppl            LPPOLYLINE to the polyline structure. <br> * <br> * Return Value: <br> *  none <br> */ <br> <br>void PASCAL PolylineDraw(HWND hWnd, HDC hDC, LPPOLYLINE ppl) <br>    { <br> <br>    HBRUSH          hBrush, hBrushT; <br>    HPEN            hPen, hPenT; <br>    UINT            i, j; <br>    UINT            nMM; <br>    POINTS          pt; <br>    POINT           rgpt[CPOLYLINEPOINTS]; <br>    RECT            rc; <br>    COLORREF        cr; <br> <br> <br>    GetClientRect(hWnd, &amp;rc); <br> <br>    //Get the line color. <br>    cr=GetSysColor(COLOR_WINDOWTEXT); <br> <br>    //Make a 32-bit working copy of the point array for DPtoLP. <br>    for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>        { <br>        rgpt[i].x=ppl-&gt;rgpt[i].x; <br>        rgpt[i].y=ppl-&gt;rgpt[i].y; <br>        } <br> <br>    /* <br>     * If the mapping mode is not MM_TEXT, convert the points to <br>     * whatever mapping mode in in effect before drawing. <br>     * This specifically supports metafiles in MM_ANISOTROPIC. <br>     */ <br>    nMM=fMetaDC ? MM_TEXT : GetMapMode(hDC); <br> <br>    if (MM_TEXT!=nMM) <br>        DPtoLP(hDC, rgpt, ppl-&gt;cPoints); <br> <br>    hPen=CreatePen(PS_SOLID, 1, cr); <br>    hPenT=SelectObject(hDC, hPen); <br> <br>    hBrush=CreateSolidBrush(GetSysColor(COLOR_WINDOW)); <br>    hBrushT=SelectObject(hDC, hBrush); <br> <br>    /* <br>     * Either draw the entire figure or just a single point.  The <br>     * entire figure also includes erasing the background completely, <br>     * since hDC may be a metafile DC.  Drawing a single point just <br>     * updates the figure for that new point. <br>     */ <br>    if (ppl-&gt;fDrawEntire) <br>        { <br>        //Erase the background for bitmaps and metafiles. <br>        SelectObject(hDC, GetStockObject(NULL_PEN)); <br>        Rectangle(hDC, rc.left, rc.top, rc.right+1, rc.bottom+1); <br>        SelectObject(hDC, hPen); <br> <br> <br>        /* <br>         * If we are drawing the entire figure, then loop through each <br>         * point drawing a line to each successive point. <br>         */ <br> <br>        for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>            { <br>            for (j=i; j &lt; ppl-&gt;cPoints; j++) <br>                { <br>                MoveToEx(hDC, rgpt[i].x, rgpt[i].y, NULL); <br>                LineTo(hDC, rgpt[j].x, rgpt[j].y); <br>                } <br>            } <br>        } <br>    else <br>        { <br>        /* <br>         * If we are only drawing the last point, just cycle once <br>         * through previous points. <br>         */ <br> <br>        //Get the last point entered in the array. <br>        j=ppl-&gt;cPoints-1; <br>        pt.x=(short)rgpt[j].x; <br>        pt.y=(short)rgpt[j].y; <br> <br>        for (i=0; i &lt; j; i++) <br>            { <br>            MoveToEx(hDC, pt.x, pt.y, NULL); <br>            LineTo(hDC, rgpt[i].x, rgpt[i].y); <br>            } <br>        } <br> <br>    //If we only had one point, draw a dot to indicate it's position. <br>    if (1==ppl-&gt;cPoints) <br>        SetPixel(hDC, rgpt[0].x, rgpt[0].y, cr); <br> <br> <br>    SelectObject(hDC, hPenT); <br>    SelectObject(hDC, hBrushT); <br>    DeleteObject(hBrush); <br>    DeleteObject(hPen); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
