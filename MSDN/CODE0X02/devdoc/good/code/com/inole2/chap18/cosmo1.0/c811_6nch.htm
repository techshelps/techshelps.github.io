<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEDOC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context821"></a>OLEDOC.C</h2>
<pre><code>/* <br> * OLEDOC.C <br> * <br> * Contains all callback functions in the OLESERVERDOCVTBL struture: <br> *      DocClose <br> *      DocGetObject <br> *      DocExecute <br> *      DocRelease <br> *      DocSave <br> *      DocSetColorScheme <br> *      DocSetDocDimensions <br> *      DocSetHostNames <br> * <br> * Also contains two helper functions, PDocumentAllocate and DocumentClean. <br> * PDocumentAllocate acts like a C++ constructor. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br>#ifdef MAKEOLESERVER <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br> <br> <br>/* <br> * PDocumentAllocate <br> * <br> * Purpose: <br> *  Allocates a COSMODOC structure and sets the defaults in its fields. <br> *  Used from application initialization and various server methods that <br> *  create a document. <br> * <br> * Parameters: <br> *  pVtblDoc        LPOLESERVERDOCVTBL used to initialize the pvtbl field. <br> * <br> * Return Value: <br> *  LPCOSMODOC      Pointer to the allocated structure in local memory. <br> *                  The hMem field will contain a handle to the structure <br> *                  to pass to LocalFree. <br> * <br> */ <br> <br>LPCOSMODOC WINAPI PDocumentAllocate(LPOLESERVERDOCVTBL pVtblDoc) <br>    { <br>    HLOCAL      hMem; <br>    LPCOSMODOC  pDoc; <br> <br>    hMem=LocalAlloc(LPTR, CBCOSMODOC); <br> <br>    if (NULL==hMem) <br>        return NULL; <br> <br>    pDoc=(LPCOSMODOC)(PSTR)hMem; <br> <br>    pDoc-&gt;hMem=hMem; <br>    pDoc-&gt;fRelease=TRUE; <br>    pDoc-&gt;pvtbl=pVtblDoc; <br> <br>    return pDoc; <br>    } <br> <br> <br> <br> <br>/* <br> * DocClose <br> * <br> * Purpose: <br> *  Instructs the server to unconditionally close the document.  OLESVR <br> *  calls DocClose when the client initiates a shutdown.  OLESVR always <br> *  calls this function before calling ServerRelease. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocClose(LPCOSMODOC pDoc) <br>    { <br>    OLESTATUS       os; <br> <br>    /* <br>     * Take no action to notify user--Client will take care of that. <br>     * <br>     * 1.   Call OleRevokeServerDoc; resources are freed when OLESVR <br>     *      calls DocRelease. <br>     * 2.   Return the return value of OleRevokeServerDoc, which will <br>     *      generally be OLE_OK. <br>     */ <br> <br>    os=OleRevokeServerDoc(pDoc-&gt;lh); <br>    return os; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * DocGetObject <br> * <br> * Purpose: <br> *  Requests the server application to create an OLEOBJECT structure. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> *  pszItem         OLE_LPCSTR specifying the name of the item in a document <br> *                  for which the object is to be created.  If NULL, then <br> *                  the entire document is requested.  This could be a <br> *                  range of spreadsheet cells like "R1:C3-R10:C50" <br> *  ppObj           LPLPOLEOBJECT at which to store a pointer to the <br> *                  OLEOBJECT structure. <br> *  pClient         LPOLECLIENT that should be associated with <br> *                  the object in order to notify OLECLI when the object <br> *                  changes. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocGetObject(LPCOSMODOC pDoc, OLE_LPCSTR pszItem <br>    , LPLPOLEOBJECT ppObj, LPOLECLIENT pClient) <br>    { <br>    LPCOSMOOBJECT   pObj; <br> <br>    /* <br>     * 1.   Allocate and initialize an OLEOBJECT structure. <br>     * 2.   Store pClient in the object's OLEOBJECT structure for use <br>     *      in sending notifications to the client. <br>     * 3.   Store a pointer to the new OLEOBJECT structure in ppObj. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_NAME if pszObj is <br>     *      not recognized, or OLE_ERROR_MEMORY if the object could not <br>     *      be allocated. <br>     * <br>     * This function is called in response to a client calling <br>     * OleGetObject. <br>     */ <br> <br>    //Allocate one from local FIXED memory. <br>    pObj=PObjectAllocate(&amp;pOLE-&gt;vtblObj); <br> <br>    if (NULL==pObj) <br>        return OLE_ERROR_MEMORY; <br> <br>    //Remember who we created for freeing in DocRelease. <br>    pDoc-&gt;pObj=pObj; <br> <br>    //Must save this for sending notifications. <br>    pObj-&gt;pClient=pClient; <br> <br>    //Pass back the pointer to this object. <br>    *ppObj=(LPOLEOBJECT)pObj; <br>    return OLE_OK; <br>    } <br> <br> <br> <br>/* <br> * DocExecute <br> * <br> * Purpose: <br> *  Passes DDE Execute strings related to the document to the server <br> *  application. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> *  hCommands       HGLOBAL to memory containing DDE execute strings. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocExecute(LPCOSMODOC pDoc, HGLOBAL hCommands) <br>    { <br>    /* <br>     * 1.   Lock the hCommands handle to access the execute strings. <br>     * 2.   Parse and execute the commands as necessary. <br>     * 3.   DO NOT FREE hCommands. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_COMMAND otherwise. <br>     */ <br> <br>    return OLE_ERROR_COMMAND; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DocRelease <br> * <br> * Purpose: <br> *  Notifies the server when a revoked document may be destroyed. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocRelease(LPCOSMODOC pDoc) <br>    { <br>    /* <br>     * 1.   Free any resources allocated for this document, but <br>     *      DO NOT free the OLESERVERDOC structure itself.  This could <br>     *      include freeing objects, however. <br>     * 2.   Set a flag to indicate that Release has been called. <br>     * 3.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     */ <br> <br>    if (0!=pDoc-&gt;aObject) <br>        { <br>        DeleteAtom(pDoc-&gt;aObject); <br>        pDoc-&gt;aObject=0; <br>        } <br> <br>    if (0!=pDoc-&gt;aClient) <br>        { <br>        DeleteAtom(pDoc-&gt;aClient); <br>        pDoc-&gt;aClient=0; <br>        } <br> <br> <br>    //Release any object stored in this document. <br>    if (0!=pDoc-&gt;pObj) <br>        { <br>        if (NULL!=pDoc-&gt;pObj-&gt;hMem) <br>            LocalFree(pDoc-&gt;pObj-&gt;hMem); <br>        } <br> <br>    pDoc-&gt;pObj=NULL; <br> <br>    pDoc-&gt;fRelease=TRUE; <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DocSave <br> * <br> * Purpose: <br> *  Instructs the server application to save the document.  If DocSave is <br> *  called you are assumed to have a know filename to which you can save <br> *  since this method is only used in linking. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocSave(LPCOSMODOC pDoc) <br>    { <br>    /* <br>     * 1.   Save the document to the known filename.  How you save <br>     *      documents is application-specific. <br>     * 2.   Return OLE_OK if the save is successful, OLE_ERROR_GENERIC <br>     *      otherwise. <br>     */ <br> <br>    SendMessage(pGlob-&gt;hWnd, WM_COMMAND, IDM_FILESAVE, 0L); <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DocSetColorScheme <br> * <br> * Purpose: <br> *  Provides a color scheme that the client application recommends for <br> *  rendering graphical data. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> *  pPal            LPLOGPALETTE describing the recommended palette. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocSetColorScheme(LPCOSMODOC pDoc <br>    , OLE_CONST LOGPALETTE FAR *pPal) <br>    { <br>    /* <br>     * Servers are not required to use this palette.  The LPLOGPALETTE <br>     * only is a convenient structure to contain the color scheme; IT DOES <br>     * not REPRESENT A PALETTE IN STRICT TERMS!  Do NOT call CreatePalette <br>     * and try to realize it. <br>     * <br>     * The color scheme contained in the LOGPALETTE structure contains <br>     * a number of colors where the first color is the suggested foreground, <br>     * the second the suggested background, then the first HALF of those <br>     * remaining are suggested fill colors and the last half suggested <br>     * line colors.  If there are an odd number of colors, give the extra <br>     * color to the fill colors, that is, there is one less line color than <br>     * fill colors. <br>     */ <br> <br>    return OLE_ERROR_PALETTE; <br>    } <br> <br> <br> <br>/* <br> * DocSetDocDimensions <br> * <br> * Purpose: <br> *  Specifies the rectangle on the target device for which EMBEDDED <br> *  objects should be formatted. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> *  pRect           LPRECT to the device rectangle in MM_HIMETRIC units. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocSetDocDimensions(LPCOSMODOC pDoc <br>    , OLE_CONST RECT FAR *pRect) <br>    { <br>    /* <br>     * OLESVR will call this method when the client has resized the <br>     * object. <br>     * <br>     * In this case we try to make the parent window the correct size <br>     * to just contain the object. <br>     */ <br> <br>    //First, convert the rectangle to units we can deal with MM_TEXT. <br>    RectConvertToDevice(pGlob-&gt;hWnd, (LPRECT)pRect); <br> <br>    /* <br>     * Tell the Polyline document to use this rectangle, also notifying <br>     * the parent which will then resize itself. <br>     */ <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_RECTSET, TRUE, (LONG)pRect); <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DocSetHostNames <br> * <br> * Purpose: <br> *  Set names that should be used for window titles, only for <br> *  embedded objects; linked objects have their own titles as they <br> *  are loaded through the server application's usual file loading <br> *  mechanism. <br> * <br> * Parameters: <br> *  pDoc            LPCOSMODOC identifying the document affected. <br> *  pszClient       OLE_LPCSTR to the name of the client application. <br> *  pszObj          OLE_LPCSTR to the name of the embedded object. <br> * <br> * Return Value: <br> *  OLESTATUS       OLE_OK if all is well, otherwise an OLE_* error value. <br> */ <br> <br>OLESTATUS WINAPI DocSetHostNames(LPCOSMODOC pDoc, OLE_LPCSTR pszClient <br>    , OLE_LPCSTR pszObj) <br>    { <br>    char        szTemp[256]; <br> <br>    /* <br>     * 1.   Change the title bar to reflect the embedded state with the <br>     *      appropriate names. <br>     * 2.   Change the File menu to reflect the embedded state and the name <br>     *      of the client application. <br>     * 3.   Store the object and client names in teh OLESERVERDOC structure. <br>     *      These will be needed later for message boxes where the name of <br>     *      the client application must be displayed. <br>     * 4.   Return OLE_OK if successful, OLE_ERROR_GENERIC otherwise. <br>     */ <br> <br>    wsprintf(szTemp, "%s in %s", pszObj, pszClient); <br>    WindowTitleSet(pGlob-&gt;hWnd, szTemp); <br>    MenuEmbeddingSet(pGlob-&gt;hWnd, (LPSTR)pszClient, TRUE); <br> <br>    if (0!=pDoc-&gt;aObject) <br>        DeleteAtom(pDoc-&gt;aObject); <br> <br>    pDoc-&gt;aObject=AddAtom(pszObj); <br> <br>    if (0!=pDoc-&gt;aClient) <br>        DeleteAtom(pDoc-&gt;aClient); <br> <br>    pDoc-&gt;aClient=AddAtom(pszClient); <br> <br>    return OLE_OK; <br>    } <br> <br> <br> <br> <br> <br>#endif //MAKEOLESERVER </code></pre>
<p>&nbsp;</p></body>
</HTML>
