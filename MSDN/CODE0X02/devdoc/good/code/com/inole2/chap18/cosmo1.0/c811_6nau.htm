<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FILE.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context816"></a>FILE.C</h2>
<pre><code>/* <br> * FILE.C <br> * <br> * Functions for handling dirty files and processing File menu commands. <br> * <br> * Functions: <br> *  FDirtySet, FCleanVerify <br> *  FFileNew, FFileOpen, FFileSave, FFileSaveAs, FFileExit <br> * <br> * This file contains the only functions that manipulate the fDirty flag. <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleglobl.h" <br> <br> <br> <br> <br> <br>/* <br> * FDirtySet <br> * <br> * Purpose: <br> *  Sets or clears the global 'dirty' flag returning the previous state <br> *  of that same flag.  Even though the non-OLE part of this function <br> *  is trivial, it isolates handling changes, providing a single point <br> *  to notify a client app with OLE_CHANGED. <br> * <br> *  This function does exits if pGlob-&gt;fNoDirty is set. <br> * <br> * Parameters: <br> *  fDirty          BOOL used to set the value of the pGLob-&gt;fDirty flag. <br> *                  This allows us to use this function to both set and <br> *                  clear the flag.  OLE_CHANGED is only sent if the <br> *                  flag is set to TRUE. <br> * <br> * Return Value: <br> *  BOOL            Previous value of the dirty flag. <br> */ <br> <br>BOOL WINAPI FDirtySet(BOOL fDirty) <br>    { <br>    BOOL        fPrevious; <br> <br>#ifdef MAKEOLESERVER <br>    /* <br>     * If we are a hidden window, then there's nothing that could make <br>     * us dirty since there cannot be any user interaction here.  Therefore <br>     * ignore any changes to the dirty flag, leaving it FALSE. <br>     */ <br>    if (!IsWindowVisible(pGlob-&gt;hWnd)) <br>        return pGlob-&gt;fDirty; <br> <br>#endif //MAKEOLESERVER <br> <br>    if (pGlob-&gt;fNoDirty) <br>        return pGlob-&gt;fDirty; <br> <br>    fPrevious=pGlob-&gt;fDirty; <br>    pGlob-&gt;fDirty=fDirty; <br> <br>#ifdef MAKEOLESERVER <br>    if (fDirty) <br>        //Fun indirection, huh?  That what you get with an OOP. <br>        OLEClientNotify(pOLE-&gt;pSvr-&gt;pDoc-&gt;pObj, OLE_CHANGED); <br>#endif //MAKEOLESERVER <br> <br>    return fPrevious; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FCleanVerify <br> * <br> * Purpose: <br> *  Checks the pGLob-&gt;fDirty flag, and if set, displays a message <br> *  box informing the user that the file is dirty and asking if <br> *  the file should be saved or updated.  If YES is chosen, the file <br> *  is saved or updated. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if it's safe to proceed with the operation (file <br> *                  is clean, user answered NO, or file was saved). <br> *                  FALSE if the user wants to cancel the operation or there <br> *                  was an error. <br> */ <br> <br>BOOL WINAPI FCleanVerify(LPGLOBALS pGlob) <br>    { <br>    BOOL        fRet=TRUE; <br>    UINT        uRet; <br>    char       *psz; <br> <br>#ifdef MAKEOLESERVER <br>    char        szClient[40]; <br>#endif //MAKEOLESERVER <br> <br>    //Nothing to do if we're clean. <br>    if (!pGlob-&gt;fDirty) <br>        return TRUE; <br> <br>    if (!pGlob-&gt;fOLE) <br>        { <br>        uRet=MessageBox(pGlob-&gt;hWnd, rgpsz[IDS_FILEDIRTY] <br>            , rgpsz[IDS_CAPTION], MB_YESNOCANCEL | MB_ICONEXCLAMATION); <br>        } <br>#ifdef MAKEOLESERVER <br>    if (pGlob-&gt;fOLE) <br>        { <br>        //Linking case, use the same message as before. <br>        if (pOLE-&gt;pSvr-&gt;fLink) <br>            { <br>            uRet=MessageBox(pGlob-&gt;hWnd, rgpsz[IDS_FILEDIRTY], <br>                            rgpsz[IDS_CAPTION], MB_YESNOCANCEL); <br>            } <br> <br>        //Embedding: Ask the user about updating instead of saving. <br>        if (pOLE-&gt;pSvr-&gt;fEmbed) <br>            { <br>            //Build the standard string for Updating. <br>            psz=(PSTR)LocalAlloc(LPTR, 1024); <br> <br>            if (NULL==psz) <br>                return FALSE; <br> <br>            GetAtomName(pOLE-&gt;pSvr-&gt;pDoc-&gt;aClient, szClient, sizeof(szClient)); <br> <br>            lstrcpy(psz, rgpsz[IDS_CLOSEALERT1]); <br>            lstrcat(psz, szClient); <br>            lstrcat(psz, rgpsz[IDS_CLOSEALERT2]); <br> <br>            uRet=MessageBox(pGlob-&gt;hWnd, psz, rgpsz[IDS_CAPTION], <br>                            MB_YESNOCANCEL | MB_ICONEXCLAMATION); <br> <br>            LocalFree((HLOCAL)psz); <br>            } <br>        } <br>#endif //MAKEOLESERVER <br> <br>    switch (uRet) <br>        { <br>        case IDCANCEL: <br>            fRet=FALSE; <br>            break; <br> <br>        case IDNO: <br>            fRet=TRUE; <br>            break; <br> <br>        case IDYES: <br>            if (!pGlob-&gt;fOLE) <br>                fRet=FFileSave(pGlob); <br> <br>#ifdef MAKEOLESERVER <br>            //Linking same as stand-alone. <br>            if (pOLE-&gt;pSvr-&gt;fLink) <br>                fRet=FFileSave(pGlob); <br> <br>            if (pOLE-&gt;pSvr-&gt;fEmbed) <br>                OLEClientNotify(pOLE-&gt;pSvr-&gt;pDoc-&gt;pObj, OLE_CLOSED); <br> <br>#endif //MAKEOLESERVER <br>            break; <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FFileNew <br> * <br> * Purpose: <br> *  Confirms the new file with the user and cleans out the Polyline <br> *  image. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> * <br> */ <br> <br>BOOL WINAPI FFileNew(LPGLOBALS pGlob) <br>    { <br>    if (!FCleanVerify(pGlob)) <br>        return FALSE; <br> <br>#ifdef MAKEOLESERVER <br>    PDocRevokeAndCreate(pOLE); <br>#endif //MAKEOLESERVER <br> <br>    pGlob-&gt;fOLE=FALSE; <br> <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINENEW, 0, 0L); <br>    pGlob-&gt;fDirty=FALSE; <br>    pGlob-&gt;fOpenFile=FALSE; <br> <br>    WindowTitleSet(pGlob-&gt;hWnd, rgpsz[IDS_UNTITLED]); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * FFileOpen <br> * <br> * Purpose: <br> *  Confirms that the user wants to open a new file and invokes the <br> *  common dialog file open to get the filename, then reads the <br> *  contents of the file.  If the fImport flag is TRUE, then we <br> *  import the contents of the file into the current document, <br> *  not changing the document name or any of the UI. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variable block. <br> *  fImport         BOOL indicates if we're importing from a file, <br> *                  not affecting the current filename. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> * <br> */ <br> <br>BOOL WINAPI FFileOpen(LPGLOBALS pGlob, BOOL fImport) <br>    { <br>    POLYLINE        pl; <br>    BOOL            fOK; <br>    LPSTR           psz; <br>    char            szTemp[CCHPATHMAX]; <br>    LPSTR           pszFile; <br> <br>    if (!fImport) <br>        { <br>        if (!FCleanVerify(pGlob)) <br>            return FALSE; <br>        } <br> <br>    psz=(fImport) ? rgpsz[IDS_FILEIMPORT] : rgpsz[IDS_FILEOPEN]; <br> <br>    //We have to use a temp for Import or else we'll wipe out a real filename. <br>    pszFile=(fImport) ? (LPSTR)szTemp : (LPSTR)pGlob-&gt;szFile; <br> <br>    fOK=FSaveOpenDialog(pGlob-&gt;hWnd, pGlob-&gt;hInst, rgpsz[IDS_DEFEXT] <br>        , rgpsz[IDS_FILEOPENFILTER], pszFile, psz, TRUE); <br> <br> <br>    if (fOK) <br>        { <br>        //Attempt to read the file in and display it. <br>        if (!FCosFileRead(pGlob, pszFile, &amp;pl)) <br>            return FALSE; <br> <br>#ifdef MAKEOLESERVER <br>        if (!fImport) <br>            PDocRevokeAndCreate(pOLE); <br>#endif //MAKEOLESERVER <br> <br>        SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINESET, <br>                    TRUE, (LONG)(LPSTR)&amp;pl); <br> <br>        if (!fImport) <br>            { <br>            WindowTitleSet(pGlob-&gt;hWnd, pszFile); <br>            pGlob-&gt;fOLE=FALSE; <br> <br>            pGlob-&gt;fOpenFile=TRUE; <br>            pGlob-&gt;fDirty=FALSE; <br>            } <br>        else <br>            pGlob-&gt;fDirty=TRUE; <br>        } <br> <br>    return fOK; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FFileSave <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user has <br> *  previously used FileOpen or FileSaveAs in order to have a filename. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> * <br> */ <br> <br>BOOL WINAPI FFileSave(LPGLOBALS pGlob) <br>    { <br>    POLYLINE        pl; <br> <br>#ifdef MAKEOLESERVER <br>    OLESTATUS       os; <br> <br>    //In OLE cases, this may be Update; call OleSavedServerDoc <br>    if (pGlob-&gt;fOLE) <br>        { <br>        if (pOLE-&gt;pSvr-&gt;fLink) <br>            { <br>            SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINEGET, 0, <br>                        (LONG)(LPSTR)&amp;pl); <br> <br>            if (!FCosFileWrite(pGlob, pGlob-&gt;szFile, &amp;pl)) <br>                return FALSE; <br>            } <br> <br>        //This notifies the client for us. <br>        os=OleSavedServerDoc(pOLE-&gt;pSvr-&gt;pDoc-&gt;lh); <br> <br>        pGlob-&gt;fDirty=(BOOL)(OLE_OK!=os); <br>        return !pGlob-&gt;fDirty; <br>        } <br> <br>#endif //MAKEOLESERVER <br> <br>    if (!pGlob-&gt;fOpenFile) <br>        return FFileSaveAs(pGlob); <br> <br>    SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINEGET, 0, (LONG)(LPSTR)&amp;pl); <br> <br>    if (!FCosFileWrite(pGlob, pGlob-&gt;szFile, &amp;pl)) <br>        return FALSE; <br> <br>    pGlob-&gt;fOpenFile=TRUE; <br>    pGlob-&gt;fDirty=FALSE; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * FFileSaveAs <br> * <br> * Purpose: <br> *  Invokes the common dialog for Save As to get a filename then <br> *  writes the polyline data to that file, creating if necessary. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> * <br> */ <br> <br>BOOL WINAPI FFileSaveAs(LPGLOBALS pGlob) <br>    { <br>    POLYLINE        pl; <br>    BOOL            fOK; <br> <br>    fOK=FSaveOpenDialog(pGlob-&gt;hWnd, pGlob-&gt;hInst, rgpsz[IDS_DEFEXT] <br>        , rgpsz[IDS_FILEOPENFILTER], pGlob-&gt;szFile, rgpsz[IDS_FILESAVEAS] <br>        , FALSE); <br> <br>    if (fOK) <br>        { <br>        SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINEGET <br>            , 0, (LONG)(LPSTR)&amp;pl); <br> <br>        fOK=FCosFileWrite(pGlob, pGlob-&gt;szFile, &amp;pl); <br> <br>#ifdef MAKEOLESERVER <br>        /* <br>         * In the Save Copy As case, when an object is embedded, we <br>         * don't need to call Rename or Saved since we just saved a <br>         * silent copy of the data. <br>         */ <br>        if (pGlob-&gt;fOLE &amp;&amp; pOLE-&gt;pSvr-&gt;fEmbed) <br>            return fOK; <br> <br>        if (fOK &amp;&amp; pGlob-&gt;fOLE &amp;&amp; pOLE-&gt;pSvr-&gt;fLink) <br>            { <br>            OleRenameServerDoc(pOLE-&gt;pSvr-&gt;pDoc-&gt;lh, pGlob-&gt;szFile); <br>            OleSavedServerDoc(pOLE-&gt;pSvr-&gt;pDoc-&gt;lh); <br>            } <br>#endif //MAKEOLESERVER <br> <br>        pGlob-&gt;fOpenFile=fOK; <br>        WindowTitleSet(pGlob-&gt;hWnd, pGlob-&gt;szFile); <br>        pGlob-&gt;fDirty=FALSE; <br>        } <br> <br>    return fOK; <br>    } <br> <br> <br> <br>/* <br> * FFileExit <br> * <br> * Purpose: <br> *  Handles the File/Exit menu command, verifying dirty files as necessary <br> *  and revoking the server. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the application can exit, FALSE otherwise. <br> */ <br> <br>BOOL WINAPI FFileExit(LPGLOBALS pGlob) <br>    { <br>    BOOL            fRet; <br>#ifdef MAKEOLESERVER <br>    OLESTATUS       os; <br>    LHSERVER        lhT; <br>#endif //MAKEOLESERVER <br> <br>    if (!FCleanVerify(pGlob)) <br>        return FALSE; <br> <br>#ifdef MAKEOLESERVER <br>    lhT=pOLE-&gt;pSvr-&gt;lh; <br>    pOLE-&gt;pSvr-&gt;lh=0L; <br>    os=OleRevokeServer(lhT); <br> <br>    if (OLE_WAIT_FOR_RELEASE==os) <br>        { <br>        pOLE-&gt;pSvr-&gt;fRelease=FALSE; <br>        FOLEReleaseWait(&amp;pOLE-&gt;pSvr-&gt;fRelease, lhT); <br>        fRet=TRUE; <br>        } <br>    else <br>        fRet=(OLE_OK==os); <br>#endif //MAKEOLESERVER <br> <br>    return fRet; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
