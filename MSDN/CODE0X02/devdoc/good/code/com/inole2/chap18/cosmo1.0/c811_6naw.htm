<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INIT.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context818"></a>INIT.C</h2>
<pre><code>/* <br> * INIT.C <br> * <br> * Application (not OLE) specific initialization code. <br> *  FApplicationInit <br> *  FFileInit <br> *  HLoadAppStrings <br> *  HListParse <br> *  PszWhiteSpaceScan <br> * <br> * FApplicationInit makes some calls into OLEINST.C and OLEINIT.C <br> * <br> * Copyright(c) Microsoft Corp. 1992-1994 All Rights Reserved <br> * Win32 version, January 1994 <br> */ <br> <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole.h&gt; <br>#include "cosmo.h" <br>#include "oleinst.h" <br>#include "oleglobl.h" <br> <br> <br> <br>/* <br> * FApplicationInit <br> * <br> * Purpose: <br> *  All application specific initialization including loading <br> *  the stringtable, registering window classes, and calling any <br> *  OLE specific initialziation code. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to global variable block. <br> *  hPrevInst       HINSTANCE to the previous application instance, if any. <br> * <br> * Return Value: <br> *  BOOL            TRUE if everything succeeds, FALSE otherwise. <br> *                  If FALSE is returned, allocated memory and objects <br> *                  are not necessarily freed.  The caller should then <br> *                  use the FApplicationExit function to perform cleanup. <br> */ <br> <br>BOOL WINAPI FApplicationInit(LPGLOBALS pGlob, HINSTANCE hPrevInst) <br>    { <br>    HLOCAL      hMem; <br>    LPSTR FAR * ppszCmds; <br>    LPSTR FAR * ppszT; <br>    BOOL        fRet=TRUE; <br> <br>#ifdef MAKEOLESERVER <br>    //Make sure this is NULLed in case we fail <br>    pOLE-&gt;pSvr=NULL; <br>#endif <br> <br>    /* <br>     * InitApp allocates local memory for strings. WinMain must free. <br>     * If this fails, we should quit BEFORE we register any classes <br>     * or do anything else to suck up USER or GDI resources. <br>     */ <br>    hMem=HLoadAppStrings(pGlob); <br> <br>    if (NULL==hMem) <br>        return FALSE; <br> <br>    pGlob-&gt;hStringMem=hMem; <br> <br>    //Classes are only registered if hPrevInstance is NULL. <br>    if (!FClassRegister(pGlob, hPrevInst)) <br>        { <br>        LocalFree(pGlob-&gt;hStringMem); <br>        return FALSE; <br>        } <br> <br>    //Register a private clipboard format, same as the class name. <br>    pGlob-&gt;cfCosmo=RegisterClipboardFormat(rgpsz[IDS_CLASSCOSMO]); <br> <br>    hMem=HListParse(pGlob-&gt;pszCmdLine); <br>    ppszCmds=(LPSTR FAR *)(PSTR)hMem; <br>    ppszT=ppszCmds; <br> <br>    /* <br>     * Scan the command line list for the first thing without a <br>     * / or - which is out initial file. <br>     */ <br> <br>    while (*ppszT) <br>        { <br>        if ('-'!=**ppszT &amp;&amp; '/'!=**ppszT) <br>            break; <br> <br>        ppszT++; <br>        } <br> <br>    //Copy this filename for later loading during WM_CREATE. <br>    if (NULL==*ppszT) <br>        pGlob-&gt;szFile[0]=0; <br>    else <br>        lstrcpy(pGlob-&gt;szFile, *ppszT); <br> <br> <br>#ifdef MAKEOLESERVER <br>    /* <br>     * Go do anything that deals with the registration database. <br>     * Installation could be moved to an installation program <br>     */ <br>    if (!FRegDBInstall()) <br>        { <br>        LocalFree(hMem); <br>        return FALSE; <br>        } <br> <br>    //Initialize OLE specific data.  FOLEInstanceInit affects pGlob-&gt;fOLE <br>    if (FOLEInstanceInit(pOLE, pGlob-&gt;hInst, rgpsz[IDS_CLASSCOSMO] <br>        , ppszCmds, pGlob-&gt;nCmdShow)) <br>        { <br>        //We will open any linked file later in WM_CREATE. <br> <br>        //Copy the new ShowWindow parameter. <br>        pGlob-&gt;nCmdShow=pOLE-&gt;pSvr-&gt;nCmdShow; <br>        } <br>    else <br>        fRet=FALSE; <br> <br>#endif //MAKEOLESERVER <br> <br>    //Free the command-line string list in hMem. <br>    LocalFree(hMem); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * FClassRegister <br> * <br> * Purpose: <br> *  Registers classes used by the application:  "Cosmo" the main <br> *  window, and "Polyline" the editing window. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to the global variables block. <br> *  hPrevInst       HINSTANCE of any previous application instance. <br> * <br> * Return Value: <br> *  BOOL            TRUE if all classes are successfully registered <br> *                  (or if hPrevInstance is non-NULL).  FALSE is <br> *                  any registration fails. <br> * <br> */ <br> <br>BOOL WINAPI FClassRegister(LPGLOBALS pGlob, HINSTANCE hPrevInst) <br>    { <br>    WNDCLASS        wc; <br> <br>    if (hPrevInst) <br>        return TRUE; <br> <br>    /* <br>     * Note that we do not need to unregister classes on a failure <br>     * since that's part of automatic app cleanup. <br>     */ <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = CosmoWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = 0; <br>    wc.hInstance     = pGlob-&gt;hInst; <br>    wc.hIcon         = LoadIcon(pGlob-&gt;hInst, "Icon"); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = rgpsz[IDS_CLASSCOSMO]; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br> <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc   = PolylineWndProc; <br>    wc.cbClsExtra    = 0; <br>    wc.cbWndExtra    = CBPOLYLINEWNDEXTRA; <br>    wc.hInstance     = pGlob-&gt;hInst; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_CROSS); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = rgpsz[IDS_CLASSPOLYLINE]; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * FFileInit <br> * <br> * Purpose: <br> *  Loads a file specified on the command line and sets the polyline <br> *  window data to reflect the contents of that file.  This is set <br> *  in a different function instead of in FApplicationInit since <br> *  it depends on the Polyline window being created which has not <br> *  happened by FApplicationInit time. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to global variable block. <br> * <br> * Return Value: <br> *  BOOL            TRUE if everything succeeded, FALSE otherwise. <br> * <br> */ <br> <br>BOOL WINAPI FFileInit(LPGLOBALS pGlob) <br>    { <br>    POLYLINE        pl; <br> <br>    /* <br>     * If there is a file to load, then load it and change the <br>     * window title.  If loading fails, then default to a new <br>     * untitled document. <br>     */ <br>    if (0!=pGlob-&gt;szFile[0]) <br>        { <br>        if (!FCosFileRead(pGlob, pGlob-&gt;szFile, &amp;pl)) <br>            { <br>            //If we're in OLE linking mode, return unsuccessful <br>            if (pGlob-&gt;fOLE) <br>                return FALSE; <br> <br>            pGlob-&gt;szFile[0]=0; <br>            WindowTitleSet(pGlob-&gt;hWnd, rgpsz[IDS_UNTITLED]); <br>            pGlob-&gt;fOpenFile=FALSE; <br> <br>            } <br>        else <br>            { <br>            SendMessage(pGlob-&gt;hWndPolyline, PLM_POLYLINESET, TRUE, <br>                        (LONG)(LPSTR)&amp;pl); <br>            WindowTitleSet(pGlob-&gt;hWnd, pGlob-&gt;szFile); <br>            pGlob-&gt;fOpenFile=TRUE; <br>            } <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * HLoadAppStrings <br> * <br> * Purpose: <br> *  Allocates FIXED local memory and reads the applications <br> *  string resources into that memory.  Each string's pointer <br> *  is available with rgpsz[i] where i is the ID value of the <br> *  string.  The strings must have sequential IDs. <br> * <br> * Parameters: <br> *  pGlob           LPGLOBALS to global variable block. <br> * <br> * Return Value: <br> *  HLOCAL          Handle to the local memory.  NULL if memory could <br> *                  not be allocated. <br> */ <br> <br>HLOCAL WINAPI HLoadAppStrings(LPGLOBALS pGlob) <br>    { <br>    HLOCAL      hLocalMem; <br>    char NEAR   *pch; <br>    UINT        cchUsed=0; <br>    UINT        cch; <br>    short       i; <br> <br>    /* <br>     * Allocate memory and load strings.  NOTE!  The LPTR style <br>     * specifies FIXED memory.  This should not be a big deal <br>     * since this is an early allocation into the local heap. <br>     * But it should be watched if the number of strings becomes <br>     * large. <br>     */ <br>    hLocalMem=LocalAlloc(LPTR, CSTRINGS*CCHSTRINGMAX); <br> <br>    if (hLocalMem==NULL) <br>        return (HLOCAL)NULL; <br> <br>    /* <br>     * This operation is only valid for FIXED memory.  Otherwise use <br>     * LocalLock. <br>     */ <br>    pch=(char *)hLocalMem; <br> <br> <br>    /* <br>     * Load the strings into the memory and retain the specific <br>     * pointer to that string. <br>     */ <br>    for (i=0; i&lt;CSTRINGS; i++) <br>        { <br>        cch=LoadString(pGlob-&gt;hInst, i, (LPSTR)(pch+cchUsed), CCHSTRINGMAX-1); <br>        rgpsz[i]=(char *)(pch+cchUsed); <br> <br>        /* <br>         * One is added to cch to include a NULL.  The memory was ZEROINITed <br>         * on allocation so by skipping a byte we get the NULL. <br>         */ <br>        cchUsed +=cch+1; <br>        } <br> <br>    /* <br>     * We are assuming that no string is over CCHSTRINGMAX, and therefore <br>     * we did not use all the allocated memory.  Therefore LocalReAlloc <br>     * will only SHRINK the block, never expand it.  So if it fails, we <br>     * don't care--all the strings are still there, we just wasted some <br>     * space. <br>     */ <br>    LocalReAlloc(hLocalMem, cchUsed+1, LPTR); <br> <br>    return hLocalMem; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * HListParse <br> * <br> * Purpose: <br> *  Parses any string containing text separated by whitespace into <br> *  a list of pointers into that string as well as overwriting the <br> *  whitespace with null terminators.  The result is that each <br> *  pointer in the list points to its own null-terminated string, <br> *  but those strings are not necessarily contiguous. <br> * <br> *  Since MS-DOS command lines are limited to 128 characters, this <br> *  function limits the number of arguments to 64 separate strings. <br> * <br> * Parameters: <br> *  psz             LPSTR to the string to parse. <br> * <br> * Return Value: <br> *  HLOCAL          Local LMEM_FIXED memory handle containing the <br> *                  list of LPSTRs to the list items.  NULL if memory <br> *                  could not be allocated. <br> */ <br> <br>HLOCAL WINAPI HListParse(LPSTR psz) <br>    { <br>    HLOCAL       hMem; <br>    LPSTR FAR   *ppsz; <br>    LPSTR        pszT; <br>    UINT         cp; <br> <br>    //Allocate space for 64 pointers. <br>    hMem=LocalAlloc(LPTR, 64*sizeof(LPSTR)); <br> <br>    if (NULL==hMem) <br>        return NULL; <br> <br>    ppsz=(LPSTR FAR *)(PSTR)hMem; <br>    cp=0; <br> <br>    /* <br>     * For each string, scan for whitespace, save that pointer in <br>     * ppsz, and null-terminate that string.  If it was already <br>     * null-terminated, then there are no more pieces in the list. <br>     */ <br> <br>    while (0!=*psz) <br>        { <br>        //Skip to beginning of first item. <br>        psz=PszWhiteSpaceScan(psz, TRUE); <br> <br>        //If it's a zero, stop here. <br>        if (0==*psz) <br>            break; <br> <br>        //Find the end of this item. <br>        pszT=PszWhiteSpaceScan(psz, FALSE); <br> <br>        //Null terminate this string and point to next character. <br>        if (0!=*pszT) <br>            *pszT++=0; <br> <br>        //Save this string pointer. <br>        *ppsz++=psz; <br>        cp++; <br> <br>        //Check our limit of 64. <br>        if (64 &lt;= cp) <br>            break; <br> <br>        //Check next item. <br>        psz=pszT; <br>        } <br> <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * PszWhiteSpaceScan <br> * <br> * Purpose: <br> *  Skips characters in a string until a whitespace or non-whitespace <br> *  character is seen.  Whitespace is defined as \n, \r, \t, or ' '. <br> * <br> * NOTE:  This function is not extremely well suited to localization. <br> *        It assumes that an existing application seeking to become <br> *        and OLE server probably already has such a string function <br> *        available. <br> * <br> * Parameters: <br> *  psz             LPSTR to string to manipulate <br> *  fSkip           BOOL  TRUE if we want to skip whitespace. <br> *                  FALSE if we want to skip anything but whitespace. <br> * <br> * Return Value: <br> *  LPSTR           Pointer to first character in the string that either <br> *                  non-whitespace (fSkip=TRUE) or whitespace (fSkip=FALSE), <br> *                  which may be the null terminator. <br> */ <br> <br>LPSTR PASCAL PszWhiteSpaceScan(LPSTR psz, BOOL fSkip) <br>    { <br>    char        ch; <br>    BOOL        fWhite; <br> <br>    while (ch=*psz) <br>        { <br>        fWhite=('\n'==ch || '\r'==ch || '\t'==ch || ' '==ch); <br> <br>        //Too bad C doesn't have a logical XOR (^^) operator. <br>        if ((fSkip &amp;&amp; !fWhite) || (!fSkip &amp;&amp; fWhite)) <br>            break; <br> <br>        psz++; <br>        } <br> <br>    return psz; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
