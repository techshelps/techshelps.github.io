<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOLECONT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context909"></a>IOLECONT.CPP</h2>
<pre><code>/* <br> * IOLECONT.CPP <br> * Patron Chapter 21 <br> * <br> * Implementation of the IOleItemContainer interface for Patron's <br> * CPage and CPatronDoc alike, using the constructor parameter fDoc <br> * to differentiate. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include &lt;stdlib.h&gt; <br>#include "patron.h" <br> <br> <br>/* <br> * CImpIOleItemContainer::CImpIOleItemContainer <br> * CImpIOleItemContainer::~CImpIOleItemContainer <br> * <br> * Parameters (Constructor): <br> *  pObj            LPVOID of the page or pages. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> *  fDoc            BOOL indicating if we're in CPatronDoc or CPage <br> */ <br> <br>CImpIOleItemContainer::CImpIOleItemContainer(LPVOID pObj <br>    , LPUNKNOWN pUnkOuter, BOOL fDoc) <br>    { <br>    m_cRef=0; <br>    m_fDoc=fDoc; <br> <br>    if (fDoc) <br>        { <br>        m_pDoc=(PCPatronDoc)pObj; <br>        m_pPage=NULL; <br>        } <br>    else <br>        { <br>        m_pDoc=NULL; <br>        m_pPage=(PCPage)pObj; <br>        } <br> <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIOleItemContainer::~CImpIOleItemContainer(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::QueryInterface <br> * CImpIOleItemContainer::AddRef <br> * CImpIOleItemContainer::Release <br> * <br> * Purpose: <br> *  IUnknown members for CImpIOleItemContainer object. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CImpIOleItemContainer::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleItemContainer::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::ParseDisplayName <br> * <br> * Purpose: <br> *  Inherited member of IParseDisplayName that takes a string name <br> *  and turns out a moniker for it. <br> * <br> * Parameters: <br> *  pbc             LPBC to the binding context <br> *  pszName         LPOLESTR to the name to parse. <br> *  pchEaten        ULONG * into which to store how many <br> *                  characters we scanned in the display name. <br> *  ppmk            LPMONIKER * in which to return the moniker. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::ParseDisplayName(LPBC pbc <br>    , LPOLESTR pszName, ULONG *pchEaten, LPMONIKER *ppmk) <br>    { <br>    OLECHAR     ch; <br>    ULONG       chEaten=0; <br>    TCHAR       szName[256]; <br>    TCHAR       szComp[15]; <br>    LPTSTR      psz; <br>    UINT        cch; <br> <br>    *ppmk=NULL; <br>    *pchEaten=0; <br> <br>    /* <br>     * All we have to look for is the string between the ! <br>     * delimeters (or a null terminator).  pszName should be pointing <br>     * to a !, so skip it and scan the string for a ! or 0, <br>     * then pass the result to CreateItemMoniker. <br>     */ <br> <br>    psz=szName; <br> <br>    ch=*pszName++; <br>    chEaten++; <br> <br>    if ((OLECHAR)'!'!=ch) <br>        return ResultFromScode(MK_E_SYNTAX); <br> <br>    ch=*pszName++; <br> <br>    while ((OLECHAR)0!=ch &amp;&amp; (OLECHAR)'!' !=ch) <br>        { <br>        *psz++=(TCHAR)ch; <br>        chEaten++; <br>        ch=*pszName++; <br>        } <br> <br>    *psz=(TCHAR)0; <br> <br>    /* <br>     * Syntax check.  If we're the DOcument object, check for <br>     * "Page n" at the beginning of the string.  Otherwise check <br>     * for "Tenant n". <br>     */ <br>    lstrcpy(szComp, m_fDoc ? TEXT("Page ") : TEXT("Tenant ")); <br> <br>    //Does szName start with szComp? <br>    cch=lstrlen(szComp); <br> <br>    if (0!=_tcsncicmp(szName, szComp, cch)) <br>        { <br>        *pchEaten=1;    //Parsed ! at least <br>        return ResultFromScode(MK_E_SYNTAX); <br>        } <br> <br>    //Check for a number in szName <br>    if ((TCHAR)'0' != szName[cch]) <br>        { <br>        if (0==_ttoi(szName+cch)) <br>            { <br>            *pchEaten=cch;  //Got past name <br>            return ResultFromScode(MK_E_SYNTAX); <br>            } <br>        } <br> <br>    *pchEaten=chEaten; <br>   #ifdef WIN32ANSI <br>    //Use the ANSI version here since szName is ANSI <br>    return INOLE_CreateItemMoniker(TEXT("!"), szName, ppmk); <br>   #else <br>    return CreateItemMoniker(OLETEXT("!"), szName, ppmk); <br>   #endif <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::EnumObjects <br> * <br> * Purpose: <br> *  Creates and returns an IEnumUnknown object that allows the <br> *  caller to walk through the objects in this continer thing. <br> * <br> * Parameters: <br> *  dwFlags         DWORD specifying what kind of objects to <br> *                  enumerate. <br> *  ppEnum          LPENUMUNKNOWN * into which to return the <br> *                  enumerator <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::EnumObjects(DWORD dwFlags <br>    , LPENUMUNKNOWN *ppEnum) <br>    { <br>    *ppEnum=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::LockContainer <br> * <br> * Purpose: <br> *  Establishes a lock on the container to prevent it from shutting <br> *  down outside of user control.  This is used to control the <br> *  lifetime of the container when it's used to update a link to an <br> *  embedded object within it.  If we're unlock and the user has not <br> *  taken control, we close. <br> * <br> * Parameters: <br> *  fLock           BOOL indicating a lock or unlock. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::LockContainer(BOOL fLock) <br>    { <br>    /* <br>     * This is pretty much the same implementation as <br>     * IClassFactory::LockServer, and we can use the same lock <br>     * count to accomplish our goal. <br>     */ <br> <br>    if (fLock) <br>        g_cLock++; <br>    else <br>        { <br>        g_cLock--; <br>        g_cObj++; <br>        ObjectDestroyed(); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::GetObject <br> * <br> * Purpose: <br> *  Returns the requested interface pointer on an object in this <br> *  container. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR to the item we must locate. <br> *  dwSpeed         DWORD identifying how long the caller is willing <br> *                  to wait. <br> *  pcb             LPBINDCTX providing the binding context. <br> *  riid            REFIID of the interface requested. <br> *  ppv             PPVOID into which to return the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::GetObject(LPOLESTR pszItem <br>    , DWORD dwSpeed, LPBINDCTX pbc, REFIID riid, PPVOID ppv) <br>    { <br>    DWORD       dw; <br>    char        szTemp[40];     //ANSI for atol <br>    HRESULT     hr=ResultFromScode(E_FAIL); <br>    PCPage      pPage; <br>    PCTenant    pTenant; <br>    LPUNKNOWN   pObj; <br>    UINT        i, iCur; <br> <br>    *ppv=NULL; <br> <br>    if (m_fDoc) <br>        { <br>        /* <br>         * The item name should be "Page n", so we'll do it the <br>         * easy way:  call atol on pszItem+5 (we always know that <br>         * we'll have "Page " there since we put it there (see <br>         * CPage::GetStorageName). <br>         */ <br> <br>        UNICODETOANSI((pszItem+5), szTemp, sizeof(szTemp)); <br>        dw=atol(szTemp); <br> <br>        i=m_pDoc-&gt;m_pPG-&gt;IPageGetFromID(dw, &amp;pPage, FALSE); <br> <br>        if (NOVALUE==i) <br>            return hr; <br> <br>        /* <br>         * If we're asked for immediate speed, only do this if the <br>         * page is already current, i.e. everything is loaded. <br>         */ <br>        iCur=m_pDoc-&gt;m_pPG-&gt;CurPageGet(); <br> <br>        if (BINDSPEED_IMMEDIATE==dwSpeed &amp;&amp; iCur!=i) <br>            return ResultFromScode(MK_E_EXCEEDEDDEADLINE); <br> <br>        m_pDoc-&gt;m_pPG-&gt;CurPageSet(i); <br> <br>        //This will have changed to be the current page now. <br>        if (NULL!=m_pDoc-&gt;m_pPG-&gt;m_pPageCur) <br>            hr=m_pDoc-&gt;m_pPG-&gt;m_pPageCur-&gt;QueryInterface(riid, ppv); <br>        } <br>    else <br>        { <br>        if (TenantFromName(pszItem, &amp;pTenant)) <br>            { <br>            pTenant-&gt;ObjectGet(&amp;pObj); <br> <br>            /* <br>             * If we're asked for immediate or moderate, only work <br>             * if the object is already running. <br>             */ <br>            hr=IsRunning(pszItem);  //This is the function below <br> <br>            if ((BINDSPEED_IMMEDIATE==dwSpeed <br>                || BINDSPEED_MODERATE==dwSpeed) &amp;&amp; NOERROR!=hr) <br>                hr=ResultFromScode(MK_E_EXCEEDEDDEADLINE); <br>            else <br>                { <br>                //IMPORTANT:  Make sure this object is running first <br>                OleRun(pObj); <br>                hr=pObj-&gt;QueryInterface(riid, ppv); <br>                } <br> <br>            pObj-&gt;Release(); <br>            } <br>        else <br>            hr=ResultFromScode(MK_E_NOOBJECT); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::GetObjectStorage <br> * <br> * Purpose: <br> *  Similar to get Object in that we have to locate the object <br> *  described by a given name, but instead of returning any old <br> *  interface we return a storage element. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR to the item we must locate. <br> *  pcb             LPBINDCTX providing the binding context. <br> *  riid            REFIID of the interface requested.  Usually <br> *                  IStorage or IStream. <br> *  ppv             PPVOID into which to return the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::GetObjectStorage(LPOLESTR pszItem <br>    , LPBINDCTX pbc, REFIID riid, PPVOID ppv) <br>    { <br>    PCTenant    pTenant; <br> <br>    *ppv=NULL; <br> <br>    if (m_fDoc) <br>        return ResultFromScode(E_NOTIMPL); <br> <br>    //Can only handle IStorage. <br>    if (IID_IStorage!=riid) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    if (TenantFromName(pszItem, &amp;pTenant)) <br>        pTenant-&gt;StorageGet((LPSTORAGE *)ppv); <br> <br>    return (NULL!=*ppv) ? NOERROR : ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::IsRunning <br> * <br> * Purpose: <br> *  Answers if the object under the given name is currently running. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR of the item to check <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the object is running, S_FALSE <br> *                  otherwise.  Possibly MK_E_NOOBJECT if the name <br> *                  is bogus. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::IsRunning(LPOLESTR pszItem) <br>    { <br>    HRESULT     hr; <br>    PCTenant    pTenant; <br>    LPUNKNOWN   pObj; <br>    LPOLEOBJECT pIOleObject; <br> <br>    /* <br>     * If this is the document's container interface, the object <br>     * is a page and the page is always running. <br>     */ <br>    if (m_fDoc) <br>        return NOERROR; <br>    else <br>        { <br>        if (TenantFromName(pszItem, &amp;pTenant)) <br>            { <br>            //Ask the actual object if its running. <br>            pTenant-&gt;ObjectGet(&amp;pObj); <br>            hr=pObj-&gt;QueryInterface(IID_IOleObject <br>                , (PPVOID)&amp;pIOleObject); <br>            pObj-&gt;Release(); <br> <br>            if (SUCCEEDED(hr)) <br>                { <br>                hr=(OleIsRunning(pIOleObject)) <br>                    ? NOERROR : ResultFromScode(S_FALSE); <br>                pIOleObject-&gt;Release(); <br>                } <br>            } <br>        else <br>            hr=ResultFromScode(MK_E_NOOBJECT); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::TenantFromName <br> * (Private) <br> * <br> * Purpose: <br> *  This function which is NOT part of the interface retrieves <br> *  a tenant pointer from a tenant name. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR of the tenant to locate. <br> *  ppTenant        PCTenant * in which to return the pointer. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CImpIOleItemContainer::TenantFromName(LPOLESTR pszItem <br>    , PCTenant *ppTenant) <br>    { <br>    DWORD       dw; <br>    char        szTemp[40];     //ANSI for atol <br> <br>    if (m_fDoc) <br>        return FALSE; <br> <br>    //The item name should be "Tenant xxxx", so use pszItem+7. <br>    UNICODETOANSI((pszItem+7), szTemp, sizeof(szTemp)); <br>    dw=atol(szTemp); <br> <br>    *ppTenant=NULL; <br> <br>    return m_pPage-&gt;TenantGetFromID(dw, ppTenant, FALSE); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
