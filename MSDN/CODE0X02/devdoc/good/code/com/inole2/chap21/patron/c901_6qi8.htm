<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PRINT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context920"></a>PRINT.CPP</h2>
<pre><code>/* <br> * PRINT.CPP <br> * Patron Chapter 21 <br> * <br> * Implementation of printing functions for both CPatronDoc <br> * and CPages classes.  These functions are here to keep clutter <br> * down in document.cpp and pages.cpp. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br>#include "patron.h" <br> <br>static HWND g_hDlgPrint=NULL; <br>static BOOL g_fCancelPrint=FALSE; <br> <br> <br>/* <br> * CPatronDoc::Print <br> * <br> * Purpose: <br> *  Prints the current document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> * <br> * Return Value: <br> *  BOOL            TRUE if printing happened, FALSE if it didn't <br> *                  start or didn't complete. <br> */ <br> <br>BOOL CPatronDoc::Print(HWND hWndFrame) <br>    { <br>    PRINTDLG        pd; <br>    BOOL            fSuccess; <br> <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br>    pd.hwndOwner  =hWndFrame; <br>    pd.nCopies    =1; <br>    pd.nFromPage  =(USHORT)-1; <br>    pd.nToPage    =(USHORT)-1; <br>    pd.nMinPage   =1; <br>    pd.nMaxPage   =m_pPG-&gt;NumPagesGet(); <br> <br>    pd.lpfnPrintHook=PrintDlgHook; <br> <br>    //Get the current document printer settings <br>    pd.hDevMode=m_pPG-&gt;DevModeGet(); <br> <br>    pd.Flags=PD_RETURNDC | PD_ALLPAGES | PD_COLLATE <br>        | PD_HIDEPRINTTOFILE | PD_NOSELECTION | PD_ENABLEPRINTHOOK; <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (NULL!=pd.hDevMode) <br>        GlobalFree(pd.hDevMode); <br> <br>    if (NULL!=pd.hDevNames) <br>        GlobalFree(pd.hDevNames); <br> <br>    //Go do the actual printing. <br>    fSuccess=m_pPG-&gt;Print(pd.hDC, PSZ(IDS_DOCUMENTNAME), pd.Flags <br>        , pd.nFromPage, pd.nToPage, pd.nCopies); <br> <br>    if (!fSuccess) <br>        { <br>        MessageBox(m_hWnd, PSZ(IDS_PRINTERROR) <br>            , PSZ(IDS_DOCUMENTCAPTION), MB_OK); <br>        } <br> <br>    return fSuccess; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PrinterSetup <br> * <br> * Purpose: <br> *  Selects a new printer and options for this document. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame to use for dialog parents. <br> *  fDefault        BOOL to avoid any dialog and just use the <br> *                  default. <br> * <br> * Return Value: <br> *  UINT            Undefined <br> */ <br> <br>UINT CPatronDoc::PrinterSetup(HWND hWndFrame, BOOL fDefault) <br>    { <br>    PRINTDLG        pd; <br> <br>    //Attempt to get printer metrics for the default printer. <br>    memset(&amp;pd, 0, sizeof(PRINTDLG)); <br>    pd.lStructSize=sizeof(PRINTDLG); <br> <br>    if (fDefault) <br>        pd.Flags=PD_RETURNDEFAULT; <br>    else <br>        { <br>        pd.hwndOwner=hWndFrame; <br>        pd.Flags=PD_PRINTSETUP; <br> <br>        //Get the current document printer settings <br>        pd.hDevMode=m_pPG-&gt;DevModeGet(); <br>        } <br> <br>    if (!PrintDlg(&amp;pd)) <br>        return FALSE; <br> <br>    if (!m_pPG-&gt;DevModeSet(pd.hDevMode, pd.hDevNames)) <br>        { <br>        GlobalFree(pd.hDevNames); <br>        GlobalFree(pd.hDevMode); <br>        return FALSE; <br>        } <br> <br>    FDirtySet(TRUE); <br>    return 1; <br>    } <br> <br> <br> <br>/* <br> * PrintDlgHook <br> * <br> * Purpose: <br> *  Callback hook for the Print Dialog so we can hide the Setup <br> *  button.  Patron only allows Setup before anything exists on <br> *  the page, and is not written to handle setup at Print time. <br> */ <br> <br>UINT CALLBACK PrintDlgHook(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    if (WM_INITDIALOG==iMsg) <br>        { <br>        HWND        hWnd; <br> <br>        hWnd=GetDlgItem(hDlg, psh1); <br>        ShowWindow(hWnd, SW_HIDE); <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPrinterSetup <br> * <br> * Purpose: <br> *  Returns whether or not the Printer Setup menu item can be <br> *  enabled.  Once you create a tenant in any page, Printer Setup <br> *  is voided simply to keep this sample simple, that is, we don't <br> *  have to worry about reorganizing potentially large amounts <br> *  of layout after we start plopping down objects. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE to enable the menu, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPrinterSetup(void) <br>    { <br>    return m_fPrintSetup; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::DevModeSet <br> * <br> * Purpose: <br> *  Provides the Pages with the current printer information. <br> * <br> * Parameters: <br> *  hDevMode        HGLOBAL to the memory containing the DEVMODE. <br> *                  This function assumes responsibility for this <br> *                  handle. <br> *  hDevNames       HGLOBAL providing the driver name and device <br> *                  name from which we can create a DC for <br> *                  information. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we could accept this configuration, <br> *                  FALSE otherwise.  If we return TRUE we also <br> *                  delete the old memory we hold. <br> */ <br> <br>BOOL CPages::DevModeSet(HGLOBAL hDevMode, HGLOBAL hDevNames) <br>    { <br>    LPDEVNAMES      pdn; <br>    LPTSTR          psz; <br>    HGLOBAL         hMem; <br>    PDEVICECONFIG   pdc; <br>    LPDEVMODE       pdm; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br>    ULONG           cbDevMode, cbWrite; <br>    BOOL            fRet=FALSE; <br> <br>    if (NULL==hDevMode || NULL==hDevNames) <br>        return FALSE; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_WRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * DEVMODE is variable length--total length in hDevMode, so the <br>     * amount to write is that plus string space.  We subtract <br>     * sizeof(DEVMODE) as that is already included from GlobalSize. <br>     */ <br>    cbDevMode=GlobalSize(hDevMode); <br>    cbWrite=cbDevMode+sizeof(DEVICECONFIG)-sizeof(DEVMODE); <br> <br>    hMem=GlobalAlloc(GHND, cbWrite); <br> <br>    if (NULL==hMem) <br>        { <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    pdc=(PDEVICECONFIG)GlobalLock(hMem);    //This always works <br>    pdm=(LPDEVMODE)GlobalLock(hDevMode);    //This might not <br> <br>    if (NULL!=pdm) <br>        { <br>        pdc-&gt;cb=cbWrite; <br>        pdc-&gt;cbDevMode=cbDevMode; <br>        memcpy(&amp;pdc-&gt;dm, pdm, (int)cbDevMode); <br>        GlobalUnlock(hDevMode); <br> <br>        psz=(LPTSTR)GlobalLock(hDevNames); <br> <br>        if (NULL!=psz) <br>            { <br>            pdn=(LPDEVNAMES)psz; <br>            lstrcpy(pdc-&gt;szDriver, psz+pdn-&gt;wDriverOffset); <br>            lstrcpy(pdc-&gt;szDevice, psz+pdn-&gt;wDeviceOffset); <br>            lstrcpy(pdc-&gt;szPort,   psz+pdn-&gt;wOutputOffset); <br> <br>            pIStream-&gt;Write(pdc, cbWrite, &amp;cbWrite); <br>            GlobalUnlock(hDevNames); <br>            fRet=TRUE; <br>            } <br>        } <br> <br>    GlobalUnlock(hMem); <br>    GlobalFree(hMem); <br> <br>    pIStream-&gt;Release(); <br> <br>    if (!fRet) <br>        return FALSE; <br> <br>    GlobalFree(hDevNames); <br>    GlobalFree(hDevMode); <br> <br>    return ConfigureForDevice(); <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::DevModeGet <br> * <br> * Purpose: <br> *  Retrieves a copy of the current DEVMODE structure for this <br> *  Pages window.  The caller is responsible for this memory. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HGLOBAL         Handle to the memory containing the DEVMODE <br> *                  structure. <br> */ <br> <br>HGLOBAL CPages::DevModeGet(void) <br>    { <br>    HGLOBAL         hMem; <br>    LPVOID          pv; <br>    ULONG           cbDevMode, cbRead; <br>    LARGE_INTEGER   li; <br>    LPSTREAM        pIStream; <br>    HRESULT         hr; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    //Read how much to allocate for the DEVMODE structure <br>    LISet32(li, CBSEEKOFFSETCBDEVMODE); <br>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br>    pIStream-&gt;Read(&amp;cbDevMode, sizeof(ULONG), &amp;cbRead); <br> <br>    hMem=GlobalAlloc(GHND, cbDevMode); <br> <br>    if (NULL!=hMem) <br>        { <br>        pv=(LPVOID)GlobalLock(hMem); <br>        pIStream-&gt;Read(pv, cbDevMode, &amp;cbRead); <br>        GlobalUnlock(hMem); <br>        } <br> <br>    pIStream-&gt;Release(); <br>    return hMem; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::DevReadConfig <br> * <br> * Purpose: <br> *  Public function to read the current device configuration and <br> *  optionally return an information context for it. <br> * <br> * <br> * Parameters: <br> *  ppcd            PCOMBINEDEVICE * in which to return a pointer <br> *                  to an allocated structure that has all the <br> *                  device information we want.  Ignored if NULL. <br> *                  This is allocated with the task allocator. <br> *  phDC            HDC * in which to return the information <br> *                  context.  If NULL, no IC is created.  Caller <br> *                  becomes responsible for the returned IC. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::DevReadConfig(PCOMBINEDEVICE *ppcd, HDC *phDC) <br>    { <br>    HRESULT         hr; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    PCOMBINEDEVICE  pcd; <br>    ULONG           cb, cbRead; <br>    LARGE_INTEGER   li; <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMDEVICECONFIG, 0, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * Allocate the COMBINEDEVICE structure including the variable <br>     * information past the DEVMODE part. <br>     */ <br> <br>    hr=CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc); <br> <br>    if (FAILED(hr)) <br>        { <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    /* <br>     * Read size of the DEVICECONFIG structure including variable <br>     * portion of DEVMODE.  We need to load all this information <br>     * for CreateIC.  To this size we'll add the size of <br>     * DVTARGETDEVICE in order to allocate a COMBINEDEVICE. <br>     */ <br> <br>    pIStream-&gt;Read(&amp;cb, sizeof(DWORD), &amp;cbRead); <br> <br>    pcd=(PCOMBINEDEVICE)pIMalloc-&gt;Alloc(cb+sizeof(DVTARGETDEVICE)); <br> <br>    if (NULL==pcd) <br>        { <br>        pIMalloc-&gt;Release(); <br>        pIStream-&gt;Release(); <br>        return FALSE; <br>        } <br> <br>    //Now get the real information. <br>    LISet32(li, 0); <br>    pIStream-&gt;Seek(li, STREAM_SEEK_SET, NULL); <br>    pIStream-&gt;Read(&amp;(pcd-&gt;dc), cb, &amp;cbRead); <br>    pIStream-&gt;Release(); <br> <br> <br>    /* <br>     * If requested, complete the DVTARGETDEVICE structure in <br>     * pcd and store pcd in *ppcd for return. <br>     */ <br> <br>    if (NULL!=ppcd) <br>        { <br>        WORD    cb=sizeof(DVTARGETDEVICE); <br> <br>        pcd-&gt;td.tdSize=cb; <br>        pcd-&gt;td.tdExtDevmodeOffset=cb; <br>        pcd-&gt;td.tdDriverNameOffset=cb+sizeof(DEVMODE); <br>        pcd-&gt;td.tdDeviceNameOffset=cb+sizeof(DEVMODE) <br>            +(CCHDEVICENAME*sizeof(TCHAR)); <br>        pcd-&gt;td.tdPortNameOffset  =cb+sizeof(DEVMODE) <br>            +(CCHDEVICENAME*2*sizeof(TCHAR)); <br> <br>        *ppcd=pcd; <br>        } <br> <br>    //Create an IC if requested. <br>    if (NULL!=phDC) <br>        { <br>        //Get the DC then configure <br>        *phDC=CreateIC(pcd-&gt;dc.szDriver, pcd-&gt;dc.szDevice <br>            , pcd-&gt;dc.szPort, &amp;(pcd-&gt;dc.dm)); <br> <br>        if (NULL==*phDC) <br>            return FALSE; <br>        } <br> <br>    //pcd is a temporary allocation in this case <br>    if (NULL==ppcd) <br>        pIMalloc-&gt;Free(pcd); <br> <br>    pIMalloc-&gt;Release(); <br>    return (NULL!=*phDC); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::ConfigureForDevice <br> * <br> * Purpose: <br> *  Recalculates our drawing configuration based on the contents of <br> *  an hDC.  If no HDC is given we use the contents of our DevMode <br> *  stream. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::ConfigureForDevice(void) <br>    { <br>    POINT           ptOffset, ptPaper; <br>    RECT            rc; <br>    HDC             hDC; <br>    CHourglass      hg; <br> <br>    if (!DevReadConfig(NULL, &amp;hDC)) <br>        return FALSE; <br> <br>    //Get usable page dimensions:  already sensitive to orientation <br>    m_cx=GetDeviceCaps(hDC, HORZSIZE)*10-16; //*10: mm to LOMETRIC <br>    m_cy=GetDeviceCaps(hDC, VERTSIZE)*10-16; //-16: for driver bugs. <br> <br>    //Calculate the printer-limited margins on sides in LOMETRIC. <br>    Escape(hDC, GETPRINTINGOFFSET, NULL, NULL, &amp;ptOffset); <br>    Escape(hDC, GETPHYSPAGESIZE,   NULL, NULL, &amp;ptPaper); <br> <br>    SetRect(&amp;rc, ptOffset.x, ptOffset.y, ptPaper.x, ptPaper.y); <br>    SetMapMode(hDC, MM_LOMETRIC); <br>    RectConvertMappings(&amp;rc, hDC, FALSE); <br> <br>    //Left and top margins are the printing offset. <br>    m_xMarginLeft= rc.left+8;   //+8 to match -16 above <br>    m_yMarginTop =-rc.top+8;    //LOMETRIC makes this negative. <br> <br>    //Right is (paper width)-(usable width)-(left margin) <br>    m_xMarginRight =rc.right-m_cx-m_xMarginLeft; <br> <br>    //Bottom is (paper height)-(usable height)-(top margin)+1 <br>    m_yMarginBottom=-rc.bottom-m_cy-m_yMarginTop+1; <br> <br>    UpdateScrollRanges(); <br> <br>    DeleteDC(hDC); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::Print <br> * <br> * Purpose: <br> *  Prints a specified range of pages to a given hDC.  Repeats for <br> *  a given number of copies. <br> * <br> * Parameters: <br> *  hDC             HDC to which we print. <br> *  pszDoc          LPTSTR providing the document name. <br> *  dwFlags         DWORD flags from PrintDlg <br> *  iPageStart      UINT starting page index (one based) <br> *  iPageEnd        UINT ending page index (one based).  Includes <br> *                  this page. <br> *  cCopies         UINT number of copies to print.  If PD_COLLATE <br> *                  in dwFlags is set, we print multiple copies of <br> *                  each page as we cycle through.  Otherwise we <br> *                  cycle multiple times. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::Print(HDC hDC, LPTSTR pszDoc, DWORD dwFlags <br>    , UINT iPageStart, UINT iPageEnd, UINT cCopies) <br>    { <br>    BOOL        fError=FALSE; <br>    int         iPage, iPageInc; <br>    int         iUserPage, cPages; <br>    UINT        iRepeat, cRepeat; <br>    UINT        iCycle, cCycles; <br>    UINT        iPageHold=m_iPageCur; <br>    HWND        hWndT, hWndTop=NULL; <br>    DOCINFO     di; <br>    PCDocument  pDoc; <br> <br>    //Validate hDC and page ranges <br>    if (NULL==hDC) <br>        return FALSE; <br> <br>    if ((PD_PAGENUMS &amp; dwFlags)) <br>        { <br>        if (-1==iPageStart) <br>            iPageStart=0; <br>        else <br>            iPageStart--;   //Switch to zero offset. <br> <br>        if (-1==iPageEnd) <br>            iPageEnd=m_cPages-1; <br>        else <br>            iPageEnd--;     //Switch to zero offset. <br>        } <br>    else //Can't test PD_ALLPAGES with &amp; since it's defined as 0L <br>        { <br>        iPageStart=0; <br>        iPageEnd=m_cPages-1; <br>        } <br> <br>    //Arrange cycles and repeats depending on cCopies and collating <br>    if (PD_COLLATE &amp; dwFlags) <br>        { <br>        cCycles=cCopies; <br>        cRepeat=1; <br>        } <br>    else <br>        { <br>        cCycles=1; <br>        cRepeat=cCopies; <br>        } <br> <br>    //Disable the frame window to prevent reentrancy while printing. <br>    hWndT=GetParent(m_hWnd); <br>    pDoc=(PCDocument)SendMessage(hWndT, DOCM_PDOCUMENT, 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        { <br>        PCFrame pFR; <br> <br>        pFR=pDoc-&gt;FrameGet(); <br>        hWndTop=pFR-&gt;Window(); <br>        EnableWindow(hWndTop, FALSE); <br>        } <br> <br>    SetAbortProc(hDC, AbortProc); <br>    g_fCancelPrint=FALSE; <br> <br>    //If these don't work then we'll just live without a dialog. <br>    g_hDlgPrint=CreateDialog(m_hInst, MAKEINTRESOURCE(IDD_PRINTING) <br>        , hWndTop, PrintDlgProc); <br> <br>    //Increment for either direction. <br>    iPageInc=(iPageStart &gt; iPageEnd) ? -1 : 1; <br> <br>    //Initial entries in dialog box. <br>    cPages=1+((int)(iPageEnd-iPageStart)*iPageInc); <br> <br>    SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE, 1, (LPARAM)cPages); <br>    SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, 1, (LPARAM)cRepeat); <br> <br>    di.cbSize=sizeof(DOCINFO); <br>    di.lpszDocName=pszDoc; <br>    di.lpszOutput=NULL; <br> <br>    if (StartDoc(hDC, &amp;di) &gt; 0) <br>        { <br>        /* <br>         * Iterate over the pages, repeating each page depending on <br>         * the copies we want and if we have collate enabled. <br>         */ <br> <br>        for (iCycle=1; iCycle &lt;= cCycles; iCycle++) <br>            { <br>            if (PD_COLLATE &amp; dwFlags) <br>                { <br>                SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE, iCycle <br>                    , (LPARAM)cCycles); <br>                } <br> <br>            //iPageInc controls direction <br>            for (iPage=iPageStart; ; iPage+=iPageInc) <br>                { <br>                iUserPage=1+((iPage-(int)iPageStart)*iPageInc); <br> <br>                SendMessage(g_hDlgPrint, PRINTM_PAGEUPDATE <br>                    , iUserPage, (LPARAM)cPages); <br> <br>                m_iPageCur=iPage;   //We restore this later. <br> <br>                for (iRepeat=1; iRepeat &lt;= cRepeat; iRepeat++) <br>                    { <br>                    if (!(PD_COLLATE &amp; dwFlags)) <br>                        { <br>                        SendMessage(g_hDlgPrint, PRINTM_COPYUPDATE <br>                            , iRepeat, (LPARAM)cRepeat); <br>                        } <br> <br>                    StartPage(hDC); <br>                    Draw(hDC, TRUE, TRUE); <br> <br>                    if (EndPage(hDC) &lt; 0) <br>                        fError=TRUE; <br> <br>                    if (fError || g_fCancelPrint) <br>                        break; <br>                    } <br> <br>                if (fError || g_fCancelPrint) <br>                    break; <br> <br>                //If we just printed the last page, time to quit. <br>                if (iPage==(int)iPageEnd) <br>                    break; <br>                } <br> <br>            if (fError || g_fCancelPrint) <br>                break; <br>            } <br> <br>        if (!fError) <br>            EndDoc(hDC); <br>        else <br>            AbortDoc(hDC); <br>        } <br>    else <br>        fError=TRUE; <br> <br>    //Set the page back to what it was before all this started. <br>    m_iPageCur=iPageHold; <br> <br>    EnableWindow(hWndTop, TRUE); <br>    SetFocus(hWndTop); <br>    DestroyWindow(g_hDlgPrint); <br>    DeleteDC(hDC); <br>    return !fError; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * AbortProc <br> * <br> * Purpose: <br> *  Abort procedure for printing the pages. <br> * <br> * Parameters: <br> *  hDC             HDC on which printing is happening. <br> *  iErr            int error code. <br> * <br> * Return Value: <br> *  BOOL            TRUE to continue the print job, FALSE otherwise. <br> */ <br> <br>BOOL APIENTRY AbortProc(HDC hDC, int iErr) <br>    { <br>    MSG     msg; <br> <br>    while (!g_fCancelPrint <br>        &amp;&amp; PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>        { <br>        if (NULL==g_hDlgPrint <br>            || !IsDialogMessage(g_hDlgPrint, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    return !g_fCancelPrint; <br>    } <br> <br> <br> <br> <br>/* <br> * PrintDlgProc <br> * <br> * Purpose: <br> *  Modeless dialog procedure for the dialog displayed while Patron <br> *  is printing pages. <br> */ <br> <br>BOOL APIENTRY PrintDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    TCHAR           szFormat[40]; <br>    TCHAR           szOutput[80]; <br> <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            EnableMenuItem(GetSystemMenu(hDlg, FALSE), SC_CLOSE <br>                , MF_GRAYED); <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            //Cancel button was pressed. <br>            g_fCancelPrint=TRUE; <br>            ShowWindow(hDlg, SW_HIDE); <br>            return TRUE; <br> <br>        case PRINTM_PAGEUPDATE: <br>            GetDlgItemText(hDlg, ID_PAGESTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTPAGE, szOutput); <br>            return TRUE; <br> <br>        case PRINTM_COPYUPDATE: <br>            GetDlgItemText(hDlg, ID_COPYSTRING, szFormat <br>                , sizeof(szFormat)); <br>            wsprintf(szOutput, szFormat, wParam, (UINT)lParam); <br>            SetDlgItemText(hDlg, ID_CURRENTCOPY, szOutput); <br>            return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
