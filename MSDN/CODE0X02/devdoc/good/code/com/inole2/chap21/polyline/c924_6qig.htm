<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOLEOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context928"></a>IOLEOBJ.CPP</h2>
<pre><code>/* <br> * IOLEOBJ.CPP <br> * Polyline Component Chapter 21 <br> * <br> * Implementation of the IOleObject interface for Polyline.  Some of <br> * these just pass through to the default handler which does default <br> * implementations. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * CImpIOleObject::CImpIOleObject <br> * CImpIOleObject::~CImpIOleObject <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> */ <br> <br>CImpIOleObject::CImpIOleObject(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIOleObject::~CImpIOleObject(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIOleObject::QueryInterface <br> * CImpIOleObject::AddRef <br> * CImpIOleObject::Release <br> * <br> * Purpose: <br> *  IUnknown members for CImpIOleObject object. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CImpIOleObject::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleObject::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetClientSite <br> * CImpIOleObject::GetClientSite <br> * <br> * Purpose: <br> *  Manages the IOleClientSite pointer of our container. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetClientSite <br>    (LPOLECLIENTSITE pIOleClientSite) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleClientSite) <br>        m_pObj-&gt;m_pIOleClientSite-&gt;Release(); <br> <br>    m_pObj-&gt;m_pIOleClientSite=pIOleClientSite; <br> <br>    //CHAPTER21MOD <br>    if (NULL!=m_pObj-&gt;m_pIOleClientSite) <br>        { <br>        HRESULT         hr; <br>        LPMONIKER       pmk; <br>        LPOLECONTAINER  pIOleCont; <br> <br>        m_pObj-&gt;m_pIOleClientSite-&gt;AddRef(); <br> <br>        /* <br>         * Within IRunnableObject::Run we're supposed to register <br>         * ourselves as running...however, the moniker has to come <br>         * from the container's IOleClientSite::GetMoniker.  But <br>         * Run is called before SetClientSite here, so we have to <br>         * register now that we do have the client site as well <br>         * as lock the container. <br>         */ <br> <br>        hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetMoniker <br>            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, &amp;pmk); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            INOLE_RegisterAsRunning(this, pmk, 0 <br>                , &amp;m_pObj-&gt;m_dwRegROT); <br>            pmk-&gt;Release(); <br>            } <br> <br>        hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetContainer(&amp;pIOleCont); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            m_pObj-&gt;m_fLockContainer=TRUE; <br>            pIOleCont-&gt;LockContainer(TRUE); <br>            pIOleCont-&gt;Release(); <br>            } <br>        } <br>    //End CHAPTER21MOD <br> <br>    return NOERROR; <br>    } <br> <br>STDMETHODIMP CImpIOleObject::GetClientSite(LPOLECLIENTSITE *ppSite) <br>    { <br>    //Be sure to AddRef the new pointer you are giving away. <br>    *ppSite=m_pObj-&gt;m_pIOleClientSite; <br>    m_pObj-&gt;m_pIOleClientSite-&gt;AddRef(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetHostNames <br> * <br> * Purpose: <br> *  Provides the object with names of the container application and <br> *  the object in the container to use in object user interface. <br> * <br> * Parameters: <br> *  pszApp          LPCOLESTR of the container application. <br> *  pszObj          LPCOLESTR of some name that is useful in window <br> *                  titles. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetHostNames(LPCOLESTR pszApp <br>    , LPCOLESTR pszObj) <br>    { <br>    if (NULL!=m_pObj-&gt;m_hDlg) <br>        { <br>        TCHAR       szTemp[128]; <br> <br>       #ifdef WIN32ANSI <br>        char        szObj[80]; <br>        WideCharToMultiByte(CP_ACP, 0, pszObj, -1, szObj, 80 <br>            , NULL, NULL); <br>        wsprintf(szTemp, SZPOLYFRAMETITLE, szObj); <br>       #else <br>        wsprintf(szTemp, SZPOLYFRAMETITLE, pszObj); <br>       #endif <br>        SetWindowText(m_pObj-&gt;m_hDlg, szTemp); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Close <br> * <br> * Purpose: <br> *  Forces the object to close down its user interface and unload. <br> * <br> * Parameters: <br> *  dwSaveOption    DWORD describing the circumstances under which <br> *                  the object is being saved and closed. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Close(DWORD dwSaveOption) <br>    { <br>    HWND        hWnd; <br>    BOOL        fSave=FALSE; <br> <br>    hWnd=m_pObj-&gt;m_hDlg; <br> <br>    //If object is dirty and we're asked to save, save it and close. <br>    if (OLECLOSE_SAVEIFDIRTY==dwSaveOption &amp;&amp; m_pObj-&gt;m_fDirty) <br>        fSave=TRUE; <br> <br>    /* <br>     * If asked to prompt, only do so if dirty, then if we get a <br>     * YES, save as usual and close.  On NO, just close.  On <br>     * CANCEL return OLE_E_PROMPTSAVECANCELLED. <br>     */ <br>    if (OLECLOSE_PROMPTSAVE==dwSaveOption &amp;&amp; m_pObj-&gt;m_fDirty) <br>        { <br>        TCHAR       szTitle[20]; <br>        TCHAR       szTemp[80]; <br>        UINT        uRet; <br> <br>        lstrcpy(szTitle, m_pObj-&gt;String(IDS_CLOSECAPTION)); <br>        lstrcpy(szTemp, m_pObj-&gt;String(IDS_CLOSEPROMPT)); <br> <br>        uRet=MessageBox(hWnd, szTemp, szTitle, MB_YESNOCANCEL); <br> <br>        if (IDCANCEL==uRet) <br>            return ResultFromScode(OLE_E_PROMPTSAVECANCELLED); <br> <br>        if (IDYES==uRet) <br>            fSave=TRUE; <br>        } <br> <br>    if (fSave) <br>        { <br>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVEOBJECT); <br>        m_pObj-&gt;SendAdvise(OBJECTCODE_SAVED); <br>        } <br> <br>    //We get directly here on OLECLOSE_NOSAVE. <br>    //CHAPTER21MOD <br>    if (m_pObj-&gt;m_fLockContainer) <br>        { <br>        //Match LockContainer call from SetClientSite <br>        LPOLECONTAINER  pIOleCont; <br> <br>        if (SUCCEEDED(m_pObj-&gt;m_pIOleClientSite <br>            -&gt;GetContainer(&amp;pIOleCont))) <br>            { <br>            pIOleCont-&gt;LockContainer(FALSE); <br>            pIOleCont-&gt;Release(); <br>            m_pObj-&gt;m_fLockContainer=FALSE; <br>            } <br>        } <br>    //End CHAPTER21MOD <br> <br>    if (NULL!=hWnd) <br>        { <br>        //This hides the window and sends the appropriate notify. <br>        DoVerb(OLEIVERB_HIDE, NULL, NULL, -1, NULL, NULL); <br> <br>        m_pObj-&gt;SendAdvise(OBJECTCODE_CLOSED); <br>        PostMessage(hWnd, POLYM_CLOSE, 0, 0L); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::DoVerb <br> * <br> * Purpose: <br> *  Executes an object-defined action. <br> * <br> * Parameters: <br> *  iVerb           LONG index of the verb to execute. <br> *  pMSG            LPMSG describing the event causing the <br> *                  activation. <br> *  pActiveSite     LPOLECLIENTSITE to the site involved. <br> *  lIndex          LONG the piece on which execution is happening. <br> *  hWndParent      HWND of the window in which the object can play <br> *                  in-place. <br> *  pRectPos        LPRECT of the object in hWndParent where the <br> *                  object can play in-place if desired. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::DoVerb(LONG iVerb, LPMSG pMSG <br>    , LPOLECLIENTSITE pActiveSite, LONG lIndex, HWND hWndParent <br>    , LPCRECT pRectPos) <br>    { <br>    HRESULT     hr; <br> <br>    switch (iVerb) <br>        { <br>        case OLEIVERB_HIDE: <br>            if (NULL!=m_pObj-&gt;m_hDlg) <br>                { <br>                ShowWindow(m_pObj-&gt;m_hDlg, SW_HIDE); <br>                m_pObj-&gt;SendAdvise(OBJECTCODE_HIDEWINDOW); <br>                } <br> <br>            break; <br> <br>        case OLEIVERB_PRIMARY: <br>        case OLEIVERB_OPEN: <br>        case OLEIVERB_SHOW: <br>            /* <br>             * If we're not running, make sure we are.  In any <br>             * case, make the dialog visible and insure it has <br>             * the right parent now. <br>             */ <br>            hr=NOERROR; <br>            if (NULL==m_pObj-&gt;m_hDlg) <br>                hr=m_pObj-&gt;m_pImpIRunnableObject-&gt;Run(NULL); <br> <br>            if (FAILED(hr) || NULL==m_pObj-&gt;m_hDlg) <br>                return ResultFromScode(E_OUTOFMEMORY); <br> <br>            ShowWindow(m_pObj-&gt;m_hDlg, SW_SHOW); <br>            SetFocus(m_pObj-&gt;m_hDlg); <br>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWOBJECT); <br>            m_pObj-&gt;SendAdvise(OBJECTCODE_SHOWWINDOW); <br> <br>            break; <br> <br>        default: <br>            return ResultFromScode(OLEOBJ_S_INVALIDVERB); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetUserClassID <br> * <br> * Purpose: <br> *  Used for linked objects, this returns the class ID of what end <br> *  users think they are editing. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store the CLSID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetUserClassID(LPCLSID pClsID) <br>    { <br>    /* <br>     * If you are not registered to handle data other than yourself, <br>     * then you can just return your class ID here.  If you are <br>     * registered as usable from Treat-As dialogs, then you need to <br>     * return the CLSID of what you are really editing. <br>     */ <br> <br>    *pClsID=CLSID_Polyline19; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::SetExtent <br> * <br> * Purpose: <br> *  Sets the size of the object in HIMETRIC units.  Since we're in <br> *  a dialog, the size of the object in us is fixed, so we ignore <br> *  this call. <br> * <br> * Parameters: <br> *  dwAspect        DWORD of the aspect affected. <br> *  pszl            LPSIZEL containing the new size. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetExtent(DWORD dwAspect <br>    , LPSIZEL pszl) <br>    { <br>    //Ignored:  no size change in the dialog. <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::GetExtent <br> * <br> * Purpose: <br> *  Retrieves the size of the object in HIMETRIC units. <br> * <br> * Parameters: <br> *  dwAspect        DWORD of the aspect requested <br> *  pszl            LPSIZEL into which to store the size. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetExtent(DWORD dwAspect, LPSIZEL pszl) <br>    { <br>    //Delegate directly to IViewObject2::GetExtent <br>    return m_pObj-&gt;m_pImpIViewObject-&gt;GetExtent(dwAspect, -1 <br>        , NULL, pszl); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleObject::Advise <br> * CImpIOleObject::Unadvise <br> * CImpIOleObject::EnumAdvise <br> * <br> * Purpose: <br> *  Advisory connection functions. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::Advise(LPADVISESINK pIAdviseSink <br>    , LPDWORD pdwConn) <br>    { <br>    if (NULL==m_pObj-&gt;m_pIOleAdviseHolder) <br>        { <br>        HRESULT     hr; <br> <br>        hr=CreateOleAdviseHolder(&amp;m_pObj-&gt;m_pIOleAdviseHolder); <br> <br>        if (FAILED(hr)) <br>            return hr; <br>        } <br> <br>    return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Advise(pIAdviseSink <br>        , pdwConn); <br>    } <br> <br> <br>STDMETHODIMP CImpIOleObject::Unadvise(DWORD dwConn) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder) <br>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;Unadvise(dwConn); <br> <br>    return ResultFromScode(E_FAIL); <br>    } <br> <br> <br>STDMETHODIMP CImpIOleObject::EnumAdvise(LPENUMSTATDATA *ppEnum) <br>    { <br>    if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder) <br>        return m_pObj-&gt;m_pIOleAdviseHolder-&gt;EnumAdvise(ppEnum); <br> <br>    return ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br>//CHAPTER21MOD <br>/* <br> * CImpIOleObject::SetMoniker <br> * <br> * Purpose: <br> *  Informs the object of its moniker or its container's moniker <br> *  depending on dwWhich. <br> * <br> * Parameters: <br> *  dwWhich         DWORD describing whether the moniker is the <br> *                  object's or the container's. <br> *  pmk             LPMONIKER with the name. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::SetMoniker(DWORD dwWhich <br>    , LPMONIKER pmk) <br>    { <br>    LPMONIKER       pmkFull; <br>    HRESULT         hr=ResultFromScode(E_FAIL); <br> <br>    /* <br>     * For an embedded object we might be living in a container that <br>     * has given us away as a link.  This is our indication to <br>     * register the full moniker for this object that we obtain from <br>     * IOleClientSite::GetMoniker(OLEWHICHMK_FULL). <br>     */ <br> <br>    if (NULL!=m_pObj-&gt;m_pIOleClientSite) <br>        { <br>        hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetMoniker <br>            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL <br>            , &amp;pmkFull); <br>        } <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        /* <br>         * If this moniker is already running then we don't <br>         * need to revoke and re-register the same thing again. <br>         */ <br>        if (NOERROR==pmkFull-&gt;IsRunning(NULL, NULL, NULL)) <br>            { <br>            pmkFull-&gt;Release(); <br>            return NOERROR; <br>            } <br> <br>        //This will revoke the old one if m_dwRegROT is nonzero. <br>        INOLE_RegisterAsRunning(m_pObj, pmkFull, 0 <br>            , &amp;m_pObj-&gt;m_dwRegROT); <br> <br>        //Inform clients of the new moniker <br>        if (NULL!=m_pObj-&gt;m_pIOleAdviseHolder) <br>            m_pObj-&gt;m_pIOleAdviseHolder-&gt;SendOnRename(pmkFull); <br> <br>        pmkFull-&gt;Release(); <br>        } <br> <br>    return hr; <br>    } <br> <br> <br> <br>/* <br> * CImpIOleObject::GetMoniker <br> * <br> * Purpose: <br> *  Asks the object for a moniker that can later be used to <br> *  reconnect to it. <br> * <br> * Parameters: <br> *  dwAssign        DWORD determining how to assign the moniker to <br> *                  to the object. <br> *  dwWhich         DWORD describing which moniker the caller wants. <br> *  ppmk            LPMONIKER * into which to store the moniker. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleObject::GetMoniker(DWORD dwAssign <br>    , DWORD dwWhich, LPMONIKER *ppmk) <br>    { <br>    HRESULT         hr=ResultFromScode(E_FAIL); <br> <br>    *ppmk=NULL; <br> <br>    /* <br>     * Since we only support embedded objects, our moniker <br>     * is always the full moniker from the contianer. <br>     */ <br> <br>    if (NULL!=m_pObj-&gt;m_pIOleClientSite) <br>        { <br>        hr=m_pObj-&gt;m_pIOleClientSite-&gt;GetMoniker <br>            (OLEGETMONIKER_ONLYIFTHERE, OLEWHICHMK_OBJFULL, ppmk); <br>        } <br> <br>    return (NULL!=*ppmk) ? NOERROR : hr; <br>    } <br> <br> <br> <br>//Methods not implemented or trivial <br>STDMETHODIMP CImpIOleObject::InitFromData(LPDATAOBJECT pIDataObject <br>    , BOOL fCreation, DWORD dw) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br>STDMETHODIMP CImpIOleObject::GetClipboardData(DWORD dwReserved <br>    , LPDATAOBJECT *ppIDataObj) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br>STDMETHODIMP CImpIOleObject::Update(void) <br>    { <br>    return NOERROR; <br>    } <br> <br>STDMETHODIMP CImpIOleObject::IsUpToDate(void) <br>    { <br>    return NOERROR; <br>    } <br> <br>STDMETHODIMP CImpIOleObject::SetColorScheme(LPLOGPALETTE pLP) <br>    { <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br>//End CHAPTER21MOD <br> <br> <br> <br>//Methods implemented using registry helper functions in OLE. <br> <br>STDMETHODIMP CImpIOleObject::EnumVerbs(LPENUMOLEVERB *ppEnum) <br>    { <br>    return OleRegEnumVerbs(m_pObj-&gt;m_clsID, ppEnum); <br>    } <br> <br>STDMETHODIMP CImpIOleObject::GetUserType(DWORD dwForm <br>    , LPOLESTR *ppszType) <br>    { <br>    return OleRegGetUserType(m_pObj-&gt;m_clsID, dwForm, ppszType); <br>    } <br> <br>STDMETHODIMP CImpIOleObject::GetMiscStatus(DWORD dwAspect <br>    , LPDWORD pdwStatus) <br>    { <br>    return OleRegGetMiscStatus(m_pObj-&gt;m_clsID, dwAspect <br>        , pdwStatus); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
