<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DOCUMENT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context902"></a>DOCUMENT.CPP</h2>
<pre><code>/* <br> * DOCUMENT.CPP <br> * Patron Chapter 21 <br> * <br> * Implementation of the CPatronDoc derivation of CDocument that <br> * manages pages for us. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br>#include &lt;memory.h&gt; <br>#include &lt;dlgs.h&gt;       //Pring Dlg button IDs <br> <br> <br>/* <br> * CPatronDoc::CPatronDoc <br> * CPatronDoc::~CPatronDoc <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application. <br> *  pFR             PCFrame of the frame object. <br> *  pAdv            PCDocumentAdviseSink to notify on events. <br> */ <br> <br>CPatronDoc::CPatronDoc(HINSTANCE hInst, PCFrame pFR <br>    , PCDocumentAdviseSink pAdv) <br>    : CDocument(hInst, pFR, pAdv) <br>    { <br>    m_pPG=NULL; <br>    m_lVer=VERSIONCURRENT; <br>    m_pIStorage=NULL; <br>    m_fPrintSetup=TRUE; <br>    m_pDropTarget=NULL; <br> <br>    //These CFSTR_* values are standard (defined in INC\CLASSLIB.H) <br>    m_cfEmbeddedObject=RegisterClipboardFormat <br>        (CFSTR_EMBEDDEDOBJECT); <br>    m_cfObjectDescriptor=RegisterClipboardFormat <br>        (CFSTR_OBJECTDESCRIPTOR); <br> <br>    //CHAPTER20MOD <br>    m_cfLinkSource=RegisterClipboardFormat(CFSTR_LINKSOURCE); <br>    m_cfLinkSrcDescriptor=RegisterClipboardFormat <br>        (CFSTR_LINKSRCDESCRIPTOR); <br> <br>    m_fShowTypes=FALSE; <br> <br>    //CHAPTER21MOD <br>    m_cRef=1L; <br>    m_fRename=TRUE; <br>    m_dwRegROT=0L; <br>    m_dwRegROTWild=0L; <br>    m_pImpIPersistFile=NULL; <br>    m_pImpIOleItemContainer=NULL; <br>    //End CHAPTER21MOD <br> <br>    return; <br>    } <br> <br> <br>CPatronDoc::~CPatronDoc(void) <br>    { <br>    //CHAPTER21MOD <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROTWild); <br> <br>    DeleteInterfaceImp(m_pImpIPersistFile); <br>    DeleteInterfaceImp(m_pImpIOleItemContainer); <br>    //End CHAPTER21MOD <br> <br>    if (NULL!=m_pPG) <br>        delete m_pPG; <br> <br>    ReleaseInterface(m_pIStorage); <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER21MOD <br> <br>/* <br> * CPatronDoc::QueryInterface <br> * CPatronDoc::AddRef <br> * CPatronDoc::Release <br> */ <br> <br>STDMETHODIMP CPatronDoc::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    /* <br>     * WARNING:  Because the *ppv=this implicitly does <br>     * *ppv=(LPVOID)this, the this pointer is incorrectly cast <br>     * from a CPatronDoc pointer to LPVOID where we want an <br>     * IUnknown pointer instead.  CPatronDoc uses multiple <br>     * inheritance here which means that we have to explicitly <br>     * provide the typecast to select the base class like <br>     * IUnknown.  If you don't do this, calls to AddRef, for <br>     * example, might call your desctructor! <br>     */ <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=(LPUNKNOWN)this; <br> <br>    if (IID_IOleItemContainer==riid || IID_IOleContainer==riid <br>        || IID_IParseDisplayName==riid) <br>        *ppv=m_pImpIOleItemContainer; <br> <br>    if (IID_IPersistFile==riid || IID_IPersist==riid) <br>        *ppv=m_pImpIPersistFile; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CPatronDoc::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CPatronDoc::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    PostMessage(m_hWnd, WM_CLOSE, 0, 0); <br>    return 0; <br>    } <br>//End CHAPTER21MOD <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Init <br> * <br> * Purpose: <br> *  Initializes an already created document window.  The client <br> *  actually creates the window for us, then passes that here for <br> *  further initialization. <br> * <br> * Parameters: <br> *  pDI             PDOCUMENTINIT containing initialization <br> *                  parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::Init(PDOCUMENTINIT pDI) <br>    { <br>    //Change the stringtable range to our customization. <br>    pDI-&gt;idsMin=IDS_DOCUMENTMIN; <br>    pDI-&gt;idsMax=IDS_DOCUMENTMAX; <br> <br>    //Do default initialization <br>    if (!CDocument::Init(pDI)) <br>        return FALSE; <br> <br>    //Pages are created when we get a Load later. <br> <br>    //CHAPTER21MOD <br>    //Instantiate our interfaces <br>    m_pImpIPersistFile=new CImpIPersistFile(this, this); <br> <br>    if (NULL==m_pImpIPersistFile) <br>        return FALSE; <br> <br>    m_pImpIOleItemContainer=new CImpIOleItemContainer(this, this <br>        , TRUE); <br> <br>    if (NULL==m_pImpIOleItemContainer) <br>        return FALSE; <br> <br>    //End CHAPTER21MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FMessageHook <br> * <br> * Purpose: <br> *  Processes WM_SIZE for the document so we can resize the Pages <br> *  window. <br> * <br> * Parameters: <br> *  &lt;WndProc Parameters&gt; <br> *  pLRes           LRESULT * in which to store the return <br> *                  value for the message. <br> * <br> * Return Value: <br> *  BOOL            TRUE to prevent further processing, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FMessageHook(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam, LRESULT *pLRes) <br>    { <br>    UINT        dx, dy; <br>    RECT        rc; <br> <br>    *pLRes=0; <br> <br>    //Eat to prevent flickering <br>    if (WM_ERASEBKGND==iMsg) <br>        return TRUE; <br> <br>    if (WM_SIZE==iMsg &amp;&amp; NULL!=m_pPG) <br>        { <br>        dx=LOWORD(lParam); <br>        dy=HIWORD(lParam); <br> <br>        if (SIZE_MINIMIZED!=wParam) <br>            { <br>            //Resize Pages window to fit the new document size. <br>            GetClientRect(hWnd, &amp;rc); <br>            m_pPG-&gt;RectSet(&amp;rc, FALSE); <br>            } <br>        } <br> <br>    if (WM_DESTROY==iMsg) <br>        { <br>        /* <br>         * We have to revoke the drop target here because the window <br>         * will be destroyed and the property forcefully removed <br>         * before we could do this in the destructor. <br>         */ <br>        if (NULL!=m_pDropTarget) <br>            { <br>            RevokeDragDrop(m_hWnd); <br>            CoLockObjectExternal(m_pDropTarget, FALSE, TRUE); <br>            m_pDropTarget-&gt;Release(); <br>            } <br> <br>        return FALSE; <br>        } <br> <br>    /* <br>     * We return FALSE even on WM_SIZE so we can let the default <br>     * procedure handle maximized MDI child windows appropriately. <br>     */ <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Clear <br> * <br> * Purpose: <br> *  Sets all contents in the document back to defaults with no <br> *  filename. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Clear(void) <br>    { <br>    //Completely reset the pages <br>    if (NULL!=m_pPG) <br>        m_pPG-&gt;StorageSet(NULL, FALSE, FALSE); <br> <br>    CDocument::Clear(); <br>    m_lVer=VERSIONCURRENT; <br>    return; <br>    } <br> <br> <br> <br>//CHAPTER21MOD <br>/* <br> * CPatronDoc::FDirtySet <br> * <br> * Purpose: <br> *  Sets or clears the document 'dirty' flag returning the previous <br> *  state of that same flag.  We override this to note change <br> *  times in the running object table. <br> * <br> * Parameters: <br> *  fDirty          BOOL indicating the new contents of the dirty <br> *                  flag. <br> * <br> * Return Value: <br> *  BOOL            Previous value of the dirty flag. <br> */ <br> <br>BOOL CPatronDoc::FDirtySet(BOOL fDirty) <br>    { <br>    BOOL        fRet; <br> <br>    fRet=CDocument::FDirtySet(fDirty); <br>    INOLE_NoteChangeTime(m_dwRegROT, NULL, NULL); <br>    INOLE_NoteChangeTime(m_dwRegROTWild, NULL, NULL); <br> <br>    return fRet; <br>    } <br>//End CHAPTER21MOD <br> <br> <br> <br>/* <br> * CPatronDoc::FDirtyGet <br> * <br> * Purpose: <br> *  Returns the current dirty status of the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the file is clean, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FDirtyGet() <br>    { <br>    BOOL    fPageDirty; <br> <br>    fPageDirty=m_pPG-&gt;FIsDirty(); <br>    return m_fDirty | fPageDirty; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Delete <br> * <br> * Purpose: <br> *  Removed the current object from the document. <br> * <br> * Paramters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Delete(void) <br>    { <br>    if (NULL!=m_pPG) <br>        m_pPG-&gt;TenantDestroy(); <br> <br>    CoFreeUnusedLibraries(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryObjectSelected <br> * <br> * Purpose: <br> *  Returns whether or not there is an object selected in this <br> *  document for Cut, Copy, Delete functions. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the Edit menu. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have an object, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryObjectSelected(HMENU hMenu) <br>    { <br>    return m_pPG-&gt;FQueryObjectSelected(hMenu); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Load <br> * <br> * Purpose: <br> *  Loads a given document without any user interface overwriting <br> *  the previous contents of the editor. <br> * <br> * Parameters: <br> *  fChangeFile     BOOL indicating if we're to update the window <br> *                  title and the filename from using this file. <br> *  pszFile         LPTSTR to the filename to load.  Could be NULL <br> *                  for an untitled document. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CPatronDoc::Load(BOOL fChangeFile, LPTSTR pszFile) <br>    { <br>    RECT        rc; <br>    LPSTORAGE   pIStorage; <br>    HRESULT     hr; <br>    CLSID       clsID; <br>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                    | STGM_SHARE_EXCLUSIVE; <br>    //CHAPTER21MOD <br>    LPMONIKER   pmk; <br>    //End CHAPTER21MOD <br> <br>    if (NULL==pszFile) <br>        { <br>        //Create a new temp file. <br>        hr=StgCreateDocfile(NULL, dwMode | STGM_CREATE <br>            | STGM_DELETEONRELEASE, 0, &amp;pIStorage); <br> <br>        //Mark this our class since we check with ReadClassStg. <br>        if (SUCCEEDED(hr)) <br>            WriteClassStg(pIStorage, CLSID_PatronPages); <br>        } <br>    else <br>        { <br>        hr=StgOpenStorage(pszFile, NULL, dwMode, NULL, 0, &amp;pIStorage); <br>        } <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    //Check if this is our type of file and exit if not. <br>    hr=ReadClassStg(pIStorage, &amp;clsID); <br> <br>    if (FAILED(hr) || CLSID_PatronPages!=clsID) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //Attempt to create our contained Pages window. <br>    m_pPG=new CPages(m_hInst, m_cf); <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    if (!m_pPG-&gt;Init(m_hWnd, &amp;rc, WS_CHILD | WS_VISIBLE <br>        , ID_PAGES, NULL)) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //CHAPTER21MOD <br>    /* <br>     * This moniker registration insures that all the file opening <br>     * sequence will see this instance of the document as running <br>     * and be able to communicate with it.  This is so a link to <br>     * an embedding on the same page of this document will hook <br>     * up correctly. <br>     */ <br>    if (NULL!=pszFile) <br>        { <br>        CreateFileMoniker(pszFile, &amp;pmk); <br> <br>        if (NULL!=pmk) <br>            { <br>            //This will be revoked and re-registered in Rename below <br>            INOLE_RegisterAsRunning(this, pmk, 0, &amp;m_dwRegROT); <br>            pmk-&gt;Release(); <br>            } <br>        } <br>    //End CHAPTER21MOD <br> <br>    if (!m_pPG-&gt;StorageSet(pIStorage, FALSE, (NULL==pszFile))) <br>        { <br>        pIStorage-&gt;Release(); <br>        return DOCERR_READFAILURE; <br>        } <br> <br>    //Open the window up for drag-drop <br>    m_pDropTarget=new CDropTarget(this); <br> <br>    if (NULL!=m_pDropTarget) <br>        { <br>        m_pDropTarget-&gt;AddRef(); <br>        CoLockObjectExternal(m_pDropTarget, TRUE, FALSE); <br>        RegisterDragDrop(m_hWnd, m_pDropTarget); <br>        } <br> <br>    m_pIStorage=pIStorage; <br>    Rename(pszFile); <br> <br>    //Do initial setup if new file, otherwise Pages handles things. <br>    if (NULL==pszFile) <br>        { <br>        //Go initialize the Pages for the default printer. <br>        if (!PrinterSetup(NULL, TRUE)) <br>            return DOCERR_COULDNOTOPEN; <br> <br>        //Go create an initial page. <br>        m_pPG-&gt;PageInsert(0); <br>        } <br>    else <br>        { <br>        //Can't change an already saved configuration <br>        m_fPrintSetup=FALSE; <br>        } <br> <br>    FDirtySet(FALSE); <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Save <br> * <br> * Purpose: <br> *  Writes the file to a known filename, requiring that the user <br> *  has previously used FileOpen or FileSaveAs in order to have <br> *  a filename. <br> * <br> * Parameters: <br> *  uType           UINT indicating the type of file the user <br> *                  requested to save in the File Save As dialog. <br> *  pszFile         LPTSTR under which to save.  If NULL, use the <br> *                  current name. <br> * <br> * Return Value: <br> *  UINT            An error value from DOCERR_* <br> */ <br> <br>UINT CPatronDoc::Save(UINT uType, LPTSTR pszFile) <br>    { <br>    HRESULT     hr; <br>    LPSTORAGE   pIStorage; <br> <br>    //Save or Save As with the same file is just a commit. <br>    if (NULL==pszFile <br>        || (NULL!=pszFile &amp;&amp; 0==lstrcmpi(pszFile, m_szFile))) <br>        { <br>        WriteFmtUserTypeStg(m_pIStorage, m_cf <br>            , PSZ(IDS_CLIPBOARDFORMAT)); <br> <br>        //Insure pages are up to date. <br>        m_pPG-&gt;StorageUpdate(FALSE); <br> <br>        //Commit everyting <br>        m_pIStorage-&gt;Commit(STGC_DEFAULT); <br> <br>        FDirtySet(FALSE); <br>        return DOCERR_NONE; <br>        } <br> <br>    /* <br>     * When we're given a name, open the storage, creating it new <br>     * if it does not exist or overwriting the old one.  Then CopyTo <br>     * from the current to the new, Commit the new, Release the old. <br>     */ <br> <br>    hr=StgCreateDocfile(pszFile, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return DOCERR_COULDNOTOPEN; <br> <br>    WriteClassStg(pIStorage, CLSID_PatronPages); <br>    WriteFmtUserTypeStg(pIStorage, m_cf, PSZ(IDS_CLIPBOARDFORMAT)); <br> <br>    //Insure all pages are up-to-date. <br>    m_pPG-&gt;StorageUpdate(TRUE); <br> <br>    //This also copies the CLSID we stuff in here on file creation. <br>    hr=m_pIStorage-&gt;CopyTo(NULL, NULL, NULL, pIStorage); <br> <br>    if (FAILED(hr)) <br>        { <br>        SCODE       sc; <br> <br>        pIStorage-&gt;Release(); <br>        sc=GetScode(hr); <br> <br>        /* <br>         * If we failed because of low memory, use IRootStorage <br>         * to switch into the new file. <br>         */ <br>        if (E_OUTOFMEMORY==sc) <br>            { <br>            LPROOTSTORAGE        pIRoot; <br> <br>            //Delete file we already created <br>            DeleteFile(pszFile); <br> <br>            if (FAILED(m_pIStorage-&gt;QueryInterface <br>                (IID_IRootStorage, (PPVOID)&amp;pIRoot))) <br>                return DOCERR_WRITEFAILURE; <br> <br>           #ifdef WIN32ANSI <br>            OLECHAR     szTemp[MAX_PATH]; <br> <br>            MultiByteToWideChar(CP_ACP, 0, pszFile, -1, szTemp, MAX_PATH); <br>            hr=pIRoot-&gt;SwitchToFile(szTemp); <br>           #else <br>            hr=pIRoot-&gt;SwitchToFile(pszFile); <br>           #endif <br>            pIRoot-&gt;Release(); <br> <br>            if (FAILED(hr)) <br>                return DOCERR_WRITEFAILURE; <br> <br>            //If successful, the Commit below finishes the save. <br>            pIStorage=m_pIStorage; <br>            m_pIStorage-&gt;AddRef();    //Matches Release below <br>            } <br>        } <br> <br>    //CHAPTER21MOD <br>    if (m_fRename) <br>        Rename(pszFile);    //Update caption bar. <br>    //End CHAPTER21MOD <br> <br>    pIStorage-&gt;Commit(STGC_DEFAULT); <br> <br>    /* <br>     * Revert changes on the original storage.  If this was a temp <br>     * file, it's deleted since we used STGM_DELETEONRELEASE. <br>     */ <br>    m_pIStorage-&gt;Release(); <br> <br>    //Make this new storage current <br>    m_pIStorage=pIStorage; <br>    m_pPG-&gt;StorageSet(pIStorage, TRUE, FALSE); <br> <br>    FDirtySet(FALSE); <br> <br>    return DOCERR_NONE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Clip <br> * <br> * Purpose: <br> *  Places a private format, a metafile, and a bitmap of the display <br> *  on the clipboard, optionally implementing Cut by deleting the <br> *  data in the current window after rendering. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> *  fCut            BOOL indicating cut (TRUE) or copy (FALSE). <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::Clip(HWND hWndFrame, BOOL fCut) <br>    { <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    return m_pPG-&gt;TenantClip(fCut); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Paste <br> * <br> * Purpose: <br> *  Retrieves the private data format from the clipboard and sets it <br> *  to the current figure in the editor window. <br> * <br> *  Note that if this function is called, then the clipboard format <br> *  is available because the Paste menu item is only enabled if the <br> *  format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::Paste(HWND hWndFrame) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet=FALSE; <br>    FORMATETC       fe; <br>    TENANTTYPE      tType; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    //Go get type and format we *can* paste, then actually paste it. <br>    if (FQueryPasteFromData(pIDataObject, &amp;fe, &amp;tType)) <br>        { <br>        fRet=PasteFromData(pIDataObject, &amp;fe, tType, NULL <br>            , 0L, TRUE); <br>        } <br> <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPaste <br> * <br> * Purpose: <br> *  Determines if we can paste data from the clipboard. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPaste(void) <br>    { <br>    LPDATAOBJECT    pIDataObject; <br>    BOOL            fRet; <br> <br>    if (FAILED(OleGetClipboard(&amp;pIDataObject))) <br>        return FALSE; <br> <br>    fRet=FQueryPasteFromData(pIDataObject, NULL, NULL); <br> <br>    fRet |= FQueryPasteLinkFromData(pIDataObject, NULL, NULL); <br>    pIDataObject-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PasteSpecial <br> * <br> * Purpose: <br> *  Retrieves a specific data format from the clipboard and sends <br> *  it to the editor window appropriately. <br> * <br> *  Note that if this function is called, then the appropriate <br> *  format is available because the Paste menu item is only <br> *  enabled if the format is present. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::PasteSpecial(HWND hWndFrame) <br>    { <br>    OLEUIPASTESPECIAL   ps; <br>    OLEUIPASTEENTRY     rgPaste[6]; <br>    UINT                rgcf[1];        //For ps.m_arrLinkTypes <br>    DWORD               dwData=0; <br>    UINT                uTemp; <br>    BOOL                fRet=FALSE; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    memset(&amp;ps, 0, sizeof(ps)); <br> <br>    if (FAILED(OleGetClipboard(&amp;ps.lpSrcDataObj))) <br>        return FALSE; <br> <br>    ps.cbStruct=sizeof(ps); <br>    ps.hWndOwner=hWndFrame; <br> <br>    ps.dwFlags=PSF_SELECTPASTE; <br>    ps.arrPasteEntries=rgPaste; <br> <br>    //Set up Paste Special descriptor arrays. <br>    SETDefFormatEtc(rgPaste[0].fmtetc, m_cf, TYMED_HGLOBAL); <br>    rgPaste[0].lpstrFormatName=PSZ(IDS_CLIPBOARDFORMAT); <br>    rgPaste[0].lpstrResultText=PSZ(IDS_PASTEASPATRON); <br>    rgPaste[0].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    //Embedded objects can be iconic displays if the user wants. <br>    SETDefFormatEtc(rgPaste[1].fmtetc, m_cfEmbeddedObject <br>        , TYMED_ISTORAGE); <br>    rgPaste[1].lpstrFormatName=PSZ(IDS_PASTEOBJECT); <br>    rgPaste[1].lpstrResultText=PSZ(IDS_PASTEASOBJECT); <br> <br>    /* <br>     * CAUTION:  Use OLEUI_PASTE with embedded objects or else <br>     * this item will not show up in the dialog.  I learned this the <br>     * hard way (that is, after about 6 hours of pulling hair!). <br>     */ <br>    rgPaste[1].dwFlags=OLEUIPASTE_PASTE | OLEUIPASTE_ENABLEICON; <br> <br> <br>    SETDefFormatEtc(rgPaste[2].fmtetc,CF_METAFILEPICT,TYMED_MFPICT); <br>    rgPaste[2].lpstrFormatName=PSZ(IDS_PASTEMETAFILE); <br>    rgPaste[2].lpstrResultText=PSZ(IDS_PASTEASMETAFILE); <br>    rgPaste[2].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    SETDefFormatEtc(rgPaste[3].fmtetc, CF_DIB, TYMED_HGLOBAL); <br>    rgPaste[3].lpstrFormatName=PSZ(IDS_PASTEDIB); <br>    rgPaste[3].lpstrResultText=PSZ(IDS_PASTEASDIB); <br>    rgPaste[3].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    SETDefFormatEtc(rgPaste[4].fmtetc, CF_BITMAP, TYMED_GDI); <br>    rgPaste[4].lpstrFormatName=PSZ(IDS_PASTEBITMAP); <br>    rgPaste[4].lpstrResultText=PSZ(IDS_PASTEASBITMAP); <br>    rgPaste[4].dwFlags=OLEUIPASTE_PASTEONLY; <br> <br>    SETDefFormatEtc(rgPaste[5].fmtetc,m_cfLinkSource,TYMED_ISTREAM); <br>    rgPaste[5].lpstrFormatName=PSZ(IDS_PASTELINK); <br>    rgPaste[5].lpstrResultText=PSZ(IDS_PASTEASLINK); <br>    rgPaste[5].dwFlags=OLEUIPASTE_LINKTYPE1 | OLEUIPASTE_ENABLEICON; <br> <br>    //Types we can Paste Link from the clipboard. <br>    rgcf[0]=m_cfLinkSource; <br>    ps.arrLinkTypes=rgcf; <br>    ps.cLinkTypes=1; <br>    ps.cPasteEntries=6; <br> <br>    uTemp=OleUIPasteSpecial(&amp;ps); <br> <br>    if (OLEUI_OK==uTemp) <br>        { <br>        UINT        i=ps.nSelectedIndex; <br>        TENANTTYPE  tType; <br> <br>        if (ps.fLink) <br>            tType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br>        else <br>            { <br>            if (1==ps.nSelectedIndex) <br>                tType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br>            else <br>                tType=TENANTTYPE_STATIC; <br>            } <br> <br>        //Handle iconic aspects...from links as well <br>        if ((1==i || ps.fLink) &amp;&amp; (PSF_CHECKDISPLAYASICON <br>            &amp; ps.dwFlags) &amp;&amp; NULL!=ps.hMetaPict) <br>            { <br>            rgPaste[i].fmtetc.dwAspect=DVASPECT_ICON; <br>            dwData=(DWORD)(UINT)ps.hMetaPict; <br>            } <br> <br>        fRet=PasteFromData(ps.lpSrcDataObj, &amp;rgPaste[i].fmtetc <br>            , tType, NULL, dwData, FALSE); <br> <br>        //Always free this regardless of what we do with it. <br>        INOLE_MetafilePictIconFree(ps.hMetaPict); <br>        } <br> <br>    ps.lpSrcDataObj-&gt;Release(); <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste data from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> *  pFE             LPFORMATETC in which to return the first format <br> *                  we can use.  Ignored if NULL. <br> *  ptType          PTENANTTYPE in which to store the type of <br> *                  object we can paste.  Ignored if NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPasteFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, PTENANTTYPE ptType) <br>    { <br>    FORMATETC       fe; <br>    HRESULT         hr, hr2; <br> <br>    if (NULL!=(LPVOID)ptType) <br>        *ptType=TENANTTYPE_STATIC; <br> <br>    //Any of our specific data here? <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>    //If embedded object data is available, set the appropriate type <br>    hr2=OleQueryCreateFromData(pIDataObject); <br> <br>    if (NOERROR==hr2) <br>        { <br>        if (NULL!=pFE) <br>            { <br>            /* <br>             * Default to content.  Paste will use <br>             * CFSTR_OBJECTDESCRIPTOR to figure the actual aspect. <br>             */ <br>            SETDefFormatEtc(*pFE, m_cfEmbeddedObject <br>                , TYMED_ISTORAGE); <br>            } <br> <br>        if (NULL!=(LPVOID)ptType) <br>            *ptType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br> <br>        /* <br>         * Return now if PatronObject wasn't available, otherwise <br>         * break out so that pFE gets PatronObject format. <br>         */ <br>        if (NOERROR!=hr) <br>            return TRUE; <br>        } <br> <br> <br>    if (NOERROR!=hr &amp;&amp; NOERROR!=hr2) <br>        { <br>        //Try metafile, DIB, then bitmap, setting fe each time <br>        SETDefFormatEtc(fe, CF_METAFILEPICT, TYMED_MFPICT); <br>        hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>        if (NOERROR!=hr) <br>            { <br>            SETDefFormatEtc(fe, CF_DIB, TYMED_HGLOBAL); <br>            hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br> <br>            if (NOERROR!=hr) <br>                { <br>                SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI); <br>                hr=pIDataObject-&gt;QueryGetData(&amp;fe); <br>                } <br>            } <br>        } <br> <br>    if (NOERROR==hr &amp;&amp; NULL!=pFE) <br>        *pFE=fe; <br> <br>    return (NOERROR==hr); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryPasteLinkFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Determines if we can paste link from a data object. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which we might want to paste. <br> *  pFE             LPFORMATETC in which to return the first format <br> *                  we can use.  Ignored if NULL. <br> *  ptType          PTENANTTYPE in which to store the type of object <br> *                  we can paste.  Ignored if NULL. <br> * <br> * Return Value: <br> *  BOOL            TRUE if data is available, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryPasteLinkFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, PTENANTTYPE ptType) <br>    { <br>    HRESULT         hr; <br> <br>    if (NULL==pIDataObject) <br>        return FALSE; <br> <br>    hr=OleQueryLinkFromData(pIDataObject); <br> <br>    if (NOERROR!=hr) <br>        return FALSE; <br> <br>    if (NULL!=pFE) <br>        SETDefFormatEtc(*pFE, m_cfLinkSource, TYMED_ISTREAM); <br> <br>    if (NULL!=(LPVOID)ptType) <br>        *ptType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PasteFromData <br> * (Protected) <br> * <br> * Purpose: <br> *  Retrieves the private data format from a data object and sets <br> *  it to the current figure in the editor window. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> *  pFE             LPFORMATETC to use in the paste. Cannot be NULL. <br> *  tType           TENANTTYPE to paste. <br> *  ppo             PPATRONOBJECT containing placement data. <br> *  dwData          DWORD extra data sensitive to tType <br> *  fUseObjDesc     BOOL indicating to use CFSTR_OBJECTDESCRIPTOR <br> *                  format for determining the aspect of the object <br> *                  if the format is available. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::PasteFromData(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, TENANTTYPE tType, PPATRONOBJECT ppo <br>    , DWORD dwData, BOOL fUseObjDesc) <br>    { <br>    BOOL                fRet; <br>    HRESULT             hr; <br>    PATRONOBJECT        po; <br>    STGMEDIUM           stm; <br>    LPOBJECTDESCRIPTOR  pOD; <br>    FORMATETC           fe; <br>    BOOL                fRelease=FALSE; <br> <br>    if (NULL==pFE) <br>        return FALSE; <br> <br>    //If not given any placement data, see if we can retrieve it <br>    if (pFE-&gt;cfFormat==m_cf &amp;&amp; NULL==ppo) <br>        { <br>        hr=pIDataObject-&gt;GetData(pFE, &amp;stm); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            ppo=(PPATRONOBJECT)GlobalLock(stm.hGlobal); <br> <br>            po=*ppo; <br>            ppo=&amp;po; <br> <br>            //If there's an object here, make sure type is right. <br>            if (ppo-&gt;fe.cfFormat==m_cfEmbeddedObject) <br>                tType=TENANTTYPE_EMBEDDEDOBJECTFROMDATA; <br> <br>            if (ppo-&gt;fe.cfFormat==m_cfLinkSource) <br>                tType=TENANTTYPE_LINKEDOBJECTFROMDATA; <br> <br>            GlobalUnlock(stm.hGlobal); <br>            ReleaseStgMedium(&amp;stm); <br>            } <br>        } <br> <br>    /* <br>     * If we're told to look at CFSTR_OBJECTDESCRIPTOR, then try to get <br>     * the data and copy the aspect out of it.  We're not interested <br>     * in any other part of it, however. <br>     */ <br>    if (fUseObjDesc) <br>        { <br>        SETDefFormatEtc(fe, m_cfObjectDescriptor, TYMED_HGLOBAL); <br> <br>        hr=pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br> <br>        if (FAILED(hr)) <br>            { <br>            SETDefFormatEtc(fe, m_cfLinkSrcDescriptor <br>                , TYMED_HGLOBAL); <br>            hr=pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br>            } <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            pOD=(LPOBJECTDESCRIPTOR)GlobalLock(stm.hGlobal); <br>            pFE-&gt;dwAspect=pOD-&gt;dwDrawAspect; <br> <br>            if (NULL!=ppo) <br>                ppo-&gt;fe.dwAspect=pFE-&gt;dwAspect; <br> <br>            GlobalUnlock(stm.hGlobal); <br>            ReleaseStgMedium(&amp;stm); <br> <br>            /* <br>             * Furthermore, if pFE-&gt;dwAspect is DVASPECT_ICON, get <br>             * the metafile which will always be the icon <br>             * representation. <br>             */ <br>            SETFormatEtc(fe, CF_METAFILEPICT, DVASPECT_ICON, NULL <br>                , TYMED_MFPICT, -1); <br> <br>            if (SUCCEEDED(pIDataObject-&gt;GetData(&amp;fe, &amp;stm))) <br>                { <br>                dwData=(DWORD)(UINT)stm.hGlobal; <br>                fRelease=TRUE; </code></pre>
<p>
</p>
<pre><code>} <br>            } <br>        } <br> <br>    fRet=m_pPG-&gt;TenantCreate(tType, pIDataObject, pFE, ppo, dwData); <br> <br>    //Release the stm from the last GetData <br>    if (fRelease) <br>        ReleaseStgMedium(&amp;stm); <br> <br>    if (fRet) <br>        { <br>        //Disable Printer Setup once we've created a tenant. <br>        m_fPrintSetup=FALSE; <br>        FDirtySet(TRUE); <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FQueryEnableEditLinks <br> * <br> * Purpose: <br> *  Determines whether or not the Edit Links menu item should be <br> *  enabled on the frame window menu. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE to enable the item, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::FQueryEnableEditLinks(void) <br>    { <br>    return m_pPG-&gt;FQueryLinksInPage(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::EditLinks <br> * <br> * Purpose: <br> *  Invokes the links dialog in which the end-user can manipulate <br> *  all the links in the current page. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame window to use as the dialog <br> *                  parent. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function was successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::EditLinks(HWND hWndFrame) <br>    { <br>    UINT                    uRet; <br>    OLEUIEDITLINKS          el; <br>    PCIOleUILinkContainer   pIUILinks; <br> <br>    memset(&amp;el, 0, sizeof(el)); <br>    el.cbStruct=sizeof(el); <br>    el.hWndOwner=hWndFrame; <br> <br>    if (!m_pPG-&gt;GetUILinkContainer(&amp;pIUILinks)) <br>        return FALSE; <br> <br>    el.lpOleUILinkContainer=pIUILinks; <br>    uRet=OleUIEditLinks(&amp;el); <br> <br>    //Only the IOleUILinkContainer interface will know dirtying. <br>    m_fDirty=pIUILinks-&gt;m_fDirty; <br> <br>    el.lpOleUILinkContainer-&gt;Release(); <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CPatronDoc::ShowOrQueryObjectTypes <br> * <br> * Purpose: <br> *  If querying, we return whether or not ShowObjects is active <br> *  in this document.  Otherwise pass-through to <br> *  CPages::ShowObjectTypes. <br> * <br> * Parameters: <br> *  fQuery          BOOL indicating query or set. <br> *  fShow           BOOL indicating to show the type or not. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPatronDoc::ShowOrQueryObjectTypes(BOOL fQuery, BOOL fShow) <br>    { <br>    if (fQuery) <br>        return m_fShowTypes; <br> <br>    m_fShowTypes=fShow; <br>    m_pPG-&gt;ShowObjectTypes(fShow); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NewPage <br> * <br> * Purpose: <br> *  Creates a new page in the document's pages control after the <br> *  current page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NewPage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageInsert(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::DeletePage <br> * <br> * Purpose: <br> *  Deletes the current page from the document. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the now current page. <br> */ <br> <br>UINT CPatronDoc::DeletePage(void) <br>    { <br>    FDirtySet(TRUE); <br>    return m_pPG-&gt;PageDelete(0); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::NextPage <br> * <br> * Purpose: <br> *  Shows the next page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::NextPage(void) <br>    { <br>    UINT        iPage; <br> <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(++iPage); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::PreviousPage <br> * <br> * Purpose: <br> *  Shows the previous page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::PreviousPage(void) <br>    { <br>    UINT        iPage; <br> <br>    //If iPage is zero, then we wrap around to the end. <br>    iPage=m_pPG-&gt;CurPageGet(); <br>    return m_pPG-&gt;CurPageSet(--iPage); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::FirstPage <br> * <br> * Purpose: <br> *  Shows the first page page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the new page. <br> */ <br> <br>UINT CPatronDoc::FirstPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(0); <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::LastPage <br> * <br> * Purpose: <br> *  Shows the last page in the pages window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the last page. <br> */ <br> <br>UINT CPatronDoc::LastPage(void) <br>    { <br>    return m_pPG-&gt;CurPageSet(NOVALUE); <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::Rename <br> * <br> * Purpose: <br> *  Overrides the normal rename to include notification of tenants <br> *  in this document of the new name.  This is so embedded objects <br> *  are told the correct name through IOleObject::SetHostNames. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR to the new filename. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::Rename(LPTSTR pszFile) <br>    { <br>    LPMONIKER   pmk; <br> <br>    //We don't need to change the base class, just augment... <br>    CDocument::Rename(pszFile); <br> <br>    //CHAPTER21MOD <br>    //Unregister the old moniker (m_dwRegROT set to zero). <br>    INOLE_RevokeAsRunning(&amp;m_dwRegROT); <br> <br>    if (NULL==pszFile) <br>        return; <br> <br>    CreateFileMoniker(pszFile, &amp;pmk); <br> <br>    if (NULL!=pmk) <br>        { <br>        LPMONIKER   pmkAll; <br> <br>        INOLE_RegisterAsRunning(this, pmk <br>            , ROTFLAGS_REGISTRATIONKEEPSALIVE, &amp;m_dwRegROT); <br> <br>        //Give a moniker to linked objects in tenants. <br>        m_pPG-&gt;NotifyTenantsOfRename(pszFile, pmk); <br> <br>        //Register a File!"\" wildcard moniker as well <br>        CreateItemMoniker(TEXT("!"), TEXT("\\"), &amp;pmkAll); <br> <br>        if (NULL!=pmkAll) <br>            { <br>            LPMONIKER   pmkWild; <br> <br>            INOLE_RevokeAsRunning(&amp;m_dwRegROTWild); <br>            pmk-&gt;ComposeWith(pmkAll, FALSE, &amp;pmkWild); <br> <br>            if (NULL!=pmkWild) <br>                { <br>                INOLE_RegisterAsRunning(this, pmkWild, 0 <br>                    , &amp;m_dwRegROTWild); <br>                pmkWild-&gt;Release(); <br>                } <br> <br>            pmkAll-&gt;Release(); <br>            } <br> <br>        //No need for us to hold on to this. <br>        pmk-&gt;Release(); <br>        } <br>    //End CHAPTER21MOD <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPatronDoc::InsertObject <br> * <br> * Purpose: <br> *  Retrieves a CLSID or a filename from the Insert Object dialog <br> *  box and creates an object using those identifiers. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the main window <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::InsertObject(HWND hWndFrame) <br>    { <br>    OLEUIINSERTOBJECT   io; <br>    DWORD               dwData=0; <br>    TCHAR               szFile[CCHPATHMAX]; <br>    UINT                uTemp; <br>    BOOL                fRet=FALSE; <br> <br>    if (NULL==m_pPG) <br>        return FALSE; <br> <br>    memset(&amp;io, 0, sizeof(io)); <br> <br>    io.cbStruct=sizeof(io); <br>    io.hWndOwner=hWndFrame; <br> <br>    szFile[0]=0; <br>    io.lpszFile=szFile; <br>    io.cchFile=CCHPATHMAX; <br> <br>    //We now support linking, so remove the IOF_DISABLELINK flag. <br>    io.dwFlags=IOF_SELECTCREATENEW; <br> <br>    uTemp=OleUIInsertObject(&amp;io); <br> <br>    if (OLEUI_OK==uTemp) <br>        { <br>        TENANTTYPE      tType; <br>        LPVOID          pv; <br>        FORMATETC       fe; <br> <br>        SETDefFormatEtc(fe, 0, TYMED_NULL); <br> <br>        if (io.dwFlags &amp; IOF_SELECTCREATENEW) <br>            { <br>            tType=TENANTTYPE_EMBEDDEDOBJECT; <br>            pv=&amp;io.clsid; <br>            } <br>        else <br>            { <br>            if (io.dwFlags &amp; IOF_CHECKLINK) <br>                tType=TENANTTYPE_LINKEDFILE; <br>            else <br>                tType=TENANTTYPE_EMBEDDEDFILE; <br> <br>            pv=szFile; <br>            } <br> <br>        if ((io.dwFlags &amp; IOF_CHECKDISPLAYASICON) <br>            &amp;&amp; NULL!=io.hMetaPict) <br>            { <br>            fe.dwAspect=DVASPECT_ICON; <br>            dwData=(DWORD)(UINT)io.hMetaPict; <br>            } <br> <br>        fRet=m_pPG-&gt;TenantCreate(tType, pv, &amp;fe, NULL, dwData); <br> <br>        //Free this regardless of what we do with it. <br>        INOLE_MetafilePictIconFree(io.hMetaPict); <br> <br>        if (fRet) <br>            { <br>            //Disable Printer Setup once we've created a tenant. <br>            m_fPrintSetup=FALSE; <br>            FDirtySet(TRUE); <br>            } <br>        } <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CPatronDoc::ActivateObject <br> * <br> * Purpose: <br> *  Executes a verb on the currently selected object. <br> * <br> * Parameters: <br> *  iVerb           LONG of the selected verb. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPatronDoc::ActivateObject(LONG iVerb) <br>    { <br>    m_pPG-&gt;ActivateObject(iVerb); <br>    return; <br>    } <br> <br> <br>/* <br> * CPatronDoc::ConvertObject <br> * <br> * Purpose: <br> *  Invokes the Convert dialog on the current object.  Here it's <br> *  just a pass-through to the pages. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, FALSE otherwise. <br> */ <br> <br>BOOL CPatronDoc::ConvertObject(HWND hWndFrame) <br>    { <br>    return m_pPG-&gt;ConvertObject(hWndFrame); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
