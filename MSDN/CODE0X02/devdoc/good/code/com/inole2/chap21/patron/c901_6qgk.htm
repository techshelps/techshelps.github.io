<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PAGES.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context914"></a>PAGES.CPP</h2>
<pre><code>/* <br> * PAGES.CPP <br> * Patron Chapter 21 <br> * <br> * Implementation of the CPages class.  See PAGEWIN.CPP and PRINT.CPP <br> * for additional member functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CPages:CPages <br> * CPages::~CPages <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the application we're in. <br> *  cf              UINT application clipboard format. <br> */ <br> <br>CPages::CPages(HINSTANCE hInst, UINT cf) <br>    : CWindow(hInst) <br>    { <br>    m_pPageCur=NULL; <br>    m_iPageCur=NOVALUE;  //Pages are 0 indexed, this is one before <br>    m_cPages=0; <br>    m_hWndPageList=NULL; <br>    m_hFont=NULL; <br>    m_fSystemFont=FALSE; <br> <br>    //Initialize to 8.5*11 inch with .25 inch margins as a default. <br>    m_cx=(LOMETRIC_PER_INCH*17)/2; <br>    m_cy=LOMETRIC_PER_INCH*11; <br> <br>    m_xMarginLeft=LOMETRIC_PER_INCH/4; <br>    m_xMarginRight=LOMETRIC_PER_INCH/4; <br>    m_yMarginTop=LOMETRIC_PER_INCH/4; <br>    m_yMarginBottom=LOMETRIC_PER_INCH/4; <br> <br>    m_xPos=0L; <br>    m_yPos=0L; <br> <br>    m_dwIDNext=0; <br>    m_pIStorage=NULL; <br> <br>    m_fDirty=FALSE; <br>    m_cf=cf; <br> <br>    m_fDragSource=FALSE; <br>    m_fMoveInPage=FALSE; <br>    m_fLinkAllowed=FALSE; <br> <br>    m_fDragRectShown=FALSE; <br> <br>    m_uScrollInset=GetProfileInt(TEXT("windows") <br>        , TEXT("DragScrollInset"), DD_DEFSCROLLINSET); <br> <br>    m_uScrollDelay=GetProfileInt(TEXT("windows") <br>        , TEXT("DragScrollDelay"), DD_DEFSCROLLDELAY); <br> <br>    m_uHScrollCode=0; <br>    m_uVScrollCode=0; <br>    m_fShowTypes=FALSE; <br> <br>    //CHAPTER21MOD <br>    m_pmkFile=NULL; <br>    //End CHAPTER21MOD <br>    return; <br>    } <br> <br> <br>CPages::~CPages(void) <br>    { <br>    //Ensure memory cleaned up in list; do final IStorage::Release <br>    StorageSet(NULL, FALSE, FALSE); <br> <br>    //CHAPTER21MOD <br>    ReleaseInterface(m_pmkFile); <br>    //End CHAPTER21MOD <br> <br>    if (NULL!=m_hFont &amp;&amp; !m_fSystemFont) <br>        DeleteObject(m_hFont); <br> <br>    if (NULL!=m_hWndPageList) <br>        DestroyWindow(m_hWndPageList); <br> <br>    //m_hWnd destroyed with the document. <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CPages::FIsDirty <br> * <br> * Purpose: <br> *  Tells the caller (document) if anything's happened to dirty us. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::FIsDirty(void) <br>    { <br>    return m_fDirty; <br>    } <br> <br> <br> <br>/* <br> * CPages::Init <br> * <br> * Purpose: <br> *  Instantiates a pages window within a given parent.  The <br> *  parent may be a main application window, could be an MDI child <br> *  window. We really do not care. <br> * <br> * Parameters: <br> *  hWndParent      HWND of the parent of this window <br> *  pRect           LPRECT that this window should occupy <br> *  dwStyle         DWORD containing the window's style flags. <br> *                  Should contain WS_CHILD | WS_VISIBLE in <br> *                  typical circumstances. <br> *  uID             UINT ID to associate with this window <br> *  pv              LPVOID unused for now. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::Init(HWND hWndParent, LPRECT pRect, DWORD dwStyle <br>    , UINT uID, LPVOID pv) <br>    { <br>    int     cy; <br> <br>    m_hWnd=CreateWindowEx(WS_EX_NOPARENTNOTIFY, SZCLASSPAGES <br>        , SZCLASSPAGES, dwStyle, pRect-&gt;left, pRect-&gt;top <br>        , pRect-&gt;right-pRect-&gt;left, pRect-&gt;bottom-pRect-&gt;top <br>        , hWndParent, (HMENU)uID, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    /* <br>     * Create the hidden listbox we'll use to track pages.  We give <br>     * it the owner-draw style so we can just store pointers in it. <br>     */ <br>    m_hWndPageList=CreateWindow(TEXT("listbox"), TEXT("Page List") <br>        , WS_POPUP | LBS_OWNERDRAWFIXED, 0, 0, 100, 100 <br>        , HWND_DESKTOP, NULL, m_hInst, NULL); <br> <br>    if (NULL==m_hWndPageList) <br>        return FALSE; <br> <br>    //Create a 14 point Arial font, or use the system variable font. <br>    cy=MulDiv(-14, LOMETRIC_PER_INCH, 72); <br>    m_hFont=CreateFont(cy, 0, 0, 0, FW_NORMAL, FALSE, FALSE, FALSE <br>        , ANSI_CHARSET, OUT_TT_PRECIS, CLIP_TT_ALWAYS, PROOF_QUALITY <br>        , VARIABLE_PITCH | FF_SWISS, TEXT("Arial")); <br> <br>    if (NULL==m_hFont) <br>        { <br>        m_hFont=(HFONT)GetStockObject(ANSI_VAR_FONT); <br>        m_fSystemFont=TRUE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::StorageSet <br> * <br> * Purpose: <br> *  Provides the document's IStorage to the pages for its own use. <br> *  If this is a new storage, we initalize it with streams that we <br> *  want to always exists.  If this is an open, then we create <br> *  our page list from the PageList string we wrote before. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE to the new or opened storage.  If <br> *                  NULL, we just clean up and exit. <br> *  fChange         BOOL indicating is this was a Save As operation, <br> *                  meaning that we have the structure already and <br> *                  just need to change the value of m_pIStorage. <br> *  fInitNew        BOOL indicating if this is a new storage or one <br> *                  opened from a previous save. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::StorageSet(LPSTORAGE pIStorage, BOOL fChange <br>    , BOOL fInitNew) <br>    { <br>    DWORD           dwMode=STGM_DIRECT | STGM_READWRITE <br>                        | STGM_SHARE_EXCLUSIVE; <br>    HRESULT         hr; <br>    PCPage          pPage; <br>    BOOL            fRet=FALSE; <br>    ULONG           cbRead; <br>    PAGELIST        pgList; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    LPDWORD         pdwID; <br>    UINT            i; <br> <br>    //If we're changing saved roots, simply open current page again <br>    if (fChange) <br>        { <br>        if (NULL==pIStorage) <br>            return FALSE; <br> <br>        m_pIStorage-&gt;Release(); <br>        m_pIStorage=pIStorage; <br>        m_pIStorage-&gt;AddRef(); <br> <br>        PageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br>        m_fDirty=FALSE; <br>        return TRUE; <br>        } <br> <br>    if (NULL!=m_hWndPageList) <br>        { <br>        //On new or open, clean out whatever it is we have. <br>        for (i=0; i &lt; m_cPages; i++) <br>            { <br>            //CHAPTER21MOD <br>            if (PageGet(i, &amp;pPage, FALSE)) <br>                pPage-&gt;Release(); <br>            //End CHAPTER21MOD <br>            } <br> <br>        SendMessage(m_hWndPageList, LB_RESETCONTENT, 0, 0L); <br>        } <br> <br>    if (NULL!=m_pIStorage) <br>        m_pIStorage-&gt;Release(); <br> <br>    m_pIStorage=NULL; <br> <br>    //If we're just cleaning up, then we're done. <br>    if (NULL==pIStorage) <br>        return TRUE; <br> <br>    m_pIStorage=pIStorage; <br>    m_pIStorage-&gt;AddRef(); <br> <br>    //If this is a new storage, create the streams we require <br>    if (fInitNew) <br>        { <br>        //Page list header. <br>        hr=m_pIStorage-&gt;CreateStream(SZSTREAMPAGELIST, dwMode <br>            | STGM_CREATE, 0, 0, &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br> <br>        pIStream-&gt;Release(); <br> <br>        //Device Configuration <br>        hr=m_pIStorage-&gt;CreateStream(SZSTREAMDEVICECONFIG, dwMode <br>            | STGM_CREATE, 0, 0, &amp;pIStream); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br> <br>        pIStream-&gt;Release(); <br>        return TRUE; <br>        } <br> <br> <br>    /* <br>     * We're opening an existing file: <br>     *  1)  Configure for the device we're on <br>     *  2)  Read the Page List and create page entries for each. <br>     */ <br> <br>    ConfigureForDevice(); <br> <br>    //Read the page list. <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMPAGELIST, NULL, dwMode, 0 <br>        , &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        pIStream-&gt;Read(&amp;pgList, sizeof(PAGELIST), &amp;cbRead); <br>        m_cPages  =(UINT)pgList.cPages; <br>        m_iPageCur=(UINT)pgList.iPageCur; <br>        m_dwIDNext=pgList.dwIDNext; <br> <br>        fRet=TRUE; <br>        cbRead=pgList.cPages*sizeof(DWORD); <br> <br>        if (0!=cbRead) <br>            { <br>            pdwID=(LPDWORD)pIMalloc-&gt;Alloc(cbRead); <br> <br>            if (NULL!=pdwID) <br>                { <br>                pIStream-&gt;Read(pdwID, cbRead, &amp;cbRead); <br> <br>                for (i=0; i &lt; m_cPages; i++) <br>                    fRet &amp;=PageAdd(NOVALUE, *(pdwID+i), FALSE); <br> <br>                pIMalloc-&gt;Free(pdwID); <br>                } <br>            } <br> <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    if (!fRet) <br>        return FALSE; <br> <br>    PageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br>    m_fDirty=FALSE; <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::StorageUpdate <br> * <br> * Purpose: <br> *  Insures that all pages are committed before a root save. <br> * <br> * Parameters: <br> *  fCloseAll       BOOL directing us to close all open storages <br> *                  and streams. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::StorageUpdate(BOOL fCloseAll) <br>    { <br>    PCPage          pPage; <br>    LPSTREAM        pIStream; <br>    LPMALLOC        pIMalloc; <br>    LPDWORD         pdwID; <br>    ULONG           cb; <br>    HRESULT         hr; <br>    PAGELIST        pgList; <br>    BOOL            fRet=FALSE; <br>    UINT            i; <br> <br>    //We only need to close the current page--nothing else is open. <br>    if (NULL!=m_pPageCur) <br>        { <br>        m_pPageCur-&gt;Update(); <br> <br>        if (fCloseAll) <br>            m_pPageCur-&gt;Close(FALSE); <br>        } <br> <br>    //We don't hold anything else open, so write the page list. <br>    hr=m_pIStorage-&gt;OpenStream(SZSTREAMPAGELIST, NULL, STGM_DIRECT <br>        | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    if (SUCCEEDED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        { <br>        pgList.cPages=m_cPages; <br>        pgList.iPageCur=m_iPageCur; <br>        pgList.dwIDNext=m_dwIDNext; <br> <br>        pIStream-&gt;Write(&amp;pgList, sizeof(PAGELIST), &amp;cb); <br> <br>        cb=m_cPages*sizeof(DWORD); <br>        pdwID=(LPDWORD)pIMalloc-&gt;Alloc(cb); <br> <br>        if (NULL!=pdwID) <br>            { <br>            for (i=0; i &lt; m_cPages; i++) <br>                { <br>                PageGet(i, &amp;pPage, FALSE); <br>                *(pdwID+i)=pPage-&gt;GetID(); <br>                } <br> <br>            pIStream-&gt;Write(pdwID, cb, &amp;cb); <br>            pIMalloc-&gt;Free(pdwID); <br>            fRet=TRUE; <br>            } <br>        pIMalloc-&gt;Release(); <br>        } <br> <br>    pIStream-&gt;Release(); <br> <br>    //Clean up the dirty flag when we do an update. <br>    m_fDirty=!fRet; <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectGet <br> * <br> * Purpose: <br> *  Returns the rectangle of the Pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the rectangle. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectGet(LPRECT pRect) <br>    { <br>    RECT        rc; <br>    POINT       pt; <br> <br>    //Retrieve the size of our rectangle in parent coordinates. <br>    GetWindowRect(m_hWnd, &amp;rc); <br>    SETPOINT(pt, rc.left, rc.top); <br>    ScreenToClient(GetParent(m_hWnd), &amp;pt); <br> <br>    SetRect(pRect, pt.x, pt.y, pt.x+(rc.right-rc.left) <br>        , pt.y+(rc.bottom-rc.top)); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::RectSet <br> * <br> * Purpose: <br> *  Sets a new rectangle for the Pages window which sizes to fit. <br> *  Coordinates are given in parent terms. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::RectSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, pRect-&gt;left, pRect-&gt;top <br>        , (UINT)cx, (UINT)cy, SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::SizeGet <br> * <br> * Purpose: <br> *  Retrieves the size of the pages window in parent coordinates. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to return the size.  The right <br> *                  and bottom fields will contain the dimensions. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeGet(LPRECT pRect) <br>    { <br>    RectGet(pRect); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::SizeSet <br> * <br> * Purpose: <br> *  Sets a new size in parent coordinates for the Pages window. <br> * <br> * Parameters: <br> *  pRect           LPRECT containing the new rectangle. <br> *  fNotify         BOOL indicating if we're to notify anyone of <br> *                  the change. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::SizeSet(LPRECT pRect, BOOL fNotify) <br>    { <br>    UINT        cx, cy; <br> <br>    if (NULL==pRect) <br>        return; <br> <br>    cx=pRect-&gt;right-pRect-&gt;left; <br>    cy=pRect-&gt;bottom-pRect-&gt;top; <br> <br>    SetWindowPos(m_hWnd, NULL, 0, 0, (UINT)cx, (UINT)cy <br>        , SWP_NOMOVE | SWP_NOZORDER); <br> <br>    UpdateScrollRanges(); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::ActivePage <br> * <br> * Purpose: <br> *  Returns a CPage pointer to the current page. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCPage          Pointer to the current page. <br> */ <br> <br>PCPage CPages::ActivePage(void) <br>    { <br>    PCPage      pPage; <br>    BOOL        fRet; <br> <br>    fRet=PageGet(m_iPageCur, &amp;pPage, FALSE); <br>    return fRet ? pPage : NULL; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageInsert <br> * <br> * Purpose: <br> *  Creates a new page immediately after the current page.  If <br> *  there are no pages then this creates page 1. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index of the new page, 0 on failure. <br> */ <br> <br>UINT CPages::PageInsert(UINT uReserved) <br>    { <br>    if (0!=m_cPages &amp;&amp; NULL!=m_pPageCur) <br>        { <br>        //Close the current page, committing changes. <br>        m_pPageCur-&gt;Close(TRUE); <br>        } <br> <br>    //Create and open the new page. <br>    if (!PageAdd(m_iPageCur, m_dwIDNext, TRUE)) <br>        return 0; <br> <br>    m_dwIDNext++; <br>    m_iPageCur++; <br>    m_cPages++; <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br> <br>    PageGet(m_iPageCur, &amp;m_pPageCur, FALSE); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageDelete <br> * <br> * Removes the current page from the page list. <br> * <br> * Parameters: <br> *  uReserved       UINT unused <br> * <br> * Return Value: <br> *  UINT            Index to the now current page from the page <br> *                  list, NOVALUE on error. <br> */ <br> <br>UINT CPages::PageDelete(UINT uReserved) <br>    { <br>    PCPage      pPage; <br> <br>    if (!PageGet(m_iPageCur, &amp;pPage, FALSE)) <br>        return NOVALUE; <br> <br>    //Delete the page in both the storage and in memory. <br>    SendMessage(m_hWndPageList, LB_DELETESTRING, m_iPageCur, 0L); <br> <br>    m_pPageCur-&gt;Destroy(m_pIStorage); <br> <br>    //CHAPTER21MOD <br>    m_pPageCur-&gt;Release();   //Does final pPage-&gt;Close <br>    //End CHAPTER21MOD <br>    m_pPageCur=NULL; <br> <br>    /* <br>     * If this is the last page then the current is one less.  If <br>     * it's the only page the current is zero.  Otherwise the <br>     * current is the next page. <br>     */ <br> <br>    if (m_iPageCur==m_cPages-1)   //Covers last or only page. <br>        m_iPageCur--; <br> <br>    m_cPages--; <br> <br>    //Insure the new visible page is open. <br>    if (0!=m_cPages) <br>        { <br>        PageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br>        InvalidateRect(m_hWnd, NULL, FALSE); <br>        } <br>    else <br>        InvalidateRect(m_hWnd, NULL, TRUE); <br> <br>    UpdateWindow(m_hWnd); <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageGet <br> * <br> * Purpose: <br> *  Retrieves the index of the current page we're viewing. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Index of the current page. <br> */ <br> <br>UINT CPages::CurPageGet(void) <br>    { <br>    return m_iPageCur; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::CurPageSet <br> * <br> * Purpose: <br> *  Sets the index of the current page to view. <br> * <br> * Parameters: <br> *  iPage           UINT index of the page to view. 0 means first <br> *                  page, NOVALUE means last page. <br> * <br> * Return Value: <br> *  UINT            Index of the previous current page, NOVALUE on <br> *                  error. <br> */ <br> <br>UINT CPages::CurPageSet(UINT iPage) <br>    { <br>    UINT    iPageNew; <br>    UINT    iPagePrev=m_iPageCur; <br>    PCPage  pPage; <br> <br>    switch (iPage) <br>        { <br>        case 0: <br>            iPageNew=0; <br>            break; <br> <br>        case NOVALUE: <br>            iPageNew=m_cPages-1; <br>            break; <br> <br>        default: <br>            if (iPage &gt;= m_cPages) <br>                iPage=0; <br> <br>            iPageNew=iPage; <br>            break; <br>        } <br> <br>    //No reason to switch to the same page. <br>    if (iPagePrev==iPageNew) <br>        return iPage; <br> <br>    //Close the old page committing changes. <br>    if (!PageGet(iPagePrev, &amp;pPage, FALSE)) <br>        return NOVALUE; <br> <br>    pPage-&gt;Close(TRUE); <br> <br>    m_iPageCur=iPageNew; <br> <br>    //Open the new page. <br>    PageGet(m_iPageCur, &amp;m_pPageCur, TRUE); <br> <br>    InvalidateRect(m_hWnd, NULL, FALSE); <br>    UpdateWindow(m_hWnd); <br>    return iPagePrev; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::NumPagesGet <br> * <br> * Purpose: <br> *  Returns the number of pages this object current contains. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of pages we contain. <br> */ <br> <br>UINT CPages::NumPagesGet(void) <br>    { <br>    return m_cPages; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::TenantCreate <br> * CPages::TenantDestroy <br> * <br> * Purpose: <br> *  Pass-throughs for CPage members on the current page. <br> */ <br> <br>BOOL CPages::TenantCreate(TENANTTYPE tType, LPVOID pv <br>    , LPFORMATETC pFE, PPATRONOBJECT ppo, DWORD dwData) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantCreate(tType, pv, pFE, ppo, dwData); <br>    m_fDirty |= fRet; <br>    return fRet; <br>    } <br> <br> <br>BOOL CPages::TenantDestroy(void) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantDestroy(); <br>    m_fDirty |= fRet; <br>    return fRet; <br>    } <br> <br> <br> <br>/* <br> * CPages::TenantClip <br> * <br> * Purpose: <br> *  Copies or cuts the currently selected tenant to the clipoard. <br> * <br> * Parameters: <br> *  fCut            BOOL TRUE to cut the object, FALSE to copy. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::TenantClip(BOOL fCut) <br>    { <br>    BOOL    fRet; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    fRet=m_pPageCur-&gt;TenantClip(fCut); <br>    m_fDirty |= (fRet &amp;&amp; fCut); <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::FQueryObjectSelected <br> * <br> * Purpose: <br> *  Returns whether or not there is an object selected on this <br> *  page for Cut, Copy, Delete functions. <br> * <br> * Parameters: <br> *  hMenu           HMENU on which object related items live. <br> * <br> * Return Value: <br> *  BOOL            TRUE if we have an object, FALSE otherwise. <br> */ <br> <br>BOOL CPages::FQueryObjectSelected(HMENU hMenu) <br>    { <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    return m_pPageCur-&gt;FQueryObjectSelected(hMenu); <br>    } <br> <br> <br> <br>/* <br> * CPages::ActivateObject <br> * <br> * Purpose: <br> *  Executes a verb on the currently selected object. <br> * <br> * Parameters: <br> *  iVerb           LONG of the selected verb. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::ActivateObject(LONG iVerb) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    m_pPageCur-&gt;ActivateObject(iVerb); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::ShowObjectTypes <br> * <br> * Purpose: <br> *  Pass-through to CPage::ShowObjectTypes <br> * <br> * Parameters: <br> *  fShow           BOOL indicating to show the type or not. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::ShowObjectTypes(BOOL fShow) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    m_fShowTypes=fShow; <br>    m_pPageCur-&gt;ShowObjectTypes(fShow); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::NotifyTenantsOfRename <br> * <br> * Purpose: <br> *  Pass-through to CPage to tell tenants that the document <br> *  changes names. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of the new filename. <br> *  pmk             LPMONKIER to the new file moniker. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::NotifyTenantsOfRename(LPTSTR pszFile, LPMONIKER pmk) <br>    { <br>    if (NULL==m_pPageCur) <br>        return; <br> <br>    //CHAPTER21MOD <br>    ReleaseInterface(m_pmkFile); <br>    m_pmkFile=pmk; <br>    m_pmkFile-&gt;AddRef(); <br>    //End CHAPTER21MOD <br>    m_pPageCur-&gt;NotifyTenantsOfRename(pszFile, pmk); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::FQueryLinksInPage <br> * <br> * Purpose: <br> *  Pass through to current page to see if there are any <br> *  linked objects <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>BOOL CPages::FQueryLinksInPage() <br>    { <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    return m_pPageCur-&gt;FQueryLinksInPage(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::GetUILinkContainer <br> * <br> * Purpose: <br> *  Creates an object with the IOleUILinkContainer interface for <br> *  the links dialog.  We know the current page which is what <br> *  we need to create this thing, so we can create it here instead <br> *  of bugging the page for it. <br> * <br> * Parameters: <br> *  ppObj           PCIOleUILinkContainer * in which we return <br> *                  the pointer. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::GetUILinkContainer(PCIOleUILinkContainer *ppObj) <br>    { <br>    PCIOleUILinkContainer   pObj; <br> <br>    *ppObj=NULL; <br> <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    pObj=new CIOleUILinkContainer(m_pPageCur); <br> <br>    if (NULL==pObj) <br>        return FALSE; <br> <br>    if (!pObj-&gt;Init()) <br>        { <br>        delete pObj; <br>        return FALSE; <br>        } <br> <br>    pObj-&gt;AddRef(); <br>    *ppObj=pObj; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CPages::ConvertObject <br> * <br> * Purpose: <br> *  Pass-through to the current page. <br> * <br> * Parameters: <br> *  hWndFrame       HWND of the frame window. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, FALSE <br> *                  otherwise. <br> */ <br> <br>BOOL CPages::ConvertObject(HWND hWndFrame) <br>    { <br>    if (NULL==m_pPageCur) <br>        return FALSE; <br> <br>    return m_pPageCur-&gt;ConvertObject(hWndFrame, FALSE); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CPages::CalcBoundingRect <br> * (Protected) <br> * <br> * Purpose: <br> *  Calculates a rectangle that bounds the printed page and the <br> *  current scroll state of the window. <br> * <br> * Parameters: <br> *  prc             LPRECT to fill with window (device) coordinates. <br> *  fWindow         BOOL indicating to include the window in this <br> *                  calculation or return only the printed page <br> *                  coordinates. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPages::CalcBoundingRect(LPRECT prc, BOOL fWindow) <br>    { <br>    RECT        rc, rcT; <br> <br>    if (NULL==prc) <br>        return; <br> <br>    //Calculate the boundaries for sizing: intersect page &amp; screen <br>    rc.left=LOMETRIC_BORDER+m_xMarginLeft; <br>    rc.top =-LOMETRIC_BORDER-m_yMarginTop; <br>    rc.right =rc.left+(UINT)m_cx; <br>    rc.bottom=rc.top -(UINT)m_cy; <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    OffsetRect(&amp;rc, -(int)m_xPos, -(int)m_yPos); <br> <br>    if (!fWindow) <br>        { <br>        *prc=rc; <br>        return; <br>        } <br> <br>    //Intersect with window to make the size bounds. <br>    GetClientRect(m_hWnd, &amp;rcT); <br>    IntersectRect(prc, &amp;rc, &amp;rcT); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageGet <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a page of a given index returning a BOOL so it's simple <br> *  to use this function inside if statements. <br> * <br> * Parameters: <br> *  iPage           UINT page to retrieve 0 based. <br> *  ppPage          PCPage * in which to return the page pointer <br> *  fOpen           BOOL indicating if we should open this page as <br> *                  well. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CPages::PageGet(UINT iPage, PCPage *ppPage, BOOL fOpen) <br>    { <br>    if (NULL==ppPage) <br>        return FALSE; <br> <br>    if (LB_ERR!=SendMessage(m_hWndPageList, LB_GETTEXT <br>        , iPage, (LONG)ppPage)) <br>        { <br>        if (fOpen) <br>            (*ppPage)-&gt;Open(m_pIStorage); <br> <br>        return TRUE; <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CPages::PageAdd <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new page initialized to the given values.  The new <br> *  page's storage is created if it does not already exist.  If <br> *  fOpenStorage is set the page's storage is opened and left <br> *  opened. <br> * <br> * Parameters: <br> *  iPage           UINT Location at which to insert page; new page <br> *                  is inserted after this position.  NOVALUE for <br> *                  the end. <br> *  dwID            DWORD ID for this page. <br> *  fOpenStorage    BOOL indicating if we're to leave the storage <br> *                  open. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CPages::PageAdd(UINT iPage, DWORD dwID, BOOL fOpenStorage) <br>    { <br>    PCPage      pPage; <br>    LRESULT     lr; <br> <br>    pPage=new CPage(dwID, m_hWnd, this); <br> <br>    if (NULL==pPage) <br>        return FALSE; <br> <br>    //CHAPTER21MOD <br>    pPage-&gt;AddRef(); <br>    //End CHAPTER21MOD <br> <br>    if (fOpenStorage) <br>        pPage-&gt;Open(m_pIStorage); <br> <br>    if (NOVALUE==iPage) <br>        iPage--; <br> <br>    //Now try to add to the listbox. <br>    lr=SendMessage(m_hWndPageList, LB_INSERTSTRING, iPage+1 <br>        , (LONG)pPage); <br> <br>    if (LB_ERRSPACE==lr) <br>        { <br>        if (fOpenStorage) <br>            pPage-&gt;Close(FALSE); <br> <br>        //CHAPTER21MOD <br>        pPage-&gt;Release(); <br>        //End CHAPTER21MOD <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>//CHAPTER21MOD <br>/* <br> * CPages::IPageGetFromID <br> * (Protected) <br> * <br> * Purpose: <br> *  Returns a page of a given identifier <br> * <br> * Parameters: <br> *  dwID            DWORD identifier of the page to retrieve.  If <br> *                  NOVALUE, then we return the current page. <br> *  ppPage          PCPage * in which to return the page <br> *                  pointer <br> *  fOpen           BOOL indicating if we should open this page as <br> *                  well. <br> * <br> * Return Value: <br> *  UINT            Index of the page if successful, NOVALUE <br> *                  otherwise. <br> */ <br> <br>UINT CPages::IPageGetFromID(DWORD dwID, PCPage *ppPage <br>    , BOOL fOpen) <br>    { <br>    UINT        i; <br>    PCPage      pPage; <br> <br>    if (NULL==ppPage) <br>        return FALSE; <br> <br>    if ((LONG)-1==(LONG)dwID) <br>        { <br>        *ppPage=m_pPageCur; <br>        return m_iPageCur; <br>        } <br> <br>    *ppPage=NULL; <br> <br>    for (i=0; i &lt; m_cPages; i++) <br>        { <br>        if (!PageGet(i, &amp;pPage, FALSE)) <br>            continue; <br> <br>        if (pPage-&gt;GetID()==dwID) <br>            { <br>            if (fOpen) <br>                pPage-&gt;Open(m_pIStorage); <br> <br>            *ppPage=pPage; <br>            return i; <br>            } <br>        } <br> <br>    return NOVALUE; <br>    } <br> <br>//End CHAPTER21MOD </code></pre>
<p>&nbsp;</p></body>
</HTML>
