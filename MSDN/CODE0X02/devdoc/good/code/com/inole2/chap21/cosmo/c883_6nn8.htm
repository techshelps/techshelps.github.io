<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COSMO.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context884"></a>COSMO.CPP</h2>
<pre><code>/* <br> * COSMO.CPP <br> * Cosmo Chapter 21 <br> * <br> * WinMain and CCosmoFrame implementations. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "cosmo.h" <br> <br>/* <br> * These are for proper implementation of the class factory, <br> * OLE Documents support, and shutdown conditions. <br> */ <br>ULONG g_cObj=0; <br>ULONG g_cLock=0; <br>HWND  g_hWnd=NULL; <br>BOOL  g_fUser=FALSE; <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  Should register the app class <br> *  if a previous instance has not done so and do any other one-time <br> *  initializations. <br> */ <br> <br>int PASCAL WinMain (HINSTANCE hInst, HINSTANCE hPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    PCCosmoFrame    pFR; <br>    FRAMEINIT       fi; <br>    WPARAM          wRet; <br> <br>    SETMESSAGEQUEUE; <br> <br>    //Attempt to allocate and initialize the application <br>    pFR=new CCosmoFrame(hInst, hPrev, pszCmdLine, nCmdShow); <br> <br>    if (NULL==pFR) <br>        return -1; <br> <br>    fi.idsMin=IDS_FRAMEMIN; <br>    fi.idsMax=IDS_FRAMEMAX; <br>    fi.idsStatMin=IDS_STATMESSAGEMIN; <br>    fi.idsStatMax=IDS_STATMESSAGEMAX; <br>    fi.idStatMenuMin=ID_MENUFILE; <br>    fi.idStatMenuMax=ID_MENUHELP; <br>    fi.iPosWindowMenu=WINDOW_MENU; <br>    fi.cMenus=CMENUS; <br> <br>    fi.x=CW_USEDEFAULT; <br>    fi.y=CW_USEDEFAULT; <br>    fi.cx=440; <br>    fi.cy=460; <br> <br>    //If we can initialize pFR, start chugging messages <br>    if (pFR-&gt;Init(&amp;fi)) <br>        wRet=pFR-&gt;MessageLoop(); <br> <br>    delete pFR; <br>    return wRet; <br>    } <br> <br> <br> <br>/* <br> * ObjectDestroyed <br> * <br> * Purpose: <br> *  Function for the Cosmo Figure object to call when it gets <br> *  destroyed.  We destroy the main window if the proper conditions <br> *  are met for shutdown. <br> */ <br> <br>void ObjectDestroyed(void) <br>    { <br>    g_cObj--; <br> <br>    //No more objects, no locks, no user control, shut the app down. <br>    if (0L==g_cObj &amp;&amp; 0L==g_cLock &amp;&amp; IsWindow(g_hWnd) &amp;&amp; !g_fUser) <br>        PostMessage(g_hWnd, WM_CLOSE, 0, 0L); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CCosmoFrame <br> * CCosmoFrame::~CCosmoFrame <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE from WinMain <br> *  hInstPrev       HINSTANCE from WinMain <br> *  pszCmdLine      LPSTR from WinMain <br> *  nCmdShow        int from WInMain <br> */ <br> <br>CCosmoFrame::CCosmoFrame(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    : CFrame(hInst, hInstPrev, pszCmdLine, nCmdShow) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i&lt;5; i++) <br>        m_hBmpLines[i]=NULL; <br> <br>    m_uIDCurLine=0; <br>    m_fInitialized=FALSE; <br>    m_pIClassDataTran=NULL; <br> <br>    m_fEmbedding=FALSE; <br>    m_dwRegCO=0; <br>    m_pIClassFactory=NULL; <br> <br>    return; <br>    } <br> <br> <br>CCosmoFrame::~CCosmoFrame(void) <br>    { <br>    UINT        i; <br> <br>    //Reverse CoRegisterClassObject, takes class factory ref to 1 <br>    if (0L!=m_dwRegCO) <br>        CoRevokeClassObject(m_dwRegCO); <br> <br>    ReleaseInterface(m_pIClassFactory); <br> <br>    for (i=0; i&lt;5; i++) <br>        { <br>        if (NULL!=m_hBmpLines[i]) <br>            DeleteObject(m_hBmpLines[i]); <br>        } <br> <br>    if (NULL!=m_pIClassDataTran) <br>        { <br>        m_pIClassDataTran-&gt;LockServer(FALSE); <br>        m_pIClassDataTran-&gt;Release(); <br>        } <br> <br>    OleFlushClipboard(); <br> <br>    if (m_fInitialized) <br>        OleUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::Init <br> * <br> * Purpose: <br> *  Call CoInitialize then calling down into the base class <br> *  initialization. <br> * <br> * Parameters: <br> *  pFI             PFRAMEINIT containing initialization parameters. <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::Init(PFRAMEINIT pFI) <br>    { <br>    HRESULT     hr; <br> <br>    CHECKVER_OLE; <br> <br>    if (FAILED(OleInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    hr=CoGetClassObject(CLSID_DataTransferObject <br>        , CLSCTX_INPROC_SERVER, NULL, IID_IClassFactory <br>        , (PPVOID)&amp;m_pIClassDataTran); <br> <br>    if (SUCCEEDED(hr)) <br>        m_pIClassDataTran-&gt;LockServer(TRUE); <br> <br> <br>    //Check for command line flags <br>    ParseCommandLine(); <br> <br>    if (NULL!=m_ppszCmdArgs) <br>        { <br>        if(0==lstrcmpi(m_ppszCmdArgs[0], TEXT("-Embedding")) <br>           || 0==lstrcmpi(m_ppszCmdArgs[0], TEXT("/Embedding"))) <br>            m_fEmbedding=TRUE; <br>        } <br> <br>    g_fUser=!m_fEmbedding; <br> <br> <br>    /* <br>     * Create our class factory and register it for this application <br>     * using CoRegisterClassObject.  The REGCLS_*USE flags have to <br>     * do with servicable object from this instance, not with MDI or <br>     * SDI.  Since it's most convenient to be single use, we'll do <br>     * this in either version. <br>     * <br>     * In addition, it only makes sense to do any of this if we're <br>     * being launched to be a server. <br>     */ <br>    if (m_fEmbedding) <br>        { <br>        m_pIClassFactory=new CFigureClassFactory(this); <br> <br>        if (NULL==m_pIClassFactory) <br>            return FALSE; <br> <br>        //Since we hold on to this, we should AddRef it. <br>        m_pIClassFactory-&gt;AddRef(); <br> <br>        hr=CoRegisterClassObject(CLSID_CosmoFigure, m_pIClassFactory <br>            , CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, &amp;m_dwRegCO); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br>        } <br> <br>    return CFrame::Init(pFI); <br>    } <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateCClient <br> * <br> * Purpose: <br> *  Constructs a new client specific to the application. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  PCClient        Pointer to the new client object. <br> */ <br> <br>PCClient CCosmoFrame::CreateCClient(void) <br>    { <br>    return (PCClient)(new CCosmoClient(m_hInst, this)); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::RegisterAllClasses <br> * <br> * Purpose: <br> *  Registers all classes used in this application. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if registration succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::RegisterAllClasses(void) <br>    { <br>    WNDCLASS        wc; <br> <br>    //First let the standard frame do its thing <br>    if (!CFrame::RegisterAllClasses()) <br>        return FALSE; <br> <br>    /* <br>     * We want a different background color for the document <br>     * because the Polyline we put in the document will paint <br>     * with COLOR_WINDOW which by default which is CLASSLIB's <br>     * default document color. <br>     */ <br> <br>    GetClassInfo(m_hInst, SZCLASSDOCUMENT, &amp;wc); <br>    UnregisterClass(SZCLASSDOCUMENT, m_hInst); <br> <br>    wc.hbrBackground=(HBRUSH)(COLOR_APPWORKSPACE+1); <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    //Register the Polyline window. <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.hInstance     = m_hInst; <br>    wc.cbClsExtra    = 0; <br>    wc.lpfnWndProc   = PolylineWndProc; <br>    wc.cbWndExtra    = CBPOLYLINEWNDEXTRA; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_CROSS); <br>    wc.hbrBackground = NULL; <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = SZCLASSPOLYLINE; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::PreShowInit <br> * <br> * Purpose: <br> *  Called from Init before intially showing the window.  We do <br> *  whatever else we want here, modifying nCmdShow as necessary <br> *  which affects ShowWindow in Init. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if this initialization succeeded, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CCosmoFrame::PreShowInit(void) <br>    { <br>    CreateLineMenu(); <br>    CheckLineSelection(IDM_LINESOLID); <br> <br>    //Save the window handle for shutdown if necessary. <br>    g_hWnd=m_hWnd; <br> <br>    //If we're under OLE control, don't show the main window. <br>    if (m_fEmbedding) <br>        m_nCmdShow=SW_HIDE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateLineMenu <br> * <br> * Purpose: <br> *  Initializes the bitmaps used to create the Line menu and <br> *  replaces the text items defined in the application resources <br> *  with these bitmaps.  Note that the contents of m_hBmpLines <br> *  must be cleaned up when the application terminates. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::CreateLineMenu(void) <br>    { <br>    HMENU       hMenu; <br>    HDC         hDC, hMemDC; <br>    HPEN        hPen; <br>    HGDIOBJ     hObj; <br>    TEXTMETRIC  tm; <br>    UINT        i, cx, cy; <br> <br> <br>    hMenu=GetSubMenu(GetMenu(m_hWnd), 3);   //Line menu. <br>    hDC=GetDC(m_hWnd); <br> <br>    //Create each line in a menu item 8 chars wide, one char high. <br>    GetTextMetrics(hDC, &amp;tm); <br>    cx=tm.tmAveCharWidth*8; <br>    cy=tm.tmHeight; <br> <br>    /* <br>     * Create a memory DC in which to draw lines, and bitmaps <br>     * for each line. <br>     */ <br>    hMemDC=CreateCompatibleDC(hDC); <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    for (i=0; i&lt;5; i++) <br>        { <br>        m_hBmpLines[i]=CreateCompatibleBitmap(hMemDC, cx, cy); <br>        SelectObject(hMemDC, m_hBmpLines[i]); <br> <br>        PatBlt(hMemDC, 0, 0, cx, cy, WHITENESS); <br> <br>        hPen=CreatePen(i, 1, 0L);       //i=line style like PS_SOLID <br>        hObj=SelectObject(hMemDC, hPen); <br> <br>        MoveToEx(hMemDC, 0, cy/2, NULL); <br>        LineTo(hMemDC, cx, cy/2); <br> <br>        ModifyMenu(hMenu, IDM_LINEMIN+i, MF_BYCOMMAND | MF_BITMAP <br>            , IDM_LINEMIN+i, (LPTSTR)(LONG)(UINT)m_hBmpLines[i]); <br> <br>        SelectObject(hMemDC, hObj); <br>        DeleteObject(hPen); <br>        } <br> <br>    CheckMenuItem(hMenu, IDM_LINESOLID, MF_CHECKED); <br>    DeleteDC(hMemDC); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CreateToolbar <br> * <br> * Purpose: <br> *  Procedure to create all the necessary toolbar buttons. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  UINT            Number of tools added to the bar. <br> */ <br> <br>UINT CCosmoFrame::CreateToolbar(void) <br>    { <br>    UINT            iLast; <br>    UINT            uState=GIZMO_NORMAL; <br>    UINT            utCmd =GIZMOTYPE_BUTTONCOMMAND; <br>    UINT            utEx  =GIZMOTYPE_BUTTONATTRIBUTEEX; <br> <br>    //Insert the standard ones. <br>    iLast=CFrame::CreateToolbar(); <br> <br>    /* <br>     * Insert File Import in the 5th position and account for <br>     * it in iLast. <br>     */ <br>    m_pTB-&gt;Add(utCmd, 4, IDM_FILEIMPORT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 2, uState); <br>    iLast++; <br> <br>    //Separator <br>    m_pTB-&gt;Add(GIZMOTYPE_SEPARATOR, iLast++, 0, 6, m_dyB <br>        , NULL, NULL, 0, uState); <br> <br>    /* <br>     * For the Background bitmap, preserve our use of black <br>     * (part of the image) <br>     */ <br>    m_pTB-&gt;Add(utCmd, iLast++, IDM_COLORBACKGROUND, m_dxB, m_dyB <br>        , NULL, m_hBmp, 3, GIZMO_NORMAL | PRESERVE_BLACK); <br> <br>    m_pTB-&gt;Add(utCmd, iLast++, IDM_COLORLINE, m_dxB, m_dyB <br>        , NULL, m_hBmp, 4, uState); <br> <br>    //Separator <br>    m_pTB-&gt;Add(GIZMOTYPE_SEPARATOR, iLast++, 0, 6, m_dyB <br>        , NULL, NULL, 0, uState); <br> <br>    //Line styles. <br>    m_pTB-&gt;Add(utEx, iLast++, IDM_LINESOLID, m_dxB, m_dyB <br>        , NULL, m_hBmp, 5, uState); <br>    m_pTB-&gt;Add(utEx, iLast++, IDM_LINEDASH, m_dxB, m_dyB <br>        , NULL, m_hBmp, 6, uState); <br>    m_pTB-&gt;Add(utEx, iLast++, IDM_LINEDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 7, uState); <br>    m_pTB-&gt;Add(utEx, iLast++, IDM_LINEDASHDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 8, uState); <br>    m_pTB-&gt;Add(utEx, iLast++, IDM_LINEDASHDOTDOT, m_dxB, m_dyB <br>        , NULL, m_hBmp, 9, uState); <br> <br>    return iLast; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnCommand <br> * <br> * Purpose: <br> *  WM_COMMAND handler for the Cosmo frame window that just <br> *  processes the line menu and the color menu leaving the <br> *  CFrame to do everything else. <br> * <br> * Parameters: <br> *  hWnd            HWND of the frame window. <br> *  wParam          WPARAM of the message. <br> *  lParam          LPARAM of the message. <br> * <br> * Return Value: <br> *  LRESULT         Return value for the message. <br> */ <br> <br>LRESULT CCosmoFrame::OnCommand(HWND hWnd, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PCCosmoDoc      pDoc; <br>    TCHAR           szFile[CCHPATHMAX]; <br>    BOOL            fOK; <br>    UINT            i, uTemp; <br>    COLORREF        rgColors[16]; <br>    CHOOSECOLOR     cc; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    /* <br>     * Don't bother with anything during first initialization, <br>     * skipping many toolbar notifications. <br>     */ <br>    if (m_fInit) <br>        return 0L; <br> <br>    pDoc=(PCCosmoDoc)m_pCL-&gt;ActiveDocument(); <br> <br>    /* <br>     * Check for the line style commands which are <br>     * IDM_LINEMIN+&lt;style&gt;.  We handle this by changing the menu <br>     * and toolbar, then we pass it to the document for real <br>     * processing. <br>     */ <br>    if (NULL!=pDoc &amp;&amp; IDM_LINEMIN &lt;= wID &amp;&amp; IDM_LINEMAX &gt;=wID) <br>        { <br>        CheckLineSelection(wID); <br>        pDoc-&gt;LineStyleSet(wID-IDM_LINEMIN); <br>        return 0L; <br>        } <br> <br>    switch (wID) <br>        { <br>        case IDM_FILEIMPORT: <br>            szFile[0]=0; <br>            fOK=SaveOpenDialog(szFile, CCHPATHMAX, IDS_FILEIMPORT <br>                , TRUE, &amp;i); <br> <br>            if (fOK) <br>                { <br>                uTemp=pDoc-&gt;Load(FALSE, szFile); <br>                pDoc-&gt;ErrorMessage(uTemp); <br>                } <br> <br>            return (LRESULT)fOK; <br> <br> <br>        case IDM_COLORBACKGROUND: <br>        case IDM_COLORLINE: <br>            //Invoke the color chooser for either color <br>            uTemp=(IDM_COLORBACKGROUND==wID) <br>                ? DOCCOLOR_BACKGROUND : DOCCOLOR_LINE; <br> <br>            for (i=0; i&lt;16; i++) <br>                rgColors[i]=RGB(0, 0, i*16); <br> <br>            memset(&amp;cc, 0, sizeof(CHOOSECOLOR)); <br>            cc.lStructSize=sizeof(CHOOSECOLOR); <br>            cc.lpCustColors=rgColors; <br>            cc.hwndOwner=hWnd; <br>            cc.Flags=CC_RGBINIT; <br>            cc.rgbResult=pDoc-&gt;ColorGet(uTemp); <br> <br>            if (ChooseColor(&amp;cc)) <br>                pDoc-&gt;ColorSet(uTemp, cc.rgbResult); <br> <br>            break; <br> <br> <br>        default: <br>           CFrame::OnCommand(hWnd, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnDocumentDataChange <br> * <br> * Purpose: <br> *  Update the Line menu and toolbar if the style in the data <br> *  changes. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::OnDocumentDataChange(PCDocument pDoc) <br>    { <br>    CheckLineSelection(IDM_LINEMIN <br>        +((PCCosmoDoc)pDoc)-&gt;LineStyleGet()); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::OnDocumentActivate <br> * <br> * Purpose: <br> *  Informs us that document activation changed, so update the UI <br> *  for that new document. <br> * <br> * Parameters: <br> *  pDoc            PCDocument notifying the sink. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::OnDocumentActivate(PCDocument pDoc) <br>    { <br>    CheckLineSelection(IDM_LINEMIN <br>        +((PCCosmoDoc)pDoc)-&gt;LineStyleGet()); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::UpdateMenus <br> * <br> * Purpose: <br> *  Handles the WM_INITMENU message for the frame window.  Depending <br> *  on the existence of an active window, menu items are selectively <br> *  enabled and disabled. <br> * <br> * Parameters: <br> *  hMenu           HMENU of the menu to intialize <br> *  iMenu           UINT position of the menu. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::UpdateMenus(HMENU hMenu, UINT iMenu) <br>    { <br>    PCDocument  pDoc; <br>    BOOL        fOK=FALSE; <br>    BOOL        fCallDefault=TRUE; <br>    UINT        i; <br>    UINT        uTemp; <br>    UINT        uTempE; <br>    UINT        uTempD; <br> <br>    pDoc=m_pCL-&gt;ActiveDocument(); <br> <br>    uTempE=MF_ENABLED | MF_BYCOMMAND; <br>    uTempD=MF_DISABLED | MF_GRAYED | MF_BYCOMMAND; <br>    uTemp=((NULL!=pDoc) ? uTempE : uTempD); <br> <br>    //File menu:  If there is document window, disable Import. <br>    if (m_phMenu[0]==hMenu) <br>        EnableMenuItem(hMenu, IDM_FILEIMPORT, uTemp); <br> <br>    //Color menu:  no document, no commands <br>    if (m_phMenu[2]==hMenu) <br>        { <br>        EnableMenuItem(hMenu, IDM_COLORBACKGROUND, uTemp); <br>        EnableMenuItem(hMenu, IDM_COLORLINE,       uTemp); <br>        fCallDefault=FALSE; <br>        } <br> <br>    //Line menu:  no document, no commands <br>    if (m_phMenu[3]==hMenu) <br>        { <br>        for (i=IDM_LINEMIN; i&lt;=IDM_LINEMAX; i++) <br>            EnableMenuItem(hMenu, i, uTemp); <br> <br>        fCallDefault=FALSE; <br>        } <br> <br>    if (fCallDefault) <br>        CFrame::UpdateMenus(hMenu, iMenu); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::UpdateToolbar <br> * <br> * Purpose: <br> *  Enables and disables tools depending on whether we have <br> *  a document or not. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::UpdateToolbar(void) <br>    { <br>    BOOL        fLast; <br>    UINT        i; <br> <br>    //Save the last enabled state before CFrame changes it <br>    fLast=m_fLastEnable; <br> <br>    //Let the default hack on its tools <br>    CFrame::UpdateToolbar(); <br> <br>    /* <br>     * If CFrame::UpdateToolbar changed anything, then we need <br>     * to change as well--if nothing changes, nothing to do. <br>     */ <br>    if (fLast!=m_fLastEnable) <br>        { <br>        m_pTB-&gt;Enable(IDM_FILEIMPORT, m_fLastEnable); <br> <br>        m_pTB-&gt;Enable(IDM_COLORBACKGROUND, m_fLastEnable); <br>        m_pTB-&gt;Enable(IDM_COLORLINE,       m_fLastEnable); <br> <br>        for (i=IDM_LINEMIN; i &lt;= IDM_LINEMAX; i++) <br>            m_pTB-&gt;Enable(i, m_fLastEnable); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CCosmoFrame::CheckLineSelection <br> * <br> * Purpose: <br> *  Maintains the bitmap menu and the tools for the line selection. <br> *  Both are mutially exclusive option lists where a selection in <br> *  one has to affect the other. <br> * <br> * Parameters: <br> *  uID             UINT ID of the item to be selected <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::CheckLineSelection(UINT uID) <br>    { <br>    UINT        i; <br>    HMENU       hMenu; <br> <br>    //Update menus and tools if the selection changed. <br>    if (uID!=m_uIDCurLine) <br>        { <br>        m_uIDCurLine=uID; <br>        hMenu=GetMenu(m_hWnd); <br> <br>        //Uncheck all lines initially. <br>        for (i=IDM_LINEMIN; i&lt;=IDM_LINEMAX; i++) <br>            CheckMenuItem(hMenu, i, MF_UNCHECKED | MF_BYCOMMAND); <br> <br>        CheckMenuItem(hMenu, uID, MF_CHECKED | MF_BYCOMMAND); <br>        m_pTB-&gt;Check(uID, TRUE); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CCosmoFrame::UpdateEmbeddingUI <br> * <br> * Purpose: <br> *  Puts the application into the user interface for editing an <br> *  embedded object, manipulating menus and title bars. <br> * <br> * Parameters: <br> *  fEmbedding      BOOL TRUE to go in the mode, FALSE to leave it. <br> *  pszApp          LPCTSTR name of the container application as <br> *                  received in IOleObject::SetHostNames. <br> *  pszObj          LPCTSTR name of the object in the container as <br> *                  received in IOleObject::SetHostNames. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CCosmoFrame::UpdateEmbeddingUI(BOOL fEmbedding <br>    , PCDocument pDoc, LPCTSTR pszApp, LPCTSTR pszObj) <br>    { <br>    HMENU           hMenu; <br>    TCHAR           szTemp[256]; <br> <br>    //First let's play with the File menu. <br>    hMenu=m_phMenu[0]; <br> <br>    //Remove or add the File New, Open, and Save items <br>    if (fEmbedding) <br>        { <br>        DeleteMenu(m_phMenu[0], IDM_FILENEW,   MF_BYCOMMAND); <br>        DeleteMenu(m_phMenu[0], IDM_FILEOPEN,  MF_BYCOMMAND); <br>        DeleteMenu(m_phMenu[0], IDM_FILECLOSE, MF_BYCOMMAND); <br>        DeleteMenu(m_phMenu[0], IDM_FILESAVE,  MF_BYCOMMAND); <br> <br>        //Save As-&gt;Save Copy As <br>        ModifyMenu(m_phMenu[0], IDM_FILESAVEAS, MF_BYCOMMAND <br>            , IDM_FILESAVEAS, PSZ(IDS_SAVECOPYAS)); <br>        } <br>    else <br>        { <br>        InsertMenu(m_phMenu[0], 0, MF_BYPOSITION, IDM_FILENEW <br>            , PSZ(IDS_NEW)); <br>        InsertMenu(m_phMenu[0], 1, MF_BYPOSITION, IDM_FILEOPEN <br>            , PSZ(IDS_OPEN)); <br>        InsertMenu(m_phMenu[0], 2, MF_BYPOSITION, IDM_FILESAVE <br>            , PSZ(IDS_SAVE)); <br>        InsertMenu(m_phMenu[0], 3, MF_BYPOSITION, IDM_FILECLOSE <br>            , PSZ(IDS_SAVE)); <br> <br>        //Save Copy As-&gt;Save As <br>        ModifyMenu(m_phMenu[0], IDM_FILESAVEAS, MF_BYCOMMAND <br>            , IDM_FILESAVEAS, PSZ(IDS_SAVEAS)); <br>        } <br> <br>    //Change "Exit" to "Exit &amp; Return to xx" or vice-versa for SDI <br>    if (fEmbedding) <br>        wsprintf(szTemp, PSZ(IDS_EXITANDRETURN), (LPSTR)pszObj); <br>    else <br>        lstrcpy(szTemp, PSZ(IDS_EXIT)); <br> <br>    ModifyMenu(m_phMenu[0], IDM_FILEEXIT, MF_STRING, IDM_FILEEXIT <br>        , szTemp); <br>    DrawMenuBar(m_hWnd); <br> <br>    //Now let's play with the toolbar. <br>    m_pTB-&gt;Show(IDM_FILENEW,   !fEmbedding); <br>    m_pTB-&gt;Show(IDM_FILEOPEN,  !fEmbedding); <br>    m_pTB-&gt;Show(IDM_FILECLOSE, !fEmbedding); <br>    m_pTB-&gt;Show(IDM_FILESAVE,  !fEmbedding); <br> <br>    //Enable what's left appropriately. <br>    UpdateToolbar(); <br> <br>    //Now play with the title bar. <br> <br>    //IDS_EMBEDDINGCAPTION is MDI/SDI sensitive in COSMO.RC. <br>    wsprintf(szTemp, PSZ(IDS_EMBEDDINGCAPTION), pszObj); <br> <br>    /* <br>     * Remember that in MDI situations that Windows takes care of <br>     * the frame window caption bar when the document is maximized. <br>     */ <br>   #ifdef MDI <br>    SetWindowText(pDoc-&gt;Window(), szTemp); <br>   #else <br>    SetWindowText(m_hWnd, szTemp); <br>   #endif <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
