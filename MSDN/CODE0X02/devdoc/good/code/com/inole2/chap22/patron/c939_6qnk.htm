<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPERFILE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context950"></a>IPERFILE.CPP</h2>
<pre><code>/* <br> * IPERFILE.CPP <br> * Patron Chapter 22 <br> * <br> * Implementation of the IPersistFile interface for Patron's <br> * documents. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CImpIPersistFile:CImpIPersistFile <br> * CImpIPersistFile::~CImpIPersistFile <br> * <br> * Constructor Parameters: <br> *  pDoc            PCPatronDoc associated with this interface <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> */ <br> <br>CImpIPersistFile::CImpIPersistFile(PCPatronDoc pDoc <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pDoc=pDoc; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br> <br>CImpIPersistFile::~CImpIPersistFile(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPersistFile::QueryInterface <br> * CImpIPersistFile::AddRef <br> * CImpIPersistFile::Release <br> * <br> * Purpose: <br> *  Standard set of IUnknown members for this interface <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistFile::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIPersistFile::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIPersistFile::GetClassID <br> * <br> * Purpose: <br> *  Returns the CLSID of the file represented by this interface. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store our CLSID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::GetClassID(LPCLSID pClsID) <br>    { <br>    *pClsID=CLSID_PatronPages; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIPersistFile::IsDirty <br> * <br> * Purpose: <br> *  Tells the caller if we have made changes to this file since <br> *  it was loaded or initialized new. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         Contains S_OK if we ARE dirty, S_FALSE if <br> *                  NOT dirty. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::IsDirty(void) <br>    { <br>    return ResultFromScode(m_pDoc-&gt;FDirtyGet() ? S_OK : S_FALSE); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * IPersistFile::Load <br> * <br> * Purpose: <br> *  Asks the server to load the document for the given filename. <br> * <br> * Parameters: <br> *  pszFile         LPCOLESTR to the filename to load. <br> *  grfMode         DWORD containing open flags requested from the <br> *                  caller.  Currently these are safely ignored. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::Load(LPCOLESTR pszFile, DWORD grfMode) <br>    { <br>    UINT        uRet; <br> <br>   #ifdef WIN32ANSI <br>    char        szTemp[CCHPATHMAX]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szTemp, CCHPATHMAX <br>       , NULL, NULL); <br>    uRet=m_pDoc-&gt;Load(TRUE, szTemp); <br>   #else <br>    uRet=m_pDoc-&gt;Load(TRUE, (LPTSTR)pszFile); <br>   #endif <br>    return (DOCERR_NONE==uRet) ? NOERROR <br>        : ResultFromScode(STG_E_READFAULT); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * IPersistFile::Save <br> * <br> * Purpose: <br> *  Instructs the server to write the current file into a new <br> *  filename, possibly then using that filename as the current one. <br> * <br> * Parameters: <br> *  pszFile         LPCOLESTR of the file into which we save.  If NULL, <br> *                  this means save the current file. <br> *  fRemember       BOOL indicating if we're to use this filename as <br> *                  the current file now (Save As instead of Save <br> *                  Copy As). <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::Save(LPCOLESTR pszFile, BOOL fRemember) <br>    { <br>    UINT        uRet; <br> <br>    /* <br>     * Since we don't want to mess with changing Save (which would <br>     * require changes to CLASSLIB, urk) we instead save fRemember <br>     * in the document before calling Save which supresses the call <br>     * to CPatronDoc::Rename if FALSE. <br>     */ <br> <br>    m_pDoc-&gt;m_fRename=fRemember; <br>   #ifdef WIN32ANSI <br>    char        szTemp[CCHPATHMAX]; <br> <br>    WideCharToMultiByte(CP_ACP, 0, pszFile, -1, szTemp, CCHPATHMAX <br>       , NULL, NULL); <br>    uRet=m_pDoc-&gt;Save(0, szTemp); <br>   #else <br>    uRet=m_pDoc-&gt;Save(0, (LPTSTR)pszFile); <br>   #endif <br>    m_pDoc-&gt;m_fRename=TRUE; <br> <br>    return (DOCERR_NONE==uRet) ? NOERROR <br>        : ResultFromScode(STG_E_WRITEFAULT); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * IPersistFile::SaveCompleted <br> * <br> * Purpose: <br> *  Informs us that the operation that called Save is now finished <br> *  and we can access the file again. <br> * <br> * Parameters: <br> *  pszFile         LPCOLESTR of the file in which we can start <br> *                  writing again. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::SaveCompleted(LPCOLESTR pszFile) <br>    { <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * IPersistFile::GetCurFile <br> * <br> * Purpose: <br> *  Retrieves the name of the current file. <br> * <br> * Parameters: <br> *  ppszFile        LPOLESTR * into which we store a pointer to <br> *                  the filename that should be allocated with the <br> *                  shared IMalloc. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIPersistFile::GetCurFile(LPOLESTR *ppszFile) <br>    { <br>    LPMALLOC    pIMalloc; <br>    LPOLESTR    psz; <br>    UINT        uRet; <br> <br>    *ppszFile=NULL; <br> <br>    if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;pIMalloc))) <br>        return ResultFromScode(E_FAIL); <br> <br>    psz=(LPOLESTR)pIMalloc-&gt;Alloc(CCHPATHMAX*sizeof(OLECHAR)); <br>    pIMalloc-&gt;Release(); <br> <br>   #ifdef WIN32ANSI <br>    char    szTemp[CCHPATHMAX]; <br> <br>    uRet=m_pDoc-&gt;FilenameGet(szTemp, CCHPATHMAX); <br>    MultiByteToWideChar(CP_ACP, 0, szTemp, -1, psz, CCHPATHMAX); <br>   #else <br>    uRet=m_pDoc-&gt;FilenameGet(psz, CCHPATHMAX); <br>   #endif <br> <br>    //If we have no filename, return the prompt for File Open/Save. <br>    if (0==uRet) <br>       #ifdef WIN32ANSI <br>        MultiByteToWideChar(CP_ACP, 0 <br>            , (*m_pDoc-&gt;m_pST)[IDS_EXTENSION], -1, psz, CCHPATHMAX); <br>       #else <br>        lstrcpy(psz, (*m_pDoc-&gt;m_pST)[IDS_EXTENSION]); <br>       #endif <br> <br>    *ppszFile=psz; <br>    return (0==uRet) ? ResultFromScode(S_FALSE) : NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
