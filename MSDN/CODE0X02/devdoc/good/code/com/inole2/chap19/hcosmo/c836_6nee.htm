<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FIGURE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context836"></a>FIGURE.CPP</h2>
<pre><code>/* <br> * FIGURE.CPP <br> * Cosmo Handler Chapter 19 <br> * <br> * Implementation of the CFigure class that we expose as a <br> * CosmoFigure Object in this handler. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "hcosmo.h" <br> <br> <br>/* <br> * CFigure:CFigure <br> * CFigure::~CFigure <br> * <br> * Constructor Parameters: <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> *  pfnDestroy      PFNDESTROYED to call when object is destroyed. <br> *  hInst           HINSTANCE of the application we're in. <br> */ <br> <br>CFigure::CFigure(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy <br>    , HINSTANCE hInst) <br>    { <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pfnDestroy=pfnDestroy; <br>    m_clsID=CLSID_CosmoFigure; <br> <br>    m_cf=RegisterClipboardFormat(SZPOLYLINECLIPFORMAT); <br> <br>    //NULL any contained interfaces initially. <br>    m_pImpIOleObject     =NULL; <br>    m_pImpIViewObject2   =NULL; <br>    m_pImpIPersistStorage=NULL; <br>    m_pImpIAdviseSink    =NULL; <br> <br>    m_pDefIUnknown       =NULL; <br>    m_pDefIOleObject     =NULL; <br>    m_pDefIViewObject2   =NULL; <br>    m_pDefIPersistStorage=NULL; <br>    m_pDefIDataObject    =NULL; <br> <br>    m_pIAdvSinkView      =NULL; <br>    m_dwAdviseFlags      =0; <br>    m_dwAdviseAspects    =0; <br>    m_dwFrozenAspects    =0; <br> <br>    return; <br>    } <br> <br> <br>CFigure::~CFigure(void) <br>    { <br>    LPUNKNOWN       pIUnknown=this; <br> <br>    if (NULL!=m_pUnkOuter) <br>        pIUnknown=m_pUnkOuter; <br> <br>    /* <br>     * In aggregation, release cached pointers but <br>     * AddRef the controlling unknown first. <br>     */ <br>    if (NULL!=m_pDefIOleObject) <br>        { <br>        pIUnknown-&gt;AddRef(); <br>        m_pDefIOleObject-&gt;Release(); <br>        } <br> <br>    if (NULL!=m_pDefIViewObject2) <br>        { <br>        pIUnknown-&gt;AddRef(); <br>        m_pDefIViewObject2-&gt;Release(); <br>        } <br> <br>    if (NULL!=m_pDefIDataObject) <br>        { <br>        pIUnknown-&gt;AddRef(); <br>        m_pDefIDataObject-&gt;Release(); <br>        } <br> <br>    if (NULL!=m_pDefIPersistStorage) <br>        { <br>        pIUnknown-&gt;AddRef(); <br>        m_pDefIPersistStorage-&gt;Release(); <br>        } <br> <br>    ReleaseInterface(m_pIAdvSinkView); <br>    ReleaseInterface(m_pDefIUnknown) <br> <br>    DeleteInterfaceImp(m_pImpIAdviseSink); <br>    DeleteInterfaceImp(m_pImpIPersistStorage); <br>    DeleteInterfaceImp(m_pImpIViewObject2); <br>    DeleteInterfaceImp(m_pImpIOleObject); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CFigure::Init <br> * <br> * Purpose: <br> *  Performs any intiailization of a CFigure that's prone to failure <br> *  that we also use internally before exposing the object outside <br> *  this DLL. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CFigure::Init(void) <br>    { <br>    LPUNKNOWN       pIUnknown=this; <br>    HRESULT         hr; <br>    DWORD           dwConn; <br>    FORMATETC       fe; <br> <br>    if (NULL!=m_pUnkOuter) <br>        pIUnknown=m_pUnkOuter; <br> <br>    //First create our interfaces. <br>    m_pImpIOleObject=new CImpIOleObject(this, pIUnknown); <br> <br>    if (NULL==m_pImpIOleObject) <br>        return FALSE; <br> <br>    m_pImpIViewObject2=new CImpIViewObject2(this, pIUnknown); <br> <br>    if (NULL==m_pImpIViewObject2) <br>        return FALSE; <br> <br>    m_pImpIPersistStorage=new CImpIPersistStorage(this, pIUnknown); <br> <br>    if (NULL==m_pImpIPersistStorage) <br>        return FALSE; <br> <br>    m_pImpIAdviseSink=new CImpIAdviseSink(this, pIUnknown); <br> <br>    if (NULL==m_pImpIAdviseSink) <br>        return FALSE; <br> <br>    /* <br>     * Get an IUnknown on the default handler, passing pIUnknown <br>     * as the controlling unknown.  The extra reference count is to <br>     * prevent us from going away accidentally. <br>     */ <br>    m_cRef++; <br> <br>    hr=OleCreateDefaultHandler(CLSID_CosmoFigure, pIUnknown <br>        , IID_IUnknown, (PPVOID)&amp;m_pDefIUnknown); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * NOTE:  The spec specifically states that any interfaces <br>     * besides IUnknown that we obtain on an aggregated object <br>     * should be Released immediately after we QueryInterface for <br>     * them because the QueryInterface will AddRef us, and since <br>     * we would not release these interfaces until we were <br>     * destroyed, we'd never go away because we'd never get a zero <br>     * ref count. <br>     */ <br> <br>    //Now try to get other interfaces to which we delegate <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IOleObject <br>        , (PPVOID)&amp;m_pDefIOleObject); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IViewObject2 <br>        , (PPVOID)&amp;m_pDefIViewObject2); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IDataObject <br>        , (PPVOID)&amp;m_pDefIDataObject); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    hr=m_pDefIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;m_pDefIPersistStorage); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    pIUnknown-&gt;Release(); <br> <br>    m_cRef--; <br> <br>    //Set up an advise on native data so we can keep in sync <br>    SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL); <br>    m_pDefIDataObject-&gt;DAdvise(&amp;fe, 0, m_pImpIAdviseSink, &amp;dwConn); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFigure::QueryInterface <br> * CFigure::AddRef <br> * CFigure::Release <br> * <br> * Purpose: <br> *  IUnknown members for CFigure object. <br> */ <br> <br>STDMETHODIMP CFigure::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    /* <br>     * The only calls we get here for IUnknown are either in a non- <br>     * aggregated case or when we're created in an aggregation, so <br>     * in either we always return our IUnknown for IID_IUnknown. <br>     */ <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IPersist==riid || IID_IPersistStorage==riid) <br>        *ppv=m_pImpIPersistStorage; <br> <br>    if (IID_IOleObject==riid) <br>        *ppv=m_pImpIOleObject; <br> <br>    if (IID_IViewObject==riid || IID_IViewObject2==riid) <br>        *ppv=m_pImpIViewObject2; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    /* <br>     * Only expose default handler interfaces that you explicitly <br>     * know you are aggregating.  You cannot just blindly <br>     * delegate any other QueryInterface to the handler because <br>     * it may return interfaces you do not expect...such as a <br>     * newer version of an interface you implement in the handler. <br>     * We know as a handler that we must provide IDataObject, <br>     * IOleCache[2], IOleCacheControl, and IRunnableObject, and <br>     * these we get from the default handler. <br>     */ <br> <br>    if (IID_IDataObject==riid || IID_IOleCache==riid <br>        || IID_IOleCache2==riid || IID_IOleCacheControl==riid <br>        || IID_IRunnableObject==riid) <br>        return m_pDefIUnknown-&gt;QueryInterface(riid, ppv); <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CFigure::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CFigure::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    m_cRef++; <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFigure::Draw <br> * <br> * Purpose: <br> *  Paints the current window to an hDC which might be a printer. <br> * <br> * Parameters: <br> *  hDC             HDC to draw on, could be a metafile or <br> *                  printer DC. <br> *  pRect           LPRECT defining hDC bounds in which to draw. <br> *  dwAspect        DWORD aspect to draw. <br> *  ptd             DVTARGETDEVICE * containing device info. <br> *  hICDev          HDC containing the IC for the device. <br> *  ppl             PPOLYLINEDATA from which to draw. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::Draw(HDC hDC, LPRECT pRect, DWORD dwAspect <br>    , DVTARGETDEVICE *ptd, HDC hICDev, PPOLYLINEDATA ppl) <br>    { <br>    HBRUSH          hBrush; <br>    HPEN            hPen; <br>    HGDIOBJ         hObj1, hObj2; <br>    UINT            i, j; <br>    int             nDC; <br>    POINTS          pt1,pt2; <br>    POINT           rgpt[CPOLYLINEPOINTS]; <br> <br>    nDC=SaveDC(hDC); <br> <br>    for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>        { <br>        rgpt[i].x=ppl-&gt;rgpt[i].x; <br>        rgpt[i].y=ppl-&gt;rgpt[i].y; <br>        } <br> <br>    hPen=CreatePen(ppl-&gt;iLineStyle, 1, ppl-&gt;rgbLine); <br>    hObj1=SelectObject(hDC, hPen); <br> <br>    hBrush=CreateSolidBrush(ppl-&gt;rgbBackground); <br>    hObj2=SelectObject(hDC, hBrush); <br>    SetBkColor(hDC, ppl-&gt;rgbBackground); <br> <br>    //If we have one point, draw a dot to indicate it's position. <br>    if (1==m_pl.cPoints) <br>        { <br>        pt1.x=(short)rgpt[0].x; <br>        pt1.y=(short)rgpt[0].y; <br>        PointScale(pRect, &amp;pt1, TRUE); <br>        SetPixel(hDC, pt1.x, pt1.y, m_pl.rgbLine); <br>        } <br>    else <br>        { <br>        //Erase the background for bitmaps and metafiles. <br>        SelectObject(hDC, GetStockObject(NULL_PEN)); <br>        Rectangle(hDC, pRect-&gt;left, pRect-&gt;top, pRect-&gt;right+1 <br>            , pRect-&gt;bottom+1); <br>        SelectObject(hDC, hPen); <br> <br>        for (i=0; i &lt; ppl-&gt;cPoints; i++) <br>            { <br>            for (j=i; j &lt; ppl-&gt;cPoints; j++) <br>                { <br>                pt1.x=(short)rgpt[i].x; <br>                pt1.y=(short)rgpt[i].y; <br>                pt2.x=(short)rgpt[j].x; <br>                pt2.y=(short)rgpt[j].y; <br>                PointScale(pRect, &amp;pt1, TRUE); <br>                PointScale(pRect, &amp;pt2, TRUE); <br>                MoveToEx(hDC, pt1.x, pt1.y, NULL); <br>                LineTo(hDC, pt2.x, pt2.y); <br>                } <br>            } <br>        } <br> <br>    SelectObject(hDC, hObj1); <br>    SelectObject(hDC, hObj2); <br>    DeleteObject(hBrush); <br>    DeleteObject(hPen); <br> <br>    RestoreDC(hDC, nDC); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CFIgure::PointScale <br> * <br> * Purpose: <br> *  Scales a point from a 0-32767 coordinate to a rectangle relative <br> *  coordinate. <br> * <br> * Parameters: <br> *  pRect           LPRECT in which to scale. <br> *  ppt             LPPOINTS to convert <br> *  fUnused         BOOL of no use. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFigure::PointScale(LPRECT pRect, LPPOINTS ppt, BOOL fUnused) <br>    { <br>    DWORD   cx, cy; <br> <br>    cx=(DWORD)(pRect-&gt;right-pRect-&gt;left); <br>    cy=(DWORD)(pRect-&gt;bottom-pRect-&gt;top); <br> <br>    //Must use DWORD to insure proper scaling. <br>    ppt-&gt;x=pRect-&gt;left+(UINT)(((DWORD)ppt-&gt;x*cx) &gt;&gt; 15); <br>    ppt-&gt;y=pRect-&gt;top+(UINT)(((DWORD)ppt-&gt;y*cy) &gt;&gt; 15); <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
