<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICONNPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context845"></a>ICONNPT.CPP</h2>
<pre><code>/* <br> * ICONNPT.CPP <br> * Polyline Component Chapter 19 <br> * <br> * Implementation of CImpIConnectionPoint for the Polyline object <br> * as well as CConnectionPoint. <br> * <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * CImpIConnPtCont:CImpIConnPtCont <br> * CImpIConnPtCont::~CImpIConnPtCont <br> * <br> * Constructor Parameters: <br> *  pObj            PCPolyline pointing to the object we live in. <br> *  pUnkOuter       LPUNKNOWN of the controlling unknown. <br> */ <br> <br>CImpIConnPtCont::CImpIConnPtCont(PCPolyline pObj <br>    , LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br> <br>CImpIConnPtCont::~CImpIConnPtCont(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIConnPtCont::QueryInterface <br> * CImpIConnPtCont::AddRef <br> * CImpIConnPtCont::Release <br> */ <br> <br>STDMETHODIMP CImpIConnPtCont::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIConnPtCont::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIConnPtCont::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CImpIConnPtCont::EnumConnectionPoints <br> * <br> * Purpose: <br> *  Not implemented. <br> * <br> * Return Value: <br> *  HRESULT         E_NOTIMPL <br> */ <br> <br>STDMETHODIMP CImpIConnPtCont::EnumConnectionPoints <br>    (LPENUMCONNECTIONPOINTS *ppEnum) <br>    { <br>    *ppEnum=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br>/* <br> * CImpIConnPtCont::FindConnectionPoint <br> * <br> * Purpose: <br> *  Returns a pointer to the IConnectionPoint for a given <br> *  outgoing IID. <br> * <br> * Parameters: <br> *  riid            REFIID of the outgoing interface for which <br> *                  a connection point is desired. <br> *  ppCP            IConnectionPoint ** in which to return <br> *                  the pointer after calling AddRef. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the connection point is found, <br> *                  E_NOINTERFACE if it's not supported. <br> */ <br> <br>STDMETHODIMP CImpIConnPtCont::FindConnectionPoint(REFIID riid <br>    , IConnectionPoint **ppCP) <br>    { <br>    *ppCP=NULL; <br> <br>    if (IID_IPolylineAdviseSink10==riid) <br>        { <br>        return m_pObj-&gt;m_pConnPt-&gt;QueryInterface <br>            (IID_IConnectionPoint, (PPVOID)ppCP); <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br> <br> <br> <br>//CConnectionPoint implementation <br> <br>/* <br> * CConnectionPoint::CConnectionPoint <br> * CConnectionPoint::~CConnectionPoint <br> * <br> * Parameters (Constructor): <br> *  pObj            PCPolyline of the object we're in.  We can <br> *                  query this for the IConnectionPointContainer <br> *                  interface we might need. <br> */ <br> <br>CConnectionPoint::CConnectionPoint(PCPolyline pObj) <br>    { <br>    m_cRef=0; <br> <br>    /* <br>     * Our lifetime is controlled by the connectable object itself, <br>     * although other external clients will call AddRef and Release. <br>     * Since we're nested in the connectable object's lifetime, <br>     * there's no need to call AddRef on pObj. <br>     */ <br>    m_pObj=pObj; <br>    return; <br>    } <br> <br>CConnectionPoint::~CConnectionPoint(void) <br>    { <br>    ReleaseInterface(m_pObj-&gt;m_pAdv); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::QueryInterface <br> * CConnectionPoint::AddRef <br> * CConnectionPoint::Release <br> * <br> * Purpose: <br> *  Non-delegating IUnknown members for CConnectionPoint. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IConnectionPoint==riid) <br>        *ppv=(LPVOID)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionInterface <br> * <br> * Purpose: <br> *  Returns the IID of the outgoing interface supported through <br> *  this connection point. <br> * <br> * Parameters: <br> *  pIID            IID * in which to store the IID. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID) <br>    { <br>    if (NULL==pIID) <br>        return ResultFromScode(E_POINTER); <br> <br>    *pIID=IID_IPolylineAdviseSink10; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionPointContainer <br> * <br> * Purpose: <br> *  Returns a pointer to the IConnectionPointContainer that <br> *  is manageing this connection point. <br> * <br> * Parameters: <br> *  ppCPC           IConnectionPointContainer ** in which to return <br> *                  the pointer after calling AddRef. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionPointContainer <br>    (IConnectionPointContainer **ppCPC) <br>    { <br>    return m_pObj-&gt;QueryInterface(IID_IConnectionPointContainer <br>        , (void **)ppCPC); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Advise <br> * <br> * Purpose: <br> *  Provides this connection point with a notification sink to <br> *  call whenever the appropriate outgoing function/event occurs. <br> * <br> * Parameters: <br> *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection <br> *                  point must QueryInterface on this pointer to obtain <br> *                  the proper interface to call.  The connection <br> *                  point must also insure that any pointer held has <br> *                  a reference count (QueryInterface will do it). <br> *  pdwCookie       DWORD * in which to store the connection key for <br> *                  later calls to Unadvise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Advise(LPUNKNOWN pUnkSink <br>    , DWORD *pdwCookie) <br>    { <br>    IPolylineAdviseSink10  *pSink; <br> <br>    *pdwCookie=0; <br> <br>    //Only allow one connection <br>    if (NULL!=m_pObj-&gt;m_pAdv) <br>        return ResultFromScode(CONNECT_E_ADVISELIMIT); <br> <br>    //Check for the right interface on the sink. <br>    if (FAILED(pUnkSink-&gt;QueryInterface(IID_IPolylineAdviseSink10 <br>        , (PPVOID)&amp;pSink))) <br>        return ResultFromScode(CONNECT_E_CANNOTCONNECT); <br> <br>    *pdwCookie=ADVISEKEY; <br>    m_pObj-&gt;m_pAdv=pSink; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Unadvise <br> * <br> * Purpose: <br> *  Terminates the connection to the notification sink identified <br> *  with dwCookie (that was returned from Advise).  The connection <br> *  point has to Release any held pointers for that sink. <br> * <br> * Parameters: <br> *  dwCookie        DWORD connection key from Advise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie) <br>    { <br>    if (0==dwCookie) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    if (ADVISEKEY!=dwCookie) <br>        ResultFromScode(CONNECT_E_NOCONNECTION); <br> <br>    ReleaseInterface(m_pObj-&gt;m_pAdv); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::EnumConnections <br> * <br> * Purpose: <br> *  Not implemented. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::EnumConnections <br>    (LPENUMCONNECTIONS *ppEnum) <br>    { <br>    *ppEnum=NULL; <br>    return ResultFromScode(E_NOTIMPL); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
