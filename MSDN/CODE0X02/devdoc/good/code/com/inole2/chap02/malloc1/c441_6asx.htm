<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MALLOC1.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context441"></a>MALLOC1.C</h2>
<pre><code>/* <br> * MALLOC1.C <br> * C Malloc Demonstration Chapter 2 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "malloc1.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG         msg; <br>    PAPP        pApp; <br>    DWORD       dwVer; <br>    HRESULT     hr; <br> <br>    SETMESSAGEQUEUE; <br> <br>    //Make sure COM is the right version <br>    dwVer=CoBuildVersion(); <br> <br>    if (rmm!=HIWORD(dwVer)) <br>        return 0; <br> <br>    //Initialize OLE <br>    hr=CoInitialize(NULL); <br> <br>    if (FAILED(hr)) <br>        return 0; <br> <br>    pApp=App_Create(hInst, hInstPrev, nCmdShow); <br> <br>    if (NULL!=pApp) <br>        { <br>        if (App_Init(pApp)) <br>            { <br>            while (GetMessage(&amp;msg, NULL, 0,0 )) <br>                { <br>                TranslateMessage(&amp;msg); <br>                DispatchMessage(&amp;msg); <br>                } <br>            } <br> <br>        App_Destroy(pApp); <br>        } <br> <br>    //Only call this if CoInitialize worked <br>    CoUninitialize(); <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * MallocWndProc <br> * <br> * Purpose: <br> *  Standard window class procedure. <br> */ <br> <br>LRESULT APIENTRY MallocWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PAPP        pApp; <br>    ULONG       cb; <br>    UINT        i; <br>    BOOL        fResult; <br> <br>    pApp=(PAPP)GetWindowLong(hWnd, MALLOCWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pApp=(PAPP)(((LPCREATESTRUCT)lParam)-&gt;lpCreateParams); <br>            SetWindowLong(hWnd, MALLOCWL_STRUCTURE, (LONG)pApp); <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDM_COGETMALLOC: <br>                    App_GetAllocator(pApp); <br>                    break; <br> <br> <br>                case IDM_RELEASE: <br>                    if (!App_HaveAllocator(pApp)) <br>                        break; <br> <br>                    App_FreeAllocations(pApp, TRUE); <br>                    App_Message(pApp, TEXT("Release complete")); <br>                    break; <br> <br> <br>                case IDM_ALLOC: <br>                    if (!App_HaveAllocator(pApp)) <br>                        break; <br> <br>                    fResult=App_DoAllocations(pApp, FALSE); <br> <br>                    App_Message(pApp, fResult <br>                        ? TEXT("Alloc succeeded") <br>                        : TEXT("Alloc failed")); <br> <br>                    break; <br> <br> <br>                case IDM_FREE: <br>                    if (!App_HaveAllocations(pApp)) <br>                        break; <br> <br>                    App_FreeAllocations(pApp, FALSE); <br>                    App_Message(pApp, TEXT("Free complete")); <br>                    break; <br> <br> <br>                case IDM_REALLOC: <br>                    if (!App_HaveAllocator(pApp)) <br>                        break; <br> <br>                    fResult=App_DoAllocations(pApp, TRUE); <br> <br>                    App_Message(pApp, fResult <br>                        ? TEXT("Realloc succeeded") <br>                        : TEXT("Realloc failed")); <br> <br>                    break; <br> <br> <br>                case IDM_GETSIZE: <br>                    if (!App_HaveAllocations(pApp)) <br>                        break; <br> <br>                    fResult=TRUE; <br> <br>                    for (i=0; i &lt; CALLOCS; i++) <br>                        { <br>                        cb=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;GetSize <br>                            (pApp-&gt;m_pIMalloc, pApp-&gt;m_rgpv[i]); <br> <br>                        /* <br>                         * We test that the size is *at least* <br>                         * what we wanted. <br>                         */ <br>                        fResult &amp;= (pApp-&gt;m_rgcb[i] &lt;= cb); <br>                        } <br> <br>                    App_Message(pApp, fResult <br>                        ? TEXT("Sizes matched") <br>                        : TEXT("Sizes mismatch")); <br> <br>                    break; <br> <br> <br>                case IDM_DIDALLOC: <br>                    if (!App_HaveAllocations(pApp)) <br>                        break; <br> <br>                    /* <br>                     * DidAlloc may return -1 if it does not know <br>                     * whether or not it actually allocated <br>                     * something.  In that case we just blindly <br>                     * &amp; in a -1 with no affect. <br>                     */ <br> <br>                    fResult=(BOOL)-1; <br> <br>                    for (i=0; i &lt; CALLOCS; i++) <br>                        { <br>                        fResult &amp;= pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;DidAlloc <br>                            (pApp-&gt;m_pIMalloc, pApp-&gt;m_rgpv[i]); <br>                        } <br> <br>                    if (0==fResult) <br>                        App_Message(pApp, TEXT("DidAlloc is FALSE")); <br> <br>                    if (1==fResult) <br>                        App_Message(pApp, TEXT("DidAlloc is TRUE")); <br> <br>                    if (-1==fResult) <br>                        App_Message(pApp, TEXT("DidAlloc is unknown")); <br> <br>                    break; <br> <br> <br>                case IDM_HEAPMINIMIZE: <br>                    if (!App_HaveAllocator(pApp)) <br>                        break; <br> <br>                    pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;HeapMinimize <br>                        (pApp-&gt;m_pIMalloc); <br>                    App_Message(pApp, TEXT("HeapMinimize finished")); <br>                    break; <br> <br> <br>                case IDM_EXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * App_Create <br> * App_Destroy <br> * <br> * Constructor Parameters: (from WinMain) <br> *  hInst           HINSTANCE of the application. <br> *  hInstPrev       HINSTANCE of a previous instance. <br> *  nCmdShow        UINT specifying how to show the app window. <br> */ <br> <br>PAPP App_Create(HINSTANCE hInst, HINSTANCE hInstPrev, UINT nCmdShow) <br>    { <br>    UINT        i; <br>    ULONG       cb; <br>    PAPP        pApp; <br> <br>    pApp=(PAPP)malloc(sizeof(APP)); <br> <br>    if (NULL==pApp) <br>        return NULL; <br> <br>    pApp-&gt;m_hInst       =hInst; <br>    pApp-&gt;m_hInstPrev   =hInstPrev; <br>    pApp-&gt;m_nCmdShow    =nCmdShow; <br> <br>    pApp-&gt;m_hWnd        =NULL; <br>    pApp-&gt;m_pIMalloc    =NULL; <br>    pApp-&gt;m_fAllocated  =FALSE; <br> <br>    //100 is arbitrary.  IMalloc can handle larger. <br>    cb=100; <br> <br>    for (i=0; i &lt; CALLOCS; i++) <br>        { <br>        pApp-&gt;m_rgcb[i]=cb; <br>        pApp-&gt;m_rgpv[i]=NULL; <br> <br>        cb*=2; <br>        } <br> <br>    return pApp; <br>    } <br> <br> <br> <br>void App_Destroy(PAPP pApp) <br>    { <br>    App_FreeAllocations(pApp, TRUE); <br>    free(pApp); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * App_Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure.  If this function fails the caller should insure <br> *  that the destructor is called. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL App_Init(PAPP pApp) <br>    { <br>    WNDCLASS    wc; <br> <br>    if (!pApp-&gt;m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = MallocWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = CBWNDEXTRA; <br>        wc.hInstance      = pApp-&gt;m_hInst; <br>        wc.hIcon          = LoadIcon(pApp-&gt;m_hInst, TEXT("Icon")); <br>        wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU); <br>        wc.lpszClassName  = TEXT("MALLOC"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>        } <br> <br>    pApp-&gt;m_hWnd=CreateWindow(TEXT("MALLOC") <br>        , TEXT("C Malloc Demo"), WS_OVERLAPPEDWINDOW, 35, 35 <br>        , 350, 250, NULL, NULL, pApp-&gt;m_hInst, pApp); <br> <br>    if (NULL==pApp-&gt;m_hWnd) <br>        return FALSE; <br> <br>    ShowWindow(pApp-&gt;m_hWnd, pApp-&gt;m_nCmdShow); <br>    UpdateWindow(pApp-&gt;m_hWnd); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * App_GetAllocator <br> * <br> * Purpose: <br> *  Retrieves the current allocator. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void App_GetAllocator(PAPP pApp) <br>    { <br>    HRESULT     hr; <br>    TCHAR       szTemp[80]; <br> <br>    //This also releases pApp-&gt;m_pIMalloc <br>    App_FreeAllocations(pApp, TRUE); <br> <br>    hr=CoGetMalloc(MEMCTX_TASK, &amp;pApp-&gt;m_pIMalloc); <br> <br>    wsprintf(szTemp, TEXT("CoGetMalloc %s") <br>        , SUCCEEDED(hr) ? TEXT("succeeded") : TEXT("failed")); <br> <br>    App_Message(pApp, szTemp); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * App_HaveAllocator <br> * <br> * Purpose: <br> *  Checks if there's a valid allocator and displays a <br> *  message if not. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if there is an allocator, FALSE otherwise. <br> */ <br> <br>BOOL App_HaveAllocator(PAPP pApp) <br>    { <br>    if (NULL==pApp-&gt;m_pIMalloc) <br>        { <br>        App_Message(pApp, TEXT("Create the allocator first")); <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * App_DoAllocations <br> * <br> * Purpose: <br> *  Centralized place to clean up allocations made on <br> *  the current IMalloc. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> *  fRelease        BOOL indicating if we're to <br> *                  IMalloc::Release as well. <br> * <br> * Return Value: <br> *  BOOL            TRUE if all allocations succeeded. <br> */ <br> <br>BOOL App_DoAllocations(PAPP pApp, BOOL fRealloc) <br>    { <br>    UINT        i; <br>    ULONG       iByte; <br>    BOOL        fResult=TRUE; <br>    ULONG       cb; <br>    LPVOID      pv; <br> <br>    if (!fRealloc) <br>        App_FreeAllocations(pApp, FALSE); <br> <br>    for (i=0; i &lt; CALLOCS; i++) <br>        { <br>        //cb is set in the code below for later initialization <br>        if (fRealloc) <br>            { <br>            pApp-&gt;m_rgcb[i]+=128; <br>            cb=pApp-&gt;m_rgcb[i]; <br> <br>            //Old memory is not freed if Realloc fails <br>            pv=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Realloc(pApp-&gt;m_pIMalloc <br>                , pApp-&gt;m_rgpv[i], cb); <br>            } <br>        else <br>            { <br>            cb=pApp-&gt;m_rgcb[i]; <br>            pv=pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Alloc(pApp-&gt;m_pIMalloc, cb); <br>            } <br> <br>        pApp-&gt;m_rgpv[i]=pv; <br> <br>        //Fill the memory with letters. <br>        if (NULL!=pv) <br>            { <br>            LPBYTE  pb=(LPBYTE)pv; <br> <br>            for (iByte=0; iByte &lt; cb; iByte++) <br>                *pb++=('a'+i); <br>            } <br> <br>        fResult &amp;= (NULL!=pv); <br>        } <br> <br>    pApp-&gt;m_fAllocated=fResult; <br> <br>    //Clean up whatever we might have allocated <br>    if (!fResult) <br>        App_FreeAllocations(pApp, FALSE); <br> <br>    return fResult; <br>    } <br> <br> <br> <br> <br>/* <br> * App_HaveAllocations <br> * <br> * Purpose: <br> *  Checks if we have allocated memory from the current allocator, <br> *  displaying a message if not. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if there are allocations, FALSE otherwise. <br> */ <br> <br>BOOL App_HaveAllocations(PAPP pApp) <br>    { <br>    if (!App_HaveAllocator(pApp)) <br>        return FALSE; <br> <br>    if (!pApp-&gt;m_fAllocated) <br>        { <br>        App_Message(pApp, TEXT("Choose Alloc first")); <br>        return FALSE; <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * App_FreeAllocations <br> * <br> * Purpose: <br> *  Centralized place to clean up allocations made on <br> *  the current IMalloc. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> *  fRelease        BOOL indicating if we're to <br> *                  IMalloc::Release as well. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void App_FreeAllocations(PAPP pApp, BOOL fRelease) <br>    { <br>    UINT    i; <br> <br>    if (NULL==pApp-&gt;m_pIMalloc) <br>        return; <br> <br>    if (pApp-&gt;m_fAllocated) <br>        { <br>        for (i=0; i &lt; CALLOCS; i++) <br>            { <br>            if (NULL!=pApp-&gt;m_rgpv[i]) <br>                { <br>                pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Free(pApp-&gt;m_pIMalloc <br>                    , pApp-&gt;m_rgpv[i]); <br>                } <br> <br>            pApp-&gt;m_rgpv[i]=NULL; <br>            } <br> <br>        pApp-&gt;m_fAllocated=FALSE; <br>        } <br> <br>    if (fRelease) <br>        { <br>        pApp-&gt;m_pIMalloc-&gt;lpVtbl-&gt;Release(pApp-&gt;m_pIMalloc); <br>        pApp-&gt;m_pIMalloc=NULL; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * App_Message <br> * <br> * Purpose: <br> *  Displays a message in the client area of the window.  This is <br> *  just to centralize the call to simpify other code. <br> * <br> * Parameters: <br> *  pApp            PAPP identifying the object. <br> *  psz             LPTSTR to the string to display. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void App_Message(PAPP pApp, LPTSTR psz) <br>    { <br>    HDC     hDC; <br>    RECT    rc; <br> <br>    hDC=GetDC(pApp-&gt;m_hWnd); <br>    GetClientRect(pApp-&gt;m_hWnd, &amp;rc); <br> <br>    SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>    /* <br>     * We'll just be sloppy and clear the whole window as <br>     * well as write the string with one ExtTextOut call. <br>     * No word wrapping here... <br>     */ <br> <br>    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, psz, lstrlen(psz), NULL); <br>    ReleaseDC(pApp-&gt;m_hWnd, hDC); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
