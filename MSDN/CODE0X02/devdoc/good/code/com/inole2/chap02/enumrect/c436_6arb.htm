<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMCPP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context437"></a>ENUMCPP.CPP</h2>
<pre><code>/* <br> * ENUMCPP.CPP <br> * Enumerator in C++ Chapter 2 <br> * <br> * Implements the CEnumRECT class <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "enumrect.h" <br> <br> <br>/* <br> * CreateRECTEnumeratorCPP <br> * <br> * Purpose: <br> *  Creates an enumerator object returning an IEnumRECT interface. <br> * <br> * Parameters: <br> *  ppEnum          PENUMRECT * in which to return the <br> *                  interface pointer on the created object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CreateRECTEnumeratorCPP(PENUMRECT *ppEnum) <br>    { <br>    PCEnumRect  pER; <br>    HRESULT     hr; <br> <br>    if (NULL==ppEnum) <br>        return FALSE; <br> <br>    //Create the object <br>    pER=new CEnumRect(); <br> <br>    if (NULL==pER) <br>        return FALSE; <br> <br>    //Get the interface, which calls AddRef <br>    hr=pER-&gt;QueryInterface(IID_IEnumRECT, (void **)ppEnum); <br>    return SUCCEEDED(hr); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CEnumRect::CEnumRect <br> * CEnumRect::~CEnumRect <br> * <br> * Constructor Parameters: <br> *  None <br> */ <br> <br>CEnumRect::CEnumRect(void) <br>    { <br>    UINT        i; <br> <br>    //Initialize the array of rectangles <br>    for (i=0; i &lt; CRECTS; i++) <br>        SetRect(&amp;m_rgrc[i], i, i*2, i*3, i*4); <br> <br>    //Ref counts always start at zero <br>    m_cRef=0; <br> <br>    //Current pointer is the first element. <br>    m_iCur=0; <br> <br>    return; <br>    } <br> <br> <br>CEnumRect::~CEnumRect(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CEnumRect::QueryInterface <br> * <br> * Purpose: <br> *  Manages interfaces for the CEnumRect object. <br> * <br> * Parameters: <br> *  riid            REFIID of the interface to return. <br> *  ppv             PPVOID in which to return the pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, E_NOINTERFACE if the <br> *                  interface is not supported. <br> */ <br> <br>STDMETHODIMP CEnumRect::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    //Always NULL the out-parameters <br>    *ppv=NULL; <br> <br>    /* <br>     * No explicit typecast necessary since we singly derive <br>     * from IEnumRECT. <br>     */ <br>    if (IID_IUnknown==riid || IID_IEnumRECT==riid) <br>        *ppv=this; <br> <br>    if (NULL==*ppv) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    //AddRef any interface we'll return. <br>    ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CEnumRect::AddRef <br> * <br> * Purpose: <br> *  Increments the reference count on the object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  ULONG           New reference count. <br> */ <br> <br>STDMETHODIMP_(ULONG) CEnumRect::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CEnumRect::Release <br> * <br> * Purpose: <br> *  Indicates that someone on whose behalf we once AddRef'd has <br> *  finished with the object.  We decrement our reference count <br> *  and if zero, we delete the object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  ULONG           Current reference count after decrement.  If <br> *                  this returns zero then the interface is no <br> *                  longer valid. <br> */ <br> <br>STDMETHODIMP_(ULONG) CEnumRect::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CEnumRect::Next <br> * <br> * Purpose: <br> *  Returns the next rectangle in the enumerator. <br> * <br> * Parameters: <br> *  cRect           DWORD number of RECTs to return <br> *  prc             LPRECT in which to store the returned RECT. <br> *  pdwRects        LPDWORD in which to store the number of <br> *                  structs returned. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE otherwise, <br> */ <br> <br>STDMETHODIMP CEnumRect::Next(DWORD cRect, LPRECT prc, LPDWORD pdwRects) <br>    { <br>    DWORD           cRectReturn=0L; <br> <br>    if (NULL==pdwRects) <br>        { <br>        if (1L!=cRect) <br>            return ResultFromScode(S_FALSE); <br>        } <br>    else <br>        *pdwRects=0L; <br> <br>    if (NULL==prc || (m_iCur &gt;= CRECTS)) <br>        return ResultFromScode(S_FALSE); <br> <br>    while (m_iCur &lt; CRECTS &amp;&amp; cRect &gt; 0) <br>        { <br>        *prc++=m_rgrc[m_iCur++]; <br>        cRectReturn++; <br>        cRect--; <br>        } <br> <br>    if (NULL!=pdwRects) <br>        *pdwRects=cRectReturn; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CEnumRect::Skip <br> * <br> * Purpose: <br> *  Skips the next n elements in the enumerator. <br> * <br> * Parameters: <br> *  cSkip           DWORD number of elements to skip. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE if we could not <br> *                  skip the requested number. <br> */ <br> <br>STDMETHODIMP CEnumRect::Skip(DWORD cSkip) <br>    { <br>    if ((m_iCur+cSkip) &gt;= CRECTS) <br>        return ResultFromScode(S_FALSE); <br> <br>    m_iCur+=cSkip; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CEnumRect::Reset <br> * <br> * Purpose: <br> *  Resets the current element in the enumerator to zero. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CEnumRect::Reset(void) <br>    { <br>    m_iCur=0; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpEnumRECT::Clone <br> * <br> * Purpose: <br> *  Creates a copy enumerator. <br> * <br> * Parameters: <br> *  ppEnum          PENUMRECT * in which to store the clone. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, error code otherwise. <br> */ <br> <br>STDMETHODIMP CEnumRect::Clone(PENUMRECT *ppEnum) <br>    { <br>    if (CreateRECTEnumeratorCPP(ppEnum)) <br>        { <br>        /* <br>         * Copy the current index.  The typecast is safe because <br>         * we know that the IEnumRECT from the creation function <br>         * is really a CEnumRect pointer. <br>         */ <br>        ((PCEnumRect)(*ppEnum))-&gt;m_iCur=m_iCur; <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_OUTOFMEMORY); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
