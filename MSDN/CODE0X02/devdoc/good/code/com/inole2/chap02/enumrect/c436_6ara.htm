<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ENUMC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context436"></a>ENUMC.C</h2>
<pre><code>/* <br> * ENUMC.C <br> * Enumerator in C Chapter 2 <br> * <br> * Implements the RECTENUMERATOR structure and functions (an object). <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "enumrect.h" <br> <br> <br>//We have to explicitly define the function table for IEnumRECT in C <br>static IEnumRECTVtbl  vtEnumRect; <br>static BOOL           g_fVtblInitialized=FALSE; <br> <br> <br>/* <br> * CreateRECTEnumeratorC <br> * <br> * Purpose: <br> *  Creates an enumerator object returning an IEnumRECT interface. <br> * <br> * Parameters: <br> *  ppEnum          PENUMRECT * in which to return the interface <br> *                  pointer on the created object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CreateRECTEnumeratorC(PENUMRECT *ppEnum) <br>    { <br>    PRECTENUMERATOR     pRE; <br>    HRESULT             hr; <br> <br>    if (NULL==ppEnum) <br>        return FALSE; <br> <br>    //Create the object <br>    pRE=RECTENUM_Constructor(); <br> <br>    if (NULL==pRE) <br>        return FALSE; <br> <br>    //Get the interface, which calls AddRef <br>    hr=pRE-&gt;lpVtbl-&gt;QueryInterface((PENUMRECT)pRE, &amp;IID_IEnumRECT <br>        , (void **)ppEnum); <br>    return SUCCEEDED(hr); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Constructor <br> * <br> * Purpose: <br> *  Constructor for an IMPIEnumRect structure <br> * <br> * Parameters: <br> *  None <br> */ <br> <br>PRECTENUMERATOR RECTENUM_Constructor(void) <br>    { <br>    PRECTENUMERATOR     pRE; <br>    UINT                i; <br> <br>    /* <br>     * First time through initialize function table.  Such a table <br>     * could be defined as a constant instead of doing explicit <br>     * initialization here.  However, this method shows exactly <br>     * which pointers are going where and does not depend on knowing <br>     * the ordering of the functions in the table, just the names. <br>     */ <br>    if (!g_fVtblInitialized) <br>        { <br>        vtEnumRect.QueryInterface=RECTENUM_QueryInterface; <br>        vtEnumRect.AddRef        =RECTENUM_AddRef; <br>        vtEnumRect.Release       =RECTENUM_Release; <br>        vtEnumRect.Next          =RECTENUM_Next; <br>        vtEnumRect.Skip          =RECTENUM_Skip; <br>        vtEnumRect.Reset         =RECTENUM_Reset; <br>        vtEnumRect.Clone         =RECTENUM_Clone; <br> <br>        g_fVtblInitialized=TRUE; <br>        } <br> <br>    pRE=(PRECTENUMERATOR)malloc(sizeof(RECTENUMERATOR)); <br> <br>    if (NULL==pRE) <br>        return NULL; <br> <br>    //Initialize function table pointer <br>    pRE-&gt;lpVtbl=&amp;vtEnumRect; <br> <br>    //Initialize the array of rectangles <br>    for (i=0; i &lt; CRECTS; i++) <br>        SetRect(&amp;pRE-&gt;m_rgrc[i], i, i*2, i*3, i*4); <br> <br>    //Ref counts always start at zero <br>    pRE-&gt;m_cRef=0; <br> <br>    //Current pointer is the first element. <br>    pRE-&gt;m_iCur=0; <br> <br>    return pRE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Destructor <br> * <br> * Purpose: <br> *  Destructor for RECTENUMERATOR structures. <br> * <br> * Parameters: <br> *  pRE            PRECTENUMERATOR to free <br> */ <br> <br>void RECTENUM_Destructor(PRECTENUMERATOR pRE) <br>    { <br>    if (NULL==pRE) <br>        return; <br> <br>    free(pRE); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * RECTENUM_QueryInterface <br> * <br> * Purpose: <br> *  Manages interfaces for the RECTENUMERATOR object. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> *  riid            REFIID of the interface to return. <br> *  ppv             PPVOID in which to return the pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, E_NOINTERFACE if the <br> *                  interface is not supported. <br> */ <br> <br>STDMETHODIMP RECTENUM_QueryInterface(PENUMRECT pEnum <br>    , REFIID riid, PPVOID ppv) <br>    { <br>    //Always NULL the out-parameters <br>    *ppv=NULL; <br> <br>    if (IsEqualIID(riid, &amp;IID_IUnknown) <br>        || IsEqualIID(riid, &amp;IID_IEnumRECT)) <br>        *ppv=pEnum; <br> <br>    if (NULL==*ppv) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    //AddRef any interface we'll return. <br>    ((LPUNKNOWN)*ppv)-&gt;lpVtbl-&gt;AddRef((LPUNKNOWN)*ppv); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_AddRef <br> * <br> * Purpose: <br> *  Increments the reference count on the object. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> * <br> * Return Value: <br> *  ULONG           New reference count. <br> */ <br> <br>STDMETHODIMP_(ULONG) RECTENUM_AddRef(PENUMRECT pEnum) <br>    { <br>    PRECTENUMERATOR       pRE=(PRECTENUMERATOR)pEnum; <br> <br>    return ++pRE-&gt;m_cRef; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Release <br> * <br> * Purpose: <br> *  Indicates that someone on whose behalf we once AddRef'd has <br> *  finished with the object.  We decrement our reference count <br> *  and if zero, we delete the object. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> * <br> * Return Value: <br> *  ULONG           Current reference count after decrement.  If <br> *                  this returns zero then the interface is no <br> *                  longer valid. <br> */ <br> <br>STDMETHODIMP_(ULONG) RECTENUM_Release(PENUMRECT pEnum) <br>    { <br>    PRECTENUMERATOR       pRE=(PRECTENUMERATOR)pEnum; <br> <br>    if (0!=--pRE-&gt;m_cRef) <br>        return pRE-&gt;m_cRef; <br> <br>    RECTENUM_Destructor(pRE); <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Next <br> * <br> * Purpose: <br> *  Returns the next rectangle in the enumerator. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> *  cRect           DWORD number of RECTs to return <br> *  prc             LPRECT in which to store the returned RECT. <br> *  pdwRects        LPDWORD in which to store the number of <br> *                  structs returned. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE otherwise, <br> */ <br> <br>STDMETHODIMP RECTENUM_Next(PENUMRECT pEnum, DWORD cRect, LPRECT prc <br>    , LPDWORD pdwRects) <br>    { <br>    PRECTENUMERATOR     pRE=(PRECTENUMERATOR)pEnum; <br>    DWORD               cRectReturn=0L; <br> <br>    if (NULL==pdwRects) <br>        { <br>        if (1L!=cRect) <br>            return ResultFromScode(S_FALSE); <br>        } <br>    else <br>        *pdwRects=0L; <br> <br>    if (NULL==prc || (pRE-&gt;m_iCur &gt;= CRECTS)) <br>        return ResultFromScode(S_FALSE); <br> <br>    while (pRE-&gt;m_iCur &lt; CRECTS &amp;&amp; cRect &gt; 0) <br>        { <br>        *prc++=pRE-&gt;m_rgrc[pRE-&gt;m_iCur++]; <br>        cRectReturn++; <br>        cRect--; <br>        } <br> <br>    if (NULL!=pdwRects) <br>        *pdwRects=cRectReturn; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Skip <br> * <br> * Purpose: <br> *  Skips the next n elements in the enumerator. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> *  cSkip           DWORD number of elements to skip. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE if we could not <br> *                  skip the requested number. <br> */ <br> <br>STDMETHODIMP RECTENUM_Skip(PENUMRECT pEnum, DWORD cSkip) <br>    { <br>    PRECTENUMERATOR     pRE=(PRECTENUMERATOR)pEnum; <br> <br>    if ((pRE-&gt;m_iCur+cSkip) &gt;= CRECTS) <br>        return ResultFromScode(S_FALSE); <br> <br>    pRE-&gt;m_iCur+=cSkip; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * RECTENUM_Reset <br> * <br> * Purpose: <br> *  Resets the current element in the enumerator to zero. <br> * <br> * Parameters: <br> *  pEnum           PENUMRECT to affect <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP RECTENUM_Reset(PENUMRECT pEnum) <br>    { <br>    PRECTENUMERATOR     pRE=(PRECTENUMERATOR)pEnum; <br> <br>    pRE-&gt;m_iCur=0; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * RECTENUM_Clone <br> * <br> * Purpose: <br> *  Creates a copy enumerator. <br> * <br> * Parameters: <br> *  ppEnum          PENUMRECT * in which to store the clone. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, error code otherwise. <br> */ <br> <br>STDMETHODIMP RECTENUM_Clone(PENUMRECT pEnum, PENUMRECT *ppEnum) <br>    { <br>    PRECTENUMERATOR     pRE=(PRECTENUMERATOR)pEnum; <br> <br>    if (CreateRECTEnumeratorC(ppEnum)) <br>        { <br>        /* <br>         * Copy the current index.  The typecast is safe because <br>         * we know that the IEnumRECT from the creation function <br>         * is really a RECTENUMERATOR pointer. <br>         */ <br>        ((PRECTENUMERATOR)(*ppEnum))-&gt;m_iCur=pRE-&gt;m_iCur; <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_OUTOFMEMORY); <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
