<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONNPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context466"></a>CONNPT.CPP</h2>
<pre><code>/* <br> * CONNPT.CPP <br> * <br> * Implemenation of a connection point object that manages <br> * IUnknown pointers.  This is a stand-alone object created from <br> * the implementation of IConnectionPointContainer. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "connect.h" <br> <br> <br>/* <br> * CConnectionPoint::CConnectionPoint <br> * CConnectionPoint::~CConnectionPoint <br> * <br> * Parameters (Constructor): <br> *  pObj            PCConnObject of the object we're in.  We can <br> *                  query this for the IConnectionPointContainer <br> *                  interface we might need. <br> *  riid            REFIID of the interface we're supporting <br> */ <br> <br>CConnectionPoint::CConnectionPoint(PCConnObject pObj, REFIID riid) <br>    { <br>    UINT        i; <br> <br>    m_cRef=0; <br>    m_iid=riid; <br> <br>    /* <br>     * Our lifetime is controlled by the connectable object itself, <br>     * although other external clients will call AddRef and Release. <br>     * Since we're nested in the connectable object's lifetime, <br>     * there's no need to call AddRef on pObj. <br>     */ <br>    m_pObj=pObj; <br> <br>    for (i=0; i &lt; CCONNMAX; i++) <br>        { <br>        m_rgpIUnknown[i]=NULL; <br>        m_rgdwCookies[i]=0; <br>        } <br> <br>    m_cConn=0; <br>    m_dwCookieNext=100;       //Arbitrary starting cookie value <br>    return; <br>    } <br> <br>CConnectionPoint::~CConnectionPoint(void) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i &lt; CCONNMAX; i++) <br>        ReleaseInterface(m_rgpIUnknown[i]); <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::QueryInterface <br> * CConnectionPoint::AddRef <br> * CConnectionPoint::Release <br> * <br> * Purpose: <br> *  Non-delegating IUnknown members for CConnectionPoint. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IConnectionPoint==riid) <br>        *ppv=(LPVOID)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CConnectionPoint::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionInterface <br> * <br> * Purpose: <br> *  Returns the IID of the outgoing interface supported through <br> *  this connection point. <br> * <br> * Parameters: <br> *  pIID            IID * in which to store the IID. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionInterface(IID *pIID) <br>    { <br>    if (NULL==pIID) <br>        return ResultFromScode(E_POINTER); <br> <br>    *pIID=m_iid; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::GetConnectionPointContainer <br> * <br> * Purpose: <br> *  Returns a pointer to the IConnectionPointContainer that <br> *  is manageing this connection point. <br> * <br> * Parameters: <br> *  ppCPC           IConnectionPointContainer ** in which to return <br> *                  the pointer after calling AddRef. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::GetConnectionPointContainer <br>    (IConnectionPointContainer **ppCPC) <br>    { <br>    return m_pObj-&gt;QueryInterface(IID_IConnectionPointContainer <br>        , (void **)ppCPC); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Advise <br> * <br> * Purpose: <br> *  Provides this connection point with a notification sink to <br> *  call whenever the appropriate outgoing function/event occurs. <br> * <br> * Parameters: <br> *  pUnkSink        LPUNKNOWN to the sink to notify.  The connection <br> *                  point must QueryInterface on this pointer to obtain <br> *                  the proper interface to call.  The connection <br> *                  point must also insure that any pointer held has <br> *                  a reference count (QueryInterface will do it). <br> *  pdwCookie       DWORD * in which to store the connection key for <br> *                  later calls to Unadvise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Advise(LPUNKNOWN pUnkSink <br>    , DWORD *pdwCookie) <br>    { <br>    UINT            i; <br>    IUnknown       *pSink; <br> <br>    *pdwCookie=0; <br> <br>    //Check if we're already full of sink pointers <br>    if (CCONNMAX==m_cConn) <br>        return ResultFromScode(CONNECT_E_ADVISELIMIT); <br> <br>    /* <br>     * Verify that the sink has the interface it's supposed <br>     * to.  We don't have to know what it is because we have <br>     * m_iid to describe it.  If this works, then we neatly <br>     * have a pointer with an AddRef that we can stow away. <br>     */ <br>    if (FAILED(pUnkSink-&gt;QueryInterface(m_iid, (PPVOID)&amp;pSink))) <br>        return ResultFromScode(CONNECT_E_CANNOTCONNECT); <br> <br>    /* <br>     * We got the sink, now store it in our array.  We'll look for <br>     * the first entry that is NULL, indicating a free spot. <br>     */ <br>    for (i=0; i &lt; CCONNMAX; i++) <br>        { <br>        if (NULL==m_rgpIUnknown[i]) <br>            { <br>            m_rgpIUnknown[i]=pSink; <br> <br>            /* <br>             * Note:  this increment is not thread safe.  Needs <br>             * to be blocked with a semaphore if this were a <br>             * multi-threaded object. <br>             */ <br>            m_rgdwCookies[i]=++m_dwCookieNext; <br>            *pdwCookie=m_dwCookieNext; <br>            break; <br>            } <br>        } <br> <br>    m_cConn++; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::Unadvise <br> * <br> * Purpose: <br> *  Terminates the connection to the notification sink identified <br> *  with dwCookie (that was returned from Advise).  The connection <br> *  point has to Release any held pointers for that sink. <br> * <br> * Parameters: <br> *  dwCookie        DWORD connection key from Advise. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::Unadvise(DWORD dwCookie) <br>    { <br>    UINT        i; <br> <br>    if (0==dwCookie) <br>        return ResultFromScode(E_INVALIDARG); <br> <br>    for (i=0; i &lt; CCONNMAX; i++) <br>        { <br>        if (dwCookie==m_rgdwCookies[i]) <br>            { <br>            //This releases the sink and sets the pointer to NULL <br>            ReleaseInterface(m_rgpIUnknown[i]); <br>            m_rgdwCookies[i]=0; <br>            m_cConn--; <br>            return NOERROR; <br>            } <br>        } <br> <br>    return ResultFromScode(CONNECT_E_NOCONNECTION); <br>    } <br> <br> <br> <br>/* <br> * CConnectionPoint::EnumConnections <br> * <br> * Purpose: <br> *  Creates and returns an enumerator object with the <br> *  IEnumConnections interface that will enumerate the IUnknown <br> *  pointers of each connected sink. <br> * <br> * Parameters: <br> *  ppEnum          LPENUMCONNECTIONS in which to store the <br> *                  IEnumConnections pointer. <br> */ <br> <br>STDMETHODIMP CConnectionPoint::EnumConnections <br>    (LPENUMCONNECTIONS *ppEnum) <br>    { <br>    LPCONNECTDATA       pCD; <br>    UINT                i, j; <br>    PCEnumConnections   pEnum; <br> <br>    *ppEnum=NULL; <br> <br>    if (0==m_cConn) <br>        return ResultFromScode(OLE_E_NOCONNECTION); <br> <br>    /* <br>     * Create the array of CONNECTDATA structures to give to the <br>     * enumerator. <br>     */ <br>    pCD=new CONNECTDATA[(UINT)m_cConn]; <br> <br>    if (NULL==pCD) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    for (i=0, j=0; i &lt; CCONNMAX; i++) <br>        { <br>        if (NULL!=m_rgpIUnknown[i]) <br>            { <br>            pCD[j].pUnk=(LPUNKNOWN)m_rgpIUnknown[i]; <br>            pCD[j].dwCookie=m_rgdwCookies[i]; <br>            j++; <br>            } <br>        } <br> <br>    /* <br>     * If creation works, it makes a copy pCD, so we can <br>     * always delete it regardless of the outcome. <br>     */ <br>    pEnum=new CEnumConnections(this, m_cConn, pCD); <br>    delete [] pCD; <br> <br>    if (NULL==pEnum) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    //This does an AddRef for us. <br>    return pEnum-&gt;QueryInterface(IID_IEnumConnections, (PPVOID)ppEnum); <br>    } <br> <br> <br> <br> <br>//Connection Enumerator follows <br> <br> <br>/* <br> * CEnumConnections::CEnumConnections <br> * CEnumConnections::~CEnumConnections <br> * <br> * Parameters (Constructor): <br> *  pUnkRef         LPUNKNOWN to use for reference counting. <br> *  cConn           ULONG number of connections in prgpConn <br> *  prgConnData     LPCONNECTDATA to the array to enumerate. <br> */ <br> <br>CEnumConnections::CEnumConnections(LPUNKNOWN pUnkRef, ULONG cConn <br>    , LPCONNECTDATA prgConnData) <br>    { <br>    UINT        i; <br> <br>    m_cRef=0; <br>    m_pUnkRef=pUnkRef; <br> <br>    m_iCur=0; <br>    m_cConn=cConn; <br> <br>    /* <br>     * Copy the passed array.  We need to do this because a clone <br>     * has to have its own copy as well. <br>     */ <br>    m_rgConnData=new CONNECTDATA[(UINT)cConn]; <br> <br>    if (NULL!=m_rgConnData) <br>        { <br>        for (i=0; i &lt; cConn; i++) <br>            { <br>            m_rgConnData[i]=prgConnData[i]; <br>            m_rgConnData[i].pUnk-&gt;AddRef(); <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br>CEnumConnections::~CEnumConnections(void) <br>    { <br>    if (NULL!=m_rgConnData) <br>        { <br>        UINT        i; <br> <br>        for (i=0; i &lt; m_cConn; i++) <br>            m_rgConnData[i].pUnk-&gt;Release(); <br> <br>        delete [] m_rgConnData; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CEnumConnections::QueryInterface <br> * CEnumConnections::AddRef <br> * CEnumConnections::Release <br> * <br> * Purpose: <br> *  IUnknown members for CEnumConnections object. <br> */ <br> <br>STDMETHODIMP CEnumConnections::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IEnumConnections==riid) <br>        *ppv=(LPVOID)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CEnumConnections::AddRef(void) <br>    { <br>    ++m_cRef; <br>    m_pUnkRef-&gt;AddRef(); <br>    return m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CEnumConnections::Release(void) <br>    { <br>    m_pUnkRef-&gt;Release(); <br> <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CEnumConnections::Next <br> * <br> * Purpose: <br> *  Returns the next element in the enumeration. <br> * <br> * Parameters: <br> *  cConn           ULONG number of connections to return. <br> *  pConnData       LPCONNECTDATA in which to store the returned <br> *                  structures. <br> *  pulEnum         ULONG * in which to return how many we <br> *                  enumerated. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE otherwise, <br> */ <br> <br>STDMETHODIMP CEnumConnections::Next(ULONG cConn <br>    , LPCONNECTDATA pConnData, ULONG *pulEnum) <br>    { <br>    ULONG               cReturn=0L; <br> <br>    if (NULL==m_rgConnData) <br>        return ResultFromScode(S_FALSE); <br> <br>    if (NULL==pulEnum) <br>        { <br>        if (1L!=cConn) <br>            return ResultFromScode(E_POINTER); <br>        } <br>    else <br>        *pulEnum=0L; <br> <br>    if (NULL==pConnData || m_iCur &gt;= m_cConn) <br>        return ResultFromScode(S_FALSE); <br> <br>    while (m_iCur &lt; m_cConn &amp;&amp; cConn &gt; 0) <br>        { <br>        *pConnData++=m_rgConnData[m_iCur]; <br>        m_rgConnData[m_iCur++].pUnk-&gt;AddRef(); <br>        cReturn++; <br>        cConn--; <br>        } <br> <br>    if (NULL!=pulEnum) <br>        *pulEnum=cReturn; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br>STDMETHODIMP CEnumConnections::Skip(ULONG cSkip) <br>    { <br>    if (((m_iCur+cSkip) &gt;= m_cConn) || NULL==m_rgConnData) <br>        return ResultFromScode(S_FALSE); <br> <br>    m_iCur+=cSkip; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumConnections::Reset(void) <br>    { <br>    m_iCur=0; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumConnections::Clone(LPENUMCONNECTIONS *ppEnum) <br>    { <br>    PCEnumConnections   pNew; <br> <br>    *ppEnum=NULL; <br> <br>    //Create the clone <br>    pNew=new CEnumConnections(m_pUnkRef, m_cConn, m_rgConnData); <br> <br>    if (NULL==pNew) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    pNew-&gt;AddRef(); <br>    pNew-&gt;m_iCur=m_iCur; <br> <br>    *ppEnum=pNew; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
