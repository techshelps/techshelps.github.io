<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OBJECT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context468"></a>OBJECT.CPP</h2>
<pre><code>/* <br> * OBJECT.CPP <br> * <br> * Connectable Object implementation that supports the sample <br> * interface IDuckEvents. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "connect.h" <br> <br> <br>/* <br> * CConnObject::CConnObject <br> * CConnObject::~CConnObject <br> * <br> * Constructor Parameters: <br> *  None <br> */ <br> <br>CConnObject::CConnObject(void) <br>    { <br>    UINT        i; <br> <br>    m_cRef=0; <br> <br>    for (i=0; i &lt; CCONNPOINTS; i++) <br>        m_rgpConnPt[i]=NULL; <br> <br>    return; <br>    } <br> <br>CConnObject::~CConnObject(void) <br>    { <br>    UINT    i; <br> <br>    for (i=0; i &lt; CCONNPOINTS; i++) <br>        { <br>        if (NULL!=m_rgpConnPt[i]) <br>            { <br>            if (NULL!=m_rgpConnPt[i]) <br>                delete m_rgpConnPt[i]; <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CConnObject::Init <br> * <br> * Purpose: <br> *  Instantiates the interface implementations for this object. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeds, FALSE otherwise. <br> */ <br> <br>BOOL CConnObject::Init(void) <br>    { <br>    UINT    i; <br> <br>    //Create our connection points <br>    for (i=0; i &lt; CCONNPOINTS; i++) <br>        { <br>        m_rgpConnPt[i]=new CConnectionPoint(this, IID_IDuckEvents); <br> <br>        if (NULL==m_rgpConnPt[i]) <br>            return FALSE; <br> <br>        m_rgpConnPt[i]-&gt;AddRef(); <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CConnObject::QueryInterface <br> * <br> * Purpose: <br> *  Manages the interfaces for this object which supports the <br> *  IUnknown, ISampleOne, and ISampleTwo interfaces. <br> * <br> * Parameters: <br> *  riid            REFIID of the interface to return. <br> *  ppv             PPVOID in which to store the pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, E_NOINTERFACE if the <br> *                  interface is not supported. <br> */ <br> <br>STDMETHODIMP CConnObject::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    //Always NULL the out-parameters <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IConnectionPointContainer==riid) <br>        *ppv=this; <br> <br>    if (NULL==*ppv) <br>        return ResultFromScode(E_NOINTERFACE); <br> <br>    ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnObject::AddRef <br> * CConnObject::Release <br> * <br> * Reference counting members.  When Release sees a zero count <br> * the object destroys itself. <br> */ <br> <br>DWORD CConnObject::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>DWORD CConnObject::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br>/* <br> * CConnObject::EnumConnectionPoints <br> * <br> * Purpose: <br> *  Creates and returns an enumerator object with the <br> *  IEnumConnectionPoints interface that will enumerate the <br> *  individual connection points supported in this object. <br> * <br> * Parameters: <br> *  ppEnum          LPENUMCONNECTIONPOINTS in which to store the <br> *                  IEnumConnectionPoints pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, E_OUTOFMEMORY on failure or <br> *                  other error code. <br> */ <br> <br>STDMETHODIMP CConnObject::EnumConnectionPoints <br>    (LPENUMCONNECTIONPOINTS *ppEnum) <br>    { <br>    IConnectionPoint       *rgCP[CCONNPOINTS]; <br>    UINT                    i; <br>    PCEnumConnectionPoints  pEnum; <br> <br>    *ppEnum=NULL; <br> <br>    for (i=0; i &lt; CCONNPOINTS; i++) <br>        rgCP[i]=(IConnectionPoint *)m_rgpConnPt[i]; <br> <br>    //Create the enumerator:  we only have one connection point <br>    pEnum=new CEnumConnectionPoints(this, CCONNPOINTS, rgCP); <br> <br>    if (NULL==pEnum) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    pEnum-&gt;AddRef(); <br>    *ppEnum=pEnum; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CConnObject::FindConnectionPoint <br> * <br> * Purpose: <br> *  Returns a pointer to the IConnectionPoint for a given <br> *  outgoing IID. <br> * <br> * Parameters: <br> *  riid            REFIID of the outgoing interface for which <br> *                  a connection point is desired. <br> *  ppCP            IConnectionPoint ** in which to return <br> *                  the pointer after calling AddRef. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the connection point is found, <br> *                  E_NOINTERFACE if it's not supported. <br> */ <br> <br>STDMETHODIMP CConnObject::FindConnectionPoint(REFIID riid <br>    , IConnectionPoint **ppCP) <br>    { <br>    *ppCP=NULL; <br> <br>    if (IID_IDuckEvents==riid) <br>        { <br>        return m_rgpConnPt[0]-&gt;QueryInterface(IID_IConnectionPoint <br>            , (PPVOID)ppCP); <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br> <br>/* <br> * CConnObject::TriggerEvent <br> * <br> * Purpose: <br> *  Functions to make each connection point generate calls <br> *  to any connected sinks.  Since these functions are specific <br> *  to IDuckEvents, they only deal with the connection point <br> *  for that one interface <br> * <br> * Parameters: <br> *  iEvent          UINT of the event to trigger, either <br> *                  EVENT_QUACK, EVENT_FLAP, or EVENT_PADDLE. <br> * <br> * Return Value: <br> *  BOOL            TRUE events are triggered, FALSE if there <br> *                  are no connected sinks. <br> */ <br> <br>BOOL CConnObject::TriggerEvent(UINT iEvent) <br>    { <br>    IEnumConnections   *pEnum; <br>    CONNECTDATA         cd; <br> <br>    if (FAILED(m_rgpConnPt[0]-&gt;EnumConnections(&amp;pEnum))) <br>        return FALSE; <br> <br>    while (NOERROR==pEnum-&gt;Next(1, &amp;cd, NULL)) <br>        { <br>        IDuckEvents    *pDuck; <br> <br>        if (SUCCEEDED(cd.pUnk-&gt;QueryInterface(IID_IDuckEvents <br>            , (PPVOID)&amp;pDuck))) <br>            { <br>            switch (iEvent) <br>                { <br>                case EVENT_QUACK: <br>                    pDuck-&gt;Quack(); <br>                    break; <br> <br>                case EVENT_FLAP: <br>                    pDuck-&gt;Flap(); <br>                    break; <br> <br>                case EVENT_PADDLE: <br>                    pDuck-&gt;Paddle(); <br>                    break; <br>                } <br> <br>            pDuck-&gt;Release(); <br>            } <br> <br>        cd.pUnk-&gt;Release(); <br>        } <br> <br>    pEnum-&gt;Release(); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>//Connection Point Enumerator follows <br> <br> <br>/* <br> * CEnumConnectionPoints::CEnumConnectionPoints <br> * CEnumConnectionPoints::~CEnumConnectionPoints <br> * <br> * Parameters (Constructor): <br> *  pUnkRef         LPUNKNOWN to use for reference counting. <br> *  cPoints         ULONG number of connection points in prgpCP <br> *  rgpCP           IConnectionPoint** to the array to enumerate. <br> */ <br> <br>CEnumConnectionPoints::CEnumConnectionPoints(LPUNKNOWN pUnkRef <br>    , ULONG cPoints, IConnectionPoint **rgpCP) <br>    { <br>    UINT        i; <br> <br>    m_cRef=0; <br>    m_pUnkRef=pUnkRef; <br> <br>    m_iCur=0; <br>    m_cPoints=cPoints; <br>    m_rgpCP=new IConnectionPoint *[(UINT)cPoints]; <br> <br>    if (NULL!=m_rgpCP) <br>        { <br>        for (i=0; i &lt; cPoints; i++) <br>            { <br>            m_rgpCP[i]=rgpCP[i]; <br>            m_rgpCP[i]-&gt;AddRef(); <br>            } <br>        } <br> <br>    return; <br>    } <br> <br> <br>CEnumConnectionPoints::~CEnumConnectionPoints(void) <br>    { <br>    if (NULL!=m_rgpCP) <br>        { <br>        UINT        i; <br> <br>        for (i=0; i &lt; m_cPoints; i++) <br>            m_rgpCP[i]-&gt;Release(); <br> <br>        delete [] m_rgpCP; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CEnumConnectionPoints::QueryInterface <br> * CEnumConnectionPoints::AddRef <br> * CEnumConnectionPoints::Release <br> * <br> * Purpose: <br> *  IUnknown members for CEnumConnectionPoints object. <br> */ <br> <br>STDMETHODIMP CEnumConnectionPoints::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IEnumConnectionPoints==riid) <br>        *ppv=(LPVOID)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CEnumConnectionPoints::AddRef(void) <br>    { <br>    ++m_cRef; <br>    m_pUnkRef-&gt;AddRef(); <br>    return m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CEnumConnectionPoints::Release(void) <br>    { <br>    m_pUnkRef-&gt;Release(); <br> <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CEnumConnectionPoints::Next <br> * <br> * Purpose: <br> *  Returns the next element in the enumeration. <br> * <br> * Parameters: <br> *  cPoints         ULONG number of connection points to return. <br> *  ppCP            IConnectionPoint** in which to store the returned <br> *                  pointers. <br> *  pulEnum         ULONG * in which to return how many we <br> *                  enumerated. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_FALSE otherwise, <br> */ <br> <br>STDMETHODIMP CEnumConnectionPoints::Next(ULONG cPoints <br>    , IConnectionPoint **ppCP, ULONG *pulEnum) <br>    { <br>    ULONG               cReturn=0L; <br> <br>    if (NULL==m_rgpCP) <br>        return ResultFromScode(S_FALSE); <br> <br>    if (NULL==ppCP) <br>        return ResultFromScode(E_POINTER); <br> <br>    if (NULL==pulEnum) <br>        { <br>        if (1L!=cPoints) <br>            return ResultFromScode(E_POINTER); <br>        } <br>    else <br>        *pulEnum=0L; <br> <br>    if (NULL==*ppCP || m_iCur &gt;= m_cPoints) <br>        return ResultFromScode(S_FALSE); <br> <br>    while (m_iCur &lt; m_cPoints &amp;&amp; cPoints &gt; 0) <br>        { <br>        *ppCP=m_rgpCP[m_iCur++]; <br> <br>        if (NULL!=*ppCP) <br>            (*ppCP)-&gt;AddRef(); <br> <br>        ppCP++; <br>        cReturn++; <br>        cPoints--; <br>        } <br> <br>    if (NULL!=pulEnum) <br>        *pulEnum=cReturn; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>STDMETHODIMP CEnumConnectionPoints::Skip(ULONG cSkip) <br>    { <br>    if (((m_iCur+cSkip) &gt;= m_cPoints) || NULL==m_rgpCP) <br>        return ResultFromScode(S_FALSE); <br> <br>    m_iCur+=cSkip; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumConnectionPoints::Reset(void) <br>    { <br>    m_iCur=0; <br>    return NOERROR; <br>    } <br> <br> <br>STDMETHODIMP CEnumConnectionPoints::Clone <br>    (LPENUMCONNECTIONPOINTS *ppEnum) <br>    { <br>    PCEnumConnectionPoints   pNew; <br> <br>    *ppEnum=NULL; <br> <br>    //Create the clone <br>    pNew=new CEnumConnectionPoints(m_pUnkRef, m_cPoints, m_rgpCP); <br> <br>    if (NULL==pNew) <br>        return ResultFromScode(E_OUTOFMEMORY); <br> <br>    pNew-&gt;AddRef(); <br>    pNew-&gt;m_iCur=m_iCur; <br> <br>    *ppEnum=pNew; <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
