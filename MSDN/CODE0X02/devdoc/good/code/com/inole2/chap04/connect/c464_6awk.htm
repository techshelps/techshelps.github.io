<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONNECT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context464"></a>CONNECT.CPP</h2>
<pre><code>/* <br> * CONNECT.CPP <br> * Demonstration of connectable objects and connection points, <br> * Chapter 4 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "connect.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG     msg; <br>    PAPP    pApp; <br> <br>    pApp=new CApp(hInst, hInstPrev, nCmdShow); <br> <br>    if (NULL==pApp) <br>        return -1; <br> <br>    if (pApp-&gt;Init()) <br>        { <br>        while (GetMessage(&amp;msg, NULL, 0,0 )) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    delete pApp; <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * ConnectWndProc <br> * <br> * Purpose: <br> *  Standard window class procedure. <br> */ <br> <br>LRESULT APIENTRY ConnectWndProc(HWND hWnd, UINT iMsg, WPARAM wParam <br>    , LPARAM lParam) <br>    { <br>    PAPP            pApp; <br>    BOOL            fRes; <br>    PCConnObject    pObj; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    pApp=(PAPP)GetWindowLong(hWnd, CONNECTWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pApp=(PAPP)(((LPCREATESTRUCT)lParam)-&gt;lpCreateParams); <br>            SetWindowLong(hWnd, CONNECTWL_STRUCTURE, (LONG)pApp); <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br> <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br> <br>        case WM_COMMAND: <br>            switch (wID) <br>                { <br>                case IDM_OBJECTCREATE: <br>                    if (NULL!=pApp-&gt;m_pObj) <br>                        { <br>                        //Make sure the sinks disconnect <br>                        pApp-&gt;Disconnect(SINK1); <br>                        pApp-&gt;Disconnect(SINK2); <br>                        pApp-&gt;m_pObj-&gt;Release(); <br>                        } <br> <br>                    fRes=FALSE; <br> <br>                    /* <br>                     * OLE clients never have direct access to <br>                     * an object's C++ class like this, so the <br>                     * sequence from here through the AddRef will <br>                     * always be encapsulated within the object's <br>                     * own creation functions.  This sample is a <br>                     * little contrived. <br>                     */ <br>                    pObj=new CConnObject(); <br> <br>                    if (NULL!=pObj) <br>                        { <br>                        fRes=pObj-&gt;Init(); <br>                        pObj-&gt;AddRef(); <br>                        } <br> <br>                    pApp-&gt;m_pObj=pObj; <br>                    pApp-&gt;Message(fRes ? TEXT("Object created") <br>                        : TEXT("Object creation failed")); <br> <br>                    break; <br> <br> <br>                case IDM_OBJECTRELEASE: <br>                    if (NULL==pApp-&gt;m_pObj) <br>                        { <br>                        pApp-&gt;Message(TEXT("There is no object")); <br>                        break; <br>                        } <br> <br>                    //Make sure the sinks disconnect <br>                    pApp-&gt;Disconnect(SINK1); <br>                    pApp-&gt;Disconnect(SINK2); <br> <br>                    if (0==pApp-&gt;m_pObj-&gt;Release()) <br>                        { <br>                        pApp-&gt;m_pObj=NULL; <br>                        pApp-&gt;Message(TEXT("Object released")); <br>                        } <br> <br>                    break; <br> <br> <br>                case IDM_OBJECTSINK1CONNECT: <br>                    pApp-&gt;Connect(SINK1); <br>                    break; <br> <br>                case IDM_OBJECTSINK1DISCONNECT: <br>                    pApp-&gt;Disconnect(SINK1); <br>                    break; <br> <br>                case IDM_OBJECTSINK2CONNECT: <br>                    pApp-&gt;Connect(SINK2); <br>                    break; <br> <br>                case IDM_OBJECTSINK2DISCONNECT: <br>                    pApp-&gt;Disconnect(SINK2); <br>                    break; <br> <br>                case IDM_OBJECTEXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br> <br> <br>                case IDM_TRIGGERQUACK: <br>                case IDM_TRIGGERFLAP: <br>                case IDM_TRIGGERPADDLE: <br>                    if (NULL==pApp-&gt;m_pObj) <br>                        { <br>                        pApp-&gt;Message(TEXT("There is no object")); <br>                        break; <br>                        } <br> <br>                    //The math gets the right ID for the event <br>                    if (!pApp-&gt;m_pObj-&gt;TriggerEvent <br>                        (wID-IDM_TRIGGERQUACK+EVENT_QUACK)) <br>                        { <br>                        pApp-&gt;Message <br>                            (TEXT("There are no connected sinks")); <br>                        } <br> <br>                    break; <br> <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::CApp <br> * CApp::~CApp <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE of the Application from WinMain <br> *  hInstPrev       HINSTANCE of a previous instance from WinMain <br> *  nCmdShow        UINT specifying how to show the app window, <br> *                  from WinMain. <br> */ <br> <br>CApp::CApp(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , UINT nCmdShow) <br>    { <br>    //Initialize WinMain parameter holders. <br>    m_hInst     =hInst; <br>    m_hInstPrev =hInstPrev; <br>    m_nCmdShow  =nCmdShow; <br> <br>    m_hWnd=NULL; <br>    m_pObj=NULL; <br> <br>    m_rgpSink[0]=NULL; <br>    m_rgpSink[1]=NULL; <br> <br>    return; <br>    } <br> <br> <br>CApp::~CApp(void) <br>    { <br>    //Release the object if we still have it. <br>    ReleaseInterface(m_pObj); <br>    Disconnect(SINK1); <br>    Disconnect(SINK2); <br> <br>    ReleaseInterface(m_rgpSink[SINK1]); <br>    ReleaseInterface(m_rgpSink[SINK2]); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Connect <br> * CApp::Disconnect <br> * <br> * Purpose: <br> *  Connects or disconnects a sink object to or from the <br> *  connectable object we have. <br> * <br> * Parameters: <br> *  uID             UINT identifying which sink to use. <br> */ <br> <br>void CApp::Connect(UINT uID) <br>    { <br>    HRESULT             hr; <br>    IConnectionPoint   *pCP; <br> <br>    if (NULL==m_pObj) <br>        { <br>        Message(TEXT("There is no object")); <br>        return; <br>        } <br> <br>    if (SINK2 &lt; uID) <br>        return; <br> <br>    //Is this sink connected already? <br>    if (0!=m_rgpSink[uID]-&gt;m_dwCookie) <br>        { <br>        Message(TEXT("This sink is already connected")); <br>        return; <br>        } <br> <br>    pCP=GetConnectionPoint(); <br> <br>    if (NULL!=pCP) <br>        { <br>        hr=pCP-&gt;Advise(m_rgpSink[uID] <br>            , &amp;m_rgpSink[uID]-&gt;m_dwCookie); <br> <br>        if (FAILED(hr)) <br>            Message(TEXT("Connection failed")); <br>        else <br>            Message(TEXT("Connection complete")); <br> <br>        pCP-&gt;Release(); <br>        } <br>    else <br>        Message(TEXT("Failed to get IConnectionPoint")); <br> <br>    return; <br>    } <br> <br> <br>void CApp::Disconnect(UINT uID) <br>    { <br>    HRESULT             hr; <br>    IConnectionPoint   *pCP; <br> <br>    if (NULL==m_pObj) <br>        { <br>        Message(TEXT("There is no object")); <br>        return; <br>        } <br> <br>    //Is the sink connected at all? <br>    if (0==m_rgpSink[uID]-&gt;m_dwCookie) <br>        { <br>        Message(TEXT("This sink is not connected")); <br>        return; <br>        } <br> <br>    pCP=GetConnectionPoint(); <br> <br>    if (NULL!=pCP) <br>        { <br>        hr=pCP-&gt;Unadvise(m_rgpSink[uID]-&gt;m_dwCookie); <br> <br>        if (FAILED(hr)) <br>            Message(TEXT("Disconnection failed")); <br>        else <br>            { <br>            Message(TEXT("Disconnection complete")); <br>            m_rgpSink[uID]-&gt;m_dwCookie=0; <br>            } <br> <br>        pCP-&gt;Release(); <br>        } <br>    else <br>        Message(TEXT("Failed to get IConnectionPoint")); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::GetConnectionPoint <br> * <br> * Purpose: <br> *  Asks the connectable object for an IConnectionPoint for <br> *  IDuckEvents. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  IConnectionPoint * to the interface <br> */ <br> <br>IConnectionPoint * CApp::GetConnectionPoint(void) <br>    { <br>    HRESULT                     hr; <br>    IConnectionPointContainer  *pCPCont; <br>    IConnectionPoint           *pCP=NULL; <br> <br>    hr=m_pObj-&gt;QueryInterface(IID_IConnectionPointContainer <br>        , (PPVOID)&amp;pCPCont); <br> <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    hr=pCPCont-&gt;FindConnectionPoint(IID_IDuckEvents, &amp;pCP); <br>    pCPCont-&gt;Release(); <br> <br>    //This check isn't necessary...just adds clarity <br>    if (FAILED(hr)) <br>        return NULL; <br> <br>    return pCP; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure.  If this function fails the caller should guarantee <br> *  that the destructor is called. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::Init(void) <br>    { <br>    WNDCLASS    wc; <br> <br>    //Create the two sink objects we might use <br>    m_rgpSink[SINK1]=new CDuckEvents(this, SINK1); <br>    m_rgpSink[SINK2]=new CDuckEvents(this, SINK2); <br> <br>    if (NULL==m_rgpSink[SINK1] || NULL==m_rgpSink[SINK2]) <br>        return FALSE; <br> <br>    //Lock the lifetimes of these two objects <br>    m_rgpSink[SINK1]-&gt;AddRef(); <br>    m_rgpSink[SINK2]-&gt;AddRef(); <br> <br>    //Create windows and such <br>    if (!m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = ConnectWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = CBWNDEXTRA; <br>        wc.hInstance      = m_hInst; <br>        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon")); <br>        wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU); <br>        wc.lpszClassName  = TEXT("CONNECT"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>        } <br> <br>    m_hWnd=CreateWindow(TEXT("CONNECT"), TEXT("Connectable Object Demo") <br>        , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW <br>        ,35, 35, 350, 250, NULL, NULL, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Message <br> * <br> * Purpose: <br> *  Displays a message in the client area of the window.  This is <br> *  just to centralize the call to simpify other code. <br> * <br> * Parameters: <br> *  psz             LPTSTR to the string to display. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void inline CApp::Message(LPTSTR psz) <br>    { <br>    HDC     hDC; <br>    RECT    rc; <br> <br>    hDC=GetDC(m_hWnd); <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br> <br>    /* <br>     * We'll just be sloppy and clear the whole window as <br>     * well as write the string with one ExtTextOut call. <br>     * No word wrapping here... <br>     */ <br> <br>    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &amp;rc, psz, lstrlen(psz), NULL); <br>    ReleaseDC(m_hWnd, hDC); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
