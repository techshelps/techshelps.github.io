<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TENANT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context792"></a>TENANT.CPP</h2>
<pre><code>/* <br> * TENANT.CPP <br> * Patron Chapter 17 <br> * <br> * Implementation of the CTentant class which holds information <br> * for a single object on a page.  It maintains position, references <br> * to data, and a storage. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "patron.h" <br> <br> <br>/* <br> * CTenant::CTenant <br> * CTenant::~CTenant <br> * <br> * Constructor Parameters: <br> *  dwID            DWORD identifier for this page. <br> *  hWnd            HWND of the pages window. <br> *  pPG             PCPages to the parent structure. <br> */ <br> <br>CTenant::CTenant(DWORD dwID, HWND hWnd, PCPages pPG) <br>    { <br>    m_hWnd=hWnd; <br>    m_dwID=dwID; <br> <br>    m_fInitialized=0; <br>    m_pIStorage=NULL; <br>    m_cOpens=0; <br> <br>    m_pObj=NULL; <br>    m_pPG =pPG; <br>    m_clsID=CLSID_NULL; <br>    m_fSetExtent=FALSE; <br> <br>    //CHAPTER17MOD <br>    m_cRef=0; <br>    m_pIOleObject=NULL; <br>    m_pIViewObject2=NULL; <br>    m_grfMisc=0; <br> <br>    m_pImpIOleClientSite=NULL; <br>    m_pImpIAdviseSink=NULL; <br> <br>    m_fRepaintEnabled=TRUE; <br>    //End CHAPTER17MOD <br>    return; <br>    } <br> <br> <br>CTenant::~CTenant(void) <br>    { <br>    //CHAPTER17MOD <br>    //Object pointers cleaned up in Close. <br> <br>    DeleteInterfaceImp(m_pImpIAdviseSink); <br>    DeleteInterfaceImp(m_pImpIOleClientSite); <br>    //End CHAPTER17MOD <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER17MOD <br>/* <br> * CTenant::QueryInterface <br> * CTenant::AddRef <br> * CTenant::Release <br> * <br> * Purpose: <br> *  IUnknown members for CTenant object. <br> */ <br> <br>STDMETHODIMP CTenant::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IOleClientSite==riid) <br>        *ppv=m_pImpIOleClientSite; <br> <br>    if (IID_IAdviseSink==riid) <br>        *ppv=m_pImpIAdviseSink; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CTenant::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CTenant::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br>//End CHAPTER17MOD <br> <br> <br> <br> <br> <br>/* <br> * CTenant::GetID <br> * <br> * Return Value: <br> *  DWORD           dwID field in this tenant. <br> */ <br> <br>DWORD CTenant::GetID(void) <br>    { <br>    return m_dwID; <br>    } <br> <br> <br> <br>/* <br> * CTenant::GetStorageName <br> * <br> * Parameters: <br> *  pszName         LPOLESTR to a buffer in which to store the storage <br> *                  name for this tenant. <br> * <br> * Return Value: <br> *  UINT            Number of characters stored. <br> */ <br> <br>UINT CTenant::GetStorageName(LPOLESTR pszName) <br>    { <br>   #ifdef WIN32ANSI <br>    char        szTemp[32]; <br>    UINT        cch; <br> <br>    cch=wsprintf(szTemp, "Tenant %lu", m_dwID); <br>    MultiByteToWideChar(CP_ACP, 0, szTemp, -1, pszName, 32); <br>    return cch; <br>   #else <br>    return wsprintf(pszName, TEXT("Tenant %lu"), m_dwID); <br>   #endif <br>    } <br> <br> <br> <br>//CHAPTER17MOD <br>/* <br> * CTenant::StorageGet <br> * <br> * Purpose: <br> *  Returns the IStorage pointer maintained by this tenant, <br> *  AddRef'd of course. <br> * <br> * Parameters: <br> *  ppStg           LPSTORAGE * in which to return the pointer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::StorageGet(LPSTORAGE *ppStg) <br>    { <br>    if (NULL==ppStg) <br>        return; <br> <br>    *ppStg=m_pIStorage; <br> <br>    if (NULL!=*ppStg) <br>        (*ppStg)-&gt;AddRef(); <br> <br>    return; <br>    } <br>//End CHAPTER17MOD <br> <br> <br> <br> <br>/* <br> * CTenant::Create <br> * <br> * Purpose: <br> *  Creates a new tenant of the given CLSID, which can be either a <br> *  static bitmap or metafile or any compound document object. <br> * <br> * Parameters: <br> *  tType           TENANTTYPE to create, either a static metafile, <br> *                  bitmap, or some kind of compound document object <br> *                  This determines which OleCreate* call we use. <br> *  pvType          LPVOID providing the relevant pointer from which <br> *                  to create the tenant, depending on iType. <br> *  pFE             LPFORMATETC specifying the type of renderings <br> *                  to use. <br> *  pptl            PPOINTL in which we store offset coordinates. <br> *  pszl            LPSIZEL where this object should store its <br> *                  lometric extents. <br> *  pIStorage       LPSTORAGE of the page we live in.  We have to <br> *                  create another storage in this for the tenant. <br> *  ppo             PPATRONOBJECT containing placement data. <br> *  dwData          DWORD with extra data, sensitive to iType. <br> * <br> * Return Value: <br> *  UINT            A CREATE_* value depending on what we <br> *                  actually do. <br> */ <br> <br>UINT CTenant::Create(TENANTTYPE tType, LPVOID pvType <br>    , LPFORMATETC pFE, PPOINTL pptl, LPSIZEL pszl <br>    , LPSTORAGE pIStorage, PPATRONOBJECT ppo, DWORD dwData) <br>    { <br>    HRESULT             hr; <br>    LPUNKNOWN           pObj; <br>    UINT                uRet=CREATE_GRAPHICONLY; <br>    //CHAPTER17MOD <br>    //Some things moves to ObjectInitialize <br>    //End CHAPTER17MOD <br> <br>    if (NULL==pvType || NULL==pIStorage) <br>        return CREATE_FAILED; <br> <br>    //Fail if this is called for an already living tenant. <br>    if (m_fInitialized) <br>        return CREATE_FAILED; <br> <br>    m_fInitialized=TRUE; <br> <br>    //Create a new storage for this tenant. <br>    if (!Open(pIStorage)) <br>        return CREATE_FAILED; <br> <br>    /* <br>     * Get the placement info if it's here.  We either have a non- <br>     * NULL PPATRONOBJECT in ppo or we have to use default <br>     * placement and retrieve the size from the object itself. <br>     */ <br>    pszl-&gt;cx=0; <br>    pszl-&gt;cy=0; <br> <br>    if (NULL!=ppo) <br>        { <br>        *pFE=ppo-&gt;fe; <br>        *pptl=ppo-&gt;ptl; <br>        *pszl=ppo-&gt;szl;     //Could be 0,0 , so we ask object <br> <br>        uRet=CREATE_PLACEDOBJECT; <br>        } <br> <br>    hr=ResultFromScode(E_FAIL); <br> <br>    //Now create an object based specifically for the type. <br>    switch (tType) <br>        { <br>        case TENANTTYPE_NULL: <br>            break; <br> <br>        case TENANTTYPE_STATIC: <br>            /* <br>             * We could use OleCreateStaticFromData here which does <br>             * pretty much what we're doing below.  However, it does <br>             * not allow us to control whether we paste a bitmap or <br>             * a metafile--it uses metafile first, bitmap second. <br>             * For this reason we'll use code developed in Chapter <br>             * 11's FreeLoader to affect the paste. <br>             */ <br>            hr=CreateStatic((LPDATAOBJECT)pvType, pFE, &amp;pObj); <br>            break; <br> <br>        //CHAPTER17MOD <br>        case TENANTTYPE_EMBEDDEDOBJECT: <br>            hr=OleCreate(*((LPCLSID)pvType), IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>            break; <br> <br>        case TENANTTYPE_EMBEDDEDFILE: <br>            hr=OleCreateFromFile(CLSID_NULL, (LPTSTR)pvType <br>                , IID_IUnknown, OLERENDER_DRAW, NULL, NULL <br>                , m_pIStorage, (PPVOID)&amp;pObj); <br>            break; <br> <br>        case TENANTTYPE_EMBEDDEDOBJECTFROMDATA: <br>            hr=OleCreateFromData((LPDATAOBJECT)pvType, IID_IUnknown <br>                , OLERENDER_DRAW, NULL, NULL, m_pIStorage <br>                , (PPVOID)&amp;pObj); <br>            break; <br>        //End CHAPTER17MOD <br> <br>        default: <br>            break; <br>        } <br> <br>    //If creation didn't work, get rid of the element Open created. <br>    if (FAILED(hr)) <br>        { <br>        Destroy(pIStorage); <br>        return CREATE_FAILED; <br>        } <br> <br>    //CHAPTER17MOD <br>    //We don't get the size if PatronObject data was seen already. <br>    if (!ObjectInitialize(pObj, pFE, dwData)) <br>        { <br>        Destroy(pIStorage); <br>        return CREATE_FAILED; <br>        } <br> <br>    if (0==pszl-&gt;cx &amp;&amp; 0==pszl-&gt;cy) <br>        { <br>        SIZEL   szl; <br> <br>        //Try to get the real size of the object, default to 2"*2" <br>        SETSIZEL((*pszl), 2*LOMETRIC_PER_INCH, 2*LOMETRIC_PER_INCH); <br>        hr=ResultFromScode(E_FAIL); <br> <br>        //Try IViewObject2 first, then IOleObject as a backup. <br>        if (NULL!=m_pIViewObject2) <br>            { <br>            hr=m_pIViewObject2-&gt;GetExtent(m_fe.dwAspect, -1, NULL <br>                , &amp;szl); <br>            } <br>        else <br>            { <br>            if (NULL!=m_pIOleObject) <br>                hr=m_pIOleObject-&gt;GetExtent(m_fe.dwAspect, &amp;szl); <br>            } <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Convert HIMETRIC to our LOMETRIC mapping <br>            SETSIZEL((*pszl), szl.cx/10, szl.cy/10); <br>            } <br>        } <br>    //End CHAPTER17MOD <br> <br>    return uRet; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Load <br> * <br> * Purpose: <br> *  Recreates the object living in this tenant in place of calling <br> *  FCreate.  This is used in loading as opposed to new creation. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE of the page we live in. <br> *  pti             PTENTANTINFO containing persistent information. <br> *                  The ID value in this structure is ignored. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::Load(LPSTORAGE pIStorage, PTENANTINFO pti) <br>    { <br>    HRESULT         hr; <br>    LPUNKNOWN       pObj; <br>    //CHAPTER17MOD <br>    DWORD           dwState=TENANTSTATE_DEFAULT; <br>    //End CHAPTER17MOD <br> <br>    if (NULL==pIStorage || NULL==pti) <br>        return FALSE; <br> <br>    //CHAPTER17MOD <br>    /* <br>     * If we already initialized once, clean up, releasing <br>     * everything before we attempt to reload.  This happens <br>     * when using the Convert Dialog. <br>     */ <br>    if (m_fInitialized) <br>        { <br>        //Preserve all states except open <br>        dwState=(m_dwState &amp; ~TENANTSTATE_OPEN); <br>        m_cRef++;   //Prevent accidental closure <br> <br>        //This should release all holds on our IStorage as well. <br>        if (NULL!=m_pIViewObject2) <br>            { <br>            m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, NULL); <br>            ReleaseInterface(m_pIViewObject2); <br>            } <br> <br>        ReleaseInterface(m_pIOleObject); <br>        ReleaseInterface(m_pObj); <br> <br>        m_pIStorage=NULL;   //We'll have already released this. <br>        m_cRef--;           //Match safety increment above. <br>        } <br>    //End CHAPTER14MOD <br> <br>    m_fInitialized=TRUE; <br> <br>    //Open the storage for this tenant. <br>    if (!Open(pIStorage)) <br>        return FALSE; <br> <br>    hr=OleLoad(m_pIStorage, IID_IUnknown, NULL, (PPVOID)&amp;pObj); <br> <br>    if (FAILED(hr)) <br>        { <br>        Destroy(pIStorage); <br>        return FALSE; <br>        } <br> <br>    //CHAPTER17MOD <br>    m_fSetExtent=pti-&gt;fSetExtent; <br>    ObjectInitialize(pObj, &amp;pti-&gt;fe, NULL); <br> <br>    //Restore the original state before reloading. <br>    m_dwState=dwState; <br>    //End CHAPTER17MOD <br> <br>    RectSet(&amp;pti-&gt;rcl, FALSE, FALSE); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::GetInfo <br> * <br> * Purpose: <br> *  Retrieved a TENANTINFO structure for this tenant. <br> * <br> * Parameters: <br> *  pti             PTENANTINFO structure to fill <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::GetInfo(PTENANTINFO pti) <br>    { <br>    if (NULL!=pti) <br>        { <br>        pti-&gt;dwID=m_dwID; <br>        pti-&gt;rcl=m_rcl; <br>        pti-&gt;fe=m_fe; <br>        pti-&gt;fSetExtent=m_fSetExtent; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER17MOD <br>/* <br> * CTenant::ObjectInitialize <br> * (Protected) <br> * <br> * Purpose: <br> *  Performs operations necessary after creating an object or <br> *  reloading one from storage. <br> * <br> * Parameters: <br> *  pObj            LPUNKNOWN of the object in this tenant. <br> *  pFE             LPFORMATETC describing the graphic here. <br> *  dwData          DWORD extra data.  If pFE-&gt;dwAspect== <br> *                  DVASPECT_ICON then this is the iconic metafile. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::ObjectInitialize(LPUNKNOWN pObj, LPFORMATETC pFE <br>    , DWORD dwData) <br>    { <br>    HRESULT         hr; <br>    LPPERSIST       pIPersist=NULL; <br>    DWORD           dw; <br>    PCDocument      pDoc; <br>    TCHAR           szFile[CCHPATHMAX]; <br> <br>    if (NULL==pObj || NULL==pFE) <br>        return FALSE; <br> <br>    m_pObj=pObj; <br>    m_fe=*pFE; <br>    m_fe.ptd=NULL; <br>    m_dwState=TENANTSTATE_DEFAULT; <br> <br>    /* <br>     * Determine the type:  Static or Embedded.  If Static, <br>     * this will have CLSID_Picture_Metafile or CLSID_Picture_Dib. <br>     * Otherwise it's embedded.  Later we'll add a case for links. <br>     */ <br>    m_tType=TENANTTYPE_EMBEDDEDOBJECT; <br> <br>    if (SUCCEEDED(pObj-&gt;QueryInterface(IID_IPersist <br>        , (PPVOID)&amp;pIPersist))) <br>        { <br>        CLSID   clsid=CLSID_NULL; <br> <br>        hr=pIPersist-&gt;GetClassID(&amp;clsid); <br> <br>        //If we don't have a CLSID, default to static <br>        if (FAILED(hr) || CLSID_Picture_Metafile==clsid <br>            || CLSID_Picture_Dib==clsid) <br>            m_tType=TENANTTYPE_STATIC; <br> <br>        pIPersist-&gt;Release(); <br>        } <br> <br> <br>    m_pIViewObject2=NULL; <br>    hr=pObj-&gt;QueryInterface(IID_IViewObject2 <br>        , (PPVOID)&amp;m_pIViewObject2); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, m_pImpIAdviseSink); <br> <br>    //We need an IOleObject most of the time, so get one here. <br>    m_pIOleObject=NULL; <br>    hr=pObj-&gt;QueryInterface(IID_IOleObject <br>         , (PPVOID)&amp;m_pIOleObject); <br> <br>    /* <br>     * Follow up object creation with advises and so forth.  If <br>     * we cannot get IOleObject here, then we know we can't do <br>     * any IOleObject actions from here on--object is static. <br>     */ <br>    if (FAILED(hr)) <br>        return TRUE; <br> <br>    /* <br>     * Get the MiscStatus bits and check for OLEMISC_ONLYICONIC. <br>     * If set, force dwAspect in m_fe to DVASPECT_ICON so we <br>     * remember to draw it properly and do extents right. <br>     */ <br>    m_pIOleObject-&gt;GetMiscStatus(m_fe.dwAspect, &amp;m_grfMisc); <br> <br>    if (OLEMISC_ONLYICONIC &amp; m_grfMisc) <br>        m_fe.dwAspect=DVASPECT_ICON; <br> <br>    /* <br>     * We could pass m_pImpIOleClientSite in an OleCreate* call, but <br>     * since this function could be called after OleLoad, we still <br>     * need to do this here, so it's always done here... <br>     */ <br>    m_pIOleObject-&gt;SetClientSite(m_pImpIOleClientSite); <br>    m_pIOleObject-&gt;Advise(m_pImpIAdviseSink, &amp;dw); <br> <br>    OleSetContainedObject(m_pIOleObject, TRUE); <br> <br>    /* <br>     * For IOleObject::SetHostNames we need the application name <br>     * and the document name (which is passed in the object <br>     * parameter).  The design of Patron doesn't give us nice <br>     * structured access to the name of the document we're in, so <br>     * I grab the parent of the Pages window (the document) and <br>     * send it DOCM_PDOCUMENT which returns us the pointer. <br>     * Roundabout, but it works. <br>     */ <br> <br>    pDoc=(PCDocument)SendMessage(GetParent(m_hWnd), DOCM_PDOCUMENT <br>        , 0, 0L); <br> <br>    if (NULL!=pDoc) <br>        pDoc-&gt;FilenameGet(szFile, CCHPATHMAX); <br>    else <br>        szFile[0]=0; <br> <br>    NotifyOfRename(szFile, NULL); <br> <br> <br>    /* <br>     * If we're creating an iconic aspect object and we have <br>     * an object from the Insert Object dialog, then we need to <br>     * store that iconic presentation in the cache, handled <br>     * with the utility function INOLE_SwitchDisplayAspect.  In <br>     * this case dwData is a handle to the metafile containing <br>     * the icon.  If dwData is NULL then we depend on the <br>     * server to provide the aspect, in which case we need <br>     * a view advise. <br>     */ <br> <br>    if (DVASPECT_ICON &amp; m_fe.dwAspect) <br>        { <br>        DWORD           dw=DVASPECT_CONTENT; <br>        IAdviseSink    *pSink; <br> <br>        pSink=(NULL==dwData) ? NULL : m_pImpIAdviseSink; <br> <br>        INOLE_SwitchDisplayAspect(m_pIOleObject, &amp;dw <br>            , DVASPECT_ICON, (HGLOBAL)(UINT)dwData, FALSE <br>            , (NULL!=dwData), pSink, NULL); <br>        } <br> <br>    return TRUE; <br>    } <br>//End CHAPTER17MOD <br> <br> <br> <br> <br>/* <br> * CTenant::Open <br> * <br> * Purpose: <br> *  Retrieves the IStorage associated with this tenant.  The <br> *  IStorage is owned by the tenant and thus the tenant always <br> *  holds a reference count. <br> * <br> *  If the storage is already open for this tenant, then this <br> *  function will AddRef it; therefore the caller must always <br> *  match an Open with a Close. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE above this tenant (which has its <br> *                  own storage). <br> * <br> * Return Value: <br> *  BOOL            TRUE if opening succeeds, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::Open(LPSTORAGE pIStorage) <br>    { <br>    HRESULT     hr=NOERROR; <br>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                    | STGM_SHARE_EXCLUSIVE; <br>    OLECHAR     szTemp[32]; <br> <br>    if (NULL==m_pIStorage) <br>        { <br>        if (NULL==pIStorage) <br>            return FALSE; <br> <br>        /* <br>         * Attempt to open the storage under this ID.  If there is <br>         * none, then create it.  In either case we end up with an <br>         * IStorage that we either save in pPage or release. <br>         */ <br> <br>        GetStorageName(szTemp); <br>        hr=pIStorage-&gt;OpenStorage(szTemp, NULL, dwMode, NULL, 0 <br>            , &amp;m_pIStorage); <br> <br>        if (FAILED(hr)) <br>            { <br>            hr=pIStorage-&gt;CreateStorage(szTemp, dwMode, 0, 0 <br>                , &amp;m_pIStorage); <br>            } <br>        } <br>    else <br>        m_pIStorage-&gt;AddRef(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    m_cOpens++; <br> <br>    //CHAPTER17MOD <br>    //Create these if we don't have them already. <br>    if (NULL==m_pImpIOleClientSite &amp;&amp; NULL==m_pImpIAdviseSink) <br>        { <br>        m_pImpIOleClientSite=new CImpIOleClientSite(this, this); <br>        m_pImpIAdviseSink=new CImpIAdviseSink(this, this); <br> <br>        if (NULL==m_pImpIOleClientSite || NULL==m_pImpIAdviseSink) <br>            return FALSE; <br>        } <br>    //End CHAPTER17MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Close <br> * <br> * Purpose: <br> *  Possibly commits the storage, then releases it reversing the <br> *  reference count from Open.  If the reference on the storage <br> *  goes to zero, the storage is forgotten.  However, the object we <br> *  contain is still held and as long as it's active the storage <br> *  remains alive. <br> * <br> * Parameters: <br> *  fCommit         BOOL indicating if we're to commit. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Close(BOOL fCommit) <br>    { <br>    if (fCommit) <br>        Update(); <br> <br>    if (NULL!=m_pIStorage) <br>        { <br>        m_pIStorage-&gt;Release(); <br> <br>        /* <br>         * We can't use a zero reference count to know when to NULL <br>         * this since other things might have AddRef'd the storage. <br>         */ <br>        //CHAPTER17MOD <br>        if (0==--m_cOpens) <br>            { <br>            m_pIStorage=NULL; <br> <br>            //Close the object saving if necessary <br>            if (NULL!=m_pIOleObject) <br>                { <br>                m_pIOleObject-&gt;Close(OLECLOSE_SAVEIFDIRTY); <br>                ReleaseInterface(m_pIOleObject); <br>                } <br> <br>            //Release all other held pointers <br>            if (NULL!=m_pIViewObject2) <br>                { <br>                m_pIViewObject2-&gt;SetAdvise(m_fe.dwAspect, 0, NULL); <br>                ReleaseInterface(m_pIViewObject2); <br>                } <br> <br>            //We know we only hold one ref from Create or Load <br>            ReleaseInterface(m_pObj); <br>            } <br>        //End CHAPTER17MOD <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Update <br> * <br> * Purpose: <br> *  Forces a common on the page if it's open. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the object is open, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::Update(void) <br>    { <br>    LPPERSISTSTORAGE    pIPS; <br> <br>    if (NULL!=m_pIStorage) <br>        { <br>        /* <br>         * We need to OleSave again because we might have changed <br>         * the size or position of this tenant.  We also need to <br>         * save the rectangle on the page, since that's not known <br>         * to OLE. <br>         */ <br>        m_pObj-&gt;QueryInterface(IID_IPersistStorage, (PPVOID)&amp;pIPS); <br> <br>        //This fails for static objects...so we improvise if so <br>        if (FAILED(OleSave(pIPS, m_pIStorage, TRUE))) <br>            { <br>            //This is essentially what OleSave does. <br>            WriteClassStg(m_pIStorage, m_clsID); <br>            pIPS-&gt;Save(m_pIStorage, TRUE); <br>            } <br> <br>        pIPS-&gt;SaveCompleted(NULL); <br>        pIPS-&gt;Release(); <br> <br>        m_pIStorage-&gt;Commit(STGC_DEFAULT); <br>        } <br> <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Destroy <br> * <br> * Purpose: <br> *  Removes this page from the given storage.  The caller should <br> *  eventually delete this CTenant object to free the object herein. <br> *  Nothing is committed when being destroyed. <br> * <br> * Parameters: <br> *  pIStorage       LPSTORAGE contianing this page on which to call <br> *                  DestroyElement <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Destroy(LPSTORAGE pIStorage) <br>    { <br>    OLECHAR     szTemp[32]; <br> <br>    if (NULL!=pIStorage) <br>        { <br>        //CHAPTER17MOD <br>        if (NULL!=m_pIOleObject) <br>            m_pIOleObject-&gt;Close(OLECLOSE_NOSAVE); <br>        //End CHAPTER17MOD <br> <br>        if (NULL!=m_pIStorage) <br>            { <br>            //Remove all reference/open counts on this storage. <br>            while (0!=m_cOpens) <br>                { <br>                m_pIStorage-&gt;Release(); <br>                m_cOpens--; <br>                } <br>            } <br> <br>        GetStorageName(szTemp); <br>        pIStorage-&gt;DestroyElement(szTemp); <br> <br>        m_pIStorage=NULL; <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::Select <br> * <br> * Purpose: <br> *  Selects or deselects the tenant. <br> * <br> * Parameters: <br> *  fSelect         BOOL indicating the new state of the tenant. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Select(BOOL fSelect) <br>    { <br>    BOOL        fWasSelected; <br>    DWORD       dwState; <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    fWasSelected=(BOOL)(TENANTSTATE_SELECTED &amp; m_dwState); <br> <br>    //Nothing to do when there's no change. <br>    if (fWasSelected==fSelect) <br>        return; <br> <br>    dwState=m_dwState &amp; ~TENANTSTATE_SELECTED; <br>    m_dwState=dwState | ((fSelect) ? TENANTSTATE_SELECTED : 0); <br> <br>    /* <br>     * Draw sizing handles to show the selection state.  We convert <br>     * things to MM_TEXT since that's what this function expects. <br>     */ <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>    hDC=GetDC(m_hWnd); <br> <br>    UIDrawHandles(&amp;rc, hDC, UI_HANDLES_INSIDE <br>        | UI_HANDLES_NOBORDER | UI_HANDLES_USEINVERSE <br>        , CXYHANDLE, !fWasSelected); <br> <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    if (fSelect) <br>        m_pPG-&gt;m_fDirty=TRUE; <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER17MOD <br>/* <br> * CTenant::ShowAsOpen <br> * <br> * Purpose: <br> *  Draws or removes the hatch pattern over an object. <br> * <br> * Parameters: <br> *  fOpen           BOOL indicating the open state of this tenant. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ShowAsOpen(BOOL fOpen) <br>    { <br>    BOOL        fWasOpen; <br>    DWORD       dwState; <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    fWasOpen=(BOOL)(TENANTSTATE_OPEN &amp; m_dwState); <br> <br>    dwState=m_dwState &amp; ~TENANTSTATE_OPEN; <br>    m_dwState=dwState | ((fOpen) ? TENANTSTATE_OPEN : 0); <br> <br>    //If this was not open, then just hatch, otherwise repaint. <br>    if (!fWasOpen &amp;&amp; fOpen) <br>        { <br>        RECTFROMRECTL(rc, m_rcl); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br> <br>        hDC=GetDC(m_hWnd); <br>        UIDrawShading(&amp;rc, hDC, UI_SHADE_FULLRECT, 0); <br>        ReleaseDC(m_hWnd, hDC); <br>        } <br> <br>    if (fWasOpen &amp;&amp; !fOpen) <br>        Repaint(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::ShowYourself <br> * <br> * Purpose: <br> *  Function that really just implements IOleClientSite::ShowObject. <br> *  Here we first check if the tenant is fully visible, and if so, <br> *  then nothing needs to happen.  Otherwise, if the upper left <br> *  corner of the tenant is in the upper left visible quadrant of <br> *  the window, we'll also consider ourselves done.  Otherwise <br> *  we'll put the upper left corner of the object at the upper left <br> *  corner of the window. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ShowYourself(void) <br>    { <br>    RECTL       rcl; <br>    RECT        rc; <br>    POINT       pt1, pt2; <br> <br>    //Scrolling deals in device units; get our rectangle in those. <br>    RectGet(&amp;rcl, TRUE); <br> <br>    //Get the window rectangle offset for the current scroll pos. <br>    GetClientRect(m_hWnd, &amp;rc); <br>    OffsetRect(&amp;rc, m_pPG-&gt;m_xPos, m_pPG-&gt;m_yPos); <br> <br>    //Check if the object is already visible. (macro in bookguid.h) <br>    SETPOINT(pt1, (int)rcl.left,  (int)rcl.top); <br>    SETPOINT(pt2, (int)rcl.right, (int)rcl.bottom); <br> <br>    if (PtInRect(&amp;rc, pt1) &amp;&amp; PtInRect(&amp;rc, pt2)) <br>        return; <br> <br>    //Check if the upper left is within the upper left quadrant <br>    if (((int)rcl.left &gt; rc.left <br>        &amp;&amp; (int)rcl.left &lt; ((rc.right+rc.left)/2)) <br>        &amp;&amp; ((int)rcl.top &gt; rc.top <br>        &amp;&amp; (int)rcl.top &lt; ((rc.bottom+rc.top)/2))) <br>        return; <br> <br>    //These are macros in INC\BOOK1632.H <br>    SendScrollPosition(m_hWnd, WM_HSCROLL, rcl.left-8); <br>    SendScrollPosition(m_hWnd, WM_VSCROLL, rcl.top-8); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CTenant::AddVerbMenu <br> * <br> * Purpose: <br> *  Creates the variable verb menu item for the object in this <br> *  tenant. <br> * <br> * Parmeters: <br> *  hMenu           HMENU on which to add items. <br> *  iPos            UINT position on that menu to add items. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::AddVerbMenu(HMENU hMenu, UINT iPos) <br>    { <br>    HMENU       hMenuTemp; <br>    LPOLEOBJECT pObj=m_pIOleObject; <br> <br>    //If we're static, say we have no object. <br>    if (TENANTTYPE_STATIC==m_tType) <br>        pObj=NULL; <br> <br>    OleUIAddVerbMenu(pObj, NULL, hMenu, iPos, IDM_VERBMIN <br>        , IDM_VERBMAX, TRUE, IDM_EDITCONVERT, &amp;hMenuTemp); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::TypeGet <br> * <br> * Purpose: <br> *  Returns the type of this tenant <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  TENANTTYPE      Type of the tenant. <br> */ <br> <br>TENANTTYPE CTenant::TypeGet(void) <br>    { <br>    return m_tType; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::CopyEmbeddedObject <br> * <br> * Purpose: <br> *  Copies an embedded object to the given data object (via SetData, <br> *  assuming this is a data transfer object for clipboard/drag-drop) <br> *  if that's what we're holding. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT in which to store the copy. <br> *  pFE             LPFORMATETC into which to copy CFSTR_EMBEDDEDOBJECT <br> *                  if we put that in the data object. <br> *  pptl            PPOINTL to the pick point (NULL outside of <br> *                  drag-drop); <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::CopyEmbeddedObject(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, PPOINTL pptl) <br>    { <br>    LPPERSISTSTORAGE    pIPS; <br>    STGMEDIUM           stm; <br>    FORMATETC           fe; <br>    HRESULT             hr; <br>    UINT                cf; <br>    POINTL              ptl; <br>    SIZEL               szl; <br> <br>    //Can only copy embeddings. <br>    if (TENANTTYPE_EMBEDDEDOBJECT!=m_tType || NULL==m_pIOleObject) <br>        return; <br> <br>    if (NULL==pptl) <br>        { <br>        SETPOINTL(ptl, 0, 0); <br>        pptl=&amp;ptl; <br>        } <br> <br>    /* <br>     * Create CFSTR_EMBEDDEDOBJECT.  This is simply an IStorage with <br>     * a copy of the embedded object in it.  The not-so-simple part <br>     * is getting an IStorage to stuff it in.  For this operation <br>     * we'll use a temporary compound file. <br>     */ <br> <br>    stm.pUnkForRelease=NULL; <br>    stm.tymed=TYMED_ISTORAGE; <br>    hr=StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_CREATE| STGM_SHARE_EXCLUSIVE | STGM_DELETEONRELEASE <br>        , 0, &amp;stm.pstg); <br> <br>    if (FAILED(hr)) <br>        return; <br> <br>    m_pObj-&gt;QueryInterface(IID_IPersistStorage, (PPVOID)&amp;pIPS); <br> <br>    if (NOERROR==pIPS-&gt;IsDirty()) <br>        { <br>        OleSave(pIPS, stm.pstg, FALSE); <br>        pIPS-&gt;SaveCompleted(NULL); <br>        } <br>    else <br>        m_pIStorage-&gt;CopyTo(0, NULL, NULL, stm.pstg); <br> <br>    pIPS-&gt;Release(); <br> <br>    //stm.pstg now has a copy, so stuff it away. <br>    cf=RegisterClipboardFormat(CFSTR_EMBEDDEDOBJECT); <br>    SETDefFormatEtc(fe, cf, TYMED_ISTORAGE); <br> <br>    if (SUCCEEDED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        *pFE=fe; <br>    else <br>        ReleaseStgMedium(&amp;stm); <br> <br>    stm.tymed=TYMED_HGLOBAL; <br> <br>    /* <br>     * You want to make sure that if this object is iconic, that you </code></pre>
<p>
</p>
<pre><code>* create the object descriptor with DVASPECT_ICON instead of <br>     * the more typical DVASPECT_CONTENT.  Also remember that <br>     * the pick point is in HIMETRIC. <br>     */ <br>    XformSizeInPixelsToHimetric(NULL, (LPSIZEL)pptl, (LPSIZEL)&amp;ptl); <br> <br>    SETSIZEL(szl, (10*(m_rcl.right-m_rcl.left)) <br>        , (10 * (m_rcl.bottom-m_rcl.top))); <br> <br>    stm.hGlobal=INOLE_ObjectDescriptorFromOleObject <br>        (m_pIOleObject, m_fe.dwAspect, ptl, &amp;szl); <br> <br>    cf=RegisterClipboardFormat(CFSTR_OBJECTDESCRIPTOR); <br>    SETDefFormatEtc(fe, cf, TYMED_HGLOBAL); <br> <br>    if (FAILED(pIDataObject-&gt;SetData(&amp;fe, &amp;stm, TRUE))) <br>        ReleaseStgMedium(&amp;stm); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::NotifyOfRename <br> * <br> * Purpose: <br> *  Instructs the tenant that the document was saved under a <br> *  different name.  In order to keep the right compound document <br> *  user interface, this tenant needs to tell its object through <br> *  IOleObject::SetHostNames. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of filename. <br> *  pvReserved      LPVOID reserved for future use. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::NotifyOfRename(LPTSTR pszFile, LPVOID pvReserved) <br>    { <br>    TCHAR       szObj[40]; <br>    TCHAR       szApp[40]; <br> <br>    if (NULL==m_pIOleObject) <br>        return; <br> <br>    if (TEXT('\0')==*pszFile) <br>        { <br>        LoadString(m_pPG-&gt;m_hInst, IDS_UNTITLED, szObj <br>            , sizeof(szObj)); <br>        } <br>    else <br>        { <br>        GetFileTitle(pszFile, szObj, sizeof(szObj)); <br> <br>       #ifndef WIN32 <br>        //Force filenames to uppercase in DOS versions. <br>        AnsiUpper(szObj); <br>       #endif <br>        } <br> <br>    LoadString(m_pPG-&gt;m_hInst, IDS_CAPTION, szApp, sizeof(szApp)); <br>   #ifdef WIN32ANSI <br>    OLECHAR     szObjW[40], szAppW[40]; <br> <br>    MultiByteToWideChar(CP_ACP, 0, szObj, -1, szObjW, 40); <br>    MultiByteToWideChar(CP_ACP, 0, szApp, -1, szAppW, 40); <br>    m_pIOleObject-&gt;SetHostNames(szAppW, szObjW); <br>   #else <br>    m_pIOleObject-&gt;SetHostNames(szApp, szObj); <br>   #endif <br>    return; <br>    } <br> <br>//End CHAPTER17MOD <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Activate <br> * <br> * Purpose: <br> *  Activates a verb on the object living in the tenant.  Does <br> *  nothing for static objects. <br> * <br> * Parameters: <br> *  iVerb           LONG of the verb to execute. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the object changed due to this verb <br> *                  execution. <br> */ <br> <br>BOOL CTenant::Activate(LONG iVerb) <br>    { <br>    //CHAPTER17MOD <br>    RECT        rc, rcH; <br>    CHourglass *pHour; <br>    SIZEL       szl; <br> <br>    //Can't activate statics. <br>    if (TENANTTYPE_STATIC==m_tType || NULL==m_pIOleObject) <br>        { <br>        MessageBeep(0); <br>        return FALSE; <br>        } <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    RectConvertMappings(&amp;rc, NULL, TRUE); <br>    XformRectInPixelsToHimetric(NULL, &amp;rc, &amp;rcH); <br> <br>    pHour=new CHourglass; <br> <br>    //Get the server running first, then do a SetExtent, then show it <br>    OleRun(m_pIOleObject); <br> <br>    if (m_fSetExtent) <br>        { <br>        SETSIZEL(szl, rcH.right-rcH.left, rcH.top-rcH.bottom); <br>        m_pIOleObject-&gt;SetExtent(m_fe.dwAspect, &amp;szl); <br>        m_fSetExtent=FALSE; <br>        } <br> <br>    m_pIOleObject-&gt;DoVerb(iVerb, NULL, m_pImpIOleClientSite, 0 <br>        , m_hWnd, &amp;rcH); <br> <br>    delete pHour; <br> <br>    //If object changes, IAdviseSink::OnViewChange will see it. <br>    return FALSE; <br>    //End CHAPTER17MOD <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Draw <br> * <br> * Purpose: <br> *  Draws the tenant in its rectangle on the given hDC.  We assume <br> *  the DC is already set up for the mapping mode in which our <br> *  rectangle is expressed, since the Page we're in tells us both <br> *  the rect and the hDC. <br> * <br> * Parameters: <br> *  hDC             HDC in which to draw.  Could be a metafile, <br> *                  memory DC, screen, or printer. <br> *  ptd             DVTARGETDEVICE * describing the device. <br> *  hIC             HDC holding an information context (printing). <br> *  xOff, yOff      int offsets for the page in lometric <br> *  fNoColor        BOOL indicating if we should do B &amp; W <br> *  fPrinter        BOOL indicating if we should render for a <br> *                  printer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Draw(HDC hDC, DVTARGETDEVICE *ptd, HDC hIC <br>    , int xOff, int yOff, BOOL fNoColor, BOOL fPrinter) <br>    { <br>    HRESULT         hr; <br>    RECT            rc; <br>    RECTL           rcl; <br>    UINT            uMM; <br> <br>    //CHAPTER17MOD <br>    //We hold IViewObject2 all the time now, so no QueryInterface <br>    //End CHAPTER17MOD <br> <br>    RECTFROMRECTL(rc, m_rcl); <br>    OffsetRect(&amp;rc, -xOff, -yOff); <br>    RECTLFROMRECT(rcl, rc); <br> <br>    //CHAPTER17MOD <br>    //Repaint erases the rectangle to insure full object cleanup <br>    if (!fNoColor &amp;&amp; !fPrinter) <br>        { <br>        COLORREF    cr; <br>        cr=SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br>        ExtTextOut(hDC, rc.left, rc.top, ETO_OPAQUE, &amp;rc, NULL <br>            , 0, NULL); <br>        SetBkColor(hDC, cr); <br>        } <br> <br>    //We have to use Draw since we have a target device and IC. <br>    hr=m_pIViewObject2-&gt;Draw(m_fe.dwAspect, -1, NULL, ptd, hIC, hDC <br>        , &amp;rcl, NULL, NULL, 0); <br> <br>    //End CHAPTER17MOD <br> <br>    /* <br>     * If Draw failed, then perhaps it couldn't work for the device, <br>     * so try good old OleDraw as a last resort.  The code will <br>     * generally be OLE_E_BLANK. <br>     */ <br>    if (FAILED(hr)) <br>        OleDraw(m_pObj, m_fe.dwAspect, hDC, &amp;rc); <br> <br>    //CHAPTER17MOD <br>    if (!fPrinter <br>        &amp;&amp; (TENANTSTATE_SELECTED | TENANTSTATE_OPEN) &amp; m_dwState) <br>        { <br>        /* <br>         * Draw sizing handles to show the selection state.  We <br>         * convert things to MM_TEXT since that's what this <br>         * function expects. <br>         */ <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        uMM=SetMapMode(hDC, MM_TEXT); <br> <br>        if (TENANTSTATE_SELECTED &amp; m_dwState) <br>            { <br>            UIDrawHandles(&amp;rc, hDC, UI_HANDLES_INSIDE <br>                | UI_HANDLES_NOBORDER | UI_HANDLES_USEINVERSE <br>                , CXYHANDLE, TRUE); <br>            } <br> <br>        if (TENANTSTATE_OPEN &amp; m_dwState) <br>            UIDrawShading(&amp;rc, hDC, UI_SHADE_FULLRECT, 0); <br> <br>        uMM=SetMapMode(hDC, uMM); <br>        } <br>    //End CHAPTER17MOD <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::Repaint <br> * CTenant::Invalidate <br> * <br> * Purpose: <br> *  Repaints the tenant where it lies or invalidates its area <br> *  for later repainting. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::Repaint(void) <br>    { <br>    RECT        rc; <br>    HDC         hDC; <br> <br>    //CHAPTER17MOD <br>    /* <br>     * We might be asked to repaint from <br>     * IOleClientSite::OnShowWindow after we've switched pages if <br>     * our server was running. This check on m_cOpens prevents that. <br>     */ <br>    if (0==m_cOpens || !m_fRepaintEnabled) <br>        return; <br>    //End CHAPTER17MOD <br> <br>    hDC=GetDC(m_hWnd); <br>    SetRect(&amp;rc, m_pPG-&gt;m_xPos, m_pPG-&gt;m_yPos, 0, 0); <br>    RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>    SetMapMode(hDC, MM_LOMETRIC); <br>    Draw(hDC, NULL, NULL, rc.left, rc.top, FALSE, FALSE); <br> <br>    ReleaseDC(m_hWnd, hDC); <br>    return; <br>    } <br> <br> <br>void CTenant::Invalidate(void) <br>    { <br>    RECTL       rcl; <br>    RECT        rc; <br> <br>    RectGet(&amp;rcl, TRUE); <br>    RECTFROMRECTL(rc, rcl); <br> <br>    OffsetRect(&amp;rc, -(int)m_pPG-&gt;m_xPos, -(int)m_pPG-&gt;m_yPos); <br>    InvalidateRect(m_hWnd, &amp;rc, FALSE); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>//CHAPTER17MOD <br>/* <br> * CTenant::ObjectClassFormatAndIcon <br> * <br> * Purpose: <br> *  Helper function for CPage::ConvertObject to retrieve necessary <br> *  information about the object. <br> * <br> * Parameters: <br> *  pClsID          LPCLSID in which to store the CLSID. <br> *  pwFormat        LPWORD in which to store the clipboard format <br> *                  used. <br> *  ppszType        LPTSTR * in which to return a pointer to a <br> *                  type string. <br> *  phMetaIcon      HGLOBAL * in which to return the metafile <br> *                  icon currently in use. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ObjectClassFormatAndIcon(LPCLSID pClsID <br>    , LPWORD pwFormat, LPTSTR *ppszType, HGLOBAL *phMetaIcon <br>    , LPTSTR *ppszLabel) <br>    { <br>    HRESULT         hr; <br>    TCHAR           szType[128]; <br>    LPDATAOBJECT    pIDataObject; <br>    FORMATETC       fe; <br>    STGMEDIUM       stm; <br> <br>    if (TENANTTYPE_EMBEDDEDOBJECT!=m_tType || NULL==m_pIOleObject) <br>        return; <br> <br>    if (NULL==pClsID || NULL==pwFormat || NULL==ppszType <br>        || NULL==phMetaIcon) <br>        return; <br> <br> <br>    /* <br>     * For embedded objects get the real CLSID of the object and <br>     * its format string.  If this fails then we can try to ask <br>     * the object, or we can look in the registry. <br>     */ <br> <br>    hr=ReadClassStg(m_pIStorage, pClsID); <br> <br>    if (FAILED(hr)) <br>        { <br>        hr=m_pIOleObject-&gt;GetUserClassID(pClsID); <br> <br>        if (FAILED(hr)) <br>            *pClsID=CLSID_NULL; <br>        } <br> <br> <br>    hr=ReadFmtUserTypeStg(m_pIStorage, pwFormat, ppszType); <br> <br>    if (FAILED(hr)) <br>        { <br>        *pwFormat=0; <br>        *ppszType=NULL; <br> <br>        if (INOLE_GetUserTypeOfClass(*pClsID, 0, szType <br>            , sizeof(szType))) <br>            { <br>            *ppszType=INOLE_CopyString(szType); <br>            } <br>        } <br> <br>    /* <br>     * Try to get the AuxUserType from the registry, using <br>     * the short version (registered under AuxUserType\2). <br>     * If that fails, just copy *ppszType. <br>     */ <br>    *ppszLabel=NULL; <br> <br>    if (INOLE_GetUserTypeOfClass(*pClsID, 2, szType <br>        , sizeof(szType))) <br>        { <br>        *ppszLabel=INOLE_CopyString(szType); <br>        } <br>    else <br>        *ppszLabel=INOLE_CopyString(*ppszType); <br> <br>    //Get the icon for this thing, if we're iconic. <br>    *phMetaIcon=NULL; <br> <br>    hr=m_pObj-&gt;QueryInterface(IID_IDataObject <br>        , (PPVOID)&amp;pIDataObject); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        SETFormatEtc(fe, CF_METAFILEPICT, DVASPECT_ICON, NULL <br>            , TYMED_MFPICT, -1); <br>        hr=pIDataObject-&gt;GetData(&amp;fe, &amp;stm); <br>        pIDataObject-&gt;Release(); <br> <br>        if (SUCCEEDED(hr)) <br>            *phMetaIcon=stm.hGlobal; <br>        else <br>            *phMetaIcon=OleGetIconOfClass(*pClsID, NULL, TRUE); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CTenant::SwitchOrUpdateAspect <br> * <br> * Purpose: <br> *  Switches between DVASPECT_CONTENT and DVASPECT_ICON <br> * <br> * Parameters: <br> *  hMetaIcon       HGLOBAL to the new icon if we're changing the <br> *                  icon or switching to DVASPECT_ICON.  NULL to <br> *                  change back to content. <br> *  fPreserve       BOOL indicating if we're to preserve the old <br> *                  aspect after changing. <br> * <br> * Return Value: <br> *  BOOL            TRUE if anything changed, FALSE otherwise. <br> */ <br> <br>BOOL CTenant::SwitchOrUpdateAspect(HGLOBAL hMetaIcon <br>    , BOOL fPreserve) <br>    { <br>    HRESULT     hr; <br>    DWORD       dwAspect; <br>    BOOL        fUpdate=FALSE; <br> <br>    //Nothing to do if we're content already and there's no icon. <br>    if (NULL==hMetaIcon &amp;&amp; DVASPECT_CONTENT==m_fe.dwAspect) <br>        return FALSE; <br> <br>    //If we're iconic already, just cache the new icon <br>    if (NULL!=hMetaIcon &amp;&amp; DVASPECT_ICON==m_fe.dwAspect) <br>        hr=INOLE_SetIconInCache(m_pIOleObject, hMetaIcon); <br>    else <br>        { <br>        //Otherwise, switch between iconic and content. <br>        dwAspect=(NULL==hMetaIcon) ? DVASPECT_CONTENT : DVASPECT_ICON; <br> <br>        /* <br>         * Switch between aspects, where dwAspect has the new one <br>         * and m_fe.dwAspect will be changed in the process. <br>         */ <br>        hr=INOLE_SwitchDisplayAspect(m_pIOleObject <br>            , &amp;m_fe.dwAspect, dwAspect, hMetaIcon, !fPreserve <br>            , TRUE, m_pImpIAdviseSink, &amp;fUpdate); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            //Update MiscStatus for the new aspect <br>            m_pIOleObject-&gt;GetMiscStatus(m_fe.dwAspect, &amp;m_grfMisc); <br> <br>            if (fUpdate) <br>                m_pIOleObject-&gt;Update();    //This repaints. <br>            } <br>        } <br> <br>    //If we switched, update our extents. <br>    if (SUCCEEDED(hr)) <br>        { <br>        SIZEL       szl; <br> <br>        m_pIOleObject-&gt;GetExtent(m_fe.dwAspect, &amp;szl); <br> <br>        if (0 &gt; szl.cy) <br>            szl.cy=-szl.cy; <br> <br>        //Convert HIMETRIC absolute units to our LOMETRIC mapping <br>        if (0!=szl.cx &amp;&amp; 0!=szl.cy) <br>            SETSIZEL(szl, szl.cx/10, -szl.cy/10); <br> <br>        Invalidate();                   //Remove old aspect <br>        SizeSet(&amp;szl, FALSE, FALSE);    //Change size <br>        Repaint();                      //Paint the new one <br>        } <br> <br>    return SUCCEEDED(hr); <br>    } <br> <br> <br> <br>/* <br> * CTenant::EnableRepaint <br> * <br> * Purpose: <br> *  Toggles whether the Repaint function does anything.  This <br> *  is used during conversion/emulation of an object to disable <br> *  repaints until the new object can be given the proper extents. <br> * <br> * Parameters: <br> *  fEnable         TRUE to enable repaints, FALSE to disable. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::EnableRepaint(BOOL fEnable) <br>    { <br>    m_fRepaintEnabled=fEnable; <br>    return; <br>    } <br>//End CHAPTER17MOD <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::ObjectGet <br> * <br> * Purpose: <br> *  Retrieves the LPUNKNOWN of the object in use by this tenant <br> * <br> * Parameters: <br> *  ppUnk           LPUNKNOWN * in which to return the object <br> *                  pointer. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::ObjectGet(LPUNKNOWN *ppUnk) <br>    { <br>    if (NULL!=ppUnk) <br>        { <br>        *ppUnk=m_pObj; <br>        m_pObj-&gt;AddRef(); <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::FormatEtcGet <br> * <br> * Purpose: <br> *  Retrieves the FORMATETC in use by this tenant <br> * <br> * Parameters: <br> *  pFE             LPFORMATETC in which to store the information. <br> *  fPresentation   BOOL indicating if we want the real format or <br> *                  that of the presentation. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::FormatEtcGet(LPFORMATETC pFE, BOOL fPresentation) <br>    { <br>    if (NULL!=pFE) <br>        { <br>        *pFE=m_fe; <br> <br>        //CHAPTER17MOD <br>        //If there is no format, use metafile (for embedded objects) <br>        if (fPresentation || 0==pFE-&gt;cfFormat) <br>            { <br>            //Don't mess with dwAspect; might be icon or content. <br>            pFE-&gt;cfFormat=CF_METAFILEPICT; <br>            pFE-&gt;tymed=TYMED_MFPICT; <br>            } <br>        //End CHAPTER17MOD <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CTenant::SizeGet <br> * CTenant::SizeSet <br> * CTenant::RectGet <br> * CTenant::RectSet <br> * <br> * Purpose: <br> *  Returns or sets the size/position of the object contained here. <br> * <br> * Parameters: <br> *  pszl/prcl       LPSIZEL (Size) or LPRECTL (Rect) with the <br> *                  extents of interest.  In Get situations, <br> *                  this will receive the extents; in Set it <br> *                  contains the extents. <br> *  fDevice         BOOL indicating that pszl/prcl is expressed <br> *                  in device units.  Otherwise it's LOMETRIC. <br> *  fInformObj      (Set Only) BOOL indicating if we need to inform <br> *                  the object all. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CTenant::SizeGet(LPSIZEL pszl, BOOL fDevice) <br>    { <br>    if (!fDevice) <br>        { <br>        pszl-&gt;cx=m_rcl.right-m_rcl.left; <br>        pszl-&gt;cy=m_rcl.bottom-m_rcl.top; <br>        } <br>    else <br>        { <br>        RECT        rc; <br> <br>        SetRect(&amp;rc, (int)(m_rcl.right-m_rcl.left) <br>            , (int)(m_rcl.bottom-m_rcl.top), 0, 0); <br> <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br> <br>        pszl-&gt;cx=(long)rc.left; <br>        pszl-&gt;cy=(long)rc.top; <br>        } <br> <br>    return; <br>    } <br> <br>//CHAPTER17MOD <br>void CTenant::SizeSet(LPSIZEL pszl, BOOL fDevice, BOOL fInformObj) <br>//End CHAPTER17MOD <br>    { <br>    SIZEL           szl; <br> <br>    if (!fDevice) <br>        { <br>        szl=*pszl; <br>        m_rcl.right =pszl-&gt;cx+m_rcl.left; <br>        m_rcl.bottom=pszl-&gt;cy+m_rcl.top; <br>        } <br>    else <br>        { <br>        RECT        rc; <br> <br>        SetRect(&amp;rc, (int)pszl-&gt;cx, (int)pszl-&gt;cy, 0, 0); <br>        RectConvertMappings(&amp;rc, NULL, FALSE); <br> <br>        m_rcl.right =(long)rc.left+m_rcl.left; <br>        m_rcl.bottom=(long)rc.top+m_rcl.top; <br> <br>        SETSIZEL(szl, (long)rc.left, (long)rc.top); <br>        } <br> <br> <br>    //Tell OLE that this object was resized. <br>    //CHAPTER17MOD <br>    if (NULL!=m_pIOleObject &amp;&amp; fInformObj) <br>        { <br>        HRESULT     hr; <br>        BOOL        fRun=FALSE; <br> <br>        //Convert our LOMETRIC into HIMETRIC by *=10 <br>        szl.cx*=10; <br>        szl.cy*=-10;    //Our size is stored negative. <br> <br>        /* <br>         * If the MiscStatus bit of OLEMISC_RECOMPOSEONRESIZE <br>         * is set, then we need to run the object before calling <br>         * SetExtent to make sure it has a real chance to <br>         * re-render the object.  We have to update and close <br>         * the object as well after this happens. <br>         */ <br> <br>        if (OLEMISC_RECOMPOSEONRESIZE &amp; m_grfMisc) <br>            { <br>            if (!OleIsRunning(m_pIOleObject)) <br>                { <br>                OleRun(m_pIOleObject); <br>                fRun=TRUE; <br>                } <br>            } <br> <br>        hr=m_pIOleObject-&gt;SetExtent(m_fe.dwAspect, &amp;szl); <br> <br>        /* <br>         * If the object is not running and it does not have <br>         * RECOMPOSEONRESIZE, then SetExtent fails.  Make <br>         * sure that we call SetExtent again (by just calling <br>         * SizeSet here again) when we next run the object. <br>         */ <br>        if (SUCCEEDED(hr)) <br>            { <br>            m_fSetExtent=FALSE; <br> <br>            if (fRun) <br>                { <br>                m_pIOleObject-&gt;Update(); <br>                m_pIOleObject-&gt;Close(OLECLOSE_SAVEIFDIRTY); <br>                } <br>            } <br>        else <br>            { <br>            if (OLE_E_NOTRUNNING==GetScode(hr)) <br>                m_fSetExtent=TRUE; <br>            } <br>        } <br>    //End CHAPTER17MOD <br> <br>    return; <br>    } <br> <br> <br>void CTenant::RectGet(LPRECTL prcl, BOOL fDevice) <br>    { <br>    if (!fDevice) <br>        *prcl=m_rcl; <br>    else <br>        { <br>        RECT        rc; <br> <br>        RECTFROMRECTL(rc, m_rcl); <br>        RectConvertMappings(&amp;rc, NULL, TRUE); <br>        RECTLFROMRECT(*prcl, rc); <br>        } <br> <br>    return; <br>    } <br> <br> <br>//CHAPTER17MOD <br>void CTenant::RectSet(LPRECTL prcl, BOOL fDevice, BOOL fInformObj) <br>//End CHAPTER17MOD <br>    { <br>    SIZEL   szl; <br>    LONG    cx, cy; <br> <br>    cx=m_rcl.right-m_rcl.left; <br>    cy=m_rcl.bottom-m_rcl.top; <br> <br>    if (!fDevice) <br>        m_rcl=*prcl; <br>    else <br>        { <br>        RECT        rc; <br> <br>        RECTFROMRECTL(rc, *prcl); <br>        RectConvertMappings(&amp;rc, NULL, FALSE); <br>        RECTLFROMRECT(m_rcl, rc); <br>        } <br> <br>    /* <br>     * Tell ourselves that the size changed, if it did.  SizeSet <br>     * will call IOleObject::SetExtent for us. <br>     */ <br>    if ((m_rcl.right-m_rcl.left)!=cx || (m_rcl.bottom-m_rcl.top)!=cy) <br>        { <br>        SETSIZEL(szl, m_rcl.right-m_rcl.left, m_rcl.bottom-m_rcl.top); <br>        //CHAPTER17MOD <br>        SizeSet(&amp;szl, FALSE, fInformObj); <br>        //End CHAPTER17MOD <br>        } <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CTenant::CreateStatic <br> * (Protected) <br> * <br> * Purpose: <br> *  Creates a new static bitmap or metafile object for this tenant <br> *  using a freeloading method allowing us to specify exactly which <br> *  type of data we want to paste since OleCreateStaticFromData <br> *  doesn't. <br> * <br> * Parameters: <br> *  pIDataObject    LPDATAOBJECT from which to paste. <br> *  pFE             LPFORMATETC describing the format to paste. <br> *  ppObj           LPUNKNOWN * into which we store the <br> *                  object pointer. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR on success, error code otherwise. <br> */ <br> <br>HRESULT CTenant::CreateStatic(LPDATAOBJECT pIDataObject <br>    , LPFORMATETC pFE, LPUNKNOWN *ppObj) <br>    { <br>    HRESULT             hr; <br>    STGMEDIUM           stm; <br>    LPUNKNOWN           pIUnknown; <br>    LPOLECACHE          pIOleCache; <br>    LPPERSISTSTORAGE    pIPersistStorage; <br>    CLSID               clsID; <br> <br>    *ppObj=NULL; <br> <br>    //Try to get the data desired as specified in pFE-&gt;cfFormat <br>    hr=pIDataObject-&gt;GetData(pFE, &amp;stm); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    //Create the object to handle this data. <br>    if (CF_METAFILEPICT==pFE-&gt;cfFormat) <br>        clsID=CLSID_Picture_Metafile; <br>    else <br>        clsID=CLSID_Picture_Dib; <br> <br>    hr=CreateDataCache(NULL, clsID, IID_IUnknown <br>        , (PPVOID)&amp;pIUnknown); <br> <br>    if (FAILED(hr)) <br>        { <br>        ReleaseStgMedium(&amp;stm); <br>        return hr; <br>        } <br> <br>    m_clsID=clsID; <br> <br>    //Stuff the data into the object <br>    pIUnknown-&gt;QueryInterface(IID_IPersistStorage <br>        , (PPVOID)&amp;pIPersistStorage); <br>    pIPersistStorage-&gt;InitNew(m_pIStorage); <br> <br>    //Now that we have the cache object, shove the data into it. <br>    pIUnknown-&gt;QueryInterface(IID_IOleCache, (PPVOID)&amp;pIOleCache); <br>    pIOleCache-&gt;Cache(pFE, ADVF_PRIMEFIRST, NULL); <br> <br>    hr=pIOleCache-&gt;SetData(pFE, &amp;stm, TRUE); <br>    pIOleCache-&gt;Release(); <br> <br>    //Insure there is a persistent copy on the disk <br>    WriteClassStg(m_pIStorage, m_clsID); <br>    pIPersistStorage-&gt;Save(m_pIStorage, TRUE); <br>    pIPersistStorage-&gt;SaveCompleted(NULL); <br>    pIPersistStorage-&gt;Release(); <br> <br>    //The cache owns this now. <br>    ReleaseStgMedium(&amp;stm); <br> <br>    if (FAILED(hr)) <br>        pIUnknown-&gt;Release(); <br>    else <br>        *ppObj=pIUnknown; <br> <br>    return hr; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
