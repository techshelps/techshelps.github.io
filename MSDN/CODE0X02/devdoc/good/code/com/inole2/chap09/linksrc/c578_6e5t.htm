<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IOLECONT.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context581"></a>IOLECONT.CPP</h2>
<pre><code>/* <br> * IOLECONT.CPP <br> * Link Source Server Chapter 9 <br> * <br> * Implementation of the IOleItemContainer interface for <br> * LinkSource's CFileObject and CContainerItem, using constructor <br> * arguments to distinguish the relevant object. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "linksrc.h" <br> <br> <br>#ifdef WIN32ANSI <br>/* <br> * This is to turn off the mapping to ANSI wrapper APIs because <br> * we're actually using wide char strings under Win32 all the time <br> * in parts of this code. <br> */ <br>#undef CreateItemMoniker <br>#define CreateItemMoniker CreateItemMoniker <br> <br>#endif <br> <br>extern ULONG g_cObj; <br> <br> <br>/* <br> * CImpIOleItemContainer::CImpIOleItemContainer <br> * CImpIOleItemContainer::~CImpIOleItemContainer <br> * <br> * Parameters (Constructor): <br> *  pObj            LPVOID of the page or pages. <br> *  pUnkOuter       LPUNKNOWN to which we delegate. <br> *  fFileObj        BOOL indicating if we're in CFileObject. <br> */ <br> <br>CImpIOleItemContainer::CImpIOleItemContainer(LPVOID pObj <br>    , LPUNKNOWN pUnkOuter, BOOL fFileObj) <br>    { <br>    m_cRef=0; <br>    m_fFileObj=fFileObj; <br> <br>    if (fFileObj) <br>        { <br>        m_pObjFile=(PCFileObject)pObj; <br>        m_pObjCont=NULL; <br>        } <br>    else <br>        { <br>        m_pObjFile=NULL; <br>        m_pObjCont=(PCContainerItem)pObj; <br>        } <br> <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIOleItemContainer::~CImpIOleItemContainer(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::QueryInterface <br> * CImpIOleItemContainer::AddRef <br> * CImpIOleItemContainer::Release <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::QueryInterface(REFIID riid <br>    , PPVOID ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleItemContainer::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIOleItemContainer::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::ParseDisplayName <br> * <br> * Purpose: <br> *  Parse the given name into a moniker as far as we know how <br> *  to parse. <br> * <br> * Parameters: <br> *  pbc             LPBC to the binding context <br> *  pszName         LPOLESTR to the name to parse. <br> *  pchEaten        ULONG * into which to store how many <br> *                  characters we scanned in the display name. <br> *  ppmk            LPMONIKER * in which to return the moniker. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::ParseDisplayName(LPBC pbc <br>    , LPOLESTR pszName, ULONG *pchEaten, LPMONIKER *ppmk) <br>    { <br>    OLECHAR     ch; <br>    ULONG       chEaten=0; <br>    TCHAR       szName[256]; <br>    TCHAR       szComp[15]; <br>    LPTSTR      psz; <br>    UINT        cch; <br> <br>    *ppmk=NULL; <br>    *pchEaten=0; <br> <br>    /* <br>     * All we have to look for is the string between the ! <br>     * delimeters (or a null terminator).  pszName should be pointing <br>     * to a !, so skip it and scan the string for a ! or 0, <br>     * then pass the result to CreateItemMoniker. <br>     */ <br> <br>    psz=szName; <br> <br>    ch=*pszName++; <br>    chEaten++; <br> <br>    if ((OLECHAR)'!'!=ch) <br>        return ResultFromScode(MK_E_SYNTAX); <br> <br>    ch=*pszName++; <br> <br>    while ((OLECHAR)0!=ch &amp;&amp; (OLECHAR)'!' !=ch) <br>        { <br>        *psz++=(TCHAR)ch; <br>        chEaten++; <br>        ch=*pszName++; <br>        } <br> <br>    *psz=(TCHAR)0; <br> <br>    /* <br>     * Syntax check.  If we're the File object, check for "Object n" <br>     * at the beginning of the string.  Otherwise check for <br>     * "Sub-Object n". <br>     */ <br>    lstrcpy(szComp, m_fFileObj ? TEXT("Object ") <br>        : TEXT("Sub-Object ")); <br> <br>    //Does szName start with szComp? <br>    cch=lstrlen(szComp); <br> <br>    if (0!=_tcsncicmp(szName, szComp, cch)) <br>        { <br>        *pchEaten=1;    //Parsed ! at least <br>        return ResultFromScode(MK_E_SYNTAX); <br>        } <br> <br>    //Check for a number in szName <br>    if ((TCHAR)'0' != szName[cch]) <br>        { <br>        if (0==_ttoi(szName+cch)) <br>            { <br>            *pchEaten=cch;  //Got past name <br>            return ResultFromScode(MK_E_SYNTAX); <br>            } <br>        } <br> <br>    *pchEaten=chEaten; <br>   #ifdef WIN32ANSI <br>    //Use the ANSI version here since szName is ANSI <br>    return INOLE_CreateItemMoniker(TEXT("!"), szName, ppmk); <br>   #else <br>    return CreateItemMoniker(OLETEXT("!"), szName, ppmk); <br>   #endif <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::EnumObjects <br> * <br> * Purpose: <br> *  Creates and returns an IEnumUnknown object that allows the <br> *  caller to walk through the objects in this continer thing. <br> * <br> * Parameters: <br> *  dwFlags         DWORD specifying what kind of objects to <br> *                  enumerate. <br> *  ppEnum          LPENUMUNKNOWN * into which to return the <br> *                  enumerator <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::EnumObjects(DWORD dwFlags <br>    , LPENUMUNKNOWN *ppEnum) <br>    { <br>    *ppEnum=NULL; <br> <br>    /* <br>     * We can leave this unimplemented in this sample since <br>     * we know no one will ever call it.  A real container <br>     * should be able to enumerate its contents. <br>     */ <br>    return ResultFromScode(E_NOTIMPL); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::LockContainer <br> * <br> * Purpose: <br> *  Establishes a lock on the container to prevent it from shutting <br> *  down outside of user control.  This is used to control the <br> *  lifetime of the container when it's used to update a link to an <br> *  embedded object within it.  If we're unlock and the user has not <br> *  taken control, we close. <br> * <br> * Parameters: <br> *  fLock           BOOL indicating a lock or unlock. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::LockContainer(BOOL fLock) <br>    { <br>    /* <br>     * For the purposes of this server, we need only AddRef <br>     * and release ourselves depending on fLock. <br>     */ <br> <br>    if (fLock) <br>        AddRef(); <br>    else <br>        Release(); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::GetObject <br> * <br> * Purpose: <br> *  Returns the requested interface pointer on an object in this <br> *  container. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR to the item we must locate. <br> *  dwSpeed         DWORD identifying how long the caller is willing <br> *                  to wait. <br> *  pcb             LPBINDCTX providing the binding context. <br> *  riid            REFIID of the interface requested. <br> *  ppv             PPVOID into which to return the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::GetObject(LPOLESTR pszItem <br>    , DWORD dwSpeed, LPBINDCTX pbc, REFIID riid, PPVOID ppv) <br>    { <br>    HRESULT         hr; <br>    IStorage       *pIStorage; <br>    PCContainerItem pCI; <br>    PCSimpleItem    pSI; <br>    BOOL            fSuccess; <br>    IUnknown       *pUnk; <br> <br>    *ppv=NULL; <br> <br>    /* <br>     * The item name given to either CFileObj or CContainerItem <br>     * instantiations of this interface will be the name of <br>     * a storage below the current object's storage.  So we <br>     * use m_fFileObj to know which storage to look under <br>     * (names are either "Object n" or "Sub-Object n"). <br>     * <br>     * If that storage exists, the object exists.  If it is <br>     * already running, we can check in the Running Object Table <br>     * and just return that object.  This is the only case that <br>     * works when the bind speed in the bind context is <br>     * immediate. <br>     * <br>     * Otherwise we open the storage and hand it to a new <br>     * instance of the right type of object (CContainerItem or <br>     * CSimpleItem), and register the new objects as running. <br>     */ <br> <br>    //Get the object if running <br>    hr=GetRunning(pszItem, pbc, riid, ppv, FALSE); <br> <br>    if (BINDSPEED_IMMEDIATE==dwSpeed &amp;&amp; NOERROR!=hr) <br>        return ResultFromScode(MK_E_EXCEEDEDDEADLINE); <br> <br>    //If object was running, we're done! <br>    if (NOERROR==hr) <br>        return NOERROR; <br> <br>    //Otherwise we need to get the storage. <br>    hr=GetObjectStorage(pszItem, pbc, IID_IStorage <br>        , (void **)&amp;pIStorage); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    /* <br>     * Storage exists, so create an object and give that storage <br>     * to it.  The new object will also register itself in the <br>     * Running Object Table. <br>     */ <br>    fSuccess=FALSE; <br> <br>    if (m_fFileObj) <br>        { <br>        pCI=new CContainerItem(m_pObjFile, m_pObjFile-&gt;m_pfnDestroy); <br> <br>        pUnk=pCI; <br> <br>        if (NULL!=pCI) <br>            { <br>            pUnk-&gt;AddRef(); <br>            fSuccess=pCI-&gt;Init(m_pObjFile-&gt;m_pmk, pbc, pszItem <br>                , pIStorage); <br>            } <br>        } <br>    else <br>        { <br>        pSI=new CSimpleItem(m_pObjCont, m_pObjCont-&gt;m_pfnDestroy); <br> <br>        pUnk=pSI; <br> <br>        if (NULL!=pSI) <br>            { <br>            pUnk-&gt;AddRef(); <br>            fSuccess=pSI-&gt;Init(m_pObjCont-&gt;m_pmk, pbc, pszItem <br>                , pIStorage); <br>            } <br>        } <br> <br>    if (!fSuccess) <br>        { <br>        if (NULL!=pUnk) <br>            pUnk-&gt;Release(); <br> <br>        return ResultFromScode(E_OUTOFMEMORY); <br>        } <br> <br>    g_cObj++; <br> <br>    //If QueryInterface fails, this Release destroys the object <br>    hr=pUnk-&gt;QueryInterface(riid, ppv); <br>    pUnk-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::GetObjectStorage <br> * <br> * Purpose: <br> *  Similar to GetObject in that we have to locate the object <br> *  described by a given name, but instead of returning any old <br> *  interface we return a storage element. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR to the item we must locate. <br> *  pcb             LPBINDCTX providing the binding context. <br> *  riid            REFIID of the interface requested.  Usually <br> *                  IStorage or IStream. <br> *  ppv             PPVOID into which to return the object. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR or a general error value. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::GetObjectStorage(LPOLESTR pszItem <br>    , LPBINDCTX pbc, REFIID riid, PPVOID ppv) <br>    { <br>    IStorage       *pIStorageObj; <br>    IStorage       *pIStorageNew; <br>    HRESULT         hr; <br> <br>    if (IID_IStorage!=riid) <br>        return ResultFromScode(MK_E_NOSTORAGE); <br> <br>    pIStorageObj=m_fFileObj ? m_pObjFile-&gt;m_pIStorage <br>        : m_pObjCont-&gt;m_pIStorage; <br> <br>    //Check storage existence <br>    hr=pIStorageObj-&gt;OpenStorage(pszItem <br>        , NULL, STGM_TRANSACTED | STGM_READ | STGM_SHARE_EXCLUSIVE <br>        , NULL, 0, &amp;pIStorageNew); <br> <br>    if (FAILED(hr)) <br>        { <br>        IUnknown   *pUnk; <br> <br>        /* <br>         * Because you must open a substorage with exclusive access, <br>         * we'll run into a problem where an object created for use <br>         * with parsing will still be running when another object of <br>         * the same type is used for binding.  The reason is that the <br>         * bind context holds these thing for optimization purposes. <br>         * But that does mean that OpenStorage above might fail <br>         * with STG_E_ACCESSDENIED.  In this case, we'll try to get <br>         * a previously opened storage from the bind context <br>         * (see below). <br>         */ <br>        if (STG_E_ACCESSDENIED!=GetScode(hr)) <br>            return hr; <br> <br>        if (FAILED(pbc-&gt;GetObjectParam(SZOPENSTORAGE, &amp;pUnk))) <br>            return ResultFromScode(STG_E_ACCESSDENIED); <br> <br>        //This does the necessary AddRef on the IStorage pointer <br>        hr=pUnk-&gt;QueryInterface(IID_IStorage <br>            , (void **)&amp;pIStorageNew); <br>        pUnk-&gt;Release(); <br> <br>        //This sets the out-parameter to NULL on failure <br>        *ppv=pIStorageNew; <br>        return hr; <br>        } <br> <br>    *ppv=pIStorageNew; <br>    pbc-&gt;RegisterObjectParam(SZOPENSTORAGE, pIStorageNew); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CImpIOleItemContainer::IsRunning <br> * <br> * Purpose: <br> *  Answers if the object under the given name is currently running. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR of the item to check <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the object is running, S_FALSE <br> *                  otherwise.  Possibly MK_E_NOOBJECT if the name <br> *                  is bogus. <br> */ <br> <br>STDMETHODIMP CImpIOleItemContainer::IsRunning(LPOLESTR pszItem) <br>    { <br>    return GetRunning(pszItem, NULL, IID_NULL, NULL, TRUE); <br>    } <br> <br> <br> <br> <br> <br>/* <br> * (Internal) <br> * CImpIOleItemContainer::GetRunning <br> * <br> * Purpose: <br> *  Grabs a running object from the running object table or <br> *  just checks existence. <br> * <br> * Parameters: <br> *  pszItem         LPOLESTR of the item to check <br> *  pbc             IBindCtx * to use, can be NULL. <br> *  riid            REFIID to return if fCheck is FALSE. <br> *  ppv             void ** in which to return a pointer. <br> *  fCheck          BOOL indicating to check (TRUE) or <br> *                  retrieve (FALSE). <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the object is running, S_FALSE <br> *                  or an error otherwise. <br> */ <br> <br>HRESULT CImpIOleItemContainer::GetRunning(LPOLESTR pszItem <br>    , IBindCtx *pbc, REFIID riid, void **ppv, BOOL fCheck) <br>    { <br>    OLECHAR              szDelim[]=OLETEXT("!"); <br>    HRESULT              hr=ResultFromScode(S_FALSE); <br>    IMoniker            *pmkBase; <br>    IMoniker            *pmkItem; <br>    IMoniker            *pmkComp; <br>    IRunningObjectTable *pROT; <br> <br>    pmkBase=m_fFileObj ? m_pObjFile-&gt;m_pmk : m_pObjCont-&gt;m_pmk; <br> <br>    if (FAILED(CreateItemMoniker(szDelim, pszItem, &amp;pmkItem))) <br>        return hr; <br> <br>    //Create a composite with this item <br>    hr=pmkBase-&gt;ComposeWith(pmkItem, FALSE, &amp;pmkComp); <br> <br>    if (FAILED(hr)) <br>        { <br>        pmkItem-&gt;Release(); <br>        return hr; <br>        } <br> <br> <br>    if (NULL!=pbc) <br>        hr=pbc-&gt;GetRunningObjectTable(&amp;pROT); <br>    else <br>        hr=GetRunningObjectTable(0, &amp;pROT); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        hr=pROT-&gt;IsRunning(pmkComp); <br> <br>        //If running, grab the object if necessary <br>        if (!fCheck &amp;&amp; NOERROR==hr) <br>            { <br>            IUnknown *pUnk; <br> <br>            if(SUCCEEDED(pROT-&gt;GetObject(pmkComp, &amp;pUnk))) <br>                { <br>                hr=pUnk-&gt;QueryInterface(riid, ppv); <br>                pUnk-&gt;Release(); <br>                } <br>            } <br> <br>        pROT-&gt;Release(); <br>        } <br> <br>    pmkComp-&gt;Release(); <br>    pmkItem-&gt;Release(); <br>    return hr; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
