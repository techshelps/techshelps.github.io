<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDESCRIP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context580"></a>IDESCRIP.CPP</h2>
<pre><code>/* <br> * IDESCRIP.CPP <br> * Link Source Chapter 9 <br> * <br> * Implementation the IDescription interface that doesn't care <br> * what object it works with in this LinkSource sample.  It <br> * is given a storage in which it expects to find a stream <br> * called "Description" containing the text relevant to the <br> * object showing the instance of this interface. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "linksrc.h" <br> <br>/* <br> * CImpIDescription:CImpIDescription <br> * CImpIDescription::~CImpIDescription <br> * CImpIDescription::QueryInterface <br> * CImpIDescription::AddRef <br> * CImpIDescription::Release <br> * <br> * Basic object members. <br> */ <br> <br>CImpIDescription::CImpIDescription(LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pIStorage=NULL; <br>    return; <br>    } <br> <br>CImpIDescription::~CImpIDescription(void) <br>    { <br>    return; <br>    } <br> <br>STDMETHODIMP CImpIDescription::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIDescription::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIDescription::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br>/* <br> * CImpIDescription::GetText <br> * <br> * Purpose: <br> *  Fills a buffer with our text description. <br> * <br> * Parameters: <br> *  pszText         LPOLESTR to the buffer to fill <br> *  cch             ULONG specifying the length of pszText <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, error otherwise. <br> */ <br> <br>HRESULT CImpIDescription::GetText(LPOLESTR pszText, ULONG cch) <br>    { <br>    HRESULT     hr; <br>    IStream    *pIStream; <br> <br>    /* <br>     * The description text for this object is contained in <br>     * a stream called "Description" (constant SZDESCRIPTION <br>     * has this string) found in whatever storage we happen <br>     * to have.  This implementation is ignorant of the actual <br>     * object that is exposing it. <br>     */ <br> <br>    if (NULL==m_pIStorage) <br>        return ResultFromScode(E_FAIL); <br> <br>    hr=m_pIStorage-&gt;OpenStream(SZDESCRIPTION, 0, STGM_DIRECT <br>        | STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pIStream); <br> <br>    if (FAILED(hr)) <br>        return ResultFromScode(E_FAIL); <br> <br>   #ifdef WIN32ANSI <br>    char sz[512]; <br>    hr=pIStream-&gt;Read((void *)sz, cch*sizeof(TCHAR), NULL); <br>MultiByteToWideChar(CP_ACP, 0, sz, -1, pszText, cch);     <br>   #else <br>    hr=pIStream-&gt;Read((void *)pszText, cch*sizeof(WCHAR), NULL); <br>   #endif <br>    pIStream-&gt;Release(); <br> <br>    return SUCCEEDED(hr) ? NOERROR : ResultFromScode(E_FAIL); <br>    } <br> <br> <br> <br> <br>/* <br> * (Internal) <br> * CImpIDescription::SetStorage <br> * <br> * Purpose: <br> *  Provides objects using this interface implementation to <br> *  inform us of the storage in which to look for the <br> *  description stream. <br> * <br> * Parameters: <br> *  pIStorage       IStorage * to hold. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CImpIDescription::SetStorage(IStorage *pIStorage) <br>    { <br>    /* <br>     * This may be the root storage for the File object, the <br>     * sub-storage for the first level object, or a sub-storage <br>     * for a second-level object.  Since the object exposing <br>     * this interface holds the storage itself, no AddRef is <br>     * required. <br>     */ <br>    m_pIStorage=pIStorage; <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
