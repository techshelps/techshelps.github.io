<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINKUSER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context587"></a>LINKUSER.CPP</h2>
<pre><code>/* <br> * LINKUSER.CPP <br> * Link User Chapter 9 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "linkuser.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG         msg; <br>    PAPP        pApp; <br> <br>    SETMESSAGEQUEUE(96); <br> <br>    pApp=new CApp(hInst, hInstPrev, nCmdShow); <br> <br>    if (NULL==pApp) <br>        return -1; <br> <br>    if (pApp-&gt;Init()) <br>        { <br>        while (GetMessage(&amp;msg, NULL, 0,0 )) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    delete pApp; <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DataUserWndProc <br> * <br> * Purpose: <br> *  Window class procedure.  Standard callback. <br> */ <br> <br>LRESULT APIENTRY LinkUserWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PAPP    pApp; <br>    RECT    rc; <br> <br>    COMMANDPARAMS(wID, wCode, hWndMsg); <br> <br>    pApp=(PAPP)GetWindowLong(hWnd, LINKUSERWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pApp=(PAPP)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, LINKUSERWL_STRUCTURE, (LONG)pApp); <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_SIZE: <br>            //Keep the listbox filling the client area <br>            GetClientRect(hWnd, &amp;rc); <br>            SetWindowPos(pApp-&gt;m_hWndList, NULL, rc.left, rc.top <br>                , rc.right-rc.left, rc.bottom-rc.top <br>                , SWP_NOZORDER | SWP_NOACTIVATE); <br>            break; <br> <br>        case WM_COMMAND: <br>            wID=LOWORD(wParam); <br> <br>            switch (wID) <br>                { <br>                case ID_LISTOLINKS: <br>                    switch (wCode) <br>                        { <br>                        case LBN_DBLCLK: <br>                            pApp-&gt;ShowDescription(); <br>                            break; <br>                        } <br> <br>                    break; <br> <br>                case IDM_LINKSHOWDESCRIPTION: <br>                    //Same as double-clicking in listbox <br>                    pApp-&gt;ShowDescription(); <br>                    break; <br> <br>                case IDM_LINKPARSEANDBIND: <br>                    pApp-&gt;ParseAndBind(); <br>                    break; <br> <br>                case IDM_LINKEXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CApp::CApp <br> * CApp::~CApp <br> * <br> * Constructor Parameters: (from WinMain) <br> *  hInst           HINSTANCE of the application. <br> *  hInstPrev       HINSTANCE of a previous instance. <br> *  nCmdShow        UINT specifying how to show the app window. <br> */ <br> <br>CApp::CApp(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , UINT nCmdShow) <br>    { <br>    UINT        i; <br> <br>    m_hInst=hInst; <br>    m_hInstPrev=hInstPrev; <br>    m_nCmdShow=nCmdShow; <br> <br>    m_hWnd=NULL; <br>    m_fInitialized=FALSE; <br>    m_hWndList=NULL; <br> <br>    for (i=0; i &lt; CMONIKERS; i++) <br>        m_rgpmk[i]=NULL; <br> <br>    return; <br>    } <br> <br> <br>CApp::~CApp(void) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i &lt; CMONIKERS; i++) <br>        ReleaseInterface(m_rgpmk[i]); <br> <br>    if (IsWindow(m_hWnd)) <br>        DestroyWindow(m_hWnd);  //Destroys listbox <br> <br>    if (m_fInitialized) <br>        CoUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure such as calling CoInitialize.  If this function fails <br> *  the caller should insure that the destructor is called. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::Init(void) <br>    { <br>    WNDCLASS    wc; <br>    BOOL        fRet; <br>    RECT        rc; <br> <br>    CHECKVER_COM; <br> <br>    if (FAILED(CoInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    //Register our window classes. <br>    if (!m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = LinkUserWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = CBWNDEXTRA; <br>        wc.hInstance      = m_hInst; <br>        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon")); <br>        wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU); <br>        wc.lpszClassName  = TEXT("LINKUSER"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>        } <br> <br>    //Create the main window. <br>    m_hWnd=CreateWindow(TEXT("LINKUSER"), TEXT("Link User") <br>        , WS_OVERLAPPEDWINDOW,35, 35, 420, 250, NULL <br>        , NULL, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    //Create the list of monikers <br>    GetClientRect(m_hWnd, &amp;rc); <br>    m_hWndList=CreateWindow(TEXT("listbox"), TEXT("LinkList") <br>        , WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_NOINTEGRALHEIGHT <br>        , rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top <br>        , m_hWnd, (HMENU)ID_LISTOLINKS, m_hInst, NULL); <br> <br>    if (NULL==m_hWndList) <br>        return FALSE; <br> <br>    if (!CreateMonikers()) <br>        return FALSE; <br> <br>    if (!ListInitialize()) <br>        return FALSE; <br> <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br>    return fRet; <br>    } <br> <br> <br> <br>/* <br> * CApp::CreateMonikers <br> * <br> * Purpose: <br> *  Creates monikers and stores them in m_rgpmk. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::CreateMonikers(void) <br>    { <br>    TCHAR       szFile[]=TEXT("c:\\inole\\chap09\\linksrc\\goop.lks"); <br>    TCHAR       szItem1[]=TEXT("Object 2"); <br>    TCHAR       szItem2[]=TEXT("Sub-Object 3"); <br>    TCHAR       szDelim[]=TEXT("!"); <br>    IMoniker   *pmkItem; <br>    HRESULT     hr; <br> <br>    //Create a simple file moniker <br>    if (FAILED(CreateFileMoniker(szFile, &amp;m_rgpmk[0]))) <br>        return FALSE; <br> <br>    //Create File!Item moniker, item first, then composite <br>    if (FAILED(CreateItemMoniker(szDelim, szItem1, &amp;pmkItem))) <br>        return FALSE; <br> <br>    //The output here will be the File!Item moniker <br>    hr=m_rgpmk[0]-&gt;ComposeWith(pmkItem, FALSE, &amp;m_rgpmk[1]); <br>    pmkItem-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    /* <br>     * Now create the File!Item!Item by appending another item <br>     * onto the File!Item just created. <br>     */ <br>    if (FAILED(CreateItemMoniker(szDelim, szItem2, &amp;pmkItem))) <br>        return FALSE; <br> <br>    hr=m_rgpmk[1]-&gt;ComposeWith(pmkItem, FALSE, &amp;m_rgpmk[2]); <br>    pmkItem-&gt;Release(); <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::ListInitialize <br> * <br> * Purpose: <br> *  Retrieves the display names for each moniker in our <br> *  array and displays that name in the listbox. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::ListInitialize(void) <br>    { <br>    UINT        i; <br> <br>    for (i=0; i &lt; CMONIKERS; i++) <br>        { <br>        LPOLESTR    pszName; <br>        HRESULT     hr; <br>        IBindCtx   *pbc; <br> <br>        if (FAILED(CreateBindCtx(0, &amp;pbc))) <br>            return FALSE; <br> <br>        hr=m_rgpmk[i]-&gt;GetDisplayName(pbc, NULL, &amp;pszName); <br>        pbc-&gt;Release(); <br> <br>        if (FAILED(hr)) <br>            return FALSE; <br> <br>       #ifdef WIN32ANSI <br>        char    szTemp[256]; <br> <br>        WideCharToMultiByte(CP_ACP, 0, pszName, -1, szTemp, 256 <br>            , NULL, NULL); <br>        SendMessage(m_hWndList, LB_ADDSTRING, 0, (LPARAM)szTemp); <br>       #else <br>        SendMessage(m_hWndList, LB_ADDSTRING, 0, (LPARAM)pszName); <br>       #endif <br>        } <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::ShowDescription <br> * <br> * Purpose: <br> *  Tells CApp to retrieve the description text for a particular <br> *  item in its listbox.  This is done in response to a double-click <br> *  on a moniker display name which we bind to an ask for <br> *  IDescription. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CApp::ShowDescription(void) <br>    { <br>    int             i; <br> <br>    i=(int)SendMessage(m_hWndList, LB_GETCURSEL, 0, 0L); <br> <br>    if (LB_ERR==i) <br>        return; <br> <br>    BindAndShow(m_rgpmk[i], NULL); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::ParseAndBind <br> * <br> * Purpose: <br> *  Recreates a moniker from the display name under the current <br> *  selection then attempts to bind as with ShowDescription. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CApp::ParseAndBind(void) <br>    { <br>    HRESULT         hr; <br>    IBindCtx       *pbc; <br>    IMoniker       *pmk; <br>    int             i; <br>    TCHAR           szName[512]; <br>    ULONG           chEaten=0; <br> <br>    i=(int)SendMessage(m_hWndList, LB_GETCURSEL, 0, 0L); <br> <br>    if (LB_ERR==i) <br>        return; <br> <br>    SendMessage(m_hWndList, LB_GETTEXT, i, (LPARAM)(LPTSTR)szName); <br> <br>    if (FAILED(CreateBindCtx(0, &amp;pbc))) <br>        { <br>        MessageBox(m_hWnd, TEXT("Failed to create bind context") <br>            , TEXT("Link User"), MB_OK); <br>        return; <br>        } <br> <br> <br>    hr=MkParseDisplayName(pbc, szName, &amp;chEaten, &amp;pmk); <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        MessageBox(m_hWnd, TEXT("Name parsed.  Press OK to bind...") <br>            , TEXT("Link User"), MB_OK); <br> <br>        BindAndShow(pmk, pbc); <br>        pmk-&gt;Release(); <br>        } <br>    else <br>        { <br>        //Tell the user how far parsing got <br>        wsprintf(szName, TEXT("Parsing failed after %lu characters") <br>            , chEaten); <br> <br>        MessageBox(m_hWnd, szName, TEXT("Link User"), MB_OK); <br>        } <br> <br>    pbc-&gt;Release(); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::BindAndShow <br> * <br> * Purpose: <br> *  Binds to a given moniker to given moniker and requests <br> *  IDescription, asking that object for display text. <br> * <br> * Parameters: <br> *  pmk             IMoniker * naming the object. <br> *  pbc             IBindCtx * to use.  If NULL, this will use <br> *                  a default. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CApp::BindAndShow(IMoniker *pmk, IBindCtx *pbc) <br>    { <br>    HRESULT         hr; <br>    IDescription    *pIDescription; <br> <br>    if (NULL==pbc) <br>        { <br>        hr=BindMoniker(pmk, 0, IID_IDescription <br>            , (void **)&amp;pIDescription); <br>        } <br>    else <br>        { <br>        hr=pmk-&gt;BindToObject(pbc, NULL, IID_IDescription <br>            , (void **)&amp;pIDescription); <br>        } <br> <br>    if (SUCCEEDED(hr)) <br>        { <br>        const ULONG cch=512; <br>        TCHAR       szText[cch]; <br> <br>   #ifdef WIN32ANSI <br>    WCHAR       szw[cch]; <br>hr=pIDescription-&gt;GetText(szw, cch); <br>        WideCharToMultiByte(CP_ACP, 0, szw, -1, szText, cch, NULL, NULL); <br>   #else <br>        hr=pIDescription-&gt;GetText(szText, cch); <br>   #endif <br>        pIDescription-&gt;Release(); <br> <br>        if (SUCCEEDED(hr)) <br>            { <br>            MessageBox(m_hWnd, szText, TEXT("Description Is:") <br>                , MB_OK); <br>            } <br>        else <br>            { <br>            MessageBox(m_hWnd, TEXT("Failed to get description text") <br>                , TEXT("Link User"), MB_OK); <br>            } <br>        } <br>    else <br>        { <br>        MessageBox(m_hWnd, TEXT("BindMoniker failed") <br>            , TEXT("Link User"), MB_OK); <br>        } <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
