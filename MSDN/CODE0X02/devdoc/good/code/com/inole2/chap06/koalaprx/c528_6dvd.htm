<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KOALA.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context529"></a>KOALA.CPP</h2>
<pre><code>/* <br> * KOALA.CPP <br> * Koala Object with Custom Marshaling, Chapter 6 <br> * <br> * Implementation of the CKoala object with a custom interface <br> * to demonstrate local/remote transparency. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "koala.h" <br> <br> <br>/* <br> * CKoala::CKoala <br> * CKoala::~CKoala <br> * <br> * Parameters (Constructor): <br> *  pUnkOuter       LPUNKNOWN of a controlling unknown. <br> *  pfnDestroy      PFNDESTROYED to call when an object <br> *                  is destroyed. <br> */ <br> <br>CKoala::CKoala(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy) <br>    { <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pfnDestroy=pfnDestroy; <br> <br>    m_pImpIAnimal=NULL; <br>    m_pImpIKoala=NULL; <br>    m_pImpIMarshal=NULL; <br> <br>    m_fJustAte=FALSE; <br>    m_cSleepAfterEat=0; <br> <br>    return; <br>    } <br> <br> <br>CKoala::~CKoala(void) <br>    { <br>    DeleteInterfaceImp(m_pImpIMarshal); <br>    DeleteInterfaceImp(m_pImpIKoala); <br>    DeleteInterfaceImp(m_pImpIAnimal); <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CKoala::Init <br> * <br> * Purpose: <br> *  Performs any intiailization of a CKoala that's prone to failure <br> *  that we also use internally before exposing the object outside. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CKoala::Init(void) <br>    { <br>    IUnknown   *pUnkOuter=m_pUnkOuter; <br> <br>    if (NULL==pUnkOuter) <br>        pUnkOuter=this; <br> <br>    m_pImpIAnimal=new CImpIAnimal(this, pUnkOuter); <br> <br>    if (NULL==m_pImpIAnimal) <br>        return FALSE; <br> <br>    m_pImpIKoala=new CImpIKoala(this, pUnkOuter); <br> <br>    if (NULL==m_pImpIKoala) <br>        return FALSE; <br> <br>    m_pImpIMarshal=new CImpIMarshal(this, pUnkOuter); <br> <br>    if (NULL==m_pImpIMarshal) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoala::CallLocal <br> * <br> * Purpose: <br> *  Sends or posts a message to the local object. <br> * <br> * Parameters: <br> *  iMsg            UINT identifying the function to call <br> *  lParam          LPARAM containing extra information <br> *  fAsync          BOOL indicating if this is a Post (TRUE) or <br> *                  a send (FALSE). <br> * <br> * Return Value: <br> *  DWORD           Return value from the function or an HRESULT <br> *                  on failure. <br> */ <br> <br>DWORD CKoala::CallLocal(UINT iMsg, LPARAM lParam, BOOL fAsync) <br>    { <br>    DWORD   dwRet=0; <br> <br>    if (fAsync) <br>        PostMessage(m_hWndLocal, WM_COMMAND, (WPARAM)iMsg, lParam); <br>    else <br>        { <br>        dwRet=SendMessage(m_hWndLocal, WM_COMMAND, (WPARAM)iMsg <br>            , lParam); <br>        } <br> <br>    return dwRet; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoala::QueryInterface <br> * CKoala::AddRef <br> * CKoala::Release <br> * <br> * Purpose: <br> *  IUnknown members for CKoala object. <br> */ <br> <br>STDMETHODIMP CKoala::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    /* <br>     * The only calls for IUnknown are either in a nonaggregated <br>     * case or when created in an aggregation, so in either case <br>     * always return our IUnknown for IID_IUnknown. <br>     */ <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IAnimal==riid) <br>        *ppv=m_pImpIAnimal; <br> <br>    if (IID_IKoala==riid) <br>        *ppv=m_pImpIKoala; <br> <br>    if (IID_IMarshal==riid) <br>        *ppv=m_pImpIMarshal; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoala::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoala::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    /* <br>     * If this is the last Release, then we have to tell <br>     * the server to free its object too.  This is an async <br>     * call as we don't need to hang around for it to quit. <br>     */ <br>    CallLocal(MSG_RELEASE, 0, TRUE); <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br>//Proxy-side IAnimal implementation <br> <br> <br>/* <br> * CImpIAnimal::CImpIAnimal <br> * CImpIAnimal::~CImpIAnimal <br> * <br> * Constructor Parameters: <br> *  pObj            PCKoala of the object containing us. <br> *  pUnkOuter       LPUNKNOWN to which we blindly delegate <br> *                  all IUnknown calls. <br> */ <br> <br>CImpIAnimal::CImpIAnimal(PCKoala pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIAnimal::~CImpIAnimal(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::QueryInterface <br> * CImpIAnimal::AddRef <br> * CImpIAnimal::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for interface implementation. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIAnimal::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIAnimal::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Eat <br> * <br> * Purpose: <br> *  Instructs the animal to eat something, returning what the animal <br> *  actually ate which usually goes against recommendation (which is <br> *  true for the human animal, too). <br> * <br> * Parameters: <br> *  pszFoodRecommended  LPTSTR describing the food that the animal <br> *                      should eat. <br> *  pszFoodEaten        LPTSTR describing the food the animal actually <br> *                      ate, which may not, of course, be the same as <br> *                      what it should eat. <br> *  cchEaten            short containing the lenght of pszFoodEaten. <br> * <br> * Return Value: <br> *  HRESULT             NOERROR if food is eaten, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Eat(LPTSTR pszFoodRecommended <br>    , LPTSTR pszFoodEaten, short cchEaten) <br>    { <br>    /* <br>     * Koalas aren't don't care what you tell them, they eat one <br>     * thing.  We can handle the return string for the local <br>     * object, but we still need to tell it that this was <br>     * called. <br>     */ <br> <br>    _tcsncpy(pszFoodEaten, TEXT("Eucalyptus Leaves"), cchEaten); <br>    m_pObj-&gt;CallLocal(MSG_EAT, 0L, FALSE); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Sleep <br> * <br> * Purpose: <br> *  Instructs the animal to sleep for a while. <br> * <br> * Parameters: <br> *  pcMinutes      short * (in-out) containing the number of <br> *                 minutes to sleep on entry, then number of <br> *                 minutes actually slept on exit <br> * <br> * Return Value: <br> *  HRESULT        NOERROR if sleep taken, S_FALSE if not, where <br> *                 *pcMinutes should be zero. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Sleep(short *pcMinutes) <br>    { <br>    DWORD       dwRet; <br> <br>    //Pass the client's value <br>    dwRet=m_pObj-&gt;CallLocal(MSG_SLEEP, (LPARAM)*pcMinutes, FALSE); <br> <br>    if (FAILED((HRESULT)dwRet)) <br>        return (HRESULT)dwRet; <br> <br>    //Store the return value in the client's variable. <br>    *pcMinutes=LOWORD(dwRet); <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Procreate <br> * <br> * Purpose: <br> *  Instructs the animal to procreate.  On entry, the number of <br> *  offstring is unknown, so that's an out parameter. <br> * <br> * Parameters: <br> *  pcOffspring     short * (out) in which to store the number <br> *                  of new offspring. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if offspring created, S_FALSE if not <br> *                  where *pcOffspring should be zero. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Procreate(short *pcOffspring) <br>    { <br>    DWORD       dwRet; <br> <br>    dwRet=m_pObj-&gt;CallLocal(MSG_PROCREATE, 0, FALSE); <br> <br>    if (FAILED((HRESULT)dwRet)) <br>        return (HRESULT)dwRet; <br> <br>    *pcOffspring=(short)LOWORD(dwRet); <br>    return ResultFromScode(0==dwRet ? S_FALSE : S_OK); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIAnimal::WhatKindOfAnimal <br> * <br> * Purpose: <br> *  Returns the IID of the specific animal interface that describes <br> *  the type of animal this really is (a much more complex <br> *  classification scheme might have IAnimal::WhatGenus and <br> *  IGenus::WhatSpecies, etc., but we're just being simple here). <br> * <br> * Parameters: <br> *  pIID            IID * in which to store the specific <br> *                  animal IID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the animal type is known, <br> *                  S_FALSE if not with *pIID set to IID_NULL. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::WhatKindOfAnimal(IID *pIID) <br>    { <br>    //No need to ask the local object for something we know <br>    *pIID=IID_IKoala; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>//IKoala implementation <br> <br> <br>/* <br> * CImpIKoala::CImpIKoala <br> * CImpIKoala::~CImpIKoala <br> * <br> * Constructor Parameters: <br> *  pObj            PCKoala of the object containing us. <br> *  pUnkOuter       LPUNKNOWN to which we blindly delegate <br> *                  all IUnknown calls. <br> */ <br> <br>CImpIKoala::CImpIKoala(PCKoala pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIKoala::~CImpIKoala(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::QueryInterface <br> * CImpIKoala::AddRef <br> * CImpIKoala::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for interface implementation. <br> */ <br> <br>STDMETHODIMP CImpIKoala::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIKoala::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIKoala::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::ClimbEucalyptusTree <br> * <br> * Purpose: <br> *  Tells the Koala to go climb a tree, which means eating, which <br> *  a koala is probably more than happy to do. <br> * <br> * Parameters: <br> *  iTree           short identifying the tree to climb. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if tree climbed, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CImpIKoala::ClimbEucalyptusTree(short iTree) <br>    { <br>    //We know the server doesn't need this <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::PouchOpensDown <br> * <br> * Purpose: <br> *  Do-nothing function to demonstrate a void argument list. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT             NOERROR <br> */ <br> <br>STDMETHODIMP CImpIKoala::PouchOpensDown(void) <br>    { <br>    //We know the server doesn't need this <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::SleepAfterEating <br> * <br> * Purpose: <br> *  Tells the Koala to sleep an additional number of minutes after <br> *  eating. <br> * <br> * Parameters: <br> *  cMinutes        short * (in) containing the number of <br> *                  extra minutes to sleep after eating. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIKoala::SleepAfterEating(short cMinutes) <br>    { <br>    DWORD   dwRet; <br> <br>    dwRet=m_pObj-&gt;CallLocal(MSG_SLEEPAFTEREATING <br>        , (LPARAM)cMinutes, TRUE); <br> <br>    if (FAILED((HRESULT)dwRet)) <br>        return (HRESULT)dwRet; <br> <br>    return NOERROR; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
