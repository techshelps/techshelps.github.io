<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>KOALA.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context518"></a>KOALA.CPP</h2>
<pre><code>/* <br> * KOALA.CPP <br> * Koala Object with Custom Interface, Chapter 6 <br> * <br> * Implementation of the CKoala object with a custom interface <br> * to demonstrate local/remote transparency. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "koala.h" <br> <br> <br>/* <br> * CKoala::CKoala <br> * CKoala::~CKoala <br> * <br> * Parameters (Constructor): <br> *  pUnkOuter       LPUNKNOWN of a controlling unknown. <br> *  pfnDestroy      PFNDESTROYED to call when an object <br> *                  is destroyed. <br> */ <br> <br>CKoala::CKoala(LPUNKNOWN pUnkOuter, PFNDESTROYED pfnDestroy) <br>    { <br>    m_cRef=0; <br>    m_pUnkOuter=pUnkOuter; <br>    m_pfnDestroy=pfnDestroy; <br> <br>    //CHAPTER6MOD <br>    m_pImpIAnimal=NULL; <br>    m_pImpIKoala=NULL; <br> <br>    m_fJustAte=FALSE; <br>    m_cSleepAfterEat=0; <br>    //End CHAPTER6MOD <br> <br>    return; <br>    } <br> <br> <br>CKoala::~CKoala(void) <br>    { <br>    //CHAPTER6MOD <br>    DeleteInterfaceImp(m_pImpIKoala); <br>    DeleteInterfaceImp(m_pImpIAnimal); <br>    //End CHAPTER6MOD <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CKoala::Init <br> * <br> * Purpose: <br> *  Performs any intiailization of a CKoala that's prone to failure <br> *  that we also use internally before exposing the object outside. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function is successful, <br> *                  FALSE otherwise. <br> */ <br> <br>BOOL CKoala::Init(void) <br>    { <br>    //CHAPTER6MOD <br>    IUnknown   *pUnkOuter=m_pUnkOuter; <br> <br>    if (NULL==pUnkOuter) <br>        pUnkOuter=this; <br> <br>    m_pImpIAnimal=new CImpIAnimal(this, pUnkOuter); <br> <br>    if (NULL==m_pImpIAnimal) <br>        return FALSE; <br> <br>    m_pImpIKoala=new CImpIKoala(this, pUnkOuter); <br> <br>    if (NULL==m_pImpIKoala) <br>        return FALSE; <br>    //End CHAPTER6MOD <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CKoala::QueryInterface <br> * CKoala::AddRef <br> * CKoala::Release <br> * <br> * Purpose: <br> *  IUnknown members for CKoala object. <br> */ <br> <br>STDMETHODIMP CKoala::QueryInterface(REFIID riid, PPVOID ppv) <br>    { <br>    *ppv=NULL; <br> <br>    /* <br>     * The only calls for IUnknown are either in a nonaggregated <br>     * case or when created in an aggregation, so in either case <br>     * always return our IUnknown for IID_IUnknown. <br>     */ <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    //CHAPTER6MOD <br>    if (IID_IAnimal==riid) <br>        *ppv=m_pImpIAnimal; <br> <br>    if (IID_IKoala==riid) <br>        *ppv=m_pImpIKoala; <br>    //End CHAPTER6MOD <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoala::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CKoala::Release(void) <br>    { <br>    if (0L!=--m_cRef) <br>        return m_cRef; <br> <br>    if (NULL!=m_pfnDestroy) <br>        (*m_pfnDestroy)(); <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br>//CHAPTER6MOD <br> <br>//IAnimal implementation <br> <br> <br>/* <br> * CImpIAnimal::CImpIAnimal <br> * CImpIAnimal::~CImpIAnimal <br> * <br> * Constructor Parameters: <br> *  pObj            PCKoala of the object containing us. <br> *  pUnkOuter       LPUNKNOWN to which we blindly delegate <br> *                  all IUnknown calls. <br> */ <br> <br>CImpIAnimal::CImpIAnimal(PCKoala pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIAnimal::~CImpIAnimal(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::QueryInterface <br> * CImpIAnimal::AddRef <br> * CImpIAnimal::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for interface implementation. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIAnimal::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIAnimal::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Eat <br> * <br> * Purpose: <br> *  Instructs the animal to eat something, returning what the animal <br> *  actually ate which usually goes against recommendation (which is <br> *  true for the human animal, too). <br> * <br> * Parameters: <br> *  pszFoodRecommended  LPTSTR describing the food that the animal <br> *                      should eat. <br> *  pszFoodEaten        LPTSTR describing the food the animal actually <br> *                      ate, which may not, of course, be the same as <br> *                      what it should eat. <br> *  cchEaten            short containing the lenght of pszFoodEaten. <br> * <br> * Return Value: <br> *  HRESULT             NOERROR if food is eaten, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Eat(LPTSTR pszFoodRecommended <br>    , LPTSTR pszFoodEaten, short cchEaten) <br>    { <br>    //Koalas aren't don't care what you tell them, they eat one thing <br>   #ifdef WIN32ANSI <br>    lstrcpyn(pszFoodEaten, "Eucalyptus Leaves", cchEaten); <br>   #else <br>    _tcsncpy(pszFoodEaten, TEXT("Eucalyptus Leaves"), cchEaten); <br>   #endif <br>    m_pObj-&gt;m_fJustAte=TRUE; <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Sleep <br> * <br> * Purpose: <br> *  Instructs the animal to sleep for a while. <br> * <br> * Parameters: <br> *  pcMinutes      short * (in-out) containing the number of <br> *                 minutes to sleep on entry, then number of <br> *                 minutes actually slept on exit <br> * <br> * Return Value: <br> *  HRESULT        NOERROR if sleep taken, S_FALSE if not, where <br> *                 *pcMinutes should be zero. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Sleep(short *pcMinutes) <br>    { <br>    /* <br>     * Koalas welcome the opportunity to sleep, and will probably <br>     * sleep longer than you tell them, so return more time than <br>     * we were told based on IKoala::SleepAfterEating. <br>     */ <br>    *pcMinutes=*pcMinutes+m_pObj-&gt;m_cSleepAfterEat; <br>    m_pObj-&gt;m_fJustAte=FALSE;     //Probably want to eat again <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIAnimal::Procreate <br> * <br> * Purpose: <br> *  Instructs the animal to procreate.  On entry, the number of <br> *  offstring is unknown, so that's an out parameter. <br> * <br> * Parameters: <br> *  pcOffspring     short * (out) in which to store the number <br> *                  of new offspring. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if offspring created, S_FALSE if not <br> *                  where *pcOffspring should be zero. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::Procreate(short *pcOffspring) <br>    { <br>    DWORD       dw; <br>    SCODE       sc=S_FALSE; <br> <br>    /* <br>     * Koalas like to reproduce when they damn well please and <br>     * not when someone else tells them, so we'll just check <br>     * the current time, and if it's appropriate, we'll reproduce. <br>     * (Simulation:  use GetTickCount to get the system time, then <br>     * divide by 100 to filter out resolution concerns, then see if <br>     * the result is an even multiple of 10). <br>     * <br>     * Also, Koalas only produce one offspring at a time.  If <br>     * this was a rabbit, we might get anywhere from 2-20 offspring. <br>     */ <br> <br>    dw=GetTickCount()/100; <br> <br>    if ((dw/10)*10==dw) <br>        { <br>        *pcOffspring=1; <br>        sc=S_OK; <br>        } <br>    else <br>        *pcOffspring=0; <br> <br>    return ResultFromScode(sc); <br>    } <br> <br> <br> <br> <br>/* <br> * CImpIAnimal::WhatKindOfAnimal <br> * <br> * Purpose: <br> *  Returns the IID of the specific animal interface that describes <br> *  the type of animal this really is (a much more complex <br> *  classification scheme might have IAnimal::WhatGenus and <br> *  IGenus::WhatSpecies, etc., but we're just being simple here). <br> * <br> * Parameters: <br> *  pIID            IID * in which to store the specific <br> *                  animal IID. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the animal type is known, <br> *                  S_FALSE if not with *pIID set to IID_NULL. <br> */ <br> <br>STDMETHODIMP CImpIAnimal::WhatKindOfAnimal(IID *pIID) <br>    { <br>    *pIID=IID_IKoala; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br>//IKoala implementation <br> <br> <br>/* <br> * CImpIKoala::CImpIKoala <br> * CImpIKoala::~CImpIKoala <br> * <br> * Constructor Parameters: <br> *  pObj            PCKoala of the object containing us. <br> *  pUnkOuter       LPUNKNOWN to which we blindly delegate <br> *                  all IUnknown calls. <br> */ <br> <br>CImpIKoala::CImpIKoala(PCKoala pObj, LPUNKNOWN pUnkOuter) <br>    { <br>    m_cRef=0; <br>    m_pObj=pObj; <br>    m_pUnkOuter=pUnkOuter; <br>    return; <br>    } <br> <br>CImpIKoala::~CImpIKoala(void) <br>    { <br>    return; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::QueryInterface <br> * CImpIKoala::AddRef <br> * CImpIKoala::Release <br> * <br> * Purpose: <br> *  Delegating IUnknown members for interface implementation. <br> */ <br> <br>STDMETHODIMP CImpIKoala::QueryInterface(REFIID riid <br>    , LPVOID *ppv) <br>    { <br>    return m_pUnkOuter-&gt;QueryInterface(riid, ppv); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIKoala::AddRef(void) <br>    { <br>    ++m_cRef; <br>    return m_pUnkOuter-&gt;AddRef(); <br>    } <br> <br>STDMETHODIMP_(ULONG) CImpIKoala::Release(void) <br>    { <br>    --m_cRef; <br>    return m_pUnkOuter-&gt;Release(); <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::ClimbEucalyptusTree <br> * <br> * Purpose: <br> *  Tells the Koala to go climb a tree, which means eating, which <br> *  a koala is probably more than happy to do. <br> * <br> * Parameters: <br> *  iTree           short identifying the tree to climb. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if tree climbed, S_FALSE if not. <br> */ <br> <br>STDMETHODIMP CImpIKoala::ClimbEucalyptusTree(short iTree) <br>    { <br>    //Nothing to demonstrate... <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::PouchOpensDown <br> * <br> * Purpose: <br> *  Do-nothing function to demonstrate a void argument list. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  HRESULT             NOERROR <br> */ <br> <br>STDMETHODIMP CImpIKoala::PouchOpensDown(void) <br>    { <br>    //Nothing to demonstrate... <br>    return NOERROR; <br>    } <br> <br> <br> <br>/* <br> * CImpIKoala::SleepAfterEating <br> * <br> * Purpose: <br> *  Tells the Koala to sleep an additional number of minutes after <br> *  eating. <br> * <br> * Parameters: <br> *  cMinutes        short * (in) containing the number of <br> *                  extra minutes to sleep after eating. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CImpIKoala::SleepAfterEating(short cMinutes) <br>    { <br>    m_pObj-&gt;m_cSleepAfterEat=cMinutes; <br>    return NOERROR; <br>    } <br> <br>//End CHAPTER6MOD </code></pre>
<p>&nbsp;</p></body>
</HTML>
