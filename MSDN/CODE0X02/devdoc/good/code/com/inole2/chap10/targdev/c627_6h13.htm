<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TARGDEV.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context627"></a>TARGDEV.CPP</h2>
<pre><code>/* <br> * TARGDEV.CPP <br> * <br> * Sample target device structure handling functions.  This file <br> * is intended to be a small repository of functions that might <br> * be useful in development: <br> *  TargetDeviceToDC          Creates a DC or IC from a <br> *                            DVTARGETDEVICE structure. <br> *  TargetDeviceFromPrintDlg  Creates a DVTARGETDEVICE structure <br> *                            from PrintDlg information. <br> *  TargetDeviceCopy          Makes a binary copy of a DVTARGETDEVICE <br> *                            structure. <br> *  TargerDeviceCompare       Compares two DVTARGETDEVICE structures <br> *                            for equality. <br> * <br> * Copyright (c)1992-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INC_OLE2 <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include &lt;ole2ver.h&gt; <br>#include &lt;memory.h&gt; <br>#ifndef WIN32 <br>#include &lt;print.h&gt; <br>#endif <br> <br> <br>/* <br> * TargetDeviceToDC <br> * <br> * Purpose: <br> *  Given an OLE DVTARGETDEVICE structure, create an hDC for that <br> *  device, where that hDC can optionally be an IC only. <br> * <br> * Parameters: <br> *  ptd             DVTARGETDEVICE * describing the device. <br> *  fICOnly         BOOL indicating that the caller wants an IC <br> *                  not a DC. <br> * <br> * Return Value: <br> *  HDC             Valid DC for the device or NULL. <br> */ <br> <br>STDAPI_(HDC) TargetDeviceToDC(DVTARGETDEVICE *ptd, BOOL fICOnly) <br>    { <br>    LPDEVNAMES pDevNames; <br>    LPDEVMODE  pDevMode; <br>    LPTSTR     pszDriver; <br>    LPTSTR     pszDevice; <br>    LPTSTR     pszPort; <br> <br>    //Screen DC for a NULL device. <br>    if (NULL==ptd) <br>        { <br>        if (fICOnly) <br>            return CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL); <br>        else <br>            return CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL); <br>        } <br> <br>    pDevNames=(LPDEVNAMES)ptd; // offset for size field <br> <br>    pDevMode=(ptd-&gt;tdExtDevmodeOffset==0) ? NULL <br>        : (LPDEVMODE)((LPSTR)ptd+ptd-&gt;tdExtDevmodeOffset); <br> <br>    pszDriver=(LPTSTR)pDevNames+ptd-&gt;tdDriverNameOffset; <br>    pszDevice=(LPTSTR)pDevNames+ptd-&gt;tdDeviceNameOffset; <br>    pszPort  =(LPTSTR)pDevNames+ptd-&gt;tdPortNameOffset; <br> <br>    if (fICOnly) <br>        return CreateIC(pszDriver, pszDevice, pszPort, pDevMode); <br>    else <br>        return CreateDC(pszDriver, pszDevice, pszPort, pDevMode); <br>    } <br> <br> <br> <br> <br>/* <br> * TargetDeviceFromPrintDlg <br> * <br> * Purpose: <br> *  Creates an OLE DVTARGETDEVICE structure from a PRINTDLG <br> *  structure as returned from the common dialog API PrintDlg, <br> *  which is commonly used for Printer Setup. <br> * <br> * Parameters: <br> *  pPD             LPPRINTDLG containing device information. <br> * <br> * Return Value: <br> *  DVTARGETDEVICE * pointing to the new structure.  This is <br> *  allocated with the task memory allocator and should be <br> *  freed with CoTaskMemFree. <br> */ <br> <br>STDAPI_(DVTARGETDEVICE *)TargetDeviceFromPrintDlg(LPPRINTDLG pPD) <br>    { <br>    DVTARGETDEVICE  *ptd=NULL; <br>    LPDEVNAMES       pDevNames, pDN; <br>    LPDEVMODE        pDevMode, pDM; <br>    UINT             nMaxOffset; <br>    LPTSTR           pszName; <br>    DWORD            dwDevNamesSize, dwDevModeSize, dwPtdSize; <br> <br>    pDN=(LPDEVNAMES)GlobalLock(pPD-&gt;hDevNames); <br> <br>    if (NULL==pDN) <br>        return NULL; <br> <br>    pDM=(LPDEVMODE)GlobalLock(pPD-&gt;hDevMode); <br> <br>    if (NULL==pDM) <br>        { <br>        GlobalUnlock(pPD-&gt;hDevNames); <br>        return NULL; <br>        } <br> <br>    nMaxOffset=(pDN-&gt;wDriverOffset &gt; pDN-&gt;wDeviceOffset) <br>        ? pDN-&gt;wDriverOffset : pDN-&gt;wDeviceOffset ; <br> <br>    nMaxOffset=(pDN-&gt;wOutputOffset &gt; nMaxOffset) <br>        ? pDN-&gt;wOutputOffset : nMaxOffset ; <br> <br>    pszName=(LPTSTR)pDN+nMaxOffset; <br> <br>    dwDevNamesSize=(DWORD)(nMaxOffset+lstrlen(pszName)+1); <br>    dwDevModeSize=(DWORD) (pDM-&gt;dmSize+pDM-&gt;dmDriverExtra); <br> <br>    dwPtdSize=sizeof(DWORD)+dwDevNamesSize+dwDevModeSize; <br> <br>    ptd=(DVTARGETDEVICE *)CoTaskMemAlloc(dwPtdSize); <br> <br>    if (NULL!=ptd) <br>        { <br>       ptd-&gt;tdSize=(UINT)dwPtdSize; <br> <br>       pDevNames=(LPDEVNAMES) &amp;ptd-&gt;tdDriverNameOffset; <br>       #ifdef WIN32 <br>        memcpy(pDevNames, pDN, (size_t)dwDevNamesSize); <br>       #else <br>       _fmemcpy(pDevNames, pDN, (size_t)dwDevNamesSize); <br>       #endif <br> <br>       pDevMode=(LPDEVMODE)((LPTSTR)&amp;ptd-&gt;tdDriverNameOffset <br>            + dwDevNamesSize); <br>       #ifdef WIN32 <br>       memcpy(pDevMode, pDM, (size_t)dwDevModeSize); <br>       #else <br>        _fmemcpy(pDevMode, pDM, (size_t)dwDevModeSize); <br>       #endif <br> <br>        ptd-&gt;tdDriverNameOffset +=4 ; <br>        ptd-&gt;tdDeviceNameOffset +=4 ; <br>        ptd-&gt;tdPortNameOffset   +=4 ; <br>        ptd-&gt;tdExtDevmodeOffset=(UINT)dwDevNamesSize+4 ; <br>        } <br> <br>    GlobalUnlock(pPD-&gt;hDevNames); <br>    GlobalUnlock(pPD-&gt;hDevMode); <br>    return ptd; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * TargetDeviceCopy <br> * <br> * Purpose: <br> *  Duplicate a DVTARGETDEVICE structure, allocating new memory <br> *  for the copy which the caller must free with CoTaskMemFree. <br> * <br> * Parameters: <br> *  ptdSrc          DVTARGETDEVICE * to copy <br> * <br> * Return Value: <br> *  DVTARGETDEVICE * to the copy, NULL if copy fails or ptdSrc <br> *                  is NULL. <br> */ <br> <br>STDAPI_(DVTARGETDEVICE *) TargetDeviceCopy(DVTARGETDEVICE * ptdSrc) <br>    { <br>    DVTARGETDEVICE * ptdDest=NULL; <br> <br>    if (NULL==ptdSrc) <br>    return NULL; <br> <br>    ptdDest=(DVTARGETDEVICE *)CoTaskMemAlloc(ptdSrc-&gt;tdSize); <br> <br>    if (NULL!=ptdDest) <br>       #ifdef WIN32 <br>        memcpy(ptdDest, ptdSrc, (size_t)ptdSrc-&gt;tdSize); <br>       #else <br>        _fmemcpy(ptdDest, ptdSrc, (size_t)ptdSrc-&gt;tdSize); <br>       #endif <br> <br>    return ptdDest; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * TargetDeviceCompare <br> * <br> * Purpose: <br> *  Checks if two DVTARGETDEVICE structures are equivalent. <br> * <br> * Parameters: <br> *  ptdLeft         DVTARGETDEVICE to one structure. <br> *  ptdRight        DVTARGETDEVICE to another structure. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the structures are equivalent, <br> *                  FALSE otherwise. <br> */ <br> <br>STDAPI_(BOOL) TargetDeviceCompare(DVTARGETDEVICE *ptdLeft <br>    , DVTARGETDEVICE * ptdRight) <br>    { <br>    //Same address, same devices <br>    if (ptdLeft==ptdRight) <br>        return TRUE; <br> <br>    //Either is NULL but not the other, not equal <br>    if (NULL==ptdLeft || NULL==ptdRight) <br>        return FALSE; <br> <br>    //Different sizes, not equal <br>    if (ptdLeft-&gt;tdSize!=ptdRight-&gt;tdSize) <br>        return FALSE; <br> <br>    //Fo a binary compare <br>   #ifdef WIN32 <br>    if (0!=memcmp(ptdLeft, ptdRight, ptdLeft-&gt;tdSize)) <br>   #else <br>    if (0!=_fmemcmp(ptdLeft, ptdRight, (int)ptdLeft-&gt;tdSize)) <br>   #endif <br>    return FALSE; <br> <br>    return TRUE; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
