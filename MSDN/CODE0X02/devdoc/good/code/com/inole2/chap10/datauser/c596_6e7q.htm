<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DATAUSER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context596"></a>DATAUSER.CPP</h2>
<pre><code>/* <br> * DATAUSER.CPP <br> * Data Object User Chapter 10 <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#define INITGUIDS <br>#include "datauser.h" <br> <br> <br>//These are for displaying clipboard formats textually. <br>static TCHAR * rgszCF[13]={TEXT("Unknown"), TEXT("CF_TEXT") <br>                 , TEXT("CF_BITMAP"), TEXT("CF_METAFILEPICT") <br>                 , TEXT("CF_SYLK"), TEXT("CF_DIF"), TEXT("CF_TIFF") <br>                 , TEXT("CF_OEMTEXT"), TEXT("CF_DIB") <br>                 , TEXT("CF_PALETTE"), TEXT("CF_PENDATA") <br>                 , TEXT("CF_RIFF"), TEXT("CF_WAVE")}; <br> <br> <br>static TCHAR szSuccess[]    =TEXT("succeeded"); <br>static TCHAR szFailed[]     =TEXT("failed"); <br>static TCHAR szExpected[]   =TEXT("expected"); <br>static TCHAR szUnexpected[] =TEXT("unexpected!"); <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. <br> */ <br> <br>int PASCAL WinMain(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    MSG         msg; <br>    PAPP        pApp; <br> <br>    SETMESSAGEQUEUE(96); <br> <br>    pApp=new CApp(hInst, hInstPrev, nCmdShow); <br> <br>    if (NULL==pApp) <br>        return -1; <br> <br>    if (pApp-&gt;Init()) <br>        { <br>        while (GetMessage(&amp;msg, NULL, 0,0 )) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    delete pApp; <br>    return msg.wParam; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * DataUserWndProc <br> * <br> * Purpose: <br> *  Window class procedure.  Standard callback. <br> */ <br> <br>LRESULT APIENTRY DataUserWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    HRESULT         hr; <br>    PAPP            pApp; <br>    HMENU           hMenu; <br>    FORMATETC       fe; <br>    WORD            wID; <br> <br>    pApp=(PAPP)GetWindowLong(hWnd, DATAUSERWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pApp=(PAPP)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, DATAUSERWL_STRUCTURE, (LONG)pApp); <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_PAINT: <br>            pApp-&gt;Paint(); <br>            break; <br> <br>        case WM_COMMAND: <br>            SETDefFormatEtc(fe, 0, TYMED_HGLOBAL | TYMED_GDI <br>                | TYMED_MFPICT); <br> <br>            hMenu=GetMenu(hWnd); <br>            wID=LOWORD(wParam); <br> <br>            switch (wID) <br>                { <br>                case IDM_OBJECTUSEDLL: <br>                    if (!pApp-&gt;m_fEXE) <br>                        break; <br> <br>                    pApp-&gt;m_fEXE=FALSE; <br>                    pApp-&gt;FReloadDataObjects(TRUE); <br>                    break; <br> <br> <br>                case IDM_OBJECTUSEEXE: <br>                    if (pApp-&gt;m_fEXE) <br>                        break; <br> <br>                    pApp-&gt;m_fEXE=TRUE; <br>                    pApp-&gt;FReloadDataObjects(TRUE); <br>                    break; <br> <br>                case IDM_OBJECTDATASIZESMALL: <br>                case IDM_OBJECTDATASIZEMEDIUM: <br>                case IDM_OBJECTDATASIZELARGE: <br>                    CheckMenuItem(hMenu <br>                        , IDM_OBJECTDATASIZESMALL,  MF_UNCHECKED); <br>                    CheckMenuItem(hMenu <br>                        , IDM_OBJECTDATASIZEMEDIUM, MF_UNCHECKED); <br>                    CheckMenuItem(hMenu <br>                        , IDM_OBJECTDATASIZELARGE,  MF_UNCHECKED); <br>                    CheckMenuItem(hMenu, wID,  MF_CHECKED); <br> <br>                    //Kill old advise. <br>                    if (NULL!=pApp-&gt;m_pIDataObject <br>                        || 0!=pApp-&gt;m_dwConn) <br>                        { <br>                        pApp-&gt;m_pIDataObject-&gt;DUnadvise(pApp <br>                            -&gt;m_dwConn); <br>                        } <br> <br>                    if (IDM_OBJECTDATASIZELARGE==wID) <br>                        pApp-&gt;m_pIDataObject=pApp-&gt;m_pIDataLarge; <br>                    else if (IDM_OBJECTDATASIZEMEDIUM==wID) <br>                        pApp-&gt;m_pIDataObject=pApp-&gt;m_pIDataMedium; <br>                    else <br>                        pApp-&gt;m_pIDataObject=pApp-&gt;m_pIDataSmall; <br> <br>                    //Setup new advise. <br>                    fe.cfFormat=pApp-&gt;m_cfAdvise; <br>                    pApp-&gt;m_pIDataObject-&gt;DAdvise(&amp;fe, ADVF_NODATA <br>                        , pApp-&gt;m_pIAdviseSink, &amp;pApp-&gt;m_dwConn); <br> <br>                    break; <br> <br>                case IDM_OBJECTQUERYGETDATA: <br>                    if (NULL==pApp-&gt;m_pIDataObject) <br>                        break; <br> <br>                    fe.tymed=TYMED_HGLOBAL | TYMED_GDI <br>                         | TYMED_MFPICT; <br> <br>                    pApp-&gt;TryQueryGetData(&amp;fe, CF_TEXT, TRUE, 0); <br>                    pApp-&gt;TryQueryGetData(&amp;fe, CF_BITMAP, TRUE, 1); <br>                    pApp-&gt;TryQueryGetData(&amp;fe, CF_DIB, FALSE, 2); <br>                    pApp-&gt;TryQueryGetData(&amp;fe, CF_METAFILEPICT <br>                        , TRUE, 3); <br>                    pApp-&gt;TryQueryGetData(&amp;fe, CF_WAVE, FALSE, 4); <br>                    break; <br> <br> <br>                case IDM_OBJECTGETDATATEXT: <br>                case IDM_OBJECTGETDATABITMAP: <br>                case IDM_OBJECTGETDATAMETAFILEPICT: <br>                    if (NULL==pApp-&gt;m_pIDataObject) <br>                        break; <br> <br>                    //Clean up whatever we currently have. <br>                    pApp-&gt;m_cf=0; <br>                    ReleaseStgMedium(&amp;pApp-&gt;m_stm); <br> <br>                    if (IDM_OBJECTGETDATATEXT==wID) <br>                        SETDefFormatEtc(fe, CF_TEXT, TYMED_HGLOBAL); <br> <br>                    if (IDM_OBJECTGETDATABITMAP==wID) <br>                        SETDefFormatEtc(fe, CF_BITMAP, TYMED_GDI); <br> <br>                    if (IDM_OBJECTGETDATAMETAFILEPICT==wID) <br>                        { <br>                        SETDefFormatEtc(fe, CF_METAFILEPICT <br>                            , TYMED_MFPICT); <br>                        } <br> <br>                    hr=pApp-&gt;m_pIDataObject-&gt;GetData(&amp;fe <br>                        , &amp;(pApp-&gt;m_stm)); <br> <br>                    if (SUCCEEDED(hr)) <br>                        pApp-&gt;m_cf=fe.cfFormat; <br> <br>                    InvalidateRect(hWnd, NULL, TRUE); <br>                    UpdateWindow(hWnd); <br>                    break; <br> <br>                case IDM_OBJECTEXIT: <br>                    PostMessage(hWnd, WM_CLOSE, 0, 0L); <br>                    break; <br> <br> <br>                case IDM_ADVISETEXT: <br>                case IDM_ADVISEBITMAP: <br>                case IDM_ADVISEMETAFILEPICT: <br>                    if (NULL==pApp-&gt;m_pIDataObject) <br>                        break; <br> <br>                    //Terminate the old connection <br>                    if (0!=pApp-&gt;m_dwConn) <br>                        { <br>                        pApp-&gt;m_pIDataObject-&gt;DUnadvise(pApp <br>                            -&gt;m_dwConn); <br>                        } <br> <br>                    CheckMenuItem(hMenu, pApp-&gt;m_cfAdvise <br>                        +IDM_ADVISEMIN, MF_UNCHECKED); <br>                    CheckMenuItem(hMenu, wID, MF_CHECKED); <br> <br>                    //New format is wID-IDM_ADVISEMIN <br>                    pApp-&gt;m_cfAdvise=(UINT)(wID-IDM_ADVISEMIN); <br>                    fe.cfFormat=pApp-&gt;m_cfAdvise; <br>                    pApp-&gt;m_pIDataObject-&gt;DAdvise(&amp;fe, ADVF_NODATA <br>                        , pApp-&gt;m_pIAdviseSink, &amp;pApp-&gt;m_dwConn); <br> <br>                    break; <br> <br>                case IDM_ADVISEGETDATA: <br>                    pApp-&gt;m_fGetData=!pApp-&gt;m_fGetData; <br>                    CheckMenuItem(hMenu, wID, pApp-&gt;m_fGetData <br>                        ? MF_CHECKED : MF_UNCHECKED); <br>                    break; <br> <br>                case IDM_ADVISEREPAINT: <br>                    pApp-&gt;m_fRepaint=!pApp-&gt;m_fRepaint; <br>                    CheckMenuItem(hMenu, wID, pApp-&gt;m_fRepaint <br>                        ? MF_CHECKED : MF_UNCHECKED); <br>                    break; <br> <br>                default: <br>                    break; <br>                } <br>            break; <br> <br>        default: <br>            return (DefWindowProc(hWnd, iMsg, wParam, lParam)); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CApp::CApp <br> * CApp::~CApp <br> * <br> * Constructor Parameters: (from WinMain) <br> *  hInst           HINSTANCE of the application. <br> *  hInstPrev       HINSTANCE of a previous instance. <br> *  nCmdShow        UINT specifying how to show the app window. <br> */ <br> <br>CApp::CApp(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , UINT nCmdShow) <br>    { <br>    m_hInst=hInst; <br>    m_hInstPrev=hInstPrev; <br>    m_nCmdShow=nCmdShow; <br> <br>    m_hWnd=NULL; <br>    m_fEXE=FALSE; <br> <br>    m_pIAdviseSink=NULL; <br>    m_dwConn=0; <br>    m_cfAdvise=0; <br>    m_fGetData=FALSE; <br>    m_fRepaint=FALSE; <br> <br>    m_pIDataSmall =NULL; <br>    m_pIDataMedium=NULL; <br>    m_pIDataLarge =NULL; <br>    m_pIDataObject=NULL; <br> <br>    m_cf=0; <br>    m_stm.tymed=TYMED_NULL; <br>    m_stm.lpszFileName=NULL;      //Initializes union to NULL <br>    m_stm.pUnkForRelease=NULL; <br> <br>    m_fInitialized=FALSE; <br>    return; <br>    } <br> <br> <br>CApp::~CApp(void) <br>    { <br>    //This releases the data object interfaces and advises <br>    FReloadDataObjects(FALSE); <br> <br>    ReleaseStgMedium(&amp;m_stm); <br> <br>    //We called AddRef before so we could do this <br>    ReleaseInterface(m_pIAdviseSink); <br> <br>    if (IsWindow(m_hWnd)) <br>        DestroyWindow(m_hWnd); <br> <br>    if (m_fInitialized) <br>        CoUninitialize(); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CApp::Init <br> * <br> * Purpose: <br> *  Initializes an CApp object by registering window classes, <br> *  creating the main window, and doing anything else prone to <br> *  failure such as calling CoInitialize.  If this function fails <br> *  the caller should insure that the destructor is called. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CApp::Init(void) <br>    { <br>    WNDCLASS    wc; <br>    BOOL        fRet; <br> <br>    CHECKVER_COM; <br> <br>    if (FAILED(CoInitialize(NULL))) <br>        return FALSE; <br> <br>    m_fInitialized=TRUE; <br> <br>    //Register our window classes. <br>    if (!m_hInstPrev) <br>        { <br>        wc.style          = CS_HREDRAW | CS_VREDRAW; <br>        wc.lpfnWndProc    = DataUserWndProc; <br>        wc.cbClsExtra     = 0; <br>        wc.cbWndExtra     = CBWNDEXTRA; <br>        wc.hInstance      = m_hInst; <br>        wc.hIcon          = LoadIcon(m_hInst, TEXT("Icon")); <br>        wc.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>        wc.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>        wc.lpszMenuName   = MAKEINTRESOURCE(IDR_MENU); <br>        wc.lpszClassName  = TEXT("DATAUSER"); <br> <br>        if (!RegisterClass(&amp;wc)) <br>            return FALSE; <br>        } <br> <br>    //Create the main window. <br>    m_hWnd=CreateWindow(TEXT("DATAUSER"), TEXT("Data Object User") <br>        , WS_OVERLAPPEDWINDOW,35, 35, 350, 250, NULL <br>        , NULL, m_hInst, this); <br> <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br>    m_pIAdviseSink=new CAdviseSink(this); <br> <br>    if (NULL==m_pIAdviseSink) <br>        return FALSE; <br> <br>    m_pIAdviseSink-&gt;AddRef(); <br> <br>    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTUSEDLL, MF_CHECKED); <br>    CheckMenuItem(GetMenu(m_hWnd), IDM_OBJECTDATASIZESMALL <br>        , MF_CHECKED); <br> <br>    //Load the initial objects <br>    fRet=FReloadDataObjects(TRUE); <br>    m_pIDataObject=m_pIDataSmall; <br> <br>    return fRet; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CApp::FReloadDataObjects <br> * <br> * Purpose: <br> *  Releases the old data objects we're holding on to and reloads <br> *  the new ones from either EXE or DLL depending on m_fEXE. <br> * <br> * Parameters: <br> *  fReload         BOOL indicating if we are to recreate everything <br> *                  or just release the old ones (so we can use this <br> *                  from the destructor). <br> * <br> * Return Value: <br> *  BOOL            TRUE if there are usable objects in us now. <br> */ <br> <br>BOOL CApp::FReloadDataObjects(BOOL fReload) <br>    { <br>    HRESULT     hr1, hr2, hr3; <br>    DWORD       dwClsCtx; <br>    HCURSOR     hCur, hCurT; <br>    HMENU       hMenu; <br>    UINT        uTempD, uTempE; <br> <br>    //Clean out any data we're holding <br>    m_cf=0; <br>    ReleaseStgMedium(&amp;m_stm); <br> <br>    //Turn off whatever data connection we have <br>    if (NULL!=m_pIDataObject &amp;&amp; 0!=m_dwConn) <br>        m_pIDataObject-&gt;DUnadvise(m_dwConn); <br> <br>    ReleaseInterface(m_pIDataLarge); <br>    ReleaseInterface(m_pIDataMedium); <br>    ReleaseInterface(m_pIDataSmall); <br> <br>    m_pIDataObject=NULL; <br>    CoFreeUnusedLibraries(); <br> <br>    //Exit if we just wanted to free. <br>    if (!fReload) <br>        return FALSE; <br> <br> <br>    hCur=LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)); <br>    hCurT=SetCursor(hCur); <br>    ShowCursor(TRUE); <br> <br>    dwClsCtx=(m_fEXE) ? CLSCTX_LOCAL_SERVER : CLSCTX_INPROC_SERVER; <br> <br>    hr1=CoCreateInstance(CLSID_DataObjectSmall, NULL, dwClsCtx <br>        , IID_IDataObject, (PPVOID)&amp;m_pIDataSmall); <br> <br>    hr2=CoCreateInstance(CLSID_DataObjectMedium, NULL, dwClsCtx <br>        , IID_IDataObject, (PPVOID)&amp;m_pIDataMedium); <br> <br>    hr3=CoCreateInstance(CLSID_DataObjectLarge, NULL, dwClsCtx <br>        , IID_IDataObject, (PPVOID)&amp;m_pIDataLarge); <br> <br>    ShowCursor(FALSE); <br>    SetCursor(hCurT); <br> <br>    //If anything fails, recurse to clean up... <br>    if (FAILED(hr1) || FAILED(hr2) || FAILED(hr3)) <br>        return FReloadDataObjects(FALSE); <br> <br>    //Reset the state of the menus for Small, no advise, no options. <br>    hMenu=GetMenu(m_hWnd); <br>    CheckMenuItem(hMenu, IDM_OBJECTDATASIZESMALL,  MF_CHECKED); <br>    CheckMenuItem(hMenu, IDM_OBJECTDATASIZEMEDIUM, MF_UNCHECKED); <br>    CheckMenuItem(hMenu, IDM_OBJECTDATASIZELARGE,  MF_UNCHECKED); <br> <br>    m_pIDataObject=m_pIDataSmall; <br>    CheckMenuItem(hMenu, m_cfAdvise+IDM_ADVISEMIN, MF_UNCHECKED); <br> <br>    uTempE=m_fEXE  ? MF_CHECKED : MF_UNCHECKED; <br>    uTempD=!m_fEXE ? MF_CHECKED : MF_UNCHECKED; <br> <br>    CheckMenuItem(hMenu, IDM_OBJECTUSEDLL, uTempD); <br>    CheckMenuItem(hMenu, IDM_OBJECTUSEEXE, uTempE); <br> <br>    CheckMenuItem(hMenu, IDM_ADVISEGETDATA, MF_UNCHECKED); <br>    CheckMenuItem(hMenu, IDM_ADVISEREPAINT, MF_UNCHECKED); <br> <br>    m_fGetData=FALSE; <br>    m_fRepaint=FALSE; <br> <br>    //Cannot request data using async advises, so disable these. <br>    uTempE=m_fEXE  ? MF_DISABLED | MF_GRAYED : MF_ENABLED; <br>    EnableMenuItem(hMenu,  IDM_ADVISEGETDATA, uTempE); <br>    EnableMenuItem(hMenu, IDM_ADVISEREPAINT, uTempE); <br> <br>    return TRUE; <br>    } <br> <br> <br> <br>/* <br> * CApp::TryQueryGetData <br> * <br> * Purpose: <br> *  Centralized function call and output code for displaying results <br> *  of various IDataObject::QueryGetData calls. <br> * <br> * Parameters: <br> *  pFE             LPFORMATETC to test. <br> *  cf              UINT specific clipboard format to stuff in pFE <br> *                  before calling.  If zero, use whatever is <br> *                  already in pFE. <br> *  fExpect         BOOL indicating expected results <br> *  y               UINT line on which to print results. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CApp::TryQueryGetData(LPFORMATETC pFE, UINT cf <br>    , BOOL fExpect, UINT y) <br>    { <br>    TCHAR       szTemp[80]; <br>    LPTSTR      psz1; <br>    LPTSTR      psz2; <br>    UINT        cch; <br>    HRESULT     hr; <br>    HDC         hDC; <br> <br>    if (0!=cf) <br>        pFE-&gt;cfFormat=cf; <br> <br>    hr=m_pIDataObject-&gt;QueryGetData(pFE); <br>    psz1=(NOERROR==hr) ? szSuccess : szFailed; <br>    psz2=((NOERROR==hr)==fExpect) ? szExpected : szUnexpected; <br> <br>    hDC=GetDC(m_hWnd); <br>    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>    SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br> <br>    if (CF_WAVE &lt; cf || 0==cf) <br>        { <br>        cch=wsprintf(szTemp, TEXT("QueryGetData on %d %s (%s)") <br>            , cf, psz1, psz2); <br>        } <br>    else <br>        { <br>        cch=wsprintf(szTemp, TEXT("QueryGetData on %s %s (%s)") <br>            , (LPTSTR)rgszCF[cf], psz1, psz2); <br>        } <br> <br>    //Don't overwrite other painted display. <br>    SetBkMode(hDC, TRANSPARENT); <br>    TextOut(hDC, 0, 16*y, szTemp, cch); <br> <br>    ReleaseDC(m_hWnd, hDC); <br> <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CApp::Paint <br> * <br> * Purpose: <br> *  Handles WM_PAINT for the main window by drawing whatever <br> *  data we have sitting in the STGMEDIUM at this time. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CApp::Paint(void) <br>    { <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    HDC             hMemDC; <br>    LPMETAFILEPICT  pMF; <br>    LPTSTR          psz; <br>    RECT            rc; <br>    FORMATETC       fe; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    hDC=BeginPaint(m_hWnd, &amp;ps); <br> <br>    //May need to retrieve the data with EXE objects <br>    if (m_fEXE) <br>        { <br>        if (TYMED_NULL==m_stm.tymed &amp;&amp; 0!=m_cf) <br>            { <br>            SETDefFormatEtc(fe, m_cf, TYMED_HGLOBAL <br>                | TYMED_MFPICT | TYMED_GDI); <br> <br>            if (NULL!=m_pIDataObject) <br>                m_pIDataObject-&gt;GetData(&amp;fe, &amp;m_stm); <br>            } <br>        } <br> <br>    switch (m_cf) <br>        { <br>        case CF_TEXT: <br>            psz=(LPTSTR)GlobalLock(m_stm.hGlobal); <br> <br>            if (NULL==psz) <br>                break; <br> <br>            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT)); <br>            SetBkColor(hDC, GetSysColor(COLOR_WINDOW)); <br> <br>            DrawText(hDC, psz, lstrlen(psz), &amp;rc <br>                , DT_LEFT | DT_WORDBREAK); <br>            GlobalUnlock(m_stm.hGlobal); <br>            break; <br> <br> <br>        case CF_BITMAP: <br>            hMemDC=CreateCompatibleDC(hDC); <br> <br>            if (NULL!=SelectObject(hMemDC, (HGDIOBJ)m_stm.hGlobal)) <br>                { <br>                BitBlt(hDC, 0, 0, rc.right-rc.left, rc.bottom-rc.top <br>                    , hMemDC, 0, 0, SRCCOPY); <br>                } <br> <br>            DeleteDC(hMemDC); <br>            break; <br> <br> <br>        case CF_METAFILEPICT: <br>            pMF=(LPMETAFILEPICT)GlobalLock(m_stm.hGlobal); <br> <br>            if (NULL==pMF) <br>                break; <br> <br>            SetMapMode(hDC, pMF-&gt;mm); <br>            SetWindowOrgEx(hDC, 0, 0, NULL); <br>            SetWindowExtEx(hDC, pMF-&gt;xExt, pMF-&gt;yExt, NULL); <br> <br>            SetViewportExtEx(hDC, rc.right-rc.left <br>                , rc.bottom-rc.top, NULL); <br> <br>            PlayMetaFile(hDC, pMF-&gt;hMF); <br>            GlobalUnlock(m_stm.hGlobal); <br>            break; <br> <br> <br>        default: <br>            break; <br>        } <br> <br>    EndPaint(m_hWnd, &amp;ps); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
