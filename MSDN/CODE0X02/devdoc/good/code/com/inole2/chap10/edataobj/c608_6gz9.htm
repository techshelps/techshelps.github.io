<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RENDER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context615"></a>RENDER.CPP</h2>
<pre><code>/* <br> * RENDER.CPP <br> * Data Object Chapter 10 <br> * <br> * CDataObject::Render* functions to create text, bitmaps, and <br> * metafiles in a variety of sizes. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "dataobj.h" <br>#include &lt;string.h&gt; <br> <br> <br>/* <br> * CDataObject::RenderText <br> * <br> * Purpose: <br> *  Creates a global memory block containing the letter 'k' of sizes <br> *  of 64 bytes, 1024 bytes, and 16384 bytes, into a caller-supplied <br> *  STGMEDIUM. <br> * <br> * Parameters: <br> *  pSTM            LPSTGMEDIUM in which to render. <br> * <br> * Return Value: <br> *  HRESULT         Return value for GetData <br> */ <br> <br>HRESULT CDataObject::RenderText(LPSTGMEDIUM pSTM) <br>    { <br>    DWORD       cch; <br>    HGLOBAL     hMem; <br>    LPTSTR      psz; <br>    UINT        i; <br> <br>    //Get the size of data we're dealing with <br>    switch (m_iSize) <br>        { <br>        case DOSIZE_SMALL: <br>            cch=CCHTEXTSMALL; <br>            break; <br> <br>        case DOSIZE_MEDIUM: <br>            cch=CCHTEXTMEDIUM; <br>            break; <br> <br>        case DOSIZE_LARGE: <br>            cch=CCHTEXTLARGE; <br>            break; <br> <br>        default: <br>            return ResultFromScode(E_FAIL); <br>        } <br> <br>    hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, cch*sizeof(TCHAR)); <br> <br>    if (NULL==hMem) <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br> <br>    psz=(LPTSTR)GlobalLock(hMem); <br> <br>    for (i=0; i &lt; cch-1; i++) <br>        *(psz+i)=TEXT(' ') + (i % 32); <br> <br>    *(psz+i)=0; <br> <br>    GlobalUnlock(hMem); <br> <br>    pSTM-&gt;hGlobal=hMem; <br>    pSTM-&gt;tymed=TYMED_HGLOBAL; <br>    pSTM-&gt;pUnkForRelease=NULL; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CDataObject::RenderBitmap <br> * <br> * Purpose: <br> *  Creates a new bitmap into which we copy a bitmap loaded <br> *  from our resources. <br> * <br> * Parameters: <br> *  pSTM            LPSTGMEDIUM in which to render. <br> * <br> * Return Value: <br> *  HRESULT         Return value for GetData <br> */ <br> <br>HRESULT CDataObject::RenderBitmap(LPSTGMEDIUM pSTM) <br>    { <br>    HBITMAP     hBmp, hBmpT; <br>    UINT        cxy; <br>    HDC         hDC, hDCSrc, hDCDst; <br> <br>    //Get the size of bitmap we're dealing with <br>    switch (m_iSize) <br>        { <br>        case DOSIZE_SMALL: <br>            cxy=CXYBITMAPSMALL; <br>            break; <br> <br>        case DOSIZE_MEDIUM: <br>            cxy=CXYBITMAPMEDIUM; <br>            break; <br> <br>        case DOSIZE_LARGE: <br>            cxy=CXYBITMAPLARGE; <br>            break; <br> <br>        default: <br>            return ResultFromScode(E_FAIL); <br>        } <br> <br>    //Get two memory DCs between which to BitBlt. <br>    hDC=GetDC(NULL); <br>    hDCSrc=CreateCompatibleDC(hDC); <br>    hDCDst=CreateCompatibleDC(hDC); <br>    ReleaseDC(NULL, hDC); <br> <br>    if (NULL==hDCSrc || NULL==hDCDst) <br>        { <br>        if (NULL!=hDCDst) <br>            DeleteDC(hDCDst); <br> <br>        if (NULL!=hDCSrc) <br>            DeleteDC(hDCSrc); <br> <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br>        } <br> <br>    SelectObject(hDCSrc, m_rghBmp[m_iSize-DOSIZE_SMALL]); <br> <br>    hBmp=CreateCompatibleBitmap(hDCSrc, cxy, cxy); <br> <br>    if (NULL==hBmp) <br>        { <br>        DeleteDC(hDCDst); <br>        DeleteDC(hDCSrc); <br> <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br>        } <br> <br>    //Copy from the source to destination <br>    hBmpT=(HBITMAP)SelectObject(hDCDst, hBmp); <br>    BitBlt(hDCDst, 0, 0, cxy, cxy, hDCSrc, 0, 0, SRCCOPY); <br>    SelectObject(hDCDst, hBmpT); <br> <br>    DeleteDC(hDCDst); <br>    DeleteDC(hDCSrc); <br> <br>    pSTM-&gt;hGlobal=(HGLOBAL)hBmp; <br>    pSTM-&gt;tymed=TYMED_GDI; <br>    pSTM-&gt;pUnkForRelease=NULL; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CDataObject::RenderMetafilePict <br> * <br> * Purpose: <br> *  Creates a metafile containing blue shaded bands. <br> * <br> * Parameters: <br> *  pSTM            LPSTGMEDIUM in which to render. <br> * <br> * Return Value: <br> *  HRESULT         Return value for GetData <br> */ <br> <br>HRESULT CDataObject::RenderMetafilePict(LPSTGMEDIUM pSTM) <br>    { <br>    HDC             hDC; <br>    HGLOBAL         hMem; <br>    HMETAFILE       hMF; <br>    LPMETAFILEPICT  pMF; <br>    HBRUSH          hBrush; <br>    HGDIOBJ         hBrT; <br>    UINT            cRec; <br>    int             x, y, dxy; <br>    RECT            rc; <br> <br>    switch (m_iSize) <br>        { <br>        case DOSIZE_SMALL: <br>            cRec=CRECMETAFILESMALL; <br>            break; <br> <br>        case DOSIZE_MEDIUM: <br>            cRec=CRECMETAFILEMEDIUM; <br>            break; <br> <br>        case DOSIZE_LARGE: <br>            cRec=CRECMETAFILELARGE; <br>            break; <br> <br>        default: <br>            return ResultFromScode(E_FAIL); <br>        } <br> <br> <br>    hDC=(HDC)CreateMetaFile(NULL); <br> <br>    if (NULL!=hDC) <br>        { <br>        /* <br>         * Draw something into the metafile.  For this object we <br>         * draw some number of rectangles equal to the number of <br>         * records we want.  So take the square root of the number <br>         * of records and iterate over that number in both x &amp; y. <br>         */ <br> <br>        dxy=(int)1024/cRec; <br> <br> <br>        //This creates a blue shading from light to dark <br>        for (y=1024; y &gt;=0; y-=dxy) <br>            { <br>            hBrush=CreateSolidBrush(RGB(0, 0, (1024-y)/4)); <br>            hBrT=SelectObject(hDC, (HGDIOBJ)hBrush); <br> <br>            for (x=0; x &lt; 1024; x+=dxy) <br>                { <br>                SetRect(&amp;rc, x, y, x+dxy, y+dxy); <br>                FillRect(hDC, &amp;rc, hBrush); <br>                } <br> <br>            SelectObject(hDC, hBrT); <br>            DeleteObject(hBrush); <br>            } <br> <br>        hMF=CloseMetaFile(hDC); <br>        } <br> <br>    if (NULL==hMF) <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br> <br>    //Allocate the METAFILEPICT structure. <br>    hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE <br>        , sizeof(METAFILEPICT)); <br> <br>    if (NULL==hMem) <br>        { <br>        DeleteMetaFile(hMF); <br>        return ResultFromScode(STG_E_MEDIUMFULL); <br>        } <br> <br>    pMF=(LPMETAFILEPICT)GlobalLock(hMem); <br> <br>    pMF-&gt;hMF=hMF; <br>    pMF-&gt;mm=MM_ANISOTROPIC; <br>    pMF-&gt;xExt=1024; <br>    pMF-&gt;yExt=1024; <br> <br>    GlobalUnlock(hMem); <br> <br>    pSTM-&gt;hGlobal=hMem; <br>    pSTM-&gt;tymed=TYMED_MFPICT; <br>    pSTM-&gt;pUnkForRelease=NULL; <br>    return NOERROR; <br>    } <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
