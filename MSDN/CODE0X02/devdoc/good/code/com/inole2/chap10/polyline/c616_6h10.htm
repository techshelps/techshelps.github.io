<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POLYWIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context624"></a>POLYWIN.CPP</h2>
<pre><code>/* <br> * POLYWIN.CPP <br> * Polyline Component Chapter 10 <br> * <br> * Window procedure for the polyline drawing window and support <br> * functions. <br> * <br> * Copyright (c)1993-1995 Microsoft Corporation, All Rights Reserved <br> * <br> * Kraig Brockschmidt, Microsoft <br> * Internet  :  kraigb@microsoft.com <br> * Compuserve:  &gt;INTERNET:kraigb@microsoft.com <br> */ <br> <br> <br>#include "polyline.h" <br> <br> <br>/* <br> * PolylineWndProc <br> * <br> * Purpose: <br> *  Window procedure for the polyline drawing window. <br> */ <br> <br>LRESULT APIENTRY PolylineWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCPolyline      ppl; <br>    PAINTSTRUCT     ps; <br>    HDC             hDC; <br>    POINTS          pt; <br>    RECT            rc; <br> <br>    ppl=(PCPolyline)GetWindowLong(hWnd, PLWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_CREATE: <br>            ppl=(PCPolyline)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br>            SetWindowLong(hWnd, PLWL_STRUCTURE, (LONG)ppl); <br> <br>            //New repaints this window, so store the hWnd here. <br>            ppl-&gt;m_hWnd=hWnd; <br>            ppl-&gt;m_pImpIPolyline-&gt;New(); <br>            break; <br> <br> <br>        case WM_PAINT: <br>            hDC=BeginPaint(hWnd, &amp;ps); <br>            ppl-&gt;Draw(hDC, FALSE, TRUE); <br>            EndPaint(hWnd, &amp;ps); <br>            break; <br> <br> <br>        case WM_LBUTTONDOWN: <br>            //Stop if we are already at the limit. <br>            if (CPOLYLINEPOINTS==ppl-&gt;m_pl.cPoints) <br>                { <br>                MessageBeep(0); <br>                break; <br>                } <br> <br>            //Convert the points into 0-32767 range <br>            GetClientRect(hWnd, &amp;rc); <br>            pt=MAKEPOINTS(lParam); <br>            ppl-&gt;PointScale(&amp;rc, &amp;pt, FALSE); <br> <br>            ppl-&gt;m_pl.rgpt[ppl-&gt;m_pl.cPoints++]=pt; <br> <br>            //Draw the lines to this new point only. <br>            hDC=GetDC(hWnd); <br>            ppl-&gt;Draw(hDC, FALSE, FALSE); <br>            ReleaseDC(hWnd, hDC); <br> <br>            if (NULL!=ppl-&gt;m_pAdv) <br>                ppl-&gt;m_pAdv-&gt;OnPointChange(); <br> <br>            break; <br> <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::Draw <br> * <br> * Purpose: <br> *  Paints the current line in the polyline window. <br> * <br> * Parameters: <br> *  hDC             HDC to draw on, a metafile or printer DC. <br> *  fMetafile       BOOL indicating if hDC is a metafile or not, <br> *                  so we can avoid operations that RIP. <br> *  fEntire         BOOL indicating if we should draw the entire <br> *                  figure or not. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::Draw(HDC hDC, BOOL fMetafile, BOOL fEntire) <br>    { <br>    HBRUSH          hBrush; <br>    HPEN            hPen; <br>    HGDIOBJ         hObj1, hObj2; <br>    UINT            i, j; <br>    UINT            uMM; <br>    POINTS          pt1, pt2; <br>    POINT           rgpt[CPOLYLINEPOINTS]; <br>    RECT            rc; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    /* <br>     * Make a 32-bit copy of the points in the POLYLINE itself <br>     * so we can use DPtoLP and LPtoDP. <br>     */ <br>    for (i=0; i &lt; m_pl.cPoints; i++) <br>        { <br>        rgpt[i].x=m_pl.rgpt[i].x; <br>        rgpt[i].y=m_pl.rgpt[i].y; <br>        } <br> <br>    /* <br>     * If the mapping mode is not MM_TEXT, convert the points to <br>     * whatever mapping mode in in effect before drawing. <br>     * This specifically supports metafiles in MM_ANISOTROPIC. <br>     */ <br>    uMM=fMetafile ? MM_TEXT : GetMapMode(hDC); <br> <br>    if (MM_TEXT!=uMM) <br>        DPtoLP(hDC, rgpt, m_pl.cPoints); <br> <br>    hPen=CreatePen(m_pl.iLineStyle, 1, m_pl.rgbLine); <br>    hObj1=SelectObject(hDC, hPen); <br> <br>    hBrush=CreateSolidBrush(m_pl.rgbBackground); <br>    hObj2=SelectObject(hDC, hBrush); <br>    SetBkColor(hDC, m_pl.rgbBackground); <br> <br>    /* <br>     * Either draw the entire figure or just a single point.  The <br>     * entire figure also includes erasing the background <br>     * completely, since hDC may be a metafile DC.  Drawing a single <br>     * point just updates the figure for that new point. <br>     */ <br>    if (fEntire || 0==m_pl.cPoints) <br>        { <br>        //Erase the background for bitmaps and metafiles. <br>        SelectObject(hDC, GetStockObject(NULL_PEN)); <br>        Rectangle(hDC, rc.left, rc.top, rc.right+1, rc.bottom+1); <br>        SelectObject(hDC, hPen); <br> <br> <br>        /* <br>         * If we are drawing the entire figure, then loop through <br>         * each point drawing a line to each successive point. <br>         */ <br> <br>        for (i=0; i &lt; m_pl.cPoints; i++) <br>            { <br>            for (j=i; j &lt; m_pl.cPoints; j++) <br>                { <br>                pt1.x=(short)rgpt[i].x; <br>                pt1.y=(short)rgpt[i].y; <br>                pt2.x=(short)rgpt[j].x; <br>                pt2.y=(short)rgpt[j].y; <br> <br>                PointScale(&amp;rc, &amp;pt1, TRUE); <br>                PointScale(&amp;rc, &amp;pt2, TRUE); <br>                MoveToEx(hDC, pt1.x, pt1.y, NULL); <br>                LineTo(hDC, pt2.x, pt2.y); <br>                } <br>            } <br>        } <br>    else <br>        { <br>        /* <br>         * If we are only drawing the last point, just cycle once <br>         * through previous points. <br>         */ <br> <br>        //Get the last point entered in the array. <br>        j=m_pl.cPoints-1; <br>        pt1.x=(short)rgpt[j].x; <br>        pt1.y=(short)rgpt[j].y; <br>        PointScale(&amp;rc, &amp;pt1, TRUE); <br> <br>        for (i=0; i &lt; j; i++) <br>            { <br>            pt2.x=(short)rgpt[i].x; <br>            pt2.y=(short)rgpt[i].y; <br>            PointScale(&amp;rc, &amp;pt2, TRUE); <br> <br>            MoveToEx(hDC, pt1.x, pt1.y, NULL); <br>            LineTo(hDC, pt2.x, pt2.y); <br>            } <br>        } <br> <br>    //If we have one point, draw a dot to indicate it's position. <br>    if (1==m_pl.cPoints) <br>        { <br>        pt1.x=(short)rgpt[0].x; <br>        pt1.y=(short)rgpt[0].y; <br>        PointScale(&amp;rc, &amp;pt1, TRUE); <br>        SetPixel(hDC, pt1.x, pt1.y, m_pl.rgbLine); <br>        } <br> <br>    //Restore original points. <br>    if (MM_TEXT!=uMM) <br>        LPtoDP(hDC, rgpt, m_pl.cPoints); <br> <br>    SelectObject(hDC, hObj1); <br>    SelectObject(hDC, hObj2); <br>    DeleteObject(hBrush); <br>    DeleteObject(hPen); <br>    return; <br>    } <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * CPolyline::PointScale <br> * <br> * Purpose: <br> *  Scales a point to or from a relative window coordinate to a <br> *  0-32767 coordinate. <br> * <br> * Parameters: <br> *  pRect           LPRECT of the window. <br> *  ppt             LPPOINTS to convert <br> *  fScaleToWindow  BOOL indicating direction of scaling. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CPolyline::PointScale(LPRECT pRect, LPPOINTS ppt <br>    , BOOL fScaleToWindow) <br>    { <br>    DWORD   cx, cy; <br> <br>    //Window size <br>    cx=(DWORD)(pRect-&gt;right-pRect-&gt;left); <br>    cy=(DWORD)(pRect-&gt;bottom-pRect-&gt;top); <br> <br>    //Prevent crashes <br>    if (0L==cx) cx=1; <br>    if (0L==cy) cy=1; <br> <br>    //Must use DWORD to insure proper scaling. <br>    if (fScaleToWindow) <br>        { <br>        ppt-&gt;x=(UINT)(((DWORD)ppt-&gt;x*cx) &gt;&gt; 15); <br>        ppt-&gt;y=(UINT)(((DWORD)ppt-&gt;y*cy) &gt;&gt; 15); <br>        } <br>    else <br>        { <br>        ppt-&gt;x=(UINT)(((DWORD)ppt-&gt;x &lt;&lt; 15)/cx); <br>        ppt-&gt;y=(UINT)(((DWORD)ppt-&gt;y &lt;&lt; 15)/cy); <br>        } <br> <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
