<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEIMP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context401"></a>OLEIMP.CPP</h2>
<pre><code>// =========================================================================== <br>// File: O L E I M P . C P P <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//  <br>//  The OLEIMP sample demonstrates a method for emulating auto impersonation <br>// of clients. Normally, objects created on the server will run in the <br>// context of the server.  An object method must explicitly impersonate the <br>// client if the method is to run in the context of the client.  This <br>// sample demonstrates a way to arrange for methods to "automatically" run <br>// in the context of the client. <br>//  <br>// This program is based on the oleapt sample.  It uses a set of apartment <br>// threads that each potentially impersonate a client. All objects created <br>// for a user run in the same apartment.  The security for the server <br>// is explicitly set up to allow the world call access.  Launch permission <br>// will still need to be set using the DCOMCNFG.EXE utility if you want <br>// other than the default launch permission. <br>//  <br>// The server registers a class-factory on the main application thread and <br>// also spawns several worker threads. When requests arrive from clients <br>// to create instances of the class, the server class-factory picks a <br>// worker thread for the object in the following manner: <br>//  <br>//   - If there is a thread currently impersonating that user, use that <br>//     thread. <br>//   - Otherwise, if there is a free thread, set that thread up to <br>//     impersonate the client and use that thread. <br>//   - Otherwise fail the CreateInstance call. <br>//  <br>// The server then goes through the process of having the object created <br>// within the thread and properly marshalled from the worker thread <br>// back to the class factory where it can be returned to the caller. Note <br>// that this marshalling to the main thread is fairly transient, it lasts <br>// for creation only: subsequent calls from the client to the object go <br>// straight from the client's process into the worker apartment. <br>//  <br>// To register this server run OLEIMP.EXE with the -AutoRegister command <br>// line switch.  OLEIMP.EXE registers itself to run as the interactive <br>// user.  For more information about the activation options for DCOM <br>// applications see the DCOM document on the Win32 SDK CD in the <br>// \doc\spec\ole directory. <br>// <br>// This sample may be compiled as either UNICODE or ANSI. <br>//  <br>// Copyright 1996 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define STRICT <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "util.h" <br> <br>// %%Constants: -------------------------------------------------------------- <br>#define cServerThreads  5 <br>#define szWindowClass   TEXT("OLEIMP_CLASS") <br>#define szTitleServer   TEXT("SERVER: OLE Apartment Impersonation Sample") <br>#define szCloseQuery    TEXT("Client references still exist. Are you sure you want to close?") <br>#define COINIT_APARTMENTTHREADED    2 <br>#define MAX_USER_NAME50 <br>const LARGE_INTEGER     bZero = {0,0}; <br> <br>// %%Guids: ------------------------------------------------------------------ <br>DEFINE_GUID(CLSID_CObject, 0x35b79d1, 0xd6d3, 0x11cf, 0xb9, 0xd4, 0x0, 0xaa, 0x0, 0xa2, 0x16, 0xe0); <br> <br>// %%Classes: ---------------------------------------------------------------- <br>// the class-factory object exists in the main application apartment/thread <br>// and is used to create instances of the worker objects on worker threads. <br>class CClassFactory : public IClassFactory <br>    { <br>  // IClassFactory <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return mcRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void)   { if (--mcRef == 0) { delete this; return 0; } return mcRef; } <br>    STDMETHODIMP            CreateInstance(LPUNKNOWN punkOuter, REFIID iid, LPVOID FAR *ppv); <br>    STDMETHODIMP            LockServer(BOOL fLock); <br> <br>  // data members <br>    ULONG   mcRef; <br> <br>  // constructors/destructors <br>  public: <br>    CClassFactory() { mcRef = 1; } <br>    }; <br> <br>// this worker object is simple: it simply supports IUnknown. more interesting <br>// interfaces can be readily added here and implemented for the worker. <br>class CObject : public IUnknown <br>    { <br>  // IUnknown <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return mcRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void); <br> <br>  // data members <br>    ULONG   mcRef; <br> <br>  // constructors/destructors <br>  public: <br>    CObject() { mcRef = 1; } <br>    }; <br> <br>// %%Globals: ---------------------------------------------------------------- <br>BOOL        vfServer;                       // is this instance a server or client? <br>HANDLE      vrghThread[cServerThreads];     // worker thread handles <br>DWORD       vrgtid[cServerThreads];         // worker thread id's <br>HANDLE      vrghEvent[cServerThreads];      // creation event for each worker <br>INT         vrgcObjects[cServerThreads];    // # of objects created on each thread <br>PSIDvrgpSid[cServerThreads];// SID of user in each apt. <br>LPTSTRvrgpszAptUser[cServerThreads];// name of each apt. user <br>HANDLE      vhEventServer;                  // creation-complete event for class-factory <br>CClassFactory   vclassfactory; <br>HWND        vhwndMain; <br>LPSTREAM    vpstmMarshalling;               // scratch stream used for cross-apt marshalling <br>HRESULT     vhrThreadStatus;                // signals status to class-factory <br> <br>// %%Prototypes: ------------------------------------------------------------- <br>LRESULT CALLBACK    MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam); <br>LRESULT             ServerThreadProc(LPARAM lParam); <br>BOOL                FAutoRegister(HINSTANCE hinst); <br>BOOLFindSlot(PSID psid, int *piThread); <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: MainWndProc <br>// --------------------------------------------------------------------------- <br> LRESULT CALLBACK <br>MainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    LRESULT lresult = TRUE; <br>int i; <br> <br>    switch (message) <br>        { <br>        case WM_PAINT: <br>            { <br>            HDC hdc; <br>            PAINTSTRUCT ps; <br>            int i; <br> <br>            if ((hdc = BeginPaint(hwnd, &amp;ps)) != NULL) <br>                { <br>                for (i=0; i&lt;cServerThreads; i++) <br>                    { <br>                    TCHAR    rgch[200]; <br> <br>// if a thread which is impersonating a user no <br>// longer has any objects, free up the resources <br>// and stop impersonating <br>if (0 == vrgcObjects[i] &amp;&amp; NULL != vrgpSid[i]) <br>{ <br>UtilFreeMem(vrgpszAptUser[i]); <br>vrgpszAptUser[i] = NULL; <br>UtilFreeMem(vrgpSid[i]); <br>vrgpSid[i] = NULL; <br>SetThreadToken (&amp;vrghThread[i], NULL); <br>} <br> <br>                    wsprintf(rgch, TEXT("Thread #%d (%s): %d objects"), <br>                    i, <br>                    (NULL == vrgpszAptUser[i])? <br>                    TEXT("No User") : <br>                    vrgpszAptUser[i], <br>                    vrgcObjects[i]); <br>                    TextOut(hdc, 20, 10+(i*25), rgch, lstrlen(rgch)); <br>                    } <br>                } <br>            EndPaint(hwnd, &amp;ps); <br>            } <br>            break; <br> <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_CLOSE: <br>            // check for clients and prompt in the UI. <br>            for (i=0; i&lt;cServerThreads; i++) <br>                { <br>                if (vrgcObjects[i] &gt; 0) <br>                    { <br>                    if (MessageBox(hwnd, szCloseQuery, <br>                            szTitleServer, MB_YESNO) == IDNO) <br>                        return FALSE; <br>                    else <br>                        break; <br>                    } <br>                } <br> <br>        default: <br>            return DefWindowProc(hwnd, message, wParam, lParam); <br>        } <br> <br>    return lresult; <br>}  // MainWndProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: WinMain <br>//  Initialization and main message-pump <br>// --------------------------------------------------------------------------- <br> int PASCAL <br>WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    WNDCLASS wndclass; <br>    HRESULT hr; <br>    int     i; <br>    DWORD   dwRegister = 0; <br>    MSG     msg; <br>PSECURITY_DESCRIPTOR psd = NULL; <br> <br>    // parse the command-line <br>    if (szCmdLine) <br>        { <br>        LPSTR   sz = strtok(szCmdLine, " \t"); <br> <br>if (sz) <br>{ <br>if (!strcmpi(sz, "-AutoRegister")) <br>{ <br>    if (!FAutoRegister(hinst)) <br>        { <br>        hr = GetLastError(); <br>        goto LCleanup; <br>        } <br>else <br>{ <br>MessageBox (GetDesktopWindow(), <br>TEXT("Registered Successfully!"), <br>szTitleServer, MB_OK); <br>return S_OK; <br>} <br>} <br>else <br>vfServer = TRUE; <br>} <br>        } <br>  <br>    // initialize COM <br>    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); <br>    if (FAILED(hr)) <br>        { <br>        ErrorMessage(NULL, TEXT("CoInitializeEx"), hr); <br>        return hr; <br>        } <br> <br>// psd must remain valid until after we uninit COM <br>if (!CreateAppSecurityDescriptor(&amp;psd)) <br>{ <br>return E_FAIL; <br>} <br> <br>// initialize the security layer <br>hr = CoInitializeSecurity ( <br>psd, <br>-1, <br>NULL, <br>NULL, <br>RPC_C_AUTHN_LEVEL_CONNECT, <br>RPC_C_IMP_LEVEL_IMPERSONATE, <br>NULL, <br>0, <br>NULL); <br>    if (FAILED(hr)) <br>        { <br>        ErrorMessage(NULL, TEXT("CoInitializeSecurity"), hr); <br>        return hr; <br>        } <br> <br>    // create the threads and synchronization events <br>    // which the server will need <br>    for (i=0; i&lt;cServerThreads; i++) <br>        { <br>        TCHAR    rgch[32]; <br> <br>        // create the thread suspended so its event can be <br>        // created using its thread-id and it will be able to <br>        // use it as soon as it runs <br>        vrghThread[i] = CreateThread(NULL, <br>            0, <br>            (LPTHREAD_START_ROUTINE)&amp;ServerThreadProc, <br>            0, <br>            CREATE_SUSPENDED, <br>            &amp;vrgtid[i]); <br>        if (vrghThread[i] == NULL) <br>            { <br>            hr = GetLastError(); <br>            goto LCleanup; <br>            } <br> <br>        // a thread can use its thread-id to OpenEvent this existing <br>        // event at any time. it can also look for its thread-id in <br>        // vrgtid[] to determine its index for use with vrghEvent. <br>        // this event signals to a worker thread to create a new CObject <br>        wsprintf(rgch, TEXT("Thread_%d"), vrgtid[i]); <br>        vrghEvent[i] = CreateEvent(NULL, FALSE, FALSE, rgch); <br>        if (vrghEvent[i] == NULL) <br>            { <br>            hr = GetLastError(); <br>            goto LCleanup; <br>            } <br> <br>// initially no user is associated with a thread <br>vrgpSid[i] = NULL; <br>vrgpszAptUser[i] = NULL; <br> <br>        // now that the event is available, let the thread run <br>        ResumeThread(vrghThread[i]); <br>        } <br> <br>    // this signals the status of a worker threads creation after <br>    // receiving its create signal via vrghEvent[i] <br>    vhEventServer = CreateEvent(NULL, FALSE, FALSE, TEXT("Server")); <br>    if (vhEventServer == NULL) <br>        { <br>        hr = GetLastError(); <br>        goto LCleanup; <br>        } <br> <br>    // register the class-factory with COM <br>    hr = CoRegisterClassObject(CLSID_CObject, <br>        (IUnknown *)&amp;vclassfactory, <br>        CLSCTX_LOCAL_SERVER, <br>        REGCLS_MULTIPLEUSE, <br>        &amp;dwRegister); <br>    if (FAILED(hr)) <br>        goto LCleanup; <br> <br>    // create an IStream to be used for marshalling new objects between <br>    // the worker and the CClassFactory <br>    hr = CreateStreamOnHGlobal(NULL, TRUE, &amp;vpstmMarshalling); <br>    if (FAILED(hr)) <br>        goto LCleanup; <br> <br>    // create the server UI <br>    memset(&amp;wndclass, 0, sizeof(wndclass)); <br>    wndclass.lpszClassName = szWindowClass; <br>    wndclass.style = CS_HREDRAW | CS_VREDRAW; <br>    wndclass.lpfnWndProc = MainWndProc; <br>    wndclass.hIcon = LoadIcon(NULL, IDI_APPLICATION); <br>    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1); <br>    wndclass.hInstance = hinst; <br> <br>    if (!RegisterClass(&amp;wndclass) || <br>        (vhwndMain = CreateWindow(szWindowClass, <br>            szTitleServer, <br>            WS_OVERLAPPEDWINDOW, <br>            CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, <br>            HWND_DESKTOP, NULL, hinst, NULL)) == NULL) <br>        { <br>        hr = GetLastError(); <br>        goto LCleanup; <br>        } <br> <br>    ShowWindow(vhwndMain, nCmdShow); <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>        { <br>        TranslateMessage(&amp;msg); <br>        DispatchMessage(&amp;msg); <br>        } <br>    hr = msg.wParam; <br> <br>LCleanup: <br>    if (hr != S_OK) <br>        ErrorMessage(NULL, TEXT("CoInitializeEx"), hr); <br> <br>    // we explicitly don't clean up threads and events <br>    if (dwRegister != 0) <br>        CoRevokeClassObject(dwRegister); <br>    if (vpstmMarshalling != NULL) <br>        vpstmMarshalling-&gt;Release(); <br> <br>    CoUninitialize(); <br> <br>FreeAppSecurityDescriptor (psd); <br> <br>    return hr; <br>}  // WinMain <br> <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: FAutoRegister <br>//  Registers the CObject class in the registry. <br>// --------------------------------------------------------------------------- <br> BOOL <br>FAutoRegister(HINSTANCE hinst) <br>{ <br>    static const TCHAR szClassDesc[]= TEXT("Ole Apartment Impersonation Sample"); <br>    static const TCHAR szCLSIDEntry[]= TEXT("CLSID\\{035B79D1-D6D3-11cf-B9D4-00AA00A216E0}"); <br>static const TCHAR szAppIDEntry[]= TEXT("APPID\\{035B79D1-D6D3-11cf-B9D4-00AA00A216E0}"); <br>static const TCHAR szAppIDString[]= TEXT("{035B79D1-D6D3-11cf-B9D4-00AA00A216E0}"); <br>static const TCHAR szAppID[]= TEXT("AppID"); <br>static const TCHAR szLocalServer32[]= TEXT("LocalServer32"); <br>static const TCHAR szRunAs[]= TEXT("RunAs"); <br>static const TCHAR szInteractiveUser[]= TEXT("Interactive User"); <br>    TCHAR       szPath[512]; <br>TCHARszModuleEntry[512]; <br>LPTSTRindex; <br>    HKEY        hkeyT = NULL; <br> <br>    // install the CLSID key and get the FQP for this executable <br>    if ((RegSetValue(HKEY_CLASSES_ROOT, szCLSIDEntry, REG_SZ, szClassDesc, <br>            lstrlen(szClassDesc)) != ERROR_SUCCESS) || <br>        (RegCreateKey(HKEY_CLASSES_ROOT, szCLSIDEntry, &amp;hkeyT) <br>            != ERROR_SUCCESS) || <br>        !GetModuleFileName(hinst, szPath, sizeof(szPath))) <br>        return FALSE; <br> <br>// install the LocalServer32 value <br>    if (RegSetValue(hkeyT, szLocalServer32, REG_SZ, szPath, lstrlen(szPath)) <br>            != ERROR_SUCCESS) <br>        goto LErrExit; <br> <br>// install a pointer to our App ID <br>    if (RegSetValueEx(hkeyT, szAppID, 0, REG_SZ, (LPBYTE)szAppIDString, <br>    sizeof(szAppIDString)) != ERROR_SUCCESS) <br>        goto LErrExit; <br> <br>    RegCloseKey(hkeyT); <br> <br>// install the App ID <br>if ((RegSetValue(HKEY_CLASSES_ROOT, szAppIDEntry, REG_SZ, szClassDesc, <br>lstrlen(szClassDesc)) != ERROR_SUCCESS) || <br>(RegCreateKey(HKEY_CLASSES_ROOT, szAppIDEntry, &amp;hkeyT) <br>!= ERROR_SUCCESS)) <br>goto LErrExit; <br> <br>// indicate that we should run as the interactive user <br>if (RegSetValueEx(hkeyT, szRunAs, 0, REG_SZ, (LPBYTE)szInteractiveUser, <br>sizeof(szInteractiveUser)) != ERROR_SUCCESS) <br>goto LErrExit; <br> <br>    RegCloseKey(hkeyT); <br> <br>// get the App ID module entry <br>index = _tcsrchr (szPath, TEXT('\\')); <br>if (NULL == index) <br>index = szPath; <br>else <br>index += 1; <br> <br>lstrcpy (szModuleEntry, TEXT("APPID\\")); <br>lstrcat (szModuleEntry, index); <br> <br>// Create the module entry in the APPID tree <br>if (RegCreateKey(HKEY_CLASSES_ROOT, szModuleEntry, &amp;hkeyT) <br>!= ERROR_SUCCESS) <br>goto LErrExit; <br> <br>// associate the App ID with the module <br>if (RegSetValueEx(hkeyT, szAppID, 0, REG_SZ, (LPBYTE)szAppIDString, <br>sizeof(szAppIDString)) != ERROR_SUCCESS) <br>goto LErrExit; <br> <br>    RegCloseKey(hkeyT); <br> <br>    return TRUE; <br> <br>LErrExit: <br>    RegCloseKey(hkeyT); <br>    return FALSE; <br>}  // FAutoRegister <br> <br>// =========================================================================== <br>//                          C C L A S S F A C T O R Y <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CClassFactory. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IClassFactory || iid == IID_IUnknown) <br>        { <br>        *ppv = (IClassFactory *)this; <br>        } <br>    if (*ppv != NULL) <br>        { <br>        AddRef(); <br>        return S_OK; <br>        } <br>    return E_NOINTERFACE; <br>}  // CClassFactory::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::CreateInstance <br>//  Creates a new instance of a CObject on a worker thread. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv) <br>{ <br>    LPUNKNOWN   punk; <br>    HRESULT     hr; <br>HANDLEhToken = NULL, hPrimaryToken = NULL; <br>PSIDpsidUser = NULL; <br>intiThread; <br> <br>// Get the client's token <br>hr = CoImpersonateClient (); <br>    if (FAILED(hr)) <br>    { <br>        ErrorMessage(NULL, TEXT("CoImpersonateClient"), hr); <br>    return hr; <br>} <br> <br>if (!OpenThreadToken(GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &amp;hToken)) <br>{ <br>hr = GetLastError(); <br>ErrorMessage(NULL, TEXT("OpenThreadToken"), hr); <br>return hr; <br>} <br> <br>CoRevertToSelf (); <br> <br>__try <br>{ <br>if (!GetUserSidFromToken (hToken, &amp;psidUser)) <br>{ <br>ErrorMessage(NULL, TEXT("GetUserSidFromToken"), 0); <br>return(E_FAIL); <br>} <br> <br>// find an index for this user <br>if (!FindSlot(psidUser, &amp;iThread)) <br>return(E_OUTOFMEMORY);// not enough "resources" <br> <br>// if this is a previously free slot, set it up <br>if (NULL == vrgpSid[iThread]) <br>{ <br>// The impersonation token we first get disappears after <br>// the call completes.  We need to get a more permanent <br>// token for the worker thread. <br>if (!DuplicateTokenEx(hToken, TOKEN_ALL_ACCESS, NULL, <br>SecurityImpersonation, TokenPrimary, &amp;hPrimaryToken)) <br>    { <br>hr = GetLastError (); <br>        ErrorMessage(NULL, TEXT("DuplicateTokenEx"), hr); <br>return(hr); <br>} <br> <br>CloseHandle (hToken); <br>hToken = NULL; <br> <br>if (!DuplicateTokenEx(hPrimaryToken, TOKEN_ALL_ACCESS, NULL, <br>SecurityImpersonation, TokenImpersonation, &amp;hToken)) <br>    { <br>hr = GetLastError (); <br>        ErrorMessage(NULL, TEXT("DuplicateTokenEx"), hr); <br>return(hr); <br>} <br> <br>if (!SetThreadToken (&amp;vrghThread[iThread], hToken)) <br>{ <br>hr = GetLastError (); <br>ErrorMessage(NULL, TEXT("SetThreadToken"), hr); <br>return(hr); <br>} <br> <br>// store and null out stuff we don't want freed or closed <br>vrgpSid[iThread] = psidUser; <br>psidUser = NULL; <br>} <br>} <br>__finally <br>{ <br>UtilFreeMem(psidUser); <br>if (NULL != hToken) <br>CloseHandle (hToken); <br>if (NULL != hPrimaryToken) <br>CloseHandle (hPrimaryToken); <br>} <br> <br>    *ppv = NULL; <br>    if (punkOuter != NULL) <br>        return CLASS_E_NOAGGREGATION; <br> <br>    // trigger the worker thread that we want to create an object <br>    SetEvent(vrghEvent[iThread]); <br> <br>    // now wait for the object to signal its completion <br>    WaitForSingleObject(vhEventServer, INFINITE); <br> <br>    // once the worker thread signals completion, vhrThreadStatus <br>    // lets us know if the creation process was successful, and if <br>    // vpstmMarshalling creates a marshalled interface pointer <br>    if (FAILED(vhrThreadStatus)) <br>        return vhrThreadStatus; <br> <br>    // unmarshal an IUnknown from the scratch stream. if unmarshaling <br>    // fails, it takes care of releasing the object inside the marshal-data <br>    hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>    if (FAILED(hr)) <br>        return hr; <br>    hr = CoUnmarshalInterface(vpstmMarshalling, IID_IUnknown, (void **)&amp;punk); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>    // get a reference to the interface asked for <br>    hr = punk-&gt;QueryInterface(iid, ppv); <br>    punk-&gt;Release(); <br> <br>    return hr; <br>}  // CClassFactory::CreateInstance <br> <br> STDMETHODIMP <br>CClassFactory::LockServer(BOOL fLock) <br>{ <br>    // there's no need to support this for this sample <br>    return E_FAIL; <br>}  // CClassFactory::LockServer <br> <br> <br>// =========================================================================== <br>//                               C O B J E C T <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ServerThreadProc <br>//  The worker thread function. Handles messages for objects of its thread/apt <br>// and creates new objects. <br>// --------------------------------------------------------------------------- <br> LRESULT <br>ServerThreadProc(LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    MSG     msg; <br>    int     iThread; <br> <br>    // figure out which thread this is: it needs its synchronization event <br>    for (iThread=0; iThread&lt;cServerThreads; iThread++) <br>        { <br>        if (vrgtid[iThread] == GetCurrentThreadId()) <br>            break; <br>        } <br>    if (iThread==cServerThreads) <br>        return E_UNEXPECTED; <br> <br>    // initialize COM <br>    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); <br>    if (FAILED(hr)) <br>        { <br>        MessageBeep(0); <br>        return hr; <br>        } <br> <br>    // apartment message/event loop <br>    // (see SDK documentation for MsgWaitForMultipleObjects) <br>    // here worker message loops last forever. in situations without a <br>    // static number of worker threads, the loop could easily be terminated by <br>    // WM_QUITs sent from the main thread which might manage the worker thread <br>    // pool more carefully. <br>    while (TRUE) <br>        { <br>        DWORD dwWaitResult; <br> <br>        // wait for any message sent or posted to this queue <br>        // or for one of the passed handles to become signaled <br>        dwWaitResult = MsgWaitForMultipleObjects(1, &amp;vrghEvent[iThread], <br>            FALSE, INFINITE, QS_ALLINPUT); <br> <br>        // result tells us the type of event we have: <br>        // a message or a signaled handle <br> <br>        // if there are one or more messages in the queue ... <br>        if (dwWaitResult == (WAIT_OBJECT_0 + 1)) <br>            { <br>            // dispatch all of the messages in this next loop <br>            // (here is where we'd check for WM_QUITs to end this <br>            // worker thread if we wanted to) <br>            while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>                DispatchMessage(&amp;msg); <br>            } <br>        else <br>            { <br>            // this thread was signaled to create a new object <br>            try <br>                { <br>                LPUNKNOWN   punk; <br> <br>// if the user name isn't set, look it up <br>// we could do this in the class factory, but this gives <br>// us a sanity check on the impersonation <br>if (NULL == vrgpszAptUser[iThread]) <br>{ <br>LPTSTR pszUser; <br>DWORD cchUser = MAX_USER_NAME; <br> <br>if (!UtilAllocMem ((PVOID*)&amp;pszUser, cchUser*sizeof(TCHAR))) <br>throw E_OUTOFMEMORY; <br> <br>if (!GetUserName (pszUser, &amp;cchUser)) <br>lstrcpy (pszUser, TEXT("Name not found")); <br> <br>vrgpszAptUser[iThread] = pszUser; <br>} <br> <br>                // create a new CObject <br>                punk = (IUnknown *)new CObject; <br>                if (punk == NULL) <br>                    throw E_OUTOFMEMORY; <br> <br>                hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>                if (FAILED(hr)) <br>                    throw hr; <br>                hr = CoMarshalInterface(vpstmMarshalling, <br>                    IID_IUnknown, <br>                    punk, <br>                    MSHCTX_INPROC, <br>                    NULL, <br>                    MSHLFLAGS_NORMAL); <br>                if (FAILED(hr)) <br>                    throw hr; <br> <br>                // punk is now referenced by its marshal-data in vpstmMarshalling. <br>                // we release our local reference here so the unmarshaller will <br>                // have the sole reference. a common mistake is to forget this <br>                // release and end up with orphaned objects in the server. <br>                punk-&gt;Release(); <br> <br>                // modify the global state -- the # of objects/thread -- which is <br>                // displayed in the server UI <br>                vrgcObjects[iThread]++; <br>                InvalidateRect(vhwndMain, NULL, TRUE); <br> <br>                vhrThreadStatus = S_OK; <br>                } <br>            catch (HRESULT hr) <br>                { <br>                vhrThreadStatus = hr; <br>                } <br>            SetEvent(vhEventServer); <br>            } <br> <br>        } <br> <br>    CoUninitialize(); <br>    return msg.wParam; <br>}  // ServerThreadProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CObject::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CObject. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CObject::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IUnknown) <br>        { <br>        *ppv = (IUnknown *)this; <br>        } <br>    if (*ppv != NULL) <br>        { <br>        AddRef(); <br>        return S_OK; <br>        } <br>    return E_NOINTERFACE; <br>}  // CObject::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CObject::Release <br>//  Handles releases of references to a CObject. Purpose here is to have code <br>// which alters the global state which is displayed in the servers UI. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP_(ULONG) <br>CObject::Release(void) <br>{ <br>    if (--mcRef == 0) <br>        { <br>        // change the global server state -- the # of objects/thread -- <br>        // reflected in the server UI <br>        for (int i=0; i&lt;cServerThreads; i++) <br>            { <br>            if (vrgtid[i] == GetCurrentThreadId()) <br>                { <br>// A sanity check to see if we're still impersonating... <br>TCHAR szUser[MAX_USER_NAME]; <br>DWORD cchUser = MAX_USER_NAME; <br> <br>if (!GetUserName (szUser, &amp;cchUser)) <br>ErrorMessage(NULL, TEXT("GetUserName"), GetLastError ()); <br>else <br>{ <br>if (lstrcmp (szUser, vrgpszAptUser[i])) <br>ErrorMessage (NULL, TEXT("Impersonation error."), S_OK); <br>} <br> <br>                vrgcObjects[i]--; <br>                InvalidateRect(vhwndMain, NULL, TRUE); <br>                break; <br>                } <br>            } <br> <br>        delete this; <br>        return 0; <br>        } <br>    return mcRef; <br>}  // CObject::Release <br> <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: FindSlot <br>//  Determines what slot in the array of worker threads may be used by the <br>// user represented by psid. <br>// --------------------------------------------------------------------------- <br>BOOL FindSlot(PSID psid, int *piThread) <br>{ <br>int iThread; <br> <br>// see if there is already an apartment impersonating this user <br>for (iThread = 0; iThread &lt; cServerThreads; iThread++) <br>{ <br>if ((NULL != vrgpSid[iThread]) &amp;&amp; <br>(EqualSid (psid, vrgpSid[iThread]))) <br>break; <br>} <br> <br>// if this user didn't have a thread already, find a free one <br>if (iThread == cServerThreads) <br>{ <br>for (iThread = 0; iThread &lt; cServerThreads; iThread++) <br>{ <br>if (NULL == vrgpSid[iThread]) <br>break; <br>} <br> <br>if (iThread == cServerThreads) // no resources available... <br>return(FALSE); <br>} <br> <br>// return the index to use <br>*piThread = iThread; <br>return(TRUE); <br>} <br> <br>// EOF ======================================================================= </code></pre>
<p>&nbsp;</p></body>
</HTML>
