<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SDMGMT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context396"></a>SDMGMT.CPP</h2>
<pre><code>/*++ <br> <br>DCOM Permission Configuration Sample <br>Copyright (c) 1996, Microsoft Corporation. All rights reserved. <br> <br>Module Name: <br> <br>    sdmgmt.cpp <br> <br>Abstract: <br> <br>    Routines to manage security descriptors <br> <br>Author: <br> <br>    Michael Nelson <br> <br>Environment: <br> <br>    Windows NT <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "ntsecapi.h" <br>#include "dcomperm.h" <br> <br>DWORD <br>CreateNewSD ( <br>    SECURITY_DESCRIPTOR **SD <br>    ) <br>{ <br>    PACL    dacl; <br>    DWORD   sidLength; <br>    PSID    sid; <br>    PSID    groupSID; <br>    PSID    ownerSID; <br>    DWORD   returnValue; <br> <br>    *SD = NULL; <br> <br>    returnValue = GetCurrentUserSID (&amp;sid); <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    sidLength = GetLengthSid (sid); <br> <br>    *SD = (SECURITY_DESCRIPTOR *) malloc ( <br>        (sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength) + <br>        (2 * sidLength) + <br>        sizeof (SECURITY_DESCRIPTOR)); <br> <br>    groupSID = (SID *) (*SD + 1); <br>    ownerSID = (SID *) (((BYTE *) groupSID) + sidLength); <br>    dacl = (ACL *) (((BYTE *) ownerSID) + sidLength); <br> <br>    if (!InitializeSecurityDescriptor (*SD, SECURITY_DESCRIPTOR_REVISION)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br> <br>    if (!InitializeAcl (dacl, <br>                        sizeof (ACL)+sizeof (ACCESS_ALLOWED_ACE)+sidLength, <br>                        ACL_REVISION2)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br> <br>    if (!AddAccessAllowedAce (dacl, <br>                              ACL_REVISION2, <br>                              COM_RIGHTS_EXECUTE, <br>                              sid)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br> <br>    if (!SetSecurityDescriptorDacl (*SD, TRUE, dacl, FALSE)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br> <br>    memcpy (groupSID, sid, sidLength); <br>    if (!SetSecurityDescriptorGroup (*SD, groupSID, FALSE)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br> <br>    memcpy (ownerSID, sid, sidLength); <br>    if (!SetSecurityDescriptorOwner (*SD, ownerSID, FALSE)) <br>    { <br>        free (*SD); <br>        free (sid); <br>        return GetLastError(); <br>    } <br>    return ERROR_SUCCESS; <br>} <br> <br> <br>DWORD <br>MakeSDAbsolute ( <br>    PSECURITY_DESCRIPTOR OldSD, <br>    PSECURITY_DESCRIPTOR *NewSD <br>    ) <br>{ <br>    PSECURITY_DESCRIPTOR  sd; <br>    DWORD                 descriptorSize; <br>    DWORD                 daclSize; <br>    DWORD                 saclSize; <br>    DWORD                 ownerSIDSize; <br>    DWORD                 groupSIDSize; <br>    PACL                  dacl; <br>    PACL                  sacl; <br>    PSID                  ownerSID; <br>    PSID                  groupSID; <br>    BOOL                  present; <br>    BOOL                  systemDefault; <br> <br>    // <br>    // Get SACL <br>    // <br> <br>    if (!GetSecurityDescriptorSacl (OldSD, &amp;present, &amp;sacl, &amp;systemDefault)) <br>        return GetLastError(); <br> <br>    if (sacl &amp;&amp; present) <br>    { <br>        saclSize = sacl-&gt;AclSize; <br>    } else saclSize = 0; <br> <br>    // <br>    // Get DACL <br>    // <br> <br>    if (!GetSecurityDescriptorDacl (OldSD, &amp;present, &amp;dacl, &amp;systemDefault)) <br>        return GetLastError(); <br> <br>    if (dacl &amp;&amp; present) <br>    { <br>        daclSize = dacl-&gt;AclSize; <br>    } else daclSize = 0; <br> <br>    // <br>    // Get Owner <br>    // <br> <br>    if (!GetSecurityDescriptorOwner (OldSD, &amp;ownerSID, &amp;systemDefault)) <br>        return GetLastError(); <br> <br>    ownerSIDSize = GetLengthSid (ownerSID); <br> <br>    // <br>    // Get Group <br>    // <br> <br>    if (!GetSecurityDescriptorGroup (OldSD, &amp;groupSID, &amp;systemDefault)) <br>        return GetLastError(); <br> <br>    groupSIDSize = GetLengthSid (groupSID); <br> <br>    // <br>    // Do the conversion <br>    // <br> <br>    descriptorSize = 0; <br> <br>    MakeAbsoluteSD (OldSD, sd, &amp;descriptorSize, dacl, &amp;daclSize, sacl, <br>                    &amp;saclSize, ownerSID, &amp;ownerSIDSize, groupSID, <br>                    &amp;groupSIDSize); <br> <br>    sd = (PSECURITY_DESCRIPTOR) new BYTE [SECURITY_DESCRIPTOR_MIN_LENGTH]; <br>    if (!InitializeSecurityDescriptor (sd, SECURITY_DESCRIPTOR_REVISION)) <br>        return GetLastError(); <br> <br>    if (!MakeAbsoluteSD (OldSD, sd, &amp;descriptorSize, dacl, &amp;daclSize, sacl, <br>                         &amp;saclSize, ownerSID, &amp;ownerSIDSize, groupSID, <br>                         &amp;groupSIDSize)) <br>        return GetLastError(); <br> <br>    *NewSD = sd; <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>SetNamedValueSD ( <br>    HKEY RootKey, <br>    LPTSTR KeyName, <br>    LPTSTR ValueName, <br>    SECURITY_DESCRIPTOR *SD <br>    ) <br>{ <br>    DWORD   returnValue; <br>    DWORD   disposition; <br>    HKEY    registryKey; <br> <br>    // <br>    // Create new key or open existing key <br>    // <br> <br>    returnValue = RegCreateKeyEx (RootKey, KeyName, 0, TEXT(""), 0, KEY_ALL_ACCESS, NULL, &amp;registryKey, &amp;disposition); <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    // <br>    // Write the security descriptor <br>    // <br> <br>    returnValue = RegSetValueEx (registryKey, ValueName, 0, REG_BINARY, (LPBYTE) SD, GetSecurityDescriptorLength (SD)); <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    RegCloseKey (registryKey); <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>GetNamedValueSD ( <br>    HKEY RootKey, <br>    LPTSTR KeyName, <br>    LPTSTR ValueName, <br>    SECURITY_DESCRIPTOR **SD, <br>    BOOL *NewSD <br>    ) <br>{ <br>    DWORD               returnValue; <br>    HKEY                registryKey; <br>    DWORD               valueType; <br>    DWORD               valueSize; <br> <br>    *NewSD = FALSE; <br> <br>    // <br>    // Get the security descriptor from the named value. If it doesn't <br>    // exist, create a fresh one. <br>    // <br> <br>    returnValue = RegOpenKeyEx (RootKey, KeyName, 0, KEY_ALL_ACCESS, &amp;registryKey); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>    { <br>        if (returnValue == ERROR_FILE_NOT_FOUND) <br>        { <br>            *SD = NULL; <br>            returnValue = CreateNewSD (SD); <br>            if (returnValue != ERROR_SUCCESS) <br>                return returnValue; <br> <br>            *NewSD = TRUE; <br>            return ERROR_SUCCESS; <br>        } else <br>            return returnValue; <br>    } <br> <br>    returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &amp;valueType, NULL, &amp;valueSize); <br> <br>    if (returnValue &amp;&amp; returnValue != ERROR_INSUFFICIENT_BUFFER) <br>    { <br>        *SD = NULL; <br>        returnValue = CreateNewSD (SD); <br>        if (returnValue != ERROR_SUCCESS) <br>            return returnValue; <br> <br>        *NewSD = TRUE; <br>    } else <br>    { <br>        *SD = (SECURITY_DESCRIPTOR *) malloc (valueSize); <br> <br>        returnValue = RegQueryValueEx (registryKey, ValueName, NULL, &amp;valueType, (LPBYTE) *SD, &amp;valueSize); <br>        if (returnValue) <br>        { <br>            free (*SD); <br> <br>            *SD = NULL; <br>            returnValue = CreateNewSD (SD); <br>            if (returnValue != ERROR_SUCCESS) <br>                return returnValue; <br> <br>            *NewSD = TRUE; <br>        } <br>    } <br> <br>    RegCloseKey (registryKey); <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>ListNamedValueSD ( <br>    HKEY RootKey, <br>    LPTSTR KeyName, <br>    LPTSTR ValueName <br>    ) <br>{ <br>    DWORD               returnValue; <br>    SECURITY_DESCRIPTOR *sd; <br>    BOOL                present; <br>    BOOL                defaultDACL; <br>    PACL                dacl; <br>    BOOL                newSD = FALSE; <br> <br>    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &amp;sd, &amp;newSD); <br> <br>    if ((returnValue != ERROR_SUCCESS) || (newSD == TRUE)) <br>    { <br>        _tprintf (TEXT("&lt;Using Default Permissions&gt;\n")); <br>        free (sd); <br>        return returnValue; <br>    } <br> <br>    if (!GetSecurityDescriptorDacl (sd, &amp;present, &amp;dacl, &amp;defaultDACL)) <br>    { <br>        free (sd); <br>        return GetLastError(); <br>    } <br> <br>    if (!present) <br>    { <br>        _tprintf (TEXT("&lt;Access is denied to everyone&gt;\n")); <br>        free (sd); <br>        return ERROR_SUCCESS; <br>    } <br> <br>    ListACL (dacl); <br> <br>    free (sd); <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>AddPrincipalToNamedValueSD ( <br>    HKEY RootKey, <br>    LPTSTR KeyName, <br>    LPTSTR ValueName, <br>    LPTSTR Principal, <br>    BOOL Permit <br>    ) <br>{ <br>    DWORD               returnValue; <br>    SECURITY_DESCRIPTOR *sd; <br>    SECURITY_DESCRIPTOR *sdSelfRelative; <br>    SECURITY_DESCRIPTOR *sdAbsolute; <br>    DWORD               secDescSize; <br>    BOOL                present; <br>    BOOL                defaultDACL; <br>    PACL                dacl; <br>    BOOL                newSD = FALSE; <br> <br>    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &amp;sd, &amp;newSD); <br> <br>    // <br>    // Get security descriptor from registry or create a new one <br>    // <br> <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    if (!GetSecurityDescriptorDacl (sd, &amp;present, &amp;dacl, &amp;defaultDACL)) <br>        return GetLastError(); <br> <br>    if (newSD) <br>    { <br>        AddAccessAllowedACEToACL (&amp;dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM")); <br>        AddAccessAllowedACEToACL (&amp;dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE")); <br>    } <br> <br>    // <br>    // Add the Principal that the caller wants added <br>    // <br> <br>    if (Permit) <br>        returnValue = AddAccessAllowedACEToACL (&amp;dacl, COM_RIGHTS_EXECUTE, Principal); else <br>        returnValue = AddAccessDeniedACEToACL (&amp;dacl, GENERIC_ALL, Principal); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>    { <br>        free (sd); <br>        return returnValue; <br>    } <br> <br>    // <br>    // Make the security descriptor absolute if it isn't new <br>    // <br> <br>    if (!newSD) <br>        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &amp;sdAbsolute); else <br>        sdAbsolute = sd; <br> <br>    // <br>    // Set the discretionary ACL on the security descriptor <br>    // <br> <br>    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) <br>        return GetLastError(); <br> <br>    // <br>    // Make the security descriptor self-relative so that we can <br>    // store it in the registry <br>    // <br> <br>    secDescSize = 0; <br>    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &amp;secDescSize); <br>    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize); <br>    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &amp;secDescSize)) <br>        return GetLastError(); <br> <br>    // <br>    // Store the security descriptor in the registry <br>    // <br> <br>    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative); <br> <br>    free (sd); <br>    free (sdSelfRelative); <br>    free (sdAbsolute); <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>RemovePrincipalFromNamedValueSD ( <br>    HKEY RootKey, <br>    LPTSTR KeyName, <br>    LPTSTR ValueName, <br>    LPTSTR Principal <br>    ) <br>{ <br>    DWORD               returnValue; <br>    SECURITY_DESCRIPTOR *sd; <br>    SECURITY_DESCRIPTOR *sdSelfRelative; <br>    SECURITY_DESCRIPTOR *sdAbsolute; <br>    DWORD               secDescSize; <br>    BOOL                present; <br>    BOOL                defaultDACL; <br>    PACL                dacl; <br>    BOOL                newSD = FALSE; <br> <br>    returnValue = GetNamedValueSD (RootKey, KeyName, ValueName, &amp;sd, &amp;newSD); <br> <br>    // <br>    // Get security descriptor from registry or create a new one <br>    // <br> <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    if (!GetSecurityDescriptorDacl (sd, &amp;present, &amp;dacl, &amp;defaultDACL)) <br>        return GetLastError(); <br> <br>    // <br>    // If the security descriptor is new, add the required Principals to it <br>    // <br> <br>    if (newSD) <br>    { <br>        AddAccessAllowedACEToACL (&amp;dacl, COM_RIGHTS_EXECUTE, TEXT("SYSTEM")); <br>        AddAccessAllowedACEToACL (&amp;dacl, COM_RIGHTS_EXECUTE, TEXT("INTERACTIVE")); <br>    } <br> <br>    // <br>    // Remove the Principal that the caller wants removed <br>    // <br> <br>    returnValue = RemovePrincipalFromACL (dacl, Principal); <br>    if (returnValue != ERROR_SUCCESS) <br>    { <br>        free (sd); <br>        return returnValue; <br>    } <br> <br>    // <br>    // Make the security descriptor absolute if it isn't new <br>    // <br> <br>    if (!newSD) <br>        MakeSDAbsolute ((PSECURITY_DESCRIPTOR) sd, (PSECURITY_DESCRIPTOR *) &amp;sdAbsolute); else <br>        sdAbsolute = sd; <br> <br>    // <br>    // Set the discretionary ACL on the security descriptor <br>    // <br> <br>    if (!SetSecurityDescriptorDacl (sdAbsolute, TRUE, dacl, FALSE)) <br>        return GetLastError(); <br> <br>    // <br>    // Make the security descriptor self-relative so that we can <br>    // store it in the registry <br>    // <br> <br>    secDescSize = 0; <br>    MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &amp;secDescSize); <br>    sdSelfRelative = (SECURITY_DESCRIPTOR *) malloc (secDescSize); <br>    if (!MakeSelfRelativeSD (sdAbsolute, sdSelfRelative, &amp;secDescSize)) <br>        return GetLastError(); <br> <br>    // <br>    // Store the security descriptor in the registry <br>    // <br> <br>    SetNamedValueSD (RootKey, KeyName, ValueName, sdSelfRelative); <br> <br>    free (sd); <br>    free (sdSelfRelative); <br>    free (sdAbsolute); <br> <br>    return ERROR_SUCCESS; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
