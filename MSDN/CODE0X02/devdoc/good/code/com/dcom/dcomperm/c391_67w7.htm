<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SRVCMGMT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context397"></a>SRVCMGMT.CPP</h2>
<pre><code>/*++ <br> <br>DCOM Permission Configuration Sample <br>Copyright (c) 1996, Microsoft Corporation. All rights reserved. <br> <br>Module Name: <br> <br>    srvcmgmt.cpp <br> <br>Abstract: <br> <br>    Routines to manage RunAs and Service settings for DCOM servers <br> <br>Author: <br> <br>    Michael Nelson <br> <br>Environment: <br> <br>    Windows NT <br> <br>--*/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;tchar.h&gt; <br>#include "ntsecapi.h" <br>#include "dcomperm.h" <br> <br>DWORD GetRunAsPassword ( <br>    LPTSTR AppID, <br>    LPTSTR Password <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES objectAttributes; <br>    HANDLE                policyHandle = NULL; <br>    LSA_UNICODE_STRING    lsaKeyString; <br>    PLSA_UNICODE_STRING   lsaPasswordString; <br>    WCHAR                 key [4 + GUIDSTR_MAX + 1]; <br>    WCHAR                 wideAppID [GUIDSTR_MAX + 1]; <br>    ULONG                 returnValue; <br> <br>#ifndef UNICODE <br>    STR2UNI (wideAppID, AppID); <br>#else <br>    lstrcpy (wideAppID, AppID); <br>#endif <br> <br>    wcscpy (key, L"SCM:"); <br>    wcscat (key, wideAppID); <br> <br>    lsaKeyString.Length = (USHORT) ((wcslen (key) + 1) * sizeof (WCHAR)); <br>    lsaKeyString.MaximumLength = (GUIDSTR_MAX + 5) * sizeof (WCHAR); <br>    lsaKeyString.Buffer = key; <br> <br>    // <br>    // Open the local security policy <br>    // <br> <br>    memset (&amp;objectAttributes, 0x00, sizeof (LSA_OBJECT_ATTRIBUTES)); <br>    objectAttributes.Length = sizeof (LSA_OBJECT_ATTRIBUTES); <br> <br>    returnValue = LsaOpenPolicy (NULL, <br>                                 &amp;objectAttributes, <br>                                 POLICY_GET_PRIVATE_INFORMATION, <br>                                 &amp;policyHandle); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    // <br>    // Read the user's password <br>    // <br> <br>    returnValue = LsaRetrievePrivateData (policyHandle, <br>                                          &amp;lsaKeyString, <br>                                          &amp;lsaPasswordString); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>    { <br>        LsaClose (policyHandle); <br>        return returnValue; <br>    } <br> <br>    LsaClose (policyHandle); <br> <br>#ifndef UNICODE <br>    UNI2STR (Password, lsaPasswordString-&gt;Buffer); <br>#else <br>    wcscpy (Password, lsaPasswordString-&gt;Buffer); <br>#endif <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD SetRunAsPassword ( <br>    LPTSTR AppID, <br>    LPTSTR Principal, <br>    LPTSTR Password <br>    ) <br>{ <br>    LSA_OBJECT_ATTRIBUTES objectAttributes; <br>    HANDLE                policyHandle = NULL; <br>    LSA_UNICODE_STRING    lsaKeyString; <br>    LSA_UNICODE_STRING    lsaPasswordString; <br>    WCHAR                 key [4 + GUIDSTR_MAX + 1]; <br>    WCHAR                 wideAppID [GUIDSTR_MAX + 1]; <br>    WCHAR                 widePassword [256]; <br>    DWORD                 returnValue; <br> <br>#ifndef UNICODE <br>    STR2UNI (wideAppID, AppID); <br>    STR2UNI (widePassword, Password); <br>#else <br>    wcscpy (wideAppID, AppID); <br>    wcscpy (widePassword, Password); <br>#endif <br> <br>    wcscpy (key, L"SCM:"); <br>    wcscat (key, wideAppID); <br> <br>    lsaKeyString.Length = (USHORT) ((wcslen (key) + 1) * sizeof (WCHAR)); <br>    lsaKeyString.MaximumLength = (GUIDSTR_MAX + 5) * sizeof (WCHAR); <br>    lsaKeyString.Buffer = key; <br> <br>    lsaPasswordString.Length = (USHORT) ((wcslen (widePassword) + 1) * sizeof (WCHAR)); <br>    lsaPasswordString.Buffer = widePassword; <br>    lsaPasswordString.MaximumLength = lsaPasswordString.Length; <br> <br>    // <br>    // Open the local security policy <br>    // <br> <br>    memset (&amp;objectAttributes, 0x00, sizeof (LSA_OBJECT_ATTRIBUTES)); <br>    objectAttributes.Length = sizeof (LSA_OBJECT_ATTRIBUTES); <br> <br>    returnValue = LsaOpenPolicy (NULL, <br>                                 &amp;objectAttributes, <br>                                 POLICY_CREATE_SECRET, <br>                                 &amp;policyHandle); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    // <br>    // Store the user's password <br>    // <br> <br>    returnValue = LsaStorePrivateData (policyHandle, <br>                                       &amp;lsaKeyString, <br>                                       &amp;lsaPasswordString); <br> <br>    if (returnValue != ERROR_SUCCESS) <br>    { <br>        LsaClose (policyHandle); <br>        return returnValue; <br>    } <br> <br>    LsaClose (policyHandle); <br> <br>    returnValue = SetAccountRights (Principal, TEXT("SeBatchLogonRight")); <br>    if (returnValue != ERROR_SUCCESS) <br>        return returnValue; <br> <br>    return ERROR_SUCCESS; <br>} <br> <br>DWORD <br>SetAccountRights ( <br>    LPTSTR User, <br>    LPTSTR Privilege <br>    ) <br>{ <br>    LSA_HANDLE            policyHandle; <br>    LSA_OBJECT_ATTRIBUTES objectAttributes; <br>    PSID                  principalSID; <br>    LSA_UNICODE_STRING    lsaPrivilegeString; <br>    WCHAR                 widePrivilege [256]; <br> <br>#ifdef _UNICODE <br>    lstrcpy (widePrivilege, Privilege); <br>#else <br>    STR2UNI (widePrivilege, Privilege); <br>#endif <br> <br>    memset (&amp;objectAttributes, 0, sizeof(LSA_OBJECT_ATTRIBUTES)); <br>    if (LsaOpenPolicy (NULL, <br>                       &amp;objectAttributes, <br>                       POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, <br>                       &amp;policyHandle) != ERROR_SUCCESS) <br>    { <br>        return GetLastError(); <br>    } <br> <br>    GetPrincipalSID (User, &amp;principalSID); <br> <br>    lsaPrivilegeString.Length = (USHORT) (wcslen (widePrivilege) * sizeof (WCHAR)); <br>    lsaPrivilegeString.MaximumLength = (USHORT) (lsaPrivilegeString.Length + sizeof (WCHAR)); <br>    lsaPrivilegeString.Buffer = widePrivilege; <br> <br>    if (LsaAddAccountRights (policyHandle, <br>                             principalSID, <br>                             &amp;lsaPrivilegeString, <br>                             1) != ERROR_SUCCESS) <br>    { <br>        free (principalSID); <br>        LsaClose (policyHandle); <br>        return GetLastError(); <br>    } <br> <br>    free (principalSID); <br>    LsaClose (policyHandle); <br> <br>    return ERROR_SUCCESS; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
