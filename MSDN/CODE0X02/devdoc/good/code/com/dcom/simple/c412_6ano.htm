<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SSERVER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context414"></a>SSERVER.CPP</h2>
<pre><code>// =========================================================================== <br>// File: S S E R V E R . C P P <br>//  <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//  <br>// Description: <br>//  <br>//  This is the server-portion of the SIMPLE Network OLE sample. This <br>// application implements the CLSID_SimpleObject class as a LocalServer. <br>// Instances of this class support a limited form of the IStream interface -- <br>// calls to IStream::Read and IStream::Write will "succeed" (they do nothing), <br>// and calls on any other methods fail with E_NOTIMPL. <br>//  <br>//  The purpose of this sample is to demonstrate what is minimally required <br>// to implement an object that can be used by clients (both those on the same <br>// machine using OLE and those using Network OLE across the network). <br>//  <br>// Instructions: <br>//  <br>//  To use this sample: <br>//   * build it using the NMAKE command. NMAKE will create SSERVER.EXE and <br>//     SCLIENT.EXE. <br>//   * edit the SSERVER.REG file to make the LocalServer32 key point to the <br>//     location of SSERVER.EXE, and run the INSTALL.BAT command (it simply <br>//     performs REGEDIT SSERVER.REG) <br>//   * run SSERVER.EXE. it should display the message "Waiting..." <br>//   * run SCLIENT.EXE on the same machine using no command-line arguments, <br>//     or from another machine using the machine-name (UNC or DNS) as the sole <br>//     command-line argument. it will connect to the server, perform some read <br>//     and write calls, and disconnect. both SSERVER.EXE and SCLIENT.EXE will <br>//     automatically terminate. both applications will display some status text. <br>//   * you can also run SCLIENT.EXE from a different machine without having first <br>//     run SSERVER.EXE on the machine. in this case, SSERVER.EXE will be launched <br>//     by OLE in the background and you will be able to watch the output of <br>//     SCLIENT.EXE but the output of SSERVER.EXE will be hidden. <br>//   * to examine the automatic launch-security features of Network OLE, try <br>//     using the '...\CLSID\{...}\LaunchPermission = Y' key commented out in  <br>//     the SSERVER.REG file and reinstalling it. by setting different read-access <br>//     privileges on this key (using the Security/Permissions... dialog in the <br>//     REGEDT32 registry tool built into the system) you can allow other <br>//     users to run the SCLIENT.EXE program from their accounts. <br>//  <br>// Copyright 1996 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define STRICT <br>#include &lt;stdio.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br> <br>// %%GUIDs: ------------------------------------------------------------------ <br>DEFINE_GUID(CLSID_SimpleObject, 0x5e9ddec7, 0x5767, 0x11cf, 0xbe, 0xab, 0x0, 0xaa, 0x0, 0x6c, 0x36, 0x6); <br> <br>// %%Globals: ---------------------------------------------------------------- <br>HANDLE          hevtDone; <br> <br>// %%Classes: ---------------------------------------------------------------- <br>// simple class-factory: only knows how to create CSimpleObject instances <br>class CClassFactory : public IClassFactory { <br>  public: <br>    // IUnknown <br>    STDMETHODIMP    QueryInterface (REFIID riid, void** ppv); <br>    STDMETHODIMP_(ULONG) AddRef(void)  { return 1; }; <br>    STDMETHODIMP_(ULONG) Release(void) { return 1; } <br> <br>    // IClassFactory <br>    STDMETHODIMP    CreateInstance (LPUNKNOWN punkOuter, REFIID iid, void **ppv); <br>    STDMETHODIMP    LockServer (BOOL fLock) { return E_FAIL; }; <br>    }; <br> <br>// simple object supporting a dummy IStream <br>class CSimpleObject : public IStream { <br>  public: <br>    // IUnknown <br>    STDMETHODIMP    QueryInterface (REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG) AddRef(void)  { return InterlockedIncrement(&amp;m_cRef); }; <br>    STDMETHODIMP_(ULONG) Release(void) { if (InterlockedDecrement(&amp;m_cRef) == 0) { delete this; return 0; } return 1; } <br> <br>    // IStream <br>    STDMETHODIMP    Read(void *pv, ULONG cb, ULONG *pcbRead); <br>    STDMETHODIMP    Write(VOID const *pv, ULONG cb, ULONG *pcbWritten); <br>    STDMETHODIMP    Seek(LARGE_INTEGER dbMove, DWORD dwOrigin, ULARGE_INTEGER *pbNewPosition) <br>        { return E_FAIL; } <br>    STDMETHODIMP    SetSize(ULARGE_INTEGER cbNewSize) <br>        { return E_FAIL; } <br>    STDMETHODIMP    CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten) <br>        { return E_FAIL; } <br>    STDMETHODIMP    Commit(DWORD grfCommitFlags) <br>        { return E_FAIL; } <br>    STDMETHODIMP    Revert(void) <br>        { return E_FAIL; } <br>    STDMETHODIMP    LockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType) <br>        { return E_FAIL; } <br>    STDMETHODIMP    UnlockRegion(ULARGE_INTEGER bOffset, ULARGE_INTEGER cb, DWORD dwLockType) <br>        { return E_FAIL; } <br>    STDMETHODIMP    Stat(STATSTG *pstatstg, DWORD grfStatFlag) <br>        { return E_FAIL; } <br>    STDMETHODIMP    Clone(IStream **ppstm) <br>        { return E_FAIL; } <br> <br>    // constructors/destructors <br>    CSimpleObject()     { m_cRef = 1; } <br>    ~CSimpleObject()    { SetEvent(hevtDone); } <br> <br>  private: <br>    LONG        m_cRef; <br>    }; <br> <br>// %%Globals: ---------------------------------------------------------------- <br>CClassFactory   g_ClassFactory; <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: Message <br>//  <br>//  Formats and displays a message to the console. <br>// --------------------------------------------------------------------------- <br> void <br>Message(LPTSTR szPrefix, HRESULT hr) <br>{ <br>    LPTSTR   szMessage; <br> <br>    if (hr == S_OK) <br>        { <br>        wprintf(szPrefix); <br>        wprintf(TEXT("\n")); <br>        return; <br>        } <br>  <br>    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) <br>        hr = HRESULT_CODE(hr); <br> <br>    FormatMessage( <br>        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>        FORMAT_MESSAGE_FROM_SYSTEM, <br>        NULL, <br>        hr, <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language <br>        (LPTSTR)&amp;szMessage, <br>        0, <br>        NULL ); <br> <br>    wprintf(TEXT("%s: %s(%lx)\n"), szPrefix, szMessage, hr); <br>     <br>    LocalFree(szMessage); <br>}  // Message <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSimpleObject::QueryInterface <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSimpleObject::QueryInterface(REFIID riid, void** ppv) <br>{ <br>    if (ppv == NULL) <br>        return E_INVALIDARG; <br>    if (riid == IID_IUnknown || riid == IID_IStream) <br>        { <br>        *ppv = (IUnknown *) this; <br>        AddRef(); <br>        return S_OK; <br>        } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>}  // CSimpleObject::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSimpleObject::Read <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSimpleObject::Read(void *pv, ULONG cb, ULONG *pcbRead) <br>{ <br>    Message(TEXT("Server: IStream:Read"), S_OK); <br>    if (!pv &amp;&amp; cb != 0) <br>        return E_INVALIDARG; <br> <br>    // fill the buffer with FF's. we could read it from somewhere. <br>    if (cb != 0) <br>        memset(pv, 0xFF, cb); <br> <br>    if (pcbRead) <br>        *pcbRead = cb; <br>    return S_OK; <br>}  // CSimpleObject::Read <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSimpleObject::Write <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSimpleObject::Write(VOID const *pv, ULONG cb, ULONG *pcbWritten) <br>{ <br>    Message(TEXT("Server: IStream:Write"), S_OK); <br>    if (!pv &amp;&amp; cb != 0) <br>        return E_INVALIDARG; <br>    // ignore the data, but we could examine it or put it somewhere <br>    if (pcbWritten) <br>        *pcbWritten = cb; <br>    return S_OK; <br>}  // CSimpleObject::Write <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::QueryInterface <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID riid, void** ppv) <br>{ <br>    if (ppv == NULL) <br>        return E_INVALIDARG; <br>    if (riid == IID_IClassFactory || riid == IID_IUnknown) <br>        { <br>        *ppv = (IClassFactory *) this; <br>        AddRef(); <br>        return S_OK; <br>        } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>}  // CClassFactory::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::CreateInstance <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void** ppv) <br>{ <br>    LPUNKNOWN   punk; <br>    HRESULT     hr; <br> <br>    *ppv = NULL; <br> <br>    if (punkOuter != NULL) <br>        return CLASS_E_NOAGGREGATION; <br> <br>    Message(TEXT("Server: IClassFactory:CreateInstance"), S_OK); <br> <br>    punk = new CSimpleObject; <br> <br>    if (punk == NULL) <br>        return E_OUTOFMEMORY; <br> <br>    hr = punk-&gt;QueryInterface(riid, ppv); <br>    punk-&gt;Release(); <br>    return hr; <br>}  // CClassFactory::CreateInstance <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: main <br>// --------------------------------------------------------------------------- <br> void __cdecl <br>main() <br>{ <br>    HRESULT hr; <br>    DWORD   dwRegister; <br> <br>    // create the thread which is signaled when the instance is deleted <br>    hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL); <br>    if (hevtDone == NULL) <br>        { <br>        hr = HRESULT_FROM_WIN32(GetLastError()); <br>        Message(TEXT("Server: CreateEvent"), hr); <br>        exit(hr); <br>        } <br> <br>    // initialize COM for free-threading <br>    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>    if (FAILED(hr)) <br>        { <br>        Message(TEXT("Server: CoInitializeEx"), hr); <br>        exit(hr); <br>        } <br> <br>    // register the class-object with OLE <br>    hr = CoRegisterClassObject(CLSID_SimpleObject, &amp;g_ClassFactory, <br>        CLSCTX_SERVER, REGCLS_SINGLEUSE, &amp;dwRegister); <br>    if (FAILED(hr)) <br>        { <br>        Message(TEXT("Server: CoRegisterClassObject"), hr); <br>        exit(hr); <br>        } <br> <br>    Message(TEXT("Server: Waiting"), S_OK); <br> <br>    // wait until an object is created and deleted. <br>    WaitForSingleObject(hevtDone, INFINITE); <br> <br>    CloseHandle(hevtDone); <br> <br>    CoUninitialize(); <br>    Message(TEXT("Server: Done"), S_OK); <br>}  // main <br> <br>// EOF ======================================================================= <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
