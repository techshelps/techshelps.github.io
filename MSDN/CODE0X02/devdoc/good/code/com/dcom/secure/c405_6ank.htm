<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECSVR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context410"></a>SECSVR.CPP</h2>
<pre><code>// =========================================================================== <br>// File: S E C S V R . C P P <br>//  <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Description: <br>//  <br>//  This is the server-portion of the SECURE Network OLE sample. This <br>// application implements several different server capabilities: <br>//   * Free-threaded server implemented as a Service. The application <br>//     implements a "LocalService" (CLSID_SecureObjectService) class. <br>//   * Free-threaded server implemented as a standard executable. The <br>//     application implements a "LocalServer32" (CLSID_SecureObject) class <br>//     and runs without user-interface. <br>//   * Apartment-threaded server implemented as a standard executable. The <br>//     application implements a "LocalServer32" (CLSID_SecureObject) class <br>//     and runs with a dialog-box user-interface showing the status of the <br>//     objects that it has handed out to clients. <br>//  <br>//  The purpose of this sample is to demonstrate the different packaging <br>// options available to server writers, and to demonstrate call-security <br>// capabilities. <br>//  <br>// Instructions: <br>//  <br>//  To use this sample: <br>//   * build the samples using the NMAKE command. NMAKE will create SECCLNT.EXE, <br>//     SECSVR.EXE, and PSMYPROP.DLL. PSMYPROP.DLL is the remoting proxies and <br>//     stubs for the custom interface used between the client and the server. <br>//   * install the server on the current machine or on a remote machine <br>//     by running INSTALL.BAT in the same directory with SECSVR.EXE and <br>//     PSMYPROP.DLL. This program registers the proxy-stub DLL using the <br>//     REGSVR32 tool (included in the \mstools\bin directory of the SDK) and <br>//     runs the SECSVR.EXE program with "-AutoRegister" on the command-line, <br>//     which forces it to install itself. <br>//   * to run the apartment-threaded server, use "SECSVR -Interactive" to launch <br>//     the server from the command-line. the application will present UI allowing <br>//     you to choose how to initialize security for the server process, and <br>//     to view objects currently being used by clients. <br>//   * In Section 1, choose the security parameters to CoInitializeSecurity from <br>//     the two drop-down lists, and press the Initialize button. <br>//   * next, run SECCLNT.EXE from the same machine or from a remote machine. Follow <br>//     the instructions listed in SECCLNT.CPP to connect to this instance of the <br>//     SECSVR.EXE application. <br>//   * once a client has created an instance of the CLSID_SecureObject class, the <br>//     object will be listed in the drop-down list in Section 2 of the SECSVR.EXE <br>//     UI. Select the object to be viewed from this list. The current color and <br>//     "name" established by the client will be displayed in Section 2. <br>//   * use the "Lock" button to prevent the client from setting the color or "UserName" <br>//     of the object. the client will display an "access-denied" message if it <br>//     fails to set the color or "UserName". in the future this sample will include <br>//     the ability to establish a security-descriptor on the color and Name, and <br>//     will demonstrate impersonating the client and performing an AccessCheck() <br>//     during the PutColor and PutUserName methods. <br>//   * Push the "Exit" button in Section 1 to shut the server down. <br>//  <br>// Copyright 1996 Microsoft Corporation. All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define STRICT <br>#define UNICODE <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br>#include "myprop.h" <br>#include "secsvr.h" <br> <br>// %%Macros: ----------------------------------------------------------------- <br>#define ENTRY(sz, val)      { sz, val } <br>#define RGSIZEOF(rg)        (sizeof(rg)/sizeof((rg)[0])) <br> <br>// %%Constants: -------------------------------------------------------------- <br>const TCHAR szServiceName[] = TEXT("SecSvr"); <br>const TCHAR szDescription[] = TEXT("Network OLE Security Sample"); <br>#define cAuthnLevelEntries  RGSIZEOF(rgAuthnLevelEntries) <br>#define cImpLevelEntries    RGSIZEOF(rgImpLevelEntries) <br> <br>// %%Types: ------------------------------------------------------------------ <br>typedef struct tagENTRY{ <br>    TCHAR   *szName; <br>    DWORD   dwVal; <br>} ENTRY, *PENTRY; <br> <br>// %%Classes: ---------------------------------------------------------------- <br>class CClassFactory : public IClassFactory <br>    { <br>  // IClassFactory <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return 1; } <br>    STDMETHODIMP_(ULONG)    Release(void)   { return 1; } <br>    STDMETHODIMP            CreateInstance(LPUNKNOWN punkOuter, REFIID iid, LPVOID FAR *ppv); <br>    STDMETHODIMP            LockServer(BOOL fLock); <br>    }; <br> <br>class CSecureObject : public IMyProperties <br>    { <br>  // IUnknown <br>    STDMETHODIMP    QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG) AddRef(void)    { return InterlockedIncrement(&amp;m_cRef); } <br>    STDMETHODIMP_(ULONG) Release(void)   { if (InterlockedDecrement(&amp;m_cRef) == 0) { delete this; return 0; } return 1; } <br> <br>  // IMyProperties <br>    STDMETHODIMP    GetColor(COLORREF* pcr); <br>    STDMETHODIMP    PutColor(COLORREF cr); <br>    STDMETHODIMP    GetUserName(WCHAR szUserName[20]); <br>    STDMETHODIMP    PutUserName(WCHAR szUserName[20]); <br> <br>  // data members <br>    LONG        m_cRef; <br>  public: <br>    COLORREF    m_crColor; <br>    BOOL        m_fDenyPutColor; <br>    WCHAR       m_rgchUserName[20]; <br>    BOOL        m_fDenyPutUserName; <br> <br>  // constructors/destructors <br>    CSecureObject(); <br>    ~CSecureObject(); <br>    }; <br> <br>// %%Prototypes: ------------------------------------------------------------- <br>void    MyServiceMain(DWORD cArg, LPTSTR *rgszArg); <br>void    MyServiceHandler(DWORD dwControl); <br>void    ErrorMessage(HWND hwnd, LPTSTR szFunction, HRESULT hr); <br> <br>// %%Globals: ---------------------------------------------------------------- <br>CClassFactory   s_ClassFactory; <br>struct { <br>    SERVICE_STATUS          Status; <br>    SERVICE_STATUS_HANDLE   hStatus; <br>    DWORD                   dwRegister; <br>    } s_Service; <br>SERVICE_TABLE_ENTRY     s_rgsteServices[2] = { { (TCHAR*)szServiceName, MyServiceMain }, <br>      { NULL, NULL } }; <br>HWND            s_hwndDlg; <br>UINT            s_cInstances; <br>HANDLE          s_hevtDone; <br>CRITICAL_SECTION s_csDone; <br>BOOL            s_fDone, s_fServer, s_fService; <br>ENTRY   rgAuthnLevelEntries[] = { <br>    ENTRY(TEXT("Default    "), RPC_C_AUTHN_DEFAULT), <br>    ENTRY(TEXT("None       "), RPC_C_AUTHN_LEVEL_NONE), <br>    ENTRY(TEXT("Connect    "), RPC_C_AUTHN_LEVEL_CONNECT), <br>    ENTRY(TEXT("Call       "), RPC_C_AUTHN_LEVEL_CALL), <br>    ENTRY(TEXT("Packet     "), RPC_C_AUTHN_LEVEL_PKT), <br>    ENTRY(TEXT("Integrity  "), RPC_C_AUTHN_LEVEL_PKT_INTEGRITY), <br>    ENTRY(TEXT("Privacy    "), RPC_C_AUTHN_LEVEL_PKT_PRIVACY), <br>    }; <br> <br>ENTRY   rgImpLevelEntries[] = { <br>    ENTRY(TEXT("Anonymous  "), RPC_C_IMP_LEVEL_ANONYMOUS), <br>    ENTRY(TEXT("Identify   "), RPC_C_IMP_LEVEL_IDENTIFY), <br>    ENTRY(TEXT("Impersonate"), RPC_C_IMP_LEVEL_IMPERSONATE), <br>    ENTRY(TEXT("Delegate   "), RPC_C_IMP_LEVEL_DELEGATE), <br>    }; <br> <br> <br>// =========================================================================== <br>//                          C C L A S S F A C T O R Y <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::QueryInterface <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    if (iid == IID_IClassFactory || iid == IID_IUnknown) <br>{ <br>*ppv = (IClassFactory *)this; <br>AddRef(); <br>return S_OK; <br>} <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>}  // CClassFactory::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::CreateInstance <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppv) <br>{ <br>    LPUNKNOWN   punk; <br>    HRESULT     hr; <br> <br>    *ppv = NULL; <br> <br>    if (punkOuter != NULL) <br>return CLASS_E_NOAGGREGATION; <br> <br>    if (s_fServer) <br>{ <br>EnterCriticalSection(&amp;s_csDone); <br>if (s_fDone == TRUE) <br>    { <br>    LeaveCriticalSection(&amp;s_csDone); <br>    return E_FAIL; <br>    } <br>LeaveCriticalSection(&amp;s_csDone); <br>} <br> <br>    punk = new CSecureObject; <br>    if (punk == NULL) <br>return E_OUTOFMEMORY; <br> <br>    hr = punk-&gt;QueryInterface(riid, ppv); <br>    punk-&gt;Release(); <br>    return hr; <br>}  // CClassFactory::CreateInstance <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::LockServer <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::LockServer(BOOL fLock) <br>{ <br>    // LockServer not supported by the GUI server -- shutdown is <br>    // completely controlled by the UI's Exit command <br>    if (!s_fServer) <br>return E_FAIL; <br> <br>    // LockServer acts like having an artificial object outstanding: <br>    // this code mimics the lifetime management found in the constructor <br>    // and destructor of CSecureObject <br>    EnterCriticalSection(&amp;s_csDone); <br>    if (fLock) <br>s_cInstances++; <br>    else <br>{ <br>if (!--s_cInstances &amp;&amp; !s_fService) /* could perform other shutdown management here */ <br>    { <br>    s_fDone = TRUE; <br>    SetEvent(s_hevtDone); <br>    } <br>} <br>    LeaveCriticalSection(&amp;s_csDone); <br>    return S_OK; <br>}  // CClassFactory::LockServer <br> <br> <br>// =========================================================================== <br>//                        C S e c u r e O b j e c t <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::CSecureObject <br>// --------------------------------------------------------------------------- <br>CSecureObject::CSecureObject() <br>{ <br>    static int s_ID = 0; <br> <br>    // initialize the object's state <br>    m_cRef = 1; <br>    m_crColor = 0; <br>    m_fDenyPutColor = FALSE; <br>    lstrcpyW(m_rgchUserName, L"Default"); <br>    m_fDenyPutUserName = FALSE; <br> <br>    if (!s_fServer) <br>{ <br>TCHAR   rgchName[20]; <br>HWND    hwnd; <br>int     iPos; <br> <br>// insert the object into the server UI. put our this-pointer into the item <br>// data field of the entry so that we can remove the entry in our destructor <br>wsprintf(rgchName, TEXT("Object %d"), s_ID++); <br>hwnd = GetDlgItem(s_hwndDlg, IDC_OBJECTS); <br>iPos = SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)rgchName); <br>SendMessage(hwnd, CB_SETITEMDATA, iPos, (LPARAM)this); <br>} <br>    else <br>{ <br>EnterCriticalSection(&amp;s_csDone); <br>s_cInstances++; <br>LeaveCriticalSection(&amp;s_csDone); <br>} <br>}  // CSecureObject::CSecureObject <br> <br>CSecureObject::~CSecureObject() <br>{ <br>    if (!s_fServer) <br>{ <br>HWND    hwnd; <br>int     i, iSel, iMac; <br> <br>// remove the reference to us from the server UI. our this-pointer is in <br>// the item-data field of the entry -- find it. <br>hwnd = GetDlgItem(s_hwndDlg, IDC_OBJECTS); <br>iSel = SendMessage(hwnd, CB_GETCURSEL, 0, 0); <br>iMac = SendMessage(hwnd, CB_GETCOUNT, 0, 0); <br>for (i=0; i&lt;iMac; i++) <br>    { <br>    if ((LRESULT)this == SendMessage(hwnd, CB_GETITEMDATA, i, 0)) <br>{ <br>SendMessage(hwnd, CB_DELETESTRING, i, 0); <br> <br>// if the item being deleted is the current selection, <br>// change the selection <br>if (i == iSel) <br>    { <br>    SendMessage(hwnd, CB_SETCURSEL, 0, 0); <br>    PostMessage(s_hwndDlg, WM_COMMAND, MAKELONG(IDC_OBJECTS, CBN_SELCHANGE), <br>(LPARAM)hwnd); <br>    } <br>break; <br>} <br>    } <br>} <br>    else <br>{ <br>EnterCriticalSection(&amp;s_csDone); <br>if (!--s_cInstances &amp;&amp; !s_fService) /* could perform other shutdown management here */ <br>    { <br>    s_fDone = TRUE; <br>    SetEvent(s_hevtDone); <br>    } <br>LeaveCriticalSection(&amp;s_csDone); <br>} <br>}  // CSecureObject::~CSecureObject <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::QueryInterface <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSecureObject::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    if (iid == IID_IMyProperties || iid == IID_IUnknown) <br>{ <br>*ppv = (IMyProperties *)this; <br>AddRef(); <br>return S_OK; <br>} <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>}  // CSecureObject::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::GetColor <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSecureObject::GetColor(COLORREF* pcr) <br>{ <br>    *pcr = m_crColor; <br>    return S_OK; <br>}  // CSecureObject::GetColor <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::PutColor <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSecureObject::PutColor(COLORREF cr) <br>{ <br>    // a naive security check under control of the local-server's UI <br>    if (m_fDenyPutColor == TRUE) <br>return E_ACCESSDENIED; <br> <br>    m_crColor = cr; <br> <br>    // update the UI to reflect a valid PutColor occurred <br>    if (!s_fServer) <br>PostMessage(s_hwndDlg, WM_COMMAND, MAKELONG(IDC_OBJECTS,CBN_SELCHANGE), <br>    (LPARAM)GetDlgItem(s_hwndDlg, IDC_OBJECTS)); <br> <br>    return S_OK; <br>}  // CSecureObject::PutColor <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::GetUserName <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSecureObject::GetUserName(WCHAR szUserName[20]) <br>{ <br>    lstrcpynW(szUserName, m_rgchUserName, 20); <br>    return S_OK; <br>}  // CSecureObject::GetUserName <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CSecureObject::PutUserName <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CSecureObject::PutUserName(WCHAR szUserName[20]) <br>{ <br>    // a naive security check under control of the local-server's UI <br>    if (m_fDenyPutUserName == TRUE) <br>return E_ACCESSDENIED; <br> <br>    lstrcpynW(m_rgchUserName, szUserName, 20); <br> <br>    // update the UI to reflect a valid PutUserName occurred <br>    if (!s_fServer) <br>PostMessage(s_hwndDlg, WM_COMMAND, MAKELONG(IDC_OBJECTS,CBN_SELCHANGE), <br>    (LPARAM)GetDlgItem(s_hwndDlg, IDC_OBJECTS)); <br> <br>    return S_OK; <br>}  // CSecureObject::PutUserName <br> <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: FAutoRegister <br>// --------------------------------------------------------------------------- <br> BOOL <br>FAutoRegister(HINSTANCE hinst) <br>{ <br>    static const TCHAR szCLSIDEntryServer[]     = TEXT("CLSID\\{28f64ee0-4656-11cf-8110-00aa00389b71}"); <br>    static const TCHAR szLocalServer32[]        = TEXT("LocalServer32"); <br>    static const TCHAR szAllowRemoteActivation[] = TEXT("AllowRemoteActivation"); <br>    static const TCHAR szCLSIDEntryService[]    = TEXT("CLSID\\{28f64ee2-4656-11cf-8110-00aa00389b71}"); <br>    static const TCHAR szLocalService[]         = TEXT("LocalService"); <br>    static const TCHAR szServiceParameters[]    = TEXT("ServiceParameters"); <br>    static const TCHAR szParameters[]           = TEXT("-Service"); <br>    static const TCHAR szEmpty[]                = TEXT(""); <br>    SC_HANDLE   hManager = NULL, hService = NULL; <br>    TCHAR       szPath[MAX_PATH], *szError = TEXT("Registry Manipulation"); <br>    HKEY        hkeyT = NULL, hkey2; <br> <br>    // install the CLSID_SecureObject key and get the FQP to this executable <br>    if ((RegSetValue(HKEY_CLASSES_ROOT, szCLSIDEntryServer, REG_SZ, szDescription, <br>    lstrlen(szDescription)) != ERROR_SUCCESS) || <br>(RegCreateKey(HKEY_CLASSES_ROOT, szCLSIDEntryServer, &amp;hkeyT) != ERROR_SUCCESS) || <br>!GetModuleFileName(hinst, szPath, sizeof(szPath)/sizeof(TCHAR))) <br>goto LErrExit; <br> <br>    // install the LocalServer32 key and the AllowRemoteActivation key <br>    if ((RegSetValue(hkeyT, szLocalServer32, REG_SZ, szPath, lstrlen(szPath)) <br>    != ERROR_SUCCESS) || <br>(RegSetValue(hkeyT, szAllowRemoteActivation, REG_SZ, szEmpty, lstrlen(szEmpty)) <br>    != ERROR_SUCCESS)) <br>goto LErrExit; <br>    RegCloseKey(hkeyT); <br>    hkeyT = NULL; <br> <br>    // install the CLSID_SecureObjectService key <br>    if ((RegSetValue(HKEY_CLASSES_ROOT, szCLSIDEntryService, REG_SZ, szDescription, <br>    lstrlen(szDescription)) != ERROR_SUCCESS) || <br>(RegCreateKey(HKEY_CLASSES_ROOT, szCLSIDEntryService, &amp;hkeyT) != ERROR_SUCCESS)) <br>goto LErrExit; <br> <br>    // install the LocalService key and the ServiceParameters named-value <br>    if ((RegSetValue(hkeyT, szLocalService, REG_SZ, szServiceName, lstrlen(szServiceName)) <br>    != ERROR_SUCCESS) || <br>(RegOpenKey(hkeyT, szLocalService, &amp;hkey2) != ERROR_SUCCESS)) <br>goto LErrExit; <br>    RegCloseKey(hkeyT); <br>    hkeyT = hkey2; <br>    if (RegSetValueEx(hkeyT, szServiceParameters, 0, REG_SZ, (const BYTE*)szParameters, <br>    (lstrlen(szParameters)+1) * sizeof(TCHAR)) != ERROR_SUCCESS) <br>goto LErrExit; <br> <br>    RegCloseKey(hkeyT); <br>    hkeyT = NULL; <br> <br>    // install the application to run as a service <br>    hManager = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS); <br>    if (hManager == NULL) <br>{ <br>szError = TEXT("OpenSCManager"); <br>goto LErrExit; <br>} <br> <br>    hService = OpenService(hManager, szServiceName, SERVICE_ALL_ACCESS); <br>    if (hService != NULL) <br>{ <br>if (!ChangeServiceConfig(hService, <br>    SERVICE_WIN32_OWN_PROCESS, <br>    SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, szPath, <br>    NULL, NULL, NULL, NULL, NULL, szDescription)) <br>    { <br>    szError = TEXT("ChangeServiceConfig"); <br>    goto LErrExit; <br>    } <br>return TRUE; <br>} <br> <br>    hService = CreateService(hManager, szServiceName, szDescription, <br>SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS, <br>SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL, szPath, <br>NULL, NULL, NULL,  NULL, NULL); <br>    if (hService == NULL) <br>{ <br>szError = TEXT("CreateService"); <br>goto LErrExit; <br>} <br> <br>    CloseServiceHandle(hService); <br>    CloseServiceHandle(hManager); <br>    return TRUE; <br> <br>LErrExit: <br>    ErrorMessage(GetDesktopWindow(), szError, GetLastError()); <br>    if (hkeyT != NULL) <br>RegCloseKey(hkeyT); <br>    if (hService != NULL) <br>CloseServiceHandle(hService); <br>    if (hManager != NULL) <br>CloseServiceHandle(hManager); <br>    return FALSE; <br>}  // FAutoRegister <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ErrorMessage <br>// --------------------------------------------------------------------------- <br> void <br>ErrorMessage(HWND hwnd, LPTSTR szFunction, HRESULT hr) <br>{ <br>    LPTSTR   szMessage; <br> <br>    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) <br>hr = HRESULT_CODE(hr); <br> <br>    if (!FormatMessage( <br>FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, hr, <br>MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language <br>(LPTSTR)&amp;szMessage, 0, NULL)) <br>return; <br> <br>    if (hwnd == NULL) <br>{ <br>OutputDebugString(szFunction); <br>OutputDebugString(TEXT(": ")); <br>OutputDebugString(szMessage); <br>OutputDebugString(TEXT("\n")); <br>} <br>    else <br>MessageBox(hwnd, szMessage, szFunction, MB_OK); <br>     <br>    LocalFree(szMessage); <br>}  // ErrorMessage <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: SelectEntry <br>// --------------------------------------------------------------------------- <br> void <br>SelectEntry(HWND hwnd, ENTRY* rgEntries, int cEntries, DWORD dwVal) <br>{ <br>    for (int i=0; i&lt;cEntries; i++) <br>{ <br>if (rgEntries[i].dwVal == dwVal) <br>    { <br>    SendMessage(hwnd, CB_SETCURSEL, i, 0); <br>    return; <br>    } <br>} <br>}  // SelectEntry <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: GetField <br>// --------------------------------------------------------------------------- <br> DWORD <br>GetField(HWND hwndDlg, UINT idItem) <br>{ <br>    HWND    hwnd; <br>    int     iCur; <br> <br>    hwnd = GetDlgItem(hwndDlg, idItem); <br>    iCur = SendMessage(hwnd, CB_GETCURSEL, 0, 0); <br>    return SendMessage(hwnd, CB_GETITEMDATA, iCur, 0); <br>}  // GetField <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ServerDialogProc <br>// --------------------------------------------------------------------------- <br> BOOL CALLBACK <br>ServerDialogProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static DWORD    s_dwRegister = 0; <br>    static BOOL     s_fInitialized = FALSE; <br>    static CSecureObject* s_pcso = NULL; <br>    static COLORREF s_rgcrCustom[16]; <br>    static HBRUSH   s_hbrCurrent = NULL; <br>    HRESULT hr; <br> <br>    switch (message) <br>{ <br>case WM_INITDIALOG: <br>    { <br>    HWND    hwnd; <br>    int     cxScreen, cyScreen, i; <br>    RECT    rcDlg; <br> <br>    // save the hwndDlg into a global <br>    s_hwndDlg = hwndDlg; <br> <br>    // Center the UI on screen <br>    cxScreen = GetSystemMetrics(SM_CXFULLSCREEN); <br>    cyScreen = GetSystemMetrics(SM_CYFULLSCREEN); <br>    GetWindowRect(hwndDlg, &amp;rcDlg); <br>    OffsetRect(&amp;rcDlg, <br>(cxScreen - rcDlg.right - rcDlg.left)/2, <br>(cyScreen - rcDlg.bottom - rcDlg.top)/2); <br>    MoveWindow(hwndDlg, rcDlg.left, rcDlg.top, <br>rcDlg.right-rcDlg.left, rcDlg.bottom-rcDlg.top, TRUE); <br> <br>    // build the lists of authentication levels. choose None for the <br>    // process default. <br>    hwnd = GetDlgItem(hwndDlg, IDC_SERVER_AUTHNLEVEL); <br>    for (i=0; i&lt;cAuthnLevelEntries; i++) <br>{ <br>SendMessage(hwnd, CB_INSERTSTRING, i, (LPARAM)rgAuthnLevelEntries[i].szName); <br>SendMessage(hwnd, CB_SETITEMDATA, i, rgAuthnLevelEntries[i].dwVal); <br>} <br>    SelectEntry(hwnd, rgAuthnLevelEntries, cAuthnLevelEntries, RPC_C_AUTHN_LEVEL_NONE); <br> <br>    // build the lists of impersonation levels. choose Anonymous for the <br>    // process default. <br>    hwnd = GetDlgItem(hwndDlg, IDC_SERVER_IMPLEVEL); <br>    for (i=0; i&lt;cImpLevelEntries; i++) <br>{ <br>SendMessage(hwnd, CB_INSERTSTRING, i, (LPARAM)rgImpLevelEntries[i].szName); <br>SendMessage(hwnd, CB_SETITEMDATA, i, rgImpLevelEntries[i].dwVal); <br>} <br>    SelectEntry(hwnd, rgImpLevelEntries, cImpLevelEntries, RPC_C_IMP_LEVEL_ANONYMOUS); <br>    return 1; <br>    } <br> <br>case WM_SYSCOMMAND: <br>    if (wParam == SC_CLOSE) <br>goto LClose; <br>    break; <br> <br>case WM_COMMAND: <br>    switch (LOWORD(wParam)) <br>{ <br>case IDCANCEL: <br>LClose: <br>    if (s_hbrCurrent != NULL) <br>{ <br>DeleteObject(s_hbrCurrent); <br>s_hbrCurrent = NULL; <br>} <br>    if (s_dwRegister != 0) <br>{ <br>CoRevokeClassObject(s_dwRegister); <br>s_dwRegister = 0; <br>} <br>    if (s_fInitialized == TRUE) <br>{ <br>CoUninitialize(); <br>s_fInitialized = FALSE; <br>} <br>    EndDialog(hwndDlg, 0); <br>    break; <br> <br>case IDC_INITIALIZE: <br>    // initialize as apartment-threaded to synchronize the UI <br>    // with calls to the objects <br>    hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); <br>    if (FAILED(hr)) <br>{ <br>ErrorMessage(hwndDlg, TEXT("CoInitialize"), hr); <br>break; <br>} <br> <br>                    // initialize security layer with our choices <br>    hr = CoInitializeSecurity(NULL, <br>                        -1, <br>                        NULL, <br>                        NULL, <br>GetField(hwndDlg, IDC_SERVER_AUTHNLEVEL), <br>GetField(hwndDlg, IDC_SERVER_IMPLEVEL), <br>                        NULL, <br>                        0, <br>NULL); <br>    if (FAILED(hr)) <br>{ <br>ErrorMessage(hwndDlg, TEXT("CoInitializeSecurity"), hr); <br>break; <br>} <br> <br>    hr = CoRegisterClassObject(CLSID_SecureObject, &amp;s_ClassFactory,  <br>CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &amp;s_dwRegister); <br>    if (FAILED(hr)) <br>{ <br>ErrorMessage(hwndDlg, TEXT("CoRegisterClassObject"), hr); <br>CoUninitialize(); <br>break; <br>} <br>     <br>    // Disable Initialization Step (#1) <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_INITIALIZE), FALSE); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_SERVER_AUTHNLEVEL), FALSE); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_SERVER_IMPLEVEL), FALSE); <br> <br>    // Enable Object Viewing Steps (#2) <br>    // (choosing a valid object in the list box will enable the <br>    //  other controls) <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_OBJECTS), TRUE); <br> <br>    s_fInitialized = TRUE; <br>    break; <br> <br>case IDC_OBJECTS: <br>    { <br>    int     iCur; <br> <br>    if (HIWORD(wParam) != CBN_SELCHANGE) <br>break; <br> <br>    // a different object was chosen, or a property has changed. <br>    // retrieve the object's pointer from the item-data of the <br>    // current list-box item and update the UI. <br>    iCur = SendMessage(GetDlgItem(hwndDlg, IDC_OBJECTS), <br>CB_GETCURSEL, 0, 0); <br>    if (iCur == CB_ERR) <br>s_pcso = NULL; <br>    else <br>{ <br>s_pcso = (CSecureObject*)SendMessage(GetDlgItem(hwndDlg, IDC_OBJECTS), <br>    CB_GETITEMDATA, iCur, 0); <br>if (s_pcso == (LPVOID)CB_ERR) <br>    s_pcso = NULL; <br>} <br> <br>    if (s_hbrCurrent != NULL) <br>{ <br>DeleteObject(s_hbrCurrent); <br>s_hbrCurrent = NULL; <br>} <br>    SetWindowText(GetDlgItem(hwndDlg, IDC_USERNAME), TEXT("")); <br>    InvalidateRect(GetDlgItem(hwndDlg, IDC_CHOOSECOLOR), NULL, TRUE); <br>    InvalidateRect(GetDlgItem(hwndDlg, IDC_COLOR), NULL, TRUE); <br>    InvalidateRect(GetDlgItem(hwndDlg, IDC_USERNAME), NULL, TRUE); <br>    InvalidateRect(GetDlgItem(hwndDlg, IDC_NOPUTCOLOR), NULL, TRUE); <br>    InvalidateRect(GetDlgItem(hwndDlg, IDC_NOPUTUSERNAME), NULL, TRUE); <br> <br>    if (s_pcso != NULL) <br>{ <br>SetWindowTextW(GetDlgItem(hwndDlg, IDC_USERNAME), s_pcso-&gt;m_rgchUserName); <br>s_hbrCurrent = CreateSolidBrush(s_pcso-&gt;m_crColor); <br>} <br> <br>    // enable/disable the object-specific windows <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSECOLOR), s_pcso != NULL); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_COLOR), s_pcso != NULL); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_USERNAME), s_pcso != NULL); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_NOPUTCOLOR), s_pcso != NULL); <br>    EnableWindow(GetDlgItem(hwndDlg, IDC_NOPUTUSERNAME), s_pcso != NULL); <br>    break; <br>    } <br> <br>case IDC_NOPUTCOLOR: <br>    s_pcso-&gt;m_fDenyPutColor = SendMessage( <br>GetDlgItem(hwndDlg, IDC_NOPUTCOLOR), BM_GETCHECK, 0, 0); <br>    break; <br> <br>case IDC_NOPUTUSERNAME: <br>    s_pcso-&gt;m_fDenyPutUserName = SendMessage( <br>GetDlgItem(hwndDlg, IDC_NOPUTUSERNAME), BM_GETCHECK, 0, 0); <br>    break; <br> <br>case IDC_CHOOSECOLOR: <br>    { <br>    CHOOSECOLOR cc; <br> <br>    cc.lStructSize = sizeof(CHOOSECOLOR); <br>    cc.hwndOwner = hwndDlg; <br>    cc.rgbResult = s_pcso-&gt;m_crColor; <br>    cc.lpCustColors = s_rgcrCustom; <br>    cc.Flags = CC_RGBINIT | CC_SHOWHELP; <br> <br>    if (ChooseColor(&amp;cc)) <br>{ <br>s_pcso-&gt;m_crColor = cc.rgbResult; <br>if (s_hbrCurrent != NULL) <br>    DeleteObject(s_hbrCurrent); <br>s_hbrCurrent = CreateSolidBrush(cc.rgbResult); <br>InvalidateRect((HWND)lParam, NULL, TRUE); <br>} <br>    break; <br>    } <br> <br>case IDC_USERNAME: <br>    { <br>    static s_fDirty = FALSE; <br> <br>    if (HIWORD(wParam) == EN_CHANGE) <br>{ <br>s_fDirty = TRUE; <br>} <br>    else if (HIWORD(wParam) == EN_KILLFOCUS &amp;&amp; s_fDirty) <br>{ <br>GetWindowTextW(GetDlgItem(hwndDlg, IDC_USERNAME), <br>    s_pcso-&gt;m_rgchUserName, 20); <br>s_fDirty = FALSE; <br>} <br>    break; <br>    } <br>} <br>    break; <br> <br>case WM_DRAWITEM: <br>    { <br>    LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam; <br> <br>    FillRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, <br>s_hbrCurrent != NULL ? s_hbrCurrent : (HBRUSH)GetStockObject(WHITE_BRUSH)); <br>    FrameRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, (HBRUSH)GetStockObject(BLACK_BRUSH)); <br>    if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>InvertRect(lpdis-&gt;hDC, (LPRECT)&amp;lpdis-&gt;rcItem); <br>    if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>DrawFocusRect(lpdis-&gt;hDC, (LPRECT) &amp;lpdis-&gt;rcItem); <br>    return TRUE; <br>    } <br>} <br>    return FALSE; <br>}  // ServerDialogProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: MyServiceMain <br>// --------------------------------------------------------------------------- <br> void <br>MyServiceMain(DWORD dwArgc, LPTSTR *pszArgv) <br>{ <br>    HRESULT hr; <br>  <br>    s_Service.Status.dwServiceType        = SERVICE_WIN32_OWN_PROCESS; <br>    s_Service.Status.dwCurrentState       = SERVICE_START_PENDING; <br>    s_Service.Status.dwControlsAccepted   = SERVICE_ACCEPT_STOP; <br>    s_Service.Status.dwWin32ExitCode      = 0; <br>    s_Service.Status.dwServiceSpecificExitCode = 0; <br>    s_Service.Status.dwCheckPoint         = 0; <br>    s_Service.Status.dwWaitHint           = 0; <br> <br>    s_Service.hStatus = RegisterServiceCtrlHandler(szServiceName, MyServiceHandler); <br> <br>    if (s_Service.hStatus == NULL) <br>return; <br> <br>    // used to gaurd the s_fDone variable that prevents new instances <br>    // from being created in IClassFactory::CreateInstance during shutdown <br>    InitializeCriticalSection(&amp;s_csDone); <br> <br>    // event used to signal the service has stopped <br>    s_hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL); <br>    if (s_hevtDone == NULL) <br>{ <br>ErrorMessage(NULL, TEXT("CreateEvent"), GetLastError()); <br>goto LErrExit; <br>} <br> <br>    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>    if (FAILED(hr)) </code></pre>
<p>
</p>
<pre><code>{ <br>ErrorMessage(NULL, TEXT("CoInitialize"), hr); <br>goto LErrExit; <br>} <br> <br>    // the Service CLSID is used here, different from the LocalServer case <br>    hr = CoRegisterClassObject(CLSID_SecureObjectService, &amp;s_ClassFactory,  <br>CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &amp;s_Service.dwRegister); <br> <br>    if (FAILED(hr)) <br>{ <br>ErrorMessage(NULL, TEXT("CoRegisterClassObject"), hr); <br>CoUninitialize(); <br>goto LErrExit; <br>} <br> <br>    // Initialization complete - report running status  <br>    s_Service.Status.dwCurrentState       = SERVICE_RUNNING;  <br>    s_Service.Status.dwCheckPoint         = 0;  <br>    s_Service.Status.dwWaitHint           = 0;  <br> <br>    // notify the service-manager that the service is running <br>    if (!SetServiceStatus(s_Service.hStatus, &amp;s_Service.Status)) <br>ErrorMessage(NULL, TEXT("SetServiceStatus(SERVICE_RUNNING)"), GetLastError()); <br> <br>    // wait for the signal from MyServiceHandler:SERVICE_CONTROL_STOP <br>    WaitForSingleObject(s_hevtDone, INFINITE); <br> <br>    CloseHandle(s_hevtDone); <br>    s_hevtDone = NULL; <br> <br>    CoRevokeClassObject(s_Service.dwRegister); <br>    CoUninitialize(); <br> <br>    // notify the service-manager that the service has totally stopped <br>    s_Service.Status.dwCurrentState = SERVICE_STOPPED; <br>    if (!SetServiceStatus(s_Service.hStatus, &amp;s_Service.Status)) <br>ErrorMessage(NULL, TEXT("SetServiceStatus(SERVICE_STOPPED)"), GetLastError()); <br>    return; <br> <br>LErrExit: <br>    if (s_hevtDone != NULL) <br>{ <br>CloseHandle(s_hevtDone); <br>s_hevtDone = NULL; <br>} <br>    s_Service.Status.dwCurrentState       = SERVICE_STOPPED; <br>    s_Service.Status.dwCheckPoint         = 0; <br>    s_Service.Status.dwWaitHint           = 0; <br>    s_Service.Status.dwWin32ExitCode      = hr; <br>    s_Service.Status.dwServiceSpecificExitCode = hr; <br>    SetServiceStatus(s_Service.hStatus, &amp;s_Service.Status);  <br>    return; <br>}  // MyServiceMain <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: MyServiceHandler <br>// --------------------------------------------------------------------------- <br> void <br>MyServiceHandler(DWORD dwControl) <br>{ <br>    switch (dwControl) <br>{ <br>case SERVICE_CONTROL_STOP: <br>    s_Service.Status.dwWin32ExitCode = 0; <br>    s_Service.Status.dwCurrentState  = SERVICE_STOP_PENDING; <br>    s_Service.Status.dwCheckPoint    = 0; <br>    s_Service.Status.dwWaitHint      = 0; <br>    if (!SetServiceStatus (s_Service.hStatus, &amp;s_Service.Status)) <br>ErrorMessage(NULL, TEXT("SetServiceStatus"), GetLastError()); <br> <br>    EnterCriticalSection(&amp;s_csDone); <br> <br>    // prevent further instances from being created in IClassFactory::CreateInstance <br>    s_fDone = TRUE; <br> <br>    // restart the waiting MyServiceMain thread and allow it to uninitialize and exit. <br>    SetEvent(s_hevtDone); <br> <br>    LeaveCriticalSection(&amp;s_csDone); <br>    return; <br> <br>case SERVICE_CONTROL_INTERROGATE: <br>    // fall out and send the current status of s_Service.Status <br>    break; <br> <br>default: <br>    break; <br>} <br>  <br>    // send current status. <br>    if (!SetServiceStatus(s_Service.hStatus,  &amp;s_Service.Status)) <br>ErrorMessage(NULL, TEXT("SetServiceStatus"), GetLastError()); <br> <br>    return;  <br>}  // MyServiceHandler <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: WinMain <br>// --------------------------------------------------------------------------- <br> int WINAPI <br>WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR szCmdLine, int nCmdShow) <br>{ <br>    HRESULT hr; <br> <br>    // DebugBreak(); <br> <br>    // parse the command-line <br>    if (szCmdLine) <br>{ <br>char    *sz = strtok(szCmdLine, " \t"); <br>if (sz) <br>    { <br>    if (!strcmpi(sz, "-Embedding")) <br>s_fServer = TRUE; <br> <br>    // Auto-register, display success or failure, and exit <br>    else if (!strcmpi(sz, "-AutoRegister")) <br>{ <br>if (FAutoRegister(hInstance)) <br>    MessageBox(GetDesktopWindow(), <br>TEXT("Registered Successfully!"), <br>szDescription, <br>MB_OK); <br>return S_OK; <br>} <br> <br>    // any other argument besides interactive causes help to be displayed <br>    else if (strcmpi(sz, "-Interactive")) <br>{ <br>// MessageBox some help here <br>} <br>    } <br>else <br>    { <br>    s_fService = TRUE; <br>    s_fServer = TRUE; <br>    } <br>} <br> <br>    // when launched without command-line args, run as a service, without any UI <br>    // and running multi-threaded <br>    if (s_fService) <br>return StartServiceCtrlDispatcher(s_rgsteServices) ? 0 : GetLastError(); <br> <br>    // when launched with -Embedding, come up <br>    // without any UI and run multi-threaded <br>    else if (s_fServer) <br>{ <br>DWORD   dwRegister; <br> <br>InitializeCriticalSection(&amp;s_csDone); <br> <br>s_hevtDone = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if (s_hevtDone == NULL) <br>    return HRESULT_FROM_WIN32(GetLastError()); <br> <br>hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>if (FAILED(hr)) <br>    return hr; <br> <br>hr = CoRegisterClassObject(CLSID_SecureObject, &amp;s_ClassFactory,  <br>    CLSCTX_SERVER, REGCLS_MULTIPLEUSE, &amp;dwRegister); <br>if (FAILED(hr)) <br>    goto LServerExit; <br> <br>// wait for all open connections to the server to go away <br>WaitForSingleObject(s_hevtDone, INFINITE); <br> <br>// Destroy the event handle <br>CloseHandle(s_hevtDone); <br>s_hevtDone = NULL; <br> <br>// destroy the critsec used to determine when we're done <br>DeleteCriticalSection(&amp;s_csDone); <br> <br>CoRevokeClassObject(dwRegister); <br> <br>LServerExit: <br>CoUninitialize(); <br>return hr; <br>} <br> <br>    // when launched with -Interactive, run with UI. <br>    // this allows the user to adjust the exact security parameters of the <br>    // process and to monitor individual client objects. in this case, we will <br>    // eventually initialize COM (once the user selects security parameters <br>    // and hits the Initialize button) to use the apartment model in order <br>    // to synchronize calls with our UI. <br>    DialogBox(hInstance, MAKEINTRESOURCE(IDD_SECSVR), GetDesktopWindow(), <br>(DLGPROC)ServerDialogProc); <br> <br>    return 0; <br>} // WinMain <br> <br>// EOF ======================================================================= <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
