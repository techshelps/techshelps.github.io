<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SECCLNT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context408"></a>SECCLNT.CPP</h2>
<pre><code>// =========================================================================== <br>// File: S E C C L N T . C P P <br>//  <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Description: <br>//  <br>//  This is the client-portion of the SECURE Network OLE sample. This <br>// application displays UI to allow you to select security settings for <br>// the client process's connections to the server, connect to local or remote <br>// instances of either the "LocalServer32" (CLSID_SecureObject) or "LocalService" <br>// (CLSID_SecureObjectService) objects. <br>//  <br>//  The purpose of this sample is to demonstrate client-side security <br>// capabilities. <br>//  <br>// Instructions: <br>//  <br>//  To use this sample: <br>//   * build the samples using the NMAKE command. NMAKE will create SECCLNT.EXE, <br>//     SECSVR.EXE, and PSMYPROP.DLL. PSMYPROP.DLL is the remoting proxies and <br>//     stubs for the custom interface used between the client and the server. <br>//   * install the server on the current machine or on a remote machine <br>//     by running INSTALL.BAT in the same directory with SECSVR.EXE and <br>//     PSMYPROP.DLL. This program registers the proxy-stub DLL using the <br>//     REGSVR32 tool (included in the \mstools\bin directory of the SDK) and <br>//     runs the SECSVR.EXE program with "-AutoRegister" on the command-line, <br>//     which forces it to install itself. <br>//   * next, run SECCLNT.EXE. it will bring up a user interface with 3 different <br>//     sections. <br>//   * In Section 1, choose the security parameters to CoInitializeSecurity from <br>//     the two drop-down lists, and press the Initialize button. <br>//   * Next, in Section 2, choose a machine name to instantiate the object on <br>//     (leave this field blank to use the current machine) and choose between the <br>//     "LocalService" or the standard "LocalServer32" implementation of the object. <br>//     Then, press the "Create Now" button to create an instance. <br>//   * With some security settings, you will receive a message box at this point <br>//     telling you that the connection to the object has no authentication. In this <br>//     case, the call-level security choices in Section 3 will not be made available. <br>//   * Next, go to Section 3 and set the color and the "Name" on the object. <br>//     These UI elements make calls on the custom IMyProperties interface. If you <br>//     have pre-launched SECSVR.EXE with the "-Interactive" flag on the local or <br>//     remote machine that you are connected to, you will be able to see the <br>//     changes you make to the color and the name reflected in its UI, and may <br>//     adjust some simple security settings (see the Instructions section of <br>//     SECSVR.CPP for details). <br>//   * Push the "Release" button in Section 2 to release the object and connect to <br>//     a different object. When you are done, close the dialog box or push the <br>//     "Exit" button in Section 1 at any time to exit. <br>//  <br>// Copyright 1996 Microsoft Corporation. All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define UNICODE <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br>#include "myprop.h" <br>#include &lt;rpcdce.h&gt; <br>#include "secclnt.h" <br> <br>// %%Macros: ----------------------------------------------------------------- <br>#define ENTRY(sz, val)      { sz, val } <br>#define RGSIZEOF(rg)        (sizeof(rg)/sizeof((rg)[0])) <br> <br>// %%Constants: -------------------------------------------------------------- <br>#define cServerEntries      RGSIZEOF(rgServerEntries) <br>#define cAuthnLevelEntries  RGSIZEOF(rgAuthnLevelEntries) <br>#define cAuthzEntries       RGSIZEOF(rgAuthzEntries) <br>#define cImpLevelEntries    RGSIZEOF(rgImpLevelEntries) <br>#define cAuthnEntries       RGSIZEOF(rgAuthnEntries) <br> <br>// %%Types: ------------------------------------------------------------------ <br>typedef struct tagENTRY{ <br>    TCHAR   *szName; <br>    DWORD   dwVal; <br>} ENTRY, *PENTRY; <br> <br>// %%Globals: ---------------------------------------------------------------- <br>COLORREF s_crCurrent; <br>HBRUSH   s_hbrCurrent = NULL; <br> <br>ENTRY   rgServerEntries[] = { <br>    ENTRY(TEXT("Secure Object"), (DWORD)(LPVOID)&amp;CLSID_SecureObject), <br>    ENTRY(TEXT("Secure Object Service"), (DWORD)(LPVOID)&amp;CLSID_SecureObjectService), <br>    }; <br> <br>ENTRY   rgAuthnLevelEntries[] = { <br>    ENTRY(TEXT("Default    "), RPC_C_AUTHN_DEFAULT), <br>    ENTRY(TEXT("None       "), RPC_C_AUTHN_LEVEL_NONE), <br>    ENTRY(TEXT("Connect    "), RPC_C_AUTHN_LEVEL_CONNECT), <br>    ENTRY(TEXT("Call       "), RPC_C_AUTHN_LEVEL_CALL), <br>    ENTRY(TEXT("Packet     "), RPC_C_AUTHN_LEVEL_PKT), <br>    ENTRY(TEXT("Integrity  "), RPC_C_AUTHN_LEVEL_PKT_INTEGRITY), <br>    ENTRY(TEXT("Privacy    "), RPC_C_AUTHN_LEVEL_PKT_PRIVACY), <br>    }; <br>ENTRY   rgAuthzEntries[] = { <br>    ENTRY(TEXT("None       "), RPC_C_AUTHZ_NONE), <br>    ENTRY(TEXT("Name       "), RPC_C_AUTHZ_NAME), <br>    ENTRY(TEXT("DCE        "), RPC_C_AUTHZ_DCE), <br>    }; <br> <br>ENTRY   rgImpLevelEntries[] = { <br>    ENTRY(TEXT("Anonymous  "), RPC_C_IMP_LEVEL_ANONYMOUS), <br>    ENTRY(TEXT("Identify   "), RPC_C_IMP_LEVEL_IDENTIFY), <br>    ENTRY(TEXT("Impersonate"), RPC_C_IMP_LEVEL_IMPERSONATE), <br>    ENTRY(TEXT("Delegate   "), RPC_C_IMP_LEVEL_DELEGATE), <br>    }; <br> <br>ENTRY   rgAuthnEntries[] = { <br>    ENTRY(TEXT("None       "), RPC_C_AUTHN_NONE), <br>    ENTRY(TEXT("DCE Private"), RPC_C_AUTHN_DCE_PRIVATE), <br>    ENTRY(TEXT("DCE Public "), RPC_C_AUTHN_DCE_PUBLIC), <br>    ENTRY(TEXT("DEC Public "), RPC_C_AUTHN_DEC_PUBLIC), <br>    ENTRY(TEXT("Windows NT "), RPC_C_AUTHN_WINNT), <br>    ENTRY(TEXT("Default    "), RPC_C_AUTHN_DEFAULT), <br>    }; <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ErrorMessage <br>// --------------------------------------------------------------------------- <br> void <br>ErrorMessage(HWND hwnd, LPTSTR szFunction, HRESULT hr) <br>{ <br>    LPTSTR   szMessage; <br> <br>    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) <br>        hr = HRESULT_CODE(hr); <br>  <br>    FormatMessage( <br>        FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>        FORMAT_MESSAGE_FROM_SYSTEM, <br>        NULL, <br>        hr, <br>        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language <br>        (LPTSTR)&amp;szMessage, <br>        0, <br>        NULL ); <br> <br>    MessageBox(hwnd, szMessage, szFunction, MB_OK); <br>     <br>    LocalFree(szMessage); <br>}  // ErrorMessage <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: SelectEntry <br>// --------------------------------------------------------------------------- <br> void <br>SelectEntry(HWND hwnd, ENTRY* rgEntries, int cEntries, DWORD dwVal) <br>{ <br>    for (int i=0; i&lt;cEntries; i++) <br>        { <br>        if (rgEntries[i].dwVal == dwVal) <br>            { <br>            SendMessage(hwnd, CB_SETCURSEL, i, 0); <br>            return; <br>            } <br>        } <br>}  // SelectEntry <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: GetField <br>// --------------------------------------------------------------------------- <br> DWORD <br>GetField(HWND hwndDlg, UINT idItem) <br>{ <br>    HWND    hwnd; <br>    int     iCur; <br> <br>    hwnd = GetDlgItem(hwndDlg, idItem); <br>    iCur = SendMessage(hwnd, CB_GETCURSEL, 0, 0); <br>    return SendMessage(hwnd, CB_GETITEMDATA, iCur, 0); <br>}  // GetField <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: UpdateSecurityFields <br>// --------------------------------------------------------------------------- <br> void <br>UpdateSecurityFields(HWND hwndDlg, LPUNKNOWN punk, BOOL fSet) <br>{ <br>    HWND    hwnd; <br>    DWORD   dwAuthn, dwAuthz, dwAuthnLevel, dwImpLevel; <br>    LPOLESTR wszPrinciple; <br>    HRESULT hr; <br> <br>    // in response to a CBN_SELCHANGE, we try to set the new proxy <br>    // security parameters first <br>    if (fSet) <br>        { <br>        hr = CoSetProxyBlanket(punk, <br>            GetField(hwndDlg, IDC_PROXY_AUTHN), <br>            GetField(hwndDlg, IDC_PROXY_AUTHZ), <br>            NULL, <br>            GetField(hwndDlg, IDC_PROXY_AUTHNLEVEL), <br>            GetField(hwndDlg, IDC_PROXY_IMPLEVEL), <br>            NULL, <br>            NULL); <br>        if (FAILED(hr)) <br>            { <br>            ErrorMessage(hwndDlg, TEXT("CoSetProxyBlanket"), hr); <br>            } <br>        } <br> <br>    // in all cases, update the fields to reflect the actual state of <br>    // security on the proxy <br>    hr = CoQueryProxyBlanket(punk, <br>        &amp;dwAuthn, &amp;dwAuthz, &amp;wszPrinciple, &amp;dwAuthnLevel, &amp;dwImpLevel, <br>        NULL, NULL); <br>    if (FAILED(hr)) <br>        { <br>        ErrorMessage(hwndDlg, TEXT("CoQueryProxyBlanket"), hr); <br>        } <br>    else <br>        { <br>        hwnd = GetDlgItem(hwndDlg, IDC_PROXY_AUTHN); <br>        EnableWindow(hwnd, TRUE); <br>        SelectEntry(hwnd, rgAuthnEntries, cAuthnEntries, dwAuthn); <br> <br>        hwnd = GetDlgItem(hwndDlg, IDC_PROXY_AUTHZ); <br>        EnableWindow(hwnd, TRUE); <br>        SelectEntry(hwnd, rgAuthzEntries, cAuthzEntries, dwAuthz); <br> <br>        hwnd = GetDlgItem(hwndDlg, IDC_PROXY_AUTHNLEVEL); <br>        EnableWindow(hwnd, TRUE); <br>        SelectEntry(hwnd, rgAuthnLevelEntries, cAuthnLevelEntries, dwAuthnLevel); <br> <br>        hwnd = GetDlgItem(hwndDlg, IDC_PROXY_IMPLEVEL); <br>        EnableWindow(hwnd, TRUE); <br>        SelectEntry(hwnd, rgImpLevelEntries, cImpLevelEntries, dwImpLevel); <br> <br>        SetWindowTextW(GetDlgItem(hwndDlg, IDC_PROXY_PRINCIPLENAME), <br>            wszPrinciple); <br>        } <br>}  // UpdateSecurityFields <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: UpdatePropertyFields <br>// --------------------------------------------------------------------------- <br> void <br>UpdatePropertyFields(HWND hwndDlg, LPMYPROPERTIES pmp) <br>{ <br>    COLORREF    cr; <br>    WCHAR       rgchUserName[20]; <br>    HRESULT     hr; <br> <br>    hr = pmp-&gt;GetColor(&amp;cr); <br>    if (FAILED(hr)) <br>        { <br>        ErrorMessage(hwndDlg, TEXT("Get Color"), hr); <br>        } <br>    else <br>        { <br>        s_crCurrent = cr; <br>        if (s_hbrCurrent != NULL) <br>            DeleteObject(s_hbrCurrent); <br>        s_hbrCurrent = CreateSolidBrush(s_crCurrent); <br>        InvalidateRect(GetDlgItem(hwndDlg, IDC_COLOR), NULL, TRUE); <br>        } <br> <br>    hr = pmp-&gt;GetUserName(rgchUserName); <br>    if (FAILED(hr)) <br>        { <br>        ErrorMessage(hwndDlg, TEXT("Get User Name"), hr); <br>        } <br>    else <br>        { <br>        SetWindowTextW(GetDlgItem(hwndDlg, IDC_USERNAME), rgchUserName); <br>        } <br>}  // UpdatePropertyFields <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ClientDialogProc <br>// --------------------------------------------------------------------------- <br> BOOL CALLBACK <br>ClientDialogProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    static BOOL s_fInitialized = FALSE; <br>    static LPMYPROPERTIES s_pmp = NULL; <br>    static COLORREF s_rgcrCustom[16]; <br>    HRESULT     hr; <br> <br>    switch (message) <br>        { <br>        case WM_INITDIALOG: <br>            { <br>            HWND    hwnd1, hwnd2; <br>            int     i, cxScreen, cyScreen; <br>            RECT    rcDlg; <br> <br>            cxScreen = GetSystemMetrics(SM_CXFULLSCREEN); <br>            cyScreen = GetSystemMetrics(SM_CYFULLSCREEN); <br> <br>            GetWindowRect(hwndDlg, &amp;rcDlg); <br>            OffsetRect(&amp;rcDlg, <br>                (cxScreen - rcDlg.right - rcDlg.left)/2, <br>                (cyScreen - rcDlg.bottom - rcDlg.top)/2); <br> <br>            MoveWindow(hwndDlg, rcDlg.left, rcDlg.top, <br>                rcDlg.right-rcDlg.left, rcDlg.bottom-rcDlg.top, TRUE); <br> <br>            // build the list of servers, select the Remote Server by default <br>            hwnd1 = GetDlgItem(hwndDlg, IDC_SERVER_CLASS); <br>            for (i=0; i&lt;cServerEntries; i++) <br>                { <br>                SendMessage(hwnd1, CB_INSERTSTRING, i, (LPARAM)rgServerEntries[i].szName); <br>                SendMessage(hwnd1, CB_SETITEMDATA, i, rgServerEntries[i].dwVal); <br>                } <br>            SendMessage(hwnd1, CB_SETCURSEL, 0, 0); <br> <br>            // build the lists of authentication levels. choose None for the <br>            // process default. the proxy setting will be retrieved via CoQueryProxyBlanket <br>            // once the object is instantiated <br>            hwnd1 = GetDlgItem(hwndDlg, IDC_CLIENT_AUTHNLEVEL); <br>            hwnd2 = GetDlgItem(hwndDlg, IDC_PROXY_AUTHNLEVEL); <br>            for (i=0; i&lt;cAuthnLevelEntries; i++) <br>                { <br>                SendMessage(hwnd1, CB_INSERTSTRING, i, (LPARAM)rgAuthnLevelEntries[i].szName); <br>                SendMessage(hwnd1, CB_SETITEMDATA, i, rgAuthnLevelEntries[i].dwVal); <br>                SendMessage(hwnd2, CB_INSERTSTRING, i, (LPARAM)rgAuthnLevelEntries[i].szName); <br>                SendMessage(hwnd2, CB_SETITEMDATA, i, rgAuthnLevelEntries[i].dwVal); <br>                } <br>            SelectEntry(hwnd1, rgAuthnLevelEntries, cAuthnLevelEntries, RPC_C_AUTHN_LEVEL_NONE); <br> <br>            // build the lists of impersonation levels. choose Anonymous for the <br>            // process default. the proxy setting will be retrieved via CoQueryProxyBlanket <br>            // once the object is instantiated <br>            hwnd1 = GetDlgItem(hwndDlg, IDC_CLIENT_IMPLEVEL); <br>            hwnd2 = GetDlgItem(hwndDlg, IDC_PROXY_IMPLEVEL); <br>            for (i=0; i&lt;cImpLevelEntries; i++) <br>                { <br>                SendMessage(hwnd1, CB_INSERTSTRING, i, (LPARAM)rgImpLevelEntries[i].szName); <br>                SendMessage(hwnd1, CB_SETITEMDATA, i, rgImpLevelEntries[i].dwVal); <br>                SendMessage(hwnd2, CB_INSERTSTRING, i, (LPARAM)rgImpLevelEntries[i].szName); <br>                SendMessage(hwnd2, CB_SETITEMDATA, i, rgImpLevelEntries[i].dwVal); <br>                } <br>            SelectEntry(hwnd1, rgImpLevelEntries, cImpLevelEntries, RPC_C_IMP_LEVEL_ANONYMOUS); <br> <br>            // build the list of authorization services. the actual setting will <br>            // be retrieved via CoQueryProxyBlanket once the object is instantiated, <br>            // and can be modified after that. <br>            hwnd1 = GetDlgItem(hwndDlg, IDC_PROXY_AUTHZ); <br>            for (i=0; i&lt;cAuthzEntries; i++) <br>                { <br>                SendMessage(hwnd1, CB_INSERTSTRING, i, (LPARAM)rgAuthzEntries[i].szName); <br>                SendMessage(hwnd1, CB_SETITEMDATA, i, rgAuthzEntries[i].dwVal); <br>                } <br> <br>            // build the list of authentication services. the actual setting will <br>            // be retrieved via CoQueryProxyBlanket once the object is instantiated, <br>            // and can be modified after that. <br>            hwnd1 = GetDlgItem(hwndDlg, IDC_PROXY_AUTHN); <br>            for (i=0; i&lt;cAuthnEntries; i++) <br>                { <br>                SendMessage(hwnd1, CB_INSERTSTRING, i, (LPARAM)rgAuthnEntries[i].szName); <br>                SendMessage(hwnd1, CB_SETITEMDATA, i, rgAuthnEntries[i].dwVal); <br>                } <br>            return 1; <br>            } <br> <br>        case WM_SYSCOMMAND: <br>            if (wParam == SC_CLOSE) <br>                goto LClose; <br>            break; <br> <br>        case WM_COMMAND: <br>            if (HIWORD(wParam) == CBN_SELCHANGE &amp;&amp; s_pmp != NULL) <br>                { <br>                UpdateSecurityFields(hwndDlg, s_pmp, TRUE); <br>                } <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDCANCEL: <br>LClose: <br>                    if (s_pmp != NULL) <br>                        { <br>                        s_pmp-&gt;Release(); <br>                        s_pmp = NULL; <br>                        } <br>                    if (s_fInitialized == TRUE) <br>                        { <br>                        CoUninitialize(); <br>                        s_fInitialized = FALSE; <br>                        } <br>                    if (s_hbrCurrent != NULL) <br>                        { <br>                        DeleteObject(s_hbrCurrent); <br>                        s_hbrCurrent = NULL; <br>                        } <br>                    EndDialog(hwndDlg, 0); <br>                    break; <br> <br>                case IDC_INITIALIZE: <br>                    hr = CoInitialize(NULL); <br>                    if (FAILED(hr)) <br>                        { <br>                        ErrorMessage(hwndDlg, TEXT("CoInitialize"), hr); <br>                        } <br>                    else <br>                        { <br>                        hr = CoInitializeSecurity(NULL, <br>                            -1, <br>                            NULL, <br>                            NULL, <br>                            GetField(hwndDlg, IDC_CLIENT_AUTHNLEVEL), <br>                            GetField(hwndDlg, IDC_CLIENT_IMPLEVEL), <br>                            NULL, <br>                            0, <br>                            NULL); <br>                        if (FAILED(hr)) <br>                            { <br>                            ErrorMessage(hwndDlg, TEXT("CoInitializeSecurity"), hr); <br>                            } <br>                        else <br>                            { <br>                            // Disable Initialization Step (#1) <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_INITIALIZE), FALSE); <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_CLIENT_AUTHNLEVEL), FALSE); <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_CLIENT_IMPLEVEL), FALSE); <br> <br>                            // Enable Object Creation Step (#2) <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_SERVER_CLASS), TRUE); <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_MACHINENAME), TRUE); <br>                            EnableWindow(GetDlgItem(hwndDlg, IDC_CREATE), TRUE); <br>                            s_fInitialized = TRUE; <br>                            } <br>                        } <br>                    break; <br>                         <br>                case IDC_CREATE: <br>                    { <br>                    OLECHAR rgchName[MAX_PATH]; <br>                    LPCLASSFACTORY  pcf; <br>                    COSERVERINFO    csi, *pcsi; <br>                    CLSID   *pclsid; <br>                    HWND    hwnd; <br>                    int     iCur; <br> <br>                    // retrieve the class to instantiate <br>                    hwnd = GetDlgItem(hwndDlg, IDC_SERVER_CLASS); <br>                    iCur = SendMessage(hwnd, CB_GETCURSEL, 0, 0); <br>                    pclsid = (LPCLSID)SendMessage(hwnd, CB_GETITEMDATA, iCur, 0); <br> <br>                    // retrieve the machine name to run the server on. if this <br>                    // is blank or ".", instantiate locally by passing a NULL ComServerInfo <br>                    memset(&amp;csi, 0, sizeof(COSERVERINFO)); <br>                    csi.pwszName = rgchName; <br>                    GetWindowTextW(GetDlgItem(hwndDlg, IDC_MACHINENAME), <br>                        rgchName, RGSIZEOF(rgchName)); <br>                    if (lstrlenW(rgchName) == 0 || lstrcmpiW(rgchName, L".") == 0) <br>                        pcsi = NULL; <br>                    else <br>                        pcsi = &amp;csi; <br> <br>                    // create the object <br>                    hr = CoGetClassObject(*pclsid, CLSCTX_SERVER, <br>                        pcsi, IID_IClassFactory, (void**)&amp;pcf); <br>                    if (FAILED(hr)) <br>                        { <br>                        ErrorMessage(hwndDlg, TEXT("CoGetClassObject"), hr); <br>                        break; <br>                        } <br>                    hr = pcf-&gt;CreateInstance(NULL, IID_IMyProperties, (void**)&amp;s_pmp); <br>                    pcf-&gt;Release(); <br>                    if (FAILED(hr)) <br>                        { <br>                        ErrorMessage(hwndDlg, TEXT("IClassFactory::CreateInstance"), hr); <br>                        break; <br>                        } <br> <br>                    // Allow a different instance to get created only if the Release <br>                    // button is pushed first <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_CREATE), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_SERVER_CLASS), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_MACHINENAME), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_RELEASE), TRUE); <br> <br>                    // Enable manipulation of the object's properties. Allow <br>                    // this even if the values of the object's call-security <br>                    // parameters can not be determined, due to errors in <br>                    // UpdateSecurityFields <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSECOLOR), TRUE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_USERNAME), TRUE); <br> <br>                    UpdateSecurityFields(hwndDlg, s_pmp, FALSE); <br>                    UpdatePropertyFields(hwndDlg, s_pmp); <br>                    break; <br>                    } <br> <br>                case IDC_RELEASE: <br>                    s_pmp-&gt;Release(); <br>                    s_pmp = NULL; <br> <br>                    // Disable manipulating the properties and selecting the call <br>                    // security parameters <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSECOLOR), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_USERNAME), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_PROXY_AUTHN), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_PROXY_AUTHN), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_PROXY_AUTHNLEVEL), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_PROXY_IMPLEVEL), FALSE); <br> <br>                    // Enable a new object to be created <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_RELEASE), FALSE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_CREATE), TRUE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_SERVER_CLASS), TRUE); <br>                    EnableWindow(GetDlgItem(hwndDlg, IDC_MACHINENAME), TRUE); <br>                    break; <br> <br>                case IDC_CHOOSECOLOR: <br>                    { <br>                    CHOOSECOLOR cc; <br> <br>                    cc.lStructSize = sizeof(CHOOSECOLOR); <br>                    cc.hwndOwner = hwndDlg; <br>                    cc.rgbResult = s_crCurrent; <br>                    cc.lpCustColors = s_rgcrCustom; <br>                    cc.Flags = CC_RGBINIT | CC_SHOWHELP; <br> <br>                    if (ChooseColor(&amp;cc)) <br>                        { <br>                        hr = s_pmp-&gt;PutColor(cc.rgbResult); <br>                        if (FAILED(hr)) <br>                            { <br>                            ErrorMessage(hwndDlg, TEXT("Put Color"), hr); <br>                            } <br>                        else <br>                            { <br>                            UpdatePropertyFields(hwndDlg, s_pmp); <br>                            } <br>                        } <br>                    break; <br>                    } <br> <br>                case IDC_USERNAME: <br>                    { <br>                    static s_fDirty = FALSE; <br> <br>                    if (HIWORD(wParam) == EN_CHANGE) <br>                        { <br>                        s_fDirty = TRUE; <br>                        } <br>                    else if (HIWORD(wParam) == EN_KILLFOCUS &amp;&amp; s_fDirty) <br>                        { <br>                        WCHAR   rgchUserName[20]; <br> <br>                        GetWindowTextW(GetDlgItem(hwndDlg, IDC_USERNAME), rgchUserName, 20); <br>                        hr = s_pmp-&gt;PutUserName(rgchUserName); <br>                        if (FAILED(hr)) <br>                            ErrorMessage(hwndDlg, TEXT("Put User Name"), hr); <br>                        UpdatePropertyFields(hwndDlg, s_pmp); <br>                        s_fDirty = FALSE; <br>                        } <br>                    break; <br>                    } <br>                } <br>            break; <br> <br>        case WM_DRAWITEM: <br>            { <br>            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT)lParam; <br> <br>            FillRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, <br>                s_hbrCurrent != NULL ? s_hbrCurrent : (HBRUSH)GetStockObject(WHITE_BRUSH)); <br>            FrameRect(lpdis-&gt;hDC, &amp;lpdis-&gt;rcItem, (HBRUSH)GetStockObject(BLACK_BRUSH)); <br>            if (lpdis-&gt;itemState &amp; ODS_SELECTED) <br>                InvertRect(lpdis-&gt;hDC, (LPRECT)&amp;lpdis-&gt;rcItem); <br>            if (lpdis-&gt;itemState &amp; ODS_FOCUS) <br>                DrawFocusRect(lpdis-&gt;hDC, (LPRECT) &amp;lpdis-&gt;rcItem); <br>            return TRUE; <br>            } <br>        } <br>    return FALSE; <br>}  // ClientDialogProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: WinMain <br>// --------------------------------------------------------------------------- <br> int WINAPI <br>WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, int nCmdShow) <br>{ <br>    return DialogBox(hInstance, MAKEINTRESOURCE(IDD_SECCLNT), GetDesktopWindow(), (DLGPROC)ClientDialogProc); <br>}  // WinMain <br> <br>// EOF ======================================================================= <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
