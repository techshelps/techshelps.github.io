<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COMPERF.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context390"></a>COMPERF.CPP</h2>
<pre><code>// =========================================================================== <br>// File: C O M P E R F . C P P <br>#define PURPOSE "This is the reference performance sample for COM/DCOM run on local\n\ <br>and remote machines. This program is both a client and a server.\n\ <br>It launches as a client by default, registering its executable as a\n\ <br>server with COM and creating other instances of itself on a remote and\n\ <br>local machine to be servers. A single command-line argument is allowed\n\ <br>for a remote server name. Performance numbers in calls/sec are output\n\ <br>in tabular form. Tests COM and IDispatch method calls with two security\n\ <br>levels: default/min and full. Use DCOMCNFG to set default security to \n\ <br>Authn Lvl to NONE for best comparison. Parameter sizes are varied to see\n\ <br>effect on security levels(~4/50/4k bytes). Uses psoleperf.dll MIDL generated\n\ <br>proxy/stub implementation. Put pscomperf.dll in same dir as this exe on\n\ <br>all machines. Run exe on each machine to automatically register class code\n\ <br>and proxy/stub dll. You can then run on either machine and pass a remote\n\ <br>machine name (DNS or IP address) as single cmd-line parameter.\n\n"  <br> <br>// Instructions: <br>// Install on one or more machines as described above. Run on command-line as "comperf". <br>// A single command-line argument is allowed for a remote server name. E.g. <br>// "comperf MyComputer" or "comperf 123.44.44.234" using IP address. <br>// This sample may be compiled as UNICODE or ANSI <br>//  <br>// Copyright 1996 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br> <br>// %%Includes: --------------------------------------------------------------- <br>#define INC_OLE2 <br>#define STRICT <br>#define LOOPS 2000  // default number of test function calls <br>#include &lt;windows.h&gt; <br>#include &lt;initguid.h&gt; <br>#include &lt;tchar.h&gt; <br>#include &lt;stdio.h&gt; <br>#include "psperf.h" // MIDL generated header <br> <br>// %%Constants: -------------------------------------------------------------- <br>#define cServerThreads  3 // number support threads each server will generate <br>#define dispidICOMPerformance_Test1  11 <br>#define dispidICOMPerformance_Test23  12 <br>#define szTitleServer   TEXT("SERVER: COM Performance Sample") <br>#define szTitleClient   TEXT("COM Performance Sample") <br>const LARGE_INTEGER     bZero = {0,0}; <br> <br>// %%IDispatch support <br>PARAMDATA paramdata[2] = {{L"i", VT_I4},{L"bstr", VT_BSTR}};  <br>METHODDATA methoddata[2] = {{L"Test1", &amp;paramdata[0], 11, 3, CC_CDECL, 1, DISPATCH_METHOD, VT_I4}, <br>{L"Test23", &amp;paramdata[1], 12, 4, CC_CDECL, 1, DISPATCH_METHOD, VT_I4}}; <br>INTERFACEDATA interfacedata = { methoddata, 2 }; <br> <br>// %%Guids: ------------------------------------------------------------------ <br>// {DDC68870-E08E-11cf-A535-00AA00615B03} <br>DEFINE_GUID(CLSID_CTestCOMPerformance,0xddc68870,0xe08e,0x11cf,0xa5,0x35,0x0,0xaa,0x0,0x61,0x5b,0x3); <br> <br>// %%typedefs: -------------------------------------------------------------- <br>typedef HRESULT (WINAPI *LPFNREG)(); <br>typedef struct  perf  <br>{ <br>    TCHAR   *szTest; <br>    float    sec[3]; // time for all three methods in ICOMPerformance <br>} PERF; <br> <br>// %%Globals: ---------------------------------------------------------------- <br>BOOL        vfServer = FALSE;               // is this instance a server or client? <br>BOOL        vfRemote = FALSE;               // is there a remote server? <br>HANDLE      vrghThread[cServerThreads];     // worker thread handles <br>DWORD       vrgtid[cServerThreads];         // worker thread id's <br>HANDLE      vrghEvent[cServerThreads];      // creation event for each worker <br>HANDLE          vhEventCliDone; <br>HANDLE      vhEventServer;                  // creation-complete event for class-factory <br>HANDLE          vhEventCliStart; <br>HANDLE          hKillSvr;                       // shuts down the server   <br>UINT        viNextThread;                   // next worker to create an object on <br>UINT            g_cObjectCount = 0; <br>LPSTREAM    vpstmMarshalling;               // scratch stream used for cross-apt marshalling <br>HRESULT     vhrThreadStatus;                // signals status to class-factory <br> <br>LPWSTR pszDesc1 = L"String is passed to Test methd of ICOMPerformance"; <br> <br>PERF    vrgperfloc[] = { <br>    { TEXT("COM FreeToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDisp FreeToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("COM FreeTo Free"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDispFreeToFree"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("COM AptToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDispAptToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { NULL, {-1.0f,-1.0f,-1.0f}} }; <br> <br>PERF    vrgperfrmt[] = { <br>    { TEXT("COM FreeToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDisp FreeToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("COM FreeTo Free"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDispFreeToFree"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("COM AptToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { TEXT("IDispAptToApt"), {-1.0f,-1.0f,-1.0f}}, <br>    { NULL, {-1.0f,-1.0f,-1.0f}} };          <br> <br>// %%Prototypes: ------------------------------------------------------------- <br>LRESULT     ServerThreadProc(LPARAM lParam); <br>LRESULT     ClientThreadProc(LPARAM lParam); <br>BOOL        FAutoRegister(); <br>void            Message(LPTSTR szPrefix, HRESULT hr); <br>void            FPrintResults(void); <br>BOOL        AptFreeCOMTest(int cLoops); <br>BOOL            AptFreeAutoTest(int cLoops); <br>BOOL            FreeFreeCOMTest(int cLoops); <br>BOOL            FreeFreeAutoTest(int cLoops); <br>BOOL            DoTests(void); <br>void            Usage(void); <br> <br>typedef IClientSecurity *LPCLIENTSECURITY; <br>typedef ICOMPerformance *LPCOMPERFORMANCE; <br>LPCOMPERFORMANCE pCOMApt, pCOMFree, pCOMAptRmt, pCOMFreeRmt;  <br>LPDISPATCH pAutoApt, pAutoFree, pAutoAptRmt, pAutoFreeRmt;  <br> <br>// %%Classes: ---------------------------------------------------------------- <br>// the class-factory object exists in the main application apartment/thread <br>// and is used to create instances of the worker objects on worker threads. <br>class CClassFactory : public IClassFactory <br>{ <br>public:   <br>// IClassFactory <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)  { return m_cRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void) { if (--m_cRef == 0){ delete this; return 0; } return m_cRef;} <br>    STDMETHODIMP            CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv); <br>    STDMETHODIMP            LockServer(BOOL fLock); <br>     <br>    CClassFactory() { m_cRef = 1; } <br>private: <br>ULONG   m_cRef; <br>}; <br> <br>// this worker object is simple: it simply supports IUnknown. more interesting <br>// interfaces can be readily added here and implemented for the worker. <br>class CTestCOMPerformance : public ICOMPerformance , public IDispatch <br>{ <br>public: <br>// IUnknown <br>    STDMETHODIMP            QueryInterface(REFIID iid, void **ppv); <br>    STDMETHODIMP_(ULONG)    AddRef(void)    { return m_cRef++; } <br>    STDMETHODIMP_(ULONG)    Release(void); <br> <br>// ICOMPerformance <br>STDMETHODIMP                    Test1(int l); <br>    STDMETHODIMP                        Test23(BSTR szDesc); <br> <br>// IDispatch <br>STDMETHODIMP  GetTypeInfoCount(unsigned int  *pcti); <br>    STDMETHODIMP  GetTypeInfo(unsigned int iti, LCID lcid, LPTYPEINFO  *ppti); <br>    STDMETHODIMP  GetIDsOfNames(REFIID riid, WCHAR  *  *rgszNames, unsigned int cNames, LCID lcid, DISPID  *pdispid); <br>    STDMETHODIMP  Invoke(DISPID dispidMember, REFIID riid, LCID lcid, unsigned short wFlags, <br> DISPPARAMS  *pdispparams, VARIANT  *pvarResult, EXCEPINFO  *pexcepinfo, unsigned int  *puArgErr); <br> <br>    CTestCOMPerformance() { m_cRef = 1;} <br>private: <br>    ULONG   m_cRef; <br>}; <br> <br>class CTIMER  <br>{ <br>  public: <br>    inline CTIMER()              { memset(this, 0, sizeof(*this)); } <br>    inline void Start()  { QueryPerformanceCounter(&amp;m_sStart); } <br>    inline void Stop()   { QueryPerformanceCounter(&amp;m_sStop); } <br>inline float OutputTime()       { QueryPerformanceFrequency(&amp;m_liFreq);  <br>return (float)(( m_sStop.LowPart - m_sStart.LowPart)/(float)m_liFreq.LowPart);} <br>    // data members <br>    LARGE_INTEGER   m_sStart, m_sStop, m_liFreq; <br>}; <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: Message <br>//  <br>//  Formats and displays a message to the console. <br>// --------------------------------------------------------------------------- <br> void <br>Message(LPTSTR szPrefix, HRESULT hr) <br>{ <br>    LPTSTR   szMessage; <br> <br>    if (hr == S_OK) <br>    { <br>_tprintf(szPrefix); <br>_tprintf(TEXT("\n")); <br>return; <br>    } <br>  <br>    if (HRESULT_FACILITY(hr) == FACILITY_WINDOWS) <br>hr = HRESULT_CODE(hr); <br>  <br>    FormatMessage( <br>FORMAT_MESSAGE_ALLOCATE_BUFFER | <br>FORMAT_MESSAGE_FROM_SYSTEM, <br>NULL, <br>hr, <br>MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), //The user default language <br>(LPTSTR)&amp;szMessage, <br>0, <br>NULL ); <br> <br>_tprintf(TEXT("%s: %s(%lx)\n"), szPrefix, szMessage, hr); <br>    LocalFree(szMessage); <br>}  // Message <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: main  <br>// --------------------------------------------------------------------------- <br> int __cdecl <br>main(int argc, CHAR **argv) <br>{ <br>    HRESULT hr; <br>    int     i; <br>    DWORD   dwRegister = 0; <br>    COSERVERINFO csi, *pcsi=NULL; <br>    WCHAR wsz [MAX_PATH]; <br>CClassFactory   *pcf = NULL; <br>LPCLASSFACTORY pcflocal = NULL; <br>LPCLASSFACTORY pcfrmt = NULL; <br>LPCLIENTSECURITY pclntsec = NULL;  <br>TCHAR    rgch[32];       <br> <br>DWORD AuthnSvc, AuthzSvc, AuthnLvl, ImpLvl, Capabilities; <br> <br> <br>if(!FAutoRegister()) <br>{ <br>exit(-1); <br>} <br>// parse command-line <br>    if (argc &gt; 1) <br>    { <br>// either started as server or passing in server name <br>MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, argv[1], -1, <br>    wsz, MAX_PATH); <br> <br>// register the CTestCOMPerformance class in the registry so <br>// that the client can create instances of the server <br>if((!lstrcmpW(L"-?", wsz)) || (!lstrcmpW(L"/?", wsz))) <br>{ <br>Usage(); <br>return 0; <br>} <br>if(!lstrcmpW(L"-Embedding", wsz)) <br>vfServer = TRUE; <br>else <br>{ <br>// allow a machine-name as the command-line argument <br>csi.dwReserved1 = 0; <br>csi.pAuthInfo = NULL; <br>csi.dwReserved2 = 0; <br>csi.pwszName = wsz; <br>pcsi = &amp;csi; <br>vfRemote = TRUE; <br>} <br>    } <br>if(vfServer) <br>Message(szTitleServer, S_OK); <br>else <br>Message(szTitleClient, S_OK); <br> <br>    // initialize COM <br>    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>    if (FAILED(hr)) <br>    { <br>Message(TEXT("CoInitializeEx"), hr); <br>exit(hr); <br>    } <br> <br>// create an IStream to be used for marshalling interfaces <br>    hr = CreateStreamOnHGlobal(NULL, TRUE, &amp;vpstmMarshalling); <br>    if (FAILED(hr)) <br>{ <br>Message(TEXT("CreateStreamOnHGlobal"), hr); <br>goto LCleanup; <br>} <br> <br>    if (vfServer) <br>    { <br>// create the threads and synchronization events <br>// which the server will need <br>for (i=0; i&lt;cServerThreads; i++) <br>{ <br>    // create the thread suspended so its event can be <br>    // created using its thread-id and it will be able to <br>    // use it as soon as it runs <br>    vrghThread[i] = CreateThread(NULL, <br>0, <br>(LPTHREAD_START_ROUTINE)&amp;ServerThreadProc, <br>0, <br>CREATE_SUSPENDED, <br>&amp;vrgtid[i]); <br>    if (vrghThread[i] == NULL) <br>{ <br>hr = GetLastError(); <br>goto LCleanup; <br>} <br> <br>    // this event signals to a worker thread to create a new CTestCOMPerformance <br>    wsprintf(rgch, TEXT("Thread_%d"), vrgtid[i]); <br>    vrghEvent[i] = CreateEvent(NULL, FALSE, FALSE, rgch); <br>    if (vrghEvent[i] == NULL) <br>    { <br>hr = GetLastError(); <br>goto LCleanup; <br>    } <br>    // now that the event is available, let the thread run <br>    ResumeThread(vrghThread[i]); <br>} <br>hKillSvr = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if (hKillSvr == NULL) <br>    { <br>    hr = GetLastError(); <br>    goto LCleanup; <br> } <br> <br>// this signals the status of a worker threads creation after <br>// receiving its create signal via vrghEvent[i] <br>vhEventServer = CreateEvent(NULL, FALSE, FALSE, TEXT("Server")); <br>if (vhEventServer == NULL) <br>{ <br>    hr = GetLastError(); <br>    goto LCleanup; <br>} <br>pcf = new CClassFactory; <br>if(pcf == NULL) <br>{ <br>    hr = E_OUTOFMEMORY; <br>    goto LCleanup; <br>} <br> <br>// register the class-factory with COM <br>hr = CoRegisterClassObject(CLSID_CTestCOMPerformance, <br>    (IUnknown *)pcf, <br>    CLSCTX_LOCAL_SERVER, <br>    REGCLS_MULTIPLEUSE, <br>    &amp;dwRegister); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("CoRegisterClassObject"), hr); <br>    goto LCleanup; <br>} <br> <br>Message(TEXT("Server waiting"), S_OK); <br>WaitForSingleObject(hKillSvr, INFINITE); <br>Sleep(7000); // allow time for last Release call processing <br> delete pcf; <br>pcf = NULL; <br>} <br> <br>    else // client case  <br>    { <br>pCOMApt = pCOMFree = pCOMAptRmt =pCOMFreeRmt = NULL;  <br>pAutoFree = pAutoFree = pAutoAptRmt = pAutoFreeRmt = NULL;  <br> <br>// get local class factory <br>hr = CoGetClassObject(CLSID_CTestCOMPerformance, CLSCTX_LOCAL_SERVER, NULL, <br>IID_IClassFactory, (void**)&amp;pcflocal); <br>if(FAILED(hr)) <br>{ <br>Message(TEXT("CoGetClassObject:"), hr); <br>goto LCleanup; <br>} <br>// apt-model obj <br>hr = pcflocal-&gt;CreateInstance(NULL, IID_ICOMPerformance, (void**)&amp;pCOMApt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("Create Local Apt Instance:"), hr); <br>goto LCleanup; <br>} <br>hr = pCOMApt-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pAutoApt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("QI for pAutoApt:"), hr); <br>goto LCleanup; <br>} <br>// get free-threaded obj <br>hr = pcflocal-&gt;CreateInstance(NULL, IID_ICOMPerformance, (void**)&amp;pCOMFree); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("Create Local Free Instance"), hr); <br>goto LCleanup; <br>}                <br>hr = pCOMFree-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pAutoFree); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("QI for pAutoFree"), hr); <br>goto LCleanup; <br>} <br>hr = pcflocal-&gt;Release(); <br>pcflocal = NULL; <br>if(vfRemote) <br>{ <br>hr = CoGetClassObject(CLSID_CTestCOMPerformance, CLSCTX_REMOTE_SERVER, pcsi, <br>IID_IClassFactory, (void**)&amp;pcfrmt); <br>if(FAILED(hr)) <br>{ <br>Message(TEXT("CoGetClassObject for remote CF"), hr); <br>vfRemote = FALSE; <br>goto LContinue; <br>} <br>// apt-model obj <br>hr = pcfrmt-&gt;CreateInstance(NULL, IID_ICOMPerformance, (void**)&amp;pCOMAptRmt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("Create Remote Instance"), hr); <br>goto LCleanup; <br>} <br>hr = pCOMAptRmt-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pAutoAptRmt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("QI for pAutoAptFreeRmt"), hr); <br>goto LCleanup; <br>} <br>// get free-threaded obj <br>hr = pcfrmt-&gt;CreateInstance(NULL, IID_ICOMPerformance, (void**)&amp;pCOMFreeRmt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("Create Remote Free Instance"), hr); <br>goto LCleanup; <br>} <br>hr = pCOMFreeRmt-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pAutoFreeRmt); <br>if (FAILED(hr)) <br>{ <br>Message(TEXT("QI for pAutoFreeFreeRmt"), hr); <br>goto LCleanup; <br>} <br>hr = pcfrmt-&gt;Release(); <br>pcfrmt = NULL; <br>} <br>LContinue: <br>// create apartment thread for client <br>DWORD   dwClienttid; <br>// create the thread suspended so its event can be <br>// created using its thread-id and it will be able to <br>// use it as soon as it runs <br>HANDLE hClientThread = CreateThread(NULL, <br>    0, <br>    (LPTHREAD_START_ROUTINE)&amp;ClientThreadProc, <br>    0, <br>    CREATE_SUSPENDED, <br>    &amp;dwClienttid); <br>if (hClientThread == NULL) <br>{ <br>    hr = GetLastError(); <br>goto LCleanup; <br>} <br>wsprintf(rgch, TEXT("Thread_%d"), dwClienttid); <br> <br>vhEventCliStart = CreateEvent(NULL, FALSE, FALSE, rgch); <br>if (vhEventCliStart == NULL) <br>{ <br>    hr = GetLastError(); <br>    goto LCleanup; <br>} <br>vhEventCliDone = CreateEvent(NULL, FALSE, FALSE, NULL); <br>if (vhEventCliDone == NULL) <br>{ <br>    hr = GetLastError(); <br>    goto LCleanup; <br>}        <br>// Marshall local apt thread <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>    throw hr; <br>hr = CoMarshalInterface(vpstmMarshalling, <br>    IID_IUnknown, <br>    (ICOMPerformance*)pCOMApt, <br>    MSHCTX_INPROC, <br>    NULL, <br>    MSHLFLAGS_NORMAL); <br>if (FAILED(hr)) <br>    throw hr; <br>// now that the event is available, let the thread run <br>ResumeThread(hClientThread); <br>SetEvent(vhEventCliStart); <br>WaitForSingleObject(vhEventCliDone, INFINITE); <br> <br>if(vfRemote &amp;&amp; NULL != pCOMAptRmt) <br>{ <br>// Marshall local apt thread <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>throw hr; <br>hr = CoMarshalInterface(vpstmMarshalling, <br>IID_IUnknown, <br>(ICOMPerformance*)pCOMAptRmt, <br>MSHCTX_INPROC, <br>NULL, <br>MSHLFLAGS_NORMAL); <br>if (FAILED(hr)) <br>throw hr; <br>SetEvent(vhEventCliStart); <br>WaitForSingleObject(vhEventCliDone, INFINITE); <br>} <br> <br>// Test <br>_tprintf(TEXT("Output in Calls per sec\n")); <br>_tprintf(TEXT("DEF Sec:\t\tLOCAL\t\t\tREMOTE\n")); <br>// Do all tests <br>if(!DoTests()) <br>goto LCleanup; <br>// Up security on proxies <br>// Get current security <br>hr = pCOMApt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec); <br>hr = pclntsec-&gt;QueryBlanket(pCOMApt, &amp;AuthnSvc, &amp;AuthzSvc, NULL, &amp;AuthnLvl, &amp;ImpLvl, NULL, <br>&amp;Capabilities); <br> <br>_tprintf(TEXT("Increasing local security from AuthnLvl:%d  ImpLvl:%d\n"), AuthnLvl, ImpLvl); <br> <br>hr = pclntsec-&gt;SetBlanket(pCOMApt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>hr = pclntsec-&gt;QueryBlanket(pCOMApt, &amp;AuthnSvc, &amp;AuthzSvc, NULL, &amp;AuthnLvl, &amp;ImpLvl, NULL, <br>&amp;Capabilities); <br> <br>_tprintf(TEXT("Local security is now AuthnLvl:%d  ImpLvl:%d\n"), AuthnLvl, ImpLvl); <br> <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pCOMFree-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);   <br>hr = pclntsec-&gt;SetBlanket(pCOMFree, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pAutoApt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);   <br>hr = pclntsec-&gt;SetBlanket(pAutoApt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pAutoFree-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);  <br>hr = pclntsec-&gt;SetBlanket(pAutoFree, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>if(vfRemote) <br>{ <br>hr = pCOMAptRmt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);         <br>hr = pclntsec-&gt;QueryBlanket(pCOMAptRmt, &amp;AuthnSvc, &amp;AuthzSvc, NULL, &amp;AuthnLvl, &amp;ImpLvl, NULL, <br>&amp;Capabilities); <br> <br>_tprintf(TEXT("Increasing remote security from AuthnLvl:%d  ImpLvl:%d\n"), AuthnLvl, ImpLvl); <br> <br>hr = pclntsec-&gt;SetBlanket(pCOMAptRmt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br> <br>_tprintf(TEXT("Remote security is now AuthnLvl:%d  ImpLvl:%d\n"), AuthnLvl, ImpLvl); <br> <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pCOMFreeRmt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);        <br>hr = pclntsec-&gt;SetBlanket(pCOMFreeRmt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pAutoAptRmt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec);        <br>hr = pclntsec-&gt;SetBlanket(pAutoAptRmt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>hr = pAutoFreeRmt-&gt;QueryInterface(IID_IClientSecurity, (void**)&amp;pclntsec); <br>hr = pclntsec-&gt;SetBlanket(pAutoFreeRmt, AuthnSvc, AuthzSvc, NULL, 6, <br>4, NULL, Capabilities); <br>pclntsec-&gt;Release(); <br>pclntsec = NULL; <br>} <br>// Do all tests with FULL sec <br>// Apt to Apt first <br>// Marshall local apt thread <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>    throw hr; <br>hr = CoMarshalInterface(vpstmMarshalling, <br>    IID_IUnknown, <br>    (ICOMPerformance*)pCOMApt, <br>    MSHCTX_INPROC, <br>    NULL, <br>    MSHLFLAGS_NORMAL); <br>if (FAILED(hr)) <br>    throw hr; <br>// now that the event is available, let the thread run <br>ResumeThread(hClientThread); <br>SetEvent(vhEventCliStart); <br>WaitForSingleObject(vhEventCliDone, INFINITE); <br> <br>if(vfRemote &amp;&amp; NULL != pCOMAptRmt) <br>{ <br>// Marshall local apt thread <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>throw hr; <br>hr = CoMarshalInterface(vpstmMarshalling, <br>IID_IUnknown, <br>(ICOMPerformance*)pCOMAptRmt, <br>MSHCTX_INPROC, <br>NULL, <br>MSHLFLAGS_NORMAL); <br>if (FAILED(hr)) <br>throw hr; <br>SetEvent(vhEventCliStart); <br>WaitForSingleObject(vhEventCliDone, INFINITE); <br>} <br>_tprintf(TEXT("Modified Sec:\t\tLOCAL\t\t\tREMOTE\n")); <br>DoTests(); <br>    } <br>LCleanup: <br>if (vpstmMarshalling != NULL) <br>vpstmMarshalling-&gt;Release(); <br>if (vfServer) <br>    { <br>// we explicitly don't clean up threads and events <br>if (dwRegister != 0) <br>CoRevokeClassObject(dwRegister); <br>if(NULL != pcf) <br>delete pcf; <br>    } <br>    else // client <br>{ <br>// client case: release objects <br>if(NULL != pcflocal) <br>hr = pcflocal-&gt;Release(); <br>if(NULL != pcfrmt) <br>hr = pcfrmt-&gt;Release(); <br>if(NULL != pCOMFree) <br>hr = pCOMFree-&gt;Release(); <br>if(NULL != pAutoFree) <br>hr = pAutoFree-&gt;Release(); <br>if(NULL != pCOMApt) <br>hr = pCOMApt-&gt;Release(); <br>if(NULL != pAutoApt) <br>hr = pAutoApt-&gt;Release(); <br>if(NULL != pCOMFreeRmt) <br>hr = pCOMFreeRmt-&gt;Release(); <br>if(NULL != pAutoFreeRmt) <br>hr = pAutoFreeRmt-&gt;Release(); <br>if(NULL != pCOMAptRmt) <br>hr = pCOMAptRmt-&gt;Release(); <br>if(NULL != pAutoAptRmt) <br>hr = pAutoAptRmt-&gt;Release(); <br>    } <br>    CoUninitialize(); <br>    return hr; <br>}  // main <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: FAutoRegister <br>//  Registers the CTestCOMPerformance class in the registry. <br>// --------------------------------------------------------------------------- <br> BOOL <br>FAutoRegister() <br>{ <br>    static TCHAR szClassDesc[] = TEXT("COM Performance Sample"); <br>static TCHAR szCLSIDEntry[] = TEXT("CLSID\\{DDC68870-E08E-11cf-A535-00AA00615B03}"); <br>    TCHAR       szBuf[512]; <br>    TCHAR       szPath[512]; <br>    HKEY        hkeyT = NULL; <br> <br> <br>HRESULT hr; <br>LPFNREG lpfn = NULL; <br>HINSTANCE hLib = NULL; <br> <br>    // register class code <br>    if ((RegSetValue(HKEY_CLASSES_ROOT, szCLSIDEntry, REG_SZ, szClassDesc, <br>    lstrlen(szClassDesc)) != ERROR_SUCCESS) || <br>(RegCreateKey(HKEY_CLASSES_ROOT, szCLSIDEntry, &amp;hkeyT) <br>    != ERROR_SUCCESS) || <br>!GetModuleFileName(NULL, szBuf, sizeof(szBuf))) <br>return FALSE; <br>    lstrcpy(szPath, szBuf); <br>    if (RegSetValue(hkeyT, TEXT("LocalServer32"), REG_SZ, szBuf, lstrlen(szBuf)) <br>    != ERROR_SUCCESS) <br>goto LErrExit; <br>    RegCloseKey(hkeyT); <br>hkeyT = NULL; <br>// Register the ICOMPerformance MIDL-generated proxy-stub component <br>hLib = LoadLibrary(TEXT("psperf.dll")); <br>if (NULL == hLib) <br>{ <br>goto  LErrExit; <br>} <br>// Find entry point. <br>lpfn = (LPFNREG)GetProcAddress(hLib, TEXT("DllRegisterServer")); <br>if (lpfn == NULL) <br>{ <br>//Message(_T("Couldn't find entry point in DLL"), S_OK); //unable to locate entry point <br>goto LErrExit; <br>} <br>hr = (*lpfn)(); <br> <br>FreeLibrary(hLib); <br>if(SUCCEEDED(hr)) <br>return TRUE; <br>LErrExit: <br>if(NULL != hkeyT) <br>RegCloseKey(hkeyT); <br>return FALSE; <br>}  // FAutoRegister <br> <br>// =========================================================================== <br>//                          C C L A S S F A C T O R Y <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CClassFactory. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IClassFactory || iid == IID_IUnknown) <br>{ <br>*ppv = (IClassFactory *)this; <br>} <br>    if (*ppv != NULL) <br>{ <br>AddRef(); <br>return S_OK; <br>} <br>    return E_NOINTERFACE; <br>}  // CClassFactory::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CClassFactory::CreateInstance <br>//  Creates a new instance of a CTestCOMPerformance on the next worker thread. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CClassFactory::CreateInstance(LPUNKNOWN punkOuter, REFIID iid, void **ppv) <br>{ <br>    LPUNKNOWN   punk; <br>    HRESULT     hr; <br> <br>    *ppv = NULL; <br>    if (punkOuter != NULL) <br>return CLASS_E_NOAGGREGATION; <br> <br>    // trigger the worker thread that we want to create an object <br>    SetEvent(vrghEvent[viNextThread]); <br> <br>    // now wait for the object to signal its completion <br>    WaitForSingleObject(vhEventServer, INFINITE); <br> <br>    // once the worker thread signals completion, vhrThreadStatus <br>    // lets us know if the creation process was successful, and if <br>    // vpstmMarshalling creates a marshalled interface pointer <br>    if (FAILED(vhrThreadStatus)) <br>return vhrThreadStatus; <br> <br>    // unmarshal an IUnknown from the scratch stream. if unmarshaling <br>    // fails, it takes care of releasing the object inside the marshal-data <br>    hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>    if (FAILED(hr)) <br>return hr; <br>    hr = CoUnmarshalInterface(vpstmMarshalling, IID_IUnknown, (void **)&amp;punk); <br>    if (FAILED(hr)) <br>return hr; <br> <br>    // get a reference to the interface asked for <br>    hr = punk-&gt;QueryInterface(iid, ppv); <br>    punk-&gt;Release(); <br>++g_cObjectCount; <br>    viNextThread++; <br>//    viNextThread %= cServerThreads; <br> <br>    return hr; <br>}  // CClassFactory::CreateInstance <br> <br> STDMETHODIMP <br>CClassFactory::LockServer(BOOL fLock) <br>{ <br>    // there's no need to support this for this sample <br>    return E_FAIL; <br>}  // CClassFactory::LockServer <br> <br> <br>// =========================================================================== <br>//                               C O B J E C T <br>// =========================================================================== <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ServerThreadProc <br>//  The worker thread function. Handles messages for objects of its thread/apt <br>// and creates new objects. <br>// --------------------------------------------------------------------------- <br> LRESULT <br>ServerThreadProc(LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    MSG     msg; <br>    int     iThread; <br> <br>    // figure out which thread this is: it needs its synchronization event <br>    for (iThread=0; iThread&lt;cServerThreads; iThread++) <br>{ <br>if (vrgtid[iThread] == GetCurrentThreadId()) <br>    break; <br>} <br>    if (iThread==cServerThreads) <br>return E_UNEXPECTED; <br> <br>    // initialize COM <br>if((0 == iThread) || (2 == iThread)) <br>{ <br>hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); <br>Message(TEXT("Apartment Thread"), hr); <br>} <br>else <br>{ <br>hr = CoInitializeEx(NULL, COINIT_MULTITHREADED); <br>Message(TEXT("Free-threaded Model"), hr); <br>} <br>    if (FAILED(hr)) <br>{ <br>MessageBeep(0); <br>return hr; <br>} <br> <br>    // apartment message/event loop <br>    // here worker message loops last forever. in situations without a <br>    // static number of worker threads, the loop could easily be terminated by <br>    // WM_QUITs sent from the main thread which might manage the worker thread <br>    // pool more carefully. <br>    while (TRUE) <br>{ <br>DWORD dwWaitResult; <br> <br>// wait for any message sent or posted to this queue <br>// or for one of the passed handles to become signaled <br>dwWaitResult = MsgWaitForMultipleObjects(1, &amp;vrghEvent[iThread], <br>    FALSE, INFINITE, QS_ALLINPUT); <br> <br>// result tells us the type of event we have: <br>// a message or a signaled handle <br> <br>// if there are one or more messages in the queue ... <br>if (dwWaitResult == (WAIT_OBJECT_0 + 1)) <br>    { <br>    // dispatch all of the messages in this next loop <br>    // (here is where we'd check for WM_QUITs to end this <br>    // worker thread if we wanted to) <br>    while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>DispatchMessage(&amp;msg); <br>    } <br>else <br>    { <br>    // this thread was signaled to create a new object <br>    try <br>{ <br>LPUNKNOWN   punk; <br> <br>// create a new CTestCOMPerformance <br>punk = (ICOMPerformance *)new CTestCOMPerformance; <br>if (punk == NULL) <br>    throw E_OUTOFMEMORY; <br> <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>    throw hr; <br>hr = CoMarshalInterface(vpstmMarshalling, <br>    IID_IUnknown, <br>    punk, <br>    MSHCTX_INPROC, <br>    NULL, <br>    MSHLFLAGS_NORMAL); <br>if (FAILED(hr)) <br>    throw hr; <br> <br>// punk is now referenced by its marshal-data in vpstmMarshalling. <br>// we release our local reference here so the unmarshaller will <br>// have the sole reference. a common mistake is to forget this <br>// release and end up with orphaned objects in the server. <br>punk-&gt;Release(); <br>vhrThreadStatus = S_OK; <br>} <br>    catch (HRESULT hr) <br>{ <br>vhrThreadStatus = hr; <br>} <br>    SetEvent(vhEventServer); <br>    } <br> <br>} <br> <br>    CoUninitialize(); <br>    return msg.wParam; <br>}  // ServerThreadProc <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: ServerThreadProc <br>//  The worker thread function. Handles messages for objects of its thread/apt <br>// and creates new objects. </code></pre>
<p>
</p>
<pre><code>// --------------------------------------------------------------------------- <br> LRESULT <br>ClientThreadProc(LPARAM lParam) <br>{ <br>    HRESULT hr; <br>    MSG     msg; <br>UINT cCount = 0; <br>hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED); <br>    if (FAILED(hr)) <br>    { <br>return hr; <br>    } <br>    while (TRUE) <br>    { <br>DWORD dwWaitResult; <br> <br>// wait for any message sent or posted to this queue <br>// or for one of the passed handles to become signaled <br>dwWaitResult = MsgWaitForMultipleObjectsEx(1, &amp;vhEventCliStart, <br>    INFINITE, QS_SENDMESSAGE, 0); <br> <br>// result tells us the type of event we have: <br>// a message or a signaled handle <br> <br>// if there are one or more messages in the queue ... <br>if (dwWaitResult == (WAIT_OBJECT_0 + 1)) <br>{ <br>    // dispatch all of the messages in this next loop <br>    // (here is where we'd check for WM_QUITs to end this <br>    // worker thread if we wanted to) <br>    while (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE)) <br>DispatchMessage(&amp;msg); <br>} <br>else <br>{ <br>    // this thread was signaled to test Apt to Apt <br>    try <br>    { <br>//Message(TEXT("Testing Apt to Apt"), hr); <br>LPUNKNOWN   punk; <br>LPDISPATCH   pdisp; <br>// unmarshal an IUnknown from the scratch stream. if unmarshaling <br>// fails, it takes care of releasing the object inside the marshal-data <br>hr = vpstmMarshalling-&gt;Seek(bZero, STREAM_SEEK_SET, NULL); <br>if (FAILED(hr)) <br>return hr; <br>hr = CoUnmarshalInterface(vpstmMarshalling, IID_IUnknown, (void **)&amp;punk); <br>if (FAILED(hr)) <br>return hr; <br>ICOMPerformance *pcomperf = NULL; <br>// get a reference to ICOMPerformance and IDispatch interface <br>hr = punk-&gt;QueryInterface(IID_ICOMPerformance, (void**)&amp;pcomperf); <br>hr = punk-&gt;QueryInterface(IID_IDispatch, (void**)&amp;pdisp); <br>LONG    i, k; <br>CTIMER  tmElapsed; <br>BSTR bstr1, bstr2; <br>bstr1 = SysAllocString(pszDesc1); <br>bstr2 = SysAllocStringByteLen((const char *)pszDesc1, 4096); <br>// Test1 <br>tmElapsed.Start(); <br>for (i=0; i&lt;LOOPS; i++) <br>k = (LONG)pcomperf-&gt;Test1(i); <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[4].sec[0] = tmElapsed.OutputTime(); <br>else  <br>vrgperfloc[4].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>for (i=0; i&lt;LOOPS; i++) <br>k = (LONG)pcomperf-&gt;Test23(bstr1); <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[4].sec[1] = tmElapsed.OutputTime(); <br>else <br>vrgperfloc[4].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>for (i=0; i&lt;LOOPS; i++) <br>k = (LONG)pcomperf-&gt;Test23(bstr2); <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[4].sec[2] = tmElapsed.OutputTime(); <br>else <br>vrgperfloc[4].sec[2] = tmElapsed.OutputTime(); <br>// Now IDispatch <br>VARIANTARG  rgvt[1]; <br>DISPPARAMS  dispparams = { rgvt, NULL, 1, 0 }; <br>EXCEPINFO  excepinfo; <br> <br>VARIANT vtResult; <br>UINT    argerr; <br>// Test1 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;LOOPS; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_I4; <br>V_I4(&amp;rgvt[0]) = i; <br>hr = pdisp-&gt;Invoke(dispidICOMPerformance_Test1, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[5].sec[0] = tmElapsed.OutputTime(); <br>else <br>vrgperfloc[5].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;LOOPS; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr1;        <br>hr = pdisp-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[5].sec[1] = tmElapsed.OutputTime(); <br>else <br>vrgperfloc[5].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;LOOPS; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr2; <br>hr = pdisp-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>if(cCount &amp;&amp; vfRemote) <br>vrgperfrmt[5].sec[2] = tmElapsed.OutputTime(); <br>else <br>vrgperfloc[5].sec[2] = tmElapsed.OutputTime(); <br>SysFreeString(bstr1); <br>SysFreeString(bstr2); <br>hr = pcomperf-&gt;Release(); <br>hr = pdisp-&gt;Release(); <br>hr = punk-&gt;Release(); <br> <br>vhrThreadStatus = S_OK; <br>    } <br>    catch (HRESULT hr) <br>    { <br>vhrThreadStatus = hr; <br>} <br>    SetEvent(vhEventCliDone); <br>if(cCount) <br>--cCount; <br>else <br>++cCount; <br>} <br>    } <br>    CoUninitialize(); <br>    return msg.wParam; <br>}  // ClientThreadProc <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::QueryInterface <br>//  Returns a new reference of the specified iid-type to a CTestCOMPerformance. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CTestCOMPerformance::QueryInterface(REFIID iid, void **ppv) <br>{ <br>    *ppv = NULL; <br> <br>    if (iid == IID_IUnknown || iid == IID_ICOMPerformance) <br>    { <br>*ppv = (ICOMPerformance *)this; <br>    } <br>else if (iid == IID_IDispatch) <br>*ppv = (IDispatch *)this; <br>    if (*ppv == NULL) <br>    { <br>return E_NOINTERFACE; <br>    } <br>AddRef(); <br>    return S_OK; <br>}  // CTestCOMPerformance::QueryInterface <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::Release <br>//  Handles releases of references to a CTestCOMPerformance. Purpose here is to have code <br>// which alters the global state which is displayed in the servers UI. <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP_(ULONG) <br>CTestCOMPerformance::Release(void) <br>{ <br>if (--m_cRef == 0) <br>    { <br>--g_cObjectCount; <br>delete this; <br>Message(TEXT("Object Deleted"), S_OK); <br>if(g_cObjectCount == 0) SetEvent(hKillSvr); <br>return 0; <br>    } <br>    return m_cRef; <br>}  // CTestCOMPerformance::Release <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::GetTypeInfoCount <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CTestCOMPerformance::GetTypeInfoCount(UINT  *pctInfo) <br>{ <br>    *pctInfo = 1; <br>    return S_OK; <br>}  // CTestCOMPerformance::GetTypeInfoCount <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::GetTypeInfo <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CTestCOMPerformance::GetTypeInfo(unsigned int itInfo, LCID lcid, LPTYPEINFO  *ppti) <br>{ <br>HRESULT hr; <br> <br>    if (ppti == NULL) <br>return E_POINTER; <br>hr = CreateDispTypeInfo( &amp;interfacedata, 0, ppti); <br>    return hr; <br>}  // CTestCOMPerformance::GetTypeInfo <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::GetIDsOfNames <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CTestCOMPerformance::GetIDsOfNames(REFIID riid, WCHAR  *  *rgszNames, unsigned int cNames, LCID lcid, DISPID  *pdispid) <br>{ <br>    return E_NOTIMPL; <br>}  // CTestCOMPerformance::GetIDsOfNames <br> <br>// --------------------------------------------------------------------------- <br>// %%Function: CTestCOMPerformance::Invoke <br>// --------------------------------------------------------------------------- <br> STDMETHODIMP <br>CTestCOMPerformance::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS  *pdispparams, VARIANT  *pvarResult, <br>  EXCEPINFO  *pexcepinfo, unsigned int  *puArgErr) <br>{ <br>    LPTYPEINFO pti = NULL; <br>HRESULT hr = GetTypeInfo(0, lcid, &amp;pti); <br>if(FAILED(hr)) <br>return hr; <br> <br>hr =  pti-&gt;Invoke((ICOMPerformance*)this, dispidMember, <br>    wFlags, pdispparams, pvarResult, <br>    pexcepinfo, puArgErr); <br>hr = pti-&gt;Release(); <br>return hr; <br>}  // CTestCOMPerformance::Invoke <br> <br> <br> STDMETHODIMP                    <br>CTestCOMPerformance::Test1(int l) <br>{ <br> return S_OK; <br>} <br> <br> STDMETHODIMP                    <br>CTestCOMPerformance::Test23(BSTR bstr) <br>{ <br> return S_OK; <br>} <br> <br>// Tests <br> BOOL         <br>AptFreeCOMTest(int cLoops) <br>{ <br>LONG    i, k; <br>    CTIMER  tmElapsed; <br>BSTR bstr1, bstr2; <br>bstr1 = SysAllocString(pszDesc1); <br>bstr2 = SysAllocStringByteLen((const char *)pszDesc1, 4096); <br>// Local <br>// Test1 <br>    tmElapsed.Start(); <br>    for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMApt-&gt;Test1(i); <br>    tmElapsed.Stop(); <br>    vrgperfloc[0].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>    tmElapsed.Start(); <br>    for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMApt-&gt;Test23(bstr1); <br>    tmElapsed.Stop(); <br>    vrgperfloc[0].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>    tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMApt-&gt;Test23(bstr2); <br>    tmElapsed.Stop(); <br>    vrgperfloc[0].sec[2] = tmElapsed.OutputTime(); <br> <br>// Remote <br>if(vfRemote) <br>{ <br>tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMAptRmt-&gt;Test1(i); <br>tmElapsed.Stop(); <br>vrgperfrmt[0].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMAptRmt-&gt;Test23(bstr1); <br>tmElapsed.Stop(); <br>vrgperfrmt[0].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMAptRmt-&gt;Test23(bstr2); <br>tmElapsed.Stop(); <br>vrgperfrmt[0].sec[2] = tmElapsed.OutputTime(); <br> <br>} <br>SysFreeString(bstr1); <br>SysFreeString(bstr2); <br>return TRUE; <br>} <br> <br> BOOL            <br>AptFreeAutoTest(int cLoops) <br>{ <br>HRESULT hr; <br>static VARIANTARG  rgvt[1]; <br>    static DISPPARAMS  dispparams = { rgvt, NULL, 1, 0 }; <br>    static EXCEPINFO  excepinfo; <br>    VARIANT vtResult; <br>    UINT    argerr; <br>    LONG    i, k; <br>    CTIMER  tmElapsed; <br>BSTR bstr1, bstr2; <br>bstr1 = SysAllocString(pszDesc1); <br>bstr2 = SysAllocStringByteLen((const char *)pszDesc1, 4096); <br> <br>// Test1 <br>    tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_I4; <br>V_I4(&amp;rgvt[0]) = i; <br>hr = pAutoApt-&gt;Invoke(dispidICOMPerformance_Test1, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[1].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr1;        <br>hr = pAutoApt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[1].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr2; <br>hr = pAutoApt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[1].sec[2] = tmElapsed.OutputTime(); <br>// Remote <br>if(vfRemote) <br>{ <br>// Test1 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_I4; <br>V_I4(&amp;rgvt[0]) = i; <br>hr = pAutoAptRmt-&gt;Invoke(dispidICOMPerformance_Test1, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[1].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr1;        <br>hr = pAutoAptRmt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[1].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr2; <br>hr = pAutoAptRmt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[1].sec[2] = tmElapsed.OutputTime(); <br>} <br> <br>SysFreeString(bstr1); <br>SysFreeString(bstr2); <br>return TRUE; <br>} <br> <br> BOOL            <br>FreeFreeCOMTest(int cLoops) <br>{ <br>LONG    i, k; <br>    CTIMER  tmElapsed; <br>BSTR bstr1, bstr2; <br>bstr1 = SysAllocString(pszDesc1); <br>bstr2 = SysAllocStringByteLen((const char *)pszDesc1, 4096); <br> <br>// Test1 <br>    tmElapsed.Start(); <br>    for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMFree-&gt;Test1(i); <br>    tmElapsed.Stop(); <br>    vrgperfloc[2].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>    tmElapsed.Start(); <br>    for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMFree-&gt;Test23(bstr1); <br>    tmElapsed.Stop(); <br>    vrgperfloc[2].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>    tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>k = (LONG)pCOMFree-&gt;Test23(bstr2); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[2].sec[2] = tmElapsed.OutputTime(); <br> <br>// Remote <br>if(vfRemote) <br>{ <br>// Test1 <br>    tmElapsed.Start(); <br>    for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMFreeRmt-&gt;Test1(i); <br>tmElapsed.Stop(); <br>vrgperfrmt[2].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>k = (LONG)pCOMFreeRmt-&gt;Test23(bstr1); <br>tmElapsed.Stop(); <br>vrgperfrmt[2].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>k = (LONG)pCOMFreeRmt-&gt;Test23(bstr2); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[2].sec[2] = tmElapsed.OutputTime(); <br>} <br> <br>SysFreeString(bstr1); <br>SysFreeString(bstr2); <br>return TRUE; <br>} <br>  <br> BOOL            <br>FreeFreeAutoTest(int cLoops) <br>{ <br>HRESULT hr; <br>static VARIANTARG  rgvt[1]; <br>    static DISPPARAMS  dispparams = { rgvt, NULL, 1, 0 }; <br>    static EXCEPINFO  excepinfo; <br>    VARIANT vtResult; <br>    UINT    argerr; <br>    LONG    i, k; <br>    CTIMER  tmElapsed; <br>BSTR bstr1, bstr2; <br>bstr1 = SysAllocString(pszDesc1); <br>bstr2 = SysAllocStringByteLen((const char *)pszDesc1, 4096); <br> <br>// Local <br>// Test1 <br>    tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_I4; <br>V_I4(&amp;rgvt[0]) = i; <br>hr = pAutoFree-&gt;Invoke(dispidICOMPerformance_Test1, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[3].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr1;        <br>hr = pAutoFree-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[3].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>    V_VT(&amp;vtResult) = VT_HRESULT; <br>    for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr2; <br>hr = pAutoFree-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>    tmElapsed.Stop(); <br>    vrgperfloc[3].sec[2] = tmElapsed.OutputTime(); <br> <br>// Remote <br>if(vfRemote) <br>{ <br>// Test1 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_I4; <br>V_I4(&amp;rgvt[0]) = i; <br>hr = pAutoFreeRmt-&gt;Invoke(dispidICOMPerformance_Test1, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[3].sec[0] = tmElapsed.OutputTime(); <br>// Test2 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr1;        <br>hr = pAutoFreeRmt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[3].sec[1] = tmElapsed.OutputTime(); <br>// Test3 <br>tmElapsed.Start(); <br>V_VT(&amp;vtResult) = VT_HRESULT; <br>for (i=0; i&lt;cLoops; i++) <br>{ <br>V_VT(&amp;rgvt[0]) = VT_BSTR; <br>V_BSTR(&amp;rgvt[0]) = bstr2; <br>hr = pAutoFreeRmt-&gt;Invoke(dispidICOMPerformance_Test23, IID_NULL, 0, DISPATCH_METHOD, &amp;dispparams, <br>&amp;vtResult, &amp;excepinfo, &amp;argerr); <br>k = V_I4(&amp;vtResult); <br>} <br>tmElapsed.Stop(); <br>vrgperfrmt[3].sec[2] = tmElapsed.OutputTime(); <br>} <br>SysFreeString(bstr1); <br>SysFreeString(bstr2); <br>return TRUE; <br>} <br> <br> void <br>FPrintResults() <br>{ <br>_tprintf(TEXT("Data Size\t\t4\t50\t4k\t4\t50\t4k\n")); <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[0].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[0].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[0].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[0].sec[2]); <br>if(vfRemote)        <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[0].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[0].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[0].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[1].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[1].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[1].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[1].sec[2]); <br>if(vfRemote)    <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[1].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[1].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[1].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[2].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[2].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[2].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[2].sec[2]); <br>if(vfRemote)     <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[2].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[2].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[2].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[3].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[3].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[3].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[3].sec[2]); <br>if(vfRemote)     <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[3].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[3].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[3].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[4].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[4].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[4].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[4].sec[2]); <br>if(vfRemote)     <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[4].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[4].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[4].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br>_tprintf(TEXT("%s\t\t"), vrgperfloc[5].szTest); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[5].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[5].sec[1]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfloc[5].sec[2]); <br>if(vfRemote)     <br>{ <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[5].sec[0]); <br>_tprintf(TEXT("%4.2f\t"), LOOPS/vrgperfrmt[5].sec[1]); <br>_tprintf(TEXT("%4.2f\n"), LOOPS/vrgperfrmt[5].sec[2]); <br>} <br>else <br>{ <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\t")); <br>_tprintf(TEXT("--\n")); <br>} <br> <br>   <br>} <br> <br> BOOL  <br>DoTests(void) <br>{ <br>if(!AptFreeCOMTest(LOOPS)) <br>return FALSE; <br>if(!AptFreeAutoTest(LOOPS)) <br>return FALSE; <br>if(!FreeFreeCOMTest(LOOPS)) <br>return FALSE; <br>if(!FreeFreeAutoTest(LOOPS)) <br>return FALSE; <br>FPrintResults(); <br>return TRUE; <br>} // DoTests <br> <br>void Usage() <br>{ <br>_tprintf(TEXT("Usage: COMPERF [machine name | IP address | /? | -?]\n\n")); <br>_tprintf(TEXT("/?\t\t\tDisplays this help screen.\n")); <br>_tprintf(TEXT("machine name\t\tName of remote machine.\n")); <br>_tprintf(TEXT("IP address\t\tIP address of remote machine.\n\n")); <br>_tprintf("%s", PURPOSE); <br>} <br> <br>// EOF ======================================================================= <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
