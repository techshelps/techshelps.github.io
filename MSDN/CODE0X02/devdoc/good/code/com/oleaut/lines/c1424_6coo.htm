<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1428"></a>LINE.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Lines Object. <br>** <br>**  line.cpp <br>** <br>**  CLine implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif       <br>#include "lines.h" <br> <br>/* <br> * CLine::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Line automation object and initializes it. <br> * <br> * Parameters: <br> *  ppLine    Returns Line automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CLine::Create(CLine FAR* FAR* ppLine )  <br>{    <br>    HRESULT hr; <br>    CLine FAR* pLine = NULL; <br>      <br>    *ppLine = NULL; <br>     <br>    pLine = new CLine(); <br>    if (pLine == NULL) <br>        goto error;         <br>     <br>    // Load type information for the line from type library.  <br>    hr = LoadTypeInfo(&amp;pLine-&gt;m_ptinfo, IID_ILine); <br>    if (FAILED(hr)) <br>        goto error; <br> <br>    *ppLine = pLine; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pLine == NULL) <br>        return E_OUTOFMEMORY;  <br>                     <br>    if (pLine-&gt;m_ptinfo) <br>        pLine-&gt;m_ptinfo-&gt;Release(); <br>     <br>    // Set to NULL to prevent destructor from attempting to free again <br>    pLine-&gt;m_ptinfo = NULL;  <br>     <br>    delete pLine; <br>    return hr; <br>} <br> <br>/* <br> * CLine::CLine <br> * <br> * Purpose: <br> *  Constructor for CLine object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CLine::CLine() : m_SupportErrorInfo(this, IID_ILine) <br>#pragma warning (default : 4355) <br>{    <br>    m_ptinfo = NULL; <br>    m_pPointStart = NULL; <br>    m_pPointEnd = NULL; <br>    m_nThickness = 0;   <br>    m_colorref = 0;     <br>    m_cRef = 0;   <br>} <br> <br>/* <br> * CLine::~CLine <br> * <br> * Purpose: <br> *  Destructor for CLine object. <br> * <br> */ <br>CLine::~CLine() <br>{             <br>     if (m_ptinfo) m_ptinfo-&gt;Release();  <br>     if (m_pPointStart) m_pPointStart-&gt;Release(); <br>     if (m_pPointEnd) m_pPointEnd-&gt;Release();  <br>} <br> <br>/* <br> * CLine::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CLine::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>     <br>    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_ILine) <br>        *ppv = this;  <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CLine::AddRef(void) <br>{   <br> <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Line\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br> <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CLine::Release(void) <br>{     <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Line\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br> <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>/* <br> * CLine::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CLine::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CLine::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CLine::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CLine::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CLine::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CLine::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used.  <br> * <br> */ <br>STDMETHODIMP <br>CLine::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>    // VB 3.0/Disptest have a bug in which they pass DISPATCH_PROPERTYPUT <br>    // instead of DISPATCH_PROPERTYPUTREF for the EndPoint and StartPoint <br>    // properties. Future versions of VB will correctly pass DISPATCH_PROPERTYPUTREF. <br>    // EndPoint has DISPID == 1 and StartPoint has DISPID == 2 - see lines.odl.  <br>    // The following code works around the VB 3.0/Disptest bug.  <br>    if ((dispidMember == 1 || dispidMember == 2) <br>        &amp;&amp; wFlags == DISPATCH_PROPERTYPUT) <br>        wFlags = DISPATCH_PROPERTYPUTREF; <br> <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);  <br>}  <br> <br>/*   <br> *  <br> * Properties and methods exposed through automation. <br> * <br> */ <br>STDMETHODIMP <br>CLine::get_Color(long FAR* plColorref) <br>{ <br>    *plColorref =  m_colorref;    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CLine::put_Color(long lColorref) <br>{ <br>    m_colorref = (COLORREF)lColorref;   <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CLine::get_EndPoint(IPoint FAR* FAR* ppPoint) <br>{    <br>    HRESULT hr;        <br>     <br>    *ppPoint = NULL; <br>     <br>    if (NULL == m_pPointEnd)   <br>        return RaiseException(IDS_NoStartPoint, IID_ILine);                       <br>     <br>    hr = m_pPointEnd-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPoint); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_ILine);  <br>    return NOERROR;  <br>} <br> <br>STDMETHODIMP <br>CLine::putref_EndPoint(IPoint FAR* pPointNew) <br>{    <br>    HRESULT hr; <br>    CPoint FAR* pPoint; <br>     <br>    // Save the IPoint interface so we can easily access private data <br>    hr = pPointNew-&gt;QueryInterface(IID_IPoint, (void FAR* FAR*)&amp;pPoint); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_PointFromOtherInstance, IID_ILine);     <br>         <br>    // Replace the old point with the new <br>    if (m_pPointEnd) <br>       m_pPointEnd-&gt;Release();     <br> <br>    m_pPointEnd = pPoint;    <br>    return NOERROR; <br>}           <br> <br>STDMETHODIMP <br>CLine::get_StartPoint(IPoint FAR* FAR* ppPoint) <br>{    <br>    HRESULT hr;      <br>     <br>    *ppPoint = NULL; <br>     <br>    if (NULL == m_pPointStart)   <br>        return RaiseException(IDS_NoStartPoint, IID_ILine);               <br>     <br>    hr = m_pPointStart-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPoint); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_ILine);  <br> <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CLine::putref_StartPoint(IPoint FAR* pPointNew) <br>{ <br>    HRESULT hr; <br>    CPoint FAR* pPoint; <br>     <br>    // Save the IPoint interface so we can easily access private data <br>    hr = pPointNew-&gt;QueryInterface(IID_IPoint, (void FAR* FAR*)&amp;pPoint); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_PointFromOtherInstance, IID_ILine);    <br>         <br>    // Replace the old point with the new <br>    if (m_pPointStart) <br>       m_pPointStart-&gt;Release();     <br> <br>    m_pPointStart = pPoint;    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CLine::get_Thickness(int FAR* pnThickness) <br>{ <br>    *pnThickness = m_nThickness; <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CLine::put_Thickness(int nThickness) <br>{ <br>    m_nThickness = nThickness;   <br>    return NOERROR; <br>} <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */   <br> <br>STDMETHODIMP_(void) <br>CLine::Draw(HDC hdc) <br>{ <br>    HPEN hpen, hpenOld; <br>     <br>    if (m_pPointStart == NULL) <br>        return; <br>    if (m_pPointEnd == NULL) <br>        return; <br>     <br>    hpen = CreatePen(PS_SOLID, m_nThickness, m_colorref); <br>    hpenOld = (HPEN) (HGDIOBJ)SelectObject(hdc, (HGDIOBJ)hpen);           <br>       <br>    MoveToEx(hdc, m_pPointStart-&gt;get_x(), m_pPointStart-&gt;get_y(), NULL); <br>    LineTo(hdc, m_pPointEnd-&gt;get_x(), m_pPointEnd-&gt;get_y()); <br>     <br>    SelectObject(hdc, (HGDIOBJ)hpenOld); <br>    DeleteObject((HGDIOBJ)hpen);      <br>    return;                  <br>} <br> <br>/* <br> * CLine::GetInvalidateRect <br> * <br> * Purpose: <br> *  Get the rectangle that cicumscribes the line. This rectangle is used to invalidate the area <br> *  of the window where the line is to be draw or erased. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CLine::GetInvalidateRect(LPRECT prc) <br>{     <br>    int nX1, nY1, nX2, nY2; <br>    <br>    nX1 = m_pPointStart-&gt;get_x(); <br>    nY1 = m_pPointStart-&gt;get_y(); <br>   <br>    nX2 = m_pPointEnd-&gt;get_x(); <br>    nY2 = m_pPointEnd-&gt;get_y(); <br>     <br>    if (nX1 &lt; nX2) <br>    { <br>        prc-&gt;left = nX1; <br>        prc-&gt;right = nX2; <br>    } <br>    else  <br>    {     <br>        prc-&gt;left = nX2; <br>        prc-&gt;right = nX1;      <br>    } <br>    if (nY1 &lt; nY2) <br>    { <br>        prc-&gt;top = nY1; <br>        prc-&gt;bottom = nY2; <br>    } <br>    else  <br>    {     <br>        prc-&gt;top = nY2; <br>        prc-&gt;bottom = nY1;      <br>    }   <br> <br>    InflateRect(prc, m_nThickness, m_nThickness); <br>}  <br> <br>STDMETHODIMP_(BOOL) <br>CLine::AddEndPointsToPane(CPane FAR* pPane) <br>{  <br>    // Does the line have end points? <br>    if (NULL == m_pPointStart) <br>       return FALSE; <br>    if (NULL == m_pPointEnd) <br>       return FALSE; <br>     <br>    // Add points to Point collection in the Pane object. <br>    if (pPane-&gt;AddPoint(m_pPointStart)) <br>        return pPane-&gt;AddPoint(m_pPointEnd);  <br>    return FALSE; <br> <br>} <br> <br>STDMETHODIMP_(void) <br>CLine::RemoveEndPointsFromPane(CPane FAR* pPane) <br>{     <br>    // Remove the end points of the line to be removed from the Points collection in the Pane.       <br>    if (NULL != m_pPointStart) <br>        pPane-&gt;RemovePoint(m_pPointStart); <br>    if (NULL != m_pPointEnd) <br>       pPane-&gt;RemovePoint(m_pPointEnd);    <br> <br>}     </code></pre>
<p>&nbsp;</p></body>
</HTML>
