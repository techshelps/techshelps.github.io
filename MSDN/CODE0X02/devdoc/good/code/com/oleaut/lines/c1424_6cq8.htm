<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINES.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1430"></a>LINES.H</h2>
<pre><code>#ifdef WIN32 <br> <br>#ifdef UNICODE <br>    #define FROM_OLE_STRING(str) str <br>    #define TO_OLE_STRING(str) str  <br>#else <br>    #define FROM_OLE_STRING(str) ConvertToAnsi(str) <br>    char* ConvertToAnsi(OLECHAR FAR* szW);   <br>    #define TO_OLE_STRING(str) ConvertToUnicode(str) <br>    OLECHAR* ConvertToUnicode(char FAR* szA);    <br>    // Maximum length of string that can be converted between Ansi &amp; Unicode <br>    #define STRCONVERT_MAXLEN 300          <br>#endif <br> <br>#else  // WIN16 <br>  #define APIENTRY far pascal   <br>  #define TCHAR char <br>  #define TEXT(sz) sz  <br>  #define FROM_OLE_STRING(str) str   <br>  #define TO_OLE_STRING(str) str   <br>  #define LPTSTR LPSTR <br>   <br>  // Windows NT defines the following in windowsx.h <br>  #define GET_WM_COMMAND_ID(w,l) (w) <br>  #define GET_WM_COMMAND_CMD(w,l) HIWORD(l) <br>  #define GET_WM_COMMAND_HWND(w,l) LOWORD(l) <br>#endif <br> <br>#include "tlb.h" <br>  <br>// Menu IDs <br>#define IDM_DRAWLINE  101 <br>#define IDM_CLEAR     102 <br>#define IDM_EXIT      103   <br> <br>// Dialog ID <br>#define IDD_DRAWLINE  101 <br>// Icon ID <br>#define IDI_ICON      102 <br> <br>// Dialog Control IDs <br>#define IDC_THICKNESS     101 <br>#define IDC_CHOOSECOLOR   102 <br>#define IDC_STARTPOINT_X  103 <br>#define IDC_STARTPOINT_Y  104 <br>#define IDC_ENDPOINT_X    105 <br>#define IDC_ENDPOINT_Y    106  <br>#define IDC_STATIC         -1 <br> <br>// MAX len of string table entries <br>#define STR_LEN   200 <br> <br>// String table constants <br>#define IDS_Name                   1  <br>#define IDS_ErrorLoadingTypeLib    2 <br>#define IDS_ProgID                 3  <br>#define IDS_Unexpected             1001 <br>#define IDS_OutOfMemory            1002    <br>#define IDS_InvalidIndex           1003 <br>#define IDS_CollectionFull         1004 <br>#define IDS_LineFromOtherInstance  1005 <br>#define IDS_CantAddEndPoints       1006   <br>#define IDS_PointFromOtherInstance 1007  <br>#define IDS_NoVisibleXCoordinate   1008 <br>#define IDS_NoVisibleYCoordinate   1009   <br>#define IDS_NoStartPoint           1010 <br>#define IDS_NoEndPoint             1011    <br> <br>// SCODEs for the Lines Application. This is required for vtable-binding <br>// Automation objects want to return custom HRESULTs. All the OLE-defined  <br>// FACILITY_ITF codes have a code value which lies in the region 0x0000-0x01FFF. <br>// While it is legal for the definer to use any code, it is highly recommended <br>// that only code values in the range 0x0200-0xFFFF be used, as this will reduce the <br>// possiblity of accidental confusion with any OLE-defined errors. <br>#define LINES_E_FIRST MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x0200)   <br> <br>#define LINES_E_UNEXPECTED              (LINES_E_FIRST + 0x0)  <br>// Unexpected error <br>#define LINES_E_OUTOFMEMORY             (LINES_E_FIRST + 0x1)  <br>// Out of memory <br>#define LINES_E_INVALIDINDEX            (LINES_E_FIRST + 0x2)  <br>// Invalid index to Points or Lines collections  <br>#define LINES_E_COLLECTIONFULL          (LINES_E_FIRST + 0x3)  <br>// Points or Lines collection is full <br>#define LINES_E_LINEFROMOTHERINSTANCE   (LINES_E_FIRST + 0x4) <br>// Line from another instance of this application cannot be added. <br>#define LINES_E_CANTADDENDPOINTS        (LINES_E_FIRST + 0x5)    <br>// End points of line cannot be added to collection. (Make sure line has two end points). <br>#define LINES_E_POINTFROMOTHERINSTANCE  (LINES_E_FIRST + 0x6) <br>// Point from another instance of this application cannot be added. <br>#define LINES_E_NOVISIBLEXCOORDINATE    (LINES_E_FIRST + 0x7) <br>// No visible X coordinate. <br>#define LINES_E_NOVISIBLEYCOORDINATE    (LINES_E_FIRST + 0x8) <br>// No visible Y coordinate. <br>#define LINES_E_NOSTARTPOINT            (LINES_E_FIRST + 0x9) <br>// Line does not have a start point. <br>#define LINES_E_NOENDPOINT              (LINES_E_FIRST + 0xA) <br>// Line does not have an end point. <br> <br>// Number of SCODEs <br>#define SCODE_COUNT 11    <br> <br>// Function prototypes <br>int APIENTRY WinMain (HINSTANCE, HINSTANCE, LPSTR, int); <br>BOOL InitApplication (HINSTANCE); <br>BOOL InitInstance (HINSTANCE); <br>BOOL ProcessCmdLine(LPSTR pCmdLine, LPDWORD pdwRegisterCF, LPDWORD pdwRegisterActiveObject, int nCmdShow); <br>void Uninitialize(DWORD dwRegisterCF, DWORD dwRegisterActiveObject); <br>HRESULT LoadTypeInfo(ITypeInfo FAR* FAR* pptinfo, REFCLSID clsid); <br>HRESULT RaiseException(int nID, REFGUID rguid); <br> <br>#ifdef WIN16 <br>extern "C" LRESULT __export CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);  <br>extern "C" BOOL __export CALLBACK DrawLineDialogFunc(HWND, UINT, WPARAM, LPARAM);                   <br>#else  <br>extern "C" LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);  <br>extern "C" BOOL CALLBACK DrawLineDialogFunc(HWND, UINT, WPARAM, LPARAM);  <br>#endif    <br>  <br>// Class definitions <br>class CPane;   <br>class CLine; <br>class CPoint; <br>class CLines; <br>class CPoints;   <br> <br>// ISupportErrorInfo interface implementation <br>interface CSupportErrorInfo : public ISupportErrorInfo  <br>{ <br>public: <br>    // IUnknown methods  <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(void); <br>    STDMETHOD_(ULONG, Release)(void);  <br>     <br>    // ISupportErrorInfo method <br>    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);   <br>      <br>    CSupportErrorInfo(IUnknown FAR* punkObject, REFIID riid);  <br>private: <br>    LPUNKNOWN m_punkObject;  // IUnknown of Object that implements this interface  <br>    GUID m_iid; <br>};      <br> <br>class FAR CApplicationCF : public IClassFactory <br>{ <br>public: <br>    // IUnknown methods  <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(void); <br>    STDMETHOD_(ULONG, Release)(void);  <br>     <br>    // IClassFactory methods <br>    STDMETHOD(CreateInstance)(IUnknown FAR* punkOuter, REFIID riid,  <br>                              void FAR* FAR* ppv); <br>    STDMETHOD(LockServer)(BOOL fLock);     <br>     <br>    CApplicationCF(); <br>     <br>private: <br>    ULONG m_cRef;                   // Reference count <br>};  <br> <br>     <br>class FAR CApplication : public IApplication <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* IApplication automation exposed properties and methods */    <br>    STDMETHOD(get_Application)(IApplication FAR* FAR* ppApplication); <br>    STDMETHOD(get_FullName)(BSTR FAR* pbstr); <br>    STDMETHOD(get_Name)(BSTR FAR* pbstr); <br>    STDMETHOD(get_Parent)(IApplication FAR* FAR* ppApplication); <br>    STDMETHOD(put_Visible)(VARIANT_BOOL bVisible); <br>    STDMETHOD(get_Visible)(VARIANT_BOOL FAR* pbVisible); <br>    STDMETHOD(Quit)(); <br>    STDMETHOD(get_Pane)(IPane FAR* FAR* ppPane); <br>    STDMETHOD(CreateLine)(ILine FAR* FAR* ppLine); <br>    STDMETHOD(CreatePoint)(IPoint FAR* FAR* ppPoint); <br>     <br>    /* CApplication methods */ <br>    STDMETHOD_(void, Draw)(); <br>    STDMETHOD_(void, OnSize)(unsigned int nWidth, unsigned int nHeight); <br>    STDMETHOD_(void, ShowWindow)(int nCmdShow);  <br>    STDMETHOD_(void, CreateAndDrawLine)(); <br>    STDMETHOD_(void, ClearPane)();   <br>     <br>    static HRESULT Create(HINSTANCE hwnd, CApplication FAR* FAR* ppApplication); // Creates and intializes Applicaton object  <br>    CApplication(); <br>    ~CApplication();     <br>     <br>public: <br>    HWND m_hwnd;                   // Application window.      <br>    HINSTANCE m_hinst;             // Hinstance of application.  <br>    BSTR m_bstrName;               // Name of application. <br>    BSTR m_bstrProgID;             // ProgID of application.  <br>    BOOL m_bUserClosing;           // User is closing the application. <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of IApplication interface. <br>    BSTR m_bstrFullName;           // Full name of application. <br>    BOOL m_bVisible;               // Is window visible? <br>    CPane FAR* m_pPane;            // Pointer to the Pane object.    <br>    ULONG m_cRef;                  // Reference count.    <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CPane : public IPane <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* IPane automation exposed properties &amp; methods */     <br>    STDMETHOD(get_Lines)(ILines FAR* FAR* ppLines); <br>    STDMETHOD(get_Points)(IPoints FAR* FAR* ppPoints); <br>    STDMETHOD(get_MaxX)(int FAR* pnMaxX); <br>    STDMETHOD(get_MaxY)(int FAR* pnMaxY); <br>    STDMETHOD(Clear)(); <br>    STDMETHOD(Refresh)(); <br>     <br>    /* CPane methods */ <br>    STDMETHOD_(void, Draw)();  <br>    STDMETHOD_(void, OnSize)(unsigned int nWidth, unsigned int nHeight);     <br>    STDMETHOD_(HDC,  GetDC)();   <br>    STDMETHOD_(void, ReleaseDC)(HDC hdc);    <br>    STDMETHOD_(void, InvalidateRect)(LPRECT prc); <br>    STDMETHOD_(void, Update)(void); <br>    STDMETHOD_(BOOL, AddPoint)(CPoint FAR* pPoint); <br>    STDMETHOD_(void, RemovePoint)(CPoint FAR* pPoint); <br>     <br>    static HRESULT Create(HWND hwnd, CPane FAR* FAR* ppPane); // Creates and intializes Pane object  <br>    CPane(); <br>    ~CPane(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of IPane interface. <br>    HWND m_hwnd;                   // Main window. <br>    CLines FAR *m_pLines;          // Lines collection. <br>    CPoints FAR* m_pPoints;        // Points collection. <br>    int m_nMaxX;                   // Maximum visible X coordinate in twips. <br>    int m_nMaxY;                   // Maximum visible Y coordinate in twips. <br>    int m_nWidth;                  // Width of pane in twips. <br>    int m_nHeight;                 // Height of pane in twips.   <br>    ULONG m_cRef;                  // Reference count.    <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CLine : public ILine <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* ILine automation exposed properties &amp; methods */    <br>    STDMETHOD(get_Color)(long FAR* plColorref); <br>    STDMETHOD(put_Color)(long lColorref); <br>    STDMETHOD(get_EndPoint)(IPoint FAR* FAR* ppPoint); <br>    STDMETHOD(putref_EndPoint)(IPoint FAR* pPoint); <br>    STDMETHOD(get_StartPoint)(IPoint FAR* FAR* ppPoint); <br>    STDMETHOD(putref_StartPoint)(IPoint FAR* pPoint); <br>    STDMETHOD(get_Thickness)(int FAR* pnThickness); <br>    STDMETHOD(put_Thickness)(int nThickness); <br>     <br>    /* CLine methods */ <br>    STDMETHOD_(void, Draw)(HDC hdc);      <br>    STDMETHOD_(void, GetInvalidateRect)(LPRECT prc); <br>    STDMETHOD_(BOOL, AddEndPointsToPane)(CPane FAR* pPane); <br>    STDMETHOD_(void, RemoveEndPointsFromPane)(CPane FAR* pPane);   <br>     <br>    static HRESULT Create(CLine FAR* FAR* ppLine); // Creates and intializes Line object  <br>    CLine(); <br>    ~CLine(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of ILine interface. <br>    COLORREF m_colorref;           // RGB color of line. <br>    CPoint FAR* m_pPointStart;     // Start point of line. <br>    CPoint FAR* m_pPointEnd;       // End point of line. <br>    int m_nThickness;              // Line thickness in twips.  <br>    ULONG m_cRef;                  // Reference count. <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CPoint : public IPoint <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* IPoint automation exposed properties &amp; methods */     <br>    STDMETHOD(get_x)(int FAR* pnX); <br>    STDMETHOD(put_x)(int nX); <br>    STDMETHOD(get_y)(int FAR* pnY); <br>    STDMETHOD(put_y)(int nY); <br>     <br>    /* CPoint methods */ <br>    STDMETHOD_(ULONG, InternalAddRef)(); <br>    STDMETHOD_(ULONG, InternalRelease)(); <br>    STDMETHOD_(int, get_x)();       <br>    STDMETHOD_(int, get_y)();  <br>     <br>    static HRESULT Create(CPoint FAR* FAR* ppPoint); // Creates and intializes Point object  <br>    CPoint(); <br>    ~CPoint(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of IPoint interface. <br>    int m_nX;                      // X coordinate of point in twips. <br>    int m_nY;                      // Y coordinate of point in twips. <br>    ULONG m_cInternalRef;          // Reference count for the use of the Points collection only. <br>    ULONG m_cRef;                  // Reference count.   <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CLines : public ILines <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* ILines automation exposed properties &amp; methods */  <br>    STDMETHOD(Add)(ILine FAR* pLine); <br>    STDMETHOD(get_Count)(long FAR* lCount); <br>    STDMETHOD(get_Item)(long lIndex, ILine FAR* FAR* ppLine); <br>    STDMETHOD(get__NewEnum)(IUnknown FAR* FAR* ppunkEnum); <br>    STDMETHOD(Remove)(long lIndex); <br>     <br>    /* CLines methods */ <br>    STDMETHOD_(void, Draw)(HDC hdc); <br>    STDMETHOD_(void, Clear)();    <br>     <br>    static HRESULT Create(ULONG lMaxSize, long lLBound, CPane FAR* pPane, CLines FAR* FAR* ppLines); // Creates and intializes Lines object  <br>    CLines(); <br>    ~CLines(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of ILines interface. <br>    SAFEARRAY FAR *m_psa;          // Safe array that holds Lines collection items. <br>    ULONG m_cElements;             // Number of items in Lines collection. <br>    ULONG m_cMax;                  // Maximum number of items Lines collection can hold. <br>    long m_lLBound;                // Lower bound of index of Lines collection. <br>    CPane FAR* m_pPane;            // Pointer to the Pane object that contains this Lines collection.   <br>    ULONG m_cRef;                  // Reference count.      <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CPoints : public IPoints <br>{ <br>public: <br>    /* IUnknown methods */ <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    /* IDispatch methods */ <br>    STDMETHOD(GetTypeInfoCount)(UINT FAR* pctinfo); <br>    STDMETHOD(GetTypeInfo)(        <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo); <br>    STDMETHOD(GetIDsOfNames)(        <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid); <br>    STDMETHOD(Invoke)(        <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr); <br> <br>    /* IPoints automation exposed properties &amp; methods */     <br>    STDMETHOD(get_Count)(long FAR* plCount); <br>    STDMETHOD(get_Item)(long lIndex, IPoint FAR* FAR* ppPoint); <br>    STDMETHOD(get__NewEnum)(IUnknown FAR* FAR* ppunkEnum); <br>     <br>    /* CPoints methods */ <br>    STDMETHOD_(BOOL, Add)(CPoint FAR* pPointNew); <br>    STDMETHOD_(BOOL, Remove)(CPoint FAR* pPointRemove); <br>    STDMETHOD_(void, Clear)();    <br>    STDMETHOD_(void, GetMaxXMaxY)(int FAR* pnX, int FAR* pnY, LPRECT prc);   <br>     <br>    static HRESULT Create(ULONG lMaxSize, long lLBound, CPane FAR* pPane, CPoints FAR* FAR* ppPoints); // Creates and intializes Points object  <br>    CPoints(); <br>    ~CPoints(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;           // Type information of IPoints interface. <br>    SAFEARRAY FAR *m_psa;          // Safe array that holds Points collection items. <br>    ULONG m_cElements;             // Number of items in Points collection. <br>    ULONG m_cMax;                  // Maximum number of items Points collection can hold. <br>    long m_lLBound;                // Lower bound of index of Points collection.      <br>    CPane FAR* m_pPane;            // Pointer to the Pane object that contains this Points collection.   <br>    ULONG m_cRef;                  // Reference count. <br>    CSupportErrorInfo m_SupportErrorInfo; // ISupportErrorInfo interface implementation  <br>}; <br> <br>class FAR CEnumVariant : public IEnumVARIANT <br>{ <br>public: <br>    // IUnknown methods  <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    // IEnumVARIANT methods  <br>    STDMETHOD(Next)(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched); <br>    STDMETHOD(Skip)(ULONG cElements); <br>    STDMETHOD(Reset)(); <br>    STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum); <br>     <br>    static HRESULT Create(SAFEARRAY FAR*, ULONG, CEnumVariant FAR* FAR*); // Creates and intializes Enumerator <br>    CEnumVariant(); <br>    ~CEnumVariant(); <br>     <br>private: <br>    ULONG m_cRef;           // Reference count                                  <br>    ULONG m_cElements;      // Number of elements in enumerator.  <br>    long m_lLBound;         // Lower bound of index. <br>    long m_lCurrent;        // Current index. <br>    SAFEARRAY FAR* m_psa;   // Safe array that holds elements. <br>};  <br>  <br>// Structure filled by dialog from user input to create a line. <br>typedef struct _lineinfo <br>{ <br>    COLORREF colorref;    // RGB color of line. <br>    POINT ptStart;        // Start point of line.    <br>    POINT ptEnd;          // End point of line. <br>    int nThickness;       // Thickness of line. <br>} LINEINFO, FAR* LPLINEINFO; <br>  <br>extern CApplication FAR* g_pApplication; </code></pre>
<p>&nbsp;</p></body>
</HTML>
