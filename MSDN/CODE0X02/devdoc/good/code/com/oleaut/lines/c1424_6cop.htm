<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>LINES.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1429"></a>LINES.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Lines object <br>** <br>**  lines.cpp <br>** <br>**  CLines collection implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif       <br>#include "lines.h"    <br> <br>/* <br> * CLines::Create <br> * <br> * Purpose: <br> *  Creates an instance of a Lines collection object and initializes it. <br> * <br> * Parameters: <br> *  lMaxSize   Maximum number of items that can added to collection. <br> *  lLBound    Lower bound of index of collection.   <br> *  pPane      Pointer to pane that contains this collection. Required because the pane coordinates  <br> *             the lines and points collection. <br> *  ppLines    Returns Lines collection object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT <br>CLines::Create(ULONG lMaxSize, long lLBound, CPane FAR* pPane, CLines FAR* FAR* ppLines)  <br>{    <br>    HRESULT hr; <br>    CLines FAR* pLines = NULL; <br>    SAFEARRAYBOUND sabound[1]; <br>      <br>    *ppLines = NULL; <br>     <br>    // Create new collection <br>    pLines = new CLines(); <br>    if (pLines == NULL) <br>        goto error; <br> <br>    pLines-&gt;m_cMax = lMaxSize; <br>    pLines-&gt;m_cElements = 0;  <br>    pLines-&gt;m_lLBound = lLBound; <br>    pLines-&gt;m_pPane = pPane;       <br>     <br>    // Load type information for the Lines collection from type library.  <br>    hr = LoadTypeInfo(&amp;pLines-&gt;m_ptinfo, IID_ILines); <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>    // Create a safe array of variants which is used to implement the collection.             <br>    sabound[0].cElements = lMaxSize; <br>    sabound[0].lLbound = lLBound;         <br>    pLines-&gt;m_psa = SafeArrayCreate(VT_VARIANT, 1, sabound); <br>    if (pLines-&gt;m_psa == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto error; <br>    }              <br> <br>    *ppLines = pLines; <br>    return NOERROR; <br>     <br>error:  <br>    if (pLines == NULL) <br>        return E_OUTOFMEMORY; <br>    if (pLines-&gt;m_ptinfo) <br>        pLines-&gt;m_ptinfo-&gt;Release();                             <br>    if (pLines-&gt;m_psa)  <br>        SafeArrayDestroy(pLines-&gt;m_psa);  <br>   <br>    pLines-&gt;m_psa = NULL; <br>    pLines-&gt;m_ptinfo = NULL;  <br>     <br>    delete pLines; <br>    return hr; <br>} <br> <br>/* <br> * CLines::CLines <br> * <br> * Purpose: <br> *  Constructor for CLines object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CLines::CLines() : m_SupportErrorInfo(this, IID_ILines) <br>#pragma warning (default : 4355) <br>{     <br>    m_cRef = 0; <br>    m_psa = NULL; <br>    m_ptinfo = NULL;  <br>} <br> <br>/* <br> * CLines::~CLines <br> * <br> * Purpose: <br> *  Destructor for CLines object.  <br> * <br> */ <br>CLines::~CLines() <br>{     <br>     if (m_ptinfo) m_ptinfo-&gt;Release();                    <br>     if (m_psa) SafeArrayDestroy(m_psa); <br>} <br> <br>/* <br> * CLines::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CLines::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{     <br>    *ppv = NULL; <br>         <br>    if (iid == IID_IUnknown || iid == IID_ILines || iid == IID_IDispatch) <br>        *ppv = this;      <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CLines::AddRef(void) <br>{  <br> <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Lines\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br>     <br>    return ++m_cRef; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CLines::Release(void) <br>{  <br> <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Lines\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>     <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>}  <br> <br>/* <br> * CLines::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CLines::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CLines::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CLines::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CLines::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CLines::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CLines::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP <br>CLines::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);  <br>} <br> <br>/*   <br> *  <br> * Properties and methods exposed through automation. <br> * <br> */ <br> <br>/* <br> * CLines::Add <br> * <br> * Purpose: <br> *  Adds a line to the lines collection.  <br> * <br> * Parameters: <br> *  pLineNew    IDispatch of line to be added to collection. <br> * <br> */ <br>STDMETHODIMP   <br>CLines::Add(ILine FAR* pLineNew) <br>{  <br>    HRESULT hr;    <br>    LONG l; <br>    CLine FAR* pLine = NULL; <br>    VARIANT v;        <br>    HDC hdc; <br>     <br>    // Is the collection full? <br>    if (m_cElements == m_cMax)  <br>        return RaiseException(IDS_CollectionFull, IID_ILines); <br> <br>    hr = pLineNew-&gt;QueryInterface(IID_ILine, (void FAR* FAR*)&amp;pLine); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_LineFromOtherInstance, IID_ILines); <br>     <br>    // Add end points of line to the pane's point collection     <br>    if (FALSE == pLine-&gt;AddEndPointsToPane(m_pPane))      <br>        {hr = RaiseException(IDS_CantAddEndPoints, IID_ILines); goto error;}   <br>     <br>    // Add new line to collection <br>    l = m_lLBound+m_cElements;  <br>    VariantInit(&amp;v); <br>    V_VT(&amp;v) = VT_DISPATCH; <br>    V_DISPATCH(&amp;v) = pLineNew;     <br>    hr = SafeArrayPutElement(m_psa, &amp;l, &amp;v); <br>    if (FAILED(hr)) <br>        {hr = RaiseException(IDS_Unexpected, IID_ILines); goto error;}   <br>    m_cElements++;    <br>     <br>    // Draw the new line <br>    hdc = m_pPane-&gt;GetDC();     <br>    pLine-&gt;Draw(hdc); <br>    m_pPane-&gt;ReleaseDC(hdc);   <br>     <br>    pLine-&gt;Release();                     <br>    return NOERROR;     <br>     <br>error:   <br>    if (pLine) <br>        pLine-&gt;Release();       <br>    return hr;    <br>} <br> <br>/* <br> * CLines::get_Count <br> * <br> * Purpose: <br> *  Returns number of items in collection. <br> * <br> */ <br>STDMETHODIMP     <br>CLines::get_Count(long FAR* lCount)   <br>{ <br>    *lCount = m_cElements; <br>    return NOERROR;              <br>} <br> <br>/* <br> * CLines::get_Item <br> * <br> * Purpose: <br> *  Retrieves item from collection, given an index.  <br> * <br> * Parameters:    <br> *   lIndex   Index of item to be retrieved.  <br> *   ppLine   Returns IDispatch of item retrieved from collection. <br> * <br> */ <br>STDMETHODIMP <br>CLines::get_Item(long lIndex, ILine FAR* FAR* ppLine) <br>{  <br>    HRESULT hr;                                             <br>    VARIANT v; <br>    <br>    // Check if index is within range          <br>    if (lIndex &lt; m_lLBound || lIndex &gt;= (long)(m_lLBound+m_cElements))  <br>        return RaiseException(IDS_InvalidIndex, IID_ILines);  <br>     <br>    // Retrieve and return item. Note that SafeArrayGetElement AddRefs, so an additional AddRef <br>    // is not required. <br>    VariantInit(&amp;v); <br>    hr = SafeArrayGetElement(m_psa, &amp;lIndex, &amp;v); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_ILines); <br>    *ppLine = (ILine FAR*) V_DISPATCH(&amp;v);   <br>    return NOERROR; <br>} <br> <br>/* <br> * CLines::get_NewEnum <br> * <br> * Purpose: <br> *  Returns an enumerator (IEnumVARIANT) for the items curently in the collection.  <br> *  The NewEnum property is restricted and so is invisible to users of an  <br> *  automation controller's scripting language. Automation controllers that support <br> *  a 'For Each' statement to iterate through the elements of a collection will use <br> *  the enumerator returned by NewEnum. The enumerator creates a snapshot of the <br> *  the current state of the collection. <br> * <br> */ <br>STDMETHODIMP <br>CLines::get__NewEnum(IUnknown FAR* FAR* ppunkEnum) <br>{ <br>    CEnumVariant FAR* penum = NULL;; <br>    HRESULT hr; <br>     <br>    *ppunkEnum = NULL; <br>     <br>    // Create new enumerator for items currently in collection and QI for IUnknown <br>    hr = CEnumVariant::Create(m_psa, m_cElements, &amp;penum); <br>    if (FAILED(hr)) <br>        {hr = RaiseException(IDS_OutOfMemory, IID_ILines); goto error;}         <br>    hr = penum-&gt;QueryInterface(IID_IUnknown, (VOID FAR* FAR*)ppunkEnum);     <br>    if (FAILED(hr))  <br>        {hr = RaiseException(IDS_Unexpected, IID_ILines); goto error;}   <br>    return NOERROR;  <br>     <br>error: <br>    if (penum) <br>        delete penum;    <br>    return hr;               <br>} <br> <br>/* <br> * CLines::Remove <br> * <br> * Purpose: <br> *  Removes specified item from collection.  <br> * <br> * Parameters:    <br> *   lIndex   Index of item to be removed.  <br> * <br> */ <br>STDMETHODIMP <br>CLines::Remove(long lIndex) <br>{ <br>    HRESULT hr; <br>    long l; <br>    VARIANT HUGEP *pvar; <br>    CLine FAR* pLine = NULL;   <br>    RECT rc; <br>     <br>    // Check if integer index is within range.  <br>    if (lIndex &lt; m_lLBound || lIndex &gt;= (long)(m_lLBound+m_cElements)) <br>        return RaiseException(IDS_InvalidIndex, IID_ILines);     <br> <br>    hr = SafeArrayAccessData(m_psa, (void HUGEP* FAR*)&amp;pvar); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_ILines);  <br>    V_DISPATCH(&amp;pvar[lIndex-m_lLBound])-&gt;QueryInterface(IID_ILine, (void FAR* FAR*)&amp;pLine);          <br>      <br>    // Ask the pane to invalidate the area where the line is drawn. <br>    pLine-&gt;GetInvalidateRect(&amp;rc); <br>    m_pPane-&gt;InvalidateRect(&amp;rc); <br>     <br>    // Remove end points of line from the pane's point collection.    <br>    pLine-&gt;RemoveEndPointsFromPane(m_pPane);     <br>    // Remove Line   <br>    V_DISPATCH(&amp;pvar[lIndex-m_lLBound])-&gt;Release();     <br>    // Move up the array elements, after the element to be removed.         <br>    for (l=lIndex-m_lLBound; l&lt;(long)(m_cElements-1); l++)   <br>        pvar[l] = pvar[l+1];     <br>    // Remove last element.     <br>    V_VT(&amp;pvar[l]) = VT_EMPTY; <br>     <br>    pLine-&gt;Release();         <br>    hr = SafeArrayUnaccessData(m_psa); <br>    if (FAILED(hr)) <br>       return RaiseException(IDS_Unexpected, IID_ILines);  <br>        <br>    m_cElements--;   <br>    m_pPane-&gt;Update();     // Ask the pane to repaint invalidated areas caused by removal of line. <br>    return NOERROR; <br>} <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */   <br>  <br>/* <br> * CLines::Draw <br> * <br> * Purpose: <br> *  Draws all lines in collection. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CLines::Draw(HDC hdc) <br>{ <br>    HRESULT hr; <br>    long l; <br>    CLine FAR* pLine = NULL; <br>    VARIANT HUGEP *pvar; <br>     <br>    // Draw each line in the Lines collection <br>    hr = SafeArrayAccessData(m_psa, (void HUGEP* FAR*)&amp;pvar); <br>    if (FAILED(hr)) <br>       return;            <br>    for (l=0; l&lt;(long)m_cElements; l++) <br>    {         <br>        hr = V_DISPATCH(&amp;pvar[l])-&gt;QueryInterface(IID_ILine, (void FAR* FAR*)&amp;pLine); <br>        if (FAILED(hr)) <br>            continue;           <br>        pLine-&gt;Draw(hdc); <br>        pLine-&gt;Release();         <br>    }    <br>    hr = SafeArrayUnaccessData(m_psa); <br>    if (FAILED(hr)) <br>        return; <br>    return; <br>} <br> <br>/* <br> * CLines::Clear <br> * <br> * Purpose: <br> *  Removes all items from collection. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CLines::Clear(void) <br>{ <br>    SafeArrayDestroyData(m_psa);    <br>    SafeArrayAllocData(m_psa); <br>    m_cElements = 0; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
