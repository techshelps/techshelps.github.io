<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>APP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1435"></a>APP.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Lines Object. <br>** <br>**  app.cpp <br>** <br>**  CApplication implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif  <br>#include "lines.h"   <br> <br>/* <br> * CApplication::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Application automation object and initializes it. <br> * <br> * Parameters:        <br> *  hinst            HINSTANCE of application. <br> *  ppApplication    Returns Application automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT <br>CApplication::Create(HINSTANCE hinst, CApplication FAR* FAR* ppApplication )  <br>{    <br>    TCHAR ach[STR_LEN];    <br>    TCHAR achFullName[260]; <br>    HRESULT hr; <br>    CApplication FAR* pApplication = NULL;   <br>    HWND hwnd; <br>      <br>    *ppApplication = NULL; <br>     <br>    // Create application object. <br>    pApplication = new CApplication(); <br>    if (pApplication == NULL) <br>    { <br>        hr = E_OUTOFMEMORY;  <br>        goto error; <br>    } <br>     <br>    LoadString(hinst, IDS_Name, ach, sizeof(ach)); <br>    hwnd = CreateWindow(TEXT("MainWndClass"), ach, <br>                       WS_OVERLAPPEDWINDOW, <br>                       CW_USEDEFAULT, CW_USEDEFAULT, <br>                       650, 650, <br>                       NULL, NULL, hinst, NULL); <br>    if (!hwnd) <br>    { <br>       hr = E_OUTOFMEMORY;   <br>       goto error; <br>    }   <br>    pApplication-&gt;m_hwnd = hwnd; <br>    pApplication-&gt;m_hinst = hinst; <br>     <br>    // Set name and fullname of application.   <br>    pApplication-&gt;m_bstrName = SysAllocString(TO_OLE_STRING(ach)); <br>    if (NULL == pApplication-&gt;m_bstrName) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }  <br>    GetModuleFileName(hinst, achFullName, sizeof(achFullName)); <br>    pApplication-&gt;m_bstrFullName = SysAllocString(TO_OLE_STRING(achFullName)); <br>    if (NULL == pApplication-&gt;m_bstrFullName) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    } <br>    // ProgID  <br>    LoadString(hinst, IDS_ProgID, ach, sizeof(ach));   <br>    pApplication-&gt;m_bstrProgID = SysAllocString(TO_OLE_STRING(ach)); <br>    if (NULL == pApplication-&gt;m_bstrProgID) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }       <br>     <br>    // Load type information for the application object from type library. <br>    // If required, notify user on failure.  <br>    hr = LoadTypeInfo(&amp;pApplication-&gt;m_ptinfo, IID_IApplication); <br>    if (FAILED(hr))  <br>    {        <br>        LoadString(hinst, IDS_ErrorLoadingTypeLib, ach, sizeof(ach)); <br>        MessageBox(NULL, ach, FROM_OLE_STRING(pApplication-&gt;m_bstrName), MB_OK); <br>        goto error; <br>    } <br>         <br>    // Create Pane     <br>    hr = CPane::Create(hwnd, &amp;pApplication-&gt;m_pPane); <br>    if (FAILED(hr)) <br>       goto error;     <br>    pApplication-&gt;m_pPane-&gt;AddRef();     <br> <br>    *ppApplication = pApplication; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pApplication == NULL) <br>        return E_OUTOFMEMORY;  <br>     <br>    if (pApplication-&gt;m_bstrFullName) <br>        SysFreeString(pApplication-&gt;m_bstrFullName);   <br>    if (pApplication-&gt;m_bstrName) <br>        SysFreeString(pApplication-&gt;m_bstrName); <br>    if (pApplication-&gt;m_bstrProgID)  <br>        SysFreeString(pApplication-&gt;m_bstrProgID);                        <br>    if (pApplication-&gt;m_ptinfo) <br>        pApplication-&gt;m_ptinfo-&gt;Release();         <br>    if (pApplication-&gt;m_pPane) <br>        pApplication-&gt;m_pPane-&gt;Release(); <br>     <br>    // Set to NULL to prevent destructor from attempting to free again <br>    pApplication-&gt;m_bstrFullName = NULL; <br>    pApplication-&gt;m_bstrName = NULL; <br>        pApplication-&gt;m_bstrProgID = NULL; <br>    pApplication-&gt;m_ptinfo = NULL; <br>    pApplication-&gt;m_pPane = NULL; <br>     <br>    delete pApplication; <br>    return hr; <br>} <br> <br>/* <br> * CApplication::CApplication <br> * <br> * Purpose: <br> *  Constructor for CApplication object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CApplication::CApplication() : m_SupportErrorInfo(this, IID_IApplication) <br>#pragma warning (default : 4355) <br>{    <br>    extern ULONG g_cObj; <br>      <br>    m_hwnd = NULL; <br>    m_bstrFullName = NULL; <br>    m_bstrName = NULL; <br>    m_bstrProgID = NULL; <br>    m_ptinfo = NULL; <br>    m_pPane = NULL; <br>    m_cRef = 0;    <br>    m_bVisible = 0; <br>    m_bUserClosing = FALSE; <br>} <br> <br>/* <br> * CApplication::~CApplication <br> * <br> * Purpose: <br> *  Destructor for CApplication object. Frees Application message BSTR and default <br> *  IDispatch implementation. Closes the aplication. <br> * <br> */ <br>CApplication::~CApplication() <br>{  <br>     extern ULONG g_cObj; <br>      <br>     if (m_bstrFullName) SysFreeString(m_bstrFullName); <br>     if (m_bstrName) SysFreeString(m_bstrName); <br>     if (m_bstrProgID) SysFreeString(m_bstrProgID);           <br>     if (m_ptinfo) m_ptinfo-&gt;Release();   <br>     if (m_pPane) m_pPane-&gt;Release(); <br>     if (!m_bUserClosing &amp;&amp; IsWindow(m_hwnd)) DestroyWindow(m_hwnd);      <br>} <br> <br>/* <br> * CApplication::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CApplication::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>     <br>    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IApplication) <br>        *ppv = this;  <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CApplication::AddRef(void) <br>{     <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, App\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br> <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CApplication::Release(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, App\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>     <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>/* <br> * CApplication::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CApplication::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CApplication::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CApplication::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CApplication::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CApplication::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CApplication::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP <br>CApplication::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>   return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);    <br>} <br> <br>/* <br> * CApplication::get_Application, get_FullName, get_Name, get_Parent, get_Visible, put_Visible, Quit  <br> * <br> * Purpose: <br> *  Implements the standard Application, FullName, Name, Parent &amp; Visible properties <br> *  and the Quit method.  <br> * <br> */ <br>STDMETHODIMP <br>CApplication::get_Application(IApplication FAR* FAR* ppApplication) <br>{ <br>    HRESULT hr; <br>     <br>    hr = QueryInterface(IID_IDispatch, (void FAR* FAR*)ppApplication);  <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IApplication);  <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CApplication::get_FullName(BSTR FAR* pbstr) <br>{ <br>    *pbstr = SysAllocString(m_bstrFullName);    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CApplication::get_Name(BSTR FAR* pbstr) <br>{ <br>    *pbstr = SysAllocString(m_bstrName);  <br>    return NOERROR;  <br>} <br> <br>STDMETHODIMP <br>CApplication::get_Parent(IApplication FAR* FAR* ppApplication)       <br>{ <br>    HRESULT hr; <br>     <br>    hr = QueryInterface(IID_IDispatch, (void FAR* FAR*)ppApplication);  <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IApplication);  <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CApplication::put_Visible(VARIANT_BOOL bVisible) <br>{ <br>    ShowWindow(bVisible ? SW_SHOW : SW_HIDE);   <br>    return NOERROR; <br>}  <br> <br>STDMETHODIMP <br>CApplication::get_Visible(VARIANT_BOOL FAR* pbVisible) <br>{ <br>    *pbVisible = m_bVisible;      <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CApplication::Quit() <br>{ <br>    // CoDisconnectObject has no effect for an inproc server.  So the controller <br>    // will GP fault if it attempts to access the object (including calling IUnknown::Release()) <br>    // after Quit has been called. For a local server, CoDisconnectObject will disconnect <br>    // the object from external connections. So the controller will get an RPC error if <br>    // it access the object after calling Quit. The controller will not GP fault in this case.  <br>    CoDisconnectObject((LPUNKNOWN)this, 0);   <br>    PostMessage(m_hwnd, WM_CLOSE, 0, 0L); <br>    return NOERROR;                                      <br>}  <br> <br>/* <br> * CApplication::get_Pane <br> * <br> * Purpose: <br> *  Returns pane object. <br> * <br> */       <br>STDMETHODIMP <br>CApplication::get_Pane(IPane FAR* FAR* ppPane) <br>{ <br>    HRESULT hr; <br>     <br>    hr = m_pPane-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPane);  <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IApplication);  <br>    return NOERROR; <br>} <br> <br>/* <br> * CApplication::CreateLine <br> * <br> * Purpose: <br> *  Returns a newly created line object with no start or end point. <br> * <br> */   <br>STDMETHODIMP <br>CApplication::CreateLine(ILine FAR* FAR* ppLine) <br>{ <br>    CLine FAR* pline = NULL; <br>    HRESULT hr; <br>     <br>    // Create new item and QI for IDispatch    <br>    hr = CLine::Create(&amp;pline); <br>    if (FAILED(hr))  <br>        {hr = RaiseException(IDS_OutOfMemory, IID_IApplication); goto error;}  <br>               <br>    hr = pline-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppLine);  <br>    if (FAILED(hr))  <br>        {hr = RaiseException(IDS_Unexpected, IID_IApplication); goto error;} <br>    return NOERROR; <br>     <br>error:  <br>    if (pline) <br>        delete pline;        <br>    return hr;      <br>} <br> <br>/* <br> * CApplication::CreateLine <br> * <br> * Purpose: <br> *  Returns a newly created point object intialized to (0,0). <br> * <br> */  <br>STDMETHODIMP <br>CApplication::CreatePoint(IPoint FAR* FAR* ppPoint) <br>{ <br>    CPoint FAR* ppoint = NULL; <br>    HRESULT hr; <br>     <br>    // Create new item and QI for IDispatch    <br>    hr = CPoint::Create(&amp;ppoint); <br>    if (FAILED(hr)) <br>        {hr = RaiseException(IDS_OutOfMemory, IID_IApplication); goto error;}           <br>         <br>    hr = ppoint-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPoint);  <br>    if (FAILED(hr)) <br>        {hr = RaiseException(IDS_Unexpected, IID_IApplication); goto error;} <br>    return NOERROR; <br>     <br>error:  <br>    if (ppoint) <br>        delete ppoint;         <br>    return hr;      <br>}    <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */ <br> <br>STDMETHODIMP_(void) <br>CApplication::Draw() <br>{ <br>   m_pPane-&gt;Draw(); <br>} <br> <br>/* <br> * CApplication::OnSize <br> * <br> * Purpose: <br> *  Called when application window receives WM_SIZE. <br> * <br> */  <br>STDMETHODIMP_(void) <br>CApplication::OnSize(unsigned int nWidth, unsigned int nHeight)  <br>{ <br>   m_pPane-&gt;OnSize(nWidth, nHeight); <br>}  <br> <br>STDMETHODIMP_(void) <br>CApplication::ShowWindow(int nCmdShow) <br>{    <br>    // Return if curently hidden and asked to hide or currently visible <br>    // and asked to show. <br>    if ((!m_bVisible &amp;&amp; nCmdShow == SW_HIDE) || (m_bVisible &amp;&amp; nCmdShow != SW_HIDE)) <br>        return;  <br>     <br>    m_bVisible = (nCmdShow == SW_HIDE) ? FALSE : TRUE; <br>     <br>    // The Automation object shutdown behavior is as follows: <br>    // 1. If the object application is visible, it shuts down only in response to an <br>    // explicit user command (File/Exit) or it's programmatic equivalent (for example <br>    // the Quit method of the Application object). <br>    // 2. If the object application is not visible, it goes away when it's last <br>    // object is released.    <br>    //    <br>    // CoLockObjectExternal can be used to increment the ref count of the application object <br>    // when it is visible. This will implement shutdown behavior 1. When the application <br>    // goes invisible, CoLockObjectExternal is used to decrement the ref count. This will <br>    // implement shutdown behavior 2. <br>     <br>    if (m_bVisible) <br>        CoLockObjectExternal(this, TRUE /*fLock*/, TRUE/*ignored when fLock==TRUE*/); <br>    else CoLockObjectExternal(this, FALSE/*fLock*/, TRUE/*fLastLockReleases*/);   <br>    ::ShowWindow (m_hwnd, nCmdShow); <br>} <br> <br>STDMETHODIMP_(void) <br>CApplication::CreateAndDrawLine() <br>{    <br>    LINEINFO lineinfo; <br>    CLine FAR* pLine = NULL; <br>    CPoint FAR* pPointStart = NULL; <br>    CPoint FAR* pPointEnd = NULL;  <br>    ILines FAR* pLines = NULL;  <br>    int nRet;      <br>    HRESULT hr; <br>                   <br>    nRet = DialogBoxParam(m_hinst, MAKEINTRESOURCE(IDD_DRAWLINE), m_hwnd,  <br>                      (DLGPROC)DrawLineDialogFunc, (LPARAM)(LPLINEINFO)&amp;lineinfo);     <br>    if (nRet != IDOK)  <br>        return; <br>    hr = CLine::Create(&amp;pLine); <br>    if (FAILED(hr))   <br>        goto error; <br>    hr = CPoint::Create(&amp;pPointStart); <br>    if (FAILED(hr))  <br>        goto error;  <br>    hr = CPoint::Create(&amp;pPointEnd); <br>    if (FAILED(hr)) <br>        goto error; <br> <br>    pPointStart-&gt;put_x(lineinfo.ptStart.x); <br>    pPointStart-&gt;put_y(lineinfo.ptStart.y);  <br>    pPointEnd-&gt;put_x(lineinfo.ptEnd.x); <br>    pPointEnd-&gt;put_y(lineinfo.ptEnd.y);    <br> <br>    pLine-&gt;putref_StartPoint(pPointStart);   <br>    pLine-&gt;putref_EndPoint(pPointEnd);   <br>    pLine-&gt;put_Thickness(lineinfo.nThickness); <br>    pLine-&gt;put_Color(lineinfo.colorref); <br>     <br>    hr = m_pPane-&gt;get_Lines(&amp;pLines);  <br>    if (FAILED(hr))  <br>        goto error;  <br>    hr = pLines-&gt;Add(pLine);  <br>    if (FAILED(hr))  <br>        goto error;   <br>    pLines-&gt;Release(); <br>    return; <br> <br>error: <br>    if (pLine) delete pLine; <br>    if (pPointStart) delete pPointStart; <br>    if (pPointEnd) delete pPointEnd;  <br>    if (pLines) pLines-&gt;Release();    <br>    MessageBox(m_hwnd, TEXT("Cannot create Line"), FROM_OLE_STRING(m_bstrName), MB_OK); <br>} <br> <br>STDMETHODIMP_(void) <br>CApplication::ClearPane()   <br>{ <br>    m_pPane-&gt;Clear(); <br>}   <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
