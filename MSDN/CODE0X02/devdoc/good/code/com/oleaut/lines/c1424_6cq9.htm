<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1431"></a>MAIN.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Lines Object. <br>** <br>**  main.cpp <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt; <br>  #include &lt;commdlg.h&gt;   <br>#endif   <br>#include &lt;initguid.h&gt; <br>#include "lines.h"         <br> <br>// Globals   <br>CApplication FAR* g_pApplication; <br>  <br>SCODE g_scodes[SCODE_COUNT] =                // Array of SCODEs for easy lookup <br>{    LINES_E_UNEXPECTED, <br>     LINES_E_OUTOFMEMORY, <br>     LINES_E_INVALIDINDEX, <br>     LINES_E_COLLECTIONFULL, <br>     LINES_E_LINEFROMOTHERINSTANCE, <br>     LINES_E_CANTADDENDPOINTS, <br>     LINES_E_POINTFROMOTHERINSTANCE, <br>     LINES_E_NOVISIBLEXCOORDINATE, <br>     LINES_E_NOVISIBLEYCOORDINATE, <br>     LINES_E_NOSTARTPOINT, <br>     LINES_E_NOENDPOINT <br>}; <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  <br> * <br> */ <br>int APIENTRY WinMain (HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR pCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    DWORD dwRegisterCF;      <br>    DWORD dwRegisterActiveObject; <br> <br>#ifdef WIN16 <br>   //  It is recommended that all 16 bit OLE applications set <br>   //  their message queue size to 96. This improves the capacity <br>   //  and performance of OLE's LRPC mechanism. <br>   int cMsg = 96;                  // Recommend msg queue size for OLE <br>   while (cMsg &amp;&amp; !SetMessageQueue(cMsg))  // take largest size we can get. <br>       cMsg -= 8; <br>   if (!cMsg) <br>       return -1;  // ERROR: we got no message queue        <br>#endif <br>    <br>    if (!hinstPrev) <br>       if (!InitApplication(hinst)) // Register window class         <br>          return FALSE; <br>     <br>    if (!InitInstance(hinst))   // Initialize OLE and create Lines application object <br>        return (FALSE);     <br>     <br>    // Determine if /Automation was specified in command line and register class <br>    // factory and active object. Show window if application was started stand alone. <br>    if (!ProcessCmdLine(pCmdLine, &amp;dwRegisterCF, &amp;dwRegisterActiveObject, nCmdShow))    <br>    { <br>       Uninitialize(dwRegisterCF, dwRegisterActiveObject);    <br>       return (FALSE);     <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>       TranslateMessage(&amp;msg); <br>       DispatchMessage(&amp;msg); <br>    } <br>    <br>    Uninitialize(dwRegisterCF, dwRegisterActiveObject);    <br>    return (msg.wParam);  <br>} <br> <br>/* <br> * InitApplication <br> * <br> * Purpose: <br> *  Registers window class <br> * <br> * Parameters: <br> *  hinst       hInstance of application <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitApplication (HINSTANCE hinst) <br>{ <br>   WNDCLASS wc; <br>    <br>   wc.style = CS_DBLCLKS | CS_HREDRAW | CS_VREDRAW; <br>   wc.lpfnWndProc = MainWndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = 0; <br>   wc.hInstance = hinst; <br>   wc.hIcon = LoadIcon(hinst, MAKEINTRESOURCE(IDI_ICON)); <br>   wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>   wc.lpszMenuName = TEXT("AppMenu"); <br>   wc.lpszClassName = TEXT("MainWndClass");  <br>      <br>   return RegisterClass(&amp;wc);         <br>} <br> <br>/* <br> * InitInstance <br> * <br> * Purpose: <br> *  Intializes OLE and creates Lines Application object <br> * <br> * Parameters: <br> *  hinst           hInstance of application <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitInstance (HINSTANCE hinst) <br>{   <br>    HRESULT hr; <br>     <br>    // Intialize OLE <br>    hr = OleInitialize(NULL); <br>    if (FAILED(hr)) <br>       return FALSE;  <br>     <br>    // Create an instance of the Lines Application object. Object is <br>    // created with refcount 0. <br>    hr = CApplication::Create(hinst, &amp;g_pApplication);        <br>    if (FAILED(hr)) <br>        return FALSE; <br>    return TRUE;           <br>} <br> <br>/* <br> * ProcessCmdLine <br> * <br> * Purpose: <br> *  Check if command line contains /Automation. If so, the class factory of the  <br> *  application object is registered.  If not, the application was started stand-alone and <br> *  so the window is shown. The application object is registered using RegisterActiveObject. <br> * <br> * Parameters: <br> *  pCmdLine       Command line passed to application <br> *  pdwRegisterCF   Returns id returned after class factory registration. Can be used to  <br> *                  revoke class factory registration.  <br> *  pdwRegisterActiveObject   Returns id returned after active object registration. Can be used to  <br> *                  revoke active object registration.    <br> *  nCmdShow        Specifies how window is to be shown if application was started stand alone. <br> * <br> * Return Value: <br> *    TRUE if OLE initialization succeeded, FALSE otherwise. <br> * <br> */ <br>BOOL ProcessCmdLine(LPSTR pCmdLine, LPDWORD pdwRegisterCF, LPDWORD pdwRegisterActiveObject, int nCmdShow) <br>{ <br>   LPCLASSFACTORY pcf = NULL; <br>   HRESULT hr; <br>    <br>   *pdwRegisterCF = 0;      <br>   *pdwRegisterActiveObject = 0; <br>    <br>   // Expose class factory for application object if command line contains the  <br>   // Automation switch        <br>   if (_fstrstr(pCmdLine, "-Automation") != NULL <br>       || _fstrstr(pCmdLine, "/Automation") != NULL) <br>   { <br>       pcf = new CApplicationCF; <br>       if (!pcf) <br>           goto error;   <br>       pcf-&gt;AddRef();            <br>       hr = CoRegisterClassObject(CLSID_Lines, pcf, <br>                                     CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, <br>                                     pdwRegisterCF); <br>       if (hr != NOERROR) <br>           goto error;            <br>       pcf-&gt;Release(); <br>   }   <br>   else g_pApplication-&gt;ShowWindow(nCmdShow);    // Show window if started stand-alone        <br>    <br>   // Register Lines application object in the Running Object Table (ROT). This  <br>   // allows controllers to connect to a running application object instead of creating <br>   // a new instance. Use weak registration so that the ROT releases it's reference when  <br>   // all external references are released. If strong registration is used, the ROT will not <br>   // release it's reference until RevokeActiveObject is called and so will keep <br>   // the object alive even after all external references have been released. <br>   RegisterActiveObject(g_pApplication, CLSID_Lines, ACTIVEOBJECT_WEAK, pdwRegisterActiveObject); <br>   return TRUE;            <br>            <br>error: <br>    if (pcf) <br>        pcf-&gt;Release(); <br>    return FALSE; <br>} <br> <br>/* <br> * Uninitialize <br> * <br> *  Purpose: <br> *   Revoke class factory and active object registration and uninitialize OLE. <br> * <br> * Parameters: <br> *  dwRegisterCF ID returned after class factory registration.  <br> *  dwRegisterActiveObject ID returned after active object registration. <br> * <br> */ <br>void Uninitialize(DWORD dwRegisterCF, DWORD dwRegisterActiveObject) <br>{ <br>    if (dwRegisterCF != 0) <br>        CoRevokeClassObject(dwRegisterCF); <br>    if (dwRegisterActiveObject != 0) <br>        RevokeActiveObject(dwRegisterActiveObject, NULL);    <br>    OleUninitialize(); <br>} <br> <br>/* <br> * MainWndProc <br> * <br> * Purpose: <br> *  Window procedure for main window <br> * <br> */ <br>LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{      <br>   switch (msg) <br>   {            <br>      case WM_PAINT:           <br>          g_pApplication-&gt;Draw();             <br>          break; <br>       <br>      case WM_SIZE: <br>          g_pApplication-&gt;OnSize(LOWORD(lParam), HIWORD(lParam));         <br>          break;  <br>           <br>      case WM_COMMAND: <br>      {    <br>          switch(GET_WM_COMMAND_ID(wParam,lParam)) <br>          { <br>              case IDM_DRAWLINE: <br>                  g_pApplication-&gt;CreateAndDrawLine(); <br>                  break; <br>                   <br>              case IDM_CLEAR: <br>                  g_pApplication-&gt;ClearPane();               <br>                  break; <br>                   <br>              case IDM_EXIT:  <br>                  PostMessage(hwnd, WM_CLOSE, 0, 0L); <br>                  break;  <br>          }               <br>      } <br>      break; <br>           <br>      case WM_CLOSE:  <br>         // Hide the window to release the refcount added by CoLockObjectExternal <br>         // (See CLines::ShowWindow) <br>         g_pApplication-&gt;m_bUserClosing = TRUE; <br>         g_pApplication-&gt;ShowWindow(SW_HIDE);  <br>         DestroyWindow(hwnd); <br>         return 0L; <br>       <br>      case WM_DESTROY:             <br>         PostQuitMessage(0); <br>         break; <br>       <br>      default:                          <br>         return DefWindowProc(hwnd, msg, wParam, lParam); <br>   } <br>    <br>   return NULL; <br>}  <br> <br>/* <br> * DrawLineDialogFunc <br> * <br> * Purpose: <br> *  Dialog function of DrawLine dialog. Prompts user and returns information to draw a line. <br> * <br> */  <br>BOOL CALLBACK DrawLineDialogFunc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static LPLINEINFO plineinfo;       <br>   BOOL b;   <br>   CHOOSECOLOR cc;      <br>   COLORREF clrCustom[16]; <br>   int n; <br>    <br>   switch (msg) <br>   { <br>      case WM_INITDIALOG: <br>         plineinfo = (LPLINEINFO)lParam;    <br>         // Initialize edit controls. Units are twips. <br>         SetDlgItemText(hwndDlg, IDC_STARTPOINT_X, TEXT("4500")); <br>         SetDlgItemText(hwndDlg, IDC_STARTPOINT_Y, TEXT("4500")); <br>         SetDlgItemText(hwndDlg, IDC_ENDPOINT_X, TEXT("8000")); <br>         SetDlgItemText(hwndDlg, IDC_ENDPOINT_Y, TEXT("8000")); <br>         SetDlgItemText(hwndDlg, IDC_THICKNESS, TEXT("100")); <br>         plineinfo-&gt;colorref = 0;  <br>         return TRUE; <br> <br>      case WM_COMMAND: <br>         switch(GET_WM_COMMAND_ID(wParam,lParam)) <br>         { <br>             case IDOK: <br>                 plineinfo-&gt;ptStart.x = GetDlgItemInt(hwndDlg, IDC_STARTPOINT_X, &amp;b, TRUE);  <br>                 plineinfo-&gt;ptStart.y = GetDlgItemInt(hwndDlg, IDC_STARTPOINT_Y, &amp;b, TRUE); <br>                 plineinfo-&gt;ptEnd.x = GetDlgItemInt(hwndDlg, IDC_ENDPOINT_X, &amp;b, TRUE); <br>                 plineinfo-&gt;ptEnd.y = GetDlgItemInt(hwndDlg, IDC_ENDPOINT_Y, &amp;b, TRUE); <br>                 plineinfo-&gt;nThickness = GetDlgItemInt(hwndDlg, IDC_THICKNESS, &amp;b, TRUE);         <br>                 EndDialog(hwndDlg, IDOK); <br>                 return TRUE; <br>                  <br>             case IDCANCEL: <br>                 EndDialog(hwndDlg, IDCANCEL); <br>                 return TRUE; <br>                  <br>             case IDC_CHOOSECOLOR:     <br>                 memset(&amp;cc, 0, sizeof(CHOOSECOLOR));  <br>                 cc.lStructSize = sizeof(CHOOSECOLOR);  <br>                 cc.hwndOwner = hwndDlg; <br>                 cc.rgbResult = RGB(0, 0, 0); <br>                 cc.Flags = CC_RGBINIT;   <br>                 for (n=0; n&lt;16; n++) <br>                    clrCustom[n] = RGB(255, 255, 255); <br>                 cc.lpCustColors = clrCustom; <br>                 if (ChooseColor(&amp;cc)) <br>                     plineinfo-&gt;colorref = cc.rgbResult;                                                                <br>         } <br>         break; <br>   } <br>   return FALSE; <br>} <br> <br>/* <br> * LoadTypeInfo <br> * <br> *  Purpose: <br> *   Gets type information of an object's interface from type library. <br> * <br> * Parameters: <br> *  ppunkStdDispatch    Returns type information. <br> *  clsid               Interface id of object in type library.  <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT LoadTypeInfo(ITypeInfo FAR* FAR* pptinfo, REFCLSID clsid) <br>{                           <br>    HRESULT hr; <br>    LPTYPELIB ptlib = NULL; <br>    LPTYPEINFO ptinfo = NULL; <br> <br>    *pptinfo = NULL;      <br>     <br>    // Load Type Library.  <br>    hr = LoadRegTypeLib(LIBID_Lines, 1, 0, 0x09, &amp;ptlib); <br>    if (FAILED(hr))  <br>    {    <br>        // if it wasn't registered, try to load it from the path <br>        // if this succeeds, it will have registered the type library for us <br>        // for the next time.   <br>        hr = LoadTypeLib(OLESTR("lines.tlb"), &amp;ptlib);  <br>        if(FAILED(hr))         <br>            return hr;    <br>    } <br>     <br>    // Get type information for interface of the object.       <br>    hr = ptlib-&gt;GetTypeInfoOfGuid(clsid, &amp;ptinfo); <br>    if (FAILED(hr))   <br>    {  <br>        ptlib-&gt;Release(); <br>        return hr; <br>    }    <br> <br>    ptlib-&gt;Release(); <br>    *pptinfo = ptinfo; <br>    return NOERROR; <br>} <br> <br>/* <br> * RaiseException <br> * <br> * Parameters: <br> *  nID                 Error number <br> *  rguid               GUID of interface that is raising the exception. <br> * <br> * Return Value: <br> *  HRESULT correspnding to the nID error number. <br> * <br> * Purpose: <br> *  Fills the EXCEPINFO structure.  <br> *  Sets ErrorInfo object for vtable-binding controllers. <br> *  For id-binding and late binding controllers DispInvoke <br> *  will return DISP_E_EXCEPTION and fill the EXCEPINFO parameter <br> *  with the error information set by SetErrorInfo. <br> * <br> */   <br>HRESULT RaiseException(int nID, REFGUID rguid) <br>{    <br>    extern SCODE g_scodes[]; <br>    TCHAR szError[STR_LEN];    <br>    ICreateErrorInfo *pcerrinfo;   <br>    IErrorInfo *perrinfo; <br>    HRESULT hr; <br>    BSTR bstrDescription = NULL; <br>     <br>    if (LoadString(g_pApplication-&gt;m_hinst, nID, szError, sizeof(szError))) <br>        bstrDescription = SysAllocString(TO_OLE_STRING(szError));     <br>     <br>    // Set ErrorInfo object so that vtable binding controller can get <br>    // rich error information. If the controller is using IDispatch <br>    // to access properties or methods, DispInvoke will fill the <br>    // EXCEPINFO structure using the values specified in the ErrorInfo <br>    // object and DispInvoke will return DISP_E_EXCEPTION. The property <br>    // or method must return a failure SCODE for DispInvoke to do this. <br>    hr = CreateErrorInfo(&amp;pcerrinfo);  <br>    if (SUCCEEDED(hr)) <br>    { <br>       pcerrinfo-&gt;SetGUID(rguid); <br>       pcerrinfo-&gt;SetSource(g_pApplication-&gt;m_bstrProgID); <br>       if (bstrDescription) <br>           pcerrinfo-&gt;SetDescription(bstrDescription);   <br>       hr = pcerrinfo-&gt;QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &amp;perrinfo); <br>       if (SUCCEEDED(hr)) <br>       { <br>          SetErrorInfo(0, perrinfo); <br>          perrinfo-&gt;Release(); <br>       }   <br>       pcerrinfo-&gt;Release(); <br>    }   <br>     <br>    if (bstrDescription) <br>        SysFreeString(bstrDescription); <br>    return g_scodes[nID-1001]; <br>}  <br> <br> <br> <br>/* <br> * Quick &amp; Dirty ANSI/Unicode conversion routines. These routines use a static <br> * buffer of fixed size to hold the converted string. Consequently these <br> * routines are limited to strings of size STRCONVERT_MAXLEN. Also the same <br> * buffer is reused when the routine is called a second time. So make sure <br> * that the converted string is used before the conversion routine is called <br> * again <br> */ <br>#ifdef WIN32 <br> <br>#ifndef UNICODE <br>char* ConvertToAnsi(OLECHAR FAR* szW) <br>{ <br>  static char achA[STRCONVERT_MAXLEN];  <br>   <br>  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);   <br>  return achA;  <br>}  <br> <br>OLECHAR* ConvertToUnicode(char FAR* szA) <br>{ <br>  static OLECHAR achW[STRCONVERT_MAXLEN];  <br> <br>  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);   <br>  return achW;  <br>} <br>#endif <br> <br>#endif       <br>     <br> <br> <br>    <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
