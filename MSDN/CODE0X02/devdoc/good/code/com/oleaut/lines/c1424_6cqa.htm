<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PANE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1432"></a>PANE.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Lines Object. <br>** <br>**  pane.cpp <br>** <br>**  CPane implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif       <br>#include "lines.h"   <br> <br>/* <br> * CPane::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Pane automation object and initializes it. <br> * <br> * Parameters:   <br> *  hwnd      Handle of the window of the pane. <br> *  ppPane    Returns Pane automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CPane::Create(HWND hwnd, CPane FAR* FAR* ppPane )  <br>{    <br>    HRESULT hr; <br>    CPane FAR* pPane = NULL; <br>      <br>    *ppPane = NULL; <br>     <br>    pPane = new CPane(); <br>    if (pPane == NULL) <br>        goto error; <br>         <br>    pPane-&gt;m_hwnd = hwnd;         <br>     <br>    // Create an empty Lines collection of size 100 <br>    hr = CLines::Create(100, 1, pPane, &amp;pPane-&gt;m_pLines);     <br>    if (FAILED(hr)) <br>       goto error;     <br>    pPane-&gt;m_pLines-&gt;AddRef();   <br>     <br>    // Create an empty Points collection of size 200    <br>    hr = CPoints::Create(200, 1, pPane, &amp;pPane-&gt;m_pPoints);   <br>    if (FAILED(hr)) <br>       goto error;       <br>    pPane-&gt;m_pPoints-&gt;AddRef();  <br>     <br>    // Load type information for the pane object from type library.  <br>    hr = LoadTypeInfo(&amp;pPane-&gt;m_ptinfo, IID_IPane); <br>    if (FAILED(hr)) <br>        goto error; <br> <br>    *ppPane = pPane; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pPane == NULL) <br>        return E_OUTOFMEMORY;  <br>                     <br>    if (pPane-&gt;m_ptinfo) <br>        pPane-&gt;m_ptinfo-&gt;Release();         <br>    if (pPane-&gt;m_pLines) <br>        pPane-&gt;m_pLines-&gt;Release(); <br>    if (pPane-&gt;m_pPoints) <br>        pPane-&gt;m_pPoints-&gt;Release(); <br>     <br>    // Set to NULL to prevent destructor from attempting to free again <br>    pPane-&gt;m_ptinfo = NULL;  <br>    pPane-&gt;m_pLines = NULL; <br>    pPane-&gt;m_pPoints = NULL; <br>     <br>    delete pPane; <br>    return hr; <br>} <br> <br>/* <br> * CPane::CPane <br> * <br> * Purpose: <br> *  Constructor for CPane object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CPane::CPane() : m_SupportErrorInfo(this, IID_IPane) <br>#pragma warning (default : 4355) <br>{    <br>    m_cRef = 0; <br>    m_hwnd = NULL; <br>    m_ptinfo = NULL;   <br>    m_pLines = NULL; <br>    m_pPoints = NULL;   <br>    m_nMaxX = -1; <br>    m_nMaxY = -1; <br>} <br> <br>/* <br> * CPane::~CPane <br> * <br> * Purpose: <br> *  Destructor for CPane object.  <br> * <br> */ <br>CPane::~CPane() <br>{             <br>     if (m_ptinfo) m_ptinfo-&gt;Release();  <br>     if (m_pLines) m_pLines-&gt;Release(); <br>     if (m_pPoints) m_pPoints-&gt;Release();  <br>} <br> <br>/* <br> * CPane::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CPane::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>     <br>    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IPane) <br>        *ppv = this;  <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CPane::AddRef(void) <br>{    <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Pane\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif     <br> <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CPane::Release(void) <br>{   <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Pane\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>   <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>/* <br> * CPane::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CPane::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CPane::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CPane::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CPane::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CPane::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CPane::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP <br>CPane::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{         <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);  <br>} <br>  <br>/* <br> * CPane::get_Lines <br> * <br> * Purpose: <br> *  Returns the collection of all line objects in the drawing. <br> * <br> */ <br>STDMETHODIMP <br>CPane::get_Lines(ILines FAR* FAR* ppLines) <br>{ <br>    HRESULT hr; <br>     <br>    hr = m_pLines-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppLines);  <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IPane);  <br>    return NOERROR; <br>} <br> <br>/* <br> * CPane::get_Points <br> * <br> * Purpose: <br> *  Returns the collection of all point objects in the drawing. <br> * <br> */ <br>STDMETHODIMP <br>CPane::get_Points(IPoints FAR* FAR* ppPoints) <br>{ <br>    HRESULT hr; <br>     <br>    hr = m_pPoints-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)ppPoints);  <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IPane); <br>    return NOERROR; <br>} <br> <br>/* <br> * CPane::get_MaxX, get_MaxY <br> * <br> * Purpose: <br> *  Returns the maximum visible X &amp; Y coordinate values in twips. <br> * <br> */ <br>STDMETHODIMP <br>CPane::get_MaxX(int FAR* pnMaxX) <br>{    <br>     *pnMaxX = m_nMaxX;  <br>    if (m_nMaxX == -1) <br>        return RaiseException(IDS_NoVisibleXCoordinate, IID_IPane);     <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CPane::get_MaxY(int FAR* pnMaxY) <br>{    <br>    *pnMaxY = m_nMaxY;  <br>    if (m_nMaxY == -1) <br>        return RaiseException(IDS_NoVisibleYCoordinate, IID_IPane);    <br>    return NOERROR; <br>} <br> <br>/* <br> * CPane::Clear <br> * <br> * Purpose: <br> *  Removes all the Lines and Points from the drawing and refreshes the client area. <br> *  The result is a blank slate as if the application had just been launched. <br> * <br> */ <br>STDMETHODIMP <br>CPane::Clear() <br>{ <br>    m_pLines-&gt;Clear(); <br>    m_pPoints-&gt;Clear(); <br>    ::InvalidateRect(m_hwnd, NULL, TRUE); <br>    UpdateWindow(m_hwnd);   <br>    m_nMaxX = m_nMaxY = -1;   <br>    return NOERROR;     <br>} <br> <br>/* <br> * CPane::Refresh <br> * <br> * Purpose: <br> *  Invalidates the entire drawing window so the drawing is cleared <br> *  and each of the lines in the Lines collection is redrawn. <br> * <br> */ <br>STDMETHODIMP <br>CPane::Refresh() <br>{ <br>    ::InvalidateRect(m_hwnd, NULL, TRUE); <br>    UpdateWindow(m_hwnd); <br>    return NOERROR;     <br>} <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */ <br> <br>STDMETHODIMP_(void) <br>CPane::Draw(void) <br>{ <br>    PAINTSTRUCT ps; <br>     <br>    BeginPaint(m_hwnd, &amp;ps); <br>    SetMapMode(ps.hdc, MM_TWIPS);    <br>    SetWindowOrgEx(ps.hdc, 0, m_nHeight, NULL); <br>    m_pLines-&gt;Draw(ps.hdc); <br>    EndPaint(m_hwnd, &amp;ps); <br>}   <br> <br>/* <br> * CPane::OnSize <br> * <br> * Purpose: <br> *  Called when the pane is resized. Remembers the new size and gets the new maximum visible <br> *  x and y coordinates. <br> * <br> */  <br>STDMETHODIMP_(void) <br>CPane::OnSize(unsigned int nWidth, unsigned int nHeight)  <br>{ <br>   HDC hdc; <br>   POINT pt;       <br>   RECT rc; <br>    <br>   // Translate the height and width of pane from device units to twips. <br>   hdc = ::GetDC(m_hwnd); <br>   SetMapMode(hdc, MM_TWIPS);  <br>   pt.x = nWidth; pt.y = nHeight; <br>   DPtoLP(hdc, &amp;pt, 1); <br>   m_nWidth = pt.x; <br>   m_nHeight = -pt.y; <br>   ::ReleaseDC(m_hwnd, hdc);  <br>    <br>   // Get the new max visible x and y coordinates    <br>   SetRect(&amp;rc, 0, 0, m_nWidth, m_nHeight); <br>   m_pPoints-&gt;GetMaxXMaxY(&amp;m_nMaxX, &amp;m_nMaxY, &amp;rc);    <br>} <br> <br>STDMETHODIMP_(HDC) <br>CPane::GetDC() <br>{ <br>    HDC hdc;         <br>     <br>    hdc = ::GetDC(m_hwnd);   <br>    SetMapMode(hdc, MM_TWIPS);     <br>    SetWindowOrgEx(hdc, 0, m_nHeight, NULL); <br>    return hdc; <br>}     <br> <br>STDMETHODIMP_(void) <br>CPane::ReleaseDC(HDC hdc) <br>{     <br>    ::ReleaseDC(m_hwnd, hdc); <br>}   <br> <br>STDMETHODIMP_(void) <br>CPane::InvalidateRect(LPRECT prc) <br>{    <br>    RECT rc; <br>    HDC hdc;   <br>    int t; <br>     <br>   // Translate the area to be invalidated from twips to device units <br>   hdc = ::GetDC(m_hwnd); <br>   SetMapMode(hdc, MM_TWIPS);  <br>   SetWindowOrgEx(hdc, 0, m_nHeight, NULL);    <br>   rc = *prc; <br>   LPtoDP(hdc, (LPPOINT)&amp;rc.left, 1);      <br>   LPtoDP(hdc, (LPPOINT)&amp;rc.right, 1);    <br>    <br>   // Make sure left is not greater than right and top is not greater than bottom. Otherwise <br>   // InvalidateRect will not invalidate. <br>   if (rc.right &lt; rc.left) <br>   { <br>       t = rc.right; <br>       rc.right = rc.left; <br>       rc.left = t; <br>   } <br>   if (rc.bottom &lt; rc.top) <br>   { <br>       t = rc.bottom; <br>       rc.bottom = rc.top; <br>       rc.top = t; <br>   }   <br>    <br>   ::InvalidateRect(m_hwnd, &amp;rc, TRUE);     <br>   ::ReleaseDC(m_hwnd, hdc); <br>}  <br> <br>STDMETHODIMP_(void) <br>CPane::Update(void) <br>{ <br>    UpdateWindow(m_hwnd); <br>} <br> <br>/* <br> * CPane::AddPoint <br> * <br> * Purpose: <br> *  Adds a point to the point collection. Updates max visible coordinates is required. <br> * <br> */ <br>STDMETHODIMP_(BOOL) <br>CPane::AddPoint(CPoint FAR* pPoint) <br>{ <br>    int nX, nY; <br>  <br>    nX = pPoint-&gt;get_x(); <br>    nY = pPoint-&gt;get_y(); <br>     <br>    if (nX &gt; m_nMaxX &amp;&amp; nX &lt;= m_nWidth) <br>        m_nMaxX = nX; <br>    if (nY &gt; m_nMaxY &amp;&amp; nY &lt;= m_nHeight) <br>        m_nMaxY = nY; <br>         <br>    return m_pPoints-&gt;Add(pPoint); <br>} <br> <br>/* <br> * CPane::RemovePoint <br> * <br> * Purpose: <br> *  Removes point from point collection. Updates max visible coordinates is required. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CPane::RemovePoint(CPoint FAR* pPoint) <br>{    <br>    RECT rc;     <br>     <br>    // If point was removed from the collection, update max visible X &amp; Y coordinates      <br>    if (m_pPoints-&gt;Remove(pPoint))  <br>    { <br>        SetRect(&amp;rc, 0, 0, m_nWidth, m_nHeight); <br>        m_pPoints-&gt;GetMaxXMaxY(&amp;m_nMaxX, &amp;m_nMaxY, &amp;rc);    <br>    } <br>}    </code></pre>
<p>&nbsp;</p></body>
</HTML>
