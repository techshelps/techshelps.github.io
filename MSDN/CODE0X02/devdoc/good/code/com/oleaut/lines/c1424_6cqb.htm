<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POINT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1433"></a>POINT.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Points Object. <br>** <br>**  point.cpp <br>** <br>**  CPoint implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif       <br>#include "lines.h"   <br> <br>/* <br> * CPoint::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Point automation object and initializes it. <br> * <br> * Parameters: <br> *  ppPoint    Returns Point automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CPoint::Create(CPoint FAR* FAR* ppPoint )  <br>{    <br>    HRESULT hr; <br>    CPoint FAR* pPoint = NULL; <br>      <br>    *ppPoint = NULL; <br>     <br>    pPoint = new CPoint(); <br>    if (pPoint == NULL) <br>        goto error; <br>     <br>    // Load type information for the point from type library.  <br>    hr = LoadTypeInfo(&amp;pPoint-&gt;m_ptinfo, IID_IPoint); <br>    if (FAILED(hr)) <br>        goto error; <br> <br>    *ppPoint = pPoint; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pPoint == NULL) <br>        return E_OUTOFMEMORY;  <br>                     <br>    if (pPoint-&gt;m_ptinfo) <br>        pPoint-&gt;m_ptinfo-&gt;Release(); <br>     <br>    // Set to NULL to prevent destructor from attempting to free again <br>    pPoint-&gt;m_ptinfo = NULL;  <br>     <br>    delete pPoint; <br>    return hr; <br>} <br> <br>/* <br> * CPoint::CPoint <br> * <br> * Purpose: <br> *  Constructor for CPoint object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CPoint::CPoint() : m_SupportErrorInfo(this, IID_IPoint) <br>#pragma warning (default : 4355) <br>{    <br>    m_cRef = 0;    <br>    m_cInternalRef = 0; <br>    m_ptinfo = NULL; <br>    m_nX = -1; <br>    m_nY = -1;     <br>} <br> <br>/* <br> * CPoint::~CPoint <br> * <br> * Purpose: <br> *  Destructor for CPoint object. Frees Point message BSTR and default <br> *  IDispatch implementation. Closes the aplication. <br> * <br> */ <br>CPoint::~CPoint() <br>{             <br>     if (m_ptinfo) m_ptinfo-&gt;Release();   <br>} <br> <br>/* <br> * CPoint::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CPoint::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>     <br>    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IPoint) <br>        *ppv = this;    <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CPoint::AddRef(void) <br>{  <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Point\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br> <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CPoint::Release(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Point\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>     <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>/* <br> * CPoint::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CPoint::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CPoint::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CPoint::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CPoint::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CPoint::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CPoint::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP <br>CPoint::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr); <br>} <br> <br>STDMETHODIMP <br>CPoint::get_x(int FAR* pnX) <br>{ <br>    *pnX = m_nX;    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CPoint::put_x(int nX) <br>{ <br>    m_nX = nX; <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CPoint::get_y(int FAR* pnY) <br>{ <br>    *pnY = m_nY;  <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CPoint::put_y(int nY) <br>{ <br>    m_nY = nY;   <br>    return NOERROR; <br>}   <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */ <br> <br>/* <br> * CPoint::InternalAddRef, InternalRelease <br> * <br> * Purpose:   <br> *  Implements an internal ref count for the use of the points collection. <br> *  The points collection does not have duplicates, instead a reference count is incremented. <br> *  A point is removed from the collection when the reference count drops to 0. <br> * <br> */ <br>STDMETHODIMP_(ULONG) <br>CPoint::InternalAddRef(void) <br>{  <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Internal Ref = %ld, Point\r\n"), m_cInternalRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br> <br>    return ++m_cInternalRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CPoint::InternalRelease(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Internal Ref = %ld, Point\r\n"), m_cInternalRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>     <br>    return --m_cInternalRef; <br>}     <br> <br>STDMETHODIMP_(int) <br>CPoint::get_x(void) <br>{ <br>    return m_nX; <br>} <br> <br> <br>STDMETHODIMP_(int) <br>CPoint::get_y(void) <br>{ <br>    return m_nY; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
