<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>POINTS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1434"></a>POINTS.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Points object <br>** <br>**  points.cpp <br>** <br>**  CPoints collection implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif       <br>#include "lines.h"   <br> <br>/* <br> * CPoints::Create <br> * <br> * Purpose: <br> *  Creates an instance of a collection object and initializes it. <br> * <br> * Parameters: <br> *  lMaxSize   Maximum number of items that can added to collection. <br> *  lLBound    Lower bound of index of collection.   <br> *  pPane      Pointer to pane that contains this collection. Required because the pane coordinates  <br> *             the lines and points collection. <br> *  ppPoints    Returns collection object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CPoints::Create(ULONG lMaxSize, long lLBound, CPane FAR* pPane, CPoints FAR* FAR* ppPoints)  <br>{    <br>    HRESULT hr; <br>    CPoints FAR* pPoints = NULL; <br>    SAFEARRAYBOUND sabound[1]; <br>      <br>    *ppPoints = NULL; <br>     <br>    // Create new collection <br>    pPoints = new CPoints(); <br>    if (pPoints == NULL) <br>        goto error; <br>     <br>    pPoints-&gt;m_cMax = lMaxSize; <br>    pPoints-&gt;m_cElements = 0;  <br>    pPoints-&gt;m_lLBound = lLBound;      <br>    pPoints-&gt;m_pPane = pPane;   <br>     <br>    // Load type information for the points collection from type library.  <br>    hr = LoadTypeInfo(&amp;pPoints-&gt;m_ptinfo, IID_IPoints); <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>    // Create a safe array which is used to implement the collection.             <br>    sabound[0].cElements = lMaxSize; <br>    sabound[0].lLbound = lLBound;         <br>    pPoints-&gt;m_psa = SafeArrayCreate(VT_VARIANT, 1, sabound); <br>    if (pPoints-&gt;m_psa == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto error; <br>    }              <br> <br>    *ppPoints = pPoints; <br>    return NOERROR; <br>     <br>error:  <br>    if (pPoints == NULL) <br>        return E_OUTOFMEMORY; <br>    if (pPoints-&gt;m_ptinfo) <br>        pPoints-&gt;m_ptinfo-&gt;Release();                             <br>    if (pPoints-&gt;m_psa)  <br>        SafeArrayDestroy(pPoints-&gt;m_psa);  <br>   <br>    pPoints-&gt;m_psa = NULL; <br>    pPoints-&gt;m_ptinfo = NULL;  <br>     <br>    delete pPoints; <br>    return hr; <br>} <br> <br>/* <br> * CPoints::CPoints <br> * <br> * Purpose: <br> *  Constructor for CPoints object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CPoints::CPoints() : m_SupportErrorInfo(this, IID_IPoints) <br>#pragma warning (default : 4355) <br>{     <br>    m_cRef = 0; <br>    m_psa = NULL; <br>    m_ptinfo = NULL;  <br>} <br> <br>/* <br> * CPoints::~CPoints <br> * <br> * Purpose: <br> *  Destructor for CPoints object.  <br> * <br> */ <br>CPoints::~CPoints() <br>{     <br>     if (m_ptinfo) m_ptinfo-&gt;Release();                    <br>     if (m_psa) SafeArrayDestroy(m_psa); <br>} <br> <br>/* <br> * CPoints::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CPoints::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{     <br>    *ppv = NULL; <br>         <br>    if (iid == IID_IUnknown || iid == IID_IPoints || iid == IID_IDispatch) <br>        *ppv = this;         <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CPoints::AddRef(void) <br>{  <br> <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Points\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br>     <br>    return ++m_cRef; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CPoints::Release(void) <br>{  <br> <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Ref = %ld, Points\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br>     <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>}  <br> <br>/* <br> * CPoints::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CPoints::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CPoints::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CPoints::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CPoints::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CPoints::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CPoints::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used.  <br> * <br> */ <br>STDMETHODIMP <br>CPoints::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);    <br>} <br> <br>/* <br> * CPoints::get_Count <br> * <br> * Purpose: <br> *  Returns number of items in collection. <br> * <br> */ <br>STDMETHODIMP    <br>CPoints::get_Count(long FAR* plCount)   <br>{ <br>    *plCount = m_cElements; <br>    return NOERROR;              <br>} <br> <br>/* <br> * CPoints::get_Item <br> * <br> * Purpose: <br> *  Retrieves item from collection, given an index. <br> * <br> * Parameters:    <br> *   lIndex   Index of item to be retrieved.  <br> * <br> * Returns <br> *  IDispatch of item retrieved from collection. <br> * <br> */ <br>STDMETHODIMP <br>CPoints::get_Item(long lIndex, IPoint FAR* FAR* ppPoint) <br>{  <br>    HRESULT hr; <br>    VARIANT v; <br>    LPDISPATCH pdisp = NULL; <br>    <br>    // Check if integer index is within range          <br>    if (lIndex &lt; m_lLBound || lIndex &gt;= (long)(m_lLBound+m_cElements))  <br>        return RaiseException(IDS_InvalidIndex, IID_IPoints);  <br>     <br>    // Retrieve and return item. Note that SafeArrayGetElement AddRefs so an additional AddRef <br>    // is not required. <br>    VariantInit(&amp;v); <br>    hr = SafeArrayGetElement(m_psa, &amp;lIndex, &amp;v); <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IPoints);  <br>    *ppPoint = (IPoint FAR*) V_DISPATCH(&amp;v);     <br>    return NOERROR; <br>} <br> <br>/* <br> * CPoints::get_NewEnum <br> * <br> * Purpose: <br> *  Returns an enumerator (IEnumVARIANT) for the items curently in the collection.  <br> *  The NewEnum property is restricted and so is invisible to users of an  <br> *  automation controller's scripting language. Automation controllers that support <br> *  a 'For Each' statement to iterate through the elements of a collection will use <br> *  the enumerator returned by NewEnum. The enumerator creates a snapshot of the <br> *  the current state of the collection. <br> * <br> */ <br>STDMETHODIMP <br>CPoints::get__NewEnum(IUnknown FAR* FAR* ppunkEnum) <br>{ <br>    CEnumVariant FAR* penum = NULL; <br>    HRESULT hr; <br>     <br>    // Create new enumerator for items currently in collection and QI for IUnknown <br>    hr = CEnumVariant::Create(m_psa, m_cElements, &amp;penum); <br>    if (FAILED(hr)) <br>        {hr = RaiseException(IDS_OutOfMemory, IID_IPoints); goto error;}        <br>    hr = penum-&gt;QueryInterface(IID_IUnknown, (VOID FAR* FAR*)ppunkEnum);     <br>    if (FAILED(hr))  <br>        {hr = RaiseException(IDS_Unexpected, IID_IPoints); goto error;}          <br>    return NOERROR;  <br>     <br>error: <br>    if (penum) <br>        delete penum;     <br>    return hr;               <br>} <br> <br>/*  <br> * <br> * The following methods are not exposed through Automation <br> * <br> */ <br> <br>/* <br> * CPoints::Add <br> * <br> * Purpose: <br> *  Adds an item to the collection. The points collection does not have duplicates. <br> * <br> * Parameters: <br> *  pPointAdd    Point to be added to collection. <br> * <br> */ <br>STDMETHODIMP_(BOOL)    <br>CPoints::Add(CPoint FAR* pPointAdd) <br>{  <br>    HRESULT hr;    <br>    LONG l; <br>    VARIANT v;   <br>    VARIANT HUGEP *pvar; <br>    int nX, nY; <br>    BOOL bFound = FALSE;      <br>    LPDISPATCH pdispPointAdd = NULL; <br>    CPoint FAR *pPoint; <br>    LPDISPATCH pdispPoint;    <br>     <br>    // Is the collection full? <br>    if (m_cElements == m_cMax)  <br>        goto error;               <br>        <br>    // Get coordinates of point to be added to collection  <br>    nX = pPointAdd-&gt;get_x(); <br>    nY = pPointAdd-&gt;get_y(); <br>           <br>    hr = SafeArrayAccessData(m_psa, (void HUGEP* FAR*)&amp;pvar); <br>    if (FAILED(hr)) <br>        goto error;  <br>               <br>    // Check if point to be added is already in the collection.        <br>    for (l=0; l&lt;(long)m_cElements; l++) <br>    {    <br>        pdispPoint = V_DISPATCH(&amp;pvar[l]);       <br>        hr = pdispPoint-&gt;QueryInterface(IID_IPoint, (void FAR* FAR*)&amp;pPoint); <br>        if (FAILED(hr)) <br>            continue;                 <br>        if (nX == pPoint-&gt;get_x() &amp;&amp;  nY == pPoint-&gt;get_y()) <br>        {    <br>            // Point is already in the collection. AddRef it.    <br>            // Internal AddRef keeps track of number of times this point was added to this collection. When <br>            //    this internal ref count drops to 0, this point can be removed from this collection.   <br>            pPoint-&gt;InternalAddRef();         <br>            pdispPoint-&gt;AddRef();   <br>             <br>            bFound = TRUE; <br>            pPoint-&gt;Release();  <br>            break;  <br>        }              <br>        pPoint-&gt;Release();         <br>    }    <br>    hr = SafeArrayUnaccessData(m_psa); <br>    if (FAILED(hr)) <br>       goto error; <br>            <br>    // Add point if it was not in the collection. <br>    if (!bFound) <br>    { <br>        l = m_lLBound+m_cElements;     <br> <br>        hr = pPointAdd-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdispPointAdd); <br>        if (FAILED(hr)) <br>            goto error;               <br>        VariantInit(&amp;v); <br>        V_VT(&amp;v) = VT_DISPATCH; <br>        V_DISPATCH(&amp;v) = pdispPointAdd;     <br>        hr = SafeArrayPutElement(m_psa, &amp;l, &amp;v); <br>        if (FAILED(hr)) <br>            goto error;    <br>             <br>        // Internal AddRef keeps track of number of times this point was added to this collection. When <br>        //    this internal ref count drops to 0, this point can be removed from this collection.        <br>        pPointAdd-&gt;InternalAddRef();   <br>        pdispPointAdd-&gt;Release();    <br>           <br>        m_cElements++; <br>    }                     <br>    return TRUE;     <br>     <br>error: <br>    if (pdispPointAdd) <br>        pdispPointAdd-&gt;Release();      <br>    return FALSE;    <br>} <br> <br>/* <br> * CPoints::Remove <br> * <br> * Purpose: <br> *  Removes specified item from collection. The points collection does not have duplicates. <br> * <br> * Parameters:    <br> *   pPointRemove    Point to be removed from collection. <br> * <br> */ <br>STDMETHODIMP_(BOOL) <br>CPoints::Remove(CPoint FAR* pPointRemove) <br>{ <br>    HRESULT hr; <br>    long l, lIndex; <br>    VARIANT HUGEP *pvar; <br>    ULONG cRef; <br>    int nX, nY; <br>    CPoint FAR* pPoint = NULL; <br>    BOOL bFound = FALSE;     <br>    BOOL bRet = FALSE; <br>     <br>    // Get coordinates of point to be removed from collection <br>    nX = pPointRemove-&gt;get_x(); <br>    nY = pPointRemove-&gt;get_y(); <br>           <br>    hr = SafeArrayAccessData(m_psa, (void HUGEP* FAR*)&amp;pvar); <br>    if (FAILED(hr)) <br>       goto error;  <br> <br>               <br>    // Check if point to be removed is in the collection.        <br>    for (l=0; l&lt;(long)m_cElements; l++) <br>    {         <br>        hr = V_DISPATCH(&amp;pvar[l])-&gt;QueryInterface(IID_IPoint, (void FAR* FAR*)&amp;pPoint); <br>        if (FAILED(hr)) <br>            continue; <br>                   <br>        if (nX == pPoint-&gt;get_x() &amp;&amp;  nY == pPoint-&gt;get_y()) <br>        { <br>            // Release point. Note that this collection does not have duplicates. Duplicate <br>            // points are handled by increasing the ref count. <br>            V_DISPATCH(&amp;pvar[l])-&gt;Release();      <br>            cRef = pPoint-&gt;InternalRelease();   <br>            bFound = TRUE; <br>            lIndex = l; <br>            pPoint-&gt;Release();  <br>            break;  <br>        }              <br>        pPoint-&gt;Release();         <br>    }    <br>     <br>    // If the internal ref count of point to be removed has dropped to 0, move up the array elements <br>    // after the element to be removed.      <br>    if (bFound &amp;&amp; cRef == 0) <br>    {            <br>        for (l=lIndex; l&lt;(long)(m_cElements-1); l++)   <br>            pvar[l] = pvar[l+1]; <br>     <br>        // Remove last element.     <br>        V_VT(&amp;pvar[l]) = VT_EMPTY; <br>        m_cElements--;  <br>        bRet = TRUE; <br>    } <br>             <br>    hr = SafeArrayUnaccessData(m_psa); <br>    if (FAILED(hr)) <br>       goto error;           <br>    return bRet;  <br>        <br>error:  <br>    return FALSE; <br>} <br> <br>/* <br> * CPoints::Clear <br> * <br> * Purpose: <br> *  Removes all items from collection. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CPoints::Clear(void) <br>{ <br>    SafeArrayDestroyData(m_psa);      <br>    SafeArrayAllocData(m_psa); <br>    m_cElements = 0; <br>}     <br> <br>/* <br> * CPoints::GetMaxXMaxY <br> * <br> * Purpose: <br> *  Get the maximum X and Y coordinates that are in the rectangle, prc. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CPoints::GetMaxXMaxY(int FAR *pnX, int FAR *pnY, LPRECT prc) <br>{    <br>    HRESULT hr; <br>    long l; <br>    VARIANT HUGEP *pvar; <br>    int nMaxX, nMaxY;        <br>    CPoint FAR* pPoint; <br>    POINT pt; <br>     <br>    hr = SafeArrayAccessData(m_psa, (void HUGEP* FAR*)&amp;pvar); <br>    if (FAILED(hr)) <br>       return;  <br> <br>    nMaxX = -1; nMaxY = -1; <br>     <br>    // Find the maximume X and Y coordinates that are in the prc rectangle.     <br>    for (l=0; l&lt;(long)m_cElements; l++) <br>    {         <br>        V_DISPATCH(&amp;pvar[l])-&gt;QueryInterface(IID_IPoint, (void FAR* FAR*)&amp;pPoint); <br>        pt.x = pPoint-&gt;get_x();  <br>        pt.y = pPoint-&gt;get_y(); <br>          <br>        if (PtInRect(prc, pt)) <br>        {    <br>            if (pt.x &gt; nMaxX) <br>                nMaxX = pt.x; <br>             <br>            if (pt.y &gt; nMaxY) <br>                nMaxY = pt.y; <br>        }         <br>        pPoint-&gt;Release(); <br>    } <br>     <br>    *pnX = nMaxX; <br>    *pnY = nMaxY;     <br>     <br>    SafeArrayUnaccessData(m_psa);   <br>    return; <br>}   <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
