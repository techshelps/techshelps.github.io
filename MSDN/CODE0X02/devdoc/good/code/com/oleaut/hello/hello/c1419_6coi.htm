<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1422"></a>MAIN.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Hello 2.0 Application. <br>** <br>**  main.cpp <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif   <br>#include &lt;initguid.h&gt; <br>#include "hello.h"       <br> <br>// Globals   <br>CHello FAR* g_phello; <br>  <br>SCODE g_scodes[SCODE_COUNT] =          // Array of SCODEs for easy lookup <br>{     <br>    HELLO_E_UNEXPECTED <br>}; <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  <br> * <br> */ <br>int APIENTRY WinMain (HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR pCmdLine, int nCmdShow) <br>{ <br>    MSG msg; <br>    DWORD dwRegisterCF;      <br>    DWORD dwRegisterActiveObject; <br> <br>#ifdef WIN16 <br>   //  It is recommended that all 16 bit OLE applications set <br>   //  their message queue size to 96. This improves the capacity <br>   //  and performance of OLE's LRPC mechanism. <br>   int cMsg = 96;                  // Recommend msg queue size for OLE <br>   while (cMsg &amp;&amp; !SetMessageQueue(cMsg))  // take largest size we can get. <br>       cMsg -= 8; <br>   if (!cMsg) <br>       return -1;  // ERROR: we got no message queue        <br>#endif <br>                     <br>    if (!hinstPrev) <br>       if (!InitApplication(hinst)) // Register window class         <br>          return FALSE; <br>     <br>    if (!InitInstance(hinst))   // Initialize OLE and create Hello application object <br>        return (FALSE);     <br>     <br>    // Determine if /Automation was specified in command line and register class <br>    // factory and active object. Show window if application was started stand alone. <br>    if (!ProcessCmdLine(pCmdLine, &amp;dwRegisterCF, &amp;dwRegisterActiveObject, nCmdShow))    <br>    { <br>       Uninitialize(dwRegisterCF, dwRegisterActiveObject);    <br>       return (FALSE);     <br>    } <br> <br>    while (GetMessage(&amp;msg, NULL, 0, 0)) <br>    { <br>       TranslateMessage(&amp;msg); <br>       DispatchMessage(&amp;msg); <br>    } <br>    <br>    Uninitialize(dwRegisterCF, dwRegisterActiveObject);    <br>    return (msg.wParam);  <br>} <br> <br>/* <br> * InitApplication <br> * <br> * Purpose: <br> *  Registers window class <br> * <br> * Parameters: <br> *  hinst       hInstance of application <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitApplication (HINSTANCE hinst) <br>{ <br>   WNDCLASS wc; <br>    <br>   wc.style = CS_DBLCLKS | CS_SAVEBITS | CS_BYTEALIGNWINDOW; <br>   wc.lpfnWndProc = MainWndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = DLGWINDOWEXTRA; <br>   wc.hInstance = hinst; <br>   wc.hIcon = LoadIcon(hinst, MAKEINTRESOURCE(IDI_ICON)); <br>   wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = HBRUSH(COLOR_WINDOW + 1); <br>   wc.lpszMenuName = NULL; <br>   wc.lpszClassName = TEXT("MainWndClass");  <br>      <br>   return RegisterClass(&amp;wc);         <br>} <br> <br>/* <br> * InitInstance <br> * <br> * Purpose: <br> *  Intializes OLE and creates Hello Application object <br> * <br> * Parameters: <br> *  hinst           hInstance of application <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitInstance (HINSTANCE hinst) <br>{   <br>    HRESULT hr;  <br>    TCHAR ach[STR_LEN]; <br>     <br>    // Intialize OLE <br>    hr = OleInitialize(NULL); <br>    if (FAILED(hr)) <br>       return FALSE;  <br>     <br>    // Create an instance of the Hello Application object. Object is <br>    // created with refcount 0.  <br>    LoadString(hinst, IDS_HelloMessage, ach, sizeof(ach)); <br>    hr = CHello::Create(hinst, ach, &amp;g_phello);        <br>    if (FAILED(hr)) <br>        return FALSE; <br>    return TRUE;           <br>} <br> <br>/* <br> * ProcessCmdLine <br> * <br> * Purpose: <br> *  Check if command line contains /Automation. If so, the class factory of the  <br> *  application object is registered.  If not, the application was started stand-alone and <br> *  so the window is shown. The application object is registered using RegisterActiveObject. <br> * <br> * Parameters: <br> *  pCmdLine       Command line passed to application <br> *  pdwRegisterCF   Returns id returned after class factory registration. Can be used to  <br> *                  revoke class factory registration.  <br> *  pdwRegisterActiveObject   Returns id returned after active object registration. Can be used to  <br> *                  revoke active object registration.    <br> *  nCmdShow        Specifies how window is to be shown if application was started stand alone. <br> * <br> * Return Value: <br> *    TRUE if OLE initialization succeeded, FALSE otherwise. <br> * <br> */ <br>BOOL ProcessCmdLine(LPSTR pCmdLine, LPDWORD pdwRegisterCF, LPDWORD pdwRegisterActiveObject, int nCmdShow) <br>{ <br>   LPCLASSFACTORY pcf = NULL; <br>   HRESULT hr; <br>    <br>   *pdwRegisterCF = 0;      <br>   *pdwRegisterActiveObject = 0; <br> <br>   // Expose class factory for application object if command line contains the  <br>   // Automation switch        <br>   if (_fstrstr(pCmdLine, "-Automation") != NULL <br>       || _fstrstr(pCmdLine, "/Automation") != NULL) <br>   { <br>       pcf = new CHelloCF; <br>       if (!pcf) <br>           goto error;   <br>       pcf-&gt;AddRef();            <br>       hr = CoRegisterClassObject(CLSID_Hello, pcf, <br>                                     CLSCTX_LOCAL_SERVER, REGCLS_SINGLEUSE, <br>                                     pdwRegisterCF); <br>       if (hr != NOERROR) <br>           goto error;            <br>       pcf-&gt;Release(); <br>   }   <br>   else g_phello-&gt;ShowWindow(nCmdShow);    // Show window if started stand-alone        <br>    <br>   // Register Hello application object in the Running Object Table (ROT). This  <br>   // allows controllers to connect to a running application object instead of creating <br>   // a new instance. Use weak registration so that the ROT releases it's reference when  <br>   // all external references are released. If strong registration is used, the ROT will not <br>   // release it's reference until RevokeActiveObject is called and so will keep <br>   // the object alive even after all external references have been released. <br>   RegisterActiveObject(g_phello, CLSID_Hello, ACTIVEOBJECT_WEAK, pdwRegisterActiveObject); <br>   return TRUE;            <br>            <br>error: <br>    if (pcf) <br>        pcf-&gt;Release(); <br>    return FALSE; <br>} <br> <br>/* <br> * Uninitialize <br> * <br> *  Purpose: <br> *   Revoke class factory and active object registration and uninitialize OLE. <br> * <br> * Parameters: <br> *  dwRegisterCF ID returned after class factory registration.  <br> *  dwRegisterActiveObject ID returned after active object registration. <br> * <br> */ <br>void Uninitialize(DWORD dwRegisterCF, DWORD dwRegisterActiveObject) <br>{ <br>    if (dwRegisterCF != 0) <br>        CoRevokeClassObject(dwRegisterCF); <br>    if (dwRegisterActiveObject != 0) <br>        RevokeActiveObject(dwRegisterActiveObject, NULL);    <br>    OleUninitialize(); <br>} <br> <br> <br>/* <br> * MainWndProc <br> * <br> * Purpose: <br> *  Window procedure for main window. The main window is a dialog. <br> * <br> */ <br>LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   switch (msg) <br>   {                <br>      case WM_COMMAND: <br>      {    <br>          switch(GET_WM_COMMAND_ID(wParam, lParam)) <br>          { <br>              case IDC_SAYHELLO: <br>                  g_phello-&gt;SayHello(); <br>                  break; <br>               <br>              case IDC_HELLODISPLAY:               <br>                  switch(GET_WM_COMMAND_CMD(wParam, lParam)) <br>                  {    <br>                      TCHAR ach[100]; <br>               <br>                      case EN_CHANGE:  <br>                      // Update HelloMsg property of Hello object corresponding to this <br>                       // window when the contents of the edit control change.  <br>                       GetDlgItemText(hwnd, IDC_HELLODISPLAY, ach, 100); <br>                       g_phello-&gt;put_HelloMessage(TO_OLE_STRING(ach)); <br>                  } <br>                  return 0L; <br>                  default: <br>                      return 0L;    <br>                  break;   <br>          }               <br>      } <br>      break; <br>       <br>      case WM_CLOSE:  <br>         // Hide the window to release the refcount added by CoLockObjectExternal <br>         // (See CHello::ShowWindow) <br>         g_phello-&gt;ShowWindow(SW_HIDE);  <br>         return DefDlgProc(hwnd, msg, wParam, lParam); <br>         break; <br>       <br>      case WM_DESTROY:             <br>         PostQuitMessage(0); <br>         break; <br>       <br>      default:                          <br>         return DefDlgProc(hwnd, msg, wParam, lParam); <br>   } <br>    <br>   return NULL; <br>} <br> <br>/* <br> * LoadTypeInfo <br> * <br> *  Purpose: <br> *   Gets type information of an object's interface from type library. <br> * <br> * Parameters: <br> *  ppunkStdDispatch    Returns type information. <br> *  clsid               Interface id of object in type library.  <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT LoadTypeInfo(ITypeInfo FAR* FAR* pptinfo, REFCLSID clsid) <br>{                           <br>    HRESULT hr; <br>    LPTYPELIB ptlib = NULL; <br>    LPTYPEINFO ptinfo = NULL; <br> <br>    *pptinfo = NULL;      <br>     <br>    // Load Type Library.  <br>    hr = LoadRegTypeLib(LIBID_Hello, 2, 0, 0x09, &amp;ptlib); <br>    if (FAILED(hr))  <br>    {    <br>        // if it wasn't registered, try to load it from the path <br>        // if this succeeds, it will have registered the type library for us <br>        // for the next time.   <br>        hr = LoadTypeLib(OLESTR("hello.tlb"), &amp;ptlib);  <br>        if(FAILED(hr))         <br>            return hr;    <br>    } <br>     <br>    // Get type information for interface of the object.       <br>    hr = ptlib-&gt;GetTypeInfoOfGuid(clsid, &amp;ptinfo); <br>    if (FAILED(hr))   <br>    {  <br>        ptlib-&gt;Release(); <br>        return hr; <br>    }    <br> <br>    ptlib-&gt;Release(); <br>    *pptinfo = ptinfo; <br>    return NOERROR; <br>}  <br> <br>/* <br> * RaiseException <br> * <br> * Parameters: <br> *  nID                 Error number <br> *  rguid               GUID of interface that is raising the exception. <br> * <br> * Return Value: <br> *  HRESULT correspnding to the nID error number. <br> * <br> * Purpose: <br> *  Fills the EXCEPINFO structure.  <br> *  Sets ErrorInfo object for vtable-binding controllers. <br> *  For id-binding and late binding controllers DispInvoke <br> *  will return DISP_E_EXCEPTION and fill the EXCEPINFO parameter <br> *  with the error information set by SetErrorInfo. <br> * <br> */   <br>HRESULT RaiseException(int nID, REFGUID rguid) <br>{    <br>    extern SCODE g_scodes[]; <br>    TCHAR szError[STR_LEN];    <br>    ICreateErrorInfo *pcerrinfo;   <br>    IErrorInfo *perrinfo; <br>    HRESULT hr; <br>    BSTR bstrDescription = NULL; <br>     <br>    if (LoadString(g_phello-&gt;m_hinst, nID, szError, sizeof(szError))) <br>        bstrDescription = SysAllocString(TO_OLE_STRING(szError));     <br>     <br>    // Set ErrorInfo object so that vtable binding controller can get <br>    // rich error information. If the controller is using IDispatch <br>    // to access properties or methods, DispInvoke will fill the <br>    // EXCEPINFO structure using the values specified in the ErrorInfo <br>    // object and DispInvoke will return DISP_E_EXCEPTION. The property <br>    // or method must return a failure SCODE for DispInvoke to do this. <br>    hr = CreateErrorInfo(&amp;pcerrinfo);  <br>    if (SUCCEEDED(hr)) <br>    { <br>       pcerrinfo-&gt;SetGUID(rguid); <br>       pcerrinfo-&gt;SetSource(g_phello-&gt;m_bstrProgID); <br>       if (bstrDescription) <br>           pcerrinfo-&gt;SetDescription(bstrDescription);   <br>       hr = pcerrinfo-&gt;QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &amp;perrinfo); <br>       if (SUCCEEDED(hr)) <br>       { <br>          SetErrorInfo(0, perrinfo); <br>          perrinfo-&gt;Release(); <br>       }   <br>       pcerrinfo-&gt;Release(); <br>    }   <br>     <br>    if (bstrDescription) <br>        SysFreeString(bstrDescription); <br>    return ResultFromScode(g_scodes[nID-1001]); <br>}   <br> <br>/* <br> * Quick &amp; Dirty ANSI/Unicode conversion routines. These routines use a static <br> * buffer of fixed size to hold the converted string. Consequently these <br> * routines are limited to strings of size STRCONVERT_MAXLEN. Also the same <br> * buffer is reused when the routine is called a second time. So make sure <br> * that the converted string is used before the conversion routine is called <br> * again <br> */ <br>#ifdef WIN32 <br> <br>#ifndef UNICODE <br>char* ConvertToAnsi(OLECHAR FAR* szW) <br>{ <br>  static char achA[STRCONVERT_MAXLEN];  <br>   <br>  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);   <br>  return achA;  <br>}  <br> <br>OLECHAR* ConvertToUnicode(char FAR* szA) <br>{ <br>  static OLECHAR achW[STRCONVERT_MAXLEN];  <br> <br>  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);   <br>  return achW;  <br>} <br>#endif <br> <br>#endif       <br>     <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
