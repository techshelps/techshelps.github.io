<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HELLCTRL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1417"></a>HELLCTRL.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**    Automation Controller that uses vtable binding. <br>**    Controls the HELLO automation object. <br>** <br>**    hellctrl.cpp <br>** <br>** <br>**     Written by Microsoft Product Support Services, Windows Developer Support <br>**    (c) Copyright Microsoft Corp. 1994 - 1996 All Rights Reserved <br>** <br>*************************************************************************/ <br>#define STRICT <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt; <br>  #include &lt;commdlg.h&gt;   <br>#endif   <br>#include &lt;initguid.h&gt;    <br>#include "tlb.h"  <br>#include "hellctrl.h"       <br> <br>// Globals <br>HINSTANCE g_hinst;                          // Instance of application <br>HWND      g_hwnd;                           // Toplevel window handle <br> <br>// String resource buffers <br>TCHAR g_szTitle[STR_LEN];                    // Main window caption <br>TCHAR g_szResult[STR_LEN];                   // "Result" <br>TCHAR g_szError[STR_LEN];                    // "Error" <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application. Should register the app class <br> *  if a previous instance has not done so and do any other one-time <br> *  initializations. <br> * <br> */ <br>int APIENTRY WinMain (HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>   MSG msg; <br>        <br>#ifdef WIN16 <br>   //  It is recommended that all 16 bit OLE applications set <br>   //  their message queue size to 96. This improves the capacity <br>   //  and performance of OLE's LRPC mechanism. <br>   int cMsg = 96;                  // Recommend msg queue size for OLE <br>   while (cMsg &amp;&amp; !SetMessageQueue(cMsg))  // take largest size we can get. <br>       cMsg -= 8; <br>   if (!cMsg) <br>       return -1;  // ERROR: we got no message queue        <br>#endif <br>    <br>   // Load string constants <br>   LoadString(hinst, IDS_PROGNAME, g_szTitle, STR_LEN); <br>   LoadString(hinst, IDS_RESULT, g_szResult, STR_LEN); <br>   LoadString(hinst, IDS_ERROR, g_szError, STR_LEN); <br>    <br>   if (!hinstPrev) <br>      if (!InitApplication(hinst)) <br>         return (FALSE); <br> <br>   if(OleInitialize(NULL) != NOERROR) <br>      return FALSE; <br>       <br>   if (!InitInstance(hinst, nCmdShow)) <br>      return (FALSE); <br> <br>   while (GetMessage(&amp;msg, NULL, NULL, NULL)) <br>   { <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br>   } <br>    <br>   OleUninitialize(); <br>    <br>   return (msg.wParam); // Returns the value from PostQuitMessage <br>} <br> <br>/* <br> * InitApplication <br> * <br> * Purpose: <br> *  Registers window class <br> * <br> * Parameters: <br> *  hinst       hInstance of application <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitApplication (HINSTANCE hinst) <br>{ <br>   WNDCLASS wc; <br> <br>   wc.style = CS_DBLCLKS; <br>   wc.lpfnWndProc = MainWndProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = 0; <br>   wc.hInstance = hinst; <br>   wc.hIcon = LoadIcon(hinst, TEXT("ControlIcon")); <br>   wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); <br>   wc.lpszMenuName = TEXT("ControlMenu"); <br>   wc.lpszClassName = TEXT("MainWndClass"); <br>      <br>   return RegisterClass(&amp;wc); <br> } <br> <br>/* <br> * InitInstance <br> * <br> * Purpose: <br> *  Creates and shows main window <br> * <br> * Parameters: <br> *  hinst           hInstance of application <br> *  nCmdShow        specifies how window is to be shown <br> * <br> * Return Value: <br> *  TRUE if initialization succeeded, FALSE otherwise. <br> */ <br>BOOL InitInstance (HINSTANCE hinst, int nCmdShow) <br>{ <br>   <br>   g_hinst = hinst; <br>   // Create Main Window <br>   g_hwnd = CreateWindow(TEXT("MainWndClass"), g_szTitle, <br>                       WS_OVERLAPPEDWINDOW, <br>                       CW_USEDEFAULT, CW_USEDEFAULT, <br>                       400, 200, <br>                       NULL, NULL, hinst, NULL); <br>   if (!g_hwnd) <br>      return FALSE; <br>    <br>   ShowWindow(g_hwnd, nCmdShow);                   <br>   UpdateWindow(g_hwnd);             <br>   return TRUE; <br>} <br> <br>/* <br> * MainWndProc <br> * <br> * Purpose: <br> *  Window procedure for main window <br> * <br> */ <br>LRESULT CALLBACK MainWndProc (HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) <br>{ <br>   static IHello FAR* phello = NULL;     <br>   HRESULT hr; <br>   LPUNKNOWN punk; <br>    <br>   switch (msg) <br>   { <br>      case WM_COMMAND: <br>         switch (wParam) <br>         { <br>            case IDM_CREATEHELLO:    <br>                // Create Hello object and QueryInterface for IHello interface. <br>                hr = CoCreateInstance(CLSID_Hello, NULL, CLSCTX_SERVER,  <br>                     IID_IUnknown, (void FAR* FAR*)&amp;punk); <br>                if (FAILED(hr))   <br>                { <br>                    MessageBox(NULL, TEXT("CoCreateInstance"), g_szError, MB_OK);  <br>                    return 0L; <br>                }                      <br>                hr = punk-&gt;QueryInterface(IID_IHello,  (void FAR* FAR*)&amp;phello);    <br>                if (FAILED(hr))   <br>                { <br>                    MessageBox(NULL, TEXT("QueryInterface(IID_IHello)"), g_szError, MB_OK); <br>                    punk-&gt;Release();  <br>                    return 0L; <br>                } <br>                punk-&gt;Release(); <br>                return 0L; <br>                                <br>            case IDM_SETVISIBLE:   <br>                // Set Visible property to TRUE <br>                hr = phello-&gt;put_Visible(TRUE); <br>                if (FAILED(hr)) <br>                    DisplayError(phello); <br>                return 0L; <br>                 <br>            case IDM_SETINVISIBLE:     <br>                // Set visible property to FALSE <br>                hr = phello-&gt;put_Visible(FALSE); <br>                if (FAILED(hr)) <br>                    DisplayError(phello); <br>                return 0L; <br>                 <br>            case IDM_GETHELLOMESSAGE:     <br>            {    <br>                // Access Hello Message property and display it <br>                // in a MessageBox <br>                BSTR bstr = NULL;   // BSTR must be intialized before passing <br>                                    // to get_HelloMessage. <br>                hr = phello-&gt;get_HelloMessage(&amp;bstr); <br>                if (FAILED(hr)) <br>                    DisplayError(phello); <br>                else MessageBox(NULL, FROM_OLE_STRING(bstr), g_szResult, MB_OK);  <br>                 <br>                // Caller is responsible for freeing parameters and return values. <br>                if (bstr) <br>                    SysFreeString(bstr); <br>                return 0L;    <br>            } <br>               <br>            case IDM_SAYHELLO:     <br>                // Invoke SayHello method <br>                hr = phello-&gt;SayHello(); <br>                if (FAILED(hr)) <br>                    DisplayError(phello); <br>                return 0L; <br>                 <br>            case IDM_RELEASEHELLO: <br>                // Release the Hello object <br>                phello-&gt;Release(); <br>                phello = NULL; <br>                return 0L; <br>         } <br>         break; <br>          <br>      case WM_INITMENUPOPUP: <br>      { <br>         HMENU hmenu = (HMENU)wParam; <br>          <br>         if (LOWORD(lParam) != 0) <br>            return 0L; <br>             <br>         // Enable or gray the appropriate menu items. phello indicates if an automation object <br>         //  is currently being controlled.    <br>         EnableMenuItem(hmenu, IDM_CREATEHELLO,  MF_BYCOMMAND | (phello?MF_GRAYED:MF_ENABLED)); <br>         EnableMenuItem(hmenu, IDM_SETVISIBLE,   MF_BYCOMMAND | (phello?MF_ENABLED:MF_GRAYED));  <br>         EnableMenuItem(hmenu, IDM_SETINVISIBLE,   MF_BYCOMMAND | (phello?MF_ENABLED:MF_GRAYED)); <br>         EnableMenuItem(hmenu, IDM_GETHELLOMESSAGE,   MF_BYCOMMAND | (phello?MF_ENABLED:MF_GRAYED)); <br>         EnableMenuItem(hmenu, IDM_SAYHELLO,  MF_BYCOMMAND | (phello?MF_ENABLED:MF_GRAYED)); <br>         EnableMenuItem(hmenu, IDM_RELEASEHELLO, MF_BYCOMMAND | (phello?MF_ENABLED:MF_GRAYED)); <br>         return 0L; <br>      } <br>       <br>      case WM_DESTROY: <br>         if (phello) <br>            phello-&gt;Release();                 <br>         PostQuitMessage(0); <br>         break; <br> <br>      default:                          <br>         return DefWindowProc(hwnd, msg, wParam, lParam); <br>   } <br>    <br>   return NULL; <br>} <br> <br>/* <br> * DisplayError <br> * <br> * Purpose: <br> *  Obtains Rich Error Information about the automation error from <br> *  the IErrorInfo interface. <br> * <br> */ <br>void DisplayError(IHello FAR* phello) <br>{   <br>   IErrorInfo FAR* perrinfo;     <br>   BSTR bstrDesc; <br>   HRESULT hr; <br>   ISupportErrorInfo FAR* psupporterrinfo;   <br> <br>   hr = phello-&gt;QueryInterface(IID_ISupportErrorInfo, (LPVOID FAR*)&amp;psupporterrinfo); <br>   if (FAILED(hr))  <br>   { <br>      MessageBox(NULL, TEXT("QueryInterface(IID_ISupportErrorInfo)"), g_szError, MB_OK); <br>      return; <br>   } <br>    <br>   hr = psupporterrinfo-&gt;InterfaceSupportsErrorInfo(IID_IHello);    <br>   if (hr != NOERROR) <br>   {    <br>       psupporterrinfo-&gt;Release(); <br>       return; <br>   } <br>   psupporterrinfo-&gt;Release(); <br>   <br>   // In this example only the error description is obtained and displayed.  <br>   // See the IErrorInfo interface for other information that is available.  <br>   hr = GetErrorInfo(0, &amp;perrinfo);  <br>   if (FAILED(hr)) <br>       return;    <br>   hr = perrinfo-&gt;GetDescription(&amp;bstrDesc); <br>   if (FAILED(hr))  <br>   { <br>       perrinfo-&gt;Release();  <br>       return; <br>   }   <br>    <br>   MessageBox(NULL, FROM_OLE_STRING(bstrDesc), g_szError, MB_OK);    <br>   SysFreeString(bstrDesc); <br>} <br> <br>/* <br> * Quick &amp; Dirty ANSI/Unicode conversion routines. These routines use a static <br> * buffer of fixed size to hold the converted string. Consequently these <br> * routines are limited to strings of size STRCONVERT_MAXLEN. Also the same <br> * buffer is reused when the routine is called a second time. So make sure <br> * that the converted string is used before the conversion routine is called <br> * again <br> */ <br>#ifdef WIN32 <br> <br>#ifndef UNICODE <br>char* ConvertToAnsi(OLECHAR FAR* szW) <br>{ <br>  static char achA[STRCONVERT_MAXLEN];  <br>   <br>  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);   <br>  return achA;  <br>}  <br> <br>OLECHAR* ConvertToUnicode(char FAR* szA) <br>{ <br>  static OLECHAR achW[STRCONVERT_MAXLEN];  <br> <br>  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);   <br>  return achW;  <br>} <br>#endif <br> <br>#endif    <br>    </code></pre>
<p>&nbsp;</p></body>
</HTML>
