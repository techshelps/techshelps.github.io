<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HELLO.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1423"></a>HELLO.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation Hello 2.0 Application. <br>** <br>**  hello.cpp <br>** <br>**  CHello implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif  <br>#include "hello.h" <br> <br>/* <br> * CHello::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Hello Application object and initializes it. <br> * <br> * Parameters: <br> *  hinst      HINSTANCE of application. <br> *  lpszHelloMessage Initial Hello message.  <br> *  pphello    Returns Hello automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CHello::Create(HINSTANCE hinst, LPTSTR lpszHelloMessage, CHello FAR* FAR* pphello)  <br>{    <br>    TCHAR ach[STR_LEN];    <br>    TCHAR achFullName[260]; <br>    HRESULT hr; <br>    CHello FAR* phello = NULL;    <br>    HWND hwnd; <br>      <br>    *pphello = NULL; <br>     <br>    // Create Hello Application object <br>    phello = new CHello(); <br>    if (phello == NULL) <br>        goto error; <br>    <br>    // Create Main Window <br>    hwnd = CreateDialog(hinst, MAKEINTRESOURCE(IDD_MAINWINDOW), NULL, NULL); <br>    if (!hwnd) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }   <br>      <br>    phello-&gt;m_cRef = 0; <br>    phello-&gt;m_bVisible = FALSE; <br>    phello-&gt;m_hwnd = hwnd;      <br>    phello-&gt;m_hinst = hinst; <br>     <br>    // FullName <br>    GetModuleFileName(hinst, achFullName, sizeof(achFullName));  <br>    phello-&gt;m_bstrFullName = SysAllocString(TO_OLE_STRING(achFullName)); <br>    if (NULL == phello-&gt;m_bstrFullName) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }    <br>    // Name <br>    LoadString(hinst, IDS_Name, ach, sizeof(ach));   <br>    phello-&gt;m_bstrName = SysAllocString(TO_OLE_STRING(ach)); <br>    if (NULL == phello-&gt;m_bstrName) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }  <br>    // ProgID  <br>    LoadString(hinst, IDS_ProgID, ach, sizeof(ach));   <br>    phello-&gt;m_bstrProgID = SysAllocString(TO_OLE_STRING(ach)); <br>    if (NULL == phello-&gt;m_bstrProgID) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    }    <br>    // Hello Message <br>    phello-&gt;m_bstrHelloMsg = SysAllocString(TO_OLE_STRING(lpszHelloMessage)); <br>    if (NULL == phello-&gt;m_bstrHelloMsg) <br>    { <br>        hr = E_OUTOFMEMORY;     <br>        goto error; <br>    } <br>     <br>    // Load type information from type library. If required, notify user on failure.  <br>    hr = LoadTypeInfo(&amp;phello-&gt;m_ptinfo, IID_IHello); <br>    if (FAILED(hr))  <br>    { <br>         <br>        LoadString(hinst, IDS_ErrorLoadingTypeLib, ach, sizeof(ach)); <br>        MessageBox(NULL, ach, FROM_OLE_STRING(phello-&gt;m_bstrName), MB_OK); <br>        goto error; <br>    } <br>          <br>    *pphello = phello; <br>    return NOERROR; <br>     <br>error:                         <br>    if (phello == NULL) return E_OUTOFMEMORY;     <br>    if (phello-&gt;m_bstrFullName) SysFreeString(phello-&gt;m_bstrFullName);   <br>    if (phello-&gt;m_bstrName) SysFreeString(phello-&gt;m_bstrName);  <br>    if (phello-&gt;m_bstrProgID) SysFreeString(phello-&gt;m_bstrProgID);                      <br>    if (phello-&gt;m_bstrHelloMsg) SysFreeString(phello-&gt;m_bstrHelloMsg);       <br>    if (phello-&gt;m_ptinfo) phello-&gt;m_ptinfo-&gt;Release(); <br>     <br>    // Set to NULL to prevent destructor from attempting to free again <br>    phello-&gt;m_bstrFullName = NULL; <br>    phello-&gt;m_bstrName = NULL; <br>    phello-&gt;m_bstrProgID = NULL; <br>    phello-&gt;m_bstrHelloMsg = NULL; <br>    phello-&gt;m_ptinfo = NULL; <br>     <br>    delete phello; <br>    return hr; <br>} <br> <br>/* <br> * CHello::CHello <br> * <br> * Purpose: <br> *  Constructor for CHello object. Initializes members to NULL. <br> * <br> */ <br>#pragma warning (disable : 4355) <br>CHello::CHello() : m_SupportErrorInfo(this, IID_IHello) <br>#pragma warning (default : 4355) <br>{    <br>    extern ULONG g_cObj; <br>      <br>    m_hwnd = NULL; <br>    m_bstrFullName = NULL; <br>    m_bstrName = NULL; <br>    m_bstrProgID = NULL; <br>    m_bstrHelloMsg = NULL; <br>    m_ptinfo = NULL;  <br>    m_bVisible = 0; <br>} <br> <br>/* <br> * CHello::~CHello <br> * <br> * Purpose: <br> *  Destructor for CHello object.  <br> * <br> */ <br>CHello::~CHello() <br>{  <br>     extern ULONG g_cObj; <br>      <br>     if (m_bstrFullName) SysFreeString(m_bstrFullName); <br>     if (m_bstrName) SysFreeString(m_bstrName); <br>     if (m_bstrProgID) SysFreeString(m_bstrProgID); <br>     if (m_bstrHelloMsg) SysFreeString(m_bstrHelloMsg);           <br>     if (m_ptinfo) m_ptinfo-&gt;Release(); <br>     if (IsWindow(m_hwnd)) DestroyWindow(m_hwnd); <br>} <br> <br>/* <br> * CHello::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>STDMETHODIMP <br>CHello::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>     <br>    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IHello  )  <br>        *ppv = this;    <br>    else if (iid == IID_ISupportErrorInfo) <br>        *ppv = &amp;m_SupportErrorInfo; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CHello::AddRef(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("AddRef: Ref = %ld, Hello\r\n"), m_cRef+1);  <br>    OutputDebugString(ach);  <br>#endif   <br> <br>    return ++m_cRef; <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CHello::Release(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[50]; <br>    wsprintf(ach, TEXT("Release: Ref = %ld, Hello\r\n"), m_cRef-1);  <br>    OutputDebugString(ach);    <br>#endif <br> <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>/* <br> * CHello::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CHello::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CHello::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CHello::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CHello::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CHello::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CHello::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP <br>CHello::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{         <br>    return DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);  <br>} <br> <br>/* <br> * CHello::put_HelloMessage, get_HelloMessage, SayHello <br> * <br> * Purpose: <br> *  Implements the standard Application, FullName, Name, Parent &amp; Visible properties <br> *  and the Quit method.  <br> * <br> */ <br>STDMETHODIMP  <br>CHello::get_Application(IHello FAR* FAR* ppHello) <br>{ <br>    HRESULT hr; <br>     <br>    *ppHello = NULL; <br>     <br>    hr = QueryInterface(IID_IDispatch, (void FAR* FAR*)ppHello);   <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IHello);  <br>    return hr; <br>} <br> <br>STDMETHODIMP <br>CHello::get_FullName(BSTR FAR* pbstr) <br>{ <br>    *pbstr = SysAllocString(m_bstrFullName);    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CHello::get_Name(BSTR FAR* pbstr) <br>{ <br>    *pbstr = SysAllocString(m_bstrName);    <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CHello::get_Parent(IHello FAR* FAR* ppHello) <br>{ <br>    HRESULT hr; <br>     <br>    *ppHello = NULL; <br>     <br>    hr = QueryInterface(IID_IDispatch, (void FAR* FAR*)ppHello);    <br>    if (FAILED(hr)) <br>        return RaiseException(IDS_Unexpected, IID_IHello);  <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CHello::put_Visible(VARIANT_BOOL bVisible) <br>{ <br>    ShowWindow(bVisible ? SW_SHOW : SW_HIDE);   <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CHello::get_Visible(VARIANT_BOOL FAR* pbool) <br>{ <br>    *pbool =  m_bVisible;   <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP <br>CHello::Quit()  <br>{ <br>    // CoDisconnectObject has no effect for an inproc server.  So the controller <br>    // will GP fault if it attempts to access the object (including calling IUnknown::Release()) <br>    // after Quit has been called. For a local server, CoDisconnectObject will disconnect <br>    // the object from external connections. So the controller will get an RPC error if <br>    // it accesses the object after calling Quit and controller will not GP fault.  <br>    CoDisconnectObject((LPUNKNOWN)this, 0);   <br>    PostMessage(m_hwnd, WM_CLOSE, 0, 0L); <br>    return NOERROR;            <br>}  <br> <br>/* <br> * CHello::put_HelloMessage, get_HelloMessage, SayHello <br> * <br> * Purpose: <br> *  Implements the HelloMessage property and the SayHello method. <br> * <br> */     <br>STDMETHODIMP <br>CHello::put_HelloMessage(BSTR bstrMessage) <br>{ <br>    SysReAllocString(&amp;m_bstrHelloMsg, bstrMessage);    <br>    return NOERROR;  <br>} <br> <br>STDMETHODIMP <br>CHello::get_HelloMessage(BSTR FAR* pbstrMessage) <br>{    <br>    *pbstrMessage = SysAllocString(m_bstrHelloMsg); <br>    return NOERROR;  <br>} <br> <br>STDMETHODIMP <br>CHello::SayHello() <br>{     <br>    SetDlgItemText(m_hwnd, IDC_HELLODISPLAY, FROM_OLE_STRING(m_bstrHelloMsg));        <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP_(void) <br>CHello::ShowWindow(int nCmdShow) <br>{    <br>    // Return if curently hidden and asked to hide or currently visible <br>    // and asked to show. <br>    if ((!m_bVisible &amp;&amp; nCmdShow == SW_HIDE) || (m_bVisible &amp;&amp; nCmdShow != SW_HIDE)) <br>        return;  <br>     <br>    m_bVisible = (nCmdShow == SW_HIDE) ? FALSE : TRUE; <br>     <br>    // The Automation object shutdown behavior is as follows: <br>    // 1. If the object application is visible, it shuts down only in response to an <br>    // explicit user command (File/Exit) or it's programmatic equivalent (for example <br>    // the Quit method of the Application object). <br>    // 2. If the object application is not visible, it goes away when it's last <br>    // object is released.    <br>    //    <br>    // CoLockObjectExternal can be used to increment the ref count of the application object <br>    // when it is visible. This will implement shutdown behavior 1. When the application <br>    // goes invisible, CoLockObjectExternal is used to decrement the ref count. This will <br>    // implement shutdown behavior 2. <br>     <br>    if (m_bVisible) <br>        CoLockObjectExternal(this, TRUE /*fLock*/, TRUE/*ignored when fLock==TRUE*/); <br>    else CoLockObjectExternal(this, FALSE/*fLock*/, TRUE/*fLastLockReleases*/);   <br>    ::ShowWindow (m_hwnd, nCmdShow); <br>} <br> <br> <br>/* <br> * ISupportErrorInfo implementation <br> * <br> */ <br>CSupportErrorInfo::CSupportErrorInfo(IUnknown FAR* punkObject, REFIID riid) <br>{ <br>    m_punkObject = punkObject;  <br>    m_iid = riid; <br>}          <br> <br>STDMETHODIMP <br>CSupportErrorInfo::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    return m_punkObject-&gt;QueryInterface(iid, ppv);     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CSupportErrorInfo::AddRef(void) <br>{ <br>    return m_punkObject-&gt;AddRef(); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CSupportErrorInfo::Release(void) <br>{ <br>    return m_punkObject-&gt;Release(); <br>}  <br> <br>STDMETHODIMP <br>CSupportErrorInfo::InterfaceSupportsErrorInfo(REFIID riid)   <br>{ <br>    return (riid == m_iid) ? NOERROR : S_FALSE; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
