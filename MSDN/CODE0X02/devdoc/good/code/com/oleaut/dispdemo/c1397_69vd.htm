<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CREMPOLY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1399"></a>CREMPOLY.CPP</h2>
<pre><code>/***  <br>*crempoly.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This file contains the implementation of CRemPoly, the remote polygon <br>*  class. This class presents a standard C++ vtable interface to the <br>*  rest of the application, and hides the details of talking to the <br>*  actual remote CPoly class exposed by the SPoly server. Each of <br>*  the introduced methods is simply a cover for an IDispatch invocation <br>*  of the actual method on the remote object. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "dispdemo.h" <br>#include "crempoly.h" <br> <br>extern int g_fTrace; <br> <br>// method names on the CPoly class. <br>// <br>OLECHAR FAR* CRemPoly::m_rgszMethods[] = { <br>    OLESTR("draw"), <br>    OLESTR("dump"), <br>    OLESTR("reset"), <br>    OLESTR("addpoint"), <br>    OLESTR("enumpoints"), <br>    OLESTR("getxorigin"), <br>    OLESTR("setxorigin"), <br>    OLESTR("getyorigin"), <br>    OLESTR("setyorigin"), <br>    OLESTR("getwidth"), <br>    OLESTR("setwidth"), <br>    OLESTR("get_red"), <br>    OLESTR("set_red"), <br>    OLESTR("get_green"), <br>    OLESTR("set_green"), <br>    OLESTR("get_blue"), <br>    OLESTR("set_blue") <br>}; <br> <br>#ifdef _MAC <br># define IfMac(X) (X) <br># define IfWin(X) <br>#else <br># define IfMac(X) <br># define IfWin(X) (X) <br>#endif <br> <br> <br>CRemPoly::CRemPoly() <br>{ <br>    m_refs = 0; <br>    m_pdisp = (IDispatch FAR*)NULL; <br>} <br> <br> <br>// A useful pre-initialized DISPATCHPARAMS, used on all the methods that <br>// take 0 arguments. <br>// <br>DISPPARAMS NEAR g_dispparamsNoArgs = {NULL, NULL, 0, 0}; <br> <br> <br>/*** <br>*HRESULT CRemPoly::Create(clsid, CRemPoly**) <br>* <br>*Purpose: <br>*  This function creates an instance of the CRemPoly class, connects <br>*  it to the IDispatch interface of the remote CPoly class, and learns <br>*  the DISPIDs for the members (that we know about) exposed by that <br>*  class. <br>* <br>*Entry: <br>*  clsid = The CLSID of the CPoly we are to create. (taking this as a <br>*    param is a bit weird, but allows us to connect to several remote <br>*    versions. <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *pprempoly = pointer to the newly created CRemPoly, if successfyl. <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::Create(CLSID clsid, CRemPoly FAR* FAR* pprempoly) <br>{ <br>    int i; <br>    HRESULT hresult; <br>    IUnknown FAR* punk; <br>    CRemPoly FAR* prempoly; <br> <br> <br>    prempoly = new FAR CRemPoly(); <br>    if(prempoly == (CRemPoly FAR*)NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError; <br>    } <br>    prempoly-&gt;AddRef(); <br>       <br>    // create an instance of the remote CPoly class. <br>    // <br>    IfMac(DbPrintf("CoCreateInstance(CLSID_CPoly)")); <br>    hresult = CoCreateInstance( <br>      clsid, NULL, CLSCTX_LOCAL_SERVER, IID_IUnknown, (void FAR* FAR*)&amp;punk); <br>    if(hresult != NOERROR){ <br>      IfMac(DbPrintf("CoCreateInstance() = 0x%x", hresult)); <br>      IfWin(MessageBox(NULL, TSTR("Unable to create polygon object"),  <br>               NULL, MB_OK)); <br>      goto LFreeCRemPoly; <br>    } <br> <br>    // were going to talk to this remote instance via IDispatch. <br>    // <br>    IfMac(DbPrintf("QueryInterface(IID_IDispatch)")); <br>    hresult = punk-&gt;QueryInterface( <br>      IID_IDispatch, (void FAR* FAR*)&amp;prempoly-&gt;m_pdisp); <br>    if(hresult != NOERROR){ <br>      IfMac(DbPrintf("QueryInterface(IID_IDispatch) = 0x%x", hresult)); <br>      IfWin(MessageBox(NULL, TSTR("Unable to QueryInterface to IDispatch"), <br>               NULL, MB_OK)); <br>      goto LReleaseUnk; <br>    } <br> <br>    // We learn *all* the member IDs up front. A more sophisticated <br>    // implementation might defer learning about the IDs for a given <br>    // method until the first time the method is invoked, thereby <br>    // amortizing the creation costs. <br>    // <br>    IfMac(DbPrintf("GetIDsOfNames()")); <br>    for(i = 0; i &lt; IMETH_CREMPOLY_MAX; ++i){ <br>      hresult = prempoly-&gt;m_pdisp-&gt;GetIDsOfNames( <br>IID_NULL, <br>        &amp;prempoly-&gt;m_rgszMethods[i], <br>1, LOCALE_USER_DEFAULT, <br>&amp;prempoly-&gt;m_rgdispid[i]); <br>      if(hresult != NOERROR){ <br>IfMac(DbPrintf("GetIDsOfNames() = 0x%x", hresult)); <br>IfWin(MessageBox(NULL, TSTR("Unrecognized member name"), <br>         NULL, MB_OK)); <br>goto LReleaseUnk; <br>      } <br>    } <br> <br>    punk-&gt;Release(); <br> <br>    *pprempoly = prempoly; <br> <br>    IfMac(DbPrintf("Object created.")); <br> <br>    return NOERROR; <br> <br>LReleaseUnk:; <br>    punk-&gt;Release(); <br> <br>LFreeCRemPoly:; <br>    prempoly-&gt;Release(); <br> <br>LError:; <br>    return hresult; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IUnknown methods <br>//--------------------------------------------------------------------- <br> <br> <br>/*** <br>*HRESULT CRemPoly::QueryInterface(REFIID, void**) <br>* <br>*Purpose: <br>*  Standard Ole2 implementation of QueryInterface. This class <br>*  supports the IUnknown interface, and introduces a number of <br>*  nonvirtual members. <br>* <br>*Entry: <br>*  riid = reference to the requested interface id <br>* <br>*Exit: <br>*  return value = HRESULT <br>*  *ppv = pointer to the requested interface, if successful. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CRemPoly::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown)){ <br>      *ppv = this; <br>      AddRef(); <br>      return NOERROR; <br>    } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br> <br>/*** <br>*unsigned long CRemPoly::AddRef(void) <br>* <br>*Purpose: <br>*  Add a reference to the instance. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = unsigned long. The resulting reference count. <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(unsigned long) <br>CRemPoly::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>/*** <br>*unsigned long CRemPoly::Release(void) <br>* <br>*Purpose: <br>*  Release a reference to the instance. If the reference count goes <br>*  to zero, delete the instance. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = unsigned long. The resulting reference count. <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(unsigned long) <br>CRemPoly::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      if(m_pdisp != (IDispatch FAR*)NULL){ <br>        m_pdisp-&gt;Release(); <br>      } <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                    Introduced methods <br>//--------------------------------------------------------------------- <br> <br> <br>/* <br> * Each of these methods is simply a cover for an IDispatch Invocation <br> * of the actual method on the remote CPoly class. This allows CRemPoly <br> * to present an interface that looks and acts just like the CPoly <br> * object, even though the actual work is being done in another process. <br> * <br> */ <br> <br>/*** <br>*HRESULT CRemPoly::Draw(void) <br>* <br>*Purpose: <br>*  Invoke the Draw method on the remote CPoly instance. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::Draw() <br>{ <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_DRAW], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::Dump(void) <br>* <br>*Purpose: <br>*  Invoke the Dump() method on the remote CPoly instance. This method <br>*  dumps the contained CPoints and writes the properties of the remote <br>*  CPoly instance to the debug window. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::Dump() <br>{ <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_DUMP], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::Reset(void) <br>* <br>*Purpose: <br>*  Invoke the Reset() method on the remote CPoly instance. The Reset() <br>*  method causes the remote CPoly to release all contained CPoints. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::Reset() <br>{ <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_RESET], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::AddPoint(short, short) <br>* <br>*Purpose: <br>*  Invoke the AddPoint method in the remote CPoly object to add a <br>*  new point with the given coordinates to this instance. <br>* <br>*Entry: <br>*  x,y = the x and y coordinates of the new point. <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::AddPoint(short x, short y) <br>{ <br>    HRESULT hresult; <br>    VARIANTARG varg[2]; <br>    DISPPARAMS dispparams; <br> <br>    V_VT(&amp;varg[0]) = VT_I2; <br>    V_I2(&amp;varg[0]) = y; <br> <br>    V_VT(&amp;varg[1]) = VT_I2; <br>    V_I2(&amp;varg[1]) = x; <br> <br>    dispparams.cArgs = 2; <br>    dispparams.rgvarg = varg; <br>    dispparams.cNamedArgs = 0; <br>    dispparams.rgdispidNamedArgs = NULL; <br> <br>    hresult = m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_ADDPOINT], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;dispparams, NULL, NULL, NULL); <br> <br>    return hresult; <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::EnumPoints(IEnumVARIANT**) <br>*Purpose: <br>*  Inoke the EnumPoints() method in the remote object to <br>*  get a enumerator for the points contained in the current poly. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *ppenum = pointer to the point enumerator <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::EnumPoints(IEnumVARIANT FAR* FAR* ppenum) <br>{ <br>    HRESULT hresult; <br>    IEnumVARIANT FAR* penum; <br>    VARIANT varResult, FAR* pvarResult; <br> <br> <br>    pvarResult = &amp;varResult; <br>    VariantInit(pvarResult); <br>    hresult = m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_ENUMPOINTS], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, pvarResult, NULL, NULL); <br> <br>    if(hresult != NOERROR) <br>      return hresult; <br> <br>    if(V_VT(pvarResult) != VT_UNKNOWN) <br>      return E_FAIL; <br> <br>    hresult = V_UNKNOWN(pvarResult)-&gt;QueryInterface( <br>      IID_IEnumVARIANT, (void FAR* FAR*)&amp;penum); <br> <br>    if(hresult == NOERROR) <br>      *ppenum = penum; <br> <br>    VariantClear(pvarResult); <br> <br>    return NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::GetXOrigin(short*) <br>* <br>*Purpose: <br>*  Invoke the GetXOrigin() method on the remote object to extract <br>*  the current value of the XOrigin property. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *pxorg = the current X origin of the polygon. <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::GetXOrigin(short FAR* pxorg) <br>{ <br>    HRESULT hresult; <br>    VARIANT varResult; <br> <br>    VariantInit(&amp;varResult); <br>    hresult = m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_GETXORIGIN], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, &amp;varResult, NULL, NULL); <br> <br>    if(hresult != NOERROR) <br>      return hresult; <br> <br>    *pxorg = V_I2(&amp;varResult); <br>    VariantClear(&amp;varResult); <br>     <br>    return NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::SetXOrigin(short) <br>* <br>*Purpose: <br>*  Invoke the SetXOrigin method on the remote object to set the <br>*  XOrigin property of the polygon to the given value. <br>* <br>*Entry: <br>*  xorg = the new X origin <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::SetXOrigin(short xorg) <br>{ <br>    VARIANTARG varg; <br>    DISPPARAMS dispparams; <br> <br> <br>    V_VT(&amp;varg) = VT_I2; <br>    V_I2(&amp;varg) = xorg; <br> <br>    dispparams.cArgs = 1; <br>    dispparams.cNamedArgs = 0; <br>    dispparams.rgvarg = &amp;varg; <br> <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_SETXORIGIN], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;dispparams, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::GetYOrigin(short*) <br>* <br>*Purpose: <br>*  Invoke the GetYOrigin() method on the remote object to extract <br>*  the current value of the YOrigin property. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *pyorg = the current Y origin of the polygon <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::GetYOrigin(short FAR* pyorg) <br>{ <br>    HRESULT hresult; <br>    VARIANT varResult; <br> <br> <br>    VariantInit(&amp;varResult); <br>    hresult = m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_GETYORIGIN], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, &amp;varResult, NULL, NULL); <br> <br>    if(hresult != NOERROR) <br>      return hresult; <br> <br>    *pyorg = V_I2(&amp;varResult); <br>    VariantClear(&amp;varResult); <br>     <br>    return hresult; <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::SetYOrigin(short) <br>* <br>*Purpose: <br>*  Invoke the SetYOrigin method on the remote object to set the <br>*  YOrigin property of the polygon to the given value. <br>* <br>*Entry: <br>*  yorg = the new Y origin <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::SetYOrigin(short yorg) <br>{ <br>    VARIANTARG varg; <br>    DISPPARAMS dispparams; <br> <br>    V_VT(&amp;varg) = VT_I2; <br>    V_I2(&amp;varg) = yorg; <br> <br>    dispparams.cArgs = 1; <br>    dispparams.cNamedArgs = 0; <br>    dispparams.rgvarg = &amp;varg; <br> <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_SETYORIGIN], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;dispparams, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::GetWidth(short*) <br>* <br>*Purpose: <br>*  Invoke the GetWidth() method on the remote object to extract <br>*  the current value of the line width property. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *pwidth = short, the current line width of the polygon <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::GetWidth(short FAR* pwidth) <br>{ <br>    HRESULT hresult; <br>    VARIANT varResult; <br> <br>    VariantInit(&amp;varResult); <br>    hresult = m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_GETWIDTH], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, &amp;varResult, NULL, NULL); <br> <br>    if(hresult != NOERROR) <br>      return hresult; <br> <br>    *pwidth = V_I2(&amp;varResult); <br>    VariantClear(&amp;varResult); <br>    return NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CRemPoly::SetWidth(short) <br>* <br>*Purpose: <br>*  Invoke the SetWidth method on the remote object to set the <br>*  line width property of the polygon to the given value. <br>* <br>*Entry: <br>*  width = the new value for the line width property. <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT <br>CRemPoly::SetWidth(short width) <br>{ <br>    VARIANTARG varg; <br>    DISPPARAMS dispparams; <br> <br> <br>    V_VT(&amp;varg) = VT_I2; <br>    V_I2(&amp;varg) = width; <br> <br>    dispparams.cArgs = 1; <br>    dispparams.cNamedArgs = 0; <br>    dispparams.rgvarg = &amp;varg; <br> <br>    return m_pdisp-&gt;Invoke( <br>      m_rgdispid[IMETH_CREMPOLY_SETWIDTH], <br>      IID_NULL, <br>      LOCALE_USER_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;dispparams, NULL, NULL, NULL); <br>} <br> <br> <br>HRESULT CRemPoly::get_red(short FAR* psRed) <br>{ <br>    return get_i2(m_rgdispid[IMETH_CREMPOLY_GETRED], psRed); <br>} <br> <br>HRESULT CRemPoly::set_red(short sRed) <br>{ <br>    return set_i2(m_rgdispid[IMETH_CREMPOLY_SETRED], sRed); <br>} <br> <br> <br>HRESULT CRemPoly::get_green(short FAR* psGreen) <br>{ <br>    return get_i2(m_rgdispid[IMETH_CREMPOLY_GETGREEN], psGreen); <br>} <br> <br>HRESULT CRemPoly::set_green(short sGreen) <br>{ <br>    return set_i2(m_rgdispid[IMETH_CREMPOLY_SETGREEN], sGreen); <br>} <br> <br> <br>HRESULT CRemPoly::get_blue(short FAR* psBlue) <br>{ <br>    return get_i2(m_rgdispid[IMETH_CREMPOLY_GETBLUE], psBlue); <br>} <br> <br>HRESULT CRemPoly::set_blue(short sBlue) <br>{ <br>    return set_i2(m_rgdispid[IMETH_CREMPOLY_SETBLUE], sBlue); <br>} <br> <br>HRESULT <br>CRemPoly::get_i2(DISPID dispid, short FAR* ps) <br>{ <br>    HRESULT hresult; <br>    VARIANT varResult; <br> <br>    VariantInit(&amp;varResult); <br> <br>    hresult = m_pdisp-&gt;Invoke( <br>      dispid, <br>      IID_NULL, <br>      LOCALE_SYSTEM_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;g_dispparamsNoArgs, <br>      &amp;varResult, NULL, NULL); <br> <br>    if(hresult != NOERROR) <br>      return hresult; <br> <br>    hresult = VariantChangeType(&amp;varResult, &amp;varResult, 0, VT_I2); <br>    if(hresult != NOERROR){ <br>      VariantClear(&amp;varResult); <br>      return hresult; <br>    } <br> <br>    *ps = V_I2(&amp;varResult); <br>    VariantClear(&amp;varResult); <br>    return NOERROR; <br>} <br> <br>HRESULT <br>CRemPoly::set_i2(DISPID dispid, short s) <br>{ <br>    VARIANTARG varg; <br>    DISPPARAMS dispparams; <br> <br>    V_VT(&amp;varg) = VT_I2; <br>    V_I2(&amp;varg) = s; <br> <br>    dispparams.cArgs = 1; <br>    dispparams.cNamedArgs = 0; <br>    dispparams.rgvarg = &amp;varg; <br> <br>    return m_pdisp-&gt;Invoke( <br>      dispid, <br>      IID_NULL, <br>      LOCALE_SYSTEM_DEFAULT, <br>      DISPATCH_METHOD, <br>      &amp;dispparams, NULL, NULL, NULL); <br>} <br> <br> <br>/*** <br>*void DoPoly(CLSID)  <br>* <br>*Purpose: <br>*  This function simply exercises our CRemPoly class by creating an <br>*  instance and invoking a number of its methods. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDAPI <br>DoPoly(CLSID clsid) <br>{ <br>    HRESULT hr; <br>    int numpoly, i, j; <br> <br>static struct { <br>    short x; <br>    short y; <br>} rgptPoly[] = { <br>      { 25,   0} <br>    , { 75,   0} <br>    , {100,  25} <br>    , {100,  75} <br>    , { 75, 100} <br>    , { 25, 100} <br>    , {  0,  75} <br>    , {  0,  25} <br>}; <br> <br>static struct { <br>    short red; <br>    short green; <br>    short blue; <br>} rgrgbColors[] = { <br>#ifdef _MAC <br>      {     0,      0,      0} <br>    , {     0,      0, 0x7fff} <br>    , {     0, 0x7fff,      0} <br>    , {0x7fff,      0,      0} <br>    , {0x7fff,      0, 0x7fff} <br>    , {0x7fff, 0x7fff,      0} <br>    , {0x7fff, 0x7fff, 0x7fff} <br>#else <br>      {  0,   0,   0} <br>    , {  0,   0, 127} <br>    , {  0, 127,   0} <br>    , {127,   0,   0} <br>    , {127,   0, 127} <br>    , {127, 127,   0} <br>    , {127, 127, 127} <br>#endif <br>}; <br> <br>    CRemPoly FAR* rgprempoly[DIM(rgrgbColors)]; <br> <br>    numpoly = DIM(rgprempoly); <br> <br>    // init <br>    for(i = 0; i &lt; numpoly; ++i) <br>      rgprempoly[i] = (CRemPoly FAR*)NULL; <br> <br>    for(i = 0; i &lt; numpoly; ++i){ <br>      hr = CRemPoly::Create(clsid, &amp;rgprempoly[i]); <br>      if(hr != NOERROR) <br>        goto LError0; <br>      IfMac(DbPrintf("CRemPoly::Create()")); <br> <br>      for(j = 0; j &lt; DIM(rgptPoly); ++j){ <br>        short x = rgptPoly[j].x; <br>short y = rgptPoly[j].y; <br>        IfMac(DbPrintf("CRemPoly::AddPoint(%d,%d)", x, y)); <br>        hr = rgprempoly[i]-&gt;AddPoint(x, y); <br>ASSERT(hr == NOERROR); <br>      } <br> <br>      for(j = 0; j &lt; DIM(rgrgbColors); ++j){ <br>        hr = rgprempoly[i]-&gt;SetWidth(i + j); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::SetWidth()")); <br> <br>        hr = rgprempoly[i]-&gt;set_red(rgrgbColors[j].red); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::set_red()")); <br> <br>        hr = rgprempoly[i]-&gt;set_green(rgrgbColors[j].green); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::set_green()")); <br> <br>        hr = rgprempoly[i]-&gt;set_blue(rgrgbColors[j].blue); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::set_blue()")); <br> <br>        hr = rgprempoly[i]-&gt;SetXOrigin((2*i) + j &lt;&lt; 4); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::SetXOrigin()")); <br> <br>        hr = rgprempoly[i]-&gt;SetYOrigin(j &lt;&lt; 4); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::SetYOrigin()")); <br> <br>        hr = rgprempoly[i]-&gt;Draw(); <br>ASSERT(hr == NOERROR); <br>IfMac(DbPrintf("CRemPoly::Draw()")); <br>      } <br>    } <br> <br>    hr = NOERROR; <br> <br>LError0:; <br>    for(i = 0; i &lt; numpoly; ++i){ <br>      if(rgprempoly[i] != (CRemPoly FAR*)NULL){ <br>rgprempoly[i]-&gt;Release(); <br>      } <br>    } <br> <br>    return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
