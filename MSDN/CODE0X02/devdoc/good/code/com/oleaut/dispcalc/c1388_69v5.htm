<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPCALC.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1391"></a>DISPCALC.H</h2>
<pre><code>/***  <br>*dispcalc.h <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  UNDONE <br>* <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "hostenv.h" <br>#include "resource.h" <br>#include "clsid.h" <br> <br>#ifndef CLASS <br># ifdef __TURBOC__ <br>#  define CLASS class huge <br># else <br>#  define CLASS class FAR <br># endif <br>#endif <br> <br>#pragma warning(disable:4355) <br> <br>#ifdef _MAC <br># define NEARDATA <br>#else <br># ifdef WIN32 <br>#  define NEARDATA <br># else <br>#  define NEARDATA __near <br># endif <br>#endif <br> <br>#ifdef _MAC <br># define UNUSED(X) ((void)(void*)&amp;(X)) <br>#else <br># define UNUSED(X) (X) <br>#endif <br> <br>#define DIM(X) (sizeof(X)/sizeof(X[0])) <br> <br> <br> <br>// forward decl <br>CLASS CCalc; <br> <br>// Introduced "calculator" interface <br>// <br>// This class implementes core arithmetic functionality <br>// (such as it is) *and* is the interface that will be <br>// exposed via IDispatch for external programmability. <br> <br>#if defined(_MAC) &amp;&amp; !(!defined(applec) || defined(__SC__) || defined(_MSC_VER)) <br> <br>// Mac Note: The default implementation of IDispatch places <br>// a couple of requirements on the layout of an instance that <br>// in can invoke on. <br>// <br>//   1. It assumes that the vtable pointer is at offset 0 <br>//      from the beginning of the instance. This appears <br>//      to always be the case if the class derives from <br>//      an interface, and hence the games I play below <br>//      creating a stub _CArith interface containing a <br>//      single pure virtual function. The only reason for <br>//      this is to ensure that the vtable ptr is at offset <br>//      0 when this class is a member of CCalc. If your <br>//      class derives from an Ole interface, then you are ok. <br>// <br>//   2. It assumes that the vtable is a simple array of <br>//      function pointers, with index zero reserved. In <br>//      order to ensure this, the class must derive from <br>//      SingleObject. Note that IUnknown derives from SingleObject, <br>//      so if your class derives from any Ole interface, then <br>//      you are also ok - otherwise you need to explicitly <br>//      derive from SingleObject as I have done below. <br>// <br>//  (The above comments apply to MPW C++ v3.3) <br>//       <br> <br>interface _CArith : public SingleObject <br>{ <br>    STDMETHOD_(void,  put_Accum)(long l) PURE; <br>}; <br>CLASS CArith : public _CArith <br>#else <br>CLASS CArith <br>#endif <br>{ <br>public: <br>#if defined(_MAC) <br>    BEGIN_INTERFACE <br>#endif //_MAC <br> <br>    STDMETHOD_(void,  put_Accum)(long l); <br>    STDMETHOD_(long,  get_Accum)(void); <br>    STDMETHOD_(void,  put_Opnd)(long l); <br>    STDMETHOD_(long,  get_Opnd)(void); <br>    STDMETHOD_(void,  put_Op)(short op); <br>    STDMETHOD_(short, get_Op)(void); <br>    STDMETHOD_(short, Eval)(void); <br>    STDMETHOD_(void,  Clear)(void); <br>    STDMETHOD_(void,  Display)(void); <br>    STDMETHOD_(void,  Quit)(void); <br>    STDMETHOD_(short, Button)(BSTR button); <br> <br>    // the following method is internal, and not exposed for programmability <br>    int ButtonPush(int button); <br> <br>    CArith(CCalc FAR* pcalc){ <br>      m_pcalc = pcalc; <br>      Clear(); <br>    } <br>    enum states { STATE_LOPND, STATE_OP, STATE_ROPND, STATE_EVAL }; <br> <br>private: <br>    CCalc FAR*  m_pcalc; <br> <br>    shortm_op; <br>    longm_opnd; <br>    longm_accum; <br>    enum states m_state; <br>}; <br> <br> <br>CLASS CCalc : public IUnknown { <br>public: <br>    friend CArith; <br> <br>    static CCalc FAR* Create(); <br> <br>    STDMETHOD(QueryInterface)(REFIID riid, void FAR* FAR* ppv); <br>    STDMETHOD_(unsigned long, AddRef)(void); <br>    STDMETHOD_(unsigned long, Release)(void); <br> <br>    CCalc(); <br> <br>#ifdef _MAC <br>    DialogPtr m_pdlg;  <br>#else <br>    HWND m_hwnd; <br>#endif <br>    CArith m_arith; <br> <br>private: <br>    unsigned long m_refs; <br>    IUnknown FAR* m_punkStdDisp; <br>}; <br> <br>enum operators { <br>    OP_NONE = 0, <br>    OP_PLUS, <br>    OP_MINUS, <br>    OP_MULT, <br>    OP_DIV <br>}; <br> <br>// the following enum defines method indices used by the <br>// default IDispatch implementation - DispInvoke(). <br>// <br>// Note: these must match the order of the preceeding declarations <br>// <br>enum IMETH_CARITH { <br>    IMETH_PUTACCUM = 0, <br>    IMETH_GETACCUM, <br>    IMETH_PUTOPERAND, <br>    IMETH_GETOPERAND, <br>    IMETH_PUTOPERATOR, <br>    IMETH_GETOPERATOR, <br>    IMETH_EVAL, <br>    IMETH_CLEAR, <br>    IMETH_DISPLAY, <br>    IMETH_QUIT, <br>    IMETH_BUTTON, <br> <br>    // Define the "property" indices. these are defined to be <br>    // the first index in a set/get property method pair. These <br>    // definitions are used to build the METHODDATA that drives <br>    // our implementation of IDispatch. see cdisp.cpp. <br>    // <br>    IMETH_ACCUM    = IMETH_PUTACCUM, <br>    IMETH_OPERAND  = IMETH_PUTOPERAND, <br>    IMETH_OPERATOR = IMETH_PUTOPERATOR <br>}; <br> <br>// the following enum defines the IDs used by IDispatch <br>// <br>// Note: these values do *not* depend on order of declaration, <br>// but are sensitive to the kind of the method - ie, if a get/set <br>// method pair implements a property, then they need to share <br>// an ID. <br>// <br>// Note: by assigning "accum" the ID 'DISPID_VALUE', we are <br>// choosing to expose it as the default "value" property. <br>// <br>enum IDMEMBER_CARITH { <br>    IDMEMBER_ACCUM = DISPID_VALUE,// the default property <br>    IDMEMBER_OPERAND, <br>    IDMEMBER_OPERATOR, <br>    IDMEMBER_EVAL, <br>    IDMEMBER_CLEAR, <br>    IDMEMBER_DISPLAY, <br>    IDMEMBER_QUIT, <br>    IDMEMBER_BUTTON <br>}; <br> <br> <br>// the CCalc Class Factory <br>// <br>CLASS CCalcCF : public IClassFactory { <br>public: <br>    static IClassFactory FAR* Create(); <br> <br>    STDMETHOD(QueryInterface)(REFIID riid, void FAR* FAR* ppv); <br>    STDMETHOD_(unsigned long, AddRef)(void); <br>    STDMETHOD_(unsigned long, Release)(void); <br> <br>    STDMETHOD(CreateInstance)( <br>      IUnknown FAR* punkOuter, REFIID riid, void FAR* FAR* ppv); <br>#ifdef _MAC <br>    STDMETHOD(LockServer)(unsigned long fLock); <br>#else <br>    STDMETHOD(LockServer)(BOOL fLock); <br>#endif <br> <br>    CCalcCF() { m_refs = 1; } <br> <br>private: <br>    unsigned long m_refs; <br>}; <br> <br>extern HRESULT InitOle(void); <br>extern HRESULT UninitOle(void); <br> <br>extern CCalc FAR* g_pcalc; <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
