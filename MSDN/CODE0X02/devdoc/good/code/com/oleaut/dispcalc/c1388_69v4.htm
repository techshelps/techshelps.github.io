<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DISPCALC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1390"></a>DISPCALC.CPP</h2>
<pre><code>/***  <br>*dispcalc.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the basic user interface and arithmetic <br>*  functionality of the IDispatch calculator.  <br>* <br>*  The implementation of IDispatch it via aggregation with an <br>*  instance of the "standard" IDispatch implementation, which is <br>*  initialized with a DispTypeInfo constructed from an INTERFACEDATA <br>*  description. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "dispcalc.h" <br> <br>CCalc FAR* g_pcalc = NULL; <br> <br>unsigned long g_dwCCalcCF = 0; <br>unsigned long g_dwRegisterCCalc = 0; <br> <br>#ifdef _MAC          <br>extern Boolean g_fQuit; <br>#endif //_MAC <br> <br> <br>CCalc::CCalc() : m_arith(this) <br>{ <br>    m_refs = 0; <br>#ifdef _MAC <br>    m_pdlg = nil; <br>#else <br>    m_hwnd = NULL; <br>#endif <br>    m_punkStdDisp = NULL; <br>} <br> <br>/*** <br>*CCalc *CCalc::Create(void) <br>*Purpose: <br>*  Create an instance of the IDispatch calculator, build a <br>*  TypeInfo that describes the exposed functionality and <br>*  aggregate with an instance of CStdDispatch that has been <br>*  initialized with this TypeInfo. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = CCalc*, NULL if the creation failed. <br>* <br>***********************************************************************/ <br>CCalc FAR* <br>CCalc::Create() <br>{ <br>    HRESULT hresult; <br>    CCalc FAR* pcalc; <br>    CArith FAR* parith; <br>    ITypeInfo FAR* ptinfo; <br>    IUnknown FAR* punkStdDisp; <br>extern INTERFACEDATA NEARDATA g_idataCCalc; <br> <br>    if((pcalc = new FAR CCalc()) == NULL) <br>      return NULL; <br>    pcalc-&gt;AddRef(); <br> <br>    parith = &amp;(pcalc-&gt;m_arith); <br> <br>    // Build a TypeInfo for the functionality on this object that <br>    // is being exposing for external programmability. <br>    // <br>    hresult = CreateDispTypeInfo( <br>      &amp;g_idataCCalc, LOCALE_SYSTEM_DEFAULT, &amp;ptinfo); <br>    if(hresult != NOERROR) <br>      goto LError0; <br> <br>    // Create and aggregate with an instance of the default <br>    // implementation of IDispatch that is initialized with our <br>    // TypeInfo. <br>    // <br>    hresult = CreateStdDispatch( <br>      pcalc,                    // controlling unknown <br>      parith,                   // instance to dispatch on <br>      ptinfo,                   // typeinfo describing the instance <br>      &amp;punkStdDisp); <br> <br>    ptinfo-&gt;Release(); <br> <br>    if(hresult != NOERROR) <br>      goto LError0; <br> <br>    pcalc-&gt;m_punkStdDisp = punkStdDisp; <br> <br>    return pcalc; <br> <br>LError0:; <br>    pcalc-&gt;Release(); <br> <br>    return NULL; <br>} <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br>STDMETHODIMP <br>CCalc::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown)){ <br>      *ppv = this; <br>    }else <br>    if(IsEqualIID(riid, IID_IDispatch)){ <br>      return m_punkStdDisp-&gt;QueryInterface(riid, ppv); <br>    }else { <br>      *ppv = NULL;           <br>      return E_NOINTERFACE;  <br>    } <br> <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CCalc::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CCalc::Release() <br>{ <br>    if(--m_refs == 0){ <br>      if(m_punkStdDisp != NULL) <br>m_punkStdDisp-&gt;Release(); <br>#ifndef _MAC <br>      PostQuitMessage(0); <br>#endif <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                       Arithmetic features <br>//--------------------------------------------------------------------- <br> <br>STDMETHODIMP_(void) <br>CArith::Clear() <br>{ <br>    m_opnd = 0; <br>    m_accum = 0; <br>    m_op = OP_NONE; <br>    m_state = STATE_LOPND; <br>} <br> <br>STDMETHODIMP_(void) <br>CArith::put_Accum(long l) <br>{ <br>    m_accum = l; <br>} <br> <br> <br>STDMETHODIMP_(long) <br>CArith::get_Accum() <br>{ <br>    return m_accum; <br>} <br> <br>STDMETHODIMP_(void) <br>CArith::put_Opnd(long l) <br>{ <br>    m_opnd = l; <br>} <br> <br>STDMETHODIMP_(long) <br>CArith::get_Opnd() <br>{ <br>    return m_opnd; <br>} <br> <br>STDMETHODIMP_(void) <br>CArith::put_Op(short op) <br>{ <br>    m_op = op; <br>} <br> <br>STDMETHODIMP_(short) <br>CArith::get_Op() <br>{ <br>    return m_op; <br>} <br> <br>STDMETHODIMP_(short) <br>CArith::Eval() <br>{ <br>    if(m_op == OP_NONE) <br>      return 0; <br> <br>    switch(m_op){ <br>    case OP_PLUS: <br>      m_accum += m_opnd; <br>      break; <br>    case OP_MINUS: <br>      m_accum -= m_opnd; <br>      break; <br>    case OP_MULT: <br>      m_accum *= m_opnd; <br>      break; <br>    case OP_DIV: <br>      m_accum = (m_opnd == 0) ? 0 : (m_accum / m_opnd); <br>      break; <br>    default: <br>      // ASSERT(UNREACHED); <br>      return 0; <br>       <br>    } <br> <br>    m_state = STATE_EVAL; <br> <br>    return 1; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                       User Interface features <br>//--------------------------------------------------------------------- <br> <br>/*** <br>*void CArith::Display() <br>*Purpose: <br>*  Display the contents of the register currently being edited. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(void) <br>CArith::Display() <br>{ <br>    VARIANT var; <br> <br>    VariantInit(&amp;var); <br>     <br>    V_VT(&amp;var) = VT_I4; <br>    V_I4(&amp;var) = (m_state == STATE_ROPND) ? m_opnd : m_accum; <br>    VariantChangeType(&amp;var, &amp;var, 0, VT_BSTR); <br> <br>#ifdef _MAC <br>    { <br>      Rect rcItem; <br>      Handle hItem; <br>      char str[255]; <br>      short sItemKind; <br> <br>      strcpy(str, V_BSTR(&amp;var)); <br>      GetDItem(m_pcalc-&gt;m_pdlg, IDC_DISPLAY, &amp;sItemKind, &amp;hItem, &amp;rcItem); <br>      SetIText(hItem, c2pstr(str)); <br>    } <br>#else <br>    SetDlgItemText(m_pcalc-&gt;m_hwnd, IDC_DISPLAY, STRING(V_BSTR(&amp;var))); <br>#endif <br> <br>    VariantClear(&amp;var); <br>} <br> <br>STDMETHODIMP_(short) <br>CArith::Button(BSTR bstrButton) <br>{ <br>    int i, button; <br> <br>static struct { <br>    OLECHAR ch; <br>    int idc; <br>} NEARDATA rgIdcOfCh[] = { <br>      { OLESTR('+'), IDC_PLUS   } <br>    , { OLESTR('-'), IDC_MINUS  } <br>    , { OLESTR('*'), IDC_MULT   } <br>    , { OLESTR('/'), IDC_DIV    } <br>    , { OLESTR('C'), IDC_CLEAR  } <br>    , { OLESTR('c'), IDC_CLEAR  } <br>    , { OLESTR('='), IDC_EQUALS } <br>    , { OLESTR('0'), IDC_ZERO   } <br>    , { OLESTR('1'), IDC_ONE    } <br>    , { OLESTR('2'), IDC_TWO    } <br>    , { OLESTR('3'), IDC_THREE  } <br>    , { OLESTR('4'), IDC_FOUR   } <br>    , { OLESTR('5'), IDC_FIVE   } <br>    , { OLESTR('6'), IDC_SIX    } <br>    , { OLESTR('7'), IDC_SEVEN  } <br>    , { OLESTR('8'), IDC_EIGHT  } <br>    , { OLESTR('9'), IDC_NINE   } <br>    , { (OLECHAR)-1 , -1         } <br>}; <br> <br>    // if the string is more that 1 character long, then we know its wrong. <br>    if(SysStringLen(bstrButton) &gt; 1) <br>      return 0; <br> <br>    // translate button string into control ID <br>    for(i = 0;; ++i){ <br>      if(rgIdcOfCh[i].ch == -1) <br>return 0; <br>      if(rgIdcOfCh[i].ch == bstrButton[0]){ <br>button = rgIdcOfCh[i].idc; <br>break; <br>      } <br>    } <br> <br>    return ButtonPush(button); <br>} <br> <br>// the following method is internal, and not exposed for programmability <br>int <br>CArith::ButtonPush(int button) <br>{ <br>    if(button &gt;= IDC_ZERO &amp;&amp; button &lt;= IDC_NINE){ <br> <br>      long lVal = button - IDC_ZERO; <br> <br>      switch(m_state){ <br>      case STATE_EVAL: <br>m_accum = lVal; <br>m_state = STATE_LOPND; <br>break; <br>      case STATE_OP: <br>m_opnd = lVal; <br>m_state = STATE_ROPND; <br>break; <br>      case STATE_LOPND: <br>m_accum = (m_accum * 10) + lVal; <br>break; <br>      case STATE_ROPND: <br>m_opnd  = (m_opnd * 10) + lVal; <br>break; <br>      } <br> <br>    }else if(button &gt;= IDC_PLUS &amp;&amp; button &lt;= IDC_DIV){ <br> <br>      if(m_state == STATE_ROPND) <br>Eval(); <br> <br>      m_opnd  = m_accum; <br>      m_state = STATE_OP; <br>      m_op    = button - IDC_PLUS + OP_PLUS; <br> <br>    }else if(button == IDC_EQUALS){ <br> <br>      if(m_state &gt; STATE_LOPND) <br>Eval(); <br> <br>    }else if (button == IDC_CLEAR){ <br> <br>      Clear(); <br> <br>    }else{ <br> <br>      return 0; // unknown button <br> <br>    } <br> <br>    // Flash the button <br> <br>#ifdef _MAC <br>    { <br>      Rect rcItem; <br>      long lDummy; <br>      Handle hItem; <br>      short sItemKind; <br> <br>      GetDItem(m_pcalc-&gt;m_pdlg, button, &amp;sItemKind, &amp;hItem, &amp;rcItem); <br>      HiliteControl((ControlHandle)hItem, 1); <br>      Delay(6, &amp;lDummy); <br>      HiliteControl((ControlHandle)hItem, 0); <br>    } <br>#else <br>    SendMessage(m_pcalc-&gt;m_hwnd, BM_SETSTATE, 1, 0L); <br>    SendMessage(m_pcalc-&gt;m_hwnd, BM_SETSTATE, 0, 0L); <br>#endif <br> <br>    // Update the calculator display <br> <br>    Display(); <br> <br>    return 1; <br>} <br> <br>/*** <br>*void CArith::Quit() <br>*Purpose: <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(void) <br>CArith::Quit() <br>{ <br>#ifndef _MAC <br>    PostQuitMessage(0); <br>#else <br>    g_fQuit = 1; <br>#endif <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                      The CCalc Class Factory <br>//--------------------------------------------------------------------- <br> <br>IClassFactory FAR* <br>CCalcCF::Create() <br>{ <br>    return new FAR CCalcCF(); <br>} <br> <br>STDMETHODIMP <br>CCalcCF::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown) ||  <br>       IsEqualIID(riid, IID_IClassFactory)){ <br>      AddRef(); <br>      *ppv = this; <br>      return NOERROR; <br>    } <br>     <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CCalcCF::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CCalcCF::Release() <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br>STDMETHODIMP <br>CCalcCF::CreateInstance( <br>    IUnknown FAR* punkOuter, <br>    REFIID riid, <br>    void FAR* FAR* ppv) <br>{ <br>    if(punkOuter != NULL) <br>      return CLASS_E_NOAGGREGATION; <br>    return g_pcalc-&gt;QueryInterface(riid, ppv); <br>} <br> <br>STDMETHODIMP <br>#ifdef _MAC <br>CCalcCF::LockServer(unsigned long fLock) <br>#else <br>CCalcCF::LockServer(BOOL fLock) <br>#endif <br>{ <br>    UNUSED(fLock); <br>    return NOERROR; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                        Ole Init/Uninit <br>//--------------------------------------------------------------------- <br> <br>HRESULT <br>UninitOle() <br>{ <br>    if(g_dwRegisterCCalc != 0) <br>      RevokeActiveObject(g_dwRegisterCCalc, NULL); <br> <br>    if(g_dwCCalcCF != 0) <br>      CoRevokeClassObject(g_dwCCalcCF); <br> <br>    if(g_pcalc != NULL) <br>      g_pcalc-&gt;Release(); <br> <br>    OleUninitialize(); <br> <br>    return NOERROR; <br>} <br> <br>#ifdef _MAC <br>struct regentry{ <br>    char *szKey; <br>    char *szValue; <br>} g_rgregentry[] = { <br> <br>      { "CLSID\\{00020467-0000-0000-C000-000000000046}", <br>"OLE Automation DispCalc 1.0 Application" } <br> <br>    , { "CLSID\\{00020467-0000-0000-C000-000000000046}\\LocalServer", <br>"DCLC" } <br> <br>    , { "CLSID\\{00020467-0000-0000-C000-000000000046}\\ProgID", <br>"Dispcalc.Application" } <br> <br>    , { "CLSID\\{00020467-0000-0000-C000-000000000046}\\InprocHandler", <br>"OLE2:Def$DefFSet" } <br> <br>    , { "DCLC", "{00020467-0000-0000-C000-000000000046}" } <br> <br>    , { "Dispcalc.Application\\CLSID", <br>"{00020467-0000-0000-C000-000000000046}" } <br> <br>}; <br> <br>HRESULT <br>EnsureRegistration() <br>{ <br>    HKEY hkey; <br> <br>    if(RegOpenKey(HKEY_CLASSES_ROOT, "DCLC", &amp;hkey) == NOERROR){ <br>      RegCloseKey(hkey); <br>      return NOERROR; <br>    } <br> <br>    for(int i = 0; i &lt; DIM(g_rgregentry); ++i){ <br>      if(RegSetValue(HKEY_CLASSES_ROOT, g_rgregentry[i].szKey, REG_SZ, g_rgregentry[i].szValue, 0) != ERROR_SUCCESS) <br>return E_FAIL; <br>    } <br> <br>    return NOERROR; <br>} <br>#endif <br> <br>/*** <br>*HRESULT InitOle(void) <br>*Purpose: <br>*  Initialize Ole, and register our class factories. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>HRESULT <br>InitOle() <br>{ <br>    HRESULT hresult; <br>    IClassFactory FAR* pcf; <br> <br>    if(FAILED(hresult = OleInitialize(NULL))) <br>      goto LError0; <br> <br>#ifdef _MAC <br>    if(FAILED(hresult = EnsureRegistration())) <br>      goto LError0; <br>#endif <br> <br>    // create the single global instance of CCalc <br>    if((g_pcalc = CCalc::Create()) == NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError0; <br>    } <br> <br>    if((pcf = CCalcCF::Create()) == NULL) <br>      goto LError1; <br> <br>    hresult = CoRegisterClassObject( <br>      CLSID_CCalc, <br>      pcf, <br>      CLSCTX_LOCAL_SERVER, <br>      REGCLS_MULTIPLEUSE, <br>      &amp;g_dwCCalcCF); <br>    if(FAILED(hresult)) <br>      goto LError2; <br> <br>    hresult = RegisterActiveObject( <br>      g_pcalc, CLSID_CCalc, NULL, &amp;g_dwRegisterCCalc); <br>    if(FAILED(hresult)) <br>      goto LError2; <br> <br>    pcf-&gt;Release(); <br> <br>    return NOERROR; <br> <br>LError2:; <br>    pcf-&gt;Release(); <br> <br>LError1:; <br>    UninitOle(); <br> <br>LError0:; <br>    return hresult; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
