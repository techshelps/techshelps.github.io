<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPOINT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1442"></a>CPOINT.CPP</h2>
<pre><code>/***  <br>*cpoint.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the CPoint and CPointCF classes. <br>* <br>*  This module is intended as a sample implementation of the IDispatch <br>*  interface, and its purpose is to demonstrate how an object can <br>*  expose methods and properties for programatic and cross-process <br>*  access via the IDispatch interface. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "spoly.h" <br>#include "cpoint.h" <br> <br> <br>CPoint::CPoint() <br>{ <br>    m_x = 0; <br>    m_y = 0; <br>    m_refs = 0; <br>} <br> <br>/*** <br>*CPoint::Create(void) <br>*Purpose: <br>*  Create an instance of a CPoint object. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  returns a CPoint*, NULL if creation failed. <br>* <br>***********************************************************************/ <br>CPoint FAR* <br>CPoint::Create() <br>{ <br>    CPoint FAR* ppoint; <br> <br>    if((ppoint = new FAR CPoint()) == NULL) <br>      return NULL; <br>    ppoint-&gt;AddRef(); <br>    return ppoint; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IUnknown Methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CPoint::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(!IsEqualIID(riid, IID_IUnknown)) <br>      if(!IsEqualIID(riid, IID_IDispatch)) { <br>        *ppv = NULL;       <br>        return E_NOINTERFACE; <br>    } <br> <br>    *ppv = this; <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoint::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoint::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IDispatch methods <br>//--------------------------------------------------------------------- <br> <br>/* <br> * NOTE: Support for the following two methods is not available <br> * in this version. <br> * <br> */ <br> <br>STDMETHODIMP <br>CPoint::GetTypeInfoCount(unsigned int FAR* pctinfo) <br>{ <br>    *pctinfo = 0; <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP <br>CPoint::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) <br>{ <br>    UNUSED(itinfo); <br>    UNUSED(lcid); <br>    UNUSED(pptinfo); <br> <br>    return E_NOTIMPL; <br>} <br> <br> <br>/*** <br>*HRESULT CPoint::GetIDsOfNames(REFIID, OLECHAR**, unsigned int, LCID, long*) <br>*Purpose: <br>*  This method translates the given array of names to a corresponding <br>*  array of DISPIDs. <br>* <br>*  Index 0 of the name array is the member name, and indices 1-N if <br>*  present represent named parameters on that member. <br>* <br>*  The local ID ('lcid') is unused by this naive implementation. A more <br>*  sophisticated implementation, sensitive to localization and natural <br>*  language support would use the locale ID to interpret the given names <br>*  in a correct locale specific context. <br>* <br>*Entry: <br>*  rgszNames = pointer to an array of names <br>*  cNames = the number of names in the rgszNames array <br>*  lcid = the callers locale ID <br>* <br>*Exit: <br>*  return value = HRESULT <br>*  rgid = array of name IDs corresponding to the rgszNames array <br>*    this array will contain -1 for each entry that is not known. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoint::GetIDsOfNames( <br>    REFIID riid, <br>    OLECHAR FAR* FAR* rgszNames, <br>    unsigned int cNames, <br>    LCID lcid, <br>    DISPID FAR* rgdispid) <br>{ <br>static MEMBERDESC rgmdCPoint[] = { <br>    {OLESTR("GETX"),IDMEMBER_CPOINT_GETX,NULL,0}, <br>    {OLESTR("SETX"),IDMEMBER_CPOINT_SETX,NULL,0}, <br>    {OLESTR("GETY"),IDMEMBER_CPOINT_GETY,NULL,0}, <br>    {OLESTR("SETY"),IDMEMBER_CPOINT_SETY,NULL,0} <br>}; <br> <br>    // this object only exposed the "default" interface. <br>    // <br>    if(!IsEqualIID(riid, IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    return SPolyGetIDsOfNames( <br>      rgmdCPoint, DIM(rgmdCPoint), rgszNames, cNames, lcid, rgdispid); <br>} <br> <br> <br>/*** <br>*HRESULT CPoint::Invoke(...) <br>*Purpose: <br>*  Dispatch a method or property request for objects of type CPoint. <br>* <br>*  see the IDispatch document for more information, and a general <br>*  description of this method. <br>* <br>*Entry: <br>*  dispidMember = the DISPID of the member being requested <br>* <br>*  riid = reference to the interface ID of the interface on this object <br>*    that the requested member belongs to. IID_NULL means to interpret <br>*    the member as belonging to the implementation defined "default" <br>*    or "primary" interface. <br>* <br>*  lcid = the caller's locale ID <br>* <br>*  wFlags = flags indicating the type of access being requested <br>* <br>*  pdispparams = pointer to the DISPPARAMS struct containing the <br>*    requested members arguments (if any) and its named parameter <br>*    DISPIDs (if any). <br>* <br>*Exit: <br>*  return value = HRESULT <br>*   see the IDispatch spec for a description of possible success codes. <br>* <br>*  pvarResult = pointer to a caller allocated VARIANT containing <br>*    the members return value (if any). <br>* <br>*  pexcepinfo = caller allocated exception info structure, this will <br>*    be filled in only if an exception was raised that must be passed <br>*    up through Invoke to an enclosing handler. <br>* <br>*  puArgErr = pointer to a caller allocated UINT, that will contain the <br>*    index of the offending argument if a DISP_E_TYPEMISMATCH error <br>*    was returned indicating that one of the arguments was of an <br>*    incorrect type and/or could not be reasonably coerced to a proper <br>*    type. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoint::Invoke( <br>    DISPID dispidMember, <br>    REFIID riid, <br>    LCID lcid, <br>    unsigned short wFlags, <br>    DISPPARAMS FAR* pdispparams, <br>    VARIANT FAR* pvarResult, <br>    EXCEPINFO FAR* pexcepinfo, <br>    unsigned int FAR* puArgErr) <br>{ <br>    unsigned int uArgErr; <br>    HRESULT hresult; <br>    VARIANTARG varg0; <br>    VARIANT varResultDummy; <br> <br>    UNUSED(lcid); <br>    UNUSED(pexcepinfo); <br> <br>    // make sure the wFlags are legal <br>    if(wFlags &amp; ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) <br>      return E_INVALIDARG; <br> <br>    // this object only exposes a "default" interface. <br>    // <br>    if(!IsEqualIID(riid, IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    // this makes the following code a bit simpler <br>    if(puArgErr == NULL) <br>      puArgErr = &amp;uArgErr; <br>    if(pvarResult == NULL) <br>      pvarResult = &amp;varResultDummy; <br> <br>    VariantInit(&amp;varg0); <br> <br>    // assume the return type is void, unless we find otherwise. <br>    VariantInit(pvarResult); <br> <br>    switch(dispidMember){ <br>    case IDMEMBER_CPOINT_GETX: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = GetX(); <br>      break; <br> <br>    case IDMEMBER_CPOINT_SETX: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      SetX(V_I2(&amp;varg0)); <br>      break; <br> <br>    case IDMEMBER_CPOINT_GETY: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = GetY(); <br>      break; <br> <br>    case IDMEMBER_CPOINT_SETY: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      SetY(V_I2(&amp;varg0)); <br>      break; <br> <br>    default: <br>      return DISP_E_MEMBERNOTFOUND; <br>    } <br>    return NOERROR; <br>} <br> <br>short PASCAL <br>CPoint::GetX() <br>{ <br>    return m_x; <br>} <br> <br>void PASCAL <br>CPoint::SetX(short x) <br>{ <br>    m_x = x; <br>} <br> <br>short PASCAL <br>CPoint::GetY() <br>{ <br>    return m_y; <br>} <br> <br>void PASCAL <br>CPoint::SetY(short y) <br>{ <br>    m_y = y; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//         Implementation of the CPoint Class Factory <br>//--------------------------------------------------------------------- <br> <br>CPointCF::CPointCF() <br>{ <br>    m_refs = 0; <br>} <br> <br>IClassFactory FAR* <br>CPointCF::Create() <br>{ <br>    CPointCF FAR* pCF; <br> <br>    if((pCF = new FAR CPointCF()) == NULL) <br>      return NULL; <br>    pCF-&gt;AddRef(); <br>    return pCF; <br>} <br> <br>STDMETHODIMP <br>CPointCF::QueryInterface(REFIID riid, void FAR* FAR* ppv)  <br>{  <br> <br>    if(!IsEqualIID(riid, IID_IUnknown)) <br>      if(!IsEqualIID(riid, IID_IClassFactory)) { <br>        *ppv = NULL;       <br>        return E_NOINTERFACE; <br>    } <br> <br>    *ppv = this; <br>    ++m_refs; <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPointCF::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPointCF::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br>STDMETHODIMP <br>CPointCF::CreateInstance( <br>    IUnknown FAR* punkOuter, <br>    REFIID riid, <br>    void FAR* FAR* ppv) <br>{ <br>    HRESULT hresult; <br>    CPoint FAR *ppoint; <br> <br>    UNUSED(punkOuter); <br> <br>    if((ppoint = CPoint::Create()) == NULL){ <br>      *ppv = NULL; <br>      return E_OUTOFMEMORY; <br>    } <br>    hresult = ppoint-&gt;QueryInterface(riid, ppv); <br>    ppoint-&gt;Release(); <br>    return hresult; <br>} <br> <br>STDMETHODIMP <br>#ifdef _MAC <br>CPointCF::LockServer(unsigned long fLock) <br>#else <br>CPointCF::LockServer(BOOL fLock) <br>#endif <br>{ <br>    UNUSED(fLock); <br> <br>    return NOERROR; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
