<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CENUMPT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1448"></a>CENUMPT.CPP</h2>
<pre><code>/***  <br>*cenumpt.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the CEnumPoint class. <br>* <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "hostenv.h" <br>#include "cenumpt.h" <br> <br> <br>CEnumPoint::CEnumPoint() <br>{ <br>    m_refs = 0; <br> <br>    m_psa = NULL; <br>    m_celts = 0; <br>    m_iCurrent = 0; <br>} <br> <br> <br>/*** <br>*HRESULT CEnumPoint::Create(SAFEARRAY*, CEnumPoint**) <br>*Purpose: <br>*  This routine creates a CPoint enumerator from the given <br>*  (1 X N) SafeArray of CPoint IDispatch pointers. <br>* <br>*Entry: <br>*  psa = pointer to a SafeArray of VARIANTs <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *ppenum = pointer to a CPoint enumerator <br>* <br>***********************************************************************/ <br>HRESULT <br>CEnumPoint::Create(SAFEARRAY FAR* psa, CEnumPoint FAR* FAR* ppenum) <br>{ <br>    long lBound; <br>    HRESULT hresult; <br>    CEnumPoint FAR* penum; <br> <br> <br>    // Verify that the SafeArray is the proper shape. <br>    // <br>    if(SafeArrayGetDim(psa) != 1) <br>      return E_INVALIDARG; <br> <br>    hresult = SafeArrayGetLBound(psa, 1, &amp;lBound); <br>    if(FAILED(hresult)) <br>      return hresult; <br> <br>    if(lBound != 0) <br>      return E_INVALIDARG; <br> <br>    penum = new FAR CEnumPoint(); <br>    if(penum == NULL) <br>      return E_OUTOFMEMORY; <br>    penum-&gt;AddRef(); <br> <br>    hresult = SafeArrayGetUBound(psa, 1, &amp;lBound); <br>    if(FAILED(hresult)) <br>      goto LError0; <br> <br>    penum-&gt;m_psa = psa; <br>    penum-&gt;m_celts = lBound + 1; <br> <br>    *ppenum = penum; <br> <br>    return NOERROR; <br> <br>LError0:; <br>    penum-&gt;Release(); <br> <br>    return hresult; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CEnumPoint::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br> <br>    if(!IsEqualIID(riid, IID_IUnknown)) <br>      if(!IsEqualIID(riid, IID_IEnumVARIANT)) { <br>        *ppv = NULL;       <br>        return E_NOINTERFACE; <br>    } <br> <br>    *ppv = this; <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CEnumPoint::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CEnumPoint::Release() <br>{ <br>    if(--m_refs == 0){ <br>      if(m_psa != NULL) <br>SafeArrayDestroy(m_psa); <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                        IEnumVARIANT methods <br>//--------------------------------------------------------------------- <br> <br> <br>/*** <br>*HRESULT CEnumPoint::Next(unsigned long, VARIANT*, unsigned long*) <br>*Purpose: <br>*  Attempt to get the next 'celt' items in the enumeration sequence. <br>* <br>*Entry: <br>*  celt = the number of elements to get <br>* <br>*Exit: <br>*  return value = HRESULT <br>*    S_OK <br>*    S_FALSE - the end of the sequence was reached <br>* <br>*  rgvar = array of the next 'celt' items <br>*  *pceltFetched = count of the elements actually fetched. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CEnumPoint::Next( <br>    unsigned long celt, <br>    VARIANT FAR* rgvar, <br>    unsigned long FAR* pceltFetched) <br>{ <br>    long ix; <br>    unsigned int i; <br>    HRESULT hresult; <br> <br> <br>    for(i = 0; i &lt; celt; ++i) <br>      VariantInit(&amp;rgvar[i]); <br> <br>    for(i = 0; i &lt; celt; ++i){ <br>      if(m_iCurrent == m_celts){ <br>        hresult = S_FALSE; <br>goto LDone; <br>      } <br> <br>      ix = m_iCurrent++; <br>      hresult = SafeArrayGetElement(m_psa, &amp;ix, &amp;rgvar[i]); <br>      if(FAILED(hresult)) <br>goto LError0; <br>    } <br> <br>    hresult = NOERROR; <br> <br>LDone:; <br>    if (pceltFetched != NULL) <br>      *pceltFetched = i; <br> <br>    return hresult; <br> <br>LError0:; <br> <br>    for(i = 0; i &lt; celt; ++i) <br>      VariantClear(&amp;rgvar[i]); <br> <br>    return hresult; <br>} <br> <br> <br>/*** <br>*HRESULT CEnumPoint::Skip(unsigned long) <br>*Purpose: <br>*  Attempt to skip over the next 'celt' elements in the enumeration <br>*  sequence. <br>* <br>*Entry: <br>*  celt = the count of elements to skip <br>* <br>*Exit: <br>*  return value = HRESULT <br>*    S_OK <br>*    S_FALSE -  the end of the sequence was reached <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CEnumPoint::Skip(unsigned long celt) <br>{ <br>    m_iCurrent += celt; <br> <br>    if(m_iCurrent &gt; m_celts) <br>     m_iCurrent = m_celts; <br> <br>    return (m_iCurrent == m_celts) <br>      ? S_FALSE : NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CEnumPoint::Reset(void) <br>*Purpose: <br>*  Reset the enumeration sequence back to the beginning. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = SHRESULT CODE <br>*    S_OK <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CEnumPoint::Reset() <br>{ <br>    m_iCurrent = 0; <br> <br>    return NOERROR;  <br>} <br> <br> <br>/*** <br>*HRESULT CEnumPoint::Clone(IEnumVARIANT**) <br>*Purpose: <br>*  Retrun a CPoint enumerator with exactly the same state as the <br>*  current one. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>*    S_OK <br>*    E_OUTOFMEMORY <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CEnumPoint::Clone(IEnumVARIANT FAR* FAR* ppenum) <br>{ <br>    HRESULT hresult; <br>    SAFEARRAY FAR* psa; <br>    CEnumPoint FAR* penum; <br> <br>    hresult = SafeArrayCopy(m_psa, &amp;psa); <br>    if(FAILED(hresult)) <br>      return hresult; <br> <br>    hresult = CEnumPoint::Create(psa, &amp;penum); <br>    if(FAILED(hresult)) <br>      goto LError0; <br> <br>    // Assert(penum-&gt;m_celts == m_celts); <br> <br>    penum-&gt;m_iCurrent = m_iCurrent; <br> <br>    *ppenum = penum; <br> <br>    return NOERROR; <br> <br>LError0: <br>    SafeArrayDestroy(psa); <br> <br>    return hresult; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
