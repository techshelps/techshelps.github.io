<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPOLY.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1444"></a>CPOLY.CPP</h2>
<pre><code>/***  <br>*CPoly.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the CPoly and CPolyCF classes. <br>* <br>*  This module is intended as a sample implementation of the IDispatch <br>*  interface, and its purpose is to demonstrate how an object can <br>*  expose methods and properties for programatic and cross-process <br>*  access via the IDispatch interface. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "spoly.h" <br>#include "cpoint.h" <br>#include "cpoly.h" <br>#include "cenumpt.h" <br> <br>#ifndef _MAC <br>extern CStatBar FAR* g_psb; <br>#else <br>extern "C" WindowPtr g_pwndClient; <br>#endif <br> <br>extern unsigned int g_fQuit; <br> <br>// our global list of polygons. <br>// <br>POLYLINK FAR* g_ppolylink = (POLYLINK FAR*)NULL; <br> <br>// global count of polygons. <br>// <br>int g_cPoly = 0; <br> <br> <br>CPoly::CPoly() <br>{ <br>    m_refs = 0; <br>    m_xorg = 0; <br>    m_yorg = 0; <br>    m_width = 0; <br>    m_cPoints = 0; <br> <br>    m_red   = 0; <br>    m_green = 0; <br>    m_blue  = 0; <br> <br>    m_ppointlink = NULL; <br>    m_ppointlinkLast = NULL; <br>} <br> <br> <br>/*** <br>*CPoly *CPoly::Create(void) <br>*Purpose: <br>*  Create an instance of a CPoly object, and add it to the global <br>*  list of polygons. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  returns a polygon object, NULL the allocation failed. <br>* <br>***********************************************************************/ <br>CPoly FAR* <br>CPoly::Create() <br>{ <br>    CPoly FAR* ppoly; <br>    POLYLINK FAR* ppolylink; <br> <br>    if((ppolylink = new FAR POLYLINK) == (POLYLINK FAR*)NULL) <br>      return (CPoly FAR*)NULL; <br> <br>    if((ppoly = new FAR CPoly()) == (CPoly FAR*)NULL) <br>      return (CPoly FAR*)NULL; <br> <br>    ppoly-&gt;AddRef(); <br> <br>    // push the new polygon onto the front of the polygon list. <br>    // <br>    ++g_cPoly; <br> <br>    ppolylink-&gt;ppoly = ppoly; <br> <br>    ppolylink-&gt;next = g_ppolylink; <br>    g_ppolylink = ppolylink; <br> <br>#ifndef _MAC <br>    SBprintf(g_psb, TSTR("#poly = %d"), g_cPoly); <br>#endif <br> <br>    IncObjectCount(); <br> <br>    return ppoly; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IUnknown Methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CPoly::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown) || <br>       IsEqualIID(riid, IID_IDispatch)) { <br>      *ppv = this; <br>      AddRef(); <br>      return NOERROR;        <br>    } <br>        <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoly::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoly::Release() <br>{ <br>    POLYLINK FAR* FAR* pppolylink, FAR* ppolylinkDead; <br> <br>    if(--m_refs == 0){ <br>      Reset(); // release all CPoints <br> <br>      // remove ourselves from the global list of polygons <br>      // <br>      for( pppolylink = &amp;g_ppolylink; <br>          *pppolylink != NULL; <br>   pppolylink = &amp;(*pppolylink)-&gt;next) <br>      { <br>if((*pppolylink)-&gt;ppoly == this){ <br>  ppolylinkDead = *pppolylink; <br>  *pppolylink = (*pppolylink)-&gt;next; <br>  delete ppolylinkDead; <br>  break; <br>} <br>      } <br> <br>      --g_cPoly; <br> <br>#ifndef _MAC <br>      SBprintf(g_psb, TSTR("#poly = %d"), g_cPoly); <br>#endif <br> <br>      delete this; <br> <br>      DecObjectCount(); <br> <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IDispatch Methods <br>//--------------------------------------------------------------------- <br> <br> <br>/* <br> * NOTE: Support for the following two methods is not available <br> * in this version. <br> * <br> */ <br> <br>STDMETHODIMP <br>CPoly::GetTypeInfoCount(unsigned int FAR* pctinfo) <br>{ <br>    *pctinfo = 0; <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP <br>CPoly::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) <br>{ <br>    UNUSED(itinfo); <br>    UNUSED(lcid); <br>    UNUSED(pptinfo); <br> <br>    return E_NOTIMPL; <br>} <br> <br> <br>/*** <br>*HRESULT CPoly::GetIDsOfNames(OLECHAR**, unsigned int, LCID, long*) <br>*Purpose: <br>*  This method translates the given array of names to a corresponding <br>*  array of DISPIDs. <br>* <br>*  This method deferrs to a common implementation shared by <br>*  both the CPoly and CPoint objects. See the description of <br>*  'SPolyGetIDsOfNames()' in dispimpl.cpp for more information. <br>* <br>*Entry: <br>*  rgszNames = pointer to an array of names <br>*  cNames = the number of names in the rgszNames array <br>*  lcid = the callers locale ID <br>* <br>*Exit: <br>*  return value = HRESULT <br>*  rgdispid = array of DISPIDs corresponding to the rgszNames array <br>*    this array will contain -1 for each entry that is not known. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoly::GetIDsOfNames( <br>    REFIID riid, <br>    OLECHAR FAR* FAR* rgszNames, <br>    unsigned int cNames, <br>    LCID lcid, <br>    DISPID FAR* rgdispid) <br>{ <br>static PARAM_DESC rgpdAddPoint[] = { <br>    {OLESTR("X")}, {OLESTR("Y")} <br>}; <br>static MEMBERDESC rgmdCPoly[] = { <br>    {OLESTR("DRAW"),   IDMEMBER_CPOLY_DRAW,NULL,0}, <br>    {OLESTR("RESET"),   IDMEMBER_CPOLY_RESET,NULL,0}, <br>    {OLESTR("ADDPOINT"),   IDMEMBER_CPOLY_ADDPOINT,rgpdAddPoint,2}, <br>    {OLESTR("ENUMPOINTS"), IDMEMBER_CPOLY_ENUMPOINTS,NULL,0}, <br>    {OLESTR("GETXORIGIN"), IDMEMBER_CPOLY_GETXORIGIN,NULL,0}, <br>    {OLESTR("SETXORIGIN"), IDMEMBER_CPOLY_SETXORIGIN,NULL,0}, <br>    {OLESTR("GETYORIGIN"), IDMEMBER_CPOLY_GETYORIGIN,NULL,0}, <br>    {OLESTR("SETYORIGIN"), IDMEMBER_CPOLY_SETYORIGIN,NULL,0}, <br>    {OLESTR("GETWIDTH"),   IDMEMBER_CPOLY_GETWIDTH,NULL,0}, <br>    {OLESTR("SETWIDTH"),   IDMEMBER_CPOLY_SETWIDTH,NULL,0}, <br>    {OLESTR("get_red"),   IDMEMBER_CPOLY_GETRED,NULL,0}, <br>    {OLESTR("set_red"),   IDMEMBER_CPOLY_SETRED,NULL,0}, <br>    {OLESTR("get_green"),  IDMEMBER_CPOLY_GETGREEN,NULL,0}, <br>    {OLESTR("set_green"),  IDMEMBER_CPOLY_SETGREEN,NULL,0}, <br>    {OLESTR("get_blue"),   IDMEMBER_CPOLY_GETBLUE,NULL,0}, <br>    {OLESTR("set_blue"),   IDMEMBER_CPOLY_SETBLUE,NULL,0}, <br>    {OLESTR("DUMP"),   IDMEMBER_CPOLY_DUMP,NULL,0}, <br>    {OLESTR("Quit"),       IDMEMBER_CPOLY_QUIT,     NULL,       0} <br>}; <br> <br>    // this object only exposes a "default" interface. <br>    // <br>    if(!IsEqualIID(riid, IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    return SPolyGetIDsOfNames( <br>      rgmdCPoly, DIM(rgmdCPoly), rgszNames, cNames, lcid, rgdispid); <br>} <br> <br> <br>/*** <br>*HRESULT CPoly::Invoke(...) <br>*Purpose: <br>*  Dispatch a method or property request for objects of type CPoly. <br>* <br>*  see the IDispatch document for more information, and a general <br>*  description of this method. <br>* <br>*Entry: <br>*  dispidMember = the DISPID of the member being requested <br>* <br>*  riid = reference to the interface ID of the interface on this object <br>*    that the requested member belongs to. IID_NULL means to interpret <br>*    the member as belonging to the implementation defined "default" <br>*    or "primary" interface. <br>* <br>*  lcid = the caller's locale ID <br>* <br>*  wFlags = flags indicating the type of access being requested <br>* <br>*  pdispparams = pointer to the DISPPARAMS struct containing the <br>*    requested members arguments (if any) and its named parameter <br>*    DISPIDs (if any). <br>* <br>*Exit: <br>*  return value = HRESULT <br>*   see the IDispatch spec for a description of possible success codes. <br>* <br>*  pvarResult = pointer to a caller allocated VARIANT containing <br>*    the members return value (if any). <br>* <br>*  pexcepinfo = caller allocated exception info structure, this will <br>*    be filled in only if an exception was raised that must be passed <br>*    up through Invoke to an enclosing handler. <br>* <br>*  puArgErr = pointer to a caller allocated UINT, that will contain the <br>*    index of the offending argument if a DISP_E_TYPEMISMATCH error <br>*    was returned indicating that one of the arguments was of an <br>*    incorrect type and/or could not be reasonably coerced to a proper <br>*    type. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoly::Invoke( <br>    DISPID dispidMember, <br>    REFIID riid, <br>    LCID lcid, <br>    unsigned short wFlags, <br>    DISPPARAMS FAR* pdispparams, <br>    VARIANT FAR* pvarResult, <br>    EXCEPINFO FAR* pexcepinfo, <br>    unsigned int FAR* puArgErr) <br>{ <br>    HRESULT hresult; <br>    VARIANTARG varg0, varg1; <br>    VARIANT varResultDummy; <br> <br>    UNUSED(lcid); <br>    UNUSED(pexcepinfo); <br> <br>    if(wFlags &amp; ~(DISPATCH_METHOD | DISPATCH_PROPERTYGET | DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) <br>      return E_INVALIDARG; <br> <br>    // this object only exposes a "default" interface. <br>    // <br>    if(!IsEqualIID(riid, IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    // This makes the following code a bit simpler if the caller <br>    // happens to be ignoring the return value. Some implementations <br>    // may choose to deal with this differently. <br>    // <br>    if(pvarResult == (VARIANT FAR*)NULL) <br>      pvarResult = &amp;varResultDummy; <br> <br>    VariantInit(&amp;varg0); <br>    VariantInit(&amp;varg1); <br> <br>    // assume the return type is void, unless we find otherwise. <br>    VariantInit(pvarResult); <br> <br>    switch(dispidMember){ <br>    case IDMEMBER_CPOLY_DRAW: <br>      Draw(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_RESET: <br>      Reset(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_DUMP: <br>      Dump(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_QUIT: <br>      Quit(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_ADDPOINT: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>return hresult; <br> <br>      hresult = DispGetParam(pdispparams, 1, VT_I2, &amp;varg1, puArgErr); <br>      if(hresult != NOERROR) <br>return hresult; <br> <br>      hresult = AddPoint(V_I2(&amp;varg1), V_I2(&amp;varg0)); <br>      if(hresult != NOERROR) <br>return hresult; <br>      break; <br> <br>    case IDMEMBER_CPOLY_ENUMPOINTS: <br>      IEnumVARIANT FAR* penum; <br> <br>      hresult = EnumPoints(&amp;penum); <br>      if(hresult != NOERROR) <br>return hresult; <br> <br>      V_VT(pvarResult) = VT_UNKNOWN; <br>      hresult = penum-&gt;QueryInterface( <br>IID_IUnknown, (void FAR* FAR*)&amp;V_UNKNOWN(pvarResult)); <br>      if(hresult != NOERROR) <br>return hresult; <br>      penum-&gt;Release(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETXORIGIN: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = m_xorg; <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETXORIGIN: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      m_xorg = V_I2(&amp;varg0); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETYORIGIN: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = m_yorg; <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETYORIGIN: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      m_yorg = V_I2(&amp;varg0); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETWIDTH: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = GetWidth(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETWIDTH: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      SetWidth(V_I2(&amp;varg0)); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETRED: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = get_red(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETRED: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      set_red(V_I2(&amp;varg0)); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETGREEN: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = get_green(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETGREEN: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      set_green(V_I2(&amp;varg0)); <br>      break; <br> <br>    case IDMEMBER_CPOLY_GETBLUE: <br>      V_VT(pvarResult) = VT_I2; <br>      V_I2(pvarResult) = get_blue(); <br>      break; <br> <br>    case IDMEMBER_CPOLY_SETBLUE: <br>      hresult = DispGetParam(pdispparams, 0, VT_I2, &amp;varg0, puArgErr); <br>      if(hresult != NOERROR) <br>        return hresult; <br>      set_blue(V_I2(&amp;varg0)); <br>      break; <br> <br>    default: <br>      return DISP_E_MEMBERNOTFOUND; <br>    } <br> <br>    return NOERROR; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     Introduced Methods <br>//--------------------------------------------------------------------- <br> <br> <br>/*** <br>*void CPoly::Draw(void) <br>*Purpose: <br>*  Draw the polygon, using the current x/y origin and line width <br>*  properties. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void PASCAL <br>CPoly::Draw() <br>{ <br>    short xorg, yorg; <br>    POINTLINK FAR* ppointlinkFirst, FAR* ppointlink; <br> <br>    if((ppointlinkFirst = m_ppointlink) == (POINTLINK FAR*)NULL) <br>      return; <br> <br>#ifdef _MAC /* { */ <br> <br>    short x, y; <br>    RGBColor rgb; <br>    WindowPtr pwndSaved; <br> <br>    GetPort(&amp;pwndSaved); <br>    SetPort(g_pwndClient); <br> <br>    PenNormal(); <br>    PenSize(m_width, m_width); <br> <br>    rgb.red = m_red; <br>    rgb.green = m_green; <br>    rgb.blue = m_blue; <br>    RGBForeColor(&amp;rgb); <br> <br>    xorg = m_xorg; <br>    yorg = m_yorg; <br> <br>    MoveTo( <br>      xorg + ppointlinkFirst-&gt;ppoint-&gt;m_x, <br>      yorg + ppointlinkFirst-&gt;ppoint-&gt;m_y); <br> <br>    for(ppointlink = ppointlinkFirst-&gt;next; <br>ppointlink != (POINTLINK FAR*)NULL; <br>ppointlink = ppointlink-&gt;next) <br>    { <br>      x = xorg + ppointlink-&gt;ppoint-&gt;m_x; <br>      y = yorg + ppointlink-&gt;ppoint-&gt;m_y; <br>      LineTo(x, y); <br>    } <br> <br>    LineTo( <br>      xorg + ppointlinkFirst-&gt;ppoint-&gt;m_x, <br>      yorg + ppointlinkFirst-&gt;ppoint-&gt;m_y); <br> <br>    SetPort(pwndSaved); <br> <br>#else /* }{ */ <br> <br>    HDC hdc; <br>    RECT rect; <br>    HPEN hpen, hpenOld; <br>extern HWND g_hwndClient; <br> <br>    GetClientRect(g_hwndClient, &amp;rect); <br>    xorg = m_xorg + (short) rect.left; <br>    yorg = m_yorg + (short) rect.top; <br> <br>    hdc = GetDC(g_hwndClient); <br>    hpen = CreatePen(PS_SOLID, m_width, RGB(m_red, m_green, m_blue)); <br>    hpenOld = (HPEN)SelectObject(hdc, hpen); <br> <br>#ifdef WIN32 <br>    MoveToEx(hdc, <br>      xorg + ppointlinkFirst-&gt;ppoint-&gt;m_x, <br>      yorg + ppointlinkFirst-&gt;ppoint-&gt;m_y, NULL); <br>#else <br>    MoveTo(hdc, <br>      xorg + ppointlinkFirst-&gt;ppoint-&gt;m_x, <br>      yorg + ppointlinkFirst-&gt;ppoint-&gt;m_y); <br>#endif <br> <br>    for(ppointlink = ppointlinkFirst-&gt;next; <br>ppointlink != (POINTLINK FAR*)NULL; <br>ppointlink = ppointlink-&gt;next) <br>    { <br>      LineTo(hdc, <br>xorg + ppointlink-&gt;ppoint-&gt;m_x, <br>yorg + ppointlink-&gt;ppoint-&gt;m_y); <br>    } <br> <br>    LineTo(hdc, <br>      xorg + ppointlinkFirst-&gt;ppoint-&gt;m_x, <br>      yorg + ppointlinkFirst-&gt;ppoint-&gt;m_y); <br> <br>    SelectObject(hdc, hpenOld); <br>    DeleteObject(hpen); <br> <br>    ReleaseDC(g_hwndClient, hdc); <br> <br>#endif /* } */ <br>} <br> <br> <br>/*** <br>*void CPoly::Reset(void) <br>*Purpose: <br>*  Release all points referenced by this poly. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void PASCAL <br>CPoly::Reset() <br>{ <br>    POINTLINK FAR* ppointlink, FAR* ppointlinkNext; <br> <br>    for(ppointlink = m_ppointlink; <br>ppointlink != (POINTLINK FAR*)NULL; <br>ppointlink = ppointlinkNext) <br>    { <br>      ppointlinkNext = ppointlink-&gt;next; <br>      ppointlink-&gt;ppoint-&gt;Release(); <br>      delete ppointlink; <br>    } <br> <br>    m_cPoints = 0; <br>    m_ppointlink = NULL; <br>    m_ppointlinkLast = NULL; <br>} <br> <br> <br>/*** <br>*HRESULT CPoly::AddPoint(short, short) <br>*Purpose: <br>*  Add a CPoint with the given coordinates to the end of our current <br>*  list of points. <br>* <br>*Entry: <br>*  x,y = the x and y coordinates of the new point. <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>***********************************************************************/ <br>HRESULT PASCAL <br>CPoly::AddPoint(short x, short y) <br>{ <br>    CPoint FAR* ppoint; <br>    POINTLINK FAR* ppointlink; <br> <br>    ppoint = CPoint::Create(); <br>    if(ppoint == (CPoint FAR*)NULL) <br>      return E_OUTOFMEMORY; <br> <br>    ppoint-&gt;SetX(x); <br>    ppoint-&gt;SetY(y); <br> <br>    ppointlink = new FAR POINTLINK; <br>    if(ppointlink == (POINTLINK FAR*)NULL){ <br>      delete ppoint; <br>      return E_OUTOFMEMORY; <br>    } <br> <br>    ppointlink-&gt;ppoint = ppoint; <br>    ppointlink-&gt;next = (POINTLINK FAR*)NULL; <br> <br>    if(m_ppointlinkLast == (POINTLINK FAR*)NULL){ <br>      m_ppointlink = m_ppointlinkLast = ppointlink; <br>    }else{ <br>      m_ppointlinkLast-&gt;next = ppointlink; <br>      m_ppointlinkLast = ppointlink; <br>    } <br> <br>    ++m_cPoints; <br> <br>    return NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CPoly::EnumPoints(IEnumVARIANT**); <br>*Purpose: <br>*  Return and enumerator for the points in this polygon. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = HRESULT <br>* <br>*  *ppenum = pointer to an IEnumVARIANT for the points in this polygon <br>* <br>***********************************************************************/ <br>HRESULT PASCAL <br>CPoly::EnumPoints(IEnumVARIANT FAR* FAR* ppenum) <br>{ <br>    unsigned int i; <br>    VARIANT var; <br>    HRESULT hresult; <br>    SAFEARRAY FAR* psa; <br>    CEnumPoint FAR* penum; <br>    POINTLINK FAR* ppointlink; <br>    SAFEARRAYBOUND rgsabound[1]; <br> <br>    rgsabound[0].lLbound = 0; <br>    rgsabound[0].cElements = m_cPoints; <br> <br>    psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound); <br>    if(psa == NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError0; <br>    } <br> <br>    ppointlink = m_ppointlink; <br>    for(i = 0; i &lt; m_cPoints; ++i){ <br>      long ix[1]; <br> <br>      if(ppointlink == NULL){ <br>        // this indicates an internal consistency error. <br>// (this test should probably be an assertion) <br>        hresult = E_FAIL; <br>        goto LError1; <br>      } <br> <br>      V_VT(&amp;var) = VT_DISPATCH; <br>      hresult = ppointlink-&gt;ppoint-&gt;QueryInterface( <br>IID_IDispatch, (void FAR* FAR*)&amp;V_DISPATCH(&amp;var)); <br>      if(hresult != NOERROR) <br>        goto LError1; <br> <br>      ix[0] = i; <br>      SafeArrayPutElement(psa, ix, &amp;var); <br> <br>      // SafeArrayPutElement adds a reference to the contents of the <br>      // variant, so we must free the variable we have. <br>      // <br>      VariantClear(&amp;var); <br> <br>      ppointlink = ppointlink-&gt;next; <br>    } <br> <br>    hresult = CEnumPoint::Create(psa, &amp;penum); <br>    if(hresult != NOERROR) <br>      goto LError1; <br> <br>    *ppenum = penum; <br> <br>    return NOERROR; <br> <br>LError1:; <br>    // destroy the array if we were not successful creating the enumerator. <br>    SafeArrayDestroy(psa); <br> <br>LError0:; <br>    return hresult; <br>} <br> <br>short PASCAL <br>CPoly::GetXOrigin() <br>{ <br>    return m_xorg; <br>} <br> <br>void PASCAL <br>CPoly::SetXOrigin(short x) <br>{ <br>    m_xorg = x; <br>} <br> <br>short PASCAL <br>CPoly::GetYOrigin() <br>{ <br>    return m_yorg; <br>} <br> <br>void PASCAL <br>CPoly::SetYOrigin(short y) <br>{ <br>    m_yorg = y; <br>} <br> <br>short PASCAL <br>CPoly::GetWidth() <br>{ <br>    return m_width; <br>} <br> <br>void PASCAL <br>CPoly::SetWidth(short width) <br>{ <br>    m_width = width; <br>} <br> <br>short PASCAL <br>CPoly::get_red() <br>{ <br>    return m_red; <br>} <br> <br>void PASCAL <br>CPoly::set_red(short red) <br>{ <br>    m_red = red; <br>} <br> <br>short PASCAL <br>CPoly::get_green() <br>{ <br>    return m_green; <br>} <br> <br>void PASCAL <br>CPoly::set_green(short green) <br>{ <br>    m_green = green; <br>} <br> <br>short PASCAL <br>CPoly::get_blue() <br>{ <br>    return m_blue; <br>} <br> <br>void PASCAL <br>CPoly::set_blue(short blue) <br>{ <br>    m_blue = blue; <br>} <br> <br> <br>/*** <br>*void CPoly::Dump(void) <br>*Purpose: <br>*  Output a debug dump of this instance. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void PASCAL <br>CPoly::Dump() <br>{ <br>#ifdef _MAC <br> <br>    // REVIEW: implement for the mac <br> <br>#else <br> <br>    TCHAR buffer[80]; <br>    POINTLINK FAR* ppointlink; <br> <br>    wsprintf(buffer, TSTR("CPoly(0x%x) =\n"), (int)this); <br>    OutputDebugString(buffer); <br> <br>    wsprintf(buffer, <br>      TSTR("    xorg = %d, yorg = %d, width = %d, rgb = {%d,%d,%d}\n    points = "), <br>      m_xorg, m_yorg, m_width, <br>      get_red(), <br>      get_green(), <br>      get_blue()); <br> <br>    OutputDebugString(buffer); <br> <br>    for(ppointlink = m_ppointlink; <br>ppointlink != (POINTLINK FAR*)NULL; <br>ppointlink = ppointlink-&gt;next) <br>    { <br>      wsprintf(buffer, TSTR("{%d,%d}"), <br>        ppointlink-&gt;ppoint-&gt;GetX(), <br>        ppointlink-&gt;ppoint-&gt;GetY()); <br>      OutputDebugString(buffer); <br> <br>      wsprintf(buffer, TSTR(" ")); <br>      OutputDebugString(buffer); <br>    } <br>    wsprintf(buffer, TSTR("\n")); <br>    OutputDebugString(buffer); <br> <br>#endif <br>} <br> <br>/*** <br>*void CPoly::Quit(void) <br>*Purpose: <br>*  Exit when all objects are released. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void PASCAL <br>CPoly::Quit() <br>{ <br>    g_fQuit = 1; <br>} <br> <br>/*** <br>*void CPoly::PolyDraw(void) <br>*Purpose: <br>*  Draw all polygons. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CPoly::PolyDraw() <br>{ <br>    POLYLINK FAR* polylink; <br> <br>    for(polylink = g_ppolylink; <br>polylink != (POLYLINK FAR*)NULL; <br>polylink = polylink-&gt;next) <br>    { <br>      polylink-&gt;ppoly-&gt;Draw(); <br>    } <br>} <br> <br> <br>/*** <br>*void PolyTerm(void) <br>*Purpose: <br>*  Release all polygons. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CPoly::PolyTerm() <br>{ <br>    POLYLINK FAR* ppolylink; <br>    POLYLINK FAR* ppolylinkNext; <br> <br>    for(ppolylink = g_ppolylink; <br>ppolylink != (POLYLINK FAR*)NULL; <br>ppolylink = ppolylinkNext) <br>    { <br>      ppolylinkNext = ppolylink-&gt;next; <br>      ppolylink-&gt;ppoly-&gt;Release(); <br>      delete ppolylink; <br>    } <br>    g_ppolylink = NULL; <br>} <br> <br> <br>/*** <br>*void PolyDump(void) <br>*Purpose: <br>*  Invoke the debug Dump() method on all polygons were currently <br>*  holding on to. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CPoly::PolyDump() <br>{ <br>    POLYLINK FAR* ppolylink; <br> <br>    if(g_ppolylink == (POLYLINK FAR*)NULL){ <br>#ifndef _MAC <br>      OutputDebugString(TSTR("\t(none)\n")); <br>#endif <br>      return; <br>    } <br> <br>    for(ppolylink = g_ppolylink; <br>ppolylink != (POLYLINK FAR*)NULL; <br>ppolylink = ppolylink-&gt;next) <br>    { <br>      ppolylink-&gt;ppoly-&gt;Dump(); <br>    } <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//             Implementation of the CPoly Class Factory  <br>//--------------------------------------------------------------------- <br> <br> <br>CPolyCF::CPolyCF() <br>{ <br>    m_refs = 0; <br>} <br> <br>IClassFactory FAR* <br>CPolyCF::Create() <br>{ <br>    CPolyCF FAR* pCF; <br> <br>    if((pCF = new FAR CPolyCF()) == NULL) <br>      return NULL; <br>    pCF-&gt;AddRef(); <br>    return pCF; <br>} <br> <br>STDMETHODIMP <br>CPolyCF::QueryInterface(REFIID riid, void FAR* FAR* ppv)  <br>{ <br>    if(!IsEqualIID(riid, IID_IUnknown)){ <br>      if(!IsEqualIID(riid, IID_IClassFactory)){ <br>*ppv = NULL; <br>        return E_NOINTERFACE; <br>      } <br>    } <br> <br>    *ppv = this; <br>    ++m_refs; <br>    return NOERROR; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPolyCF::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPolyCF::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br>STDMETHODIMP <br>CPolyCF::CreateInstance( <br>    IUnknown FAR* punkOuter, <br>    REFIID iid, <br>    void FAR* FAR* ppv) <br>{ <br>    HRESULT hresult; <br>    CPoly FAR *ppoly; <br> <br>    UNUSED(punkOuter); <br> <br>#ifdef _MAC <br>    if(GetZone() != ApplicZone()){ <br>#ifndef _MSC_VER <br>#ifndef ConstStr255Param <br>#define ConstStr255Param StringPtr <br>#endif <br>#endif <br>      DebugStr((ConstStr255Param)"\pZones do not match"); <br>    } <br> <br>#endif <br> <br>    if((ppoly = CPoly::Create()) == NULL){ <br>      *ppv = NULL; <br>      return E_OUTOFMEMORY; <br>    } <br>    hresult = ppoly-&gt;QueryInterface(iid, ppv); <br>    ppoly-&gt;Release(); <br>    return hresult; <br>} <br> <br>STDMETHODIMP <br>#ifdef _MAC <br>CPolyCF::LockServer(unsigned long fLock) <br>#else <br>CPolyCF::LockServer(BOOL fLock) <br>#endif <br>{ <br>    UNUSED(fLock); <br> <br>    return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
