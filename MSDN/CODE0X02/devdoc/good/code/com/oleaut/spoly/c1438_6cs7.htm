<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MISC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1447"></a>MISC.CPP</h2>
<pre><code>/***  <br>*misc.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br> <br> <br>#include "spoly.h" <br>#include "cpoint.h" <br>#include "cpoly.h" <br> <br>#include &lt;stdio.h&gt; <br> <br>#ifdef _MAC <br># include &lt;string.h&gt; <br># include &lt;ctype.h&gt; <br>#endif <br>       <br>#ifdef WIN32  // Use native CompareString operation <br>  #undef CompareString <br>  #ifdef UNICODE <br>    #define CompareString CompareStringW <br>  #else <br>    // CONSIDER: write a wrapper for CompareStringW if not available <br>  #endif <br>#else   <br>  #define CompareString CompareStringA <br>#endif   <br> <br>unsigned long g_dwPolyCF = 0; <br>unsigned long g_dwPointCF = 0; <br> <br>IClassFactory FAR* g_ppolyCF = NULL; <br>IClassFactory FAR* g_ppointCF = NULL; <br> <br>unsigned int g_fObjectsRevoked = 0; <br>unsigned long g_cObjects = 0; <br>unsigned int g_fQuit = 0; <br> <br>#ifdef _MAC <br>struct regentry{ <br>    char *szKey; <br>    char *szValue; <br>} g_rgregentry[] = { <br> <br>      { "CLSID\\{00020462-0000-0000-C000-000000000046}", <br>"OLE Automation SPoly 1.0 Application" } <br> <br>    , { "CLSID\\{00020462-0000-0000-C000-000000000046}\\LocalServer", <br>"SPLy" } <br> <br>    , { "CLSID\\{00020462-0000-0000-C000-000000000046}\\ProgID", <br>"SPoly.Application" } <br> <br>    , { "CLSID\\{00020462-0000-0000-C000-000000000046}\\InprocHandler", <br>"OLE2:Def$DefFSet" } <br> <br>    , { "SPLy", "{00020462-0000-0000-C000-000000000046}" } <br> <br>    , { "SPoly.Application\\CLSID", <br>"{00020462-0000-0000-C000-000000000046}" } <br> <br>}; <br> <br>HRESULT <br>EnsureRegistration() <br>{ <br>    HKEY hkey; <br> <br>    if(RegOpenKey(HKEY_CLASSES_ROOT, "SPLy", &amp;hkey) == NOERROR){ <br>      RegCloseKey(hkey); <br>      return NOERROR; <br>    } <br> <br>    for(int i = 0; i &lt; DIM(g_rgregentry); ++i){ <br>      if(RegSetValue(HKEY_CLASSES_ROOT, g_rgregentry[i].szKey, REG_SZ, g_rgregentry[i].szValue, 0) != ERROR_SUCCESS) <br>        return E_FAIL; <br>    } <br> <br>    return NOERROR; <br>} <br>#endif <br> <br> <br>/*** <br>*HRESULT InitOle(void) <br>*Purpose: <br>*  Initialize Ole, and register our class factories. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDAPI <br>InitOle() <br>{ <br>    HRESULT hresult; <br> <br>    if((hresult = OleInitialize(NULL)) != NOERROR) <br>      goto LError0; <br> <br>#ifdef _MAC <br>    if((hresult = EnsureRegistration()) != NOERROR) <br>      goto LError0; <br>#endif <br> <br>    // Register the CPoint Class Factory <br>    // <br>    if((g_ppointCF = CPointCF::Create()) == NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError1; <br>    } <br> <br>    hresult = CoRegisterClassObject( <br>      CLSID_CPoint, <br>      g_ppointCF, <br>      CLSCTX_LOCAL_SERVER, <br>      REGCLS_MULTIPLEUSE, <br>      &amp;g_dwPointCF); <br>    if(FAILED(hresult)) <br>      goto LError1; <br> <br>    // Register the CPoly Class Factory. <br>    // <br>    if((g_ppolyCF = CPolyCF::Create()) == NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError1; <br>    } <br> <br>    hresult = CoRegisterClassObject( <br>      CLSID_CPoly, <br>      g_ppolyCF, <br>      CLSCTX_LOCAL_SERVER, <br>      REGCLS_MULTIPLEUSE, <br>      &amp;g_dwPolyCF); <br>    if(FAILED(hresult)) <br>      goto LError1; <br> <br>    g_ppolyCF-&gt;Release(); <br> <br>    g_ppointCF-&gt;Release(); <br> <br>    return NOERROR; <br> <br> <br>LError1:; <br>    if(g_ppolyCF != NULL) <br>      g_ppolyCF-&gt;Release(); <br> <br>    if(g_ppointCF != NULL) <br>      g_ppointCF-&gt;Release(); <br> <br>    UninitOle(); <br> <br>LError0:; <br>    return hresult; <br>} <br> <br>STDAPI  <br>Revoke() <br>{ <br>    if (!g_fObjectsRevoked) { <br>      // Tell Ole to release our class factories. <br>      // <br>      if(g_dwPointCF != 0L) <br>        CoRevokeClassObject(g_dwPointCF); <br> <br>      if(g_dwPolyCF != 0L) <br>        CoRevokeClassObject(g_dwPolyCF); <br> <br>      g_fObjectsRevoked = 1; <br>    } <br> <br>    return NOERROR; <br>} <br> <br>STDAPI <br>UninitOle() <br>{ <br>    Revoke(); <br>    OleUninitialize(); <br> <br>    return NOERROR; <br>} <br> <br>/*** <br>*HRESULT SPolyGetIDsOfNames(MEMBERDESC*, unsigned int, char**, unsigned int, LCID, long*) <br>*Purpose: <br>*  This is the table driven implementation of IDispatch::GetIDsOfNames <br>*  deferred to by both the CPoint and CPoly objects. <br>* <br>*Entry: <br>*  rgmd = pointer to an array of method descriptors <br>*  cMethods = number of elements in the array of method descriptors <br>*  rgszNames = pointer to an array of names <br>*  cNames = the number of names in the rgszNames array <br>*  lcid = the callers locale ID <br>* <br>*Exit: <br>*  return value = HRESULT <br>*  rgdispid = array of name IDs corresponding to the rgszNames array <br>*    this array will contain -1 for each entry that is not known. <br>* <br>***********************************************************************/ <br>STDAPI <br>SPolyGetIDsOfNames( <br>    MEMBERDESC FAR* rgmd, <br>    unsigned int cMethods, <br>    OLECHAR FAR* FAR* rgszNames, <br>    unsigned int cNames, <br>    LCID lcid, <br>    DISPID FAR* rgdispid) <br>{ <br>    HRESULT hresult; <br>    PARAM_DESC FAR* ppd; <br>    MEMBERDESC FAR* pmd; <br>    unsigned int iName, iTry, cParams; <br> <br>    hresult = NOERROR; <br> <br>    // first lookup the member name. <br>    // <br>    for(pmd = rgmd;; ++pmd){ <br>      if(pmd == &amp;rgmd[cMethods]) <br>        goto LMemberNotFound; <br> <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>      // CompareStringW is not available on Windows 95 <br>      if(wcsicmp(rgszNames[0], pmd-&gt;szName) == 0) <br>#else <br>      if(CompareString(lcid, NORM_IGNORECASE, rgszNames[0], -1, pmd-&gt;szName, -1) == 2) <br>#endif <br>      { <br>rgdispid[0] = pmd-&gt;id; <br>break; <br>      } <br>    } <br> <br>    // Lookup the named parameters, if there are any. <br>    if(cNames &gt; 1){ <br>      cParams = pmd-&gt;cParams; <br>      for(iName = 1; iName &lt; cNames; ++iName){ <br>for(iTry = 0;; ++iTry){ <br>  if(iTry == cParams){ <br>    hresult = DISP_E_UNKNOWNNAME; <br>    rgdispid[iName] = -1; <br>    break; <br>  } <br>  ppd = &amp;pmd-&gt;rgpd[iTry]; <br> <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>          // CompareStringW is not available on Windows 95 <br>          if(wcsicmp(rgszNames[iName], ppd-&gt;szName) == 0) <br>#else <br>  if(CompareString(lcid, NORM_IGNORECASE, rgszNames[iName], -1, ppd-&gt;szName, -1) == 2) <br>#endif <br>  { <br>    // The DISPID for a named parameter is defined to be its <br>    // zero based positional index.  This routine assumes that <br>    // that PARAM_DESC array was declared in correct textual order. <br>    // <br>    rgdispid[iName] = iTry; <br>    break; <br>  } <br>        } <br>      } <br>    } <br> <br>    return hresult; <br> <br>LMemberNotFound:; <br>    // If the member name is unknown, everything is unknown. <br>    for(iName = 0; iName &lt; cNames; ++iName) <br>      rgdispid[iName] = -1; <br>    return DISP_E_UNKNOWNNAME; <br>} <br> <br> <br>// disable unicode expansion for assertions <br>#undef UNICODE <br> <br>void <br>Assert(int fCond, char FAR* file, int line, char FAR* message) <br>{ <br>    char * fmt; <br>    char buf[128]; <br> <br>    if(fCond) <br>      return; <br> <br>    fmt = (message == NULL) <br>      ? "Assertion failed: %s(%d)" <br>      : "Assertion failed: %s(%d) '%s'"; <br>    sprintf(buf, fmt, file, line, message); <br> <br>#ifdef _MAC <br>    DebugStr(c2pstr(buf)); <br>#else <br>#ifdef WIN32 <br>    OutputDebugStringA(buf); <br>#else //WIN32 <br>    OutputDebugString(buf); <br>#endif //WIN32 <br>    DebugBreak(); <br>#endif <br>} <br> <br>void IncObjectCount() <br>{ <br>    g_cObjects++; <br>} <br> <br>void DecObjectCount() <br>{ <br>    g_cObjects--; <br> <br>    if (!g_cObjects &amp;&amp; g_fQuit) { <br>      Revoke(); <br>#ifndef _MAC <br>      PostQuitMessage(0); <br>#endif // !_MAC <br>    } <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
