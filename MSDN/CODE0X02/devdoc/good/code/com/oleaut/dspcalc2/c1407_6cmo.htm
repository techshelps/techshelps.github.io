<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DSPCALC2.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1410"></a>DSPCALC2.CPP</h2>
<pre><code>/***  <br>*dspcalc2.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1993 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the basic user interface and arithmetic <br>*  functionality of the IDispatch calculator. <br>* <br>*  The implementation of IDispatch is via aggregation with an <br>*  instance of the "standard" IDispatch implementation, which is <br>*  initialized with a TypeInfo loaded from the TypeLib that was <br>*  constructed from the ODL description of the calculator. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "dspcalc2.h" <br> <br>CCalc FAR* g_pcalc = NULL; <br> <br>unsigned long g_dwCCalcCF = 0; <br>unsigned long g_dwRegisterCCalc = 0; <br> <br>#ifdef _MAC          <br>extern Boolean g_fQuit; <br>#endif //_MAC <br> <br> <br>/*** <br>*CCalc *CCalc::Create(void) <br>*Purpose: <br>*  Create an instance of the IDispatch calculator, load the <br>*  TypeInfo that describes the exposed functionality and <br>*  aggregate with an instance of CStdDispatch that has been <br>*  initialized with this TypeInfo. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = CCalc*, NULL if the creation failed. <br>* <br>***********************************************************************/ <br>CCalc FAR* <br>CCalc::Create() <br>{ <br>    HRESULT hresult; <br>    CCalc FAR* pcalc; <br>    ITypeLib FAR* ptlib; <br>    ITypeInfo FAR* ptinfo; <br>    IUnknown FAR* punkStdDisp; <br> <br>    ptlib = NULL; <br>    ptinfo = NULL; <br> <br>    if((pcalc = new FAR CCalc()) == NULL) <br>      return NULL; <br>    pcalc-&gt;AddRef(); <br>     <br>    // first try to load the type library from the information in the registry <br>    if((hresult = LoadRegTypeLib(LIBID_DspCalc2, 1, 0, 0x0409, &amp;ptlib)) != NOERROR){ <br> <br>      #define TLB_NAME OLESTR("dspcalc2.tlb") <br> <br>      // if it wasn't registered, try to load it from the path/current directory <br>      // if this succeeds, it will have registered the type library for us <br>      // for the next time. <br>      if((hresult = LoadTypeLib(TLB_NAME, &amp;ptlib)) != NOERROR){ <br>#ifndef _MAC         <br>MessageBox(NULL, TSTR("error loading TypeLib"), <br>   TSTR("dspcalc2"), MB_OK); <br>#endif    <br>goto LError0; <br>      } <br> <br>    } <br> <br>    if((hresult = ptlib-&gt;GetTypeInfoOfGuid(IID_ICalculator, &amp;ptinfo)) != NOERROR){ <br>#ifndef _MAC         <br>      MessageBox(NULL, TSTR("error accessing TypeInfo"),  <br> TSTR("dspcalc2"), MB_OK); <br>#endif    <br>      goto LError0; <br>    } <br> <br>    // Create and aggregate with an instance of the default <br>    // implementation of IDispatch that is initialized with our <br>    // TypeInfo. <br>    // <br>    hresult = CreateStdDispatch( <br>      pcalc,                            // controlling unknown <br>      &amp;(pcalc-&gt;m_arith),                // vtable* to dispatch on <br>      ptinfo, <br>      &amp;punkStdDisp); <br> <br>    if(hresult != NOERROR) <br>      goto LError0; <br> <br>    pcalc-&gt;m_punkStdDisp = punkStdDisp; <br> <br>    ptinfo-&gt;Release(); <br>    ptlib-&gt;Release(); <br> <br>    return pcalc; <br> <br>LError0:; <br>    pcalc-&gt;Release(); <br>    if(ptinfo != NULL) <br>      ptinfo-&gt;Release(); <br>    if(ptlib != NULL) <br>      ptlib-&gt;Release(); <br>    return NULL; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                        IUnknown methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CCalc::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown)){ <br>      *ppv = this; <br>    }else <br>    if(IsEqualIID(riid, IID_IDispatch) || <br>       IsEqualIID(riid, IID_DCalculator)){ <br>      return m_punkStdDisp-&gt;QueryInterface(IID_IDispatch, ppv); <br>    }else  <br>    if(IsEqualIID(riid, IID_ICalculator)){ <br>      *ppv = &amp;m_arith; <br>    }else { <br>      *ppv = NULL;           <br>      return E_NOINTERFACE; <br>    } <br> <br>    AddRef(); <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CCalc::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CCalc::Release() <br>{ <br>    if(--m_refs == 0){ <br>      if(m_punkStdDisp != NULL) <br>m_punkStdDisp-&gt;Release(); <br>#ifndef _MAC <br>      PostQuitMessage(0); <br>#endif <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>STDMETHODIMP <br>CArith::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    return m_pcalc-&gt;QueryInterface(riid, ppv); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CArith::AddRef() <br>{ <br>    return m_pcalc-&gt;AddRef(); <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CArith::Release() <br>{ <br>    return m_pcalc-&gt;Release(); <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                       Arithmetic features <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP_(void) <br>CArith::DCClear() <br>{ <br>    m_opnd = 0; <br>    m_accum = 0; <br>    m_op = OP_NONE; <br>    m_state = STATE_LOPND; <br>} <br> <br>STDMETHODIMP_(void) <br>CArith::put_Accum(long l) <br>{ <br>    m_accum = l; <br>} <br> <br> <br>STDMETHODIMP_(long) <br>CArith::get_Accum() <br>{ <br>    return m_accum; <br>} <br> <br> <br>STDMETHODIMP_(void) <br>CArith::put_Opnd(long l) <br>{ <br>    m_opnd = l; <br>} <br> <br> <br>STDMETHODIMP_(long) <br>CArith::get_Opnd() <br>{ <br>    return m_opnd; <br>} <br> <br> <br>STDMETHODIMP_(void) <br>CArith::put_Op(OPERATORS op) <br>{ <br>    m_op = op; <br>} <br> <br> <br>STDMETHODIMP_(OPERATORS) <br>CArith::get_Op() <br>{ <br>    return m_op; <br>} <br> <br> <br>STDMETHODIMP_(VARIANT_BOOL) <br>CArith::Eval() <br>{ <br>    if(m_op == OP_NONE) <br>      return FALSE; <br> <br>    switch(m_op){ <br>    case OP_PLUS: <br>      m_accum += m_opnd; <br>      break; <br>    case OP_MINUS: <br>      m_accum -= m_opnd; <br>      break; <br>    case OP_MULT: <br>      m_accum *= m_opnd; <br>      break; <br>    case OP_DIV: <br>      m_accum = (m_opnd == 0) ? 0 : (m_accum / m_opnd); <br>      break; <br>    default: <br>      // ASSERT(UNREACHED); <br>      return FALSE; <br>       <br>    } <br> <br>    m_state = STATE_EVAL; <br> <br>    return VARIANT_TRUE; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                       User Interface features <br>//--------------------------------------------------------------------- <br> <br> <br>/*** <br>*void CArith::Display() <br>*Purpose: <br>*  Display the contents of the register currently being edited. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(void) <br>CArith::Display() <br>{ <br>    VARIANT var; <br> <br>    VariantInit(&amp;var); <br>    V_VT(&amp;var) = VT_I4; <br>    V_I4(&amp;var) = (m_state == STATE_ROPND) ? m_opnd : m_accum; <br>    VariantChangeType(&amp;var, &amp;var, 0, VT_BSTR); <br> <br>    #ifdef _MAC <br>    { <br>      Rect rcItem; <br>      Handle hItem; <br>      char str[255]; <br>      short sItemKind; <br> <br>      strcpy(str, V_BSTR(&amp;var)); <br>      GetDItem(m_pcalc-&gt;m_pdlg, IDC_DISPLAY, &amp;sItemKind, &amp;hItem, &amp;rcItem); <br>      SetIText(hItem, c2pstr(str)); <br>    } <br>#else <br>    SetDlgItemText(m_pcalc-&gt;m_hwnd, IDC_DISPLAY, STRING(V_BSTR(&amp;var))); <br>#endif <br> <br>    VariantClear(&amp;var); <br>} <br> <br> <br>STDMETHODIMP_(VARIANT_BOOL) <br>CArith::Button(SAFEARRAY FAR * psa) <br>{ <br>    int i, button; <br> <br>static struct { <br>    OLECHAR ch; <br>    int idc; <br>} NEAR rgIdcOfCh[] = { <br>      { OLESTR('+'), IDC_PLUS   } <br>    , { OLESTR('-'), IDC_MINUS  } <br>    , { OLESTR('*'), IDC_MULT   } <br>    , { OLESTR('/'), IDC_DIV    } <br>    , { OLESTR('C'), IDC_CLEAR  } <br>    , { OLESTR('c'), IDC_CLEAR  } <br>    , { OLESTR('='), IDC_EQUALS } <br>    , { OLESTR('0'), IDC_ZERO   } <br>    , { OLESTR('1'), IDC_ONE    } <br>    , { OLESTR('2'), IDC_TWO    } <br>    , { OLESTR('3'), IDC_THREE  } <br>    , { OLESTR('4'), IDC_FOUR   } <br>    , { OLESTR('5'), IDC_FIVE   } <br>    , { OLESTR('6'), IDC_SIX    } <br>    , { OLESTR('7'), IDC_SEVEN  } <br>    , { OLESTR('8'), IDC_EIGHT  } <br>    , { OLESTR('9'), IDC_NINE   } <br>    , { (OLECHAR)-1 , -1         } <br>}; <br>    LONG saIndex, saUbound; <br>    VARIANT varButton; <br> <br>    // Since this is a vararg function, we should be given a 1-dimensional <br>    // array with 0 for the lower bound. The array could be uninitialized <br>    // if 0 args were passed to us -- this call will give an error in this case. <br>    if (SafeArrayGetUBound(psa, 1, &amp;saUbound) != NOERROR) <br>      return FALSE;     // most likely 0 args were passed to us <br> <br>    for (saIndex = 0; saIndex &lt;= saUbound; saIndex++) { <br> <br>      // get next parameter <br>      if (SafeArrayGetElement(psa, &amp;saIndex, &amp;varButton) != NOERROR) <br>return FALSE; <br> <br>      // convert it to a string in-place <br>      if (VariantChangeType(&amp;varButton, &amp;varButton, 0, VT_BSTR) != NOERROR) <br>goto Error; <br> <br>      // if the string is more that 1 character long, then we know its wrong. <br>      if(SysStringLen(varButton.bstrVal) &gt; 1) <br>goto Error; <br> <br>      // translate button string into control ID <br>      for(i = 0;; ++i){ <br>if(rgIdcOfCh[i].ch == -1) <br>  goto Error; <br>if(rgIdcOfCh[i].ch == varButton.bstrVal[0]){ <br>  button = rgIdcOfCh[i].idc; <br>  break; <br>} <br>      } <br> <br>      VariantClear(&amp;varButton);         // done with the parameter <br> <br>      if (!ButtonPush(button)) <br>return FALSE; <br> <br>    } // for <br> <br>    return VARIANT_TRUE;        // success <br> <br>Error: <br>    VariantClear(&amp;varButton); <br>    return FALSE;       // failure <br>} <br> <br> <br>// the following method is internal, and not exposed for programmability <br>BOOL <br>CArith::ButtonPush(int button) <br>{ <br>    if(button &gt;= IDC_ZERO &amp;&amp; button &lt;= IDC_NINE){ <br> <br>      long lVal = button - IDC_ZERO; <br> <br>      switch(m_state){ <br>      case STATE_EVAL: <br>m_accum = lVal; <br>m_state = STATE_LOPND; <br>break; <br>      case STATE_OP: <br>m_opnd = lVal; <br>m_state = STATE_ROPND; <br>break; <br>      case STATE_LOPND: <br>m_accum = (m_accum * 10) + lVal; <br>break; <br>      case STATE_ROPND: <br>m_opnd  = (m_opnd * 10) + lVal; <br>break; <br>      } <br> <br>    }else if(button &gt;= IDC_PLUS &amp;&amp; button &lt;= IDC_DIV){ <br> <br>      if(m_state == STATE_ROPND) <br>Eval(); <br> <br>      m_opnd  = m_accum; <br>      m_state = STATE_OP; <br>      m_op    = (OPERATORS)(button - IDC_PLUS + OP_PLUS); <br> <br>    }else if(button == IDC_EQUALS){ <br> <br>      if(m_state &gt; STATE_LOPND) <br>Eval(); <br> <br>    }else if (button == IDC_CLEAR){ <br> <br>      DCClear(); <br> <br>    } else { <br> <br>      return 0; // unknown button <br> <br>    } <br>     <br> <br>    // Flash the button <br> <br>#ifdef _MAC <br>    { <br>      Rect rcItem; <br>      long lDummy; <br>      Handle hItem; <br>      short sItemKind; <br> <br>      GetDItem(m_pcalc-&gt;m_pdlg, button, &amp;sItemKind, &amp;hItem, &amp;rcItem); <br>      HiliteControl((ControlHandle)hItem, 1); <br>      Delay(6, &amp;lDummy); <br>      HiliteControl((ControlHandle)hItem, 0); <br>    } <br>#else <br>    SendMessage(m_pcalc-&gt;m_hwnd, BM_SETSTATE, 1, 0L); <br>    SendMessage(m_pcalc-&gt;m_hwnd, BM_SETSTATE, 0, 0L); <br>#endif <br> <br>    // Update the calculator display <br> <br>    Display(); <br> <br>    return TRUE; <br>} <br> <br>/*** <br>*void CArith::Quit() <br>*Purpose: <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>STDMETHODIMP_(void) <br>CArith::Quit() <br>{ <br>#ifndef _MAC <br>    PostQuitMessage(0); <br>#else <br>    g_fQuit = TRUE; <br>#endif <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                      The CCalc Class Factory <br>//--------------------------------------------------------------------- <br> <br> <br>IClassFactory FAR* <br>CCalcCF::Create() <br>{ <br>    return new FAR CCalcCF(); <br>} <br> <br> <br>STDMETHODIMP <br>CCalcCF::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory)){ <br>      AddRef(); <br>      *ppv = this; <br>      return NOERROR; <br>    } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CCalcCF::AddRef() <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CCalcCF::Release() <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>STDMETHODIMP <br>CCalcCF::CreateInstance( <br>    IUnknown FAR* punkOuter, <br>    REFIID riid, <br>    void FAR* FAR* ppv) <br>{ <br>extern CCalc FAR* g_pcalc; <br> <br>    UNUSED(punkOuter); <br>    return g_pcalc-&gt;QueryInterface(riid, ppv); <br>} <br> <br> <br>STDMETHODIMP <br>#ifdef _MAC <br>CCalcCF::LockServer(unsigned long fLock) <br>#else <br>CCalcCF::LockServer(BOOL fLock) <br>#endif <br>{ <br>    UNUSED(fLock); <br>    return NOERROR; <br>} <br> <br>#ifdef _MAC <br>struct regentry{ <br>    char *szKey; <br>    char *szValue; <br>} g_rgregentry[] = { <br> <br>      { "CLSID\\{00020469-0000-0000-C000-000000000046}", <br>"OLE Automation DspCalc2 1.0 Application" } <br> <br>    , { "CLSID\\{00020469-0000-0000-C000-000000000046}\\LocalServer", <br>"DCL2" } <br> <br>    , { "CLSID\\{00020469-0000-0000-C000-000000000046}\\ProgID", <br>"Dspcalc2.Application" } <br> <br>    , { "CLSID\\{00020469-0000-0000-C000-000000000046}\\InprocHandler", <br>"OLE2:Def$DefFSet" } <br> <br>    , { "DCL2", "{00020469-0000-0000-C000-000000000046}" } <br> <br>    , { "Dspcalc2.Application\\CLSID", <br>"{00020469-0000-0000-C000-000000000046}" } <br> <br>}; <br> <br>HRESULT <br>EnsureRegistration() <br>{ <br>    HKEY hkey; <br> <br>    if(RegOpenKey(HKEY_CLASSES_ROOT, "DCL2", &amp;hkey) == NOERROR){ <br>      RegCloseKey(hkey); <br>      return NOERROR; <br>    } <br> <br>    for(int i = 0; i &lt; DIM(g_rgregentry); ++i){ <br>      if(RegSetValue(HKEY_CLASSES_ROOT, g_rgregentry[i].szKey, REG_SZ, g_rgregentry[i].szValue, 0) != ERROR_SUCCESS) <br>return E_FAIL; <br>    } <br> <br>    return NOERROR; <br>} <br>#endif //_MAC <br> <br> <br>/*** <br>*HRESULT InitOle(void) <br>*Purpose: <br>*  Initialize Ole, and register our class factories. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>HRESULT <br>InitOle() <br>{ <br>    HRESULT hresult; <br>    IClassFactory FAR* pcf; <br> <br> <br>    if((hresult = OleInitialize(NULL)) != NOERROR) <br>      goto LError0; <br> <br>#ifdef _MAC <br>    if((hresult = EnsureRegistration()) != NOERROR) <br>      goto LError0; <br>#endif <br> <br>    // create the single global instance of CCalc <br>    if((g_pcalc = CCalc::Create()) == NULL){ <br>      hresult = E_OUTOFMEMORY; <br>      goto LError0; <br>    } <br> <br>    if((pcf = CCalcCF::Create()) == NULL) <br>      goto LError1; <br> <br>    hresult = CoRegisterClassObject( <br>      CLSID_CCalc2, <br>      pcf, <br>      CLSCTX_LOCAL_SERVER, <br>      REGCLS_MULTIPLEUSE, <br>      &amp;g_dwCCalcCF); <br>    if(FAILED(hresult)) <br>      goto LError2; <br> <br>    hresult = RegisterActiveObject( <br>      g_pcalc, CLSID_CCalc2, NULL, &amp;g_dwRegisterCCalc); <br>    if(FAILED(hresult)) <br>      goto LError2; <br> <br>    pcf-&gt;Release(); <br> <br>    return NOERROR; <br> <br>LError2:; <br>    pcf-&gt;Release(); <br> <br>LError1:; <br>    UninitOle(); <br> <br>LError0:; <br>    return hresult; <br>} <br> <br> <br>HRESULT <br>UninitOle() <br>{ <br>    if(g_dwRegisterCCalc != 0) <br>      RevokeActiveObject(g_dwRegisterCCalc, NULL); <br> <br>    if(g_dwCCalcCF != 0) <br>      CoRevokeClassObject(g_dwCCalcCF); <br> <br>    // cause the remaining typeinfo to be released <br>    if(g_pcalc != NULL) <br>      g_pcalc-&gt;Release(); <br> <br>    OleUninitialize(); <br> <br>    return NOERROR; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
