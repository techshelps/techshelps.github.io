<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CPOINT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1458"></a>CPOINT.CPP</h2>
<pre><code>/***  <br>*cpoint.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module implements the CPoint and CPointCF classes. <br>* <br>*  This module is intended as a sample implementation of the IDispatch <br>*  interface, and its purpose is to demonstrate how an object can <br>*  expose methods and properties for programatic and cross-process <br>*  access via the IDispatch interface. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include "spoly.h" <br>#include "cpoint.h" <br> <br> <br>CPoint::CPoint() <br>{ <br>    m_x = 0; <br>    m_y = 0; <br>    m_refs = 0; <br>    m_ptinfo = NULL; <br>} <br> <br>/*** <br>*CPoint::Create(void) <br>*Purpose: <br>*  Create an instance of a CPoint object. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  returns a CPoint*, NULL if creation failed. <br>* <br>***********************************************************************/ <br>CPoint FAR* <br>CPoint::Create() <br>{ <br>    HRESULT hresult; <br>    CPoint FAR* ppoint; <br>    ITypeInfo FAR* ptinfo; <br>extern INTERFACEDATA NEAR g_idataCPoint; <br> <br> <br>    if((ppoint = new FAR CPoint()) == NULL) <br>      return NULL; <br>    ppoint-&gt;AddRef(); <br> <br>    hresult = <br>      CreateDispTypeInfo(&amp;g_idataCPoint, LOCALE_SYSTEM_DEFAULT, &amp;ptinfo); <br>    if(hresult != NOERROR) <br>      goto LError0; <br> <br>    ppoint-&gt;m_ptinfo = ptinfo; <br> <br>    return ppoint; <br> <br>LError0:; <br>    ppoint-&gt;Release(); <br> <br>    return NULL; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IUnknown Methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CPoint::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IDispatch)){ <br>      *ppv = this; <br>      AddRef(); <br>      return NOERROR; <br>    } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoint::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CPoint::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      if(m_ptinfo != NULL){ <br>m_ptinfo-&gt;Release(); <br>      } <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IDispatch methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CPoint::GetTypeInfoCount(unsigned int FAR* pctinfo) <br>{ <br>    // this object has a single *introduced* interface <br>    // <br>    *pctinfo = 1; <br> <br>    return NOERROR; <br>} <br> <br> <br>STDMETHODIMP <br>CPoint::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo) <br>{ <br>    UNUSED(lcid); <br> <br>    if(itinfo != 0) <br>      return DISP_E_BADINDEX; <br> <br>    m_ptinfo-&gt;AddRef(); <br>    *pptinfo = m_ptinfo; <br> <br>    return NOERROR; <br>} <br> <br> <br>/*** <br>*HRESULT CPoint::GetIDsOfNames(REFIID, char**, unsigned int, LCID, DISPID*) <br>*Purpose: <br>*  This method translates the given array of names to a corresponding <br>*  array of DISPIDs. <br>* <br>*  Index 0 of the name array is the member name, and indices 1-N if <br>*  present represent named parameters on that member. <br>* <br>*  The local ID ('lcid') is unused by this naive implementation. A more <br>*  sophisticated implementation, sensitive to localization and natural <br>*  language support would use the locale ID to interpret the given names <br>*  in a correct locale specific context. <br>* <br>*Entry: <br>*  rgszNames = pointer to an array of names <br>*  cNames = the number of names in the rgszNames array <br>*  lcid = the callers locale ID <br>* <br>*Exit: <br>*  return value = HRESULT <br>*  rgid = array of name IDs corresponding to the rgszNames array <br>*    this array will contain -1 for each entry that is not known. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoint::GetIDsOfNames( <br>    REFIID riid, <br>    OLECHAR FAR* FAR* rgszNames, <br>    unsigned int cNames, <br>    LCID lcid, <br>    DISPID FAR* rgdispid) <br>{ <br>    UNUSED(lcid); <br> <br>    if(!IsEqualIID(riid,IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br> <br>/*** <br>*HRESULT CPoint::Invoke(...) <br>*Purpose: <br>*  Dispatch a method or property request for objects of type CPoint. <br>* <br>*  see the IDispatch document for more information, and a general <br>*  description of this method. <br>* <br>*Entry: <br>*  dispidMember = the DISPID of the member being requested <br>* <br>*  riid = reference to the interface ID of the interface on this object <br>*    that the requested member belongs to. IID_NULL means to interpret <br>*    the member as belonging to the implementation defined "default" <br>*    or "primary" interface. <br>* <br>*  lcid = the caller's locale ID <br>* <br>*  wFlags = flags indicating the type of access being requested <br>* <br>*  pdispparams = pointer to the DISPPARAMS struct containing the <br>*    requested members arguments (if any) and its named parameter <br>*    DISPIDs (if any). <br>* <br>*Exit: <br>*  return value = HRESULT <br>*   see the IDispatch spec for a description of possible success codes. <br>* <br>*  pvarResult = pointer to a caller allocated VARIANT containing <br>*    the members return value (if any). <br>* <br>*  pexcepinfo = caller allocated exception info structure, this will <br>*    be filled in only if an exception was raised that must be passed <br>*    up through Invoke to an enclosing handler. <br>* <br>*  puArgErr = pointer to a caller allocated UINT, that will contain the <br>*    index of the offending argument if a DISP_E_TYPEMISMATCH error <br>*    was returned indicating that one of the arguments was of an <br>*    incorrect type and/or could not be reasonably coerced to a proper <br>*    type. <br>* <br>***********************************************************************/ <br>STDMETHODIMP <br>CPoint::Invoke( <br>    DISPID dispidMember, <br>    REFIID riid, <br>    LCID lcid, <br>    unsigned short wFlags, <br>    DISPPARAMS FAR* pdispparams, <br>    VARIANT FAR* pvarResult, <br>    EXCEPINFO FAR* pexcepinfo, <br>    unsigned int FAR* puArgErr) <br>{ <br>    UNUSED(lcid); <br> <br>    if(!IsEqualIID(riid, IID_NULL)) <br>      return DISP_E_UNKNOWNINTERFACE; <br> <br>    return DispInvoke( <br>      this, m_ptinfo, <br>      dispidMember, wFlags, pdispparams, <br>      pvarResult, pexcepinfo, puArgErr); <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                       Introduced methods <br>//--------------------------------------------------------------------- <br> <br>short METHODCALLTYPE EXPORT <br>CPoint::GetX() <br>{ <br>    return m_x; <br>} <br> <br>void METHODCALLTYPE EXPORT <br>CPoint::SetX(short x) <br>{ <br>    m_x = x; <br>} <br> <br>short METHODCALLTYPE EXPORT <br>CPoint::GetY() <br>{ <br>    return m_y; <br>} <br> <br>void METHODCALLTYPE EXPORT <br>CPoint::SetY(short y) <br>{ <br>    m_y = y; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//         Implementation of the CPoint Class Factory <br>//--------------------------------------------------------------------- <br> <br>CPointCF::CPointCF() <br>{ <br>    m_refs = 0; <br>} <br> <br>IClassFactory FAR* <br>CPointCF::Create() <br>{ <br>    CPointCF FAR* pCF; <br> <br>    if((pCF = new FAR CPointCF()) == NULL) <br>      return NULL; <br>    pCF-&gt;AddRef(); <br>    return pCF; <br>} <br> <br>STDMETHODIMP <br>CPointCF::QueryInterface(REFIID riid, void FAR* FAR* ppv)  <br>{ <br>    if(IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory)){ <br>      *ppv = this; <br>      ++m_refs; <br>      return NOERROR; <br>    } <br>    *ppv = NULL; <br>    return E_NOINTERFACE; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPointCF::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br>STDMETHODIMP_(unsigned long) <br>CPointCF::Release(void) <br>{ <br>    if(--m_refs == 0){ <br>      delete this; <br>      return 0; <br>    } <br>    return m_refs; <br>} <br> <br>STDMETHODIMP <br>CPointCF::CreateInstance( <br>    IUnknown FAR* punkOuter, <br>    REFIID riid, <br>    void FAR* FAR* ppv) <br>{ <br>    HRESULT hresult; <br>    CPoint FAR *ppoint; <br> <br>    UNUSED(punkOuter); <br> <br>    if((ppoint = CPoint::Create()) == NULL){ <br>      *ppv = NULL; <br>      return E_OUTOFMEMORY; <br>    } <br>    hresult = ppoint-&gt;QueryInterface(riid, ppv); <br>    ppoint-&gt;Release(); <br>    return hresult; <br>} <br> <br>STDMETHODIMP <br>#ifdef _MAC <br>CPointCF::LockServer(unsigned long fLock) <br>#else <br>CPointCF::LockServer(BOOL fLock) <br>#endif <br>{ <br>    UNUSED(fLock); <br> <br>    return NOERROR; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
