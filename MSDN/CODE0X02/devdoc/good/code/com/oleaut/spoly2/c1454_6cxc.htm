<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WINMAIN.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1470"></a>WINMAIN.CPP</h2>
<pre><code>/***  <br>*winmain.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  This module is the main entry point for the sample IDispatch polygon <br>*  server, spoly2.exe. <br>* <br>*  This program is intended to demonstrate an implementation of the IDispatch <br>*  interface. Spoly2 is a very simple app, that implements two simple objects, <br>*  CPoly and CPoint and exposes their properties and methods for programatic <br>*  and cross-process access via IDispatch. <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "spoly.h" <br>#include "cpoint.h" <br>#include "cpoly.h" <br> <br> <br>HINSTANCE g_hinst = 0; <br> <br>HWND g_hwndFrame = 0; <br>HWND g_hwndClient = 0; <br> <br>TCHAR g_szFrameWndClass[] = TSTR("FrameWClass"); <br> <br>CStatBar FAR* g_psb = NULL; <br> <br> <br>BOOL InitApplication(HINSTANCE); <br>BOOL InitInstance(HINSTANCE, int); <br> <br>extern "C" int PASCAL WinMain(HINSTANCE, HINSTANCE, LPSTR, int); <br>extern "C" long FAR PASCAL FrameWndProc(HWND, UINT, WPARAM, LPARAM); <br> <br> <br>extern "C" int PASCAL <br>WinMain( <br>    HINSTANCE hinst, <br>    HINSTANCE hPrevInstance, <br>    LPSTR lpCmdLine, <br>    int nCmdShow) <br>{ <br>    MSG msg; <br>    int retval; <br>    HRESULT hresult; <br> <br>    if(!hPrevInstance) <br>      if(!InitApplication(hinst)) <br>return FALSE; <br> <br>    if((hresult = InitOle()) != NOERROR) <br>      return FALSE; <br> <br>    if(!InitInstance(hinst, nCmdShow)){ <br>      retval = FALSE; <br>      goto LExit; <br>    } <br> <br>    while(GetMessage(&amp;msg, NULL, NULL, NULL)) { <br>      TranslateMessage(&amp;msg); <br>      DispatchMessage(&amp;msg); <br>    } <br> <br>    g_psb-&gt;Release(); <br>    CPoly::PolyTerm(); <br> <br>    retval = msg.wParam; <br> <br>LExit:; <br>    UninitOle(); <br> <br>    return retval; <br>} <br> <br> <br>BOOL <br>InitApplication(HINSTANCE hinst) <br>{ <br>    WNDCLASS  wc; <br> <br>    wc.style= CS_HREDRAW | CS_VREDRAW; <br>    wc.lpfnWndProc= FrameWndProc; <br>    wc.cbClsExtra= 0; <br>    wc.cbWndExtra= 0; <br>    wc.hInstance= hinst; <br>    wc.hIcon= LoadIcon(hinst, TSTR("SPOLY")); <br>    wc.hCursor= LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground= (HBRUSH) (COLOR_APPWORKSPACE+1); <br>    wc.lpszMenuName= TSTR("SPolyMenu"); <br>    wc.lpszClassName= g_szFrameWndClass; <br> <br>    if(!RegisterClass(&amp;wc)) <br>      return FALSE; <br> <br>    return TRUE; <br>} <br> <br>#ifdef WIN32 <br>#define szAppTitle TSTR("IDispatch Polygon Server #2 (32-bit)") <br>#else //WIN32 <br>#define szAppTitle TSTR("IDispatch Polygon Server #2") <br>#endif //WIN32 <br> <br>BOOL <br>InitInstance(HINSTANCE hinst, int nCmdShow) <br>{ <br>    g_hinst = hinst; <br> <br>    // Create a main frame window <br>    // <br>    g_hwndFrame = CreateWindow( <br>      g_szFrameWndClass, <br>      szAppTitle, <br>      WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, <br>      CW_USEDEFAULT, <br>      CW_USEDEFAULT, <br>      CW_USEDEFAULT, <br>      CW_USEDEFAULT, <br>      NULL, <br>      NULL, <br>      hinst, <br>      NULL); <br>    if(!g_hwndFrame) <br>      return FALSE; <br> <br>    g_hwndClient = GetWindow(g_hwndFrame, GW_CHILD); <br>    if(!g_hwndClient) <br>      return FALSE; <br> <br>    // create the status bar <br>    // <br>    g_psb = CStatBar::Create(g_hinst, g_hwndFrame); <br>    if(!g_psb) <br>      return FALSE; <br> <br>    // initialize and show the status bar <br>    // <br>    g_psb-&gt;SetHeight(GetSystemMetrics(SM_CYCAPTION) - 1); <br>    g_psb-&gt;SetFont((HFONT)GetStockObject(SYSTEM_FONT)); <br>    g_psb-&gt;SetText(OLESTR("")); <br>    g_psb-&gt;Show(); <br> <br>    ShowWindow(g_hwndFrame, nCmdShow); <br> <br>    UpdateWindow(g_hwndFrame); <br> <br>    return TRUE; <br>} <br> <br> <br>void <br>FrameWndOnCreate(HWND hwnd) <br>{ <br>    CLIENTCREATESTRUCT ccs; <br> <br>    ccs.hWindowMenu = NULL; <br>    ccs.idFirstChild = IDM_FIRSTCHILD; <br> <br>    g_hwndClient = CreateWindow( <br>      TSTR("MDICLIENT"), <br>      0, <br>      WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE, <br>      0, 0, 0, 0, <br>      hwnd, <br>      (HMENU) 1, <br>      g_hinst, <br>      &amp;ccs); <br>} <br> <br> <br>void <br>FrameWndOnSize(HWND hwnd) <br>{ <br>    RECT rc; <br>    int height; <br> <br>    // Get the client rectangle for the frame window <br>    GetClientRect(hwnd, &amp;rc); <br> <br>    height = g_psb-&gt;GetHeight(); <br> <br>    // adjust the client win to make room for the status bar. <br>    // <br>    MoveWindow( <br>      g_hwndClient, <br>      rc.left, <br>      rc.top, <br>      rc.right - rc.left, <br>      rc.bottom - rc.top - height, <br>      TRUE); <br> <br>    // move the status bar to the bottom of the newly positioned window. <br>    // <br>    g_psb-&gt;SetX(rc.left); <br>    g_psb-&gt;SetY(rc.bottom - height), <br>    g_psb-&gt;SetWidth(rc.right - rc.left); <br>    g_psb-&gt;Move(); <br>} <br> <br> <br>extern "C" long FAR PASCAL <br>FrameWndProc( <br>    HWND hwnd, <br>    UINT message, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    switch(message){ <br>    case WM_COMMAND: <br>      switch(wParam){ <br>      case IDM_DUMP: <br>CPoly::PolyDump(); <br>return 0; <br> <br>      case IDM_CLEAR: <br>InvalidateRect(g_hwndClient, NULL, TRUE); <br>return 0; <br>      } <br>      break; <br> <br>    case WM_CREATE: <br>      FrameWndOnCreate(hwnd); <br>      break; <br> <br>    case WM_SIZE: <br>      FrameWndOnSize(hwnd); <br>      return 1; <br> <br>    case WM_PAINT: <br>      CPoly::PolyDraw(); <br>      break; <br> <br>    case WM_CLOSE: <br>      DestroyWindow(hwnd); <br>      return 0; <br> <br>    case WM_DESTROY: <br>      PostQuitMessage(0); <br>      return 0; <br>    } <br>    return DefFrameProc(hwnd, g_hwndClient, message, wParam, lParam); <br>} <br> <br> <br>#if defined(WIN32) <br> <br>extern "C" OLECHAR FAR* <br>ConvertStrAtoW(char FAR* strIn, OLECHAR FAR* buf, UINT size) <br>{ <br>  MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,  <br>                       strIn, -1, buf, size) ;  <br>  return buf; <br>} <br> <br>extern "C" OLECHAR FAR* <br>WideString(char FAR* strIn) <br>{ <br>  static OLECHAR buf[256]; <br>   <br>  return (ConvertStrAtoW(strIn, buf, 256)); <br>} <br> <br>extern "C" char FAR* <br>ConvertStrWtoA(OLECHAR FAR* strIn, char FAR* buf, UINT size) <br>{ <br>  int badConversion = FALSE; <br>   <br>  WideCharToMultiByte(CP_ACP, NULL,  <br>              strIn, -1,  <br>      buf, size,  <br>      NULL, &amp;badConversion); <br>  return buf; <br>} <br> <br>extern "C" char FAR* <br>AnsiString(OLECHAR FAR* strIn) <br>{ <br>  static char buf[256]; <br>   <br>  return (ConvertStrWtoA(strIn, buf, 256)); <br>} <br> <br>#endif <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
