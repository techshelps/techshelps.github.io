<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STATBAR.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1467"></a>STATBAR.CPP</h2>
<pre><code>/***  <br>*statbar.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#include &lt;stdarg.h&gt; <br> <br>#include "hostenv.h" <br>#include "statbar.h" <br> <br> <br>extern "C" long FAR PASCAL StatBarWndProc(HWND, unsigned int, WPARAM, LPARAM); <br> <br> <br>TCHAR FAR* CStatBar::m_szWndClass = TSTR("StatBarWndClass"); <br> <br> <br>CStatBar::CStatBar() <br>{ <br>    m_refs = 0; <br> <br>    m_x = 0; <br>    m_y = 0; <br>    m_width = 0; <br>    m_height = 0; <br> <br>    m_bstrMsg = NULL; <br> <br>    m_hfont = (HFONT)0; <br>} <br> <br>CStatBar::~CStatBar() <br>{ <br>    SysFreeString(m_bstrMsg); <br>} <br> <br> <br>/*** <br>*PUBLIC CStatBar FAR* CStatBar::Create(HINSTANCE, HWND) <br>* <br>*Purpose: <br>* <br>*Entry: <br>* <br>*Exit: <br>* <br>***********************************************************************/ <br>CStatBar FAR* <br>CStatBar::Create(HINSTANCE hinst, HWND hwndFrame) <br>{ <br>    CStatBar FAR* psb; <br> <br>    psb = new FAR CStatBar(); <br>    if(psb == NULL) <br>      return NULL; <br>    psb-&gt;AddRef(); <br> <br>    if(!psb-&gt;Register(hinst)) <br>      goto LFail; <br> <br>    psb-&gt;m_hwnd = CreateWindow( <br>      CStatBar::m_szWndClass, <br>      NULL, <br>      WS_CHILD | WS_CLIPSIBLINGS, <br>      0, 0, 0, 0, <br>      hwndFrame, <br>      0, <br>      hinst, <br>      NULL); <br> <br>    if(!psb-&gt;m_hwnd) <br>      goto LFail; <br> <br>    // Stash the newly created CStatBar* in the extra bytes of the <br>    // associated window so we can get at the instance in the message <br>    // proc. <br>    // <br>    // Note: we do not AddRef for this reference. We make sure that the <br>    // window is destroyed when the refcnt goes to 0. <br>    // <br>    SetWindowLong(psb-&gt;m_hwnd, 0, (long)psb); <br> <br>    return psb; <br> <br>LFail:; <br>    delete psb; <br>    return NULL; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     IUnknown Methods <br>//--------------------------------------------------------------------- <br> <br> <br>STDMETHODIMP <br>CStatBar::QueryInterface(REFIID riid, void FAR* FAR* ppv) <br>{ <br>    if(IsEqualIID(riid,IID_IUnknown)){ <br>      *ppv = this; <br>      AddRef(); <br>      return NOERROR; <br>    } <br>    *ppv = (void FAR*)NULL; <br>    return E_NOINTERFACE; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CStatBar::AddRef(void) <br>{ <br>    return ++m_refs; <br>} <br> <br> <br>STDMETHODIMP_(unsigned long) <br>CStatBar::Release(void) <br>{ <br>    if(--m_refs == 0){ <br> <br>      // destroy the status bar window. <br>      // <br>      SendMessage(m_hwnd, WM_DESTROY, 0, 0L); <br> <br>      delete this; <br>      return 0; <br>    } <br> <br>    return m_refs; <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                     Introduced Methods <br>//--------------------------------------------------------------------- <br> <br> <br>/*** <br>*PRIVATE BOOL CStatBar::Register(HINSTANCE) <br>* <br>*Purpose: <br>*  Register the status bar window class. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = BOOL, TRUE if successful, FALSE if not. <br>* <br>***********************************************************************/ <br>BOOL <br>CStatBar::Register(HINSTANCE hinst) <br>{ <br>    WNDCLASS  wc; <br> <br>    // register the class, unless already registered. <br>    if(GetClassInfo(hinst, m_szWndClass, &amp;wc) == 0){ <br>      wc.style         = 0; <br>      wc.lpfnWndProc   = StatBarWndProc; <br>      wc.cbClsExtra    = 0; <br>      wc.cbWndExtra    = sizeof(CStatBar FAR*); <br>      wc.hInstance     = hinst; <br>      wc.hIcon         = 0; <br>      wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>      wc.hbrBackground = (HBRUSH)GetStockObject(LTGRAY_BRUSH);  <br>      wc.lpszMenuName  = 0; <br>      wc.lpszClassName = CStatBar::m_szWndClass; <br>      if(!RegisterClass(&amp;wc)) <br>        return FALSE; <br>    } <br>    return TRUE; <br>} <br> <br> <br>/*** <br>*PUBLIC void CStatBar::Show(void) <br>* <br>*Purpose: <br>*  Show the status bar window associated with this CStatBar instance. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CStatBar::Show() <br>{ <br>    ShowWindow(m_hwnd, SW_SHOW); <br>} <br> <br>void <br>CStatBar::SetFont(HFONT hfont) <br>{ <br>    HDC hdc; <br>    TEXTMETRIC tm; <br>    HFONT hfontOld; <br> <br>    // compute the character sizes given this new font. <br>    // <br>    hdc = GetDC(m_hwnd); <br>    hfontOld = (HFONT)SelectObject(hdc, hfont); <br>    GetTextMetrics(hdc, &amp;tm); <br>    m_dxFont = tm.tmAveCharWidth; <br>    m_dyFont = tm.tmHeight + tm.tmExternalLeading; <br>    SelectObject(hdc, hfontOld); <br>    ReleaseDC(m_hwnd, hdc); <br> <br>    m_hfont = hfont; <br>} <br> <br>/*** <br>*PRIVATE CStatBar::WMPaint(void) <br>* <br>*Purpose: <br>*  This method is responsible for drawing the status bar, and is called <br>*  in response to a WM_PAINT message. <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  None <br>* <br>***********************************************************************/ <br>void <br>CStatBar::WMPaint() <br>{ <br>    HDC hdc; <br>    RECT rcMsg; <br>    HRGN hrgn; <br>    HFONT hfontOld; <br>    PAINTSTRUCT ps; <br>    HPEN hpenBlack, hpenWhite, hpenGray, hpenOld; <br> <br>    hdc = BeginPaint(m_hwnd, &amp;ps); <br> <br>    // compute the message box rect <br>    // <br>    rcMsg.top= 3; <br>    rcMsg.bottom= m_height - 3; <br>    rcMsg.left= m_dxFont; <br>    rcMsg.right= m_width - m_dxFont; <br> <br>    // prepare the pens <br>    // <br>    hpenWhite= (HPEN)GetStockObject(WHITE_PEN); <br>    hpenBlack= (HPEN)GetStockObject(BLACK_PEN); <br>    hpenGray= CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNSHADOW)); <br> <br>    // draw a top gray line <br>    // <br>    hpenOld = (HPEN)SelectObject(hdc, hpenGray); <br>#if   defined(WIN16) <br>    MoveTo(hdc, ps.rcPaint.left, 0); <br>#elif defined(WIN32) <br>    MoveToEx(hdc, ps.rcPaint.left, 0, NULL); <br>#endif <br>    LineTo(hdc, ps.rcPaint.right, 0); <br> <br>    // draw a white line just under <br>    // <br>    SelectObject(hdc, hpenWhite); <br>#if   defined(WIN16) <br>    MoveTo(hdc, ps.rcPaint.left, 1); <br>#elif defined(WIN32) <br>    MoveToEx(hdc, ps.rcPaint.left, 1, NULL); <br>#endif <br>    LineTo(hdc, ps.rcPaint.right, 1); <br> <br>    // do not overwrite the background color <br>    // <br>    SetBkMode(hdc, TRANSPARENT); <br> <br>    // message area <br>    // <br>    SelectObject(hdc, hpenBlack); <br>#if   defined(WIN16) <br>    MoveTo(hdc, rcMsg.left,  rcMsg.bottom); <br>#elif defined(WIN32) <br>    MoveToEx(hdc, rcMsg.left,  rcMsg.bottom, NULL); <br>#endif <br>    LineTo(hdc, rcMsg.left,  rcMsg.top); <br>    LineTo(hdc, rcMsg.right, rcMsg.top); <br> <br>    SelectObject(hdc, hpenWhite); <br>    LineTo(hdc, rcMsg.right, rcMsg.bottom); <br>    LineTo(hdc, rcMsg.left,  rcMsg.bottom); <br> <br>    // select the black pen for writing <br>    // <br>    SelectObject(hdc, hpenBlack); <br> <br>    // select the status bar font to write in <br>    // <br>    hfontOld = (HFONT)SelectObject(hdc, m_hfont); <br> <br>    // set the clipping region <br>    // <br>    hrgn = CreateRectRgn( <br>      rcMsg.left, rcMsg.top, rcMsg.right, rcMsg.bottom); <br> <br>    SelectClipRgn(hdc, hrgn); <br> <br>    // draw the status message <br>    // <br>    TextOut( <br>      hdc, <br>      rcMsg.left + (m_dxFont / 2), <br>      rcMsg.top + ((rcMsg.bottom - rcMsg.top - m_dyFont) / 2), <br>      STRING(m_bstrMsg), (SysStringLen(m_bstrMsg))); <br> <br>    // cleanup <br>    // <br>    SelectObject(hdc, hpenOld); <br>    SelectObject(hdc, hfontOld); <br> <br>    DeleteObject(hrgn); <br>    DeleteObject(hpenGray); <br> <br>    EndPaint(m_hwnd, &amp;ps); <br>} <br> <br>extern "C" long FAR PASCAL <br>StatBarWndProc( <br>    HWND hwnd, <br>    unsigned int message, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    CStatBar FAR* psb; <br> <br>    switch(message){ <br>    case WM_SIZE: <br>      return 0; <br>    case WM_PAINT: <br>      psb = (CStatBar FAR*)GetWindowLong(hwnd, 0); <br>      psb-&gt;WMPaint(); <br>      return 0; <br>    } <br>    return(DefWindowProc(hwnd, message, wParam, lParam)); <br>} <br> <br> <br>//--------------------------------------------------------------------- <br>//                    Status Bar Utilities <br>//--------------------------------------------------------------------- <br> <br>extern "C" void <br>SBprintf(CStatBar FAR* psb, TCHAR FAR* szFmt, ...) <br>{ <br>    va_list args; <br>static TCHAR buf[256]; <br> <br>    va_start(args, szFmt); <br>    wvsprintf(buf, szFmt, args); <br>    psb-&gt;SetText(WIDESTRING(buf)); <br>    psb-&gt;Update(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
