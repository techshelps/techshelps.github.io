<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COLLECT.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1368"></a>COLLECT.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation TypeLibrary Browse Helper Sample <br>** <br>**  collect.cpp <br>** <br>**  CCollection implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif    <br>#include "browseh.h"   <br> <br>/* <br> * CCollection::Create <br> * <br> * Purpose: <br> *  Creates an instance of a collection object and initializes it. <br> * <br> * Parameters: <br> *  lMaxSize   Maximum number of items that can added to collection. <br> *  lLBound    Lower bound of index of collection.   <br> *  ppCollection    Returns collection object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CCollection::Create(ULONG lMaxSize, long lLBound, CCollection FAR* FAR* ppCollection)  <br>{    <br>    HRESULT hr; <br>    CCollection FAR* pCollection = NULL; <br>    SAFEARRAYBOUND sabound[1]; <br>      <br>    *ppCollection = NULL; <br>     <br>    // Create new collection <br>    pCollection = new CCollection(); <br>    if (pCollection == NULL) <br>        goto error;  <br>    // Load type information for the collection from type library.  <br>    hr = pCollection-&gt;LoadTypeInfo(IID_ICollection); <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>    // If lMaxSize is 0 increment it to 1 or SafeArrayCreate will fail <br>    if (lMaxSize == 0)    <br>       lMaxSize = 1;        <br>    pCollection-&gt;m_cMax = lMaxSize; <br>    pCollection-&gt;m_cElements = 0;  <br>    pCollection-&gt;m_lLBound = lLBound; <br> <br>    // Create a safe array which is used to implement the collection    <br>    sabound[0].cElements = lMaxSize; <br>    sabound[0].lLbound = lLBound;         <br>    pCollection-&gt;m_psa = SafeArrayCreate(VT_VARIANT, 1, sabound); <br>    if (pCollection-&gt;m_psa == NULL) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto error; <br>    } <br>     <br>#ifdef _DEBUG   <br>    lstrcpyn(pCollection-&gt;m_szClassName, TEXT("Collection"), 100); <br>#endif           <br> <br>    *ppCollection = pCollection; <br>    return NOERROR; <br>     <br>error:  <br>    if (pCollection == NULL) <br>        return E_OUTOFMEMORY;                        <br>    if (pCollection-&gt;m_psa)  <br>        SafeArrayDestroy(pCollection-&gt;m_psa);  <br>   <br>    pCollection-&gt;m_psa = NULL; <br>     <br>    delete pCollection; <br>    return hr; <br>} <br> <br>/* <br> * CCollection::CCollection <br> * <br> * Purpose: <br> *  Constructor for CCollection object. Initializes members to NULL. <br> * <br> */ <br>CCollection::CCollection() <br>{ <br>    m_psa = NULL; <br>} <br> <br>/* <br> * CCollection::~CCollection <br> * <br> * Purpose: <br> *  Destructor for CCollection object.  <br> * <br> */ <br>CCollection::~CCollection() <br>{                   <br>     if (m_psa) SafeArrayDestroy(m_psa); <br>} <br> <br>STDMETHODIMP_(REFCLSID) <br>CCollection::GetInterfaceID() <br>{ <br>    return IID_ICollection; <br>} <br> <br>/* <br> * CCollection::get_Count <br> * <br> * Purpose: <br> *  Returns number of items in collection. <br> * <br> */ <br>STDMETHODIMP_(long)      <br>CCollection::get_Count(void)   <br>{ <br>    return m_cElements;              <br>} <br> <br>/* <br> * CCollection::get_Item <br> * <br> * Purpose: <br> *  Retrieves item from collection, given an index. <br> * <br> * Parameters:    <br> *   lIndex   Index of item to be retrieved.  <br> * <br> * Returns <br> *  IDispatch of item retrieved from collection. <br> * <br> */ <br>STDMETHODIMP_(LPDISPATCH) <br>CCollection::get_Item(long lIndex) <br>{  <br>    HRESULT hr; <br>    VARIANT v; <br>    LPDISPATCH pdisp = NULL; <br>    <br>    // Check if integer index is within range          <br>    if (lIndex &lt; m_lLBound || lIndex &gt;= (long)(m_lLBound+m_cElements))  <br>        {RaiseException(IDS_InvalidIndex); return NULL;} <br>     <br>    // Retrieve and return item. Note that SafeArrayGetElement AddRefs so an additional AddRef <br>    // is not required. <br>    VariantInit(&amp;v); <br>    hr = SafeArrayGetElement(m_psa, &amp;lIndex, &amp;v); <br>    if (FAILED(hr)) <br>        {RaiseException(IDS_Unexpected); return NULL;} <br>    return V_DISPATCH(&amp;v);  <br>} <br> <br>/* <br> * CCollection::get_NewEnum <br> * <br> * Purpose: <br> *  Returns an enumerator (IEnumVARIANT) for the items curently in the collection.  <br> *  The NewEnum property is restricted and so is invisible to users of an  <br> *  automation controller's scripting language. Automation controllers that support <br> *  a 'For Each' statement to iterate through the elements of a collection will use <br> *  the enumerator returned by NewEnum. The enumerator creates a snapshot of the <br> *  the current state of the collection. <br> * <br> */ <br>STDMETHODIMP_(LPUNKNOWN) <br>CCollection::get__NewEnum(void) <br>{ <br>    CEnumVariant FAR* penum = NULL;; <br>    LPUNKNOWN punkEnumVariant = NULL; <br>    HRESULT hr; <br> <br>    // Create new enumerator for items currently in collection and QI for IUnknown <br>    hr = CEnumVariant::Create(m_psa, m_cElements, &amp;penum); <br>    if (FAILED(hr)) <br>        {RaiseException(IDS_OutOfMemory); goto error;}        <br>    hr = penum-&gt;QueryInterface(IID_IUnknown, (VOID FAR* FAR*)&amp;punkEnumVariant);     <br>    if (FAILED(hr))  <br>        {RaiseException(IDS_Unexpected); goto error;}          <br>    return punkEnumVariant;  <br>     <br>error: <br>    if (penum) <br>        delete penum;     <br>    return NULL;               <br>} <br> <br>/* <br> * CCollection::Add <br> * <br> * Purpose: <br> *  Adds an item to the collection.  <br> * <br> * Parameters: <br> *  pdispItemAdd    Item to be added to collection. <br> * <br> */ <br>STDMETHODIMP_(void)    <br>CCollection::Add(LPDISPATCH pdispItem) <br>{  <br>    HRESULT hr;    <br>    LONG l; <br>    VARIANT v;   <br>     <br>    // Is the collection full? <br>    if (m_cElements == m_cMax)  <br>        {RaiseException(IDS_CollectionFull); return;}              <br>        <br>    l = m_lLBound+m_cElements;               <br>    VariantInit(&amp;v); <br>    V_VT(&amp;v) = VT_DISPATCH; <br>    V_DISPATCH(&amp;v) = pdispItem;  <br>        <br>    hr = SafeArrayPutElement(m_psa, &amp;l, &amp;v); <br>    if (FAILED(hr)) <br>        {RaiseException(IDS_Unexpected); return;}                <br>           <br>    m_cElements++;                       <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
