<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FUNCTION.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1373"></a>FUNCTION.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation TypeLibrary Browse Helper Sample <br>** <br>**  function.cpp <br>** <br>**  CFunction implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif  <br>#include "browseh.h"   <br> <br>/* <br> * CFunction::Create <br> * <br> * Purpose: <br> *  Creates an instance of the Function automation object and initializes it. <br> * <br> * Parameters:        <br> *  ptinfo        TypeInfo of which this Function is an element of. <br> *  nIndex      Index of function in containing TypeInfo. <br> *  ppFunction    Returns Function automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CFunction::Create(LPTYPEINFO ptinfo, unsigned short nIndex, CFunction FAR* FAR* ppFunction)  <br>{    <br>    HRESULT hr; <br>    CFunction FAR* pFunction = NULL;       <br>    CTypeDesc FAR* pTypeDesc = NULL; <br>      <br>    *ppFunction = NULL; <br>     <br>    // Create object. <br>    pFunction = new CFunction(); <br>    if (pFunction == NULL) <br>    { <br>        hr = E_OUTOFMEMORY;  <br>        goto error; <br>    }     <br>     <br>    // Load type information for the application object from type library.  <br>    hr = pFunction-&gt;LoadTypeInfo(IID_IFunction); <br>    if (FAILED(hr)) <br>        goto error;  <br>     <br>    hr = ptinfo-&gt;GetFuncDesc(nIndex, &amp;pFunction-&gt;m_pfuncdesc);    <br>    if (FAILED(hr)) <br>        goto error; <br>    // Function return type. <br>    hr = CTypeDesc::Create(ptinfo, &amp;pFunction-&gt;m_pfuncdesc-&gt;elemdescFunc.tdesc, &amp;pTypeDesc); <br>    if (FAILED(hr)) <br>        goto error; <br>    pTypeDesc-&gt;QueryInterface(IID_IDispatch, (LPVOID FAR*)&amp;pFunction-&gt;m_pdispTypeDesc); <br>     <br>    hr = ptinfo-&gt;GetDocumentation(pFunction-&gt;m_pfuncdesc-&gt;memid, &amp;pFunction-&gt;m_bstrName, &amp;pFunction-&gt;m_bstrDocumentation, <br>             &amp;pFunction-&gt;m_ulHelpContext, &amp;pFunction-&gt;m_bstrHelpFile);  <br>    if (FAILED(hr)) <br>        goto error;    <br>         <br>    ptinfo-&gt;AddRef(); <br>    pFunction-&gt;m_ptinfoFunction = ptinfo; <br> <br>#ifdef _DEBUG   <br>    lstrcpyn(pFunction-&gt;m_szClassName, TEXT("Function"), 100); <br>#endif  <br>         <br>    *ppFunction = pFunction; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pFunction == NULL) return E_OUTOFMEMORY; <br>    if (pFunction-&gt;m_pfuncdesc) ptinfo-&gt;ReleaseFuncDesc(pFunction-&gt;m_pfuncdesc);     <br>    if (pFunction-&gt;m_ptinfoFunction) pFunction-&gt;m_ptinfoFunction-&gt;Release(); <br>    if (pFunction-&gt;m_bstrName) SysFreeString(pFunction-&gt;m_bstrName); <br>    if (pFunction-&gt;m_bstrDocumentation) SysFreeString(pFunction-&gt;m_bstrDocumentation); <br>    if (pFunction-&gt;m_bstrHelpFile) SysFreeString(pFunction-&gt;m_bstrHelpFile); <br>          <br>    // Set to NULL to prevent destructor from attempting to free again   <br>    pFunction-&gt;m_ptinfoFunction = NULL; <br>    pFunction-&gt;m_pfuncdesc = NULL; <br>    pFunction-&gt;m_bstrName = NULL; <br>    pFunction-&gt;m_bstrDocumentation = NULL; <br>    pFunction-&gt;m_bstrHelpFile = NULL; <br>     <br>    delete pFunction; <br>    return hr; <br>} <br> <br>/* <br> * CFunction::CFunction <br> * <br> * Purpose: <br> *  Constructor for CFunction object. Initializes members to NULL. <br> * <br> */ <br>CFunction::CFunction() <br>{ <br>    m_bstrName = NULL; <br>    m_bstrDocumentation = NULL; <br>    m_bstrHelpFile = NULL; <br>    m_pdispParameters = NULL;     <br>    m_ptinfoFunction = NULL; <br>    m_pfuncdesc = NULL;   <br>    m_pdispTypeDesc = NULL; <br>} <br> <br>/* <br> * CFunction::~CFunction <br> * <br> * Purpose: <br> *  Destructor for CFunction object.  <br> * <br> */ <br>CFunction::~CFunction() <br>{     <br>     if (m_bstrName) SysFreeString(m_bstrName); <br>     if (m_bstrDocumentation) SysFreeString(m_bstrDocumentation); <br>     if (m_bstrHelpFile) SysFreeString(m_bstrHelpFile); <br>     if (m_pdispParameters) m_pdispParameters-&gt;Release();         <br>     if (m_pfuncdesc &amp;&amp; m_ptinfoFunction) m_ptinfoFunction-&gt;ReleaseFuncDesc(m_pfuncdesc); <br>     if (m_ptinfoFunction) m_ptinfoFunction-&gt;Release();       <br>     if (m_pdispTypeDesc) m_pdispTypeDesc-&gt;Release(); <br>} <br> <br>STDMETHODIMP_(REFCLSID) <br>CFunction::GetInterfaceID() <br>{ <br>    return IID_IFunction; <br>} <br> <br>STDMETHODIMP_(BSTR) <br>CFunction::get_Name() <br>{ <br>    return SysAllocString(m_bstrName); <br>}  <br> <br>STDMETHODIMP_(BSTR) <br>CFunction::get_Documentation()      <br>{ <br>    return SysAllocString(m_bstrDocumentation); <br>}   <br> <br>STDMETHODIMP_(long) <br>CFunction::get_HelpContext()      <br>{ <br>    return (long)m_ulHelpContext; <br>} <br> <br>STDMETHODIMP_(BSTR) <br>CFunction::get_HelpFile()      <br>{ <br>    return SysAllocString(m_bstrHelpFile); <br>}    <br> <br> <br>STDMETHODIMP_(ITypeDesc FAR*) <br>CFunction::get_ReturnType() <br>{    <br>    m_pdispTypeDesc-&gt;AddRef(); <br>    return (ITypeDesc FAR*)m_pdispTypeDesc; <br>} <br> <br> <br>STDMETHODIMP_(ICollection FAR*) <br>CFunction::get_Parameters() <br>{    <br>    HRESULT hr;         <br>    CParameter FAR* pParameter; <br>    CCollection FAR* pCollection = NULL; <br>    LPDISPATCH pdisp; <br>    BSTR FAR* rgbstrNames = NULL;   <br>    unsigned int cNames;        <br>    unsigned short n = 0; <br>     <br>// Create a collection of parameters and return it. <br>    if (m_pdispParameters == NULL) <br>    {    <br>        rgbstrNames = new BSTR[m_pfuncdesc-&gt;cParams+1]; <br>        if (rgbstrNames == NULL) <br>            {RaiseException(IDS_OutOfMemory); return NULL;}   <br> <br>// Get the name of the function and its parameters <br>        hr = m_ptinfoFunction-&gt;GetNames(m_pfuncdesc-&gt;memid, rgbstrNames,  <br>                  m_pfuncdesc-&gt;cParams+1, &amp;cNames); <br>        if (FAILED(hr)) <br>            {RaiseException(IDS_Unexpected); goto error;}      <br>        SysFreeString(rgbstrNames[0]); <br>         <br>// Create a parameter collection <br>        hr = CCollection::Create(m_pfuncdesc-&gt;cParams, 0, &amp;pCollection);   <br>        if (FAILED(hr)) <br>            {RaiseException(IDS_Unexpected); goto error;}         <br>         <br>// The value being assigned to a property does not have a name. Call it 'Value' <br>if (m_pfuncdesc-&gt;invkind &amp; INVOKE_PROPERTYPUT) <br>            rgbstrNames[n+1] = SysAllocString(OLESTR("Value")); <br>// Add parameters to the parameter collection <br>        for (n=0; n&lt;m_pfuncdesc-&gt;cParams; n++) <br>        { <br>            hr = CParameter::Create(m_ptinfoFunction,  <br>   rgbstrNames[n+1],  <br>                   &amp;m_pfuncdesc-&gt;lprgelemdescParam[n].tdesc,  <br>                   &amp;m_pfuncdesc-&gt;lprgelemdescParam[n].idldesc, <br>                   &amp;pParameter); <br>            if (FAILED(hr)) <br>                {RaiseException(IDS_Unexpected); goto error;}      <br>            SysFreeString(rgbstrNames[n+1]); <br>            pParameter-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>            pCollection-&gt;Add(pdisp); <br>            pdisp-&gt;Release();   <br>        } <br>        pCollection-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>        m_pdispParameters = pdisp;    <br>        delete rgbstrNames; <br>    }     <br>    m_pdispParameters-&gt;AddRef(); <br>    return (ICollection FAR*)m_pdispParameters;        <br>     <br>error:   <br>    if (pCollection) delete pCollection;   <br>    if (rgbstrNames)  <br>        for (; n&lt;m_pfuncdesc-&gt;cParams; n++) <br>            SysFreeString(rgbstrNames[n+1]);      <br>    return NULL; <br>}  <br> <br>STDMETHODIMP_(MEMBERID) <br>CFunction::get_Memberid() <br>{ <br>    return m_pfuncdesc-&gt;memid; <br>} <br> <br>STDMETHODIMP_(CALLCONV) <br>CFunction::get_CallConvention() <br>{  <br>    return m_pfuncdesc-&gt;callconv; <br>} <br> <br>STDMETHODIMP_(FUNCKIND) <br>CFunction::get_FuncKind() <br>{  <br>    return m_pfuncdesc-&gt;funckind; <br>} <br> <br>STDMETHODIMP_(INVOKEKIND) <br>CFunction::get_InvocationKind() <br>{  <br>    return m_pfuncdesc-&gt;invkind; <br>} <br> <br>STDMETHODIMP_(short) <br>CFunction::get_NumberOfOptionalParams() <br>{ <br>return m_pfuncdesc-&gt;cParamsOpt; <br>} <br> <br>STDMETHODIMP_(short) <br>CFunction::get_OffsetInVtbl() <br>{ <br>return m_pfuncdesc-&gt;oVft; <br>} <br> <br>STDMETHODIMP_(unsigned short) <br>CFunction::get_FuncFlags() <br>{ <br>return m_pfuncdesc-&gt;wFuncFlags; <br>} <br> <br>STDMETHODIMP_(OBJTYPE) <br>CFunction::get_Kind() <br>{    <br>    return TYPE_FUNCTION; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
