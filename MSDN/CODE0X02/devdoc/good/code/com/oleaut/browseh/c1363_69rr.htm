<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MYDISP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1377"></a>MYDISP.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation TypeLibrary Browse Helper Sample <br>** <br>**  mydisp.cpp <br>** <br>**  CMyDispatch implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>**  The CMyDispatch object implement IUnknown &amp; IDispatch for all the automation <br>**  objects in this sample. All objects derive from CMyDispatch. <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif  <br>#include "browseh.h"  <br>  <br>/* <br> * CMyDispatch::CMyDispatch <br> * <br> * Purpose: <br> *  Constructor for CMyDispatch object. Initializes members to NULL. <br> * <br> */ <br>CMyDispatch::CMyDispatch() <br>{     <br>    m_ptinfo = NULL; <br>    m_cRef = 0; <br>} <br> <br>/* <br> * CMyDispatch::~CMyDispatch <br> * <br> * Purpose: <br> *  Destructor for CMyDispatch object.  <br> * <br> */ <br>CMyDispatch::~CMyDispatch() <br>{     <br>     if (m_ptinfo) m_ptinfo-&gt;Release();                    <br>} <br> <br>/* <br> * CMyDispatch::QueryInterface, AddRef, Release <br> * <br> * Purpose: <br> *  Implements IUnknown::QueryInterface, AddRef, Release <br> * <br> */ <br>  <br>STDMETHODIMP <br>CMyDispatch::QueryInterface(REFIID iid, void FAR* FAR* ppv)  <br>{    <br>    *ppv = NULL; <br>         <br>    if (iid == IID_IUnknown)  <br>        *ppv = this;    <br>    else if (iid == IID_IDispatch) <br>        *ppv = this;      <br>    else if (iid == GetInterfaceID()) <br>        *ppv = this; <br>    else return E_NOINTERFACE;  <br> <br>    AddRef(); <br>    return NOERROR;     <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CMyDispatch::AddRef(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[150]; <br>    wsprintf(ach, TEXT("Ref = %ld, Object = %s\r\n"), m_cRef+1, m_szClassName);  <br>    OutputDebugString(ach);  <br>#endif     <br>    return ++m_cRef; <br>} <br> <br> <br>STDMETHODIMP_(ULONG) <br>CMyDispatch::Release(void) <br>{ <br>#ifdef _DEBUG   <br>    TCHAR ach[150]; <br>    wsprintf(ach, TEXT("Ref = %ld, Object = %s\r\n"), m_cRef-1, m_szClassName);  <br>    OutputDebugString(ach); <br>#endif   <br>    if(--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>}  <br> <br>/* <br> * CMyDispatch::GetTypeInfoCount <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfoCount. <br> * <br> */ <br>STDMETHODIMP <br>CMyDispatch::GetTypeInfoCount(UINT FAR* pctinfo) <br>{ <br>    *pctinfo = 1; <br>    return NOERROR; <br>} <br> <br>/* <br> * CMyDispatch::GetTypeInfo <br> * <br> * Purpose: <br> *  Implements IDispatch::GetTypeInfo.  <br> * <br> */ <br>STDMETHODIMP <br>CMyDispatch::GetTypeInfo( <br>      UINT itinfo, <br>      LCID lcid, <br>      ITypeInfo FAR* FAR* pptinfo) <br>{     <br>    *pptinfo = NULL; <br>      <br>    if(itinfo != 0) <br>        return DISP_E_BADINDEX; <br>     <br>    m_ptinfo-&gt;AddRef();  <br>    *pptinfo = m_ptinfo; <br>     <br>    return NOERROR; <br>} <br> <br>/* <br> * CMyDispatch::GetIDsOfNames <br> * <br> * Purpose: <br> *  Implements IDispatch::GetIDsOfNames.  The standard implementation, DispGetIDsOfNames, <br> *  is used. <br> * <br> */ <br>STDMETHODIMP  <br>CMyDispatch::GetIDsOfNames( <br>      REFIID riid, <br>      OLECHAR FAR* FAR* rgszNames, <br>      UINT cNames, <br>      LCID lcid, <br>      DISPID FAR* rgdispid) <br>{ <br>    return DispGetIDsOfNames(m_ptinfo, rgszNames, cNames, rgdispid); <br>} <br> <br>/* <br> * CMyDispatch::Invoke <br> * <br> * Purpose: <br> *  Implements IDispatch::Invoke.  The standard implementation, DispInvoke, <br> *  is used. Properties and methods  will <br> *  set m_bRaiseException to raise an exception.  <br> * <br> */ <br>STDMETHODIMP <br>CMyDispatch::Invoke( <br>      DISPID dispidMember, <br>      REFIID riid, <br>      LCID lcid, <br>      WORD wFlags, <br>      DISPPARAMS FAR* pdispparams, <br>      VARIANT FAR* pvarResult, <br>      EXCEPINFO FAR* pexcepinfo, <br>      UINT FAR* puArgErr) <br>{   <br>    HRESULT hr; <br>    <br>    m_bRaiseException = FALSE;          <br>    hr =  DispInvoke( <br>        this, m_ptinfo, <br>        dispidMember, wFlags, pdispparams, <br>        pvarResult, pexcepinfo, puArgErr);  <br>    if (m_bRaiseException)  <br>    { <br>       if (NULL != pexcepinfo) <br>           _fmemcpy(pexcepinfo, &amp;m_excepinfo, sizeof(EXCEPINFO));   <br>       return DISP_E_EXCEPTION;  <br>    } <br>    else return hr;    <br>}  <br> <br>/* <br> * CMyDispatch::LoadTypeInfo <br> * <br> *  Purpose: <br> *   Gets type information of an object's interface from type library. <br> * <br> * Parameters: <br> *  clsid               Interface id of object in type library.  <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>STDMETHODIMP <br>CMyDispatch::LoadTypeInfo(REFCLSID clsid) <br>{                           <br>    HRESULT hr; <br>    LPTYPELIB ptlib = NULL; <br>    LPTYPEINFO ptinfo = NULL; <br>     <br>    // Load Type Library. If required, notify user on failure. <br>    hr = LoadRegTypeLib(LIBID_BrowseHelper, 1, 0, 0x09, &amp;ptlib); <br>    if (FAILED(hr)) <br>        return hr;  <br>     <br>    // Get type information for interface of the object.       <br>    hr = ptlib-&gt;GetTypeInfoOfGuid(clsid, &amp;ptinfo); <br>    if (FAILED(hr))   <br>    {  <br>        ptlib-&gt;Release(); <br>        return hr; <br>    }    <br> <br>    ptlib-&gt;Release(); <br>    m_ptinfo = ptinfo; <br>    return NOERROR; <br>} <br> <br>/* <br> * CMyDispatch::RaiseException <br> * <br> *  Purpose: <br> *   Raises exception so CMyDispatch::Invoke will return DISP_E_EXCEPTION <br> * <br> * Parameters: <br> *  nID               ID of exception to be raised. <br> * <br> */ <br>STDMETHODIMP_(void) <br>CMyDispatch::RaiseException(int nID) <br>{    <br>    extern HINSTANCE g_hinst; <br>    extern TCHAR g_szServerName[];      <br>    TCHAR szError[STR_LEN]; <br>     <br>    _fmemset(&amp;m_excepinfo, 0, sizeof(EXCEPINFO)); <br>     <br>    m_excepinfo.wCode = nID; <br>    if (LoadString(g_hinst, nID, szError, sizeof(szError))) <br>        m_excepinfo.bstrDescription = SysAllocString(TO_OLE_STRING(szError));     <br>    m_excepinfo.bstrSource = SysAllocString(TO_OLE_STRING(g_szServerName)); <br>     <br>    m_bRaiseException = TRUE;  <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
