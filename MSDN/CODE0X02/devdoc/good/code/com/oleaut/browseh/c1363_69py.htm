<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BROWSEH.H</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1366"></a>BROWSEH.H</h2>
<pre><code>#ifdef WIN32 <br> <br>#ifdef UNICODE <br>    #define FROM_OLE_STRING(str) str <br>    #define TO_OLE_STRING(str) str  <br>#else <br>    #define FROM_OLE_STRING(str) ConvertToAnsi(str) <br>    char FAR* ConvertToAnsi(OLECHAR FAR* szW);   <br>    #define TO_OLE_STRING(str) ConvertToUnicode(str) <br>    OLECHAR FAR* ConvertToUnicode(char FAR* szA);    <br>    // Maximum length of string that can be converted between Ansi &amp; Unicode <br>    #define STRCONVERT_MAXLEN 300          <br>#endif <br> <br>#else  // WIN16 <br>  #define TCHAR char <br>  #define TEXT(sz) sz  <br>  #define FROM_OLE_STRING(str) str   <br>  #define TO_OLE_STRING(str) str   <br>  #define LPTSTR LPSTR <br>#endif <br>       <br>#include "mydisp.h" <br>#include "tlb.h" <br> <br>// MAX len of string table entries <br>#define STR_LEN   200 <br> <br>// String table constants <br>#define IDS_SERVERNAME             1 <br>// These exception strings IDs that is will used in EXCEPINFO.wCode    <br>#define IDS_Unexpected             1001 <br>#define IDS_OutOfMemory            1002    <br>#define IDS_InvalidIndex           1003 <br>#define IDS_CollectionFull         1004 <br>#define IDS_CannotFindTypeLibrary  1005 <br>#define IDS_TypeLibraryCreationFailed 1006     <br>#define IDS_WrongType               1007 <br>#define IDS_InvalidProgid           1008 <br>#define IDS_CouldNotCreateObject    1009 <br>#define IDS_ObjectDoesNotSupportAutomation   1010        <br>#define IDS_ObjectDoesNotProvideTypeInfo  1011 <br>#define IDS_NotDualInterface 1012 <br> <br>// Function prototypes <br>BOOL InitDLL (HINSTANCE hInstance); <br>extern "C" STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);    <br>extern "C" STDAPI DllCanUnloadNow(void); <br> <br>//Forward declarations. <br>class CArrayBound; <br>  <br>class FAR CBrowseHelperCF : public IClassFactory <br>{ <br>public: <br>    // IUnknown methods  <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(void); <br>    STDMETHOD_(ULONG, Release)(void);  <br>     <br>    // IClassFactory methods <br>    STDMETHOD(CreateInstance)(IUnknown FAR* punkOuter, REFIID riid, void FAR* FAR* ppv); <br>    STDMETHOD(LockServer)(BOOL fLock);     <br>     <br>    CBrowseHelperCF(); <br>     <br>private: <br>    ULONG m_cRef;                   // Reference count <br>};  <br> <br>     <br>class FAR CBrowseHelper : public IBrowseHelper <br>{ <br>public: <br>    // IBrowseHelper automation exposed methods <br>    STDMETHOD_(ITypeLibrary FAR*, BrowseTypeLibrary)(BSTR bstrPath);      <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(CBrowseHelper FAR* FAR* ppBrowseHelper); // Creates and intializes Applicaton object  <br>    CBrowseHelper(); <br>    ~CBrowseHelper(); <br>}; <br> <br>class FAR CTypeLibrary : public ITypeLibrary <br>{ <br>public: <br>    // ITypeLibrary automation exposed properties &amp; methods  <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(BSTR, get_Documentation)(); <br>    STDMETHOD_(long, get_HelpContext)(); <br>    STDMETHOD_(BSTR, get_HelpFile)(); <br>    STDMETHOD_(long, get_LocaleID)(); <br>    STDMETHOD_(int, get_MajorVersion)(); <br>    STDMETHOD_(int, get_MinorVersion)(); <br>STDMETHOD_(BSTR, get_GUIDAsString)(); <br>    STDMETHOD_(ICollection FAR*, get_TypeInfos)();    <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPELIB ptlib, CTypeLibrary FAR* FAR* ppTypeLibrary); // Creates and intializes TypeLibrary object  <br>    CTypeLibrary(); <br>    ~CTypeLibrary(); <br>     <br>private:     <br>    BSTR m_bstrName;               // Type Library name <br>    BSTR m_bstrDocumentation;      // Documentation <br>    unsigned long m_ulHelpContext; // HelpContext <br>    BSTR m_bstrHelpFile;           // HelpFile <br>    GUID m_guid;                   // GUID <br>LPOLESTR m_pszGUID;            // String form of GUID <br>    LCID m_lcid;                   // Locale ID <br>    unsigned short m_wMajorVer;    // Major version <br>    unsigned short m_wMinorVer;    // Minor version <br>    LPTYPELIB m_ptlib;             // ITypeLib* of type library. <br>    LPDISPATCH m_pdispTypeInfos;   // Collection of typeinfos contained by this typelib <br>}; <br> <br>// CTypeInfo is the base class for all the TypeInfos (CInterface, CDispinterface, <br>// CModule, CCoClass, CEnum, CStruct, CUnion, CAlias) <br>class FAR CTypeInfo : public ITypeInformation <br>{ <br>public: <br>    // ITypeInfo automation exposed properties &amp; methods  <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(BSTR, get_Documentation)(); <br>    STDMETHOD_(long, get_HelpContext)(); <br>    STDMETHOD_(BSTR, get_HelpFile)(); <br>    STDMETHOD_(TYPEKIND, get_TypeInfoKind)(); <br>    STDMETHOD_(short, get_TypeFlags)(); <br>    STDMETHOD_(BSTR, get_GUIDAsString)(); <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)(); <br>    STDMETHOD(_InitTypeInfo)(LPTYPEINFO ptinfo); // Called by derived class to intialize this base class <br>    static HRESULT Create(LPTYPEINFO ptinfo, CTypeInfo FAR* FAR* ppTypeInfo); // Creates and intializes TypeInfo object  <br>    CTypeInfo(); <br>    ~CTypeInfo(); <br> <br>protected: <br>short m_wTypeFlags;            // TYPEFLAGS <br> <br>private:     <br>    BSTR m_bstrName;               // TypeInfo name <br>    BSTR m_bstrDocumentation;      // Documentation  <br>    unsigned long m_ulHelpContext; // Help context <br>    BSTR m_bstrHelpFile;           // Help file <br>    TYPEKIND m_typekind;           // Type of TypeInfo. See TYPEKIND enumeration. <br>    GUID m_guid;                   // GUID <br>LPOLESTR m_pszGUID;            // String form of GUID <br>}; <br> <br>class FAR CInterface : public CTypeInfo        <br>{ <br>public: <br>    // IInterface automation exposed properties &amp; methods  <br>    STDMETHOD_(ICollection FAR*, get_Functions)(); <br>    STDMETHOD_(IInterface FAR*, get_BaseInterface)(); <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CInterface FAR* FAR* ppInterface); // Creates and intializes Interface object  <br>    CInterface(); <br>    ~CInterface(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;             // ITypeInfo* of interface typeinfo. <br>    LPDISPATCH m_pdispFunctions;     // Collection of functions in interface. <br>LPDISPATCH m_pdispBaseInterface; // Base interface of this interface. <br>}; <br> <br>class FAR CDispinterface : public CTypeInfo <br>{ <br>public: <br>    // IDispinterface automation exposed properties &amp; methods  <br>    STDMETHOD_(ICollection FAR*, get_Properties)(); <br>    STDMETHOD_(ICollection FAR*, get_Methods)(); <br>STDMETHOD_(IInterface FAR*, get_Interface)(); <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CDispinterface FAR* FAR* ppDispinterface); // Creates and intializes Dispinterface object  <br>    CDispinterface(); <br>    ~CDispinterface(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;              // ITypeInfo* of dispinterface typeinfo. <br>    LPDISPATCH m_pdispProperties;     // Collection of properties in dispinterface <br>    LPDISPATCH m_pdispMethods;        // Collection of methods in dispinterface <br>LPDISPATCH m_pdispInterface;      // Interface part of dual interface, if this is a dual interface <br>};   <br> <br>class FAR CModule : public CTypeInfo        <br>{ <br>public: <br>    // IModule automation exposed properties &amp; methods  <br>    STDMETHOD_(ICollection FAR*, get_Functions)();     <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();    <br>    static HRESULT Create(LPTYPEINFO ptinfo, CModule FAR* FAR* ppInterface); // Creates and intializes Module object  <br>    CModule(); <br>    ~CModule(); <br>     <br>private:                              <br>    LPTYPEINFO m_ptinfo;              // ITypeInfo* of module typeinfo. <br>    LPDISPATCH m_pdispFunctions;      // Collection of functions in module <br>}; <br> <br>class FAR CCoClass : public CTypeInfo <br>{ <br>public:    <br>    // ICoClass automation exposed properties &amp; methods  <br>    STDMETHOD_(ICollection FAR*, get_Interfaces)();      <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CCoClass FAR* FAR* ppCoClass); // Creates and intializes CoClass object      <br>    CCoClass(); <br>    ~CCoClass(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;              // ITypeInfo* of coclass typeinfo. <br>    LPDISPATCH m_pdispInterfaces;     // Collection of interfaces/dispinterfaces in coclass <br>};  <br> <br>class FAR CEnum : public CTypeInfo <br>{ <br>public: <br>    // IEnum automation exposed properties &amp; methods <br>    STDMETHOD_(ICollection FAR*, get_Elements)();     <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CEnum FAR* FAR* ppEnum); // Creates and intializes Enum object  <br>    CEnum(); <br>    ~CEnum(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;             // ITypeInfo* of enum typeinfo. <br>    LPDISPATCH m_pdispElements;      // Collection of elements in enum. <br>}; <br> <br>class FAR CStruct : public CTypeInfo <br>{ <br>public:  <br>     // IStruct automation exposed properties &amp; methods  <br>    STDMETHOD_(ICollection FAR*, get_Members)();  <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CStruct FAR* FAR* ppStruct); // Creates and intializes Struct object  <br>    CStruct(); <br>    ~CStruct(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;            // ITypeInfo* of struct typeinfo. <br>    LPDISPATCH m_pdispMembers;      // Collection of members in struct. <br>}; <br> <br>class FAR CUnion : public CTypeInfo <br>{   <br>public: <br>    // IUnion automation exposed properties &amp; methods   <br>    STDMETHOD_(ICollection FAR*, get_Members)();    <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CUnion FAR* FAR* ppUnion); // Creates and intializes Struct object  <br>    CUnion(); <br>    ~CUnion(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;            // ITypeInfo* of union typeinfo. <br>    LPDISPATCH m_pdispMembers;      // Collection of members in union. <br>}; <br> <br> <br>class FAR CAlias : public CTypeInfo <br>{  <br>public:     <br>    // IAlias automation exposed properties &amp; methods   <br>    STDMETHOD_(ITypeDesc FAR*, get_BaseType)();  <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, CAlias FAR* FAR* ppAlias); // Creates and intializes Alias object  <br>    CAlias(); <br>    ~CAlias(); <br>     <br>private: <br>    LPTYPEINFO m_ptinfo;             // ITypeInfo* of alias typeinfo. <br>    LPDISPATCH m_pdispTypeDescBase;  // IDispatch of ITypeDesc which describes the base type of this alias. <br>};   <br> <br>// CFunction represents all functions (including methods). <br>class FAR CFunction : public IFunction <br>{ <br>public: <br>    // IFunction automation exposed properties &amp; methods  <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(BSTR, get_Documentation)(); <br>    STDMETHOD_(long, get_HelpContext)(); <br>    STDMETHOD_(BSTR, get_HelpFile)(); <br>    STDMETHOD_(ITypeDesc FAR*, get_ReturnType)(); <br>    STDMETHOD_(ICollection FAR*, get_Parameters)();  <br>    STDMETHOD_(MEMBERID, get_Memberid)(); <br>    STDMETHOD_(CALLCONV, get_CallConvention)();  <br>    STDMETHOD_(FUNCKIND, get_FuncKind)(); <br>    STDMETHOD_(INVOKEKIND, get_InvocationKind)(); <br>STDMETHOD_(short, get_NumberOfOptionalParams)(); <br>    STDMETHOD_(short, get_OffsetInVtbl)(); <br>STDMETHOD_(unsigned short, get_FuncFlags)(); <br>    STDMETHOD_(OBJTYPE, get_Kind)();       <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, unsigned short nIndex, CFunction FAR* FAR* ppFunction); // Creates and intializes Function object  <br>    CFunction(); <br>    ~CFunction(); <br>     <br>private:    <br>    BSTR m_bstrName;                     // Function name. <br>    BSTR m_bstrDocumentation;            // Documentation. <br>    unsigned long m_ulHelpContext;       // Help context. <br>    BSTR m_bstrHelpFile;                 // Help file. <br>    LPDISPATCH m_pdispTypeDesc;          // IDispatch of ITypeDesc that described return type. <br>    LPDISPATCH m_pdispParameters;        // Collection of parameters function. <br>    LPFUNCDESC m_pfuncdesc;              // FUNCDESC of function. <br>    LPTYPEINFO m_ptinfoFunction;         // TypeInfo of which this function is an element. <br>}; <br> <br>// CProperty represents dispinterface properties and structure &amp; union members. <br>class FAR CProperty : public IProperty <br>{ <br>public: <br>    // IProperty automation exposed properties &amp; methods  <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(BSTR, get_Documentation)(); <br>    STDMETHOD_(long, get_HelpContext)(); <br>    STDMETHOD_(BSTR, get_HelpFile)(); <br>    STDMETHOD_(ITypeDesc FAR*, get_Type)(); <br>    STDMETHOD_(MEMBERID, get_Memberid)();  <br>    STDMETHOD_(OBJTYPE, get_Kind)();   <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();    <br>    static HRESULT Create(LPTYPEINFO ptinfo, LPVARDESC pvardesc, CProperty FAR* FAR* ppProperty); // Creates and intializes Property object  <br>    CProperty(); <br>    ~CProperty(); <br>     <br>private:         <br>    BSTR m_bstrName;                     // Property name. <br>    BSTR m_bstrDocumentation;            // Documentation. <br>    unsigned long m_ulHelpContext;       // Help Context. <br>    BSTR m_bstrHelpFile;                 // Helpfile. <br>    MEMBERID m_memid;                    // MEMBERID of property. <br>    LPDISPATCH m_pdispTypeDesc;          // ITypeDesc that describes type of property. <br>}; <br> <br>class FAR CConstant : public IConstant <br>{ <br>public: <br>    // IConstant automation exposed properties &amp; methods <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(BSTR, get_Documentation)(); <br>    STDMETHOD_(long, get_HelpContext)(); <br>    STDMETHOD_(BSTR, get_HelpFile)(); <br>    STDMETHOD_(ITypeDesc FAR*, get_Type)();     <br>    STDMETHOD_(VARIANT, get_Value)();       <br>    STDMETHOD_(MEMBERID, get_Memberid)();  <br>    STDMETHOD_(OBJTYPE, get_Kind)();   <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, LPVARDESC pvardesc, CConstant FAR* FAR* ppConstant); // Creates and intializes Constant object  <br>    CConstant(); <br>    ~CConstant(); <br>     <br>private:         <br>    BSTR m_bstrName;                       // Constant name <br>    BSTR m_bstrDocumentation;              // Documentation <br>    unsigned long m_ulHelpContext;         // Help context <br>    BSTR m_bstrHelpFile;                   // Helpfile <br>    LPDISPATCH m_pdispTypeDesc;            // ITypeDesc that describes type of constant. <br>    MEMBERID m_memid;                      // MEMBERID. <br>    VARIANT m_vValue;                      // Constant value. <br>}; <br> <br>class FAR CParameter : public IParameter <br>{ <br>public: <br>    // IParameter automation exposed properties &amp; methods  <br>    STDMETHOD_(BSTR, get_Name)(); <br>    STDMETHOD_(ITypeDesc FAR*, get_Type)();  <br>    STDMETHOD_(int, get_IDLFlags)(); <br>    STDMETHOD_(OBJTYPE, get_Kind)();     <br>     <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, BSTR bstrName, TYPEDESC FAR* ptypedesc,  <br>         IDLDESC FAR* pidldesc, CParameter FAR* FAR* ppParameter);  // Creates and intializes Parameter object  <br>    CParameter(); <br>    ~CParameter(); <br>     <br>private:   <br>    BSTR m_bstrName;                      // Parameter name. <br>    unsigned short m_wIDLFlags;           // specifies in/out/in-out/none <br>    LPDISPATCH m_pdispTypeDesc;           // ITypeDesc* that describes type of parameter. <br>};   <br> <br>// Describes a type <br>class FAR CTypeDesc : public ITypeDesc <br>{ <br>public:    <br>    // ITypeDesc automation exposed properties &amp; methods <br>    STDMETHOD_(short, get_Type)(); <br>    STDMETHOD_(ITypeInformation FAR*, get_UserDefinedDesc)(); <br>    STDMETHOD_(IArrayDesc FAR*, get_ArrayDesc)(); <br>    STDMETHOD_(ITypeDesc FAR*, get_PointerDesc)();   <br> <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, TYPEDESC FAR* ptypedesc, CTypeDesc FAR* FAR* ppTypeDesc); // Creates and intializes TypeDesc object  <br>    CTypeDesc(); <br>    ~CTypeDesc(); <br>     <br>private: <br>    VARTYPE m_vartype;                  // Type <br>    LPDISPATCH m_pdispUserDefinedDesc;  // If m_vartype==VT_USERDEFINED, contains ITypeInformation* of user-defined type.,  <br>    LPDISPATCH m_pdispArrayDesc;        // if m_vartype==VT_CARRAY, contains IArrayDesc*  <br>    LPDISPATCH m_pdispPointerDesc;      // if m_vartype==VT_PTR contains ITypeDesc* of type pointed to. <br>}; <br> <br>// Describes C-Style array <br>class FAR CArrayDesc : public IArrayDesc <br>{ <br>public:      <br>    // IArrayDesc automation exposed properties &amp; methods <br>    STDMETHOD_(ITypeDesc FAR*, get_ElementType)(); <br>    STDMETHOD_(ICollection FAR*, get_ArrayBounds)();    <br> <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(LPTYPEINFO ptinfo, ARRAYDESC FAR* parraydesc, CArrayDesc FAR* FAR* ppArrayDesc); // Creates and intializes ArrayDesc object  <br>    CArrayDesc(); <br>    ~CArrayDesc(); <br>     <br>private: <br>    LPDISPATCH m_pdispTypeDescElement;     // ITypeDesc that descibed type of array element. <br>    LPDISPATCH m_pdispArrayBounds;         // IArrayBound that describes array bounds. <br>}; <br> <br>class FAR CArrayBound : public IArrayBound <br>{ <br>public: <br>    // IArrayBound automation exposed properties &amp; methods <br>    STDMETHOD_(long, get_ElementsCount)(); <br>    STDMETHOD_(long, get_LowerBound)();   <br> <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();     <br>    static HRESULT Create(unsigned long cElements, long lLBound, CArrayBound FAR* FAR* ppArrayBound); // Creates and intializes ArrayBound object <br>     <br>private: <br>    unsigned long m_cElements;             // Count of elements in array. <br>    long m_lLBound;                        // Lower bound of array. <br>}; <br> <br>// Generic collection class that holds all collections. <br>class FAR CCollection : public ICollection <br>{ <br>public: <br>    // ICollection automation exposed properties &amp; methods <br>    STDMETHOD_(long, get_Count)(); <br>    STDMETHOD_(LPDISPATCH, get_Item)(long lIndex); <br>    STDMETHOD_(LPUNKNOWN, get__NewEnum)(); <br>     <br>    // CCollection methods  <br>    STDMETHOD_(void, Add)(LPDISPATCH pdispItem);   <br>    STDMETHOD_(REFCLSID, GetInterfaceID)();    <br>    static HRESULT Create(ULONG lMaxSize, long lLBound, CCollection FAR* FAR* ppCollection); // Creates and intializes Collection object  <br>    CCollection(); <br>    ~CCollection(); <br>     <br>private: <br>    SAFEARRAY FAR *m_psa;          // Safe array that holds Collection collection items. <br>    ULONG m_cElements;             // Number of items in Collection collection. <br>    ULONG m_cMax;                  // Maximum number of items Collection collection can hold. <br>    long m_lLBound;                // Lower bound of index of Collection collection. <br>}; <br> <br>class FAR CEnumVariant : public IEnumVARIANT <br>{ <br>public: <br>    // IUnknown methods  <br>    STDMETHOD(QueryInterface)(REFIID riid, LPVOID FAR* ppvObj); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>    // IEnumVARIANT methods  <br>    STDMETHOD(Next)(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched); <br>    STDMETHOD(Skip)(ULONG cElements); <br>    STDMETHOD(Reset)(); <br>    STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum); <br>     <br>    static HRESULT Create(SAFEARRAY FAR*, ULONG, CEnumVariant FAR* FAR*); // Creates and intializes Enumerator <br>    CEnumVariant(); <br>    ~CEnumVariant(); <br>     <br>private: <br>    ULONG m_cRef;           // Reference count                                  <br>    ULONG m_cElements;      // Number of elements in enumerator.  <br>    long m_lLBound;         // Lower bound of index. <br>    long m_lCurrent;        // Current index. <br>    SAFEARRAY FAR* m_psa;   // Safe array that holds elements. <br>};   </code></pre>
<p>&nbsp;</p></body>
</HTML>
