<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TYPELIB.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1385"></a>TYPELIB.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  OLE Automation TypeLibrary Browse Helper Sample <br>** <br>**  typelib.cpp <br>** <br>**  CTypeLibrary implementation <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;   <br>#endif  <br>#include "browseh.h"   <br> <br>/* <br> * CTypeLibrary::Create <br> * <br> * Purpose: <br> *  Creates an instance of the TypeLibrary automation object and initializes it. <br> * <br> * Parameters:        <br> *  ptlib            ITypeLib interface that corresponds to this CTypeLibrary object. <br> *  ppTypeLibrary    Returns TypeLibrary automation object. <br> * <br> * Return Value: <br> *  HRESULT <br> * <br> */ <br>HRESULT  <br>CTypeLibrary::Create(LPTYPELIB ptlib, CTypeLibrary FAR* FAR* ppTypeLibrary )  <br>{    <br>    HRESULT hr; <br>    CTypeLibrary FAR* pTypeLibrary = NULL;     <br>    LPTLIBATTR ptlibattr; <br>      <br>    *ppTypeLibrary = NULL; <br>     <br>    // Create typelibrary object. <br>    pTypeLibrary = new CTypeLibrary(); <br>    if (pTypeLibrary == NULL) <br>    { <br>        hr = E_OUTOFMEMORY;  <br>        goto error; <br>    } <br>     <br>    // Load type information for the typelibrary object from type library.  <br>    hr = pTypeLibrary-&gt;LoadTypeInfo(IID_ITypeLibrary); <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>    hr = ptlib-&gt;GetDocumentation(-1, &amp;pTypeLibrary-&gt;m_bstrName, &amp;pTypeLibrary-&gt;m_bstrDocumentation, <br>             &amp;pTypeLibrary-&gt;m_ulHelpContext, &amp;pTypeLibrary-&gt;m_bstrHelpFile);   <br>    if (FAILED(hr)) <br>        goto error;     <br>         <br>    hr = ptlib-&gt;GetLibAttr(&amp;ptlibattr); <br>    if (FAILED(hr)) <br>        goto error; <br>    pTypeLibrary-&gt;m_guid = ptlibattr-&gt;guid; <br>    pTypeLibrary-&gt;m_lcid = ptlibattr-&gt;lcid; <br>    pTypeLibrary-&gt;m_wMajorVer = ptlibattr-&gt;wMajorVerNum;   <br>    pTypeLibrary-&gt;m_wMinorVer = ptlibattr-&gt;wMinorVerNum; <br>    ptlib-&gt;ReleaseTLibAttr(ptlibattr); <br>         <br>    ptlib-&gt;AddRef(); <br>    pTypeLibrary-&gt;m_ptlib = ptlib;   <br>     <br>#ifdef _DEBUG   <br>    lstrcpyn(pTypeLibrary-&gt;m_szClassName, TEXT("TypeLibrary"), 100); <br>#endif <br>         <br>    *ppTypeLibrary = pTypeLibrary; <br>    return NOERROR; <br>     <br>error:                         <br>    if (pTypeLibrary == NULL) return E_OUTOFMEMORY; <br>    if (pTypeLibrary-&gt;m_ptlib) pTypeLibrary-&gt;m_ptlib-&gt;Release(); <br>    if (pTypeLibrary-&gt;m_bstrName) SysFreeString(pTypeLibrary-&gt;m_bstrName); <br>    if (pTypeLibrary-&gt;m_bstrDocumentation) SysFreeString(pTypeLibrary-&gt;m_bstrDocumentation); <br>    if (pTypeLibrary-&gt;m_bstrHelpFile) SysFreeString(pTypeLibrary-&gt;m_bstrHelpFile); <br>          <br>    // Set to NULL to prevent destructor from attempting to free again   <br>    pTypeLibrary-&gt;m_ptlib = NULL; <br>    pTypeLibrary-&gt;m_bstrName = NULL; <br>    pTypeLibrary-&gt;m_bstrDocumentation = NULL; <br>    pTypeLibrary-&gt;m_bstrHelpFile = NULL; <br>     <br>    delete pTypeLibrary; <br>    return hr; <br>} <br> <br>/* <br> * CTypeLibrary::CTypeLibrary <br> * <br> * Purpose: <br> *  Constructor for CTypeLibrary object. Initializes members to NULL. <br> * <br> */ <br>CTypeLibrary::CTypeLibrary() <br>{   <br>    m_ptlib = NULL;  <br>    m_bstrName = NULL; <br>    m_bstrDocumentation = NULL; <br>    m_bstrHelpFile = NULL;    <br>    m_pdispTypeInfos = NULL; <br>        m_pszGUID = NULL; <br>} <br> <br>/* <br> * CTypeLibrary::~CTypeLibrary <br> * <br> * Purpose: <br> *  Destructor for CTypeLibrary object. Frees TypeLibrary message BSTR and default <br> *  IDispatch implementation. Closes the aplication. <br> * <br> */ <br>CTypeLibrary::~CTypeLibrary() <br>{     <br>    if (m_ptlib) m_ptlib-&gt;Release();     <br>    if (m_bstrName) SysFreeString(m_bstrName); <br>    if (m_bstrDocumentation) SysFreeString(m_bstrDocumentation); <br>    if (m_bstrHelpFile) SysFreeString(m_bstrHelpFile);   <br>    if (m_pdispTypeInfos) m_pdispTypeInfos-&gt;Release(); <br>#ifdef WIN32 <br>    if (m_pszGUID) CoTaskMemFree(m_pszGUID); <br>#else <br>    HRESULT hr; <br>    LPMALLOC pmalloc; <br>    if (m_pszGUID) <br>    { <br>       hr = CoGetMalloc(MEMCTX_TASK, &amp;pmalloc); <br>       if (SUCCEEDED(hr)) <br>       { <br>           pmalloc-&gt;Free(m_pszGUID); <br>           pmalloc-&gt;Release(); <br>       } <br>    } <br>#endif  <br>     <br>}  <br> <br>STDMETHODIMP_(REFCLSID) <br>CTypeLibrary::GetInterfaceID() <br>{ <br>    return IID_ITypeLibrary; <br>} <br>  <br>STDMETHODIMP_(BSTR) <br>CTypeLibrary::get_Name()      <br>{ <br>    return SysAllocString(m_bstrName); <br>}   <br> <br>STDMETHODIMP_(BSTR) <br>CTypeLibrary::get_Documentation()     <br>{ <br>    return SysAllocString(m_bstrDocumentation); <br>}   <br> <br>STDMETHODIMP_(long) <br>CTypeLibrary::get_HelpContext()      <br>{ <br>    return (long)m_ulHelpContext; <br>} <br> <br>STDMETHODIMP_(BSTR) <br>CTypeLibrary::get_HelpFile()      <br>{ <br>    return SysAllocString(m_bstrHelpFile); <br>}   <br> <br>STDMETHODIMP_(int) <br>CTypeLibrary::get_MajorVersion()      <br>{ <br>    return (int)m_wMajorVer; <br>}  <br> <br>STDMETHODIMP_(int) <br>CTypeLibrary::get_MinorVersion()      <br>{ <br>    return (int)m_wMinorVer; <br>} <br> <br>STDMETHODIMP_(long) <br>CTypeLibrary::get_LocaleID()      <br>{ <br>    return (long)m_lcid; <br>}  <br> <br>STDMETHODIMP_(ICollection FAR*) <br>CTypeLibrary::get_TypeInfos()      <br>{    <br>    HRESULT hr; <br>    CTypeInfo FAR* pTypeInfo; <br>    CInterface FAR* pInterface; <br>    CDispinterface FAR* pDispinterface; <br>    CModule FAR* pModule; <br>    CCoClass FAR* pCoClass;     <br>    CEnum FAR* pEnum;    <br>    CAlias FAR* pAlias; <br>    CStruct FAR* pStruct; <br>    CUnion FAR* pUnion; <br>    CCollection FAR* pCollection = NULL; <br>    LPDISPATCH pdisp;  <br>    LPTYPEINFO ptinfo = NULL; <br>    unsigned int cTypeInfo;     <br>    unsigned int n;       <br>    TYPEKIND typekind; <br>     <br>    if (m_pdispTypeInfos == NULL) <br>    { <br>        cTypeInfo = m_ptlib-&gt;GetTypeInfoCount();      <br>        hr = CCollection::Create(cTypeInfo, 0, &amp;pCollection); <br>        if (FAILED(hr)) <br>            {RaiseException(IDS_Unexpected); goto error;}   <br>         <br>        // Enumerate the typeinfos in this type library <br>        for (n=0; n&lt;cTypeInfo; n++) <br>        { <br>            hr = m_ptlib-&gt;GetTypeInfo(n, &amp;ptinfo);   <br>            if (FAILED(hr)) <br>                {RaiseException(IDS_Unexpected); goto error;}     <br>            hr = m_ptlib-&gt;GetTypeInfoType(n, &amp;typekind); <br>            if (FAILED(hr)) <br>                {RaiseException(IDS_Unexpected); goto error;}       <br>            switch (typekind) <br>            { <br>                case TKIND_INTERFACE: <br>                    hr = CInterface::Create(ptinfo, &amp;pInterface);  <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}   <br>                    pInterface-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break; <br>              <br>                case TKIND_DISPATCH: <br>                    hr = CDispinterface::Create(ptinfo, &amp;pDispinterface);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}    <br>                    pDispinterface-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;   <br>                     <br>                case TKIND_MODULE: <br>                    hr = CModule::Create(ptinfo, &amp;pModule);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}    <br>                    pModule-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break; <br>                 <br>                case TKIND_COCLASS: <br>                    hr = CCoClass::Create(ptinfo, &amp;pCoClass);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}     <br>                    pCoClass-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;  <br>                     <br>                case TKIND_ENUM: <br>                    hr = CEnum::Create(ptinfo, &amp;pEnum);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}     <br>                    pEnum-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;   <br>                     <br>                case TKIND_ALIAS: <br>                    hr = CAlias::Create(ptinfo, &amp;pAlias);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}     <br>                    pAlias-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;  <br>                     <br>                 case TKIND_RECORD: <br>                    hr = CStruct::Create(ptinfo, &amp;pStruct);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}     <br>                    pStruct-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;  <br>                     <br>                 case TKIND_UNION: <br>                    hr = CUnion::Create(ptinfo, &amp;pUnion);   <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}     <br>                    pUnion-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break;  <br>                     <br>                default:        <br>                    // Currently unsupported TKINDs <br>                    hr = CTypeInfo::Create(ptinfo, &amp;pTypeInfo);  <br>                    if (FAILED(hr)) <br>                        {RaiseException(IDS_Unexpected); goto error;}   <br>                    pTypeInfo-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>                    break; <br>            }  <br>            // Add typeinfo to collection of typeinfos. <br>            pCollection-&gt;Add(pdisp);   <br>            pdisp-&gt;Release(); <br>            ptinfo-&gt;Release();    <br>            ptinfo = NULL; <br>        }  <br>     <br>        pCollection-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>        m_pdispTypeInfos = pdisp; <br>    } <br>    m_pdispTypeInfos-&gt;AddRef(); <br>    return (ICollection FAR*)m_pdispTypeInfos; <br> <br>error:    <br>    if (ptinfo) ptinfo-&gt;Release();      <br>    if (pCollection) delete pCollection;     <br>    return NULL; <br>} <br> <br>STDMETHODIMP_(BSTR) <br>CTypeLibrary::get_GUIDAsString()      <br>{ <br>        if (m_pszGUID == NULL) <br>            StringFromCLSID(m_guid, &amp;m_pszGUID); <br>    return SysAllocString(m_pszGUID); <br>}  </code></pre>
<p>&nbsp;</p></body>
</HTML>
