<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INVHELP.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1359"></a>INVHELP.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  Automation Controller helper functions <br>** <br>**  invhelp.cpp <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>/* <br> * This file contains helper functions that make it simple to create late-binding <br> * automation controllers. CreateObject() will create an automation object and <br> * Invoke() will call a property or method of the automation object.  <br> * <br> * For example, the following VB code will control Microsoft Word: <br> *     <br> *    Private Sub Form_Load() <br> *    Dim wb As Object <br> *    Set wb = CreateObject("Word.Basic") <br> *    wb.AppShow <br> *    wb.FileNewDefault <br> *    wb.Insert "This is a test" <br> *    wb.FileSaveAs "c:\sample.doc)" <br> *    End Sub <br> *    <br> * A C++ automation controller that does the same can be written as follows using <br> * the helper functions: <br> *  <br> *   LPDISPATCH pdispWord; <br> *   CreateObject(OLESTR("Word.Basic"), &amp;pdispWord); <br> *   Invoke(pdispWord, DISPATCH_METHOD, NULL, NULL, NULL, <br> *              OLESTR("AppShow"), NULL);    <br> *   Invoke(pdispWord, DISPATCH_METHOD, NULL, NULL, NULL, <br> *              OLESTR("FileNewDefault"), NULL);  <br> *   Invoke(pdispWord, DISPATCH_METHOD, NULL, NULL, NULL,  <br> *              OLESTR("Insert"), TEXT("s"), (LPOLESTR)OLESTR("This is a test")); <br> *   Invoke(pdispWord, DISPATCH_METHOD, NULL, NULL, NULL,  <br> *              OLESTR("FileSaveAs"), TEXT("s"), OLESTR("c:\\sample.doc")); <br> *   pdispWord-&gt;Release(); <br> *   <br> * See the header comments of CreateObject and Invoke for documentation to use <br> * these functions. <br> * <br> */ <br>      <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt;  <br>#endif <br>#include &lt;stdarg.h&gt;   <br> <br>#ifdef WIN16 <br>  #define LPCTSTR LPCSTR <br>  #define LPOLESTR LPSTR <br>#endif <br> <br>HRESULT CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn); <br>LPCTSTR GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt); <br> <br>/* <br> * CreateObject <br> * <br> * Purpose: <br> *  Creates an instance of the Automation object and obtains it's IDispatch interface. <br> *  Uses Unicode with OLE. <br> * <br> * Parameters: <br> *  pszProgID         ProgID of Automation object <br> *  ppdisp             Returns IDispatch of Automation object <br> * <br> * Return Value: <br> *  HRESULT indicating success or failure  <br> */ <br>HRESULT CreateObject(LPOLESTR pszProgID, IDispatch FAR* FAR* ppdisp) <br>{ <br>    CLSID clsid;                   // CLSID of automation object <br>    HRESULT hr; <br>    LPUNKNOWN punk = NULL;         // IUnknown of automation object <br>    LPDISPATCH pdisp = NULL;       // IDispatch of automation object <br>     <br>    *ppdisp = NULL; <br>     <br>    // Retrieve CLSID from the progID that the user specified <br>    hr = CLSIDFromProgID(pszProgID, &amp;clsid); <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>    // Create an instance of the automation object and ask for the IDispatch interface <br>    hr = CoCreateInstance(clsid, NULL, CLSCTX_SERVER,  <br>                          IID_IUnknown, (void FAR* FAR*)&amp;punk); <br>    if (FAILED(hr)) <br>        goto error; <br>                    <br>    hr = punk-&gt;QueryInterface(IID_IDispatch, (void FAR* FAR*)&amp;pdisp); <br>    if (FAILED(hr)) <br>        goto error; <br> <br>    *ppdisp = pdisp; <br>    punk-&gt;Release(); <br>    return NOERROR; <br>      <br>error: <br>    if (punk) punk-&gt;Release(); <br>    if (pdisp) pdisp-&gt;Release(); <br>    return hr; <br>}   <br> <br>/* <br> * Invoke <br> * <br> * Purpose: <br> *  Invokes a property accessor function or method of an automation object. Uses Unicode with OLE. <br> * <br> * Parameters: <br> *  pdisp         IDispatch* of automation object. <br> *  wFlags        Specfies if property is to be accessed or method to be invoked. <br> *                Can hold DISPATCH_PROPERTYGET, DISPATCH_PROPERTYPUT, DISPATCH_METHOD, <br> *                DISPATCH_PROPERTYPUTREF or DISPATCH_PROPERTYGET|DISPATCH_METHOD.    <br> *  pvRet         NULL if caller excepts no result. Otherwise returns result. <br> *  pexcepinfo    Returns exception info if DISP_E_EXCEPTION is returned. Can be NULL if <br> *                caller is not interested in exception information.  <br> *  pnArgErr      If return is DISP_E_TYPEMISMATCH, this returns the index (in reverse <br> *                order) of argument with incorrect type. Can be NULL if caller is not interested <br> *                in this information.  <br> *  pszName       Name of property or method. <br> *  pszFmt        Format string that describes the variable list of parameters that  <br> *                follows. The format string can contain the follwoing characters. <br> *                &amp; = mark the following format character as VT_BYREF  <br> *                b = VT_BOOL <br> *                i = VT_I2 <br> *                I = VT_I4 <br> *                r = VT_R2 <br> *                R = VT_R4 <br> *                c = VT_CY  <br> *                s = VT_BSTR (far string pointer can be passed, BSTR will be allocated by this function). <br> *                e = VT_ERROR <br> *                d = VT_DATE <br> *                v = VT_VARIANT. Use this to pass data types that are not described in  <br> *                                the format string. (For example SafeArrays). <br> *                D = VT_DISPATCH <br> *                U = VT_UNKNOWN <br> *     <br> *  ...           Arguments of the property or method. Arguments are described by pszFmt.   <br> *                ****FAR POINTERS MUST BE PASSED FOR POINTER ARGUMENTS in Win16.**** <br> * Return Value: <br> *  HRESULT indicating success or failure         <br> * <br> * Usage examples: <br> * <br> *  HRESULT hr;   <br> *  LPDISPATCH pdisp;    <br> *  BSTR bstr; <br> *  short i; <br> *  BOOL b;    <br> *  VARIANT v, v2; <br> * <br> *1. bstr = SysAllocString(OLESTR("")); <br> *   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method1"),  <br> *        TEXT("bis&amp;b&amp;i&amp;s"), TRUE, 2, (LPOLESTR)OLESTR("param"), (BOOL FAR*)&amp;b, (short FAR*)&amp;i, (BSTR FAR*)&amp;bstr);    <br> * <br> *2. VariantInit(&amp;v); <br> *   V_VT(&amp;v) = VT_R8; <br> *   V_R8(&amp;v) = 12345.6789;  <br> *   VariantInit(&amp;v2); <br> *   hr = Invoke(pdisp, DISPATCH_METHOD, NULL, NULL, NULL, OLESTR("method2"),  <br> *         TEXT("v&amp;v"), v, (VARIANT FAR*)&amp;v2); <br> */ <br>HRESULT  <br>Invoke(LPDISPATCH pdisp,  <br>    WORD wFlags, <br>    LPVARIANT pvRet, <br>    EXCEPINFO FAR* pexcepinfo, <br>    UINT FAR* pnArgErr,  <br>    LPOLESTR pszName, <br>    LPCTSTR pszFmt,  <br>    ...) <br>{ <br>    va_list argList; <br>    va_start(argList, pszFmt);   <br>    DISPID dispid; <br>    HRESULT hr; <br>    VARIANTARG* pvarg = NULL; <br>   <br>    if (pdisp == NULL) <br>        return E_INVALIDARG; <br>     <br>    // Get DISPID of property/method <br>    hr = pdisp-&gt;GetIDsOfNames(IID_NULL, &amp;pszName, 1, LOCALE_USER_DEFAULT, &amp;dispid); <br>    if(FAILED(hr)) <br>        return hr; <br>                <br>    DISPPARAMS dispparams; <br>    _fmemset(&amp;dispparams, 0, sizeof dispparams); <br> <br>    // determine number of arguments <br>    if (pszFmt != NULL) <br>        CountArgsInFormat(pszFmt, &amp;dispparams.cArgs); <br>     <br>    // Property puts have a named argument that represents the value that the property is <br>    // being assigned. <br>    DISPID dispidNamed = DISPID_PROPERTYPUT; <br>    if (wFlags &amp; DISPATCH_PROPERTYPUT) <br>    { <br>        if (dispparams.cArgs == 0) <br>            return E_INVALIDARG; <br>        dispparams.cNamedArgs = 1; <br>        dispparams.rgdispidNamedArgs = &amp;dispidNamed; <br>    } <br> <br>    if (dispparams.cArgs != 0) <br>    { <br>        // allocate memory for all VARIANTARG parameters <br>        pvarg = new VARIANTARG[dispparams.cArgs]; <br>        if(pvarg == NULL) <br>            return E_OUTOFMEMORY;    <br>        dispparams.rgvarg = pvarg; <br>        _fmemset(pvarg, 0, sizeof(VARIANTARG) * dispparams.cArgs); <br> <br>        // get ready to walk vararg list <br>        LPCTSTR psz = pszFmt; <br>        pvarg += dispparams.cArgs - 1;   // params go in opposite order <br>         <br>        while (psz = GetNextVarType(psz, &amp;pvarg-&gt;vt)) <br>        { <br>            if (pvarg &lt; dispparams.rgvarg) <br>            { <br>                hr = E_INVALIDARG; <br>                goto cleanup;   <br>            } <br>            switch (pvarg-&gt;vt) <br>            { <br>            case VT_I2: <br>                V_I2(pvarg) = va_arg(argList, short); <br>                break; <br>            case VT_I4: <br>                V_I4(pvarg) = va_arg(argList, long); <br>                break; <br>            case VT_R4: <br>                V_R4(pvarg) = va_arg(argList, float); <br>                break;  <br>            case VT_DATE: <br>            case VT_R8: <br>                V_R8(pvarg) = va_arg(argList, double); <br>                break; <br>            case VT_CY: <br>                V_CY(pvarg) = va_arg(argList, CY); <br>                break; <br>            case VT_BSTR: <br>                V_BSTR(pvarg) = SysAllocString(va_arg(argList, OLECHAR FAR*)); <br>                if (pvarg-&gt;bstrVal == NULL)  <br>                { <br>                    hr = E_OUTOFMEMORY;   <br>                    pvarg-&gt;vt = VT_EMPTY; <br>                    goto cleanup;   <br>                } <br>                break; <br>            case VT_DISPATCH: <br>                V_DISPATCH(pvarg) = va_arg(argList, LPDISPATCH); <br>                break; <br>            case VT_ERROR: <br>                V_ERROR(pvarg) = va_arg(argList, SCODE); <br>                break; <br>            case VT_BOOL: <br>                V_BOOL(pvarg) = va_arg(argList, BOOL) ? -1 : 0; <br>                break; <br>            case VT_VARIANT: <br>                *pvarg = va_arg(argList, VARIANTARG);  <br>                break; <br>            case VT_UNKNOWN: <br>                V_UNKNOWN(pvarg) = va_arg(argList, LPUNKNOWN); <br>                break; <br> <br>            case VT_I2|VT_BYREF: <br>                V_I2REF(pvarg) = va_arg(argList, short FAR*); <br>                break; <br>            case VT_I4|VT_BYREF: <br>                V_I4REF(pvarg) = va_arg(argList, long FAR*); <br>                break; <br>            case VT_R4|VT_BYREF: <br>                V_R4REF(pvarg) = va_arg(argList, float FAR*); <br>                break; <br>            case VT_R8|VT_BYREF: <br>                V_R8REF(pvarg) = va_arg(argList, double FAR*); <br>                break; <br>            case VT_DATE|VT_BYREF: <br>                V_DATEREF(pvarg) = va_arg(argList, DATE FAR*); <br>                break; <br>            case VT_CY|VT_BYREF: <br>                V_CYREF(pvarg) = va_arg(argList, CY FAR*); <br>                break; <br>            case VT_BSTR|VT_BYREF: <br>                V_BSTRREF(pvarg) = va_arg(argList, BSTR FAR*); <br>                break; <br>            case VT_DISPATCH|VT_BYREF: <br>                V_DISPATCHREF(pvarg) = va_arg(argList, LPDISPATCH FAR*); <br>                break; <br>            case VT_ERROR|VT_BYREF: <br>                V_ERRORREF(pvarg) = va_arg(argList, SCODE FAR*); <br>                break; <br>            case VT_BOOL|VT_BYREF:  <br>                { <br>                    BOOL FAR* pbool = va_arg(argList, BOOL FAR*); <br>                    *pbool = 0; <br>                    V_BOOLREF(pvarg) = (VARIANT_BOOL FAR*)pbool; <br>                }  <br>                break;               <br>            case VT_VARIANT|VT_BYREF:  <br>                V_VARIANTREF(pvarg) = va_arg(argList, VARIANTARG FAR*); <br>                break; <br>            case VT_UNKNOWN|VT_BYREF: <br>                V_UNKNOWNREF(pvarg) = va_arg(argList, LPUNKNOWN FAR*); <br>                break; <br> <br>            default: <br>                { <br>                    hr = E_INVALIDARG; <br>                    goto cleanup;   <br>                } <br>                break; <br>            } <br> <br>            --pvarg; // get ready to fill next argument <br>        } //while <br>    } //if <br>     <br>    // Initialize return variant, in case caller forgot. Caller can pass NULL if return <br>    // value is not expected. <br>    if (pvRet) <br>        VariantInit(pvRet);  <br>    // make the call  <br>    hr = pdisp-&gt;Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, wFlags, <br>        &amp;dispparams, pvRet, pexcepinfo, pnArgErr); <br> <br>cleanup: <br>    // cleanup any arguments that need cleanup <br>    if (dispparams.cArgs != 0) <br>    { <br>        VARIANTARG FAR* pvarg = dispparams.rgvarg; <br>        UINT cArgs = dispparams.cArgs;    <br>         <br>        while (cArgs--) <br>        { <br>            switch (pvarg-&gt;vt) <br>            { <br>            case VT_BSTR: <br>                VariantClear(pvarg); <br>                break; <br>            } <br>            ++pvarg; <br>        } <br>    } <br>    delete dispparams.rgvarg; <br>    va_end(argList); <br>    return hr;    <br>}    <br> <br>HRESULT CountArgsInFormat(LPCTSTR pszFmt, UINT FAR *pn) <br>{ <br>    *pn = 0; <br> <br>    if(pszFmt == NULL) <br>      return NOERROR; <br>     <br>    while (*pszFmt)   <br>    { <br>       if (*pszFmt == '&amp;') <br>           pszFmt++; <br> <br>       switch(*pszFmt) <br>       { <br>           case 'b': <br>           case 'i':  <br>           case 'I': <br>           case 'r':  <br>           case 'R': <br>           case 'c': <br>           case 's': <br>           case 'e': <br>           case 'd': <br>           case 'v': <br>           case 'D': <br>           case 'U': <br>               ++*pn;  <br>               pszFmt++; <br>               break; <br>           case '\0':   <br>           default: <br>               return E_INVALIDARG;    <br>        } <br>    } <br>    return NOERROR; <br>} <br> <br> <br>LPCTSTR GetNextVarType(LPCTSTR pszFmt, VARTYPE FAR* pvt) <br>{    <br>    *pvt = 0; <br>    if (*pszFmt == '&amp;')  <br>    { <br>         *pvt = VT_BYREF;  <br>         pszFmt++;     <br>         if (!*pszFmt) <br>             return NULL;     <br>    }  <br>    switch(*pszFmt) <br>    { <br>        case 'b': <br>            *pvt |= VT_BOOL; <br>            break; <br>        case 'i':  <br>            *pvt |= VT_I2; <br>            break; <br>        case 'I':  <br>            *pvt |= VT_I4; <br>            break; <br>        case 'r':  <br>            *pvt |= VT_R4; <br>            break; <br>        case 'R':  <br>            *pvt |= VT_R8; <br>            break; <br>        case 'c': <br>            *pvt |= VT_CY; <br>            break; <br>        case 's':  <br>            *pvt |= VT_BSTR; <br>            break; <br>        case 'e':  <br>            *pvt |= VT_ERROR; <br>            break; <br>        case 'd':  <br>            *pvt |= VT_DATE;  <br>            break; <br>        case 'v':  <br>            *pvt |= VT_VARIANT; <br>            break; <br>        case 'U':  <br>            *pvt |= VT_UNKNOWN;  <br>            break; <br>        case 'D':  <br>            *pvt |= VT_DISPATCH; <br>            break;   <br>        case '\0': <br>             return NULL;     // End of Format string <br>        default: <br>            return NULL; <br>    }  <br>    return ++pszFmt;   <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
