<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BROWSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1361"></a>BROWSE.CPP</h2>
<pre><code>/************************************************************************* <br>** <br>**  This is a part of the Microsoft Source Code Samples. <br>** <br>**  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>** <br>**  This source code is only intended as a supplement to Microsoft Development <br>**  Tools and/or WinHelp documentation.  See these sources for detailed <br>**  information regarding the Microsoft samples programs. <br>** <br>**  Type Library Browser <br>** <br>**  browseex.cpp <br>** <br>**  Written by Microsoft Product Support Services, Windows Developer Support <br>** <br>*************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include &lt;windowsx.h&gt; <br>#ifdef WIN16    <br>  #include &lt;ole2.h&gt; <br>  #include &lt;compobj.h&gt;     <br>  #include &lt;dispatch.h&gt;  <br>  #include &lt;variant.h&gt; <br>  #include &lt;olenls.h&gt; <br>  #include &lt;commdlg.h&gt;   <br>#endif   <br>#include "resource.h" <br>#include "browse.h"  <br>#include "invhelp.h"          <br> <br>CBrowseApp BrowseApp;         // Application <br> <br>int APIENTRY WinMain (HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lpCmdLine, int nCmdShow) <br>{ <br>   WNDCLASS wc;        <br>   HRESULT hr; <br> <br>#ifdef WIN16 <br>   //  It is recommended that all 16 bit OLE applications set <br>   //  their message queue size to 96. This improves the capacity <br>   //  and performance of OLE's LRPC mechanism. <br>   int cMsg = 96;                  // Recommend msg queue size for OLE <br>   while (cMsg &amp;&amp; !SetMessageQueue(cMsg))  // take largest size we can get. <br>       cMsg -= 8; <br>   if (!cMsg) <br>       return -1;  // ERROR: we got no message queue        <br>#endif   <br>    <br>   // Register class for the dialog that is the main window. <br>   wc.style = 0; <br>   wc.lpfnWndProc = DefDlgProc; <br>   wc.cbClsExtra = 0; <br>   wc.cbWndExtra = DLGWINDOWEXTRA; <br>   wc.hInstance = hinst; <br>   wc.hIcon = LoadIcon(hinst, MAKEINTRESOURCE(ID_ICON)); <br>   wc.hCursor = LoadCursor(NULL, IDC_ARROW); <br>   wc.hbrBackground = HBRUSH(COLOR_WINDOW + 1); <br>   wc.lpszMenuName = NULL; <br>   wc.lpszClassName = TEXT("DlgClass"); <br>   RegisterClass(&amp;wc); <br> <br>   hr = OleInitialize(NULL); <br>   if FAILED(hr) <br>   { <br>       MessageBox(NULL, TEXT("Could not Intialize OLE"), TEXT("Error"), MB_ICONEXCLAMATION|MB_OK); <br>       return 0; <br>   } <br>   DialogBox(hinst, MAKEINTRESOURCE(IDD_MAINDIALOG), NULL, (DLGPROC)MainDialogFunc);  <br>   OleUninitialize(); <br>    <br>   return 0; <br>} <br> <br> <br>BOOL CALLBACK MainDialogFunc(HWND hwndDlg, UINT msg, WPARAM wParam, LPARAM lParam) <br>{   <br>   HRESULT hr; <br>    <br>   switch (msg) <br>   {   <br>      case WM_INITDIALOG: <br>          BrowseApp.Init(hwndDlg); <br>          return FALSE; <br>                       <br>      case WM_COMMAND: <br>         switch(GET_WM_COMMAND_ID(wParam,lParam)) <br>         {    <br>             case IDM_EXIT: <br>             case IDCANCEL:   <br>                 BrowseApp.Cleanup();                  <br>                 EndDialog(hwndDlg, IDOK); <br>                 CoFreeUnusedLibraries(); <br>                 return TRUE; <br>                  <br>             case IDM_FILEOPEN:    <br>                 hr = BrowseApp.BrowseTypeLibrary(); <br>                 if (FAILED(hr)) <br>                     MessageBox(hwndDlg, TEXT("Failed to browse type library"), TEXT("Error"), MB_ICONEXCLAMATION|MB_OK);      <br>                 return TRUE; <br>                  <br>             case IDC_TYPEINFOSLIST: <br>                 switch (GET_WM_COMMAND_CMD(wParam, lParam)) <br>                 { <br>                     case LBN_SELCHANGE: <br>                         hr = BrowseApp.ChangeTypeInfosSelection();     <br>                         if (FAILED(hr)) <br>                             MessageBox(hwndDlg, TEXT("Failed to get TypeInfo information"), TEXT("Error"), MB_ICONEXCLAMATION|MB_OK);      <br>                         return TRUE; <br>                 } <br>                 break;   <br>                  <br>             case IDC_ELEMENTSLIST: <br>                 switch (GET_WM_COMMAND_CMD(wParam, lParam)) <br>                 { <br>                     case LBN_SELCHANGE: <br>                         hr = BrowseApp.ChangeElementsSelection();   <br>                         if (FAILED(hr)) <br>                             MessageBox(hwndDlg, TEXT("Failed to get Element information"), TEXT("Error"), MB_ICONEXCLAMATION|MB_OK); <br>                         return TRUE; <br>                 }  <br>                 break;  <br>                  <br>             case IDC_PARAMETERSLIST: <br>                 switch (GET_WM_COMMAND_CMD(wParam, lParam)) <br>                 { <br>                     case LBN_SELCHANGE: <br>                         hr = BrowseApp.ChangeParametersSelection(); <br>                         if (FAILED(hr)) <br>                             MessageBox(hwndDlg, TEXT("Failed to get Parameter information"), TEXT("Error"), MB_ICONEXCLAMATION|MB_OK); <br>                         return TRUE; <br>                 }  <br>                 break; <br>                  <br>             case IDC_ELEM_OPEN_HELPFILE: <br>                 BrowseApp.OpenElementHelpFile();    <br>                 return TRUE;     <br>                                                                                                <br>         } <br>         break; <br>   } <br>   return FALSE; <br>}   <br> <br>/* <br> * CBrowseApp::BrowseTypeLibrary <br> * <br> * Purpose: <br> *  Prompts user for type library. Fills the TypeInfo list with the TypeInfos of <br> *  the type library. <br> * <br> */ <br>HRESULT CBrowseApp::BrowseTypeLibrary() <br>{    <br>    OPENFILENAME   ofn; <br>    TCHAR szFileName[128];  <br>    BOOL bRes; <br>    VARIANT vRet;   <br>    HRESULT hr; <br>    HCURSOR hcursorOld; <br>    LPDISPATCH pdispBrowseHelper = NULL;   <br>    LPDISPATCH pdispTypeLibrary = NULL; <br>    LPDISPATCH pdispTypeInfos = NULL;       <br>    TCHAR szTemp[100]; <br>     <br>    // Prompt user for type library <br>    szFileName[0] = '\0'; <br>    _fmemset(&amp;ofn, 0, sizeof(ofn)); <br>    ofn.lStructSize = sizeof(ofn); <br>    ofn.hwndOwner = m_hwndMain; <br>    ofn.lpstrFile = szFileName; <br>    ofn.nMaxFile  = sizeof(szFileName); <br>    ofn.hInstance = m_hinst; <br>    ofn.lpstrFilter  = TEXT("Type Libraries *.tlb,*.olb\0*.tlb;*.olb\0All Files *.*\0*.*\0\0"); <br>    ofn.nFilterIndex = 1;  <br>    ofn.Flags= OFN_FILEMUSTEXIST;     <br>    bRes = GetOpenFileName(&amp;ofn); <br>    if (!bRes) <br>        return S_FALSE;   <br>         <br>    // Empty lists and clear fields. <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_TYPEINFOSLIST));  <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_ELEMENTSLIST)); <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_PARAMETERSLIST));    <br>    ClearTypeLibStaticFields(); <br>    ClearTypeInfoStaticFields(); <br>    ClearElementStaticFields(); <br>    ClearParamStaticFields();  <br>    EnableWindow(GetDlgItem(m_hwndMain, IDC_ELEM_OPEN_HELPFILE), FALSE);  <br>     <br>    hcursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>    // Create BrowseHelper object <br>    hr = CreateObject(OLESTR("BrowseHelper.Browser"), &amp;pdispBrowseHelper);    <br>    if (FAILED(hr))   <br>    { <br>        MessageBox(m_hwndMain,  <br> TEXT("Failed to create BrowseHelper object. Build and register the BROWSEH sample"),  <br> TEXT("Error"), MB_ICONEXCLAMATION|MB_OK); <br>        goto error; <br>    } <br>                 <br>    // Invoke IBrowseHelper.BrowseTypeLibrary(szFileName). Returns ITypeLibrary. <br>    hr = Invoke(pdispBrowseHelper, DISPATCH_METHOD, &amp;vRet, NULL, NULL, <br>                      OLESTR("BrowseTypeLibrary"), TEXT("s"), (LPOLESTR)TO_OLE_STRING(szFileName));  <br>    if (FAILED(hr)) <br>        goto error;   <br>    pdispTypeLibrary = V_DISPATCH(&amp;vRet);   <br>     <br>    // Invoke ITypeLibrary.Name. Returns BSTR. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Name"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>if (NULL != V_BSTR(&amp;vRet)) <br>        SetDlgItemText(m_hwndMain, IDC_TYPELIB_NAME, FROM_OLE_STRING(V_BSTR(&amp;vRet))); <br>    VariantClear(&amp;vRet); <br>     <br>    // Invoke ITypeLibrary.HelpFile. Returns BSTR. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("HelpFile"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>if (NULL != V_BSTR(&amp;vRet)) <br>        SetDlgItemText(m_hwndMain, IDC_TYPELIB_HELPFILE, FROM_OLE_STRING(V_BSTR(&amp;vRet))); <br>    if (NULL == V_BSTR(&amp;vRet)) <br>        m_szHelpFile[0] = '\0'; <br>    else lstrcpy(m_szHelpFile, FROM_OLE_STRING(V_BSTR(&amp;vRet)));  <br>    VariantClear(&amp;vRet);  <br>     <br>    // Invoke ITypeLibrary.Documentation. Returns BSTR. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Documentation"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>if (V_BSTR(&amp;vRet) != NULL) //NULL is a valid value for a BSTR <br>        SetDlgItemText(m_hwndMain, IDC_TYPELIB_DOC, FROM_OLE_STRING(V_BSTR(&amp;vRet))); <br>    VariantClear(&amp;vRet); <br>     <br>    // Invoke ITypeLibrary.LocaleID. Returns VT_I4. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("LocaleID"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;    <br>    wsprintf(szTemp, TEXT("0x%lx"), V_I4(&amp;vRet));  <br>    SetDlgItemText(m_hwndMain, IDC_TYPELIB_LCID, szTemp); <br>     <br>    // Invoke ITypeLibrary.MajorVersion. Returns VT_I2. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("MajorVersion"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;    <br>    wsprintf(szTemp, TEXT("%d"), V_I2(&amp;vRet));     <br>    // Invoke ITypeLibrary.MinorVersion. Returns VT_I2. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("MinorVersion"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;    <br>    wsprintf(szTemp, TEXT("%s.%d"), (LPSTR)szTemp, V_I2(&amp;vRet));  <br>    SetDlgItemText(m_hwndMain, IDC_TYPELIB_VERSION, szTemp); <br>     <br>    // Invoke ITypeLibrary.TypeInfos. Returns ICollection of ITypeInfo. <br>    hr = Invoke(pdispTypeLibrary, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("TypeInfos"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>    pdispTypeInfos = V_DISPATCH(&amp;vRet); <br>     <br>    // Load TypeInfo list with the names of the type infos. <br>    hr = LoadList(pdispTypeInfos, IDC_TYPEINFOSLIST);  <br>    if (FAILED(hr)) <br>        goto error;   <br>     <br>    pdispBrowseHelper-&gt;Release();  <br>    pdispTypeLibrary-&gt;Release(); <br>    pdispTypeInfos-&gt;Release(); <br>    SetCursor(hcursorOld); <br>    return NOERROR;      <br> <br>error:      <br>    if (pdispBrowseHelper) pdispBrowseHelper-&gt;Release();   <br>    if (pdispTypeLibrary) pdispTypeLibrary-&gt;Release();   <br>    if (pdispTypeInfos) pdispTypeLibrary-&gt;Release();  <br>    VariantClear(&amp;vRet);  <br>    SetCursor(hcursorOld); <br>    return hr; <br>}   <br> <br>/* <br> * CBrowseApp::ChangeTypeInfosSelection <br> * <br> * Purpose: <br> *  Called when user changes selection in TypeInfos list box. Information  <br> *  about the the selected TypeInfo is dispayed. Elements of the TypeInfo <br> *  are placed in the Elements list box. <br> * <br> */ <br>HRESULT CBrowseApp::ChangeTypeInfosSelection() <br>{    <br>    int nCurSel; <br>    VARIANT vRet;    <br>    HRESULT hr;    <br>    HCURSOR hcursorOld; <br>    LPDISPATCH pdispTypeInfo;   <br>    TYPEKIND typekind;    <br>    TCHAR szTemp[100];  <br>    LPDISPATCH pdispElements = NULL; <br>    LPDISPATCH pdispMembers = NULL; <br>    LPDISPATCH pdispFunctions = NULL; <br>    LPDISPATCH pdispProperties = NULL; <br>    LPDISPATCH pdispMethods = NULL; <br>    LPDISPATCH pdispInterfaces = NULL; <br>    LPDISPATCH pdispTypeDesc = NULL; <br>      <br>    // Get current selection in TypeInfos list. <br>    nCurSel = (int)SendDlgItemMessage(m_hwndMain, IDC_TYPEINFOSLIST, LB_GETCURSEL, 0, 0L); <br>    if (nCurSel == LB_ERR)  <br>        return NOERROR;  <br>    // Get IDispatch* of selected TypeInfo. <br>    pdispTypeInfo = (LPDISPATCH) SendDlgItemMessage(m_hwndMain, IDC_TYPEINFOSLIST, LB_GETITEMDATA, <br>                (WPARAM)nCurSel, 0L); <br>     <br>    // Empty Elements &amp; Parameters lists. <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_ELEMENTSLIST)); <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_PARAMETERSLIST));      <br>    ClearElementStaticFields(); <br>    ClearParamStaticFields(); <br> <br>    ClearTypeInfoStaticFields(); <br>     <br>    hcursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT)); <br>    // Invoke ITypeInformation.HelpContext. Returns VT_I4. <br>    hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("HelpContext"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;       <br>    wsprintf(szTemp, TEXT("%ld"), V_I4(&amp;vRet));  <br>    SetDlgItemText(m_hwndMain, IDC_TYPEINFO_HELPCTX, szTemp); <br>     <br>    // Invoke ITypeInformation.Documentation. Returns BSTR. <br>    hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Documentation"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>if (V_BSTR(&amp;vRet) != NULL) //NULL is a valid value for a BSTR <br>        SetDlgItemText(m_hwndMain, IDC_TYPEINFO_DOC, FROM_OLE_STRING(V_BSTR(&amp;vRet))); <br>    VariantClear(&amp;vRet); <br>     <br>    // Invoke ITypeInformation.TypeInfoKind. Returns TYPEKIND. <br>    hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("TypeInfoKind"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;  <br>    typekind = (TYPEKIND)V_I2(&amp;vRet);   <br>     <br>    switch (typekind) <br>    { <br>        case TKIND_ENUM: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_ENUM")); <br>            // Invoke IEnum.Elements. Returns ICollection of IConstant. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Elements"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispElements = V_DISPATCH(&amp;vRet);    <br>            // Put the Enumerator constants in the Elements list.  <br>            hr = LoadList(pdispElements, IDC_ELEMENTSLIST);   <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispElements-&gt;Release();      <br>            break;    <br>         <br>        case TKIND_RECORD:         <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_RECORD")); <br>            // Invoke IStruct.Members. Returns ICollection of IProperty. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Members"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMembers = V_DISPATCH(&amp;vRet);     <br>            // Put the Structure memebers in the Elements list. <br>            hr = LoadList(pdispMembers, IDC_ELEMENTSLIST);    <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMembers-&gt;Release();  <br>            break;  <br>             <br>        case TKIND_MODULE: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_MODULE")); <br>            // Invoke IModule.Functions. Returns ICollection of IFunction. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Functions"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispFunctions = V_DISPATCH(&amp;vRet);  <br>            // Put the Module functions in the Elements list. <br>            hr = LoadList(pdispFunctions, IDC_ELEMENTSLIST);          <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispFunctions-&gt;Release();  <br>            break;    <br>             <br>        case TKIND_INTERFACE: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_INTERFACE")); <br>            // Invoke IInterface.Functions. Returns ICollection of IFunction. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Functions"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispFunctions = V_DISPATCH(&amp;vRet);  <br>            // Put the Interface functions in the Elements list. <br>            hr = LoadList(pdispFunctions, IDC_ELEMENTSLIST); <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispFunctions-&gt;Release();  <br>            break;   <br>             <br>        case TKIND_DISPATCH: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_DISPATCH")); <br>            // Invoke Dispinterface.Properties. Returns ICollection of IProperty. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Properties"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispProperties = V_DISPATCH(&amp;vRet);  <br>            // Invoke IDispinterface.Methods. Returns ICollection of IFunction. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Methods"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMethods = V_DISPATCH(&amp;vRet); <br>            // Put the Dispinterface properties and methods in the Elements list.    <br>            hr = LoadList(pdispProperties, IDC_ELEMENTSLIST);   <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispProperties-&gt;Release();   <br>            hr = LoadList(pdispMethods, IDC_ELEMENTSLIST);  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMethods-&gt;Release();  <br>            break;  <br>             <br>        case TKIND_COCLASS: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_COCLASS")); <br>            // Invoke ICoClass.Interfaces. Returns ICollection of IInterface &amp; IDispinterface. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Interfaces"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispInterfaces = V_DISPATCH(&amp;vRet);   <br>            // Put the CoClass interfaces and dispinterfaces in the Elements list. <br>            hr = LoadList(pdispInterfaces, IDC_ELEMENTSLIST);  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispInterfaces-&gt;Release();   <br>            break;         <br>             <br>        case TKIND_ALIAS:            <br>            // An alias does not have elements. Display the base type. <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_ALIAS")); <br>            // Invoke IAlias.BaseType. Returns ITypeDesc. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("BaseType"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispTypeDesc = V_DISPATCH(&amp;vRet); <br>            szTemp[0] = '\0'; // Must initialize to empty string before calling TypeToString. <br>            hr = TypeToString(pdispTypeDesc, szTemp); <br>            if (FAILED(hr)) <br>                goto error;  <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_ALIASTYPE, szTemp); <br>            pdispTypeDesc-&gt;Release();   <br>            break; <br>             <br>        case TKIND_UNION: <br>            SetDlgItemText(m_hwndMain, IDC_TYPEINFO_TYPE, TEXT("TKIND_UNION")); <br>            // Invoke IUnion.Members. Returns ICollection of IProperty. <br>            hr = Invoke(pdispTypeInfo, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Members"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMembers = V_DISPATCH(&amp;vRet);      <br>            // Put the Union members in the Elements list. <br>            hr = LoadList(pdispMembers, IDC_ELEMENTSLIST);    <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispMembers-&gt;Release();   <br>            break;    <br>    } <br>    SetCursor(hcursorOld);    <br>    return NOERROR; <br>error:  <br>    if (pdispElements) pdispElements-&gt;Release();  <br>    if (pdispMembers) pdispMembers-&gt;Release();  <br>    if (pdispFunctions) pdispFunctions-&gt;Release();  <br>    if (pdispProperties) pdispProperties-&gt;Release();  <br>    if (pdispMethods) pdispElements-&gt;Release();  <br>    if (pdispInterfaces) pdispInterfaces-&gt;Release();  <br>    if (pdispTypeDesc) pdispTypeDesc-&gt;Release(); <br>    VariantClear(&amp;vRet);  <br>    SetCursor(hcursorOld); <br>    return hr; <br>} <br> <br>/* <br> * CBrowseApp::ChangeElementsSelection <br> * <br> * Purpose: <br> *  Called when user changes selection in Elements list box. Information  <br> *  about the the selected Element is dispayed. If the element is a function, <br> *  the parameters are placed in the the Parameters list box. <br> * <br> */ <br>HRESULT CBrowseApp::ChangeElementsSelection() <br>{  <br>    int nCurSel; <br>    VARIANT vRet;    <br>    HRESULT hr;      <br>    int nKind;  <br>    TYPEKIND typekind; <br>    LPDISPATCH pdispElement;    <br>    LPDISPATCH pdispParameters = NULL; <br>    LPDISPATCH pdispTypeDesc = NULL;  <br>    TCHAR szTemp[100]; <br>     <br>    // Disable the help file button. <br>    EnableWindow(GetDlgItem(m_hwndMain, IDC_ELEM_OPEN_HELPFILE), FALSE);  <br>     <br>    // Get current selection in Elements list. <br>    nCurSel = (int)SendDlgItemMessage(m_hwndMain, IDC_ELEMENTSLIST, LB_GETCURSEL, 0, 0L); <br>    if (nCurSel == LB_ERR)  <br>        return NOERROR;  <br>    // Get IDispatch* of selected Element. <br>    pdispElement = (LPDISPATCH) SendDlgItemMessage(m_hwndMain, IDC_ELEMENTSLIST, LB_GETITEMDATA, <br>                (WPARAM)nCurSel, 0L); <br>     <br>    // Empty Parameters lists. <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_PARAMETERSLIST));   <br>    ClearParamStaticFields(); <br> <br>    ClearElementStaticFields(); <br>     <br>    // Invoke IFunction/IConstant/IProperty/IInterface/IDispinterface.HelpContext. Returns VT_I4. <br>    hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("HelpContext"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;       <br>    wsprintf(szTemp, TEXT("%ld"), V_I4(&amp;vRet));  <br>    SetDlgItemText(m_hwndMain, IDC_ELEM_HELPCTX, szTemp); <br>    m_lElemHelpCtx = V_I4(&amp;vRet);  <br>     <br>    // Invoke IFunction/IConstant/IProperty/IInterface/IDispinterface.Documentation. Returns BSTR. <br>    hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Documentation"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;  <br>if (V_BSTR(&amp;vRet) != NULL) //NULL is a valid value for a BSTR <br>        SetDlgItemText(m_hwndMain, IDC_ELEM_DOC, FROM_OLE_STRING(V_BSTR(&amp;vRet))); <br>    VariantClear(&amp;vRet); <br>     <br>    // Invoke IFunction/IConstant/IProperty.MemberID. Returns VT_I4. <br>    hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("MemberID"), TEXT(""));  <br>    if (FAILED(hr)) <br>    { <br>        // This maybe a interface/dispinterface element of a coclass    <br>        hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("TypeInfoKind"), TEXT(""));  <br>        if (FAILED(hr)) <br>            goto error;  <br>        typekind = (TYPEKIND)V_I2(&amp;vRet);   <br>        if (typekind == TKIND_INTERFACE) <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_TYPE, TEXT("TKIND_INTERFACE")); <br>        else if (typekind == TKIND_DISPATCH) <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_TYPE, TEXT("TKIND_DISPATCH"));   <br>        else SetDlgItemText(m_hwndMain, IDC_ELEM_TYPE, TEXT("Unknown element"));    <br>        return NOERROR; <br>    } <br>    wsprintf(szTemp, TEXT("0x%lx"), V_I4(&amp;vRet)); <br>    SetDlgItemText(m_hwndMain, IDC_ELEM_MEMID, szTemp); <br>     <br>    // Invoke IFunction/IConstant/IProperty.Kind property. Returns OBJKIND. <br>    hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Kind"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;   <br>    nKind = V_I2(&amp;vRet);   <br>     <br>    switch (nKind) <br>    { <br>        case TYPE_FUNCTION: //Function <br>            // Invoke IFunction.Parameters. Returns ICollection of IParameter.. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                        OLESTR("Parameters"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;  <br>            pdispParameters = V_DISPATCH(&amp;vRet);  <br>            hr = LoadList(pdispParameters, IDC_PARAMETERSLIST);    <br>            if FAILED(hr) <br>                goto error; <br>            pdispParameters-&gt;Release(); pdispParameters = NULL; <br>             <br>            // Invoke IFunction.CallConvention. Returns CALLCONV. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("CallConvention"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;    <br>            CallConvToString(V_I2(&amp;vRet), szTemp); <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_CALLCONV, szTemp);  <br>             <br>            // Invoke IFunction.FuncKind. Returns FUNCKIND. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("FuncKind"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;    <br>            FuncKindToString(V_I2(&amp;vRet), szTemp); <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_FUNCKIND, szTemp); <br>             <br>            // Invoke IFunction.InvocationKind. Returns INVOKEKIND. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("InvocationKind"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;    <br>            InvokeKindToString(V_I2(&amp;vRet), szTemp); <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_INVOKEKIND, szTemp);    <br>             <br>            // Invoke IFunction.ReturnType. Returns ITypeDesc. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("ReturnType"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;            <br>            break;     <br>             <br>        case TYPE_CONSTANT: <br>            // Invoke IConstant.Value. Returns VARIANT. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Value"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;    <br>            VariantToString(vRet, szTemp); <br>            SetDlgItemText(m_hwndMain, IDC_ELEM_CONST_VALUE, szTemp); <br>            // Fall through to default.      <br>             <br>        default:  <br>            // Invoke IConstant/IProperty.Type. Returns ITypeDesc. <br>            hr = Invoke(pdispElement, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Type"), TEXT(""));  <br>            if (FAILED(hr)) <br>                goto error;   <br>            break; <br>    }    <br>    // Get string that describes type and display it. <br>    pdispTypeDesc = V_DISPATCH(&amp;vRet);   <br>    szTemp[0] = '\0'; // Must initialize to empty string before calling TypeToString. <br>    hr = TypeToString(pdispTypeDesc, szTemp); <br>    if (FAILED(hr)) <br>        goto error; <br>    SetDlgItemText(m_hwndMain, IDC_ELEM_TYPE, szTemp); <br>    pdispTypeDesc-&gt;Release();  <br>     <br>    // Enable the helpfile button if a helpfile and help context is specified. <br>    if (m_lElemHelpCtx &amp;&amp; m_szHelpFile[0]) <br>        EnableWindow(GetDlgItem(m_hwndMain, IDC_ELEM_OPEN_HELPFILE), TRUE); <br>    return NOERROR; <br>error:  <br>    if (pdispParameters) pdispParameters-&gt;Release();   <br>    VariantClear(&amp;vRet); <br>    return hr;  <br>} <br> <br>/* <br> * CBrowseApp::ChangeParametersSelection <br> * <br> * Purpose: <br> *  Called when user changes selection in Parameters list box. Information  <br> *  about the the selected Parameter is dispayed. <br> * <br> */ <br>HRESULT CBrowseApp::ChangeParametersSelection() <br>{    <br>    int nCurSel; <br>    VARIANT vRet;    <br>    HRESULT hr; <br>    LPDISPATCH pdispParameter; <br>    LPDISPATCH pdispTypeDesc = NULL;  <br>    TCHAR szTemp[100]; <br>      <br>    // Get current selection in Parameters list. <br>    nCurSel = (int)SendDlgItemMessage(m_hwndMain, IDC_PARAMETERSLIST, LB_GETCURSEL, 0, 0L); <br>    if (nCurSel == LB_ERR)  <br>        return NOERROR;  <br>    // Get IDispatch* of selected Parameter. <br>    pdispParameter = (LPDISPATCH) SendDlgItemMessage(m_hwndMain, IDC_PARAMETERSLIST, LB_GETITEMDATA, <br>                (WPARAM)nCurSel, 0L);   <br>     <br>    ClearParamStaticFields(); <br>     <br>    // Invoke IParameter.IDLFlags. Returns VT_I2. <br>    hr = Invoke(pdispParameter, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("IDLFlags"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;  <br>    IDLFlagsToString(V_I2(&amp;vRet), szTemp);  <br>    SetDlgItemText(m_hwndMain, IDC_PARAM_INOUT, szTemp); <br>                     <br>    // Invoke IParameter.Type. Returns ITypeDesc. <br>    hr = Invoke(pdispParameter, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Type"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error; <br>     <br>   // Get string that describes type and display it. <br>    pdispTypeDesc = V_DISPATCH(&amp;vRet);   <br>    szTemp[0] = '\0'; // Must initialize to empty string before calling TypeToString. <br>    hr = TypeToString(pdispTypeDesc, szTemp);      <br>    if (FAILED(hr)) <br>        goto error; <br>    SetDlgItemText(m_hwndMain, IDC_PARAM_TYPE, szTemp); <br>    pdispTypeDesc-&gt;Release(); <br>    return NOERROR; <br>error:  <br>    if (pdispTypeDesc) pdispTypeDesc-&gt;Release(); <br>    VariantClear(&amp;vRet); <br>    return hr;  <br>}  <br> <br>/* <br> * CBrowseApp::OpenElementHelpFile <br> * <br> * Purpose: <br> *  Opens the helpfile for the element. <br> * <br> */ <br>void CBrowseApp::OpenElementHelpFile() <br>{ <br>    BOOL b; <br>     <br>    b = WinHelp(m_hwndMain, m_szHelpFile, HELP_CONTEXT, m_lElemHelpCtx); <br>    if (!b) <br>        MessageBox(m_hwndMain, TEXT("Failed to open help file"), TEXT("Error"),  <br>            MB_ICONEXCLAMATION|MB_OK);       <br>} <br> <br>void CBrowseApp::EmptyList(HWND hwndList) <br>{ <br>    int nItems, i; <br>    LPDISPATCH pdispItem; <br> <br>    nItems = (int)SendMessage(hwndList, LB_GETCOUNT, 0, 0L); <br>    for (i=0; i&lt;nItems; i++) <br>    { <br>        pdispItem = (LPDISPATCH)SendMessage(hwndList, LB_GETITEMDATA, (WPARAM)i, 0L);  <br>        if (pdispItem) <br>            pdispItem-&gt;Release(); <br>    } <br>    SendMessage(hwndList, LB_RESETCONTENT, 0, 0L); <br>}  <br> <br>/* <br> * CBrowseApp::LoadList   <br> * <br> * Parameters: <br> *  pdispItems IDispatch* of collection of items to be put into the list. <br> *  nListID    Identifies the list to be filled. <br> * <br> * Purpose: <br> *  Loads the list with the items in the collection. </code></pre>
<p>
</p>
<pre><code>* <br> */ <br>HRESULT CBrowseApp::LoadList(LPDISPATCH pdispItems, int nListID) <br>{    <br>    VARIANT vRet, v;   <br>    HRESULT hr;     <br>    LPUNKNOWN punkEnum; <br>    IEnumVARIANT FAR* penum = NULL;   <br>    LPDISPATCH pdispItem = NULL;    <br>    int nIndex; <br>     <br>    // Get _NewEnum property. Returns enumerator's IUnknown. <br>    hr = Invoke(pdispItems, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                        OLESTR("_NewEnum"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;          <br>    punkEnum = V_UNKNOWN(&amp;vRet); <br>    hr = punkEnum-&gt;QueryInterface(IID_IEnumVARIANT, (LPVOID FAR*)&amp;penum); <br>    if (FAILED(hr)) <br>        goto error; <br>    punkEnum-&gt;Release(); <br> <br>    VariantInit(&amp;v); <br>    // Enumerate the Items. <br>    while (S_OK == penum-&gt;Next(1, &amp;v, NULL)) <br>    { <br>        pdispItem = V_DISPATCH(&amp;v); <br>        pdispItem-&gt;AddRef(); <br>        VariantClear(&amp;v); <br>         <br>        // Get Name of Item. <br>        hr = Invoke(pdispItem, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL, <br>                    OLESTR("Name"), TEXT(""));  <br>        if (FAILED(hr)) <br>            goto error;              <br>        // Add name to ItemsList. <br>        nIndex = (int)SendDlgItemMessage(m_hwndMain, nListID, LB_ADDSTRING, <br>            0, (LPARAM)(LPTSTR)FROM_OLE_STRING(V_BSTR(&amp;vRet)));  <br>        VariantClear(&amp;vRet);           <br>        // Save IDispatch* of Item in the list. <br>        SendDlgItemMessage(m_hwndMain, nListID, LB_SETITEMDATA, <br>            nIndex, (LPARAM)pdispItem); <br>    } <br>    penum-&gt;Release(); <br>    return NOERROR;      <br> <br>error:    <br>    if (penum) penum-&gt;Release();   <br>    if (pdispItem) pdispItem-&gt;Release(); <br>    return hr; <br>}   <br> <br>void CBrowseApp::Init(HWND hwndMain)  <br>{    <br>    HFONT hfontDlg;    <br>    LOGFONT lfont; <br>    int nID; <br>     <br>    m_hwndMain = hwndMain; <br>    m_hfont = NULL; <br>#ifdef WIN16    <br>    m_hinst = (HINSTANCE)GetWindowWord(hwndMain, GWW_HINSTANCE);  <br>#else <br>    m_hinst = (HINSTANCE)GetWindowLong(hwndMain, GWL_HINSTANCE); <br>#endif      <br>    EnableWindow(GetDlgItem(m_hwndMain, IDC_ELEM_OPEN_HELPFILE), FALSE); <br>     <br>    // Change to the font of the fields to a non-bold font. <br>    hfontDlg = (HFONT)SendMessage(m_hwndMain, WM_GETFONT, NULL, NULL);   <br>    if (!hfontDlg) <br>        return; <br>    GetObject(hfontDlg, sizeof(LOGFONT), (LPVOID)&amp;lfont);             <br>    lfont.lfWeight = FW_NORMAL;     <br>    if (m_hfont = CreateFontIndirect(&amp;lfont))  <br>        for (nID=IDC_TYPELIB_FIRST; nID&lt;=IDC_PARAM_LAST; nID++)  <br>            SendDlgItemMessage(m_hwndMain, nID, WM_SETFONT, (WPARAM)m_hfont, 0L); <br>         <br>}  <br> <br>void CBrowseApp::Cleanup()  <br>{ <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_TYPEINFOSLIST));  <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_ELEMENTSLIST)); <br>    EmptyList(GetDlgItem(m_hwndMain, IDC_PARAMETERSLIST)); <br>    ClearTypeLibStaticFields(); <br>    ClearTypeInfoStaticFields();      <br>    ClearElementStaticFields(); <br>    ClearParamStaticFields(); <br>    if (m_hfont) <br>        DeleteObject(m_hfont);   <br>}  <br> <br>void CBrowseApp::ClearTypeLibStaticFields() <br>{    <br>    int nID; <br>     <br>    for (nID=IDC_TYPELIB_FIRST; nID&lt;=IDC_TYPELIB_LAST; nID++) <br>        SetDlgItemText(m_hwndMain, nID, TEXT("")); <br>} <br>void CBrowseApp::ClearTypeInfoStaticFields() <br>{    <br>    int nID; <br>     <br>    for (nID=IDC_TYPEINFO_FIRST; nID&lt;=IDC_TYPEINFO_LAST; nID++) <br>        SetDlgItemText(m_hwndMain, nID, TEXT("")); <br>}      <br>void CBrowseApp::ClearElementStaticFields() <br>{  <br>    int nID; <br>     <br>    for (nID=IDC_ELEM_FIRST; nID&lt;=IDC_ELEM_LAST; nID++) <br>        SetDlgItemText(m_hwndMain, nID, TEXT("")); <br>} <br>void CBrowseApp::ClearParamStaticFields() <br>{   <br>    int nID; <br>     <br>    for (nID=IDC_PARAM_FIRST; nID&lt;=IDC_PARAM_LAST; nID++) <br>        SetDlgItemText(m_hwndMain, nID, TEXT("")); <br>}  <br> <br>#define CASE_VT(vt)  \ <br>        case vt: \ <br>            lstrcat(pszTypeName, TEXT(#vt)); \ <br>            break; <br>HRESULT CBrowseApp::TypeToString(LPDISPATCH pdispTypeDesc, LPTSTR pszTypeName) <br>{   <br>    VARIANT vRet; <br>    VARTYPE vartype;   <br>    HRESULT hr;    <br>    LPDISPATCH pdispTypeDesc2;  <br>     <br>    // Get Type property   <br>    hr = Invoke(pdispTypeDesc, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Type"), TEXT(""));  <br>    if (FAILED(hr)) <br>        goto error;    <br>    vartype = V_I2(&amp;vRet);  <br>     <br>    if (vartype &amp; 0x2000)  // If SafeArray <br>      lstrcat(pszTypeName, TEXT("SAFEARRAY("));  <br>     <br>    switch (vartype &amp; ~0x7000) <br>    {  <br>    CASE_VT(VT_EMPTY) <br>    CASE_VT(VT_NULL) <br>    CASE_VT(VT_I2) <br>    CASE_VT(VT_I4) <br>    CASE_VT(VT_R4) <br>    CASE_VT(VT_R8) <br>    CASE_VT(VT_CY) <br>    CASE_VT(VT_DATE) <br>    CASE_VT(VT_BSTR) <br>    CASE_VT(VT_DISPATCH) <br>    CASE_VT(VT_ERROR) <br>    CASE_VT(VT_BOOL) <br>    CASE_VT(VT_VARIANT) <br>    CASE_VT(VT_UNKNOWN) <br> <br>    CASE_VT(VT_I1) <br>    CASE_VT(VT_UI1) <br>    CASE_VT(VT_UI2) <br>    CASE_VT(VT_UI4) <br>    CASE_VT(VT_I8) <br>    CASE_VT(VT_UI8) <br>    CASE_VT(VT_INT) <br>    CASE_VT(VT_UINT) <br>    CASE_VT(VT_VOID) <br>    CASE_VT(VT_HRESULT) <br>    CASE_VT(VT_SAFEARRAY)   <br>    CASE_VT(VT_CARRAY) <br>    CASE_VT(VT_LPSTR) <br>    CASE_VT(VT_LPWSTR) <br> <br>    CASE_VT(VT_FILETIME) <br>    CASE_VT(VT_BLOB) <br>    CASE_VT(VT_STREAM) <br>    CASE_VT(VT_STORAGE) <br>    CASE_VT(VT_STREAMED_OBJECT) <br>    CASE_VT(VT_STORED_OBJECT) <br>    CASE_VT(VT_BLOB_OBJECT) <br>    CASE_VT(VT_CF) <br>    CASE_VT(VT_CLSID) <br>    <br>    case VT_PTR:     <br>         // Get ITypeDesc.PointerDesc property. Returns ITypeDesc.   <br>         hr = Invoke(pdispTypeDesc, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("PointerDesc"), TEXT(""));  <br>         if (FAILED(hr)) <br>             goto error;   <br>         pdispTypeDesc2 = V_DISPATCH(&amp;vRet); <br>         TypeToString(pdispTypeDesc2, pszTypeName); <br>         lstrcat(pszTypeName, TEXT(" *")); <br>         pdispTypeDesc2-&gt;Release(); <br>         break; <br> <br>    case VT_USERDEFINED:    <br>         // Get ITypeDesc.UserDefinedDesc property. Returns ITypeInformation  <br>         hr = Invoke(pdispTypeDesc, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("UserDefinedDesc"), TEXT(""));  <br>         if (FAILED(hr)) <br>             goto error;   <br>         pdispTypeDesc2 = V_DISPATCH(&amp;vRet); <br>         // Get ITypeInformation.Name property. Returns BSTR.   <br>         hr = Invoke(pdispTypeDesc2, DISPATCH_PROPERTYGET, &amp;vRet, NULL, NULL,  <br>                OLESTR("Name"), TEXT(""));  <br>         if (FAILED(hr)) <br>             goto error;   <br>         lstrcat(pszTypeName, FROM_OLE_STRING(V_BSTR(&amp;vRet)));  <br>         VariantClear(&amp;vRet); <br>         pdispTypeDesc2-&gt;Release(); <br>         break; <br>    }     <br>     <br>    if (vartype &amp; 0x2000) // If SafeArray <br>        lstrcat(pszTypeName, TEXT(")"));   <br>       <br>    return NOERROR; <br>error: <br>    return ERROR; <br>}    <br> <br>void CBrowseApp::IDLFlagsToString(int n, LPTSTR psz) <br>{   <br>   psz[0] = '\0'; <br>   if (n &amp; IDLFLAG_FIN) <br>   { <br>       lstrcpy(psz, TEXT("IN"));  <br>       if (n &amp; IDLFLAG_FOUT) <br>           lstrcat(psz, TEXT("|OUT")); <br>   } <br>   else if (n &amp; IDLFLAG_FOUT) <br>       lstrcpy(psz, TEXT("OUT"));     <br>} <br> <br>#define CASE_INVOKE(invokekind)  \ <br>        case invokekind: \ <br>            lstrcpy(psz, TEXT(#invokekind)); \ <br>            break;    <br>void CBrowseApp::CallConvToString(int n, LPTSTR psz)    <br>{ <br>    CALLCONV c = (CALLCONV)n; <br>    switch (c) <br>    { <br>        CASE_INVOKE(CC_CDECL) <br>        CASE_INVOKE(CC_PASCAL) <br>        CASE_INVOKE(CC_MACPASCAL) <br>        CASE_INVOKE(CC_STDCALL) <br>        CASE_INVOKE(CC_SYSCALL) <br>        default: <br>            lstrcpy(psz, TEXT("Unknown"));           <br>    } <br>} <br> <br>#define CASE_FUNC(funckind)  \ <br>        case funckind: \ <br>            lstrcpy(psz, TEXT(#funckind)); \ <br>            break;    <br>void CBrowseApp::FuncKindToString(int n, LPTSTR psz)     <br>{      <br>    FUNCKIND f = (FUNCKIND)n; <br>    switch (f) <br>    { <br>        CASE_FUNC(FUNC_VIRTUAL) <br>        CASE_FUNC(FUNC_PUREVIRTUAL) <br>        CASE_FUNC(FUNC_NONVIRTUAL) <br>        CASE_FUNC(FUNC_STATIC) <br>        CASE_FUNC(FUNC_DISPATCH) <br>        default: <br>            lstrcpy(psz, TEXT("Unknown"));           <br>    } <br>}  <br> <br>#define CASE_INVOKE(invokekind)  \ <br>        case invokekind: \ <br>            lstrcpy(psz, TEXT(#invokekind)); \ <br>            break;    <br>void CBrowseApp::InvokeKindToString(int n, LPTSTR psz)   <br>{   <br>    INVOKEKIND i = (INVOKEKIND)n; <br>    switch (i) <br>    { <br>        CASE_INVOKE(INVOKE_FUNC) <br>        CASE_INVOKE(INVOKE_PROPERTYGET) <br>        CASE_INVOKE(INVOKE_PROPERTYPUT) <br>        CASE_INVOKE(DISPATCH_PROPERTYPUTREF) <br>        default: <br>            lstrcpy(psz, TEXT("Unknown"));           <br>    } <br>} <br>void CBrowseApp::VariantToString(VARIANT v, LPTSTR psz)  <br>{    <br>    HRESULT hr; <br>    VARIANT vTemp; <br>     <br>    VariantInit(&amp;vTemp); <br>    hr = VariantChangeType(&amp;vTemp, &amp;v, 0, VT_BSTR); <br>    if (FAILED(hr)) <br>        lstrcpy(psz, TEXT("Cannot Display Value"));  <br>    else lstrcpy(psz, FROM_OLE_STRING(V_BSTR(&amp;vTemp)));  <br>    VariantClear(&amp;vTemp); <br>} <br> <br> <br>/* <br> * Quick &amp; Dirty ANSI/Unicode conversion routines. These routines use a static <br> * buffer of fixed size to hold the converted string. Consequently these <br> * routines are limited to strings of size STRCONVERT_MAXLEN. Also the same <br> * buffer is reused when the routine is called a second time. So make sure <br> * that the converted string is used before the conversion routine is called <br> * again <br> */ <br>#ifdef WIN32 <br> <br>#ifndef UNICODE <br>char* ConvertToAnsi(OLECHAR FAR* szW) <br>{ <br>  static char achA[STRCONVERT_MAXLEN];  <br>   <br>  WideCharToMultiByte(CP_ACP, 0, szW, -1, achA, STRCONVERT_MAXLEN, NULL, NULL);   <br>  return achA;  <br>}  <br> <br>OLECHAR* ConvertToUnicode(char FAR* szA) <br>{ <br>  static OLECHAR achW[STRCONVERT_MAXLEN];  <br> <br>  MultiByteToWideChar(CP_ACP, 0, szA, -1, achW, STRCONVERT_MAXLEN);   <br>  return achW;  <br>} <br>#endif <br> <br>#endif    </code></pre>
<p>&nbsp;</p></body>
</HTML>
