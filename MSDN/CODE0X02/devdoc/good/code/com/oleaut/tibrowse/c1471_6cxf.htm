<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TIBROWSE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context1473"></a>TIBROWSE.CPP</h2>
<pre><code>/***  <br>*tibrowse.cpp <br>* <br>*  This is a part of the Microsoft Source Code Samples. <br>* <br>*  Copyright 1992 - 1998 Microsoft Corporation. All rights reserved. <br>* <br>*  This source code is only intended as a supplement to Microsoft Development <br>*  Tools and/or WinHelp documentation.  See these sources for detailed <br>*  information regarding the Microsoft samples programs. <br>* <br>*Purpose: <br>*  Type Information Browser <br>* <br>* <br>*Implementation Notes: <br>* <br>*****************************************************************************/ <br> <br>#if defined(_MAC) <br> <br>#if defined(_PPCMAC) <br>#pragma data_seg("_FAR_DATA") <br>#pragma data_seg( ) <br>#define MAXLONG 0x7fffffff <br>#define EventHandlerProcPtr AEEventHandlerUPP <br>#else //_PPCMAC <br>#define  GetMenuItemText(mApple,menuItem,daName)  GetItem(mApple,menuItem,daName) <br>#endif //_PPCMAC <br> <br>#endif //_MAC <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#include "tibrowse.h" <br> <br>#ifdef WIN32  <br>  #define SPRINTFswprintf <br>#else <br>  #define SPRINTFsprintf <br>#endif <br> <br>#if defined(UNICODE) <br>  #define TCHARWCHAR <br>  #define TSTR(str)L##str <br>#else <br>  #define TCHARchar <br>  #define TSTR(str)str <br>  #ifndef LPTSTR <br>    #define LPTSTR LPSTR <br>  #endif <br>#endif <br> <br>#ifdef _MAC <br>DECLARE_ROUTINE_DESC(UserItemUPP,DrawListbox); <br>#endif <br> <br>#ifdef _MAC <br>DialogPtr g_pdlg = NULL; <br>ListHandle g_rghlist[IDC_PARAMLIST+1] = {NULL}; <br>#else <br>HWND g_hwnd; <br>TCHAR g_szAppName[] = TSTR("TiBrowse"); <br>#endif <br> <br>ITypeLib  FAR *g_ptlib = NULL; <br>ITypeInfo FAR *g_ptinfoCur = NULL; <br>TYPEATTR  FAR *g_ptattrCur = NULL; <br> <br>OLECHAR * g_rgszTKind[] = { <br>    OLESTR("Enum"),/* TKIND_ENUM */ <br>    OLESTR("Struct"),/* TKIND_RECORD */ <br>    OLESTR("Module"),/* TKIND_MODULE */ <br>    OLESTR("Interface"),/* TKIND_INTERFACE */ <br>    OLESTR("Dispinterface"),/* TKIND_DISPATCH */ <br>    OLESTR("Coclass"),/* TKIND_COCLASS */ <br>    OLESTR("Typedef"),/* TKIND_ALIAS */ <br>    OLESTR("Union"),/* TKIND_UNION */ <br>}; <br> <br> <br>// Set the text of the control identified by the given control id <br>void <br>XSetDlgItemText(int ctlid, OLECHAR FAR* psz) <br>{ <br>#ifdef _MAC <br>    Rect rc; <br>    Handle h; <br>    short kind; <br>    char buf[255]; <br> <br>    strcpy(buf, psz); <br>    GetDItem(g_pdlg, ctlid, &amp;kind, &amp;h, &amp;rc); <br>    SetIText(h, c2pstr(buf)); <br>#else <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    char bufA[256]; <br>    WideCharToMultiByte(CP_ACP, NULL, psz, -1, bufA, 256, NULL, NULL); <br>    SendDlgItemMessage(g_hwnd, ctlid, WM_SETTEXT, 0, (LPARAM)&amp;bufA); <br>#else <br>    SendDlgItemMessage(g_hwnd, ctlid, WM_SETTEXT, 0, (LPARAM)psz); <br>#endif <br>#endif <br>} <br> <br>// Clear the listbox identified by the given control id <br>void <br>XClrDlgItemList(int ctlid) <br>{ <br>#ifdef _MAC <br>    LDelRow(0, 0, g_rghlist[ctlid]); // delete everything <br>#else <br>    SendMessage(GetDlgItem(g_hwnd, ctlid), LB_RESETCONTENT, 0, 0L);  <br>#endif <br>} <br> <br>// Add the given string to the listbox identified by the given control id <br>void <br>XAddDlgItemList(int ctlid, OLECHAR FAR* psz) <br>{ <br>#ifdef _MAC <br>    int row; <br>    Point pt; <br>    ListHandle hlist; <br> <br>    hlist = g_rghlist[ctlid]; <br>    row = LAddRow(1, -1, hlist); <br>    pt.v = row, pt.h = 0; <br>    LSetCell(psz, strlen(psz), pt, hlist); <br>#else <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    char bufA[256]; <br>    WideCharToMultiByte(CP_ACP, NULL, psz, -1, bufA, 256, NULL, NULL); <br>    SendDlgItemMessage(g_hwnd, ctlid, LB_ADDSTRING, 0, (LPARAM)&amp;bufA); <br>#else <br>    SendDlgItemMessage(g_hwnd, ctlid, LB_ADDSTRING, 0, (LPARAM)psz); <br>#endif <br>#endif <br>} <br> <br>void Cleanup() <br>{ <br>    if(g_ptinfoCur != NULL){ <br>      if(g_ptattrCur != NULL) <br>        g_ptinfoCur-&gt;ReleaseTypeAttr(g_ptattrCur); <br>      g_ptinfoCur-&gt;Release(); <br>      g_ptinfoCur = NULL; <br>    } <br>    if(g_ptlib != NULL){ <br>      g_ptlib-&gt;Release(); <br>      g_ptlib = NULL; <br>    } <br>} <br> <br>void Uninit() <br>{ <br>    OleUninitialize();  <br>#ifdef _MAC <br>#ifndef _PPCMAC <br>    UninitOleManager();// clean up applet <br>#endif <br>#endif <br>} <br> <br> <br>void <br>OpenTypeLib(OLECHAR FAR *sztlib) <br>{                                      <br>    unsigned int utypeinfoCount, i; <br>    BSTR bstrName; <br>    TLIBATTR FAR* ptlibattr; <br> <br>    /* clear out globals */ <br>    Cleanup(); <br> <br>    /* clear out listboxes */ <br>    XClrDlgItemList(IDC_TYPELIST); <br>    XClrDlgItemList(IDC_MEMBERLIST); <br>    XClrDlgItemList(IDC_PARAMLIST); <br> <br>    /* load the type library */ <br>    CHECKRESULT(LoadTypeLib(sztlib, &amp;g_ptlib)); <br> <br>    /* get library attributes for the fun of it */ <br>    CHECKRESULT(g_ptlib-&gt;GetLibAttr(&amp;ptlibattr)); <br> <br>    /* release library attributes */ <br>    g_ptlib-&gt;ReleaseTLibAttr(ptlibattr); <br> <br>    /* Now add each of the names to the type list */ <br>    utypeinfoCount = g_ptlib-&gt;GetTypeInfoCount(); <br>    for(i = 0; i &lt; utypeinfoCount; i++){ <br>      CHECKRESULT(g_ptlib-&gt;GetDocumentation(i, &amp;bstrName, NULL, NULL, NULL));   <br>      ASSERT(bstrName); <br>      XAddDlgItemList(IDC_TYPELIST, bstrName); <br>      SysFreeString(bstrName); <br>    } <br>} <br> <br>#ifdef WIN32 <br>void <br>OpenTypeLib(char FAR *sztlib) <br>{                                      <br>  OLECHAR buf[MAX_PATH]; <br> <br>  MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,  <br>              sztlib, -1, buf, MAX_PATH); <br>  OpenTypeLib(buf); <br>} <br>#endif <br> <br> <br>/*** <br>*void SetSelectedType <br>*Purpose: <br>*  When the user changes the selection of a type, this function updates the <br>*  dialog by changing the member list and the help for the type. It also sets <br>*  g_ptinfoCur to refer to the typeinfo. <br>* <br>*Entry: <br>*  dwIndex = <br>* <br>*Exit: <br>*  return value = None <br>* <br>***********************************************************************/ <br>void <br>SetSelectedType(unsigned long dwIndex) <br>{ <br>    HRESULT hr; <br>    BSTR bstrDoc; <br>    OLECHAR FAR* psz; <br>    OLECHAR szBuf[40]; <br>    unsigned long dwHelpContext; <br>    TYPEKIND tkind; <br> <br>    if(g_ptinfoCur != NULL){ <br>      g_ptinfoCur-&gt;ReleaseTypeAttr(g_ptattrCur); <br>      g_ptinfoCur-&gt;Release(); <br>    } <br> <br>    /* Clear out the member list */ <br>    XClrDlgItemList(IDC_MEMBERLIST); <br> <br>    if(g_ptlib == NULL) <br>      return; <br> <br>    // Note: the index in the list box is conveniently the same as the <br>    // one to pass to GetTypeInfo/GetTypeInfoType <br> <br>    // typeinfo type can be obtained without actually loading the typeinfo <br>    CHECKRESULT(g_ptlib-&gt;GetTypeInfoType((unsigned int)dwIndex, &amp;tkind)); <br>    XSetDlgItemText(IDC_TYPEKIND, g_rgszTKind[tkind]); <br> <br>    CHECKRESULT(g_ptlib-&gt;GetTypeInfo((unsigned int)dwIndex, &amp;g_ptinfoCur)); <br>    CHECKRESULT(g_ptinfoCur-&gt;GetTypeAttr(&amp;g_ptattrCur)); <br> <br>    // GUID <br>    hr = StringFromCLSID(g_ptattrCur-&gt;guid, &amp;psz); <br>    ASSERT(hr == NOERROR); <br>    XSetDlgItemText(IDC_GUID, psz); <br>    MemFree(psz); <br> <br>    // Version <br>    SPRINTF(szBuf, OLESTR("%u.%02u"), <br>      g_ptattrCur-&gt;wMajorVerNum, g_ptattrCur-&gt;wMinorVerNum); <br>    XSetDlgItemText(IDC_VERSION, szBuf); <br>     <br>    CHECKRESULT( <br>      g_ptlib-&gt;GetDocumentation( <br>        (unsigned int)dwIndex, NULL, &amp;bstrDoc, &amp;dwHelpContext, NULL)); <br> <br>    // Help Context <br>    SPRINTF(szBuf, OLESTR("%ld"), dwHelpContext); <br>    XSetDlgItemText(IDC_HELPCONTEXT, szBuf); <br> <br>    // Documentation string <br>    psz = (bstrDoc != NULL) ? bstrDoc : OLESTR("&lt;none&gt;"); <br>    XSetDlgItemText(IDC_HELPSTRING, psz); <br>    SysFreeString(bstrDoc); <br>    <br>    FillMemberList(g_ptinfoCur, g_ptattrCur, IDC_MEMBERLIST);  <br> <br>    XClrDlgItemList(IDC_PARAMLIST); <br>} <br> <br>/*** <br>*void FillMemberList <br>*Purpose: <br>* Sets the current typeinfo to the typeinfo indexed by dwIndex, and <br>* then fills in the list box with the members of the type. <br>* <br>*Entry: <br>*  ptinfo =  <br>*  ptypeattr = <br>* <br>*Exit: <br>*  return value = None <br>* <br>***********************************************************************/ <br>void <br>FillMemberList( <br>    ITypeInfo FAR *ptinfo, <br>    TYPEATTR FAR *ptypeattr, <br>    int ctlid) <br>{ <br>    MEMBERID memid;  <br>    BSTR bstrName; <br>    unsigned int i; <br>    FUNCDESC FAR *pfuncdesc; <br>    VARDESC  FAR *pvardesc; <br> <br>    /* Now add all of the functions and all of the vars. <br>     * This is somewhat roundabout. <br>     * For each one, we need to get the funcdesc, or the vardesc. <br>     * From that we get the MEMBERID, and finally can get to the name. <br>     */ <br>    for(i = 0; i &lt; ptypeattr-&gt;cFuncs; i++){ <br>      CHECKRESULT(ptinfo-&gt;GetFuncDesc(i, &amp;pfuncdesc)); <br>      memid = pfuncdesc-&gt;memid; <br>      CHECKRESULT(ptinfo-&gt;GetDocumentation(memid, &amp;bstrName, NULL, NULL, NULL)); <br>      ptinfo-&gt;ReleaseFuncDesc(pfuncdesc); <br>      pfuncdesc = NULL; <br>     <br>      ASSERT(bstrName); <br>      XAddDlgItemList(ctlid, bstrName); <br>      SysFreeString(bstrName); <br>    } <br>     <br>    for(i = 0; i &lt; ptypeattr-&gt;cVars; i++) <br>    { <br>      CHECKRESULT(ptinfo-&gt;GetVarDesc(i, &amp;pvardesc)); <br>      memid = pvardesc-&gt;memid; <br>      CHECKRESULT(ptinfo-&gt;GetDocumentation(memid, &amp;bstrName, NULL, NULL, NULL)); <br>      ptinfo-&gt;ReleaseVarDesc(pvardesc); <br>      pvardesc = NULL; <br> <br>      ASSERT(bstrName); <br>      XAddDlgItemList(ctlid, bstrName); <br>      SysFreeString(bstrName); <br>    } <br>} <br> <br>/*** <br>*void SetSelectedMember <br>*Purpose: <br>*  When a member of a type is selected, update the help to be the help <br>*  of the member, and if the member is a function update the parameter <br>*  list to reflect that it is a function. <br>* <br>*Entry: <br>*  dwIndex = <br>* <br>*Exit: <br>*  return value = None <br>* <br>***********************************************************************/ <br>void <br>SetSelectedMember(unsigned long dwIndex) <br>{ <br>    MEMBERID memid; <br> <br>    /* In any case, we'll need to clear out the parameter list. */ <br>    XClrDlgItemList(IDC_PARAMLIST); <br> <br>    if(g_ptattrCur == NULL) <br>      return; <br> <br>    /* if this is a function, fill the param list, otherwise just fill <br>     * in the item info. <br>     */ <br>    if(dwIndex &lt; g_ptattrCur-&gt;cFuncs){ <br>      unsigned short i; <br>      unsigned int cNames; <br>      FUNCDESC FAR *pfuncdesc; <br>      const unsigned int MAX_NAMES = 40; <br>      BSTR rgNames[MAX_NAMES]; <br> <br>      CHECKRESULT(g_ptinfoCur-&gt;GetFuncDesc((unsigned int) dwIndex, &amp;pfuncdesc)); <br>      memid = pfuncdesc-&gt;memid; <br>      UpdateMemberInfo(memid); <br>     <br>      CHECKRESULT(g_ptinfoCur-&gt;GetNames(memid, rgNames, MAX_NAMES,&amp;cNames)); <br>      for(i = 1; i &lt; cNames; i++){ <br>ASSERT(rgNames[i]) <br>XAddDlgItemList(IDC_PARAMLIST, rgNames[i]); <br>SysFreeString(rgNames[i]); <br>      } <br>      ASSERT(rgNames[0]);           <br>      SysFreeString(rgNames[0]); <br>      g_ptinfoCur-&gt;ReleaseFuncDesc(pfuncdesc); <br>    } <br>    else <br>    { <br>      VARDESC FAR *pvardesc; <br> <br>      CHECKRESULT( <br>        g_ptinfoCur-&gt;GetVarDesc( <br>  (unsigned int)(dwIndex - g_ptattrCur-&gt;cFuncs), &amp;pvardesc)); <br>      memid = pvardesc-&gt;memid; <br>      UpdateMemberInfo(memid); <br>      g_ptinfoCur-&gt;ReleaseVarDesc(pvardesc); <br>    } <br>} <br> <br>/*** <br>*void UpdateMemberInfo <br>*Purpose: <br>*  sets fields on the dialog (such as help string and help context) from <br>*  the type information. <br>* <br>*Entry: <br>*  memid = <br>* <br>*Exit: <br>*  return value = None <br>* <br>***********************************************************************/ <br>void <br>UpdateMemberInfo(MEMBERID memid)                    <br>{ <br>    BSTR bstrDoc; <br>    OLECHAR buf[40];                     <br>    unsigned long dwHelpContext; <br> <br>    /* get the member information */ <br>    CHECKRESULT(g_ptinfoCur-&gt;GetDocumentation( <br>      memid, NULL, &amp;bstrDoc, &amp;dwHelpContext, NULL)); <br> <br>    /* update the help string displayed in the dialog */ <br>    XSetDlgItemText(IDC_HELPSTRING, (bstrDoc != NULL) ?  <br>                             bstrDoc : OLESTR("&lt;none&gt;")); <br>    SysFreeString(bstrDoc); <br>         <br>    /* update the help context displayed in the dialog */ <br>    SPRINTF(buf, OLESTR("%ld"), dwHelpContext); <br>    XSetDlgItemText(IDC_HELPCONTEXT, buf); <br>} <br> <br>/*** <br>*void SetSelectedParam <br>*Purpose: <br>*  CONSIDER: Enhance to show parameter type information here. <br>* <br>*Entry: <br>*  dwIndex = <br>* <br>*Exit: <br>*  return value = None <br>* <br>***********************************************************************/ <br>void <br>SetSelectedParam(unsigned long dwIndex) <br>{ <br>} <br> <br> <br>HRESULT <br>GetFileName(BSTR FAR* pbstrFileName) <br>{ <br>    OLECHAR buf[1024]; <br>    BSTR bstrFileName; <br> <br>#ifdef _MAC <br> <br>    int i; <br>    Point pt; <br>    long dirID; <br>    char *p, *q; <br>    SFReply sfr; <br>    SFTypeList sftl; <br>    short sRefNumReal; <br> <br>    SetPt(&amp;pt, 100, 100); <br>    //sftl[0] = 'OTLB'; <br>    sftl[0] = 0; // currently allow all file types <br>    SFGetFile(pt, NULL, NULL, -1, sftl, NULL, &amp;sfr); <br> <br>    if(!sfr.good) <br>      return E_FAIL; <br> <br>    // translate sfr.vRefNum into a dirID <br>    { <br>WDPBRec wdpbr; <br> <br>wdpbr.ioWDIndex   = 0; <br>wdpbr.ioVRefNum   = sfr.vRefNum; <br>wdpbr.ioWDVRefNum = 0; <br>wdpbr.ioWDIndex   = 0; <br>wdpbr.ioWDProcID  = 0; <br>wdpbr.ioNamePtr   = (StringPtr)buf; <br> <br>if(PBGetWDInfoSync (&amp;wdpbr) != noErr) <br>  return E_FAIL; <br> <br>sRefNumReal = wdpbr.ioWDVRefNum; <br>dirID = wdpbr.ioWDDirID; <br>    } <br> <br>    { <br>Str255 stDir; <br>CInfoPBRec pb; <br>DirInfo *pdirinfo = (DirInfo*)&amp;pb; <br>char rgchTemp[256]; // REVIEW: what should the size be? <br> <br>pdirinfo-&gt;ioNamePtr = stDir; <br>pdirinfo-&gt;ioVRefNum = sRefNumReal; <br>pdirinfo-&gt;ioDrParID = dirID; <br>pdirinfo-&gt;ioFDirIndex = -1;  // get info on a dir <br> <br>buf[0] = '\0'; <br> <br>// loop until we hit the root dir <br>do{ <br>  pdirinfo-&gt;ioDrDirID = pdirinfo-&gt;ioDrParID; <br>  if(PBGetCatInfoSync (&amp;pb) != noErr) <br>    return E_FAIL; <br>  strncpy(rgchTemp, (char*)stDir, 64); <br>  p2cstr((StringPtr)rgchTemp); <br>  strcat(rgchTemp, ":"); <br>  strcat(rgchTemp, buf); <br>  strcpy(buf, rgchTemp); <br>}while(pdirinfo-&gt;ioDrDirID != fsRtDirID); <br> <br>    } <br> <br>    q = (char*)sfr.fName; <br>    i = (int)*q++; <br>    p = &amp;buf[strlen(buf)]; <br>    while(i--&gt;0) <br>      *p++ = *q++; <br>    *p = '\0'; <br> <br>    if((bstrFileName = SysAllocString(buf)) == NULL) <br>      return E_OUTOFMEMORY; <br> <br>#else <br> <br>    OPENFILENAME ofn;                          <br> <br>    memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>    ofn.lStructSize  = sizeof(OPENFILENAME); <br>    ofn.hwndOwner    = g_hwnd; <br>    ofn.lpstrFile    = (LPTSTR) &amp;buf; <br>    ofn.nMaxFile     = sizeof(buf); <br>    *buf = OLESTR('\0'); <br>    ofn.lpstrFilter  = TSTR("Type Libraries\0*.tlb\0\0"); <br>    ofn.nFilterIndex = 1;  <br>    ofn.Flags        = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_SHAREAWARE; <br>    if(GetOpenFileName(&amp;ofn) == 0){  <br>      // REVIEW: we can probably do something smarter with this error <br>      DWORD dwerr = CommDlgExtendedError(); <br>      return E_FAIL; <br>    } <br>#if defined(WIN32) &amp;&amp; !defined(UNICODE) <br>    OLECHAR szFileW[_MAX_PATH]; <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, <br>ofn.lpstrFile, -1, szFileW, _MAX_PATH); <br>    if((bstrFileName = SysAllocString(szFileW)) == NULL) <br>      return E_OUTOFMEMORY; <br>#else <br>    if((bstrFileName = SysAllocString(ofn.lpstrFile)) == NULL) <br>      return E_OUTOFMEMORY; <br>#endif <br> <br>#endif <br> <br>    *pbstrFileName = bstrFileName; <br>    return NOERROR; <br>} <br> <br>void <br>AssertFail(char FAR* file, int line) <br>{ <br>    // Ansi Output for Assertion <br>    #ifdef UNICODE <br>      #define OUTPUTDEBUGSTRINGOutputDebugStringA <br>      #define MESSAGEBOXMessageBoxA <br>    #else <br>      #define OUTPUTDEBUGSTRINGOutputDebugString <br>      #define MESSAGEBOXMessageBox <br>    #endif   <br> <br>    char buf[128]; <br> <br>    sprintf(buf, "Assertion failed: %s(%d)", file, line); <br> <br>#ifdef _MAC <br>    DebugStr(c2pstr(buf)); <br>#else <br>    OUTPUTDEBUGSTRING(buf); <br>    if(MESSAGEBOX(NULL, buf,  <br>  "TiBrowse Assertion.  OK to continue, CANCEL to quit.", <br>  MB_OKCANCEL | MB_TASKMODAL) == IDCANCEL) <br>      exit(1); <br>    DebugBreak(); <br>#endif <br>} <br> <br>#ifdef _MAC /* { */ <br> <br>void Init(void); <br>void EventLoop(void); <br> <br>void AdjustMenus(void); <br>void DoEvent(EventRecord *pevent); <br>void DoMenuCommand(long menuResult); <br>void Quit(void); <br>#ifndef _MSC_VER <br>#ifndef ConstStr255Param <br>#define ConstStr255Param StringPtr <br>#endif <br>#endif <br>void Fatal(ConstStr255Param); <br> <br>Boolean <br>IsAppWindow(WindowPtr window) <br>{ <br>    return (window == NULL) <br>      ? false : ((WindowPeek)window)-&gt;windowKind == userKind; <br>} <br> <br>Boolean <br>IsDAWindow(WindowPtr window) <br>{ <br>    return (window == NULL) <br>      ? false : (((WindowPeek)window)-&gt;windowKind &lt; 0); <br>} <br> <br>void <br>main() <br>{ <br>    Init(); <br>//    ShowWindow(g_pdlg); // REVIEW: necessarry? <br>    EventLoop(); <br>} <br> <br>void <br>DoDialogEvent(EventRecord *pevent, short sItem) <br>{ <br>    Point pt; <br>    GrafPtr pport; <br>    ListHandle hlist; <br> <br>    switch(sItem){ <br>    case IDC_TYPELIST: <br>    case IDC_MEMBERLIST: <br>    case IDC_PARAMLIST: <br>      if(pevent-&gt;what == mouseDown){ <br>GetPort(&amp;pport); <br>SetPort(g_pdlg); <br>        GlobalToLocal(&amp;pevent-&gt;where); <br>hlist = g_rghlist[sItem]; <br>        LClick(pevent-&gt;where, pevent-&gt;modifiers, hlist); <br>SetPt(&amp;pt, 0, 0); <br>if(LGetSelect(true, &amp;pt, hlist)){ <br>  switch(sItem){ <br>  case IDC_TYPELIST: <br>    SetSelectedType(pt.v); <br>    break; <br>  case IDC_MEMBERLIST: <br>    SetSelectedMember(pt.v); <br>    break; <br>  case IDC_PARAMLIST: <br>    SetSelectedParam(pt.v); <br>    break; <br>  } <br>} <br>SetPort(pport); <br>      } <br>      break; <br>    } <br>} <br> <br>void <br>EventLoop() <br>{ <br>    short sItem; <br>    DialogPtr pdlg; <br>    EventRecordevent; <br>    RgnHandle cursorRgn; <br> <br>    cursorRgn = NewRgn(); <br>    while(1){ <br>      if(WaitNextEvent(everyEvent, &amp;event, MAXLONG, cursorRgn)){ <br>if (FrontWindow() != NULL <br> &amp;&amp; event.what != diskEvt <br> &amp;&amp; (event.what != keyDown || (event.modifiers &amp; cmdKey) == 0) <br> &amp;&amp; IsDialogEvent(&amp;event)) <br>{ <br>  if(DialogSelect(&amp;event, &amp;pdlg, &amp;sItem)){ <br>    ASSERT(pdlg == g_pdlg); <br>    DoDialogEvent(&amp;event, sItem); <br>  } <br>}else{ <br>  DoEvent(&amp;event); <br>} <br>      } <br>    } <br>} <br> <br>void <br>DoEvent(EventRecord *pevent) <br>{ <br>    char key; <br>    short part; <br>    WindowPtr window; <br> <br>    switch(pevent-&gt;what){ <br>    case mouseDown: <br>      part = FindWindow(pevent-&gt;where, &amp;window); <br>      switch(part){ <br>      case inMenuBar: <br>AdjustMenus(); <br>DoMenuCommand(MenuSelect(pevent-&gt;where)); <br>break; <br> <br>      case inSysWindow:/* let the system handle the mouseDown */ <br>SystemClick(pevent, window); <br>break; <br> <br>      case inContent: <br>if(window != FrontWindow()){ <br>  SelectWindow(window); <br>} <br>break; <br> <br>      case inDrag: <br>DragWindow(window, pevent-&gt;where, &amp;qd.screenBits.bounds); <br>break; <br>      } <br>      break; <br> <br>    case keyDown: <br>    case autoKey:/* check for menukey equivalents */ <br>      key = (char)(pevent-&gt;message &amp; charCodeMask); <br>      if(pevent-&gt;modifiers &amp; cmdKey){/* Command key down */ <br>if(pevent-&gt;what == keyDown){ <br>  /* enable/disable/check menu items properly */ <br>  AdjustMenus(); <br>  DoMenuCommand(MenuKey(key)); <br>} <br>      } <br>      break; <br>    } <br>} <br> <br>void <br>Enable(MenuHandle hmenu, short sItem, Boolean fEnable) <br>{ <br>    if(fEnable) <br>      EnableItem(hmenu, sItem); <br>    else <br>      DisableItem(hmenu, sItem); <br>} <br> <br>void <br>AdjustMenus() <br>{ <br>    Boolean fIsDA; <br>    MenuHandle hmenu; <br> <br>    fIsDA = IsDAWindow(FrontWindow()); <br> <br>    /* we can allow desk accessories to be closed from the menu */ <br>    hmenu = GetMHandle(mFile); <br>    Enable(hmenu, iClose, fIsDA); <br> <br>    hmenu = GetMHandle(mEdit); <br>    Enable(hmenu, iUndo,  fIsDA); <br>    Enable(hmenu, iCut,   fIsDA); <br>    Enable(hmenu, iCopy,  fIsDA); <br>    Enable(hmenu, iPaste, fIsDA); <br>    Enable(hmenu, iClear, fIsDA); <br>} <br> <br>void <br>DoMenuCommand(long menuResult) <br>{ <br>    short menuID;/* the resource ID of the selected menu */ <br>    short menuItem;/* the item number of the selected menu */ <br>    Str255 daName; <br> <br>    menuID = HiWord(menuResult); <br>    menuItem = LoWord(menuResult); <br> <br>    switch(menuID){ <br>    case mApple: <br>      switch(menuItem){ <br>      case iAbout:/* bring up alert for About */ <br>Alert(rAboutAlert, NULL); <br>break; <br>      default: <br>GetMenuItemText(GetMHandle(mApple), menuItem, daName); <br>OpenDeskAcc(daName); <br>break; <br>      } <br>      break; <br> <br>    case mFile: <br>      switch(menuItem){ <br>      case iOpen: <br>    { <br>        BSTR bstrFileName; <br>        if(GetFileName(&amp;bstrFileName) != NOERROR) <br>{ <br>  // REVIEW: shouldnt just bag out here <br>  Fatal((ConstStr255Param)"\pUnable to open Type Library"); <br>        } <br>        OpenTypeLib(bstrFileName); <br>    } <br>break; <br> <br>      case iQuit: <br>Quit(); <br>break; <br>      } <br>      break; <br> <br>    case mEdit: <br>      SystemEdit(menuItem-1); <br>      break; <br>    } <br> <br>    HiliteMenu(0); <br>} <br> <br>extern "C" { <br> <br>#if defined(_MSC_VER) <br>void pascal <br>#else <br>pascal void <br>#endif <br>DrawListbox(DialogPtr pdlg, short sItem) <br>{ <br>    Rect rc; <br>    Handle h; <br>    short kind; <br>    GrafPtr port; <br>    ListHandle hlist; <br> <br>    ASSERT(sItem == IDC_TYPELIST <br>|| sItem == IDC_MEMBERLIST <br>|| sItem == IDC_PARAMLIST); <br> <br>    GetPort(&amp;port); <br>    SetPort(pdlg); <br>    hlist = g_rghlist[sItem]; <br>    LUpdate(pdlg-&gt;visRgn, hlist); <br>    GetDItem(pdlg, sItem, &amp;kind, &amp;h, &amp;rc); <br>    InsetRect(&amp;rc, -1, -1); <br>    FrameRect(&amp;rc); <br>    SetPort(port); <br>} <br> <br>} <br> <br> <br>/*** <br>*ListHandle CreateListBox(DialogPtr, int) <br>*Purpose: <br>*  Create a listbox on the given dialog, associated with the given <br>*  control id. <br>* <br>*Entry: <br>*  pdlg = <br>*  ctlid = <br>* <br>*Exit: <br>*  return value = ListHandle <br>* <br>***********************************************************************/ <br>ListHandle <br>CreateListbox(DialogPtr pdlg, int ctlid) <br>{ <br>    Handle h; <br>    short kind; <br>    Point ptCell; <br>    ListHandle hlist; <br>    Rect rcView, rcBounds; <br> <br>    INIT_ROUTINE_DESC(NewUserItemProc,DrawListbox); <br> <br>    GetDItem(pdlg, ctlid, &amp;kind, &amp;h, &amp;rcView); <br>    SetDItem(pdlg, ctlid, kind, (Handle) ROUTINE_DESC(DrawListbox), &amp;rcView); <br> <br>    // make room for scroll bars <br>    rcView.right -= 15; <br> <br>    // list is 1 wide <br>    SetRect(&amp;rcBounds, 0, 0, 1, 0); <br> <br>    SetPt(&amp;ptCell, 0, 0); <br> <br>    hlist = LNew( <br>      &amp;rcView, <br>      &amp;rcBounds, <br>      ptCell, <br>      0, (WindowPtr)pdlg, true, false, false, true); <br> <br>    ASSERT(hlist != NULL); <br> <br>    (*hlist)-&gt;selFlags = lUseSense | lNoRect | lNoExtend | lOnlyOne; <br> <br>    return hlist; <br>} <br> <br>/*** <br>*DialogPtr CreateDialog(void) <br>*Purpose: <br>*  Create the TiBrowse dialog <br>* <br>*Entry: <br>*  None <br>* <br>*Exit: <br>*  return value = DialogPtr <br>* <br>***********************************************************************/ <br>DialogPtr <br>CreateDialog() <br>{ <br>    int i; <br>    Point pt; <br>    DialogPtr pdlg; <br>    ListHandle hlist; <br>static short rgctl[] = {IDC_TYPELIST, IDC_MEMBERLIST, IDC_PARAMLIST}; <br> <br>    if((pdlg = GetNewDialog(rDlg, NULL, (WindowPtr)-1)) == NULL) <br>      return NULL; <br> <br>    for(i = 0; i &lt; DIM(rgctl); ++i){ <br>      g_rghlist[rgctl[i]]  = CreateListbox(pdlg, rgctl[i]); <br>    } <br> <br>    SetPt(&amp;pt, 0, 0); <br>    for(i = 0; i &lt; DIM(rgctl); ++i){ <br>      hlist = g_rghlist[rgctl[i]]; <br>      LSetSelect(true, pt, hlist); <br>      LDoDraw(true, hlist); <br>    } <br> <br>    return pdlg; <br>} <br> <br> <br>void <br>Init() <br>{ <br>    Handle menuBar; <br> <br>    MaxApplZone(); <br> <br>    InitGraf((Ptr)&amp;qd.thePort); <br>    InitFonts(); <br>    InitWindows(); <br>    InitMenus(); <br>    TEInit(); <br>    InitDialogs(NULL); <br>    InitCursor(); <br>    FlushEvents(everyEvent, 0); <br> <br>#ifndef _PPCMAC <br>    if (InitOleManager(0) != NOERROR) <br>      Fatal((ConstStr255Param)"\pCould not initialize OLE Applet"); <br>#endif <br> <br>    if(OleInitialize(NULL) != NOERROR) <br>      Fatal((ConstStr255Param)"\pUnable to Initialize Ole"); <br> <br>    if((menuBar = GetNewMBar(rMenuBar)) == NULL) <br>      Fatal((ConstStr255Param)"\pUnable to load menu bar"); <br>    SetMenuBar(menuBar); <br>    DisposHandle(menuBar); <br>    AddResMenu(GetMHandle(mApple), 'DRVR'); <br>    DrawMenuBar(); <br> <br>    if((g_pdlg = CreateDialog()) == NULL) <br>      Fatal((ConstStr255Param)"\pUnable to create dialog"); <br>} <br> <br>void <br>Quit() <br>{ <br>    Cleanup(); <br>    Uninit(); <br>    ExitToShell(); <br>} <br> <br>/* display fatal error alert, and exit */ <br>void <br>Fatal(ConstStr255Param msg) <br>{ <br>    SetCursor(&amp;qd.arrow); <br>    ParamText(msg, (ConstStr255Param)"\p", (ConstStr255Param)"\p", (ConstStr255Param)"\p"); <br>    Alert(rUserAlert, nil); <br>    Quit(); <br>} <br> <br>#else /* }{ */ <br> <br>long FAR PASCAL EXPORT WndProc (HWND, UINT, WPARAM, LPARAM) ; <br> <br>int PASCAL <br>WinMain( <br>    HINSTANCE hinst, <br>    HINSTANCE hinstPrev, <br>    LPSTR lpszCmdLine, <br>    int nCmdShow) <br>{ <br>    MSG msg; <br>    WNDCLASS wndclass; <br>  <br>    if(!hinstPrev){ <br>      wndclass.style          = CS_HREDRAW | CS_VREDRAW; <br>      wndclass.lpfnWndProc    = WndProc ; <br>      wndclass.cbClsExtra     = 0 ; <br>      wndclass.cbWndExtra     = DLGWINDOWEXTRA ; <br>      wndclass.hInstance      = hinst ; <br>      wndclass.hIcon          = LoadIcon (hinst, g_szAppName) ; <br>      wndclass.hCursor        = LoadCursor (NULL, IDC_ARROW) ; <br>      wndclass.hbrBackground  = (HBRUSH) (COLOR_WINDOW + 1) ; <br>      wndclass.lpszMenuName   = NULL ; <br>      wndclass.lpszClassName  = g_szAppName ; <br> <br>      RegisterClass (&amp;wndclass) ; <br>    } <br>        <br>    if(OleInitialize(NULL) != NOERROR){ <br>      MessageBox(NULL, TSTR("unable to initialize Ole"), <br>         g_szAppName, MB_OK); <br>      return 0; <br>    } <br>      <br>    g_hwnd = CreateDialog(hinst, g_szAppName, 0, NULL); <br> <br>    if(*lpszCmdLine == '\0'){ <br>      BSTR bstrFileName; <br>      if(GetFileName(&amp;bstrFileName) != NOERROR){ <br>Cleanup(); <br>Uninit(); <br>exit(-1); <br>      } <br>      OpenTypeLib(bstrFileName); <br>      SysFreeString(bstrFileName); <br>    }else{ <br>      OpenTypeLib(lpszCmdLine); <br>    } <br>       <br>    ShowWindow(g_hwnd, nCmdShow); <br> <br>    while(GetMessage (&amp;msg, NULL, 0, 0)){ <br>      TranslateMessage (&amp;msg); <br>      DispatchMessage (&amp;msg); <br>    } <br>    Cleanup(); <br>    Uninit(); <br>    return msg.wParam; <br>} <br> <br>long FAR PASCAL EXPORT <br>WndProc( <br>    HWND hwnd, <br>    UINT message, <br>    WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    unsigned long dwIndex; <br> <br>    switch(message){ <br>    case WM_COMMAND:  <br>      /* We deal with the following events: <br>       * The selection changes on the type list and we have <br>       *  to update the member list &amp; type info. <br>       * The selection changes on the member list and we have <br>       *  to update the param list &amp; member info. <br>       * Selection changes on a parameter and we have to <br>       *  update the param info. <br>       */ <br>#ifdef WIN32 <br># define wParamX LOWORD(wParam) <br># define notifyMsg HIWORD(wParam) <br>#else <br># define wParamX wParam <br># define notifyMsg HIWORD(lParam) <br>#endif <br>      switch(wParamX){ <br>      case IDC_TYPELIST: <br>        if(notifyMsg == LBN_SELCHANGE){ <br>          dwIndex = SendDlgItemMessage(hwnd, IDC_TYPELIST, LB_GETCURSEL, 0, 0L); <br>  if(dwIndex != LB_ERR) <br>    SetSelectedType(dwIndex); <br>} <br>break; <br>      case IDC_MEMBERLIST: <br>        if(notifyMsg == LBN_SELCHANGE){ <br>          dwIndex = SendDlgItemMessage(hwnd, IDC_MEMBERLIST, LB_GETCURSEL,0,0L); <br>  if(dwIndex != LB_ERR) <br>    SetSelectedMember(dwIndex); <br>} <br>        break; <br>      case IDC_PARAMLIST: <br>        if(notifyMsg == LBN_SELCHANGE){ <br>          dwIndex = SendDlgItemMessage(hwnd, IDC_PARAMLIST, LB_GETCURSEL, 0,0L); <br>  if(dwIndex != LB_ERR) <br>    SetSelectedParam(dwIndex); <br>} <br>break; <br>      } <br>      return 0; <br> <br>    case WM_DESTROY: <br>      PostQuitMessage(0); <br>      return 0 ; <br>    } <br>    return DefWindowProc (hwnd, message, wParam, lParam) ; <br>} <br> <br>#endif /* } */ <br> <br>void <br>MethodError(HRESULT hresult) <br>{ <br>    /* CONSIDER: add code to figure out what specific error this is */ <br>    UNUSED(hresult); <br> <br>#ifdef _MAC <br>    Fatal((ConstStr255Param)"\pType Library"); <br>#else <br>    MessageBox(NULL, TSTR("Error returned from TYPELIB.DLL"), <br>       g_szAppName, MB_OK); <br>    exit(1); <br>#endif <br>} <br> <br>/* free using the task allocator */ <br>void <br>MemFree(void FAR* pv) <br>{ <br>    HRESULT hresult; <br>    IMalloc FAR* pmalloc; <br> <br>    hresult = CoGetMalloc(MEMCTX_TASK, &amp;pmalloc); <br> <br>    if(hresult != NOERROR){ <br>#ifdef _MAC <br>      Fatal((ConstStr255Param)"\pError accessing task allocator"); <br>#else <br>      MessageBox(NULL, TSTR("Error accessing task allocator"), <br>         g_szAppName, MB_OK); <br>#endif <br>      return; <br>    } <br> <br>    pmalloc-&gt;Free(pv); <br>    pmalloc-&gt;Release(); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
