<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTILS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context47"></a>UTILS.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          Utils.cpp <br>    <br>   Description:   Contains utility routines for the DOServer sample. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include &lt;windows.h&gt; <br>#include "utils.h" <br> <br>/************************************************************************** <br> <br>   ParseCommandLine() <br>    <br>   Parses the Windows command line which was passed to WinMain. <br>   This function determines if the -Embedding switch has been given. <br> <br>**************************************************************************/ <br> <br>STDAPI_(void) ParseCommandLine(LPSTR pszCommandLine, LPBOOL pfEmbedFlag, LPTSTR pszFileName) <br>{ <br>int      i; <br>TCHAR    szCmdLine[MAX_PATH]; <br>LPTSTR   pszCmdLine = szCmdLine; <br>TCHAR    szBuf[MAX_PATH]; <br> <br>if(!pszCommandLine) <br>   return; <br>    <br>if(!pfEmbedFlag) <br>   return; <br>    <br>*pfEmbedFlag = FALSE; <br> <br>#ifdef UNICODE <br>MultiByteToWideChar( CP_ACP,  <br>                     MB_PRECOMPOSED,  <br>                     pszCommandLine,  <br>                     -1,  <br>                     pszCmdLine, <br>                     ARRAYSIZE(szCmdLine)); <br>#else <br>lstrcpy(pszCmdLine, pszCommandLine); <br>#endif <br> <br>// skip blanks <br>while(isspace(*pszCmdLine))  <br>   pszCmdLine++; <br> <br>// No filename or options, so start a fresh document. <br>if(!*pszCmdLine)    <br>   return; <br> <br>// Check for "-Embedding" or "/Embedding" and set fEmbedding. <br>if((*pszCmdLine == '-') || (*pszCmdLine == '/')) <br>   { <br>   pszCmdLine++; <br>   pszCmdLine = GetWord(pszCmdLine, szBuf); <br>   *pfEmbedFlag = !lstrcmp(szBuf, EMBEDDINGFLAG); <br>   } <br> <br>if(!pszFileName) <br>   return; <br>    <br>*pszFileName = 0; <br> <br>// skip blanks <br>while(isspace(*pszCmdLine))  <br>   pszCmdLine++; <br> <br>// set pszFileName to argument <br>for(i = 0; *(pszCmdLine + i); i++)  <br>   { <br>   *(pszFileName + i) = *(pszCmdLine + i); <br>   } <br> <br>*(pszFileName + i) = 0; <br>} <br> <br> <br>/************************************************************************** <br> <br>   GetWord() <br>    <br>   LPSTR lpszSrc - Pointer to a source string <br>   LPSTR lpszDst - Pointer to destination buffer <br> <br>   Will copy one space-terminated or null-terminated word from the source <br>   string to the destination buffer. <br>    <br>   returns: pointer to next character following the word. <br> <br>**************************************************************************/ <br> <br>static LPTSTR GetWord(LPTSTR lpszSrc, LPTSTR lpszDst) <br>{ <br>while (*lpszSrc &amp;&amp; !isspace(*lpszSrc)) <br>   *lpszDst++ = *lpszSrc++; <br> <br>*lpszDst = '\0'; <br> <br>return lpszSrc; <br>} <br> <br>/* GetOleObjectDataHere <br>** ---------------------- <br>**    Render CF_EMBEDSOURCE/CF_EMBEDDEDOBJECT data on an TYMED_ISTORAGE <br>**    medium by asking the object to save into the storage. <br>**    the object must support IPersistStorage. <br>** <br>**    if lpMedium-&gt;tymed == TYMED_NULL, then a delete-on-release <br>**    storage is allocated (either file-based or memory-base depending <br>**    the value of fUseMemory). this is useful to support an <br>**    IDataObject::GetData call where the callee must allocate the <br>**    medium. <br>** <br>**    if lpMedium-&gt;tymed == TYMED_ISTORAGE, then the data is writen <br>**    into the passed in IStorage. this is useful to support an <br>**    IDataObject::GetDataHere call where the caller has allocated his <br>**    own IStorage. <br>*/ <br>STDAPI GetOleObjectDataHere(  LPPERSISTSTORAGE lpPStg, <br>                              LPFORMATETC lpformatetc, <br>                              LPSTGMEDIUM lpMedium) <br>{ <br>LPSTORAGE   lpstg = NULL; <br>DWORD       reserved = 0; <br>HRESULT     hr = DATA_E_FORMATETC; <br> <br>lpMedium-&gt;pUnkForRelease = NULL; <br> <br>if(lpMedium-&gt;tymed != TYMED_ISTORAGE)  <br>   { <br>   return hr; <br>   } <br> <br>//AddRef the IStorage pointer <br>lpPStg-&gt;AddRef(); <br> <br>// NOTE: even if OleSave returns an error you should still call <br>// SaveCompleted. <br> <br>hr = OleSave(lpPStg, lpMedium-&gt;pstg, FALSE /* fSameAsLoad */); <br> <br>lpPStg-&gt;SaveCompleted(NULL); <br> <br>return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
