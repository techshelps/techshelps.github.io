<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OLEDOC.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context35"></a>OLEDOC.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          OleDoc.cpp <br>    <br>   Description:   COleDocument implementation. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "OleDoc.h" <br>#include "comcat.h" <br> <br>/************************************************************************** <br>   global variables <br>**************************************************************************/ <br> <br>extern DWORD   g_DllRefCount; <br> <br>/************************************************************************** <br> <br>   COleDocument::COleDocument() <br> <br>**************************************************************************/ <br> <br>COleDocument::COleDocument() <br>{ <br>OutputDebugString(TEXT("COleDocument's constructor\n")); <br> <br>m_ObjRefCount = 0; <br> <br>m_fDirty = FALSE; <br>m_fNoScribbleMode = FALSE; <br>m_pOleAdviseHolder = NULL; <br>m_pOleClientSite = NULL; <br>m_dwRegister = 0; <br>m_pOleDocView = NULL; <br>m_Color = DEFAULT_COLOR; <br>m_fCreated = FALSE; <br> <br>m_pOleObject = new COleObject(this); <br> <br>m_pDataObject = new CDataObject(this); <br> <br>m_pOleInPlaceObject = new COleInPlaceObject(this); <br> <br>m_pOleInPlaceActiveObject = new COleInPlaceActiveObject(this); <br> <br>m_pPersistStorage = new CPersistStorage(this); <br> <br>m_pPersistFile = new CPersistFile(this, m_pPersistStorage); <br> <br>m_pOleDocView = new COleDocumentView(this); <br> <br>g_DllRefCount++; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::~COleDocument() <br> <br>**************************************************************************/ <br> <br>COleDocument::~COleDocument() <br>{ <br>OutputDebugString(TEXT("COleDocument's destructor\n")); <br> <br>if(m_pOleAdviseHolder) <br>   m_pOleAdviseHolder-&gt;Release(); <br> <br>if(m_pOleClientSite) <br>   m_pOleClientSite-&gt;Release(); <br> <br>delete m_pOleDocView; <br> <br>delete m_pPersistFile; <br> <br>delete m_pPersistStorage; <br> <br>delete m_pOleInPlaceActiveObject; <br> <br>delete m_pOleInPlaceObject; <br> <br>delete m_pDataObject; <br> <br>delete m_pOleObject; <br> <br>g_DllRefCount--; <br> <br>PostQuitMessage(0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////// <br>// <br>// IUnknown Implementation <br>// <br> <br>/************************************************************************** <br> <br>   COleDocument::QueryInterface <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::QueryInterface(REFIID riid, LPVOID *ppReturn) <br>{ <br>OutputDebugString(TEXT("COleDocument::QueryInterface - ")); <br> <br>HRESULT  hr = E_NOINTERFACE; <br>*ppReturn = NULL; <br> <br>if(riid == IID_IUnknown) <br>   { <br>   *ppReturn = this; <br>   OutputDebugString(TEXT("IUnknown requested - ")); <br>   } <br>else if (riid == IID_IOleDocument) <br>   { <br>   *ppReturn = this; <br>   OutputDebugString(TEXT("IOleDocument requested - ")); <br>   } <br>else if (riid == IID_IOleDocumentView) <br>   { <br>   *ppReturn = m_pOleDocView; <br>   OutputDebugString(TEXT("IOleDocumentView requested - ")); <br>   } <br>else if (riid == IID_IOleObject) <br>   { <br>   *ppReturn = m_pOleObject; <br>   OutputDebugString(TEXT("IOleObject requested - ")); <br>   } <br>else if (riid == IID_IDataObject) <br>   { <br>   *ppReturn = m_pDataObject; <br>   OutputDebugString(TEXT("IDataObject requested - ")); <br>   } <br>else if (riid == IID_IOleInPlaceObject) <br>   { <br>   *ppReturn = m_pOleInPlaceObject; <br>   OutputDebugString(TEXT("IOleInPlaceObject requested - ")); <br>   } <br>else if (riid == IID_IOleInPlaceActiveObject) <br>   { <br>   *ppReturn = m_pOleInPlaceActiveObject; <br>   OutputDebugString(TEXT("IOleInPlaceActiveObject requested - ")); <br>   } <br>else if((riid == IID_IPersistStorage) || (riid == IID_IPersist)) <br>   { <br>   *ppReturn = m_pPersistStorage; <br>   OutputDebugString(TEXT("IPersistStorage requested - ")); <br>   } <br>else if(riid == IID_IPersistFile) <br>   { <br>   *ppReturn = m_pPersistFile; <br>   OutputDebugString(TEXT("IPersistFile requested - ")); <br>   } <br> <br>if (*ppReturn) <br>   { <br>   OutputDebugString(TEXT("Interface Found\n")); <br>   ((LPUNKNOWN)*ppReturn)-&gt;AddRef(); <br>   hr = S_OK; <br>   } <br>else <br>   { <br>   OutputDebugString(TEXT("No Interface - ")); <br> <br>   LPWSTR   pwsz; <br>   TCHAR    szString[MAX_PATH] = TEXT(""); <br>    <br>   StringFromIID(riid, &amp;pwsz); <br> <br>   if(pwsz) <br>      { <br>#ifdef UNICODE <br>      lstrcpy(szString, pwsz); <br>#else <br>      WideCharToMultiByte( CP_ACP, <br>                           0, <br>                           pwsz, <br>                           -1, <br>                           szString, <br>                           ARRAYSIZE(szString), <br>                           NULL, <br>                           NULL); <br>#endif <br>      OutputDebugString(szString); <br>      OutputDebugString(TEXT("\n")); <br> <br>      //free the string <br>      LPMALLOC pMalloc; <br>      CoGetMalloc(1, &amp;pMalloc); <br>      pMalloc-&gt;Free(pwsz); <br>      pMalloc-&gt;Release(); <br>      } <br>   } <br> <br>return hr; <br>}                                              <br> <br>/************************************************************************** <br> <br>   COleDocument::AddRef <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) COleDocument::AddRef() <br>{ <br>//OutputDebugString("COleDocument::AddRef\n"); <br>TCHAR szText[MAX_PATH]; <br>wsprintf(szText, TEXT("COleDocument::AddRef - ref count will be %d\n"), m_ObjRefCount + 1); <br>OutputDebugString(szText); <br> <br>return ++m_ObjRefCount; <br>} <br> <br> <br>/************************************************************************** <br> <br>   COleDocument::Release <br> <br>**************************************************************************/ <br> <br>STDMETHODIMP_(DWORD) COleDocument::Release() <br>{ <br>//OutputDebugString("COleDocument::Release\n"); <br>TCHAR szText[MAX_PATH]; <br>wsprintf(szText, TEXT("COleDocument::Release - ref count will be %d\n"), m_ObjRefCount - 1); <br>OutputDebugString(szText); <br> <br>if(0 == --m_ObjRefCount) <br>   { <br>   delete this; <br>   return 0; <br>   } <br>    <br>return m_ObjRefCount; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::CreateView() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::CreateView( IOleInPlaceSite *pInPlaceSite,  <br>                                       IStream *pStream,  <br>                                       DWORD dwReserved,  <br>                                       IOleDocumentView **ppOleDocumentView) <br>{ <br>OutputDebugString(TEXT("COleDocument::CreateView\n")); <br> <br>HRESULT  hr = E_FAIL; <br> <br>//NULL the view pointer <br>*ppOleDocumentView = NULL; <br> <br>//we only support one view, so fail if the view already exists <br>if(!m_fCreated) <br>   { <br>   //AddRef since we are giving away the pointer <br>   m_pOleDocView-&gt;AddRef(); <br> <br>   // if we were given a site, set this as the site for the view we just created <br>   if(pInPlaceSite)  <br>      { <br>      m_pOleDocView-&gt;SetInPlaceSite(pInPlaceSite); <br>      } <br> <br>   // if given a stream to initialize from, initialize our view state <br>   if(pStream)  <br>      { <br>      m_pOleDocView-&gt;ApplyViewState(pStream); <br>      } <br> <br>   *ppOleDocumentView = m_pOleDocView; <br> <br>   m_fCreated = TRUE; <br>    <br>   hr = S_OK; <br>   } <br>    <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::GetDocMiscStatus() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::GetDocMiscStatus(DWORD *pdwStatus) <br>{ <br>OutputDebugString(TEXT("COleDocument::GetDocMiscStatus\n")); <br> <br>if(!pdwStatus) <br>   return E_INVALIDARG; <br> <br>*pdwStatus = 0; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::EnumViews() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::EnumViews(  IEnumOleDocumentViews **ppEnum,  <br>                                       IOleDocumentView **ppView) <br>{ <br>OutputDebugString(TEXT("COleDocument::EnumViews\n")); <br> <br>*ppEnum = NULL; <br>*ppView = NULL; <br> <br>return E_NOTIMPL; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::GetWindow() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::GetWindow(HWND *phwnd) <br>{ <br>OutputDebugString(TEXT("COleDocument::GetWindow\n")); <br> <br>if(!phwnd) <br>   return E_INVALIDARG; <br> <br>*phwnd = NULL; <br> <br>if(m_pOleDocView) <br>   *phwnd = m_pOleDocView-&gt;m_hwndView; <br> <br>return S_OK; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::UIDeactivate() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::DeactivateUI() <br>{ <br>OutputDebugString(TEXT("COleInPlaceObject::DeactivateUI\n")); <br> <br>if(m_pOleDocView) <br>   return m_pOleDocView-&gt;DeactivateUI(); <br> <br>return E_FAIL; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocumentView::DeactivateInPlace() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP COleDocument::DeactivateInPlace() <br>{ <br>OutputDebugString(TEXT("COleDocument::DeactivateInPlace\n")); <br> <br>if(m_pOleDocView) <br>   return m_pOleDocView-&gt;DeactivateInPlace(); <br> <br>return E_FAIL; <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::RegisterServer <br> <br>**************************************************************************/ <br> <br>typedef struct{ <br>   HKEY  hRootKey; <br>   TCHAR szSubKey[MAX_PATH]; <br>   TCHAR szValue[MAX_PATH]; <br>}DOREGSTRUCT, *LPDOREGSTRUCT; <br> <br>BOOL COleDocument::RegisterServer(void) <br>{ <br>OutputDebugString("COleDocument::RegisterServer\n"); <br> <br>int      i; <br>HKEY     hKey; <br>LRESULT  lResult; <br>DWORD    dwDisp; <br>TCHAR    szSubKey[MAX_PATH]; <br>TCHAR    szCLSID[MAX_PATH]; <br>TCHAR    szApp[MAX_PATH]; <br>LPWSTR   pwsz; <br>CLSID    clsid; <br> <br>//get this app's CLSID in string form <br>m_pPersistStorage-&gt;GetClassID(&amp;clsid); <br>StringFromIID(clsid, &amp;pwsz); <br> <br>if(pwsz) <br>   { <br>#ifdef UNICODE <br>   lstrcpy(szCLSID, pwsz); <br>#else <br>   WideCharToMultiByte( CP_ACP, <br>                        0, <br>                        pwsz, <br>                        -1, <br>                        szCLSID, <br>                        ARRAYSIZE(szCLSID), <br>                        NULL, <br>                        NULL); <br>#endif <br> <br>   //free the string <br>   LPMALLOC pMalloc; <br>   CoGetMalloc(1, &amp;pMalloc); <br>   pMalloc-&gt;Free(pwsz); <br>   pMalloc-&gt;Release(); <br>   } <br> <br>//get this app's path and file name <br>GetModuleFileName(NULL, szApp, ARRAYSIZE(szApp)); <br> <br>//register the file extension entries <br>{ <br>DOREGSTRUCT FileEntries[] = { HKEY_CLASSES_ROOT,   TEXT("%s"),                         PROG_ID, <br>                              0,                   TEXT(""),                           TEXT("")}; <br> <br>for(i = 0; FileEntries[i].hRootKey; i++) <br>   { <br>   //create the sub key string - for this case, insert the file extension <br>   wsprintf(szSubKey, FileEntries[i].szSubKey, FILE_EXT); <br> <br>   lResult = RegCreateKeyEx(  FileEntries[i].hRootKey, <br>                              szSubKey, <br>                              0, <br>                              NULL, <br>                              REG_OPTION_NON_VOLATILE, <br>                              KEY_WRITE, <br>                              NULL, <br>                              &amp;hKey, <br>                              &amp;dwDisp); <br>    <br>   if(NOERROR == lResult) <br>      { <br>      lResult = RegSetValueEx(   hKey, <br>                                 NULL, <br>                                 0, <br>                                 REG_SZ, <br>                                 (LPBYTE)FileEntries[i].szValue, <br>                                 lstrlen(FileEntries[i].szValue) + 1); <br>       <br>      RegCloseKey(hKey); <br>      } <br>   else <br>      return FALSE; <br>   } <br>} <br> <br>{ <br>DOREGSTRUCT ProgEntries[] = { HKEY_CLASSES_ROOT,   TEXT("%s"),                         DOC_NAME, <br>                              HKEY_CLASSES_ROOT,   TEXT("%s\\CLSID"),                  TEXT("%s"), <br>                              HKEY_CLASSES_ROOT,   TEXT("%s\\DocObject"),   TEXT(""), <br>                              0,                   TEXT(""),                           TEXT("")}; <br> <br>//register the ProgID entries <br>for(i = 0; ProgEntries[i].hRootKey; i++) <br>   { <br>   //create the sub key string - for this case, insert the ProgID <br>   wsprintf(szSubKey, ProgEntries[i].szSubKey, PROG_ID); <br> <br>   lResult = RegCreateKeyEx(  ProgEntries[i].hRootKey, <br>                              szSubKey, <br>                              0, <br>                              NULL, <br>                              REG_OPTION_NON_VOLATILE, <br>                              KEY_WRITE, <br>                              NULL, <br>                              &amp;hKey, <br>                              &amp;dwDisp); <br>    <br>   if(NOERROR == lResult) <br>      { <br>      TCHAR szValue[MAX_PATH]; <br> <br>      //if necessary, create the value string <br>      wsprintf(szValue, ProgEntries[i].szValue, szCLSID); <br>    <br>      lResult = RegSetValueEx(   hKey, <br>                                 NULL, <br>                                 0, <br>                                 REG_SZ, <br>                                 (LPBYTE)szValue, <br>                                 lstrlen(szValue) + 1); <br>       <br>      RegCloseKey(hKey); <br>      } <br>   else <br>      return FALSE; <br>   } <br>} <br> <br>{ <br>DOREGSTRUCT ClsidEntries[] = {HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s"),                  DOC_NAME, <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\LocalServer32"),   TEXT("%s"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocHandler32"), TEXT("ole32.dll"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\DefaultIcon"),     TEXT("%s,0"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\DocObject"),   TEXT("0"), <br>                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\ProgID"),   PROG_ID, <br>                              0,                   TEXT(""),                           TEXT("")}; <br> <br>//register the CLSID entries <br>for(i = 0; ClsidEntries[i].hRootKey; i++) <br>   { <br>   //create the sub key string - for this case, insert the file extension <br>   wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID); <br> <br>   lResult = RegCreateKeyEx(  ClsidEntries[i].hRootKey, <br>                              szSubKey, <br>                              0, <br>                              NULL, <br>                              REG_OPTION_NON_VOLATILE, <br>                              KEY_WRITE, <br>                              NULL, <br>                              &amp;hKey, <br>                              &amp;dwDisp); <br>    <br>   if(NOERROR == lResult) <br>      { <br>      TCHAR szValue[MAX_PATH]; <br> <br>      //if necessary, create the value string <br>      wsprintf(szValue, ClsidEntries[i].szValue, szApp); <br>    <br>      lResult = RegSetValueEx(   hKey, <br>                                 NULL, <br>                                 0, <br>                                 REG_SZ, <br>                                 (LPBYTE)szValue, <br>                                 lstrlen(szValue) + 1); <br>       <br>      RegCloseKey(hKey); <br>      } <br>   else <br>      return FALSE; <br>   } <br>} <br> <br>//register the component as insertable and a document object <br>ICatRegister   *pcr; <br>HRESULT        hr = S_OK ; <br>     <br>CoInitialize(NULL); <br> <br>hr = CoCreateInstance(  CLSID_StdComponentCategoriesMgr,  <br>                        NULL,  <br>                        CLSCTX_INPROC_SERVER,  <br>                        IID_ICatRegister,  <br>                        (LPVOID*)&amp;pcr); <br> <br>if(SUCCEEDED(hr)) <br>   { <br>   CATID rgcatid[2]; <br>    <br>   rgcatid[0] = CATID_Insertable; <br>   rgcatid[1] = CATID_DocObject; <br> <br>   hr = pcr-&gt;RegisterClassImplCategories(clsid, 2, rgcatid); <br> <br>   pcr-&gt;Release(); <br>   } <br>         <br>CoUninitialize(); <br> <br>return SUCCEEDED(hr); <br>} <br> <br>/************************************************************************** <br> <br>   COleDocument::CreateFile(HWND) <br> <br>**************************************************************************/ <br> <br>BOOL COleDocument::CreateFile(HWND hwndParent) <br>{ <br>OutputDebugString("COleDocument::CreateFile(HWND)\n"); <br> <br>OPENFILENAME   ofn; <br>TCHAR          szFilter[MAX_PATH]; <br>TCHAR          szFile[MAX_PATH] = TEXT(""); <br>LPTSTR         pTemp; <br> <br>//build the filter string <br>pTemp = szFilter; <br>lstrcpy(pTemp, DOC_NAME); <br>pTemp += lstrlen(pTemp) + 1; <br>lstrcpy(pTemp, TEXT("*")); <br>lstrcat(pTemp, FILE_EXT); <br>pTemp += lstrlen(pTemp) + 1; <br>*pTemp = 0; <br> <br>ZeroMemory(&amp;ofn, sizeof(ofn)); <br>ofn.lStructSize         = sizeof(ofn); <br>ofn.hwndOwner           = hwndParent; <br>ofn.hInstance           = g_hInst; <br>ofn.lpstrFilter         = szFilter; <br>ofn.lpstrCustomFilter   = NULL; <br>ofn.nMaxCustFilter      = 0; <br>ofn.nFilterIndex        = 1; <br>ofn.lpstrFile           = szFile; <br>ofn.nMaxFile            = ARRAYSIZE(szFile); <br>ofn.lpstrFileTitle      = NULL; <br>ofn.nMaxFileTitle       = 0; <br>ofn.lpstrInitialDir     = NULL; <br>ofn.lpstrTitle          = NULL; <br>ofn.lpTemplateName      = MAKEINTRESOURCE(IDD_COLOR_DIALOG); <br>ofn.lpfnHook            = (LPOFNHOOKPROC)ColorHookProc; <br>ofn.lCustData           = (DWORD)this; <br>ofn.Flags               = OFN_EXPLORER | <br>                           OFN_OVERWRITEPROMPT | <br>                           OFN_HIDEREADONLY | <br>                           OFN_ENABLEHOOK |  <br>                           OFN_ENABLETEMPLATE | <br>                           0; <br> <br>if(GetSaveFileName(&amp;ofn)) <br>   { <br>   //if the extension isn't attached, attach it <br>   pTemp = szFile + lstrlen(szFile) - 4; <br>   if(lstrcmpi(pTemp, FILE_EXT)) <br>      { <br>      lstrcat(szFile, FILE_EXT); <br>      } <br> <br>   return CreateFile(szFile); <br>   } <br> <br>return FALSE; <br>} <br> <br> <br>/************************************************************************** <br> <br>   COleDocument::CreateFile(LPTSTR) <br> <br>**************************************************************************/ <br> <br>BOOL COleDocument::CreateFile(LPTSTR pszFile) <br>{ <br>OutputDebugString("COleDocument::CreateFile(LPTSTR)\n"); <br> <br>WCHAR szwFile[MAX_PATH]; <br> <br>#ifdef UNICODE <br>lstrcpy(szwFile, pszFile); <br>#else <br>MultiByteToWideChar( CP_ACP,  <br>                     MB_PRECOMPOSED,  <br>                     pszFile,  <br>                     -1,  <br>                     szwFile, <br>                     ARRAYSIZE(szwFile)); <br>#endif <br> <br>m_pPersistFile-&gt;Save(szwFile, FALSE); <br> <br>return TRUE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
