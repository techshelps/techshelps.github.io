<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PERFILE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context41"></a>PERFILE.CPP</h2>
<pre><code>/************************************************************************** <br>   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>   PARTICULAR PURPOSE. <br> <br>   Copyright 1997 Microsoft Corporation.  All Rights Reserved. <br>**************************************************************************/ <br> <br>/************************************************************************** <br> <br>   File:          PerFile.cpp <br>    <br>   Description:   CPersistFile implementation. <br> <br>**************************************************************************/ <br> <br>/************************************************************************** <br>   #include statements <br>**************************************************************************/ <br> <br>#include "PerFile.h" <br> <br>/************************************************************************** <br> <br>   CPersistFile::CPersistFile() <br>    <br>**************************************************************************/ <br> <br>CPersistFile::CPersistFile(COleDocument *pOleDoc, CPersistStorage *pPersistStorage) <br>{ <br>OutputDebugString(TEXT("CPersistFile's constructor\n")); <br> <br>m_pOleDoc = pOleDoc; <br>    <br>m_pPersistStorage = pPersistStorage; <br> <br>m_pStorage = NULL; <br> <br>m_pwszFile = new OLECHAR[MAX_PATH]; <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::~CPersistFile() <br>    <br>**************************************************************************/ <br> <br>CPersistFile::~CPersistFile()  <br>{ <br>OutputDebugString(TEXT("CPersistFile's destructor\n")); <br> <br>if(m_pStorage) <br>   m_pStorage-&gt;Release(); <br> <br>delete m_pwszFile; <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::QueryInterface() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::QueryInterface(REFIID riid, LPVOID *ppReturn) <br>{ <br>OutputDebugString(TEXT("CPersistFile::QueryInterface\n")); <br> <br>return m_pOleDoc-&gt;QueryInterface(riid, ppReturn); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::AddRef() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP_(ULONG) CPersistFile::AddRef() <br>{ <br>OutputDebugString(TEXT("CPersistFile::AddRef\n")); <br> <br>return m_pOleDoc-&gt;AddRef(); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::Release() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP_(ULONG) CPersistFile::Release() <br>{ <br>OutputDebugString(TEXT("CPersistFile::Release\n")); <br> <br>return m_pOleDoc-&gt;Release(); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::GetClassID() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::GetClassID(LPCLSID pClassID) <br>{ <br>OutputDebugString(TEXT("CPersistFile::GetClassID\n")); <br> <br>return m_pPersistStorage-&gt;GetClassID(pClassID); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::Save() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::Save(LPCOLESTR pwszFile, BOOL fRemember) <br>{ <br>OutputDebugString(TEXT("CPersistFile::Save\n")); <br> <br>if(!pwszFile) <br>   return E_INVALIDARG; <br> <br>HRESULT     hr; <br> <br>/* <br>Only create a new storage if we don't already have a storage or the file name  <br>has changed. <br>*/ <br>if(!m_pStorage || (0 != lstrcmpiW(pwszFile, m_pwszFile))) <br>   { <br>   //if we have a storage, release it <br>   if(m_pStorage) <br>      { <br>      m_pPersistStorage-&gt;ReleaseStreamsAndStorage(); <br>      m_pStorage-&gt;Release(); <br>      m_pStorage = NULL; <br>      *m_pwszFile = 0; <br>      } <br> <br>   //open the file as storage <br>   hr = StgCreateDocfile(  pwszFile, <br>                           STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>                           0, <br>                           &amp;m_pStorage); <br> <br>   } <br> <br> <br> <br>if(m_pStorage) <br>   { <br>   hr = m_pPersistStorage-&gt;Save(m_pStorage, FALSE); <br>   } <br> <br> <br>if(fRemember) <br>   { <br>   lstrcpyW(m_pwszFile, pwszFile); <br>   } <br>else <br>   { <br>   m_pPersistStorage-&gt;ReleaseStreamsAndStorage(); <br>   m_pStorage-&gt;Release(); <br>   m_pStorage = NULL; <br>   *m_pwszFile = 0; <br>   } <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::SaveCompleted() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::SaveCompleted(LPCOLESTR pwszFile) <br>{ <br>OutputDebugString(TEXT("CPersistFile::SaveCompleted\n")); <br> <br>return m_pPersistStorage-&gt;SaveCompleted(NULL); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::Load() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::Load(LPCOLESTR pwszFile, DWORD dwMode) <br>{ <br>OutputDebugString(TEXT("CPersistFile::Load\n")); <br> <br>HRESULT     hr; <br> <br>if(!pwszFile) <br>   return E_INVALIDARG; <br> <br>//close any existing storage we might have <br>if(m_pStorage) <br>   { <br>   m_pPersistStorage-&gt;ReleaseStreamsAndStorage(); <br>   m_pStorage-&gt;Release(); <br>   m_pStorage = NULL; <br>   *m_pwszFile = 0; <br>   } <br> <br>//open the file as storage and load it <br>hr = StgOpenStorage(    pwszFile, <br>                        NULL, <br>                        dwMode | STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE, <br>                        NULL, <br>                        0, <br>                        &amp;m_pStorage); <br> <br>if(m_pStorage) <br>   { <br>   hr = m_pPersistStorage-&gt;Load(m_pStorage); <br>   } <br>else <br>   { <br>   hr = E_FAIL; <br>   } <br> <br>if(SUCCEEDED(hr)) <br>   lstrcpyW(m_pwszFile, pwszFile); <br> <br>return hr; <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::IsDirty() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::IsDirty() <br>{ <br>OutputDebugString(TEXT("CPersistFile::IsDirty\n")); <br> <br>return m_pPersistStorage-&gt;IsDirty(); <br>} <br> <br>/************************************************************************** <br> <br>   CPersistFile::GetCurFile() <br>    <br>**************************************************************************/ <br> <br>STDMETHODIMP CPersistFile::GetCurFile(LPOLESTR *ppwszOut) <br>{ <br>OutputDebugString(TEXT("CPersistFile::GetCurFile\n")); <br> <br>HRESULT  hr = E_FAIL; <br> <br>*ppwszOut = NULL; <br> <br>LPMALLOC pMalloc; <br>CoGetMalloc(1, &amp;pMalloc); <br>if(pMalloc) <br>   { <br>   if(*m_pwszFile) <br>      { <br>      *ppwszOut = (LPOLESTR)pMalloc-&gt;Alloc(lstrlenW(m_pwszFile) + sizeof(OLECHAR)); <br>      if(*ppwszOut) <br>         { <br>         lstrcpyW(*ppwszOut, m_pwszFile); <br>         hr = S_OK; <br>         } <br>      } <br>   else <br>      { <br>      *ppwszOut = (LPOLESTR)pMalloc-&gt;Alloc(lstrlenW(DEFAULT_PROMPT) + sizeof(OLECHAR)); <br>      if(*ppwszOut) <br>         { <br>         lstrcpyW(*ppwszOut, DEFAULT_PROMPT); <br>         hr = S_FALSE; <br>         } <br>      } <br>    <br>   pMalloc-&gt;Release(); <br>   } <br> <br>return hr; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
