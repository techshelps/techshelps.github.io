<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CALLBACK.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context60"></a>CALLBACK.CPP</h2>
<pre><code>// =========================================================================== <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>// <br>// Copyright 1996 Microsoft Corporation.  All Rights Reserved. <br>// =========================================================================== <br>#include &lt;urlmon.h&gt; <br>#include &lt;wininet.h&gt; <br>#include "callback.hpp" <br> <br>#define BOUNDARY_MAXSIZE 500  <br>#define RECV_BUF_SIZE   8192 <br> <br>static char szCRLF[] = "\r\n"; <br>static char szLF[]   = "\n"; <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::CUrlmonCallback <br>// --------------------------------------------------------------------------- <br>CUrlmonCallback::CUrlmonCallback (PHTTP_REQUEST_PARAM pParam) <br>{ <br>    m_pBinding = NULL; <br>    m_pstm = NULL; <br>    m_cRef = 0; <br> <br>    m_pParam = pParam; <br> <br>    if (m_pParam-&gt;punkOuter) <br>        ((IUnknown *) m_pParam-&gt;punkOuter)-&gt;AddRef(); <br>     <br>    m_CBParam.cbStruct = sizeof(m_CBParam); <br>    m_CBParam.dwRequestCtx = m_pParam-&gt;dwRequestCtx; <br> <br>    m_dwOffset = 0; <br>    m_dwResponseCode = 0; <br>    m_pszRangeDelimiter = NULL; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::~CUrlmonCallback <br>// --------------------------------------------------------------------------- <br>CUrlmonCallback::~CUrlmonCallback() <br>{ <br>    if (m_pParam-&gt;punkOuter) <br>        ((IUnknown *) m_pParam-&gt;punkOuter)-&gt;Release(); <br>    if (m_pstm) <br>        m_pstm-&gt;Release(); <br>    if (m_pszRangeDelimiter) <br>        LocalFree ((HLOCAL) m_pszRangeDelimiter); <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::QueryInterface <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::QueryInterface(REFIID riid, void** ppv) <br>{  <br>    if(IsEqualGUID(riid,IID_IUnknown)) <br>        *ppv = (IUnknown *) (IBindStatusCallback *) this; <br>    else if (IsEqualGUID(riid,IID_IBindStatusCallback)) <br>        *ppv = (IBindStatusCallback *) this; <br>    else if (IsEqualGUID(riid, IID_IHttpNegotiate)) <br>        *ppv = (IHttpNegotiate *) this; <br>    else <br>        *ppv = NULL; <br> <br>    if (!*ppv) <br>        return E_NOINTERFACE; <br>     <br>    // Increment our reference count before we hand out our interface <br>    ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>    return S_OK; <br> <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::AddRef <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CUrlmonCallback::AddRef(void) <br>{ <br>    if (m_pParam-&gt;punkOuter) <br>        ((IUnknown *) m_pParam-&gt;punkOuter)-&gt;AddRef(); <br>    return m_cRef++; <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::Release <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP_(ULONG) CUrlmonCallback::Release(void) <br>{ <br>    if (m_pParam-&gt;punkOuter) <br>        ((IUnknown *) m_pParam-&gt;punkOuter)-&gt;Release(); <br> <br>    if (--m_cRef == 0) <br>    { <br>        delete this; <br>        return 0; <br>    } <br>    return m_cRef; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::BeginningTransaction <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP <br>CUrlmonCallback::BeginningTransaction (LPCWSTR szURL, <br>    LPCWSTR szHeaders, DWORD dwReserved, LPWSTR *ppszAdditionalHeaders) <br>{ <br>    static char szRangeHeader[] = "Range: bytes="; <br>    static char szUnlessHeader[] = "Unless-Modified-Since: "; <br> <br>    HRESULT hr = S_OK; <br>    PSTR pszHeader = NULL; <br>     <br>    // Don't add any headers if not a range request. <br>    DWORD cRanges = m_pParam-&gt;cRanges; <br>    if (!cRanges) <br>    { <br>        *ppszAdditionalHeaders = NULL; <br>        goto done; <br>    } <br> <br>    PHTTP_REQUEST_RANGE pRanges; <br>    pRanges = m_pParam-&gt;pRanges; <br> <br>    // Allocate ANSI buffer. <br>    DWORD cbHeader; <br>    cbHeader = sizeof(szRangeHeader) + 20 * cRanges + 2; <br>    if (m_pParam-&gt;pstUnlessModifiedSince) <br>       cbHeader += sizeof(szUnlessHeader) + INTERNET_RFC1123_BUFSIZE + 2; <br>    pszHeader = (PSTR) LocalAlloc (LMEM_FIXED, cbHeader); <br>    if (!pszHeader) <br>    { <br>        hr = E_OUTOFMEMORY; <br>        goto done; <br>    } <br> <br>    // Format the read range request header. <br>    UINT cchHeader; <br>    cchHeader = wsprintf (pszHeader, "%s", szRangeHeader); <br> <br>    // Add the ranges. <br>    while (cRanges--) <br>    { <br>        if (pRanges-&gt;dwSize) <br>        { <br>            // Format range, end value is inclusive. <br>            cchHeader += wsprintf (pszHeader + cchHeader, "%d-%d", <br>                pRanges-&gt;dwOffset, pRanges-&gt;dwOffset + pRanges-&gt;dwSize - 1); <br>        } <br>        else <br>        { <br>            // Format range to end of file. <br>            cchHeader += wsprintf (pszHeader + cchHeader, "%d-", <br>                pRanges-&gt;dwOffset); <br>        } <br>             <br>        pRanges++; <br>        if (cRanges) <br>           cchHeader += wsprintf (pszHeader + cchHeader, ", "); <br>        else <br>           cchHeader += wsprintf (pszHeader + cchHeader, szCRLF); <br>    } <br> <br>    if (m_pParam-&gt;pstUnlessModifiedSince) <br>    { <br>        // Add unless-modified-since qualifier. <br>        cchHeader += wsprintf (pszHeader + cchHeader, szUnlessHeader); <br>        if (!InternetTimeFromSystemTime <br>        ( <br>            m_pParam-&gt;pstUnlessModifiedSince, <br>            INTERNET_RFC1123_FORMAT, <br>            pszHeader + cchHeader, <br>            INTERNET_RFC1123_BUFSIZE <br>        )) <br>        { <br>            hr = E_FAIL; <br>            goto done; <br>        } <br>         <br>        cchHeader += lstrlen (pszHeader + cchHeader); <br>        cchHeader += wsprintf (pszHeader + cchHeader, szCRLF); <br>    } <br> <br>    cchHeader++; // for NULL termination <br> <br>    // Allocate Unicode buffer. <br>    *ppszAdditionalHeaders = (WCHAR *) CoTaskMemAlloc (sizeof(WCHAR) * cchHeader); <br>    if (*ppszAdditionalHeaders) <br>    { <br>        MultiByteToWideChar (CP_ACP, 0, pszHeader, -1, *ppszAdditionalHeaders, <br>            sizeof(WCHAR) * cchHeader); <br>    } <br> <br>    hr = *ppszAdditionalHeaders? S_OK : E_OUTOFMEMORY; <br> <br>done: <br>    if (pszHeader) <br>        LocalFree (pszHeader); <br>    return hr; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnResponse <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnResponse <br>( <br>    DWORD   dwResponseCode,  <br>    LPCWSTR szResponseHeaders, <br>    LPCWSTR szRequestHeaders, <br>    LPWSTR  *pszAdditionalRequestHeaders <br>) <br>{ <br>    // Get the HttpQueryInfo wrapper object. <br>    IWinInetHttpInfo *pHttpInfo = NULL; <br>    HRESULT hr = m_pBinding-&gt;QueryInterface <br>        (IID_IWinInetHttpInfo, (void **) &amp;pHttpInfo); <br>    if (FAILED(hr)) <br>        goto done; <br> <br>    // Save the response code. <br>    m_dwResponseCode = dwResponseCode; <br>    m_CBParam.dwResponseCode = dwResponseCode; <br> <br>    DWORD cbBuf; <br> <br>    // Check for partial response. <br>    if (dwResponseCode == 206) <br>    { <br>       // Server responded with byte ranges, ergo must support them. <br>       m_CBParam.fdwRequestFlags = HTTP_REQUEST_ACCEPT_RANGES; <br> <br>       // Look for multi-part delimiter embedded in content type. <br>       const static char szMultiPart[] = "multipart/x-byteranges; boundary"; <br>       const static DWORD cbMultiPart = sizeof(szMultiPart); <br> <br>       // Get length of buffer to hold content type. <br>       DWORD cbContentType = 0; <br>       pHttpInfo-&gt;QueryInfo <br>          (HTTP_QUERY_CONTENT_TYPE, NULL, &amp;cbContentType, NULL, 0); <br> <br>       if (cbContentType &gt; cbMultiPart + 1) <br>       { <br>            // Content type is big enough to embed a delimiter. <br>            m_pszRangeDelimiter = (PSTR) LocalAlloc (LMEM_FIXED, cbContentType); <br>            if (!m_pszRangeDelimiter) <br>            { <br>                hr = E_OUTOFMEMORY; <br>                goto done; <br>            } <br> <br>            if (S_OK != pHttpInfo-&gt;QueryInfo (HTTP_QUERY_CONTENT_TYPE, <br>                 m_pszRangeDelimiter, &amp;cbContentType, NULL, 0)) <br>            { <br>                hr = E_FAIL; <br>                goto done; <br>            }  <br>             <br>            // Split the string at the '=' <br>            m_pszRangeDelimiter[cbMultiPart - 1] = 0; <br>            if (lstrcmpi (m_pszRangeDelimiter, szMultiPart)) <br>            { <br>                // Response must not be multi-part. <br>                LocalFree ((HLOCAL) m_pszRangeDelimiter); <br>                m_pszRangeDelimiter = NULL; <br>            } <br>            else <br>            { <br>                m_cchRangeDelimiter = <br>                    lstrlen (m_pszRangeDelimiter + cbMultiPart); <br> <br>                // Shift the delimiter to offset 2 of string. <br>                MoveMemory <br>                ( <br>                  m_pszRangeDelimiter + 2, // +2 for prefix <br>                  m_pszRangeDelimiter + cbMultiPart, <br>                  m_cchRangeDelimiter + 1  // +1 for null <br>                );     <br> <br>                // Prefix delimiter with "--" <br>                m_pszRangeDelimiter[0] = '-'; <br>                m_pszRangeDelimiter[1] = '-'; <br>                m_cchRangeDelimiter += 2; <br> <br>                // Initialize range boundaries. <br>                m_dwRangeBeg = 0; <br>                m_dwRangeEnd = 0; <br>            } <br>             <br>        } // end if (cbContentType &gt; cbMultiPart + 1) <br> <br>        // Adjust the offset if we have a single range <br>        if (!m_pszRangeDelimiter) <br>            m_dwOffset = m_pParam-&gt;pRanges[0].dwOffset; <br>    } <br>     <br>    else // if (dwResponseCode != 206) <br>    { <br>        // Check if ranges are supported. <br>        static char szBytes[] = "bytes"; <br>        char szBuf[sizeof(szBytes)]; <br>        cbBuf = sizeof(szBytes); <br>        hr = pHttpInfo-&gt;QueryInfo <br>            (HTTP_QUERY_ACCEPT_RANGES, szBuf, &amp;cbBuf, NULL, 0); <br>        if (SUCCEEDED(hr) &amp;&amp; !lstrcmpi (szBytes, szBuf)) <br>            m_CBParam.fdwRequestFlags = HTTP_REQUEST_ACCEPT_RANGES; <br>        else <br>            m_CBParam.fdwRequestFlags = 0; <br>    } <br> <br>    // Get last modified time. <br>    SYSTEMTIME stLastModified; <br>    cbBuf = sizeof(stLastModified); <br>    hr = pHttpInfo-&gt;QueryInfo <br>    ( <br>        HTTP_QUERY_FLAG_SYSTEMTIME | HTTP_QUERY_LAST_MODIFIED, <br>        &amp;stLastModified, &amp;cbBuf, NULL, 0 <br>    ); <br>    if (hr != S_OK) <br>    { <br>        memset (&amp;stLastModified, 0, sizeof(stLastModified)); <br>        hr = S_OK; <br>    } <br>    m_CBParam.pstLastModified = &amp;stLastModified; <br>                 <br>    // Get content length. <br>    m_CBParam.dwContentLength = 0; <br>    if (dwResponseCode != 206) <br>    {    <br>        cbBuf = sizeof(m_CBParam.dwContentLength); <br>        hr = pHttpInfo-&gt;QueryInfo <br>        ( <br>            HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_CONTENT_LENGTH, <br>            &amp;m_CBParam.dwContentLength, &amp;cbBuf, NULL, 0 <br>        ); <br>        if (hr != S_OK) <br>        { <br>            m_CBParam.dwContentLength = 0; <br>            hr = S_OK; <br>        } <br>    } <br> <br> <br>    // Inform the client the request is started. <br>    m_CBParam.CallbackType = REQUESTCB_STARTED; <br>    if (!(*(m_pParam-&gt;pfnRequestCB)) (&amp;m_CBParam)) <br>         m_pBinding-&gt;Abort(); <br>    hr = S_OK; <br> <br>done: <br> <br>    if (pHttpInfo) <br>        pHttpInfo-&gt;Release(); <br>     <br>    return hr; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnStartBinding <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnStartBinding <br>    (DWORD grfBSCOption, IBinding* pBinding) <br>{ <br>    if (pBinding != NULL) <br>    { <br>         m_pBinding = pBinding; <br>         m_pBinding-&gt;AddRef(); <br>    } <br>     <br>    // Initialize receive buffer. <br>    if (!BufAlloc(RECV_BUF_SIZE)) <br>        return E_OUTOFMEMORY; <br>         <br>    return S_OK; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::GetPriority <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::GetPriority(LONG* pnPriority)  <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnLowResource <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnLowResource(DWORD dwReserved) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnProgress <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnProgress <br>    (ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) <br>{ <br>    return S_OK; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnStopBinding <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnStopBinding <br>    (HRESULT hrStatus, LPCWSTR pszError)  <br>{ <br>    // Release the binding, which will eventually release the callback object. <br>    m_pBinding-&gt;Release(); <br>    m_pBinding = NULL; <br> <br>    // Notify the client that we are done. <br>    m_CBParam.CallbackType = REQUESTCB_DONE; <br>    m_CBParam.hrRequest = hrStatus; <br>    (*(m_pParam-&gt;pfnRequestCB)) (&amp;m_CBParam); <br>     <br>    return S_OK; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::GetBindInfo <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::GetBindInfo <br>    (DWORD* pgrfBINDF, BINDINFO* pbindInfo) <br>{ <br>    *pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA; <br>    *pgrfBINDF |= BINDF_GETNEWESTVERSION; <br>    pbindInfo-&gt;cbSize = sizeof(BINDINFO); <br>    pbindInfo-&gt;szExtraInfo = NULL; <br>    ZeroMemory (&amp;pbindInfo-&gt;stgmedData, sizeof(STGMEDIUM)); <br>    pbindInfo-&gt;grfBindInfoF = 0; <br>    pbindInfo-&gt;dwBindVerb = BINDVERB_GET; <br>    pbindInfo-&gt;szCustomVerb = NULL; <br>    return S_OK; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnDataAvailable <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnDataAvailable <br>    (DWORD grfBSCF, DWORD dwSize, FORMATETC* pfmtetc, STGMEDIUM* pstgmed)  <br>{ <br>    if (!m_pstm &amp;&amp; pstgmed-&gt;tymed == TYMED_ISTREAM) <br>    { <br>        m_pstm = pstgmed-&gt;pstm; <br>        m_pstm-&gt;AddRef(); <br>        m_CBParam.CallbackType = REQUESTCB_DATA; <br>    } <br> <br>    // Check for multi-part response. <br>    if (m_pszRangeDelimiter) <br>       return ParseMultiPartBuffer (grfBSCF &amp; BSCF_LASTDATANOTIFICATION); <br> <br>    HRESULT hrRead; <br>    DWORD cbActual; <br> <br>    do // until hrRead != S_OK <br>    { <br>        // Read some more data. <br>        hrRead = m_pstm-&gt;Read (BufBeg(), BufSize(), &amp;cbActual); <br> <br>        // Notify the client we got some data. <br>        if (cbActual) <br>        { <br>            m_CBParam.dwDataOffset = m_dwOffset; <br>            m_CBParam.lpDataBuffer = BufBeg(); <br>            m_CBParam.cbDataLength = cbActual; <br>            if (!(*(m_pParam-&gt;pfnRequestCB)) (&amp;m_CBParam)) <br>            { <br>                 // Client wants to stop. <br>                 m_pBinding-&gt;Abort(); <br>                 return S_OK; <br>            } <br>        }    <br> <br>        m_dwOffset += cbActual; <br>         <br>    } while (hrRead == S_OK); <br> <br>    return (hrRead == S_FALSE || hrRead == E_PENDING)? S_OK : hrRead; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::OnObjectAvailable <br>// --------------------------------------------------------------------------- <br>STDMETHODIMP CUrlmonCallback::OnObjectAvailable(REFIID riid, IUnknown* punk)  <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::ParseMultiPartHeader <br>// --------------------------------------------------------------------------- <br>BOOL CUrlmonCallback::ParseMultiPartHeader (void) <br>{ <br>    // multi-part boundary string literals. <br>    static char szContentType[]  = "Content-Type: "; <br>    static char szContentRange[] = "Content-Range: bytes "; <br> <br>// Some macros for prettiness... <br>#define GrokStr(str) if (!BufScanStr (str, sizeof(str)-1)) return FALSE; <br>#define GrokInt(pint, delim) if (!BufScanInt (pint,delim)) return FALSE; <br> <br>// Check for presence of boundary. <br>    if (m_dwRangeBeg &gt; 0) // must not be first range <br>    GrokStr (szLF);   // will also detect a CR-LF <br>if (!BufScanStr (m_pszRangeDelimiter, m_cchRangeDelimiter)) <br>    return FALSE; <br> <br>// Check for end boundary. <br>if <br>(    m_pbDataBeg + 2 &lt;= m_pbDataEnd <br>&amp;&amp; m_pbDataBeg[0] == '-' <br>&amp;&amp; m_pbDataBeg[1] == '-' <br>) <br>{ <br>    m_dwRangeBeg = 0; <br>    m_dwRangeEnd = 0; <br>    return TRUE; <br>    } <br>     <br>// Scan content type and data range. <br>GrokStr (szLF); <br>GrokStr (szContentType); <br>GrokStr (szLF); <br>GrokStr (szContentRange); <br>    GrokInt (&amp;m_dwRangeBeg, '-'); <br>    GrokInt (&amp;m_dwRangeEnd, '/'); <br>    GrokStr (szLF); <br>    GrokStr (szLF); <br>     <br>    // Range end is inclusive; make it exclusive. <br>    m_dwRangeEnd++;  <br>    return TRUE; <br> <br>#undef GrokStr <br>#undef GrokInt <br>} <br> <br>// --------------------------------------------------------------------------- <br>// CUrlmonCallback::ParseMultiPartBuffer <br>// --------------------------------------------------------------------------- <br>HRESULT CUrlmonCallback::ParseMultiPartBuffer (BOOL fLastCall) <br>{ <br>    HRESULT hrRead; <br>    DWORD cbActual; <br> <br>    do // until hrRead != S_OK <br>    { <br>        // Read data and append to buffer. <br>        hrRead = m_pstm-&gt;Read(m_pbDataEnd, BufSpace(), &amp;cbActual); <br>        m_pbDataEnd += cbActual; <br> <br>        // Dispatch to current state handler. <br>        if (m_dwRangeBeg != m_dwRangeEnd) <br>            goto process_data; <br>        else <br>            goto parse_header; <br>             <br>parse_header: <br> <br>        // If download not at EOF, don't try to parse multi-part <br>        // boundary if any chance it would be split across buffers. <br>        if (hrRead != S_FALSE &amp;&amp; m_pbDataBeg &gt; m_pbDataEnd - BOUNDARY_MAXSIZE) <br>        { <br>            BufShift(); <br>            continue; <br>        } <br> <br>        // Attempt to parse the multi-part boundary. <br>        if (!ParseMultiPartHeader()) <br>            break; <br>                <br>        // Check if we got termination boundary. <br>        if (m_dwRangeBeg == m_dwRangeEnd) <br>            break; <br> <br>        goto process_data; <br> <br>process_data: <br> <br>        // Calculate amount of data to report. <br>        DWORD cbData   = m_pbDataEnd  - m_pbDataBeg; <br>        DWORD cbRange  = m_dwRangeEnd - m_dwRangeBeg; <br>        DWORD cbLength = min (cbData, cbRange); <br> <br>        if (cbLength) <br>        { <br>            // Call back the client with more data. <br>            m_CBParam.dwDataOffset = m_dwRangeBeg; <br>            m_CBParam.lpDataBuffer = m_pbDataBeg; <br>            m_CBParam.cbDataLength = cbLength; <br>            if (!(*(m_pParam-&gt;pfnRequestCB)) (&amp;m_CBParam)) <br>            { <br>                 // Client wants to stop. <br>                 m_pBinding-&gt;Abort(); <br>                 break; <br>            } <br>            m_dwRangeBeg += cbLength; <br>        } <br> <br>        // Adjust the buffer depending on next state. <br>        if (m_dwRangeBeg == m_dwRangeEnd) // (cbLength == cbRange) <br>        { <br>            // Consume the data and look for next header. <br>            m_pbDataBeg += cbLength; <br>            goto parse_header; <br>        } <br>        else <br>        { <br>            // Reset buffer and get some more data. <br>            BufReset(); <br>            continue; <br>        } <br> <br>    } while (hrRead == S_OK); <br> <br>    return (hrRead == S_FALSE || hrRead == E_PENDING)? S_OK : hrRead; <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
