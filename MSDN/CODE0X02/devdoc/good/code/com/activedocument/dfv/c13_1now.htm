<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MWCLASS.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context20"></a>MWCLASS.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       mwclass.cxx <br>// <br>//  Contents:   implementation for the main window class <br>// <br>//  Classes:    CMainWindow <br>// <br>//  Functions:  Exists <br>// <br>//  History:    6-08-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include "dfv.h" <br>#include "mwclass.h" <br>#include "about.h" <br>#include "bitmaps.h" <br>#include "strmvwr.h" <br>#include &lt;assert.h&gt; <br> <br>#define BITMAPWIDTH 16 <br>#define BITMAPHEIGHT 16 <br>#define INDENT BITMAPWIDTH <br>#define ROOTSTGSTR OLESTR(" \\ - ") <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::CMainWindow <br>// <br>//  Synopsis:   constructor <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CMainWindow::CMainWindow() <br>{ <br>    _hlb = NULL; <br>    _hbmpStorage = _hbmpStream = NULL; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::~CMainWindow <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//  Notes:      Destruction of the main window indicates that the app should <br>//              quit. <br>// <br>//---------------------------------------------------------------------------- <br> <br>CMainWindow::~CMainWindow() <br>{ <br>    DeleteObject(_hbmpStorage); <br>    DeleteObject(_hbmpStream); <br>    PostQuitMessage(0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::InitInstance <br>// <br>//  Synopsis:   Instantiates an instance of the docfile viewer window. <br>// <br>//  Arguments:  [hInstance] - instance of the app <br>//              [nCmdShow]  - command to pass to ShowWindow <br>// <br>//  Returns:    TRUE on success <br>//              FALSE on failure <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//  Notes:      This method must be called only once, immediately after <br>//              class construction. <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CMainWindow::InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    // Note, the Create method sets the _hwnd member for me so I don't <br>    // need to set it myself. <br>    if (!Create( <br>        TEXT(MAIN_WINDOW_CLASS_NAME), <br>        TEXT(VER_INTERNALNAME_STR), <br>        WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX <br>            | WS_MAXIMIZEBOX | WS_THICKFRAME, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance)) <br>    { <br>        return(FALSE); <br>    } <br> <br>    ShowWindow(_hwnd, nCmdShow); <br>    UpdateWindow(_hwnd); <br> <br>    // build a path to where the help file should be <br>    // (it should be in the same directory as the .EXE) <br>    // first get the exe's path <br>    DWORD cch = GetModuleFileName(hInstance, _szHelpFile, MAX_PATH); <br>    // then back up past the name of the application <br>    while (cch &gt; 0 &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT('\\') &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT('/') &amp;&amp; <br>        _szHelpFile[cch - 1] != TEXT(':')) <br>    { <br>        cch--; <br>    } <br>    // finally copy the help file's name at the end of the path <br>    lstrcpy(&amp;_szHelpFile[cch], TEXT(HELPFILE_STR)); <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::WindowProc <br>// <br>//  Synopsis:   main window procedure <br>// <br>//  Arguments:  [uMsg]   - Windows message <br>//              [wParam] - first message parameter <br>//              [lParam] - second message parameter <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//  Notes:      See CHlprWindow for a description of how this method gets <br>//              called by the global WinProc. <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CMainWindow::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_CREATE: <br>        { <br>            RECT rc; <br>            GetClientRect(_hwnd, &amp;rc); <br>            // record the width before we create the list box <br>            _wWidth = (WORD) rc.right; <br> <br>            HDC hdc = GetDC(_hwnd); <br>            GetTextMetrics(hdc, &amp;_tm); <br>            ReleaseDC(_hwnd, hdc); <br> <br>            // create the child listbox <br>            _hlb = CreateWindow( <br>                TEXT("listbox"), <br>                TEXT(""), <br>                LBS_OWNERDRAWFIXED | <br>                    WS_CHILD | <br>                    WS_VISIBLE | <br>                    WS_VSCROLL | <br>                    LBS_NOTIFY | <br>                    LBS_NOINTEGRALHEIGHT | <br>                    LBS_WANTKEYBOARDINPUT, <br>                0, <br>                0, <br>                rc.right, <br>                rc.bottom, <br>                _hwnd, <br>                (HMENU) IDC_LISTBOX, <br>                _hInstance, <br>                NULL); <br>            if (NULL == _hlb) <br>            { <br>                // abort window creation <br>                return(-1); <br>            } <br>            SetFocus(_hlb); <br> <br>            if (!LoadBitmaps()) <br>            { <br>                MessageBoxFromStringIds( <br>                    _hwnd, <br>                    _hInstance, <br>                    IDS_LOADBITMAPSFAILED, <br>                    IDS_ERROR, <br>                    MB_OK | MB_ICONEXCLAMATION); <br>                return(-1); <br>            } <br>            _crTextHigh = GetSysColor(COLOR_HIGHLIGHTTEXT); <br>            _crTextNorm = GetSysColor(COLOR_WINDOWTEXT); <br>            _crBkHigh = GetSysColor(COLOR_HIGHLIGHT); <br>            _crBkNorm = GetSysColor(COLOR_WINDOW); <br> <br>            // Fill in the File's OPENFILENAME structure <br>            _szFileName[0] = 0; <br>            _szFileTitle[0] = 0; <br>            _ofnFile.lStructSize = sizeof(OPENFILENAME); <br>            _ofnFile.hwndOwner = _hwnd; <br>            _ofnFile.lpstrFilter = TEXT("All Files (*.*)\0*.*\0Doc Files (*.DFL;*.OL?)\0*.DFL;*.OL;\0"); <br>            _ofnFile.lpstrCustomFilter = NULL; <br>            _ofnFile.nMaxCustFilter = 0; <br>            _ofnFile.nFilterIndex = 1; <br>            _ofnFile.lpstrFile = _szFileName; <br>            _ofnFile.nMaxFile = MAX_PATH; <br>            _ofnFile.lpstrInitialDir = NULL; <br>            _ofnFile.lpstrFileTitle = _szFileTitle; <br>            _ofnFile.nMaxFileTitle = MAX_PATH; <br>            _ofnFile.lpstrTitle = TEXT("Open DocFile"); <br>            _ofnFile.lpstrDefExt = NULL; <br>            _ofnFile.Flags = OFN_HIDEREADONLY; <br>        } <br>        break; <br>    case WM_SETFOCUS: <br>        { <br>            if (_hlb) <br>            { <br>                SetFocus(_hlb); <br>            } <br>        break; <br>        } <br>    case WM_MEASUREITEM: <br>        { <br>            LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam; <br>            if (BITMAPHEIGHT &lt; _tm.tmHeight + _tm.tmExternalLeading) <br>            { <br>                lpmis-&gt;itemHeight = _tm.tmHeight + _tm.tmExternalLeading; <br>            } <br>            else <br>            { <br>                lpmis-&gt;itemHeight = BITMAPHEIGHT; <br>            } <br>            lpmis-&gt;itemWidth = _wWidth; <br>            return(TRUE); <br>        } <br>    case WM_DELETEITEM: <br>        if (IDC_LISTBOX == wParam) <br>        { <br>            DeleteElement((LISTBOXELEMENT *)((LPDELETEITEMSTRUCT)lParam)-&gt;itemData); <br>        } <br>        break; <br>    case WM_DRAWITEM: <br>        { <br>            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam; <br>            if (-1 == lpdis-&gt;itemID) <br>            { <br>                // no items in the listbox <br>                break; <br>            } <br>            // draw the item <br>            switch (lpdis-&gt;itemAction) <br>            { <br>            case ODA_SELECT: <br>            case ODA_DRAWENTIRE: <br>                { <br>                    // draw the listbox item <br> <br>                    LISTBOXELEMENT * plbe = (LISTBOXELEMENT *) lpdis-&gt;itemData; <br>                    assert(plbe); <br> <br>                    // compute the starting point <br>                    int x = lpdis-&gt;rcItem.left + plbe-&gt;uIndent * INDENT; <br>                    int y = lpdis-&gt;rcItem.top; <br> <br>                    // paint the bitmap <br>                    HDC hMemDC = CreateCompatibleDC(lpdis-&gt;hDC); <br>                    HBITMAP hbmp; <br>                    switch (plbe-&gt;uType) <br>                    { <br>                    case LBE_STORAGE: <br>                        hbmp = _hbmpStorage; <br>                        break; <br>                    case LBE_STREAM: <br>                        hbmp = _hbmpStream; <br>                        break; <br>                    default: <br>                        assert(!"Unsupported type"); <br>                        hbmp = _hbmpStream; <br>                        break; <br>                    } <br>                    HBITMAP hbmpOld = (HBITMAP) SelectObject(hMemDC, hbmp); <br>                    int nBitmap = ((lpdis-&gt;itemState &amp; ODS_SELECTED) ? 0 : 2) + <br>                        plbe-&gt;fOpen; <br>                    BitBlt( <br>                        lpdis-&gt;hDC, <br>                        x, <br>                        y, <br>                        BITMAPWIDTH, <br>                        _cyBitmap, <br>                        hMemDC, <br>                        nBitmap * BITMAPWIDTH, 0, SRCCOPY); <br>                    SelectObject(hMemDC, hbmpOld); <br>                    DeleteDC(hMemDC); <br>                    x += BITMAPWIDTH; <br> <br>                    // paint the text <br>                    SIZE sizeText; <br>                    RECT rcItem = lpdis-&gt;rcItem; <br>                    rcItem.left = x; <br> <br>                    // Note that pwcsName is an OLEStr and <br>                    // is therefore always wide under WIN32. <br>                    GetTextExtentPoint32W( <br>                        lpdis-&gt;hDC, <br>                        plbe-&gt;pwcsName, <br>                        wcslen(plbe-&gt;pwcsName), <br>                        &amp;sizeText); <br>                    rcItem.right = x + sizeText.cx; <br>                    COLORREF crOldText = SetTextColor( <br>                        lpdis-&gt;hDC, <br>                        (lpdis-&gt;itemState &amp; ODS_SELECTED) ? _crTextHigh : _crTextNorm); <br>                    COLORREF crOldBack = SetBkColor( <br>                        lpdis-&gt;hDC, <br>                        (lpdis-&gt;itemState &amp; ODS_SELECTED) ? _crBkHigh : _crBkNorm); <br>                    ExtTextOutW( <br>                        lpdis-&gt;hDC, <br>                        x, <br>                        y, <br>                        ETO_OPAQUE | ETO_CLIPPED, <br>                        &amp;rcItem, <br>                        plbe-&gt;pwcsName, <br>                        wcslen(plbe-&gt;pwcsName), <br>                        NULL); <br>                    SetTextColor(lpdis-&gt;hDC, crOldText); <br>                    SetBkColor(lpdis-&gt;hDC, crOldBack); <br>                } <br>                break; <br>            case ODA_FOCUS: <br>                break; <br>            } <br>            return(TRUE); <br>        } <br>    case WM_VKEYTOITEM: <br>        if ((HWND)lParam == _hlb) <br>        { <br>            if (LOWORD(wParam) == VK_RETURN) <br>            { <br>                if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>                { <br>                    Toggle(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>                    InvalidateRect(_hlb, NULL, FALSE); <br>                } <br>                return(-2); <br>            } <br>            return(-1); <br>        } <br>        break; <br>    case WM_SIZE: <br>        { <br>            _wWidth = LOWORD(lParam); <br>            WORD wHeight = HIWORD(lParam); <br>            if (_hlb) <br>            { <br>                SetWindowPos(_hlb, NULL, 0, 0, _wWidth, wHeight, SWP_NOMOVE | SWP_NOZORDER); <br>            } <br>            break; <br>        } <br>    case WM_COMMAND: <br>        if ((LOWORD(wParam) == IDC_LISTBOX) &amp;&amp; ((HWND) lParam == _hlb)) <br>        { <br>            switch (HIWORD(wParam)) <br>            { <br>                case LBN_DBLCLK: <br>                    { <br>                        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>                        { <br>                            Toggle(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>                            InvalidateRect(_hlb, NULL, FALSE); <br>                        } <br>                    } <br>                    break; <br>                default: <br>                    break; <br>            } <br>        } <br>        return DoMenu(wParam, lParam); <br>    case WM_QUIT: <br>    case WM_CLOSE: <br>    default: <br>        return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>    } <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::DoMenu <br>// <br>//  Synopsis:   implements the main menu commands <br>// <br>//  Arguments:  [wParam] - first window parameter <br>//              [lParam] - second window parameter <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CMainWindow::DoMenu(WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (LOWORD(wParam)) <br>    { <br>    case IDM_OPEN: <br>        if (!GetOpenFileName((LPOPENFILENAME)&amp;_ofnFile)) <br>        { <br>            return(FALSE); <br>        } <br>        OpenFile(); <br>        break; <br>    case IDM_CLOSE: <br>        SendMessage(_hlb, LB_RESETCONTENT, 0, 0); <br>        break; <br>    case IDM_EXPAND: <br>        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            Expand(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>        break; <br>    case IDM_EXPANDBRANCH: <br>        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            ExpandAll(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>        break; <br>    case IDM_EXPANDALL: <br>        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            ExpandAll(0); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>        break; <br>    case IDM_COLLAPSE: <br>        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            Collapse(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>        break; <br>    case IDM_COLLAPSEALL: <br>        if(SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            Collapse(0); <br>            SendMessage(_hlb, LB_SETCURSEL, 0, 0); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>        break; <br>    case IDM_TOGGLE: <br>        if (SendMessage(_hlb, LB_GETCOUNT, 0, 0)) <br>        { <br>            Toggle(SendMessage(_hlb, LB_GETCURSEL, 0, 0)); <br>            InvalidateRect(_hlb, NULL, FALSE); <br>        } <br>    case IDM_EXIT: <br>        SendMessage(_hwnd, WM_CLOSE, 0, 0); <br>        break; <br>    case IDM_HELP: <br>        if (!Exists(_szHelpFile)) <br>        { <br>            MessageBoxFromStringIds( <br>                _hwnd, <br>                _hInstance, <br>                IDS_NOHELPFILE, <br>                IDS_ERROR, <br>                MB_OK | MB_ICONEXCLAMATION); <br>        } <br>        else <br>        { <br>            WinHelp(_hwnd, _szHelpFile, HELP_CONTEXT, 3); <br>        } <br>        break; <br>    case IDM_ABOUT: <br>        { <br>            CAbout dlgAbout; <br>            dlgAbout.ShowDialog(_hInstance, MAKEINTRESOURCE(IDM_ABOUT), _hwnd); <br>        } <br>        break; <br>    default: <br>        return(DefWindowProc(_hwnd, WM_COMMAND, wParam, lParam)); <br>    } <br>    return(FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::Expand <br>// <br>//  Synopsis:   Expands a level of the tree. <br>// <br>//  Arguments:  [lIndex] - index of the item that needs to be expanded <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::Expand(long lIndex) <br>{ <br>    LISTBOXELEMENT * pElement = (LISTBOXELEMENT *) SendMessage(_hlb, LB_GETITEMDATA, lIndex, 0); <br>    if (pElement-&gt;fOpen) <br>    { <br>        // this element has already been expanded <br>        return; <br>    } <br>    SendMessage(_hlb, WM_SETREDRAW, FALSE, 0); <br>    switch (pElement-&gt;uType) <br>    { <br>    case LBE_STORAGE: <br>        { <br>            // create entries for all of its children <br>            IStorage * pstg = (IStorage *) pElement-&gt;pInterface; <br>            IEnumSTATSTG * penumStatStg; <br>            STATSTG statstg; <br>            HRESULT hr = pstg-&gt;EnumElements(0, NULL, 0, &amp;penumStatStg); <br>            if (SUCCEEDED(hr)) <br>            { <br>                pElement-&gt;fOpen = TRUE; <br>                pElement-&gt;nChildren = 0; <br>                while (hr != S_FALSE) <br>                { <br>                    hr = penumStatStg-&gt;Next(1, &amp;statstg, NULL); <br>                    if (FAILED(hr)) <br>                    { <br>                        MessageBoxFromStringIdsAndArgs( <br>                            _hwnd, <br>                            _hInstance, <br>                            IDS_ENUMSTATSTGFAILED, <br>                            IDS_ERROR, <br>                            MB_OK | MB_ICONEXCLAMATION, <br>                            hr); <br>                    } <br>                    else if (S_OK == hr) <br>                    { <br>                        // retrieved another member from the list <br>                        LISTBOXELEMENT * plbe; <br>                        switch (statstg.type) <br>                        { <br>                        case STGTY_STORAGE: <br>                            { <br>                                IStorage * pstg2; <br>                                hr = pstg-&gt;OpenStorage( <br>                                    statstg.pwcsName, <br>                                    NULL, <br>                                    STGM_READ | STGM_SHARE_EXCLUSIVE, <br>                                    NULL, <br>                                    0, <br>                                    &amp;pstg2); <br>                                if (SUCCEEDED(hr)) <br>                                { <br>                                    plbe = CreateStorageElement(pstg2); <br>                                } <br>                                else <br>                                { <br>                                    MessageBoxFromStringIdsAndArgs( <br>                                        _hwnd, <br>                                        _hInstance, <br>                                        IDS_OPENSTORAGEFAILED, <br>                                        IDS_ERROR, <br>                                        MB_OK | MB_ICONEXCLAMATION, <br>                                        hr); <br>                                    plbe = NULL; <br>                                } <br>                            } <br>                            break; <br>                        case STGTY_STREAM: <br>                            { <br>                                IStream * pstm; <br>                                hr = pstg-&gt;OpenStream( <br>                                    statstg.pwcsName, <br>                                    0, <br>                                    STGM_READ | STGM_SHARE_EXCLUSIVE, <br>                                    0, <br>                                    &amp;pstm); <br>                                if (SUCCEEDED(hr)) <br>                                { <br>                                    plbe = CreateStreamElement(pstm); <br>                                } <br>                                else <br>                                { <br>                                    MessageBoxFromStringIdsAndArgs( <br>                                        _hwnd, <br>                                        _hInstance, <br>                                        IDS_OPENSTREAMFAILED, <br>                                        IDS_ERROR, <br>                                        MB_OK | MB_ICONEXCLAMATION, <br>                                        hr); <br>                                    plbe = NULL; <br>                                } <br>                            } <br>                            break; <br>                        } <br>                        if (plbe) <br>                        { <br>                            plbe-&gt;pwcsName = statstg.pwcsName; <br>                            plbe-&gt;uIndent = pElement-&gt;uIndent + 1; <br>                            pElement-&gt;nChildren++; <br>                            if (SendMessage(_hlb, LB_INSERTSTRING, lIndex + pElement-&gt;nChildren, (LPARAM) plbe) == LB_ERRSPACE) <br>                            { <br>                                MessageBoxFromStringIds( <br>                                    _hwnd, <br>                                    _hInstance, <br>                                    IDS_INSERTSTRINGFAILED, <br>                                    IDS_ERROR, <br>                                    MB_OK | MB_ICONEXCLAMATION); <br>                                DeleteElement(plbe); <br>                                pElement-&gt;nChildren--; <br>                            } <br>                        } <br>                    } <br>                } <br>                penumStatStg-&gt;Release(); <br>            } <br>            else <br>            { <br>                MessageBoxFromStringIdsAndArgs( <br>                    _hwnd, <br>                    _hInstance, <br>                    IDS_ENUMELEMENTSFAILED, <br>                    IDS_ERROR, <br>                    MB_OK | MB_ICONEXCLAMATION, <br>                    hr); <br>            } <br>        } <br>        break; <br>    case LBE_STREAM: <br>        // streams are only expanded if they are the currently selected list item <br>        if (SendMessage(_hlb, LB_GETCURSEL, 0, 0) == lIndex) <br>        { <br>            // open stream <br>            CStreamView * psv = new CStreamView(_hlb, pElement); <br>            if (psv) <br>            { <br>                pElement-&gt;fOpen = psv-&gt;InitInstance(_hInstance, SW_SHOWNORMAL); <br>                if (pElement-&gt;fOpen) <br>                { <br>                    pElement-&gt;hwndView = psv-&gt;GetHwnd(); <br>                    SetFocus(pElement-&gt;hwndView); <br>                } <br>            } <br>        } <br>        break; <br>    } <br>    SendMessage(_hlb, WM_SETREDRAW, TRUE, 0); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::Collapse <br>// <br>//  Synopsis:   collapses a level of the tree <br>// <br>//  Arguments:  [lIndex] - index of the item to be collapsed <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::Collapse(long lIndex) <br>{ <br>    LISTBOXELEMENT * pElement = (LISTBOXELEMENT *) SendMessage(_hlb, LB_GETITEMDATA, lIndex, 0); <br>    if (pElement-&gt;fOpen) <br>    { <br>        switch (pElement-&gt;uType) <br>        { <br>        case LBE_STORAGE: <br>            while (pElement-&gt;nChildren--) <br>            { <br>                Collapse(lIndex + 1); <br>                SendMessage(_hlb, LB_DELETESTRING, lIndex + 1, 0); <br>            } <br>            break; <br>        case LBE_STREAM: <br>            if (pElement-&gt;fOpen) <br>            { <br>                DestroyWindow(pElement-&gt;hwndView); <br>            } <br>            break; <br>        } <br>        pElement-&gt;fOpen = FALSE; <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::ExpandAll <br>// <br>//  Synopsis:   expands the current item and all its children <br>// <br>//  Arguments:  [lIndex] - index of the item to be expanded <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::ExpandAll(long lIndex) <br>{ <br>    LISTBOXELEMENT * pElement = (LISTBOXELEMENT *) SendMessage(_hlb, LB_GETITEMDATA, lIndex, 0); <br>    Expand(lIndex); <br>    if (pElement-&gt;uType == LBE_STORAGE) <br>    { <br>        unsigned nChildren = pElement-&gt;nChildren; <br>        while (nChildren--) <br>        { <br>            ExpandAll(lIndex + 1 + nChildren); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::Toggle <br>// <br>//  Synopsis:   toggles a node - expanding or collapsing as appropriate <br>// <br>//  Arguments:  [lIndex] - index of the node <br>// <br>//  History:    6-25-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::Toggle(long lIndex) <br>{ <br>    LISTBOXELEMENT * pElement = (LISTBOXELEMENT *) SendMessage(_hlb, LB_GETITEMDATA, lIndex, 0); <br>    if (pElement-&gt;fOpen) <br>    { <br>        Collapse(lIndex); <br>    } <br>    else <br>    { <br>        Expand(lIndex); <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::CreateStreamElement <br>// <br>//  Synopsis:   turns an IStream pointer into a listbox element <br>// <br>//  Arguments:  [pstm] - IStream pointer <br>// <br>//  Returns:    pointer to the newly created element <br>//              (NULL on failure) <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LISTBOXELEMENT * CMainWindow::CreateStreamElement(IStream * pstm) <br>{ <br>    LISTBOXELEMENT * plbe = new LISTBOXELEMENT; <br>    if (plbe) <br>    { <br>        plbe-&gt;uType = LBE_STREAM; <br>        plbe-&gt;fOpen = FALSE; <br>        plbe-&gt;pInterface = (void *) pstm; <br>        plbe-&gt;uIndent = 0; <br>        plbe-&gt;hwndView = NULL; <br>    } <br>    else <br>    { <br>        MessageBoxFromStringIds( <br>            _hwnd, <br>            _hInstance, <br>            IDS_OUTOFMEMORY, <br>            IDS_ERROR, <br>            MB_OK | MB_ICONEXCLAMATION); <br>    } <br>    return(plbe); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::CreateStorageElement <br>// <br>//  Synopsis:   turns an IStorage pointer into a listbox element <br>// <br>//  Arguments:  [pstg] - IStorage pointer <br>// <br>//  Returns:    pointer to the newly created element <br>//              (NULL on failure) <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LISTBOXELEMENT * CMainWindow::CreateStorageElement(IStorage * pstg) <br>{ <br>    LISTBOXELEMENT * plbe = new LISTBOXELEMENT; <br>    if (plbe) <br>    { <br>        plbe-&gt;uType = LBE_STORAGE; <br>        plbe-&gt;fOpen = FALSE; <br>        plbe-&gt;pInterface = (void *) pstg; <br>        plbe-&gt;uIndent = 0; <br>        plbe-&gt;nChildren = 0; <br>    } <br>    else <br>    { <br>        MessageBoxFromStringIds( <br>            _hwnd, <br>            _hInstance, <br>            IDS_OUTOFMEMORY, <br>            IDS_ERROR, <br>            MB_OK | MB_ICONEXCLAMATION); <br>    } <br>    return(plbe); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::DeleteElement <br>// <br>//  Synopsis:   deletes a listbox element and it's associated data <br>// <br>//  Arguments:  [plbe] - pointer to the element <br>// <br>//  History:    6-23-94   stevebl   Created <br>// <br>//  Notes:      This doesn't remove it from the list, it just frees up <br>//              the LISTBOXELEMENT pointer and it's data. <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::DeleteElement(LISTBOXELEMENT * plbe) <br>{ <br> <br>    switch (plbe-&gt;uType) <br>    { <br>    case LBE_STORAGE: <br>        ((IStorage *) plbe-&gt;pInterface)-&gt;Release(); <br>        break; <br>    case LBE_STREAM: <br>        if (plbe-&gt;fOpen) <br>        { <br>            DestroyWindow(plbe-&gt;hwndView); <br>        } <br>        ((IStream *) plbe-&gt;pInterface)-&gt;Release(); <br>        break; <br>    } <br>    LPMALLOC pMalloc; <br>    CoGetMalloc(MEMCTX_TASK, &amp;pMalloc); <br>    pMalloc-&gt;Free(plbe-&gt;pwcsName); <br>    pMalloc-&gt;Release(); <br>    delete(plbe); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::LoadBitmaps <br>// <br>//  Synopsis:   loads the Storage and Stream bitmap arrays <br>// <br>//  Returns:    TRUE on success <br>//              FALSE on failure <br>// <br>//  Modifies:   _hbmpStorage and _hbmpStream <br>// <br>//  History:    6-24-94   stevebl   Created from code used in original DFView <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CMainWindow::LoadBitmaps(void) <br>{ <br>    // <br>    // Get some metrics/info <br>    // <br>    UINT cxBitmap = BITMAPWIDTH; <br>    _cyBitmap = BITMAPHEIGHT; <br>    if (_cyBitmap &lt; (UINT) _tm.tmHeight + _tm.tmExternalLeading) <br>    { <br>        _cyBitmap = _tm.tmHeight + _tm.tmExternalLeading; <br>    } <br>    UINT crHigh   = (COLORREF) GetSysColor(COLOR_HIGHLIGHT); <br>    UINT crNorm   = (COLORREF) GetSysColor(COLOR_WINDOW); <br> <br>    HDC hdc = CreateCompatibleDC(NULL); <br>    if (!hdc) <br>    { <br>        goto ERRLOADBITMAP; <br>    } <br>    _hbmpStorage = CreateBitmap( <br>        4 * cxBitmap, <br>        _cyBitmap, <br>        GetDeviceCaps(hdc, PLANES), <br>        GetDeviceCaps(hdc, BITSPIXEL), <br>        NULL); <br>    _hbmpStream = CreateBitmap( <br>        4 * cxBitmap, <br>        _cyBitmap, <br>        GetDeviceCaps(hdc, PLANES), <br>        GetDeviceCaps (hdc, BITSPIXEL), <br>        NULL); <br>   DeleteDC(hdc); <br>   if (!_hbmpStorage || !_hbmpStream) <br>   { <br>        goto ERRLOADBITMAP; <br>   } <br> <br>    // <br>    //  Load our bitmaps, and munge them to create <br>    //  our 4-bitmap "arrays".  Anything RED in the loaded <br>    //  bitmap will be considered clear. <br>    // <br>    if (!LoadAndStretch( <br>        _hInstance, <br>        _hbmpStorage, <br>        MAKEINTRESOURCE(BMP_STORAGE), <br>        cxBitmap, <br>        _cyBitmap, </code></pre>
<p>
</p>
<pre><code>crHigh, <br>        crNorm)) <br>    { <br>        goto ERRLOADBITMAP; <br>    } <br>    if (!LoadAndStretch( <br>        _hInstance, <br>        _hbmpStream, <br>        MAKEINTRESOURCE(BMP_STREAM), <br>        cxBitmap, <br>        _cyBitmap, <br>        crHigh, <br>        crNorm)) <br>    { <br>        goto ERRLOADBITMAP; <br>    } <br>    return TRUE; <br> <br>ERRLOADBITMAP: <br>    // <br>    // Bitmap loading error. <br>    // <br>    DeleteObject(_hbmpStorage); <br>    DeleteObject(_hbmpStream); <br>    _hbmpStorage = NULL; <br>    _hbmpStream = NULL; <br> <br>    return FALSE; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CMainWindow::OpenFile <br>// <br>//  Synopsis:   attempts to open whatever docfile is named by _szFileName; <br>// <br>//  History:    6-24-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>void CMainWindow::OpenFile(void) <br>{ <br>    SendMessage(_hlb, LB_RESETCONTENT, 0, 0); <br>    IStorage * pstg; <br>#ifndef UNICODE <br>    // convert file name to a wide string <br>    OLECHAR wszFileName[MAX_PATH]; <br>    mbstowcs(wszFileName, _szFileName, MAX_PATH); <br>#endif <br>    // get IStorage <br>    HRESULT hr = StgOpenStorage( <br>#ifdef UNICODE <br>        _szFileName, <br>#else <br>        wszFileName, <br>#endif <br>        NULL, <br>        STGM_TRANSACTED | STGM_READ | STGM_SHARE_DENY_WRITE, <br>        NULL, <br>        0, <br>        &amp;pstg); <br>    if (FAILED(hr)) <br>    { <br>        MessageBoxFromStringIdsAndArgs( <br>            _hwnd, <br>            _hInstance, <br>            IDS_STGOPENSTORAGEFAILED, <br>            IDS_ERROR, <br>            MB_OK | MB_ICONEXCLAMATION, <br>#ifdef UNICODE <br>            _szFileName <br>#else <br>            wszFileName <br>#endif <br>            ); <br>        return; <br>    } <br>    // Storage was opened successfully. <br>    LISTBOXELEMENT * plbe = CreateStorageElement(pstg); <br>    if (plbe) <br>    { <br>        IMalloc * pMalloc; <br>        CoGetMalloc(MEMCTX_TASK, &amp;pMalloc); <br>        plbe-&gt;pwcsName = (LPOLESTR) pMalloc-&gt;Alloc(sizeof(OLECHAR) *  (lstrlen(_szFileName) + wcslen(ROOTSTGSTR) + 1)); <br>        pMalloc-&gt;Release(); <br>        if (plbe-&gt;pwcsName) <br>        { <br>            wcscpy(plbe-&gt;pwcsName, ROOTSTGSTR); <br>#ifdef UNICODE <br>            wcscpy(&amp;plbe-&gt;pwcsName[wcslen(ROOTSTGSTR)], _szFileName); <br>#else <br>            mbstowcs(&amp;plbe-&gt;pwcsName[wcslen(ROOTSTGSTR)], _szFileName, strlen(_szFileName) + 1); <br>#endif <br>        } <br>        if (SendMessage(_hlb, LB_INSERTSTRING, 0, (LPARAM) plbe) == LB_ERRSPACE) <br>        { <br>            MessageBoxFromStringIds( <br>                _hwnd, <br>                _hInstance, <br>                IDS_INSERTSTRINGFAILED, <br>                IDS_ERROR, <br>                MB_OK | MB_ICONEXCLAMATION); <br>            DeleteElement(plbe); <br>        } <br>        else <br>        { <br>            SendMessage(_hlb, LB_SETCURSEL, 0, 0); <br>        } <br>    } <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Function:   Exists <br>// <br>//  Synopsis:   simple function to test for the existance of a file <br>// <br>//  History:    6-16-93   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>int Exists(TCHAR *sz) <br>{ <br>    HANDLE h; <br>    h = CreateFile(sz, <br>        GENERIC_READ, <br>        FILE_SHARE_READ | FILE_SHARE_WRITE, <br>        NULL, <br>        OPEN_EXISTING, <br>        0, <br>        0); <br>    if (h != INVALID_HANDLE_VALUE) <br>    { <br>        CloseHandle(h); <br>        return(1); <br>    } <br>    return (0); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
