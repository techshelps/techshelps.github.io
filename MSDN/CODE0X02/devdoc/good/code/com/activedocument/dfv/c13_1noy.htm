<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STRMVWR.CXX</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context22"></a>STRMVWR.CXX</h2>
<pre><code>//+--------------------------------------------------------------------------- <br>// <br>//  Microsoft Windows <br>//  Copyright 1992 - 1998 Microsoft Corporation. <br>// <br>//  File:       stmvwr.cxx <br>// <br>//  Contents:   implementation for the stream viewer window class <br>// <br>//  Classes:    CStreamView <br>// <br>//  Functions: <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>#include &lt;windows.h&gt; <br>#include &lt;ole2.h&gt; <br>#include "strmvwr.h" <br> <br>#define BYTESPERLINE 16 <br>#define DIVISIONPOINTS 8 <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CStreamView::CStreamView <br>// <br>//  Synopsis:   constructor <br>// <br>//  Arguments:  [hlb]    - handle to CMainWindow's listbox <br>//              [ple]    - pointer to the LISTBOXELEMENT structure for this <br>//                         stream <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CStreamView::CStreamView(HWND hlb, LISTBOXELEMENT * ple) <br>{ <br>    _hlbParent = hlb; <br>    _ple = ple; <br>    _hfListBox = NULL; <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CStreamView::~CStreamView <br>// <br>//  Synopsis:   destructor <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>CStreamView::~CStreamView() <br>{ <br>    _ple-&gt;fOpen = FALSE; <br>    if (_hfListBox) <br>    { <br>        DeleteObject(_hfListBox); <br>    } <br>    InvalidateRect(_hlbParent, NULL, FALSE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CStreamView::InitInstance <br>// <br>//  Synopsis:   creates and shows the stream viewer window <br>// <br>//  Arguments:  [hInstance] - the application's instance handle <br>//              [nCmdShow]  - command to pass to ShowWindow <br>// <br>//  Returns:    TRUE on success <br>//              FALSE on failure <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//  Notes:      must only be called once immediately after class construction <br>// <br>//---------------------------------------------------------------------------- <br> <br>BOOL CStreamView::InitInstance(HINSTANCE hInstance, int nCmdShow) <br>{ <br>    IStream * pstm = (IStream * ) _ple-&gt;pInterface; <br>    STATSTG statstg; <br>    HRESULT hr = pstm-&gt;Stat(&amp;statstg, STATFLAG_NONAME); <br>    if (FAILED(hr)) <br>    { <br>        MessageBoxFromStringIdsAndArgs( <br>            _hwnd, <br>            _hInstance, <br>            IDS_STMSTATFAILED, <br>            IDS_ERROR, <br>            MB_OK | MB_ICONEXCLAMATION, <br>            hr <br>            ); <br>        return(FALSE); <br>    } <br>    _cbSize = statstg.cbSize.LowPart; <br> <br>    TCHAR szStreamTitleText[MAX_STRING_LENGTH]; <br>    if (!LoadString(_hInstance, IDS_STMTITLETEXT, szStreamTitleText, MAX_STRING_LENGTH)) <br>    { <br>        lstrcpy(szStreamTitleText, TEXT("")); <br>    } <br> <br>    TCHAR * szTitle = new TCHAR[lstrlen(TEXT("  [0x00000000 bytes]")) <br>        + lstrlen(szStreamTitleText) + wcslen(_ple-&gt;pwcsName) + 1]; <br>    if (szTitle) <br>    { <br>        wsprintf(szTitle, TEXT("%s %ws [0x%08X bytes]"), szStreamTitleText, _ple-&gt;pwcsName, _cbSize); <br>    } <br>    // Note, the Create method sets the _hwnd member for me so I don't <br>    // need to set it myself. <br>    HWND hwnd = Create( <br>        TEXT(STREAM_VIEW_CLASS_NAME), <br>        szTitle, <br>        WS_OVERLAPPED <br>            | WS_MINIMIZEBOX <br>            | WS_MAXIMIZEBOX <br>            | WS_SYSMENU <br>            | WS_THICKFRAME, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        CW_USEDEFAULT, <br>        NULL, <br>        NULL, <br>        hInstance); <br>    delete[] szTitle; <br>    if (!hwnd) <br>    { <br>        return(FALSE); <br>    } <br>    ShowWindow(hwnd, nCmdShow); <br>    UpdateWindow(hwnd); <br>    return(TRUE); <br>} <br> <br>//+--------------------------------------------------------------------------- <br>// <br>//  Member:     CStreamView::WindowProc <br>// <br>//  Synopsis:   window procedure for the stream viewer window <br>// <br>//  Arguments:  [uMsg]   - Window's message <br>//              [wParam] - first message parameter <br>//              [lParam] - second message parameter <br>// <br>//  History:    6-27-94   stevebl   Created <br>// <br>//---------------------------------------------------------------------------- <br> <br>LRESULT CStreamView::WindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam) <br>{ <br>    switch (uMsg) <br>    { <br>    case WM_CREATE: <br>        { <br>            RECT rc; <br>            GetClientRect(_hwnd, &amp;rc); <br>            // record the width before we create the list box <br>            _wWidth = (WORD) rc.right; <br> <br>            HDC hdc = GetDC(_hwnd); <br>            LOGFONT lf; <br>            memset(&amp;lf, 0, sizeof(LOGFONT)); <br> <br>            // Get an 8 point Courier font. <br>            lf.lfHeight = -MulDiv(8, GetDeviceCaps(hdc, LOGPIXELSY), 72); <br>            lstrcpy(lf.lfFaceName, TEXT("Courier")); <br>            _hfListBox = CreateFontIndirect(&amp;lf); <br>            HFONT hfOld = (HFONT) SelectObject(hdc, _hfListBox); <br>            GetTextMetrics(hdc, &amp;_tm); <br>            SelectObject(hdc, hfOld); <br>            ReleaseDC(_hwnd, hdc); <br> <br>            // create the child listbox <br>            _hlb = CreateWindow( <br>                TEXT("listbox"), <br>                TEXT(""), <br>                LBS_OWNERDRAWFIXED | <br>                    WS_CHILD | <br>                    WS_VISIBLE | <br>                    WS_VSCROLL | <br>                    LBS_NOINTEGRALHEIGHT | <br>                    LBS_NODATA, <br>                0, <br>                0, <br>                rc.right, <br>                rc.bottom, <br>                _hwnd, <br>                (HMENU) IDC_LISTBOX, <br>                _hInstance, <br>                NULL); <br>            if (NULL == _hlb) <br>            { <br>                // abort window creation <br>                return(-1); <br>            } <br>            SetFocus(_hlb); <br> <br>            SendMessage( <br>                _hlb, <br>                LB_SETCOUNT, <br>                (WPARAM)((_cbSize / BYTESPERLINE) + (_cbSize % BYTESPERLINE ? 1 : 0)), <br>                0); <br>            SendMessage(_hlb, WM_SETFONT, (WPARAM) _hfListBox, 0); <br>            SendMessage(_hlb, LB_SETCURSEL, 0, 0); <br>            _crTextHigh = GetSysColor(COLOR_HIGHLIGHTTEXT); <br>            _crTextNorm = GetSysColor(COLOR_WINDOWTEXT); <br>            _crBkHigh = GetSysColor(COLOR_HIGHLIGHT); <br>            _crBkNorm = GetSysColor(COLOR_WINDOW); <br>        } <br>        break; <br>    case WM_SETFOCUS: <br>        { <br>            if (_hlb) <br>            { <br>                SetFocus(_hlb); <br>            } <br>        break; <br>        } <br>    case WM_MEASUREITEM: <br>        { <br>            LPMEASUREITEMSTRUCT lpmis = (LPMEASUREITEMSTRUCT) lParam; <br>            lpmis-&gt;itemHeight = _tm.tmHeight + _tm.tmExternalLeading; <br>            lpmis-&gt;itemWidth = _wWidth; <br>            return(TRUE); <br>        } <br>    case WM_DRAWITEM: <br>        { <br>            LPDRAWITEMSTRUCT lpdis = (LPDRAWITEMSTRUCT) lParam; <br>            if (-1 == lpdis-&gt;itemID) <br>            { <br>                // no items in the listbox <br>                break; <br>            } <br>            // draw the item <br>            switch (lpdis-&gt;itemAction) <br>            { <br>            case ODA_SELECT: <br>            case ODA_DRAWENTIRE: <br>                { <br>                    // draw the listbox item <br>                    LONG lStartByte = lpdis-&gt;itemID * BYTESPERLINE; <br> <br>                    // NOTE:  The following string is actually a bit larger <br>                    // than it has to be.  The minimum size for this string <br>                    // is acutally somewhere between 5 and 6 bytes for each <br>                    // byte (plus 12) in the stream that is to be displayed. <br>                    // Doing it this way wastes a little space but it's much <br>                    // simpler, it's faster, and it's less prone to error <br>                    // than dynamically computing it each time. <br>                    TCHAR szLine[BYTESPERLINE * 6 + 12]; <br> <br>                    unsigned cch; <br>                    wsprintf(szLine, TEXT("0x%08X:"), lStartByte); <br>                    for (cch = BYTESPERLINE * 6 + 12; (unsigned) lstrlen(TEXT("0x12345678:")) &lt; cch--; ) <br>                    { <br>                        szLine[cch] = TEXT(' '); <br>                    } <br> <br>                    IStream * pstm = (IStream *) _ple-&gt;pInterface; <br>                    BYTE rgb[BYTESPERLINE]; <br>                    LARGE_INTEGER dlibMove; <br>                    dlibMove.HighPart = 0; <br>                    // If we ever get a stream that's big enough to require <br>                    // that the HiPart get set, then nobody would want to <br>                    // browse that much data anyway! <br>                    dlibMove.LowPart = lStartByte; <br> <br>                    HRESULT hr = pstm-&gt;Seek(dlibMove, STREAM_SEEK_SET, NULL); <br>                    if (FAILED(hr)) <br>                    { <br>                        MessageBoxFromStringIdsAndArgs( <br>                            _hwnd, <br>                            _hInstance, <br>                            IDS_STMSEEKFAILED, <br>                            IDS_ERROR, <br>                            MB_OK | MB_ICONEXCLAMATION, <br>                            hr <br>                            ); <br>                        return(FALSE); <br>                    } <br>                    ULONG cbRead; <br>                    hr = pstm-&gt;Read(rgb, BYTESPERLINE, &amp;cbRead); <br>                    if (FAILED(hr)) <br>                    { <br>                        MessageBoxFromStringIdsAndArgs( <br>                            _hwnd, <br>                            _hInstance, <br>                            IDS_STMREADFAILED, <br>                            IDS_ERROR, <br>                            MB_OK | MB_ICONEXCLAMATION, <br>                            hr <br>                            ); <br>                        return(FALSE); <br>                    } <br> <br>                    for (cch = 0; cch &lt; cbRead; cch++) <br>                    { <br>                        TCHAR szTemp[3]; <br>                        wsprintf(szTemp, TEXT("%02X"), rgb[cch]); <br>                        szLine[cch * 3 + cch / DIVISIONPOINTS + 12] = szTemp[0]; <br>                        szLine[cch * 3 + cch / DIVISIONPOINTS + 13] = szTemp[1]; <br>                        char ch = rgb[cch]; <br>                        if (ch &lt; ' ') <br>                        { <br>                            ch = '.'; <br>                        } <br>                        // this is a little trick to get the character in the <br>                        // correct type of string (UNICODE or not) <br>                        wsprintf(szTemp, TEXT("%c"), ch); <br>                        szLine[cch + 13 + cch / DIVISIONPOINTS + 3 * BYTESPERLINE + BYTESPERLINE / DIVISIONPOINTS] = szTemp[0]; <br>                    } <br>                    szLine[cch + 13 + cch / DIVISIONPOINTS + 3 * BYTESPERLINE + BYTESPERLINE / DIVISIONPOINTS] = 0; <br> <br>                    SIZE sizeText; <br>                    RECT rcItem = lpdis-&gt;rcItem; <br> <br>                    GetTextExtentPoint32( <br>                        lpdis-&gt;hDC, <br>                        szLine, <br>                        lstrlen(szLine), <br>                        &amp;sizeText); <br>                    rcItem.right = rcItem.left + sizeText.cx; <br>                    COLORREF crOldText = SetTextColor( <br>                        lpdis-&gt;hDC, <br>                        (lpdis-&gt;itemState &amp; ODS_SELECTED) ? _crTextHigh : _crTextNorm); <br>                    COLORREF crOldBack = SetBkColor( <br>                        lpdis-&gt;hDC, <br>                        (lpdis-&gt;itemState &amp; ODS_SELECTED) ? _crBkHigh : _crBkNorm); <br>                    ExtTextOut( <br>                        lpdis-&gt;hDC, <br>                        rcItem.left, <br>                        rcItem.top, <br>                        ETO_OPAQUE | ETO_CLIPPED, <br>                        &amp;rcItem, <br>                        szLine, <br>                        lstrlen(szLine), <br>                        NULL); <br>                    SetTextColor(lpdis-&gt;hDC, crOldText); <br>                    SetBkColor(lpdis-&gt;hDC, crOldBack); <br>                } <br>                break; <br>            case ODA_FOCUS: <br>                break; <br>            } <br>            return(TRUE); <br>        } <br>    case WM_SIZE: <br>        { <br>            _wWidth = LOWORD(lParam); <br>            WORD wHeight = HIWORD(lParam); <br>            if (_hlb) <br>            { <br>                SetWindowPos(_hlb, NULL, 0, 0, _wWidth, wHeight, SWP_NOMOVE | SWP_NOZORDER); <br>            } <br>            break; <br>        } <br>    case WM_COMMAND: <br>    case WM_QUIT: <br>    case WM_CLOSE: <br>    default: <br>        return(DefWindowProc(_hwnd, uMsg, wParam, lParam)); <br>    } <br>    return(FALSE); <br>} <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
