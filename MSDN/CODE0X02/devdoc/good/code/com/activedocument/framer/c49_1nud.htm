<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>FRAMER.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context55"></a>FRAMER.CPP</h2>
<pre><code>/* <br> * FRAMER.CPP <br> * Document Objects Framer <br> * <br> * Sample to demonstrate in-place activation of a DocObject--also <br> * activates normal embeddings in separate windows. <br> * <br> * Copyright (c)1995-1997 Microsoft Corporation, All Rights Reserved <br> */ <br> <br> <br>#define INITGUID <br>#include "framer.h" <br> <br> <br>/* <br> * WinMain <br> * <br> * Purpose: <br> *  Main entry point of application.  Should register the app class <br> *  if a previous instance has not done so and do any other one-time <br> *  initializations. <br> */ <br> <br>int PASCAL WinMain (HINSTANCE hInst, HINSTANCE hPrev <br>    , LPSTR pszCmdLine, int nCmdShow) <br>    { <br>    PCFrame         pFR;     <br>    WPARAM          wRet; <br> <br>    //Attempt to allocate and initialize the application <br>    pFR=new CFrame(hInst, hPrev, pszCmdLine, nCmdShow); <br> <br>    if (NULL==pFR) <br>        return 0; <br>     <br>    //If we can initialize pFR, start chugging messages <br>    if (pFR-&gt;Init(CMENUS, CW_USEDEFAULT, CW_USEDEFAULT <br>        , CW_USEDEFAULT, CW_USEDEFAULT)) <br>        wRet=pFR-&gt;MessageLoop(); <br> <br>    delete pFR; <br>    return wRet; <br>    } <br> <br> <br> <br>/* <br> * CFrame::CFrame <br> * CFrame::~CFrame <br> * <br> * Constructor Parameters: <br> *  hInst           HINSTANCE from WinMain <br> *  hInstPrev       HINSTANCE from WinMain <br> *  pszCmdLine      LPSTR from WinMain <br> *  nCmdShow        int from WinMain <br> */ <br> <br>CFrame::CFrame(HINSTANCE hInst, HINSTANCE hInstPrev <br>    , LPSTR pszCmdLine, int nCmdShow)     <br>    { <br>    m_hInst=hInst; <br>    m_hWnd=NULL; <br>    m_hInstPrev=hInstPrev; <br>    m_nCmdShow=nCmdShow; <br> <br>    m_phMenu=NULL; <br>    m_hAccel=NULL; <br>    m_hWndClient=NULL; <br> <br>    m_fInitialized=FALSE; <br>    m_pIStorage=NULL; <br>    m_dwIDCounter=0; <br> <br>    m_hMenuOrg=NULL; <br>    m_hMenuTop=NULL; <br>m_hMenuHelp=NULL; <br>m_fInObjectHelp=FALSE; <br>m_fUsingOurHelp=FALSE; <br>     <br>    m_fHaveObject=FALSE; <br>m_hWndObj=NULL; <br> <br>    m_pSite=NULL; <br>    m_fOurMenuShowing=TRUE; <br>    SetRect(&amp;m_bwIP, 0, 0, 0, 0); <br>    m_fInContextHelp=FALSE; <br>    m_pIOleIPActiveObject=NULL; <br> <br>    return; <br>    } <br> <br> <br> <br>CFrame::~CFrame(void) <br>    { <br>    if (NULL!=m_hWndClient) <br>        DestroyWindow(m_hWndClient); <br> <br>    //Frees the temp file. <br>    ReleaseInterface(m_pIStorage); <br>     <br>    //m_pSite cleaned up in Close <br> <br>    //Accelerators freed automatically. <br> <br>//Destroy the special help menu <br>if (NULL!=m_hMenuHelp) <br>DestroyMenu(m_hMenuHelp); <br> <br>    //Free the menu handle array <br>    if (NULL!=m_phMenu) <br>        delete []((UINT *)m_phMenu); <br> <br>    if (m_fInitialized) <br>        OleUninitialize(); <br> <br>    return; <br>    } <br> <br> <br>/* <br> * CFrame::Init <br> * <br> * Purpose: <br> *  Initializer for a CFrame object containing anything prone to <br> *  failure. <br> * <br> * Parameters: <br> *  cMenus          UINT number of menus on the frame <br> *  x, y, cx, cy    int location and size of frame window  <br> * <br> * Return Value: <br> *  BOOL            TRUE if initialization succeeded, FALSE <br> *                  otherwise. If FALSE is returned, the caller must <br> *                  guarantee that the destructor is called promptly <br> *                  to insure cleanup. <br> */ <br> <br>BOOL CFrame::Init(UINT cMenus, int x, int y, int cx, int cy) <br>    { <br>    HMENU               hMenu; <br>    UINT                uTemp; <br>    RECT                rc; <br> <br>    //1.  Initialize OLE <br>    if (SUCCEEDED(OleInitialize(NULL))) <br>        m_fInitialized=TRUE; <br>    else <br>        return FALSE; <br> <br> <br>    //2.  Register window classes <br>    if (NULL==m_hInstPrev) <br>        { <br>        if (!RegisterAllClasses()) <br>            return FALSE; <br>        } <br> <br> <br>    //3.  Create the main window and client-area window <br>    m_hWnd=CreateWindow(SZCLASSFRAME, TEXT("DocObject Framer") <br>        , WS_MINIMIZEBOX | WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN <br>        , x, y, cx, cy, NULL, NULL, m_hInst, this); <br>         <br>    if (NULL==m_hWnd) <br>        return FALSE; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br> <br>    m_hWndClient=CreateWindow(SZCLASSCLIENT, SZCLASSCLIENT <br>        , WS_CHILD | WS_CLIPCHILDREN | WS_VISIBLE | WS_CLIPSIBLINGS <br>        , rc.left, rc.top, rc.right-rc.left <br>        , rc.bottom-rc.top, m_hWnd, NULL, m_hInst, this); <br> <br>    if (NULL==m_hWndClient) <br>        return FALSE; <br> <br>    //4. Allocate menu array for use with in-place menu merging. <br>    m_phMenu=new HMENU[cMenus]; <br>    hMenu=GetMenu(m_hWnd); <br>    m_hMenuOrg=hMenu; <br> <br>    for (uTemp=0; uTemp &lt; cMenus; uTemp++) <br>        m_phMenu[uTemp]=GetSubMenu(hMenu, uTemp); <br> <br>//Also load the special help menu <br>m_hMenuHelp=LoadMenu(m_hInst <br>, MAKEINTRESOURCE(IDR_MENUHELP)); <br> <br>    //5.  Load accelerators <br>    m_hAccel=LoadAccelerators(m_hInst <br>        , MAKEINTRESOURCE(IDR_ACCELERATORS)); <br> <br>    if (NULL==m_hAccel) <br>        return FALSE; <br> <br> <br>    //6.  Make us all visible. <br>    ShowWindow(m_hWnd, m_nCmdShow); <br>    UpdateWindow(m_hWnd); <br> <br> <br>    /* <br>     * 7.  Create a temp file for all embedded files.  Note that in this <br>     *     sample we don't save any changes to DocObjects because we  <br> *     don't manage any storage directly. <br> */   <br>    if (FAILED(StgCreateDocfile(NULL, STGM_TRANSACTED | STGM_READWRITE <br>        | STGM_SHARE_EXCLUSIVE | STGM_CREATE| STGM_DELETEONRELEASE <br>        , 0, &amp;m_pIStorage))) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::RegisterAllClasses <br> * <br> * Purpose: <br> *  Registers all classes used in this application. <br> * <br> * Return Value: <br> *  BOOL            TRUE if registration succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CFrame::RegisterAllClasses(void) <br>    { <br>    WNDCLASS        wc; <br> <br>    //Field that are the same for all windows. <br>    wc.style         = CS_HREDRAW | CS_VREDRAW; <br>    wc.hInstance     = m_hInst; <br>    wc.cbClsExtra    = 0; <br> <br>    //Register the Frame window <br>    wc.lpfnWndProc   = FrameWndProc; <br>    wc.cbWndExtra    = CBFRAMEWNDEXTRA; <br>    wc.hIcon         = LoadIcon(m_hInst, TEXT("Icon")); <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = NULL; <br>    wc.lpszMenuName  = MAKEINTRESOURCE(IDR_MENU); <br>    wc.lpszClassName = SZCLASSFRAME; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br> <br>    //Register the do-nothing Client window <br>    wc.lpfnWndProc   = ClientWndProc; <br>    wc.cbWndExtra    = CBCLIENTWNDEXTRA; <br>    wc.hIcon         = NULL; <br>    wc.hCursor       = LoadCursor(NULL, IDC_ARROW); <br>    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1); <br>    wc.lpszMenuName  = NULL; <br>    wc.lpszClassName = SZCLASSCLIENT; <br> <br>    if (!RegisterClass(&amp;wc)) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::OnCommand <br> * <br> * Purpose: <br> *  WM_COMMAND handler for the frame window so derivations can <br> *  process their messages and then pass the standard commands (like <br> *  file open and save) on to the base class. <br> * <br> * Parameters: <br> *  hWnd            HWND of the frame window. <br> *  wParam          WPARAM of the message. <br> *  lParam          LPARAM of the message. <br> * <br> * Return Value: <br> *  LRESULT         Return value for the message. <br> */ <br> <br>LRESULT CFrame::OnCommand(HWND hWnd, WPARAM wParam, LPARAM lParam) <br>    { <br>    TCHAR           szFile[MAX_PATH]; <br>    BOOL            fOK; <br>    PCHourglass     pHour; <br>    WORD            wID=LOWORD(wParam); <br> <br>    switch (wID) <br>        { <br>        case IDM_FILEOPEN: <br>            /* <br>             * This will be disabled if we already have an object. <br>             * User must File/Close first to get back here.  <br>             * <br>             * Otherwise open the File/Open dialog <br>             */ <br>            szFile[0]=0; <br>            if (!OpenDialog(szFile, MAX_PATH)) <br>                return 0L; <br>                 <br>            pHour=new CHourglass;             <br>            fOK=CreateObject(szFile); <br>            delete pHour; <br>            return 0; <br> <br> <br>        case IDM_FILECLOSE: <br>            Close(); <br>            break; <br> <br> <br>        case IDM_FILEEXIT: <br>            PostMessage(hWnd, WM_CLOSE, 0, 0L);             <br>            break; <br> <br> <br>        case IDM_HELPABOUT: <br>            DialogBox(m_hInst, MAKEINTRESOURCE(IDD_ABOUT) <br>                , m_hWnd, (DLGPROC)AboutProc); <br>            break; <br> <br> <br>        case IDM_ENTERCONTEXTHELP: <br>        case IDM_ESCAPECONTEXTHELP: <br>            //Notify the object on entry and exit. <br>            ContextSensitiveHelp(IDM_ENTERCONTEXTHELP==wID); <br>            break; <br> <br> <br>        default: <br>           return DefWindowProc(hWnd, WM_COMMAND, wParam, lParam); <br>                <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CFrame::OpenDialog <br> * <br> * Purpose: <br> *  Invokes the COMMDLG.DLL GetOpenFileName dialog and retrieves <br> *  a filename for saving or opening. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR buffer to receive the entered filename. <br> *  cchFile         UINT length of pszFile  <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function retrieved a filename, <br> *                  FALSE if the user pressed CANCEL. <br> */ <br> <br>BOOL CFrame::OpenDialog(LPTSTR pszFile, UINT cchFile) <br>    { <br>    OPENFILENAME        ofn; <br>    static TCHAR        szFilter[80]=TEXT("All Files (*.*)\0*.*\0\0"); <br>    BOOL                fRet; <br>   #ifdef DEBUG <br>    DWORD               dwErr; <br>   #endif <br> <br>    if (NULL==pszFile) <br>        return FALSE; <br> <br>    memset(&amp;ofn, 0, sizeof(OPENFILENAME)); <br>    ofn.lStructSize      =sizeof(OPENFILENAME); <br>    ofn.hwndOwner        =m_hWnd; <br> <br>    ofn.lpstrFilter      =szFilter; <br>    ofn.nFilterIndex     =1L; <br> <br>    ofn.lpstrTitle       =NULL; <br>    ofn.lpstrFile        =pszFile; <br>    ofn.nMaxFile         =cchFile; <br> <br>    ofn.lpstrDefExt      =TEXT("*"); <br>    ofn.Flags            =OFN_HIDEREADONLY | OFN_FILEMUSTEXIST; <br> <br>    fRet=GetOpenFileName(&amp;ofn); <br>     <br>   #ifdef DEBUG <br>    dwErr=CommDlgExtendedError(); <br>   #endif <br>    return fRet; <br>    } <br> <br> <br> <br>/* <br> * CFrame::CreateObject <br> * <br> * Purpose: <br> *  Creates a site and has it create an object based on a filename. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR pointing to the filename from which to <br> *                  create the object. <br> * <br> * Return Value: <br> *  BOOL            TRUE if successful, FALSE otherwise. <br> */ <br> <br>BOOL CFrame::CreateObject(LPTSTR pszFile) <br>    {     <br>    m_pSite=new CSite(++m_dwIDCounter, m_hWndClient, this); <br> <br>    if (NULL==m_pSite) <br>        return FALSE; <br> <br>    m_pSite-&gt;AddRef();  //So we can free with Release <br> <br>    /* <br>     * Now tell the site to create an object in it using the filename <br>     * and the storage we opened.  The site will create a sub-storage <br>     * for the doc object's use. <br>     */ <br>    if (!m_pSite-&gt;Create(pszFile, m_pIStorage)) <br>        return FALSE; <br> <br>    m_fHaveObject=TRUE; <br> <br>    //We created the thing, now activate it with "Show" <br>    m_pSite-&gt;Activate(OLEIVERB_SHOW); <br> <br>//Force repaint to show "have object" message <br>InvalidateRect(m_hWndClient, NULL, TRUE); <br>UpdateWindow(m_hWndClient); <br>    return TRUE;         <br>    } <br> <br> <br> <br>/* <br> * CFrame::Close <br> * <br> * Purpose: <br> *  Handles File/Close by freeing the object and resetting the <br> *  application state. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CFrame::Close(void) <br>    {     <br>RECTrc; <br> <br>    if (NULL!=m_pSite) <br>        { <br>CSite *pSite=m_pSite;        //Prevents reentry <br>m_pSite=NULL; <br> <br>        pSite-&gt;Close(FALSE);         //Frees the object <br>        pSite-&gt;Destroy(m_pIStorage); //Cleans up the storage <br>        pSite-&gt;Release();            //Frees the site         <br>        } <br>     <br>m_fHaveObject=FALSE; <br>    SetRect(&amp;m_bwIP, 0, 0, 0, 0); <br> <br>GetClientRect(m_hWnd, &amp;rc); <br>ResizeClientWindow(rc.left, rc.top, rc.right-rc.left <br>, rc.bottom-rc.top); <br> <br>//Force repaint to remove "have object" message <br>InvalidateRect(m_hWndClient, NULL, TRUE); <br>UpdateWindow(m_hWndClient); <br>     <br>    return;         <br>    } <br> <br> <br>/* <br> * CFrame::ResizeClientWindow <br> * <br> * Purpose: <br> *Resizes the client-area window according to current toolbar sizes <br> *  and the frame window size. <br> * <br> * Parameters: <br> *x,y,cx,cyUINT origin and dimensions of the window <br> * <br> * Return Value: <br> *None <br> */ <br> <br>void CFrame::ResizeClientWindow(UINT x, UINT y, UINT cx, UINT cy) <br>{ <br>SetWindowPos(m_hWndClient, NULL, x, y, cx, cy     <br>        , SWP_NOZORDER | SWP_NOACTIVATE); <br> <br>    //Tell the site to tell the object. <br>if (NULL!=m_pSite) <br>    m_pSite-&gt;UpdateObjectRects(); <br> <br>return; <br>} <br> <br> <br>/* <br> * CFrame::MessageLoop <br> * <br> * Purpose: <br> *  Spins in a standard message loop (with accelerators) until <br> *  WM_QUIT is found after which it returns. <br> * <br> * Return Value: <br> *  WPARAM          Contents of msg.wParam from WM_QUIT. <br> */ <br> <br>WPARAM CFrame::MessageLoop(void) <br>    { <br>    MSG     msg; <br> <br>    while (GetMessage(&amp;msg, NULL, 0,0 )) <br>        { <br>        //Always give the object first crack at translation. <br>        if (NULL!=m_pIOleIPActiveObject) <br>            { <br>            HRESULT     hr; <br> <br>            hr=m_pIOleIPActiveObject-&gt;TranslateAccelerator(&amp;msg); <br> <br>            //If the object translated the accelerator, we're done <br>            if (NOERROR==hr) <br>                continue; <br>            } <br> <br>        if (!::TranslateAccelerator(m_hWnd, m_hAccel, &amp;msg)) <br>            { <br>            TranslateMessage(&amp;msg); <br>            DispatchMessage(&amp;msg); <br>            } <br>        } <br> <br>    return msg.wParam; <br>    } <br> <br> <br> <br>/* <br> * FrameWndProc <br> * <br> * Purpose: <br> *  Frame window class procedure that allows a derivation of these <br> *  classes to hook and process any messages desired.  Otherwise this <br> *  handles standard commands as well as the status line and menus. <br> */ <br> <br>LRESULT APIENTRY FrameWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCFrame         pFR; <br>    RECT            rc; <br>    HMENU           hMenu; <br> <br>    pFR=(PCFrame)GetWindowLong(hWnd, FRAMEWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pFR=(PCFrame)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br> <br>            SetWindowLong(hWnd, FRAMEWL_STRUCTURE, (LONG)pFR); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_DESTROY: <br>            PostQuitMessage(0); <br>            break; <br> <br>        case WM_CLOSE:                         <br>            pFR-&gt;Close(); <br>            DestroyWindow(hWnd); <br>            break; <br> <br>        case WM_ERASEBKGND: <br>            //Client area window always manages painting <br>            return FALSE; <br> <br>        case WM_SIZE: <br>            //Tell the in-place object about the new frame size <br>            GetClientRect(hWnd, &amp;rc); <br> <br>            if (NULL!=pFR-&gt;m_pIOleIPActiveObject) <br>                pFR-&gt;m_pIOleIPActiveObject-&gt;ResizeBorder(&amp;rc, pFR, TRUE); <br> <br>            /* <br>             * Resize the client, which is done in all cases since this window <br> * is the parent of the DocObject, plus we need to tell the  <br> * DocObject of the new size through IOleDocumentView::SetRect. <br> */ <br>            rc.left  +=pFR-&gt;m_bwIP.left; <br>            rc.right -=pFR-&gt;m_bwIP.right; <br>            rc.top   +=pFR-&gt;m_bwIP.top; <br>            rc.bottom-=pFR-&gt;m_bwIP.bottom;             <br> <br>pFR-&gt;ResizeClientWindow(rc.left, rc.top, rc.right-rc.left <br>, rc.bottom-rc.top); <br> <br>            break; <br> <br> <br>        case WM_SETFOCUS: <br>            if (NULL!=pFR-&gt;m_pIOleIPActiveObject) <br>                { <br>                HWND    hWndObj; <br> <br>                pFR-&gt;m_pIOleIPActiveObject-&gt;GetWindow(&amp;hWndObj); <br>                SetFocus(hWndObj); <br>                } <br> <br>            return TRUE; <br> <br> <br>case WM_INITMENU: <br>pFR-&gt;m_fInObjectHelp=FALSE; <br>break; <br> <br> <br>case WM_MENUSELECT: <br>{ <br> UINT fuFlags=(UINT)HIWORD(wParam); <br> UINT uItem=(UINT)LOWORD(wParam); <br> <br>if (MF_POPUP &amp; fuFlags) <br>{ <br>/* <br> * If we're inside our m_hMenuHelp, and uItem is <br> * not zero (first item on the menu, which is ours), <br> * then we must be in an object-supplied menu. <br> * <br> * Therefore we set our flag and forward the message <br> * as well as others that occur later.  Otherwise we <br> * clear the flag so we get messages again. <br> */ <br>if (NULL!=pFR-&gt;m_hMenuHelp <br>&amp;&amp; (HMENU)lParam==pFR-&gt;m_hMenuHelp) <br>{ <br>pFR-&gt;m_fInObjectHelp=(0!=uItem); <br> <br>if (pFR-&gt;m_fInObjectHelp) <br>SendMessage(pFR-&gt;m_hWndObj, iMsg, wParam, lParam); <br>} <br>} <br>else <br>{ <br>//Forward the message on <br>if (pFR-&gt;m_fInObjectHelp) <br>{ <br>SendMessage(pFR-&gt;m_hWndObj, iMsg, wParam, lParam); <br>break; <br>} <br>} <br>} <br>break; <br> <br>case WM_INITMENUPOPUP: <br>/* <br> * If we're in the object's Help menu, forward to <br> * the object received in IOleInPlaceFrame::SetActiveObject <br> */ <br>if (pFR-&gt;m_fInObjectHelp &amp;&amp; NULL!=pFR-&gt;m_hWndObj)  <br>SendMessage(pFR-&gt;m_hWndObj, iMsg, wParam, lParam); <br> <br> <br>//Skip the system menu <br>            if (TRUE==(BOOL)HIWORD(lParam)) <br>                break; <br> <br>    /* <br>             * If we have an object, enable Close, otherwise <br>             * enable Open. <br>             */ <br>            hMenu=(HMENU)wParam; <br> <br>            if (hMenu==pFR-&gt;m_phMenu[0]) <br>                { <br>                UINT uTempE=MF_BYCOMMAND | MF_ENABLED; <br>                UINT uTempD=MF_BYCOMMAND | MF_DISABLED | MF_GRAYED; <br> <br>                EnableMenuItem(hMenu, IDM_FILEOPEN <br>                    , pFR-&gt;m_fHaveObject ? uTempD : uTempE); <br>                EnableMenuItem(hMenu, IDM_FILECLOSE <br>                    , pFR-&gt;m_fHaveObject ? uTempE : uTempD); <br>                } <br>             <br>            break; <br> <br>        case WM_COMMAND: <br>if (pFR-&gt;m_fInObjectHelp) <br>{ <br>SendMessage(pFR-&gt;m_hWndObj, iMsg, wParam, lParam); <br>break; <br>} <br>else <br>            return pFR-&gt;OnCommand(hWnd, wParam, lParam); <br> <br>case WM_ACTIVATEAPP: <br>if (NULL!=pFR-&gt;m_pIOleIPActiveObject) <br>{ <br>HRESULT hr; <br>hr=pFR-&gt;m_pIOleIPActiveObject-&gt;OnFrameWindowActivate((BOOL)wParam); <br>} <br>break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br>/* <br> * ClientWndProc <br> * <br> * Purpose: <br> *  Client window class procedure that's only used to paint a <br> *  message when we have a non-DocObject open.  Otherwise this <br> *  is completely hidden. <br> */ <br> <br>LRESULT APIENTRY ClientWndProc(HWND hWnd, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    PCFrame         pFR; <br>PAINTSTRUCTps; <br> <br>    pFR=(PCFrame)GetWindowLong(hWnd, CLIENTWL_STRUCTURE); <br> <br>    switch (iMsg) <br>        { <br>        case WM_NCCREATE: <br>            pFR=(PCFrame)((LPCREATESTRUCT)lParam)-&gt;lpCreateParams; <br> <br>            SetWindowLong(hWnd, CLIENTWL_STRUCTURE, (LONG)pFR); <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br> <br>        case WM_PAINT: <br>BeginPaint(hWnd, &amp;ps); <br> <br>if (pFR-&gt;m_fHaveObject) <br>{ <br>static TCHAR szMsg[]={TEXT("A non-DocObject is open or loaded. Use File/Close to destroy it.")}; <br> <br>SetBkColor(ps.hdc, GetSysColor(COLOR_WINDOW)); <br>TextOut(ps.hdc, 0, 0, szMsg, lstrlen(szMsg)); <br>} <br> <br>EndPaint(hWnd, &amp;ps); <br>            break; <br> <br>        default: <br>            return DefWindowProc(hWnd, iMsg, wParam, lParam); <br>        } <br> <br>    return 0L; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * AboutProc <br> * <br> * Purpose: <br> *  Dialog procedure for the omnipresent About box. <br> * <br> * Parameters: <br> *  The standard. <br> * <br> * Return Value: <br> *  The value to be returned through the DialogBox call that <br> *  created the dialog. <br> * <br> */ <br> <br>BOOL APIENTRY AboutProc(HWND hDlg, UINT iMsg <br>    , WPARAM wParam, LPARAM lParam) <br>    { <br>    switch (iMsg) <br>        { <br>        case WM_INITDIALOG: <br>            return TRUE; <br> <br>        case WM_COMMAND: <br>            switch (LOWORD(wParam)) <br>                { <br>                case IDOK: <br>                    EndDialog(hDlg, TRUE); <br>                } <br>            break; <br>        } <br>    return FALSE; <br>    } <br> <br> <br> <br> <br> <br> <br> <br> <br> <br>/* <br> * IUnknown implementation <br> */ <br> <br> <br>/* <br> * CFrame::QueryInterface <br> * CFrame::AddRef <br> * CFrame::Release <br> */ <br> <br>STDMETHODIMP CFrame::QueryInterface(REFIID riid, void **ppv) <br>    { <br>    /* <br>     * We only know IOleInPlaceFrame and its base interfaces as well <br>     * as a bogus IOleCommandTarget to make PowerPoint happy. <br> */ <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid || IID_IOleInPlaceUIWindow==riid <br>        || IID_IOleWindow==riid || IID_IOleInPlaceFrame==riid) <br>        *ppv=(IOleInPlaceFrame *)this; <br> <br>if (IID_IOleCommandTarget==riid) <br>        *ppv=(IOleCommandTarget *)this; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return E_NOINTERFACE; <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CFrame::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CFrame::Release(void) <br>    { <br>    //Nothing special happening here--frame's life if user-controlled. <br>    return --m_cRef; <br>    } <br> <br> <br>/* <br> * IOleInPlaceFrame implementation <br> */ <br> <br> <br>/* <br> * CFrame::GetWindow <br> * <br> * Purpose: <br> *  Retrieves the handle of the window associated with the object <br> *  on which this interface is implemented. <br> * <br> * Parameters: <br> *  phWnd           HWND * in which to store the window handle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, E_FAIL if there is no <br> *                  window. <br> */ <br> <br>STDMETHODIMP CFrame::GetWindow(HWND *phWnd) <br>    { <br>    *phWnd=m_hWnd; <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::ContextSensitiveHelp <br> * <br> * Purpose: <br> *  Instructs the object on which this interface is implemented to <br> *  enter or leave a context-sensitive help mode. <br> * <br> * Parameters: <br> *  fEnterMode      BOOL TRUE to enter the mode, FALSE otherwise. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::ContextSensitiveHelp(BOOL fEnterMode) <br>    { <br>    /* <br>     * Don't bother if there is no active object since we don't do <br>     * context help on our own. <br>     */ <br>    if (NULL==m_pIOleIPActiveObject) <br>        return NOERROR; <br> <br>    //If the state changes, notify the active object. <br>    if (m_fInContextHelp!=fEnterMode) <br>        { <br>        m_fInContextHelp=fEnterMode; <br>        m_pIOleIPActiveObject-&gt;ContextSensitiveHelp(fEnterMode); <br>        } <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::GetBorder <br> * <br> * Purpose: <br> *  Returns the rectangle in which the container is willing to <br> *  negotiate about an object's adornments. <br> * <br> * Parameters: <br> *  prcBorder       LPRECT in which to store the rectangle. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if all is well, INPLACE_E_NOTOOLSPACE <br> *                  if there is no negotiable space. <br> */ <br> <br>STDMETHODIMP CFrame::GetBorder(LPRECT prcBorder) <br>    { <br>    if (NULL==prcBorder) <br>        return E_INVALIDARG; <br> <br>    //We return all the client area space <br>    GetClientRect(m_hWnd, prcBorder); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::RequestBorderSpace <br> * <br> * Purpose: <br> *  Asks the container if it can surrender the amount of space <br> *  in pBW that the object would like for it's adornments.  The <br> *  container does nothing but validate the spaces on this call. <br> * <br> * Parameters: <br> *  pBW             LPCBORDERWIDTHS containing the requested space. <br> *                  The values are the amount of space requested <br> *                  from each side of the relevant window. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if we can give up space, <br> *                  INPLACE_E_NOTOOLSPACE otherwise. <br> */ <br> <br>STDMETHODIMP CFrame::RequestBorderSpace(LPCBORDERWIDTHS pBW) <br>    { <br>    //Framer has no border space restrictions <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::SetBorderSpace <br> * <br> * Purpose: <br> *  Called when the object now officially requests that the <br> *  container surrender border space it previously allowed <br> *  in RequestBorderSpace.  The container should resize windows <br> *  appropriately to surrender this space. <br> * <br> * Parameters: <br> *  pBW             LPCBORDERWIDTHS containing the amount of space <br> *                  from each side of the relevant window that the <br> *                  object is now reserving. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::SetBorderSpace(LPCBORDERWIDTHS pBW) <br>    { <br>    RECT            rc; <br> <br>    /* <br>     * Since we have no tools, we can accept anything the object sends <br>     * and must therefore adjust the client-area window accordingly. <br>     */ <br> <br>    /* <br>     * If pBW is NULL, the object is not interested in tools, so we <br>     * don't have to do anything.  In either case we need to save <br>     * the toolspace allocations in order to resize the client window <br>     * correctly. <br>     */ <br>    if (NULL==pBW) <br>        { <br>        if (!m_fOurMenuShowing) <br>            SetMenu(NULL, NULL, NULL); <br> <br>        SetRect(&amp;m_bwIP, 0, 0, 0, 0); <br>        GetClientRect( m_hWnd, &amp;rc ); <br>        } <br>    else <br>        { <br>        GetClientRect(m_hWnd, &amp;rc); <br>        rc.left  +=pBW-&gt;left; <br>        rc.right -=pBW-&gt;right; <br>        rc.top   +=pBW-&gt;top; <br>        rc.bottom-=pBW-&gt;bottom; <br> <br>        m_bwIP=*pBW; <br>        } <br> <br>ResizeClientWindow(rc.left, rc.top, rc.right-rc.left <br>, rc.bottom-rc.top); <br> <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::SetActiveObject <br> * <br> * Purpose: <br> *  Provides the container with the object's IOleInPlaceActiveObject <br> *  pointer <br> * <br> * Parameters: <br> *  pIIPActiveObj   LPOLEINPLACEACTIVEOBJECT of interest. <br> *  pszObj          LPCOLESTR naming the object.  Not used. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::SetActiveObject <br>    (LPOLEINPLACEACTIVEOBJECT pIIPActiveObj, LPCOLESTR pszObj) <br>    { <br>    if (NULL!=m_pIOleIPActiveObject) <br>        m_pIOleIPActiveObject-&gt;Release(); <br> <br>    //NULLs m_pIOleIPActiveObject if pIIPActiveObj is NULL <br>    m_pIOleIPActiveObject=pIIPActiveObj; <br> <br>    if (NULL!=m_pIOleIPActiveObject) <br>        m_pIOleIPActiveObject-&gt;AddRef(); <br> <br>m_pIOleIPActiveObject-&gt;GetWindow(&amp;m_hWndObj); <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::InsertMenus <br> * <br> * Purpose: <br> *  Instructs the container to place its in-place menu items where <br> *  necessary in the given menu and to fill in elements 0, 2, and 4 <br> *  of the OLEMENUGROUPWIDTHS array to indicate how many top-level <br> *  items are in each group. <br> * <br> * Parameters: <br> *  hMenu           HMENU in which to add popups. <br> *  pMGW            LPOLEMENUGROUPWIDTHS in which to store the <br> *                  width of each container menu group. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::InsertMenus(HMENU hMenu <br>    , LPOLEMENUGROUPWIDTHS pMGW) <br>    {     <br>//Copy our File menu into the shared menu.     <br>    InsertMenu(hMenu, 0, MF_BYPOSITION | MF_POPUP, (UINT)m_phMenu[0] <br>        , TEXT("&amp;File")); <br> <br>    pMGW-&gt;width[0]=1; <br>    pMGW-&gt;width[2]=0; <br>    pMGW-&gt;width[4]=0; <br> <br>/* <br> * Add the special help menu which is the first item in <br> * the m_hMenuHelp popup that's sitting around. <br> */ <br>InsertMenu(hMenu, 1, MF_BYPOSITION | MF_POPUP <br>    , (UINT)m_hMenuHelp, TEXT("&amp;Help")); <br> <br>//Tell the object we added our Help menu <br>pMGW-&gt;width[5]=1;     <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::SetMenu <br> * <br> * Purpose: <br> *  Instructs the container to replace whatever menu it's currently <br> *  using with the given menu and to call OleSetMenuDescritor so OLE <br> *  knows to whom to dispatch messages. <br> * <br> * Parameters: <br> *  hMenu           HMENU to show. <br> *  hOLEMenu        HOLEMENU to the menu descriptor. <br> *  hWndObj         HWND of the active object to which messages are <br> *                  dispatched. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::SetMenu(HMENU hMenu, HOLEMENU hOLEMenu <br>    , HWND hWndObj) <br>    { <br>    HRESULT         hr; <br> <br>    /* <br>     * Our responsibilities here are to put the menu on the frame <br>     * window and call OleSetMenuDescriptor. <br>     */ <br> <br>    if (NULL==hMenu) <br>        { <br>        //Prevent redundant calls, or debug warnings on startup. <br>        if (NULL==m_hMenuTop) <br>            return NOERROR; <br> <br>        hMenu=m_hMenuTop; <br>        m_hMenuTop=NULL; <br>        m_fOurMenuShowing=TRUE; <br>        } <br>    else <br>        { <br>        m_hMenuTop=m_hMenuOrg; <br>        m_fOurMenuShowing=FALSE; <br> <br>/* <br> * Check if our Help menu has anything added to it.  If so, then <br> * remember to forward menu messages.  If not, remove the Help <br> * menu altogether (destroying it after removing our normal Help <br> * popup, as we also do in RemoveMenus. <br> */ <br>if (CHELPITEMS!=GetMenuItemCount(m_hMenuHelp)) <br>m_fUsingOurHelp=TRUE; <br>else <br>{ <br>UINTi, cItems; <br> <br>cItems=GetMenuItemCount(hMenu); <br> <br>//Find m_hMenuHelp in the menu and remove it. </code></pre>
<p>
</p>
<pre><code>for (i=0; i &lt; cItems; i++) <br>{ <br>if (GetSubMenu(hMenu, i)==m_hMenuHelp) <br>{ <br>RemoveMenu(hMenu, i, MF_BYPOSITION); <br>break; <br>} <br>} <br>} <br>        } <br> <br>    if (NULL!=hMenu) <br>        ::SetMenu(m_hWnd, hMenu); <br> <br>    DrawMenuBar(m_hWnd); <br> <br>    hr=OleSetMenuDescriptor(hOLEMenu, m_hWnd, hWndObj, NULL, NULL); <br>    return hr; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::RemoveMenus <br> * <br> * Purpose: <br> *  Asks the container to remove any menus it put into hMenu in <br> *  InsertMenus. <br> * <br> * Parameters: <br> *  hMenu           HMENU from which to remove the container's <br> *                  items. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::RemoveMenus(HMENU hMenu) <br>    { <br>    int         cItems, i, j; <br>    HMENU       hMenuT; <br> <br>/* <br>     * To be defensive, loop through this menu removing anything <br>     * we recognize (that is, anything in m_phMenu) just in case <br>     * the server didn't clean it up right.  At least we can <br>     * give ourselves the prophylactic benefit. <br>     */ <br> <br>    if (NULL==hMenu) <br>        return NOERROR; <br> <br>    cItems=GetMenuItemCount(hMenu); <br> <br>    /* <br>     * Walk backwards down the menu.  For each popup, see if it <br>     * matches any other popup we know about, and if so, remove <br>     * it from the shared menu. <br>     */ <br>    for (i=cItems; i &gt;=0; i--) <br>        { <br>        hMenuT=GetSubMenu(hMenu, i); <br> <br>        for (j=0; j &lt;= CMENUS; j++) <br>            { <br>//Remove any owned popup, or our special help menu <br>            if (hMenuT==m_phMenu[j] <br>                || (hMenuT==m_hMenuHelp &amp;&amp; m_hMenuHelp!=NULL)) <br>                RemoveMenu(hMenu, i, MF_BYPOSITION); <br>            } <br>        } <br> <br>m_fUsingOurHelp=FALSE; <br> <br>    //The menu should now be empty. <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::SetStatusText <br> * <br> * Purpose: <br> *  Asks the container to place some text in a status line, if one <br> *  exists.  If the container does not have a status line it <br> *  should return E_FAIL here in which case the object could <br> *  display its own. <br> * <br> * Parameters: <br> *  pszText         LPCOLESTR to display. <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if successful, S_TRUNCATED if not all <br> *                  of the text could be displayed, or E_FAIL if <br> *                  the container has no status line. <br> */ <br> <br>STDMETHODIMP CFrame::SetStatusText(LPCOLESTR pszText) <br>    { <br>    //We have no status line... <br>    return E_NOTIMPL; <br>    } <br> <br> <br> <br>/* <br> * CFrame::EnableModeless <br> * <br> * Purpose: <br> *  Instructs the container to show or hide any modeless popup <br> *  windows that it may be using. <br> * <br> * Parameters: <br> *  fEnable         BOOL indicating to enable/show the windows <br> *                  (TRUE) or to hide them (FALSE). <br> * <br> * Return Value: <br> *  HRESULT         NOERROR <br> */ <br> <br>STDMETHODIMP CFrame::EnableModeless(BOOL fEnable) <br>    { <br>    return NOERROR; <br>    } <br> <br> <br> <br> <br>/* <br> * CFrame::TranslateAccelerator <br> * <br> * Purpose: <br> *  When dealing with an in-place object from an EXE server, this <br> *  is called to give the container a chance to process accelerators <br> *  after the server has looked at the message. <br> * <br> * Parameters: <br> *  pMSG            LPMSG for the container to examine. <br> *  wID             WORD the identifier in the container's <br> *                  accelerator table (from IOleInPlaceSite <br> *                  ::GetWindowContext) for this message (OLE does <br> *                  some translation before calling). <br> * <br> * Return Value: <br> *  HRESULT         NOERROR if the keystroke was used, <br> *                  S_FALSE otherwise. <br> */ <br> <br>STDMETHODIMP CFrame::TranslateAccelerator(LPMSG pMSG, WORD wID) <br>    { <br>    /* <br>     * wID already has anything translated from m_hAccel for us, <br>     * so we can just check for the commands we want and process <br>     * them instead of calling TranslateAccelerator which would be <br>     * redundant and which also has a possibility of dispatching to <br>     * the wrong window. <br>     */ <br>    if (IDM_ENTERCONTEXTHELP==wID || IDM_ESCAPECONTEXTHELP==wID) <br>        { <br>        //wID properly expands to 32-bits <br>        OnCommand(m_hWnd, (WPARAM)wID, 0L); <br>        return NOERROR; <br>        } <br> <br>    return S_FALSE; <br>    } <br> <br> <br>/* <br> * IOleCommandTarget methods, provided to make PowerPoint happy <br> * with this frame. <br> */ <br> <br>STDMETHODIMP CFrame::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds <br>    , OLECMD *prgCmds, OLECMDTEXT *pCmdText) <br>{ <br>return OLECMDERR_E_UNKNOWNGROUP; <br>} <br>         <br>STDMETHODIMP CFrame::Exec(const GUID *pguidCmdGroup, DWORD nCmdID <br>    , DWORD nCmdexecopt, VARIANTARG *pvaIn, VARIANTARG *pvaOut) <br>{ <br>return OLECMDERR_E_UNKNOWNGROUP; <br>} <br>     </code></pre>
<p>&nbsp;</p></body>
</HTML>
