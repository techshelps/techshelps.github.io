<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SITE.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context57"></a>SITE.CPP</h2>
<pre><code>/* <br> * SITE.CPP <br> * Document Object Site Object <br> * <br> * Copyright (c)1995-1997 Microsoft Corporation, All Rights Reserved <br> */ <br> <br> <br>#include "framer.h" <br> <br> <br>/* <br> * CSite::CSite <br> * CSite::~CSite <br> * <br> * Constructor Parameters: <br> *  dwID            DWORD identifer for this site. <br> *  hWnd            HWND of the window associated with the site <br> *  pFR             PCFrame to the parent structure. <br> */ <br> <br>CSite::CSite(DWORD dwID, HWND hWnd, PCFrame pFR) <br>    { <br>    m_cRef=0; <br>    m_dwID=dwID; <br>    m_hWnd=hWnd; <br>    m_pFR=pFR; <br> <br>    m_fInitialized=0; <br>    m_pIStorage=NULL; <br> <br>    m_pObj=NULL; <br>     <br>    m_pIOleObject=NULL; <br>    m_pIOleIPObject=NULL; <br>    m_pIOleDocView=NULL; <br> <br>    m_pImpIOleClientSite=NULL; <br>    m_pImpIAdviseSink=NULL; <br>    m_pImpIOleIPSite=NULL; <br>    m_pImpIOleDocumentSite=NULL; <br> <br>    m_fDocObj=FALSE; <br>    return; <br>    } <br> <br> <br>CSite::~CSite(void) <br>    { <br>    //Object pointers cleaned up in Close. <br> <br>    //We delete our own interfaces since we control them <br>    DeleteInterfaceImp(m_pImpIOleDocumentSite); <br>    DeleteInterfaceImp(m_pImpIOleIPSite); <br>    DeleteInterfaceImp(m_pImpIAdviseSink); <br>    DeleteInterfaceImp(m_pImpIOleClientSite); <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CSite::QueryInterface <br> * CSite::AddRef <br> * CSite::Release <br> * <br> * Purpose: <br> *  IUnknown members for CSite object. <br> */ <br> <br>STDMETHODIMP CSite::QueryInterface(REFIID riid, void **ppv) <br>    { <br>    *ppv=NULL; <br> <br>    if (IID_IUnknown==riid) <br>        *ppv=this; <br> <br>    if (IID_IOleClientSite==riid) <br>        *ppv=m_pImpIOleClientSite; <br> <br>    if (IID_IAdviseSink==riid) <br>        *ppv=m_pImpIAdviseSink; <br> <br>    if (IID_IOleWindow==riid || IID_IOleInPlaceSite==riid) <br>        *ppv=m_pImpIOleIPSite; <br> <br>    if (IID_IOleDocumentSite==riid) <br>        *ppv=m_pImpIOleDocumentSite; <br> <br>    if (NULL!=*ppv) <br>        { <br>        ((LPUNKNOWN)*ppv)-&gt;AddRef(); <br>        return NOERROR; <br>        } <br> <br>    return ResultFromScode(E_NOINTERFACE); <br>    } <br> <br> <br>STDMETHODIMP_(ULONG) CSite::AddRef(void) <br>    { <br>    return ++m_cRef; <br>    } <br> <br>STDMETHODIMP_(ULONG) CSite::Release(void) <br>    { <br>    if (0!=--m_cRef) <br>        return m_cRef; <br> <br>    delete this; <br>    return 0; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CSite::Create <br> * <br> * Purpose: <br> *  Asks the site to instantiate an object given a filename. <br> *  This goes through OleCreateFromFile and will either create <br> *  an embedded object or a package (embedded) object.  When <br> *  activated, this will either launch the app and activate <br> *  as a DocObject, launch the app and open the file, or fail <br> *  because no app can open the file. <br> * <br> * Parameters: <br> *  pszFile         LPTSTR of the file from which to create the object. <br> *  pIStorage       IStorage * of the parent storage in which we're <br> *                  to create an IStorage for the new object. <br> *  dwID            DWORD identifier for this site. <br> * <br> * Return Value: <br> *  BOOL            Result of the creation. <br> */ <br> <br>BOOL CSite::Create(LPTSTR pszFile, IStorage *pIStorage) <br>    { <br>    HRESULT             hr=E_FAIL; <br>    LPUNKNOWN           pObj; <br> <br>    //Create a new storage for this object (sets m_pIStorage) <br>    if (!CreateStorage(pIStorage)) <br>        return FALSE; <br> <br>    //Now create an object from the file <br>   #ifdef UNICODE     <br>    hr=OleCreateFromFile(CLSID_NULL, pszFile, IID_IUnknown <br>        , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void **)&amp;pObj); <br>   #else <br>    OLECHAR     szFile[512];    //Assumption on string length <br> <br>    MultiByteToWideChar(CP_ACP, 0, pszFile, -1, szFile, 512);     <br>hr=OleCreateFromFile(CLSID_NULL, szFile, IID_IUnknown <br>        , OLERENDER_NONE, NULL, NULL, m_pIStorage, (void **)&amp;pObj); <br>   #endif <br> <br>    //If creation didn't work, get rid of the element Open created. <br>    if (FAILED(hr)) <br>        { <br>        Destroy(pIStorage); <br>        return FALSE; <br>        } <br> <br>    //We don't get the size if PatronObject data was seen already. <br>    if (!ObjectInitialize(pObj)) <br>        { <br>        Destroy(pIStorage); <br>        return FALSE; <br>        } <br> <br>    m_fInitialized=TRUE; <br>    return TRUE; <br>    } <br> <br> <br> <br> <br> <br> <br>/* <br> * CSite::ObjectInitialize <br> * (Protected) <br> * <br> * Purpose: <br> *  Performs operations necessary after creating an object or <br> *  reloading one from storage. <br> * <br> * Parameters: <br> *  pObj            LPUNKNOWN of the object in this tenant. <br> *  pFE             LPFORMATETC describing the graphic here. <br> *  dwData          DWORD extra data.  If pFE-&gt;dwAspect== <br> *                  DVASPECT_ICON then this is the iconic metafile. <br> * <br> * Return Value: <br> *  BOOL            TRUE if the function succeeded, FALSE otherwise. <br> */ <br> <br>BOOL CSite::ObjectInitialize(LPUNKNOWN pObj) <br>    { <br>    HRESULT         hr; <br>    DWORD           dw; <br> <br>    if (NULL==pObj) <br>        return FALSE; <br> <br>    m_pObj=pObj; <br> <br>    //We need an IOleObject most of the time, so get one here. <br>    m_pIOleObject=NULL; <br>    hr=pObj-&gt;QueryInterface(IID_IOleObject, (void **)&amp;m_pIOleObject);          <br> <br>    /* <br>     * Follow up object creation with advises and so forth.  If <br>     * we cannot get IOleObject here, then we know we can't do <br>     * any IOleObject actions from here on--object is static. <br>     */ <br>    if (FAILED(hr)) <br>        return TRUE; <br> <br>    //SetClientSite is critical for DocObjects <br>    m_pIOleObject-&gt;SetClientSite(m_pImpIOleClientSite); <br>    m_pIOleObject-&gt;Advise(m_pImpIAdviseSink, &amp;dw); <br> <br>//This is to give PowerPoint a chance to initialize itself earlier <br>OleRun(m_pIOleObject); <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CSite::CreateStorage <br> * <br> * Purpose: <br> *  Creates an sub-storage within a given parent storage, <br> *  setting m_pIStorage. <br> * <br> * Parameters: <br> *  pIStorage       IStorage * of the parent storage <br> * <br> * Return Value: <br> *  BOOL            TRUE if creation succeeds, FALSE otherwise. <br> */ <br> <br>BOOL CSite::CreateStorage(IStorage *pIStorage) <br>    { <br>    HRESULT     hr; <br>    DWORD       dwMode=STGM_TRANSACTED | STGM_READWRITE <br>                    | STGM_SHARE_EXCLUSIVE; <br>    TCHAR       szName[32]; <br> <br>    if (NULL==pIStorage) <br>        return FALSE; <br> <br>    /* <br>     * Attempt to open the storage under this ID.  If there is <br>     * none, then create it.  In either case we end up with an <br>     * IStorage that we either save in pPage or release. <br>     */ <br>    wsprintf(szName, TEXT("Site %lu"), m_dwID); <br> <br>   #ifdef UNICODE <br>    hr=pIStorage-&gt;CreateStorage(szName, dwMode, 0, 0, &amp;m_pIStorage); <br>   #else <br>    OLECHAR  szwName[32]; <br>MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 32);     <br>    hr=pIStorage-&gt;CreateStorage(szwName, dwMode, 0, 0, &amp;m_pIStorage); <br>   #endif <br> <br>    if (FAILED(hr)) <br>        return FALSE; <br> <br>//Create stream for the object; name is irrelevant <br>dwMode=STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE; <br>   #ifdef UNICODE <br>    hr=m_pIStorage-&gt;CreateStream(TEXT("\003DocObjInfo"), dwMode, 0, 0 <br>        , &amp;m_pIStream); <br>   #else     <br>MultiByteToWideChar(CP_ACP, 0, "\003DocObjInfo", -1, szwName, 32);     <br>    hr=m_pIStorage-&gt;CreateStream(szwName, dwMode, 0, 0, &amp;m_pIStream); <br>   #endif <br>    <br>    //If we failed to create a stream in the file, do it in memory <br>if (FAILED(hr)) <br>{ <br>if (FAILED(CreateStreamOnHGlobal(NULL, TRUE, &amp;m_pIStream))) <br>    return FALSE; <br>} <br> <br>    //Create interface implementations <br>    m_pImpIOleClientSite=new CImpIOleClientSite(this, this); <br>    m_pImpIAdviseSink=new CImpIAdviseSink(this, this); <br>    m_pImpIOleIPSite=new CImpIOleInPlaceSite(this, this); <br>    m_pImpIOleDocumentSite=new CImpIOleDocumentSite(this, this); <br> <br>    if (NULL==m_pImpIOleClientSite || NULL==m_pImpIAdviseSink <br>        || NULL==m_pImpIOleIPSite || NULL==m_pImpIOleDocumentSite) <br>        return FALSE; <br> <br>    return TRUE; <br>    } <br> <br> <br> <br> <br>/* <br> * CSite::Close <br> * <br> * Purpose: <br> *  Possibly commits the storage, then releases it, afterwards <br> *  frees alls the object pointers. <br> * <br> * Parameters: <br> *  fCommit         BOOL indicating if we're to commit. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSite::Close(BOOL fCommit) <br>    { <br>    //OnInPlaceDeactivate releases this pointer. <br>    if (NULL!=m_pIOleIPObject) <br>        m_pIOleIPObject-&gt;InPlaceDeactivate(); <br> <br>    ReleaseInterface(m_pIOleDocView); <br> <br>    if (NULL!=m_pIOleObject) <br>        { <br>        m_pIOleObject-&gt;Close(fCommit <br>            ? OLECLOSE_SAVEIFDIRTY : OLECLOSE_NOSAVE); <br>        ReleaseInterface(m_pIOleObject); <br>        } <br> <br>    ReleaseInterface(m_pObj); <br>ReleaseInterface(m_pIStream); <br>    ReleaseInterface(m_pIStorage); <br> <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CSite::Update <br> * <br> * Purpose: <br> *  Forces a commit on the object's storage <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSite::Update(void) <br>    { <br>    LPPERSISTSTORAGE    pIPS; <br> <br>    if (NULL!=m_pIStorage) <br>        return; <br> <br>    m_pObj-&gt;QueryInterface(IID_IPersistStorage, (void **)&amp;pIPS); <br>    OleSave(pIPS, m_pIStorage, TRUE); <br>    pIPS-&gt;SaveCompleted(NULL); <br>    pIPS-&gt;Release(); <br> <br>    m_pIStorage-&gt;Commit(STGC_DEFAULT); <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CSite::Destroy <br> * <br> * Purpose: <br> *  Removes this storage from the parent storage.  The caller should <br> *  eventually delete this CSite object to free the object herein. <br> *  Nothing is committed when being destroyed. <br> * <br> * Parameters: <br> *  pIStorage       IStorage * of the parent <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSite::Destroy(IStorage *pIStorage) <br>    { <br>    TCHAR     szName[32]; <br> <br>    if (NULL==pIStorage) <br>        return; <br> <br>    if (NULL!=m_pObj) <br>        Close(FALSE); <br>     <br>wsprintf(szName, TEXT("Site %lu"), m_dwID); <br>   #ifdef UNICODE <br>    pIStorage-&gt;DestroyElement(szName); <br>   #else <br>    OLECHAR  szwName[32]; <br>MultiByteToWideChar(CP_ACP, 0, szName, -1, szwName, 512);     <br>pIStorage-&gt;DestroyElement(szwName);     <br>   #endif <br>    return; <br>    } <br> <br> <br> <br> <br> <br>/* <br> * CSite::Activate <br> * <br> * Purpose: <br> *  Activates a verb on the object living in the site. <br> * <br> * Parameters: <br> *  iVerb           LONG of the verb to execute. <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSite::Activate(LONG iVerb) <br>    { <br>    CHourglass *pHour; <br>    RECT        rc; <br>             <br>    pHour=new CHourglass; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br>    m_pIOleObject-&gt;DoVerb(iVerb, NULL, m_pImpIOleClientSite, 0 <br>        , m_hWnd, &amp;rc); <br> <br>    delete pHour; <br>    return; <br>    } <br> <br> <br> <br> <br>/* <br> * CSite::UpdateObjectRects <br> * <br> * Purpose: <br> *  Informs the site that the client area window was resized and <br> *  that the site needs to also tell the DocObject of the resize. <br> * <br> * Parameters: <br> *  None <br> * <br> * Return Value: <br> *  None <br> */ <br> <br>void CSite::UpdateObjectRects(void) <br>    { <br>    RECT    rc; <br> <br>    if (NULL==m_pIOleDocView) <br>        return; <br> <br>    GetClientRect(m_hWnd, &amp;rc); <br>    m_pIOleDocView-&gt;SetRect(&amp;rc); <br>    return; <br>    } </code></pre>
<p>&nbsp;</p></body>
</HTML>
