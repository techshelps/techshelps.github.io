<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>WIMGCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context149"></a>WIMGCTL.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// WImgCtl.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// <br>// <br>#include "IPServer.H" <br> <br>#include "Guids.H" <br>#include "LocalObj.H" <br>#include "Util.H" <br>#include "Globals.H" <br>#include "Resource.H" <br>#include "Wimgctl.H" <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>WCHAR wszImage [] = L"Image"; <br> <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// all the events in this control <br>// <br>// TODO: add events here ... <br>// <br> <br>//=--------------------------------------------------------------------------= <br>// array describing all of our property pages.  these clsids are typically <br>// in guids.h <br>// <br>// TODO: add any additional property page guids here ... <br>// <br>const GUID *rgWebImagePropPages [] = { <br>    &amp;CLSID_WebImageGeneralPage <br>}; <br> <br>//=--------------------------------------------------------------------------= <br>// Custum Verb information <br>// <br>// TODO: add any custom verbs here in an array, using the VERBINFO structure. <br>//       then mark the controld def'n in WebImageCtl.H with <br>//       this verb array <br>// <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::Create <br>//=--------------------------------------------------------------------------= <br>// global static function that creates an instance of the control an returns <br>// an IUnknown pointer for it. <br>// <br>// Parameters: <br>//    IUnknown *        - [in] controlling unknown for aggregation <br>// <br>// Output: <br>//    IUnknown *        - new object. <br>// <br>// Notes: <br>// <br>IUnknown *CWebImageControl::Create <br>( <br>    IUnknown *pUnkOuter <br>) <br>{ <br>    // make sure we return the private unknown so that we support aggegation <br>    // correctly! <br>    // <br>    CWebImageControl *pNew = new CWebImageControl(pUnkOuter); <br>    return pNew-&gt;PrivateUnknown(); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::CWebImageControl <br>//=--------------------------------------------------------------------------= <br>// "Being born is like being kidnapped.  And then sold into slavery." <br>//    - andy warhol (1928 - 87) <br>// <br>// Parameters: <br>//    IUnknown *        - [in] <br>// <br>// Notes: <br>// <br>#pragma warning(disable:4355)  // using 'this' in constructor <br>CWebImageControl::CWebImageControl <br>( <br>    IUnknown *pUnkOuter <br>) <br>: CInternetControl(pUnkOuter, OBJECT_TYPE_CTLWEBIMAGE, (IDispatch *)this) <br>{ <br>m_bmpPath = 0; <br>m_dib = 0; <br>m_dibFile = 0; <br>m_state= bdsNoBitsYet; <br> <br>} <br>#pragma warning(default:4355)  // using 'this' in constructor <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::~CWebImageControl <br>//=--------------------------------------------------------------------------= <br>// "We all labour against our own cure, for death is the cure of all diseases" <br>//    - Sir Thomas Browne (1605 - 82) <br>// <br>// Notes: <br>// <br>CWebImageControl::~CWebImageControl () <br>{ <br>if(m_bmpPath) <br>delete [] m_bmpPath; <br>if( m_dibFile ) <br>delete m_dibFile; <br>if( m_dib ) <br>delete m_dib; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl:RegisterClassData <br>//=--------------------------------------------------------------------------= <br>// register the window class information for your control here. <br>// this information will automatically get cleaned up for you on DLL shutdown. <br>// <br>// Output: <br>//    BOOL            - FALSE means fatal error. <br>// <br>// Notes: <br>// <br>BOOL CWebImageControl::RegisterClassData() <br>{ <br>    WNDCLASS wndclass; <br> <br>    // TODO: register any additional information you find interesting here. <br>    //       this method is only called once for each type of control <br>    // <br>    memset(&amp;wndclass, 0, sizeof(WNDCLASS)); <br>    wndclass.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC; <br>    wndclass.lpfnWndProc    = COleControl::ControlWindowProc; <br>    wndclass.hInstance      = g_hInstance; <br>    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>    wndclass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_CTLWEBIMAGE); <br> <br>    return RegisterClass(&amp;wndclass); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::BeforeCreateWindow <br>//=--------------------------------------------------------------------------= <br>// called just before the window is created.  Great place to set up the <br>// window title, etc, so that they're passed in to the call to CreateWindowEx. <br>// speeds things up slightly. <br>// <br>// Notes: <br>// <br>void CWebImageControl::BeforeCreateWindow() <br>{ <br>} <br> <br>BOOL CWebImageControl::AfterCreateWindow() <br>{ <br>m_dc = ::GetDC(m_hwnd); <br>HPALETTE hpal = ::CreateHalftonePalette(m_dc); <br>::SelectPalette(m_dc, hpal, FALSE); <br> <br>        UpdateImage(); <br>        return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// qi for things only we support. <br>// <br>// Parameters: <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CWebImageControl::InternalQueryInterface <br>( <br>    REFIID  riid, <br>    void  **ppvObjOut <br>) <br>{ <br>    IUnknown *pUnk; <br> <br>    *ppvObjOut = NULL; <br> <br>    // TODO: if you want to support any additional interrfaces, then you should <br>    // indicate that here.  never forget to call COleControl's version in the <br>    // case where you don't support the given interface. <br>    // <br>    if (DO_GUIDS_MATCH(riid, IID_IWebImage)) { <br>        pUnk = (IUnknown *)(IWebImage *)this; <br>    } else{ <br>        return COleControl::InternalQueryInterface(riid, ppvObjOut); <br>    } <br> <br>    pUnk-&gt;AddRef(); <br>    *ppvObjOut = (void *)pUnk; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::LoadTextState <br>//=--------------------------------------------------------------------------= <br>// load in our text state for this control. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] property bag to read from <br>//    IErrorLog *           - [in] errorlog object to use with proeprty bag <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - NOTE: if you have a binary object, then you should pass an unknown <br>//      pointer to the property bag, and it will QI it for IPersistStream, and <br>//      get said object to do a Load() <br>// <br>STDMETHODIMP CWebImageControl::LoadTextState <br>( <br>    IPropertyBag *pPropertyBag, <br>    IErrorLog    *pErrorLog <br>) <br>{ <br>    VARIANT v; <br> <br>VariantInit(&amp;v); <br> <br>    v.vt = VT_BSTR; <br>    v.bstrVal = NULL; <br> <br>HRESULT hr = S_OK; <br>    // try to load in the property.  if we can't get it, then leave <br>    // things at their default. <br>    // <br>    pPropertyBag-&gt;Read(::wszImage, &amp;v, pErrorLog); <br>    if (v.bstrVal) { <br>        MAKE_ANSIPTR_FROMWIDE(psz, v.bstrVal); <br>hr = SetBmpPath(psz); <br>        VariantClear(&amp;v); <br>    } <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::LoadBinaryState <br>//=--------------------------------------------------------------------------= <br>// loads in our binary state using streams. <br>// <br>// Parameters: <br>//    IStream *            - [in] stream to write to. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>const DWORD STREAMHDR_MAGIC = 12345678L; <br> <br>STDMETHODIMP CWebImageControl::LoadBinaryState <br>( <br>    IStream *pStream <br>) <br>{ <br>DWORDsh; <br>    HRESULThr; <br> <br>    // first read in the streamhdr, and make sure we like what we're getting <br>    // <br>    hr = pStream-&gt;Read(&amp;sh, sizeof(sh), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // sanity check <br>    // <br>    if (sh != STREAMHDR_MAGIC ) <br>return E_UNEXPECTED; <br> <br>return(SetBmpPath(pStream)); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::SaveTextState <br>//=--------------------------------------------------------------------------= <br>// saves out the text state for this control using a property bag. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] the property bag with which to work. <br>//    BOOL                  - [in] if TRUE, then write out ALL properties, even <br>//                            if they're their the default value ... <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CWebImageControl::SaveTextState <br>( <br>    IPropertyBag *pPropertyBag, <br>    BOOL          fWriteDefaults <br>) <br>{ <br>    HRESULT hr; <br>    VARIANT v; <br> <br>    v.vt = VT_BSTR; <br>    v.bstrVal = BSTRFROMANSI(m_bmpPath); <br>    RETURN_ON_NULLALLOC(v.bstrVal); <br> <br>    // this control currently only persists out the caption property <br>    // <br>    hr = pPropertyBag-&gt;Write(::wszImage, &amp;v); <br>    VariantClear(&amp;v); <br>    return hr;} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::SaveBinaryState <br>//=--------------------------------------------------------------------------= <br>// save out the binary state for this control, using the given IStream object. <br>// <br>// Parameters: <br>//    IStream  *             - [in] save to which you should save. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - it is important that you seek to the end of where you saved your <br>//      properties when you're done with the IStream. <br>// <br>STDMETHODIMP CWebImageControl::SaveBinaryState <br>( <br>    IStream *pStream <br>) <br>{ <br>    DWORD sh = STREAMHDR_MAGIC; <br>    HRESULT hr; <br> <br>    // write out the stream hdr. <br>    // <br>    hr = pStream-&gt;Write(&amp;sh, sizeof(sh), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // write out he control state information <br>    // <br> <br>DWORD dw = m_bmpPath ? lstrlen(m_bmpPath) : 0; <br> <br>hr = pStream-&gt;Write(&amp;dw,sizeof(dw),0); <br>RETURN_ON_FAILURE(hr); <br> <br>if( dw ) <br>hr = pStream-&gt;Write(m_bmpPath,dw+1,0); <br> <br>    return hr; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::OnDraw <br>//=--------------------------------------------------------------------------= <br>// "I don't very much enjoy looking at paintings in general.  i know too <br>//  much about them.  i take them apart." <br>//    - georgia o'keeffe (1887-1986) <br>// <br>// Parameters: <br>//    DWORD              - [in]  drawing aspect <br>//    HDC                - [in]  HDC to draw to <br>//    LPCRECTL           - [in]  rect we're drawing to <br>//    LPCRECTL           - [in]  window extent and origin for meta-files <br>//    HDC                - [in]  HIC for target device <br>//    BOOL               - [in]  can we optimize dc handling? <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT CWebImageControl::OnDraw <br>( <br>    DWORD    dvAspect, <br>    HDC      hdcDraw, <br>    LPCRECTL prcBounds, <br>    LPCRECTL prcWBounds, <br>    HDC      hicTargetDevice, <br>    BOOL     fOptimize <br>) <br>{ <br>if(m_dib)  <br>{ <br>if (prcWBounds != NULL) //printing <br>{ <br>SetMapMode(hdcDraw,MM_TEXT); <br>HBITMAP hBitmap; <br>//printing DIB <br>hBitmap = (HBITMAP) HANDLE(*m_dib); <br>DIBSECTION ds; <br>GetObject(hBitmap,sizeof(DIBSECTION),(LPSTR)&amp;ds); <br>StretchDIBits(hdcDraw,prcBounds-&gt;left,prcBounds-&gt;top,prcBounds-&gt;right - prcBounds-&gt;left, <br>prcBounds-&gt;bottom - prcBounds-&gt;top,0,0, <br>ds.dsBm.bmWidth, ds.dsBm.bmHeight, <br>ds.dsBm.bmBits,  <br>(BITMAPINFO *)(*m_dibFile),  <br>DIB_RGB_COLORS, <br>SRCCOPY); <br>return S_OK; <br>} <br> <br>if( hdcDraw != m_dc ) <br>{ <br>HPALETTE hpal = ::CreateHalftonePalette(hdcDraw); <br>::SelectPalette(hdcDraw, hpal, FALSE); <br>} <br> <br>::RealizePalette(hdcDraw); <br> <br>m_dib-&gt;PaintTo(hdcDraw,prcBounds-&gt;left,prcBounds-&gt;top); <br> <br>} <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::OnProgress <br>//=--------------------------------------------------------------------------= <br>// <br>// Parameters: <br>//    DISPIDpropId- [in]  Same dispId that was passed into SetupDownload <br>//    ULONGprogress- [in]  Size downlaoded so far <br>//    ULONG     themax- [in]  Overall size of object being downloaded <br>//    ULONGstatusFlag- [in]  Flags according  <br>//    LPCWSTR   statusStr- [in]Readable version of status <br>// <br>// Notes: <br>// <br>HRESULT CWebImageControl::OnProgress <br>( <br>DISPIDpropId,  <br>ULONGprogress,  <br>ULONGthemax,  <br>ULONGstatusFlag, <br>LPCWSTRstatusString <br>) <br>{ <br>// TODO: put custom progress UI notification code here. The default action <br>//(shown below) is to fire an OnProgress event to the host <br> <br>return(FireProgress(themax ? (progress * 100)/themax : 0)); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::WindowProc <br>//=--------------------------------------------------------------------------= <br>// window procedure for this control.  nothing terribly exciting. <br>// <br>// Parameters: <br>//     see win32sdk on window procs. <br>// <br>// Notes: <br>// <br>LRESULT CWebImageControl::WindowProc <br>( <br>    UINT   msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>) <br>{ <br>    // TODO: handle any messages here, like in a normal window <br>    // proc.  note that for special keys, you'll want to override and <br>    // implement OnSpecialKey. <br>    // <br>    return OcxDefWindowProc(msg, wParam, lParam); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::AboutBox <br>//=--------------------------------------------------------------------------= <br>// prints up an about box.  fweeeee. <br>// <br>// Notes: <br>// <br>void CWebImageControl::AboutBox <br>( <br>    void <br>) <br>{ <br>    // TODO: Ideally, one would use DialogBox, and some sort of Dialog Box here if <br>    // they wanted a slightly more interesting About Box ...  you should <br>    // still call ModalDialog first, however. <br>    // <br>    ModalDialog(TRUE); <br>    MessageBox(NULL, "This is My Control", "About WebImage", MB_OK | MB_TASKMODAL); <br>    ModalDialog(FALSE); <br>} <br> <br>STDMETHODIMP  CWebImageControl::get_Image(BSTR * path) <br>{ <br>CHECK_POINTER(path); <br> <br>// Actually we need to be accepting (happily IMoniker objects) <br> <br>//path-&gt;vt = VT_BSTR; <br> <br>BSTR * pbstrPath = path; //&amp;path-&gt;bstrVal; <br>     <br>    *pbstrPath = (m_bmpPath &amp;&amp; *m_bmpPath) ? BSTRFROMANSI(m_bmpPath) : SysAllocString(L""); <br> <br>    return (*pbstrPath) ? S_OK : E_OUTOFMEMORY; <br>} <br> <br>STDMETHODIMP  CWebImageControl::put_Image(BSTR path) <br>{ <br>// NOTE: We should reference and IMoniker*!! <br> <br>//if( path.vt != VT_BSTR ) <br>//return(E_UNEXPECTED); <br> <br>BSTR &amp; bstrPath = path; //.bstrVal; <br>    // get an ANSI pointer, so we can stuff it in our local buffer for captions! <br>    // <br> <br>    MAKE_ANSIPTR_FROMWIDE(pszPath, bstrPath); <br> <br>HRESULT hr = SetBmpPath(pszPath); <br> <br>// update anybody who cares about property changes and mark ourselves <br>// as dirty <br>// <br>PropertyChanged(DISPID_BMPPATH); <br>m_fDirty = TRUE; <br> <br>    return hr; <br>} <br> <br>STDMETHODIMP  CWebImageControl::Scramble() <br>{ <br>HRESULT hr; <br> <br>        if (m_dib) <br>{ <br>unsigned char * p = m_dib-&gt;Base(); <br>DWORDdw = m_dib-&gt;ImageSize(); <br> <br>for( DWORD i = 0; i &lt; dw; i+=3,p+=3 ) <br>*p ^= 0x55; <br> <br>InvalidateControl(0); <br> <br>hr = S_OK; <br>} <br>else <br>{ <br>hr = E_FAIL; // E_PENDING; <br>} <br> <br> <br>return(hr); <br>} <br> <br>HRESULT CWebImageControl::SetBmpPath(const char *psz) <br>{ <br>    // if it hasn't changed, don't waste any time. <br>    // <br>    if (psz &amp;&amp; m_bmpPath ) <br>{ <br>CHECK_POINTER(psz); <br>if( !lstrcmp(m_bmpPath, psz) ) <br>return S_OK; <br>} <br> <br>if( m_bmpPath ) <br>delete [] m_bmpPath; <br> <br>if(!psz) <br>{ <br>m_bmpPath = 0; <br>return(S_OK); <br>} <br> <br>CHECK_POINTER(psz); <br> <br>if( !*psz ) <br>{ <br>m_bmpPath = 0; <br>return(S_OK); <br>} <br> <br>DWORD dw = lstrlen(psz); <br> <br>m_bmpPath = new char[dw + 1]; <br> <br>if( !m_bmpPath ) <br>{ <br>FAIL("No memory"); <br>return(E_OUTOFMEMORY); <br>} <br> <br>lstrcpy(m_bmpPath, psz); <br> <br>        UpdateImage(); <br> <br>return(S_OK); <br>} <br> <br>HRESULT CWebImageControl::SetBmpPath(IStream * strm) <br>{ <br>CHECK_POINTER(strm); <br> <br>char * tmp = 0; <br> <br>if( m_bmpPath ) <br>delete [] m_bmpPath; <br> <br>DWORDdw; <br>HRESULT hr = strm-&gt;Read(&amp;dw,sizeof(dw),0); <br> <br>if( SUCCEEDED(hr) ) <br>{ <br>if( !dw ) <br>{ <br>hr = S_OK; <br>} <br>else <br>{ <br>tmp = new char[dw+1]; <br> <br>if( !tmp ) <br>{ <br>FAIL("No memory"); <br>hr = E_OUTOFMEMORY; <br>} <br>else <br>{ <br>hr = strm-&gt;Read(tmp,dw+1,0); <br>} <br>} <br>} <br> <br>// if it hasn't changed, don't waste any time. <br>    // <br>    if ((!tmp &amp;&amp; !m_bmpPath) || !lstrcmp(m_bmpPath, tmp)) <br>        return S_OK; <br> <br>if( m_bmpPath ) <br>delete [] m_bmpPath; <br> <br>m_bmpPath = tmp; <br> <br>        UpdateImage(); <br> <br>return(hr); <br>} <br> <br>HRESULT CWebImageControl::UpdateImage() <br>{ <br>if( !m_hwnd ) <br>return(S_OK); <br> <br>if( !m_bmpPath ) <br>return(S_OK); <br> <br>return( SetupDownload(OLESTRFROMANSI(m_bmpPath),DISPID_BMPPATH) ); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CWebImageControl::OnData <br>//=--------------------------------------------------------------------------= <br>// <br>// Parameters: <br>//    DISPIDpropId- [in]  Same dispId that was passed into SetupDownload <br>//    DWORDgrfBSCF- [in]  Notification flags ("URL Moniker" specification) <br>//    IStream *strm- [in]  Stream to read data from <br>//    DWORDdwSize- [in]  Overall size available so far <br>// <br>// <br>//Notes:This is the class that is monitering and interpreting the bits that <br>//are being downloaded. The methods in class inherited from IBindStatusCallback <br>//are only called during 'DispatchMessage' calls from the main applications loop. <br>//This impelmentation maintains a state machine for the bits as they arrive: <br>// <br>//Initial state:No bits have been seen yet <br>// <br>//              Have BITMAPFILEHEADER   We now have this structure. At this point there is <br>//enough information to calculate the following values: <br>//- The file is actually a Windows BMP file <br>//- The size of the entire image <br>//- This size of the BITMAPINFO structure <br>// <br>//Have BITMAPINFOWe now have enough information to call  <br>//CreateDibSection! That function will return a  <br>//a buffer it allocated. <br>// <br>//Getting BITSAt this point the bits are arriving and all we  <br>//have to do is strm-&gt;Read the bits directly into <br>//buffer returned from the step above and notify <br>//our view sink that we need refreshing. <br>// <br>//BITS are done(nothing to do!?) <br>// <br>HRESULT CWebImageControl::OnData <br>( <br>DISPIDpropId, <br>DWORDgrfBSCF, <br>IStream *strm, <br>DWORDdwSize <br>) <br>{ <br>HRESULThr= NOERROR; <br> <br>switch(m_state) <br>{ <br>case bdsNoBitsYet: <br>{ <br>if( dwSize &gt;= sizeof(BITMAPFILEHEADER) ) <br>{ <br>                    CHECK_POINTER(strm); <br>                    strm-&gt;AddRef(); <br> <br>if( m_dibFile ) <br>delete m_dibFile; <br> <br>m_dibFile = new CDibFile; <br> <br>if( !m_dibFile ) <br>{ <br>hr = E_OUTOFMEMORY; <br>break; <br>} <br> <br>hr = m_dibFile-&gt;GetFileHeader(strm); <br> <br>if( FAILED(hr) ) <br>break; <br> <br>m_state = bdsGotFileHeader; <br> <br>// now FALL THRU! <br>} <br>else <br>{ <br>break; <br>} <br>} <br> <br>case bdsGotFileHeader: <br>{ <br>if( dwSize &gt;= (m_dibFile-&gt;HeaderSize() + sizeof(BITMAPFILEHEADER)) ) <br>{ <br>if( m_dibFile ) <br>hr = m_dibFile-&gt;GetInfoHeader(strm); <br>else <br>hr = E_OUTOFMEMORY; <br> <br>if( FAILED(hr) ) <br>break; <br> <br>if( m_dib ) <br>delete m_dib; <br> <br>m_dib = new CDibSection; <br> <br>if( !m_dib ) <br>{ <br>hr = E_OUTOFMEMORY; <br>break; <br>} <br> <br>m_dib-&gt;Setup(m_dc); <br> <br>hr = m_dib-&gt;Create(*m_dibFile); <br> <br>if( FAILED(hr) ) <br>break; <br> <br>m_dib-&gt;ImageSize( m_dibFile-&gt;CalcImageSize() ); <br>m_state = bdsGotBitmapInfo; <br> <br>// FALL THRU! <br> <br>} <br>else <br>{ <br>break; <br>} <br>} <br> <br>case bdsGotBitmapInfo: <br>{ <br>SIZELsz; <br>m_dib-&gt;GetSize(sz); <br>SetControlSize(&amp;sz); <br> <br>// we need m_dibFile for printing <br>//delete m_dibFile; <br>//m_dibFile = 0; <br> <br>m_state = bdsGettingBits; <br> <br>// FALL THRU <br>} <br> <br>case bdsGettingBits: <br>{ <br>if( dwSize &gt; 0 ) <br>{ <br>hr = m_dib-&gt;ReadFrom( strm, dwSize ); <br> <br>if( FAILED(hr) ) <br>break; <br> <br>::RealizePalette(m_dc); <br> <br>m_dib-&gt;PaintTo(m_dc); <br>} <br> <br>if( grfBSCF &amp; BSCF_LASTDATANOTIFICATION ) <br>m_state = bdsBitsAreDone; <br>else <br>break; <br>} <br> <br>case bdsBitsAreDone: <br>{ <br>m_state = bdsNoBitsYet; <br>                strm-&gt;Release(); <br>break; <br>} <br> <br>} <br> <br>return(hr); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
