<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DIBCLS.CPP</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context139"></a>DIBCLS.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// DibCls.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// contains the CDibFile and CDibSection classes. <br>// <br>#include "IPServer.H" <br> <br>#include "DibCls.H" <br> <br>#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4) <br> <br>//=--------------------------------------------------------------------------= <br>// DIB Utitilty Classes <br>//=--------------------------------------------------------------------------= <br>// Not wholey generic but getting there... <br>// <br>// Notes: <br>// <br>CDibFile::CDibFile() <br>{ <br>m_headerSize = 0; <br>m_bmi.p = 0; <br>} <br> <br>CDibFile::~CDibFile() <br>{ <br>if( m_bmi.p ) <br>delete m_bmi.p; <br>} <br> <br> <br>DWORD CDibFile::CalcImageSize() <br>{ <br>DWORD &amp; dw = m_bmi.p-&gt;bmiHeader.biSizeImage; <br>if( dw == 0) <br>        dw = WIDTHBYTES((DWORD)m_bmi.p-&gt;bmiHeader.biWidth * <br>                m_bmi.p-&gt;bmiHeader.biBitCount) * m_bmi.p-&gt;bmiHeader.biHeight; <br> <br>return(dw); <br>} <br> <br>HRESULT CDibFile::GetInfoHeader( IStream * strm ) <br>{ <br>HRESULT hr = S_OK; m_bmi.bytes = new unsigned char[ m_headerSize ]; <br> <br>if( !m_bmi.bytes ) <br>hr = E_OUTOFMEMORY; <br> <br>if( SUCCEEDED(hr) ) <br>hr = strm-&gt;Read(m_bmi.bytes,m_headerSize,0); <br> <br>if( SUCCEEDED(hr) ) <br>CalcImageSize(); <br> <br>return(hr); <br>} <br> <br>HRESULT CDibFile::GetFileHeader(IStream * strm) <br>{ <br>BITMAPFILEHEADERbmfh; <br> <br>HRESULThr = strm-&gt;Read(&amp;bmfh,sizeof(bmfh),0); <br> <br>if( SUCCEEDED(hr) &amp;&amp; (bmfh.bfType != 0x4d42 )) <br>hr = E_UNEXPECTED; <br> <br>if( SUCCEEDED(hr) ) <br>m_headerSize = bmfh.bfOffBits - sizeof(bmfh); <br> <br>return(hr); <br>} <br> <br> <br>CDibSection::CDibSection() <br>{ <br>m_bitsBase= 0; <br>m_current= 0; <br>m_memDC= 0; <br>m_handle= <br>m_oldBitmap = 0; <br>m_w= <br>m_h= 32;  // totally arbitrary <br>} <br> <br>CDibSection::~CDibSection() <br>{ <br>if( m_memDC ) <br>{ <br>if( m_oldBitmap ) <br>::SelectObject( m_memDC, m_oldBitmap ); <br> <br>::DeleteDC(m_memDC); <br>} <br> <br>if( m_handle ) <br>::DeleteObject(m_handle); <br> <br>} <br> <br> <br>HRESULT CDibSection::Create(CDibFile&amp; dibFile) <br>{ <br>HRESULThr= S_OK; <br>BITMAPINFOHEADER *bmih= dibFile;// will convert itself <br> <br>m_handle = ::CreateDIBSection( <br>m_memDC,// handle to device context <br>dibFile,// pointer to structure containing bitmap size, <br>//format, and color data <br>DIB_RGB_COLORS,// color data type indicator: RGB values or <br>//palette indices <br>(void **)&amp;m_bitsBase,// pointer to variable to receive a pointer <br>//to the bitmap's bit values <br>0,// optional handle to a file mapping object <br>0// offset to the bitmap bit values <br>//within the file mapping object <br>); <br> <br>if( !m_handle ) <br>hr = E_FAIL; <br> <br>if( SUCCEEDED(hr) ) <br>{ <br>m_oldBitmap = (HBITMAP) ::SelectObject( m_memDC, m_handle ); <br> <br>if( !m_oldBitmap ) <br>hr = E_FAIL; <br>} <br> <br>if( SUCCEEDED(hr) ) <br>{ <br>m_current = m_bitsBase; <br> <br>m_w = bmih-&gt;biWidth; <br>m_h = bmih-&gt;biHeight; <br> <br>if( m_h &lt; 0 ) <br>m_h *= -1; <br>} <br> <br>return(hr); <br>} <br> <br>HRESULT CDibSection::ReadFrom( IStream * strm, DWORD amount ) <br>{ <br>   DWORD    dwRead      = 0; <br>   HRESULT  hr; <br> <br>   do <br>   { <br>      hr = strm-&gt;Read(m_current, m_imageSize, &amp;dwRead); <br> <br>      if (SUCCEEDED(hr) || hr == E_PENDING) <br>          m_current += dwRead; <br>   } <br>   while (!(hr == E_PENDING || hr == S_FALSE) &amp;&amp; SUCCEEDED(hr)); <br> <br>   return (hr); <br>} <br> <br> <br>HRESULT CDibSection::Setup(HDC hdc) <br>{ <br>m_memDC = ::CreateCompatibleDC(hdc); <br> <br>return( m_memDC ? NOERROR : E_FAIL ); <br>} <br> <br> <br>HRESULTCDibSection::PaintTo(HDC hdc, int x, int y) <br>{ <br>BOOL b = BitBlt( <br> hdc,// handle to destination device context <br> x,// x-coordinate of destination rectangle's upper-left corner <br> y,// x-coordinate of destination rectangle's upper-left corner <br> m_w,// width of destination rectangle <br> m_h,// height of destination rectangle <br> m_memDC,// handle to source device context <br> 0,// x-coordinate of source rectangle's upper-left corner <br> 0,// y-coordinate of source rectangle's upper-left corner <br> SRCCOPY// raster operation code <br>); <br> <br>return( b ? NOERROR : E_FAIL ); <br>} <br> <br>HRESULTCDibSection::GetSize(SIZEL &amp;sz) <br>{ <br>sz.cx = m_w; <br>sz.cy = m_h; <br> <br>return(S_OK); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
