<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context101"></a>AUTOOBJ.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// AutoObj.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// all of our objects will inherit from this class to share as much of the same <br>// code as possible.  this super-class contains the unknown, dispatch and <br>// error info implementations for them. <br>// <br>#include "IPServer.H" <br>#include "LocalSrv.H" <br> <br>#include "AutoObj.H" <br>#include "Globals.H" <br>#include "Util.H" <br> <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::CAutomationObject <br>//=--------------------------------------------------------------------------= <br>// create the object and initialize the refcount <br>// <br>// Parameters: <br>//    IUnknown *      - [in] controlling Unknown <br>//    int             - [in] the object type that we are <br>//    void *          - [in] the VTable of of the object we really are. <br>// <br>// Notes: <br>// <br>CAutomationObject::CAutomationObject  <br>( <br>    IUnknown *pUnkOuter, <br>    int   ObjType, <br>    void *pVTable, <br>BOOL fExpandoEnabled <br>) <br>: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType) <br>{ <br>    m_fLoadedTypeInfo = FALSE; <br>m_fExpandoEnabled = fExpandoEnabled; <br>m_pexpando = NULL; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::~CAutomationObject <br>//=--------------------------------------------------------------------------= <br>// "I have a rendezvous with Death, At some disputed barricade" <br>// - Alan Seeger (1888-1916) <br>// <br>// Notes: <br>// <br>CAutomationObject::~CAutomationObject () <br>{ <br>    // if we loaded up a type info, release our count on the globally stashed <br>    // type infos, and release if it becomes zero. <br>    // <br>    if (m_fLoadedTypeInfo) { <br> <br>        // we have to crit sect this since it's possible to have more than <br>        // one thread partying with this object. <br>        // <br>        EnterCriticalSection(&amp;g_CriticalSection); <br>        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos"); <br>        CTYPEINFOOFOBJECT(m_ObjectType)--; <br> <br>        // if we're the last one, free that sucker! <br>        // <br>        if (!CTYPEINFOOFOBJECT(m_ObjectType)) { <br>            PTYPEINFOOFOBJECT(m_ObjectType)-&gt;Release(); <br>            PTYPEINFOOFOBJECT(m_ObjectType) = NULL; <br>        } <br>        LeaveCriticalSection(&amp;g_CriticalSection); <br>    } <br> <br>if (m_pexpando) <br>{ <br>delete m_pexpando; <br>} <br>    return; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// the controlling unknown will call this for us in the case where they're <br>// looking for a specific interface. <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CAutomationObject::InternalQueryInterface <br>( <br>    REFIID riid, <br>    void **ppvObjOut <br>) <br>{ <br>    ASSERT(ppvObjOut, "controlling Unknown should be checking this!"); <br> <br>    // start looking for the guids we support, namely IDispatch, and  <br>    // IDispatchEx <br> <br>    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) { <br>// If expando functionality is enabled, attempt to allocate an <br>// expando object and return that for the IDispatch interface. <br>// If the allocation fails, we will fall back on using the regular <br>// IDispatch from m_pvInterface; <br>if (m_fExpandoEnabled) <br>{ <br>if (!m_pexpando) <br>m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);   <br> <br>if (m_pexpando) <br>{ <br>*ppvObjOut = (void*)(IDispatch*) m_pexpando; <br>((IUnknown *)(*ppvObjOut))-&gt;AddRef(); <br>return S_OK; <br>} <br>} <br> <br>        *ppvObjOut = (void*) (IDispatch*) m_pvInterface; <br>        ((IUnknown *)(*ppvObjOut))-&gt;AddRef(); <br>        return S_OK; <br>    } <br>    else if (DO_GUIDS_MATCH(riid, IID_IDispatchEx) &amp;&amp; m_fExpandoEnabled) { <br>// Allocate the expando object if it hasn't been allocated already <br>if (!m_pexpando) <br>m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);   <br> <br>// If the allocation succeeded, return the IDispatchEx interface from <br>// the expando.  Otherwise fall through to CUnknownObject::InternalQueryInterface, <br>// (which will most likely fail) <br>if (m_pexpando) <br>{ <br> *ppvObjOut = (void *)(IDispatchEx *) m_pexpando; <br>((IUnknown *)(*ppvObjOut))-&gt;AddRef(); <br>return S_OK; <br>} <br>    } <br> <br>    // just get our parent class to process it from here on out. <br>    // <br>    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::GetTypeInfoCount <br>//=--------------------------------------------------------------------------= <br>// returns the number of type information interfaces that the object provides <br>// <br>// Parameters: <br>//    UINT *            - [out] the number of interfaces supported. <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG <br>// <br>// Notes: <br>// <br>STDMETHODIMP CAutomationObject::GetTypeInfoCount <br>( <br>    UINT *pctinfo <br>) <br>{ <br>    // arg checking <br>    // <br>    if (!pctinfo) <br>        return E_INVALIDARG; <br> <br>    // we support GetTypeInfo, so we need to return the count here. <br>    // <br>    *pctinfo = 1; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::GetTypeInfo <br>//=--------------------------------------------------------------------------= <br>// Retrieves a type information object, which can be used to get the type <br>// information for an interface. <br>// <br>// Parameters: <br>//    UINT              - [in]  the type information they'll want returned <br>//    LCID              - [in]  the LCID of the type info we want <br>//    ITypeInfo **      - [out] the new type info object. <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_INVALIDARG, etc. <br>// <br>// Notes: <br>// <br>STDMETHODIMP CAutomationObject::GetTypeInfo <br>( <br>    UINT        itinfo, <br>    LCID        lcid, <br>    ITypeInfo **ppTypeInfoOut <br>) <br>{ <br>    DWORD       dwPathLen; <br>    char        szDllPath[MAX_PATH]; <br>    HRESULT     hr; <br>    ITypeLib   *pTypeLib; <br>    ITypeInfo **ppTypeInfo =NULL; <br> <br>    // arg checking <br>    // <br>    if (itinfo != 0) <br>        return DISP_E_BADINDEX; <br> <br>    if (!ppTypeInfoOut) <br>        return E_POINTER; <br> <br>    *ppTypeInfoOut = NULL; <br> <br>    // ppTypeInfo will point to our global holder for this particular <br>    // type info.  if it's null, then we have to load it up. if it's not <br>    // NULL, then it's already loaded, and we're happy. <br>    // crit sect this entire nightmare so we're okay with multiple <br>    // threads trying to use this object. <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType); <br> <br>    if (*ppTypeInfo == NULL) { <br> <br>        ITypeInfo *pTypeInfoTmp; <br>        HREFTYPE   hrefType; <br> <br>        // we don't have the type info around, so go load the sucker. <br>        // <br>        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0, <br>                            LANG_NEUTRAL, &amp;pTypeLib); <br> <br>        // if, for some reason, we failed to load the type library this <br>        // way, we're going to try and load the type library directly out of <br>        // our resources.  this has the advantage of going and re-setting all <br>        // the registry information again for us. <br>        // <br>        if (FAILED(hr)) { <br> <br>            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH); <br>            if (!dwPathLen) { <br>                hr = E_FAIL; <br>                goto CleanUp; <br>            } <br> <br>            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath); <br>            hr = LoadTypeLib(pwsz, &amp;pTypeLib); <br>            CLEANUP_ON_FAILURE(hr); <br>        } <br> <br>        // we've got the Type Library now, so get the type info for the interface <br>        // we're interested in. <br>        // <br>        hr = pTypeLib-&gt;GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &amp;pTypeInfoTmp); <br>        pTypeLib-&gt;Release(); <br>        CLEANUP_ON_FAILURE(hr); <br> <br>        // the following couple of lines of code are to dereference the dual <br>        // interface stuff and take us right to the dispatch portion of the <br>        // interfaces. <br>        // <br>        hr = pTypeInfoTmp-&gt;GetRefTypeOfImplType(0xffffffff, &amp;hrefType); <br>        if (FAILED(hr)) { <br>            pTypeInfoTmp-&gt;Release(); <br>            goto CleanUp; <br>        } <br> <br>        hr = pTypeInfoTmp-&gt;GetRefTypeInfo(hrefType, ppTypeInfo); <br>        pTypeInfoTmp-&gt;Release(); <br>        CLEANUP_ON_FAILURE(hr); <br> <br>        // add an extra reference to this object.  if it ever becomes zero, then <br>        // we need to release it ourselves.  crit sect this since more than <br>        // one thread can party on this object. <br>        // <br>        CTYPEINFOOFOBJECT(m_ObjectType)++; <br>        m_fLoadedTypeInfo = TRUE; <br>    } <br> <br> <br>    // we still have to go and addref the Type info object, however, so that <br>    // the people using it can release it. <br>    // <br>    (*ppTypeInfo)-&gt;AddRef(); <br>    *ppTypeInfoOut = *ppTypeInfo; <br>    hr = S_OK; <br> <br>  CleanUp: <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br>    return hr; <br>} <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::GetIDsOfNames <br>//=--------------------------------------------------------------------------= <br>// Maps a single member and an optional set of argument names to a <br>// corresponding set of integer DISPIDs <br>// <br>// Parameters: <br>//    REFIID            - [in]  must be IID_NULL <br>//    OLECHAR **        - [in]  array of names to map. <br>//    UINT              - [in]  count of names in the array. <br>//    LCID              - [in]  LCID on which to operate <br>//    DISPID *          - [in]  place to put the corresponding DISPIDs. <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME, <br>//                        DISP_E_UNKNOWNLCID <br>// <br>// Notes: <br>//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle, <br>//      and to let this superclass handle it. <br>// <br>STDMETHODIMP CAutomationObject::GetIDsOfNames <br>( <br>    REFIID    riid, <br>    OLECHAR **rgszNames, <br>    UINT      cNames, <br>    LCID      lcid, <br>    DISPID   *rgdispid <br>) <br>{ <br>    HRESULT     hr; <br>    ITypeInfo  *pTypeInfo; <br> <br>    if (!DO_GUIDS_MATCH(riid, IID_NULL)) <br>        return E_INVALIDARG; <br> <br>    // get the type info for this dude! <br>    // <br>    hr = GetTypeInfo(0, lcid, &amp;pTypeInfo); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // use the standard provided routines to do all the work for us. <br>    // <br>    hr = pTypeInfo-&gt;GetIDsOfNames(rgszNames, cNames, rgdispid); <br>    pTypeInfo-&gt;Release(); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::Invoke <br>//=--------------------------------------------------------------------------= <br>// provides access to the properties and methods on this object. <br>// <br>// Parameters: <br>//    DISPID            - [in]  identifies the member we're working with. <br>//    REFIID            - [in]  must be IID_NULL. <br>//    LCID              - [in]  language we're working under <br>//    USHORT            - [in]  flags, propput, get, method, etc ... <br>//    DISPPARAMS *      - [in]  array of arguments. <br>//    VARIANT *         - [out] where to put result, or NULL if they don't care. <br>//    EXCEPINFO *       - [out] filled in in case of exception <br>//    UINT *            - [out] where the first argument with an error is. <br>// <br>// Output: <br>//    HRESULT           - tonnes of them. <br>// <br>// Notes: <br>//     <br>STDMETHODIMP CAutomationObject::Invoke <br>( <br>    DISPID      dispid, <br>    REFIID      riid, <br>    LCID        lcid, <br>    WORD        wFlags, <br>    DISPPARAMS *pdispparams, <br>    VARIANT    *pvarResult, <br>    EXCEPINFO  *pexcepinfo, <br>    UINT       *puArgErr <br>) <br>{ <br>    HRESULT    hr; <br>    ITypeInfo *pTypeInfo; <br> <br>    if (!DO_GUIDS_MATCH(riid, IID_NULL)) <br>        return E_INVALIDARG; <br> <br>    // get our typeinfo first! <br>    // <br>    hr = GetTypeInfo(0, lcid, &amp;pTypeInfo); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // Clear exceptions <br>    // <br>    SetErrorInfo(0L, NULL); <br> <br>    // This is exactly what DispInvoke does--so skip the overhead. <br>    // <br>    hr = pTypeInfo-&gt;Invoke(m_pvInterface, dispid, wFlags, <br>                           pdispparams, pvarResult, <br>                           pexcepinfo, puArgErr); <br>    pTypeInfo-&gt;Release(); <br> <br>return hr; <br> <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::Exception <br>//=--------------------------------------------------------------------------= <br>// fills in the rich error info object so that both our vtable bound interfaces <br>// and calls through ITypeInfo::Invoke get the right error informaiton. <br>// <br>// Parameters: <br>//    HRESULT          - [in] the SCODE that should be associated with this err <br>//    WORD             - [in] the RESOURCE ID of the error message. <br>//    DWORD            - [in] helpcontextid for the error <br>// <br>// Output: <br>//    HRESULT          - the HRESULT that was passed in. <br>// <br>// Notes: <br>// <br>HRESULT CAutomationObject::Exception <br>( <br>    HRESULT hrExcep, <br>    WORD    idException, <br>    DWORD   dwHelpContextID <br>) <br>{ <br>    ICreateErrorInfo *pCreateErrorInfo; <br>    IErrorInfo *pErrorInfo; <br>    WCHAR   wszTmp[256]; <br>    char    szTmp[256]; <br>    HRESULT hr; <br> <br> <br>    // first get the createerrorinfo object. <br>    // <br>    hr = CreateErrorInfo(&amp;pCreateErrorInfo); <br>    if (FAILED(hr)) return hrExcep; <br> <br>    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType)); <br> <br>    // set up some default information on it. <br>    // <br>    pCreateErrorInfo-&gt;SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType)); <br>    pCreateErrorInfo-&gt;SetHelpFile(wszHelpFile); <br>    pCreateErrorInfo-&gt;SetHelpContext(dwHelpContextID); <br> <br>    // load in the actual error string value.  max of 256. <br>    // <br>    LoadString(GetResourceHandle(), idException, szTmp, 256); <br>    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256); <br>    pCreateErrorInfo-&gt;SetDescription(wszTmp); <br> <br>    // load in the source <br>    // <br>    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256); <br>    pCreateErrorInfo-&gt;SetSource(wszTmp); <br> <br>    // now set the Error info up with the system <br>    // <br>    hr = pCreateErrorInfo-&gt;QueryInterface(IID_IErrorInfo, (void **)&amp;pErrorInfo); <br>    CLEANUP_ON_FAILURE(hr); <br> <br>    SetErrorInfo(0, pErrorInfo); <br>    pErrorInfo-&gt;Release(); <br> <br>  CleanUp: <br>    pCreateErrorInfo-&gt;Release(); <br>    return hrExcep; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::InterfaceSupportsErrorInfo <br>//=--------------------------------------------------------------------------= <br>// indicates whether or not the given interface supports rich error information <br>// <br>// Parameters: <br>//    REFIID        - [in] the interface we want the answer for. <br>// <br>// Output: <br>//    HRESULT       - S_OK = Yes, S_FALSE = No. <br>// <br>// Notes: <br>// <br>HRESULT CAutomationObject::InterfaceSupportsErrorInfo <br>( <br>    REFIID riid <br>) <br>{ <br>    // see if it's the interface for the type of object that we are. <br>    // <br>    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType)) <br>        return S_OK; <br> <br>    return S_FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject::GetResourceHandle    [helper] <br>//=--------------------------------------------------------------------------= <br>// virtual routine to get the resource handle.  virtual, so that inheriting <br>// objects, such as COleControl can use theirs instead, which goes and gets <br>// the Host's version ... <br>// <br>// Output: <br>//    HINSTANCE <br>// <br>// Notes: <br>// <br>HINSTANCE CAutomationObject::GetResourceHandle <br>( <br>    void <br>) <br>{ <br>    return ::GetResourceHandle(); <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
