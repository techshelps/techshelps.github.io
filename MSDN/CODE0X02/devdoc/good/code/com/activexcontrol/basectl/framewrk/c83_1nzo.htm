<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CLASSF.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context84"></a>CLASSF.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// ClassF.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// contains the implementation of the ClassFactory object. we support  <br>// IClassFactory and IClassFactory2 <br>// <br>#include "IPServer.H" <br>#include "LocalSrv.H" <br> <br>#include "ClassF.H" <br>#include "Globals.H" <br>#include "Unknown.H"                    // for CREATEFNOFOBJECT <br> <br>//=--------------------------------------------------------------------------= <br>// private module level data <br>//=--------------------------------------------------------------------------= <br>// <br> <br>// ASSERT and FAIL require this <br>// <br>SZTHISFILE <br> <br>// private routines for this file <br>// <br>HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID); <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::CClassFactory <br>//=--------------------------------------------------------------------------= <br>// create the object and initialize the refcount <br>// <br>// Parameters: <br>//    int            - [in] index into our global table of objects for this guy <br>// <br>// Notes: <br>// <br>CClassFactory::CClassFactory <br>( <br>    int iIndex <br>) <br>: m_iIndex(iIndex) <br>{ <br>    m_cRefs = 1; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::CClassFactory <br>//=--------------------------------------------------------------------------= <br>// "Life levels all men.  Death reveals the eminent." <br>// - George Bernard Shaw (1856 - 1950) <br>// <br>// Notes: <br>// <br>CClassFactory::~CClassFactory () <br>{ <br>    ASSERT(m_cRefs == 0, "Object being deleted with refs!"); <br>    return; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::QueryInterface <br>//=--------------------------------------------------------------------------= <br>// the user wants another interface.  we won't give 'em. very many. <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::QueryInterface <br>( <br>    REFIID riid, <br>    void **ppvObjOut <br>) <br>{ <br>    void *pv; <br> <br>    CHECK_POINTER(ppvObjOut); <br> <br>    // we support IUnknown, and the two CF interfaces <br>    // <br>    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) { <br>        pv = (void *)(IClassFactory *)this; <br>    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) { <br>        pv = (void *)(IClassFactory2 *)this; <br>    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) { <br>        pv = (void *)(IUnknown *)this; <br>    } else { <br>        *ppvObjOut = NULL; <br>        return E_NOINTERFACE; <br>    } <br> <br>    ((IUnknown *)pv)-&gt;AddRef(); <br>    *ppvObjOut = pv; <br>    return S_OK; <br>} <br> <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::AddRef <br>//=--------------------------------------------------------------------------= <br>// adds a tick to the current reference count. <br>// <br>// Output: <br>//    ULONG        - the new reference count <br>// <br>// Notes: <br>// <br>ULONG CClassFactory::AddRef <br>( <br>    void <br>) <br>{ <br>    return ++m_cRefs; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::Release <br>//=--------------------------------------------------------------------------= <br>// removes a tick from the count, and delets the object if necessary <br>// <br>// Output: <br>//    ULONG         - remaining refs <br>// <br>// Notes: <br>// <br>ULONG CClassFactory::Release <br>( <br>    void <br>) <br>{ <br>    ASSERT(m_cRefs, "No Refs, and we're being released!"); <br>    if(--m_cRefs) <br>        return m_cRefs; <br> <br>    delete this; <br>    return 0; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::CreateInstance <br>//=--------------------------------------------------------------------------= <br>// create an instance of some sort of object. <br>// <br>// Parameters: <br>//    IUnknown *        - [in]  controlling IUknonwn for aggregation <br>//    REFIID            - [in]  interface id for new object <br>//    void **           - [out] pointer to new interface object. <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED, <br>//                        E_OUTOFMEMORY, E_INVALIDARG <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::CreateInstance <br>( <br>    IUnknown *pUnkOuter, <br>    REFIID    riid, <br>    void    **ppvObjOut <br>) <br>{ <br>    // check args <br>    // <br>    if (!ppvObjOut) <br>        return E_INVALIDARG; <br> <br>    // check to see if we've done our licensing work.  we do this as late <br>    // as possible that people calling CreateInstanceLic don't suffer from <br>    // a performance hit here. <br>    // <br>    // crit sect this for apartment threading, since it's global <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (!g_fCheckedForLicense) { <br>        g_fMachineHasLicense = CheckForLicense(); <br>        g_fCheckedForLicense = TRUE; <br>    } <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    // check to see if they have the appropriate license to create this stuff <br>    // <br>    if (!g_fMachineHasLicense) <br>        return CLASS_E_NOTLICENSED; <br> <br>    // try to create one of the objects that we support <br>    // <br>    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::LockServer <br>//=--------------------------------------------------------------------------= <br>// lock the server so we can't unload <br>// <br>// Parameters: <br>//    BOOL        - [in] TRUE means addref, false means release lock count. <br>// <br>// Output: <br>//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::LockServer <br>( <br>    BOOL fLock <br>) <br>{ <br>    // update the lock count.  crit sect these in case of another thread. <br>    // <br>    if (fLock)   <br>        InterlockedIncrement(&amp;g_cLocks); <br>    else { <br>        ASSERT(g_cLocks, "D'oh! Lock Counting Problem"); <br>        InterlockedDecrement(&amp;g_cLocks); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::GetLicInfo <br>//=--------------------------------------------------------------------------= <br>// IClassFactory2 GetLicInfo <br>// <br>// Parameters: <br>//    LICINFO *          - unclear <br>// <br>// Output: <br>//    HRESULT            - unclear <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::GetLicInfo <br>( <br>    LICINFO *pLicInfo <br>) <br>{ <br>    CHECK_POINTER(pLicInfo); <br> <br>    pLicInfo-&gt;cbLicInfo = sizeof(LICINFO); <br> <br>    // This says whether RequestLicKey will work <br>    // <br>    pLicInfo-&gt;fRuntimeKeyAvail = g_fMachineHasLicense; <br> <br>    // This says whether the standard CreateInstance will work <br>    // <br>    pLicInfo-&gt;fLicVerified = g_fMachineHasLicense; <br> <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::RequestLicKey <br>//=--------------------------------------------------------------------------= <br>// IClassFactory2 RequestLicKey <br>// <br>// Parameters: <br>//    DWORD             - [in]  reserved <br>//    BSTR *            - [out] unclear <br>// <br>// Output: <br>//    HRESULT           - unclear <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::RequestLicKey <br>( <br>    DWORD  dwReserved, <br>    BSTR  *pbstr <br>) <br>{ <br>    // if the machine isn't licensed, then we're not about to give this to them ! <br>    // <br>    if (!g_fMachineHasLicense) <br>        return CLASS_E_NOTLICENSED; <br> <br>    *pbstr = GetLicenseKey(); <br>    return (*pbstr) ? S_OK : E_OUTOFMEMORY; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CClassFactory::CreateInstanceLic <br>//=--------------------------------------------------------------------------= <br>// create a new instance given a licensing key, etc ... <br>// <br>// Parameters: <br>//    IUnknown *        - [in]  controlling IUnknown for aggregation <br>//    IUnknown *        - [in]  reserved, must be NULL <br>//    REFIID            - [in]  IID We're looking for. <br>//    BSTR              - [in]  license key <br>//    void **           - [out] where to put the new object. <br>// <br>// Output: <br>//    HRESULT           - unclear <br>// <br>// Notes: <br>// <br>STDMETHODIMP CClassFactory::CreateInstanceLic <br>( <br>    IUnknown *pUnkOuter, <br>    IUnknown *pUnkReserved, <br>    REFIID    riid, <br>    BSTR      bstrKey, <br>    void    **ppvObjOut <br>) <br>{ <br>    *ppvObjOut = NULL; <br> <br>    // go and see if the key they gave us matches. <br>    // <br>    if (!CheckLicenseKey(bstrKey)) <br>        return CLASS_E_NOTLICENSED; <br> <br>    // if it does, then go and create the object. <br>    // <br>    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CreateOleObjectFromIndex <br>//=--------------------------------------------------------------------------= <br>// given an index in our object table, create an object from it. <br>// <br>// Parameters: <br>//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation <br>//    int              - [in]  index into our global table <br>//    void **          - [out] where to put resulting object. <br>//    REFIID           - [in]  the interface they want resulting object to be. <br>// <br>// Output: <br>//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CreateOleObjectFromIndex <br>( <br>    IUnknown *pUnkOuter, <br>    int       iIndex, <br>    void    **ppvObjOut, <br>    REFIID    riid <br>) <br>{ <br>    IUnknown *pUnk = NULL; <br>    HRESULT   hr; <br> <br>    // go and create the object <br>    // <br>    ASSERT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!"); <br>    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter); <br> <br>    // sanity check and make sure the object actually got allocated. <br>    // <br>    RETURN_ON_NULLALLOC(pUnk); <br> <br>    // make sure we support aggregation here properly -- if they gave us <br>    // a controlling unknown, then they -must- ask for IUnknown, and we'll <br>    // give them the private unknown the object gave us. <br>    // <br>    if (pUnkOuter) { <br>        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) { <br>            pUnk-&gt;Release(); <br>            return E_INVALIDARG; <br>        } <br> <br>        *ppvObjOut = (void *)pUnk; <br>        hr = S_OK; <br>    } else { <br> <br>        // QI for whatever the user wants. <br>        // <br>        hr = pUnk-&gt;QueryInterface(riid, ppvObjOut); <br>        pUnk-&gt;Release(); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
