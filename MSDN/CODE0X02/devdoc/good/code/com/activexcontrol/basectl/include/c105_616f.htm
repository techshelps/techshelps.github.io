<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context117"></a>UTIL.H</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// Util.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// contains utilities that we will find useful. <br>// <br>#ifndef _UTIL_H_ <br> <br>#include "Globals.H" <br> <br> <br>//=--------------------------------------------------------------------------= <br>// Misc Helper Routines <br>//=--------------------------------------------------------------------------= <br>// <br>HWND      GetParkingWindow(void); <br>HINSTANCE GetResourceHandle(void); <br> <br>//=--------------------------------------------------------------------------= <br>// miscellaneous [useful] numerical constants <br>//=--------------------------------------------------------------------------= <br>// the length of a guid once printed out with -'s, leading and trailing bracket, <br>// plus 1 for NULL <br>// <br>#define GUID_STR_LEN    40 <br> <br> <br>//=--------------------------------------------------------------------------= <br>// allocates a temporary buffer that will disappear when it goes out of scope <br>// NOTE: be careful of that -- make sure you use the string in the same or <br>// nested scope in which you created this buffer. people should not use this <br>// class directly.  use the macro(s) below. <br>// <br>class TempBuffer { <br>  public: <br>    TempBuffer(ULONG cBytes) { <br>        m_pBuf = (cBytes &lt;= 120) ? &amp;m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes); <br>        m_fHeapAlloc = (cBytes &gt; 120); <br>    } <br>    ~TempBuffer() { <br>        if (m_pBuf &amp;&amp; m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf); <br>    } <br>    void *GetBuffer() { <br>        return m_pBuf; <br>    } <br> <br>  private: <br>    void *m_pBuf; <br>    // we'll use this temp buffer for small cases. <br>    // <br>    char  m_szTmpBuf[120]; <br>    unsigned m_fHeapAlloc:1; <br>}; <br> <br>//=--------------------------------------------------------------------------= <br>// string helpers. <br>// <br>// given and ANSI String, copy it into a wide buffer. <br>// be careful about scoping when using this macro! <br>// <br>// how to use the below two macros: <br>// <br>//  ... <br>//  LPSTR pszA; <br>//  pszA = MyGetAnsiStringRoutine(); <br>//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA); <br>//  MyUseWideStringRoutine(pwsz); <br>//  ... <br>// <br>// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not <br>// have to be declared, and no clean up must be done. <br>// <br>#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \ <br>    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \ <br>    TempBuffer __TempBuffer##ptrname(__l##ptrname); \ <br>    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \ <br>    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer() <br> <br>// <br>// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE  <br>// character to map to 2 ansi characters this is a quick guarantee that enough <br>// space will be allocated. <br>// <br>#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \ <br>    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \ <br>    TempBuffer __TempBuffer##ptrname(__l##ptrname); \ <br>    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \ <br>    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer() <br> <br>#define STR_BSTR   0 <br>#define STR_OLESTR 1 <br>#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR) <br>#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR) <br>#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR) <br>#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR) <br>#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR) <br>#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR) <br> <br>LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType); <br>LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType); <br>LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType); <br> <br> <br>// takes a GUID, and a pointer to a buffer, and places the string form of the <br>// GUID in said buffer. <br>// <br>int StringFromGuidA(REFIID, LPSTR); <br> <br> <br>//=--------------------------------------------------------------------------= <br>// registry helpers. <br>// <br>// takes some information about an Automation Object, and places all the <br>// relevant information about it in the registry. <br>// <br>BOOL RegSetMultipleValues(HKEY hkey, ...); <br>BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject); <br>BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject); <br>BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId); <br>BOOL UnregisterUnknownObject(REFCLSID riidObject); <br>BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject); <br>#define UnregisterControlObject UnregisterAutomationObject <br>BOOL UnregisterTypeLibrary(REFCLSID riidLibrary); <br> <br>// deletes a key in the registr and all of it's subkeys <br>// <br>BOOL DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey); <br> <br> <br>//=--------------------------------------------------------------------------= <br>// conversion helpers. <br>// <br>void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels); <br>void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric); <br> <br> <br>#define _UTIL_H_ <br>#endif // _UTIL_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
