<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CARDCTL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context68"></a>CARDCTL.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CardCtl.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// <br>// <br>#include "IPServer.H" <br> <br>#include "Guids.H" <br>#include "LocalObj.H" <br>#include "Util.H" <br>#include "Globals.H" <br>#include "Resource.H" <br>#include "cardctl.H" <br> <br>#include "carddraw.h" <br> <br>extern HBITMAP cardcacheMem[]; <br>extern CRITICAL_SECTION drawCritSec; <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>WCHAR wszImage [] = L"Card"; <br> <br>//=--------------------------------------------------------------------------= <br>// all the events in this control <br>// <br>// TODO: add events here ... <br>// <br> <br>static VARTYPE rgMouse[] = { VT_I2, VT_I2, VT_I4, VT_I4 }; <br>enum { MouseMove=0, MouseDown, MouseUp, Click, DblClick }; <br> <br>static EVENTINFO rgEvents [] = { <br>    { DISPID_MOUSEMOVE, 4, rgMouse }, <br>    { DISPID_MOUSEDOWN, 4, rgMouse }, <br>    { DISPID_MOUSEUP, 4, rgMouse }, <br>    { DISPID_CLICK, 0, NULL }, <br>    { DISPID_DBLCLICK, 0, NULL }, <br>}; <br> <br>//=--------------------------------------------------------------------------= <br>// array describing all of our property pages.  these clsids are typically <br>// in guids.h <br>// <br>// TODO: add any additional property page guids here ... <br>// <br>const GUID *rgCardPropPages [] = { <br>    &amp;CLSID_CardGeneralPage <br>}; <br> <br>//=--------------------------------------------------------------------------= <br>// Custum Verb information <br>// <br>// TODO: add any custom verbs here in an array, using the VERBINFO structure. <br>//       then mark the controld def'n in CardCtl.H with <br>//       this verb array <br>// <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::CCardControl <br>//=--------------------------------------------------------------------------= <br>// "Being born is like being kidnapped.  And then sold into slavery." <br>//    - andy warhol (1928 - 87) <br>// <br>// Parameters: <br>//    IUnknown *        - [in] <br>// <br>// Notes: <br>// <br>#pragma warning(disable:4355)  // using 'this' in constructor <br>CCardControl::CCardControl <br>( <br>    IUnknown *pUnkOuter <br>) <br>: COleControl(pUnkOuter, OBJECT_TYPE_CTLCARD, (IDispatch *)this) <br>{ <br>    static SIZEL size = { CCardDraw::CardSizeX, CCardDraw::CardSizeY }; <br> <br>    m_number = DefaultNumber; <br>    m_suite = DefaultSuite; <br>    m_invert = DefaultInvert; <br>    m_cardalignment = DefaultCardAlignment; <br>    BackBrush = NULL; <br> <br>    SetControlSize( &amp;size ); <br> <br>#if 0 <br>// for better performance when the cards are first displayed (such as <br>// when a full deck is displayed to the user), un-ifdef this code.   <br>// for better initial control creation time, keep this code ifdef'd.   <br> <br>    // initialize the standard 52 cards (no jokers, no backs) <br>    if( !cardcacheMem[0] ) <br>    { <br>        EnterCriticalSection( &amp;drawCritSec ); <br>        if( !cardcacheMem[0] ) <br>        { <br>            CCardDraw cd( CCardDraw::DrawAll ); <br>            HDC drawDc; <br>            HBITMAP drawDcMem; <br>            int t; <br> <br>            drawDc = CreateCompatibleDC( NULL ); <br> <br>            for( t = 0; t &lt; 52; t++ ) <br>            { <br>                cardcacheMem[t] = cd.CreateDIBCard( drawDc ); <br>                drawDcMem = SelectObject( drawDc, cardcacheMem[t] ); <br>                cd.DrawCard( drawDc, (t/14) + 1, (t%14) + 1 ); <br>                SelectObject( drawDc, drawDcMem ); <br>            } <br>            DeleteDC( drawDc ); <br>        } <br>        LeaveCriticalSection( &amp;drawCritSec ); <br>    } <br>#endif <br>} <br>#pragma warning(default:4355)  // using 'this' in constructor <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::~CCardControl <br>//=--------------------------------------------------------------------------= <br>// "We all labour against our own cure, for death is the cure of all diseases" <br>//    - Sir Thomas Browne (1605 - 82) <br>// <br>// Notes: <br>// <br>CCardControl::~CCardControl () <br>{ <br>if( BackBrush ) <br>DeleteObject( BackBrush ); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl:RegisterClassData <br>//=--------------------------------------------------------------------------= <br>// register the window class information for your control here. <br>// this information will automatically get cleaned up for you on DLL shutdown. <br>// <br>// Output: <br>//    BOOL            - FALSE means fatal error. <br>// <br>// Notes: <br>// <br>BOOL CCardControl::RegisterClassData() <br>{ <br>    WNDCLASS wndclass; <br> <br>    // TODO: register any additional information you find interesting here. <br>    //       this method is only called once for each type of control <br>    // <br>    memset(&amp;wndclass, 0, sizeof(WNDCLASS)); <br>    wndclass.style          = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS | CS_OWNDC; <br>    wndclass.lpfnWndProc    = COleControl::ControlWindowProc; <br>    wndclass.hInstance      = g_hInstance; <br>    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW); <br>    wndclass.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1); <br>    wndclass.lpszClassName  = WNDCLASSNAMEOFCONTROL(OBJECT_TYPE_CTLCARD); <br> <br>    return RegisterClass(&amp;wndclass); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// qi for things only we support. <br>// <br>// Parameters: <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CCardControl::InternalQueryInterface <br>( <br>    REFIID  riid, <br>    void  **ppvObjOut <br>) <br>{ <br>    IUnknown *pUnk; <br> <br>    *ppvObjOut = NULL; <br> <br>    // TODO: if you want to support any additional interrfaces, then you should <br>    // indicate that here.  never forget to call COleControl's version in the <br>    // case where you don't support the given interface. <br>    // <br>    if (DO_GUIDS_MATCH(riid, IID_ICard)) { <br>        pUnk = (IUnknown *)(ICard *)this; <br>    } else{ <br>        return COleControl::InternalQueryInterface(riid, ppvObjOut); <br>    } <br> <br>    pUnk-&gt;AddRef(); <br>    *ppvObjOut = (void *)pUnk; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::LoadTextState <br>//=--------------------------------------------------------------------------= <br>// load in our text state for this control. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] property bag to read from <br>//    IErrorLog *           - [in] errorlog object to use with proeprty bag <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - NOTE: if you have a binary object, then you should pass an unknown <br>//      pointer to the property bag, and it will QI it for IPersistStream, and <br>//      get said object to do a Load() <br>// <br>STDMETHODIMP CCardControl::LoadTextState <br>( <br>    IPropertyBag *pPropertyBag, <br>    IErrorLog    *pErrorLog <br>) <br>{ <br>    VARIANT v; <br>    HRESULT hr; <br> <br>    VariantInit(&amp;v); <br> <br>    v.vt = VT_I2; <br>    hr = pPropertyBag-&gt;Read(L"Number",&amp;v,pErrorLog); <br>    if (SUCCEEDED(hr)) <br>        m_number = (enumCardNumber) v.iVal; <br>    ValidateNumber(); <br>    VariantClear(&amp;v); <br> <br>    v.vt = VT_I2; <br>    hr = pPropertyBag-&gt;Read(L"Suite",&amp;v,pErrorLog); <br>    if (SUCCEEDED(hr)) <br>        m_suite = (enumCardSuite) v.iVal; <br>    ValidateSuite(); <br>    VariantClear(&amp;v); <br> <br>    v.vt = VT_BOOL; <br>    hr = pPropertyBag-&gt;Read(L"Invert",&amp;v,pErrorLog); <br>    if (SUCCEEDED(hr)) <br>        m_invert = v.boolVal; <br>    VariantClear(&amp;v); <br> <br>    v.vt = VT_I2; <br>    hr = pPropertyBag-&gt;Read(L"CardAlignment",&amp;v,pErrorLog); <br>    if (SUCCEEDED(hr)) <br>        m_cardalignment = (enumCardAlignment) v.iVal; <br>    ValidateCardAlignment(); <br>    VariantClear(&amp;v); <br> <br>    return S_OK; <br>} <br> <br>#defineSTREAMHDR_MAGIC1296924267 <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::LoadBinaryState <br>//=--------------------------------------------------------------------------= <br>// loads in our binary state using streams. <br>// <br>// Parameters: <br>//    IStream *            - [in] stream to write to. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CCardControl::LoadBinaryState <br>( <br>    IStream *pStream <br>) <br>{ <br>    HRESULT hr; <br>    DWORD sh; <br> <br>    hr = pStream-&gt;Read(&amp;sh, sizeof(sh), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    if (sh != STREAMHDR_MAGIC ) <br>        return E_UNEXPECTED; <br> <br>    hr = pStream-&gt;Read(&amp;(m_number),sizeof(m_number),NULL); <br>    RETURN_ON_FAILURE(hr); <br>    ValidateNumber(); <br> <br>    hr = pStream-&gt;Read(&amp;(m_suite),sizeof(m_suite),NULL); <br>    RETURN_ON_FAILURE(hr); <br>    ValidateSuite(); <br> <br>    hr = pStream-&gt;Read(&amp;(m_invert),sizeof(m_invert),NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    hr = pStream-&gt;Read(&amp;(m_cardalignment),sizeof(m_cardalignment),NULL); <br>    RETURN_ON_FAILURE(hr); <br>    ValidateCardAlignment(); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::SaveTextState <br>//=--------------------------------------------------------------------------= <br>// saves out the text state for this control using a property bag. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] the property bag with which to work. <br>//    BOOL                  - [in] if TRUE, then write out ALL properties, even <br>//                            if they're their the default value ... <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CCardControl::SaveTextState <br>( <br>    IPropertyBag *pPropertyBag, <br>    BOOL          fWriteDefaults <br>) <br>{ <br>    VARIANT v; <br>    HRESULT hr; <br> <br>    if( m_number != DefaultNumber ) <br>    { <br>        VariantInit(&amp;v); <br>        v.vt = VT_I2; <br>        v.iVal = m_number; <br>        hr = pPropertyBag-&gt;Write( L"Number", &amp;v); <br>    } <br> <br>    if( m_suite != DefaultSuite ) <br>    { <br>        VariantInit(&amp;v); <br>        v.vt = VT_I2; <br>        v.iVal = m_suite; <br>        hr = pPropertyBag-&gt;Write( L"Suite", &amp;v); <br>    } <br> <br>    if( m_invert != DefaultInvert ) <br>    { <br>        VariantInit(&amp;v); <br>        v.vt = VT_BOOL; <br>        v.boolVal = m_invert; <br>        hr = pPropertyBag-&gt;Write( L"Invert", &amp;v); <br>    } <br> <br>    if( m_cardalignment != DefaultCardAlignment ) <br>    { <br>        VariantInit(&amp;v); <br>        v.vt = VT_I2; <br>        v.iVal = m_cardalignment; <br>        hr = pPropertyBag-&gt;Write( L"CardAlignment", &amp;v); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::SaveBinaryState <br>//=--------------------------------------------------------------------------= <br>// save out the binary state for this control, using the given IStream object. <br>// <br>// Parameters: <br>//    IStream  *             - [in] save to which you should save. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - it is important that you seek to the end of where you saved your <br>//      properties when you're done with the IStream. <br>// <br>STDMETHODIMP CCardControl::SaveBinaryState <br>( <br>    IStream *pStream <br>) <br>{ <br>    HRESULT hr; <br>    DWORD sh = STREAMHDR_MAGIC;     <br> <br>    // write out the stream hdr. <br>    // <br>    hr = pStream-&gt;Write(&amp;sh, sizeof(sh), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    hr = pStream-&gt;Write(&amp;(m_number),sizeof(m_number),NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    hr = pStream-&gt;Write(&amp;(m_suite),sizeof(m_suite),NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    hr = pStream-&gt;Write(&amp;(m_invert),sizeof(m_invert),NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    hr = pStream-&gt;Write(&amp;(m_cardalignment),sizeof(m_cardalignment),NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::OnDraw <br>//=--------------------------------------------------------------------------= <br>// "I don't very much enjoy looking at paintings in general.  i know too <br>//  much about them.  i take them apart." <br>//    - georgia o'keeffe (1887-1986) <br>// <br>// Parameters: <br>//    HDC                - [in]  HDC to draw to <br>//    LPCRECTL           - [in]  rect we're drawing to <br>//    LPCRECTL           - [in]  window extent and origin for meta-files <br>//    HDC                - [in]  HIC for target device <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT CCardControl::OnDraw <br>( <br>    DWORD    dvaspect,         <br>    HDC      hdcDraw, <br>    LPCRECTL prcBounds, <br>    LPCRECTL prcWBounds, <br>    HDC      hicTargetDevice, <br>    BOOL     fOptimize <br>) <br>{ <br>    int OffsetX, OffsetY; <br>    RECTL rcBoundsDP; <br>    int width, height; <br>    int savedDC; <br>    HDC drawDc; <br>    HBITMAP drawDcMem; <br>    int c; <br> <br>    if( !Windowless() &amp;&amp; !BackBrush ) <br>    { <br>        OLE_COLOR BackColor; <br>        COLORREF BackColorCR; <br>        if( !GetAmbientProperty( DISPID_AMBIENT_BACKCOLOR, VT_I4, &amp;BackColor ) ) <br>                BackColor = 0; <br>        OleTranslateColor( BackColor, NULL, &amp;BackColorCR ); <br>        BackBrush = CreateSolidBrush( BackColorCR ); <br>    } <br> <br>    rcBoundsDP = *prcBounds; <br>    LPtoDP( hdcDraw, (POINT *) &amp;rcBoundsDP, 2 ); <br> <br>    width = rcBoundsDP.right - rcBoundsDP.left; <br>    height = rcBoundsDP.bottom - rcBoundsDP.top; <br> <br>    switch( m_cardalignment ) <br>    { <br>        case CardTopCenter: <br>        case CardCenter: <br>        case CardBottomCenter: <br>                OffsetX = (width - CCardDraw::CardSizeX) / 2; <br>                break; <br>        case CardTopRight: <br>        case CardCenterRight: <br>        case CardBottomRight: <br>                OffsetX = (width - CCardDraw::CardSizeX); <br>                break; <br>        default: <br>                OffsetX = 0; <br>                break; <br>    } <br>    switch( m_cardalignment ) <br>    { <br>         case CardCenterRight: <br>        case CardCenter: <br>        case CardCenterLeft: <br>                OffsetY = (height - CCardDraw::CardSizeY) / 2; <br>                break; <br>        case CardBottomRight: <br>        case CardBottomCenter: <br>        case CardBottomLeft: <br>                OffsetY = (height - CCardDraw::CardSizeY); <br>                break; <br>        default: <br>                OffsetY = 0; <br>                break; <br>    } <br> <br>    if( BackBrush ) <br>        FillRect( hdcDraw, (RECT *) prcBounds, BackBrush ); <br> <br>    if( m_suite == CardBlank ) <br>        return S_OK; <br> <br>    savedDC = SaveDC( hdcDraw ); <br> <br>    SetMapMode( hdcDraw, MM_TEXT ); <br>    SetWindowOrgEx( hdcDraw, -(OffsetX + rcBoundsDP.left), <br>                             -(OffsetY + rcBoundsDP.top), NULL ); <br>    SetViewportOrgEx( hdcDraw, 0, 0, NULL ); <br> <br>    if( width &lt; CCardDraw::CardSizeX || height &lt; CCardDraw::CardSizeY ) <br>    { <br>        HRGN clipRgn; <br>        clipRgn = CreateRectRgn( rcBoundsDP.left, <br>                                 rcBoundsDP.top, <br>                                 rcBoundsDP.left + width, <br>                                 rcBoundsDP.top + height ); <br>        SelectClipRgn( hdcDraw, clipRgn ); <br>        DeleteObject( clipRgn ); <br>    } <br> <br>    SelectObject( hdcDraw, GetStockObject( m_invert ? WHITE_PEN : BLACK_PEN ) ); <br> <br>    drawDc = CreateCompatibleDC( NULL ); <br> <br>    if( m_suite &gt; 0 ) <br>        c = (m_suite-1)*14 + (m_number-1); <br>    else <br>        c = (m_suite &lt; -12) ? 56 : -m_suite + 56; <br> <br>    if( !cardcacheMem[c] ) <br>    { <br>        CCardDraw cd( (c &gt; 55 ? CCardDraw::DrawBack : (int) m_number) ); <br> <br>        EnterCriticalSection( &amp;drawCritSec ); <br>        if( !cardcacheMem[c] ) <br>        { <br>            cardcacheMem[c] = cd.CreateDIBCard( hdcDraw ); <br>            drawDcMem = (HBITMAP) SelectObject( drawDc, cardcacheMem[c] ); <br>            cd.DrawCard( drawDc, m_suite, m_number ); <br>        } <br>        else <br>                drawDcMem = (HBITMAP) SelectObject( drawDc, cardcacheMem[c] ); <br>        LeaveCriticalSection( &amp;drawCritSec ); <br>    } <br>    else <br>        drawDcMem = (HBITMAP) SelectObject( drawDc, cardcacheMem[c] ); <br> <br>    if( m_cardalignment != CardStretch ) <br>    { <br>        BitBlt( hdcDraw, 1, 1, CCardDraw::CardSizeX-2, CCardDraw::CardSizeY-2, <br>                drawDc, 1, 1, m_invert ? NOTSRCCOPY : SRCCOPY ); <br>        Polyline( hdcDraw, CCardDraw::CardBorder, <br>                  sizeof(CCardDraw::CardBorder)/sizeof(POINT) ); <br>    } <br>    else <br>    { <br>        POINT border[9]; <br>        memcpy( border, CCardDraw::CardBorder, sizeof(border) ); <br>        border[2].x = border[5].x = width-3; <br>        border[3].x = border[4].x = width-1; <br>        border[4].y = border[7].y = height-3; <br>        border[5].y = border[6].y = height-1; <br>        StretchBlt( hdcDraw, 1, 1, width-2, height-2, <br>                    drawDc, 1, 1, <br>                    CCardDraw::CardSizeX-2, <br>                    CCardDraw::CardSizeY-2, <br>                    m_invert ? NOTSRCCOPY : SRCCOPY ); <br>        Polyline( hdcDraw, border, sizeof(border)/sizeof(POINT) ); <br>    } <br> <br>    RestoreDC( hdcDraw, savedDC ); <br> <br>    SelectObject( drawDc, drawDcMem ); <br>    DeleteDC( drawDc ); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::WindowProc <br>//=--------------------------------------------------------------------------= <br>// window procedure for this control.  nothing terribly exciting. <br>// <br>// Parameters: <br>//     see win32sdk on window procs. <br>// <br>// Notes: <br>// <br>LRESULT CCardControl::WindowProc <br>( <br>    UINT   msg, <br>    WPARAM wParam, <br>    LPARAM lParam <br>) <br>{ <br>    POINTS pt; <br>    RECT rect; <br>    int b, s; <br>    int ev = -1; <br> <br>    switch( msg ) <br>    { <br>    case WM_MOUSEMOVE: <br>            ev = MouseMove; <br>            // FALL THROUGH! <br>    case WM_LBUTTONDOWN: <br>    case WM_MBUTTONDOWN: <br>    case WM_RBUTTONDOWN: <br>            if( ev == -1 )  ev = MouseDown; <br>            // FALL THROUGH! <br>    case WM_LBUTTONUP: <br>    case WM_MBUTTONUP: <br>    case WM_RBUTTONUP: <br>            if( ev == -1 )  ev = MouseUp; <br>            pt = MAKEPOINTS( lParam ); <br>            OcxGetWindowRect( &amp;rect ); <br>            b = (wParam &amp; 3) == 3 ? 4 : wParam &amp; 3; <br>            s = (wParam &gt;&gt; 2) &amp; 7; <br>            FireEvent( &amp;rgEvents[ev], b, s, pt.x-rect.left, pt.y-rect.top ); <br>            if( msg == WM_LBUTTONUP ) <br>                    FireEvent( &amp;rgEvents[Click] ); <br>            break; <br>    case WM_LBUTTONDBLCLK: <br>            FireEvent( &amp;rgEvents[DblClick] ); <br>            break; <br>    } <br> <br>    return OcxDefWindowProc(msg, wParam, lParam); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::AboutBox <br>//=--------------------------------------------------------------------------= <br>// prints up an about box.  fweeeee. <br>// <br>// Notes: <br>// <br>void CCardControl::AboutBox <br>( <br>    void <br>) <br>{ <br>    // TODO: Ideally, one would use DialogBox, and some sort of Dialog Box here if <br>    // they wanted a slightly more interesting About Box ...  you should <br>    // still call ModalDialog first, however. <br>    // <br>    ModalDialog(TRUE); <br>    MessageBox(NULL, "Microsoft ActiveX Card Control\n\n" <br>                     "Copyright 1996 - 1998 Microsoft Corp.", <br>                     "About Card", <br>                     MB_OK | MB_TASKMODAL); <br>    ModalDialog(FALSE); <br>} <br> <br>STDMETHODIMP  CCardControl::get_Number(enumCardNumber * number) <br>{ <br>    CHECK_POINTER(number); <br> <br>    *number = m_number; <br> <br>    return( S_OK ); <br>} <br> <br>STDMETHODIMP  CCardControl::put_Number(enumCardNumber number) <br>{ <br>    if( m_number == number ) <br>            return S_OK; <br> <br>    m_number = number; <br>    ValidateNumber(); <br>    if( m_suite &gt;= 1 ) <br>    { <br>            if( Windowless() ) <br>            { <br>                    RECT rect; <br>                    OcxGetWindowRect( &amp;rect ); <br>                    OcxInvalidateRect( &amp;rect, TRUE ); <br>            } <br>            else <br>                    InvalidateControl( NULL ); <br>    } <br> <br>    // update anybody who cares about property changes and mark ourselves <br>    // as dirty <br>    // <br>    PropertyChanged(DISPID_NUMBER); <br>    m_fDirty = TRUE; <br> <br>return S_OK; <br>} <br> <br>STDMETHODIMP  CCardControl::get_Invert( VARIANT_BOOL *invert ) <br>{ <br>    CHECK_POINTER(invert); <br> <br>    *invert = m_invert; <br> <br>    return( S_OK ); <br>} <br> <br>STDMETHODIMP  CCardControl::put_Invert( VARIANT_BOOL invert ) <br>{ <br>    if( m_invert == invert ) <br>            return S_OK; <br> <br>    m_invert = invert; <br> <br>    { <br>            if( Windowless() ) <br>            { <br>                    RECT rect; <br>                    OcxGetWindowRect( &amp;rect ); <br>                    OcxInvalidateRect( &amp;rect, TRUE ); <br>            } <br>            else <br>                    InvalidateControl( NULL ); <br>    } <br> <br>    // update anybody who cares about property changes and mark ourselves <br>    // as dirty <br>    // <br>    PropertyChanged(DISPID_INVERT); <br>    m_fDirty = TRUE; <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP  CCardControl::get_CardAlignment( enumCardAlignment *cardalignment ) <br>{ <br>    CHECK_POINTER(cardalignment); <br> <br>    *cardalignment = m_cardalignment; <br> <br>    return( S_OK ); <br>} <br> <br>STDMETHODIMP  CCardControl::put_CardAlignment( enumCardAlignment cardalignment ) <br>{ <br>     if( m_cardalignment == cardalignment ) <br>            return S_OK; <br> <br>    m_cardalignment = cardalignment; <br>    ValidateCardAlignment(); <br> <br>    { <br>        if( Windowless() ) <br>        { <br>            RECT rect; <br>            OcxGetWindowRect( &amp;rect ); <br>            OcxInvalidateRect( &amp;rect, TRUE ); <br>        } <br>        else <br>                InvalidateControl( NULL ); <br>    } <br> <br>    // update anybody who cares about property changes and mark ourselves <br>    // as dirty <br>    // <br>    PropertyChanged(DISPID_CARDALIGNMENT); <br>    m_fDirty = TRUE; <br> <br>    return S_OK; <br>} <br> <br>STDMETHODIMP  CCardControl::get_Suite(enumCardSuite * suite) <br>{ <br>    CHECK_POINTER(suite); <br> <br>    *suite = m_suite; <br> <br>    return( S_OK ); <br>} <br> <br>STDMETHODIMP  CCardControl::put_Suite(enumCardSuite suite) <br>{ <br>    if( m_suite == suite ) <br>            return S_OK; <br> <br>    m_suite = suite; <br>    ValidateSuite(); <br> <br>    { <br>        if( Windowless() ) <br>        { <br>            RECT rect; <br>            OcxGetWindowRect( &amp;rect ); <br>            OcxInvalidateRect( &amp;rect, TRUE ); <br>        } <br>        else <br>                InvalidateControl( NULL ); <br>    } <br> <br>    // update anybody who cares about property changes and mark ourselves <br>    // as dirty <br>    // <br>    PropertyChanged(DISPID_SUITE); <br>    m_fDirty = TRUE; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CCardControl::Create <br>//=--------------------------------------------------------------------------= <br>// global static function that creates an instance of the control an returns <br>// an IUnknown pointer for it. <br>// <br>// Parameters: <br>//    IUnknown *        - [in] controlling unknown for aggregation <br>// <br>// Output: <br>//    IUnknown *        - new object. <br>// <br>// Notes: <br>// <br>IUnknown *CCardControl::Create <br>( <br>    IUnknown *pUnkOuter <br>) <br>{ <br>    // make sure we return the private unknown so that we support aggegation <br>    // correctly! <br>    // <br>    CCardControl *pNew = new CCardControl(pUnkOuter); <br>    return pNew-&gt;PrivateUnknown(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
