<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>AUTOOBJ.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context105"></a>AUTOOBJ.H</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// AutoObj.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// all of our objects will inherit from this class to share as much of the same <br>// code as possible.  this super-class contains the unknown and dispatch <br>// implementations for them. <br>// <br>#ifndef _AUTOOBJ_H_ <br> <br>// all automation objects will use the Unknown object that supports aggegation. <br>// <br>#include "Unknown.H" <br> <br>//=--------------------------------------------------------------------------= <br>// the constants in this header file uniquely identify your automation objects. <br>// make sure that for each object you have in the g_ObjectInfo table, you have <br>// a constant in this header file. <br>// <br>#include "LocalSrv.H" <br>#include "extobj.h" <br> <br>//=--------------------------------------------------------------------------= <br>// AUTOMATIONOBJECTINFO <br>//=--------------------------------------------------------------------------= <br>// for each automation object type you wish to expose to the programmer/user <br>// that is not a control, you must fill out one of these structures.  if the <br>// object isn't CoCreatable, then the first four fields should be empty. <br>// otherwise, they should be filled in with the appropriate information. <br>// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object. <br>// make sure you have an entry in the global table of objects, g_ObjectInfo <br>// in the main .Cpp file for your InProc server. <br>// <br>typedef struct { <br> <br>    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable <br>    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable! <br>    const IID   *riid;                           // object's type <br>    LPCSTR       pszHelpFile;                    // the helpfile for this automation object. <br>    ITypeInfo   *pTypeInfo;                      // typeinfo for this object <br>    UINT         cTypeInfo;                      // number of refs to the type info <br> <br>} AUTOMATIONOBJECTINFO; <br> <br>// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table. <br>// <br>#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;lVersion <br>#define INTERFACEOFOBJECT(index)       *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;riid) <br>#define PPTYPEINFOOFOBJECT(index)      &amp;((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;pTypeInfo)) <br>#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;pTypeInfo <br>#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;cTypeInfo <br>#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;pszHelpFile <br> <br> <br>#ifndef INITOBJECTS <br> <br>#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \ <br>extern AUTOMATIONOBJECTINFO name##Object \ <br> <br>#else <br>#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \ <br>    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \ <br> <br>#endif // INITOBJECTS <br> <br>//=--------------------------------------------------------------------------= <br>// Standard Dispatch and SupportErrorInfo <br>//=--------------------------------------------------------------------------= <br>// all objects should declare these in their class definitions so that they <br>// get standard implementations of IDispatch and ISupportErrorInfo. <br>// <br>#define DECLARE_STANDARD_DISPATCH() \ <br>    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \ <br>        return CAutomationObject::GetTypeInfoCount(pctinfo); \ <br>    } \ <br>    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \ <br>        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \ <br>    } \ <br>    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \ <br>        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \ <br>    } \ <br>    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \ <br>        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \ <br>    } \ <br> <br> <br>#define DECLARE_STANDARD_SUPPORTERRORINFO() \ <br>    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \ <br>        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \ <br>    } \ <br> <br>enum {EXPANDO_DISABLED=FALSE, EXPANDO_ENABLED=TRUE}; <br> <br>//=--------------------------------------------------------------------------= <br>// CAutomationObject <br>//=--------------------------------------------------------------------------= <br>// global class that all automation objects can inherit from to give them a <br>// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo <br>// <br>// <br>class CAutomationObject : public CUnknownObject { <br> <br>  public: <br>    // aggreation query interface support <br>    // <br>    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut); <br> <br>    // IDispatch methods <br>    // <br>    STDMETHOD(GetTypeInfoCount)(UINT *); <br>    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **); <br>    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *); <br>    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *); <br> <br>    //  ISupportErrorInfo methods <br>    // <br>    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID); <br> <br>    CAutomationObject(IUnknown *, int , void *, BOOL fExpandoEnabled=FALSE); <br>    virtual ~CAutomationObject(); <br> <br>    // callable functions -- things that most people will find useful. <br>    // <br>    virtual HINSTANCE GetResourceHandle(void); <br>    HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID); <br> <br>  protected: <br>    // member variables that derived objects might need to get at information in the <br>    // global object table <br>    // <br>    int   m_ObjectType; <br> <br>  private: <br>    // member variables we don't share. <br>    // <br>    BYTE  m_fLoadedTypeInfo; <br>BYTE  m_fExpandoEnabled; <br>CExpandoObject* m_pexpando; <br>}; <br> <br> <br>#define _AUTOOBJ_H_ <br>#endif // _AUTOOBJ_H_ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
