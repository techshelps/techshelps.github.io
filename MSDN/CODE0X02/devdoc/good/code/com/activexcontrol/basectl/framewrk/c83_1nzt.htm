<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLMISC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context89"></a>CTLMISC.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlMisc.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// things that aren't elsewhere, such as property pages, and connection <br>// points. <br> <br>#include "IPServer.H" <br>#include "CtrlObj.H" <br>#include "CtlHelp.H" <br>#include "Globals.H" <br>#include "StdEnum.H" <br>#include "Util.H" <br> <br>#include &lt;stdarg.h&gt; <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>// this is used in our window proc so that we can find out who was last created <br>// <br>static COleControl *s_pLastControlCreated; <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::COleControl <br>//=--------------------------------------------------------------------------= <br>// constructor <br>// <br>// Parameters: <br>//    IUnknown *          - [in] controlling Unknown <br>//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_* <br>//    void *              - [in] pointer to entire object <br>//  BOOL                - [in] whether to enable IDispatchEx functionality <br>//to allow dynamic adding of properties <br>// Notes: <br>// <br>COleControl::COleControl <br>( <br>    IUnknown *pUnkOuter, <br>    int       iPrimaryDispatch, <br>    void     *pMainInterface, <br>BOOL     fExpandoEnabled <br>) <br>: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface, fExpandoEnabled), <br>  m_cpEvents(SINK_TYPE_EVENT), <br>  m_cpPropNotify(SINK_TYPE_PROPNOTIFY) <br>{ <br>    // initialize all our variables -- we decided against using a memory-zeroing <br>    // memory allocator, so we sort of have to do this work now ... <br>    // <br>    m_nFreezeEvents = 0; <br> <br>    m_pClientSite = NULL; <br>    m_pControlSite = NULL; <br>    m_pInPlaceSite = NULL; <br>    m_pInPlaceFrame = NULL; <br>    m_pInPlaceUIWindow = NULL; <br> <br> <br>    m_pInPlaceSiteWndless = NULL; <br> <br>    // certain hosts don't like 0,0 as your initial size, so we're going to set <br>    // our initial size to 100,50 [so it's at least sort of visible on the screen] <br>    // <br>    m_Size.cx = 0; <br>    m_Size.cy = 0; <br>    memset(&amp;m_rcLocation, 0, sizeof(m_rcLocation)); <br> <br>    m_hRgn = NULL; <br>    m_hwnd = NULL; <br>    m_hwndParent = NULL; <br>    m_hwndReflect = NULL; <br>    m_fHostReflects = TRUE; <br>    m_fCheckedReflecting = FALSE; <br> <br>    m_nFreezeEvents = 0; <br>    m_pSimpleFrameSite = NULL; <br>    m_pOleAdviseHolder = NULL; <br>    m_pViewAdviseSink = NULL; <br>    m_pDispAmbient = NULL; <br> <br>    m_fDirty = FALSE; <br>    m_fModeFlagValid = FALSE; <br>    m_fInPlaceActive = FALSE; <br>    m_fInPlaceVisible = FALSE; <br>    m_fUIActive = FALSE; <br>    m_fSaveSucceeded = FALSE; <br>    m_fViewAdvisePrimeFirst = FALSE; <br>    m_fViewAdviseOnlyOnce = FALSE; <br>    m_fRunMode = FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::~COleControl <br>//=--------------------------------------------------------------------------= <br>// "We are all of us resigned to death; it's life we aren't resigned to." <br>//    - Graham Greene (1904-91) <br>// <br>// Notes: <br>// <br>COleControl::~COleControl() <br>{ <br>    // if we've still got a window, go and kill it now. <br>    // <br>    if (m_hwnd) { <br>        // so our window proc doesn't crash. <br>        // <br>        SetWindowLong(m_hwnd, GWL_USERDATA, 0xFFFFFFFF); <br>        DestroyWindow(m_hwnd); <br>    } <br> <br>    if (m_hwndReflect) { <br>        SetWindowLong(m_hwndReflect, GWL_USERDATA, 0); <br>        DestroyWindow(m_hwndReflect); <br>    } <br> <br>    if (m_hRgn != NULL) <br>    { <br>       DeleteObject(m_hRgn); <br>       m_hRgn = NULL; <br>    } <br> <br>    // clean up all the pointers we're holding around. <br>    // <br>    QUICK_RELEASE(m_pClientSite); <br>    QUICK_RELEASE(m_pControlSite); <br>    QUICK_RELEASE(m_pInPlaceSite); <br>    QUICK_RELEASE(m_pInPlaceFrame); <br>    QUICK_RELEASE(m_pInPlaceUIWindow); <br>    QUICK_RELEASE(m_pSimpleFrameSite); <br>    QUICK_RELEASE(m_pOleAdviseHolder); <br>    QUICK_RELEASE(m_pViewAdviseSink); <br>    QUICK_RELEASE(m_pDispAmbient); <br> <br>    QUICK_RELEASE(m_pInPlaceSiteWndless); <br>} <br> <br>#ifndef DEBUG <br>#pragma optimize("t", on) <br>#endif // DEBUG <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// derived-controls should delegate back to this when they decide to support <br>// additional interfaces <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>//    - NOTE: this function is speed critical!!!! <br>// <br>HRESULT COleControl::InternalQueryInterface <br>( <br>    REFIID riid, <br>    void **ppvObjOut <br>) <br>{ <br>    switch (riid.Data1) { <br>        // private interface for prop page support <br>        case Data1_IControlPrv: <br>          if(DO_GUIDS_MATCH(riid, IID_IControlPrv)) { <br>            *ppvObjOut = (void *)this; <br>            ExternalAddRef(); <br>            return S_OK; <br>          } <br>          goto NoInterface; <br>        QI_INHERITS(this, IOleControl); <br>        QI_INHERITS(this, IPointerInactive); <br>        QI_INHERITS(this, IQuickActivate); <br>        QI_INHERITS(this, IOleObject); <br>        QI_INHERITS((IPersistStorage *)this, IPersist); <br>        QI_INHERITS(this, IPersistStreamInit); <br>        QI_INHERITS(this, IOleInPlaceObject); <br>        QI_INHERITS(this, IOleInPlaceObjectWindowless); <br>        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow); <br>        QI_INHERITS(this, IOleInPlaceActiveObject); <br>        QI_INHERITS(this, IViewObject); <br>        QI_INHERITS(this, IViewObject2); <br>        QI_INHERITS(this, IViewObjectEx); <br>        QI_INHERITS(this, IConnectionPointContainer); <br>        QI_INHERITS(this, ISpecifyPropertyPages); <br>        QI_INHERITS(this, IPersistStorage); <br>        QI_INHERITS(this, IPersistPropertyBag); <br>        QI_INHERITS(this, IProvideClassInfo); <br>        default: <br>            goto NoInterface; <br>    } <br> <br>    // we like the interface, so addref and return <br>    // <br>    ((IUnknown *)(*ppvObjOut))-&gt;AddRef(); <br>    return S_OK; <br> <br>  NoInterface: <br>    // delegate to super-class for automation interfaces, etc ... <br>    // <br>    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut); <br>} <br> <br>#ifndef DEBUG <br>#pragma optimize("s", on) <br>#endif // DEBUG <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::FindConnectionPoint    [IConnectionPointContainer] <br>//=--------------------------------------------------------------------------= <br>// given an IID, find a connection point sink for it. <br>// <br>// Parameters: <br>//    REFIID              - [in]  interfaces they want <br>//    IConnectionPoint ** - [out] where the cp should go <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::FindConnectionPoint <br>( <br>    REFIID             riid, <br>    IConnectionPoint **ppConnectionPoint <br>) <br>{ <br>    CHECK_POINTER(ppConnectionPoint); <br> <br>    // we support the event interface, and IDispatch for it, and we also <br>    // support IPropertyNotifySink. <br>    // <br>    if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch)) <br>        *ppConnectionPoint = &amp;m_cpEvents; <br>    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink)) <br>        *ppConnectionPoint = &amp;m_cpPropNotify; <br>    else <br>        return E_NOINTERFACE; <br> <br>    // generic post-processing. <br>    // <br>    (*ppConnectionPoint)-&gt;AddRef(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::EnumConnectionPoints    [IConnectionPointContainer] <br>//=--------------------------------------------------------------------------= <br>// creates an enumerator for connection points. <br>// <br>// Parameters: <br>//    IEnumConnectionPoints **    - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::EnumConnectionPoints <br>( <br>    IEnumConnectionPoints **ppEnumConnectionPoints <br>) <br>{ <br>    IConnectionPoint **rgConnectionPoints; <br> <br>    CHECK_POINTER(ppEnumConnectionPoints); <br> <br>    // HeapAlloc an array of connection points [since our standard enum <br>    // assumes this and HeapFree's it later ] <br>    // <br>    rgConnectionPoints = (IConnectionPoint **)HeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2); <br>    RETURN_ON_NULLALLOC(rgConnectionPoints); <br> <br>    // we support the event interface for this dude as well as IPropertyNotifySink <br>    // <br>    rgConnectionPoints[0] = &amp;m_cpEvents; <br>    rgConnectionPoints[1] = &amp;m_cpPropNotify; <br> <br>    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints, <br>                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints, <br>                                CopyAndAddRefObject); <br>    if (!*ppEnumConnectionPoints) { <br>        HeapFree(g_hHeap, 0, rgConnectionPoints); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetPages    [ISpecifyPropertyPages] <br>//=--------------------------------------------------------------------------= <br>// returns a counted array with the guids for our property pages. <br>// <br>// parameters: <br>//    CAUUID *    - [out] where to put the counted array. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// NOtes: <br>// <br>STDMETHODIMP COleControl::GetPages <br>( <br>    CAUUID *pPages <br>) <br>{ <br>    const GUID **pElems; <br>    void *pv; <br>    WORD  x; <br> <br>    // if there are no property pages, this is actually pretty easy. <br>    // <br>    if (!CPROPPAGESOFCONTROL(m_ObjectType)) { <br>        pPages-&gt;cElems = 0; <br>        pPages-&gt;pElems = NULL; <br>        return S_OK; <br>    } <br> <br>    // fill out the Counted array, using IMalloc'd memory. <br>    // <br>    pPages-&gt;cElems = CPROPPAGESOFCONTROL(m_ObjectType); <br>    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages-&gt;cElems)); <br>    RETURN_ON_NULLALLOC(pv); <br>    pPages-&gt;pElems = (GUID *)pv; <br> <br>    // loop through our array of pages and get 'em. <br>    // <br>    pElems = PPROPPAGESOFCONTROL(m_ObjectType); <br>    for (x = 0; x &lt; pPages-&gt;cElems; x++) <br>        pPages-&gt;pElems[x] = *(pElems[x]); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::m_pOleControl <br>//=--------------------------------------------------------------------------= <br>// returns a pointer to the control in which we are nested. <br>// <br>// Output: <br>//    COleControl * <br>// <br>// Notes: <br>// <br>inline COleControl *COleControl::CConnectionPoint::m_pOleControl <br>( <br>    void <br>) <br>{ <br>    return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT) <br>                                          ? offsetof(COleControl, m_cpEvents) <br>                                          : offsetof(COleControl, m_cpPropNotify))); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::QueryInterface <br>//=--------------------------------------------------------------------------= <br>// standard qi <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::QueryInterface <br>( <br>    REFIID riid, <br>    void **ppvObjOut <br>) <br>{ <br>    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) { <br>        *ppvObjOut = (IConnectionPoint *)this; <br>        AddRef(); <br>        return S_OK; <br>    } <br> <br>    return E_NOINTERFACE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::AddRef <br>//=--------------------------------------------------------------------------= <br>// <br>// Output: <br>//    ULONG        - the new reference count <br>// <br>// Notes: <br>// <br>ULONG COleControl::CConnectionPoint::AddRef <br>( <br>    void <br>) <br>{ <br>    return m_pOleControl()-&gt;ExternalAddRef(); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::Release <br>//=--------------------------------------------------------------------------= <br>// <br>// Output: <br>//    ULONG         - remaining refs <br>// <br>// Notes: <br>// <br>ULONG COleControl::CConnectionPoint::Release <br>( <br>    void <br>) <br>{ <br>    return m_pOleControl()-&gt;ExternalRelease(); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::GetConnectionInterface <br>//=--------------------------------------------------------------------------= <br>// returns the interface we support connections on. <br>// <br>// Parameters: <br>//    IID *        - [out] interface we support. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface <br>( <br>    IID *piid <br>) <br>{ <br>    if (m_bType == SINK_TYPE_EVENT) <br>        *piid = EVENTIIDOFCONTROL(m_pOleControl()-&gt;m_ObjectType); <br>    else <br>        *piid = IID_IPropertyNotifySink; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::GetConnectionPointContainer <br>//=--------------------------------------------------------------------------= <br>// returns the connection point container <br>// <br>// Parameters: <br>//    IConnectionPointContainer **ppCPC <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer <br>( <br>    IConnectionPointContainer **ppCPC <br>) <br>{ <br>    return m_pOleControl()-&gt;ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectiontPoint::Advise <br>//=--------------------------------------------------------------------------= <br>// someboyd wants to be advised when something happens. <br>// <br>// Parameters: <br>//    IUnknown *        - [in]  guy who wants to be advised. <br>//    DWORD *           - [out] cookie <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::Advise <br>( <br>    IUnknown *pUnk, <br>    DWORD    *pdwCookie <br>) <br>{ <br>    HRESULT    hr; <br>    void      *pv; <br> <br>    CHECK_POINTER(pdwCookie); <br> <br>    // first, make sure everybody's got what they thinks they got <br>    // <br>    if (m_bType == SINK_TYPE_EVENT) { <br> <br>        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find <br>        // connection point on IDispatch, and they just happened to also support <br>        // the Event IID, we'd advise on that.  this is not awesome, but will <br>        // prove entirely acceptable short term. <br>        // <br>        hr = pUnk-&gt;QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()-&gt;m_ObjectType), &amp;pv); <br>        if (FAILED(hr)) <br>            hr = pUnk-&gt;QueryInterface(IID_IDispatch, &amp;pv); <br>    } <br>    else <br>        hr = pUnk-&gt;QueryInterface(IID_IPropertyNotifySink, &amp;pv); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // finally, add the sink.  it's now been cast to the correct type and has <br>    // been AddRef'd. <br>    // <br>    return AddSink(pv, pdwCookie); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::AddSink <br>//=--------------------------------------------------------------------------= <br>// in some cases, we'll already have done the QI, and won't need to do the <br>// work that is done in the Advise routine above.  thus, these people can <br>// just call this instead. [this stems really from IQuickActivate] <br>// <br>// Parameters: <br>//    void *        - [in]  the sink to add. it's already been addref'd <br>//    DWORD *       - [out] cookie <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::CConnectionPoint::AddSink <br>( <br>    void  *pv, <br>    DWORD *pdwCookie <br>) <br>{ <br>    IUnknown **rgUnkNew; <br>    int        i = 0; <br> <br>    // we optimize the case where there is only one sink to not allocate <br>    // any storage.  turns out very rarely is there more than one. <br>    // <br>    switch (m_cSinks) { <br> <br>        case 0: <br>            ASSERT(!m_rgSinks, "this should be null when there are no sinks"); <br>            m_rgSinks = (IUnknown **)pv; <br>            break; <br> <br>        case 1: <br>            // go ahead and do the initial allocation.  we'll get 8 at a time <br>            // <br>            rgUnkNew = (IUnknown **)HeapAlloc(g_hHeap, 0, 8 * sizeof(IUnknown *)); <br>            RETURN_ON_NULLALLOC(rgUnkNew); <br>            rgUnkNew[0] = (IUnknown *)m_rgSinks; <br>            rgUnkNew[1] = (IUnknown *)pv; <br>            m_rgSinks = rgUnkNew; <br>            break; <br> <br>        default: <br>            // if we're out of sinks, then we have to increase the size <br>            // of the array <br>            // <br>            if (!(m_cSinks &amp; 0x7)) { <br>                rgUnkNew = (IUnknown **)HeapReAlloc(g_hHeap, 0, m_rgSinks, (m_cSinks + 8) * sizeof(IUnknown *)); <br>                RETURN_ON_NULLALLOC(rgUnkNew); <br>                m_rgSinks = rgUnkNew; <br>            } else <br>                rgUnkNew = m_rgSinks; <br> <br>            rgUnkNew[m_cSinks] = (IUnknown *)pv; <br>            break; <br>    } <br> <br>    *pdwCookie = (DWORD)pv; <br>    m_cSinks++; <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::Unadvise <br>//=--------------------------------------------------------------------------= <br>// they don't want to be told any more. <br>// <br>// Parameters: <br>//    DWORD        - [in]  the cookie we gave 'em. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::Unadvise <br>( <br>    DWORD dwCookie <br>) <br>{ <br>    IUnknown *pUnk; <br>    int       x; <br> <br>    if (!dwCookie) <br>        return S_OK; <br> <br>    // see how many sinks we've currently got, and deal with things based <br>    // on that. <br>    // <br>    switch (m_cSinks) { <br>        case 1: <br>            // it's the only sink.  make sure the ptrs are the same, and <br>            // then free things up <br>            // <br>            if ((DWORD)m_rgSinks != dwCookie) <br>                return CONNECT_E_NOCONNECTION; <br>            m_rgSinks = NULL; <br>            break; <br> <br>        case 2: <br>            // there are two sinks.  go back down to one sink scenario <br>            // <br>            if ((DWORD)m_rgSinks[0] != dwCookie &amp;&amp; (DWORD)m_rgSinks[1] != dwCookie) <br>                return CONNECT_E_NOCONNECTION; <br> <br>            pUnk = ((DWORD)m_rgSinks[0] == dwCookie) <br>                   ? m_rgSinks[1] <br>                   : ((DWORD)m_rgSinks[1] == dwCookie) ? m_rgSinks[0] : NULL; <br> <br>            if (!pUnk) return CONNECT_E_NOCONNECTION; <br> <br>            HeapFree(g_hHeap, 0, m_rgSinks); <br>            m_rgSinks = (IUnknown **)pUnk; <br>            break; <br> <br>        default: <br>            // there are more than two sinks.  just clean up the hole we've <br>            // got in our array now. <br>            // <br>            for (x = 0; x &lt; m_cSinks; x++) { <br>                if ((DWORD)m_rgSinks[x] == dwCookie) <br>                    break; <br>            } <br>            if (x == m_cSinks) return CONNECT_E_NOCONNECTION; <br>            if (x &lt; m_cSinks - 1)  <br>                memcpy(&amp;(m_rgSinks[x]), &amp;(m_rgSinks[x + 1]), (m_cSinks -1 - x) * sizeof(IUnknown *)); <br>            else <br>                m_rgSinks[x] = NULL; <br>            break; <br>    } <br> <br> <br>    // we're happy <br>    // <br>    m_cSinks--; <br>    ((IUnknown *)dwCookie)-&gt;Release(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::EnumConnections <br>//=--------------------------------------------------------------------------= <br>// enumerates all current connections <br>// <br>// Paramters: <br>//    IEnumConnections ** - [out] new enumerator object <br>// <br>// Output: <br>//    HRESULT <br>// <br>// NOtes: <br>// <br>STDMETHODIMP COleControl::CConnectionPoint::EnumConnections <br>( <br>    IEnumConnections **ppEnumOut <br>) <br>{ <br>    CONNECTDATA *rgConnectData = NULL; <br>    int i; <br> <br>    if (m_cSinks) { <br>        // allocate some memory big enough to hold all of the sinks. <br>        // <br>        rgConnectData = (CONNECTDATA *)HeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA)); <br>        RETURN_ON_NULLALLOC(rgConnectData); <br> <br>        // fill in the array <br>        // <br>        if (m_cSinks == 1) { <br>            rgConnectData[0].pUnk = (IUnknown *)m_rgSinks; <br>            rgConnectData[0].dwCookie = (DWORD)m_rgSinks; <br>        } else { <br>            // loop through all available sinks. <br>            // <br>            for (i = 0; i &lt; m_cSinks; i++) { <br>                rgConnectData[i].pUnk = m_rgSinks[i]; <br>                rgConnectData[i].dwCookie = (DWORD)m_rgSinks[i]; <br>            } <br>        } <br>    } <br> <br>    // create yon enumerator object. <br>    // <br>    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections, <br>                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject); <br>    if (!*ppEnumOut) { <br>        HeapFree(g_hHeap, 0, rgConnectData); <br>        return E_OUTOFMEMORY; <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::~CConnectionPoint <br>//=--------------------------------------------------------------------------= <br>// cleans up <br>// <br>// Notes: <br>// <br>COleControl::CConnectionPoint::~CConnectionPoint () <br>{ <br>    int x; <br> <br>    // clean up some memory stuff <br>    // <br>    if (!m_cSinks) <br>        return; <br>    else if (m_cSinks == 1) <br>        ((IUnknown *)m_rgSinks)-&gt;Release(); <br>    else { <br>        for (x = 0; x &lt; m_cSinks; x++) <br>            QUICK_RELEASE(m_rgSinks[x]); <br>        HeapFree(g_hHeap, 0, m_rgSinks); <br>    } <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPiont::DoInvoke <br>//=--------------------------------------------------------------------------= <br>// fires an event to all listening on our event interface. <br>// <br>// Parameters: <br>//    DISPID            - [in] event to fire. <br>//    DISPPARAMS        - [in] <br>// <br>// Notes: <br>// <br>void COleControl::CConnectionPoint::DoInvoke <br>( <br>    DISPID      dispid, <br>    DISPPARAMS *pdispparams <br>) <br>{ <br>    int iConnection; <br> <br>    // if we don't have any sinks, then there's nothing to do.  we intentionally <br>    // ignore errors here. <br>    // <br>    if (m_cSinks == 0) <br>        return; <br>    else if (m_cSinks == 1) <br>        ((IDispatch *)m_rgSinks)-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL); <br>    else <br>        for (iConnection = 0; iConnection &lt; m_cSinks; iConnection++) <br>            ((IDispatch *)m_rgSinks[iConnection])-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::DoOnChanged <br>//=--------------------------------------------------------------------------= <br>// fires the OnChanged event for IPropertyNotifySink listeners. <br>// <br>// Parameters: <br>//    DISPID            - [in] dude that changed. <br>// <br>// Output: <br>//    none <br>// <br>// Notes: <br>// <br>void COleControl::CConnectionPoint::DoOnChanged <br>( <br>    DISPID dispid <br>) <br>{ <br>    int iConnection; <br> <br>    // if we don't have any sinks, then there's nothing to do. <br>    // <br>    if (m_cSinks == 0) <br>        return; <br>    else if (m_cSinks == 1) <br>        ((IPropertyNotifySink *)m_rgSinks)-&gt;OnChanged(dispid); <br>    else <br>        for (iConnection = 0; iConnection &lt; m_cSinks; iConnection++) <br>            ((IPropertyNotifySink *)m_rgSinks[iConnection])-&gt;OnChanged(dispid); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CConnectionPoint::DoOnRequestEdit <br>//=--------------------------------------------------------------------------= <br>// fires the OnRequestEdit for IPropertyNotifySinkListeners <br>// <br>// Parameters: <br>//    DISPID             - [in] dispid user wants to change. <br>// <br>// Output: <br>//    BOOL               - false means you cant <br>// <br>// Notes: <br>// <br>BOOL COleControl::CConnectionPoint::DoOnRequestEdit <br>( <br>    DISPID dispid <br>) <br>{ <br>    HRESULT hr; <br>    int     iConnection; <br> <br>    // if we don't have any sinks, then there's nothing to do. <br>    // <br>    if (m_cSinks == 0) <br>        hr = S_OK; <br>    else if (m_cSinks == 1) <br>        hr =((IPropertyNotifySink *)m_rgSinks)-&gt;OnRequestEdit(dispid); <br>    else { <br>        for (iConnection = 0; iConnection &lt; m_cSinks; iConnection++) { <br>            hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])-&gt;OnRequestEdit(dispid); <br>            if (hr != S_OK) break; <br>        } <br>    } <br> <br>    return (hr == S_OK) ? TRUE : FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::CreateInPlaceWindow <br>//=--------------------------------------------------------------------------= <br>// creates the window with which we will be working. <br>// yay. <br>// <br>// Parameters: <br>//    int            - [in] left <br>//    int            - [in] top <br>//    BOOL           - [in] can we skip redrawing? <br>// <br>// Output: <br>//    HWND <br>// <br>// Notes: <br>//    - DANGER! DANGER!  this function is protected so that anybody can call it <br>//      from their control.  however, people should be extremely careful of when <br>//      and why they do this.  preferably, this function would only need to be <br>//      called by an end-control writer in design mode to take care of some <br>//      hosting/painting issues.  otherwise, the framework should be left to <br>//      call it when it wants. <br>// <br>HWND COleControl::CreateInPlaceWindow <br>( <br>    int  x, <br>    int  y, <br>    BOOL fNoRedraw <br>) <br>{ <br>    BOOL    fVisible; <br>    HRESULT hr; <br>    DWORD   dwWindowStyle, dwExWindowStyle; <br>    char    szWindowTitle[128]; <br> <br>    // if we've already got a window, do nothing. <br>    // <br>    if (m_hwnd) <br>        return m_hwnd; <br> <br>    // get the user to register the class if it's not already <br>    // been done.  we have to critical section this since more than one thread <br>    // can be trying to create this control <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) { <br>        if (!RegisterClassData()) { <br>            LeaveCriticalSection(&amp;g_CriticalSection); <br>            return NULL; <br>        } else  <br>            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE; <br>    } <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    // let the user set up things like the window title, the <br>    // style, and anything else they feel interested in fiddling <br>    // with. <br>    // <br>    dwWindowStyle = dwExWindowStyle = 0; <br>    szWindowTitle[0] = '\0'; <br>    if (!BeforeCreateWindow(&amp;dwWindowStyle, &amp;dwExWindowStyle, szWindowTitle)) <br>        return NULL; <br> <br>    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS); <br> <br>    // create window visible if parent hidden (common case) <br>    // otherwise, create hidden, then shown.  this is a little subtle, but <br>    // it makes sense eventually. <br>    // <br>    if (!m_hwndParent) <br>        m_hwndParent = GetParkingWindow(); <br> <br>    fVisible = IsWindowVisible(m_hwndParent); <br> <br>    // This one kinda sucks -- if a control is subclassed, and we're in <br>    // a host that doesn't support Message Reflecting, we have to create <br>    // the user window in another window which will do all the reflecting. <br>    // VERY blech. [don't however, bother in design mode] <br>    // <br>    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) &amp;&amp; (m_hwndParent != GetParkingWindow())) { <br>        // determine if the host supports message reflecting. <br>        // <br>        if (!m_fCheckedReflecting) { <br>            VARIANT_BOOL f; <br>            hr = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &amp;f); <br>            if (FAILED(hr) || !f) <br>                m_fHostReflects = FALSE; <br>            m_fCheckedReflecting = TRUE; <br>        } <br> <br>        // if the host doesn't support reflecting, then we have to create <br>        // an extra window around the control window, and then parent it <br>        // off that. <br>        // <br>        if (!m_fHostReflects) { <br>            ASSERT(m_hwndReflect == NULL, "Where'd this come from?"); <br>            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &amp;m_Size); <br>            if (!m_hwndReflect) <br>                return NULL; <br>            SetWindowLong(m_hwndReflect, GWL_USERDATA, (long)this); <br>            dwWindowStyle |= WS_VISIBLE; <br>        } <br>    } else { <br>        if (!fVisible) <br>            dwWindowStyle |= WS_VISIBLE; <br>    } <br> <br>    // we have to mutex the entire create window process since we need to use <br>    // the s_pLastControlCreated to pass in the object pointer.  nothing too <br>    // serious <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    s_pLastControlCreated = this; <br>    m_fCreatingWindow = TRUE; </code></pre>
<p>
</p>
<pre><code><br>    // finally, go create the window, parenting it as appropriate. <br>    // <br>    m_hwnd = CreateWindowEx(dwExWindowStyle, <br>                            WNDCLASSNAMEOFCONTROL(m_ObjectType), <br>                            szWindowTitle, <br>                            dwWindowStyle, <br>                            (m_hwndReflect) ? 0 : x, <br>                            (m_hwndReflect) ? 0 : y, <br>                            m_Size.cx, m_Size.cy, <br>                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent, <br>                            NULL, g_hInstance, NULL); <br> <br>    // clean up some variables, and leave the critical section <br>    // <br>    m_fCreatingWindow = FALSE; <br>    s_pLastControlCreated = NULL; <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    if (m_hwnd) { <br>        // let the derived-control do something if they so desire <br>        // <br>        if (!AfterCreateWindow()) { <br>            BeforeDestroyWindow(); <br>            SetWindowLong(m_hwnd, GWL_USERDATA, 0xFFFFFFFF); <br>            DestroyWindow(m_hwnd); <br>            m_hwnd = NULL; <br>            return m_hwnd; <br>        } <br> <br>        // if we didn't create the window visible, show it now. <br>        // <br> <br>        if (fVisible) <br>{ <br>if (GetParent(m_hwnd) != m_hwndParent) <br>// SetWindowPos fails if parent hwnd is passed in so keep <br>// this behaviour in those cases without ripping.  <br>SetWindowPos(m_hwnd, m_hwndParent, 0, 0, 0, 0, <br> SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | ((fNoRedraw) ? SWP_NOREDRAW : 0)); <br>} <br>    } <br> <br>    // finally, tell the host of this <br>    // <br>    if (m_pClientSite) <br>        m_pClientSite-&gt;ShowObject(); <br> <br>    return m_hwnd; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetInPlaceParent    [helper] <br>//=--------------------------------------------------------------------------= <br>// sets up the parent window for our control. <br>// <br>// Parameters: <br>//    HWND            - [in] new parent window <br>// <br>// Notes: <br>// <br>void COleControl::SetInPlaceParent <br>( <br>    HWND hwndParent <br>) <br>{ <br>    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls"); <br> <br>    if (m_hwndParent == hwndParent) <br>        return; <br> <br>    m_hwndParent = hwndParent; <br>    if (m_hwnd) <br>        SetParent(GetOuterWindow(), hwndParent); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ControlWindowProc <br>//=--------------------------------------------------------------------------= <br>// default window proc for an OLE Control.   controls will have their own <br>// window proc called from this one, after some processing is done. <br>// <br>// Parameters: <br>//    - see win32sdk docs. <br>// <br>// Notes: <br>// <br>LRESULT CALLBACK COleControl::ControlWindowProc <br>( <br>    HWND    hwnd, <br>    UINT    msg, <br>    WPARAM  wParam, <br>    LPARAM  lParam <br>) <br>{ <br>    COleControl *pCtl = ControlFromHwnd(hwnd); <br>    HRESULT hr; <br>    LRESULT lResult; <br>    DWORD   dwCookie; <br> <br>    // if the value isn't a positive value, then it's in some special <br>    // state [creation or destruction]  this is safe because under win32, <br>    // the upper 2GB of an address space aren't available. <br>    // <br>    if ((LONG)pCtl == 0) { <br>        pCtl = s_pLastControlCreated; <br>        SetWindowLong(hwnd, GWL_USERDATA, (LONG)pCtl); <br>        pCtl-&gt;m_hwnd = hwnd; <br>    } else if ((ULONG)pCtl == 0xffffffff) { <br>        return DefWindowProc(hwnd, msg, wParam, lParam); <br>    } <br> <br>    // message preprocessing <br>    // <br>    if (pCtl-&gt;m_pSimpleFrameSite) { <br>        hr = pCtl-&gt;m_pSimpleFrameSite-&gt;PreMessageFilter(hwnd, msg, wParam, lParam, &amp;lResult, &amp;dwCookie); <br>        if (hr == S_FALSE) return lResult; <br>    } <br> <br>    // for certain messages, do not call the user window proc. instead, <br>    // we have something else we'd like to do. <br>    // <br>    switch (msg) { <br>      case WM_PAINT: <br>        { <br>        // call the user's OnDraw routine. <br>        // <br>        PAINTSTRUCT ps; <br>        RECT        rc; <br>        HDC         hdc; <br> <br>        // if we're given an HDC, then use it <br>        // <br>        if (!wParam) <br>            hdc = BeginPaint(hwnd, &amp;ps); <br>        else <br>            hdc = (HDC)wParam; <br> <br>        GetClientRect(hwnd, &amp;rc); <br>        pCtl-&gt;OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&amp;rc, NULL, NULL, TRUE); <br> <br>        if (!wParam) <br>            EndPaint(hwnd, &amp;ps); <br>        } <br>        break; <br> <br>      default: <br>        // call the derived-control's window proc <br>        // <br>        lResult = pCtl-&gt;WindowProc(msg, wParam, lParam); <br>        break; <br>    } <br> <br>    // message postprocessing <br>    // <br>    switch (msg) { <br> <br>      case WM_NCDESTROY: <br>        // after this point, the window doesn't exist any more <br>        // <br>        pCtl-&gt;m_hwnd = NULL; <br>        break; <br> <br>      case WM_SETFOCUS: <br>      case WM_KILLFOCUS: <br>        // give the control site focus notification <br>        // <br>        if (pCtl-&gt;m_fInPlaceActive &amp;&amp; pCtl-&gt;m_pControlSite) <br>            pCtl-&gt;m_pControlSite-&gt;OnFocus(msg == WM_SETFOCUS); <br>        break; <br> <br>      case WM_SIZE: <br>        // a change in size is a change in view <br>        // <br>        if (!pCtl-&gt;m_fCreatingWindow) <br>            pCtl-&gt;ViewChanged(); <br>        break; <br>    } <br> <br>    // lastly, simple frame postmessage processing <br>    // <br>    if (pCtl-&gt;m_pSimpleFrameSite) <br>        pCtl-&gt;m_pSimpleFrameSite-&gt;PostMessageFilter(hwnd, msg, wParam, lParam, &amp;lResult, dwCookie); <br> <br>    return lResult; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetFocus <br>//=--------------------------------------------------------------------------= <br>// we have to override this routine to get UI Activation correct. <br>// <br>// Parameters: <br>//    BOOL              - [in] true means take, false release <br>// <br>// Output: <br>//    BOOL <br>// <br>// Notes: <br>//    - CONSIDER: this is pretty messy, and it's still not entirely clear <br>//      what the ole control/focus story is. <br>// <br>BOOL COleControl::SetFocus <br>( <br>    BOOL fGrab <br>) <br>{ <br>    HRESULT hr; <br>    HWND    hwnd; <br> <br>    // first thing to do is check out UI Activation state, and then set <br>    // focus [either with windows api, or via the host for windowless <br>    // controls] <br>    // <br>    if (m_pInPlaceSiteWndless) { <br>        if (!m_fUIActive &amp;&amp; fGrab) <br>            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE; <br> <br>        hr = m_pInPlaceSiteWndless-&gt;SetFocus(fGrab); <br>        return (hr == S_OK) ? TRUE : FALSE; <br>    } else { <br> <br>        // we've got a window. <br>        // <br>        if (m_fInPlaceActive) { <br>            hwnd = (fGrab) ? m_hwnd : m_hwndParent; <br>            if (!m_fUIActive &amp;&amp; fGrab) <br>                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE)); <br>            else <br>                return SetGUIFocus(hwnd); <br>        } else <br>            return FALSE; <br>    } <br> <br>    // dead code <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetGUIFocus <br>//=--------------------------------------------------------------------------= <br>// does the work of setting the Windows GUI focus to the specified window <br>// <br>// Parameters: <br>//    HWND              - [in] window that should get focus <br>// <br>// Output: <br>//    BOOL              - [out] whether setting focus succeeded <br>// <br>// Notes: <br>//    we do this because some controls host non-ole window hierarchies, like <br>// the Netscape plugin ocx.  in such cases, the control may need to be UIActive <br>// to function properly in the document, but cannot take the windows focus <br>// away from one of its child windows.  such controls may override this method <br>// and respond as appropriate. <br>// <br>BOOL COleControl::SetGUIFocus <br>( <br>    HWND hwndSet <br>) <br>{ <br>    return (::SetFocus(hwndSet) == hwndSet); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ReflectWindowProc <br>//=--------------------------------------------------------------------------= <br>// reflects window messages on to the child window.  very lame. <br>// <br>// Parameters and Output: <br>//    - see win32 sdk docs <br>// <br>// Notes: <br>// <br>LRESULT CALLBACK COleControl::ReflectWindowProc <br>( <br>    HWND    hwnd, <br>    UINT    msg, <br>    WPARAM  wParam, <br>    LPARAM  lParam <br>) <br>{ <br>    COleControl *pCtl; <br> <br>    switch (msg) { <br>        case WM_COMMAND: <br>        case WM_NOTIFY: <br>        case WM_CTLCOLORBTN: <br>        case WM_CTLCOLORDLG: <br>        case WM_CTLCOLOREDIT: <br>        case WM_CTLCOLORLISTBOX: <br>        case WM_CTLCOLORMSGBOX: <br>        case WM_CTLCOLORSCROLLBAR: <br>        case WM_CTLCOLORSTATIC: <br>        case WM_DRAWITEM: <br>        case WM_MEASUREITEM: <br>        case WM_DELETEITEM: <br>        case WM_VKEYTOITEM: <br>        case WM_CHARTOITEM: <br>        case WM_COMPAREITEM: <br>        case WM_HSCROLL: <br>        case WM_VSCROLL: <br>        case WM_PARENTNOTIFY: <br>        case WM_SETFOCUS: <br>        case WM_SIZE: <br>            pCtl = (COleControl *)GetWindowLong(hwnd, GWL_USERDATA); <br>            if (pCtl) <br>                return SendMessage(pCtl-&gt;m_hwnd, OCM__BASE + msg, wParam, lParam); <br>            break; <br>    } <br> <br>    return DefWindowProc(hwnd, msg, wParam, lParam); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetAmbientProperty    [callable] <br>//=--------------------------------------------------------------------------= <br>// returns the value of an ambient property <br>// <br>// Parameters: <br>//    DISPID        - [in]  property to get <br>//    VARTYPE       - [in]  type of desired data <br>//    void *        - [out] where to put the data <br>// <br>// Output: <br>//    BOOL          - FALSE means didn't work. <br>// <br>// Notes: <br>// <br>BOOL COleControl::GetAmbientProperty <br>( <br>    DISPID  dispid, <br>    VARTYPE vt, <br>    void   *pData <br>) <br>{ <br>    DISPPARAMS dispparams; <br>    VARIANT v, v2; <br>    HRESULT hr; <br> <br>    v.vt = VT_EMPTY; <br>    v.lVal = 0; <br>    v2.vt = VT_EMPTY; <br>    v2.lVal = 0; <br> <br>    // get a pointer to the source of ambient properties. <br>    // <br>    if (!m_pDispAmbient) { <br>        if (m_pClientSite) <br>            m_pClientSite-&gt;QueryInterface(IID_IDispatch, (void **)&amp;m_pDispAmbient); <br> <br>        if (!m_pDispAmbient) <br>            return FALSE; <br>    } <br> <br>    // now go and get the property into a variant. <br>    // <br>    memset(&amp;dispparams, 0, sizeof(DISPPARAMS)); <br>    hr = m_pDispAmbient-&gt;Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &amp;dispparams, <br>                                &amp;v, NULL, NULL); <br>    if (FAILED(hr)) return FALSE; <br> <br>    // we've got the variant, so now go an coerce it to the type that the user <br>    // wants.  if the types are the same, then this will copy the stuff to <br>    // do appropriate ref counting ... <br>    // <br>    hr = VariantChangeType(&amp;v2, &amp;v, 0, vt); <br>    if (FAILED(hr)) { <br>        VariantClear(&amp;v); <br>        return FALSE; <br>    } <br> <br>    // copy the data to where the user wants it <br>    // <br>    CopyMemory(pData, &amp;(v2.lVal), g_rgcbDataTypeSize[vt]); <br>    VariantClear(&amp;v); <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetAmbientFont    [callable] <br>//=--------------------------------------------------------------------------= <br>// gets the current font for the user. <br>// <br>// Parameters: <br>//    IFont **         - [out] where to put the font. <br>// <br>// Output: <br>//    BOOL             - FALSE means couldn't get it. <br>// <br>// Notes: <br>// <br>BOOL COleControl::GetAmbientFont <br>( <br>    IFont **ppFont <br>) <br>{ <br>    IDispatch *pFontDisp; <br> <br>    // we don't have to do much here except get the ambient property and QI <br>    // it for the user. <br>    // <br>    *ppFont = NULL; <br>    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &amp;pFontDisp)) <br>        return FALSE; <br> <br>    pFontDisp-&gt;QueryInterface(IID_IFont, (void **)ppFont); <br>    pFontDisp-&gt;Release(); <br>    return (*ppFont) ? TRUE : FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::DesignMode <br>//=--------------------------------------------------------------------------= <br>// returns TRUE if we're in Design mode. <br>// <br>// Output: <br>//    BOOL            - true is design mode, false is run mode <br>// <br>// Notes: <br>// <br>BOOL COleControl::DesignMode <br>( <br>    void <br>) <br>{ <br>    VARIANT_BOOL f; <br> <br>    // if we don't already know our run mode, go and get it.  we'll assume <br>    // it's true unless told otherwise [or if the operation fails ...] <br>    // <br>    if (!m_fModeFlagValid) { <br>        f = TRUE; <br>        m_fModeFlagValid = TRUE; <br>        GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &amp;f); <br>        m_fRunMode = f; <br>    } <br> <br>    return !m_fRunMode; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::FireEvent <br>//=--------------------------------------------------------------------------= <br>// fires an event.  handles arbitrary number of arguments. <br>// <br>// Parameters: <br>//    EVENTINFO *        - [in] struct that describes the event. <br>//    ...                - arguments to the event <br>// <br>// Output: <br>//    none <br>// <br>// Notes: <br>//    - use stdarg's va_* macros. <br>// <br>void __cdecl COleControl::FireEvent <br>( <br>    EVENTINFO *pEventInfo, <br>    ... <br>) <br>{ <br>    va_list    valist; <br>    DISPPARAMS dispparams; <br>    VARIANT    rgvParameters[MAX_ARGS]; <br>    VARIANT   *pv; <br>    VARTYPE    vt; <br>    int        iParameter; <br>    int        cbSize; <br> <br>    ASSERT(pEventInfo-&gt;cParameters &lt;= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry."); <br> <br>    va_start(valist, pEventInfo); <br> <br>    // copy the Parameters into the rgvParameters array.  make sure we reverse <br>    // them for automation <br>    // <br>    pv = &amp;(rgvParameters[pEventInfo-&gt;cParameters - 1]); <br>    for (iParameter = 0; iParameter &lt; pEventInfo-&gt;cParameters; iParameter++) { <br> <br>        vt = pEventInfo-&gt;rgTypes[iParameter]; <br> <br>        // if it's a by value variant, then just copy the whole <br>        // dang thing <br>        // <br>        if (vt == VT_VARIANT) <br>            *pv = va_arg(valist, VARIANT); <br>        else { <br>            // copy the vt and the data value. <br>            // <br>            pv-&gt;vt = vt; <br>            if (vt &amp; VT_BYREF) <br>                cbSize = sizeof(void *); <br>            else <br>                cbSize = g_rgcbDataTypeSize[vt]; <br> <br>            // small optimization -- we can copy 2/4 bytes over quite <br>            // quickly. <br>            // <br>            if (cbSize == sizeof(short)) <br>                V_I2(pv) = va_arg(valist, short); <br>            else if (cbSize == 4) <br>                V_I4(pv) = va_arg(valist, long); <br>            else { <br>                // copy over 8 bytes <br>                // <br>                ASSERT(cbSize == 8, "don't recognize the type!!"); <br>                V_CY(pv) = va_arg(valist, CURRENCY); <br>            } <br>        } <br> <br>        pv--; <br>    } <br> <br>    // fire the event <br>    // <br>    dispparams.rgvarg = rgvParameters; <br>    dispparams.cArgs = pEventInfo-&gt;cParameters; <br>    dispparams.rgdispidNamedArgs = NULL; <br>    dispparams.cNamedArgs = 0; <br> <br>    m_cpEvents.DoInvoke(pEventInfo-&gt;dispid, &amp;dispparams); <br> <br>    va_end(valist); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::AfterCreateWindow    [overridable] <br>//=--------------------------------------------------------------------------= <br>// something the user can pay attention to <br>// <br>// Output: <br>//    BOOL             - false means fatal error, can't continue <br>// Notes: <br>// <br>BOOL COleControl::AfterCreateWindow <br>( <br>    void <br>) <br>{ <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::BeforeCreateWindow    [overridable] <br>//=--------------------------------------------------------------------------= <br>// called just before we create a window.  the user should register their <br>// window class here, and set up any other things, such as the title of <br>// the window, and/or sytle bits, etc ... <br>// <br>// Parameters: <br>//    DWORD *            - [out] dwWindowFlags <br>//    DWORD *            - [out] dwExWindowFlags <br>//    LPSTR              - [out] name of window to create <br>// <br>// Output: <br>//    BOOL               - false means fatal error, can't continue <br>// <br>// Notes: <br>// <br>BOOL COleControl::BeforeCreateWindow <br>( <br>    DWORD *pdwWindowStyle, <br>    DWORD *pdwExWindowStyle, <br>    LPSTR  pszWindowTitle <br>) <br>{ <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InvalidateControl    [callable] <br>//=--------------------------------------------------------------------------= <br>void COleControl::InvalidateControl <br>( <br>    LPCRECT lpRect <br>) <br>{ <br>    if (m_fInPlaceActive) <br>        InvalidateRect(m_hwnd, lpRect, TRUE); <br>    else <br>        ViewChanged(); <br> <br>    // CONSIDER: one might want to call pOleAdviseHolder-&gt;OnDataChanged() here <br>    // if there was support for IDataObject <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetControlSize    [callable] <br>//=--------------------------------------------------------------------------= <br>// sets the control size. they'll give us the size in pixels.  we've got to <br>// convert them back to HIMETRIC before passing them on! <br>// <br>// Parameters: <br>//    SIZEL *        - [in] new size <br>// <br>// Output: <br>//    BOOL <br>// <br>// Notes: <br>// <br>BOOL COleControl::SetControlSize <br>( <br>    SIZEL *pSize <br>) <br>{ <br>    HRESULT hr; <br>    SIZEL slHiMetric; <br> <br>    PixelToHiMetric(pSize, &amp;slHiMetric); <br>    hr = SetExtent(DVASPECT_CONTENT, &amp;slHiMetric); <br>    return (FAILED(hr)) ? FALSE : TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::RecreateControlWindow    [callable] <br>//=--------------------------------------------------------------------------= <br>// called by a [subclassed, typically] control to recreate it's control <br>// window. <br>// <br>// Parameters: <br>//    none <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE <br>//      OPERATION! <br>// <br>HRESULT COleControl::RecreateControlWindow <br>( <br>    void <br>) <br>{ <br>    HRESULT hr; <br>    HWND    hwndPrev; <br> <br>    // we need to correctly preserve the control's position within the <br>    // z-order here. <br>    // <br>    if (m_hwnd) <br>        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV); <br> <br>    // if we're in place active, then we have to deactivate, and reactivate <br>    // ourselves with the new window ... <br>    // <br>    if (m_fInPlaceActive) { <br> <br>        hr = InPlaceDeactivate(); <br>        RETURN_ON_FAILURE(hr); <br>        hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE); <br>        RETURN_ON_FAILURE(hr); <br> <br>    } else if (m_hwnd) { <br>        DestroyWindow(m_hwnd); <br>        m_hwnd = NULL; <br>        if (m_hwndReflect) { <br>            DestroyWindow(m_hwndReflect); <br>            m_hwndReflect = NULL; <br>        } <br> <br>        CreateInPlaceWindow(0, 0, FALSE); <br>    } <br> <br>    // restore z-order position <br>    // <br>    if (m_hwnd) <br>        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE); <br> <br>    return m_hwnd ? S_OK : E_FAIL; <br>} <br> <br>// from Globals.C. don't need to mutex it here since we only read it. <br>// <br>extern HINSTANCE g_hInstResources; <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetResourceHandle    [callable] <br>//=--------------------------------------------------------------------------= <br>// gets the HINSTANCE of the DLL where the control should get resources <br>// from.  implemented in such a way to support satellite DLLs. <br>// <br>// Output: <br>//    HINSTANCE <br>// <br>// Notes: <br>// <br>HINSTANCE COleControl::GetResourceHandle <br>( <br>    void <br>) <br>{ <br>    if (!g_fSatelliteLocalization) <br>        return g_hInstance; <br> <br>    // if we've already got it, then there's not all that much to do. <br>    // don't need to crit sect this one right here since even if they do fall <br>    // into the ::GetResourceHandle call, it'll properly deal with things. <br>    // <br>    if (g_hInstResources) <br>        return g_hInstResources; <br> <br>    // we'll get the ambient localeid from the host, and pass that on to the <br>    // automation object. <br>    // <br>    // crit sect this for apartment threading support. <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (!g_fHaveLocale) <br>        // if we can't get the ambient locale id, then we'll just continue <br>        // with the globally set up value. <br>        // <br>        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &amp;g_lcidLocale)) <br>            goto Done; <br> <br>    g_fHaveLocale = TRUE; <br> <br>  Done: <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br>    return ::GetResourceHandle(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
