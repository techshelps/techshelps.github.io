<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INTERNET.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context98"></a>INTERNET.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// Internet.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// contains internet helper classes CDownloadSink and CInternetControl <br>// <br>#include "IPServer.H" <br>#include "Internet.H" <br>#include "Util.H" <br> <br>static VARTYPE rgI4[] = { VT_I4 }; <br> <br>typedef enum { <br>    InternetEvent_Progress = 0, <br>    InternetEvent_ReadyStateChange = 1 <br>} INTERNETEVENTS; <br> <br>static EVENTINFO rgEvents [] = { <br>    { DISPID_PROGRESS, 1, rgI4 },           // (long percentDone) <br>    { DISPID_READYSTATECHANGE, 1, rgI4 },       // (OLE_READYSTATE newState) <br>}; <br> <br> <br>// local class for doing async monitoring. It's not really all that <br>// general purpose, but it does the job... <br> <br> <br>class CDownloadSink : public IBindStatusCallback <br>{ <br>public: <br>    CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID ); <br>    ~CDownloadSink(); <br> <br>    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut); <br>    STDMETHOD_(ULONG, AddRef)(); <br>    STDMETHOD_(ULONG, Release)(); <br> <br>        STDMETHOD(OnStartBinding)( <br>            /* [in] */ DWORD grfBSCOption, <br>            /* [in] */ IBinding *pib); <br> <br>        STDMETHOD(GetPriority)( <br>            /* [out] */ LONG *pnPriority); <br> <br>        STDMETHOD(OnLowResource)( <br>            /* [in] */ DWORD reserved); <br> <br>        STDMETHOD(OnProgress)( <br>            /* [in] */ ULONG ulProgress, <br>            /* [in] */ ULONG ulProgressMax, <br>            /* [in] */ ULONG ulStatusCode, <br>            /* [in] */ LPCWSTR szStatusText); <br> <br>        STDMETHOD(OnStopBinding)( <br>            /* [in] */ HRESULT hresult, <br>            /* [in] */ LPCWSTR szError); <br> <br>        STDMETHOD(GetBindInfo)( <br>            /* [out] */ DWORD *grfBINDINFOF, <br>            /* [unique][out][in] */ BINDINFO *pbindinfo); <br> <br>        STDMETHOD(OnDataAvailable)( <br>            /* [in] */ DWORD grfBSCF, <br>            /* [in] */ DWORD dwSize, <br>            /* [in] */ FORMATETC *pformatetc, <br>            /* [in] */ STGMEDIUM *pstgmed); <br> <br>        STDMETHOD(OnObjectAvailable)( <br>            /* [in] */ REFIID riid, <br>            /* [iid_is][in] */ IUnknown *punk); <br> <br> <br> <br>        CDownloadSink * Next()                  { return(m_next); } <br>        void            Next(CDownloadSink *n)  { m_next = n; } <br> <br>        DISPID          DispId()  { return(m_propId); } <br>        IBinding *      Binding() { return(m_binding); } <br> <br>private: <br> <br>        CDownloadSink *         m_next; <br>        CInternetControl *      m_control; <br>        DISPID                  m_propId; <br>        IBinding *              m_binding; <br>        DWORD                   m_ref; <br>                IStream *                               m_stream; <br> <br>}; <br> <br> <br>CDownloadSink::CDownloadSink <br>( <br>        IUnknown *              punkOuter, <br>        CInternetControl *      control, <br>        DISPID                  propId <br>) <br>{ <br>//      CHECK_POINTER(control); <br> <br>        m_control = control; <br>        m_control-&gt;AddRef(); <br> <br>        m_propId  = propId; <br>        m_next    = 0; <br>        m_binding = 0; <br>        m_ref     = 0; <br>        m_stream  = 0; <br>} <br> <br>CDownloadSink::~CDownloadSink() <br>{ <br>        if( m_control ) <br>                m_control-&gt;Release(); <br>        if( m_binding ) <br>                m_binding-&gt;Release(); <br>        if( m_stream ) <br>                m_stream-&gt;Release(); <br>} <br> <br>STDMETHODIMP <br>CDownloadSink::QueryInterface(const GUID &amp;iid,void **ppv ) <br>{ <br>        if( IsEqualGUID(iid,IID_IUnknown) || IsEqualGUID(iid,IID_IBindStatusCallback) ) <br>        { <br>                *ppv = this; <br>                AddRef(); <br>                return(NOERROR); <br>        } <br>        return( E_NOINTERFACE ); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CDownloadSink::AddRef() <br>{ <br>        return(++m_ref); <br>} <br> <br>STDMETHODIMP_(ULONG) <br>CDownloadSink::Release() <br>{ <br>        if(!--m_ref) <br>        { <br>                delete this; <br>                return(0); <br>        } <br>        return( m_ref ); <br>} <br> <br> <br>STDMETHODIMP <br>CDownloadSink::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo) <br>{ <br>    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA; <br>        return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP <br>CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *pib) <br>{ <br>        // BUGBUG: should check to see options are what we think they are <br>        m_binding = pib; <br>        pib-&gt;AddRef(); <br>        return(NOERROR); <br>} <br> <br> <br>STDMETHODIMP <br>CDownloadSink::GetPriority( LONG *pnPriority) <br>{ <br>        return(E_NOTIMPL); <br>} <br> <br>STDMETHODIMP <br>CDownloadSink::OnProgress <br>( <br>     ULONG ulProgress, <br>     ULONG ulProgressMax, <br>     ULONG ulStatusCode, <br>     LPCWSTR pwzStatusText <br>) <br>{ <br>        return(m_control-&gt;OnProgress(m_propId,ulProgress, <br>                                                        ulProgressMax,ulStatusCode,pwzStatusText) ); <br>} <br> <br>STDMETHODIMP <br>CDownloadSink::OnDataAvailable <br>( <br>     DWORD                      grfBSCF, <br>     DWORD                      dwSize, <br>     FORMATETC *        pFmtetc, <br>         STGMEDIUM *    pstgmed <br>) <br>{ <br>#ifdef DEBUG <br>        char msg[200]; <br>        wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)\n",grfBSCF,dwSize, <br>                pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL" ); <br>        OutputDebugString(msg); <br>#endif <br> <br>    if( !m_stream ) <br>                m_stream = pstgmed-&gt;pstm; <br> <br>        return(m_control-&gt;OnData(       m_propId, <br>                                                                grfBSCF, <br>                                                                m_stream, <br>                                                                dwSize )); <br>} <br> <br>STDMETHODIMP <br>CDownloadSink::OnObjectAvailable <br>( <br>        REFIID riid, <br>    IUnknown *punk <br>) <br>{ <br>        return(E_NOTIMPL); <br>} <br> <br> <br>STDMETHODIMP <br>CDownloadSink::OnLowResource( DWORD reserved) <br>{ <br>        // BUGBUG: really should have this kind of harsh policy on this ... <br>        m_binding-&gt;Abort(); <br>        return(S_OK); <br>} <br> <br>STDMETHODIMP <br>CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError) <br>{ <br>        m_binding-&gt;Release(); <br>        m_binding = 0; <br>        m_control-&gt;Release(); <br>        m_control = 0; <br> <br>        return(NOERROR); <br>} <br> <br> <br> <br>//------------------------------------------------------ <br>// <br>// class CInternetControl <br>// <br>// <br>CInternetControl::CInternetControl <br>( <br>        IUnknown *      pUnkOuter, <br>        int                     iPrimaryDispatch, <br>        void *          pMainInterface <br>) <br>        : COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface) <br>{ <br>        m_host = 0; <br>        m_readyState = READYSTATE_LOADING; <br>} <br> <br>CInternetControl::~CInternetControl() <br>{ <br>        if( m_host ) <br>                m_host-&gt;Release(); <br>} <br> <br> <br>HRESULT CInternetControl::InternalQueryInterface <br>( <br>    REFIID  riid, <br>    void  **ppvObjOut <br>) <br>{ <br>    *ppvObjOut = NULL; <br>     return COleControl::InternalQueryInterface(riid, ppvObjOut); <br>} <br> <br> <br> <br>HRESULT <br>CInternetControl::GetBindHost() <br>{ <br> <br>        if( m_host ) <br>                return(NOERROR); <br> <br>    // Try service provider first... <br> <br>        IServiceProvider * serviceProvider = 0; <br> <br>        HRESULT hr = m_pClientSite-&gt;QueryInterface <br>                                                                        ( <br>                                                                                IID_IServiceProvider, <br>                                                                                (void**)&amp;serviceProvider <br>                                                                        ); <br> <br>        if( SUCCEEDED(hr) ) <br>    { <br>                hr = serviceProvider-&gt;QueryService <br>                                    ( <br>                                        SID_IBindHost, <br>                                        IID_IBindHost, <br>                                        (void**)&amp;m_host <br>                                    ); <br>                serviceProvider-&gt;Release(); <br>    } <br> <br>    if( FAILED(hr) ) <br>    { <br>        // Some containers put IBindHost directly on the client site <br> <br>        hr = m_pClientSite-&gt;QueryInterface <br>                                                                        ( <br>                                        IID_IBindHost, <br>                                        (void**)&amp;m_host <br>                                                                        ); <br> <br> <br>    } <br> <br>        return(hr); <br> <br>} <br> <br> <br>HRESULT CInternetControl::GetAMoniker( LPOLESTR url, IMoniker ** ppmkr ) <br>{ <br>        HRESULT hr = GetBindHost(); <br> <br>        if( SUCCEEDED(hr) ) <br>                hr = m_host-&gt;CreateMoniker(url,NULL, ppmkr,0); <br> <br>        if( FAILED(hr) ) <br>    { <br>           // FUTURE: This really should be a call to MkParseDisplayNameEx!!! <br>       hr = ::CreateURLMoniker(0,url,ppmkr); <br>       // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr); <br>    } <br> <br>        return( hr ); <br>} <br> <br> <br>HRESULT CInternetControl::SetupDownload( LPOLESTR url, DISPID propId ) <br>{ <br>        CHECK_POINTER(url); <br> <br>        IMoniker * pmkr; <br> <br>        HRESULT hr = GetAMoniker( url, &amp;pmkr ); <br> <br>        IBindCtx * pBindCtx = 0; <br> <br>        if( SUCCEEDED(hr) ) <br>    { <br>        hr = ::CreateBindCtx(0,&amp;pBindCtx); <br>    } <br> <br>        CDownloadSink * sink = 0; <br> <br>        if( SUCCEEDED(hr) ) <br>        { <br>                sink = new CDownloadSink(0,this,propId); <br>                if( sink ) <br>                        sink-&gt;AddRef(); <br>        } <br> <br>        if( SUCCEEDED(hr) &amp;&amp; !sink ) <br>                hr = E_OUTOFMEMORY; <br> <br>        if( SUCCEEDED(hr) ) <br>        { <br>                // BUGBUG: There should be a define for 0x77 <br>                hr = ::RegisterBindStatusCallback(pBindCtx, sink,0, 0) ; <br>        } <br> <br>        IStream * strm = 0; <br> <br>        if( SUCCEEDED(hr) ) <br>                hr = pmkr-&gt;BindToStorage( pBindCtx, 0, IID_IStream, (void**)&amp;strm ); <br> <br>        if( strm ) <br>                strm-&gt;Release(); <br> <br>        if( pBindCtx ) <br>                pBindCtx-&gt;Release(); <br> <br>        if( FAILED(hr) &amp;&amp; sink ) <br>                sink-&gt;Release(); <br> <br>        return(hr); <br> <br>} <br> <br> <br>HRESULT CInternetControl::OnData( DISPID, DWORD,IStream *, DWORD) <br>{ <br>        return(NOERROR); <br>} <br> <br>HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR) <br>{ <br>        return(NOERROR); <br>} <br> <br> <br>HRESULT CInternetControl::FireReadyStateChange( long newState ) <br>{ <br>        FireEvent( &amp;::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState ); <br>        return(S_OK); <br>} <br> <br>HRESULT CInternetControl::FireProgress( ULONG dwAmount ) <br>{ <br>        FireEvent( &amp;::rgEvents[InternetEvent_Progress], dwAmount ); <br>        return(S_OK); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
