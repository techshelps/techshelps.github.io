<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context96"></a>EXTOBJ.CPP</h2>
<pre><code>//// <br>// <br>// CExpandoObject <br>// <br>// Notes: <br>// 1) If the LCID passed to this object changes from call to call we are screwed. This is hard to <br>// create an ASSERT for because it would require memoizing the LCID at some point. <br>// 2) There is a maximum on the number of slots allowed (this is currently 2048) <br>// 3) This is not a thread safe structure. <br>// 4) I'm currently using malloc -- this is probably wrong for IE. <br>// <br> <br>// for ASSERT and FAIL <br>// <br> <br>#include "IPServer.H" <br>#include "LocalSrv.H" <br>#include "Globals.H" <br>#include "extobj.h"  <br>#include "Util.H" <br>#define GTR_MALLOC(size)  CoTaskMemAlloc(size) <br>#define GTR_FREE(pv) CoTaskMemFree(pv) <br> <br>SZTHISFILE <br>//// <br>// <br>// Private Utility Functions <br>// <br>//// <br> <br>//// <br>// <br>// Get the ID of a Name <br>// <br> <br>HRESULT CExpandoObject::GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id) <br>{ <br>HRESULT hr = NOERROR; <br>ULONG hash = LHashValOfName(lcid, name); <br>UINT hashIndex = hash % kSlotHashTableSize; <br>CExpandoObjectSlot* slot; <br> <br>for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot-&gt;Next(m_slots)) <br>{ <br>if (slot-&gt;CompareName(name, hash, caseSensitive)) <br>{ <br>*id = slot-&gt;DispId(); <br>goto Exit; <br>} <br>} <br> <br>// not found <br>hr = DISP_E_UNKNOWNNAME; <br>*id = DISPID_UNKNOWN; <br> <br>Exit: <br>return hr; <br>} <br> <br>//// <br>// <br>// Add a new slot to the object <br>// <br> <br>HRESULT CExpandoObject::AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id) <br>{ <br>HRESULT hr = NOERROR; <br>ULONG hash = LHashValOfName(lcid, name); <br>UINT hashIndex = hash % kSlotHashTableSize; <br>CExpandoObjectSlot* slot; <br>DISPIDdispId; <br> <br>// first check if the slot exists <br>for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot-&gt;Next(m_slots)) <br>{ <br>// bail if the name matches <br>if (slot-&gt;CompareName(name, hash, caseSensitive)) <br>{ <br>hr = E_INVALIDARG; <br>goto Exit; <br>} <br>} <br> <br>// allocate a slot <br>dispId = (DISPID) m_totalSlots; <br>slot = AllocSlot(); <br>if (slot == NULL) <br>{ <br>hr = E_OUTOFMEMORY; <br>goto Exit; <br>} <br> <br>// Initialize it <br>// BUGBUG robwell 8May96 If this fails and the initialValue is not VT_EMTPY or VT_NULL <br>// there in no cleanup code. <br>hr = slot-&gt;Init(name, lcid, dispId + m_dispIdBase, initialValue); <br>if (FAILED(hr)) <br>{ <br>// free the slot and dispId <br>m_totalSlots -= 1; <br>goto Exit; <br>} <br> <br>// intern the slot into the proper hash table <br>slot-&gt;Insert(m_slots, m_hashTable[hashIndex]); <br> <br>// set the DISPID return value <br>*id = slot-&gt;DispId(); <br> <br>Exit: <br>return hr; <br>} <br> <br>//// <br>// <br>// Slot allocation <br>// <br>// Because slots are never freed there is no free method <br>// <br> <br>CExpandoObjectSlot* CExpandoObject::AllocSlot() <br>{ <br>// limit on the number of slots <br>if (m_totalSlots &gt;= kMaxTotalSlots) <br>return NULL; <br> <br>// do we need to realloc the array? <br>if (m_totalSlots == m_slotTableSize) <br>{ <br>UINT i; <br>UINT newSize; <br>CExpandoObjectSlot* newSlots; <br> <br>// allocate twice as many slots unless first time around <br>if (m_slotTableSize == 0) <br>newSize = kInitialSlotTableSize; <br>else <br>newSize = m_slotTableSize * 2; <br> <br>// allocate the space for the slots <br>newSlots = (CExpandoObjectSlot*) GTR_MALLOC(sizeof(CExpandoObjectSlot)*newSize); <br>if (newSlots == NULL) <br>return NULL; <br> <br>// copy the old values if the old m_slots is not NULL <br>if (m_slots) <br>{ <br>// copy the slots <br>memcpy(newSlots, m_slots, sizeof(CExpandoObjectSlot)*m_totalSlots); <br>// free the old values <br>GTR_FREE(m_slots); <br>} <br> <br>// construct all of the unused slots <br>for (i=m_totalSlots; i&lt;newSize; ++i) <br>newSlots[i].Construct(); <br> <br>// make the new array the new table and fix the total size <br>m_slots = newSlots; <br>m_slotTableSize = newSize; <br>} <br> <br>// return a pointer to the slot and bump the totalSlots count <br>return &amp;m_slots[m_totalSlots++]; <br>} <br> <br>//// <br>// <br>// Free all of the slots <br>// <br> <br>void CExpandoObject::FreeAllSlots() <br>{ <br>UINT i; <br>UINT initedSlotCount; <br>CExpandoObjectSlot* slots; <br> <br>// first clear the hash table <br>ClearHashTable(); <br> <br>// detach the slots <br>slots = m_slots; <br>initedSlotCount = m_totalSlots; <br> <br>// clear the object info <br>m_totalSlots = 0; <br>m_slotTableSize = 0; <br>m_slots = NULL; <br> <br>// only need to destruct those slots in use <br>for (i=0; i&lt;initedSlotCount; ++i) <br>slots[i].Destruct(); <br> <br>// free the storage <br>if (slots) <br>GTR_FREE(slots); <br>} <br> <br> <br> <br>//// <br>// <br>// IDispatch Methods <br>// <br>//// <br> <br>HRESULT CExpandoObject::GetTypeInfoCount(UINT *pctinfo) <br>{ <br>*pctinfo = 0; <br>return NOERROR; <br>} <br> <br>HRESULT CExpandoObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo) <br>{ <br>*pptinfo = NULL; <br>return E_NOTIMPL; <br>} <br> <br>HRESULT CExpandoObject::GetIDsOfNames( <br>REFIID riid, <br>LPOLESTR *prgpsz, <br>UINT cpsz, <br>LCID lcid, <br>DISPID *prgdispid <br>) <br>{ <br>HRESULT hr; <br> <br>if (IID_NULL != riid) <br>return DISP_E_UNKNOWNINTERFACE; <br> <br>// First see if the outer object knows about the name <br>if (m_pdisp) <br>{ <br>hr = m_pdisp-&gt;GetIDsOfNames( <br>riid, <br>prgpsz, <br>cpsz, <br>lcid, <br>prgdispid); <br> <br>// if so, just return <br>if (SUCCEEDED(hr)) <br>return hr; <br>} <br> <br>// Otherwise look on our expanded properties <br> <br>if (cpsz == 0) <br>return NOERROR; <br> <br>// get the ids for the name <br>hr = GetIDOfName(prgpsz[0], lcid, FALSE, &amp;prgdispid[0]); <br> <br>// clear the rest of the array <br>for (unsigned int i = 1; i &lt; cpsz; i++) <br>{ <br>if (SUCCEEDED(hr)) <br>hr = DISP_E_UNKNOWNNAME; <br>prgdispid[i] = DISPID_UNKNOWN; <br>} <br> <br>return hr; <br>} <br> <br>HRESULT CExpandoObject::Invoke( <br>DISPID dispID, <br>REFIID riid, <br>LCID lcid, <br>WORD wFlags, <br>DISPPARAMS *pdispparams, <br>VARIANT *pvarRes, <br>EXCEPINFO *pexcepinfo, <br>UINT *puArgErr <br>) <br>{ <br>if (IID_NULL != riid) <br>return DISP_E_UNKNOWNINTERFACE; <br> <br>HRESULT hr; <br> <br>// First try the outer object's invoke <br>if (m_pdisp) <br>{ <br>hr = m_pdisp-&gt;Invoke( <br>dispID, <br>riid, <br>lcid, <br>wFlags, <br>pdispparams, <br>pvarRes, <br>pexcepinfo, <br>puArgErr <br>); <br> <br>// If that succeeded, we're done <br>if (SUCCEEDED(hr)) <br>return hr; <br>} <br> <br>// Otherwise, try the expando object's invoke <br>if (NULL != puArgErr) <br>*puArgErr = 0; <br> <br>if (wFlags &amp; DISPATCH_PROPERTYGET) <br>{ <br>if (NULL == pvarRes) <br>return NOERROR; <br> <br>if (NULL != pdispparams &amp;&amp; 0 != pdispparams-&gt;cArgs) <br>return E_INVALIDARG; <br> <br>// clear the result slot <br>pvarRes-&gt;vt = VT_EMPTY; <br>return GetSlot(dispID, pvarRes); <br>} <br> <br>if (wFlags &amp; (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF)) <br>{ <br>if (NULL == pdispparams <br>|| 1 != pdispparams-&gt;cArgs <br>|| 1 != pdispparams-&gt;cNamedArgs <br>|| DISPID_PROPERTYPUT != pdispparams-&gt;rgdispidNamedArgs[0] <br>) <br>return DISP_E_PARAMNOTOPTIONAL; <br> <br>return SetSlot(dispID, &amp;pdispparams-&gt;rgvarg[0]); <br>} <br> <br>return DISP_E_MEMBERNOTFOUND; <br>} <br> <br>//// <br>// <br>// IDispatchEx methods <br>// <br>//// <br> <br>// Get dispID for names, with options <br>HRESULT STDMETHODCALLTYPE CExpandoObject::GetIDsOfNamesEx( <br>REFIID riid, <br>LPOLESTR *prgpsz, <br>UINT cpsz, <br>LCID lcid, <br>DISPID *prgid, <br>DWORD grfdex <br>) <br>{ <br>HRESULT hr; <br>BOOL caseSensitive = ((grfdex &amp; fdexCaseSensitive) != 0); <br> <br> <br>// First see if the outer object knows about the name <br>if (m_pdisp) <br>{ <br>hr = m_pdisp-&gt;GetIDsOfNames( <br>riid, <br>prgpsz, <br>cpsz, <br>lcid, <br>prgid); <br> <br>// if so, just return <br>if (SUCCEEDED(hr)) <br>return hr; <br>} <br> <br> <br>if (IID_NULL != riid) <br>return DISP_E_UNKNOWNINTERFACE; <br> <br>if (cpsz == 0) <br>return NOERROR; <br> <br>// check the array arguments <br>if (prgpsz == NULL || prgid == NULL) <br>return E_INVALIDARG; <br> <br>// get the id from the name <br>hr = GetIDOfName(prgpsz[0], lcid, caseSensitive, &amp;prgid[0]); <br> <br>// create the slot? <br>if (hr == DISP_E_UNKNOWNNAME &amp;&amp; (grfdex &amp; fdexDontCreate) == 0) <br>{ <br>VARIANT initialValue; <br> <br>if (grfdex &amp; fdexInitNull) <br>initialValue.vt = VT_NULL; <br>else <br>initialValue.vt = VT_EMPTY; <br> <br>hr = AddSlot(prgpsz[0], lcid, caseSensitive, &amp;initialValue, &amp;prgid[0]); <br>} <br> <br>// clear the rest of the array <br>for (unsigned int i = 1; i &lt; cpsz; i++) <br>{ <br>hr = DISP_E_UNKNOWNNAME; <br>prgid[i] = DISPID_UNKNOWN; <br>} <br> <br>return hr; <br>} <br> <br>// Enumerate dispIDs and their associated "names". <br>// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an <br>// error code if the call fails. <br>HRESULT STDMETHODCALLTYPE CExpandoObject::GetNextDispID( <br>DISPID id, <br>DISPID *pid, <br>BSTR *pbstrName <br>) <br>{ <br>HRESULT hr; <br>CExpandoObjectSlot* slot; <br> <br>// check the outgoing parameters <br>if (pid == NULL || pbstrName == NULL) <br>return E_INVALIDARG; <br> <br>// set to the default failure case <br>*pid = DISPID_UNKNOWN; <br>*pbstrName = NULL; <br> <br>// get the next slot <br>hr = Next(id, slot); <br>if (hr == NOERROR) <br>{ <br>BSTR name; <br> <br>// allocate the result string <br>name = SysAllocString(slot-&gt;Name()); <br>if (name == NULL) <br>return E_OUTOFMEMORY; <br> <br>// fill in the outgoing parameters <br>*pid = slot-&gt;DispId(); <br>*pbstrName = name; <br>} <br> <br>return hr; <br>} <br> <br>// Copy all of the expando-object properties from obj <br>CExpandoObject::CloneProperties(CExpandoObject&amp; obj) <br>{ <br>    // BUGBUG  PhilBo <br>    // The initialization code below is copied from the default constructor. <br>    // This should be factored out into a shared method. <br> <br>// Copy each of the properties from the original object <br>    HRESULT hr = S_OK; <br>    DISPID dispid = 0; <br>    BSTR bstrName = NULL; <br>     <br>    while (obj.GetNextDispID(dispid, &amp;dispid, &amp;bstrName) == S_OK) <br>    { <br>        // Get the value of the property from the original object <br>        VARIANT varResult; <br>        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};  <br>        VariantInit(&amp;varResult); <br> <br>        hr = obj.Invoke(  <br>        dispid,  <br>        IID_NULL,  <br>        LOCALE_SYSTEM_DEFAULT,  <br>        DISPATCH_PROPERTYGET,  <br>        &amp;dispparamsNoArgs, &amp;varResult, NULL, NULL);  <br> <br>        ASSERT(SUCCEEDED(hr), ""); <br>        if (FAILED(hr)) <br>            continue; <br> <br>        // Set the property on the new object             <br>        DISPID dispidNew = 0; <br>    hr = GetIDsOfNamesEx(IID_NULL, &amp;bstrName, 1, LOCALE_SYSTEM_DEFAULT, <br>    &amp;dispidNew, 0); <br> <br>        ASSERT(SUCCEEDED(hr), ""); <br>        if (FAILED(hr)) <br>            continue; <br> <br>        DISPPARAMS dispparams;  <br>        dispparams.rgvarg[0] = varResult;  <br> <br>        DISPID rgdispid[] = {DISPID_PROPERTYPUT}; <br>        dispparams.rgdispidNamedArgs = rgdispid;  <br>        dispparams.cArgs = 1;  <br>        dispparams.cNamedArgs = 1;  <br> <br>        hr = Invoke(  <br>    dispidNew,  <br>    IID_NULL,  <br>    LOCALE_SYSTEM_DEFAULT,  <br>    DISPATCH_PROPERTYPUT,  <br>    &amp;dispparams, NULL, NULL, NULL);  <br>    } <br> <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
