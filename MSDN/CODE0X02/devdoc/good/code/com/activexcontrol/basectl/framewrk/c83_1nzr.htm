<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLHELP.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context87"></a>CTLHELP.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlHelp.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// helper routines for our COleControl implementation <br>// <br> <br>#include "IPServer.H" <br>#include "CtrlObj.H" <br> <br>#include "CtlHelp.H" <br>#include "Util.H" <br>#include &lt;windows.h&gt; <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>//=--------------------------------------------------------------------------= <br>// this is used by the window reflection code. <br>// <br>extern BYTE g_fRegisteredReflect; <br>extern char g_szReflectClassName []; <br> <br> <br>// define this here, since it's the only guid we really need to define in the <br>// framework -- the user control defines all other interesting guids. <br>// <br>static const GUID IID_IControlPrv = <br>{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } }; <br> <br> <br>// this table is used for copying data around, and persisting properties. <br>// basically, it contains the size of a given data type <br>// <br>const BYTE g_rgcbDataTypeSize[] = { <br>    0,                      // VT_EMPTY= 0, <br>    0,                      // VT_NULL= 1, <br>    sizeof(short),          // VT_I2= 2, <br>    sizeof(long),           // VT_I4 = 3, <br>    sizeof(float),          // VT_R4  = 4, <br>    sizeof(double),         // VT_R8= 5, <br>    sizeof(CURRENCY),       // VT_CY= 6, <br>    sizeof(DATE),           // VT_DATE = 7, <br>    sizeof(BSTR),           // VT_BSTR = 8, <br>    sizeof(IDispatch *),    // VT_DISPATCH    = 9, <br>    sizeof(SCODE),          // VT_ERROR    = 10, <br>    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11, <br>    sizeof(VARIANT),        // VT_VARIANT= 12, <br>    sizeof(IUnknown *),     // VT_UNKNOWN= 13, <br>}; <br> <br>const BYTE g_rgcbPromotedDataTypeSize[] = { <br>    0,                      // VT_EMPTY= 0, <br>    0,                      // VT_NULL= 1, <br>    sizeof(int ),           // VT_I2= 2, <br>    sizeof(long),           // VT_I4 = 3, <br>    sizeof(double),         // VT_R4  = 4, <br>    sizeof(double),         // VT_R8= 5, <br>    sizeof(CURRENCY),       // VT_CY= 6, <br>    sizeof(DATE),           // VT_DATE = 7, <br>    sizeof(BSTR),           // VT_BSTR = 8, <br>    sizeof(IDispatch *),    // VT_DISPATCH    = 9, <br>    sizeof(SCODE),          // VT_ERROR    = 10, <br>    sizeof(int),            // VT_BOOL    = 11, <br>    sizeof(VARIANT),        // VT_VARIANT= 12, <br>    sizeof(IUnknown *),     // VT_UNKNOWN= 13, <br>}; <br> <br>//=--------------------------------------------------------------------------= <br>// _SpecialKeyState <br>//=--------------------------------------------------------------------------= <br>// returns a short with some information on which of the SHIFT, ALT, and CTRL <br>// keys are set. <br>// <br>// Output: <br>//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT. <br>// <br>// Notes: <br>// <br>short _SpecialKeyState() <br>{ <br>    // don't appear to be able to reduce number of calls to GetKeyState <br>    // <br>    BOOL bShift = (GetKeyState(VK_SHIFT) &lt; 0); <br>    BOOL bCtrl  = (GetKeyState(VK_CONTROL) &lt; 0); <br>    BOOL bAlt   = (GetKeyState(VK_MENU) &lt; 0); <br> <br>    return (short)(bShift + (bCtrl &lt;&lt; 1) + (bAlt &lt;&lt; 2)); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CopyAndAddRefObject <br>//=--------------------------------------------------------------------------= <br>// copies an object pointer, and then addref's the object. <br>// <br>// Parameters: <br>//    void *        - [in] dest. <br>//    const void *  - [in] src <br>//    DWORD         - [in] size, ignored, since it's always 4 <br>// <br>// Notes: <br>// <br>void WINAPI CopyAndAddRefObject <br>( <br>    void       *pDest, <br>    const void *pSource, <br>    DWORD       dwSize <br>) <br>{ <br>    ASSERT(pDest &amp;&amp; pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!"); <br> <br>    *((IUnknown **)pDest) = *((IUnknown **)pSource); <br>    ADDREF_OBJECT(*((IUnknown **)pDest)); <br> <br>    return; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CopyOleVerb    [helper] <br>//=--------------------------------------------------------------------------= <br>// copies an OLEVERB structure.  used in CStandardEnum <br>// <br>// Parameters: <br>//    void *        - [out] where to copy to <br>//    const void *  - [in]  where to copy from <br>//    DWORD         - [in]  bytes to copy <br>// <br>// Notes: <br>// <br>void WINAPI CopyOleVerb <br>( <br>    void       *pvDest, <br>    const void *pvSrc, <br>    DWORD       cbCopy <br>) <br>{ <br>    VERBINFO * pVerbDest = (VERBINFO *) pvDest; <br>    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc; <br> <br>    *pVerbDest = *pVerbSrc; <br>    ((OLEVERB *)pVerbDest)-&gt;lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)-&gt;idVerbName); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// ControlFromUnknown    [helper, callable] <br>//=--------------------------------------------------------------------------= <br>// given an unknown, get the COleControl pointer for it. <br>// <br>// Parameters: <br>//    IUnknown *        - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>COleControl *ControlFromUnknown <br>( <br>    IUnknown *pUnk <br>) <br>{ <br>    COleControl *pCtl = NULL; <br> <br>    if (!pUnk) return NULL; <br>    pUnk-&gt;QueryInterface(IID_IControlPrv, (void **)&amp;pCtl); <br> <br>    return pCtl; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CreateReflectWindow    [blech] <br>//=--------------------------------------------------------------------------= <br>// unfortunately, in certain cases, we have to create two windows, one of <br>// which exists strictly to reflect messages on to the control.  Majorly <br>// lame.  Fortunately, the number of hosts which require this is quite small. <br>// <br>// Parameters: <br>//    BOOL        - [in] should it be created visible? <br>//    HWND        - [in] parent window <br>//    int         - [in] x pos <br>//    int         - [in] y pos <br>//    SIZEL *     - [in] size <br>// <br>// Output: <br>//    HWND        - reflecting hwnd or NULL if it failed. <br>// <br>// Notes: <br>// <br>HWND CreateReflectWindow <br>( <br>    BOOL   fVisible, <br>    HWND   hwndParent, <br>    int    x, <br>    int    y, <br>    SIZEL *pSize <br>) <br>{ <br>    WNDCLASS wndclass; <br> <br>    // first thing to do is register the window class.  crit sect this <br>    // so we don't have to move it into the control <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (!g_fRegisteredReflect) { <br> <br>        memset(&amp;wndclass, 0, sizeof(wndclass)); <br>        wndclass.lpfnWndProc = COleControl::ReflectWindowProc; <br>        wndclass.hInstance   = g_hInstance; <br>        wndclass.lpszClassName = g_szReflectClassName; <br> <br>        if (!RegisterClass(&amp;wndclass)) { <br>            FAIL("Couldn't Register Parking Window Class!"); <br>            LeaveCriticalSection(&amp;g_CriticalSection); <br>            return NULL; <br>        } <br>        g_fRegisteredReflect = TRUE; <br>    } <br> <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    // go and create the window. <br>    // <br>    return CreateWindowEx(0, g_szReflectClassName, NULL, <br>                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0), <br>                          x, y, pSize-&gt;cx, pSize-&gt;cy, <br>                          hwndParent, <br>                          NULL, g_hInstance, NULL); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// in case the user doesn't want our default window proc, we support <br>// letting them specify one themselves. this is defined in their main ipserver <br>// file. <br>// <br>extern WNDPROC g_ParkingWindowProc; <br> <br>//=--------------------------------------------------------------------------= <br>// GetParkingWindow <br>//=--------------------------------------------------------------------------= <br>// creates the global parking window that we'll use to parent things, or <br>// returns the already existing one <br>// <br>// Output: <br>//    HWND                - our parking window <br>// <br>// Notes: <br>// <br>HWND GetParkingWindow <br>( <br>    void <br>) <br>{ <br>    WNDCLASS wndclass; <br> <br>    // crit sect this creation for apartment threading support. <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (g_hwndParking) <br>        goto CleanUp; <br> <br>    ZeroMemory(&amp;wndclass, sizeof(wndclass)); <br>    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc; <br>    wndclass.hInstance   = g_hInstance; <br>    wndclass.lpszClassName = "CtlFrameWork_Parking"; <br> <br>    if (!RegisterClass(&amp;wndclass)) { <br>        FAIL("Couldn't Register Parking Window Class!"); <br>        goto CleanUp; <br>    } <br> <br>    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL); <br>    if (g_hwndParking != NULL) <br>       ++g_cLocks; <br> <br>    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!"); <br> <br> <br>  CleanUp: <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br>    return g_hwndParking; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
