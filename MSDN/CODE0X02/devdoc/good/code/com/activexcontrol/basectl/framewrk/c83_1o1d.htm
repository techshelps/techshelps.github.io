<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLPSST.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context91"></a>CTLPSST.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlPsst.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of persistence interfaces for COleControl. <br>// <br>#include "IPServer.H" <br>#include "CtrlObj.H" <br> <br>#include "CtlHelp.H" <br>#include "Util.H" <br> <br>// this is the name of the stream we'll save our ole controls to. <br>// <br>const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM"; <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>//=--------------------------------------------------------------------------= <br>// to help with out stream save implementation ... <br>// <br>#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!) <br>#define IPROP_END 0xFF                  // Marker at end of property list <br>#define MAXAUTOBUF 3800                 // Best if &lt; 1 page. <br> <br>typedef struct tagSTREAMHDR { <br> <br>    DWORD  dwSignature;     // Signature. <br>    size_t cbWritten;       // Number of bytes written <br> <br>} STREAMHDR; <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl persistence interfaces <br>//=--------------------------------------------------------------------------= <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Load    [IPersistPropertyBag] <br>//=--------------------------------------------------------------------------= <br>// IPersistPropertyBag.  we've got a property bag, so let's load our properties <br>// from it. <br>// <br>// Parameters: <br>//    IPropertyBag *      - [in] pbag from which to read props. <br>//    IErrorLog *         - [in] error log to write to <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Load <br>( <br>    IPropertyBag *pPropertyBag, <br>    IErrorLog    *pErrorLog <br>) <br>{ <br>    HRESULT hr; <br> <br>    // load in our standard state first.  nothing serious here ... currently, <br>    // we've just got two properties, for cx and cy. <br>    // <br>    hr = LoadStandardState(pPropertyBag, pErrorLog); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // now call the user text load function, and get them to load in whatever <br>    // they're interested in. <br>    // <br>    hr = LoadTextState(pPropertyBag, pErrorLog); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Save    [IPersistPropertyBag] <br>//=--------------------------------------------------------------------------= <br>// given a property bag, save out all the relevant state information. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] property to write to <br>//    BOOL                  - [in] do we clear the dirty bit? <br>//    BOOL                  - [in] do we write out default values anyhoo? <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Save <br>( <br>    IPropertyBag *pPropertyBag, <br>    BOOL          fClearDirty, <br>    BOOL          fWriteDefault <br>) <br>{ <br>    HRESULT hr; <br> <br>    // save out standard state information <br>    // <br>    hr = SaveStandardState(pPropertyBag); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // now call the user function and get them to save out <br>    // all of their properties. <br>    // <br>    hr = SaveTextState(pPropertyBag, fWriteDefault); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // now clear the dirty flag and send out notification that we're <br>    // done. <br>    // <br>    if (fClearDirty) <br>        m_fDirty = FALSE; <br> <br>    if (m_pOleAdviseHolder) <br>        m_pOleAdviseHolder-&gt;SendOnSave(); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetClassID    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// returns the classid of this mamma <br>// <br>// Parameters: <br>//    CLSID *         - [out] where to put the clsid <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetClassID <br>( <br>    CLSID *pclsid <br>) <br>{ <br>    CHECK_POINTER(pclsid); <br> <br>    // copy the thing over <br>    // <br>    *pclsid = CLSIDOFOBJECT(m_ObjectType); <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::IsDirty    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// asks if we're dirty or not.  duh. <br>// <br>// Output: <br>//    HRESULT        - S_OK: dirty, S_FALSE: not dirty <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::IsDirty <br>( <br>    void <br>) <br>{ <br>    return (m_fDirty) ? S_OK : S_FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InitNew    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// causes the control to intialize itself with a new bunch of state information <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::InitNew <br>( <br>    void <br>) <br>{ <br>    BOOL f; <br> <br>    // call the overridable function to do this work <br>    // <br>    f = InitializeNewState(); <br>    return (f) ? S_OK : E_FAIL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetSizeMax    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// <br>// Parameters: <br>//    ULARGE_INTEGER *    - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetSizeMax <br>( <br>    ULARGE_INTEGER *pulMaxSize <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Load    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// load from an IStream <br>// <br>// Parameters: <br>//    IStream *    - [in] stream from which to load <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Load <br>( <br>    IStream *pStream <br>) <br>{ <br>    HRESULT hr; <br> <br>    // first thing to do is read in standard properties the user don't <br>    // persist themselves. <br>    // <br>    hr = LoadStandardState(pStream); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // load in the user properties.  this method is one they -have- to implement <br>    // themselves. <br>    // <br>    hr = LoadBinaryState(pStream); <br>     <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Save    [IPersistStreamInit] <br>//=--------------------------------------------------------------------------= <br>// saves out our state using streams <br>// <br>// Parameters: <br>//    IStream *        - [in] <br>//    BOOL             - [in] clear dirty bit? <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Save <br>( <br>    IStream *pStream, <br>    BOOL     fClearDirty <br>) <br>{ <br>    HRESULT hr; <br> <br>    // use our helper routine that we share with the IStorage persistence <br>    // code. <br>    // <br>    hr = m_SaveToStream(pStream); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // clear out dirty flag [if appropriate] and notify that we're done <br>    // with save. <br>    // <br>    if (fClearDirty) <br>        m_fDirty = FALSE; <br>    if (m_pOleAdviseHolder) <br>        m_pOleAdviseHolder-&gt;SendOnSave(); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InitNew    [IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// ipersiststorage version of this.  fweee <br>// <br>// Parameters: <br>//    IStorage *    - [in] we don't use this <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::InitNew <br>( <br>    IStorage *pStorage <br>) <br>{ <br>    // we already have an implementation of this [for IPersistStreamInit] <br>    // <br>    return InitNew(); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Load    [IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// Ipersiststorage version of this <br>// <br>// Parameters: <br>//    IStorage *    - [in] DUH. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Load(IStorage *pStorage) <br>{ <br>    IStream *pStream; <br>    HRESULT  hr; <br> <br>    // we're going to use IPersistStream::Load from the CONTENTS stream. <br>    // <br>    hr = pStorage-&gt;OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &amp;pStream); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // IPersistStreamInit::Load <br>    // <br>    hr = Load(pStream); <br>    pStream-&gt;Release(); <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Save    [IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// save into the contents stream of the given storage object. <br>// <br>// Parameters: <br>//    IStorage *        - [in] 10 points if you figure it out <br>//    BOOL              - [in] is the storage the same as the load storage? <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Save <br>( <br>    IStorage *pStorage, <br>    BOOL      fSameAsLoad <br>) <br>{ <br>    IStream *pStream; <br>    HRESULT  hr; <br> <br>    // we're just going to save out to the CONTENTES stream. <br>    // <br>    hr = pStorage-&gt;CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE, <br>                                0, 0, &amp;pStream); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // use our helper routine. <br>    // <br>    hr = m_SaveToStream(pStream); <br>    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE; <br>    pStream-&gt;Release(); <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SaveCompleted    [IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// lets us clear out our flags. <br>// <br>// Parameters: <br>//    IStorage *    - ignored <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SaveCompleted <br>( <br>    IStorage *pStorageNew <br>) <br>{ <br>    // if our save succeeded, then we can do our post save work. <br>    // <br>    if (m_fSaveSucceeded) { <br>        m_fDirty = FALSE; <br>        if (m_pOleAdviseHolder) <br>            m_pOleAdviseHolder-&gt;SendOnSave(); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::HandsOffStorage    [IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// not interesting <br>// <br>// Output: <br>//    S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::HandsOffStorage <br>( <br>    void <br>) <br>{ <br>    // we don't ever hold on to  a storage pointer, so this is remarkably <br>    // uninteresting to us. <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage] <br>//=--------------------------------------------------------------------------= <br>// save ourselves to a stream <br>// <br>// Parameters: <br>//    IStream *        - figure it out <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::m_SaveToStream <br>( <br>    IStream *pStream <br>) <br>{ <br>    HRESULT hr; <br> <br>    // save out standard state information that the user has no control <br>    // over <br>    // <br>    hr = SaveStandardState(pStream); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // save out user-specific satte information.  they MUST implement this <br>    // function <br>    // <br>    hr = SaveBinaryState(pStream); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::LoadStandardState    [ helper ] <br>//=--------------------------------------------------------------------------= <br>// reads in standard properties that all controls are going to have, using <br>// text persistence APIs.  there is another version for streams. <br>// <br>// Parameters: <br>//    IPropertyBag *    - [in] <br>//    IErrorLog *       - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::LoadStandardState <br>( <br>    IPropertyBag *pPropertyBag, <br>    IErrorLog    *pErrorLog <br>) <br>{ <br>    VARIANT v; <br>    HRESULT hr; <br>    SIZEL   slHiMetric = { 100, 50 }; <br> <br>    // currently, our only standard properties are related to size. <br>    // if we can't find them, then we'll just use some defaults. <br>    // <br>    v.vt = VT_I4; <br>    v.lVal = 0; <br>    hr = pPropertyBag-&gt;Read(L"_ExtentX", &amp;v, pErrorLog); <br>    if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal; <br> <br>    v.lVal = 0; <br>    hr = pPropertyBag-&gt;Read(L"_ExtentY", &amp;v, pErrorLog); <br>    if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal; <br> <br>    HiMetricToPixel(&amp;slHiMetric, &amp;m_Size); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::LoadStandardState    [ helper ] <br>//=--------------------------------------------------------------------------= <br>// reads in standard properties that all controls are going to have, using <br>// stream persistence APIs.  there is another version for text. <br>// <br>// Parameters: <br>//    IStream *         - [in]  <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::LoadStandardState <br>( <br>    IStream *pStream <br>) <br>{ <br>    STREAMHDR stmhdr; <br>    HRESULT hr; <br>    SIZEL   slHiMetric; <br> <br>    // look for our header structure, so we can verify stream validity. <br>    // <br>    hr = pStream-&gt;Read(&amp;stmhdr, sizeof(STREAMHDR), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE) <br>        return E_UNEXPECTED; <br> <br>    // currently, the only standard state we're writing out is <br>    // a SIZEL structure describing the control's size. <br>    // <br>    if (stmhdr.cbWritten != sizeof(m_Size)) <br>        return E_UNEXPECTED; <br> <br>    // we like the stream.  let's go load in our two properties. <br>    // <br>    hr = pStream-&gt;Read(&amp;slHiMetric, sizeof(slHiMetric), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    HiMetricToPixel(&amp;slHiMetric, &amp;m_Size); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SaveStandardState    [ helper ] <br>//=--------------------------------------------------------------------------= <br>// saves out standard properties that we're managing for a control using text <br>// persistence APIs.  there is another version for stream persistence. <br>// <br>// Parameters: <br>//    IPropertyBag *        - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::SaveStandardState <br>( <br>    IPropertyBag *pPropertyBag <br>) <br>{ <br>    HRESULT hr; <br>    VARIANT v; <br>    SIZEL   slHiMetric; <br> <br>    // currently, the only standard proprerties we persist are Size related <br>    // <br>    PixelToHiMetric(&amp;m_Size, &amp;slHiMetric); <br> <br>    v.vt = VT_I4; <br>    v.lVal = slHiMetric.cx; <br> <br>    hr = pPropertyBag-&gt;Write(L"_ExtentX", &amp;v); <br>    RETURN_ON_FAILURE(hr); <br> <br>    v.lVal = slHiMetric.cy; <br> <br>    hr = pPropertyBag-&gt;Write(L"_ExtentY", &amp;v); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SaveStandardState    [ helper ] <br>//=--------------------------------------------------------------------------= <br>// saves out standard properties that we're managing for a control using stream <br>// persistence APIs.  there is another version for text persistence. <br>// <br>// Parameters: <br>//    IStream *            - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::SaveStandardState <br>( <br>    IStream *pStream <br>) <br>{ <br>    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) }; <br>    HRESULT hr; <br>    SIZEL   slHiMetric; <br> <br> <br>    // first thing to do is write out our stream hdr structure. <br>    // <br>    hr = pStream-&gt;Write(&amp;streamhdr, sizeof(STREAMHDR), NULL); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // the only properties we're currently persisting here are the size <br>    // properties for this control.  make sure we do that in HiMetric <br>    // <br>    PixelToHiMetric(&amp;m_Size, &amp;slHiMetric); <br> <br>    hr = pStream-&gt;Write(&amp;slHiMetric, sizeof(slHiMetric), NULL); <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InitializeNewState    [overridable] <br>//=--------------------------------------------------------------------------= <br>// the user can override this to initialize variables <br>// <br>// Output: <br>//    BOOL        - FALSE means couldn't do it. <br>// <br>// Notes: <br>// <br>BOOL COleControl::InitializeNewState <br>( <br>    void <br>) <br>{ <br>    // we find this largely uninteresting <br>    // <br>    return TRUE; <br>} <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
