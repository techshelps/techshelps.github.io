<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLEMBED.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context86"></a>CTLEMBED.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlEmbed.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of the interfaces required for inplace activation for <br>// COleControl <br>// <br> <br>#include "IPServer.H" <br>#include "CtrlObj.H" <br> <br>#include "CtlHelp.H" <br>#include "Globals.H" <br>#include "StdEnum.H" <br>#include "Util.H" <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br> <br>//=--------------------------------------------------------------------------= <br>// all controls support the following in-place verbs at an absolute minimum. <br>// <br>#define CINPLACEVERBS 4 <br> <br>const VERBINFO rgInPlaceVerbs [] = { <br>    { OLEIVERB_SHOW,            0, 0, 0}, <br>    { OLEIVERB_HIDE,            0, 0, 0}, <br>    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0}, <br>    { OLEIVERB_PRIMARY,         0, 0, 0} <br>}; <br> <br>// NOTE: Resource ID for Properties string must be 1000 <br>// <br>const VERBINFO ovProperties = <br>    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU }; <br> <br>const VERBINFO ovUIActivate = <br>    { OLEIVERB_UIACTIVATE, 0, 0, 0}; <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetControlInfo    (IOleControl) <br>//=--------------------------------------------------------------------------= <br>// returns some information on a control, such as an accelerator table, and <br>// flags.  really used for keyboard handling and mnemonics <br>// <br>// Parameters: <br>//    CONTROLINFO *        - [in]  where to put said information <br>// <br>// Output: <br>//    HRESULT              - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetControlInfo <br>( <br>    CONTROLINFO *pControlInfo <br>) <br>{ <br>    CHECK_POINTER(pControlInfo); <br> <br>    // certain hosts have a bug in which it doesn't initialize the cb in the <br>    // CONTROLINFO structure, so we can only assert on that here. <br>    // <br>    ASSERT(pControlInfo-&gt;cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure"); <br> <br>    // NOTE: control writers should override this routine if they want to <br>    // return accelerator information in their control. <br>    // <br>    pControlInfo-&gt;hAccel = NULL; <br>    pControlInfo-&gt;cAccel = NULL; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnMnemonic    [IOleControl] <br>//=--------------------------------------------------------------------------= <br>// the container has decided to pass on a key that the end-user has pressed to <br>// us.  default implementation will be to just activate the control.  people <br>// looking for more functionality should override this method. <br>// <br>// Parameters: <br>//    LPMSG                - [in] message for this mnemonic <br>// <br>// Output: <br>//    HRESULT              - S_OK, E_POINTER <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnMnemonic <br>( <br>    LPMSG pMsg <br>) <br>{ <br>    // OVERRIDE: default implementation is to just activate our control.   <br>    // user can override if they want more interesting behaviour. <br>    // <br>    return InPlaceActivate(OLEIVERB_UIACTIVATE); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl:OnAmbientPropertyChange    [IOleControl] <br>//=--------------------------------------------------------------------------= <br>// a container calls this whenever it changes an ambient property. <br>// <br>// Parameters: <br>//    DISPID            - [in] dispid of the property that changed. <br>// <br>// Output: <br>//    HRESULT           - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnAmbientPropertyChange <br>( <br>    DISPID dispid <br>) <br>{ <br>    // if we're being told about a change in mode [design/run] then <br>    // remember that so our stashing of mode will update itself <br>    // correctly <br>    // <br>    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN) <br>        m_fModeFlagValid = FALSE; <br> <br>    // just pass this on to the derived control and see if they want <br>    // to do anything with it. <br>    // <br>    AmbientPropertyChanged(dispid); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControL::FreezeEvents    [IOleControl] <br>//=--------------------------------------------------------------------------= <br>// allows a container to freeze all of a controls events.  when events are <br>// frozen, a control will not fire any of them. <br>// <br>// Parameters: <br>//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW <br>// <br>// Output: <br>//    HRESULT         - S_OK <br>// <br>// Notes: <br>//    - we maintain an internal count of freezes versus thaws. <br>// <br>STDMETHODIMP COleControl::FreezeEvents <br>( <br>    BOOL fFreeze <br>) <br>{ <br>    // OVERRIDE: by default, we don't care.  user can override if they want to. <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetClientSite    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// informs the embedded object [control] of it's client site [display <br>// location] within it's container <br>// <br>// Parameters: <br>//    IOleClientSite *        - [in] pointer to client site. <br>// <br>// Output: <br>//    HRESULT                 - S_OK, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SetClientSite <br>( <br>    IOleClientSite *pClientSite <br>) <br>{ <br>    RELEASE_OBJECT(m_pClientSite); <br>    RELEASE_OBJECT(m_pControlSite); <br>    RELEASE_OBJECT(m_pSimpleFrameSite); <br> <br>    // store away the new client site <br>    // <br>    m_pClientSite = pClientSite; <br> <br>    // if we've actually got one, then get some other interfaces we want to keep <br>    // around, and keep a handle on it <br>    // <br>    if (m_pClientSite) { <br>        m_pClientSite-&gt;AddRef(); <br>        m_pClientSite-&gt;QueryInterface(IID_IOleControlSite, (void **)&amp;m_pControlSite); <br> <br>        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) &amp; OLEMISC_SIMPLEFRAME) <br>            m_pClientSite-&gt;QueryInterface(IID_ISimpleFrameSite, (void **)&amp;m_pSimpleFrameSite); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetClientSite    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// obtains a pointer to the controls client site. <br>// <br>// Parameters: <br>//    IOleClientSite **        - [out] <br>// <br>// Output: <br>//    HRESULT                  - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetClientSite <br>( <br>    IOleClientSite **ppClientSite <br>) <br>{ <br>    CHECK_POINTER(ppClientSite); <br> <br>    *ppClientSite = m_pClientSite; <br>    ADDREF_OBJECT(*ppClientSite); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetHostNames    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Provides the control with the name of its container application and the <br>// compound document in which it is embedded <br>// <br>// Parameters: <br>//    LPCOLESTR        - [in] name of container application <br>//    LPCOLESTR        - [in] name of container document <br>// <br>// Output: <br>//    HRESULT          - S_OK <br>// <br>// Notes: <br>//    - we don't care about this <br>// <br>STDMETHODIMP COleControl::SetHostNames <br>( <br>    LPCOLESTR szContainerApp, <br>    LPCOLESTR szContainerObject <br>) <br>{ <br>    // we don't care about these <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Close    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Changes the control from the running to the loaded state <br>// <br>// Parameters: <br>//    DWORD             - [in] indicates whether to save the object before closing <br>// <br>// Output: <br>//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Close <br>( <br>    DWORD dwSaveOption <br>) <br>{ <br>    HRESULT hr; <br> <br>    if (m_fInPlaceActive) { <br>        hr = InPlaceDeactivate(); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    // handle the save flag. <br>    // <br>    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) &amp;&amp; m_fDirty) { <br>        if (m_pClientSite) m_pClientSite-&gt;SaveObject(); <br>        if (m_pOleAdviseHolder) m_pOleAdviseHolder-&gt;SendOnSave(); <br>    } <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetMoniker    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Notifies an object of its container's moniker, the object's own moniker <br>// relative to the container, or the object's full moniker <br>// <br>// Parameters: <br>//    DWORD                - [in] which moniker is being set <br>//    IMoniker *           - [in] the moniker <br>// <br>// Output: <br>//    HRESULT              - S_OK, E_FAIL <br>// <br>// Notes: <br>//    - we don't support monikers. <br>// <br>STDMETHODIMP COleControl::SetMoniker <br>( <br>    DWORD     dwWhichMoniker, <br>    IMoniker *pMoniker <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetMoniker    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Returns a embedded object's moniker, which the caller can use to link to <br>// the object <br>// <br>// Parameters: <br>//    DWORD            - [in]  how it's assigned <br>//    DWORD            - [in]  which moniker <br>//    IMoniker **      - [out] duh. <br>// <br>// Output: <br>//    HRESULT          - E_NOTIMPL <br>// <br>// Notes: <br>//    - we don't support monikers <br>// <br>STDMETHODIMP COleControl::GetMoniker <br>( <br>    DWORD      dwAssign, <br>    DWORD      dwWhichMoniker, <br>    IMoniker **ppMonikerOut <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InitFromData    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Initializes a newly created object with data from a specified data object, <br>// which can reside either in the same container or on the Clipboard <br>// <br>// Parameters: <br>//    IDataObject*    - [in] data object with the data <br>//    BOOL            - [in] how object is created <br>//    DWORD           - reserved <br>// <br>// Output: <br>//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING <br>// <br>// Notes: <br>//    - we don't have data object support <br>// <br>STDMETHODIMP COleControl::InitFromData <br>( <br>    IDataObject *pDataObject, <br>    BOOL         fCreation, <br>    DWORD        dwReserved <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetClipboardData    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Retrieves a data object containing the current contents of the control. <br>// Using the pointer to this data object, it is possible to create a new control <br>// with the same data as the original <br>// <br>// Parameters: <br>//    DWORD          - reserved <br>//    IDataObject ** - [out] data object for this control <br>// <br>// Output: <br>//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetClipboardData <br>( <br>    DWORD         dwReserved, <br>    IDataObject **ppDataObject <br>) <br>{ <br>    *ppDataObject = NULL;        // be a good neighbour <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::DoVerb    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Requests an object to perform an action in response to an end-user's <br>// action. <br>// <br>// Parameters: <br>//    LONG             - [in]  verb to be performed <br>//    LPMSG            - [in]  event that invoked the verb <br>//    IOleClientSite * - [in]  the controls active client site <br>//    LONG             - [in]  reserved <br>//    HWND             - [in]  handle of window containing the object. <br>//    LPCRECT          - [in]  pointer to objects's display rectangle <br>// <br>// Output: <br>//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE, <br>//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND, <br>//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT, <br>//                       OLE_CLASSDIFF, E_NOTIMPL <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::DoVerb <br>( <br>    LONG            lVerb, <br>    LPMSG           pMsg, <br>    IOleClientSite *pActiveSite, <br>    LONG            lIndex, <br>    HWND            hwndParent, <br>    LPCRECT         prcPosRect <br>) <br>{ <br>    HRESULT hr; <br> <br>    switch (lVerb) { <br>      case OLEIVERB_SHOW: <br>      case OLEIVERB_INPLACEACTIVATE: <br>      case OLEIVERB_UIACTIVATE: <br>        hr = InPlaceActivate(lVerb); <br>        OnVerb(lVerb); <br>        return (hr); <br> <br>      case OLEIVERB_HIDE: <br>        UIDeactivate(); <br>        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE); <br>        OnVerb(lVerb); <br>        return S_OK; <br> <br>      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it <br>      // turns out that the CDK and certain hosts expect this to show the <br>      // properties instead.  Users can change what this verb does at will. <br>      // <br>      case OLEIVERB_PRIMARY: <br>      case CTLIVERB_PROPERTIES: <br>      case OLEIVERB_PROPERTIES: <br>        { <br>        // show the frame ourselves if the hose can't. <br>        // <br>        if (m_pControlSite) { <br>            hr = m_pControlSite-&gt;ShowPropertyFrame(); <br>            if (hr != E_NOTIMPL) <br>                return hr; <br>        } <br>        IUnknown *pUnk = (IUnknown *)(IOleObject *)this; <br>        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType)); <br> <br>        ModalDialog(TRUE); <br>        hr = OleCreatePropertyFrame(GetActiveWindow(), <br>                            GetSystemMetrics(SM_CXSCREEN) / 2, <br>                            GetSystemMetrics(SM_CYSCREEN) / 2, <br>                            pwsz, <br>                            1, <br>                            &amp;pUnk, <br>                            CPROPPAGESOFCONTROL(m_ObjectType), <br>                            (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)), <br>                            g_lcidLocale, <br>                            NULL, NULL); <br>        ModalDialog(FALSE); <br>        return hr; <br>        } <br> <br>      default: <br>        // if it's a derived-control defined verb, pass it on to them <br>        // <br>        if (lVerb &gt; 0) { <br>            hr = DoCustomVerb(lVerb); <br> <br>            if (hr == OLEOBJ_S_INVALIDVERB) { <br>                // unrecognised verb -- just do the primary verb and <br>                // activate the sucker. <br>                // <br>                hr = InPlaceActivate(OLEIVERB_PRIMARY); <br>                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB; <br>            } else <br>                return hr; <br>        } else { <br>            FAIL("Unrecognized Negative verb in DoVerb().  bad."); <br>            return E_NOTIMPL; <br>        } <br>        break; <br>    } <br> <br>    // dead code <br>    FAIL("this should be dead code!"); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::EnumVerbs    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// create an enumerator object for the verbs this object supports. <br>// <br>// Parameters: <br>//    IEnumOleVERB **    - [out] new enumerator. <br>// <br>// Output: <br>//    HRESULT            - S_OK, E_OUTOFMEMORY <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::EnumVerbs <br>( <br>    IEnumOLEVERB **ppEnumVerbs <br>) <br>{ <br>    int cVerbs; <br>    OLEVERB *rgVerbs, *pVerb; <br> <br>    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType); <br>    BOOL fCanInPlace = !(dw &amp; OLEMISC_INVISIBLEATRUNTIME) || (dw &amp; OLEMISC_ACTIVATEWHENVISIBLE); <br>    BOOL fCanUIActivate = !(dw &amp; OLEMISC_NOUIACTIVATE); <br>    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0); <br> <br>    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType); <br> <br>    // count up all the verbs <br>    // <br>    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0) <br>             + (fHasProperties ? 1 : 0) + cVerbExtra; <br> <br>    // if there aren't any, this suddenly gets really easy ! <br>    // <br>    if (cVerbs == 0) <br>        return OLEOBJ_E_NOVERBS; <br> <br>    // HeapAlloc some storage for these dudes so that we can pass them on to <br>    // the standard enumerator! <br>    // <br>    if (! (rgVerbs = (OLEVERB *)HeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB)))) <br>        return E_OUTOFMEMORY; <br>   <br>    // start copying over verbs.  first, the in-place guys <br>    // <br>    pVerb = rgVerbs; <br>    if (fCanInPlace) { <br>        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB)); <br>        pVerb += CINPLACEVERBS; <br>      } <br> <br>    if (fCanUIActivate) <br>        memcpy(pVerb++, &amp;ovUIActivate, sizeof(OLEVERB)); <br> <br>    // if their control has properties, copy that over now. <br>    // <br>    if (fHasProperties) { <br>        memcpy(pVerb, &amp;ovProperties, sizeof(OLEVERB)); <br>        pVerb++; <br>    } <br> <br>    // finally, any custom verbs! <br>    // <br>    if (cVerbExtra) { <br>        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra); <br>    } <br> <br>    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB, <br>                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb); <br>    if (!*ppEnumVerbs) <br>        return E_OUTOFMEMORY; <br> <br>    // this forces us to go and look for the Localized DLLs.  This is necessary here <br>    // because the CopyOleVerb will get information from localized resources, but <br>    // will only use the global GetResourceHandle, which only uses the global value <br>    // for the LCID.  This turns out to not be a big performance hit, since this <br>    // function is typically only called in design mode, and we stash this value. <br>    // <br>    GetResourceHandle(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Update    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Updates an object handler's or link object's data or view caches. <br>// <br>// Output: <br>//    HRESULT            - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Update <br>( <br>    void <br>) <br>{ <br>    // nothing to do!!! <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::IsUpToDate    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Checks recursively whether or not an object is up to date. <br>// <br>// Output: <br>//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::IsUpToDate <br>( <br>    void <br>) <br>{ <br>    // we're always up to date <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetUserClassID    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Returns the controls class identifier, the CLSID corresponding to the <br>// string identifying the object to an end user. <br>// <br>// Parameters: <br>//    CLSID *      - [in] where to put the CLSID <br>// <br>// Output: <br>//    HRESULT      - S_OK, E_FAIL <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetUserClassID <br>( <br>    CLSID *pclsid <br>) <br>{ <br>    // this is the same as IPersist::GetClassID <br>    // <br>    return GetClassID(pclsid); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetUserType    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Retrieves the user-type name of the control for display in user-interface <br>// elements such as menus, list boxes, and dialog boxes. <br>// <br>// Parameters: <br>//    DWORD        - [in]  specifies the form of the type name. <br>//    LPOLESTR *   - [out] where to put user type <br>// <br>// Output: <br>//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetUserType <br>( <br>    DWORD     dwFormOfType, <br>    LPOLESTR *ppszUserType <br>) <br>{ <br>    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType)); <br>    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetExtent    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Informs the control of how much display space its container has assigned it. <br>// <br>// Parameters: <br>//    DWORD            - [in] which form or 'aspect'  is to be displayed. <br>//    SIZEL *          - [in] size limit for the control. <br>// <br>// Output: <br>//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SetExtent <br>( <br>    DWORD  dwDrawAspect, <br>    SIZEL *psizel <br>) <br>{ <br>    SIZEL sl; <br>    RECT  rect; <br>    BOOL  f; <br> <br>    if (dwDrawAspect &amp; DVASPECT_CONTENT) { <br> <br>        // change the units to pixels, and resize the control. <br>        // <br>        HiMetricToPixel(psizel, &amp;sl); <br> <br>        // first call the user version.  if they return FALSE, they want <br>        // to keep their current size <br>        // <br>        f = OnSetExtent(&amp;sl); <br>        if (f) <br>            HiMetricToPixel(psizel, &amp;m_Size); <br> <br>        // set things up with our HWND if we've got one. <br>        // <br>        if (!m_pInPlaceSiteWndless) { <br>            if (m_fInPlaceActive) { <br>     <br>                // theoretically, one should not need to call OnPosRectChange <br>                // here, but there appear to be a few host related issues that <br>                // will make us keep it here.  we won't, however, both with <br>                // windowless ole controls, since they are all new hosts who <br>                // should know better <br>                // <br>                GetWindowRect(m_hwnd, &amp;rect); <br>                MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&amp;rect, 2); <br>                rect.right = rect.left + m_Size.cx; <br>                rect.bottom = rect.top + m_Size.cy; <br>                m_pInPlaceSite-&gt;OnPosRectChange(&amp;rect); <br>     <br>                if (m_hwnd) { <br>                    // just go and resize <br>                    // <br>                    if (m_hwndReflect) <br>                        SetWindowPos(m_hwndReflect, 0, 0, 0, m_Size.cx, m_Size.cy, <br>                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>                    SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy, <br>                                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>                } <br>            } else if (m_hwnd) { <br>                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE); <br>            } else { <br>                ViewChanged(); <br>            } <br>        } else <br>            if (m_pInPlaceSite) m_pInPlaceSite-&gt;OnPosRectChange(&amp;rect); <br> <br>        // return code depending on whether or not user accepted given <br>        // size <br>        // <br>        return (f) ? S_OK : E_FAIL; <br> <br>    } else { <br>        // we don't support any other aspects. <br>        // <br>        return DV_E_DVASPECT; <br>    } <br> <br>    // dead code <br>    FAIL("This should be dead code"); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetExtent    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Retrieves the control's current display size. <br>// <br>// Parameters: <br>//    DWORD            - [in] aspect <br>//    SIZEL *          - [in] where to put results <br>// <br>// Output: <br>//    S_OK, E_INVALIDARG <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetExtent <br>( <br>    DWORD  dwDrawAspect, <br>    SIZEL *pSizeLOut <br>) <br>{ <br> <br>    if (dwDrawAspect &amp; DVASPECT_CONTENT) { <br>        PixelToHiMetric((const SIZEL *)&amp;m_Size, pSizeLOut); <br>        return S_OK; <br>    } else { <br>        return DV_E_DVASPECT; <br>    } <br> <br>    // dead code <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Advise    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// establishes and advisory connection between the control and the container, <br>// in which the control will notify the container of certain events. <br>// <br>// Parameters: <br>//    IAdviseSink *     - [in]  advise sink of calling object <br>//    DWORD             - [out] cookie <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_OUTOFMEMORY <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Advise <br>( <br>    IAdviseSink *pAdviseSink, <br>    DWORD       *pdwConnection <br>) <br>{ <br>    HRESULT hr; <br> <br>    // if we haven't yet created a standard advise holder object, do so <br>    // now <br>    // <br>    if (!m_pOleAdviseHolder) { <br>        hr = CreateOleAdviseHolder(&amp;m_pOleAdviseHolder); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    // just get it to do the work for us! <br>    // <br>    return m_pOleAdviseHolder-&gt;Advise(pAdviseSink, pdwConnection); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Unadvise    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Deletes a previously established advisory connection. <br>// <br>// Parameters: <br>//    DWORD         - [in] connection cookie <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Unadvise <br>( <br>    DWORD dwConnection <br>) <br>{ <br>    if (!m_pOleAdviseHolder) { <br>        FAIL("Somebody called Unadvise on IOleObject without calling Advise!"); <br>        CONNECT_E_NOCONNECTION; <br>    } <br> <br>    return m_pOleAdviseHolder-&gt;Unadvise(dwConnection); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::EnumAdvise    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Enumerates the advisory connections registered for an object, so a container <br>// can know what to release prior to closing down. <br>// <br>// Parameters: <br>//    IEnumSTATDATA **    - [out] where to put enumerator <br>// <br>// Output: <br>//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::EnumAdvise <br>( <br>    IEnumSTATDATA **ppEnumOut <br>) <br>{ <br>    if (!m_pOleAdviseHolder) { <br>        FAIL("Somebody Called EnumAdvise without setting up any connections"); <br>        *ppEnumOut = NULL; <br>        return E_FAIL; <br>    } <br> <br>    return m_pOleAdviseHolder-&gt;EnumAdvise(ppEnumOut); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetMiscStatus    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Returns a value indicating the status of an object at creation and loading. <br>// <br>// Parameters: <br>//    DWORD         - [in]  aspect desired <br>//    DWORD *       - [out] where to put the bits. <br>// <br>// Output: <br>//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetMiscStatus <br>( <br>    DWORD  dwAspect, <br>    DWORD *pdwStatus <br>) <br>{ <br>    CHECK_POINTER(pdwStatus); <br> <br>    if (dwAspect == DVASPECT_CONTENT) { <br>        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType); <br>        return S_OK; <br>    } else { <br>        return DV_E_DVASPECT; <br>    } <br> <br>    // dead code <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetColorScheme    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Specifies the color palette that the object application should use when it <br>// edits the specified object. <br>// <br>// Parameters: <br>//    LOGPALETTE *     - [in] new palette <br>// <br>// Output: <br>//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING <br>// <br>// Notes: <br>//    - we don't care. <br>// <br>STDMETHODIMP COleControl::SetColorScheme <br>( <br>    LOGPALETTE *pLogpal <br>) <br>{ <br>    // OVERRIDE: control writers can use this if they want to <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// Returns the window handle to one of the windows participating in in-place <br>// activation (frame, document, parent, or in-place object window). <br>// <br>// Parameters: <br>//    HWND *        - [out] where to return window handle. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL <br>// <br>// Notes: <br>//    - this routine has slightly different semantics for windowless controls <br>// <br>STDMETHODIMP COleControl::GetWindow <br>( <br>    HWND *phwnd <br>) </code></pre>
<p>
</p>
<pre><code>{ <br>    // if we're windowles, then we want to return E_FAIL for this so hosts <br>    // know we're windowless <br>    // <br>    if (m_pInPlaceSiteWndless) <br>        return E_FAIL; <br> <br>    // otherwise, just return our outer window. <br>    // <br>    *phwnd = GetOuterWindow(); <br> <br>    return (*phwnd) ? S_OK : E_UNEXPECTED; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// Determines whether context-sensitive help mode should be entered during an <br>// in-place activation session. <br>// <br>// Parameters: <br>//    BOOL            - [in] whether or not to enter help mode. <br>// <br>// Output: <br>//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::ContextSensitiveHelp <br>( <br>    BOOL fEnterMode <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InPlaceActivate <br>//=--------------------------------------------------------------------------= <br>// activates the control, and depending on the verb, optionally ui activates <br>// it as well. <br>// <br>// Parameters: <br>//    LONG         - [in] the verb that caused us to activate <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - this is spaghetti code at it's worst.  effectively, we have to <br>//      be able to handle three types of site pointers -- IOleInPlaceSIte, <br>//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly <br>//      pretty. <br>// <br>HRESULT COleControl::InPlaceActivate <br>( <br>    LONG lVerb <br>) <br>{ <br>    BOOL f; <br>    SIZEL sizel; <br>    IOleInPlaceSiteEx *pIPSEx = NULL; <br>    HRESULT hr; <br>    BOOL    fNoRedraw = FALSE; <br> <br>    // if we don't have a client site, then there's not much to do. <br>    // <br>    if (!m_pClientSite) <br>        return S_OK; <br> <br>    // get an InPlace site pointer. <br>    // <br>    if (!GetInPlaceSite()) { <br> <br>        // if they want windowless support, then we want IOleInPlaceSiteWindowless <br>        // <br>        if (FCONTROLISWINDOWLESS(m_ObjectType)) <br>            m_pClientSite-&gt;QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&amp;m_pInPlaceSiteWndless); <br> <br>        // if we're not able to do windowless siting, then we'll just get an <br>        // IOleInPlaceSite pointer. <br>        // <br>        if (!m_pInPlaceSiteWndless) { <br>            hr = m_pClientSite-&gt;QueryInterface(IID_IOleInPlaceSite, (void **)&amp;m_pInPlaceSite); <br>            RETURN_ON_FAILURE(hr); <br>        } <br>    } <br> <br>    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free <br>    // activation.  if we're windowless, we've already got it, else we need to <br>    // try and get it <br>    // <br>    if (m_pInPlaceSiteWndless) { <br>        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless; <br>        pIPSEx-&gt;AddRef(); <br>    } else <br>        m_pClientSite-&gt;QueryInterface(IID_IOleInPlaceSiteEx, (void **)&amp;pIPSEx); <br> <br>    // if we're not already active, go and do it. <br>    // <br>    if (!m_fInPlaceActive) { <br>        OLEINPLACEFRAMEINFO InPlaceFrameInfo; <br>        RECT rcPos, rcClip; <br> <br>        // if we have a windowless site, see if we can go in-place windowless <br>        // active <br>        // <br>        hr = S_FALSE; <br>        if (m_pInPlaceSiteWndless) { <br>            hr = m_pInPlaceSiteWndless-&gt;CanWindowlessActivate(); <br>            CLEANUP_ON_FAILURE(hr); <br> <br>            // if they refused windowless, we'll try windowed <br>            // <br>            if (S_OK != hr) { <br>                RELEASE_OBJECT(m_pInPlaceSiteWndless); <br>                hr = m_pClientSite-&gt;QueryInterface(IID_IOleInPlaceSite, (void **)&amp;m_pInPlaceSite); <br>                CLEANUP_ON_FAILURE(hr); <br>            } <br>        } <br> <br>        // just try regular windowed in-place activation <br>        // <br>        if (hr != S_OK) { <br>            hr = m_pInPlaceSite-&gt;CanInPlaceActivate(); <br>            if (hr != S_OK) { <br>                hr = (FAILED(hr)) ? E_FAIL : hr; <br>                goto CleanUp; <br>            } <br>        } <br> <br>        // if we are here, then we have permission to go in-place active. <br>        // now, announce our intentions to actually go ahead and do this. <br>        // <br>        hr = (pIPSEx) ? pIPSEx-&gt;OnInPlaceActivateEx(&amp;fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0) <br>                       : m_pInPlaceSite-&gt;OnInPlaceActivate(); <br>        CLEANUP_ON_FAILURE(hr); <br> <br>        // if we're here, we're ready to go in-place active.  we just need <br>        // to set up some flags, and then create the window [if we have <br>        // one] <br>        // <br>        m_fInPlaceActive = TRUE; <br> <br>        // we need to get some information about our location in the parent <br>        // window, as well as some information about the parent <br>        // <br>        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br>        hr = GetInPlaceSite()-&gt;GetWindow(&amp;m_hwndParent); <br>        if (SUCCEEDED(hr)) <br>            hr = GetInPlaceSite()-&gt;GetWindowContext(&amp;m_pInPlaceFrame, &amp;m_pInPlaceUIWindow, &amp;rcPos, &amp;rcClip, &amp;InPlaceFrameInfo); <br>        CLEANUP_ON_FAILURE(hr); <br> <br>        // make sure we'll display ourselves in the correct location with the correct size <br>        // <br>        sizel.cx = rcPos.right - rcPos.left; <br>        sizel.cy = rcPos.bottom - rcPos.top; <br>        f = OnSetExtent(&amp;sizel); <br>        if (f) m_Size = sizel; <br>        SetObjectRects(&amp;rcPos, &amp;rcClip); <br> <br>        // finally, create our window if we have to! <br>        // <br>        if (!m_pInPlaceSiteWndless) { <br>     <br>            SetInPlaceParent(m_hwndParent); <br> <br>            // create the window, and display it.  die horribly if we couldnt' <br>            // <br>            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) { <br>                hr = E_FAIL; <br>                goto CleanUp; <br>            } <br>        } <br>    } <br> <br>    // don't need this any more <br>    // <br>    RELEASE_OBJECT(pIPSEx); <br> <br>    // if we're not inplace visible yet, do so now. <br>    // <br>    if (!m_fInPlaceVisible) <br>        SetInPlaceVisible(TRUE); <br> <br>    // if we weren't asked to UIActivate, then we're done. <br>    // <br>    if (lVerb != OLEIVERB_PRIMARY &amp;&amp; lVerb != OLEIVERB_UIACTIVATE) <br>        return S_OK; <br> <br>    // if we're not already UI active, do sow now. <br>    // <br>    if (!m_fUIActive) { <br>        m_fUIActive = TRUE; <br> <br>        // inform the container of our intent <br>        // <br>        GetInPlaceSite()-&gt;OnUIActivate(); <br> <br>        // take the focus  [which is what UI Activation is all about !] <br>        // <br>        SetFocus(TRUE); <br> <br>        // set ourselves up in the host. <br>        // <br>        m_pInPlaceFrame-&gt;SetActiveObject((IOleInPlaceActiveObject *)this, NULL); <br>        if (m_pInPlaceUIWindow) <br>            m_pInPlaceUIWindow-&gt;SetActiveObject((IOleInPlaceActiveObject *)this, NULL); <br> <br>        // we have to explicitly say we don't wany any border space. <br>        // <br>        m_pInPlaceFrame-&gt;SetBorderSpace(NULL); <br>        if (m_pInPlaceUIWindow) <br>            m_pInPlaceUIWindow-&gt;SetBorderSpace(NULL); <br>    } <br> <br>    // be-de-be-de-be-de that's all folks! <br>    // <br>    return S_OK; <br> <br>  CleanUp: <br>    // something catastrophic happened [or, at least something bad]. <br>    // die a horrible fiery mangled painful death. <br>    // <br>    QUICK_RELEASE(pIPSEx); <br>    m_fInPlaceActive = FALSE; <br>    return hr; <br> <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::InPlaceDeactivate    [IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// Deactivates an active in-place object and discards the object's undo state. <br>// <br>// Output: <br>//    HRESULT        - S_OK, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::InPlaceDeactivate <br>( <br>    void <br>) <br>{ <br>    // if we're not in-place active yet, then this is easy. <br>    // <br>    if (!m_fInPlaceActive) <br>        return S_OK; <br> <br>    // transition from UIActive back to active <br>    // <br>    if (m_fUIActive) <br>        UIDeactivate(); <br> <br>    m_fInPlaceActive = FALSE; <br>    m_fInPlaceVisible = FALSE; <br> <br>    // if we have a window, tell it to go away. <br>    // <br>    if (m_hwnd) { <br>        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up"); <br> <br>        // so our window proc doesn't crash. <br>        // <br>        BeforeDestroyWindow(); <br>        SetWindowLong(m_hwnd, GWL_USERDATA, 0xFFFFFFFF); <br>        DestroyWindow(m_hwnd); <br>        m_hwnd = NULL; <br> <br>        if (m_hwndReflect) { <br>            SetWindowLong(m_hwndReflect, GWL_USERDATA, 0); <br>            DestroyWindow(m_hwndReflect); <br>            m_hwndReflect = NULL; <br>        } <br>    } <br> <br>    RELEASE_OBJECT(m_pInPlaceFrame); <br>    RELEASE_OBJECT(m_pInPlaceUIWindow); <br>    GetInPlaceSite()-&gt;OnInPlaceDeactivate(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::UIDeactivate    [IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// transitions us from UI Active to merely being active [visible]  for <br>// a control, this doesn't mean all that much. <br>// <br>// Output: <br>//    HRESULT         - S_OK, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::UIDeactivate <br>( <br>    void <br>) <br>{ <br>    // if we're not UIActive, not much to do. <br>    // <br>    if (!m_fUIActive) <br>        return S_OK; <br> <br>    m_fUIActive = FALSE; <br> <br>    // notify frame windows, if appropriate, that we're no longer ui-active. <br>    // <br>    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow-&gt;SetActiveObject(NULL, NULL); <br>    m_pInPlaceFrame-&gt;SetActiveObject(NULL, NULL); <br> <br>    // we don't need to explicitly release the focus here since somebody <br>    // else grabbing the focus is what is likely to cause us to get lose it <br>    // <br>    GetInPlaceSite()-&gt;OnUIDeactivate(FALSE); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetObjectRects    [IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// Indicates how much of the control is visible. <br>// <br>// Parameters: <br>//    LPCRECT        - [in] position of the control. <br>//    LPCRECT        - [in] clipping rectangle for the control. <br>// <br>// Output: <br>//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SetObjectRects <br>( <br>    LPCRECT prcPos, <br>    LPCRECT prcClip <br>) <br>{ <br>    BOOL fRemoveWindowRgn; <br> <br>    // move our window to the new location and handle clipping. not applicable <br>    // for windowless controls, since the container will be responsible for all <br>    // clipping. <br>    // <br>    if (m_hwnd) { <br>        fRemoveWindowRgn = m_fUsingWindowRgn; <br>        if (prcClip) { <br>            // the container wants us to clip, so figure out if we really <br>            // need to <br>            // <br>            RECT rcIXect; <br>            if ( IntersectRect(&amp;rcIXect, prcPos, prcClip) ) { <br>                if (!EqualRect(&amp;rcIXect, prcPos)) { <br>                    OffsetRect(&amp;rcIXect, -(prcPos-&gt;left), -(prcPos-&gt;top)); <br> <br>                    HRGN tempRgn = CreateRectRgnIndirect(&amp;rcIXect); <br>                    SetWindowRgn(GetOuterWindow(), tempRgn, TRUE); <br> <br>                    if (m_hRgn != NULL) <br>                       DeleteObject(m_hRgn); <br>                    m_hRgn = tempRgn; <br> <br>                    m_fUsingWindowRgn = TRUE; <br>                    fRemoveWindowRgn  = FALSE; <br>                } <br>            } <br>        } <br> <br>        if (fRemoveWindowRgn) { <br>            SetWindowRgn(GetOuterWindow(), NULL, TRUE); <br>            if (m_hRgn != NULL) <br>            { <br>               DeleteObject(m_hRgn); <br>               m_hRgn = NULL; <br>            } <br>            m_fUsingWindowRgn = FALSE; <br>        } <br> <br>        // set our control's location, but don't change it's size at all <br>        // [people for whom zooming is important should set that up here] <br>        // <br>        DWORD dwFlag; <br>        OnSetObjectRectsChangingWindowPos(&amp;dwFlag); <br> <br>        int cx, cy; <br>        cx = prcPos-&gt;right - prcPos-&gt;left; <br>        cy = prcPos-&gt;bottom - prcPos-&gt;top; <br>        SetWindowPos(GetOuterWindow(), NULL, prcPos-&gt;left, prcPos-&gt;top, cx, cy, dwFlag | SWP_NOZORDER | SWP_NOACTIVATE); <br>    } <br> <br>    // save out our current location.  windowless controls want this more <br>    // that windowed ones do, but everybody can have it just in case <br>    // <br>    m_rcLocation = *prcPos; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ReactivateAndUndo    [IOleInPlaceObject] <br>//=--------------------------------------------------------------------------= <br>// Reactivates a previously deactivated object, undoing the last state of the object. <br>// <br>// Output: <br>//    HRESULT        - S_OK, E_NOTUNDOABLE <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::ReactivateAndUndo <br>( <br>    void <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless] <br>//=--------------------------------------------------------------------------= <br>// this method lets the container dispatch a message to a windowless OLE <br>// object. <br>// <br>// Parameters: <br>//    UINT                - [in]  the message <br>//    WPARAM              - [in]  the messages wparam <br>//    LPARAM              - [in]  duh. <br>//    LRESULT *           - [out] the output value <br>// <br>// Output: <br>//    HRESULT             - S_OK <br>// <br>// Notes: <br>//    - people should call m_pInPlaceSiteWndless-&gt;OnDefWindowMessage [control <br>//      writers should just call OcxDefWindowProc(msg, wparam, lparam)]; <br>// <br>STDMETHODIMP COleControl::OnWindowMessage <br>( <br>    UINT     msg, <br>    WPARAM   wParam, <br>    LPARAM   lParam, <br>    LRESULT *plResult <br>) <br>{ <br>    // little bit of pre-processing -- we need to handle some cases here <br>    // before passing the messages on <br>    // <br>    switch (msg) { <br>        // make sure our UI Activation correctly matches the focus <br>        // <br>        case WM_KILLFOCUS: <br>        case WM_SETFOCUS: <br>            // give the control site focus notification <br>            // <br>            if (m_fInPlaceActive &amp;&amp; m_pControlSite) <br>                m_pControlSite-&gt;OnFocus(msg == WM_SETFOCUS); <br>            break; <br>    } <br> <br>    // just pass it to the control's window proc. <br>    // <br>    *plResult = WindowProc(msg, wParam, lParam); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless] <br>//=--------------------------------------------------------------------------= <br>// this method returns a pointer to the objects IDropTarget interface.  since <br>// they do not have a window, windowless objects cannot register an IDropTarget <br>// interface. <br>// <br>// Parameters: <br>//    IDropTarget **        - [out] <br>// <br>// Output: <br>//    HRESULT               - S_OK, E_NOTIMPL <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetDropTarget <br>( <br>    IDropTarget **ppDropTarget <br>) <br>{ <br>    // OVERRIDE: if you want to do drag and drop and you're windowless, <br>    // override me. <br>    // <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject] <br>//=--------------------------------------------------------------------------= <br>// Processes menu accelerator-key messages from the container's message queue. <br>// <br>// Parameters: <br>//    LPMSG            - [in] the message that has the special key in it. <br>// <br>// Output: <br>//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::TranslateAccelerator <br>( <br>    LPMSG    pmsg <br>) <br>{ <br>    // see if we want it or not. <br>    // <br>    if (OnSpecialKey(pmsg)) <br>        return S_OK; <br> <br>    // if not, then we want to forward it back to the site for further processing <br>    // <br>    if (m_pControlSite) <br>        return m_pControlSite-&gt;TranslateAccelerator(pmsg, _SpecialKeyState()); <br> <br>    // we didn't want it. <br>    // <br>    return S_FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject] <br>//=--------------------------------------------------------------------------= <br>// Notifies the control when the container's top-level frame window is <br>// activated or deactivated. <br>// <br>// Parameters: <br>//    BOOL        - [in] state of containers top level window. <br>// <br>// Output: <br>//    HRESULT     - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnFrameWindowActivate <br>( <br>    BOOL fActivate <br>) <br>{ <br>    // we're supposed to go UI active in this case <br>    // <br>    return InPlaceActivate(OLEIVERB_UIACTIVATE); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject] <br>//=--------------------------------------------------------------------------= <br>// Notifies the active control when the container's document window is <br>// activated or deactivated. <br>// <br>// Parameters: <br>//    BOOL            - state of mdi child window. <br>// <br>// Output: <br>//    HRESULT         - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnDocWindowActivate <br>( <br>    BOOL fActivate <br>) <br>{ <br>    // we're supposed to go UI active in this case <br>    // <br>    return InPlaceActivate(OLEIVERB_UIACTIVATE); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ResizeBorder    [IOleInPlaceActiveObject] <br>//=--------------------------------------------------------------------------= <br>// Alerts the control that it needs to resize its border space. <br>// <br>// Parameters: <br>//    LPCRECT               - [in] new outer rectangle for border space <br>//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed <br>//    BOOL                  - [in] true if it was the fram window taht called. <br>// <br>// Output: <br>//    HRESULT               - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::ResizeBorder <br>( <br>    LPCRECT              prcBorder, <br>    IOleInPlaceUIWindow *pInPlaceUIWindow, <br>    BOOL                 fFrame <br>) <br>{ <br>    // this is largely uninteresting to us, since we have no border. <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::EnableModeless    [IOleInPlaceActiveObject] <br>//=--------------------------------------------------------------------------= <br>// Enables or disables modeless dialog boxes when the container creates or <br>// destroys a modal dialog box. <br>// <br>// Parameters: <br>//    BOOL            - [in] enable or disable modeless dialogs. <br>// <br>// Output: <br>//    HRESULT         - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::EnableModeless <br>( <br>    BOOL fEnable <br>) <br>{ <br>    // phenomenally uninteresting <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetClassInfo    [IProvideClassInfo] <br>//=--------------------------------------------------------------------------= <br>// returns the TypeInfo for the control's coclass. <br>// <br>// Parameters: <br>//    ITypeInfo **        - [out] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetClassInfo <br>( <br>    ITypeInfo **ppTypeInfo <br>) <br>{ <br>    ITypeLib *pTypeLib; <br>    HRESULT hr; <br> <br>    CHECK_POINTER(ppTypeInfo); <br>    *ppTypeInfo = NULL; <br> <br>    // go and get our type library. <br>    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching. <br>    // CONSIDER: - consider trying to register our typelib if this fails. <br>    // <br>    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0, <br>                        LANGIDFROMLCID(g_lcidLocale), &amp;pTypeLib); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // got the typelib.  get typeinfo for our coclass. <br>    // <br>    hr = pTypeLib-&gt;GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo); <br>    pTypeLib-&gt;Release(); <br>    RETURN_ON_FAILURE(hr); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ViewChange    [callable] <br>//=--------------------------------------------------------------------------= <br>// called whenever the view of the object has changed. <br>// <br>// Notes: <br>// <br>void COleControl::ViewChanged <br>( <br>    void <br>) <br>{ <br>    // send the view change notification to anybody listening. <br>    // <br>    if (m_pViewAdviseSink) { <br>        m_pViewAdviseSink-&gt;OnViewChange(DVASPECT_CONTENT, -1); <br> <br>        // if they only asked to be advised once, kill the connection <br>        // <br>        if (m_fViewAdviseOnlyOnce) <br>            SetAdvise(DVASPECT_CONTENT, 0, NULL); <br>    } <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetInPlaceVisible    [helper] <br>//=--------------------------------------------------------------------------= <br>// controls the visibility of the control window. <br>// <br>// Parameters: <br>//    BOOL        - TRUE shows FALSE hides. <br>// <br>// Notes: <br>// <br>void COleControl::SetInPlaceVisible <br>( <br>    BOOL fShow <br>) <br>{ <br>    BOOL fVisible; <br> <br>    m_fInPlaceVisible = fShow; <br> <br>    // don't do anything if we don't have a window.  otherwise, set it <br>    // <br>    if (m_hwnd) { <br>        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) &amp; WS_VISIBLE) != 0); <br> <br>        if (fVisible &amp;&amp; !fShow) <br>            ShowWindow(GetOuterWindow(), SW_HIDE); <br>        else if (!fVisible &amp;&amp; fShow) <br>            ShowWindow(GetOuterWindow(), SW_SHOWNA); <br>    } <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::AmbientPropertyChanged    [overridable] <br>//=--------------------------------------------------------------------------= <br>// a method that derived controls can override to do whatever they want. <br>// we don't particularily care about this event. <br>// <br>// Parameters: <br>//    DISPID            - [in] dispid of prop that changed. <br>// <br>// Notes: <br>// <br>void COleControl::AmbientPropertyChanged <br>( <br>    DISPID dispid <br>) <br>{ <br>    // do nothing <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::DoCustomVerb    [overridable] <br>//=--------------------------------------------------------------------------= <br>// we were asked to execute a verb we don't know about right away.  see if <br>// it's a verb that the dervied-control defined. <br>// <br>// Parameters: <br>//    LONG            - [in] the verb. <br>// <br>// Output: <br>//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB <br>// <br>// Notes: <br>// <br>HRESULT COleControl::DoCustomVerb <br>( <br>    LONG    lVerb <br>) <br>{ <br>    return OLEOBJ_S_INVALIDVERB; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnSetExtent    [overridable] <br>//=--------------------------------------------------------------------------= <br>// let the user do something in the resize, if they care. <br>// <br>// Parameters: <br>//    SIZEL *        - [in] new values. <br>// <br>// Output: <br>//    BOOL           - FALSE means keep current size <br>// <br>// Notes: <br>// <br>BOOL COleControl::OnSetExtent <br>( <br>    const SIZEL *pSizeL <br>) <br>{ <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnSpecialKey    [overridable] <br>//=--------------------------------------------------------------------------= <br>// allows controls to handle special keys such as arrows, CTRL+, etc ... <br>// <br>// Parameters: <br>//    LPMSG        - [in] the special key msg. <br>// <br>// Output: <br>//    BOOL         - TRUE we processed it, FALSE we didn't. <br>// <br>// Notes: <br>// <br>BOOL COleControl::OnSpecialKey <br>( <br>    LPMSG pmsg <br>) <br>{ <br>    // do nothing. <br>    // <br>    return FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::ModalDialog    [callable, utility] <br>//=--------------------------------------------------------------------------= <br>// should be called when the control is about to show and hide a modal dialog. <br>// <br>// Parameters: <br>//    BOOL        - [in] true means showing a modal dialog, false means done <br>// <br>// Notes: <br>// <br>void COleControl::ModalDialog <br>( <br>    BOOL fShow <br>) <br>{ <br>    // notify the container of our intention to show a modal dialog... <br>    // <br>    if (m_pInPlaceFrame) <br>        m_pInPlaceFrame-&gt;EnableModeless(!fShow); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::BeforeDestroyWindow    [overridable] <br>//=--------------------------------------------------------------------------= <br>// called just before we destroy a window.  gives the user the opportunity to <br>// save information out, especially if they're a subclassed control, and this <br>// is an interesting thing to do. <br>// <br>// Notes: <br>// <br>void COleControl::BeforeDestroyWindow <br>( <br>    void <br>) <br>{ <br>    // fweeee <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnSetObjectRectsChangingWIndowPos    [overridable] <br>//=--------------------------------------------------------------------------= <br>// called just before we perform a SetWindowPos in the SetObjectRects <br>// function. gives a control the opportunity to change the flags. <br>// <br>// Notes: <br>// <br>void COleControl::OnSetObjectRectsChangingWindowPos(DWORD *dwFlag) <br>{ <br>    *dwFlag = 0; <br>} <br> <br>void COleControl::OnVerb(LONG lVerb) <br>{ <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
