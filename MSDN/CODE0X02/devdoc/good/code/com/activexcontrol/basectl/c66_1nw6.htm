<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>README.TXT</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context66"></a>README.TXT</h2>
<pre><code><br>THIS TOOL IS NOT SUPPORTED BY MICROSOFT CORPORATION. IT IS PROVIDED "AS IS"  <br>BECAUSE WE BELIEVE IT MAY BE USEFUL TO YOU. <br> <br>NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE <br> <br>It is necessary to build the FrameWrk samples before building ToDoSvr  <br>or WebImage. Running "nmake" from the &lt;sdkdir&gt;\samples\com\activexcontrol\basectl  <br>directory will build all of the sample code in the correct order.  Before  <br>building any of the samples, run setenv.bat to add the Microsoft Platform SDK  <br>include, bin, and lib directories to the front of your environment. <br> <br>More information on the Internet-aware OLE controls is available in  <br>readme.txt files in the sample directories. <br> <br> <br>The Framework Sample Code for Authoring non-MFC Controls <br>====+==================================================== <br> <br> <br>This document presents a short discussion on using the ActiveX Controls  <br>Framework to author new ActiveX controls. <br> <br> <br>0. Contents <br>=---------= <br> <br>1.0  Introduction <br>   1.1  Target Audience <br>   1.2  Structure of the Framework <br>   1.3  Target Environment <br> <br>2.0  Creating an ActiveX Control <br>   2.1  Building the Control <br>   2.2  Working with the In-Process Server <br> <br>3.0  Working with Your ActiveX Control <br>   3.1  Structure of a Control <br>   3.2  Painting a Control <br>   3.3  Handling Messages in a Control <br>   3.4  Adding a Property <br>   3.5  Adding a Method <br>   3.6  Adding an Event <br>   3.7  Using Standard ActiveX Types <br>   3.8  Throwing an Exception <br> <br>4.0  Persistence <br>   4.1  Text Persistence <br>   4.2  Binary Persistence <br> <br>5.0  Property Pages <br>   5.1 Working with a Property Page <br>   5.2 Navigating through Associated Objects <br>   5.3 Marking Your Page as Dirty <br>   <br>6.0  String Manipulation <br>   6.1 Types of Strings <br>   6.2 Working with Strings <br> <br>7.0  Localization <br>   7.1  Setting up for Localization <br> <br>8.0 Miscellaneous <br>   8.1 Recommended Reading <br>   8.2 Host-Specific Notes <br>      8.2.1 Microsoft Access 95 <br> <br>1.0 Introduction <br>=--------------= <br> <br>The ActiveX Controls Framework is a sample code base from which one can author new  <br>ActiveX controls for use in existing containers, such as Microsoft Visual Basic,  <br>Microsoft Access, and Microsoft Visual FoxPro, or in future containers of ActiveX Controls. <br> <br>It differs from the Microsoft Visual C++ CDK in many ways.  Most notably, this  <br>framework is intended to be considerably more "bare bones."  Only minimal  <br>functionality is provided to the programmer.  Little in the way of default handlers  <br>for various windows messages, OLE events, et. al. has been provided.  The ability  <br>to add them is there, but the code is not.  The code base has also been designed  <br>primarily for performance and reduced code size as much as possible.  Whenever a  <br>choice between ease of use and performance arose, the latter was typically chosen. <br> <br>In addition, the code is designed to take advantage of whatever OC '96 features are  <br>available from the host.  The code will use any available features, and fall back  <br>to the 'older' behavior for those cases where they aren't. <br> <br>The code base is extremely extensible, however, and of course, all the source code  <br>is there -- if something doesn't do what you want it to, make it. <br> <br> <br> <br>  1.1 Target Audience <br> <br>This framework targets a slightly more advanced programmer than the Microsoft  <br>Visual C++ Control Developers Kit.  Specifically, the programmer will be required  <br>to understand some of the fundamentals of OLE automation and dual interfaces.  The  <br>user will have to be able to understand and modify an .ODL file on their own.   <br>In addition, the user will be required to understand and be able to work with  <br>OLE persistence interfaces, most notably IStream IPersistPropertyBag and  <br>IPersistStream.  However, if it is not desired, the user will not be required  <br>to have much knowledge of OLE embedding interfaces. <br> <br>Programmers who do not have specific performance requirements, those not familiar  <br>with many of the pertinent OLE technologies, or those who work primarily with the  <br>Microsoft Foundation Classes will find the MFC/CDK far more suited to their needs. <br> <br> <br> <br>   1.2 Structure of the Framework <br> <br>The directory structure of the ActiveX Controls Framework is as follows: <br> <br> <br> BaseCtl + <br> |- \FrameWrk <br> | <br> |- \IELnk <br> | <br> |- \IEMIME <br> | <br> |- \Include <br> | <br> |- \Lib <br> | <br> |- \ToDoSvr <br> | <br> +- \WebImage <br> <br> <br>The BaseCtl\Framewrk and BaseCtl\Include directories contain the core code for  <br>writing an ActiveX control.  The BaseCtl\Include directory contains the headers  <br>that most controls will get their information from, and the BaseCtl\Framewrk  <br>directory contains the core functionality (in the COleControl class) which compiles  <br>into a static library (.LIB) form. <br> <br>A few samples are provided with the framework.   <br> <br>   1.3  Target Environment <br> <br>This framework was developed assuming you have the Microsoft Visual C++ 4.0 (or later)  <br>toolset in your path and the Microsft Windows Platform SDK installed. Running 'nmake'  <br>in BaseCtl or BaseCtl\FrameWrk will build debug a version of the static library.   <br>'nmake nodebug=1' will build a retail (nodebug) static library. <br> <br>All of the makefiles and build processes are command-line based.  Various people have  <br>reported, however, that it's largely trivial to integrate that into their favorite  <br>environments. <br> <br>NOTE: Under Windows 95, Visual C++ will not, by default, register its environment  <br>variables to set up for command line builds. Occasionally on some Windows 95 machines  <br>you may get a bunch of "Out of Environment Space" messages when doing this.  In the  <br>properties dialog for the Command Prompt, you can increase the size of the environment  <br>from "Auto" to some number like 1024, and this takes care of the problem.  None of this  <br>should happen when developing under Microsoft Windows NT. <br> <br> <br> <br>The file dwinvers.h in &lt;sdkdir&gt;\samples\com\activexcontrol\BaseCtl\Framewrk is a  <br>file that contains version and copyright information that should be updated by you  <br>each time you run your builds.  The framework does not do this work for you. <br> <br> <br>2.0 Creating an ActiveX Control <br>=-------------------------= <br> <br>Creating an ActiveX control using this framework proves moderately straightforward.   <br>We will go into the process in brief here.  Templating off the sample code should be  <br>able to fill in the holes. <br> <br>The framework implements the core functionality in a few C++ classes, notably  <br>CAutomationObject, COleControl (which inherits from CAutomationObject), and  <br>CPropertyPage.  All objects inherit from CUnknownObject, which provides the  <br>support for aggregation. <br> <br>So, to write an ActiveX Control, you need to declare a new object which inherits  <br>from COleControl.  In addition, you'll need to inherit from some sort of Automation  <br>interface that describes the properties and methods for your control, say, IMyControl.   <br>This interface description is generated by MKTYPLIB and will be put in some output  <br>file created by MKTYPLIB.  COleControl has a number of virtual methods that are  <br>declared as pure, which you simply must implement in your control class.  These  <br>include WindowProc, LoadBinaryState, LoadTextState, SaveBinaryState, SaveTextState,  <br>OnDraw, and RegisterClassData. <br> <br>To write a property page, you declare a new object which inherits from CPropertyPage.   <br>This object must implement a DialogProc.  You can also implement automation objects  <br>and collections by declaring a new object that inherits from CAutomationObject. <br> <br>Since an ActiveX control is an In-Process OLE Server, you also need one file to  <br>describe all your objects, whether they be controls, automation objects, or property  <br>pages.  This file will have a bunch of information in it, including a table of all  <br>objects and information about them.  In addition, it'll have information on what  <br>sort of localization your server would like to use, and what sort of licensing  <br>support you'd like to have. <br> <br>Finally, you'll need a resource file, an .ODL file to describe your interfaces and  <br>event interfaces, a .DEF file for your linking information, and a file to define  <br>all the guids that have been declared. <br> <br> You can template all this information from one of the sample controls.  <br> <br>   2.1  Building the Control <br> <br>To build your control, you first need to generate the libraries for the Framework files.   <br>The libraries are not automatically generated; this allows you to modify the libraries  <br>if desired.  Doing this is as simple as going to the \Framewrk directory and typing  <br>'nmake' (for debug) or 'nmake nodebug=1' (for retail). You will only need to recompile  <br>the framework files if you make a change to a file in the BaseCtrl\Framewrk directories. <br> <br>Once the framework files have been built, go back to your control's subdirectory,  <br>and type "nmake" or "nmake nodebug=1" there.  This will build your control. <br> <br> <br>   2.2  Working with the In-Process Server <br> <br>Your ActiveX control, any property pages, and automation objects are all just OLE COM <br>objects in an in-process server.  All of these objects must be declared in a global table,  <br>g_ObjectInfo, which is found in the main in-proc server file.  Each object is declared  <br>with a wrapper, one of CONTROLOBJECT, PROPERTYPAGE, or AUTOMATIONOBJECT.  The name of  <br>the object is entered as an argument to the macro.  In the header file where you declare  <br>the COM object, you'll need to use one of DEFINE_PROPERTYPAGEOBJECT, DEF <br>INE_CONTROLOBJECT, DEFINE_WINDOWLESSCONTROL, or DEFINE_AUTOMATIONOBJECT to actually  <br>declare the object for use in the global table.  If it turns out that you are declaring  <br>objects that aren't createable from a class factory, they still do need to be declared  <br>in the global table, but the Creation function specified in the structure should be left  <br>as NULL. <br> <br>There is some additional information that must be put in the file for the in-process server.   <br>The LIBID of the type library (.TLB) must be put in the global variable g_pLibid.  You  <br>must indicate what sort of localization your control supports by using the variables  <br>g_fSatelliteLocalization and g_lcidLocale.   See Section 7.0, "Localization," for more information. <br> <br>In your in-proc server file, there are a few routines that you can put code in. The first  <br>two, InitializeLibrary() and UninitializeLibrary(), are called when the DLL is first loaded  <br>into and unloaded from memory.  This is a good place to do any sort of initialization that  <br>can't be put off until later.  It is worth noting that for performance reasons, delaying  <br>as much as possible is often a good idea.  The CheckForLicense function lets the control  <br>decide if it is licensed or not to run.  GetLicenseKey() is called by the class factory.   <br>You should return your license key here if you support licensing, or just return "" otherwise. <br> <br>The RegisterData and UnregisterData routines are called from DllRegisterServer and  <br>DllUnregisterServer, and can be used to register and clean up additional information in  <br>the registry. <br> <br>Finally, two small pieces of code are included in this file so that your project does  <br>not have to link with any of the C-runtimes.  This typically results in smaller DLL size, and can help with performance.  If you want to link with the C runtime libraries, or the CRTDLL libraries, then you should remove these last things from the in-proc server file. <br> <br> <br>3.0  Working with Your ActiveX Control <br>=--------------------------------= <br> <br>Once you have your control up and running, you'll want to start extending its functionality.  The first thing to note is that your control is, in many ways, much like a regular Windows program.  Even if your control doesn't have a window [ie, it's taking advantage of the windowless features of the OC '96 specification], you have a window proc, and you have to paint the client area yourself using regular windows drawing APIs and handles to Device Contexts (DC's). <br> <br>To declare your control, you'll use one of DEFINE_CONTROLOBJECT and DEFINE_WINDOWLESSCOTNROL in your control's header file.  These structures are mostlystraightforward and self-documenting, but there are two parameters worth a little extra dicussion. <br> <br>The first is the dwActivationPolicy parameter.  The framework allows your control to take advantage of the delayed activation features provided by IPointerInactive.  If your control wishes to use any of these, then you should insert an activation policy in to this field.  By default, it is 0.  Subclassed windows controls should not change this.  Other control authors may wish to take advantage of this interface, and should consult the OC '96 specification for more information. <br> <br>The second non-trivial parameter is a boolean passed in to the DEFINE_WINDOWLESSCONTROL macro which indicates whether your control will have any transparent regions or not.  If it is true, the host will have to do a little extra work to ensure that your control paints correctly in the z-order of things.  If it is false, your control is required to paint it's entire client area, but the host has to do a little less work. <br> <br> <br>   3.1 Structure of a Control <br> <br>There is a core set of methods that every control in this framework must implement, based on creation semantics and methods that COleControl simply does not provide for you.  There are also a bunch of routines that are interesting to override and provide an implementation for.  The following is a discussion of many of these. <br> <br>   a. static Create() function. Every control must create their control object in this routine, and then return a pointer to its private unknown (for aggregation support). <br> <br>   b. Constructor and Destructor.  These are also generated for you, and a control should initialize anything here.  Controls should try to minimize the amount of work that is done here in order to help prevent load time from degrading unacceptably. <br> <br>   c. RegisterClassData().  All controls must implement this routine.  Even if your control will be windowless for the most part, it is entirely possible that a user will place your control in a host that doesn't support all of the OC '96 features, and the framework will be forced to create an HWND for you control.  In this case, you will need a window class.  This routine will only be called once the first time a control of the given type is loaded in a process in a situation in which it must have an HWND <br>.  Controls should register their window class (using RegisterClass and the WNDCLASS structure) here.  In addition, subclassed windows controls should get a pointer to the parent control's WindowProc and set that up in the g_ObjectInfo table using the SUBCLASSWNDPROCOFCONTROL() macro.  See the Button and Circle control samples for examples of how this is done.  Invisible at Runtime controls should just return FALSE in this routine, as it should never get called. <br> <br>   d. BeforeCreateWindow() and AfterCreateWindow() are not mandatory to implement, but are extremely interesting routines.  BeforeCreateWindow() is called right before the call to CreateWindow() if your control is windowed, but after persistent state has been loaded.  Controls should use this opportunity to set the window title for their control in m_szWindowTitle, and can also set up bits in pdwWindowStyle and pdwWindowStyleEx parameters that are passed in.  In addition, controls can set their initial cap <br>tion here in the parameter passed in for this purpose.  This does, however, have a limit as defined in CreateInPlaceWindow in ctlmisc.cpp.  Control writers should use this opportunity to set up these defaults as much as possible as opposed to in the message handler for WM_CREATE, as it typically results in much better performance. <br> <br>   e. InternalQueryInterface().  Your control implements this to support the QI for the control's primary automation interface, such as IMyControl.  You can also use this method to support additional interfaces in your control.  For example, if you want to support IPerPropertyBrowsing, you'd have your control's CMyControl class inherit from IPerPropertyBrowsing, and support the QueryInterface for IID_IPerPropertyBrowsing in InternalQueryInterface.  If the control fails the QI, then the control should deleg <br>ate back to COleControl::InternalQueryInterface to see if it likes the IID. <br> <br>   f. LoadTextState, LoadBinaryState, SaveTextState, SaveBinaryState.  All controls must implement these persistence routines.  See Section 4.0, "Persistence," for a discussion of these interfaces. <br> <br>   g. OnDraw.  This routine is called when your control is expected to draw itself.  In Design mode, this call will originate from a container calling IViewObject2::Draw.  In run mode, the controls framework will intercept the WM_PAINT message, and will translate it into a call to your OnDraw routine.  See Section 3.2, "Painting a Control," for more information on this routine. <br> <br>   h. WindowProc.  Messages that are not handled in the framework code (such as SimpleFrame messages and WM_PAINT), are sent to your control here.  Your control should deal with these here.  See Section 3.3, "Handling Messages in a Control," for a discussion of this routine.  In addition, please see the note below on OnSpecialKey for more information. <br> <br>   i. OnSpecialKey.  Messages for various keyboard events, such as moving the Cursor keys, function keys, and other non-standard keys do not go to the WindowProc.  Instead, they are sent to the OnSpecialKey routine.  If you want your control to handle special keys and accelerators you should override and implement this routine.  The control should return TRUE if it handles a key, or FALSE if it ignores the key. <br> <br>   j. DoCustomVerb.  If you choose to have your control implement custom verbs in addition to the property page one that is provided by default (provided your control has a property page), then you should implement this routine and take appropriate action depending on what verb was sent in.  Return OLEOBJ_S_INVALIDVERB if you don't recognize the verb given. <br> <br>   k. OnSetExtent.  This is called every time your control is resized.  The m_Size SIZEL structure is your control's current size in pixels.  Controls should look in here for their size information and override OnSetExtent if they want control over how their control is sized.  Please see the Invisible sample for an example of a control that is of a fixed size. <br> <br>   l. OnQuickActivate.  This routine is called if your control is in a host that supports quick activation, and has used IQuickActivate::QuickActivate to activate your control.  Your control will be given a pointer to a QACONTAINER structure, and should examine the data in it which it finds interesting.  A non-trivial number of ambients will be passed to the control in this way, and will save later calls to GetAmbientProperty, which is not cheap.  Please see documentation for IQuickActivate [OC '96 specifi <br>cation] for more information. <br> <br> <br>In addition, the following methods/routines can be called by the ActiveX control, and often prove to be extremely useful. <br> <br>   a. DoSuperClassPaint.  Subclassed window controls can call this from their OnDraw routines to paint themselves.  For most window controls, this routine will paint them correctly in design mode and run mode.  Some Windows controls, however, will prove somewhat moody, and might require a little extra tweaking. <br> <br>   b. RecreateControlWindow.  Again, used for subclassed controls -- will go and recreate the control's hWnd.  This is useful if the control is changing a style bit that simply can't be changed with a SetWindowLong(GWL_STYLE ...) call. <br> <br>   c. DesignMode.  Returns a BOOL indicating its best guess as to whether the environment is in design mode or not.  If it can't figure it out, it will return FALSE. <br> <br>   d. GetAmbientProperty.  This routine is used to get an ambient property from the container.  Not all containers will return these (they might not support them), so be careful to check the return code. <br> <br>   e. GetAmbientFont.  Gets the current ambient font.  Don't forget to release the font once you're done with it.  Again, the container may simply not implement this.  Controls are encouraged to look for the ambient font in the QACONTAINER structure passed in to OnQuickActivate.  Not calling GetAmbientFont saves time. <br> <br>   f. ModalDialog.  Controls must call this before they show a modal dialog.  This is seen when the control is about to show its About Box dialog. <br> <br>   g. InvalidateControl.  Much like the InvalidateRect API, but this also operates in design mode.  This will force the control to be repainted if you pass in NULL for the rectangle, or will just invalidate the given area if it's not NULL. <br> <br>   h. SetControlSize.  Control's who are changing their size out of OnSetExtent should use this routine to set their size.  The control passes in a SIZEL structure in PIXELS, and should expect a call to OnSetExtent.  Be careful of some recursive situations. <br> <br>   i. PropertyChanged.  Whenever the value of a property changes, this routine should be called to notify a host.  This will cause hosts to update any property browsers (such as those seen in Microsoft Visual Basic 4.0) <br> <br>   j. RequestPropertyEdit.  Whenever the control wants to change a property that is marked as requestedit in the .ODL file, the control will need to call this first, and check the return code. <br> <br>   k. GetResourceHandle.  Controls should call this whenever they're loading a resource that could be localized.  This routine will go and get the handle to the appropriate DLL, and deals with satellite DLLs or the lack thereof.  Please see the Localize sample for how this works. <br> <br>   l. FireEvent.  The control will pass this routine an EVENTINFO structure, and an event as described in the EVENTINFO will be fired.  The control will also pass parameters to this routine, as it is a varargs method. <br> <br>   m. ControlFromUnknown.  Property page code often finds it useful to get the COleControl * pointer from the IUnknown for a control object.  This routine does just that. <br> <br>   n. Exception.  Your control, or any automation objects, can use this to send the user an error message.  Please see Section 3.8, "Throwing an Exception," for more information on using this routine. <br> <br> <br>Windowless that wish to support windowless in-place activation have a couple of routines they must call instead of regular Win32 APIs in order to get the correct functionality.  The following is a list of these and their replacements: <br> <br>   a. GetFocus --&gt; Writers should call OcxGetFocus().  This will return a boolean indicating whether or not the control has keyboard focus. <br>   b. SetFocus --&gt; Writers should call OcxSetFocus().  This routine takes a boolean parameter indicating whether or not you want to take the focus or give it up. <br>   c. GetCapture --&gt; Use OcxGetCaputre() instead.  This indicates whether or not you have the keyboard capture or not. <br>   d. SetCapture --&gt; By calling OcxSetCapture(), you can ask for or release the keyboard capture. <br>   e. GetDC/ReleaseDC.  OcxGetDC/OcxReleaseDC now provide this functionality for windowless controls. <br>   f. InvalidateRect --&gt;  OcxInvalidateRect() will let you force a repaint of your control. <br> <br>It is worth noting that these routines will all work correctly if your control does, in fact have an HWND.  If your control doesn't plan on working without an HWND, then you may safely use the regular Win32 APIs. <br> <br> <br> <br>   3.2  Painting a Control <br> <br>The OnDraw routine is called whenever the control needs to paint.  Sometimes the origin of the call is from IViewObject2::Draw (as in design mode), and other times it comes from being sent a WM_PAINT message (as handled in ControlWindowProc). <br> <br>Your control is given a DC, a rectangle to describe where to paint, a rectangle for describing a metafile, and an Information Context (IC, passed in as an HDC) that describes the device.  If the device is a metafile, then the control must do a little different work.  However, if the device is a raster display, the control is typically painting to the screen. <br> <br>Your control must be careful not to make any assumptions about the DC, except that it will be in MM_TEXT mapping mode.  Often, there will be no default pens, brushes, fonts or colors selected into the DC.  Your control will have to do this work itself.  This will typically manifest itself by having your control look slightly different in design and run modes. <br> <br>If the fOptimize parameter passed in is TRUE, then the control writer may take advantage of the optimizations described in the OC '96 specification for not fully cleaning up the DC on exit.  [Writers are still responsible for deleting GDI objects they create/load, but they may leave things selected in the DC on exit if this parameter is TRUE.  Please see the OC '96 specification for more information.] <br> <br>Finally, the dvAspect parameter is passed in to the OnDraw routine.  This is used for multi-pass drawing, as described in the OC '96 specification [IViewObjectEx].  Authors not wishing to support multi-pass drawing should just ignore this parameter, as their control defaults to not supporting it. <br> <br>   3.3  Handling Messages in a Control <br> <br>Your control has a method called WindowProc, which is called whenever a message is sent to your control.  Your control should respond to messages in the desired fashion here.  If your control has an HWND, try to reduce the amount of work that is done in the WM_CREATE message handler, and see if it can't be put in BeforeCreateWindow(). <br> <br>For certain types of messages, such as keyboard messages for arrow keys, and other special keys, your WindowProc routine will not get called.  Instead, you'll find OnSpecialKey called instead.  The code in OnSpecialKey should look for WM_KEYDOWN/UP, WM_CHAR, and other messages and deal with them as appropriate. <br> <br>There is a certain class of messages that typically involve notifying a window about happenings that are usually sent to a window's parent.  These include WM_COMMAND, WM_NOTIFY, WM_CTLCOLOR, etc.  These messages will be reflected by the host to your control in the form of OCM_COMMAND, OCM_NOTIFY, OCM_CTLCOLOR, etc.  Your controls should look for these messages instead of WM_COMMAND, etc.  Please see olectl.h for other OCM_ messages that the control might be interested in.  This, of course, does not apply t <br>o windowless controls. <br> <br> <br> <br>   3.4  Adding a Property <br> <br>One of the more important parts of a control is often the set of properties.   To add properties is a relatively straightforward and simple process. <br> <br>First, you need to modify the primary dispatch interface for your control in the .ODL file.  For example, let's say you have a control called SuperScroll, and you'd like to add a LargeChange method to the control.  You'd add the following to the ISuperScroll interface description in the .ODL: <br> <br>[id(DISPID_LARGECHANGE), propget, helpstring("The largechange property")] <br>HRESULT LargeChange([out, retval] long *plLargeChange); <br>[id(DISPID_LARGECHANGE), propput] <br>HRESULT LargeChange([in] long lLargeChange); <br> <br>DISPID_LARGECHANGE is something that you define in dispids.h.  You then regenerate the type library (.TLB) file by typing: <br> <br>nmake <br> <br>More importantly, this regenerates SuperScrollInterfaces.H.  You can then cut and paste the following two lines from SuperScrollInterfaces.H: <br> <br> <br>STDMETHOD(get_LargeChange)(THIS_ long FAR* plLargeChange) PURE; <br>STDMETHOD(put_LargeChange)(THIS_ long lLargeChange) PURE; <br> <br>Take these two lines and add them to your class description for CSuperScroll, and make sure that you remove the PURE declarators at the end; i.e.: <br> <br>STDMETHOD(get_LargeChange)(long FAR* plLargeChange); <br>STDMETHOD(put_LargeChange)(long lLargeChange); <br> <br> <br>You can now implement these methods in your control file to implement your property. <br> <br>Please note that there are a few standard dispids defined for you in olectl.h.  Whenever you want to declare a property, take a look in this header first to see if there is a standard dispid for it. <br> <br> <br> <br>   3.5  Adding a Method <br> <br>Adding a method is much like adding a property to your control.  First thing you need to do is define a dispid for the method.  Once you've got that, it's as simple as adding the method to the primary interface for your control.  Lets say we'd like to define a method called MooCow, with three parameters, the last of which is optional.  Here is one such method: <br> <br>[id(DISPID_MOOCOW), helpstring("Makes your Cow moo")] <br>HRESULT MooCow([in] long lSeconds, [in] boolean fLowPitch, <br>[in, optional] VARIANT vPitch); <br> <br> <br>Again, as with properties, you regenerate the type library, and then paste the declaration into your control header (without the PURE declarator) and implement it. <br> <br> <br> <br>   3.6  Adding an Event <br> <br>In many situations, a control will want to fire an event.  For example, when a control gets a WM_?BUTTONDOWN message, it often makes sense to fire a MouseDown event.  This turns out to be easy. <br> <br>The first thing that has to be done is the event has to be defined in an EVENTINFO structure.  There are many ways to do this, including declaring a new global variable for each event type, or using an array.  We will talk about the latter, since it's a little neater.  Let's say you want to have KeyDown, KeyUp, and KeyPushed events. <br> <br>Here's how you might declare them: <br> <br>typedef enum { <br>MyCtlEvent_KeyDown = 0, <br>MyCtlEvent_KeyUp = 1, <br>MyCtlEvent_KeyPushed = 2 <br>} MYCTLEVENTS; <br> <br>VARTYPE rgI2 [] = { VT_I2 }; <br> <br>EVENTINFO m_rgMyCtlEvents [] = { <br>{ DISPID_KEYDOWN, 1, rgI2 }, <br>{ DISPID_KEYUP, 1, rgI2 }, <br>{ DISPID_KEYPUSHED, 1, rgI2 } <br>}; <br> <br>The EVENTINFO structure has three members;  the dispid of the event, the count of arguments in the event, and a pointer to an array of VARTYPEs that describe the types of the parameters to the event.  Please note, again, that there are a bunch of dispids defined for you in olectl.h.  Whenever you're adding an event, go check there first to see if there's already a dispid for it. <br> <br> <br>To fire these events from code, just call the following: <br> <br>FireEvent(&amp;(m_rgMyCtlEvents[MyCtlEvent_KeyDown]), sKeyValue); <br> <br> <br> <br>   3.7  Using Standard ActiveX Types <br> <br>For many controls, you will find it useful to declare properties of types provided by OLE, such as Font, Picture, and Color.  Many hosts will detect properties of these types and put up convenient browsers for the user to select values for these types. <br> <br>To declare a property of one of these types, you must first make sure their .ODL includes the following at the top: </code></pre>
<p>
</p>
<pre><code><br>importlib(STDTYPE_TLB); <br> <br>Then, to declare a property of type Font, Picture, or Color, you would do something similar to the following, depending on the type: <br> <br>[id(DISPID_FONT), propget] <br>HRESULT Font([out, retval] IFontDisp **ppFont); <br>[id(DISPID_FONT), propputref] <br>HRESULT Font([in] IFontDisp *pFont); <br> <br>[id(DISPID_MOUSEICON), propget] <br>HRESULT MouseIcon([out, retval] IPictureDisp **ppMouseIcon); <br>[id(DISPID_MOUSEICON), propputref] <br>HRESULT MouseIcon([in] IPictureDisp *pMouseIcon); <br> <br>[id(DISPID_FORECOLOR), propget] <br>HRESULT ForeColor([out, retval] OLE_COLOR *pocForeColor); <br>[id(DISPID_FORECOLOR), propput] <br>HRESULT ForeColor([in] OLE_COLOR ocForeColor); <br> <br> <br>For the get_ and put_ methods for these types, the control will get a property as declared above.  For fonts and pictures, the control will probably want to QI these for IFont and IPicture respectively.  See the FontColor control sample for an idea of how this is done. <br> <br>MSDN contains some very good descriptions of how to use these fonts in your application, but the following is a short run-down. <br> <br>To use a font object in your control, the control will typically call the get_hFont method, and pass the resulting HFONT to the control's DC.  Pictures will be much the same. <br> <br>To use a color, the control will want to call OleTranslateColor to convert it to a real COLORREF.  OLE_COLORs are basically COLORREFs with some support for "generic" colors, such as COLOR_WINDOW, COLOR_WINDOWTEXT, etc.  To convert one of these into an OLE_COLOR, just OR (|) them with 0x80000000.  For example, to initialize the control's background to COLOR_WINDOW, set the backcolor property to COLOR_WINDOW | 0x80000000.  Then, to paint the backdrop, just call OleTranslateColor(), and use the resulting colo <br>rref. <br> <br>NOTE:  The Framework uses dual/vtable bound automation interfaces, and uses OLE Automation functionality to support IDispatch methods on the automation objects. There is a known problem in OLE automation, which will cause problems (unexpected failures and/or crashes) when using the provided ITypeInfo::Invoke on properties that are declared to be of types that are imported from a type library (i.e., any font, picture, or color property has this problem.) <br> <br>The way to get around this problem is to override Invoke(), and to look for the dispids of the control's properties that are of this type.  In this case, the control can quickly dispatch the call to the appropriate member function.  The FontColor sample does just this.  See its implementation of IDispatch::Invoke for sample code on how to work around it.  This problem will not exist in a future version of OLE Automation, but until then, the workaround is necessary -- but fortunately not terribly expensive. <br> <br> <br> <br>   3.8 Throwing an Exception <br> <br>Every once in a while, during an operation, your control will find itself rather upset with the state of the union, and will wish to communicate this to the user. <br> <br>The way to do this is via an exception.  In any of the control's OLE Automation methods or property operators, the control can call the Exception method when exiting, and the method will set up all the appropriate information to trigger the error. <br> <br>For example: <br> <br>CMyControl::put_ButtZilla(long lButtZilla) <br>{ <br>if (lButtZilla == 10) <br>return Exception(MYCTL_E_IHATETHENUMBER10, IDS_ERR_IHATETHENUMBER10, 0); <br>m_lButtZilla = lButtZilla; <br>return S_OK; <br>} <br> <br>The arguments to the Exception routine are as the follows:  the first is the scode of the error the control wishes to trigger.  For errors unique to the control, you should define them something like: <br> <br>#define MYCTL_E_IHATETHENUMBER10 MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, 34500) <br> <br>The second argument is the resource id of the string that the control should display.  The Exception code will correctly get this information from the control's localized satellite DLL. <br> <br>Finally, the last argument is the helpcontextid that will be passed to the helpfile that is defined in your control's structure. <br> <br> <br> <br>4.0 Persistence <br>=-------------= <br> <br>One of the most important things your control will do is save out and restore its persistent state.  This will typically be done in one of two ways: through PropertyBags for text persistence, and through Streams for binary persistence.  In the latter, performance is absolutely critical to make your control load quickly. <br> <br>The ActiveX Controls Framework requires that your control implement four member functions to support persistence.  The control is required to implement LoadTextState, LoadBinaryState, SaveTextState, and SaveBinaryState.  If you are positive that the control is never going to be in a host that uses IPersistPropertyBag, then you can ignore the two text interfaces, but this isn't recommended (they prove sufficiently straightforward to use). <br> <br> <br> <br>   4.1  Text Persistence <br> <br>Text persistence in the Framework is done via IPersistPropertyBag and IPropertyBag.  All ActiveX controls have an implementation of IPersistProperty Bag, and are given pointers to PropertyBag objects to do their work. <br> <br>MSDN and Kraig Brockschmidt's book, "Inside OLE 2 (2nd edition)," both have descriptions of the IPropertyBag interface.  Effectively, there are two routines that the programmer will use:  Read and Write.  In both cases, the programmer will pass in a VARIANT.  In the Read case, the property, if it was saved out, will be put in the VARIANT.  If the property couldn't be found (it wasn't ever saved out), then the default value for that property should be used, and an error should probably not be returned.  For the Write, a VARIANT with the data is passed in.  To persist out a collection or an object (such as a Font or Picture object), the programmer can pass in a VT_UNKNOWN object, and the PropertyBag will then QI that object for IPersistPropertyBag or IPersistStream and persist it.  This actually proves effective for persisting collections -- they can just support IPersistPropertyBag. <br> <br>All of the samples except the Localize and Circle sample have examples of how to persist out properties using PropertyBags.  For controls with many properties, it often makes sense to head to some sort of table-driven persistence to reduce code size and bug potential. <br> <br> <br> <br>   4.2  Binary Persistence <br> <br>Binary persistence turns out to be the more critical thing to work on when implementing an ActiveX control.  Control load speed can be severely hampered by a poorly written LoadBinaryState routine, so it's rather critical to spend some time thinking about how to keep this routine fast. The binary persistence code is used by many hosts all the time, and by other hosts when including the control in a generated executable file. <br> <br>In both routines, the control is handed a pointer to an IStream object.  The key to load speed here is to reduce the number of operations on the stream.  For save, this is slightly less critical. <br> <br>Typically, a control will want to save out the following information (often in the given order): <br> <br>   - Some sort of header with a magic number, version, and size information <br>   - Fixed size state information, such as longs, floats, colors, strings, etc. <br>   - Variable sized persistent state, such as fonts, pictures, collections, etc. <br> <br>Most control writers will want to start out the control's binary persistent state with some sort of header structure that includes a "magic" number that the control can check for sanity when the control is loading.  You'll also want to include some sort of version number so that future versions of your control can deal with older versions, and finally, you will often want the control to write out the number of bytes of data that were written. <br> <br>The samples in the framework that have a binary persistent state use the following structure: <br> <br>#define STREAMHDR_MAGIC    0x12345678 <br> <br>typedef struct { <br>DWORD dwMagic; <br>DWORD dwVersion; <br>DWORD cbSize; <br>} STREAMHDR; <br> <br>The SaveBinaryState routine saves out this information, and the LoadBinaryState routine looks for it. <br> <br>One way to write out all the fixed-size information (and therefore load it efficiently) is to do it all in one chunk -- if all the control's fixed persistent state is in a structure in the control object, then you can just write out the structure in the persistence code.   The sample controls show the properties grouped together in a m_state structure in the control declaration. <br> <br>hr = pStream-&gt;Write(&amp;m_state, sizeof(m_state), NULL); <br> <br>For loading, it becomes as simple as: <br> <br>hr = pStream-&gt;Read(&amp;(m_state), sizeof(m_state), NULL); <br> <br>Extremely efficient and simple. <br> <br>For fonts and pictures, it's slightly more complicated.  Effectively, the control has to QI those objects for IPersistStream, and then call the Load or Save routine with the stream that the control has been given.  Typically, this can be done after the control has written out all other information.  The FontColor control sample does just this. <br> <br>If you follow the above suggestions for persistent state structure, you can typically have the control's load routine look something like as follows: <br> <br> <br>IPersistStream *pps; <br>STREAMHDR sh; <br>HRESULT   hr; <br> <br>// first read in the streamhdr, and make sure we like what we're getting <br> <br>hr = pStream-&gt;Read(&amp;sh, sizeof(sh), NULL); <br>RETURN_ON_FAILURE(hr); <br> <br>// sanity check <br> <br>if (sh.dwMagic != STREAMHDR_MAGIC || sh.cbSize != sizeof(m_state)) <br>return E_UNEXPECTED; <br> <br>// read in the control state information <br> <br>hr = pStream-&gt;Read(&amp;(m_state), sizeof(m_state), NULL); <br>RETURN_ON_FAILURE(hr); <br> <br> <br>// now read in the font! <br> <br>OleCreateFontIndirect(&amp;_fdDefault, IID_IFont, (void **)&amp;m_pFont); <br>RETURN_ON_NULLALLOC(m_pFont); <br> <br>// qi it for ipersiststream and load it in. <br> <br>hr = m_pFont-&gt;QueryInterface(IID_IPersistStream, (void **)&amp;pps); <br>RETURN_ON_FAILURE(hr); <br> <br>hr = pps-&gt;Load(pStream); <br>pps-&gt;Release(); <br> <br>return hr; <br> <br> <br>This proves to be acceptably fast and robust. <br> <br> <br>5.0 Property Pages <br>=----------------= <br> <br>Most ActiveX Controls will find property pages an invaluable addition to their design time functionality.  Fortunately, implementing them proves to be relatively straightforward.  To do so, you merely need to declare an object that inherits from CPropertyPage. <br> <br> <br> <br>   5.1 Working with a Property Page <br> <br>The control's property page is declared in the header file using the DEFINE_PROPERTYPAGE macro, which puts it into the g_ObjectInfo table.  The framework supports the creation of the property page object, but you are required to implement the static Create() function. <br> <br>The property page is created much like a regular windows dialog box would be -- you use your favorite resource editor to create a DIALOG resource, and then just cut and paste it into your control's resource (.RC) file. <br> <br>The most important method you'll have to implement will be the DialogProc method, which is where all the work will take place.  In addition to the regular windows messages that one would expect in a DialogProc, there are a few additional ones which people working with this framework will expect: <br> <br>   a. PPM_NEWOBJECTS -- your control has been given some new objects.  The control is expected to go and populate its page's controls with information from this object.  Using the FirstControl() and NextControl() methods from the CPropertyPage class, the control can get the relevant information. <br> <br>   b. PPM_APPLY -- the control has to apply any changes that have occurred now.  Again, you can use the FirstControl() and NextControl() routines to loop through all the objects for which the property pages were visible and apply the values (note that it's possible for there to be more than one object for which a property page is being displayed). <br> <br>   c. PPM_EDITPROPERTY -- when the control is sent this message, the control is expected to set the focus to the control instance which represents the property of the given dispid.  You will typically only see this message called if you implement IPerPropertyBrowsing and return a value in MapPropertyToPage. <br> <br>   d. PPM_FREEOBJECTS -- Various people will find it interesting to stash, in some way, the pointers they receive in PPM_NEWOBJECTS.  This message tells them that it is time to free them, as the objects are no longer valid.  This can be called from the property page's destructor, so people should be careful not to make too many assumptions about the property page. <br> <br>Please see one of the sample controls for exact details on these messages. <br> <br> <br> <br>   5.2 Navigating through Associated Objects <br> <br>Your property pages will operate on one or more controls.  When initializing, you will typically get some values from the first control that you are given.  You can use the FirstControl() method to get the object pointer for this control.  You can then QI it for your primary dispatch interface to get properties to populate the page with. <br> <br>When told to apply the values (PPM_APPLY), you'll want to apply them to all objects, which means you'll want to loop using FirstControl() and NextControl(), as follows: <br> <br>for (pUnk = FirstControl(&amp;dwCookie) ; pUnk; pUnk = NextControl(&amp;dwCookie)) { <br>hr = pUnk-&gt;QueryInterface(IID_IButton, (void **)&amp;pButton); <br>if (FAILED(hr)) continue; <br> <br>GetDlgItemText(hwnd, IDC_CAPTION, szTmp, 128); <br>bstr = BSTRFROMANSI(szTmp); <br>ASSERT(bstr, "Maggots!"); <br>pButton-&gt;put_Caption(bstr); <br>SysFreeString(bstr); <br>pButton-&gt;Release(); <br>} <br> <br>Please note that the return values of FirstControl() and NextControl() don't need to be Release()'d. <br> <br> <br> <br>   5.3 Marking Your Page as Dirty. <br> <br>It is moderately important to correctly mark the control's property page as dirty at the appropriate times.  This must be done manually.  Typically, the control will do this in response to a windows notification message, such as EN_CHANGE or BN_CLICKED.  When the control wishes to mark its page as dirty, the MakeDirty() routine should be called.  This will cause the Apply button to be enabled, if it was previously disabled, and will tell the host that the state should be saved before destroying the page. <br> <br>The following code causes the page to mark itself as dirty when the user changes the text in a Text box in the property page: <br> <br>case WM_COMMAND: <br>switch (LOWORD(wParam)) { <br>case IDC_CAPTION: <br>if (HIWORD(wParam) == EN_CHANGE) <br>MakeDirty(); <br>break; <br>} <br>break; <br> <br> <br> <br>6.0  String Manipulation <br>=----------------------= <br> <br>The ActiveX Controls Framework provides a robust system of macros for manipulating strings in pretty much all of the ways that you'll run into while working with an ActiveX control. <br> <br> <br> <br>   6.1 Types of Strings <br> <br>Under Win32, there are a few different types of strings, and understanding these tends to be pretty important when working with OLE, since there is great potential for memory leaks and bugs associated with strings. <br> <br>There are two fundamental types of strings -- multi-byte (which can be ANSI or double byte) and Unicode strings.  Of the former, one almost always works with some sort of char * pointer (LPSTR, LPCSTR).  Of the latter, there are a few types that are commonly used.  Most notably, there are WCHAR * (LPWSTR, LPWCSTR), BSTR, and OLESTR strings. <br> <br>LPWSTR pointers are just that -- a pointer to a wide string.  An LPOLESTR pointer is much the same, with some additional OLE rules added to it.  An OLESTR is merely a wide string, but when it's an out-parameter to a function, it should be allocated using the host's IMalloc allocator (i.e., CoTaskMemAlloc). <br> <br>A BSTR is a string with a little more structure (specifically, a length prefix).  To work with BSTRs, you need to use special APIs designed exclusively for them, notably SysAllocString, SysFreeString, and SysStringLen (there are a few others.  See the "OLE Programmers Reference, Volume II," published by Microsoft Press, for more details). <br> <br>These data types are fully interchangeable as far as compares and copies go, but they are NOT interchangeable as far as allocation and freeing go -- it is not acceptable to call SysFreeString on an OLESTR or LPWSTR string. <br> <br>Both BSTRs and OLESTRs as in-parameters to functions should not be freed (as per standard OLE COM conventions).  By the same token, BSTRs and OLESTRs as out params should be expected to be freed, and should thus be allocated appropriately. <br> <br> <br> <br>   6.2 Working with Strings <br> <br>Now, the problem is that, for the most part, your controls will be working with multi-byte strings, except for where you work with OLE.  Therefore, there will be various scenarios where you'll either be given a wide string, and need the multi-byte version of it, or you'll have a multi-byte string, and need a wide string for it. <br> <br>To solve these problems, the ActiveX Controls Framework includes the following macros to work with: <br> <br>MAKE_WIDEPTR_FROMANSI(newstringname, convertme) <br>MAKE_ANSIPTR_FROMWIDE(newstringname, convertme) <br> <br>BSTRFROMANSI(ansistr) <br>OLESTRFROMANSI(ansistr) <br>BSTRFROMRESID(resourceid) <br>OLESTRFROMRESID(resourceid) <br>COPYOLESTR(copyme) <br>COPYBSTR(copyme) <br> <br>The first two macros will take a string of a given type and a name, and create a variable of the new name (do -not- declare a variable of this name yourself), and then convert the other string into the new variable.  This cannot be used as an rvalue in C/C++ expressions, nor can it be an lvalue (it pretty much needs to sit on a line by itself). <br> <br>The last set of macros pretty much do all the remaining interesting work.  You can get BSTRs or IMalloc'd OLESTRs from an ANSI string, or copy OLESTRs and BSTRs.  The only additional functions of real interest are those that take a WORD which is a resource id, and loads in a string from your localization DLL (or the main if you don't do satellite localization) and makes either a BSTR or OLESTR out of it.  This proves useful in a few places where you need a localized string. <br> <br>Remember that while these macros were designed with a certain amount of speed in mind, converting strings is still not a ridiculously cheap operation, and control writers should try to be moderately conservative in string conversions. <br> <br> <br>7.0  Localization <br>=---------------= <br> <br>The ActiveX Controls Framework also has some support for robust localization of your control; most notably, property pages and anything other resources you find interesting to localize. <br> <br>The scheme is follows:  the resources for the default language (typically English) are in the main in-proc server's resources.  Then, for each additional language supported, there is a satellite DLL which contains the resources for that language.  The name for this satellite DLL is generated by taking the "base" name for the DLL from a string resource in the main in-proc server file, and then adding on a three letter language code as generated by the function GetLocaleInfo with the LCTYPE LOCALE_SABBREVLAN <br>GNAME. <br> <br>The code will first look for the specific language that is set up in the global variable g_lcidLocale. This should be initialized by all servers.  For ActiveX controls and property pages, you'll want to get this from the host.  For OLE automation servers, you'll want to set this up some other way, often by just using the system language.  If the satellite DLL for the specific langauge is not found, the framework will look for the primary language ID with SUBLANG_DEFAULT instead.  If that satellite is not f <br>ound, a handle to the default resources will then be returned. <br> <br>Please note that fully localized type libraries are not supported, as most hosts will ignore these and just use the default one. <br> <br> <br>   7.1  Setting up for Localization <br> <br>If you want to support satellite localization in your in-proc server, then you need to set up a couple of things. <br> <br>First, you'll need to set the variable g_fSatelliteLocalization in your in-proc server file to TRUE.  This will instruct all further code paths to use satellite localization. <br> <br>You will also, at some point, need to set up the g_lcidLocale variable, as described above.  For ActiveX controls, you can use GetAmbientProperty() and ask for AMBIENT_DISPID_LOCALE.  For property pages, there is a method on the IPropertyPageSite interface that will let you obtain the locale id, and for automation objects, you will be required to set this up yourself -- typically by obtaining the system locale id. <br> <br>Whenever you want to load a resource, make sure you use GetResourceHandle() to get the instance handle for the localized resources.  This will generate the appropriate file name for the satellite DLL and attempt to load it. <br> <br>Please see the Localize sample included with the framework for an example of how this works, along with an actual localized satellite DLL (in the French subdirectory). The satellite DLL should contain all localized resources you're interested in.   <br> <br> <br> <br>8.0 Miscellaneous <br>=---------------= <br> <br> <br>   8.1  Recommended Reading <br> <br>Inside OLE2, Second Edition, Kraig Brockschmidt, Microsoft Press.  Chapters 3, 13-15 and 24 contain most of the information you'll need to work with an ActiveX control and/or automation server.  The chapters on persistence should also prove useful for those unfamiliar with them. <br> <br>OLE2 Programmers Reference, Volume I and II, Microsoft Press. <br> <br>MFC Source Code, Visual C++ 4.x.  When looking for ideas on how to do something, the CDK source code proves to be an invaluable resource.  Use it -- frequently. <br> <br> <br>   8.2 Host-Specific Notes <br> <br>Then following are notes, things to consider, or known problems with specific ActiveX Controls hosts: <br> <br>   8.2.1 Microsoft Access 95 <br> <br>Access 95 -requires- IPerPropertyBrowsing.  If you do not implement this interface, you will not able to put one of your controls on a form.  See MSDN and the MFC source code for documentation on this interface. <br> <br>In addition, you cannot return error scodes from GetPredefinedStrings. You must return either S_OK or S_FALSE.  Returning an error scode will crash. <br> <br>MapPropertyToPage should still return PERPROP_E_NOPAGEAVAILABLE if there are no pages available. <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
