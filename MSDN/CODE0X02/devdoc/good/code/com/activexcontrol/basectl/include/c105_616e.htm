<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UNKNOWN.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context116"></a>UNKNOWN.H</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// Unknown.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// a class definition for an IUnknown super-class that will support <br>// aggregation. <br>// <br>#ifndef _UNKNOWN_H_ <br> <br>//=--------------------------------------------------------------------------= <br>// UNKNOWNOBJECTINFO <br>// <br>// if you want a simple co-creatable object, with no other guarantees about <br>// it, then you need to put the following entry in the global table of objects. <br>// other object types that are more complex, such as automation objects, and <br>// controls, will also use this information... <br>// <br>typedef struct { <br> <br>    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable! <br>    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable! <br>    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable! <br> <br>} UNKNOWNOBJECTINFO; <br> <br>#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;pszObjectName) <br>#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;rclsid)) <br>#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)-&gt;pfnCreate) <br> <br>#ifndef INITOBJECTS <br> <br>#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \ <br>extern UNKNOWNOBJECTINFO name##Object \ <br> <br>#else <br>#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \ <br>    UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \ <br> <br>#endif // INITOBJECTS <br> <br> <br>//=--------------------------------------------------------------------------= <br>// DECLARE_STANDARD_UNKNOWN <br>// <br>// All objects that are going to inherit from CUnknown for their IUnknown <br>// implementation should put this in their class declaration instead of the <br>// three IUnknown methods. <br>// <br>#define DECLARE_STANDARD_UNKNOWN() \ <br>    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \ <br>        return ExternalQueryInterface(riid, ppvObjOut); \ <br>    } \ <br>    STDMETHOD_(ULONG, AddRef)(void) { \ <br>        return ExternalAddRef(); \ <br>    } \ <br>    STDMETHOD_(ULONG, Release)(void) { \ <br>        return ExternalRelease(); \ <br>    } \ <br> <br>// global variable where we store the current lock count on our DLL.  This resides <br>// in InProcServer.Cpp <br>// <br>extern LONG g_cLocks; <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// this class doesn't inherit from IUnknown since people inheriting from it <br>// are going to do so, and just delegate their IUnknown calls to the External* <br>// member functions on this object.  the internal private unknown object does <br>// need to inherit from IUnknown, since it will be used directly as an IUnknown <br>// object. <br>// <br>class CUnknownObject { <br> <br>  public: <br>    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface) <br>        : m_pvInterface(pvInterface), <br>          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &amp;m_UnkPrivate) <br>        {  InterlockedIncrement(&amp;g_cLocks); } <br> <br>    virtual ~CUnknownObject() { InterlockedDecrement(&amp;g_cLocks); } <br> <br>    // these are all protected so that classes that inherit from this can <br>    // at get at them. <br>    // <br>  protected: <br>    // IUnknown methods.  these just delegate to the controlling <br>    // unknown. <br>    // <br>    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) { <br>        return m_pUnkOuter-&gt;QueryInterface(riid, ppvObjOut); <br>    } <br>    ULONG ExternalAddRef(void) { <br>        return m_pUnkOuter-&gt;AddRef(); <br>    } <br>    ULONG ExternalRelease(void) { <br>        return m_pUnkOuter-&gt;Release(); <br>    } <br> <br>    // people should use this during creation to return their private <br>    // unknown <br>    // <br>    inline IUnknown *PrivateUnknown (void) { <br>        return &amp;m_UnkPrivate; <br>    } <br> <br>    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut); <br> <br>    IUnknown *m_pUnkOuter;            // outer controlling Unknown <br>    void     *m_pvInterface;          // the real interface we're working with. <br> <br>  private: <br>    // the inner, private unknown implementation is for the aggregator <br>    // to control the lifetime of this object, and for those cases where <br>    // this object isn't aggregated. <br>    // <br>    class CPrivateUnknownObject : public IUnknown { <br>      public: <br>        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut); <br>        STDMETHOD_(ULONG, AddRef)(void); <br>        STDMETHOD_(ULONG, Release)(void); <br> <br>        // constructor is remarkably trivial <br>        // <br>        CPrivateUnknownObject() : m_cRef(1) {} <br> <br>      private: <br>        CUnknownObject *m_pMainUnknown(); <br>        ULONG m_cRef; <br>    } m_UnkPrivate; <br> <br>    // so they can reference themselves in CUnknownObject from pMainUnknown() <br>    // <br>    friend class CPrivateUnknownObject; <br> <br>    // by overriding this, people inheriting from this unknown can implement <br>    // additional interfaces.  declared as private here so they have to use their <br>    // own version. <br>    // <br>}; <br> <br> <br> <br> <br>#define _UNKNOWN_H_ <br>#endif // _UNKNOWN_H_ <br> <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
