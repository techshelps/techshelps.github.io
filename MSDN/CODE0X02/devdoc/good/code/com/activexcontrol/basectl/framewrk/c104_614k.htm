<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>UTIL.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context104"></a>UTIL.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// Util.C <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// contains routines that we will find useful. <br>// <br>#include "IPServer.H" <br> <br>#include "Globals.H" <br>#include "Util.H" <br> <br>void * _cdecl operator new(size_t size); <br>void  _cdecl operator delete(void *ptr); <br> <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br> <br>//=---------------------------------------------------------------------------= <br>// overloaded new <br>//=---------------------------------------------------------------------------= <br>// for the retail case, we'll just use the win32 Local* heap management <br>// routines for speed and size <br>// <br>// Parameters: <br>//    size_t         - [in] what size do we alloc <br>// <br>// Output: <br>//    VOID *         - new memoery. <br>// <br>// Notes: <br>// <br>void * _cdecl operator new <br>( <br>    size_t    size <br>) <br>{ <br>    return HeapAlloc(g_hHeap, 0, size); <br>} <br> <br>//=---------------------------------------------------------------------------= <br>// overloaded delete <br>//=---------------------------------------------------------------------------= <br>// retail case just uses win32 Local* heap mgmt functions <br>// <br>// Parameters: <br>//    void *        - [in] free me! <br>// <br>// Notes: <br>// <br>void _cdecl operator delete ( void *ptr) <br>{ <br>    HeapFree(g_hHeap, 0, ptr); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// MakeWideFromAnsi <br>//=--------------------------------------------------------------------------= <br>// given a string, make a BSTR out of it. <br>// <br>// Parameters: <br>//    LPSTR         - [in] <br>//    BYTE          - [in] <br>// <br>// Output: <br>//    LPWSTR        - needs to be cast to final desired result <br>// <br>// Notes: <br>// <br>LPWSTR MakeWideStrFromAnsi <br>( <br>    LPSTR psz, <br>    BYTE  bType <br>) <br>{ <br>    LPWSTR pwsz; <br>    int i; <br> <br>    // arg checking. <br>    // <br>    if (!psz) <br>        return NULL; <br> <br>    // compute the length of the required BSTR <br>    // <br>    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0); <br>    if (i &lt;= 0) return NULL; <br> <br>    // allocate the widestr <br>    // <br>    switch (bType) { <br>      case STR_BSTR: <br>        // -1 since it'll add it's own space for a NULL terminator <br>        // <br>        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1); <br>        break; <br>      case STR_OLESTR: <br>        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR)); <br>        break; <br>      default: <br>        FAIL("Bogus String Type."); <br>    } <br> <br>    if (!pwsz) return NULL; <br>    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i); <br>    pwsz[i - 1] = 0; <br>    return pwsz; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// MakeWideStrFromResId <br>//=--------------------------------------------------------------------------= <br>// given a resource ID, load it, and allocate a wide string for it. <br>// <br>// Parameters: <br>//    WORD            - [in] resource id. <br>//    BYTE            - [in] type of string desired. <br>// <br>// Output: <br>//    LPWSTR          - needs to be cast to desired string type. <br>// <br>// Notes: <br>// <br>LPWSTR MakeWideStrFromResourceId <br>( <br>    WORD    wId, <br>    BYTE    bType <br>) <br>{ <br>    int i; <br> <br>    char szTmp[512]; <br> <br>    // load the string from the resources. <br>    // <br>    i = LoadString(GetResourceHandle(), wId, szTmp, 512); <br>    if (!i) return NULL; <br> <br>    return MakeWideStrFromAnsi(szTmp, bType); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// MakeWideStrFromWide <br>//=--------------------------------------------------------------------------= <br>// given a wide string, make a new wide string with it of the given type. <br>// <br>// Parameters: <br>//    LPWSTR            - [in]  current wide str. <br>//    BYTE              - [in]  desired type of string. <br>// <br>// Output: <br>//    LPWSTR <br>// <br>// Notes: <br>// <br>LPWSTR MakeWideStrFromWide <br>( <br>    LPWSTR pwsz, <br>    BYTE   bType <br>) <br>{ <br>    LPWSTR pwszTmp; <br>    int i; <br> <br>    if (!pwsz) return NULL; <br> <br>    // just copy the string, depending on what type they want. <br>    // <br>    switch (bType) { <br>      case STR_OLESTR: <br>        i = lstrlenW(pwsz); <br>        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR)); <br>        if (!pwszTmp) return NULL; <br>        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR)); <br>        break; <br> <br>      case STR_BSTR: <br>        pwszTmp = (LPWSTR)SysAllocString(pwsz); <br>        break; <br>    } <br> <br>    return pwszTmp; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// StringFromGuidA <br>//=--------------------------------------------------------------------------= <br>// returns an ANSI string from a CLSID or GUID <br>// <br>// Parameters: <br>//    REFIID               - [in]  clsid to make string out of. <br>//    LPSTR                - [in]  buffer in which to place resultant GUID. <br>// <br>// Output: <br>//    int                  - number of chars written out. <br>// <br>// Notes: <br>// <br>int StringFromGuidA <br>( <br>    REFIID   riid, <br>    LPSTR    pszBuf <br>) <br>{ <br>    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1, <br>            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2], <br>            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]); <br> <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// RegisterUnknownObject <br>//=--------------------------------------------------------------------------= <br>// registers a simple CoCreatable object.  nothing terribly serious. <br>// we add the following information to the registry: <br>// <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt; = &lt;ObjectName&gt; Object <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\InprocServer32 = &lt;path to local server&gt; <br>// <br>// Parameters: <br>//    LPCSTR       - [in] Object Name <br>//    REFCLSID     - [in] CLSID of the object <br>// <br>// Output: <br>//    BOOL         - FALSE means couldn't register it all <br>// <br>// Notes: <br>// <br>BOOL RegisterUnknownObject <br>( <br>    LPCSTR   pszObjectName, <br>    REFCLSID riidObject <br>) <br>{ <br>    HKEY  hk = NULL, hkSub = NULL; <br>    char  szGuidStr[GUID_STR_LEN]; <br>    DWORD dwPathLen, dwDummy; <br>    char  szScratch[MAX_PATH]; <br>    long  l; <br> <br>    // clean out any garbage <br>    // <br>    UnregisterUnknownObject(riidObject); <br> <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt; = &lt;ObjectName&gt; Object <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\InprocServer32 = &lt;path to local server&gt; <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\InprocServer32  @ThreadingModel = Apartment <br>    // <br>    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp; <br>    wsprintf(szScratch, "CLSID\\%s", szGuidStr); <br>    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hk, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s Object", pszObjectName); <br>    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch)); <br>    if (!dwPathLen) goto CleanUp; <br> <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment")); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    RegCloseKey(hk); <br> <br>    return TRUE; <br> <br>    // we are not very happy! <br>    // <br>  CleanUp: <br>    if (hk) RegCloseKey(hk); <br>    if (hkSub) RegCloseKey(hkSub); <br>    return FALSE; <br> <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// RegisterAutomationObject <br>//=--------------------------------------------------------------------------= <br>// given a little bit of information about an automation object, go and put it <br>// in the registry. <br>// we add the following information in addition to that set up in <br>// RegisterUnknownObject: <br>// <br>// <br>// HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt; = &lt;ObjectName&gt; Object <br>// HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;\CLSID = &lt;CLSID&gt; <br>// HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;\CurVer = &lt;ObjectName&gt;.Object.&lt;VersionNumber&gt; <br>// <br>// HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt; = &lt;ObjectName&gt; Object <br>// HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt;\CLSID = &lt;CLSID&gt; <br>// <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\TypeLib = &lt;LibidOfTypeLibrary&gt; <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\ProgID = &lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt; <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\VersionIndependentProgID = &lt;LibraryName&gt;.&lt;ObjectName&gt; <br>// <br>// Parameters: <br>//    LPCSTR       - [in] Library Name <br>//    LPCSTR       - [in] Object Name <br>//    long         - [in] Version Number <br>//    REFCLSID     - [in] LIBID of type library <br>//    REFCLSID     - [in] CLSID of the object <br>// <br>// Output: <br>//    BOOL         - FALSE means not all of it was registered <br>// <br>// Notes: <br>// <br>BOOL RegisterAutomationObject <br>( <br>    LPCSTR   pszLibName, <br>    LPCSTR   pszObjectName, <br>    long     lVersion, <br>    REFCLSID riidLibrary, <br>    REFCLSID riidObject <br>) <br>{ <br>    HKEY  hk = NULL, hkSub = NULL; <br>    char  szGuidStr[GUID_STR_LEN]; <br>    char  szScratch[MAX_PATH]; <br>    long  l; <br>    DWORD dwDummy; <br> <br>    // first register the simple Unknown stuff. <br>    // <br>    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE; <br> <br>    // HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt; = &lt;ObjectName&gt; Object <br>    // HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;\CLSID = &lt;CLSID&gt; <br>    // HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;\CurVer = &lt;ObjectName&gt;.Object.&lt;VersionNumber&gt; <br>    // <br>    lstrcpy(szScratch, pszLibName); <br>    lstrcat(szScratch, "."); <br>    lstrcat(szScratch, pszObjectName); <br> <br>    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "", <br>                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, <br>                       NULL, &amp;hk, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s Object", pszObjectName); <br>    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    if (!StringFromGuidA(riidObject, szGuidStr)) <br>        goto CleanUp; <br> <br>    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion); <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    RegCloseKey(hk); <br> <br>    // HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt; = &lt;ObjectName&gt; Object <br>    // HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt;\CLSID = &lt;CLSID&gt; <br>    // <br>    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hk, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s Object", pszObjectName); <br>    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    RegCloseKey(hk); <br> <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\ProgID = &lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt; <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\VersionIndependentProgID = &lt;LibraryName&gt;.&lt;ObjectName&gt; <br>    // HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\TypeLib = &lt;LibidOfTypeLibrary&gt; <br>    // <br>    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp; <br>    wsprintf(szScratch, "CLSID\\%s", szGuidStr); <br> <br>    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ|KEY_WRITE, NULL, &amp;hk, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName); <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br> <br>    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE, <br>                       KEY_READ | KEY_WRITE, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion); <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE, <br>                       NULL, &amp;hkSub, &amp;dwDummy); <br> <br>    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp; <br> <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br>    RegCloseKey(hk); <br>    return TRUE; <br> <br>  CleanUp: <br>    if (hk) RegCloseKey(hkSub); <br>    if (hk) RegCloseKey(hk); <br>    return FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// RegisterControlObject. <br>//=--------------------------------------------------------------------------= <br>// in addition to writing out automation object information, this function <br>// writes out some values specific to a control. <br>// <br>// What we add here: <br>// <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\Control <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\MiscStatus\1 = &lt;MISCSTATUSBITS&gt; <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\ToolboxBitmap32 = &lt;PATH TO BMP&gt; <br>// HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt;\Version = &lt;VERSION&gt; <br>// <br>// Parameters: <br>//    LPCSTR       - [in] Library Name <br>//    LPCSTR       - [in] Object Name <br>//    long         - [in] Version Number <br>//    REFCLSID     - [in] LIBID of type library <br>//    REFCLSID     - [in] CLSID of the object <br>//    DWORD        - [in] misc status flags for ctl <br>//    WORD         - [in] toolbox id for control <br>// <br>// Output: <br>//    BOOL <br>// <br>// Notes: <br>//    - not the most terribly efficient routine. <br>// <br>BOOL RegisterControlObject <br>( <br>    LPCSTR   pszLibName, <br>    LPCSTR   pszObjectName, <br>    long     lVersion, <br>    REFCLSID riidLibrary, <br>    REFCLSID riidObject, <br>    DWORD    dwMiscStatus, <br>    WORD     wToolboxBitmapId <br>) <br>{ <br>    HKEY    hk, hkSub = NULL, hkSub2 = NULL; <br>    char    szTmp[MAX_PATH]; <br>    char    szGuidStr[GUID_STR_LEN]; <br>    DWORD   dwDummy; <br>    LONG    l; <br> <br>    // first register all the automation information for this sucker. <br>    // <br>    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE; <br> <br>    // then go and register the control specific stuff. <br>    // <br>    StringFromGuidA(riidObject, szGuidStr); <br>    wsprintf(szTmp, "CLSID\\%s", szGuidStr); <br>    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &amp;hk); <br>    if (l != ERROR_SUCCESS) return FALSE; <br> <br>    // create the control flag. <br>    // <br>    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    // now set up the MiscStatus Bits... <br>    // <br>    RegCloseKey(hkSub); <br>    hkSub = NULL; <br>    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    szTmp[0] = '0'; <br>    szTmp[1] = '\0'; <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkSub2, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szTmp, "%d", dwMiscStatus); <br>    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1); <br>    RegCloseKey(hkSub2); <br>    CLEANUP_ON_ERROR(l); <br> <br>    RegCloseKey(hkSub); <br> <br>    // now set up the toolbox bitmap <br>    // <br>    GetModuleFileName(g_hInstance, szTmp, MAX_PATH); <br>    wsprintf(szGuidStr, ", %d", wToolboxBitmapId); <br>    lstrcat(szTmp, szGuidStr); <br> <br>    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1); <br>    CLEANUP_ON_ERROR(l); <br> <br>    // now set up the version information <br>    // <br>    RegCloseKey(hkSub); <br>    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &amp;hkSub, &amp;dwDummy); <br>    CLEANUP_ON_ERROR(l); <br> <br>    wsprintf(szTmp, "%ld.0", lVersion); <br>    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1); <br> <br>  CleanUp: <br>    if (hk) <br>        RegCloseKey(hk); <br>    if (hkSub) <br>        RegCloseKey(hkSub); <br> <br>    return (l == ERROR_SUCCESS) ? TRUE : FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// UnregisterUnknownObject <br>//=--------------------------------------------------------------------------= <br>// cleans up all the stuff that RegisterUnknownObject puts in the <br>// registry. <br>// <br>// Parameters: <br>//    REFCLSID     - [in] CLSID of the object <br>// <br>// Output: <br>//    BOOL         - FALSE means not all of it was registered <br>// <br>// Notes: <br>//    - WARNING: this routine will blow away all other keys under the CLSID <br>//      for this object.  mildly anti-social, but likely not a problem. <br>// <br>BOOL UnregisterUnknownObject <br>( <br>    REFCLSID riidObject <br>) <br>{ <br>    char szScratch[MAX_PATH]; <br>    HKEY hk; <br>    BOOL f; <br>    long l; <br> <br>    // delete everybody of the form <br>    //   HKEY_CLASSES_ROOT\CLSID\&lt;CLSID&gt; [\] * <br>    // <br>    if (!StringFromGuidA(riidObject, szScratch)) <br>        return FALSE; <br> <br>    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &amp;hk); <br>    if (l != ERROR_SUCCESS) return FALSE; <br> <br>    f = DeleteKeyAndSubKeys(hk, szScratch); <br>    RegCloseKey(hk); <br> <br>    return f; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// UnregisterAutomationObject <br>//=--------------------------------------------------------------------------= <br>// unregisters an automation object, including all of it's unknown object <br>// information. <br>// <br>// Parameters: <br>//    LPCSTR       - [in] Library Name <br>//    LPCSTR       - [in] Object Name <br>//    long         - [in] Version Number <br>//    REFCLSID     - [in] CLSID of the object <br>// <br>// Output: <br>//    BOOL         - FALSE means couldn't get it all unregistered. <br>// <br>// Notes: <br>// <br>BOOL UnregisterAutomationObject <br>( <br>    LPCSTR   pszLibName, <br>    LPCSTR   pszObjectName, <br>    long     lVersion, <br>    REFCLSID riidObject <br>) <br>{ <br>    char szScratch[MAX_PATH]; <br>    BOOL f; <br> <br>    // first thing -- unregister Unknown information <br>    // <br>    f = UnregisterUnknownObject(riidObject); <br>    if (!f) return FALSE; <br> <br>    // delete everybody of the form: <br>    //   HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt; [\] * <br>    // <br>    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName); <br>    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch); <br>    if (!f) return FALSE; <br> <br>    // delete everybody of the form <br>    //   HKEY_CLASSES_ROOT\&lt;LibraryName&gt;.&lt;ObjectName&gt;.&lt;VersionNumber&gt; [\] * <br>    // <br>    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion); <br>    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch); <br>    if (!f) return FALSE; <br> <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// UnregisterTypeLibrary <br>//=--------------------------------------------------------------------------= <br>// blows away the type library keys for a given libid. <br>// <br>// Parameters: <br>//    REFCLSID        - [in] libid to blow away. <br>// <br>// Output: <br>//    BOOL            - TRUE OK, FALSE bad. <br>// <br>// Notes: <br>//    - WARNING: this function just blows away the entire type library section, <br>//      including all localized versions of the type library.  mildly anti- <br>//      social, but not killer. <br>// <br>BOOL UnregisterTypeLibrary <br>( <br>    REFCLSID riidLibrary <br>) <br>{ <br>    HKEY hk; <br>    char szScratch[GUID_STR_LEN]; <br>    long l; <br>    BOOL f; <br> <br>    // convert the libid into a string. <br>    // <br>    if (!StringFromGuidA(riidLibrary, szScratch)) <br>        return FALSE; <br> <br>    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &amp;hk); <br>    if (l != ERROR_SUCCESS) return FALSE; <br> <br>    f = DeleteKeyAndSubKeys(hk, szScratch); <br>    RegCloseKey(hk); <br>    return f; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// DeleteKeyAndSubKeys <br>//=--------------------------------------------------------------------------= <br>// delete's a key and all of it's subkeys. <br>// <br>// Parameters: <br>//    HKEY                - [in] delete the descendant specified <br>//    LPSTR               - [in] i'm the descendant specified <br>// <br>// Output: <br>//    BOOL                - TRUE OK, FALSE baaaad. <br>// <br>// Notes: <br>//    - I don't feel too bad about implementing this recursively, since the <br>//      depth isn't likely to get all the great. <br>//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to <br>//      work with sub-keys under windows 95. <br>// <br>BOOL DeleteKeyAndSubKeys <br>( <br>    HKEY    hkIn, <br>    LPSTR   pszSubKey <br>) <br>{ <br>    HKEY  hk; <br>    char  szTmp[MAX_PATH]; <br>    DWORD dwTmpSize; <br>    long  l; <br>    BOOL  f; <br>    int   x; <br> <br>    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &amp;hk); <br>    if (l != ERROR_SUCCESS) return FALSE; <br> <br>    // loop through all subkeys, blowing them away. <br>    // <br>    f = TRUE; <br>    x = 0; <br>    while (f) { <br>        dwTmpSize = MAX_PATH; <br>        l = RegEnumKeyEx(hk, x, szTmp, &amp;dwTmpSize, 0, NULL, NULL, NULL); <br>        if (l != ERROR_SUCCESS) break; <br>        f = DeleteKeyAndSubKeys(hk, szTmp); <br>        x++; <br>    } <br> <br>    // there are no subkeys left, [or we'll just generate an error and return FALSE]. <br>    // let's go blow this dude away. <br>    // <br>    RegCloseKey(hk); <br>    l = RegDeleteKey(hkIn, pszSubKey); <br> <br>    return (l == ERROR_SUCCESS) ? TRUE : FALSE; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// Conversion Routines <br>//=--------------------------------------------------------------------------= <br>// the following stuff is stuff used for the various conversion routines. <br>// <br>#define HIMETRIC_PER_INCH   2540 <br>#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)&gt;&gt;1)) / (ppli) ) <br>#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH ) <br> <br>static  int     s_iXppli;            // Pixels per logical inch along width <br>static  int     s_iYppli;            // Pixels per logical inch along height <br>static  BYTE    s_fGotScreenMetrics; // Are above valid? <br> <br>//=--------------------------------------------------------------------------= <br>// GetScreenMetrics <br>//=--------------------------------------------------------------------------= <br>// private function we call to set up various metrics the conversion routines <br>// will use. <br>// <br>// Notes: <br>// <br>static void GetScreenMetrics <br>( <br>    void <br>) <br>{ <br>    HDC hDCScreen; <br> <br>    // we have to critical section this in case two threads are converting <br>    // things at the same time <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (s_fGotScreenMetrics) <br>        goto Done; <br> <br>    // we want the metrics for the screen <br>    // <br>    hDCScreen = GetDC(NULL); <br> <br>    ASSERT(hDCScreen, "couldn't get a DC for the screen."); <br>    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX); <br>    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY); <br> <br>    ReleaseDC(NULL, hDCScreen); <br>    s_fGotScreenMetrics = TRUE; <br> <br>    // we're done with our critical seciton.  clean it up <br>    // <br>  Done: <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// HiMetricToPixel <br>//=--------------------------------------------------------------------------= <br>// converts from himetric to Pixels. <br>// <br>// Parameters: <br>//    const SIZEL *        - [in]  dudes in himetric <br>//    SIZEL *              - [out] size in pixels. <br>// <br>// Notes: <br>// <br>void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix) <br>{ <br>    GetScreenMetrics(); <br> <br>    // We got logical HIMETRIC along the display, convert them to pixel units <br>    // <br>    lpSizeInPix-&gt;cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric-&gt;cx, s_iXppli); <br>    lpSizeInPix-&gt;cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric-&gt;cy, s_iYppli); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// PixelToHiMetric <br>//=--------------------------------------------------------------------------= <br>// converts from pixels to himetric. <br>// <br>// Parameters: <br>//    const SIZEL *        - [in]  size in pixels <br>//    SIZEL *              - [out] size in himetric <br>// <br>// Notes: <br>// <br>void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric) <br>{ <br>    GetScreenMetrics(); <br> <br>    // We got pixel units, convert them to logical HIMETRIC along the display <br>    // <br>    lpSizeInHiMetric-&gt;cx = MAP_PIX_TO_LOGHIM(lpSizeInPix-&gt;cx, s_iXppli); <br>    lpSizeInHiMetric-&gt;cy = MAP_PIX_TO_LOGHIM(lpSizeInPix-&gt;cy, s_iYppli); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// _MakePath <br>//=--------------------------------------------------------------------------= <br>// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle. <br>// not terrilby efficient or smart, but it's registration code, so we don't <br>// really care. <br>// <br>// Notes: <br>// <br>void _MakePath <br>( <br>    LPSTR pszFull, <br>    const char * pszName, <br>    LPSTR pszOut <br>) <br>{ <br>    LPSTR psz; <br>    LPSTR pszLast; <br> <br>    lstrcpy(pszOut, pszFull); <br>    psz = pszLast = pszOut; <br>    while (*psz) { <br>        if (*psz == '\\') <br>            pszLast = AnsiNext(psz); <br>        psz = AnsiNext(psz); <br>    } <br> <br>    // got the last \ character, so just go and replace the name. <br>    // <br>    lstrcpy(pszLast, pszName); <br>} <br> <br>// from Globals.C <br>// <br>extern HINSTANCE    g_hInstResources; <br> <br>//=--------------------------------------------------------------------------= <br>// GetResourceHandle <br>//=--------------------------------------------------------------------------= <br>// returns the resource handle.  we use the host's ambient Locale ID to <br>// determine, from a table in the DLL, which satellite DLL to load for <br>// localized resources. <br>// <br>// Output: <br>//    HINSTANCE <br>// <br>// Notes: <br>// <br>HINSTANCE GetResourceHandle <br>( <br>    void <br>) <br>{ <br>    int i; <br>    char szExtension[5], szTmp[MAX_PATH]; <br>    char szDllName[MAX_PATH], szFinalName[MAX_PATH]; <br> <br>    // crit sect this so that we don't screw anything up. <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br> <br>    // don't do anything if we don't have to <br>    // <br>    if (g_hInstResources || !g_fSatelliteLocalization) <br>        goto CleanUp; <br> <br>    // we're going to call GetLocaleInfo to get the abbreviated name for the <br>    // LCID we've got. <br>    // <br>    i = GetLocaleInfo(g_lcidLocale, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension)); <br>    if (!i) goto CleanUp; <br> <br>    // we've got the language extension.  go and load the DLL name from the <br>    // resources and then tack on the extension. <br>    // please note that all inproc sers -must- have the string resource 1001 <br>    // defined to the base name of the server if they wish to support satellite <br>    // localization. <br>    // <br>    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp)); <br>    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!"); <br>    if (!i) goto CleanUp; <br> <br>    // got the basename and the extention. go and combine them, and then add <br>    // on the .DLL for them. <br>    // <br>    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension); <br> <br>    // try to load in the DLL <br>    // <br>    GetModuleFileName(g_hInstance, szTmp, MAX_PATH); <br>    _MakePath(szTmp, szDllName, szFinalName); <br> <br>    g_hInstResources = LoadLibrary(szFinalName); <br> <br>    // if we couldn't find it with the entire LCID, try it with just the primary <br>    // langid </code></pre>
<p>
</p>
<pre><code>// <br>    if (!g_hInstResources) { <br>        LPSTR psz; <br>        LCID lcid; <br>        lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT); <br>        i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension)); <br>        if (!i) goto CleanUp; <br> <br>        // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly <br>        // hacky, but it should be fine.  there are no DBCS lang identifiers. <br>        // finally, retry the load <br>        // <br>        psz = szFinalName + lstrlen(szFinalName); <br>        memcpy((LPBYTE)psz - 7, szExtension, 3); <br>        g_hInstResources = LoadLibrary(szFinalName); <br>    } <br> <br>  CleanUp: <br>    // if we couldn't load the DLL for some reason, then just return the <br>    // current resource handle, which is good enough. <br>    // <br>    if (!g_hInstResources) g_hInstResources = g_hInstance; <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    return g_hInstResources; <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
