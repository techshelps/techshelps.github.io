<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLOCX96.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context90"></a>CTLOCX96.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlOcx96.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of the OCX 96 interfaces that don't quite fit in to the <br>// categories covered by embedding, persistence, and ctlmisc.cpp <br>// <br>// <br>#include "IPServer.H" <br> <br>#include "CtrlObj.H" <br>#include "Globals.H" <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetActivationPolicy    [IPointerInactive] <br>//=--------------------------------------------------------------------------= <br>// returns the present activation policy for this object.  for non-subclassed <br>// windows controls, this means we can put off in-place activation for quite <br>// a while. <br>// <br>// Parameters: <br>//    DWORD *        - [out] activation policy <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetActivationPolicy <br>( <br>    DWORD *pdwPolicy <br>) <br>{ <br>    CHECK_POINTER(pdwPolicy); <br> <br>    // just get the policy in the global structure describing this control. <br>    // <br>    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnInactiveMouseMove    [IPointerInactive] <br>//=--------------------------------------------------------------------------= <br>// indicates to an inactive oobject that the mouse pointer has moved over the <br>// object. <br>// <br>// Parameters: <br>//    LPCRECT            - [in] <br>//    long               - [in] <br>//    long               - [in] <br>//    DWORD              - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnInactiveMouseMove <br>( <br>    LPCRECT pRectBounds, <br>    long    x, <br>    long    y, <br>    DWORD   dwMouseMsg <br>) <br>{ <br>    // OVERRIDE: end control writers should just override this if they want <br>    // to have a control that is never in-place active. <br>    // <br>    return S_OK; <br>} <br>     <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnInactiveSetCursor    [IPointerInactive] <br>//=--------------------------------------------------------------------------= <br>// called by the container for the inactive object under the mouse pointer on <br>// recept of a WM_SETCURSOR message. <br>// <br>// Parameters: <br>//    LPCRECT            - [in] <br>//    long               - [in] <br>//    long               - [in] <br>//    DWORD              - [in] <br>//    BOOL               - [in] <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::OnInactiveSetCursor <br>( <br>    LPCRECT pRectBounds, <br>    long    x, <br>    long    y, <br>    DWORD   dwMouseMsg, <br>    BOOL    fSetAlways <br>) <br>{ <br>    // OVERRIDE:  just get the user to override this if they want to never <br>    // be activated <br>    // <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::QuickActivate    [IQuickActivate] <br>//=--------------------------------------------------------------------------= <br>// allows the container to activate the control. <br>// <br>// Parameters: <br>//    QACONTAINER *        - [in]  info about the container <br>//    QACONTROL *          - [out] info about the control <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::QuickActivate <br>( <br>    QACONTAINER *pContainer, <br>    QACONTROL *pControl <br>) <br>{ <br>    HRESULT hr; <br>    DWORD   dw; <br> <br>    // we need these guys. <br>    // <br>    if (!pContainer) return E_UNEXPECTED; <br>    if (!pControl) return E_UNEXPECTED; <br> <br>    // start grabbing things from the QACONTAINER structure and apply them <br>    // as relevant <br>    // <br>    if (pContainer-&gt;cbSize &lt; sizeof(QACONTAINER)) return E_UNEXPECTED; <br>    if (pControl-&gt;cbSize &lt; sizeof(QACONTROL)) return E_UNEXPECTED; <br> <br>    // save out the client site, of course. <br>    // <br>    if (pContainer-&gt;pClientSite) { <br>        hr = SetClientSite(pContainer-&gt;pClientSite); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    // if the lcid is not LANG_NEUTRAL, score! <br>    // <br>    if (pContainer-&gt;lcid) { <br>        g_lcidLocale = pContainer-&gt;lcid; <br>        g_fHaveLocale = TRUE; <br>    } <br> <br>    // pay attention to some ambients <br>    // <br>    if (pContainer-&gt;dwAmbientFlags &amp; QACONTAINER_MESSAGEREFLECT) { <br>        m_fHostReflects = TRUE; <br>        m_fCheckedReflecting = TRUE; <br>    } <br> <br>    // hook up some notifications.  first property notifications. <br>    // <br>    if (pContainer-&gt;pPropertyNotifySink) { <br>        pContainer-&gt;pPropertyNotifySink-&gt;AddRef(); <br>        hr = m_cpPropNotify.AddSink((void *)pContainer-&gt;pPropertyNotifySink, &amp;pControl-&gt;dwPropNotifyCookie); <br>        if (FAILED(hr)) { <br>            pContainer-&gt;pPropertyNotifySink-&gt;Release(); <br>            return hr; <br>        } <br>    } <br> <br>    // then the event sink. <br>    // <br>    if (pContainer-&gt;pUnkEventSink) { <br>        hr = m_cpEvents.Advise(pContainer-&gt;pUnkEventSink, &amp;pControl-&gt;dwEventCookie); <br>        if (FAILED(hr)) { <br>            pContainer-&gt;pUnkEventSink-&gt;Release(); <br>            return hr; <br>        } <br>    } <br> <br>    // finally, the advise sink. <br>    // <br>    if (pContainer-&gt;pAdviseSink) { <br>        // don't need to pass the cookie back since there can only be one <br>        // person advising at a time. <br>        // <br>        hr = Advise(pContainer-&gt;pAdviseSink, &amp;dw); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    // set up a few things in the QACONTROL structure.  we're opaque by default <br>    // <br>    pControl-&gt;dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType); <br>    pControl-&gt;dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0; <br>    pControl-&gt;dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType); <br> <br>    // that's pretty much all we're interested in.  we will, however, pass on the <br>    // rest of the things to the end control writer and see if they want to do <br>    // anything with them. they shouldn't touch any of the above except for the <br>    // ambients. <br>    // <br>    return OnQuickActivate(pContainer, &amp;(pControl-&gt;dwViewStatus)); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetContentExtent    [IQuickActivate] <br>//=--------------------------------------------------------------------------= <br>// the container calls this to set the content extent of the control. <br>// <br>// Parameters: <br>//    LPSIZEL            - [in] the size of the content extent <br>// <br>// Output: <br>//    HRESULT            - S_OK, or E_FAIL for fixed size control <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SetContentExtent <br>( <br>    LPSIZEL pSize <br>) <br>{ <br>    return SetExtent(DVASPECT_CONTENT, pSize); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetContentExtent    [IQuickActivate] <br>//=--------------------------------------------------------------------------= <br>// the container calls this to get the content extent of the control <br>// <br>// Parameters: <br>//    LPSIZEL        - [out] returns current size <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetContentExtent <br>( <br>    LPSIZEL pSize <br>) <br>{ <br>    return GetExtent(DVASPECT_CONTENT, pSize); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnQuickActivate    [overridable] <br>//=--------------------------------------------------------------------------= <br>// not all the of the members of the QACONTAINER need to be consumed by the <br>// framework, but are, at least, extremely interesting.  thus, we will pass <br>// on the struture to the end control writer, and let them consume these. <br>// <br>// Parameters: <br>//    QACONTAINER *            - [in]  contains additional information <br>//    DWORD *                  - [out] put ViewStatus flags here. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - control writers should only look at/consume: <br>//        a. dwAmbientFlags <br>//        b. colorFore/colorBack <br>//        c. pFont <br>//        d. pUndoMgr <br>//        e. dwAppearance <br>//        f. hpal <br>// <br>//    - all the others are set up the for the user by the framework. <br>//    - control writers should set up the pdwViewStatus with flags as per <br>//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't <br>//      care, then don't touch. <br>// <br>HRESULT COleControl::OnQuickActivate <br>( <br>    QACONTAINER *pContainer, <br>    DWORD       *pdwViewStatus <br>) <br>{ <br>    // by default, nuthin much to do! <br>    // <br>    return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
