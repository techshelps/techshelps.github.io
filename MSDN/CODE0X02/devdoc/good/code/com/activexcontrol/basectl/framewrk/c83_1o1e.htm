<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTLVIEW.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context92"></a>CTLVIEW.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtlView.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of the IViewObjectEx interface, which is a moderately <br>// non-trivial bunch of code. <br>// <br>#include "IPServer.H" <br> <br>#include "CtrlObj.H" <br>#include "Globals.H" <br>#include "Util.H" <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>// local functions we're going to find useful <br>// <br>HDC _CreateOleDC(DVTARGETDEVICE *ptd); <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Draw    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Draws a representation of an object onto the specified device context.  <br>// <br>// Parameters: <br>//    DWORD                - [in] draw aspect <br>//    LONG                 - [in] part of object to draw [not relevant] <br>//    void *               - NULL <br>//    DVTARGETDEVICE *     - [in] specifies the target device <br>//    HDC                  - [in] information context for target device <br>//    HDC                  - [in] target device context <br>//    LPCRECTL             - [in] rectangle in which the object is drawn <br>//    LPCRECTL             - [in] window extent and origin for metafiles <br>//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing <br>//    DWORD                - [in] parameter to pass to callback. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>//    - we support the following OCX 96 extensions <br>//        a. flicker free drawing [multi-pass drawing] <br>//        b. pvAspect != NULL for optimized DC handling <br>//        c. prcBounds == NULL for windowless inplace active objects <br>// <br>STDMETHODIMP COleControl::Draw <br>( <br>    DWORD            dwDrawAspect, <br>    LONG             lIndex, <br>    void            *pvAspect, <br>    DVTARGETDEVICE  *ptd, <br>    HDC              hicTargetDevice, <br>    HDC              hdcDraw, <br>    LPCRECTL         prcBounds, <br>    LPCRECTL         prcWBounds, <br>    BOOL (__stdcall *pfnContinue)(DWORD dwContinue), <br>    DWORD            dwContinue <br>) <br>{ <br>    HRESULT hr; <br>    RECTL rc; <br>    POINT pVp, pW; <br>    BOOL  fOptimize = FALSE; <br>    int iMode; <br>    BYTE fMetafile = FALSE; <br>    BYTE fDeleteDC = FALSE; <br> <br>    // support the aspects required for multi-pass drawing <br>    // <br>    switch (dwDrawAspect) { <br>        case DVASPECT_CONTENT: <br>        case DVASPECT_OPAQUE: <br>        case DVASPECT_TRANSPARENT: <br>            break; <br>        default: <br>            return DV_E_DVASPECT; <br>    } <br> <br>    // first, have to do a little bit to support printing. <br>    // <br>    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) { <br> <br>        // We are dealing with a metafile. <br>        // <br>        fMetafile = TRUE; <br> <br>        // If attributes DC is NULL, create one, based on ptd. <br>        // <br>        if (!hicTargetDevice) { <br> <br>            // Does _CreateOleDC have to return an hDC <br>            // or can it be flagged to return an hIC  <br>            // for this particular case? <br>            // <br>            hicTargetDevice = _CreateOleDC(ptd); <br>            fDeleteDC = TRUE; <br>        } <br>    } <br> <br>    // check to see if we have any flags passed in the pvAspect parameter. <br>    // <br>    if (pvAspect &amp;&amp; ((DVASPECTINFO *)pvAspect)-&gt;cb == sizeof(DVASPECTINFO)) <br>        fOptimize = (((DVASPECTINFO *)pvAspect)-&gt;dwFlags &amp; DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE; <br> <br>    // if we are windowless, then we just pass this on to the end control code. <br>    // <br>    if (m_fInPlaceActive) { <br> <br>        // give them a rectangle with which to draw <br>        // <br>        //ASSERT(!m_fInPlaceActive || !prcBounds, "Inplace active and somebody passed in prcBounds!!!"); <br>        if (prcBounds) <br>memcpy(&amp;rc, prcBounds, sizeof(rc)); <br>else <br>memcpy(&amp;rc, &amp;m_rcLocation, sizeof(rc)); <br>    } else { <br> <br>        // first -- convert the DC back to MM_TEXT mapping mode so that the <br>        // window proc and OnDraw can share the same painting code.  save <br>        // some information on it, so we can restore it later [without using <br>        // a SaveDC/RestoreDC] <br>        // <br>        rc = *prcBounds; <br> <br>        // Don't do anything to hdcDraw if it's a metafile. <br>        // The control's Draw method must make the appropriate <br>        // accomodations for drawing to a metafile <br>        // <br>        if (!fMetafile) { <br>            LPtoDP(hdcDraw, (POINT *)&amp;rc, 2); <br>            SetViewportOrgEx(hdcDraw, 0, 0, &amp;pVp); <br>            SetWindowOrgEx(hdcDraw, 0, 0, &amp;pW); <br>            iMode = SetMapMode(hdcDraw, MM_TEXT); <br>        } <br>    } <br> <br>    // prcWBounds is NULL and not used if we are not dealing with a metafile. <br>    // For metafiles, we pass on rc as *prcBounds, we should also include <br>    // prcWBounds <br>    // <br>    hr = OnDraw(dwDrawAspect, hdcDraw, &amp;rc, prcWBounds, hicTargetDevice, fOptimize); <br> <br>    // clean up the DC when we're done with it, if appropriate. <br>    // <br>    if (!m_fInPlaceActive) { <br>        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL); <br>        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL); <br>        SetMapMode(hdcDraw, iMode); <br>    } <br> <br>    // if we created a dc, blow it away now <br>    // <br>    if (fDeleteDC) DeleteDC(hicTargetDevice); <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::DoSuperClassPaint <br>//=--------------------------------------------------------------------------= <br>// design time painting of a subclassed control. <br>// <br>// Parameters: <br>//    HDC                - [in]  dc to work with <br>//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT COleControl::DoSuperClassPaint <br>( <br>    HDC      hdc, <br>    LPCRECTL prcBounds <br>) <br>{ <br>    HWND hwnd; <br>    RECT rcClient; <br>    int  iMapMode; <br>    POINT ptWOrg, ptVOrg; <br>    SIZE  sWOrg, sVOrg; <br> <br>    // make sure we have a window. <br>    // <br>    hwnd = CreateInPlaceWindow(0,0, FALSE); <br>    if (!hwnd) <br>        return E_FAIL; <br> <br>    GetClientRect(hwnd, &amp;rcClient); <br> <br>    // set up the DC for painting.  this code largely taken from the MFC CDK <br>    // DoSuperClassPaint() fn.  doesn't always get things like command <br>    // buttons quite right ... <br>    // <br>    // NOTE: there is a windows 95 problem in which the font instance manager <br>    // will leak a bunch of bytes in the global GDI pool whenever you  <br>    // change your extents and have an active font.  this code gets around <br>    // this for on-screen cases, but not for printing [which shouldn't be <br>    // too serious, because you're not often changing your control size and <br>    // printing rapidly in succession] <br>    // <br>    if ((rcClient.right - rcClient.left != prcBounds-&gt;right - prcBounds-&gt;left) <br>        &amp;&amp; (rcClient.bottom - rcClient.top != prcBounds-&gt;bottom - prcBounds-&gt;top)) { <br> <br>        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC); <br>        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &amp;sWOrg); <br>        SetViewportExtEx(hdc, prcBounds-&gt;right - prcBounds-&gt;left, prcBounds-&gt;bottom - prcBounds-&gt;top, &amp;sVOrg); <br>    } <br> <br>    SetWindowOrgEx(hdc, 0, 0, &amp;ptWOrg); <br>    SetViewportOrgEx(hdc, prcBounds-&gt;left, prcBounds-&gt;top, &amp;ptVOrg); <br> <br>#if STRICT <br>    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0)); <br>#else <br>    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0)); <br>#endif // STRICT <br> <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetColorSet    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Returns the logical palette that the control will use for drawing in its <br>// IViewObject::Draw method with the corresponding parameters. <br>// <br>// Parameters: <br>//    DWORD                - [in]  how the object is to be represented <br>//    LONG                 - [in]  part of the object to draw [not relevant] <br>//    void *               - NULL <br>//    DVTARGETDEVICE *     - [in]  specifies the target device <br>//    HDC                  - [in]  information context for the target device <br>//    LOGPALETTE **        - [out] where to put palette <br>// <br>// Output: <br>//    S_OK                 - Control has a palette, and returned it through the out param. <br>//    S_FALSE              - Control does not currently have a palette. <br>//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control. <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetColorSet <br>( <br>    DWORD            dwDrawAspect, <br>    LONG             lindex, <br>    void            *IgnoreMe, <br>    DVTARGETDEVICE  *ptd, <br>    HDC              hicTargetDevice, <br>    LOGPALETTE     **ppColorSet <br>) <br>{ <br>    if (dwDrawAspect != DVASPECT_CONTENT) <br>        return DV_E_DVASPECT; <br> <br>    *ppColorSet = NULL; <br>    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Freeze    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Freezes a certain aspect of the object's presentation so that it does not <br>// change until the IViewObject::Unfreeze method is called. <br>// <br>// Parameters: <br>//    DWORD            - [in] aspect <br>//    LONG             - [in] part of object to draw <br>//    void *           - NULL <br>//    DWORD *          - [out] for Unfreeze <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Freeze <br>( <br>    DWORD   dwDrawAspect, <br>    LONG    lIndex, <br>    void   *IgnoreMe, <br>    DWORD  *pdwFreeze <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::Unfreeze    [IVewObject2] <br>//=--------------------------------------------------------------------------= <br>// Releases a previously frozen drawing. The most common use of this method <br>// is for banded printing. <br>// <br>// Parameters: <br>//    DWORD        - [in] cookie from freeze <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::Unfreeze <br>( <br>    DWORD dwFreeze <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::SetAdvise    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Sets up a connection between the control and an advise sink so that the <br>// advise sink can be notified about changes in the control's view. <br>// <br>// Parameters: <br>//    DWORD            - [in] aspect <br>//    DWORD            - [in] info about the sink <br>//    IAdviseSink *    - [in] the sink <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::SetAdvise <br>( <br>    DWORD        dwAspects, <br>    DWORD        dwAdviseFlags, <br>    IAdviseSink *pAdviseSink <br>) <br>{ <br>    // if it's not a content aspect, we don't support it. <br>    // <br>    if (!(dwAspects &amp; DVASPECT_CONTENT)) { <br>        return DV_E_DVASPECT; <br>    } <br> <br>    // set up some flags  [we gotta stash for GetAdvise ...] <br>    // <br>    m_fViewAdvisePrimeFirst = (dwAdviseFlags &amp; ADVF_PRIMEFIRST) ? TRUE : FALSE; <br>    m_fViewAdviseOnlyOnce = (dwAdviseFlags &amp; ADVF_ONLYONCE) ? TRUE : FALSE; <br> <br>    RELEASE_OBJECT(m_pViewAdviseSink); <br>    m_pViewAdviseSink = pAdviseSink; <br>    ADDREF_OBJECT(m_pViewAdviseSink); <br> <br>    // prime them if they want it [we need to store this so they can get flags later] <br>    // <br>    if (m_fViewAdvisePrimeFirst) <br>        ViewChanged(); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetAdvise    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Retrieves the existing advisory connection on the control if there is one. <br>// This method simply returns the parameters used in the most recent call to <br>// the IViewObject::SetAdvise method. <br>// <br>// Parameters: <br>//    DWORD *            - [out]  aspects <br>//    DWORD *            - [out]  advise flags <br>//    IAdviseSink **     - [out]  the sink <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes; <br>// <br>STDMETHODIMP COleControl::GetAdvise <br>( <br>    DWORD        *pdwAspects, <br>    DWORD        *pdwAdviseFlags, <br>    IAdviseSink **ppAdviseSink <br>) <br>{ <br>    // if they want it, give it to them <br>    // <br>    if (pdwAspects) <br>        *pdwAspects = DVASPECT_CONTENT; <br> <br>    if (pdwAdviseFlags) { <br>        *pdwAdviseFlags = 0; <br>        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE; <br>        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST; <br>    } <br> <br>    if (ppAdviseSink) { <br>        *ppAdviseSink = m_pViewAdviseSink; <br>        ADDREF_OBJECT(*ppAdviseSink); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetExtent    [IViewObject2] <br>//=--------------------------------------------------------------------------= <br>// Returns the size that the control will be drawn on the <br>// specified target device. <br>// <br>// Parameters: <br>//    DWORD            - [in] draw aspect <br>//    LONG             - [in] part of object to draw <br>//    DVTARGETDEVICE * - [in] information about target device <br>//    LPSIZEL          - [out] where to put the size <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetExtent <br>( <br>    DWORD           dwDrawAspect, <br>    LONG            lindex, <br>    DVTARGETDEVICE *ptd, <br>    LPSIZEL         psizel <br>) <br>{ <br>    // we already have an implementation of this [from IOleObject] <br>    // <br>    return GetExtent(dwDrawAspect, psizel); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnGetPalette    [overridable] <br>//=--------------------------------------------------------------------------= <br>// called when the host wants palette information.  ideally, people should use <br>// this sparingly and carefully. <br>// <br>// Parameters: <br>//    HDC            - [in]  HIC for the target device <br>//    LOGPALETTE **  - [out] where to put the palette <br>// <br>// Output: <br>//    BOOL           - TRUE means we processed it, false means nope. <br>// <br>// Notes: <br>// <br>BOOL COleControl::OnGetPalette <br>( <br>    HDC          hicTargetDevice, <br>    LOGPALETTE **ppColorSet <br>) <br>{ <br>    return FALSE; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetRect    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// returns a rectnagle describing a given drawing aspect <br>// <br>// Parameters: <br>//    DWORD             - [in]  aspect <br>//    LPRECTL           - [out] region rectangle <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetRect <br>( <br>    DWORD    dvAspect, <br>    LPRECTL  prcRect <br>) <br>{ <br>    RECTL rc; <br>    BOOL  f; <br> <br>    // call the user routine and let them return the size <br>    // <br>    f = OnGetRect(dvAspect, &amp;rc); <br>    if (!f) return DV_E_DVASPECT; <br> <br>    // transform these dudes. <br>    // <br>    PixelToHiMetric((LPSIZEL)&amp;rc, (LPSIZEL)prcRect); <br>    PixelToHiMetric((LPSIZEL)(LPBYTE)&amp;rc + sizeof(SIZEL), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL))); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetViewStatus    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// returns information about the opactiy of the object and what drawing <br>// aspects are supported <br>// <br>// Parameters: <br>//    DWORD *            - [out] the status <br>// <br>/// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetViewStatus <br>( <br>    DWORD *pdwStatus <br>) <br>{ <br>    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our <br>    // transparency vs opacity. <br>    // OVERRIDE:  controls that wish to support multi-pass drawing should <br>    // override this routine and return, in addition to the flags indication <br>    // opacity, flags indicating what sort of drawing aspects they support. <br>    // <br>    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::QueryHitPoint    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// indicates whether a point is within a given aspect of an object. <br>// <br>// Parameters: <br>//    DWORD                - [in]  aspect <br>//    LPCRECT              - [in]  Bounds rectangle <br>//    POINT                - [in]  hit location client coordinates <br>//    LONG                 - [in]  what the container considers close <br>//    DWORD *              - [out] info about the hit <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::QueryHitPoint <br>( <br>    DWORD    dvAspect, <br>    LPCRECT  prcBounds, <br>    POINT    ptLocation, <br>    LONG     lCloseHint, <br>    DWORD   *pdwHitResult <br>) <br>{ <br>    // OVERRIDE: override me if you want to provide additional [non-opaque] <br>    // functionality <br>    // <br>    if (dvAspect != DVASPECT_CONTENT) <br>        return DV_E_DVASPECT; <br> <br>    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::QueryHitRect    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// indicates wheter any point in a rectangle is within a given drawing aspect <br>// of an object. <br>// <br>// Parameters: <br>//    DWORD            - [in]  aspect <br>//    LPCRECT          - [in]  bounds <br>//    LPCRECT          - [in]  location <br>//    LONG             - [in]  what host considers close <br>//    DWORD *          - [out] hit result <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::QueryHitRect <br>( <br>    DWORD     dvAspect, <br>    LPCRECT   prcBounds, <br>    LPCRECT   prcLocation, <br>    LONG      lCloseHint, <br>    DWORD    *pdwHitResult <br>) <br>{ <br>    RECT rc; <br> <br>    // OVERRIDE: override this for additional behaviour <br>    // <br>    if (dvAspect != DVASPECT_CONTENT) <br>        return DV_E_DVASPECT; <br> <br>    *pdwHitResult = IntersectRect(&amp;rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::GetNaturalExtent    [IViewObjectEx] <br>//=--------------------------------------------------------------------------= <br>// supports two types of control sizing, content and integral. <br>// <br>// Parameters: <br>//    DWORD            - [in]  aspect <br>//    LONG             - [in]  index <br>//    DVTARGETDEVICE * - [in]  target device information <br>//    HDC              - [in]  HIC <br>//    DVEXTENTINFO *   - [in]  sizing data <br>//    LPSIZEL          - [out] sizing data retunred by control <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP COleControl::GetNaturalExtent <br>( <br>    DWORD           dvAspect, <br>    LONG            lIndex, <br>    DVTARGETDEVICE *ptd, <br>    HDC             hicTargetDevice, <br>    DVEXTENTINFO   *pExtentInfo, <br>    LPSIZEL         pSizel <br>) <br>{ <br>    return E_NOTIMPL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl::OnGetRect    [overridable <br>//=--------------------------------------------------------------------------= <br>// returns our rectangle <br>// <br>// Parameters: <br>//    DWORD              - [in]  aspect they want the rect for <br>//    RECTL *            - [out] the rectangle that matches this aspect <br>// <br>// Output: <br>//    BOOL               - false means we don't like the aspect <br>// <br>// Notes: <br>// <br>BOOL COleControl::OnGetRect <br>( <br>    DWORD   dvAspect, <br>    RECTL  *pRect <br>) <br>{ <br>    // by default, we only support content drawing. <br>    // <br>    if (dvAspect != DVASPECT_CONTENT) <br>        return FALSE; <br> <br>    // just give them our bounding rectangle <br>    // <br>    *((LPRECT)pRect) = m_rcLocation; <br>    return TRUE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// _CreateOleDC <br>//=--------------------------------------------------------------------------= <br>// creates an HDC given a DVTARGETDEVICE structure. <br>// <br>// Parameters: <br>//    DVTARGETDEVICE *              - [in] duh. <br>// <br>// Output: <br>//    HDC <br>// <br>// Notes: <br>// <br>HDC _CreateOleDC <br>( <br>    DVTARGETDEVICE *ptd <br>) <br>{ <br>    LPDEVMODEW   pDevModeW; <br>    DEVMODEA     DevModeA, *pDevModeA; <br>    LPOLESTR     lpwszDriverName; <br>    LPOLESTR     lpwszDeviceName; <br>    LPOLESTR     lpwszPortName; <br>    HDC          hdc; <br> <br>    // return screen DC for NULL target device <br>    // <br>    if (!ptd) <br>        return CreateDC("DISPLAY", NULL, NULL, NULL); <br> <br>    if (ptd-&gt;tdExtDevmodeOffset == 0) <br>        pDevModeW = NULL; <br>    else <br>        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd-&gt;tdExtDevmodeOffset); <br> <br>    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdDriverNameOffset); <br>    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdDeviceNameOffset); <br>    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd-&gt;tdPortNameOffset); <br> <br>    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName); <br>    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName); <br>    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName); <br> <br>    // wow, this sucks. <br>    // <br>    if (pDevModeW) { <br>        WideCharToMultiByte(CP_ACP, 0, pDevModeW-&gt;dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL); <br>memcpy(&amp;DevModeA.dmSpecVersion, &amp;pDevModeW-&gt;dmSpecVersion, <br>offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion)); <br>        WideCharToMultiByte(CP_ACP, 0, pDevModeW-&gt;dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL); <br>memcpy(&amp;DevModeA.dmLogPixels, &amp;pDevModeW-&gt;dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels)); <br>        if (pDevModeW-&gt;dmDriverExtra) { <br>            pDevModeA = (DEVMODEA *)HeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW-&gt;dmDriverExtra); <br>            if (!pDevModeA) return NULL; <br>            memcpy(pDevModeA, &amp;DevModeA, sizeof(DEVMODEA)); <br>            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW-&gt;dmDriverExtra); <br>        } else <br>            pDevModeA = &amp;DevModeA; <br> <br>DevModeA.dmSize = sizeof(DEVMODEA); <br>    } else <br>        pDevModeA = NULL; <br> <br>    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA); <br>    if (pDevModeA != &amp;DevModeA) HeapFree(g_hHeap, 0, pDevModeA); <br>    return hdc; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
