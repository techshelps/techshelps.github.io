<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CTRLOBJ.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context106"></a>CTRLOBJ.H</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CtrlObj.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// class declaration for the COleControl object <br>// <br>#ifndef _CTRLOBJ_H_ <br> <br>// we need the automation object and ctlole.h <br>// <br>#include "AutoObj.H" <br>#include &lt;olectl.h&gt; <br> <br>// forward declaration <br>// <br>class COleControl; <br> <br>//=--------------------------------------------------------------------------= <br>// Misc Helper Functions <br>//=--------------------------------------------------------------------------= <br>// <br>// given an Unknown pointer, get the COleControl * for it.  used typically <br>// in property page code. <br>// <br>COleControl *ControlFromUnknown(IUnknown *); <br> <br> <br>//=--------------------------------------------------------------------------= <br>// Misc Constants <br>//=--------------------------------------------------------------------------= <br>// maximum number of arguments that can be sent to FireEvent() <br>// <br>#define MAX_ARGS    32 <br> <br>// for the types of sinks that the COleControl class has.  you shouldn't ever <br>// need to use these <br>// <br>#define SINK_TYPE_EVENT      0 <br>#define SINK_TYPE_PROPNOTIFY 1 <br> <br>// superclass window support.  you can pass this in to DoSuperClassPaint <br>// <br>#define DRAW_SENDERASEBACKGROUND        1 <br> <br>//=--------------------------------------------------------------------------= <br>// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use <br>// that as our Properties verb number.  Instead, we're going to define <br>// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs, <br>// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb. <br>// <br>#define CTLIVERB_PROPERTIES     1 <br> <br> <br>//=--------------------------------------------------------------------------= <br>// this structure is like the OLEVERB structure, except that it has a resource ID <br>// instead of a string for the verb's name.  better support for localization. <br>// <br>typedef struct tagVERBINFO { <br> <br>    LONG    lVerb;                // verb id <br>    ULONG   idVerbName;           // resource ID of verb name <br>    DWORD   fuFlags;              // verb flags <br>    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration. <br> <br>} VERBINFO; <br> <br>// describes an event <br>// <br>typedef struct tagEVENTINFO { <br> <br>    DISPID    dispid;                    // dispid of the event <br>    int       cParameters;               // number of arguments to the event <br>    VARTYPE  *rgTypes;                   // type of each argument <br> <br>} EVENTINFO; <br> <br>//=--------------------------------------------------------------------------= <br>// CONTROLOBJECTINFO <br>//=--------------------------------------------------------------------------= <br>// for each control you wish to expose to the programmer/user, you need to <br>// declare and define one of the following structures.  the first part should <br>// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard, <br>// however, to imagine a scenario where the control isn't CoCreatable ... <br>// once this structre is declared/defined, an entry should be put in the <br>// global g_ObjectInfo table. <br>// <br>typedef struct { <br> <br>    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information <br>    const IID      *piidEvents;                    // IID of primary event interface <br>    DWORD           dwOleMiscFlags;                // control flags <br>    DWORD           dwActivationPolicy;            // IPointerInactive support <br>    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque? <br>    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can? <br>    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap <br>    LPCSTR          szWndClass;                    // name of window control class <br>    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet? <br>    WORD            cPropPages;                    // number of property pages <br>    const GUID    **rgPropPageGuids;               // array of the property page GUIDs <br>    WORD            cCustomVerbs;                  // number of custom verbs <br>    const VERBINFO *rgCustomVerbs;                 // description of custom verbs <br>    WNDPROC         pfnSubClass;                   // for subclassed controls. <br> <br>} CONTROLOBJECTINFO; <br> <br> <br>#ifndef INITOBJECTS <br> <br>#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \ <br>extern CONTROLOBJECTINFO name##Control \ <br> <br>#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \ <br>extern CONTROLOBJECTINFO name##Control \ <br> <br> <br>#else <br>#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \ <br>CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \ <br> <br>#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \ <br>CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \ <br> <br>#endif // !INITOBJECTS <br> <br>#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;dwOleMiscFlags <br>#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;fWindowless <br>#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;fOpaque <br>#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;dwActivationPolicy <br>#define EVENTIIDOFCONTROL(index)         (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;piidEvents)) <br>#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;szWndClass <br>#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;cPropPages <br>#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;rgPropPageGuids <br>#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;cCustomVerbs <br>#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;rgCustomVerbs <br>#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;wToolboxId <br>#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;fWindowClassRegistered <br>#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;pfnSubClass <br> <br> <br>//=--------------------------------------------------------------------------= <br>// COleControl <br>//=--------------------------------------------------------------------------= <br>// the mother of all C++ objects <br>// <br>class COleControl : public CAutomationObject, <br>                    public IOleObject, public IOleControl, <br>                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject, <br>                    public IViewObjectEx, public IPersistPropertyBag, <br>                    public IPersistStreamInit, public IPersistStorage, <br>                    public IConnectionPointContainer, public ISpecifyPropertyPages, <br>                    public IProvideClassInfo, public IPointerInactive, <br>                    public IQuickActivate <br>{ <br>  public: <br>    // IUnknown methods -- there are required since we inherit from variuos <br>    // people who themselves inherit from IUnknown.  just delegate to controlling <br>    // unknown <br>    // <br>    DECLARE_STANDARD_UNKNOWN(); <br> <br>    //=--------------------------------------------------------------------------= <br>    // IPersist methods.  used by IPersistStream and IPersistStorage <br>    // <br>    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID); <br> <br>    // IPersistStreamInit methods <br>    // <br>    STDMETHOD(IsDirty)(THIS); <br>    STDMETHOD(Load)(LPSTREAM pStm); <br>    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty); <br>    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize); <br>    STDMETHOD(InitNew)(); <br> <br>    // IPersistStorage <br>    // <br>    STDMETHOD(InitNew)(IStorage  *pStg); <br>    STDMETHOD(Load)(IStorage  *pStg); <br>    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad); <br>    STDMETHOD(SaveCompleted)(IStorage  *pStgNew); <br>    STDMETHOD(HandsOffStorage)(void); <br> <br>    // IPersistPropertyBag <br>    // <br>    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog); <br>    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, <br>                    BOOL fSaveAllProperties); <br> <br>    // IOleControl methods <br>    // <br>    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI); <br>    STDMETHOD(OnMnemonic)(LPMSG pMsg); <br>    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid); <br>    STDMETHOD(FreezeEvents)(BOOL bFreeze); <br> <br>    // IOleObject methods <br>    // <br>    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite); <br>    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite); <br>    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj); <br>    STDMETHOD(Close)(DWORD dwSaveOption); <br>    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk); <br>    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk); <br>    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved); <br>    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject); <br>    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex, <br>                                     HWND hwndParent, LPCRECT lprcPosRect); <br>    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb); <br>    STDMETHOD(Update)(void); <br>    STDMETHOD(IsUpToDate)(void); <br>    STDMETHOD(GetUserClassID)(CLSID  *pClsid); <br>    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType); <br>    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel); <br>    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel); <br>    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection); <br>    STDMETHOD(Unadvise)(DWORD dwConnection); <br>    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise); <br>    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus); <br>    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal); <br> <br>    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject <br>    // <br>    STDMETHOD(GetWindow)(HWND *phwnd); <br>    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode); <br> <br>    // IOleInPlaceObject/IOleInPlaceObjectWindowless <br>    // <br>    STDMETHOD(InPlaceDeactivate)(void); <br>    STDMETHOD(UIDeactivate)(void); <br>    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ; <br>    STDMETHOD(ReactivateAndUndo)(void); <br>    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult); <br>    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget); <br> <br>    // IOleInPlaceActiveObject <br>    // <br>    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg); <br>    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate); <br>    STDMETHOD(OnDocWindowActivate)(BOOL fActivate); <br>    STDMETHOD(ResizeBorder)(LPCRECT prcBorder, <br>                            IOleInPlaceUIWindow  *pUIWindow, <br>                            BOOL fFrameWindow); <br>    STDMETHOD(EnableModeless)(BOOL fEnable); <br> <br>    // IViewObject2/IViewObjectEx <br>    // <br>    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect, <br>                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw, <br>                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds, <br>                    BOOL ( __stdcall  *pfnContinue )(DWORD dwContinue), <br>                    DWORD dwContinue); <br>    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect, <br>                           DVTARGETDEVICE  *ptd, HDC hicTargetDev, <br>                           LOGPALETTE  * *ppColorSet); <br>    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex, <br>                      void  *pvAspect,DWORD  *pdwFreeze); <br>    STDMETHOD(Unfreeze)(DWORD dwFreeze); <br>    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink); <br>    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink); <br>    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel); <br>    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect); <br>    STDMETHOD(GetViewStatus)(DWORD *pdwStatus); <br>    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult); <br>    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult); <br>    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel); <br> <br>    // IConnectionPointContainer methods <br>    // <br>    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum); <br>    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP); <br> <br>    // ISpecifyPropertyPages <br>    // <br>    STDMETHOD(GetPages)(CAUUID * pPages); <br> <br>    // IProvideClassInfo methods <br>    // <br>    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI); <br> <br>    // IPointerInactive methods <br>    // <br>    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy); <br>    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg); <br>    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways); <br> <br>    // IQuickActivate methods <br>    // <br>    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol); <br>    STDMETHOD(SetContentExtent)(LPSIZEL); <br>    STDMETHOD(GetContentExtent)(LPSIZEL); <br> <br>    // constructor and destructor <br>    // <br>    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface,  <br>BOOL fExpandoEnabled=FALSE); <br>    virtual ~COleControl(); <br> <br>    //=--------------------------------------------------------------------------= <br>    // callable by anybody <br>    // <br>    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp); <br>    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp); <br>    static COleControl * ControlFromHwnd(HWND hwnd) { <br>        return (COleControl *) GetWindowLong(hwnd, GWL_USERDATA); <br>    } <br> <br>    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...); <br>    HINSTANCE    GetResourceHandle(void); <br> <br> <br>    //=--------------------------------------------------------------------------= <br>    // ole controls that want to support both windowed and windowless operations <br>    // should use these wrappers instead of the appropriate win32 api routine. <br>    // controls that don't care and just want to be windowed all the time can <br>    // just go ahead and use the api routines. <br>    // <br>    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API <br>    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd <br>    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect <br>    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc <br>    HDC     OcxGetDC(void);                             // GetDC(m_hwnd); <br>    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc); <br>    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL); <br>    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd <br>    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f); <br>    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...); <br> <br>  protected: <br> <br>    //=--------------------------------------------------------------------------= <br>    // member variables that derived controls can get at. <br>    // <br>    // derived controls Should NOT modify the following. <br>    // <br>    IOleClientSite     *m_pClientSite;             // client site <br>    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site <br>    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation <br>    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site <br>    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client <br>    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site <br>    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer <br>    SIZEL               m_Size;                    // the size of this control     <br>    RECT                m_rcLocation;              // where we at <br>    HWND                m_hwnd;                    // our window <br>    HWND                m_hwndParent;              // our parent window <br>    HRGN                m_hRgn; <br> <br>    // Windowless OLE controls support <br>    // <br>    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer <br> <br>    // flags indicating internal state.  do not modify. <br>    // <br>    unsigned m_fDirty:1;                           // does the control need to be resaved? <br>    unsigned m_fInPlaceActive:1;                   // are we in place active or not? <br>    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not? <br>    unsigned m_fUIActive:1;                        // are we UI active or not. <br>    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not <br> <br>    //=--------------------------------------------------------------------------= <br>    // methods that derived controls can override, but may need to be called <br>    // from their versions. <br>    // <br>    virtual void      ViewChanged(void); <br>    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut); <br>    virtual BOOL      SetGUIFocus(HWND hwndSet); <br> <br>    //=--------------------------------------------------------------------------= <br>    // member functions that provide for derived controls, or that we use, but <br>    // derived controls might still find useful. <br>    // <br>    HRESULT      DoSuperClassPaint(HDC, LPCRECTL); <br>    HRESULT      RecreateControlWindow(void); <br>    BOOL         DesignMode(void); <br>    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *); <br>    BOOL         GetAmbientFont(IFont **ppFontOut); <br>    void         ModalDialog(BOOL fShow); <br>    void         InvalidateControl(LPCRECT prc);     <br>    BOOL         SetControlSize(SIZEL *pSizel); <br> <br>    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw); <br>    HRESULT      InPlaceActivate(LONG lVerb); <br>    void         SetInPlaceVisible(BOOL); <br>    void         SetInPlaceParent(HWND); <br> <br>    // IPropertyNotifySink stuff. <br>    // <br>    inline void  PropertyChanged(DISPID dispid) { <br>        m_cpPropNotify.DoOnChanged(dispid); <br>    } <br>    inline BOOL  RequestPropertyEdit(DISPID dispid) { <br>        return m_cpPropNotify.DoOnRequestEdit(dispid); <br>    } <br> <br>    // subclassed windows controls support ... <br>    // <br>    inline HWND  GetOuterWindow(void) { <br>        return (m_hwndReflect) ? m_hwndReflect : m_hwnd; <br>    } <br> <br>    // little routine for people to tell if they are windowless or not <br>    // <br>    inline BOOL  Windowless(void) { <br>        return !m_fInPlaceActive || m_pInPlaceSiteWndless; <br>    } <br> <br>    // some people don't care if they're windowed or not -- they just need <br>    // a site pointer.  this makes it a little easier. <br>    // <br>    inline IOleInPlaceSite    *GetInPlaceSite(void) { <br>        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite); <br>    } <br> <br>  private: <br>    //=--------------------------------------------------------------------------= <br>    // the following are methods that ALL control writers must override and implement <br>    // <br>    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE; <br>    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE; <br>    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE; <br>    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE; <br>    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE; <br>    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE; <br>    virtual BOOL    RegisterClassData(void) PURE; <br> <br>    //=--------------------------------------------------------------------------= <br>    // OVERRIDABLES -- methods controls can implement for customized functionality <br>    // <br>    virtual void    AmbientPropertyChanged(DISPID dispid); <br>    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR); <br>    virtual void    BeforeDestroyWindow(void); <br>    virtual HRESULT DoCustomVerb(LONG lVerb); <br>    virtual BOOL    OnSetExtent(const SIZEL *pSizeL); <br>    virtual BOOL    OnSpecialKey(LPMSG); <br>    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **); <br>    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *); <br>    virtual BOOL    InitializeNewState(); <br>    virtual BOOL    AfterCreateWindow(void); <br>    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect); <br>    virtual void    OnSetObjectRectsChangingWindowPos(DWORD *dwFlag); <br>    virtual void    OnVerb(LONG lVerb); <br> <br>    //=--------------------------------------------------------------------------= <br>    // methods that various people internally will share.  not needed, however, by <br>    // any inherting classes. <br>    // <br>    HRESULT         m_SaveToStream(IStream *pStream); <br>    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog); <br>    HRESULT         LoadStandardState(IStream *pStream); <br>    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag); <br>    HRESULT         SaveStandardState(IStream *pStream); <br> <br>    //=--------------------------------------------------------------------------= <br>    // member variables we don't want anybody to get their hands on, including <br>    // inheriting classes <br>    // <br>    HWND              m_hwndReflect;               // for subclassed windows <br>    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object <br>    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2 <br>    unsigned short    m_nFreezeEvents;             // count of freezes versus thaws <br>    unsigned          m_fHostReflects:1;           // does the host reflect messages? <br>    unsigned          m_fCheckedReflecting:1;      // have we checked above yet? <br> <br>    // internal flags.  various other flags are visible to the end control class. <br>    // <br>    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible <br>    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly? <br>    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise <br>    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise <br>    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping <br>    unsigned m_fRunMode:1;                         // are we in run mode or not? <br> <br>    class CConnectionPoint : public IConnectionPoint { <br>      public: <br>        IUnknown **m_rgSinks; <br> <br>        // IUnknown methods <br>        // <br>        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ; <br>        STDMETHOD_(ULONG,AddRef)(THIS) ; <br>        STDMETHOD_(ULONG,Release)(THIS) ; <br> <br>        // IConnectionPoint methods <br>        // <br>        STDMETHOD(GetConnectionInterface)(IID FAR* pIID); <br>        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC); <br>        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie); <br>        STDMETHOD(Unadvise)(DWORD dwCookie); <br>        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum); <br> <br>        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam); <br>        void    DoOnChanged(DISPID dispid); <br>        BOOL    DoOnRequestEdit(DISPID dispid); <br>        HRESULT AddSink(void *, DWORD *); <br> <br>        COleControl *m_pOleControl(); <br>        CConnectionPoint(BYTE b){ <br>            m_bType = b; <br>            m_rgSinks = NULL; <br>            m_cSinks = 0; <br>        } <br>        ~CConnectionPoint(); <br> <br>      private: <br>        BYTE   m_bType; <br>        short  m_cSinks; <br> <br>    } m_cpEvents, m_cpPropNotify; <br> <br>    // so they can get at some of our protected things, like AddRef, QI, etc. <br>    // <br>    friend CConnectionPoint; <br>}; <br> <br>#define _CTRLOBJ_H_ <br>#endif // _CTRLOBJ_H_ </code></pre>
<p>&nbsp;</p></body>
</HTML>
