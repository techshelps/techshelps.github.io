<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXTOBJ.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context108"></a>EXTOBJ.H</h2>
<pre><code>#ifndef __EXTOBJ_H <br>#define __EXTOBJ_H <br>//// <br>// <br>// ExpandoObject header file <br>// <br>// <br>// <br>#include "IPServer.H" <br> <br>//// <br>// <br>// IDispatchEx <br>// <br>//// <br> <br>//// <br>// <br>// the GUID <br>// <br> <br>// {A0AAC450-A77B-11cf-91D0-00AA00C14A7C} <br>DEFINE_GUID(IID_IDispatchEx, 0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c); <br> <br>//// <br>// <br>// IDispatchEx flags: <br>// <br> <br>enum <br>{ <br>fdexNil = 0x00,// empty <br>fdexDontCreate = 0x01,// don't create slot if non-existant otherwise do <br>fdexInitNull = 0x02,// init a new slot to VT_NULL as opposed to VT_EMPTY <br>fdexCaseSensitive = 0x04,// match names as case sensitive <br>}; <br> <br>//// <br>// <br>// This is the interface for extensible IDispatch objects. <br>// <br> <br>class IDispatchEx : public IDispatch <br>{ <br>public: <br>// Get dispID for names, with options <br>virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx( <br>REFIID riid, <br>LPOLESTR *prgpsz, <br>UINT cpsz, <br>LCID lcid, <br>DISPID *prgid, <br>DWORD grfdex <br>) = 0; <br> <br>// Enumerate dispIDs and their associated "names". <br>// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an <br>// error code if the call fails. <br>virtual HRESULT STDMETHODCALLTYPE GetNextDispID( <br>DISPID id, <br>DISPID *pid, <br>BSTR *pbstrName <br>) = 0; <br>}; <br> <br>//// <br>// <br>// Globals and definitions <br>// <br>//// <br> <br>#define NUM_EXPANDO_DISPIDS250 <br>#defineNUM_CORE_DISPIDS250 <br>#define NUM_RESERVED_EXTENDER_DISPIDS (NUM_CORE_DISPIDS + NUM_EXPANDO_DISPIDS) <br>#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000)) <br>#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) &amp; 0xFFFF0000 ) == EXTENDER_DISPID_BASE ) <br> <br>//// <br>// <br>// Slot: the state of a value slot <br>// <br> <br>inline WCHAR ToUpper(WCHAR ch)    <br>{ <br>if (ch&gt;='a' &amp;&amp; ch &lt;= 'z')   <br>return ch - 'a' + 'A'; <br>else <br>return ch; <br> <br>} <br> <br>class CExpandoObjectSlot <br>{ <br>public: <br>//// <br>// <br>// Constructor/Destructor <br>// <br> <br>// because these monsters are malloc'ed, we need a manual constructor and destructor methods <br>void Construct() <br>{ <br>m_name = NULL; <br>m_next = -1; <br>VariantInit(&amp;m_value); <br>// set hash and dispId to dummy values <br>m_hash = 0; <br>m_dispId = DISPID_UNKNOWN; <br>} <br> <br>void Destruct() <br>{ <br>if (m_name) <br>SysFreeString(m_name); <br>VariantClear(&amp;m_value); <br>} <br> <br>private: <br>// the constructors and destructors are private because they should never be called ... <br>// we could use in-place construction if we wanted to be clever ... <br>CExpandoObjectSlot() <br>{ <br>} <br> <br>~CExpandoObjectSlot() <br>{ <br>} <br> <br>public: <br>//// <br>// <br>// Init the slot <br>// <br> <br>HRESULT Init(LPOLESTR name, LCID lcid, DISPID dispId, VARIANT* value) <br>{ <br>// allocate the string <br>m_name = SysAllocString(name); <br>if (m_name == NULL) <br>return E_OUTOFMEMORY; <br> <br>// compute the hash: uses the standard OLE string hashing function <br>// note that this function is case insensitive <br>m_hash = LHashValOfName(lcid, name); <br> <br>// set the dispId <br>m_dispId = dispId; <br> <br>// Copy the variant value <br>return VariantCopy(&amp;m_value, value); <br>} <br> <br>//// <br>// <br>// Name information <br>// <br> <br>// get the name <br>BSTR Name() <br>{ return m_name; } <br> <br>// compare two names <br>BOOL CompareName(LPOLESTR name, ULONG hash, BOOL caseSensitive) <br>{ <br>// hash should be the same, length should be the same, and strings should compare <br>// BUGBUG robwell 8May96 These functions are probably verboten. <br>if (hash != m_hash) <br>return FALSE; <br> <br>if (!name) <br>return !m_name; <br> <br>WCHAR *c1 = name; <br>WCHAR *c2 = m_name; <br> <br>// Travel down both strings until we reach a mismatched character <br>// or the end of one (or both) of the strings <br> <br>if (caseSensitive) <br>while (*c1 &amp;&amp; *c2 &amp;&amp; *c1++==*c2++); <br>else <br>while (*c1 &amp;&amp; *c2 &amp;&amp; ToUpper(*c1++)==ToUpper(*c2++)); <br> <br>// The strings match if we reached the end of both without a mismatch <br>return !*c1 &amp;&amp; !*c2; <br> } <br> <br>//// <br>// <br>// DispId information <br>// <br> <br>// get the dispatch id <br>DISPID DispId() <br>{ return m_dispId; } <br> <br>//// <br>// <br>// Get and set the property values <br>// <br> <br>HRESULT Get(VARIANT* result) <br>{ return VariantCopy(result, &amp;m_value); } <br> <br>HRESULT Set(VARIANT* value) <br>{ return VariantCopy(&amp;m_value, value); } <br> <br>//// <br>// <br>// List management <br>// <br> <br>CExpandoObjectSlot* Next(CExpandoObjectSlot* base) <br>{ return m_next == -1? NULL: &amp;base[m_next]; } <br> <br>CExpandoObjectSlot* Insert(CExpandoObjectSlot* base, LONG&amp; prev) <br>{ <br>m_next = prev; <br>prev = this - base; <br>return this; <br>} <br> <br>private: <br>// the DispId <br>DISPIDm_dispId; <br>// the name <br>LPOLESTRm_name; <br>// the name hash <br>ULONGm_hash; <br>// the property value <br>VARIANTm_value; <br>// the hash bucket link (index based) <br>LONGm_next; <br>}; <br> <br>// NB: CExpandoObject implements a crippled version of aggegation. <br>// It delegates all IUnknown calls to its controlling IUnknown, and has no <br>// private IUnknown interface. <br>// If you want the CExpandoObject to go away, simply call delete on it. <br>class CExpandoObject: public IDispatchEx <br>{ <br>public: <br> <br>//// <br>// <br>// Constructor/Destructor <br>// <br> <br>CExpandoObject(IUnknown *punkOuter, IDispatch *pdisp, ULONG dispIdBase = EXTENDER_DISPID_BASE + NUM_CORE_DISPIDS)  <br>{ <br>// remember our controlling outer <br>m_punkOuter = punkOuter; <br> <br>// remember the IDispatch to try first for IDispatch functionality <br>m_pdisp = pdisp; <br> <br>// clear the name hash table <br>ClearHashTable(); <br>// set the total slots and the table of slots to 0 and empty respectively) <br>m_totalSlots = 0; <br>m_slotTableSize = 0; <br>m_slots = NULL; <br>m_dispIdBase = dispIdBase; <br>} <br> <br>STDMETHODIMP_(ULONG) AddRef() <br>{ <br>return m_punkOuter-&gt;AddRef(); <br>} <br> <br>STDMETHODIMP_(ULONG)Release() <br>{ <br>return m_punkOuter-&gt;Release(); <br>} <br> <br>    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObjOut) <br>{ <br>return m_punkOuter-&gt;QueryInterface(riid, ppvObjOut); <br>} <br> <br>    virtual ~CExpandoObject(void) <br>{ <br>FreeAllSlots(); <br>} <br> <br> <br>    // Copy all of the properties from obj  <br>   CloneProperties(CExpandoObject&amp; obj); <br> <br>//// <br>// <br>// <br>// Utility functions <br>// <br> <br>// free all slots <br>void FreeAllSlots(); <br> <br>// IDispatch methods <br>virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo); <br>virtual HRESULT STDMETHODCALLTYPE GetTypeInfo( <br>UINT itinfo, <br>LCID lcid, <br>ITypeInfo **pptinfo <br>); <br>virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames( <br>REFIID riid, <br>LPOLESTR *prgpsz, <br>UINT cpsz, <br>LCID lcid, <br>DISPID *prgdispID <br>); <br>virtual HRESULT STDMETHODCALLTYPE Invoke( <br>DISPID dispID, <br>REFIID riid, <br>LCID lcid, <br>WORD wFlags, <br>DISPPARAMS *pdispparams, <br>VARIANT *pvarRes, <br>EXCEPINFO *pexcepinfo, <br>UINT *puArgErr <br>); <br> <br>// IDispatchEx methods <br> <br>// Get dispID for names, with options <br>virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx( <br>REFIID riid, <br>LPOLESTR *prgpsz, <br>UINT cpsz, <br>LCID lcid, <br>DISPID *prgid, <br>DWORD grfdex <br>); <br> <br>// Enumerate dispIDs and their associated "names". <br>// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an <br>// error code if the call fails. <br>virtual HRESULT STDMETHODCALLTYPE GetNextDispID( <br>DISPID id, <br>DISPID *pid, <br>BSTR *pbstrName <br>); <br> <br>private: <br>//// <br>// <br>// Implementation constants <br>// <br> <br>enum <br>{ <br>kSlotHashTableSize = 10, <br>kInitialSlotTableSize = 4, <br>kMaxTotalSlots = NUM_EXPANDO_DISPIDS <br>}; <br> <br>//// <br>// <br>// Utility functions <br>// <br> <br>// <br>CExpandoObjectSlot* GetHashTableHead(UINT hashIndex) <br>{ <br>LONG index; <br> <br>return (index = m_hashTable[hashIndex]) == -1? NULL: &amp;m_slots[index]; <br>} <br> <br>// get the ID of from a slot name <br>HRESULT GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id); <br>// add a slot to the object <br>HRESULT AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id); <br>// allocate a slot from the slot table <br>CExpandoObjectSlot* AllocSlot(); <br>// clear the hash table <br>void ClearHashTable() <br>{ <br>UINT i; <br> <br>for (i=0; i&lt;kSlotHashTableSize; ++i) <br>m_hashTable[i] = -1; <br>} <br> <br>//// <br>// <br>// Slot operations <br>// <br>// DISPIDS start at kInitialDispId so we need to offset them by that amount <br>// in this code. <br>// <br> <br>HRESULT GetSlot(DISPID id, VARIANT* result) <br>{ <br>if ((ULONG) id &lt; m_dispIdBase || (ULONG) id &gt;= (m_totalSlots+m_dispIdBase)) <br>return DISP_E_MEMBERNOTFOUND; <br> <br>return m_slots[id-m_dispIdBase].Get(result); <br>} <br> <br>HRESULT SetSlot(DISPID id, VARIANT* result) <br>{ <br>if ((ULONG) id &lt; m_dispIdBase || (ULONG) id &gt;= (m_totalSlots+m_dispIdBase)) <br>return DISP_E_MEMBERNOTFOUND; <br> <br>return m_slots[id-m_dispIdBase].Set(result); <br>} <br> <br>//// <br>// <br>// Iteration operations <br>// <br> <br>UINTNumDispIds() <br>{ return m_totalSlots; } <br> <br>DISPIDFirst() <br>{ return m_dispIdBase; } <br> <br>DISPIDLast() <br>{ return m_totalSlots + m_dispIdBase - 1; } <br> <br>BOOLValidDispId(DISPID id) <br>{ return id &gt;= First() &amp;&amp; id &lt;= Last(); } <br> <br>HRESULTNext(DISPID key, CExpandoObjectSlot*&amp; slot) <br>{ <br>// zero restarts the enumerator <br>if (key == 0) <br>{ <br>// if there are no slots we are done <br>if (NumDispIds() == 0) <br>return S_FALSE; <br> <br>// return the first slot <br>slot = &amp;m_slots[0]; <br>return NOERROR; <br>} <br>else <br>if (key == Last()) <br>{ <br>// the key was the last slot so we are done <br>return S_FALSE; <br>} <br>else <br>if (ValidDispId(key)) <br>{ <br>// return the next slot <br>slot = &amp;m_slots[key-m_dispIdBase+1]; <br>return NOERROR; <br>} <br>else <br>// the key must be invalid <br>return E_INVALIDARG; <br>} <br> <br>//// <br>// <br>// The local state of the object <br>// <br> <br>// the objects reference count <br>ULONGm_ref; <br> <br>// the base of objectIds <br>ULONGm_dispIdBase; <br> <br>// the hash table of slots - for fast GetIDSofNames lookup <br>LONGm_hashTable[kSlotHashTableSize]; <br> <br>// the number of slots (and the next dispId to allocate) <br>UINTm_totalSlots; <br> <br>// the size of the allocated array of slots <br>UINTm_slotTableSize; <br> <br>// a pointer to the allocated array of slots <br>CExpandoObjectSlot* m_slots; <br> <br>// controlling unknown <br>IUnknown *m_punkOuter; <br> <br>// controlling IDispatch <br>IDispatch *m_pdisp; <br>}; <br> <br>#endif // __EXTOBJ_H </code></pre>
<p>&nbsp;</p></body>
</HTML>
