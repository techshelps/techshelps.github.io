<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROPPAGE.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context100"></a>PROPPAGE.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// PropPage.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of CPropertyPage object. <br>// <br>#include "IPServer.H" <br>#include "PropPage.H" <br>#include "Util.H" <br>#include "Globals.H" <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>// this variable is used to pass the pointer to the object to the hwnd. <br>// <br>static CPropertyPage *s_pLastPageCreated; <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::CPropertyPage <br>//=--------------------------------------------------------------------------= <br>// constructor. <br>// <br>// Parameters: <br>//    IUnknown *          - [in] controlling unknown <br>//    int                 - [in] object type. <br>// <br>// Notes: <br>// <br>#pragma warning(disable:4355)  // using 'this' in constructor <br>CPropertyPage::CPropertyPage <br>( <br>    IUnknown         *pUnkOuter, <br>    int               iObjectType <br>) <br>: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType) <br>{ <br>    // initialize various dudes. <br>    // <br>    m_pPropertyPageSite = NULL; <br>    m_hwnd = NULL; <br>    m_fDirty = FALSE; <br>    m_fActivated = FALSE; <br>    m_cObjects = 0; <br>} <br>#pragma warning(default:4355)  // using 'this' in constructor <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::~CPropertyPage <br>//=--------------------------------------------------------------------------= <br>// destructor. <br>// <br>// Notes: <br>// <br>CPropertyPage::~CPropertyPage() <br>{ <br>    // clean up our window. <br>    // <br>    if (m_hwnd) { <br>        SetWindowLong(m_hwnd, GWL_USERDATA, 0xffffffff); <br>        DestroyWindow(m_hwnd); <br>    } <br> <br>    // release all the objects we're holding on to. <br>    // <br>    m_ReleaseAllObjects(); <br> <br>    // release the site <br>    // <br>    QUICK_RELEASE(m_pPropertyPageSite); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// we support IPP and IPP2. <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CPropertyPage::InternalQueryInterface <br>( <br>    REFIID  riid, <br>    void  **ppvObjOut <br>) <br>{ <br>    IUnknown *pUnk; <br> <br>    *ppvObjOut = NULL; <br> <br>    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) { <br>        pUnk = (IUnknown *)this; <br>    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) { <br>        pUnk = (IUnknown *)this; <br>    } else { <br>        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut); <br>    } <br> <br>    pUnk-&gt;AddRef(); <br>    *ppvObjOut = (void *)pUnk; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::SetPageSite    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// the initialization function for a property page through which the page <br>// receives an IPropertyPageSite pointer. <br>// <br>// Parameters: <br>//    IPropertyPageSite *        - [in] new site. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes; <br>// <br>STDMETHODIMP CPropertyPage::SetPageSite <br>( <br>    IPropertyPageSite *pPropertyPageSite <br>) <br>{ <br>    RELEASE_OBJECT(m_pPropertyPageSite); <br>    m_pPropertyPageSite = pPropertyPageSite; <br>    ADDREF_OBJECT(pPropertyPageSite); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Activate    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// instructs the page to create it's display window as a child of hwndparent <br>// and to position it according to prc. <br>// <br>// Parameters: <br>//    HWND                - [in]  parent window <br>//    LPCRECT             - [in]  where to position ourselves <br>//    BOOL                - [in]  whether we're modal or not. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Activate <br>( <br>    HWND    hwndParent, <br>    LPCRECT prcBounds, <br>    BOOL    fModal <br>) <br>{ <br>    HRESULT hr; <br> <br>    // first make sure the dialog window is loaded and created. <br>    // <br>    hr = m_EnsureLoaded(); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // set our parent window if we haven't done so yet. <br>    // <br>    if (!m_fActivated) { <br>        SetParent(m_hwnd, hwndParent); <br>        m_fActivated = TRUE; <br>    } <br> <br>    // now move ourselves to where we're told to be and show ourselves <br>    // <br>    Move(prcBounds); <br>    ShowWindow(m_hwnd, SW_SHOW); <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Deactivate    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// instructs the page to destroy the window created in activate <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Deactivate <br>( <br>    void <br>) <br>{ <br>    // blow away yon window. <br>    // <br>    if (m_hwnd) <br>        DestroyWindow(m_hwnd); <br>    m_hwnd = NULL; <br>    m_fActivated = FALSE; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::GetPageInfo    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// asks the page to fill a PROPPAGEINFO structure <br>// <br>// Parameters: <br>//    PROPPAGEINFO *    - [out] where to put info. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::GetPageInfo <br>( <br>    PROPPAGEINFO *pPropPageInfo <br>) <br>{ <br>    RECT rect; <br> <br>    CHECK_POINTER(pPropPageInfo); <br> <br>    m_EnsureLoaded(); <br> <br>    // clear it out first. <br>    // <br>    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO)); <br> <br>    pPropPageInfo-&gt;pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType)); <br>    pPropPageInfo-&gt;pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType)); <br>    pPropPageInfo-&gt;pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType)); <br>    pPropPageInfo-&gt;dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType); <br> <br>    if (!(pPropPageInfo-&gt;pszTitle &amp;&amp; pPropPageInfo-&gt;pszDocString &amp;&amp; pPropPageInfo-&gt;pszHelpFile)) <br>        goto CleanUp; <br> <br>    // if we've got a window yet, go and set up the size information they want. <br>    // <br>    if (m_hwnd) { <br>        GetWindowRect(m_hwnd, &amp;rect); <br> <br>        pPropPageInfo-&gt;size.cx = rect.right - rect.left; <br>        pPropPageInfo-&gt;size.cy = rect.bottom - rect.top; <br>    } <br> <br>    return S_OK; <br> <br>  CleanUp: <br>    if (pPropPageInfo-&gt;pszDocString) CoTaskMemFree(pPropPageInfo-&gt;pszDocString); <br>    if (pPropPageInfo-&gt;pszHelpFile) CoTaskMemFree(pPropPageInfo-&gt;pszHelpFile); <br>    if (pPropPageInfo-&gt;pszTitle) CoTaskMemFree(pPropPageInfo-&gt;pszTitle); <br> <br>    return E_OUTOFMEMORY; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::SetObjects    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// provides the page with the objects being affected by the changes. <br>// <br>// Parameters: <br>//    ULONG            - [in] count of objects. <br>//    IUnknown **      - [in] objects. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::SetObjects <br>( <br>    ULONG      cObjects, <br>    IUnknown **ppUnkObjects <br>) <br>{ <br>    HRESULT hr; <br>    ULONG   x; <br> <br>    // free up all the old objects first. <br>    // <br>    m_ReleaseAllObjects(); <br> <br>    if (!cObjects) <br>        return S_OK; <br> <br>    // now go and set up the new ones. <br>    // <br>    m_ppUnkObjects = (IUnknown **)HeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *)); <br>    RETURN_ON_NULLALLOC(m_ppUnkObjects); <br> <br>    // loop through and copy over all the objects. <br>    // <br>    for (x = 0; x &lt; cObjects; x++) { <br>        m_ppUnkObjects[x] = ppUnkObjects[x]; <br>        ADDREF_OBJECT(m_ppUnkObjects[x]); <br>    } <br> <br>    // go and tell the object that there are new objects <br>    // <br>    hr = S_OK; <br>    m_cObjects = cObjects; <br>    // if we've got a window, go and notify it that we've got new objects. <br>    // <br>    if (m_hwnd) <br>        SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&amp;hr); <br>    if (SUCCEEDED(hr)) m_fDirty = FALSE; <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Show    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// asks the page to show or hide its window <br>// <br>// Parameters: <br>//    UINT             - [in] whether to show or hide <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Show <br>( <br>    UINT nCmdShow <br>) <br>{ <br>    if (m_hwnd) <br>        ShowWindow(m_hwnd, nCmdShow); <br>    else <br>        return E_UNEXPECTED; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Move    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// asks the page to relocate and resize itself to a position other than what <br>// was specified through Activate <br>// <br>// Parameters: <br>//    LPCRECT        - [in] new position and size <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Move <br>( <br>    LPCRECT prcBounds <br>) <br>{ <br>    // do what they sez <br>    // <br>    if (m_hwnd) <br>        SetWindowPos(m_hwnd, NULL, prcBounds-&gt;left, prcBounds-&gt;top, <br>                     prcBounds-&gt;right - prcBounds-&gt;left, <br>                     prcBounds-&gt;bottom - prcBounds-&gt;top, <br>                     SWP_NOZORDER); <br>    else <br>        return E_UNEXPECTED; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::IsPageDirty    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// asks the page whether it has changed its state <br>// <br>// Output <br>//    S_OK            - yep <br>//    S_FALSE         - nope <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::IsPageDirty <br>( <br>    void <br>) <br>{ <br>    return m_fDirty ? S_OK : S_FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Apply    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// instructs the page to send its changes to all the objects passed through <br>// SetObjects() <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Apply <br>( <br>    void <br>) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    if (m_hwnd) { <br>        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&amp;hr); <br>        RETURN_ON_FAILURE(hr); <br> <br>        if (m_fDirty) { <br>            m_fDirty = FALSE; <br>            if (m_pPropertyPageSite) <br>                m_pPropertyPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY); <br>        } <br>    } else <br>        return E_UNEXPECTED; <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::Help    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// instructs the page that the help button was clicked. <br>// <br>// Parameters: <br>//    LPCOLESTR        - [in] help directory <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::Help <br>( <br>    LPCOLESTR pszHelpDir <br>) <br>{ <br>    BOOL f; <br> <br>    ASSERT(m_hwnd, "How can somebody have clicked Help, but we don't have an hwnd?"); <br> <br>    // oblige them and show the help. <br>    // <br>    MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir); <br>    f = WinHelp(m_hwnd, psz, HELP_CONTEXT, HELPCONTEXTOFPROPPAGE(m_ObjectType)); <br> <br>    return f ? S_OK : E_FAIL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::TranslateAccelerator    [IPropertyPage] <br>//=--------------------------------------------------------------------------= <br>// informs the page of keyboard events, allowing it to implement it's own <br>// keyboard interface. <br>// <br>// Parameters: <br>//    LPMSG            - [in] message that triggered this <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::TranslateAccelerator <br>( <br>    LPMSG pmsg <br>) <br>{ <br>    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?"); <br> <br>    // just pass this message on to the dialog proc and see if they want it. <br>    // <br>    return IsDialogMessage(m_hwnd, pmsg) ? S_OK : S_FALSE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::EditProperty    [IPropertyPage2] <br>//=--------------------------------------------------------------------------= <br>// instructs the page to set the focus to the property matching the dispid. <br>// <br>// Parameters: <br>//    DISPID            - [in] dispid of property to set focus to. <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDMETHODIMP CPropertyPage::EditProperty <br>( <br>    DISPID dispid <br>) <br>{ <br>    HRESULT hr = E_NOTIMPL; <br> <br>    // send the message on to the control, and see what they want to do with it. <br>    // <br>    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&amp;hr); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::m_EnsureLoaded <br>//=--------------------------------------------------------------------------= <br>// makes sure the dialog is actually loaded <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>HRESULT CPropertyPage::m_EnsureLoaded <br>( <br>    void <br>) <br>{ <br>    HRESULT hr = S_OK; <br> <br>    // duh <br>    // <br>    if (m_hwnd) <br>        return S_OK; <br> <br>    // set up the global variable so that when we're in the dialog proc, we can <br>    // stuff this in the hwnd <br>    // <br>    // crit sect this whole creation process for apartment threading support. <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    s_pLastPageCreated = this; <br> <br>    // create the dialog window <br>    // <br>    CreateDialog(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), GetParkingWindow(), <br>                          (DLGPROC)CPropertyPage::PropPageDlgProc); <br>    ASSERT(m_hwnd, "Couldn't load Dialog Resource!!!"); <br>    if (!m_hwnd) { <br>        LeaveCriticalSection(&amp;g_CriticalSection); <br>        return HRESULT_FROM_WIN32(GetLastError()); <br>    } <br> <br>    // clean up variables and leave the critical section <br>    // <br>    s_pLastPageCreated = NULL; <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    // go and notify the window that it should pick up any objects that are <br>    // available <br>    // <br>    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&amp;hr); <br> <br>    return hr; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::m_ReleaseAllObjects <br>//=--------------------------------------------------------------------------= <br>// releases all the objects that we're working with <br>// <br>// Notes: <br>// <br>void CPropertyPage::m_ReleaseAllObjects <br>( <br>    void <br>) <br>{ <br>    HRESULT hr; <br>    UINT x; <br> <br>    if (!m_cObjects) <br>        return; <br> <br>    // some people will want to stash pointers in the PPM_INITOBJECTS case, so <br>    // we want to tell them to release them now. <br>    // <br>    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&amp;hr); <br> <br>    // loop through and blow them all away. <br>    // <br>    for (x = 0; x &lt; m_cObjects; x++) <br>        QUICK_RELEASE(m_ppUnkObjects[x]); <br> <br>    HeapFree(g_hHeap, 0, m_ppUnkObjects); <br>    m_ppUnkObjects = NULL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::PropPageDlgProc <br>//=--------------------------------------------------------------------------= <br>// static global helper dialog proc that gets called before we pass the message <br>// on to anybody .. <br>// <br>// Parameters: <br>//    - see win32sdk docs on DialogProc <br>// <br>// Notes: <br>// <br>BOOL CALLBACK CPropertyPage::PropPageDlgProc <br>( <br>    HWND    hwnd, <br>    UINT    msg, <br>    WPARAM  wParam, <br>    LPARAM  lParam <br>) <br>{ <br>    CPropertyPage *pPropertyPage; <br> <br>    // get the window long, and see if it's been set to the object this hwnd <br>    // is operating against.  if not, go and set it now. <br>    // <br>    pPropertyPage = (CPropertyPage *)GetWindowLong(hwnd, GWL_USERDATA); <br>    if ((ULONG)pPropertyPage == 0xffffffff) <br>        return FALSE; <br>    if (!pPropertyPage) { <br>        SetWindowLong(hwnd, GWL_USERDATA, (LONG)s_pLastPageCreated); <br>        pPropertyPage = s_pLastPageCreated; <br>        pPropertyPage-&gt;m_hwnd = hwnd; <br>    } <br> <br>    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!"); <br> <br>    // just call the user dialog proc and see if they want to do anything. <br>    // <br>    return pPropertyPage-&gt;DialogProc(hwnd, msg, wParam, lParam); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::FirstControl <br>//=--------------------------------------------------------------------------= <br>// returns the first controlish object that we are showing ourselves for. <br>// returns a cookie that must be passed in for Next ... <br>// <br>// Parameters: <br>//    DWORD *    - [out] cookie to be used for Next <br>// <br>// Output: <br>//    IUnknown * <br>// <br>// Notes: <br>// <br>IUnknown *CPropertyPage::FirstControl <br>( <br>    DWORD *pdwCookie <br>) <br>{ <br>    // just use the implementation of NEXT. <br>    // <br>    *pdwCookie = 0; <br>    return NextControl(pdwCookie); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::NextControl <br>//=--------------------------------------------------------------------------= <br>// returns the next control in the chain of people to work with given a cookie <br>// <br>// Parameters: <br>//    DWORD *            - [in/out] cookie to get next from, and new cookie. <br>// <br>// Output: <br>//    IUnknown * <br>// <br>// Notes: <br>// <br>IUnknown *CPropertyPage::NextControl <br>( <br>    DWORD *pdwCookie <br>) <br>{ <br>    UINT      i; <br> <br>    // go looking through all the objects that we've got, and find the <br>    // first non-null one. <br>    // <br>    for (i = *pdwCookie; i &lt; m_cObjects; i++) { <br>        if (!m_ppUnkObjects[i]) continue; <br> <br>        *pdwCookie = i + 1;                // + 1 so we start at next item next time <br>        return m_ppUnkObjects[i]; <br>    } <br> <br>    // couldn't find it . <br>    // <br>    *pdwCookie = 0xffffffff; <br>    return NULL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::MakeDirty    [helper, callable] <br>//=--------------------------------------------------------------------------= <br>// marks a page as dirty. <br>// <br>// Notes: <br>// <br>void CPropertyPage::MakeDirty <br>( <br>    void <br>) <br>{ <br>    m_fDirty = TRUE; <br>    if (m_pPropertyPageSite) <br>        m_pPropertyPageSite-&gt;OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE); <br>} <br> <br> <br>// from Globals.C <br>// <br>extern HINSTANCE g_hInstResources; <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CPropertyPage::GetResourceHandle    [helper, callable] <br>//=--------------------------------------------------------------------------= <br>// returns current resource handle, based on pagesites ambient LCID. <br>// <br>// Output: <br>//    HINSTANCE <br>// <br>// Notes: <br>// <br>HINSTANCE CPropertyPage::GetResourceHandle <br>( <br>    void <br>) <br>{ <br>    if (!g_fSatelliteLocalization) <br>        return g_hInstance; <br> <br>    // if we've already got it, then there's not all that much to do. <br>    // don't need to crit sect this one right here since even if they do fall <br>    // into the ::GetResourceHandle call, it'll properly deal with things. <br>    // <br>    if (g_hInstResources) <br>        return g_hInstResources; <br> <br>    // we'll get the ambient localeid from the host, and pass that on to the <br>    // automation object. <br>    // <br>    // enter a critical section for g_lcidLocale and g_fHavelocale <br>    // <br>    EnterCriticalSection(&amp;g_CriticalSection); <br>    if (!g_fHaveLocale) { <br>        if (m_pPropertyPageSite) { <br>            m_pPropertyPageSite-&gt;GetLocaleID(&amp;g_lcidLocale); <br>            g_fHaveLocale = TRUE; <br>        } <br>    } <br>    LeaveCriticalSection(&amp;g_CriticalSection); <br> <br>    return ::GetResourceHandle(); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
