<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDOCOBJ.H</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context120"></a>CDOCOBJ.H</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CDocObj.H <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// class declaration for the document object server class. <br>// <br>#ifndef __CDOCOBJ_H_ <br>#define __CDOCOBJ_H_ <br> <br>#ifndef __MKTYPLIB__ <br> <br>#include &lt;IPServer.H&gt; <br>#include &lt;internet.h&gt; <br> <br>//=--------------------------------------------------------------------------= <br>// DOCOBJECTINFO <br>//=--------------------------------------------------------------------------= <br>// for each DocObject you wish to expose to the programmer/user, you need to <br>// declare and define one of the following structures.  the first part should <br>// follow the rules of the CONTROLOBJECTINFO structure.   <br>// once this structre is declared/defined, an entry should be put in the <br>// global g_ObjectInfo table. <br>// <br>typedef struct { <br>    CONTROLOBJECTINFO ControlInfo;            // control, automation and creation information <br>DWORD             dwMiscDocObj;    // value of DocObject subkey <br>BOOL              bPrint;    // IPrint interface supported <br>UINT      nIDszExt;    // resource ID of default file extension <br>UINT              nIDszFileDescription; // resource ID of file description  <br>} DOCOBJECTINFO; <br> <br>#ifndef INITOBJECTS <br> <br>#define DEFINE_DOCOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, dwmisc, bprint, nidext, niddesc) \ <br>extern DOCOBJECTINFO name##DocObj \ <br> <br>#else <br>#define DEFINE_DOCOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv, dwmisc, bprint, nidext, niddesc) \ <br>DOCOBJECTINFO name##DocObj = { { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL }, dwmisc, bprint, nidext, niddesc }\ <br> <br> <br>#endif // !INITOBJECTS <br> <br>#define MISCFLAGSOFDOCOBJECT(index)         ((DOCOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;dwMiscDocObj <br>#define PRINTOFDOCOBJECT(index)             ((DOCOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;bPrint <br>#define DEFAULTEXTIDOFDOCOBJECT(index)      ((DOCOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;nIDszExt <br>#define FILEDESCRIPTIONIDOFDOCOBJECT(index) ((DOCOBJECTINFO *)(g_ObjectInfo[index].pInfo))-&gt;nIDszFileDescription <br> <br> <br>// this is the macros you should use to fill in the table.  Note that the name <br>// must be exactly the same as that used in the global structure you created <br>// for this object. <br>// <br>// if we were adding docobj support right into the framework, we would <br>// put this definition in localobj.h, and instead of using the OI_CONTROL <br>// type, we would define a new type (eg OI_DOCOBJ).  <br>// <br>#define DOCOBJECT(name)    { OI_CONTROL,      (void *)&amp;(name##DocObj) } <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject <br>//=--------------------------------------------------------------------------= <br>// <br>// if you don't want internet-aware support, change BASECLASS to COleControl <br>// <br>#define BASECLASS   CInternetControl <br> <br>class CDocumentObject : public BASECLASS, public IOleDocument, public IOleDocumentView <br>{ <br>public: <br>    // constructor and destructor <br>    // <br>    CDocumentObject(IUnknown* pUnkOuter, int iPrimaryDispatch, void* pMainInterface); <br>    virtual ~CDocumentObject(); <br> <br>    // IUnknown methods <br>    // <br>    DECLARE_STANDARD_UNKNOWN(); <br> <br>    // IOleObject method overrides for DocObject support <br>    STDMETHOD(SetClientSite)(IOleClientSite* pClientSite); <br>    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex, <br>                                     HWND hwndParent, LPCRECT lprcPosRect); <br>    STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel); <br>    STDMETHOD(Unadvise)(DWORD dwConnection); <br> <br>    // IOleDocument -- required DocObject server interface <br>    // <br>    STDMETHOD(CreateView)(IOleInPlaceSite* pIPSite, IStream* pstm, <br>                          DWORD dwReserved, IOleDocumentView** ppView); <br>    STDMETHOD(GetDocMiscStatus)(DWORD* pdwStatus); <br>    STDMETHOD(EnumViews)(IEnumOleDocumentViews** ppEnum, IOleDocumentView** ppView); <br>     <br>    // IOleDocumentView -- required DocObject server interface <br>    // <br>    STDMETHOD(SetInPlaceSite)(IOleInPlaceSite* pIPSite); <br>    STDMETHOD(GetInPlaceSite)(IOleInPlaceSite** ppIPSite); <br>    STDMETHOD(GetDocument)(IUnknown** ppunk); <br>    STDMETHOD(SetRect)(LPRECT prcView); <br>    STDMETHOD(GetRect)(LPRECT prcView); <br>    STDMETHOD(SetRectComplex)(LPRECT prcView, LPRECT prcHScroll, <br>                              LPRECT prcVScroll, LPRECT prcSizeBox); <br>    STDMETHOD(Show)(BOOL fShow); <br>    STDMETHOD(UIActivate)(BOOL fUIActivate); <br>    STDMETHOD(Open)(void); <br>    STDMETHOD(CloseView)(ULONG ulReserved); <br>    STDMETHOD(SaveViewState)(LPSTREAM pstm); <br>    STDMETHOD(ApplyViewState)(LPSTREAM pstm); <br>    STDMETHOD(Clone)(IOleInPlaceSite* pIPSiteNew, IOleDocumentView** ppViewNew); <br> <br>    // Override base class implementation... <br>    virtual HRESULT InternalQueryInterface(REFIID, void**); <br> <br>protected: <br>    BOOL              m_fDocObj; <br>    IOleDocumentSite* m_pDocSite; <br>    IOleInPlaceSite*  m_pViewSite; <br> <br>    // Functions to override to save/restore view state <br>    virtual HRESULT OnSaveViewState(IStream* pstm); <br>    virtual HRESULT OnApplyViewState(IStream* pstm); <br> <br>    // Helper function for DocObject activation <br>    HRESULT ActivateAsDocObject(LONG lVerb); <br> <br>}; <br> <br> <br>//=--------------------------------------------------------------------------= <br>// helper functions <br>//=--------------------------------------------------------------------------= <br>// <br>BOOL RegisterDocObject(LPCSTR pszLibName, LPCSTR pszObjectName, <br>                       REFCLSID riidObject, DWORD dwMiscDocObj, <br>                   BOOL bPrint, LPCSTR szExt, LPCSTR szDescription); <br> <br>//=--------------------------------------------------------------------------= <br>// Debugging macros <br>//=--------------------------------------------------------------------------= <br>// handy-dandy TRACE macro is useful for figuring out how docobj containers <br>// are calling our interface methods  <br>// <br>#ifdef DEBUG <br>    #define TRACE(szMsg)    OutputDebugString(szMsg) <br>#else <br>    #define TRACE(szMsg) <br>#endif <br> <br>#endif __MKTYPLIB__ <br> <br>#endif __CDOCOBJ_H_ <br> </code></pre>
<p>&nbsp;</p></body>
</HTML>
