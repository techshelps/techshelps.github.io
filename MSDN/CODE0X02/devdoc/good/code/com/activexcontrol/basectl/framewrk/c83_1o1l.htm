<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IPSERVER.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context99"></a>IPSERVER.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// IPServer.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implements all exported DLL functions for the program, as well as a few <br>// others that will be used by same <br>// <br>#include "IPServer.H" <br>#include "LocalSrv.H" <br> <br>#include "AutoObj.H" <br>#include "ClassF.H" <br>#include "CtrlObj.H" <br>#include "Globals.H" <br>#include "Unknown.H" <br>#include "Util.H" <br> <br>//=--------------------------------------------------------------------------= <br>// Private module level data <br>// <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br> <br>//=--------------------------------------------------------------------------= <br>// These are used for reflection in OLE Controls.  Not that big of a hit that <br>// we mind defining them for all servers, including automation or generic <br>// COM. <br>// <br>char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow"; <br>BYTE g_fRegisteredReflect = FALSE; <br> <br> <br>//=--------------------------------------------------------------------------= <br>// allow controls to register for DLL_THREAD_ATTACH and DLL_THREAD_DETACH  <br>// <br>THRDNFYPROC g_pfnThreadProc = NULL; <br> <br>extern "C" void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify) <br>{ <br>    if ((g_pfnThreadProc = pfnThreadNotify) == NULL) <br>        DisableThreadLibraryCalls((HMODULE)g_hInstance); <br>} <br> <br> <br>// ref count for LockServer <br>// <br>LONG  g_cLocks; <br> <br> <br>// private routines for this file. <br>// <br>int       IndexOfOleObject(REFCLSID); <br>HRESULT   RegisterAllObjects(void); <br>HRESULT   UnregisterAllObjects(void); <br> <br>//=--------------------------------------------------------------------------= <br>// DllMain <br>//=--------------------------------------------------------------------------= <br>// yon standard LibMain. <br>// <br>// Parameters and Output: <br>//    - see SDK Docs on DllMain <br>// <br>// Notes: <br>// <br>BOOL WINAPI DllMain <br>( <br>    HANDLE hInstance, <br>    DWORD  dwReason, <br>    void  *pvReserved <br>) <br>{ <br>    int i; <br> <br>    switch (dwReason) { <br>      // set up some global variables, and get some OS/Version information <br>      // set up. <br>      // <br>      case DLL_PROCESS_ATTACH: <br>        { <br>        DWORD dwVer = GetVersion(); <br>        DWORD dwWinVer; <br> <br>        //  swap the two lowest bytes of dwVer so that the major and minor version <br>        //  numbers are in a usable order. <br>        //  for dwWinVer: high byte = major version, low byte = minor version <br>        //     OS               Sys_WinVersion  (as of 5/2/95) <br>        //     =-------------=  =-------------= <br>        //     Win95            0x035F   (3.95) <br>        //     WinNT ProgMan    0x0333   (3.51) <br>        //     WinNT Win95 UI   0x0400   (4.00) <br>        // <br>        dwWinVer = (UINT)(((dwVer &amp; 0xFF) &lt;&lt; 8) | ((dwVer &gt;&gt; 8) &amp; 0xFF)); <br>        g_fSysWinNT = FALSE; <br>        g_fSysWin95 = FALSE; <br>        g_fSysWin95Shell = FALSE; <br> <br>        if (dwVer &lt; 0x80000000) { <br>            g_fSysWinNT = TRUE; <br>            g_fSysWin95Shell = (dwWinVer &gt;= 0x0334); <br>        } else  { <br>            g_fSysWin95 = TRUE; <br>            g_fSysWin95Shell = TRUE; <br>        } <br> <br>        // initialize a critical seciton for our apartment threading support <br>        // <br>        InitializeCriticalSection(&amp;g_CriticalSection); <br> <br>        // create an initial heap for everybody to use. <br>        // currently, we're going to let the system make things thread-safe, <br>        // which will make them a little slower, but hopefully not enough <br>        // to notice <br>        // <br>        g_hHeap = GetProcessHeap(); <br>        if (!g_hHeap) { <br>            FAIL("Couldn't get Process Heap.  Not good!"); <br>            return FALSE; <br>        } <br> <br>        g_hInstance = (HINSTANCE)hInstance; <br> <br>        // give the user a chance to initialize whatever <br>        // <br>        InitializeLibrary(); <br> <br>        // if they didn't ask for thread notifications then optimize by turning <br>        // them off for our DLL. <br>        // <br>        if (!g_pfnThreadProc) <br>            DisableThreadLibraryCalls((HMODULE)hInstance); <br>        } <br>        break; <br> <br>      case DLL_THREAD_ATTACH: <br>      case DLL_THREAD_DETACH: <br>        if (g_pfnThreadProc) <br>            g_pfnThreadProc(hInstance, dwReason, pvReserved); <br>        break; <br> <br>      // do  a little cleaning up! <br>      // <br>      case DLL_PROCESS_DETACH: <br> <br>        // clean up our critical seciton <br>        // <br>        DeleteCriticalSection(&amp;g_CriticalSection); <br> <br>        // unregister all the registered window classes. <br>        // <br>        i = 0; <br> <br>        while (!ISEMPTYOBJECT(i)) { <br>            if (g_ObjectInfo[i].usType == OI_CONTROL) { <br>                if (CTLWNDCLASSREGISTERED(i)) <br>                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance); <br>            } <br>            i++; <br>        } <br> <br>        // clean up our parking window. <br>        // <br>        if (g_hwndParking) { <br>            DestroyWindow(g_hwndParking); <br>            UnregisterClass("CtlFrameWork_Parking", g_hInstance); <br>            --g_cLocks; <br>        } <br> <br>        // clean up after reflection, if appropriate. <br>        // <br>        if (g_fRegisteredReflect) <br>            UnregisterClass(g_szReflectClassName, g_hInstance); <br> <br>        // give the user a chance to do some cleaning up <br>        // <br>        UninitializeLibrary(); <br>        break; <br>    } <br> <br>    return TRUE; <br>} <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// DllRegisterServer <br>//=--------------------------------------------------------------------------= <br>// registers the Automation server <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDAPI DllRegisterServer <br>( <br>    void <br>) <br>{ <br>    HRESULT hr; <br> <br>    hr = RegisterAllObjects(); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // call user registration function. <br>    // <br>    return (RegisterData())? S_OK : E_FAIL; <br>} <br> <br> <br> <br>//=--------------------------------------------------------------------------= <br>// DllUnregisterServer <br>//=--------------------------------------------------------------------------= <br>// unregister's the Automation server <br>// <br>// Output: <br>//    HRESULT <br>// <br>// Notes: <br>// <br>STDAPI DllUnregisterServer <br>( <br>    void <br>) <br>{ <br>    HRESULT hr; <br> <br>    hr = UnregisterAllObjects(); <br>    RETURN_ON_FAILURE(hr); <br> <br>    // call user unregistration function <br>    // <br>    return (UnregisterData()) ? S_OK : E_FAIL; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// DllCanUnloadNow <br>//=--------------------------------------------------------------------------= <br>// we are being asked whether or not it's okay to unload the DLL.  just check <br>// the lock counts on remaining objects ... <br>// <br>// Output: <br>//    HRESULT        - S_OK, can unload now, S_FALSE, can't. <br>// <br>// Notes: <br>// <br>STDAPI DllCanUnloadNow <br>( <br>    void <br>) <br>{ <br>    // if there are any objects lying around, then we can't unload.  The <br>    // controlling CUnknownObject class that people should be inheriting from <br>    // takes care of this <br>    // <br>    return (g_cLocks) ? S_FALSE : S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// DllGetClassObject <br>//=--------------------------------------------------------------------------= <br>// creates a ClassFactory object, and returns it. <br>// <br>// Parameters: <br>//    REFCLSID        - CLSID for the class object <br>//    REFIID          - interface we want class object to be. <br>//    void **         - pointer to where we should ptr to new object. <br>// <br>// Output: <br>//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY, <br>//                      E_INVALIDARG, E_UNEXPECTED <br>// <br>// Notes: <br>// <br>STDAPI DllGetClassObject <br>( <br>    REFCLSID rclsid, <br>    REFIID   riid, <br>    void   **ppvObjOut <br>) <br>{ <br>    HRESULT hr; <br>    void   *pv; <br>    int     iIndex; <br> <br>    // arg checking <br>    // <br>    if (!ppvObjOut) <br>        return E_INVALIDARG; <br> <br>    // first of all, make sure they're asking for something we work with. <br>    // <br>    iIndex = IndexOfOleObject(rclsid); <br>    if (iIndex == -1) <br>        return CLASS_E_CLASSNOTAVAILABLE; <br> <br>    // create the blank object. <br>    // <br>    pv = (void *)new CClassFactory(iIndex); <br>    if (!pv) <br>        return E_OUTOFMEMORY; <br> <br>    // QI for whatever the user has asked for. <br>    // <br>    hr = ((IUnknown *)pv)-&gt;QueryInterface(riid, ppvObjOut); <br>    ((IUnknown *)pv)-&gt;Release(); <br> <br>    return hr; <br>} <br>//=--------------------------------------------------------------------------= <br>// IndexOfOleObject <br>//=--------------------------------------------------------------------------= <br>// returns the index in our global table of objects of the given CLSID.  if <br>// it's not a supported object, then we return -1 <br>// <br>// Parameters: <br>//    REFCLSID     - [in] duh. <br>// <br>// Output: <br>//    int          - &gt;= 0 is index into global table, -1 means not supported <br>// <br>// Notes: <br>// <br>int IndexOfOleObject <br>( <br>    REFCLSID rclsid <br>) <br>{ <br>    int x = 0; <br> <br>    // an object is creatable if it's CLSID is in the table of all allowable object <br>    // types. <br>    // <br>    while (!ISEMPTYOBJECT(x)) { <br>        if (OBJECTISCREATABLE(x)) { <br>            if (rclsid == CLSIDOFOBJECT(x)) <br>                return x; <br>        } <br>        x++; <br>    } <br> <br>    return -1; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// RegisterAllObjects <br>//=--------------------------------------------------------------------------= <br>// registers all the objects for the given automation server. <br>// <br>// Parameters: <br>//    none <br>// <br>// Output: <br>//    HERSULT        - S_OK, E_FAIL <br>// <br>// Notes: <br>// <br>HRESULT RegisterAllObjects <br>( <br>    void <br>) <br>{ <br>    ITypeLib *pTypeLib; <br>    HRESULT hr; <br>    DWORD   dwPathLen; <br>    char    szTmp[MAX_PATH]; <br>    int     x = 0; <br> <br>    // loop through all of our creatable objects [those that have a clsid in <br>    // our global table] and register them. <br>    // <br>    while (!ISEMPTYOBJECT(x)) { <br>        if (!OBJECTISCREATABLE(x)) { <br>            x++; <br>            continue; <br>        } <br> <br>        // depending on the object type, register different pieces of information <br>        // <br>        switch (g_ObjectInfo[x].usType) { <br> <br>          // for both simple co-creatable objects and proeprty pages, do the same <br>          // thing <br>          // <br>          case OI_UNKNOWN: <br>          case OI_PROPERTYPAGE: <br>            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x)); <br>            break; <br> <br>          case OI_AUTOMATION: <br>            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),  <br>                                     *g_pLibid, CLSIDOFOBJECT(x)); <br>            break; <br> <br>          case OI_CONTROL: <br>            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), <br>                                  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x), <br>                                  BITMAPIDOFCONTROL(x)); <br>            break; <br> <br>        } <br>        x++; <br>    } <br> <br>    // Load and register our type library. <br>    // <br>    if (g_fServerHasTypeLibrary) { <br>        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH); <br>        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp); <br>        hr = LoadTypeLib(pwsz, &amp;pTypeLib); <br>        RETURN_ON_FAILURE(hr); <br>        hr = RegisterTypeLib(pTypeLib, pwsz, NULL); <br>        pTypeLib-&gt;Release(); <br>        RETURN_ON_FAILURE(hr); <br>    } <br> <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// UnregisterAllObjects <br>//=--------------------------------------------------------------------------= <br>// un-registers all the objects for the given automation server. <br>// <br>// Parameters: <br>//    none <br>// <br>// Output: <br>//    HRESULT        - S_OK <br>// <br>// Notes: <br>// <br>HRESULT UnregisterAllObjects <br>( <br>    void <br>) <br>{ <br>    int x = 0; <br> <br>    // loop through all of our creatable objects [those that have a clsid in <br>    // our global table] and register them. <br>    // <br>    while (!ISEMPTYOBJECT(x)) { <br>        if (!OBJECTISCREATABLE(x)) { <br>            x++; <br>            continue; <br>        } <br> <br>        switch (g_ObjectInfo[x].usType) { <br> <br>          case OI_UNKNOWN: <br>          case OI_PROPERTYPAGE: <br>            UnregisterUnknownObject(CLSIDOFOBJECT(x)); <br>            break; <br> <br>          case OI_CONTROL: <br>            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),  <br>                                    CLSIDOFOBJECT(x)); <br>     <br>          case OI_AUTOMATION: <br>            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),  <br>                                       CLSIDOFOBJECT(x)); <br>            break; <br> <br>        } <br>        x++; <br>    } <br> <br>    // if we've got one, unregister our type library [this isn't an API function <br>    // -- we've implemented this ourselves] <br>    // <br>    if (g_pLibid) <br>        UnregisterTypeLibrary(*g_pLibid); <br> <br>    return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
