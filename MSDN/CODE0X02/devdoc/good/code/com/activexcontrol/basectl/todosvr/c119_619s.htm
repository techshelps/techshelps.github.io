<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CDOCOBJ.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context130"></a>CDOCOBJ.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CDocObj.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of CDocumentObject, which provides basic DocObject server <br>// support. This file contains overrides of basic inplace editing support. <br>// See iodoc.cpp and iodocvw.cpp for implementations of required interfaces <br>// for DocObject server support. <br>//  <br>#include &lt;IPServer.H&gt; <br>#include &lt;Globals.H&gt; <br>#include "CDocObj.H" <br> <br>// for ASSERT and FAIL <br>// <br>SZTHISFILE <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::CDocumentObject <br>//=--------------------------------------------------------------------------= <br>// <br>// Parameters: <br>//    IUnknown*        - [in] <br>//    int              - [in] <br>//    void*            - [in] <br>// <br>// Notes: <br>// <br>CDocumentObject::CDocumentObject(IUnknown* pUnkOuter, int iPrimaryDispatch,  <br>                                 void* pMainInterface) <br>   : BASECLASS(pUnkOuter, iPrimaryDispatch, pMainInterface) <br>{ <br>    m_fDocObj   = FALSE; <br>    m_pDocSite  = NULL; <br>    m_pViewSite = NULL; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::~CDocumentObject <br>//=--------------------------------------------------------------------------= <br>// <br>// Notes: <br>// <br>CDocumentObject::~CDocumentObject() <br>{ <br>    ASSERT(m_pDocSite == NULL, "CDocumentObject::m_pDocSite not properly released"); <br>    ASSERT(m_pViewSite == NULL, "CDocumentObject::m_pViewSite not properly released"); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// qi for things only we support. <br>// <br>// Parameters: <br>// Parameters: <br>//    REFIID       - [in]  interface they want <br>//    void**       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT      - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CDocumentObject::InternalQueryInterface(REFIID riid, void** ppvObjOut) <br>{ <br>    // Check for interfaces we implement <br>    if (DO_GUIDS_MATCH(riid, IID_IOleDocument))  <br>        *ppvObjOut = (void *)(IOleDocument*)this;  <br>    else if (DO_GUIDS_MATCH(riid, IID_IOleDocumentView)) <br>        *ppvObjOut = (void *)(IOleDocumentView*)this;  <br>    else <br>        // delegate to super-class for automation interfaces, etc ... <br>        // <br>        return BASECLASS::InternalQueryInterface(riid, ppvObjOut); <br> <br>    // we like the interface, so addref and return <br>    // <br>    ((IUnknown *)(*ppvObjOut))-&gt;AddRef(); <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::SetClientSite <br>//=--------------------------------------------------------------------------= <br>// determines whether object can and should activate as a DocObject <br>// <br>// Parameters: <br>//    IOleClientSite*        - [in] pointer to client site. <br>// <br>// Output: <br>//    HRESULT                - S_OK <br>// <br>// Notes: <br>// <br>HRESULT CDocumentObject::SetClientSite(IOleClientSite* pClientSite) <br>{ <br>    TRACE("\nCDocumentObject::SetClientSite"); <br> <br>    // perform regular SetClientSite processing <br>    HRESULT hr = BASECLASS::SetClientSite(pClientSite); <br>    if (FAILED(hr)) <br>        return hr; <br> <br>// If we have a document site pointer,  <br>//    release it and set docobj flag FALSE <br>RELEASE_OBJECT(m_pDocSite); <br>    m_fDocObj = FALSE; <br> <br>// If we got a client site, <br>if (pClientSite != NULL) <br>    { <br>        // If the client site supports IID_IOleDocumentSite, <br>        //    save the document site pointer <br>        //    and set docobj flag TRUE <br>hr = pClientSite-&gt;QueryInterface(IID_IOleDocumentSite,  <br>                                         (void**)&amp;m_pDocSite); <br>        if (SUCCEEDED(hr)) <br>            m_fDocObj = TRUE; <br>    } <br>return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::DoVerb    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Requests an object to perform an action in response to an end-user's <br>// action. <br>// <br>// Parameters: <br>//    LONG             - [in]  verb to be performed <br>//    LPMSG            - [in]  event that invoked the verb <br>//    IOleClientSite * - [in]  the controls active client site <br>//    LONG             - [in]  reserved <br>//    HWND             - [in]  handle of window containing the object. <br>//    LPCRECT          - [in]  pointer to objects's display rectangle <br>// <br>// Output: <br>//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE, <br>//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND, <br>//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT, <br>//                       OLE_CLASSDIFF, E_NOTIMPL <br>// <br>// Notes: <br>// <br>STDMETHODIMP CDocumentObject::DoVerb <br>( <br>    LONG            lVerb, <br>    LPMSG           pMsg, <br>    IOleClientSite *pActiveSite, <br>    LONG            lIndex, <br>    HWND            hwndParent, <br>    LPCRECT         prcPosRect <br>) <br>{ <br>    TRACE("\nCDocumentObject::DoVerb"); <br> <br>    // if we're acting as a docobj <br>    if (m_fDocObj) <br>    { <br>        switch (lVerb) <br>        { <br>        // call IOleDocumentSite::ActivateMe for Show, Open, InPlaceActivate and UIActivate Verbs <br>        case OLEIVERB_SHOW: <br>        case OLEIVERB_UIACTIVATE: <br>        case OLEIVERB_OPEN: <br>        case OLEIVERB_INPLACEACTIVATE: <br>            return m_pDocSite-&gt;ActivateMe(NULL); <br> <br>        // return E_INVALIDARG for Hide Verb <br>        case OLEIVERB_HIDE: <br>            return E_INVALIDARG; <br> <br>        // otherwise, just do normal processing <br>        default: <br>            break; <br>        } <br>    } <br>     <br>    // if we're not acting as a docobj, just do normal processing     <br>    return BASECLASS::DoVerb(lVerb, pMsg, pActiveSite, lIndex, <br>                             hwndParent, prcPosRect); <br> <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::SetExtent    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Informs the control of how much display space its container has assigned it. <br>// <br>// Parameters: <br>//    DWORD            - [in] which form or 'aspect'  is to be displayed. <br>//    SIZEL *          - [in] size limit for the control. <br>// <br>// Output: <br>//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING <br>// <br>// Notes: <br>// <br>STDMETHODIMP CDocumentObject::SetExtent(DWORD dwDrawAspect, SIZEL *psizel) <br>{ <br>    TRACE("\nCDocumentObject::SetExtent"); <br> <br>    // ignore SetExtent calls if we are a docobj <br>    if (m_fDocObj) <br>        return S_OK; <br> <br>    // otherwise do normal processing <br>    return BASECLASS::SetExtent(dwDrawAspect, psizel); <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::Unadvise    [IOleObject] <br>//=--------------------------------------------------------------------------= <br>// Deletes a previously established advisory connection. <br>// <br>// Parameters: <br>//    DWORD         - [in] connection cookie <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION <br>// <br>// Notes: <br>//      This override is included to work around a problem observed  <br>//      interacting with Office Binder. When activated as a docobj,  <br>//      IOleObject::Advise is not getting called. However, when deactivated,  <br>//      IOleObject::Unadvise *is* called. Since no advise holder was ever  <br>//      created, the base class method asserts. <br>//  <br>//      All this function does is prevent the assert from getting hit. <br>// <br>STDMETHODIMP CDocumentObject::Unadvise(DWORD dwConnection) <br>{ <br>    if (!dwConnection) { <br>        TRACE("\nSomebody called Unadvise on IOleObject without calling Advise!"); <br>        return OLE_E_NOCONNECTION; <br>    } <br> <br>    return BASECLASS::Unadvise(dwConnection); <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CDocumentObject::ActivateAsDocObject <br>//=--------------------------------------------------------------------------= <br>// activates a document object, and depending on the verb, optionally  <br>// ui activates it as well. <br>// <br>// Parameters: <br>//    LONG         - [in] the verb that caused us to activate <br>// <br>// Output: <br>//    HRESULT      - S_OK, E_UNEXPECTED <br>// <br>// Notes: <br>//      This implementation is based on COleControl::InPlaceActivate. <br>//      COleControl::InPlaceActivate is called when a CDocumentObject <br>//      is being used as a control or normal embedding, not this function. <br>// <br>HRESULT CDocumentObject::ActivateAsDocObject(LONG lVerb) <br>{ <br>    TRACE("\nEntering CDocumentObject::ActivateAsDocObject"); <br> <br>    HRESULT hr = S_OK; <br> <br>    // if our view site has not been set, report an error <br>    if (!m_pViewSite) <br>    { <br>        hr = E_UNEXPECTED; <br>        goto LeaveMethod; <br>    } <br> <br>    // if we don't have a client site, then there's not much to do. <br>    // <br>    if (!m_pClientSite) <br>        goto LeaveMethod; <br> <br> <br>    // get an InPlaceSite pointer <br>    // <br>    if (!m_pInPlaceSite) { <br>        hr = m_pClientSite-&gt;QueryInterface(IID_IOleInPlaceSite, (void **)&amp;m_pInPlaceSite); <br>        if (FAILED(hr)) <br>            goto LeaveMethod; <br>    } <br> <br>    // if we're not already active, go and do it. <br>    // <br>    if (!m_fInPlaceActive) { <br>        OLEINPLACEFRAMEINFO InPlaceFrameInfo; <br>        RECT rcPos, rcClip; <br> <br>        // ask for permission and notify the container we're going active. <br>        // <br>        hr = m_pInPlaceSite-&gt;CanInPlaceActivate(); <br>        if (hr != S_OK)  <br>        { <br>            if (FAILED(hr)) <br>                hr = E_FAIL; <br>            goto LeaveMethod; <br>        } <br> <br>        hr = m_pInPlaceSite-&gt;OnInPlaceActivate(); <br>        if (FAILED(hr)) <br>            goto LeaveMethod; <br> <br>        m_fInPlaceActive = TRUE; <br>        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO); <br> <br>        // get our parent window <br>        // <br>        hr = m_pInPlaceSite-&gt;GetWindow(&amp;m_hwndParent); <br>        if (!FAILED(hr)) <br>            // get our display and clipping rectangles <br>            // <br>            hr = m_pInPlaceSite-&gt;GetWindowContext(&amp;m_pInPlaceFrame, &amp;m_pInPlaceUIWindow, <br>                                                  &amp;rcPos, &amp;rcClip, &amp;InPlaceFrameInfo); <br>        if (FAILED(hr)) { <br>            InPlaceDeactivate(); <br>            goto LeaveMethod; <br>        } <br> <br>        // make sure we'll display ourselves in the correct location with the correct size <br>        //    SetObjectRects expects object extent to be set, but <br>  //    DocObjects ignore SetExtent. Set m_Size to the size  <br>  //    specified for the view. <br>  m_Size.cx = rcPos.right - rcPos.left; <br>  m_Size.cy = rcPos.bottom - rcPos.top; <br>        SetObjectRects(&amp;rcPos, &amp;rcClip); <br> <br>        // create the window, and display it.  <br>        // <br>        CreateInPlaceWindow(rcPos.left, rcPos.top, TRUE); <br>    } <br> <br>    if (!m_fInPlaceVisible) <br>        SetInPlaceVisible(TRUE); <br> <br>    // if we weren't asked to UIActivate, then we're done. <br>    // <br>    if (lVerb != OLEIVERB_PRIMARY &amp;&amp; lVerb != OLEIVERB_UIACTIVATE) <br>        goto LeaveMethod; <br> <br>    // if we're not already UI active, do sow now. <br>    // <br>    if (!m_fUIActive) { <br>        m_fUIActive = TRUE; <br> <br>        // inform the container of our intent <br>        // <br>        m_pInPlaceSite-&gt;OnUIActivate(); <br> <br>        // take the focus  [which is what UI Activation is all about !] <br>        // <br>        SetFocus(TRUE); <br> <br>        // set up the active object [us] with the container. <br>        // <br>        m_pInPlaceFrame-&gt;SetActiveObject((IOleInPlaceActiveObject *)this, NULL); <br>        if (m_pInPlaceUIWindow) <br>            m_pInPlaceUIWindow-&gt;SetActiveObject((IOleInPlaceActiveObject *)this, NULL); <br> <br>        // we have to explicitly say we don't wany any border space. <br>        // <br>        m_pInPlaceFrame-&gt;SetBorderSpace(NULL); <br>        if (m_pInPlaceUIWindow) <br>            m_pInPlaceUIWindow-&gt;SetBorderSpace(NULL); <br>    } <br> <br>LeaveMethod: <br>    TRACE("\nLeaving CDocumentObject::ActivateAsDocObject"); <br>    return hr; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
