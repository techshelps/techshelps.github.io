<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CARDDRAW.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context70"></a>CARDDRAW.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// CardDraw.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1996 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// <br> <br>#include &lt;windows.h&gt; <br> <br>extern HINSTANCE g_hInstance; <br> <br>#include "Resource.H" <br>#include "carddraw.h" <br> <br>const POINT CCardDraw::CardBorder[9] =  <br>{ { 0, 2 }, { 2, 0 },  <br>  { CardSizeX-3, 0 },  <br>  { CardSizeX-1, 2 },  <br>  { CardSizeX-1, CardSizeY-3 }, <br>  { CardSizeX-3, CardSizeY-1 },  <br>  { 2, CardSizeY-1 }, <br>  { 0, CardSizeY-3 }, { 0, 2 } }; <br> <br>const RECT CCardDraw::CardRect = { 0, 0, CardSizeX, CardSizeY }; <br> <br>CCardDraw::CCardDraw( int number ) <br>{ <br>symsDc = symsiDc = centerDc = jokerDc = NULL; <br> <br>// Symbols bitmaps, used by all cards <br>if( number != DrawBack ) <br>{ <br>symsDc = CreateCompatibleDC( NULL ); <br>symsMem = (HBITMAP) SelectObject( symsDc,  <br>LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_SYMS) ) ); <br>symsiDc = CreateCompatibleDC( symsDc ); <br>symsiMem = (HBITMAP) SelectObject( symsiDc, <br>CreateCompatibleBitmap( symsiDc, SymsSizeX, SymsSizeY ) ); <br>StretchBlt( symsiDc, SymsSizeX-1, SymsSizeY-1, -SymsSizeX, -SymsSizeY, <br>symsDc, 0, 0, SymsSizeX, SymsSizeY, SRCCOPY ); <br>} <br> <br>// faces, used &gt; 10 <br>if( number &gt; 10 &amp;&amp; number != 14 )  <br>{ <br>centerDc = CreateCompatibleDC( NULL ); <br>centerMem = (HBITMAP) SelectObject( centerDc,  <br>LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_FACES)) ); <br>} <br> <br>// joker <br>if( number &gt;= 14 ) <br>{ <br>jokerDc = CreateCompatibleDC( NULL ); <br>jokerMem = (HBITMAP) SelectObject( jokerDc, <br>     LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_JOKER) ) ); <br>} <br>} <br> <br>CCardDraw::~CCardDraw() <br>{ <br>HBITMAP tempMem; <br> <br>#define freeDc( s ) \ <br>       if( s##Dc ) \ <br>  { tempMem = (HBITMAP) SelectObject( s##Dc, s##Mem ); \ <br>    DeleteObject( tempMem ); \ <br>    DeleteDC( s##Dc ); } <br> <br>freeDc( syms ); <br>freeDc( symsi ); <br>freeDc( joker ); <br>freeDc( center ); <br> <br>#undef freeDc <br>} <br> <br>BOOL CCardDraw::DrawCard( HDC hdcMem, int suite, int number ) <br>{ <br>int LocX, LocY; <br> <br>const static struct { unsigned char x, y; } LargeSymLoc[10][10] =  <br>{ { {29,42} }, <br>  { {29,11}, {29,86} }, <br>  { {29,11}, {29,42}, {29,86} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {29,42} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {16,42}, {42,42} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {16,42}, {42,42}, {29,26} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {16,32}, {42,32}, {16,65}, {42,65} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {16,32}, {42,32}, {16,65}, {42,65}, {29,42} }, <br>  { {16,11}, {42,11}, {16,86}, {42,86}, {16,32}, {42,32}, {16,65}, {42,65}, {29,21}, {29,76} } }; <br> <br>const static signed char LargeSymLoc9[] = { -2, -2, 3, 0 }; <br> <br>// Macros for working with the Sym DC's <br>#define SymBitBltTop( x, y, dx, dy, sx, sy, copy ) \ <br>BitBlt( hdcMem, x, y, dx, dy, symsDc, sx, sy, copy ); <br>#define SymBitBltBottom( x,y, dx, dy, sx, sy, copy ) \ <br>BitBlt( hdcMem, CardSizeX - (x) - (dx), CardSizeY - (y) - (dy), \ <br>dx, dy, symsiDc,\ <br>SymsSizeX - (sx) - (dx), SymsSizeY - (sy) - (dy), copy ); <br>#define SymBitBlt( x, y, dx, dy, sx, sy, copy ) \ <br>{ SymBitBltTop( x, y, dx, dy, sx, sy, copy ); \ <br>  SymBitBltBottom( x, y, dx, dy, sx, sy, copy ); } <br>#define SymBitBltBottomNoTransX( x,y, dx, dy, sx, sy, copy ) \ <br>BitBlt( hdcMem, x, y - (dy), \ <br>dx, dy, symsiDc,\ <br>SymsSizeX - (sx) - (dx), SymsSizeY - (sy) - (dy), copy ); <br> <br>if( suite &lt; 0 )  <br>return( DrawCardBack( hdcMem, -suite ) ); <br> <br>// white middle <br>FillRect( hdcMem, &amp;CardRect, (HBRUSH)GetStockObject(WHITE_BRUSH) ); <br> <br>// set background color for monochrome bitmap blt's <br>SetTextColor( hdcMem, RGB((suite &gt;= 3 ? 255:0),0,0) ); <br> <br>// Joker <br>if( number == 14 ) <br>{ <br>static const RECT JokerCornerRect =  <br>{ JokerCornerRectSX, JokerCornerRectSY, <br>  CardSizeX - JokerCornerRectEX, CardSizeY - JokerCornerRectEY }; <br> <br>SymBitBlt( JokerCornerX, JokerCornerY, <br>   JokerCornerSizeX, JokerCornerSizeY,  <br>   JokerCornerSrcX, JokerCornerSrcY, SRCCOPY ); <br> <br>FillRect( hdcMem, &amp;JokerCornerRect,  <br>  (HBRUSH)GetStockObject(WHITE_BRUSH) ); <br> <br>BitBlt( hdcMem, JokerX, JokerY,JokerSizeX, JokerSizeY, <br>               jokerDc, 0, 0, SRCCOPY) ; <br>} <br> <br>if( number &lt; 14 )  <br>{ <br>long SrcY, SrcX; <br> <br>// fill number <br>LocX = (number &gt; 10 ? 2 : 3 ); <br>SrcY = (number &amp; 0x8 ? NumberSizeY : 0); <br>SrcX = (number &amp; 0x8 ? (number-8) : (number-1)); <br>SymBitBlt( LocX, NumberY,  <br>   NumberSizeX,  <br>   NumberSizeY + ((number &amp; 0x8) &gt;&gt; 2), <br>   NumberSrcX + SrcX * NumberSizeX, <br>   NumberSrcY + SrcY, <br>   SRCCOPY ); <br> <br>// Small symbols <br>SymBitBlt( LocX, SmallSymY, <br> SmallSymSizeX, SmallSymSizeY, <br> SmallSymSrcX + (suite-1) * SmallSymSizeX, <br> SmallSymSrcY, SRCCOPY ); <br>} <br> <br>// center of card, symbols <br>if( number &lt;= 10 ) <br>{ <br>for( int i = 0; i &lt; number; i++ ) <br>{ <br>LocX = LargeSymLoc[number-1][i].x; <br>LocY = LargeSymLoc[number-1][i].y; <br>if( number == 9 &amp;&amp; i == 8 )// adjustment for 9 <br>LocY += LargeSymLoc9[suite-1]; <br>if( LocY &lt;= CardSizeY/2 )  <br>{ <br>SymBitBltTop( LocX, LocY-1, <br>LargeSymSizeX, LargeSymSizeY, <br>LargeSymSrcX + (4-suite)*LargeSymSizeX, <br>LargeSymSrcY, SRCAND ); <br>} <br>else <br>{ <br>SymBitBltBottomNoTransX( LocX, LocY, <br>LargeSymSizeX, LargeSymSizeY, <br>LargeSymSrcX + (4-suite)*LargeSymSizeX, <br>LargeSymSrcY, SRCAND ); <br>} <br>} <br>} <br> <br>// center of card, face <br>if( number &gt; 10 &amp;&amp; number &lt; 14 ) <br>{ <br>HPEN oldPen; <br>static const POINT centerBorder[] =  <br>{ { PictX, PictY }, { PictX, PictY+PictSizeY+1 }, <br>  { PictX+PictSizeX+1, PictY+PictSizeY+1 }, <br>  { PictX+PictSizeX+1, PictY }, { PictX, PictY } }; <br> <br>BitBlt( hdcMem, PictX+1, PictY+1,  <br>                PictSizeX, PictSizeY/2, <br>                centerDc, <br>                (number-11)*PictSizeX, <br>                (suite-1)*PictSizeY/2, <br>                SRCCOPY) ; <br>StretchBlt( hdcMem, PictX+PictSizeX, PictY+PictSizeY, <br>-PictSizeX, -PictSizeY/2, <br>centerDc, <br>                (number-11)*PictSizeX, <br>                (suite-1)*PictSizeY/2, <br>PictSizeX, PictSizeY/2, SRCCOPY ); <br>oldPen = (HPEN) SelectObject( hdcMem, GetStockObject( BLACK_PEN ) ); <br>Polyline( hdcMem, centerBorder, sizeof(centerBorder)/sizeof(POINT) ); <br>SelectObject( hdcMem, oldPen ); <br>} <br> <br>return( TRUE ); <br>} <br> <br>BOOL CCardDraw::DrawCardBack( HDC hdcMem, int backnum ) <br>{ <br>if( backnum &gt;= 1 &amp;&amp; backnum &lt;= 12 ) <br>{ <br>HDC backDc; <br>HBITMAP backMem; <br>if( !(backDc = CreateCompatibleDC( NULL )) ) <br>return( FALSE ); <br>if( !(backMem = (HBITMAP) SelectObject( backDc, <br>LoadBitmap( g_hInstance, <br>MAKEINTRESOURCE(backnum+IDB_BACKBASE)))) ) <br>{ <br>DeleteDC( backDc ); <br>return( FALSE ); <br>} <br>BitBlt( hdcMem, 1, 1, CardSizeX-2, CardSizeY-2, <br>         backDc, 0, 0, SRCCOPY ); <br>DeleteObject( backMem ); <br>DeleteDC( backDc ); <br>} <br>else <br>{ <br>FillRect( hdcMem, &amp;CardRect,  <br>  (HBRUSH)GetStockObject(WHITE_BRUSH) ); <br> <br>for( int x = 1; x &lt; CardSizeX-1; x++ ) <br>    for( int y = 1; y &lt; CardSizeY-1; y++ ) <br>if( ((x+y-2) &amp; 3) &lt; 2 )  <br>SetPixelV( hdcMem, x, y, RGB( 0,0,128 ) ); <br>} <br> <br>return( TRUE ); <br>} <br> <br>HBITMAP CCardDraw::CreateDIBCard( HDC drawDc ) <br>{ <br>void *bits; <br>static struct { <br>BITMAPINFOHEADER bi; <br>long colors[16]; <br>} b = { { sizeof(b.bi),  <br>  (((CardSizeX + 3)&gt;&gt;2)&lt;&lt;2), <br>  CardSizeY, 1, 4, BI_RGB, 0, 0, 0, 16, 16 }, <br>{ 0x000000, 0x800000, 0x008000, 0x808000, <br>  0x000080, 0x800080, 0x808080, 0xc0c0c0, <br>  0x808080, 0xff0000, 0x00ff00, 0xffff00, <br>          0x0000ff, 0xff00ff, 0x00ffff, 0xffffff } }; <br> <br>return CreateDIBSection( drawDc, (BITMAPINFO *) &amp;b, <br> DIB_RGB_COLORS,  <br> &amp;bits, NULL, 0 ); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
