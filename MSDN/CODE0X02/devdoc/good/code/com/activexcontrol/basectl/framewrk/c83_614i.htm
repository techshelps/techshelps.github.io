<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>STDENUM.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context102"></a>STDENUM.CPP</h2>
<pre><code>//=--------------------------------------------------------------------------= <br>// StdEnum.Cpp <br>//=--------------------------------------------------------------------------= <br>// Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved. <br>// <br>// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF  <br>// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO  <br>// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A  <br>// PARTICULAR PURPOSE. <br>//=--------------------------------------------------------------------------= <br>// <br>// implementation of a generic enumerator object. <br>// <br>#include "IPServer.H" <br>#include "StdEnum.H" <br>#include "Globals.H" <br> <br>SZTHISFILE <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::CStandardEnum <br>//=--------------------------------------------------------------------------= <br>// create the object and initialize the refcount <br>// <br>// Parameters: <br>//    REFCLSID        - [in] type of enumerator that we are <br>//    int             - [in] number of elements in the enumeration <br>//    int             - [in] size of each element <br>//    void *          - [in] pointer to element data <br>//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD) <br>//                    - [in] copying function <br>// <br>// Notes: <br>// <br>#pragma warning(disable:4355)  // using 'this' in constructor <br>CStandardEnum::CStandardEnum <br>( <br>    REFCLSID rclsid, <br>    int      cElements, <br>    int      cbElementSize, <br>    void    *rgElements, <br>    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD) <br>) <br>: CUnknownObject(NULL, (IEnumGeneric *)this), <br>  m_iid(rclsid), <br>  m_cElements(cElements), <br>  m_cbElementSize(cbElementSize), <br>  m_iCurrent(0), <br>  m_rgElements(rgElements), <br>  m_pfnCopyElement(pfnCopyElement) <br>{ <br>    m_pEnumClonedFrom = NULL; <br>} <br>#pragma warning(default:4355)  // using 'this' in constructor <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::CStandardEnum <br>//=--------------------------------------------------------------------------= <br>// "it is not death, but dying, which is terrible." <br>//    - Henry Fielding (1707-54) <br>// <br>// Notes: <br>// <br>CStandardEnum::~CStandardEnum () <br>{ <br>    // if we're a cloned object, then just release our parent object and <br>    // we're done. otherwise, free up the allocated memory we were given <br>    // <br>    if (m_pEnumClonedFrom) <br>        m_pEnumClonedFrom-&gt;Release(); <br>    else { <br>        if (m_rgElements) HeapFree(g_hHeap, 0, m_rgElements); <br>    } <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::InternalQueryInterface <br>//=--------------------------------------------------------------------------= <br>// we support our internal iid, and that's all <br>// <br>// Parameters: <br>//    REFIID        - [in]  interface they want <br>//    void **       - [out] where they want to put the resulting object ptr. <br>// <br>// Output: <br>//    HRESULT       - S_OK, E_NOINTERFACE <br>// <br>// Notes: <br>// <br>HRESULT CStandardEnum::InternalQueryInterface <br>( <br>    REFIID riid, <br>    void **ppvObjOut <br>) <br>{ <br>    if (DO_GUIDS_MATCH(riid, m_iid)) { <br>        ExternalAddRef(); <br>        *ppvObjOut = (IEnumGeneric *)this; <br>        return S_OK; <br>    } <br> <br>    return E_NOINTERFACE; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::Next <br>//=--------------------------------------------------------------------------= <br>// returns the next dude in our iteration <br>// <br>// Parameters: <br>//    unsigned long     - [in]  count of elements requested <br>//    void    *         - [out] array of slots to put values in. <br>//    unsigned long *   - [out] actual number fetched <br>// <br>// Output: <br>//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE <br>// <br>// Notes: <br>// <br>STDMETHODIMP CStandardEnum::Next <br>( <br>    unsigned long  cElm, <br>    void          *rgDest, <br>    unsigned long *pcElmOut <br>) <br>{ <br>    unsigned long cElementsFetched = 0; <br>    void         *pElementDest = rgDest; <br>    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent); <br> <br>    while (cElementsFetched &lt; cElm) { <br> <br>        // if we hit EOF, break out <br>        // <br>        if (m_iCurrent &gt;= m_cElements) <br>            break; <br> <br>        // copy the element out for them <br>        // <br>        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize); <br> <br>        // increase the counters <br>        // <br>        pElementDest = (LPBYTE)pElementDest + m_cbElementSize; <br>        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize; <br>        m_iCurrent++; <br>        cElementsFetched++; <br>    } <br> <br>    if (pcElmOut) <br>        *pcElmOut = cElementsFetched; <br> <br>    return (cElementsFetched &lt; cElm)? S_FALSE : S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::Skip <br>//=--------------------------------------------------------------------------= <br>// skips the requested number of rows. <br>// <br>// Parameters: <br>//    unsigned long     - [in] number to skip <br>// <br>// Output: <br>//    HRESULT           - S_OK, S_FALSE <br>// <br>// Notes: <br>// <br>STDMETHODIMP CStandardEnum::Skip <br>( <br>    unsigned long cSkip <br>) <br>{ <br>    // handle running off the end <br>    // <br>    if (m_iCurrent + (int)cSkip &gt; m_cElements) { <br>        m_iCurrent = m_cElements; <br>        return S_FALSE; <br>    } <br> <br>    m_iCurrent += cSkip; <br>    return S_OK; <br>} <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::Reset <br>//=--------------------------------------------------------------------------= <br>// reset the counter. <br>// <br>// Output: <br>//    HRESULT        - S_OK <br>// <br>// Notes: <br>// <br>STDMETHODIMP CStandardEnum::Reset <br>( <br>    void <br>) <br>{ <br>    m_iCurrent = 0; <br>    return S_OK; <br>} <br> <br> <br>//=--------------------------------------------------------------------------= <br>// CStandardEnum::Clone <br>//=--------------------------------------------------------------------------= <br>// clones the object and gives the new one the same position <br>// <br>// Parameters: <br>//    IEnumVARIANT **    - [out] where to put the new object. <br>// <br>// Output; <br>//    HRESULT            - S_OK, E_OUTOFMEMORY <br>// <br>// Notes: <br>// <br>STDMETHODIMP CStandardEnum::Clone <br>( <br>    IEnumGeneric **ppEnumClone <br>) <br>{ <br>    CStandardEnum *pNewEnum; <br> <br>    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement); <br>    RETURN_ON_NULLALLOC(pNewEnum); <br> <br>    // hold on to who we were cloned from so m_rgElements stays alive, and we don't <br>    // have to copy it. <br>    // <br>    pNewEnum-&gt;m_pEnumClonedFrom = this; <br> <br>    // AddRef() ourselves on their behalf. <br>    // <br>    AddRef(); <br>    *ppEnumClone = (IEnumGeneric *)pNewEnum; <br>    return S_OK; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
