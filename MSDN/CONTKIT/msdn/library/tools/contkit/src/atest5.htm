<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Control Initialization</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<p>&nbsp;</p>

<p><a name="_Toc383926425"><font face="Arial"><b><i>Control
Initialization</i></b></font></a></p>

<p><font size="2">After insertion, switch immediately to browse
view (<i>View | Form View</i>) to make sure your control
doesn&#146;t cause the error - &quot;No object in this
control.&quot; Many lightweight custom controls forget to mark
themselves as dirty after insertion in the container. Access
optimizes its code-path for saving cached merged type information
for the extender object and the controls inserted to just those
controls that have been dirtied in the current design session.
When the user views the form in browse view, the form gets
destroyed, and recreated. If the control has not marked itself as
dirty, then just the extender object is on the form with no
control inside of it. This is a common mistake when control
developers use the BaseCtl framework, but the fix is simple. MFC
and VB control writers don&#146;t have to worry about this since
the frameworks handle this for you. Here are some additional
comments from an email thread on a similar case:</font></p>

<blockquote>
    <p><font size="1" face="Arial">Some BaseCtl framework OCXs
    are getting the &quot;There is no object in this
    control&quot; error message when an Access &#145;97 form
    containing the control is reloaded. This is because Access
    &#145;97 expects all controls to save their binary state to a
    stream, and our controls only save when m_fDirty is TRUE.</font></p>
    <p><font size="1" face="Arial">To behave correctly, controls
    must dirty themselves before returning from their
    implementation of IPersistStreamInit::InitNew. Code has been
    added to COleControl::InitNew to dirty the control, but not
    all controls call COleControl::InitNew in their own
    implementation of the method.</font></p>
    <p><font size="1" face="Arial">Controls can do initialization
    in the COleControl::InitializeNewState overideable to ensure
    that the control will initialize properly for both
    IpersistStorage::InitNew and IpersistStreamInit::InitNew.
    Since the initialization is commonly done in
    IPersistStreamInit::InitNew, you should make sure m_fDirty is
    set to TRUE, or better yet, call COleControl::InitNew.</font></p>
    <p><font size="1" face="Arial">Note, if you move your
    initialization to COleControl::InitializeNewState, you are
    guaranteed to get dirtied for both IPersistStorage::InitNew,
    and IPersistStreamInit::InitNew, because COleControl's code
    path for both implementations of InitNew will call
    InitializeNewState.</font></p>
</blockquote>
</body>
</html>
