<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>OC96 and Windowless Controls</title>
<style>@import url(/msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="/msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">


<p>&nbsp;</p>

<h2><font size="2" face="VERDANA,ARIAL,HELVETICA">OC96 and
Windowless Controls</font></h2>

<p><font size="2" face="VERDANA,ARIAL,HELVETICA">The OC96 (or OLE
Controls '96) specification is not new, but full support is only
now appearing in mainstream applications such as Office 97 forms
and Internet Explorer 4.0. Therefore, this specification deserves
further attention. It includes many performance enhancements
because one of the primary driving factors with this
specification was to improve the performance of controls. One of
the key features is support for windowless controls. Not only
does this improve performance, but it also allows a control to
have transparency and irregular shapes and thus partake in
overlapping 2D layout with specific z-order. All the enhancements
are designed to be compatible with existing OLE Controls
technology, so a backward-compatible control should be easy to
implement. </font></p>

<p><font size="2" face="VERDANA,ARIAL,HELVETICA">Key features of
OC96 include: </font></p>

<ul>
    <li><font size="2" face="VERDANA,ARIAL,HELVETICA"><b>Delayed
        activation.</b> Delaying the activation of a control
        means that a page can instantiate and be ready for
        interaction with the user faster, particularly if there
        are multiple controls on the page. A new interface, <b>IPointerInactive</b>,
        allows a control to remain inactive but still interact
        minimally with the mouse and drag and drop. Although the
        control still activates, it only does so as the result of
        some interaction with the user. </font></li>
    <li><font size="2" face="VERDANA,ARIAL,HELVETICA"><b>Windowless.</b>
        By not having its own window, a control can make
        efficient use of its container's window. Performance
        advantages thus are brought about by fewer resources
        being consumed and faster activation/deactivation. New
        interfaces are introduced to support windowless controls.
        The main new interfaces are <b>IOleInPlaceObjectWindowless</b>
        and <b>IOleInPlaceSiteWindowless</b>, which derive from
        their namesakes without the <b>Windowless</b> extension.
        When drawing itself, a control asks the <b>IOleInPlaceSiteWindowless</b>
        interface for a device context, and returns the device
        context after drawing. Although windowless support of a
        control is often seen in terms of providing transparency
        for interesting visual effects, supporting windowless
        modes of operation will further improve performance. </font></li>
    <li><font size="2" face="VERDANA,ARIAL,HELVETICA"><b>Hit
        detection.</b> To complete the visual benefits of
        transparency that a windowless control can provide, hit
        detection is available so that a control can have an
        irregular shape. If the container detects that the
        rectangular extent occupied by a windowless control has
        been hit, it calls <b>IViewObjectEx::QueryHitPoint</b>
        (another new interface for windowless controls). The
        control then determines if it has been hit and returns an
        indication to the container. </font></li>
    <li><font size="2" face="VERDANA,ARIAL,HELVETICA"><b>Quick
        activation.</b> To further speed activation of a control,
        a new interface, <b>IQuickActivate</b> is introduced and
        can optionally be implemented by the control. A method on
        this interface is called by the container to pass a
        structure to the control, and to receive a structure back
        from the control. These structures contain interface
        pointers frequently needed for controls and ambient
        properties. Using these structures to pass often-needed
        information during activation can cut own on the
        handshaking negotiation that frequently takes place when
        instantiating a control. </font></li>
</ul>
</body>
</html>
