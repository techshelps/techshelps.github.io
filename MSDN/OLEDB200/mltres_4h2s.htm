<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMultipleResults::GetResult</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbimultipleresults__getresult"></a>IMultipleResults::GetResult</h1>
<p>
Returns the next in a series of multiple results from the provider.</p>
<pre><code>HRESULT GetResult(
   IUnknown *   pUnkOuter,
   LONG         lReserved,
   REFIID         riid,
   LONG *      pcRowsAffected,
   IUnknown **   ppRowset);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>pUnkOuter</i></p>
<p class=indent>
[in]<br>
A pointer to the controlling <b>IUnknown</b> interface if the object is being created as part of an aggregate; otherwise, it is a null pointer.</p>
<p class=dt>
<i>lReserved</i></p>
<p class=indent>
[in]<br>
Reserved. Must be set to zero. </p>
<p class=dt>
<i>riid</i></p>
<p class=indent>
[in]<br>
The requested interface to return in <i>*ppRowset</i>. This interface is conceptually added to the list of required interfaces on the resulting rowset, and the method fails (E_NOINTERFACE) if that interface cannot be supported on the resulting rowset.</p>
<p class=tl>
If this is IID_NULL, then <i>ppRowset</i> is ignored and no rowset is returned, even if one exists.</P><p class=dt>
<i>pcRowsAffected</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the count of rows affected by an update, delete, or insert. If the value of <i>cParamSets</i> passed into <b>ICommand::Execute</b> was greater than 1, then <i>*pcRowsAffected </i>is the total number of rows affected by all of the sets of parameters represented by the current result. If the count of affected rows is not available, <i>*pcRowsAffected</i> is set to DB_COUNTUNAVAILABLE on output. If the result is not a count of rows affected by an update, delete, or insert, <i>*pcRowsAffected</i> is undefined on output. If an error occurs, *<i>pcRowsAffected</i> is set to DB_COUNTUNAVAILABLE. If <i>pcRowsAffected</i> is a null pointer, no count of affected rows is returned.</p>
<p class=tl>
Some providers do not support returning individual counts of rows, but instead return an overall count of the total rows affected by the call to <b>Execute</b>, or do not return row counts at all. Such providers set <i>*pcRowsAffected</i> to DB_COUNTUNAVAILABLE when the count of affected rows is not available.</P><p class=dt>
<i>ppRowset</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the interface for the next result. If the next result is not a rowset (for instance, if it is the count of the rows affected by an update, delete, or insert), this is set to a null pointer. If an error occurs, *<i>ppRowset</i> is set to a null pointer.</p>
<p class=tl>
If <i>ppRowset</i> is a null pointer, no rowset is created. <br>
</P><p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
This can be returned for either of the following reasons:
<ul type=disc>
<li>
An error occurred, returning one or more output parameter values associated with the next result. To determine which output parameters were not returned, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Getting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.<br><br></li>
<li>
The rowset was opened but one or more properties—for which the <i>dwOptions</i> element of the DBPROP structure was DBPROPOPTIONS_OPTIONAL—were not set. The consumer calls <b>IRowsetInfo::GetProperties</b> to determine which properties were set.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
DB_S_NORESULT<br>
There are no more results. *<i>ppRowset</i> is set to a null pointer and *<i>pcRowsAffected</i> is set to –1.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_STOPLIMITREACHED<br>
Execution has been stopped because a resource limit has been reached. The results obtained so far have been returned. Calling <b>GetResult</b> again returns information for the next result, or DB_S_NORESULT if no more results can be obtained, either because they do not exist or because the resource limit applies across multiple results.</p>
<p class=tl>
This return code takes precedence over DB_S_ERRORSOCCURRED. That is, if the conditions described here and those described in DB_S_ERRORSOCCURRED both occur, the provider returns this code. When the consumer receives this return code, it should also check for the conditions described in DB_S_ERRORSOCCURRED.</P><p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>lReserved</i> was not zero.</p>
<p class=dt>
</p>
<p class=indent>
E_NOINTERFACE<br>
The interface specified in <i>riid</i> was not supported on the rowset.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to create the rowset.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ABORTLIMITREACHED<br>
Execution has been aborted because a resource limit has been reached. No results have been returned. Calling <b>GetResult</b> again returns information for the next result, or DB_S_NORESULT if no more results can be obtained, either because they do not exist or because the resource limit applies across multiple results.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTCONVERTVALUE<br>
A literal value in the command text associated with the next result could not be converted to the type of the associated column for reasons other than data overflow.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DATAOVERFLOW<br>
A literal value in the command text associated with the next result overflowed the type specified by the associated column.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSINCOMMAND<br>
The command text associated with the next result contained one or more errors. Providers should use OLE DB error objects to return details about the errors.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
The method failed due to one or more invalid input parameter values associated with the next result. To determine which input parameter values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6. </p>
<p class=tl>
The rowset was not returned because one or more properties—for which the <i>dwOptions</i> element of the DBPROP structure was DBPROPOPTIONS_REQUIRED or an invalid value—could not be satisfied.</P><p class=dt>
</p>
<p class=indent>
DB_E_INTEGRITYVIOLATION<br>
A literal value in the command text associated with the next result violated the integrity constraints for the column.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOAGGREGATION<br>
<i>pUnkOuter</i> was not a null pointer, and the object being created does not support aggregation.</p>
<p class=indent>
<i>pUnkOuter</i> was non-null and <i>riid</i> was not IID_Unknown. </p>
<p class=dt>
</p>
<p class=indent>
DB_E_OBJECTOPEN<br>
The previous rowset is still open, and the provider does not support multiple open results simultaneously (DBPROP_MULTIPLERESULTS is DBPROPVAL_MR_SUPPORTED).</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to get the next result. <br>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>GetResult</b> returns the next in a series of multiple results from the provider. If the requested result is a rowset, <b>GetResult</b> returns the requested interface on that rowset. If the requested result is a row count, <b>GetResult</b> returns the count of rows affected in *<i>pcRowsAffected</i>.</p>
<p>
Providers will generally be able to process only one result at a time. For maximum interoperability, consumers should free any rowset obtained by a previous call to <b>GetResult</b> before requesting the next result.</p>
<p>
Providers may check the entire command text for errors at execute time, or may check the command text associated with each result when that result is retrieved. Therefore, the syntax errors returned by <b>ICommand::Execute</b> can also be returned by <b>GetResult</b>. In this case, the next call to <b>GetResult</b> moves on to the next result, or returns DB_S_NORESULT if no more results are available.</p>
<p>
When <b>GetResult</b> returns an error, its behavior depends on the error that occurred:
<ul type=disc>
<li>
If <b>GetResult</b> returns E_INVALIDARG, DB_E_NOAGGREGATION or DB_E_OBJECTOPEN, the current result is still available. Assuming there are no other errors, the next call to <b>GetResult</b> returns the current result.<br><br></li>
<li>
If <b>GetResult</b> returns any other error, the current result is lost. The next call to <b>GetResult</b> returns either the next result or DB_S_NORESULT if the error caused the provider to lose all remaining results. Providers that can recover the current result in this situation must discard it and return the next result.</li>
</ul>
<p>
The following example shows how a consumer might process multiple results:</p>
<pre><code>hr = pICommandText-&gt;Execute(pUnkOuter, IID_IMultipleResults, pParams, &amp;cRowsAffected,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;pIMultipleResults);

if (pIMultipleResults) {
 while(hr != DB_S_NORESULT) {
  if(SUCCEEDED(hr = pIMultipleResults-&gt;GetResult(pUnkOuter, 0, IID_IRowset,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;cRowsAffected, &amp;pIRowset))) {
 &nbsp; if(pIRowset) {
 &nbsp;&nbsp; // The next result is a rowset. Process the rowset.
 &nbsp;&nbsp; pIRowset-&gt;Release();
 &nbsp; } else {
 &nbsp;&nbsp; // The next result is not a rowset. Process the nonrowset result.
 &nbsp; }
  } else {
 &nbsp; // Process error from GetResult.
 &nbsp; break;
  }
 }
 pIMultipleResults-&gt;Release();
}
</code></pre>
<p class=label>
<b>See Also</b></p>
<p>
<a href="command_9zhh.htm">ICommand::Execute</a></p>
</font></BODY>
</HTML>
