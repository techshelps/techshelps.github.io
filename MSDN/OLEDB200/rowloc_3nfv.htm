<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetLocate::GetRowsByBookmark</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetlocate__getrowsbybookmark"></a>IRowsetLocate::GetRowsByBookmark</h1>
<p>
Fetches the rows that match the specified bookmarks.</p>
<pre><code>HRESULT GetRowsByBookmark (
   HCHAPTER         hChapter,
   ULONG            cRows,
   const ULONG      rgcbBookmarks[],
   const BYTE *         rgpBookmarks[],
   HROW                rghRows[],
   DBROWSTATUS   rgRowStatus[]);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>cRows</i></p>
<p class=tl>
[in]<br>
The number of rows to fetch.</P><p class=tl>
If <i>cRows</i> is zero, no rows are fetched; the fetch direction and the next fetch position are unchanged, and the provider performs no processing, returning immediately from the method invocation.</P><p class=indent>
If the provider does not discover any other errors, the method returns S_OK; whether the provider checks for any other errors is provider-specific.</p>
<p class=dt>
<i>rgcbBookmarks</i></p>
<p class=indent>
[in]<br>
An array containing the length in bytes of each bookmark. </p>
<p class=dt>
<i>rgpBookmarks</i></p>
<p class=indent>
[in]<br>
An array containing a pointer to the bookmark of each row sought. These cannot be pointers to a standard bookmark (DBBMK_FIRST, DBBMK_LAST, DBBMK_INVALID). If <i>rgpBookmarks contains a duplicate bookmark, the corresponding row is </i>fetche<i>d and the reference count incremented once for each occurrence of the bookmark.</i></p>
<p class=dt>
<i>rghRows</i></p>
<p class=indent>
[out]<br>
An array with <i>cRows</i> elements in which to return the handles of the fetched rows. The consumer allocates this array but is not required to initialize the elements of it. In each element of this array, if the row was fetched, the provider returns the handle of the row identified by the bookmark in the corresponding element of <i>rgpBookmarks</i>. If the row was not fetched, the provider returns DB_NULL_HROW.</p>
<p class=dt>
<i>rgRowStatus</i></p>
<p class=indent>
[out]<br>
An array with <i>cRows</i> elements in which to return values indicating the status of each row specified in <i>rgpBookmarks</i>. If no errors or warnings occur while fetching a row, the corresponding element of <i>rgRowStatus</i> is set to DBROWSTATUS_S_OK. If an error occurs while fetching a row, the corresponding element is set as specified in DB_S_ERRORSOCCURRED. The consumer allocates memory for this array but is not required to initialize it. If <i>rgRowStatus</i> is a null pointer, no row statuses are returned. For information about the DBROWSTATUS enumerated type, see "<a href="ch13pr_5ib7.htm">Arrays of Errors</a>" in Chapter 13.</p>
<p class=label>
<br>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. All rows were successfully fetched. The following value can be returned in <i>rgRowStatus</i>:
<ul type=disc>
<li>
The row was successfully fetched. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_S_OK.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while fetching a row, but at least one row was successfully fetched. Successes can occur for the reasons listed under S_OK. The following errors can occur:
<ul type=disc>
<li>
An element of <i>rgpBookmarks</i> pointed to an invalid or incorrectly formed bookmark. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
An element of <i>rgpBookmarks</i> pointed to a bookmark that did not match any rows in the rowset. This includes the case when the row corresponding to the bookmark has been deleted. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
An element of <i>rgcbBookmarks</i> was zero. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
An element of <i>rgpBookmarks</i> was a null pointer. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
An element of <i>rgpBookmarks</i> pointed to a standard bookmark (DBBMK_FIRST, DBBMK_LAST, DBBMK_INVALID). The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
The row corresponding to the bookmark was not fetched because fetching it would have exceeded the total number of active rows supported by the rowset. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_LIMITREACHED.<br><br></li>
<li>
The row corresponding to the bookmark was not fetched for the following reason. Fetching rows required further execution of the command, such as when the rowset uses a server-side cursor. Execution has been stopped because a resource limit has been reached. Execution cannot be resumed. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_LIMITREACHED.<br><br></li>
<li>
The rowset ran out of memory and was unable to fetch the row. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_OUTOFMEMORY.<br><br></li>
<li>
The consumer did not have sufficient permission to fetch a row. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_PERMISSIONDENIED.<br><br></li>
<li>
The consumer encountered a recoverable, provider-specific error, such as an RPC failure when transmitting the change to a remote server. The corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_FAIL.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>rghRows</i> was a null pointer.</p>
<p class=tl>
<i>rgcbBookmarks</i> or <i>rgpBookmarks</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return the row handles.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Errors occurred while fetching all of the rows. Errors can occur for the reasons listed under DB_S_ERRORSOCCURRED.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of existing rows before new ones can be fetched. For more information, see DBPROP_CANHOLDROWS in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>GetRowsByBookmark</b> increments the reference count of each row for which it returns a handle by 1. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned.</p>
<p>
If the provider encounters a problem fetching a row&nbsp;— for example, data stored in a text file contains a letter in a numeric column&nbsp;— <b>GetRowsByBookmark</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>IRowset::GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
If <b>GetRowsByBookmark</b> encounters an error while attempting to fetch a row, such as a bad bookmark or adeleted row, it notes the error in the <i>rgRowStatus</i> array, continues processing, and returns DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED. Although the rows are fetched in undefined order, the ordering of the error array must match the order of the bookmark array, so the consumer can perform a side-by-side scan of each array to determine which rows were not fetched.</p>
<p>
For information about what <b>GetRowsByBookmark</b> does when it fetches a row that it already has in its internal buffers, see "<a href="ch04pr_6pmc.htm">Uniqueness of Rows in the Rowset</a>" in Chapter 4. For information about whether <b>GetRowsByBookmark</b> can detect changes made to rows in the rowset, see "<a href="ch05pr_18oj.htm">Visibility of Changes</a>" in Chapter 5.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowloc_2oj8.htm">IRowsetLocate::GetRowsAt</a>, <a href="rowscr_8vu7.htm">IRowsetScroll::GetRowsAtRatio</a></p>
</font></BODY>
</HTML>
