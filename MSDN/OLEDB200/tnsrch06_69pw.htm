<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>INTERSECT</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="intersect"></a>INTERSECT</h1>
<h2>Removing Duplicates</h2>
<p>
Consider EXCEPT(S1, S2) where:</p>
<p>
S1 = {Kansas, Buffalo, Buffalo, Topeka, Topeka, Wichita, Canada, BC}</p>
<p>
S2 = {Buffalo, Topeka, Topeka, Canada, Quebec}
<ol>
<li>
As shown in "Literal Sets," make two tables — S1 and S2 — that contain the fully qualified member names in the sets S1 and S2, respectively.<br><br></li>
<li>
The following query does the intersect:<pre><code>SELECT Name, NewRank AS Rank
FROM 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((SELECT Name, Rank FROM S1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; WHERE S1.Name IN (SELECT Name FROM S2))
 &nbsp;&nbsp;&nbsp;&nbsp; RANKTOP 1 LEVELS RANKORDER BY Rank RANKGROUP BY Name)
 &nbsp; RANK ROWS AS NewRank RANKORDER BY Rank)
ORDER BY Rank
</code></pre>
<p class=tl>
In English, the query:</P><ol>
<li>
Selects the rows of S1 that are also in S2.<br><br></li>
<li>
The RANKTOP operation groups duplicates into separate groups by using the GROUP BY clause and orders each group by Rank and picks up the first one. This ensures that duplicates are eliminated from the tail.<br><br></li>
<li>
The RANK operation orders the filtered rows by Rank and assigns a new rank to each row so that input ordering is preserved.<b> </b></li>
</ol>
</li>
</ol>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You cannot use the INTERSECT operation of SQL-92 because duplicate elimination is not guaranteed to remove duplicates from the tail.</p>
<h2>Retaining Duplicates</h2>
<p>
Consider INTERSECT(S1, S2, ALL). As in the previous section, tables are generated for S1 and S2. Then you use the following query:</p>
<pre><code>SELECT Name, NewRank AS Rank
FROM 
 &nbsp;&nbsp;&nbsp;&nbsp; ((SELECT Name, Rank FROM S1
 &nbsp;&nbsp;&nbsp;&nbsp; WHERE S1.Name IN (SELECT Name FROM S2))
 &nbsp; RANK ROWS AS NewRank RANKORDER BY Rank)
ORDER BY Rank
</code></pre>
<p>
This is simpler because there is no need to remove duplicates. After the query that finds the intersect, the RANK operation generates a rank value for each of the rows of the resulting table. The outer SELECT emits this table, ordering it by the NewRank (renamed as Rank) column.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;You cannot use INTERSECT ALL from SQL-92 because its semantics are as follows: If a row <i>r</i> appears <i>n </i>times in S1 and <i>m</i> times in S2, then <i>r</i> appears exactly <i>p</i> times in the result, where <i>p</i> is the lesser of&nbsp; <i>m </i>and <i>n</i>. Moreover, the order of these <i>p</i> rows is not preserved.</p>
<h2>Generalizing for Sets with Arbitrary Dimensionality</h2>
<p>
Each tuple has more than one element for these sets. Replace the NAME column in the select list of each SELECT statement above by a list of columns (equivalent to the number of dimensions in the input sets). Add as many IN clauses in the WHERE as there are columns, one for each column.</p>
</font></BODY>
</HTML>
