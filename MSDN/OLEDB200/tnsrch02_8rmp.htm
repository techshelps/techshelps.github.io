<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Describing and Fetching Cell Data</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="describingfetchingcelldata"></a>Describing and Fetching Cell Data</h1>
<p>
Before the application can actually fetch cell data, it needs to know exactly what data is available in each cell, their data types, and so on. This section describes how these tasks are handled.</p>
<h2>A Conceptual Model for Cell Data</h2>
<p>
Each cell in the dataset has several pieces of data associated with it. First and foremost is the actual data value itself. As described in “Retrieving Cell Properties,” OLE DB for OLAP requires all providers to support at least two other properties: FORMATTED_VALUE and CELL_ORDINAL. You can use the CELL PROPERTIES clause to select the cell properties that the consumer wants to retrieve.</p>
<p>
Each cell in the dataset is modeled as a row and each column in this row represents a cell property. Therefore, the dataset itself becomes a set of rows, with each row containing the data for a cell. Modeling a dataset in this fashion enables the reuse of existing methods and structures in OLE DB for describing and binding to data.</p>
<h2>Describing Cell Properties</h2>
<p>
Because properties of a cell are modeled as columns in a row, you can use the interface <b>IColumnsInfo</b> to find out the name, data type, number of bytes required to transfer the data, and other related information about each property. For more information on <b>IColumnsInfo, </b>see the <i>OLE DB Programmer’s Reference</i>.</p>
<h2>Data Type of VALUE</h2>
<p>
The VALUE property of a cell, depending on the cell that you are looking at, may contain data of different types. For example, consider the query:</p>
<pre><code>SELECT NON EMPTY Products.MEMBERS DIMENSION PROPERTIES
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Products.SKU, Products.SRP ON ROWS,
NON EMPTY CROSSJOIN(Years, (Sales, BudgetedSales, PercentChange)) 
 &nbsp; ON COLUMNS
FROM SalesCube
WHERE (January, SalesPerson.All, Geography.USA)
</code></pre>
<p>
The dataset that the application displays as:</p>
<p>
<img src="te_ch0207.gif" border=0></p>
<p>
You can see that the <b>NON EMPTY</b> clause suppressed the “PercentChange” column for 1996, because the company did not track its financials before 1996. Therefore, this measure makes no sense.</p>
<p>
In this dataset, the heavily shaded regions are displayed using the information from the axes rowsets. The rest is a display of cells. Among these, the data type of the cells in the lightly shaded region is double, but the data type of the cells in the unshaded region is integer.</p>
<p>
Because each cell is modeled as a row, the rowset corresponding to the dataset has 20 rows. The ordinal number of each cell is in parentheses below the cell data. The data type of the VALUE column in rows 4, 9, 14, and 19 is double and the data type of the other rows is integer. The interface <b>IColumnsInfo</b> is not designed to describe rowsets for which the data type of a column varies based on the row. (This same problem does not exist for any other cell properties defined in OLE DB for OLAP.)</p>
<p>
To solve this problem, OLE DB for OLAP treats the VALUE property of a cell as the DBTYPE_VARIANT data type of OLE DB. This data type is capable of holding data of many different types. The consumer can look at the <i>vt</i> column of the VARIANT structure, determine the actual type of VALUE, and interpret it accordingly.</p>
<h2>Information on Supported Conversions</h2>
<p>
When fetching cell data, the consumer can ask the provider to perform data conversion to a desired target type. To do this, the consumer needs to know what data type conversions the provider supports. This information is available through the <b>IConvertType </b>interface. This is a mandatory interface on the dataset object. It has a single method, <b>IConvertType::CanConvert</b>. This method takes a source type and a target type and returns S_OK if the source type can be converted to the target type, or S_FALSE otherwise.</p>
<h2>Getting Cell Data</h2>
<p>
OLE DB for OLAP uses the same model OLE DB uses for retrieving data. In this model, the consumer:
<ol>
<li>
Allocates a buffer to hold the data it wants to fetch. The size of this buffer is determined by the data type, precision, scale, length, and so on of the column data, and this information is available through the methods in IColumnsInfo interface.<br><br></li>
<li>
Chooses the columns in the dataset’s rowset that it wants to retrieve (in other words, the cell properties that it wants).<br><br></li>
<li>
Allocates an array of DBBINDING structures, one structure for every column in the rowset. This structure is populated with the following information:<ul type=disc>
<li>
The column ordinal that corresponds to this structure.<br><br></li>
<li>
The desired data type. This is the type that the application wants the data to be in; that is, the <i>target</i> type. If the target type is different from the source type, then the provider performs the necessary data type conversion.<br><br></li>
<li>
Offset in the buffer where the data for this column is to be placed.<br><br></li>
<li>
Offset in the buffer where the number of retrieved bytes is to be placed (for string and other variable length data).<br><br></li>
<li>
Offset in the buffer where the status indicator is to be placed.<br><br></li>
<li>
Other pieces of information not relevant to this discussion.</li>
</ul>
</li>
<li>
Obtains the <b>IAccessor</b> interface on the dataset object and uses <b>IAccessor::CreateAccessor</b> to create an accessor and associate it with the set of bindings (that is, the array of DBBINDING structures). This method returns a handle to the created accessor.<br><br></li>
<li>
Gets the <b>IMDDataset</b> interface and calls <b>IMDDataset::GetCellData</b> method. This method takes as arguments:<ul type=disc>
<li>
The accessor created in step 4.<br><br></li>
<li>
Address of the buffer that was allocated in step 1.<br><br></li>
<li>
The cell ordinal that indicates the first cell of the cell set.<br><br></li>
<li>
The cell ordinal that indicates the last cell to fetch.</li>
</ul>
<p class=tl>
Using the binding information contained in the accessor, the provider populates the consumer’s buffer.</P></li>
</ol>
<p>
For more information on accessors, DBBINDING structure and data types, see the <i>OLE DB Programmer’s Reference</i>.</p>
</font></BODY>
</HTML>
