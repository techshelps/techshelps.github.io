<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Commands Generating Multiple-Rowset Results</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="commands_generating_multiple_rowset_results"></a>Commands Generating Multiple-Rowset Results</h1>
<p>
SQLOLEDB can return multiple rowsets from SQL Server statements. SQL Server statements return multiple-rowset results under the following conditions:
<ul type=disc>
<li>
Batched SQL statements submitted as a single command.<br><br></li>
<li>
Stored procedures that implement a batch of SQL statements.<br><br></li>
<li>
SQL statements that include the Transact-SQL COMPUTE or COMPUTE BY clause.</li>
</ul>
<h3>Batches</h3>
<p>
SQLOLEDB recognizes the semicolon character as a batch delimiter for SQL statements:</p>
<pre><code>WCHAR*&nbsp;&nbsp; wSQLString = L"SELECT * FROM Categories; "
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; L"SELECT * FROM Products";
<b><i>  </i></b></code></pre>
<p>
Sending multiple SQL statements in one batch is more efficient than executing each SQL statement separately. Sending one batch reduces the network roundtrips from the client to the server.</p>
<h3>Stored Procedures</h3>
<p>
SQL Server returns a result set for each statement in a stored procedure, so most SQL Server stored procedures return multiple result sets.</p>
<h3>COMPUTE BY and COMPUTE</h3>
<p>
The Transact-SQL COMPUTE BY clause generates subtotals within a SELECT statement result set. The COMPUTE clause generates a total at the end of the result set. SQLOLEDB returns each COMPUTE BY subtotal and the COMPUTE total as a separate rowset result.</p>
<h3>Using IMultipleResults</h3>
<p>
In general, consumers should use the <b>IMultipleResults</b> interface to process the rowset or rowsets returned by SQLOLEDB command execution.</p>
<p>
When SQLOLEDB submits a command for execution, SQL Server executes the statement or statements and returns any results. The complete process is a roundtrip from the client to the SQL Server and back. Each client connection to a SQL Server can have at most one active roundtrip. That is, within a SQLOLEDB session, only a single command object can be actively executing or returning results on the connection. This is the default result set behavior of SQL Server client connections.</p>
<p>
To complete a roundtrip, a client must process all results from command execution. Because SQLOLEDB command execution can generate multiple-rowset objects as results, use the <b>IMultipleResults</b> interface to ensure that application data retrieval completes the client-initiated roundtrip.</p>
<p>
The following Transact-SQL statement generates multiple rowsets, some containing row data from the <b>OrderDetails</b> table and some containing results of the COMPUTE BY clause:</p>
<pre><code>SELECT OrderID, FullPrice = (UnitPrice * Quantity), Discount,
  Discounted = UnitPrice * (1 - Discount) * Quantity
FROM OrderDetails
ORDER BY OrderID
COMPUTE
  SUM(UnitPrice * Quantity), SUM(UnitPrice * (1 - Discount) * Quantity)
  BY OrderID
<b><i>  </i></b></code></pre>
<p>
If a consumer executes a command containing this text and requests a rowset as the returned results interface, only the first set of rows is returned. The consumer may process all rows in the rowset returned, but until the command is canceled no other commands can be executed on the session object. The consumer can cancel the command either using <b>ICommand::Cancel</b> or by releasing all references held on the command object and the derived rowset.</p>
<p>
Using <b>IMultipleResults</b> in all instances allows the consumer to get all rowsets generated by command execution and allows consumers to intelligently determine when to cancel command execution and free a session object for use by other commands.</p>
<p class=indent>
<b>Note&nbsp;&nbsp;&nbsp;</b>When using SQL Server cursors, command execution creates the cursor. SQL Server returns success or failure on the cursor creation; therefore, the roundtrip to the SQL Server is complete upon the return from command execution. Each GetNextRows call then becomes a roundtrip. In this way, multiple active command objects can exist, each processing a rowset that is the result of a fetch from the server cursor. For more information, see "Rowsets and SQL Server Cursors."</p>
</font></BODY>
</HTML>
