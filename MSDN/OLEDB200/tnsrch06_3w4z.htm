<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Rank Operations</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="rankoperations"></a>Rank Operations</h1>
<h2>Rank Clause</h2>
<p>
Order of tuples is important in the sets processed by MDX. To preserve order, you need to generate a RANK column for every set. That column contains ordering information. The first tuple has a rank value of 1, the second has a rank value of 2, and so on. </p>
<p>
Rank values are generated by an extension to SQL: the RANK clause. This clause occurs at the end of a query expression (such as a SELECT statement). The input to this clause is a table and its output is also a table. The syntax is:</p>
<pre><code>&lt;rank_clause&gt; ::= 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; query_expression
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RANK ROWS | LEVELS [AS &lt;column_name&gt;] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RANKORDER BY &lt;sort_specification_list&gt;]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RANKGROUP BY &lt;grouping_column_reference_list&gt;]
</code></pre>
<p>
The semantics of this clause are as follows:
<ul type=disc>
<li>
If a RANKGROUP BY clause is present, then the set of incoming rows is divided into groups (according to the RANKGROUP BY clause). Otherwise, there is only one group. The following steps are performed on each group:<ol>
<li>
If a RANKORDER BY clause is present, then the rows are sorted accordingly. <br><br></li>
<li>
Rows are counted in their sort order (if any) by using two counters, row count and level count. Both counters start at 0. The first row increments both counts. Every input row increments row count by 1. The level count is incremented by 1 if a sort specification list is present and an input row differs from its preceding row in at least one element of the sort specification list.</li>
</ol>
</li>
<li>
The value for the new column (the one specified in &lt;column_name&gt; above) depends on whether ROWS or LEVELS was specified. If ROWS was specified, then the value is row count. If LEVELS is specified, then it is level count.<br><br></li>
<li>
If a name for the new column is not specified (using the AS &lt;column_name&gt; clause), then its name is RANK.<br><br></li>
<li>
There is one output row for every input row. The output rows have the same columns as the input rows, and have the extra rank column whose value is as described above.</li>
</ul>
<h2>RANKTOP Clause</h2>
<p>
Many OLAP operations require that a set of input tuples be separated into groups, and the top <i>x</i> rows be picked from each group (according to some criteria). As always, there is the requirement that the ordering be preserved. Clearly, what is required is an enhanced RANK clause that has the ability to pick the top <i>x</i> rows. This is achieved by the RANKTOP clause.</p>
<p>
This clause occurs at the end of a query expression (that is, a SELECT statement). The input to this clause is a table and its output is also a table. The syntax is</p>
<pre><code>&lt;ranktop_clause&gt; ::= 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;query_expression&gt;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RANKTOP &lt;numeric_value_expression&gt; ROWS 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | LEVELS [AS &lt;column_name&gt;]
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RANKORDER BY &lt;sort_specification_list&gt;] 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [RANKGROUP BY &lt;grouping_column_reference_list&gt;]
</code></pre>
<p>
The semantics of this clause are as follows:
<ul type=disc>
<li>
The first five items of semantics description are the same as the first four items of the RANK clause.<br><br></li>
<li>
An output row is produced if the value of the new column (the one specified in &lt;column_name&gt;) is less than or equal to &lt;numeric_value_expression&gt;.The output rows have the same columns as the input rows, and have the extra RANK column whose value is as described above.</li>
</ul>
<h2>Multiple RANK and RANKTOP Clauses</h2>
<p>
Both RANK and RANKTOP clauses are part of a query expression. That is, their output is a table. Therefore, if a query expression has more than one RANK or RANKTOP clause, then they are evaluated in the order of appearance. That is, the first clause results in a table that is used as the input to the second clause, which is in turn used as an input to the third clause, and so on.</p>
<p>
For example, in the query</p>
<pre><code>SELECT Name, Newrank AS Rank
FROM 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (((SELECT Name, "1" AS Src, Rank FROM S1
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UNION ALL
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SELECT Name, "2" AS Src, Rank FROM S2)
 &nbsp;&nbsp;&nbsp;&nbsp; RANKTOP 1 ROWS RANKORDER BY Src, Rank RANKGROUP BY Name)
 &nbsp; RANK ROWS AS NewRank RANKORDER BY Src, Rank)
ORDER BY Rank
</code></pre>
<p>
The innermost query expression (indented to the maximum) is used as an input to the RANKTOP clause. The output of the RANKTOP clause, which is again a table (shown above as being indented by two levels), is used as an input to the RANK clause. The output of the RANK clause is also a table (shown above as being indented by one level), which is used as input to the FROM clause.</p>
</font></BODY>
</HTML>
