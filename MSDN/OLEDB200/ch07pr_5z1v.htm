<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Storage Objects and Rowset Update Semantics</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbstorage_objects_and_rowset_update_semantics"></a>Storage Objects and Rowset Update Semantics</h1>
<p>
When does the data set in a storage object become visible to other transactions operating at the Read Uncommitted isolation level? For providers built over database servers, this question can also be phrased as, "When does data set in a storage object become visible at the data source?"</p>
<p>
The rules for storage objects are similar to the rules for data in other columns. That is, if the rowset is in immediate update mode, data made available to the rowset is immediately made available to Read Uncommitted transactions. If the rowset is in delayed update mode, data made available to the rowset is not made available to Read Uncommitted transactions until the consumer calls <b>IRowsetUpdate::Update</b>.</p>
<p>
However, storage objects differ in two ways from other, nonstorage columns in the rowset: 
<ul type=disc>
<li>
<b>Storage mode</b>—Storage objects can have another layer of buffering based on the storage mode in which they operate. If the storage object operates in transacted mode, data is not available to the rowset until the consumer calls <b>Commit</b> on the storage interface. If the storage object operates in direct mode, data is immediately available to the rowset when the consumer sets it in the storage object. <br><br></li>
<li>
<b>Ignore delayed update mode—</b>Because storage objects can be large, using them in delayed update mode can be expensive because the provider must locally cache any changes to them until <b>Update</b> is called. Consumers need to control this expense, so the DBPROP_DELAYSTORAGEOBJECTS property controls whether storage objects are always in immediate update mode, regardless of whether the rowset is in immediate or delayed update mode. For some providers this is a read-only property. See the following figure.</li>
</ul>
<p class=label>
<b>Storage object boundary controls</b></p>
<p>
<img src="ch0701.gif" border=0></p>
<p>
The following table shows the sequence of calls needed to make data set in a storage object visible to other transactions operating at the Read Uncommitted isolation level. In this table, <b>Write</b> refers collectively to any method on a storage interface that sets data, such as <b>ISequentialStream::Write</b>, <b>IStream::Write,</b> or <b>ILockBytes::WriteAt</b>, and <b>SetData</b> refers collectively to <b>IRowsetChange::SetData</b> and <b>IRowsetChange::InsertRow</b>. <b>ILockBytes</b> storage objects are always in Direct mode.</p>
<p class=label>
<b>Call sequence required for storage object visibility</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=19%><b><br>
Storage mode</b></td>
<td class=label width=18%><b><br>
Update mode</b></td>
<td class=label width=26%><b>DBPROP_DELAY<br>
STORAGEOBJECTS</b></td>
<td class=label width=37%><b>Calls needed to expose data to other transactions running at Read Uncommitted</b></td>
</tr>
<tr valign=top>
<td width=19%>Direct</td>
<td width=18%>Immediate</td>
<td width=26%>Not applicable</td>
<td width=37%><b>Write</b><br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b></td>
</tr>
<tr valign=top>
<td width=19%>Direct</td>
<td width=18%>Delayed</td>
<td width=26%>VARIANT_FALSE</td>
<td width=37%><b>Write</b><br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b></td>
</tr>
<tr valign=top>
<td width=19%>Direct</td>
<td width=18%>Delayed</td>
<td width=26%>VARIANT_TRUE</td>
<td width=37%><b>Write</b><br>
<b>Update</b><br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b><br>
<b>Update</b></td>
</tr>
<tr valign=top>
<td width=19%>Transacted</td>
<td width=18%>Immediate</td>
<td width=26%>Not applicable</td>
<td width=37%><b>Write</b><br>
<b>Commit</b> on storage interface<br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b></td>
</tr>
<tr valign=top>
<td width=19%>Transacted</td>
<td width=18%>Delayed</td>
<td width=26%>VARIANT_FALSE</td>
<td width=37%><b>Write</b><br>
<b>Commit</b> on storage interface<br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b></td>
</tr>
<tr valign=top>
<td width=19%>Transacted</td>
<td width=18%>Delayed</td>
<td width=26%>VARIANT_TRUE</td>
<td width=37%><b>Write</b><br>
<b>Commit</b> on storage interface<br>
<b>Update</b><br>
&nbsp;–&nbsp;or&nbsp;–&nbsp;<br>
<b>SetData</b><br>
<b>Update</b></td>
</tr>
</table><br>
<p>
When the rowset is in delayed update mode, the consumer cannot undo any pending changes made through a storage object if that object is still open. That is, if the provider creates a storage object over the BLOB and returns a pointer to it through <b>IRowset::GetData</b>, the consumer must release this storage object before calling <b>IRowsetUpdate::Undo</b>. If the consumer fails to release the storage object, <b>Undo</b> returns a status of DBROWSTATUS_E_OBJECTOPEN for the row.</p>
</font></BODY>
</HTML>
