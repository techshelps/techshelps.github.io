<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating SQL Server Indexes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="creating_sql_server_indexes"></a>Creating SQL Server Indexes</h1>
<p>
SQLOLEDB exposes <b>IIndexDefinition::CreateIndex</b> allowing consumers to define new indexes on SQL Server tables.</p>
<p>
SQLOLEDB creates table indexes as either indexes or constraints on a table. SQL Server gives constraint-creation privilege to the table owner, the database owner, and members of certain administrative roles. By default, only the table owner can create an index on a table. Therefore, <b>CreateIndex</b> success or failure depends not only on the application user’s access rights but also on the type of index created.</p>
<p>
Consumers specify the table name as a Unicode character string in the <i>pwszName </i>member of the <i>uName</i> union in the <i>pTableID</i> parameter. The <i>eKind </i>member of <i>pTableID</i> must be DBKIND_NAME.</p>
<p>
The <i>pIndexID</i> parameter can be NULL, and if it is, SQLOLEDB creates a unique name for the index. The consumer can capture the name of the index by specifying a valid pointer to a DBID in the <i>ppIndexID</i> parameter.</p>
<p>
The consumer can specify the index name as a Unicode character string in the <i>pwszName</i> member of the <i>uName</i> union of the <i>pIndexID</i> parameter. The <i>eKind</i> member of <i>pIndexID</i> must be DBKIND_NAME.</p>
<p>
The consumer specifies the column or columns participating in the index by name. For each DBINDEXCOLUMNDESC structure used in <b>CreateIndex</b>, the <i>eKind</i> member of the <i>pColumnID</i> must be DBKIND_NAME. The name of the column is specified as a Unicode character string in the <i>pwszName </i>member of the <i>uName</i> union in the <i>pColumnID</i>.</p>
<p>
SQLOLEDB, and SQL Server, support ascending order on values in the index. SQLOLEDB returns E_INVALIDARG if the consumer specifies DBINDEX_COL_ORDER_DESC in any DBINDEXCOLUMNDESC structure.</p>
<p>
<b>CreateIndex</b> interprets index properties as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=43%><b>Property ID</b></td>
<td class=label width=57%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_AUTOUPDATE</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_AUTOUPDATE.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_CLUSTERED</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: Controls index clustering.<br>
<br>
VARIANT_TRUE<br>
SQLOLEDB attempts to create a clustered index on the SQL Server table. SQL Server supports at most one clustered index on any table.<br>
<br>
VARIANT_FALSE<br>
SQLOLEDB attempts to create a nonclustered index on the SQL Server table.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_FILLFACTOR</td>
<td width=57%>R/W: Read/write<br>
Default: 0<br>
Description: Specifies the percent of an index page used for storage. For more information, see CREATE INDEX.<br>
<br>
The type of the variant is VT_I4. The value must be greater than or equal to 1 and less than or equal to 100.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_INITIALIZE</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_INITIALIZE.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_<br>
NULLCOLLATION</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_NULLCOLLATION.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_NULLS</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_NULLS.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_PRIMARYKEY</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: Creates the index as a referential integrity, primary key constraint.<br>
<br>
VARIANT_TRUE<br>
The index is created to support the table’s primary key constraint.<br>
<br>
VARIANT_FALSE<br>
The index is not used as a primary key constraint for row values in the table.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_<br>
SORTBOOKMARKS</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_SORTBOOKMARKS.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_TEMPINDEX</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_TEMPINDEX.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_TYPE</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: SQLOLEDB does not support DBPROP_INDEX_TYPE.<br>
Attempts to set the property in <b>CreateIndex</b> cause a DB_S_ERRORSOCCURED return value. The <i>dwStatus</i> member of the property structure indicates DBPROPSTATUS_BADVALUE.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_INDEX_UNIQUE</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: Creates the index as a unique constraint on the participating column or columns.<br>
<br>
VARIANT_TRUE<br>
The index is used to uniquely constrain row values in the table.<br>
<br>
VARIANT_FALSE<br>
The index does not uniquely constrain row values.</td>
</tr>
</table><br>
<h3>Example</h3>
<p>
This example creates a primary key index.</p>
<pre><code>////////////////////////////////////////////////////////////////////////
// Create the referential integrity, PRIMARY KEY constraint on
// OrderDetails as follows:
//
// CREATE TABLE OrderDetails
// (
//&nbsp; OrderID      int      NOT NULL
//&nbsp; ProductID   int      NOT NULL
//&nbsp;&nbsp;&nbsp; CONSTRAINT PK_OrderDetails
//&nbsp;&nbsp;&nbsp; PRIMARY KEY CLUSTERED (OrderID, ProductID),
//&nbsp; UnitPrice   money      NOT NULL,
//&nbsp; Quantity   int      NOT NULL,
//&nbsp; Discount   decimal(2,2)   NOT NULL
//&nbsp;&nbsp;&nbsp; DEFAULT 0
// )
//
HRESULT CreatePrimaryKey
  (
  IIndexDefinition* pIIndexDefinition
  )
  {
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr = S_OK;
<b><i>  </i></b>
  DBID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbidTable;
  DBID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbidIndex;
  const ULONG&nbsp;&nbsp; nCols = 2;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCol;
  const ULONG&nbsp;&nbsp; nProps = 2;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nProp;
<b><i>  </i></b>
  DBINDEXCOLUMNDESC dbidxcoldesc[nCols];
  DBPROP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dbpropIndex[nProps];
  DBPROPSET&nbsp;&nbsp;&nbsp;&nbsp; dbpropset;
<b><i>  </i></b>
  DBID*&nbsp;&nbsp;&nbsp;&nbsp; pdbidIndexOut = NULL;
<b><i>  </i></b>
  // Set up identifiers for the table and index.
  dbidTable.eKind = DBKIND_NAME;
  dbidTable.uName.pwszName = L"OrderDetails";
<b><i>  </i></b>
  dbidIndex.eKind = DBKIND_NAME;
  dbidIndex.uName.pwszName = L"PK_OrderDetails";
<b><i>  </i></b>
  // Set up column identifiers.
  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; dbidxcoldesc[nCol].pColumnID = new DBID;
 &nbsp;&nbsp; dbidxcoldesc[nCol].pColumnID-&gt;eKind = DBKIND_NAME;
<b><i>  </i></b>
 &nbsp;&nbsp; dbidxcoldesc[nCol].eIndexColOrder = DBINDEX_COL_ORDER_ASC;
 &nbsp;&nbsp; }
  dbidxcoldesc[0].pColumnID-&gt;uName.pwszName = L"OrderID";
  dbidxcoldesc[1].pColumnID-&gt;uName.pwszName = L"ProductID";
<b><i>  </i></b>
  // Set properties for the index. The index is clustered,
  // PRIMARY KEY.
  for (nProp = 0; nProp &lt; nProps; nProp++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; dbpropIndex[nProp].dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; dbpropIndex[nProp].colid = DB_NULLID;
<b><i>  </i></b>
 &nbsp;&nbsp; VariantInit(&amp;(dbpropIndex[nProp].vValue));
 &nbsp;&nbsp; 
 &nbsp;&nbsp; dbpropIndex[nProp].vValue.vt = VT_BOOL;
 &nbsp;&nbsp; }
  dbpropIndex[0].dwPropertyID = DBPROP_INDEX_CLUSTERED;
  dbpropIndex[0].vValue.boolVal = VARIANT_TRUE;
<b><i>  </i></b>
  dbpropIndex[1].dwPropertyID = DBPROP_INDEX_PRIMARYKEY;
  dbpropIndex[1].vValue.boolVal = VARIANT_TRUE;
<b><i>  </i></b>
  dbpropset.rgProperties = dbpropIndex;
  dbpropset.cProperties = nProps;
  dbpropset.guidPropertySet = DBPROPSET_INDEX;
<b><i>  </i></b>
  hr = pIIndexDefinition-&gt;CreateIndex(&amp;dbidTable, &amp;dbidIndex, nCols,
 &nbsp;&nbsp; dbidxcoldesc, 1, &amp;dbpropset, &amp;pdbidIndexOut);
<b><i>  </i></b>
  // Clean up dynamically allocated DBIDs.
  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; delete dbidxcoldesc[nCol].pColumnID;
 &nbsp;&nbsp; }
<b><i>  </i></b>
  return (hr);
  }
<b><i>  </i></b></code></pre>
</font></BODY>
</HTML>
