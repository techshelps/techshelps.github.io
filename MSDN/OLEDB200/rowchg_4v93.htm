<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetChange::InsertRow</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetchange__insertrow"></a>IRowsetChange::InsertRow</h1>
<p>
Creates and initializes a new row.</p>
<pre><code>HRESULT InsertRow (
   HCHAPTER      hChapter,
   HACCESSOR   hAccessor,
   void *            pData,
   HROW   *         phRow);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
The handle of the accessor to use.</p>
<p class=tl>
If <i>hAccessor</i> is a null accessor (that is, an accessor for which <i>cBindings</i> in <b>IAccessor::CreateAccessor</b> was zero), then <i>pData</i> is ignored and the rows are initialized as specified in the Comments. Thus, the role of a null accessor is to construct a default row; it is a convenient way for a consumer to obtain a handle for a new row without having to set any values in that row initially.</P><p class=dt>
<i>pData</i></p>
<p class=indent>
[in]<br>
A pointer to memory containing the new data values, at offsets that correspond to the bindings in the accessor.</p>
<p class=dt>
<i>phRow</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the handle of the new row. If this is a null pointer, then no reference count is held on the row. Consumers should set this to null if they do not require the ability to make further changes to, or retrieve data from, the newly inserted row. Whether or not default or computed values from the server are available when calling <b>GetData</b> for this row handle depends on the setting of the DBPROP_SERVERDATAONINSERT. If <b>InsertRow</b> returns an error, and <i>phRow</i> is not a null pointer on input, *<i>phRow</i> is set to null on output and no row handle is returned.</p>
<p class=indent>
<B><b>Note</b></B> Passing in a null pointer for <i>phRow</i>, or releasing the row handle returned in <i>*phRow</i>, does not release the row until the change is transmitted to the data source. If DBPROP_CANHOLDROWS is VARIANT_FALSE and the rowset is in deferred update mode, then in addition to freeing any reference counts on the hrow, the consumer must call <b>IRowsetUpdate::Update</b> in order to transmit the pending change to the data source before attempting to insert or retrieve any additional rows.</p>
<p class=indent>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The status of all columns bound by the accessor is set to DBSTATUS_S_OK or DBSTATUS_S_ISNULL.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while setting data for one or more columns, but data was successfully set for at least one column. To determine the columns for which values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pData</i> was a null pointer and <i>hAccessor</i> was not a null accessor.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to instantiate the row.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ABORTLIMITREACHED<br>
The rowset was in immediate update mode and the row was not inserted due to reaching a limit on the server, such as a query execution timing out.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor or was a reference accessor.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_CANCELED<br>
The insertion was canceled during notification. The row was not inserted.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTCONVERTVALUE<br>
The data value for one or more columns couldn't be converted for reasons other than sign mismatch or data overflow, and the provider was unable to determine which columns couldn't be converted. Providers that can detect which columns could not be converted return DB_S_ERRORSOCCURRED and set the status flag for the columns that couldn't be converted to DBSTATUS_E_CANTCONVERTVALUE.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DATAOVERFLOW<br>
Conversion failed because the data value for one or more columns overflowed the type used by the provider and the provider was unable to determine which columns caused the overflow. Providers that can detect which columns caused the overflow return DB_S_ERRORSOCCURRED and set the status flag for the columns in violation to DBSTATUS_E_DATAOVERFLOW.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
An error occurred while setting data for one or more columns and data was not successfully set for any columns. To determine the columns for which values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_INTEGRITYVIOLATION<br>
The data violated the integrity constraints for one or more columns of the rowset and the provider was unable to determine which columns violated the integrity constraints. Providers that can detect which columns violated the integrity constraints return DB_S_ERRORSOCCURRED and set the status flag for the columns in violation to DBSTATUS_E_INTEGRITYVIOLATION.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_MAXPENDCHANGESEXCEEDED<br>
The number of rows that have pending changes has exceeded the limit specified by the DBPROP_MAXPENDINGROWS property.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTSUPPORTED<br>
The provider does not support this method. </p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWLIMITEXCEEDED<br>
Creating another row would have exceeded the total number of active rows supported by the rowset.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The consumer attempted to insert a new row before releasing previously retrieved row handles or transmitting pending changes to the data source, and DBPROP_CANHOLDROWS is VARIANT_FALSE.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to insert a new row. This error can be returned only if the value of the DBPROP_ROWRESTRICT property is VARIANT_TRUE. If the rowset is in delayed update mode, this error might not be returned until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the applicable reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor:</b></p>
<p>
E_NOINTERFACE<br>
DB_E_BADBINDINFO<br>
DB_E_BADORDINAL<br>
DB_E_BADSTORAGEFLAGS<br>
DB_E_UNSUPPORTEDCONVERSION</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>InsertRow</b> creates a new row and initializes its columns. If <i>phRow</i> is not a null pointer, it then returns the handle of this row to the consumer and sets its reference count to one. In delayed update mode, the row is created locally to the rowset and is transmitted to the data source only when <b>IRowsetUpdate::Update</b> is called. In immediate update mode, the row is immediately transmitted to the data source. For more information, see "<a href="ch05pr_0ue9.htm">Changing Data</a>" in Chapter 5.</p>
<p>
To the consumer, newly inserted rows are almost indistinguishable from other rows. For example, they can be deleted with <b>DeleteRows</b> and updated with <b>SetData</b>. However, methods that fetch rows might not be able to return them. For more information, see "<a href="ch05pr_112r.htm">Visibility of Pending Changes</a>" and "<a href="ch05pr_010z.htm">Visibility of Transmitted Changes</a>" in Chapter 5. Furthermore, they might not contain the correct values for computed columns, including bookmark columns on some providers.</p>
<p>
For information about where rows are inserted in the rowset, see "<a href="ch05pr_0bar.htm">Position of Inserted Rows</a>" in Chapter 5.</p>
<p>
The DBPROP_COLUMNRESTRICT and DBPROP_ROWRESTRICT properties affect how security is enforced and how security errors are returned. If DBPROP_COLUMNRESTRICT is VARIANT_TRUE, the consumer might not have write permission on some columns. If the consumer attempts to write to these columns, <b>InsertRows</b> returns a column status of DBSTATUS_E_PERMISSIONDENIED and a return code of DB_S_ERRORSOCCURRED. If the DBPROP_ROWRESTRICT property is VARIANT_TRUE, the consumer might not have permission to insert some rows. If the consumer attempts to insert one of these rows, <b>InsertRows</b> returns a code of DB_SEC_E_PERMISSIONDENIED and no new row is created.</p>
<p>
When a row is created, initialization proceeds in an orderly fashion:
<ol>
<li>
The provider sets all columns to their default values. If there is no default value and the column is nullable, it sets the column to NULL. If the column is non-nullable, it sets the column status to DBSTATUS_E_UNAVAILABLE. If the provider is unable or unwilling to determine the default value of a column or whether that column is nullable, it sets the column status to DBSTATUS_E_UNAVAILABLE; the provider might be unwilling to determine default values and nullability if doing so requires a call to the data source.<p class=tl>
If the column status is DBSTATUS_E_UNAVAILABLE, the consumer can still send this value to the data source to use the default. In this case, the default is available after the insertion is transmitted to the data source. To see the default, the consumer must call <b>GetLastVisibleData</b> or <b>RefreshVisibleData</b>. However, if there is no default for the column and it is non-nullable, this will cause a schema violation.</P></li>
<li>
The provider calls <b>IRowsetNotify::OnRowChange</b> with DBREASON_ROW_INSERT if any consumer of the rowset is using notifications. This serves as a hook allowing, among other things, more complex nondeclarative default values to be set in the row. For more information about notifications, see <a href="rownfy_1zzt.htm">IRowsetNotify</a>.<br><br></li>
<li>
<b>InsertRow</b> does not further modify the column values if the accessor is a null accessor; it returns the handle to the newly created row.<br><br></li>
<li>
The provider uses the accessor, if it is not a null accessor, to set columns with the values provided by the consumer in *<i>pData</i>. During this process, the provider does not generate notifications like it does when setting data in <b>SetData</b>. This prevents, for example, DBREASON_COLUMN_SET notifications from being generated for a row that is not yet properly constructed. For a complete description of how <b>InsertRow</b> sets data, see "<a href="ch06pr_5iap.htm">Setting Data</a>" in Chapter 6.<p class=tl>
The provider is not required to compute the value of computed columns. If the provider does not compute the value of these columns but lets the data source do so, then the computed value is not available until after the change is transmitted to the data source—that is, after <b>InsertRow</b> is called in immediate update mode or after <b>IRowsetUpdate::Update</b> if <b>InsertRow</b> is called in delayed update mode. To retrieve the computed value, the consumer calls <b>RefreshVisibleData</b> or <b>GetLastVisibleData</b> in <b>IRowsetRefresh</b>. Note that bookmark columns are often computed, such as when the bookmark is the primary key or is a ROWID assigned by the data source.</P></li>
</ol>
<p>
Domain and schema validation is enforced as it is with <b>SetData</b>.</p>
<p>
If <b>InsertRow</b> returns an error, it does not create a new row.</p>
<p>
It is not recommended to use null accessors because some providers may not be able to determine default values and may not be able to identify a row inserted with all default values.</p>
<p>
Here is an example of how one might write a projection-join to a temporary file:</p>
<pre><code>#include &lt;oledb.h&gt;
#include &lt;stddef.h&gt;
int main() {
 IRowset&nbsp;&nbsp; *pLeftRowset;
 IRowset&nbsp;&nbsp; *pRightRowset;
 IAccessor&nbsp;&nbsp; *pLeftRowsetAcc;
 IAccessor&nbsp;&nbsp; *pRightRowsetAcc;
 IAccessor&nbsp;&nbsp; *pJoinRowsetAcc;
 IRowsetChange *pJoinRowsetNew;
 ULONG&nbsp;&nbsp;&nbsp; cSortedRows;
 HROW&nbsp;&nbsp;&nbsp;&nbsp; rghLeftRows [500];
 HROW&nbsp;&nbsp;&nbsp;&nbsp; rghRightRows [500];
 //...
 //&lt; sort and prepare the rows &gt;
 //..

 struct join {
  long *pl;
  double *pd;
  short&nbsp; *pi;
 };

 static DBBINDING LeftBindings [1] = {
  {
 &nbsp; 1,
 &nbsp; offsetof (join, pl),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_I4 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  }
 };
 static DBBINDING RightBindings [2]= {
  {
 &nbsp; 1,
 &nbsp; offsetof (join, pd),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_R8 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  },
  {
 &nbsp; 2,
 &nbsp; offsetof (join, pi),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_I2 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  }
 };


 static DBBINDING JoinBindings [3] = {
  {
 &nbsp; 1,
 &nbsp; offsetof (join, pl),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_I4 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  },
  {
 &nbsp; 2,
 &nbsp; offsetof (join, pd),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_R8 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  },
  {
 &nbsp; 3,
 &nbsp; offsetof (join, pi),
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (void*),
 &nbsp; 0,
 &nbsp; DBTYPE_I2 | DBTYPE_BYREF,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
  }
 };

 HACCESSOR hLeft;
 HACCESSOR hRight;
 HACCESSOR hJoin;
 join&nbsp; theJoin;

 pLeftRowsetAcc-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1, LeftBindings, 0, &amp;hLeft,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

 pRightRowsetAcc-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 2, RightBindings, 0, &amp;hRight,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

 pJoinRowsetAcc-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 3, JoinBindings, 0, &amp;hJoin,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL);

 for (ULONG j = 0; j &lt; cSortedRows;&nbsp; j++) {
  pLeftRowset-&gt;GetData(rghLeftRows[j], hLeft, &amp;theJoin);
  pRightRowset-&gt;GetData(rghRightRows[j], hRight, &amp;theJoin);
  pJoinRowsetNew-&gt;InsertRow(NULL, hJoin, &amp;theJoin, NULL);
 } ;
};
</code></pre>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowchg_0c81.htm">IRowsetChange::SetData</a>, <a href="rowupd_2xyn.htm">IRowsetUpdate::Undo</a>, <a href="rowupd_49gl.htm">IRowsetUpdate::Update</a></p>
</font></BODY>
</HTML>
