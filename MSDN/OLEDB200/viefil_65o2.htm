<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IViewFilter</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbiviewfilter"></a>IViewFilter</h1>
<p>
<b>IViewFilter</b> enables consumers to restrict the contents of a rowset to rows matching a set of conditions.</p>
<h1>When to Implement</h1>
<p>
Providers that can define a subset of rows based on a consumer-defined set of conditions expose <b>IViewFilter</b>. A provider may restrict functionality to filters based on existing indexes, or filters may require a specific sort order also to be applied.</p>
<h1>When to Call</h1>
<p>
Consumers needing a subset of rows can call <b>IViewFilter::SetFilter</b> to apply a filter condition to a view. Rowsets or chapters opening using this view expose only those rows that match the criteria. Each view can have only a single filter applied, but a view containing a filter can be applied to an existing filtered chapter to further filter its contents.</p>
<p>
Filter criteria are expressed as an array of rows and columns, with an associated set of comparison operators.</p>
<p>
Within a row of the criteria array, each column corresponds to a column in the table. The mapping of the columns in the criteria array to the columns in the table is done through an accessor passed into <b>SetFilter</b> or <b>GetFilter</b>. The same column from the table may appear once, more than once, or not at all in the criteria array. Each column in the criteria array has a corresponding comparison operation that defines how the value passed in the criteria array is to be compared to the value of the corresponding column in the rowset. Each column of the criteria array is joined in a logical AND with the other columns in that row of the criteria array.</p>
<p>
The criteria array can contain multiple rows. In this case, the array of comparison operations is a two-dimensional array stored in row-major format, such that the comparison operators for each of the columns of the first row in the criteria array are followed by the comparison operators for each column of the second row in the criteria array, and so forth. Multiple rows in the criteria array are joined together in a logical OR.</p>
<p>
For example, assume the following rowset:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=34%><b>Name</b></td>
<td class=label width=34%><b>Children</b></td>
<td class=label width=32%><b>State</b></td>
</tr>
<tr valign=top>
<td width=34%>Joe</td>
<td width=34%> 0</td>
<td width=32%>WA</td>
</tr>
<tr valign=top>
<td width=34%>Jane</td>
<td width=34%> 2</td>
<td width=32%>WA</td>
</tr>
<tr valign=top>
<td width=34%>Fred</td>
<td width=34%> 3</td>
<td width=32%>OR</td>
</tr>
<tr valign=top>
<td width=34%>Judy</td>
<td width=34%> 1</td>
<td width=32%>OR</td>
</tr>
<tr valign=top>
<td width=34%>Jane</td>
<td width=34%> 2</td>
<td width=32%>ID</td>
</tr>
</table><br>
<p>
The following table shows the results for various combinations of accessor bindings, criteria array, and comparison operators.<br>
</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=26%><b>Accessor</b></td>
<td class=label width=30%><b>Criteria Array</b></td>
<td class=label width=18%><b>Comparison Ops</b></td>
<td class=label width=26%><b>Result</b></td>
</tr>
<tr valign=top>
<td width=26%>rgBindings[0].iOrdinal = 3</td>
<td width=30%>{DBCOMPAREOPS_EQ}</td>
<td width=18%>{"WA"}</td>
<td width=26%>"Joe"0 "WA"<p>
"Jane"2 "WA"</p>
</td>
</tr>
<tr valign=top>
<td width=26%>rgBindings[0].iOrdinal=3</td>
<td width=30%>{DBCOMPAREOPS_EQ, DBCOMPAREOPS_EQ}</td>
<td width=18%>{"WA","ID"}</td>
<td width=26%>"Joe"0 "WA"<p>
"Jane"2 "WA"</p>
<p>
"Jane"2 "ID"</p>
</td>
</tr>
<tr valign=top>
<td width=26%>rgBindings[0].iOrdinal=3<p>
rgBindings[1].iOrdinal=2</p>
</td>
<td width=30%>{DBCOMPAREOPS_EQ, DBCOMPAREOPS_GT}</td>
<td width=18%>{"OR",1}</td>
<td width=26%>"Fred"3 "OR"</td>
</tr>
<tr valign=top>
<td width=26%>rgBindings[0].iOrdinal=3<p>
rgBindings[1].iOrdinal=2</p>
</td>
<td width=30%>{DBCOMPAREOPS_EQ, DBCOMPAREOPS_IGNORE, DBCOMPAREOPS_IGNORE, DBCOMPAREOPS_GT}</td>
<td width=18%>{"OR",NULL, NULL,1}</td>
<td width=26%>"Jane"2 "WA"<p>
"Fred"3 "OR"</p>
<p>
"Judy"1 "OR"</p>
<p>
"Jane"2 "ID"</p>
</td>
</tr>
</table><br>
<p>
<br>
The following code example shows defining a filter for which the individual is from Oregon <i>or</i> has more than one child:</p>
<pre><code>DBBINDING    rgBindings[2];
IAccessor     *pIAccessor;
HACCESSOR    hAccessor;
DBCOMPAREOP    rgCompareOps[] = { DBCOMPAREOP_EQ, DBCOMPAREOP_IGNORE,
                          DBCOMPAREOP_IGNORE, DBCOMPAREOP_GT };

typedef struct FILTER_CRITERIA {
   TCHAR    rcState[4];
   ULONG    ulStateStatus;
   ULONG    ulStateLength;
   ULONG    cChildren;
   ULONG    ulChildrenStatus;
} WHERE_CLAUSE;

WHERE_CLAUSE rgCriteriaData[] =
{
   _T("OR"), DBSTATUS_S_OK,&nbsp;&nbsp; 2 * sizeof(TCHAR), NULL, DBSTATUS_S_ISNULL,
   NULL,&nbsp;&nbsp; DBSTATUS_S_ISNULL, 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp; DBSTATUS_S_OK
};

//initialize common binding values
for (cCol = 0; cCol &lt; 2; cCol++)
{
   rgBindings[cCol].pTypeInfo   = NULL;
   rgBindings[cCol].pObject   = NULL;
   rgBindings[cCol].pBindExp   = NULL;
   rgBindings[cCol].dwMemOwner   = DBMEMOWNER_CLIENTOWNED;
   rgBindings[cCol].eParamIO   = DBPARAMIO_NOTPARAM;
   rgBindings[cCol].dwFlags   = 0;
   rgBindings[cCol].bPrecision   = 0;
   rgBindings[cCol].bScale      = 0;
}

//initial bindings for the "State" column
   rgBindings[0].dwPart   = DBPART_VALUE | DBPART_LENGTH | DBPART_STATUS;
   rgBindings[0].iOrdinal   = 3;
   rgBindings[0].wType      = DBTYPE_STR;
   rgBindings[0].obValue   = offsetof(WHERE_CLAUSE, rcState);
   rgBindings[0].obStatus   = offsetof(WHERE_CLAUSE, ulStateStatus);
   rgBindings[0].obLength   = offsetof(WHERE_CLAUSE, ulStateLength);
   rgBindings[0].cbMaxLen   = sizeof(WHERE_CLAUSE.rcState);

//initial bindings for the "Children" column
   rgBindings[1].dwPart   =
   rgBindings[1].iOrdinal   = 2
   rgBindings[1].wType      = DBTYPE_I4;
   rgBindings[1].obValue   = offsetof(WHERE_CLAUSE, cChildren);
   rgBindings[1].obStatus   = offsetof(WHERE_CLAUSE, ulChildrenStatus);
   rgBindings[0].obLength   = 0;
   rgBindings[1].cbMaxLen   = sizeof(WHERE_CLAUSE.cChildren);

pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 2, rgBindings, sizeof(WHERE_CLAUSE), &amp;hAccessor, NULL);

//set filter condition
pIViewFilter-&gt;SetFilter(hAccessor, 2, rgCompareOps, rgCriteriaData);
</code></pre>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Method</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="viefil_9w36.htm">GetFilter</a></td>
<td width=75%>Returns the filter condition associated with a view.</td>
</tr>
<tr valign=top>
<td width=25%><a href="viefil_74xf.htm">GetFilterBindings</a></td>
<td width=75%>Returns the bindings used to describe the filter conditions associated with a view.</td>
</tr>
<tr valign=top>
<td width=25%><a href="viefil_360i.htm">SetFilter</a></td>
<td width=75%>Sets a filter condition on a view.</td>
</tr>
</table>
</font></BODY>
</HTML>
