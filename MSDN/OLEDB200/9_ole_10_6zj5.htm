<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Getting Large Data</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="getting_large_data"></a>Getting Large Data</h1>
<p>
In general, consumers should isolate code that creates a SQLOLEDB storage object from other code that handles data not referenced through an <b>ISequentialStream</b> pointer.</p>
<p>
When the consumer indicates a storage object is one member of a row of data values, then the consumer limits its use of storage objects because SQLOLEDB can support only a single open object. In this case, the consumer can fetch only a single row of data in <b>GetNextRows</b>.</p>
<p>
SQLOLEDB does not retrieve large data from SQL Server until requested to do so by the consumer. The consumer should bind all short data in one accessor, then use one or more temporary accessors to retrieve large data values as required.</p>
<h3>Example</h3>
<p>
This example retrieves a large data value from a single column.</p>
<pre><code>HRESULT GetUnboundData
  (
  IRowset* pIRowset,
  HROW hRow,
  ULONG nCol, 
  BYTE* pUnboundData
  )
  {
  UINT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cbRow = sizeof(IUnknown*) + sizeof(ULONG);
  BYTE*&nbsp;&nbsp;&nbsp;&nbsp; pRow = new BYTE[cbRow];
<b><i>  </i></b>
  DBOBJECT&nbsp;&nbsp;&nbsp; dbobject;
<b><i>  </i></b>
  IAccessor*&nbsp;&nbsp;&nbsp; pIAccessor = NULL;
  HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp; haccessor;
<b><i>  </i></b>
  DBBINDING&nbsp;&nbsp;&nbsp;&nbsp; dbbinding;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; ulbindstatus;
<b><i>  </i></b>
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; dwStatus;
  ISequentialStream*&nbsp; pISequentialStream;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; cbRead;
<b><i>  </i></b>
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;
<b><i>  </i></b>
  // Set up the DBOBJECT structure.
  dbobject.dwFlags = STGM_READ;
  dbobject.iid = IID_ISequentialStream;
<b><i>  </i></b>
  // Create the DBBINDING, requesting a storage-object pointer from
  // SQLOLEDB.
  dbbinding.iOrdinal = nCol;
  dbbinding.obValue = 0;
  dbbinding.obStatus = sizeof(IUnknown*);
  dbbinding.obLength = 0;
  dbbinding.pTypeInfo = NULL;
  dbbinding.pObject = &amp;dbobject;
  dbbinding.pBindExt = NULL;
  dbbinding.dwPart = DBPART_VALUE | DBPART_STATUS;
  dbbinding.dwMemOwner = DBMEMOWNER_CLIENTOWNED;
  dbbinding.eParamIO = DBPARAMIO_NOTPARAM;
  dbbinding.cbMaxLen = 0;
  dbbinding.dwFlags = 0;
  dbbinding.wType = DBTYPE_IUNKNOWN;
  dbbinding.bPrecision = 0;
  dbbinding.bScale = 0;
<b><i>  </i></b>
  if (FAILED(hr = pIRowset-&gt;
 &nbsp;&nbsp; QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process QueryInterface failure.
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Create the accessor.
  if (FAILED(hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1,
 &nbsp;&nbsp; &amp;dbbinding, 0, &amp;haccessor, &amp;ulbindstatus)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from CreateAccessor.
 &nbsp;&nbsp; pIAccessor-&gt;Release();
 &nbsp;&nbsp; return (hr);
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Read and process BLOCK_SIZE bytes at a time.
  if (SUCCEEDED(hr = pIRowset-&gt;GetData(hRow, haccessor, pRow)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; dwStatus = *((ULONG*) (pRow + dbbinding.obStatus));
<b><i>  </i></b>
 &nbsp;&nbsp; if (dwStatus == DBSTATUS_S_ISNULL)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process NULL data
 &nbsp;&nbsp; }
 &nbsp;&nbsp; else if (dwStatus == DBSTATUS_S_OK)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; pISequentialStream = *((ISequentialStream**) 
 &nbsp;&nbsp;&nbsp;&nbsp; (pRow + dbbinding.obValue));
<b><i>  </i></b>
 &nbsp;&nbsp; do
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (SUCCEEDED(hr =
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pISequentialStream-&gt;Read(pUnboundData,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BLOCK_SIZE, &amp;cbRead)))
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pUnboundData += cbRead;
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; while (SUCCEEDED(hr) &amp;&amp; cbRead &gt;= BLOCK_SIZE);
<b><i>  </i></b>
 &nbsp;&nbsp; pISequentialStream-&gt;Release();
 &nbsp;&nbsp; }
 &nbsp;&nbsp; }
  else
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from GetData.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  pIAccessor-&gt;ReleaseAccessor(haccessor, NULL);
  pIAccessor-&gt;Release();
  delete [] pRow;
<b><i>  </i></b>
  return (hr);
  }</code></pre>
</font></BODY>
</HTML>
