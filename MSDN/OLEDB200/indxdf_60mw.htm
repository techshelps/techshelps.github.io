<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IIndexDefinition::CreateIndex</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbiindexdefinition__createindex"></a>IIndexDefinition::CreateIndex</h1>
<p>
Adds a new index to a base table.</p>
<pre><code>HRESULT CreateIndex(
   DBID *                                 pTableID,
   DBID *                                 pIndexID,
   ULONG                              cIndexColumnDescs,
   const DBINDEXCOLUMNDESC      rgIndexColumnDescs[],
   ULONG                              cPropertySets,
   DBPROPSET                        rgPropertySets[],
   DBID **                              ppIndexID);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>pTableID</i></p>
<p class=indent>
[in]<br>
A pointer to the DBID of the table for which to create an index.</p>
<p class=dt>
<i>pIndexID</i></p>
<p class=indent>
[in]<br>
A pointer to the ID of the new index to create. If this is a null pointer, the provider assigns an ID to the index. The ID must be unique.</p>
<p class=dt>
<i>cIndexColumnDescs</i></p>
<p class=indent>
[in]<br>
The count of DBINDEXCOLUMNSDESC structures in <i>rgIndexColumnDescs</i>.</p>
<p class=dt>
<i>rgIndexColumnDescs</i></p>
<p class=indent>
[in]<br>
An array of DBINDEXCOLUMNDESC structures that describe how to construct the index. The order of the DBINDEXCOLUMNDESC structures in <i>rgIndexColumnDescs</i> determines the order of the columns in the index key. That is, the column identified by the first element of this array is the most significant column in the index key and the column identified by the last element is the least significant column. When the index is opened as a rowset, the key columns occur in order of most significant column to least significant column.</p>
<pre><code>typedef struct {
 DBID *&nbsp;&nbsp;&nbsp; pColumnID;
 DBINDEX_COL_ORDER eIndexColOrder;
} DBINDEXCOLUMNDESC;
</code></pre>
<p class=tl>
The elements of this structure are used as follows.</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=31%><b>Element</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%><i>pColumnID</i></td>
<td width=69%>A pointer to the ID of the base table column. </td>
</tr>
<tr valign=top>
<td width=31%><i>eIndexColOrder</i></td>
<td width=69%>Whether the index is ascending or descending in this column.<ul type=disc>
<li>
DBINDEX_COL_ORDER_ASC—Ascending<br><br></li>
<li>
DBINDEX_COL_ORDER_DESC—Descending</li>
</ul>
</td>
</tr>
</table><br>
<p class=dt>
<i>cPropertySets</i></p>
<p class=indent>
[in]<br>
The number of DBPROPSET structures in <i>rgPropertySets</i>. If this is zero, the provider ignores <i>rgPropertySets</i>.</p>
<p class=dt>
<i>rgPropertySets</i></p>
<p class=indent>
[in/out]<br>
An array of DBPROPSET structures containing properties and values to be set. The properties specified in these structures must belong to the Index property group. If the same property is specified more than once in <i>rgPropertySets</i>, then it is provider-specific which value is used. If <i>cPropertySets</i> is zero, this argument is ignored.</p>
<p class=tl>
For information about the properties in the Index property group that are defined by OLE DB, see "<a href="appcpr_8u7n.htm#oledbindex_properties">Index Properties</a>" in Appendix C. For information about the DBPROPSET and DBPROP structures, see "<a href="ch11pr_5pb9.htm">DBPROPSET Structure</a>" and "<a href="ch11pr_3xt1.htm">DBPROP Structure</a>" in Chapter 11.</P><p class=dt>
<i>ppIndexID</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return a pointer to the DBID of a newly created index. If <i>ppIndexID</i> is a null pointer, no DBID is returned.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded and the new index has been created. In all DBPROP structures passed to the method, <i>dwStatus</i> is set to DBPROPSTATUS_OK.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
The index was created but one or more properties—for which the <i>dwOptions</i> element of the DBPROP structure was DBPROPOPTIONS_OPTIONAL—were not set. The consumer checks <i>dwStatus</i> in the DBPROP structures to determine which properties were not set. The method can fail to set properties for a number of reasons, including:
<ul type=disc>
<li>
The property was not supported by the provider.<br><br></li>
<li>
The property was not in the Index property group.<br><br></li>
<li>
The property set was not supported by the provider.<br><br></li>
<li>
It was not possible to set the property.<br><br></li>
<li>
The <i>colid</i> in the DBPROP structure was not DB_NULLID.<br><br></li>
<li>
The data type in <i>vValue</i> in the DBPROP structure was not the data type of the property or was not VT_EMPTY.<br><br></li>
<li>
The value in <i>vValue</i> in the DBPROP structure was invalid.<br><br></li>
<li>
The property's value conflicted with an existing property.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
DB_E_TABLEINUSE<br>
The specified table was in use and the provider could not create the index with the table open.</p>
<p class=indent>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pTableID</i> was a null pointer.</p>
<p class=tl>
<i>pIndexID</i> and <i>ppIndexID</i> were both null pointers.</P><p class=tl>
<i>cIndexColumnDescs</i> was zero.</P><p class=tl>
<i>rgIndexColumnDescs</i> was a null pointer.</P><p class=tl>
<i>eIndexColOrder</i> in an element of <i>rgIndexColumnDescs</i> was not a valid value.</P><p class=tl>
<i>cPropertySets</i> was not zero and <i>rgPropertySets</i> was a null pointer.</P><p class=tl>
In an element of <i>rgPropertySets</i>, <i>cProperties</i> was not zero and <i>rgProperties</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADCOLUMNID<br>
A column specified in an element of <i>rgIndexColumnDescs</i> did not exist.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADINDEXID<br>
<i>*pIndexID</i> was an invalid index ID.</p>
<p class=indent>
DB_E_BADTABLEID<br>
<i>*pTableID</i> was an invalid table ID.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DUPLICATEINDEXID<br>
The specified index already exists in the current data source object.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
No index was created because one or more properties—for which the <i>dwOptions</i> element of the DBPROP structure was DBPROPOPTIONS_REQUIRED or an invalid value—were not set. The consumer checks <i>dwStatus</i> in the DBPROP structures to determine which properties were not set. None of the satisfiable properties are remembered. The method can fail to set properties for any of the reasons specified in DB_S_ERRORSOCCURRED, except the reason that states that it was not possible to set the property.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTABLE<br>
The specified table does not exist in the current data source object.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to create the index.<br>
</p>
<p class=label>
<b>Comments</b></p>
<p>
If <b>CreateIndex</b> returns any errors, the index is not created, and <i>ppIndexID</i> is set to NULL on output.<br>
</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="indxdf_103c.htm">IIndexDefinition::DropIndex</a>, <a href="rowidx_8mk8.htm">IRowsetIndex</a>, <a href="tbldef_5t0u.htm">ITableDefinition</a></p>
</font></BODY>
</HTML>
