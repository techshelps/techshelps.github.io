<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>How a Consumer Retrieves an OLE DB Error Object</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbhow_a_consumer_retrieves_an_ole_db_error_object"></a>How a Consumer Retrieves an OLE DB Error Object</h1>
<p>
When a consumer wants to retrieve an error object in response to a return code it received, it performs the following steps:
<ol>
<li>
Calls <b>QueryInterface</b> on the component that returned the code to retrieve an <b>ISupportErrorInfo</b> interface pointer on that component. This interface must be supported by all components that create error objects.<br><br></li>
<li>
Calls the <b>InterfaceSupportsErrorInfo</b> method in this interface and passes it the IID of the interface containing the method that returned the code. The <b>InterfaceSupportsErrorInfo</b> method returns S_OK if the interface supports error objects (meaning the consumer should retrieve the current error object, if one exists) and S_FALSE if the interface does not support error objects (meaning the consumer should not retrieve the current error object because it applies to another interface and method).<br><br></li>
<li>
Calls the <b>GetErrorInfo</b> function in the Automation DLL. This function returns an <b>IErrorInfo</b> interface pointer on the current error object and releases its reference count on the error object, thus transferring ownership of the error object to the consumer.<br><br></li>
<li>
Calls <b>QueryInterface</b> to return an <b>IErrorRecords</b> interface pointer on the error object.<br><br></li>
<li>
Calls the methods in <b>IErrorRecords</b> to retrieve information from the error object. To retrieve the error message, source, Help file, or Help context ID from a particular record, it first calls <b>IErrorRecords::GetErrorInfo</b> to retrieve an <b>IErrorInfo</b> interface pointer for that record. (This interface pointer is different from the one retrieved in step 3 as it applies to a specific record.) The consumer then calls methods using this pointer.<br><br></li>
<li>
Calls <b>Release</b> on the error object to release it.</li>
</ol>
<p>
For example, the following code shows how a consumer might retrieve and use an OLE DB error object:</p>
<pre><code>#include &lt;oledb.h&gt;
#include &lt;stdio.h&gt;
IUnknown *pMyObject;
extern GUID IID_IMyInterface;
DWORD&nbsp;&nbsp; MYLOCALEID;
BSTR&nbsp;&nbsp;&nbsp; bstrSourceOfError, bstrDescriptionOfError;

int main() {
 IErrorInfo&nbsp;&nbsp;&nbsp; *pErrorInfo;
 IErrorInfo&nbsp;&nbsp;&nbsp; *pErrorInfoRec;
 IErrorRecords&nbsp;&nbsp; *pErrorRecords;
 ISupportErrorInfo *pSupportErrorInfo;
 HRESULT&nbsp;&nbsp;&nbsp; hr, hrErr;
 ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i, ulNumErrorRecs;
 ERRORINFO&nbsp;&nbsp;&nbsp; ErrorInfo;

 // Error or warning occurs when calling method.&nbsp; (Not shown.)
 if (!FAILED(hrErr))
  return (hrErr);

 // Check that the current interface supports error objects.
 hr = pMyObject-&gt;QueryInterface(IID_ISupportErrorInfo,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (void**) &amp;pSupportErrorInfo);

 if (SUCCEEDED(hr)) {
  hr = pSupportErrorInfo-&gt;InterfaceSupportsErrorInfo(IID_IMyInterface);
  if (hr == S_OK) {
 &nbsp; // Get the current error object. Return if no error object exists.
 &nbsp; GetErrorInfo(0,&amp;pErrorInfo);
 &nbsp; if (!pErrorInfo) return (hrErr);

 &nbsp; // Get the IErrorRecord interface and get the count of error recs.
 &nbsp; pErrorInfo-&gt;QueryInterface(IID_IErrorRecords, (void**) &amp;pErrorRecords);
 &nbsp; pErrorRecords-&gt;GetRecordCount(&amp;ulNumErrorRecs);

 &nbsp; // Read through error records and display them.
 &nbsp; for (i = 0; i &lt; ulNumErrorRecs; i++) {
 &nbsp;&nbsp; // Get basic error information.
 &nbsp;&nbsp; pErrorRecords-&gt;GetBasicErrorInfo(i, &amp;ErrorInfo);

 &nbsp;&nbsp; // Get error description and source through the IErrorInfo interface
 &nbsp;&nbsp; // pointer on a particular record.
 &nbsp;&nbsp; pErrorRecords-&gt;GetErrorInfo(i, MYLOCALEID, &amp;pErrorInfoRec);
 &nbsp;&nbsp; BSTR bstrDescriptionOfError = NULL;
 &nbsp;&nbsp; BSTR bstrSourceOfError = NULL;

 &nbsp;&nbsp; pErrorInfoRec-&gt;GetDescription(&amp;bstrDescriptionOfError); 
 &nbsp;&nbsp; pErrorInfoRec-&gt;GetSource(&amp;bstrSourceOfError);

 &nbsp;&nbsp; // At this point, you could call GetCustomErrorObject and query for
 &nbsp;&nbsp; // additional interfaces to determine what else happened.

 &nbsp;&nbsp; wprintf(
 &nbsp;&nbsp;&nbsp; OLESTR("HRESULT: %lx, Minor Code: %lu, Source: %s, Description: %s"),
 &nbsp;&nbsp;&nbsp; ErrorInfo.hrError,
 &nbsp;&nbsp;&nbsp; ErrorInfo.dwMinor,
 &nbsp;&nbsp;&nbsp; bstrSourceOfError,
 &nbsp;&nbsp;&nbsp; bstrDescriptionOfError);

 &nbsp;&nbsp; // Free the resources.
 &nbsp;&nbsp; SysFreeString(bstrDescriptionOfError);
 &nbsp;&nbsp; SysFreeString(bstrSourceOfError);
 &nbsp;&nbsp; pErrorInfoRec-&gt;Release();
 &nbsp; }

 &nbsp; // Release the error object.
 &nbsp; pErrorInfo-&gt;Release();
 &nbsp; pErrorRecords-&gt;Release();
  }
 }
 return (hrErr);
};
</code></pre>
</font></BODY>
</HTML>
