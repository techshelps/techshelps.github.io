<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Implementing Property Pages</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="implementingpropertypages"></a>Implementing Property Pages</h1>
<p>
Property pages are an invaluable addition to most ActiveX controls’ design-time functionality. Fortunately, it’s easy to implement them. To do so, you merely need to declare an object that inherits <b>CPropertyPage</b>.</p>
<h1>Working with a Property Page</h1>
<p>
The control's property page is declared in the header file using the DEFINE_PROPERTYPAGE macro, which puts it into the g_ObjectInfo table. The framework supports the creation of the property page object, but you are required to implement the static <b>Create</b> function, which the control wizard generates for you.</p>
<p>
The property page is created much like a standard Windows dialog box; use your favorite resource editor to create a DIALOG resource, and then cut and paste it into your control's resource (.rc) file.</p>
<p>
The most important method you have to implement is the <b>DialogProc</b> method, which is where all the work takes place. In addition to the regular Windows messages that one would expect in a <b>DialogProc</b>, there are a few additional messages that others working with this framework expect.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=35%><b>Message</b></td>
<td class=label width=65%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=35%><b>PPM_NEWOBJECTS</b></td>
<td width=65%>The control has been given some new objects. The control is expected to populate its page's controls with information from this object. Using the <b>FirstControl</b> and <b>NextControl</b> methods from <b>CPropertyPage</b>, the control can get the relevant information.</td>
</tr>
<tr valign=top>
<td width=35%><b>PPM_APPLY</b></td>
<td width=65%>The control now has to apply any changes that have occurred. Use the <b>FirstControl</b> and <b>NextControl</b> methods to loop through all the objects for which the property pages were visible and apply the values; it's possible to have more than one object for which a property page is being displayed.</td>
</tr>
<tr valign=top>
<td width=35%><b>PPM_EDITPROPERTY</b></td>
<td width=65%>The control is expected to set the focus to the control instance, which represents the property of the given dispid. This message is called only if you implement <b>IPerPropertyBrowsing</b> and return a value in <b>MapPropertyToPage</b>.</td>
</tr>
<tr valign=top>
<td width=35%><b>PPM_FREEOBJECTS</b></td>
<td width=65%>The control frees saved pointers received in <b>PPM_NEWOBJECTS</b>; the objects are no longer valid.&nbsp; This can be called from the property page's destructor, so be careful not to make too many assumptions about the property page.</td>
</tr>
</table><br>
<p>
See any of the sample controls for exact details about these messages.</p>
<h1>Navigating Through Associated Objects</h1>
<p>
Your property pages can operate on one or more controls. When initializing, you typically receive some values from the first control. You can use the <b>FirstControl </b>method to get the object pointer for this control. You can then use <b>QueryInterface</b> for your primary dispatch interface to get properties with which to populate the page.</p>
<p>
When told to apply the values (<b>PPM_APPLY</b>), apply them to all objects, which means you have to loop using <b>FirstControl</b> and <b>NextControl</b>, as follows:</p>
<pre><code>for (pUnk = FirstControl(&amp;dwCookie) ; pUnk; pUnk = NextControl(&amp;dwCookie)) {
   hr = pUnk-&gt;QueryInterface(IID_IButton, (void **)&amp;pButton);
   if (FAILED(hr)) continue;

   GetDlgItemText(hwnd, IDC_CAPTION, szTmp, 128);
   bstr = BSTRFROMANSI(szTmp);
   ASSERT(bstr, "Operation Failed");
   pButton-&gt;put_Caption(bstr);
   SysFreeString(bstr);
   pButton-&gt;Release();
}
</code></pre>
<p>
You do not have to run <b>Release</b> on the return values of <b>FirstControl</b> and <b>NextControl</b>.</p>
<h1>Marking Your Page as Dirty</h1>
<p>
It is moderately important to manually mark the control's property page as dirty at the appropriate times. Typically, the control does this in response to a Windows notification message, such as <b>EN_CHANGE</b> or <b>BN_CLICKED</b>. When the control wants to mark its page as dirty, it should call <b>MakeDirty</b>. This causes the <b>Apply</b> button to be enabled, if it was previously unavailable, and tells the host that the state should be saved before destroying the page.</p>
<p>
The following code causes the page to mark itself as dirty when the user changes the text in a <b>Text</b> box in the property page:</p>
<pre><code>case WM_COMMAND:
   switch (LOWORD(wParam)) {
      case IDC_CAPTION:
         if (HIWORD(wParam) == EN_CHANGE)
            MakeDirty();
         break;
   }
   break;
</code></pre>
</font></BODY>
</HTML>
