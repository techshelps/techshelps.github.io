<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Drilling by Member</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="drillingbymember"></a>Drilling by Member</h1>
<p>
To drill down by a member, use the <b>DRILLDOWNMEMBER</b> function.</p>
<p>
<b>DRILLDOWNMEMBER(&lt;set1&gt;, &lt;set2&gt;[, RECURSIVE])</b></p>
<p class=tl>
Drills down members in <i>set1</i> that are present in <i>set2</i>. If <b>RECURSIVE</b> is not specified, then each member of <i>set2</i> is checked against the original <i>set1</i> and if it is present it is drilled down. If <b>RECURSIVE</b> is specified, then each member of <i>set2</i> is checked against the result<b> </b>of the previous application of a member from <i>set2</i>. Typically, <i>set2</i> is a subset of <i>set1</i> in the invocation of this function.</P><p class=tl>
For example, the call</P><pre><code>DRILLDOWNMEMBER({USA, France, Canada}, {USA, Washington, Canada})
</code></pre>
<p class=tl>
returns the set</P><pre><code>{USA, &lt;all states in USA&gt;, France, Canada, &lt;all provinces in Canada&gt;}
</code></pre>
<p class=tl>
The member “Washington” from <i>set2</i> had no effect since it does not occur in <i>set1</i>. Note that the members that result from the drill down are hierarchized to occur under their parents. </P><p class=tl>
If the optional <b>RECURSIVE</b> flag is used in the above call, as shown here</P><pre><code>DRILLDOWNMEMBER({USA, France, Canada}, {USA, Washington, Canada}, 
 &nbsp; RECURSIVE)
</code></pre>
<p class=tl>
then the following set is returned:</P><pre><code>{USA, &lt;all states USA before Washington&gt;, Washington, 
&lt;all cities in Washington&gt;, &lt;all states in USA after Washington&gt;, 
France, Canada, &lt;all provinces in Canada&gt;}
</code></pre>
<p class=tl>
This is because the following process takes place:</P><ol>
<li>
The member “USA” from <i>set2</i> is inspected to see if present in <i>set1</i>. It is present. Therefore, it is drilled down to yield the set that has “USA,” all states in USA, “France,” and “Canada.” Call this set <i>set1 result1</i>.<br><br></li>
<li>
The second member of <i>set2</i>, “Washington,” is inspected to see if present in <i>set1 result1</i>. It is. Therefore, “Washington” is drilled down to yield all cities in Washington, and a union is formed with the result and <i>set1 result2</i>.<br><br></li>
<li>
The third member of <i>set2</i>, “Canada,” is inspected to see if present in <i>set1 result2</i>. It is. Therefore, it is drilled down to get all the provinces in Canada, and a union is formed with this result and <i>set1 result2</i> to get the final set.<p class=tl>
Note that this is sensitive to the order of the members in <i>set2</i>. If <i>set2</i> were {Washington, USA, Canada}, then the result would not contain all the cities in Washington. This is because <i>set1</i> is checked to see if it contains “Washington” first. It does not at this stage because USA has not been drilled down yet.</P><p class=tl>
A typical usage scenario for an application is: <i>set1</i> is the set of members from a given dimension on a given axis. (Note that <i>set1</i> may itself be the result of an expression.) The user clicks the plus (+) sign next to a member <i>m</i> of <i>set1</i> in the UI. The application now calls <b>DRILLDOWNMEMBER(</b><i>set1</i><b>, </b>{<i>m</i>}<b>)</b> to drill down on <i>m</i>. More sophisticated UIs can expose options for recursive drill downs, drill downs on multiple members, and so on.</P><p class=tl>
The set returned by this function is described in the following algorithm:</P></li>
<li value=1>
Let <i>set3</i> equal <i>set1</i>, the empty set.<br><br></li>
<li>
In the FOR statement, let X = <i>set3</i> if RECURSIVE and let X = <i>set1</i> if not.<br><br></li>
<li>
For each member <i>m</i> of <i>set2</i>, and for each occurrence of <i>m</i> in the set X:<p class=tl>
a. Let <i>p</i> be the member immediately after <i>m</i> in set X.</P><p class=tl>
b. If <i>p</i> is a descendant of <i>m</i>, then break.</P><p class=tl>
c. Otherwise, let <i>set3</i> = <b>HIERARCHIZE(Union(</b><i>set3</i><b>, </b><i>m</i><b>.CHILDREN))</b></P></li>
<li>
Return <i>set3</i>.<p class=tl>
In the above algorithm, the <b>BREAK </b>command pops out of the IF clause and begins another iteration.</P></li>
</ol>
<p>
The <b>DRILLDOWNMEMBERTOP</b> function is a variation of <b>DRILLDOWNMEMBER</b>. Instead of including all children (or descendants) of a member, it just includes the top <i>n</i> children (or descendants). The syntax of this function is:</p>
<p>
<b>DRILLDOWNMEMBERTOP(&lt;set1&gt;, &lt;set2&gt;, &lt;index&gt;<br>
 &nbsp; [, [&lt;numeric_value_expression&gt;][, RECURSIVE]])</b></p>
<p class=tl>
The desired number of children (or descendants) is specified by <i>index</i>, and <i>numeric_value_expression</i> gives the criterion. For example, the call</P><pre><code>DRILLDOWNMEMBERTOP({USA, France, Canada}, {USA, Washington, Canada},
 &nbsp; 5, Sales)
</code></pre>
<p class=tl>
returns the set</P><pre><code>{USA, &lt;top 5 states in USA based on Sales&gt;, France, Canada, 
&lt;top 5 provinces in Canada based on Sales&gt;}
</code></pre>
<p class=tl>
Use of the RECURSIVE flag has an effect similar to its effect in DRILLDOWNMEMBER. </P><p class=tl>
For example, the call</P><pre><code>DRILLDOWNMEMBERTOP({USA, France, Canada}, {USA, Canada}, 5, Sales,
 &nbsp; RECURSIVE)
</code></pre>
<p class=tl>
returns the set (assuming the top 5 states in USA were California, Texas, Florida, Georgia, and Washigton)</P><pre><code>{USA, California, Texas, Florida, Georgia, Washington, 
&lt;top 5 cities in Washington based on sales&gt;, France, Canada, 
&lt;top 5 provinces in Canada based on Sales&gt;}
</code></pre>
<p>
The function <b>DRILLDOWNMEMBERBOTTOM</b> is similar, except that the bottom condition is applied instead of the top condition.</p>
<p>
To drill up by a member, use the <b>DRILLUPMEMBER</b> function. The syntax is:</p>
<p>
<b>DRILLUPMEMBER(&lt;set1&gt;, &lt;set2&gt;)</b></p>
<p class=tl>
Drills up the members in <i>set1</i> that are present in <i>set2</i>. As in the case of <b>DRILLDOWNMEMBER</b>, <i>set2</i> is usually a subset of <i>set1</i> in the invocation of this function.</P><p class=tl>
For example, the call</P><pre><code>DRILLUPMEMBER({USA, Alabama, Alaska, France, Canada, Ontario, Quebec}, 
 &nbsp; {USA, Canada})
</code></pre>
<p class=tl>
returns the set</P><pre><code>{USA, France, Canada}
</code></pre>
<p class=tl>
Note that <b>DRILLUPMEMBER</b> does not have a RECURSIVE flag. This is because when a member is drilled up, it is common to have all the descendants (not just the immediate children) removed. In other words, drilling up is usually recursive. Therefore, the call</P><pre><code>DRILLUPMEMBER({USA, California, Los Angles, Washington, Seattle, 
 &nbsp; King County, France, Canada}, {USA})
</code></pre>
<p class=tl>
returns the set</P><pre><code>{USA, France, Canada}
</code></pre>
<p class=tl>
As a result, all descendants of USA — California, Los Angeles, Washington, Seattle, King County — have been drilled up, even though only California and Washington are the direct children of USA.</P><p class=tl>
The set returned by this function is described by the following algorithm:</P><ol>
<li>
For each member <i>m</i> of <i>set2</i> and for each occurrence of <i>m</i> in <i>set1</i>, remove from <i>set1</i> all the descendants of <i>m</i> that directly follow <i>m</i>.<br><br></li>
<li>
Return <i>set1</i>.</li>
</ol>
<p>
The function <b>TOGGLEDRILLSTATE</b> is a combination of <b>DRILLDOWNMEMBER</b> and <b>DRILLUPMEMBER</b>. The syntax of this function is:</p>
<p>
<b>TOGGLEDRILLSTATE(&lt;set1&gt;, &lt;set2&gt;[, RECURSIVE])</b></p>
<p class=tl>
Toggles the drill state of each member of <i>set2</i> that is present in <i>set1</i>. If a member <i>m</i> of <i>set2</i> that is present in <i>set1</i> is drilled down (that is, has a descendant), then <b>DRILLUPMEMBER(</b><i>set1</i><b>, </b>{<i>m</i>}<b>)</b> is applied. If it is drilled up (that is, there is no descendant of <i>m</i> that immediately follows <i>m</i>), then <b>DRILLDOWNMEMBER(</b><i>set1</i><b>, </b>{<i>m</i>}[<b>, RECURSIVE</b>]<b>)</b> is applied to <i>set1</i>. The optional <b>RECURSIVE</b> flag is used if <b>TOGGLEDRILLSTATE</b> was called with <b>RECURSIVE</b>.</P></font></BODY>
</HTML>
