<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Supporting Local Transactions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="supporting_local_transactions"></a>Supporting Local Transactions</h1>
<p>
A session delimits transaction scope for a SQLOLEDB local transaction. When, at consumer direction, SQLOLEDB submits a request to a connected SQL Server, the request constitutes a unit of work for SQLOLEDB. Local transactions always wrap one or more units of work on a single SQLOLEDB session.</p>
<p>
Using the default SQLOLEDB autocommit mode, a single unit of work is treated as the scope of a local transaction. No more than one unit ever participates in the local transaction. When a session is created, SQLOLEDB begins a transaction for the session. Upon successful completion of a work unit, the work is committed. On failure, any work begun is rolled back and the error is reported to the consumer. In either case, SQLOLEDB begins a new local transaction for the session, so that all work is conducted within a transaction.</p>
<p>
The SQLOLEDB consumer can direct more precise control over local transaction scope by using <b>ITransactionLocal</b>. When a consumer session initiates a transaction, all session work units between the transaction start point and the eventual <b>Commit</b> or <b>Abort</b> are treated as an atomic unit. SQLOLEDB implicitly begins a transaction when directed to do so by the consumer. If the consumer does request retention, the session reverts to parent transaction-level behavior, most commonly, autocommit mode.</p>
<p>
SQLOLEDB supports <b>ITransactionLocal::StartTransaction</b> parameters as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=33%><b>Parameter</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%><i>isoLevel</i></td>
<td width=67%>In local transactions, SQLOLEDB supports ISOLATIONLEVEL_READCOMMITTED, ISOLATIONLEVEL_REPEATABLEREAD, ISOLATIONLEVEL_ISOLATED, and the synonyms ISOLATIONLEVEL_CURSORSTABILITY and ISOLATIONLEVEL_SERIALIZABLE.</td>
</tr>
<tr valign=top>
<td width=33%><i>isoFlags</i></td>
<td width=67%>SQLOLEDB returns an error for any value other than zero.</td>
</tr>
<tr valign=top>
<td width=33%><i>pOtherOptions</i></td>
<td width=67%>If not NULL, SQLOLEDB requests the options object from the interface. SQLOLEDB returns XACT_E_<br>
NOTIMEOUT if the options object’s ulTimeout member is not zero. SQLOLEDB ignores the value of the szDescription member.</td>
</tr>
<tr valign=top>
<td width=33%><i>pulTransactionLevel</i></td>
<td width=67%>If not NULL, SQLOLEDB returns the nested level of the transaction.</td>
</tr>
</table><br>
<p>
For local transactions, SQLOLEDB implements <b>ITransaction::Abort</b> parameters as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=33%><b>Parameter</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%><i>pboidReason</i></td>
<td width=67%>Ignored if set. Can safely be NULL.</td>
</tr>
<tr valign=top>
<td width=33%><i>FRetaining</i></td>
<td width=67%>When TRUE, a new transaction is implicitly begun for the session. The transaction must be committed or aborted by the consumer.<br>
<br>
When FALSE, SQLOLEDB reverts to autocommit mode for the session.</td>
</tr>
<tr valign=top>
<td width=33%><i>FAsync</i></td>
<td width=67%>Asynchronous abort is not supported by SQLOLEDB. SQLOLEDB returns XACT_E_NOTSUPPORTED if the value is not FALSE.</td>
</tr>
</table><br>
<p>
For local transactions, SQLOLEDB implements <b>ITransaction::Commit</b> parameters as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=33%><b>Parameter</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%><i>fRetaining</i></td>
<td width=67%>When TRUE, a new transaction is implicitly begun for the session. The transaction must be committed or aborted by the consumer.<br>
<br>
When FALSE, SQLOLEDB reverts to autocommit mode for the session.</td>
</tr>
<tr valign=top>
<td width=33%><i>GrfTC</i></td>
<td width=67%>Asynchronous and phase one returns are not supported by SQLOLEDB. SQLOLEDB returns XACT_E_<br>
NOTSUPPORTED for any value other than XACTTC_<br>
SYNC.</td>
</tr>
<tr valign=top>
<td width=33%><i>GrfRM</i></td>
<td width=67%>Must be 0.</td>
</tr>
</table><br>
<p>
SQLOLEDB rowsets on the session are preserved on a local commit or abort based on the values of the rowset properties DBPROP_ABORTPRESERVE and DBPROP_COMMITPRESERVE. By default, these properties are both VARIANT_FALSE and all SQLOLEDB rowsets on the session are lost following an abort or commit.</p>
<p>
SQLOLEDB does not implement the <b>ITransactionObject</b> interface. A consumer attempt to retrieve a reference on the interface returns E_NOINTERFACE.</p>
<h3>Example</h3>
<p>
This example uses <b>ITransactionLocal</b>.</p>
<pre><code>// Interfaces used in the example.
IDBCreateSession* pIDBCreateSession = NULL;
ITransaction*&nbsp;&nbsp; pITransaction&nbsp;&nbsp; = NULL;
IDBCreateCommand* pIDBCreateCommand = NULL;
IRowset*&nbsp;&nbsp;&nbsp; pIRowset&nbsp;&nbsp;&nbsp; = NULL;
<b><i>  </i></b>
HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;
<b><i>  </i></b>
// Get the command creation and local transaction interfaces for the
// session.
if (FAILED(hr = pIDBCreateSession-&gt;CreateSession(NULL,
 &nbsp; IID_IDBCreateCommand, (IUnknown**) &amp;pIDBCreateCommand)))
  {
  // Process error from session creation. Release any references and
  // return.
  }
<b><i>  </i></b>
if (FAILED(hr = pIDBCreateCommand-&gt;QueryInterface(IID_ITransactionLocal,
  (void**) &amp;pITransaction)))
  {
  // Process error. Release any references and return.
  }
<b><i>  </i></b>
// Start the local transaction.
if (FAILED(hr = ((ITransactionLocal*) pITransaction)-&gt;StartTransaction(
  ISOLATIONLEVEL_REPEATABLEREAD, 0, NULL, NULL)))
  {
  // Process error from StartTransaction. Release any references and
  // return.
  }
<b><i>  </i></b>
// Get data into a rowset, then update the data. Functions not
// illustrated in this example.
if (FAILED(hr = ExecuteCommand(pIDBCreateCommand, &amp;pIRowset)))
  {
  // Release any references and return.
  }
<b><i>  </i></b>
// If rowset data update fails, then Abort the transaction, else
// commit. The example is not retaining.
if (FAILED(hr = UpdateDataInRowset(pIRowset, bDelayedUpdate)))
  {
  // Get error from update, then abort.
  pITransaction-&gt;Abort(NULL, FALSE, FALSE);
  }
else
  {
  if (FAILED(hr = pITransaction-&gt;Commit(FALSE, XACTTC_SYNC, 0)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Get error from failed commit.
 &nbsp;&nbsp; }
  }
<b><i>  </i></b>
if (FAILED(hr))
  {
  // Update of data or commit failed. Release any references and
  // return.
  }
<b><i>  </i></b>
// Release any references and continue.
<b><i>  </i></b></code></pre>
</font></BODY>
</HTML>
