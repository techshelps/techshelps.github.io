<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IAccessor::CreateAccessor</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbiaccessor__createaccessor"></a>IAccessor::CreateAccessor</h1>
<p>
<b>CreateAccessor</b> creates an accessor from a set of bindings.</p>
<pre><code>HRESULT CreateAccessor (
   DBACCESSORFLAGS      dwAccessorFlags,
   ULONG                     cBindings,
   const DBBINDING            rgBindings[],
   ULONG                     cbRowSize,
   HACCESSOR *               phAccessor,
   DBBINDSTATUS            rgStatus[]);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>dwAccessorFlags</i></p>
<p class=indent>
[in]<br>
A bitmask that describes the properties of the accessor and how it is to be used. These flags have the following meanings.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=30%><b>Value</b></td>
<td class=label width=70%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=30%>DBACCESSOR_<br>
INVALID</td>
<td width=70%>This flag is used by <b>GetBindings</b> to indicate that the method failed.</td>
</tr>
<tr valign=top>
<td width=30%>DBACCESSOR_<br>
PASSBYREF</td>
<td width=70%>The accessor is a reference accessor.<p>
The value passed in the consumer buffer is a pointer to the passer's internal buffer. This pointer need not point to the start of the internal buffer, as long as the relative offsets of all elements of the buffer align with the offsets specified in the accessor. The passee must know the internal structure of the passer's buffer in order to read information from it. The passee must not free the buffer at the pointer, nor may it write to this buffer.</p>
<p>
For row accessors, this buffer is the rowset's copy of the row. The consumer reads information directly from this copy of the row at a later point in time, so the provider must guarantee that the pointer remains valid.</p>
<p>
For parameter accessors, this buffer is the consumer's buffer. The provider reads data from this buffer only when <b>ICommand::Execute</b> is called, so the pointer is not required to remain valid after <b>Execute</b> returns.</p>
<p>
Support for this flag is optional. A consumer determines whether a provider supports this bit by calling <b>IDBProperties::GetProperties</b> for the DBPROP_BYREFACCESSORS property.</p>
</td>
</tr>
<tr valign=top>
<td width=30%></td>
<td width=70%>When this flag is used, the <i>dwMemOwner</i> in the DBBINDING structure is ignored. If the accessor is used for row data, the accessor refers to the provider's memory; the consumer must not write to or free this memory. If the accessor is used for input parameters, the provider copies the row of data without assuming ownership.<p>
It is an error to specify an output or input/output parameter in a reference accessor.</p>
<p>
For more information, see "<a href="ch06pr_39mb.htm">Reference Accessors</a>" in Chapter 6.</p>
</td>
</tr>
<tr valign=top>
<td width=30%>DBACCESSOR_<br>
ROWDATA</td>
<td width=70%>The accessor is a row accessor and describes bindings to columns in the rowset.<p>
An accessor may be a row accessor, a parameter accessor, or both.</p>
</td>
</tr>
<tr valign=top>
<td width=30%>DBACCESSOR_<br>
PARAMETERDATA</td>
<td width=70%>The accessor is a parameter accessor and describes bindings to parameters in the command text. In a parameter accessor, it is an error to bind an input or an input/output parameter more than once.</td>
</tr>
<tr valign=top>
<td width=30%>DBACCESSOR_<br>
OPTIMIZED</td>
<td width=70%>The row accessor is to be optimized. This hint may affect how a provider structures its internal buffers. A particular column can be bound by only one optimized accessor. The column can also be bound by other, nonoptimized accessors, but the types specified in the nonoptimized accessors must be convertable from the type in the optimized accessor. All optimized accessors must be created before the first row is fetched with <b>IRowset::GetNextRows</b>, <b>IRowsetLocate::GetRowsAt</b>, <b>IRowsetLocate::GetRowsByBookmark</b>, or <b>IRowsetScroll::GetRowsAtRatio</b>.<p>
This flag is ignored for parameter accessors.</p>
</td>
</tr>
</table><br>
<p class=dt>
<i>cBindings</i></p>
<p class=indent>
[in]<br>
The number of bindings in the accessor.</p>
<p class=tl>
If <i>cBindings</i> is zero, <b>CreateAccessor</b> creates a null accessor. Null accessors are used only by <b>IRowsetChange::InsertRow</b> to create a new row in which each column is set to its default value, NULL, or a status of DBSTATUS_E_UNAVAILABLE. Providers that support <b>InsertRow</b> must support the creation of null accessors. For more information, see <a href="rowchg_4v93.htm">InsertRow</a>.</P><p class=dt>
<i>rgBindings</i></p>
<p class=indent>
[in]<br>
An array of DBBINDING structures. For more information, see "<a href="ch06pr_7q2b.htm">DBBINDING Structures</a>" in Chapter 6.</p>
<p class=dt>
<i>cbRowSize</i></p>
<p class=indent>
[in]<br>
The numer of bytes allocated for a single set of parameters or criteria values in the consumer's buffer.</p>
<p class=tl>
<i>cbRowSize</i> is used by <b>ICommand::Execute</b> to process multiple sets of parameters, and by <b>IViewFilter::GetFilter</b> and <b>IViewFilter::SetFilter</b> to get and set multiple OR' conditions in criteria. In both cases, a single accessor may describe multiple sets of values. <i>cbRowSize </i>is generally the size of the structure that contains a single set of parameter or critieria values and is used as the offset to the start of the next set of values within the array of structures. For example, if <i>cParamSets</i> is greater than 1 in the DBPARAMS structure passed to <b>Execute</b>, the provider assumes that the <i>pData</i> element of this structure points to an array of structures containing parameter values, each <i>cbRowSize</i> bytes in size. Similarly, if <i>cRows</i> is greater than 1 in <b>SetFilter</b>, the provider assumes that the <i>pCriteriaData</i> argument points to an array of structures containing criteria values, each <i>cbRowSize</i> bytes in size.</P><p class=tl>
<i>cbRowSize</i> must be large enough to contain the structure defined by the bindings in <i>rgBindings</i>. The provider is not required to verify this, although it may.</P><p class=tl>
<i>cbRowSize</i> is not used when fetching rowset data.</P><p class=dt>
<i>phAccessor</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the handle of the created accessor. If <b>CreateAccessor</b> fails, it must attempt to set *<i>phAccessor</i> to a null handle.</p>
<p class=dt>
<i>rgStatus</i></p>
<p class=indent>
[out]<br>
An array of <i>cBindings</i> DBBINDSTATUS values in which <b>CreateAccessor</b> returns the status of each binding; that is, whether it was successfully validated or not. If <i>rgStatus</i> is a null pointer, no bind status values are returned. The consumer allocates and owns the memory for this array. The bind status values are returned for the following reasons.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=32%><b>Value</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_OK</td>
<td width=68%>No errors were found in the binding. Because accessor validation can be deferred, a status of DBBINDSTATUS_OK does not necessarily mean that the binding was successfully validated.</td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_<br>
BADORDINAL</td>
<td width=68%>A parameter ordinal was zero in a parameter accessor.<p>
If the accessor is validated against the metadata when <b>CreateAccessor</b> is called, DBBINDSTATUS_BADORDINAL can be returned for the following reasons:
<ul type=disc>
<li>
In a row accessor, a column ordinal in a binding was outside the range of available columns on the rowset.<br><br></li>
<li>
In a parameter accessor, a parameter ordinal was greater than the number of parameters in the command text.</li>
</ul>
<p>
These reasons cause a status value of DBSTATUS_E_BADACCESSOR to be returned if the accessor is validated when used.</p>
<p>
Some providers may support binding more parameters than the number of parameters in the command text, and such providers do not return DBBINDSTATUS_BADORDINAL in this case.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_<br>
UNSUPPORTED<br>
CONVERSION</td>
<td width=68%>If the accessor is validated against the metadata when <b>CreateAccessor</b> is called, DBBINDSTATUS_UNSUPPORTEDCONVERSION can be returned for the following reason:<ul type=disc>
<li>
The specified conversion was not supported by the provider. For a list of conversions the accessor must support, see "<a href="ch10pr_5wry.htm">Data Type Conversion</a>" in Chapter 10.<br><br></li>
<li>
The consumer attempted to convert a column to a storage object (ISequentialStream, IStorage, IStream, ILockBytes) and the particular conversion is not supported by the provider.</li>
</ul>
<p>
These reasons cause a status value of DBSTATUS_E_BADACCESSOR to be returned if the accessor is validated when used.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_<br>
BADBINDINFO</td>
<td width=68%><i>dwPart</i> in a binding was not one of the following:<p class=tl>
DBPART_VALUE<br>
DBPART_LENGTH<br>
DBPART_STATUS</P><p>
<i>eParamIO</i> in a binding in a parameter accessor was not one of the following:</p>
<p class=tl>
DBPARAMIO_INPUT<br>
DBPARAMIO_OUTPUT<br>
DBPARAMIO_INPUT | DBPARAMIO_OUTPUT</P><p>
A row accessor was optimized and a column ordinal in a binding was already used in another optimized accessor.</p>
<p>
In a parameter accessor, two or more bindings contained the same ordinal for an input or input/output parameter.</p>
<p>
<i>wType</i> in a binding was DBTYPE_EMPTY or DBTYPE_NULL.</p>
<p>
<i>wType</i> in a binding was one of the following:</p>
<p class=tl>
DBTYPE_BYREF | DBTYPE _EMPTY,<br>
DBTYPE_BYREF | DBTYPE_NULL, or<br>
DBTYPE_BYREF | DBTYPE_RESERVED.</P><p>
<i>wType</i> in a binding was used with more than one of the following mutually exclusive type indicators: DBTYPE_BYREF, DBTYPE_ARRAY, or DBTYPE_VECTOR.</p>
<p>
<i>wType</i> in a binding was DBTYPE_IUNKNOWN, and <i>pObject</i> in the same binding was a null pointer.</p>
<p>
Provider-owned memory was specified for a nonpointer type in a nonreference row accessor.</p>
<p>
Provider-owned memory was specified for a column and the provider does not support binding to provider-owned memory for this column.</p>
<p>
Provider-owned memory was specified for a column for which <b>IColumnsInfo::GetColumnInfo</b> returned DBCOLUMNFLAGS_ISLONG.</p>
<p>
In a nonreference parameter accessor, a binding specified provider-owned memory.</p>
<p>
An output or input/output parameter was specified in a parameter reference accessor.</p>
<p>
<i>dwFlags</i> in a binding was set to DBBINDFLAG_HTML, and <i>wType</i> for the same binding was not a string value.</p>
<p>
If the accessor is validated against the metadata when <b>CreateAccessor</b> is called, DBBINDSTATUS_BADBINDINFO can be returned for the following reasons:
<ul type=disc>
<li>
A row accessor was not optimized, a column number in a binding specified a column that was already used in an optimized accessor, and the provider did not support a conversion from the type specified in the optimized accessor for the column to the type specified in <i>wType</i>.<br><br></li>
<li>
In a parameter accessor, <i>eParamIO</i> in a binding specified the incorrect I/O type for the parameter. Some providers cannot determine parameter I/O types and never return DBBINDSTATUS_BADBINDINFO in this case.<br><br></li>
<li>
In a reference accessor, the value specified for <i>dwPart</i>, <i>obValue</i>, <i>cbMaxLen</i>, or <i>wType</i> in a binding did not match the format of the corresponding element in the rowset's copy of the row.<br><br></li>
<li>
In a nonreference accessor, a binding specified provider-owned memory, <i>wType</i> was X | DBTYPE_BYREF, and the data type of the corresponding element of the rowset's copy of the row was not X or X | DBTYPE_BYREF.<br><br></li>
<li>
In a nonreference accessor, a binding specified provider-owned memory, <i>wType</i> was DBTYPE_BSTR, and the data type of the corresponding element of the rowset's copy of the row was not DBTYPE_BSTR.<br><br></li>
<li>
The accessor was used for passing key column values in <b>IRowsetIndex::Seek</b> or <b>IRowsetIndex::SetRange</b>, and the order in which the key columns were bound did not match the order in which they were returned in <b>IColumnsInfo::GetColumnInfo</b>.<br><br></li>
<li>
The accessor was used for passing key column values in <b>Seek</b> or <b>SetRange</b>, and a less significant key column was bound without binding all more significant key columns.<br><br></li>
<li>
The accessor was used for passing key column values in <b>Seek</b> or <b>SetRange</b>, and a non-key column was bound before the last bound key column.<br><br></li>
<li>
These reasons cause a status value of DBSTATUS_E_BADACCESSOR to be returned if the accessor is validated when used.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_<br>
BADSTORAGE<br>
FLAGS</td>
<td width=68%><i>dwFlags</i>, in the DBOBJECT structure pointed to by a binding, specified invalid storage flags.<p>
If the accessor is validated against the metadata when <b>CreateAccessor</b> is called, DBBINDSTATUS_BADSTORAGEFLAGS can be returned for the following reason:
<ul type=disc>
<li>
<i>dwFlags</i>, in the DBOBJECT structure pointed to by a binding, specified a valid storage flag that was not supported by the object.</li>
</ul>
<p>
These reasons cause a status value of DBSTATUS_E_BADACCESSOR to be returned if the accessor is validated when used.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBBINDSTATUS_<br>
NOINTERFACE</td>
<td width=68%>If the accessor is validated against the metadata when <b>CreateAccessor</b> is called, DBBINDSTATUS_NOINTERFACE can be returned for the following reasons:<ul type=disc>
<li>
The provider did not support the storage interface specified in <i>iid</i> in the DBOBJECT structure pointed to by a binding in the accessor.<br><br></li>
<li>
The OLE object in a column or parameter did not support the interface specified in <i>iid</i> in the DBOBJECT structure pointed to by the corresponding binding in the accessor.<br><br></li>
<li>
The provider supports only one open storage object at a time—that is, DBPROP_MULTIPLESTORAGEOBJECTS is VARIANT_FALSE—and <i>wType</i> in more than one binding was DBTYPE_IUNKNOWN.</li>
</ul>
<p>
These reasons cause a status value of DBSTATUS_E_BADACCESSOR to be returned if the accessor is validated when used.</p>
</td>
</tr>
</table><br>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. If <i>rgStatus</i> is not a null pointer, each element is set to DBBINDSTATUS_OK.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>phAccessor</i> was a null pointer.</p>
<p class=tl>
<i>cBindings </i>was not zero and <i>rgBindings</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state. This error can be returned only when the method is called on a rowset.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORFLAGS<br>
<i>dwAccessorFlags</i> was invalid.</p>
<p class=tl>
The DBACCESSOR_PARAMETERDATA bit was set in <i>dwAccessorFlags</i>, and the provider does not support parameters.</P><p class=tl>
Neither the DBACCESSOR_PARAMETERDATA bit nor the DBACCESSOR_ROWDATA bit was set in <i>dwAccessorFlags</i>.</P><p class=tl>
A method that fetches rows (<b>IRowset::GetNextRows</b>, <b>IRowsetLocate::GetRowsAt</b>, <b>IRowsetLocate::GetRowsByBookmark</b>, or <b>IRowsetScroll::GetRowsAtRatio</b>) had already been called and the DBACCESSOR_OPTIMIZED bit in <i>dwAccessorFlags</i> was set.</P><p class=tl>
The DBACCESSOR_ PARAMETERDATA bit was set and <b>CreateAccessor</b> was called on a rowset.</P><p class=dt>
</p>
<p class=indent>
DB_E_BYREFACCESSORNOTSUPPORTED<br>
<i>dwAccessorFlags</i> was DBACCESSOR_PASSBYREF and the value of the DBPROP_BYREFACCESSORS property is VARIANT_FALSE.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Accessor validation failed. To determine which bindings failed, the consumer checks the values returned in <i>rgStatus</i>, at least one of which is not DBBINDSTATUS_OK.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NULLACCESSORNOTSUPPORTED<br>
<i>cBindings</i> was zero and the rowset does not support <b>IRowsetChange::InsertRow</b>, or <b>CreateAccessor</b> was called on a command.</p>
<p class=label>
<b>Comments</b></p>
<p>
For general information about accessors, see "<a href="ch06pr_74kz.htm">Accessors</a>" in Chapter 6.</p>
<p>
<b>CreateAccessor</b> always checks all error conditions that do not require it to validate the accessor against the metadata. As a general rule, this means it checks the error conditions for all of the return codes except those that return DB_E_ERRORSOCCURRED. <b>CreateAccessor</b> may validate the accessor against the metadata for row accessors created on the rowset; it never validates the accessor against the metadata for row or parameter accessors created on the command. When <b>CreateAccessor</b> validates the accessor against the metadata, it validates each binding in the accessor, setting the appropriate DBBINDSTATUS values as it goes. If <b>CreateAccessor</b> fails in any way, it does not create the accessor and sets *<i>phAccessor</i> to a null handle.</p>
<p>
If <b>CreateAccessor</b> does not validate the accessor against the metadata, then the validation is said to be <i>delayed</i>. <b>CreateAccessor</b> simply creates the accessor and validation is done by the first method that uses the accessor. If the accessor is found to be invalid, it remains in existence and can be used again.</p>
<p>
If accessor validation is delayed, the provider determines whether the method validating the accessor validates it against the metadata before or during data transfer. If the method validates the accessor before transferring any data, it can return any of the return codes listed below for this purpose. If the method validates the accessor while transferring the data, it sets the status value of any column or parameter for which the accessor is invalid (within the context of the method) to DBSTATUS_E_BADACCESSOR and returns DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED. Whether the method continues processing other columns or parameters depends on both the method and the provider.</p>
<p>
The following return codes are returned by methods that perform delayed accessor validation before transferring any data. The DBBINDSTATUS value to which each corresponds is also listed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=52%><b>Return code</b></td>
<td class=label width=48%><b>DBBINDSTATUS value</b></td>
</tr>
<tr valign=top>
<td width=52%>E_NOINTERFACE</td>
<td width=48%>DBBINDSTATUS_NOINTERFACE</td>
</tr>
<tr valign=top>
<td width=52%>DB_E_BADBINDINFO</td>
<td width=48%>DBBINDSTATUS_BADBINDINFO</td>
</tr>
<tr valign=top>
<td width=52%>DB_E_BADORDINAL</td>
<td width=48%>DBBINDSTATUS_BADORDINAL</td>
</tr>
<tr valign=top>
<td width=52%>DB_E_BADSTORAGEFLAGS</td>
<td width=48%>DBBINDSTATUS_<br>
BADSTORAGEFLAGS</td>
</tr>
<tr valign=top>
<td width=52%>DB_E_UNSUPPORTEDCONVERSION</td>
<td width=48%>DBBINDSTATUS_<br>
UNSUPPORTEDCONVERSION</td>
</tr>
</table><br>
<p>
Providers that do not support conversion of BLOB or non-BLOB data to a data structured storage interface should fail the accessor creation method with DB_E_ERRORSOCCURED and report DBBINDSTATUS_UNSUPPORTEDCONVERSION on the column specifying the incorrect binding.</p>
<p>
<b>See Also</b></p>
<p>
<a href="accssr_30dv.htm">IAccessor::GetBindings</a>, <a href="accssr_4sdu.htm">IAccessor::ReleaseAccessor</a>, <a href="cnvtyp_2xkk.htm">IConvertType::CanConvert</a>, <a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowchg_0c81.htm">IRowsetChange::SetData</a></p>
</font></BODY>
</HTML>
