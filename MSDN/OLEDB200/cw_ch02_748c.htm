<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Example: Creating an Edit Control</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="examplecreatingeditcontrol"></a>Example: Creating an Edit Control</h1>
<p>
The following example creates the Simptext.ocx Edit Control using the ActiveX Control Creation Wizard. Some features that you may normally put in an ActiveX control are left out of these steps for the sake of simplicity. Refer to the Simptxt project in the Samples directory, included with this SDK, for the source code to this sample.</p>
<p>
This simple bound text box works very much like the <b>TextBox</b> control in Visual Basic.</p>
<h1>Creating the Simptext.ocx Edit Control</h1>
<p>
The ActiveX Control Creation Wizard is part of the ActiveX Controls Framework. </p>
<p class=label>
<b>To create an ActiveX control in Visual Basic</b>
<ol>
<li>
Follow the instructions in Appendix A to start the control wizard.<br><br></li>
<li>
Type the name of your project—for example, Simptext.<br><br></li>
<li>
Type in or browse for the directory where you want the project to be saved.<br><br></li>
<li>
Select the project type; the default project is "ActiveX Control." Click <b>Next</b>.<br><br></li>
<li>
Type the name of your control—for example, SimpText.<br><br></li>
<li>
Select the Windows control that you want to subclass—for example, EDIT. Click <b>Next</b>.<br><br></li>
<li>
 Click <b>Finish</b>. The wizard creates a new ActiveX Framework Control in the designated directory.</li>
</ol>
<p>
Once the wizard has successfully completed, you can begin working on the new ActiveX Framework control project.</p>
<h1>Modifying the .odl File</h1>
<p>
The first step to adding a property to a control is to modify its .odl file. See "Adding Atributes to the .odl File" earlier in this chapter for details about modifying the .odl file to add the data-binding attributes. </p>
<p>
To add a default bindable property to Simptext, add the following property to the interface definition for the ISimpText declaration. Because the default bindable property should best describe a control's nature, the Text property is appropriate with an Edit control. Open the Simptext.odl file:</p>
<pre><code>[id(DISPID_TEXT), propget, bindable, requestedit, displaybind, defaultbind] 
HRESULT Text([out, retval] BSTR *pbstrText);
[id(DISPID_TEXT), propput, bindable, requestedit, displaybind, defaultbind] 
HRESULT Text([in] BSTR bstrText);
</code></pre>
<p>
DISPID_TEXT is defined in Olectl.h because it is a stock property (a property that is very common among ActiveX controls).</p>
<p>
After adding a property declaration to the .odl file, you must also add the corresponding declaration to the control’s class definition in its C++ header file. Open SimpTextCtl.h and add the following method declaration to the CSimpTextControl class definition:</p>
<pre><code>STDMETHOD(get_Text)(BSTR * pbstrText);
STDMETHOD(put_Text)(BSTR bstrText);
</code></pre>
<h1>Managing the Property Value</h1>
<p>
So far, you've created the simple bound property. In the following procedures, you add a member variable to store the actual value of the Text property, as well as initialize and store the property.</p>
<p>
To add a member variable to store the Text property, open the Simptextctl.h file and find the structure definition for SIMPTEXTCTLSTATE. Add the following structure member to the structure:</p>
<pre><code>BSTR bstrText;
</code></pre>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>In the rest of the example, you will be adding code to the Simptextctl.cpp file.</p>
<h1>Initializing State Variables </h1>
<p>
When you first create your control, you want your text property to be the same as the name of your control, just like the Visual Basic <b>TextBox</b> control. The first time you place a new control on a form, the framework's <b>COleControl::InitializeNewState</b> method is called, so this is where you put the code to initialize the <b>m_state.bstrText </b>and other state variables that may apply to this case.</p>
<p>
The implementation of <b>CSimpTextControl::InitializeNewState</b> looks like this:</p>
<pre><code>BOOL CSimpTextControl::InitializeNewState(void)
{
   // Make the text property the same as the control name
   // the first time you place the control on the form.
   if (!GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, VT_BSTR, (void*)&amp;m_state.bstrText))
      // If this is unsuccessful, then use the base control name.
      m_state.bstrText = SysAllocString(L"SimpText");

   // TRUE to proceed
   // FALSE to fail
   return TRUE;   
}
</code></pre>
<h1>Initializing the Control Window</h1>
<p>
After the control object is created by the container and the control state is initialized, the host activates the control in place. The control framework prepares the control for display, including creating the control window. To allow the control to hook into this process, <b>COleControl</b> provides two methods: <b>BeforeCreateWindow</b> and <b>AfterCreateWindow</b>.</p>
<p>
Call<b> BeforeCreateWindow</b> to allow controls to set up their window styles and captions. <b>CSimpTextControl::BeforeCreateWindow</b> is implemented as follows:</p>
<pre><code>BOOL CSimpTextControl::BeforeCreateWindow
(
  DWORD *pdwWindowStyle,
  DWORD *pdwExWindowStyle,
  LPSTR&nbsp; pszWindowTitle
)
{
   // Allow text to scroll past the right border.
   //
   *pdwWindowStyle |= ES_AUTOHSCROLL;

   // Give the border a 3-D effect.
   //
   *pdwExWindowStyle |= WS_EX_CLIENTEDGE;

   // Fill in pszWindowTitle if the Text property is initialized.
   //
   if (m_state.bstrText)
   {
      // It doesn’t matter whether conversion succeeds.
      // If it does not succeed, then the Edit control 
      // is cleared.
      //
      MAKE_ANSIPTR_FROMWIDE(szText, m_state.bstrText);

      if (szText)
      {
         // The framework allocates a buffer of
         // 128 bytes, so be careful not to exceed
         // this limit.
         //
         lstrcpyn(pszWindowTitle, szText, 127);
      }
      // szText will deallocate when it loses scope.
      // MAKE_ANSIPTR_FROMWIDE is in the framework's UTIL.H file.
   }
  return TRUE;
}
</code></pre>
<p>
Implement <b>AfterCreateWindow</b> to perform initialization after the control window has been created. If necessary, you can initialize your control during its creation process. To do this, add code to handle the WM_NCCREATE or WM_CREATE messages in your control’s implementation of <b>WindowProc</b>. While the control window is being created, the process is running in a critical section of code. Therefore, any initialization done during WM_NCCREATE and or WM_CREATE must take this into account. If possible, do your initialization in <b>AfterCreateWindow</b> after your control window is been created.</p>
<h1>Keeping the Member Variable Persistent</h1>
<p>
Now that you can store your value in the <b>m_state.bstrText</b> member variable, you need to make sure it is saved and restored whenever the control is restarted. There are two types of persistence: 
<ul type=disc>
<li>
Text, which persists using <b>IPropertyBag</b>. <br><br></li>
<li>
Binary, which persists using <b>IStream</b>.</li>
</ul>
<p>
This SDK provides persistence helpers in Persist.h and Persist.cpp to facilitate persisting properties of the most common types. For more information about implementing persistence, see “Using the Framework” in Appendix A. </p>
<h1>Managing the Text Property</h1>
<p>
Managing the Text property requires that the control handle <b>EN_CHANGE</b> notifications from the Edit window itself. These notifications occur when the user edits the control’s contents. The control also needs to implement <b>CSimpTextControl::get_Text</b> so that it can return a copy of <b>m_state.bstrText</b> to the host.</p>
<h1>Returning the Text</h1>
<p>
<b>CSimpTextControl::get_Text</b> is called when the Text property value is needed. The control may call this method internally, but the host calls it in most cases. The idea here is to return a copy of the text stored in <b>m_state.bstrText</b>. The following implementation of <b>CSimpTextControl::get_Text</b> demonstrates this:</p>
<pre><code>STDMETHODIMP CSimpTextControl::get_Text(BSTR *pbstrText)
{
   CHECK_POINTER(pbstrText);

   if (m_state.bstrText)
      // Make a copy.
      //
      *pbstrText = bstralloc(m_state.bstrText);
   else
      // Return an empty string.
      //
      *pbstrText = SysAllocString(L"");
   
   return NULL == *pbstrText ? E_OUTOFMEMORY : S_OK;
}
</code></pre>
<h1>Handling the EN_CHANGE Text Box Message</h1>
<p>
Any time the value in the text box changes, you want to notify the container of that change. In this case, add code to respond to the <b>EN_CHANGE</b> text box message to notify the container. The Windows Edit control sends the <b>EN_CHANGE</b> notification code with the <b>WM_COMMAND</b> to its owner. This message is reflected back to the ActiveX control through the <b>OCM_COMMAND</b> message. ActiveX Framework controls can handle reflected messages in their implementation of <b>WindowProc</b>. Here is an example of how <b>CSimpTextControl::WindowProc</b> is implemented to handle the <b>EN_CHANGE</b> notification:</p>
<pre><code>LRESULT CSimpTextControl::WindowProc
(
  UINT msg,
  WPARAM wParam,
  LPARAM lParam
)
{
  // TODO: handle any messages here, like in a normal window
  // proc.&nbsp; Note that for special keys, you'll want to override and
  // implement OnSpecialKey.
    //

   switch (msg)
   {
   // WM_COMMAND message is sent to the container and is
   // reflected back as OCM_COMMAND.
   //
   case OCM_COMMAND:
      // The Text property needs to be updated when
      // the edit control's contents change. The 
      // control must request permission from the
      // container to update the text here and in
      // put_Text.
      //
      if (HIWORD(wParam) == EN_CHANGE)
      {
         if (RequestPropertyEdit(DISPID_TEXT))
         {
            // You got permission, so get the new text
            // from the edit control, if any.
            //
            int nLen = GetWindowTextLength(m_hwnd);

            if (nLen)
            {
               // Allocate a buffer for text and a
               // NULL terminator.
               //
               char *szText = new char[++nLen];

               if (NULL != szText)
               {
                  GetWindowText(m_hwnd, szText, nLen);
                  BSTR bstrText = bstralloc(szText);
                  delete [] szText;

                  if (bstrText)
                  {
                     if (m_state.bstrText)
                        SysFreeString(m_state.bstrText);

                     // Assign a new Text value and notify the 
                     // container of the change.
                     //
                     m_state.bstrText = bstrText;
                     PropertyChanged(DISPID_TEXT);
                     return 0;
                  }
               }
            }
            else
            {
               // The Edit control is empty, so free any text.
               // Otherwise, nothing needs to be done.
               //
               if (m_state.bstrText)
               {
                  SysFreeString(m_state.bstrText);
                  m_state.bstrText = NULL;
                  PropertyChanged(DISPID_TEXT);
               }
               return 0;
            }
         }
         // NOTE: This code is executed if the container
         // refused the change request, or if the above
         // allocation failed. In either case,
         // you need to call SyncText to keep the edit
         // control content in sync with m_state.Text.
         //
         SyncText();
      }
      // You don't need to pass on to a subclass
      // because this is an OLE-specific message.
      //
      return 0;
   }
   return CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(OBJECT_TYPE_CTLSIMPTEXT), m_hwnd, msg, wParam, lParam);
}
</code></pre>
<h1>Setting the Text</h1>
<p>
To change the Text property, the control must first notify the host that it’s about to make a change. This is done by calling <b>COleControl::RequestPropertyEdit</b> on the dispatch ID of the property in question. If <b>RequestPropertyEdit</b> returns <b>True</b>, the host has given permission to allow the property to be changed. Then, after a successful change, the control must notify the host that the property has changed by calling <b>COleControl::PropertyChanged</b> on the dispatch ID of the property that was changed.</p>
<p>
The implementation of <b>CSimpTextControl::put_Text</b> demonstrates the procedure to notify the host of the change in the Text property:</p>
<pre><code>STDMETHODIMP CSimpTextControl::put_Text(BSTR bstrText)
{
   // Request permission to edit the property
   // and throw an exception if the container
   // does not permit it.
   //
   if (!RequestPropertyEdit(DISPID_TEXT))
      return Exception(CTL_E_SETNOTPERMITTED, 0, 0);

   if (bstrText)
   {
      // Make a copy of the text and return
      // E_OUTOFMEMORY if allocation failed.
      //
      bstrText = bstralloc(bstrText);
      RETURN_ON_NULLALLOC(bstrText);
   }
   // Free the current property. 
   //
   if (m_state.bstrText)
      SysFreeString(m_state.bstrText);

   // Assign a new property value. This can
   // be a NULL BSTR.
   //
   m_state.bstrText = bstrText;

   // Synchronize the Edit control's contents
   // with m_state.bstrText.
   //
   SyncText();

   // Notify the container of changes.
   //
   PropertyChanged(DISPID_TEXT);

   return S_OK;
}
</code></pre>
<h1>Building the Control</h1>
<p class=label>
<b>To build and register the control</b>
<ul type=disc>
<li>
&nbsp;From the <b>Build</b> menu in Microsoft Visual C++ 5.0, click <b>Build SIMPTEXT.OCX</b>. Your control is built and ready to be inserted into a container.<br><br></li>
</ul>
</font></BODY>
</HTML>
