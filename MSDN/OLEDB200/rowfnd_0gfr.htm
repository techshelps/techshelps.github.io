<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetFind::FindNextRow</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetfind__findnextrow"></a>IRowsetFind::FindNextRow</h1>
<p>
Begin at the specified bookmark and find the next row matching the specified value. </p>
<pre><code>HRESULT FindNextRow (
   HCHAPTER                  hChapter,
   HACCESSOR               hAccessor,
      void *                        pFindValue,
      DBCOMPAREOP            CompareOp,
      ULONG                     cbBookmark,
   const BYTE *                  pBookmark,
      LONG                        IRowsOffset,
   LONG                        cRows,
   ULONG *                     pcRowsObtained,
      HROW **                     prghRows);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
Accessor describing the value to be matched. This accessor must describe only a single column. If it describes more than one column, <b>FindNextRow</b> returns DB_E_BADBINDINFO.</p>
<p class=tl>
<i>Valid coercions for FindNextRow are the same as those for SetData. </i></P><p class=dt>
<i>pFindValue</i></p>
<p class=indent>
[in]<br>
Pointer to the value to be matched.&nbsp; If this indicates a null value (a variant of type VT_NULL, or a status value of DBSTATUS_ISNULL), it is compared to other values according to the DBPROP_NULLCOLLATION property returned in the Data Source Information property set. .</p>
<p class=dt>
<i>CompareOp</i></p>
<p class=indent>
[in]<br>
Operation to use in comparing the row values. The consumer should check DBPROP_FINDCOMPAREOPS to determine which comparison operators the provider supports. <br>
<br>
Only DBCOMPAREOPS_EQ, DBCOMPAREOPS_NE, and DBCOMPAREOPS_IGNORE are valid for the following CompareOps: 
<ul type=disc>
<li>
DBTYPE_BOOL<br><br></li>
<li>
DBTYPE_ERROR<br><br></li>
<li>
DBTYPE_GUID<br><br></li>
<li>
DBTYPE_IDISPATCH<br><br></li>
<li>
DBTYPE_IUNKNOWN<br><br></li>
<li>
DBTYPE_BTYES</li>
</ul>
<p class=indent>
The values in DBCOMPAREOPSENUM have the following meanings.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=50%><b>Value</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_LT</td>
<td width=50%>Match the first value that is less than the search value.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_LE</td>
<td width=50%>Match the first value that is less than or equal to the search value.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_EQ</td>
<td width=50%>Match the first value that is equal to the search value.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_GE</td>
<td width=50%>Match the first value that is greater than or equal to the search value.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_GT</td>
<td width=50%>Match the first value that is greater than the search value.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_BEGINSWITH</td>
<td width=50%>Match the first value that has the search value as its first characters. This is only valid for values bound as string data types.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_NOTBEGINSWITH</td>
<td width=50%>Match the first value that does not have the search value as its first characters. This is only valid for values bound as string data types.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_CONTAINS</td>
<td width=50%>Match the first value that contains the search value. This is only valid for values bound as string data types.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_NOTCONTAINS</td>
<td width=50%>Match the first value that does not contain the search value. This is only valid for values bound as string data types.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_NE</td>
<td width=50%>Match the first value that is not equal to the search value. NULLs evaluate as not equal to any other value, but equal to other NULLs.</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_IGNORE</td>
<td width=50%>Ignore the corresponding value.<p>
The provider ignores <i>pFindValue</i> and returns the next <i>cRows</i> rows starting from the row indicated by <i>pBookmark</i>, skipping the number of rows indicated by<i> lRowsOffset</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=50%>DBCOMPAREOPS_CASESENSITIVE and DBCOMPAREOPS_CASEINSENSITIVE</td>
<td width=50%>Specify whether the search is case sensitive or case insensitive.<p>
You can join DBCOMPAREOPS_CASESENSITIVE or DBCOMPAREOPS_CASEINSENSITIVE with any of the other DBCOMPAREOPS values in a bitwise <b>OR</b> operation. If neither one is used, the search is handled according to the provider's implementation. Both DBCOMPAREOPS_CASESENSITIVE and DBCOMPAREOPS_CASEINSENSITIVE are ignored when searching for nonstring values.</p>
</td>
</tr>
</table><br>
<p class=dt>
</p>
<p class=dt>
<i>cbBookmark</i> </p>
<p class=indent>
[in]<br>
Length in bytes of the bookmark, or zero in order to start from the next fetch location (see the description of <i>pBookmark</i>). </p>
<p class=dt>
<i>pBookmark</i></p>
<p class=indent>
[in]<br>
Pointer to a bookmark that, in combination with <i>IRowsetOffset</i>, identifies the row from which to start searching for a match. The consumer is not required to have access rights to this row. However, if this row matches the seek criteria, the provider cannot return it unless the consumer has read permission for it.<br>
<br>
The consumer can specify a <i>cbBookmark</i> value of zero, and set <i>pBookmark</i> to null, in order to request that the find occur starting with the next fetch location. The next fetch location is the same as the next fetch position used by GetNextRows.</p>
<p class=tl>
If the rowset does not support <b>IRowsetLocate</b>, then only the special bookmarks DBBMK_FIRST and DBBMK_LAST, and the null value, may be used.</P><p class=tl>
If the rowset does not support scrolling backward, then only the null bookmark value may be used.</P><p class=tl>
If the rowset is chaptered, the identified row must fall within the specified chapter.</P><p class=dt>
<i>IRowsOffset</i></p>
<p class=indent>
[in]<br>
The signed count of rows from the origin bookmark to the row at which to start searching for a match. The first row checked is determined by the bookmark and this offset. For example, if <i>IRowsOffset</i> is 0, the first row checked is the bookmarked row; if <i>IRowsOffset</i> is 1, the first row checked is the row after the bookmarked row; if <i>IRowsOffset</i> is -1, the first row checked is the row before the bookmarked row. This can be a negative number only if the value of the DBPROP_CANSCROLLBACKWARDS property is VARIANT_TRUE.</p>
<p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The number of rows to fetch from the rowset, starting with the first row found. A negative number means to fetch backward. Check the DBPROP_CANFETCHBACKWARDS property returned in <b>IRowsetInfo::GetProperties</b> to determine whether this is supported.</p>
<p class=tl>
The search direction is the same as the fetch direction, so a negative count searches backward from the starting position and returns successively earlier rows as subsequent obtained rows.</P><p class=tl>
If <i>cRows</i> is 0 and there are no other errors, no rows are fetched but the fetch position for <b>FindNextRow</b> is moved to the next match. If no match is found, the fetch position is moved before the beginning of the rowset if the previous fetch direction was backward, or after the end of the rowset if the previous fetch direction was forward or if this is the first fetch.</P><p class=dt>
<i>pcRowsObtained</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the actual number of fetched rows.</p>
<p class=dt>
<i>prghRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of handles of the retrieved rows. If *<i>prghRows</i> is not a null pointer on input, it must be a pointer to memory large enough to return the handles of the requested number of rows. If *<i>prghRows</i> is a null pointer on input, the rowset allocates memory for the row handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> after it releases the row handles. If *<i>prghRows</i> was a null pointer on input and *<i>pcRowsObtained</i> is 0 on output, the provider does not allocate any memory and ensures that *<i>prghRows</i> is a null pointer on output.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ENDOFROWSET<br>
<b>FindNextRow</b> reached the start or the end of the rowset or (in a hierarchical rowset) the start or the end of the chapter and could not fetch all requested rows because the count extended beyond the end. The next fetch position is before the start or after the end of the rowset. The number of rows actually returned is returned in *<i>pcRowsObtained</i>; this will be less than <i>cRows</i>.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ROWLIMITEXCEEDED<br>
Fetching the number of rows specified in <i>cRows</i> would have exceeded the total number of active rows supported by the rowset. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. This condition can occur only when there are more rows available than can be handled by the rowset. Thus, this condition never conflicts with those described in DB_S_ENDOFROWSET and DB_S_STOPLIMITREACHED, both of which imply that no more rows were available.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_STOPLIMITREACHED<br>
Returning rows required further execution of the command, such as when the rowset uses a server-side cursor. Execution has been stopped because a resource limit has been reached. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. Execution cannot be resumed.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_BOOKMARKSKIPPED<br>
The following behavior is only supported on rowsets that set the DBPROP_BOOKMARKSKIPPED property to VARIANT_TRUE. If this property is VARIANT_FALSE, this return code is never returned.</p>
<p class=dt>
</p>
<p class=indent>
The row specified by *<i>pBookmark</i> was deleted, is no longer a member of the rowset, or is a row to which the consumer does not have access rights. <b>FindNextRow</b> skipped that row, and began searching with the next row in the direction indicated by <i>cRows</i>.</p>
<p class=dt>
</p>
<p class=indent>
If this condition occurs along with another warning condition, the method returns the code for the other warning condition. Thus, whenever a consumer receives the return code for another warning condition, it should check to see whether this condition occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pcRowsObtained</i> or <i>prghRows</i> was a null pointer.</p>
<p class=tl>
<i>cbBookmark</i> was not 0 and <i>pBookmark</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to instantiate the rows or return the row handles.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADBINDINFO<br>
The specified accessor specified binding information for more than one column.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADBOOKMARK<br>
<i>*pBookmark</i> was invalid; for example, it was incorrectly formed.</p>
<p class=tl>
<i>*pBookmark</i> did not match any rows in the rowset. This includes the case when the row corresponding to the bookmark has been deleted and DBPROP_BOOKMARKSKIPPED was VARIANT_FALSE.</P><p class=tl>
<i>*pBookmark</i> was not a null value and the rowset does not support scrolling backward.</P><p class=tl>
<i>*pBookmark</i> was not DBBMK_FIRST, DBBMK_LAST, or a null value, and the rowset does not support <b>IRowsetLocate</b>.</P><p class=tl>
The rowset was chaptered and *<i>pBookmark</i> did not apply to the specified chapter.</P><p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Consumers should only attempt to use bookmarks that they have received from the provider. The provider is guaranteed only to handle bookmarks it gives out in a predictable manner. Attempting to use a random value as a bookmark is undefined; the provider may return DB_E_BADBOOKMARK, may return an unexpected row, or may terminate abnormally.</p><p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADCOMPAREOP<br>
<i>CompareOp </i>was an invalid value<i>.</i></p>
<p class=tl>
<i>CompareOp </i>was DBCOMPAREOPS_BEGINSWITH or DBCOMPAREOPS_CONTAINS<i> </i>and<i> pFindValue </i>was not bound as a string value.</P><p class=tl>
Both DBCOMPAREOPS_CASESENSITIVE and DBCOMPAREOPS_CASEINSENSITIVE were used in the same operation.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADSTARTPOSITION<i>IRowsOffset</i> would position the first row retrieved past either end of the rowset, regardless of the <i>cRows</i> value specified. <i>cRowsObtained</i> is 0.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTFETCHBACKWARDS<br>
<i>cRows</i> was negative and the rowset cannot fetch backward. </p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTSCROLLBACKWARDS<br>
A bookmark value of DBBMK_FIRST or DBBMK_LAST was specified and the rowset cannot scroll backward.</p>
<p class=tl>
<i>IRowsOffset</i> was negative and the rowset cannot scroll backward.</P><p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of prior HROWs before new ones can be obtained (see <b>IDBProperties::GetPropertyInfo</b>, DBPROP_CANHOLDROWS).</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to get the rows.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
See <b>IRowsetLocate::GetRowsAt</b> for a complete description of the results for given values for a bookmark, offset, and number of rows to fetch.</p>
<p>
<b>FindNextRow</b> searches the rowset in the direction indicated by <i>cRows</i> for a row that matches <i>pFindValue</i> according to the specified <i>CompareOp</i>. Once a match is found, if <i>cRows</i> is greater than 1, additional rows are returned in rowset order as if the consumer called <b>GetNextRows</b> starting with the first matching row. If no rows match the criteria, <b>FindNextRow</b> returns DB_S_ENDOFROWSET and <i>pcRowsObtained</i> is set to zero.</p>
<p>
For a newly created rowset, if <i>pBookmark</i> is null, the search begins starting with the row computed according to the next fetch position as described in <b>GetNextRows</b> for newly created rowsets.</p>
<p>
It is not required that the rowset be ordered on the column searched. <b>FindNextRow</b> always finds the next row according to the criteria, regardless of the sort order. </p>
<p>
<b>FindNextRow</b> increments the reference count of each row for which it returns a handle by 1. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned. </p>
<p>
If the provider encounters a problem fetching a row—for example, data stored in a text file contains a letter in a numeric column—<b>FindNextRow</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
If an error occurs when calling <b>FindNextRow</b>, the fetch position is left unchanged.</p>
<p>
If <b>FindNextRow</b> performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the applicable reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor</b>: E_NOINTERFACE, DB_E_BADBINDINFO, DB_E_BADORDINAL, DB_E_BADSTORAGEFLAGS, and DB_E_UNSUPPORTEDCONVERSION.</p>
<p>
For information about what <b>FindNextRow</b> does when it fetches a row that it already has in its internal buffers, see "Uniqueness of Rows in the Rowset" in Chapter 4. For information about whether <b>FindNextRow</b> can detect changes made to rows in the rowset, see "Visibility of Changes" in Chapter 5. For information about how <b>FindNextRow</b> interprets data from <i>*pFindValue</i>, see "Setting Data" in Chapter 6.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowidx_646j.htm">IRowsetIndex::Seek</a>, <a href="rowloc_2oj8.htm">IRowsetLocate::GetRowsAt</a>, <a href="rowloc_3nfv.htm">IRowsetLocate::GetRowsByBookmark</a></p>
</font></BODY>
</HTML>
