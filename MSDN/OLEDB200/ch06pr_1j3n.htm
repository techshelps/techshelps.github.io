<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Accessors</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbusing_accessors"></a>Using Accessors</h1>
<p>
Accessors are created with <b>IAccessor::CreateAccessor</b>, reference-counted with <b>IAccessor::AddRefAccessor</b>, and released with <b>IAccessor::ReleaseAccessor</b>. They can be created and released at any time. An accessor can be a parameter accessor (used for accessing parameter data), a row accessor (used for accessing rowset data), or both. Parameter accessors must be created and used on the command. Row accessors can be created on the command or the rowset and must be used on the rowset. Row accessors created after a row is fetched can still be used against that row.</p>
<p>
When <b>ICommand::Execute</b> creates a rowset, the rowset inherits all row accessors that have been created on that command. To the consumer, it appears as if each accessor has been copied from the command to the rowset: the bindings, flags, and handle of each accessor are the same on both the rowset and the command. Once the rowset is opened, it gets its own independent copy of the accessors. Calling <b>IAccessor</b> on the command object has no effect on the accessors available on any existing rowsets, and calling <b>IAccessor</b> on the rowset has no effect on the accessors available on any existing commands.</p>
<p>
For example, suppose the text command that creates a rowset contains parameters. The consumer might create multiple rowsets by repeatedly executing this text command with different parameters. Because the rowsets are created from the same text command, all can use the same row accessors. It is therefore more efficient to create these accessors once on the command, rather than creating them separately on each rowset. To create a row accessor on a command, the consumer must know the column ordinals. For a text command such as <b>SELECT * FROM MyTable</b>, there is no way to know the order of the result columns. In such a case, the consumer must define the row accessor on the rowset or modify the text command to list the columns. For commands that generate a hierarchy of rowsets, only the first (root) rowset inherits the row accessors from the command.</p>
<p>
Consumers can create and use more than one accessor on a single row. Thus, the consumer can get or set multiple copies of the same data. For example, suppose a rowset contains employee data including a picture of the employee. The consumer might create two accessors: one for all of the columns except the picture column and another for the picture column. The consumer might then pass the handle of the first accessor to <b>IRowset::GetData</b> to get all of the data except the picture. When the user requests the picture, the consumer would then pass the handle to the second accessor to <b>GetData</b> to get the picture.</p>
<p>
Row accessors can be optimized. How this is done is provider specific. In general, it is faster to use an optimized accessor than a nonoptimized accessor. For example, the provider might structure its internal row buffers to match the types used in the accessor. Optimized row accessors must be created before any rows are fetched.</p>
<p>
Flagging accessors as optimized affects only providers that support optimized accessors. In general, providers are not required to recognize optimized accessors, nor are they required to enforce any of the restrictions associated with optimized accessors.</p>
<p>
However, clients written to consume data from general OLE DB providers should never include the same column in more than one optimized accessor, and for all bindings to a particular column, should use a data type coercible from the type specified in any optimized accessor for that column.</p>
</font></BODY>
</HTML>
