<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowset::GetNextRows</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowset__getnextrows"></a>IRowset::GetNextRows</h1>
<p>
Fetches rows sequentially, remembering the previous position.</p>
<pre><code>HRESULT GetNextRows (
   HCHAPTER   hChapter,
   LONG         lRowsOffset,
   LONG         cRows,
   ULONG *      pcRowsObtained,
   HROW **      prghRows);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>lRowsOffset</i></p>
<p class=indent>
[in]<br>
The signed count of rows to skip before fetching rows. Deleted rows that the provider has removed from the rowset are not counted in the skip. If this value is zero and <i>cRows</i> continues in the same direction as the previous call to either<b> GetNextRows</b>, or <b>FindNextRow</b> with a null <i>pBookmark</i> value, then the first row fetched will be the next row after the last one fetched in the previous call. If this value is zero and <i>cRows</i> reverses direction, then the first row fetched will be the last one fetched in the previous call.</p>
<p class=tl>
<i>lRowsOffset</i> can be a negative number only if the value of the DBPROP_CANSCROLLBACKWARDS property is VARIANT_TRUE.</P><p class=tl>
There is no guarantee that skipping rows is done efficiently on a sequential rowset. If the data source resides on a remote server, there may be remote support for skipping without transferring the intervening records across the network, but this is not guaranteed. For information about how the provider implements skipping, see the documentation for the provider.</P><p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The number of rows to fetch. A negative number means to fetch backward. <i>cRows</i> can be a negative number only if the value of the DBPROP_CANFETCHBACKWARDS property is VARIANT_TRUE.</p>
<p class=tl>
If <i>cRows</i> is zero, no rows are fetched; the fetch direction and the next fetch position are unchanged, and the provider performs no processing, returning immediately from the method invocation. Specifically, <i>lRowsOffset</i> is ignored in this situation.</P><p class=tl>
If the provider does not discover any other errors, the method returns S_OK; whether the provider checks for any other errors is provider-specific.</P><p class=dt>
<i>pcRowsObtained</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the actual number of fetched rows. If a warning condition occurs, this number may be less than the number of rows available or requested, and is the number of rows actually fetched before the warning condition occurred. If the consumer has insufficient permission to fetch all rows, <b>GetNextRows</b> fetches all rows for which the consumer has sufficient permission and skips all other rows. If the method fails, *<i>pcRowsObtained</i> is <br>
set to zero.</p>
<p class=dt>
<i>prghRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of handles of the fetched rows. If *<i>prghRows</i> is not a null pointer on input, it must be a pointer to memory large enough to return the handles of the requested number of rows. If *<i>prghRows</i> is a null pointer on input, the rowset allocates memory for the row handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> after it releases the row handles. If *<i>prghRows</i> is a null pointer on input and *<i>pcRowsObtained</i> is zero on output or if the method fails, the provider does not allocate any memory and ensures that *<i>prghRows</i> is a null pointer on output.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ENDOFROWSET<br>
<b>GetNextRows</b> reached the start or the end of the rowset or chapter or the start or end of the range on an index rowset and could not fetch all requested rows because the count extended beyond the end. The next fetch position is before the start or after the end of the rowset. The number of rows actually fetched is returned in <i>*pcRowsObtained</i>; this will be less than <i>cRows</i>.</p>
<p class=tl>
The rowset is being populated asynchronously and no additional rows are available at this time. To determine whether additional rows may be available, the consumer should call <b>IDBAsynchStatus::GetStatus</b> or listen for the <b>IDBAsynchNotify::OnStop</b> notification.</P><p class=tl>
<i>lRowsOffset</i> indicated a position either more than one row before the first row of the rowset or more than one row after the last row, and the provider was a version 2.0 or greater provider. <i>*pcRowsObtained</i> is set to zero and no rows are returned.</P><p class=dt>
</p>
<p class=indent>
DB_S_ROWLIMITEXCEEDED<br>
Fetching the number of rows specified in <i>cRows</i> would have exceeded the total number of active rows supported by the rowset. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. This condition can occur only when there are more rows available than can be handled by the rowset. Thus, this condition never conflicts with those described in DB_S_ENDOFROWSET and DB_S_STOPLIMITREACHED, both of which imply that no more rows were available.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_STOPLIMITREACHED<br>
Fetching rows required further execution of the command, such as when the rowset uses a server-side cursor. Execution has been stopped because a resource limit has been reached. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pcRowsObtained</i> or <i>prghRows</i> was a null pointer.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory to complete the request.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADSTARTPOSITION<br>
<i>lRowsOffset</i> indicated a position either more than one row before the first row of the rowset or more than one row after the last row, and the provider was a 1.<i>x</i> provider,</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANCELED<br>
Fetching rows was canceled during notification. No rows were fetched.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTFETCHBACKWARDS<br>
<i>cRows</i> was negative and the rowset cannot fetch backward.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTSCROLLBACKWARDS<br>
<i>lRowsOffset</i> was negative and the rowset cannot scroll backward.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of existing rows before new ones can be fetched. For more information, see DBPROP_CANHOLDROWS in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to fetch any of the rows; no rows were fetched.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>GetNextRows</b> fetches a sequence of rows. The provider maintains a <i>next fetch position</i> that is used in subsequent calls to either <b>GetNextRows</b> or <b>FindNextRow</b>. The next fetch position is changed either by calling <b>GetNextRows</b>, or by calling <b>FindNextRow</b> with a null <i>pBookmark</i> value. Calling <b>FindNextRow</b> with a non-null <i>pBookmark</i> value has no effect on the next fetch position. If the fetch direction is reversed from the previous call, then the next fetch position in the new direction is the last row that was fetched in the previous direction, otherwise the next fetch position is the row following the last row fetched by <b>GetNextRows</b>, or by <b>FindNextRow</b> with a null <i>pBookmark</i> value.</p>
<p>
For a newly created rowset, or any time the next fetch position is prior to the first row of the rowset, the next fetch position is computed as follows, where N is the number of rows in the rowset. <i>lRowsOffset</i> can be less than zero only if DBPROP_CANSCROLLBACKWARDS is VARIANT_TRUE.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=34%><b>Value of </b><i>lRowsOffset</i></td>
<td class=label width=66%><b>Next fetch position</b></td>
</tr>
<tr valign=top>
<td width=34%><i>lRowsOffset</i> &gt; 0</td>
<td width=66%>After <i>lRowsOffset</i></td>
</tr>
<tr valign=top>
<td width=34%><i>lRowsOffset</i> &lt; 0</td>
<td width=66%>After N&nbsp;–&nbsp;abs(<i>lRowsOffset</i>)</td>
</tr>
<tr valign=top>
<td width=34%><i>lRowsOffset</i> = 0</td>
<td width=66%>Before first row if <i>cRows </i>&gt; 0, after last row if <i>cRows</i> &lt; 0</td>
</tr>
</table><br>
<p>
For example:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=60%><b>GetNextRows call</b></td>
<td class=label width=14%><b>Row fetched</b></td>
<td class=label width=26%><b>New next fetch position</b></td>
</tr>
<tr valign=top>
<td width=60%><pre><code>GetNextRows(hReserved, 2, 1,</code><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;pcRowsObtained,
 &nbsp;&nbsp; prghRows);</code></pre>
</pre>
</td>
<td width=14%>3rd row</td>
<td width=26%>After 3rd row</td>
</tr>
<tr valign=top>
<td width=60%><pre><code>GetNextRows(hReserved, 2, -1,</code><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;pcRowsObtained,
 &nbsp;&nbsp; prghRows);</code></pre>
</pre>
</td>
<td width=14%>2nd row</td>
<td width=26%>After 1st row</td>
</tr>
<tr valign=top>
<td width=60%><pre><code>GetNextRows(hReserved, -2, 1,</code><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;pcRowsObtained,
 &nbsp;&nbsp; prghRows);</code></pre>
</pre>
</td>
<td width=14%>N&nbsp;–&nbsp;1st row</td>
<td width=26%>After N&nbsp;–&nbsp;1st row</td>
</tr>
<tr valign=top>
<td width=60%><pre><code>&nbsp;GetNextRows(hReserved, -2, -1,</code><pre><code>&nbsp;&nbsp;&nbsp;&nbsp;pcRowsObtained,
 &nbsp;&nbsp; prghRows);</code></pre>
</pre>
</td>
<td width=14%>N&nbsp;–&nbsp;2nd row</td>
<td width=26%>After N&nbsp;–&nbsp;3rd row</td>
</tr>
</table><br>
<p>
None of the other methods that fetch rows, except for <b>IRowsetFind::FindNextRow</b> with a null <i>pBookmark</i> value, has any effect on the next fetch position. However, <b>IRowsetIndex::Seek</b> sets the next fetch position to the row specified in the seek criteria, and <b>RestartPosition</b> resets the next fetch position to the same position as when the rowset is first created.</p>
<p>
<b>GetNextRows</b> increments the reference count of each row for which it returns a handle by 1. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned.</p>
<p>
If the provider encounters a problem fetching a row—for example, data stored in a text file contains a letter in a numeric column—<b>GetNextRows</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
<b>GetNextRows</b> must always check for the conditions that cause E_INVALIDARG, E_UNEXPECTED, DB_E_CANTFETCHBACKWARDS, DB_E_CANTSCROLLBACKWARDS, DB_E_NOTREENTRANT, and DB_E_ROWSNOTRELEASED before changing the next fetch position. If it returns any other error besides these, the next fetch position is unknown. For example, the provider might have to perform actions that change the next fetch position in order to determine that the error DB_E_BADSTARTPOSITION occurred. When the next fetch position is unknown, the consumer generally calls <b>RestartPosition</b> to return it to a known position.</p>
<p>
For information about what <b>GetNextRows</b> does when it fetches a row that it already has in its internal buffers, see "<a href="ch04pr_6pmc.htm">Uniqueness of Rows in the Rowset</a>" in Chapter 4. For information about whether <b>GetNextRows</b> can detect changes made to rows in the rowset, see "<a href="ch05pr_18oj.htm">Visibility of Changes</a>" in Chapter 5.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowloc_2oj8.htm">IRowsetLocate::GetRowsAt</a>, <a href="rowloc_3nfv.htm">IRowsetLocate::GetRowsByBookmark</a>, <a href="rowscr_8vu7.htm">IRowsetScroll::GetRowsAtRatio</a></p>
</font></BODY>
</HTML>
