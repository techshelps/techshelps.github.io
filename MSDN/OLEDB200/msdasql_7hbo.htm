<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Error Support</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcprovidererrorsupport"></a><sup></sup>Error Support</h1>
<p>
A feature introduced in ODBC 3.0 is that of diagnostic fields. Following is information on how to use the ODBC Provider to access error information from those diagnostic fields.</p>
<p>
To retrieve diagnostic information, the consumer registers the diagnostic fields of interest beforehand. The ODBC Provider includes a new interface, <b>ISQLRequestDiagFields</b>, to facilitate this process. </p>
<p>
When an OLE DB consumer needs to retrieve certain diagnostic fields after a method call, it first calls <b>ISQLRequestDiagFields::RequestDiagFields</b> on the OLE DB object before calling the method to notify the ODBC Provider that it may request the diagnostic information. The ODBC Provider then caches those diagnostic fields. If the consumer does not call <b>ISQLRequestDiagFields::RequestDiagFields</b>, the ODBC Provider does not cache any extra diagnostic data except the information needed in the existing OLE DB error model.</p>
<p>
<b>ISQLRequestDiagFields</b> (defined in the header file Msdasql.h) is an optional interface of any OLE DB object implemented in the ODBC Provider. Any object that supports diagnostic fields exposes this interface. It has one method, <b>RequestDiagFields</b>. Here is its calling convention:</p>
<pre><code>enum KAGREQDIAGFLAGSENUM
 {   KAGREQDIAGFLAGS_HEADER&nbsp; = 0x1,
    KAGREQDIAGFLAGS_RECORD&nbsp; = 0x2
  };

typedef struct&nbsp; tagKAGREQDIAG
{
 ULONG ulDiagFlags;
 VARTYPE vt;
 SHORT sDiagField;
} KAGREQDIAG;

ISQLRequestDiagFields : public IUnknown
{
public:
  virtual HRESULT STDMETHODCALLTYPE RequestDiagFields(
  ULONG cDiagFields,
  KAGREQDIAG rgDiagFields[&nbsp; ]) = 0;

};</code></pre>
<p>
<b>cDiagFields</b> is the number of diagnostic fields to be requested; <b>rgDiagFields</b> is an array of KAGREQDIAG. KAGREQDIAG describes the diagnostic identifier, type, and flags of a diagnostic field. <b>ulDiagFlags</b> can be KAGREQDIAGFLAGS_HEADER or KAGREQDIAGFLAGS_RECORD. They tell whether the diagnostic field is a header field or record field. vt is data type of the diagnostic information and it must be VT_I2, VT_UI2, VT_I4, VT_UI4, VT_BSTR, or VT_UI1 | VT_ARRAY depending on the type of diagnostic field. For example, if the diagnostic field type is SQLINTEGER in ODBC, it must be VT_I4; if the type is string in ODBC, it must be VT_BSTR here. Otherwise, the result is undefined. This function clears the previous request of the diagnostic fields in the object. Setting <b>cDiagFields</b> to 0 means that no diagnostic fields should be cached by the provider on this object.</p>
<p>
Although the ODBC Provider will support diagnostic fields for both 2.X and 3.X ODBC drivers, it should be noted that the functionality is limited for ODBC 2.X drivers because no 2.X driver supports diagnostics.</p>
<p>
The diagnostic information is retrieved through <b>IGetDiagField::GetDiagField</b>. <b>IGetDiagField</b> is a new optional interface of <b>TCustomErrorObject</b>. </p>
<pre><code>typedef struct&nbsp; tagKAGGETDIAG
{
  ULONG ulSize;
  VARIANTARG vDiagInfo;
  SHORT sDiagField;
} KAGGETDIAG;

ISQLGetDiagField : public IUnknown
{
public:
 virtual HRESULT STDMETHODCALLTYPE GetDiagField(
 &nbsp;&nbsp;&nbsp; KAGGETDIAG *pDiagInfo) = 0;
};</code></pre>
<p>
<b>pDiagInfo</b> is an input/output argument.</p>
<p>
On input, <b>pDiagInfo-&gt;ulSize</b> should be set the size of KAGGETDIAG; <b>pDiagInfo-&gt;vDiagInfo</b> should be initialized with <b>VariantInit</b>; and <b>pDiagInfo-&gt;sDiagField</b> is the diagnostic field identifier.</p>
<p>
At return, <b>pDiagInfo-&gt;vDiagInfo</b> has the data for the diagnostic information. <b>vDiagInfo.vt</b> can be any of the values listed for argument vt in <b>ISQLRequestDiagFields::RequestDiagFields</b>.</p>
<p>
If the diagnostic data is a string or binary, the data is stored as BSTR or VT_UI1 | VT_ARRAY. When the diagnostic information is no longer needed, <b>pDiagInfo-&gt;vDiagInfo</b> should be freed with <b>VariantClear</b> by the consumer.</p>
</font></BODY>
</HTML>
