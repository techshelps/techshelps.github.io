<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICommandWithParameters:: GetParameterInfo</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbicommandwithparameters__getparameterinfo"></a>ICommandWithParameters:: GetParameterInfo</h1>
<p>
Gets a list of the command’s parameters, their names, and their types. </p>
<pre><code>HRESULT GetParameterInfo (
   ULONG *               pcParams,
   DBPARAMINFO **   prgParamInfo,
   OLECHAR **         ppNamesBuffer);
</code></pre>
<p>
<b>Parameters</b></p>
<p class=dt>
<i>pcParams</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of parameters in the command. If an error occurs, *<i>pcParams</i> is set to zero.</p>
<p class=dt>
<i>prgParamInfo</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of parameter information structures. The command allocates memory for the array, as well as the strings, and returns the address to this memory. The consumer releases the array memory with <b>IMalloc::Free</b> when it no longer needs the parameter information. If *<i>pcParams</i> is zero on output or an error occurs, the provider does not allocate any memory and ensures that *<i>prgParamInfo</i> is a null pointer on output. Parameters are returned in ascending order according to the <i>iOrdinal</i> element of the PARAMINFO structure.</p>
<p class=tl>
Here is the DBPARAMINFO structure: </P><pre><code>typedef struct tagDBPARAMINFO {
 DBPARAMFLAGS dwFlags;
 ULONG&nbsp;&nbsp;&nbsp; iOrdinal;
 LPOLESTR&nbsp;&nbsp; pwszName;
 ITypeInfo *&nbsp; pTypeInfo;
 ULONG&nbsp;&nbsp;&nbsp; ulParamSize;
 DBTYPE&nbsp;&nbsp; wType;
 BYTE&nbsp;&nbsp;&nbsp;&nbsp; bPrecision;
 BYTE&nbsp;&nbsp;&nbsp;&nbsp; bScale;
} DBPARAMINFO;
</code></pre>
<p class=tl>
The elements of this structure are used as follows.</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=18%><b>Element</b></td>
<td class=label width=82%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=18%><i>dwFlags</i></td>
<td width=82%>A bitmask describing parameter characteristics; these values have the following meaning:<ul type=disc>
<li>
DBPARAMFLAGS_ISINPUT—Whether a parameter accepts values on input. Not set if this is unknown.<br><br></li>
<li>
DBPARAMFLAGS_ISOUTPUT—Whether a parameter returns values on output. Not set if this is unknown. Providers support only those parameter types that make sense for their data source.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=18%><i>dwFlags<br>
</i>(<i>continued</i>)</td>
<td width=82%><ul type=disc>
<li>
DBPARAMFLAGS_ISSIGNED—Whether a parameter is signed. This is ignored if the type is inherently signed, such as DBTYPE_I2, or if the sign does not apply to the type, such as DBTYPE_BSTR. It is generally used in <b>SetParameterInfo</b> so the consumer can tell the provider if a provider-specific type name refers to a signed or unsigned type.<br><br></li>
<li>
DBPARAMFLAGS_ISNULLABLE—Whether a parameter accepts NULLs. If nullability is unknown, this flag is set.<br><br></li>
<li>
DBPARAMFLAGS_ISLONG—Whether a parameter contains a BLOB that contains very long data. The definition of very long data is provider specific. The flag setting corresponds to the value of the IS_LONG column in the PROVIDER_TYPES schema rowset for the data type.<p class=tl>
When this flag is set, the BLOB is best manipulated through one of the storage interfaces. Although such BLOBs can be sent in a single piece with <b>ICommand::Execute</b>, there may be provider-specific problems in doing so. For example, the BLOB might be truncated due to machine limits on memory. Furthermore, when this flag is set, the provider might not be able to accurately return the maximum length of the BLOB data in <i>ulParamSize</i> in <b>GetParameterInfo</b>.</P><p class=tl>
When this flag is not set, the BLOB can be accessed either through <b>ICommand::Execute</b> or through a storage interface.</P><p class=tl>
For more information, see ""<a href="ch07pr_47dt.htm">Accessing BLOB Data</a>"" in Chapter 7.</P></li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=18%><i>iOrdinal</i></td>
<td width=82%>The ordinal of the parameter. Parameters are numbered from left to right as they appear in the command, with the first parameter in the command having an <i>iOrdinal</i> value of 1.</td>
</tr>
<tr valign=top>
<td width=18%><i>pwszName</i></td>
<td width=82%>The name of the parameter; it is a null pointer if there is no name. Names are normal names. The colon prefix (where used within SQL text) is stripped.</td>
</tr>
<tr valign=top>
<td width=18%><i>pTypeInfo</i></td>
<td width=82%><b>ITypeInfo</b> describes the type, if <i>pTypeInfo</i> is not a null pointer.</td>
</tr>
<tr valign=top>
<td width=18%><i>ulParamSize</i></td>
<td width=82%>The maximum possible length of a value in the parameter. For parameters that use a fixed-length data type, this is the size of the data type. For parameters that use a variable-length data type, this is one of the following:<ul type=disc>
<li>
The maximum length of the parameters in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if one is defined. For example, a parameter for a CHAR(5) column in an SQL table has a maximum length of 5.<br><br></li>
<li>
The maximum length of the data type in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if the parameter does not have a defined length.<br><br></li>
<li>
~0 (bitwise, the value is not 0; that is, all bits are set to 1) if neither the parameter nor the data type has a defined maximum length.</li>
</ul>
<p>
For data types that do not have a length, this is set to ~0 (bitwise, the value is not 0; that is, all bits are set to 1).</p>
</td>
</tr>
<tr valign=top>
<td width=18%><i>wType</i></td>
<td width=82%>The indicator of the parameter’s data type.</td>
</tr>
<tr valign=top>
<td width=18%><i>bPrecision</i></td>
<td width=82%>If <i>wType</i> is a numeric type, <i>bPrecision</i> is the maximum number of digits, expressed in base 10. Otherwise, this is ~0 (bitwise, the value is not 0; that is, all bits are set to 1).</td>
</tr>
<tr valign=top>
<td width=18%><i>bScale</i></td>
<td width=82%>If <i>wType</i> is a numeric type with a fixed scale, <i>bScale</i> is the number of digits to the right, if <i>bScale</i> is positive, or left, if <i>bScale</i> is negative, of the decimal point. Otherwise, this is ~0 (bitwise, the value is not 0; that is, all bits are set to 1).</td>
</tr>
</table><br>
<p class=dt>
<i>ppNamesBuffer</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to store all string values (names used within the *<i>pwszName</i> element of the DBPARAMINFO<b> </b>structures) with a single, globally allocated buffer. Specifying a null pointer for <i>ppNamesBuffer</i> suspends the return of parameter names. The command allocates memory for the buffer and returns the address to this memory. The consumer releases the memory with <b>IMalloc::Free</b> when it no longer needs the parameter information. If *<i>pcParams</i> is zero on output or an error occurs, the provider does not allocate any memory and ensures that *<i>ppNamesBuffer</i> is a null pointer on output.</p>
<p class=tl>
Each of the individual string values stored in this buffer is terminated by a null termination character. Therefore, the buffer may contain one or more strings, each with its own null termination character, and may contain embedded null termination characters.</P><p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pcParams</i> or <i>prgParamInfo</i> was a null pointer.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return the parameter data array or parameter names.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOCOMMAND<br>
The provider can derive parameter information, but it does not support command preparation. However, no command text was currently set on the Command object and no parameter information had been specified with <b>SetParameterInfo</b>.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTPREPARED<br>
The provider can derive parameter information, and it supports command preparation. However, the command was in an unprepared state and no parameter information was specified with <b>SetParameterInfo</b>.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_PARAMUNAVAILABLE<br>
The provider cannot derive parameter information from the command and <b>SetParameterInfo</b> has not been called.</p>
<p class=label>
<b>Comments</b></p>
<p>
This method makes no logical change to the state of the object.</p>
<p>
If <b>SetParameterInfo</b> has not been called for any parameters or <b>SetParameterInfo</b> has been called with <i>cParams</i> equal to zero, <b>GetParameterInfo</b> returns information about the parameters only if the provider can derive parameter information. If the provider cannot derive parameter information, <b>GetParameterInfo</b> returns DB_E_PARAMUNAVAILABLE.</p>
<p>
If <b>SetParameterInfo</b> has been called for at least one parameter, <b>GetParameterInfo</b> returns the parameter information only for those parameters for which <b>SetParameterInfo</b> has been called. It does this even if the provider can derive information about the parameters for which <b>SetParameterInfo</b> was not called. The provider does not return a warning in this case because it often cannot determine the number of parameters and therefore cannot determine whether it has returned information for all parameters.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="cmdprm_5l4j.htm">ICommandWithParameters::MapParameterNames</a>, <a href="cmdprm_7fjj.htm">ICommandWithParameters::SetParameterInfo</a></p>
</font></BODY>
</HTML>
