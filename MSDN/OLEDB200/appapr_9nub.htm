<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Type Indicators</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbtype_indicators"></a>Type Indicators</h1>
<p>
A type indicator indicates a data type. For more information, see Chapter 10, "<a href="ch10pr_84te.htm">Data Types in OLE DB</a>."</p>
<pre><code>typedef WORD DBTYPE;

enum DBTYPEENUM {
 // The following values exactly match VARENUM 
 // in Automation and may be used in VARIANT
 DBTYPE_EMPTY = 0,
 DBTYPE_NULL,
 DBTYPE_I2,
 DBTYPE_I4,
 DBTYPE_R4,
 DBTYPE_R8,
 DBTYPE_CY,
 DBTYPE_DATE,
 DBTYPE_BSTR,
 DBTYPE_IDISPATCH,
 DBTYPE_ERROR,
 DBTYPE_BOOL,
 DBTYPE_VARIANT,
 DBTYPE_IUNKNOWN,
 DBTYPE_DECIMAL,
 DBTYPE_UI1 = 17,
 DBTYPE_ARRAY = 0x2000,
 DBTYPE_BYREF = 0x4000,

 // The following values exactly match VARENUM 
 // in Automation but cannot be used in VARIANT
 DBTYPE_I1 = 16,
 DBTYPE_UI2 = 18,
 DBTYPE_UI4,
 DBTYPE_I8,
 DBTYPE_UI8,
 DBTYPE_GUID = 72,
 DBTYPE_VECTOR = 0x1000,
 DBTYPE_FILETIME = 64,
 DBTYPE_RESERVED = 0x8000,

 // The following values are not in VARENUM in OLE
 DBTYPE_BYTES = 128,
 DBTYPE_STR = 129,
 DBTYPE_WSTR,
 DBTYPE_NUMERIC,
 DBTYPE_UDT,
 DBTYPE_DBDATE,
 DBTYPE_DBTIME,
 DBTYPE_DBTIMESTAMP,
DBTYPE_HCHAPTER = 136,
DBTYPE_PROPVARIANT = 138,
DBTYPE_VARNUMERIC = 139
};
</code></pre>
<p>
The following table describes each type indicator, including the C data type it corresponds to.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=26%><b>Type indicator</b></td>
<td class=label width=74%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_EMPTY</td>
<td width=74%>No value was specified. This indicator is valid only in a VARIANT structure and exists only to match the VT_EMPTY value in the VARENUM enumerated type in OLE. It does not correspond to any C data type.</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_NULL</td>
<td width=74%>A NULL value. This indicator is valid only in a VARIANT structure and exists only to match the VT_NULL value in the VARENUM enumerated type in OLE. It does not correspond to any C data type.</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
RESERVED</td>
<td width=74%>Reserved for future use by OLE. This indicator does not correspond to any C data type.</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_I1</td>
<td width=74%>A one-byte, signed integer:<pre><code>signed char</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_I2</td>
<td width=74%>A two-byte, signed integer:<pre><code>SHORT</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_I4</td>
<td width=74%>A four-byte, signed integer:<pre><code>LONG</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_I8</td>
<td width=74%>An eight-byte, signed integer:<pre><code>LARGE_INTEGER</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_UI1</td>
<td width=74%>A one-byte, unsigned integer:<pre><code>BYTE</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_UI2</td>
<td width=74%>A two-byte, unsigned integer:<pre><code>unsigned short</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_UI4</td>
<td width=74%>A four-byte, unsigned integer:<pre><code>unsigned int</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_UI8</td>
<td width=74%>An eight-byte, unsigned integer:<pre><code>ULARGE_INTEGER</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_R4</td>
<td width=74%>A single-precision floating point value:<pre><code>float</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_R8</td>
<td width=74%>A double-precision floating point value:<pre><code>double</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_CY</td>
<td width=74%>A currency value:<pre><code>LARGE_INTEGER</code></pre>
<p>
Currency is a fixed-point number with four digits to the right of the decimal point. It is stored in an eight-byte signed integer, scaled by 10,000.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
DECIMAL</td>
<td width=74%>An exact numeric value with a fixed precision and fixed scale, stored in the same way as in Automation:<pre><code>typedef struct tagDEC {
 USHORT wReserved;
 union {
  struct {
 &nbsp; BYTE scale;
 &nbsp; BYTE sign;
  };
  USHORT signscale;
 };
 ULONG Hi32;
 union {
  struct {
 &nbsp; ULONG Lo32;
 &nbsp; ULONG Mid32;
  };
  ULONGLONG Lo64;
 };
} DBTYPE_DECIMAL;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=74%>The elements of this structure are used as follows:<ul type=disc>
<li>
<i>wReserved</i>—Reserved. Should be 0.<br><br></li>
<li>
<i>scale</i>—The scale specifies the number of digits to the right of the decimal point and ranges from 0 to 28.<br><br></li>
<li>
<i>sign</i>—The sign: 0 if positive, 0x80 if negative.<br><br></li>
<li>
<i>Hi32</i>—The high part of the integer (32-bit aligned).<br><br></li>
<li>
<i>Mid32</i>—The middle part of the integer (32-bit aligned).<br><br></li>
<li>
<i>Lo32</i>—The low part of the integer (32-bit aligned).</li>
</ul>
<p>
For example, to specify the number 12.345, the scale is 3, the sign is 0, and the number stored in the 12-byte integer is 12345.</p>
<p>
For information about what precision and scale the provider uses when accessing DBTYPE_DECIMAL structures, see "<a href="appapr_0y7g.htm">Conversions Involving DBTYPE_NUMERIC or DBTYPE_DECIMAL</a>" later in this appendix.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
NUMERIC</td>
<td width=74%>An exact numeric value with a fixed precision and scale:<pre><code>typedef struct tagDB_NUMERIC {
 BYTE precision;
 BYTE scale;
 BYTE sign;
 BYTE val[16];
} DBTYPE_NUMERIC;
</code></pre>
<p>
The elements of this structure are used as follows:
<ul type=disc>
<li>
<i>precision</i>—The maximum number of digits in base 10.<br><br></li>
<li>
<i>scale</i>—The number of digits to the right of the decimal point.<br><br></li>
<li>
<i>sign</i>—The sign: 1 for positive numbers, 0 for negative numbers.<br><br></li>
<li>
<i>val</i>—A number stored as a 16-byte scaled integer, with the least-significant byte on the left.</li>
</ul>
<p>
For example, to specify the base 10 number 20.003 with a scale of 4, the number is scaled to an integer of 200030 (20.003 shifted by four tens digits), which is 30D5E in hexadecimal. The value stored in the 16-byte integer is 5E 0D 03 00 00 00 00 00 00 00 00 00 00 00 00 00, the precision is the maximum precision, the scale is 4, and the sign is 1.</p>
<p>
For information about what precision and scale the provider uses when accessing DBTYPE_NUMERIC structures, see "<a href="appapr_0y7g.htm">Conversions Involving DBTYPE_NUMERIC or DBTYPE_DECIMAL</a>" later in this appendix.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_DATE</td>
<td width=74%>A date stored in the same way as in Automation:<pre><code>DATE
</code></pre>
<p>
A DATE is a double, the whole part of which is the number of days since December 30, 1899, and the fractional part of which is the fraction of a day. For example, the number 2.25 represents the datetime January 1, 1900 6:00 AM.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_BOOL</td>
<td width=74%>A Boolean value stored in the same way as in Automation:<pre><code>VARIANT_BOOL
</code></pre>
<p>
0 means false and ~0 (bitwise, the value is not 0; that is, all bits are set to 1) means true.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_BYTES</td>
<td width=74%>A binary data value. That is, an array of bytes:<pre><code>BYTE[<i>length</i>]
</code></pre>
<p>
The length of the array is specified by <i>cbMaxLen</i> in the DBBINDING structure if DBTYPE_BYTES is used by itself. It is specified by the bound length value if DBTYPE_BYTES is combined with DBTYPE_BYREF.</p>
<p>
For columns containing binary data, the provider reports the data type as DBTYPE_BYTES and the maximum length as the true maximum length of the binary data (assuming there is one). For small, fixed-length binary data, such as a column in an SQL database of type BINARY(1000), the consumer generally binds the column as DBTYPE_BYTES. For small, variable-length binary data, such as a column in an SQL database of type VARBINARY(1000), the consumer generally binds the column as DBTYPE_BYTES | DBTYPE_BYREF, so no space is wasted and no data is truncated. For long binary data, the consumer generally binds the column as DBTYPE_IUNKNOWN and uses a storage interface such as <b>ISequentialStream</b> to manipulate the data. For more information, see "<a href="ch07pr_47dt.htm">Accessing BLOB Data</a>" in Chapter 7.</p>
<p>
When null-terminated string data is converted to or from DBTYPE_BYTES, the null termination character is not included in the length count or the data transferred.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_BSTR</td>
<td width=74%>A pointer to a BSTR, as in Automation:<pre><code>typedef WCHAR * BSTR;
</code></pre>
<p>
A BSTR is a pointer to a null-terminated character string in which the string length is stored with the string. Because the length is stored with the string, BSTR variables can contain embedded null characters. To determine the length of the BSTR in characters, call <b>SysStringLen</b>. To determine the length of the BSTR in bytes, call <b>SysStringByteLen</b>. In both cases, the length does not include the null termination character.</p>
<p>
In Win32 (the environment for OLE DB) a BSTR contains Unicode.</p>
<p>
Consumers are responsible for freeing the memory used by BSTRs. Failure to free such memory is a common cause of memory leaks. For example, if a consumer calls <b>IRowset::GetData</b> to retrieve a BSTR, the provider allocates memory for the BSTR and returns a pointer to it in the memory pointed to by <i>pData</i>. A memory leak occurs when the consumer calls <b>GetData</b> again with the same value of <i>pData</i> without first freeing the memory for the BSTR. In this case, the provider allocates new memory for the BSTR and overwrites the pointer to the old BSTR with the pointer to the new BSTR. The old BSTR is still allocated, but the pointer to it is lost. For more information, see "<a href="ch06pr_7bp0.htm">Memory Management</a>" in Chapter 6 and the <i>OLE Programmer's Reference, Volume 2</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_STR</td>
<td width=74%>A null-terminated ANSI character string:<pre><code>char[<i>length</i>]
</code></pre>
<p>
If DBTYPE_STR is used by itself, the number of bytes allocated for the string, including the null termination character, is specified by <i>cbMaxLen</i> in the DBBINDING structure. If DBTYPE_STR is combined with DBTYPE_BYREF, the number of bytes allocated for the string, including the null termination character, is at least the length of the string plus one. In either case, the actual length of the string is determined from the bound length value.</p>
<p>
If a locale is applicable, it is indicated first by the column metadata, or if none is available then by table metadata, or if none is available then by the database locale.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_WSTR</td>
<td width=74%>A null-terminated Unicode character string:<pre><code>wchar_t[<i>length</i>]
</code></pre>
<p>
If DBTYPE_WSTR is used by itself, the number of bytes allocated for the string, including the null termination character, is specified by <i>cbMaxLen</i> in the DBBINDING structure. If DBTYPE_WSTR is combined with DBTYPE_BYREF, the number of bytes allocated for the string, including the null termination character, is at least the length of the string plus two. In either case, the actual length of the string is determined from the bound length value. Note that the maximum length of the string is the number of allocated bytes divided by <b>sizeof(wchar_t)</b> and truncated to the nearest integer.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
VARIANT</td>
<td width=74%>An Automation VARIANT:<pre><code>VARIANT
</code></pre>
<p>
The DBTYPE values that do not match Automation VARENUM values represent data types that cannot be stored in a VARIANT. If the VARIANT structure contains a pointer to the data, then the buffer for that data is allocated separately.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
IDISPATCH</td>
<td width=74%>A pointer to an <b>IDispatch</b> interface on an OLE object:<pre><code>IDispatch *
</code></pre>
<p>
For more information, see the <i>OLE Programmer's Reference, Volume 2</i>.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
IUNKNOWN</td>
<td width=74%>A pointer to an <b>IUnknown</b> interface on an OLE object:<pre><code>IUnknown *
</code></pre>
<p>
For columns containing OLE objects, the provider reports the data type as DBTYPE_IUNKNOWN. The consumer specifies the interface to use through the <i>pObject</i> element of the DBBINDING structure. For more information, see "<a href="ch07pr_6e0j.htm">IPersist* Objects</a>" in Chapter 7.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_GUID</td>
<td width=74%>A globally unique identifier (GUID):<pre><code>GUID
</code></pre>
<p>
GUIDs are also known as universally unique identifiers (UUIDs) and are used as class identifiers (CLSIDs) and interface identifiers (IIDs). For more information, see the OLE documentation.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_ERROR</td>
<td width=74%>A 32-bit error code:<pre><code>SCODE
</code></pre>
<p>
For more information, see the OLE documentation.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_BYREF</td>
<td width=74%>A pointer to data:<pre><code>void *
</code></pre>
<p>
DBTYPE_BYREF must be combined with another type indicator. This indicates that the data in the consumer's buffer is a pointer to the other type. For example, DBTYPE_STR | DBTYPE_BYREF means that the data is a pointer to an ANSI string and DBTYPE_I2 | DBTYPE_BYREF means that the data is a pointer to a two-byte integer. DBTYPE_BYREF is commonly used to return pointers to variable-length data. It is used with provider-owned <i>bindings </i>to return pointers to the data in the rowset's copy of a row.</p>
<p>
When DBTYPE_BYREF is used, the data in the consumer's buffer can be a null pointer only when the corresponding status value is DBSTATUS_S_ISNULL. When setting a column value, if the data in the consumer's buffer is a null pointer and the status is not DBSTATUS_S_ISNULL, the provider returns a conversion error.</p>
<p>
DBTYPE_BYREF is mutually exclusive with the DBTYPE_ARRAY and DBTYPE_VECTOR modifiers and cannot be combined with the following values:</p>
<p>
DBTYPE_EMPTY<br>
DBTYPE_NULL<br>
DBTYPE_RESERVED</p>
<p>
For information about how DBTYPE_BYREF values are allocated, see "<a href="ch06pr_7bp0.htm">Memory Management</a>" in Chapter 6.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_ARRAY</td>
<td width=74%>A pointer to a SAFEARRAY:<pre><code>SAFEARRAY *
</code></pre>
<p>
DBTYPE_ARRAY must be combined with another type indicator. This indicates that the data in the consumer's buffer is a pointer to a SAFEARRAY of the other type. For example, DBTYPE_I2 | DBTYPE_ARRAY means that the data is a pointer to a SAFEARRAY of two-byte integers.</p>
<p>
When DBTYPE_ARRAY is used, the data in the consumer's buffer can be a null pointer only when the corresponding status value is DBSTATUS_S_ISNULL. When setting a column value, if the data in the consumer's buffer is a null pointer and the status is not DBSTATUS_S_ISNULL, the provider returns a conversion error.</p>
<p>
DBTYPE_ARRAY is mutually exclusive with the DBTYPE_BYREF and DBTYPE_VECTOR modifiers and cannot be combined with indicators for variable-length data types because there is no way to determine the length of each element of the array. DBTYPE_ARRAY can be combined with DBTYPE_BSTR because DBTYPE_BSTR is a fixed-length data type: A BSTR is a pointer to a separately allocated string that contains its own length.</p>
<p>
For information about how SAFEARRAYs are allocated, see "<a href="ch06pr_7bp0.htm">Memory Management</a>" in Chapter 6. For more information about SAFEARRAYs, see the OLE documentation.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
VECTOR</td>
<td width=74%>A DBVECTOR structure:<pre><code>typedef struct tagDBVECTOR {
 void * ptr;
 ULONG&nbsp; size;
} DBVECTOR;
</code></pre>
<p>
DBTYPE_VECTOR must be combined with another type indicator. This indicates that the data in the consumer's buffer is a DBVECTOR structure, which contains a pointer to an array of the other type. For example, DBTYPE_I2 | DBTYPE_VECTOR means that the data is a DBVECTOR structure that contains a pointer to an array of two-byte integers.</p>
<p>
When DBTYPE_VECTOR is used, the pointer in the DBVECTOR structure can be a null pointer only when the corresponding status value is DBSTATUS_S_ISNULL. When setting a column value, if the pointer is a null pointer and the status is not DBSTATUS_S_ISNULL, the provider returns a conversion error.</p>
<p>
DBTYPE_VECTOR is mutually exclusive with the DBTYPE_BYREF and DBTYPE_ARRAY modifiers and cannot be combined with indicators for variable-length data types because there is no way to determine the length of each element of the array.</p>
<p>
For information about how the memory pointed to by DBVECTOR structures is allocated, see "<a href="ch06pr_7bp0.htm">Memory Management</a>" in Chapter 6.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_UDT</td>
<td width=74%>A user-defined data type of variable length. In future versions, OLE DB may define the use of type libraries to support user-defined data types. This indicator does not correspond to any C data type.</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
DBDATE</td>
<td width=74%>A date structure:<pre><code>typedef struct tagDBDATE {
 SHORT&nbsp; year;
 USHORT month;
 USHORT day;
} DBDATE;
</code></pre>
<p>
The elements of this structure are used as follows:
<ul type=disc>
<li>
<i>year</i>—The year: 0-9999 measured from 0 A.D.<br><br></li>
<li>
<i>month</i>—The month: 1 – 12.<br><br></li>
<li>
<i>day</i>—1 – <i>n</i> where <i>n</i> is the number of days in the month.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
DBTIME</td>
<td width=74%>A time structure:<pre><code>typedef struct tagDBTIME {
 USHORT hour;
 USHORT minute;
 USHORT second;
} DBTIME;
</code></pre>
<p>
The elements of this structure are used as follows:
<ul type=disc>
<li>
<i>hour</i>—The hour: 0–23.<br><br></li>
<li>
<i>minute</i>—The minute: 0–59.<br><br></li>
<li>
<i>second</i>—The second: 0–61.</li>
</ul>
<p>
The range of seconds allows as many as two leap seconds to maintain synchronization with sidereal time.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_<br>
DBTIMESTAMP</td>
<td width=74%>A timestamp structure:<pre><code>typedef struct tagDBTIMESTAMP {
 SHORT&nbsp; year;
 USHORT month;
 USHORT day;
 USHORT hour;
 USHORT minute;
 USHORT second;
 ULONG&nbsp; fraction;
} DBTIMESTAMP;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=74%>The elements of this structure are used as follows:<ul type=disc>
<li>
<i>year</i>—The year: 0-9999 measured from 0 A.D.<br><br></li>
<li>
<i>month</i>—The month: 1–12.<br><br></li>
<li>
<i>day</i>—1 – <i>n</i> where <i>n</i> is the number of days in the month.<br><br></li>
<li>
<i>hour</i>—The hour: 0–23.<br><br></li>
<li>
<i>minute</i>—The minute: 0–59.<br><br></li>
<li>
<i>second</i>—The second: 0–61.<br><br></li>
<li>
<i>fraction</i>—Billionths of a second: 0–999,999,999.</li>
</ul>
<p>
The range of seconds allows as many as two leap seconds to maintain synchronization with sidereal time.</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_FILETIME</td>
<td width=74%>A 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. This type is equivalent to the FILETIME type used in the time-conversion functions between DOS and Win32.<pre><code>typedef struct tagFILETIME {
 DWORD&nbsp; dwLowDateTime;
 DWORD&nbsp; dwHighDateTime;
} FILETIME;
</code></pre>
<p>
The elements of the structure are used as follows:
<ul type=disc>
<li>
<i>dwLowDateTime</i>—The lower 32 bits of the Win32 date/time value. <br><br></li>
<li>
<i>dwHighDateTime</i>—The upper 32 bits of the Win32 date/time value.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_PROPVARIANT</td>
<td width=74%>An Automation PROPVARIANT:<pre><code>PROPVARIANT
</code></pre>
<p>
If the VARIANT structure contains a pointer to the data, then the buffer for the data is allocated separately.</p>
<p>
DBTYPE_PROPVARIANT should support the same set of conversions as DBTYPE_VARIANT (including conversions to/from DBTYPE_VARIANT).</p>
</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_HCHAPTER</td>
<td width=74%>A 4-byte chapter value that can be used to identify rows in a child rowset.</td>
</tr>
<tr valign=top>
<td width=26%>DBTYPE_VARNUMERIC</td>
<td width=74%>A variable-length, exact numeric value with a signed scale value:<pre><code>typedef struct&nbsp; tagDB_VARNUMERIC {
 BYTE    precision;
 SBYTE    scale;
 BYTE    sign;
 BYTE    val[ 1 ];
} DB_VARNUMERIC;</code></pre>
</td>
</tr>
</table><br>
</font></BODY>
</HTML>
