<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sessions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="sessions"></a>Sessions</h1>
<p>
A SQLOLEDB session represents a single connection to a SQL Server.</p>
<p>
OLE DB requires that sessions delimit transaction space for a data source. All command objects created from a specific session object will participate in the local or distributed transaction of the session object.</p>
<p>
The first session object created on the initialized data source receives the SQL Server connection established at initialization. When all references on the interfaces of the session object are released, the SQL Server connection becomes available to another session object created on the data source.</p>
<p>
An additional session object created on the data source establishes its own connection to the SQL Server as specified by the data source. The SQL Server connection is dropped when the application releases all references to objects created that session.</p>
<h3>Example</h3>
<p>
This example shows SQLOLEDB SQL Server connection usage.</p>
<pre><code>int main()
{
  // Interfaces used in the example.
  IDBInitialize*&nbsp; pIDBInitialize&nbsp; = NULL;
  IDBCreateSession* pIDBCreateSession = NULL;
  IDBCreateCommand* pICreateCmd1&nbsp;&nbsp;&nbsp; = NULL;
  IDBCreateCommand* pICreateCmd2&nbsp;&nbsp;&nbsp; = NULL;
  IDBCreateCommand* pICreateCmd3&nbsp;&nbsp;&nbsp; = NULL;
<b><i>  </i></b>
  // Initialize COM.
  if (FAILED(CoInitialize(NULL)))
  {
 &nbsp;&nbsp; // Display error from CoInitialize.
 &nbsp;&nbsp; return (-1);
  }
<b><i>  </i></b>
  // Get the memory allocator for this task.
  if (FAILED(CoGetMalloc(MEMCTX_TASK, &amp;g_pIMalloc)))
  {
 &nbsp;&nbsp; // Display error from CoGetMalloc.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // Create an instance of the data source object.
  if (FAILED(CoCreateInstance(CLSID_SQLOLEDB, NULL,
 &nbsp;&nbsp; CLSCTX_INPROC_SERVER, IID_IDBInitialize, (void**)
 &nbsp;&nbsp; &amp;pIDBInitialize)))
  {
 &nbsp;&nbsp; // Display error from CoCreateInstance.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // The InitFromPersistedDS function 
  // performs IDBInitialize-&gt;Initialize() establishing
  // the first application connection to the SQL Server.
  if (FAILED(InitFromPersistedDS(pIDBInitialize, L"MyDataSource",
 &nbsp;&nbsp; NULL, NULL)))
  {
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // The IDBCreateSession interface is implemented on the data source
  // object. Maintaining the reference we receive maintains the 
  // connection of the data source to the SQL Server.
  if (FAILED(pIDBInitialize-&gt;QueryInterface(IID_IDBCreateSession,
 &nbsp;&nbsp; (void**) &amp;pIDBCreateSession)))
  {
 &nbsp;&nbsp; // Display error from pIDBInitialize.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // Releasing this has no affect on the SQL Server connection
  // of the data source object because of the reference maintained by
  // pIDBCreateSession.
  pIDBInitialize-&gt;Release();
  pIDBInitialize = NULL;
<b><i>  </i></b>
  // The session created next receives the SQL Server connection of
  // the data source object. No new connection is established.
  if (FAILED(pIDBCreateSession-&gt;CreateSession(NULL,
 &nbsp;&nbsp; IID_IDBCreateCommand, (IUnknown**) &amp;pICreateCmd1)))
  {
 &nbsp;&nbsp; // Display error from pIDBCreateSession.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // A new connection to the SQL Server is established to support the
  // next session object created. On successful completion, the
  // application has two active connections on the SQL Server.
  if (FAILED(pIDBCreateSession-&gt;CreateSession(NULL,
 &nbsp;&nbsp; IID_IDBCreateCommand, (IUnknown**) &amp;pICreateCmd2)))
  {
 &nbsp;&nbsp; // Display error from pIDBCreateSession.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
  // pICreateCmd1 has the data source connection. Because the
  // reference on the IDBCreateSession interface of the data source
  // has not been released, releasing the reference on the session
  // object does not terminate a connection to the SQL Server.
  // However, the connection of the data source object is now 
  // available to another session object. After a successful call to 
  // Release, the application still has two active connections to the 
  // SQL Server.
  pICreateCmd1-&gt;Release();
  pICreateCmd1 = NULL;
<b><i>  </i></b>
  // The next session created gets the SQL Server connection
  // of the data source object. The application has two active
  // connections to the SQL Server.
  if (FAILED(pIDBCreateSession-&gt;CreateSession(NULL,
 &nbsp;&nbsp; IID_IDBCreateCommand, (IUnknown**) &amp;pICreateCmd3)))
  {
 &nbsp;&nbsp; // Display error from pIDBCreateSession.
 &nbsp;&nbsp; goto EXIT;
  }
<b><i>  </i></b>
EXIT:
  // Even on error, this does not terminate a SQL Server connection 
  // because pICreateCmd1 has the connection of the data source 
  // object.
  if (pICreateCmd1 != NULL)
 &nbsp;&nbsp; pICreateCmd1-&gt;Release();
<b><i>  </i></b>
  // Releasing the reference on pICreateCmd2 terminates the SQL
  // Server connection supporting the session object. The application
  // now has only a single active connection on the SQL Server.
  if (pICreateCmd2 != NULL)
 &nbsp;&nbsp; pICreateCmd2-&gt;Release();
<b><i>  </i></b>
  // Even on error, this does not terminate a SQL Server connection 
  // because pICreateCmd3 has the connection of the 
  // data source object.
  if (pICreateCmd3 != NULL)
 &nbsp;&nbsp; pICreateCmd3-&gt;Release();
<b><i>  </i></b>
  // On release of the last reference on a data source interface, the
  // connection of the data source object to the SQL Server is broken.
  // The example application now has no SQL Server connections active.
  if (pIDBCreateSession != NULL)
 &nbsp;&nbsp; pIDBCreateSession-&gt;Release();
<b><i>  </i></b>
  // Called only if an error occurred while attempting to get a 
  // reference on the IDBCreateSession interface of the data source.
  // If so, the call to IDBInitialize::Uninitialize terminates the 
  // connection of the data source object to the SQL Server.
  if (pIDBInitialize != NULL)
  {
 &nbsp;&nbsp; if (FAILED(pIDBInitialize-&gt;Uninitialize()))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Uninitialize is not required, but it fails if an
 &nbsp;&nbsp; // interface has not been released. We can use it for
 &nbsp;&nbsp; // debugging.
 &nbsp;&nbsp; }
 &nbsp;&nbsp; pIDBInitialize-&gt;Release();
  }
<b><i>  </i></b>
  if (g_pIMalloc != NULL)
 &nbsp;&nbsp; g_pIMalloc-&gt;Release();
<b><i>  </i></b>
  CoUninitialize();
  
  return (0);
}
<b><i>  </i></b></code></pre>
<p>
Connecting SQLOLEDB session objects to a SQL Server can generate significant application overhead for applications that continually create and release session objects. The overhead can be minimized by managing SQLOLEDB session objects efficiently. SQLOLEDB applications can keep the SQL Server connection of a session object active by maintaining a reference on at least one interface of the object.</p>
<p>
For example, maintaining a pool of command creation object references keeps active connections for those session objects in the pool. As session objects are required, the pool maintenance code passes a valid <b>IDBCreateCommand</b> interface pointer to the application function requiring the session. When the application function no longer requires the session, the function returns the interface pointer back to the pool maintenance code rather than releasing the application’s reference to the command creation object.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b>In the above example, the IDBCreateCommand interface is used because ICommand implements GetDBSession, the only function in command or rowset scope that allows an object to determine the session on which it was created. Therefore, a command object, and only a command object, allows an application to retrieve a data source object pointer from which additional sessions can be created.</B></p>
</font></BODY>
</HTML>
