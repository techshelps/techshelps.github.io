<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Example: Creating a List Box Control</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="examplecreatinglistboxcontrol"></a>Example: Creating a List Box Control</h1>
<p>
The following example creates the Oledblst.ocx list box control using the ActiveX Control Creation Wizard. Some features and details have been left out of the example for the sake of simplicity. Refer to the Oledblst project in the Samples directory, included with this SDK, to find the complete source code for this sample. </p>
<p>
In addition to the <b>DataSource</b> and <b>DataMember</b> properties, this complex bound list control has a <b>ListColumn</b> property to select the column specified for the display data. At run time, the list control displays all rows of the data for the selected column. It also has the ability to update or display the current record by setting or retrieving the <b>Text</b> property.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>This sample subclasses a standard Windows list box control; therefore, the maximum size of the list may vary depending on your operating system. Also, the sample does not support duplicate fields in the column to which it is bound.</p>
<h1>Creating the Oledblst.ocx List Box Control</h1>
<p>
The ActiveX Control Creation Wizard is part of the ActiveX Controls Framework. </p>
<p class=label>
<b>To create an ActiveX control in Visual Basic</b>
<ol>
<li>
Follow the instructions in Appendix A to start the control wizard.<br><br></li>
<li>
Type the name of your project—for example, Oledblst.<br><br></li>
<li>
Type in or browse for the directory in which you want the project to be saved.<br><br></li>
<li>
Select the project type; the default project is "ActiveX Control." Click <b>Next</b>.<br><br></li>
<li>
Type the name of your control—for example, OledbList. <br><br></li>
<li>
Select the Windows control that you want to subclass—for example, LISTBOX.<br><br></li>
<li>
Select the <b>Complex Data Bound Control</b> check box. This adds property definitions in the .odl file, necessary data members for the control class, implementation stubs for the <b>DataSource</b> and <b>DataMember</b> properties, and necessary header files to your control sources.<br><br></li>
<li>
Select the <b>Implement IPerPropertyBrowsing</b> check box. This adds code necessary to support <b>IPerPropertyBrowsing</b> for the control. Click <b>Next</b>.<br><br></li>
<li>
Click <b>Finish</b>. The wizard creates a new ActiveX Framework Control in the designated directory.</li>
</ol>
<p>
Once the wizard has successfully completed its work, you can start working on the new ActiveX Framework Control project.</p>
<h1>Adding Rowset Support</h1>
<p>
This sample control uses <b>CRowset</b>, the <b>IRowset </b>wrapper class implemented in Rowset.cpp and defined in Rowset.h, to simplify rowset handling. Refer to Chapter 1, “Consuming Rowsets,” for a review. </p>
<p>
To use <b>CRowset</b>, open Oledblistctl.h and add the following include statement:</p>
<pre><code>#include &lt;adbctl.h&gt;   // Data bind control library
</code></pre>
<p>
Next, add <b>CRowset</b> to the <b>COLEDBListControl</b> class inheritance list:</p>
<pre><code>class COLEDBListControl : public COleControl, ….,
                  // Add this line for CRowset
                  public CRowset
</code></pre>
<p>
Now the control is ready to consume rowsets.</p>
<h1>Initializing the Rowset</h1>
<p>
For complex data-bound controls, the wizard adds declarations for <b>m_pDataSource</b> to the COLEDBListControl class definition, and <b>dmDataMember</b> to the OLEDBLISTCTLSTATE structure definition. These definitions are located in the OleDBListCtl.h header file. It is the control’s responsibility to persist the <b>DataMember</b> property. The <b>DataSource</b> property does not need to be persisted because it is set either by the container or in code. Stub implementations for the <b>DataSource</b> and <b>DataMember</b> properties were also added to Oledblistctl.cpp. The next code fragment illustrates the stubs with code additions highlighted in bold.</p>
<pre><code>HRESULT COLEDBListControl::putref_DataSource(DataSource *pDataSource)
{
   HRESULT hr = S_OK;

   if (m_pDataSource)
   {
      // TODO: Add code to do cleanup.
<b>      AttachRowset(NULL);</b>
      
      // Clear the previous data source.
      //
      m_pDataSource-&gt;Release();
   }
   // Cache the new data source.   
   //
   m_pDataSource = pDataSource;

   if (m_pDataSource)
   {
      // Take ownership.
      //
      m_pDataSource-&gt;AddRef();

      // TODO: Add code to process the new data source.
   }
   // Repaint the contents at run time.
   //
   if (!DesignMode())
      InvalidateControl(NULL);

   // Notify sinks.
   //
   PropertyChanged(DISPID_DATASOURCE);

   return hr;
}

HRESULT COLEDBListControl::put_DataMember(DataMember dmDataMember)
{
   HRESULT hr = S_OK;

   // Make a copy of the data member.
   //
   if (dmDataMember)
   {
      dmDataMember = (DataMember)COPYBSTR(dmDataMember);
      RETURN_ON_NULLALLOC(dmDataMember);
   }
   // Free the current data member.
   //
   if (m_state.dmDataMember)
      SysFreeString((BSTR)m_state.dmDataMember);
   
   // Keep the new data member.
   //
   m_state.dmDataMember = dmDataMember;

   // TODO: Add code to handle the change in the data member.
<b>   AttachRowset(NULL);</b>

   // Repaint the contents at run time.
   //
   if (!DesignMode())
      InvalidateControl(NULL);

   // Notify sinks.
   //
   PropertyChanged(DISPID_DATAMEMBER);

   return hr;
}
</code></pre>
<p>
<b>COLEDBListControl::AttachRowset</b> takes a pointer to an <b>IUnknown</b> interface that can be an <b>IRowset</b> or an <b>IRowPosition </b>interface. When the pointer is Null, the method performs necessary cleanup to detach itself from the currently attached rowset. This method also calls the base class <b>CRowset::Attach</b> method to allow the base class to perform initialization and cleanup. <b>AttachRowset</b> is implemented as follows:</p>
<pre><code>HRESULT COLEDBListControl::AttachRowset(IUnknown *pUnk)
{
   // If you have a previous Rowset, then clean up first.
   //
   if (CRowset::GetRowset())
   {
      // Free the ColumnInfo array.
      FreeColumns();

      // Disconnect notifications.
      m_notifications.Disconnect();

      // Release the row accessor.
      FreeRowAccessor();

      // Clear the list contents.
      ClearContents();

      // Let base class do cleanup.
      CRowset::Attach(NULL);
   }
   // If you are not given a new interface, 
   // then the work is done.
   if (NULL == pUnk)
      return S_OK;

   // First let the base class attach to the
   // new rowset.
   HRESULT hr = CRowset::Attach(pUnk);
   RETURN_ON_FAILURE(hr);

   // Connect notifications.
   hr = m_notifications.Connect();

   return hr;
}
</code></pre>
<p>
To initialize the rowset, you need to call <b>COLEDBListControl::AttachRowset</b> with a pointer to an <b>IRowPosition</b> or an <b>IRowset </b>interface. You want to use an <b>IRowPosition</b> interface and place the initialization code in its own method so you can call it on demand:</p>
<pre><code>HRESULT COLEDBListControl::InitRowset(void)
{
   // If GetRowset returns a value then
   // the rowset is already attached, so
   // return success.
   //
   if (CRowset::GetRowset())
      return S_OK;

   if (m_pDataSource)
   {
      // Request IRowPostion from the data source.
      //
      IUnknown *pRowPos;
      HRESULT hr = m_pDataSource-&gt;getDataMember(m_state.dmDataMember, IID_IRowPosition, &amp;pRowPos);
      RETURN_ON_FAILURE(hr);

      // If an interface was returned, then data is 
      // available, so attach to the interface.
      // 
      if (pRowPos)
      {
         hr = AttachRowset(pRowPos);
         pRowPos-&gt;Release();
         return hr;
      }
      // IDataSource::getDataMember succeeds but
      // did not return an interface, so return
      // S_FALSE for no data.
      //
      return S_FALSE;
   }
   // No data source, so return failure.
   //
   return E_FAIL;
}
</code></pre>
<p>
<b>InitRowset</b> is called before any base-class <b>CRowset </b>methods are accessed to ensure that everything is set up correctly. Calling <b>InitRowset</b> on demand postpones the initialization code until it is needed. The example uses this style of <i>delayed initialization</i> throughout.</p>
<h1>Getting Column Information</h1>
<p>
Column information is relevant at design time to support property browsing for the <b>ListColumn </b>property, and at run time for data binding. Upon request, <b>COLEDBListControl</b> queries for a list of columns and caches this list until it is no longer needed.</p>
<h1>Getting the Columns</h1>
<p>
The columns are cached in a COLUMNINFO array stored in the <b>m_pColumns</b> class member variable. The columns count is stored in the <b>m_pColumns</b> class member variable. The array and its count are initialized in <b>InitColumns</b> and freed in <b>FreeColumns</b>. <b>InitColumns</b> is called prior to accessing the <b>m_pColumns</b> member variable to ensure that the array is initialized. Again, this is an example of delayed initialization.</p>
<h1>Calling CRowset::GetColumns</h1>
<p>
This base-class method allocates a COLUMNINFO (see Adbhelp.h and Adbhelp.cpp) array, and returns the array and column count in the corresponding arguments passed to the method. The implementation of <b>COLEDBListControl::InitColumns</b> demonstrates this:</p>
<pre><code>HRESULT COLEDBListControl::InitColumns(void)
{
   // If you already have columns, then return.
   if (m_pColumns)
      return S_OK;

   // Ensure that the rowset is attached.
   HRESULT hr = InitRowset();
   
   // Call base class to get COLUMINFO array   if (S_OK == hr)
      hr = CRowset::GetColumns(m_pColumns, m_nColumns);

   return hr;
}
</code></pre>
<p>
<b>CRowset::GetColumns</b> allocates the COLUMNINFO array on behalf of the caller using the <b>new </b>operator. Callers must explicitly free this array. <b>COLEDBListControl::FreeColumns</b> performs this task:</p>
<pre><code>HRESULT COLEDBListControl::FreeColumns(void)
{
   if (m_pColumns)
   {
      delete [] m_pColumns;
      m_pColumns = NULL;
      m_nColumns = 0;
   }
   return S_OK;
}
</code></pre>
<h1>Browsing the Column Names</h1>
<p>
<b>COLEDBListControl</b> implements the <b>ListColumn</b> property, which allows users to specify in which column in the data source the list will display. <b>ListColumn</b> can be set in code if the user knows beforehand what columns are available in the data source. At design time, the control can give the container a list of available values to assign to the <b>ListColumn</b> property by implementing the COM interface <b>IPerPropertyBrowsing</b>.</p>
<h1>Adding the ListColumn Property</h1>
<p>
As with any other property, adding the <b>ListColumn</b> property requires modifying some files. In brief, you need to make the following modifications to the corresponding files.</p>
<p>
Add the following define statement to Dispid.h:</p>
<pre><code>#define DISPID_LISTCOLUMN   102
</code></pre>
<p>
Add the following properties to the interface definition of <b>IOLEDBList</b> in Oledblst.odl:</p>
<pre><code>// ListColumn property
[id(DISPID_LISTCOLUMN), propget] 
HRESULT ListColumn([out, retval] BSTR* pbstrColumn);
[id(DISPID_LISTCOLUMN), propput] 
HRESULT ListColumn([in] BSTR bstrColumn);
</code></pre>
<p>
Add the following member to the definition of OLEDBLISTCTLSTATE structure in Oledblistctl.h:</p>
<pre><code>BSTR      bstrListColumn;
</code></pre>
<p>
Add the following <b>put</b> and <b>get</b> methods to the class definition of COLEDBListControl in Oledblistctl.h:</p>
<pre><code>STDMETHOD(get_ListColumn)(BSTR *pbstrColumn);
STDMETHOD(put_ListColumn)(BSTR bstrColumn);
</code></pre>
<p>
You can find the implementation for the <b>put</b> and <b>get</b> methods for the <b>ListColumn</b> property in Oledblistctl.cpp.</p>
<h1>Implementing IPerPropertyBrowsing</h1>
<p>
During the control-creation process, the <b>Implements IPerPropertyBrowsing</b> check box was selected. This resulted in the code generated to implement <b>IPerPropertyBrowsing</b>. Stub implementations of <b>IPerPropertyBrowsing::GetPredefinedStrings</b> and <b>IPerPropertyBrowsing::GetPredefinedValue</b> were added to Oledblistctl.cpp. </p>
<p>
<b>IPerPropertyBrowsing::GetPredefinedStrings</b> provides the list of strings, whereas the <b>IPerPropertyBrowsing::GetPredefinedValue</b> function returns the string associated with the key or cookie value that was assigned to it by <b>IPerPropertyBrowsing::GetPredefinedStrings</b>.</p>
<h1>Implementing IPerPropertyBrowsing::GetPredefinedStrings</h1>
<p>
This method is called when the container needs the list of strings describing possible values for a property. Containers may also call this method with <b>NULL</b> pointers. If so, then <b>E_POINTER</b> should be returned if the property does not support browsing, and <b>S_OK</b> if it does. Following is the implementation of the method with code additions highlighted in bold.</p>
<pre><code>STDMETHODIMP COLEDBListControl::GetPredefinedStrings(DISPID dispid, CALPOLESTR *prgOleStr, CADWORD *prgCookie)
{
   // GUID of enum type for the property
   //
  const GUID *puuid = NULL;

   // Properties for which we support browsing   
   //
   switch (dispid) 
  {
   // TODO: Add cases for properties here.

<b>   case DISPID_LISTCOLUMN:</b>
<b>      return GetColumnDisplayStrings(prgOleStr, prgCookie);</b>

   case DISPID_UNKNOWN:   // Handles default w/no case warning.
   default:
      // Containers will call with NULL arguments
      // to test whether we support browsing for
      // a property. When this happens, E_POINTER
      // should be returned for properties that
      // we do not support browsing for; and
      // S_OK for those that we do support.      
      //
      if (!prgOleStr || !prgCookie)
         return E_POINTER;

      // We don't support browsing for 
      // the requested property.
      //
      return S_FALSE;
  }
   // GetStrings will search the TypeLib for information
   // about the type identified by *puuid.
   //
  return GetStrings(prgOleStr, prgCookie, OBJECT_TYPE_CTLOLEDBLIST, *puuid);
}
</code></pre>
<p>
<b>COLEDBListControl::GetColumnDisplayStrings</b> fills in the CALPOLESTR and CADWORD structures using the columns information. See the implementation of <b>COLEDBListControl::GetColumnDisplayStrings</b> in Oledblistctl.cpp for more details.</p>
<h1>Implementing IPerPropertyBrowsing::GetPredefinedValue</h1>
<p>
This method is called when the container needs the value of a property associated with the cookie. The cookie value is the same cookie matched with the property value in <b>IPerPropertyBrowsing::GetPredefinedStrings</b>. Here is the implementation of the method with code additions highlighted in bold.</p>
<pre><code>STDMETHODIMP COLEDBListControl::GetPredefinedValue(DISPID dispid, DWORD dwCookie, VARIANT *pVarValue)
{
   switch (dispid) 
   {
   // TODO: Add cases for properties here

<b>   case DISPID_LISTCOLUMN:</b>
<b>      if ((ULONG)dwCookie &lt; m_cColumns)</b>
<b>      {</b>
<b>         // Return column name at index formatted as</b>
<b>         // a Variant BSTR since this is the property</b>
<b>         // of for ListColumn</b>
<b>         //</b>
<b>         V_VT(pVarValue) = VT_BSTR;</b>
<b>         V_BSTR(pVarValue) = bstralloc(m_pColumns[dwCookie].pwszName);</b>
<b>         return V_BSTR(pVarValue) == NULL ? E_OUTOFMEMORY : S_OK;</b>
<b>      }</b>
<b>      return E_UNEXPECTED;</b>

   case DISPID_UNKNOWN:   // Handles default w/no case warning
   default:
      // Don't recognize the property
      //
      return E_FAIL;
   }
   // Lookup the property value based on the cookie
   return GetValue(pVarValue, dwCookie);
}
 </code></pre>
<p>
The cookie is interpreted as the zero base index of the corresponding column in the COLUMNINFO array. The inserted code checks to ensure that the cookie does not over-index the array and simply looks up the column name.</p>
<h1>Getting Row Data</h1>
<p>
True data-bound controls, such as those supplied by Visual Basic, employ some implementation of a row cache, which greatly reduces the number of rows that the provider has to bring into memory. To simplify the process, at run time OledbList fills its content with the text from the column designated by the <b>ListColumn</b> property for all the rows in the data source. This is not the optimal behavior, because it would hurt performance and would be a huge drain on system resources for any consumer to attempt to access all the rows at once in a large data source.</p>
<p>
To get row data, a consumer usually does the following:
<ol>
<li>
Decides which column to get data for using the rowset's column information.<br><br></li>
<li>
Defines how the column data should be formatted.<br><br></li>
<li>
Sets up column bindings and creates an accessor for the bindings.<br><br></li>
<li>
Fetches rows.<br><br></li>
<li>
Gets data for each row using the row handle, accessor handle, and a data buffer.</li>
</ol>
<p>
Following this sequence, OledbList performs the following steps:
<ol>
<li>
Determines whether the rowset has a column with the same name as the value of the <b>ListColumn</b> property.<br><br></li>
<li>
Requests the column data to be formatted as a BSTR.<br><br></li>
<li>
Sets up a column binding and creates an accessor.<br><br></li>
<li>
Fetches all the rows sequentially until the end of the rowset is reached.<br><br></li>
<li>
Gets data for each row fetched and adds it to the list content.</li>
</ol>
<p>
In this procedure, steps 1, 2, and 3 are handled in <b>COLEDBListControl::InitRowAccessor</b>, and steps 4 and 5 are handled in <b>COLEDBListControl::FillListContents</b>.</p>
<h1>Creating an Accessor</h1>
<p>
To display row data at run time, OledbList must first bind to the list column. It does this by first establishing whether the list column is a member of the columns of the attached rowset. Once membership is established, a DBBINDING structure is set up to associate the list column with a data buffer large enough to hold a BSTR. An accessor is then created with the binding information. All this is handled in <b>COLEDBListControl::InitRowAccessor</b>, which is called on demand to ensure that the class member variable <b>m_hRowAccessor</b> is initialized.</p>
<h1>COLEDBListControl::InitRowAccessor</h1>
<p>
Following is the implementation of <b>COLEDBListControl::InitRowAccessor</b>, which can be found in Oledblistctl.cpp:</p>
<pre><code>HRESULT COLEDBListControl::InitRowAccessor(void)
{
   // Return success if already initialized.
   //
   if (m_hRowAccessor)
      return S_OK;

   // ListColumn property must be set; if not,
   // then return S_FALSE for no data.
   //
   if (!m_state.bstrListColumn || '\0' == m_state.bstrListColumn[0])
      return S_FALSE;

   // Ensure that m_pColumns is initialized.
   //
   HRESULT hr = InitColumns();
   if (S_OK != hr)
      return hr;

   // Search for the ListColumn in the Columns array.
   //
   LONG nIndex = m_cColumns;
   while (nIndex--)
   {
      // wstrcmp is in strutils.h
      if (!wstrcmpi((WCHAR*)m_state.bstrListColumn, m_pColumns[nIndex].pwszName))
         break;
   }
   // If ListColumn is not one of the columns,
   // then return S_FALSE for no data.
   //
   if (nIndex &lt; 0)
      return S_FALSE;

   // Zero out the binding structure.
   //
   DBBINDING   dbBinding;
   ZeroMemory((void*)&amp;dbBinding, sizeof dbBinding);
   
   // Set the column ordinal.
   //
   dbBinding.iOrdinal   = m_pColumns[nIndex].iOrdinal;

   // Save the ordinal for the list column.
   //
   m_listColumnOrdinal = m_pColumns[nIndex].iOrdinal;

   // Set the offset of the start of data in the buffer.
   //
   dbBinding.obValue   = 0;

   // Request data to be returned as a BSTR.
   //
   dbBinding.wType      = DBTYPE_BSTR;

   // Maximum length of the buffer is sizeof(BSTR).
   //
   dbBinding.cbMaxLen   = sizeof(BSTR);

   // We want only the value part of the column data.
   //
   dbBinding.dwPart   = DBPART_VALUE;

   // Create an accessor with this column binding.
   // DBSTATUS is an optional argument. If this
   // fails, you can check the status in the 
   // debugger.
   //
   DBSTATUS dbStatus;
   hr = CRowset::CreateAccessor(&amp;dbBinding, 1, m_hRowAccessor, &amp;dbStatus);

   return hr;
}
</code></pre>
<p>
Freeing the row accessor is implemented as follows:</p>
<pre><code>HRESULT COLEDBListControl::FreeRowAccessor(void)
{
   HRESULT hr = S_OK;

   if (m_hRowAccessor)
   {
      hr = CRowset::ReleaseAccessor(m_hRowAccessor);
      m_hRowAccessor = NULL;
      m_listColumnOrdinal = -1;
   }
   return hr;
}
</code></pre>
<h1>Getting Data</h1>
<p>
Once an accessor is created and rows are fetched, the accessor can be used in conjunction with any row handle to get data for that row. Getting data requires a buffer allocated by the consumer that is large enough to hold row data as defined by the binding information used to create the accessor. It is also the responsibility of the consumer to deallocate memory that was allocated by the provider on the consumer's behalf. These operations are illustrated by <b>COLEDBListControl::FillListContent</b>.</p>
<h1>COLEDBListControl::FillListContent </h1>
<p>
This method sequentially fetches all the rows in the attached rowset and fills the list content with text data from the list column. It is implemented as follows:</p>
<pre><code>void COLEDBListControl::FillListContent(void)
{
   // Don't do anything if this is called at design time
   // or if an attempt to fill the list has 
   // been done since the last call to ClearContent.
   //
   if (DesignMode() || m_fFilledListContent)
      return;

   // Ensure that the row accessor is initialized.
   //
   HRESULT hr = InitRowAccessor();
   if (S_OK != hr)
      return;

   // Turn off redraw while the list is
   // being populated.
   //
   SendMessage(m_hwnd, WM_SETREDRAW, 0, 0);

   BSTR bstrData;   // Buffer to hold row data
   HROW *phRows;   // Array of row handles returned by callee
   ULONG cRows;   // Number of rows actually fetched

   // Fetch until the end of the rowset.
   //
   do
   {
      // Fetch at offset zero from the current fetch
      // position. ROWS_REQUEST is an arbitrary 
      // request If there is discontinuity in the
      // rowset due to deletions; or the number of rows
      // requested is greater then the number of active
      // rows allowed, then the number of rows fetched
      // may be less than the number of rows requested.
      //
      phRows = NULL;   // Must be NULL for callee to allocate

      hr = CRowset::GetNextRows(0, ROWS_REQUEST, phRows, cRows);

      // If no rows were returned then try another fetch. 
      // 
      if (!cRows)
         continue;

      for (ULONG n = 0; n &lt; cRows; n++)
      {
         // Get data for the row.
         //
         bstrData = NULL;
         CRowset::GetData(phRows[n], m_hRowAccessor, (void*)&amp;bstrData);

         // bstrData may be NULL.
         //
         if (bstrData)
         {
            // Convert to ANSI text.
            MAKE_ANSIPTR_FROMWIDE(szText, bstrData);

            // Free the BSTR.
            SysFreeString(bstrData);
            if (szText)
               SendMessage(m_hwnd, LB_ADDSTRING, 0, (LPARAM)szText);
            else
            {
               hr = E_OUTOFMEMORY;
               break;
            }
         }
         else
            // Add a blank line if data is NULL.
            SendMessage(m_hwnd, LB_ADDSTRING, 0, (LPARAM)(LPSTR)"");
      }
      // Release row handles and free the 
      // callee-allocated array.
      //
      CRowset::FreeRows(phRows, cRows);
   }
   // Continue until an operation fails
   // or until the end of the rowset.
   //</code></pre>
<p>
<code>while (!(FAILED(hr) || DB_S_ENDOFROWSET == hr));</code></p>
<pre><code>   // Turn redraw back on and invalidate
   // the control.
   //
   SendMessage(m_hwnd, WM_SETREDRAW, (WPARAM)TRUE, 0);
   m_fFilledListContent = TRUE;

   // Update the Text property.
   //
   UpdateText(DB_NULL_HROW);
}
</code></pre>
<h1>Adding Notifications</h1>
<p>
OledbList needs to receive notifications to detect the following conditions:
<ul type=disc>
<li>
When data becomes available or unavailable.<br><br></li>
<li>
When the current row position has changed.<br><br></li>
<li>
When changes are made to the row or rowset state.</li>
</ul>
<p>
Respectively, each of the items in the list is handled by implementing <b>IDataSourceListener</b>,<b> IRowPositionChange</b>, and <b>IRowsetNotify</b>.</p>
<h1>Implementing the IDataSourceListener Interface</h1>
<p>
Implementing<b> IDataSourceListener</b> is as simple as declaring a class that inherits from the interface, then providing implementations for all of its methods. <b>IDataSource</b> calls <b>IDataSourceListener</b> methods after the operation that caused the notification has finished. Consumers can use these notifications for informational purposes only.</p>
<h1>Implementing the IRowPositionChange Interface</h1>
<p>
<b>IRowPositionChange</b> is a COM interface; therefore, its implementation must also include the implementation of the <b>IUnknown</b> interface. To implement <b>IRowPositionChange</b>, declare a class that inherits from the interface, then implement all <b>IRowPositionChange</b> and <b>IUnknown</b> methods.</p>
<h1>Implementing the IRowsetNotify Interface</h1>
<p>
<b>IRowsetNotify</b> is also a COM interface. To implement <b>IRowsetNotify</b>, declare a class that inherits from the interface, then implement all <b>IRowsetNotify</b> and <b>IUnknown</b> methods.</p>
<h1>COLEDBListControl::CNotifications</h1>
<p>
This class illustrates how to implement the notification interfaces using the ActiveX Control Framework. <b>CUnknownObject</b> provides COM capabilities to classes derived from it, and greatly reduces the complexity of implementing COM interfaces and aggregation.</p>
<p>
<b>COLEDBListControl</b> defines <b>CNotifications</b> in line for its <b>m_notifications</b> member variable. The definition of <b>COLEDBListControl::CNotifications</b> is in Oledblistctl.cpp. It is defined as follows:</p>
<pre><code>   class CNotifications :    public CUnknownObject,
                           public IRowPositionChange,
 &nbsp;&nbsp;&nbsp;                public IRowsetNotify,
 &nbsp;&nbsp;&nbsp;                public IDataSourceListener
   {
   public:
      CNotifications();
      ~CNotifications();

   public:
      // IUnknown
      //
      DECLARE_STANDARD_UNKNOWN();

      // IRowPositionChange methods
      //
      STDMETHOD(OnRowPositionChange)(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

      // IRowsetNotify methods
      //
      STDMETHOD(OnFieldChange)(IRowset *prowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
      STDMETHOD(OnRowChange)(IRowset *prowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);
      STDMETHOD(OnRowsetChange)(IRowset *prowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny);

      // IDataSourceListener methods
      //
      STDMETHOD(dataMemberChanged)(THIS_ DataMember bstrDM);
      STDMETHOD(dataMemberAdded)(THIS_ DataMember bstrDM);
      STDMETHOD(dataMemberRemoved)(THIS_ DataMember bstrDM);

   // Overrideables
   protected:
      // Aggregation query interface support
      //
      virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

   // Implementation
   protected:
      CConnectionsArray   m_connections;   // Manages notifcation connections

      COLEDBListControl* OLEDBList(void);

   // Operations
   public:
      HRESULT Connect(void);
      HRESULT Disconnect(void);
 
   // Operators
   public:
      operator IUnknown *() {return PrivateUnknown();}
   }
   m_notifications;   // Notification object
   friend class CNotifications;
};
</code></pre>
<h1>Making the Connection</h1>
<p>
<b>COLEDBListControl::AttachRowset</b> appropriately calls <b>m_notifications.Connect</b> and <b>m_notifications.Disconnect</b> to engage and disengage notifications. The implementation of <b>CNotifications::Connect</b> and <b>CNotifications::Disconnect</b> uses <b>CConnectionsArray</b> (see Advcon.h and Advcon.cpp) to manage connection links for <b>IRowPositionChange</b> and <b>IRowsetNotify</b>. They call <b>IDataSource::addDataSourceListener</b> and <b>IDataSource::removeDataSourceListener</b> for <b>IDataSourceListener</b>. See the implementation of these methods in Oledblistctl.cpp for more details.</p>
<h1>Handling Notifications</h1>
<p>
It is not necessary to respond to all notifications, even though all methods for a particular notification interface must be implemented. When a notification is not of interest, its implementation should return S_OK. For <b>IRowsetNotify</b> notifications, <b>DB_S_UNWANTEDREASON</b> or <b>DB_S_UNWANTEDPHASE</b> may also be returned.</p>
<p>
The following section describes how <b>CNotifications</b> implements its notification handlers.</p>
<h1>CNotifications::dataSourceChanged (IDataSourceListener)</h1>
<p>
The data member argument is compared, without case sensitivity, to the data member that OledbList is using. If they match, the <b>COLEDBListControl::AttachRowset</b> is called with a Null argument to reset the list.</p>
<pre><code>STDMETHODIMP COLEDBListControl::CNotifications::dataMemberChanged(DataMember bstrDM)
{
   // Compare DataMembers.
   //
   if ((NULL == OLEDBList()-&gt;m_state.dmDataMember &amp;&amp; (NULL == bstrDM || '\0' == bstrDM[0]))
    || !bstrcmpi(bstrDM, (BSTR)OLEDBList()-&gt;m_state.dmDataMember))
   {
      // Reset because the attached rowset may
      // no longer be valid or may have changed.
      //
      OLEDBList()-&gt;AttachRowset(NULL);
   }
   return S_OK;
}
</code></pre>
<h1>CNotifications::OnRowPositionChange (IRowPositionChange)</h1>
<p>
This notification is used to detect when the current row position has changed. Two things must happen in response to this notification:
<ul type=disc>
<li>
Prior to the row position change, the current row's list column must be updated if the Text property is dirty.<br><br></li>
<li>
After the row position has changed, the Text property must be updated with the list column of the new row.</li>
</ul>
<pre><code>STDMETHODIMP COLEDBListControl::CNotifications::OnRowPositionChange(DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
   // Get the handle of the current row.
   //
   DBPOSITIONFLAGS   posFlags    = NULL;
   HROW         hrow       = NULL;
   HRESULT         hr         = OLEDBList()-&gt;GetCurrentRow(hrow, &amp;posFlags);

   if (SUCCEEDED(hr))
   {
      // Prior to row position change
      //
      if (DBEVENTPHASE_OKTODO == ePhase)
         OLEDBList()-&gt;UpdateCurrentRow(hrow);

      // After row position change
      //
      else if (DBEVENTPHASE_DIDEVENT == ePhase)
         OLEDBList()-&gt;UpdateText(hrow);

      // Must release the row
      //
      OLEDBList()-&gt;ReleaseRows(&amp;hrow, 1);
   }
   return S_OK;
}
</code></pre>
<h1>CNotifications::OnFieldChange (IRowsetNotify)</h1>
<p>
This notification is sent when columns in a row are being changed. OledbList responds only after the list column has changed:
<ul type=disc>
<li>
If the current row list column has changed, the Text property must be updated if it is not dirty.<br><br></li>
<li>
The text for the corresponding row in the list is updated.</li>
</ul>
<pre><code>STDMETHODIMP COLEDBListControl::CNotifications::OnFieldChange(IRowset *prowset, HROW hRow, ULONG cColumns, ULONG rgColumns[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
   if (DBEVENTPHASE_DIDEVENT == ePhase)
   {
      // Proceed only if the ListColumn is one
      // of the columns that has changed.
      //
      while (cColumns--)
      {
         if (rgColumns[cColumns] == OLEDBList()-&gt;m_listColumnOrdinal)
            break;
      }
      if (cColumns &lt; 0)
         return S_OK;

      // Update the Text property only if it has
      // not been changed.
      // 
      if (!OLEDBList()-&gt;m_fTextDirty)
      {
         DBPOSITIONFLAGS   posFlags    = NULL;
         HROW         hrowCurrent   = NULL;
         HRESULT         hr         = OLEDBList()-&gt;GetCurrentRow(hrowCurrent, &amp;posFlags);

         // Update Text property if this is the
         // current row.
         //
         if (SUCCEEDED(hr) &amp;&amp; hrowCurrent == hRow)
            OLEDBList()-&gt;UpdateText(hRow);

         // Must release the row
         //
         OLEDBList()-&gt;ReleaseRows(&amp;hrowCurrent, 1);
      }
      // Update the corresponding row in the list.
      //
      OLEDBList()-&gt;UpdateListRow(hRow);
   }
   return DB_S_UNWANTEDPHASE;
}
</code></pre>
<h1>CNotifications IRowsetNotify::OnRowChange (IRowsetNotify)</h1>
<p>
This notification is sent when rows are changing. Rows may change for a number of reasons. OledbList responds only after rows are inserted or deleted.</p>
<pre><code>STDMETHODIMP COLEDBListControl::CNotifications::OnRowChange(IRowset *prowset, ULONG cRows, const HROW rghRows[], DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
   // Respond only after the row change.
   //
   if (DBEVENTPHASE_DIDEVENT == ePhase)
   {
      switch(eReason)
      {
      case DBREASON_ROW_UNDODELETE:
      case DBREASON_ROW_UNDOINSERT:
      case DBREASON_ROW_DELETE:
      case DBREASON_ROW_INSERT:
         // Clear the list content so 
         // it will be refilled when the
         // control repaints.
         //
         // This is not the optimal response
         // but it gets the job done.
         //
         OLEDBList()-&gt;ClearContent();
         break;

      default:
         return DB_S_UNWANTEDREASON;
      }   
      return S_OK;
   }
   return DB_S_UNWANTEDPHASE;
}
</code></pre>
<h1>CNotifications IRowsetNotify::OnRowsetChange (IRowsetNotify)</h1>
<p>
This notification occurs after the rowset is released by the provider or has changed. The response is to detach the rowset.</p>
<pre><code>STDMETHODIMP COLEDBListControl::CNotifications::OnRowsetChange(IRowset *prowset, DBREASON eReason, DBEVENTPHASE ePhase, BOOL fCantDeny)
{
   // Assume the rowset is no longer valid.
   //
   OLEDBList()-&gt;AttachRowset(NULL);
   return S_OK;
}
</code></pre>
<h1>Building the Control</h1>
<p class=label>
<b>To build and register the control</b>
<ul type=disc>
<li>
&nbsp;From the <b>Build</b> menu in Microsoft Visual C++ 5.0, click <b>Build OLEDBList.OCX</b>. Your control is built and ready to be inserted into a container.</li>
</ul>
</font></BODY>
</HTML>
