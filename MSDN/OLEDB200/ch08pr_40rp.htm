<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Index Example</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbindex_example"></a>Index Example</h1>
<p>
The following code accesses the Employees table through the Emp_LastName_Index index, using <b>IRowsetIndex</b> for the index and <b>IRowsetLocate</b> for the table.</p>
<p>
The index has two columns. The first column, Emp_LastName, is of type DBTYPE_WSTR with a length of 30 characters and is the key column. The second column is of type DBTYPE_BYTES with a length of 4 characters and contains the bookmark for the Employees table. In the information returned by <b>IColumnsInfo::GetColumnInfo</b> for this column, the DBCOLUMNFLAGS_ISBOOKMARK is set.</p>
<p>
The code sample performs the following actions:
<ol>
<li>
Initializes the database and creates a session (not shown).<br><br></li>
<li>
Obtains interfaces for the table and index. Only the latter is shown.<br><br></li>
<li>
Gets information about the column types of the index rowset (not shown).<br><br></li>
<li>
Establishes bindings for the table and index columns. Only the latter is shown.<br><br></li>
<li>
Creates accessors for the table and index rowsets. Only the latter is shown.<br><br></li>
<li>
Reads the index rowset and retrieves the corresponding row from the table rowset.</li>
</ol>
<pre><code>#include&lt;oledb.h&gt;
#include&lt;stddef.h&gt;

GetTableRowsetLocate(IOpenRowset* , BSTR, IRowsetLocate**);
PrintData(OLECHAR*, ULONG, HROW*);
IMalloc * pMalloc;&nbsp; // pMalloc is the default memory allocator
HRESULT hr;

int main() {
 IOpenRowset&nbsp; *pIOpenRowset = NULL;
 DBID&nbsp;&nbsp;&nbsp; IndxId;
 IRowsetIndex *pIndex = NULL;
 IRowset&nbsp;&nbsp;&nbsp; *pIndexRows = NULL;
 IRowsetLocate&nbsp; *pIRSLocate =NULL;
 ULONG&nbsp;&nbsp;&nbsp; *pColumns = NULL;
 DBCOLUMNINFO&nbsp; **prgInfo;
 OLECHAR&nbsp;&nbsp; **ppStringsBuffer;
 IColumnsInfo *pIndxColsInfo = NULL;
 IAccessor&nbsp; *pIndxAccsr = NULL;
 HACCESSOR&nbsp;&nbsp; hIndexAccBmk = DB_INVALID_HACCESSOR;

 // Initialize the database, create a session, and obtain, from the session object, a
 // pointer pIOpenRowset to an IOpenRowset interface. Code not shown.

 // Use IOpenRowset::OpenRowset to obtain a pointer to IRowsetIndex.
 // Set the Index's DBID
 IndxId.eKind = DBKIND_NAME;
 IndxId.uName.pwszName = OLESTR("Emp_LastName_Index");

 // Open the Index with default properties and default interfaces. (IRowsetIndex,
 // IAccessor, IRowset, IColumnsInfo, IRowsetInfo).
 pIOpenRowset-&gt;OpenRowset(NULL, NULL, &amp;IndxId, IID_IRowsetIndex, 0, NULL,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pIndex);

 // Get a rowset for the table using a helper function.
 GetTableRowsetLocate(pIOpenRowset, OLESTR("Employees"), &amp;pIRSLocate);

 // Get an accessor for the index.
 pIndex-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIndxAccsr);

 // Get a rowset for index traversal.
 pIndex-&gt;QueryInterface(IID_IRowset, (void**) &amp;pIndexRows);

 // Get a pointer to IColumnsInfo on the index and get information about the columns
 // of the index.
 pIndex-&gt;QueryInterface(IID_IColumnsInfo, (void**) &amp;pIndxColsInfo);
 pIndxColsInfo-&gt;GetColumnInfo(pColumns, prgInfo, ppStringsBuffer);

 // Explore the DBCOLUMNINFO structures. The structure not corresponding to column
 // 0 and with a flag DBCOLUMNFLAGS_ISBOOKMARK set is the bookmark to the base
 // table. Suppose that the IColumnsInfo says that there are two columns, that
 // column 1 (which corresponds to the key) contains a string, and that the base
 // table bookmark is in column 2 and that it needs 4 bytes. Code not shown.
 // Create index and table bindings and corresponding accessors.
 typedef struct tagBmk{
  OLECHAR * Name;
  ULONG&nbsp;&nbsp; cBookmark;
  BYTE&nbsp; vBookmark[4];
 } Bmk;

 DBBINDSTATUS rgStatus[2];
 static DBBINDING IndxBinds[2]= {
  {
 &nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ordinal of key column
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No binding extensions 
 &nbsp; DBPART_VALUE,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bind value
 &nbsp; DBMEMOWNER_CLIENTOWNED,&nbsp; // Client-owned memory
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cbMaxLen ignored
 &nbsp; 0,
 &nbsp; DBTYPE_WSTR | DBTYPE_BYREF, // DBTYPE
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
  },
  {
 &nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ordinal of base table bookmark
 &nbsp; offsetof(Bmk, vBookmark),&nbsp;&nbsp; // Offset to value
 &nbsp; offsetof(Bmk,cBookmark),&nbsp; // Offset to length
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No status
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Type Info
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No binding extensions
 &nbsp; DBPART_VALUE | DBPART_LENGTH, // Bind value and length
 &nbsp; DBMEMOWNER_CLIENTOWNED,&nbsp;&nbsp; // Client-owned memory
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; 4,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // max length
 &nbsp; 0,
 &nbsp; DBTYPE_BYTES,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // DBTYPE
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
  }
 };

 pIndxAccsr-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 2, IndxBinds, 0, &amp;hIndexAccBmk,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgStatus);
 //...

 // Set a range Emp_LastName LIKE "Smith*". Notice that only the Name element of the
 // Bmk structure is used.
 Bmk Bookmark;
 Bookmark.Name = OLESTR("Smith");
 pIndex-&gt;SetRange(hIndexAccBmk, 1, &amp;Bmk, 0, NULL, DBRANGE_PREFIX);
 pIndex-&gt;Seek(hIndexAccBmk, 1, &amp;Bmk, DBSEEK_GE);

 // Traverse index within the range. For each matching index entry, retrieve the
 // corresponding record in the Employees table.
 ULONG&nbsp;&nbsp;&nbsp; cIdxRows = 0, cTabRows = 0;
 HROW&nbsp;&nbsp;&nbsp; *phIdxRows = NULL, *phTabRows = NULL;
 DBROWSTATUS&nbsp; rgRowStatus[1];

 while(SUCCEEDED(hr = pIndexRows-&gt;GetNextRows(0, 0, 1, &amp;cIdxRows, &amp;phIdxRows)) &amp;&amp;
 &nbsp; cIdxRows &gt; 0) {
  // Extract the bookmark from the index and read the table directly.
  pIndexRows-&gt;GetData(*phIdxRows, hIndexAccBmk, &amp;Bookmark);
  pIRSLocate-&gt;GetRowsAt(0, NULL, Bookmark.cBookmark, &amp;(Bookmark.vBookmark[0]), 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, &amp;cTabRows, &amp;phTabRows);
  PrintData(Bookmark.Name, cTabRows, phTabRows);

  // Release memory
  pMalloc-&gt;Free(Bookmark.Name);

  // Release the index and table rows 
  pIndexRows-&gt;ReleaseRows(cIdxRows, phIdxRows, NULL, rgRowStatus, rgRowOptions);
  pIRSLocate-&gt;ReleaseRows(cTabRows, phTabRows, NULL, rgRowStatus, rgRowOptions);
 };

 //Release the accessor
pIndxAccsr-&gt;ReleaseAccessor(hIndexAccBmk);

 //...
};
</code></pre>
</font></BODY>
</HTML>
