<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetUpdate::GetPendingRows</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetupdate__getpendingrows"></a>IRowsetUpdate::GetPendingRows</h1>
<p>
Returns a list of rows with pending changes.</p>
<pre><code>HRESULT GetPendingRows (
   HCHAPTER                  hChapter,
   DBPENDINGSTATUS      dwRowStatus,
   ULONG *                     pcPendingRows,
   HROW **                     prgPendingRows,
   DBPENDINGSTATUS **   prgPendingStatus);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>dwRowStatus</i></p>
<p class=indent>
[in]<br>
Indicates whether consumers want rows with pending updates, deletes, or inserts. The following DBPENDINGSTATUS values are valid and can be combined:</p>
<p class=tl>
DBPENDINGSTATUS_NEW<br>
DBPENDINGSTATUS_CHANGED<br>
DBPENDINGSTATUS_DELETED</P><p class=tl>
For information about the DBPENDINGSTATUS type, see "<a href="ch05pr_3b5f.htm">Row States</a>" in Chapter 5.</P><p class=dt>
<i>pcPendingRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of rows with pending changes. If this is a null pointer, <i>prgPendingRows</i> and <i>prgPendingStatus</i> are ignored. This is useful when the consumer wants to check the returned return code to determine whether there are any pending changes. If an error occurs, *<i>pcPendingRows</i> is set to zero.</p>
<p class=dt>
<i>prgPendingRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of handles of rows with pending changes. If this is a null pointer, no row handles are returned. The rowset allocates memory for the row handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the row handles. This argument is ignored if <i>pcPendingRows</i> is a null pointer. If *<i>pcPendingRows</i> is zero on output or an error occurs, the provider does not allocate any memory and ensures that *<i>prgPendingRows</i> is a null pointer on output.</p>
<p class=dt>
<i>prgPendingStatus</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of DBPENDINGSTATUS values. These values are in one-to-one correspondence with the row handles returned in *<i>prgPendingRows</i> and indicate the type of pending change. For information about the DBPENDINGSTATUS type, see "<a href="ch05pr_3b5f.htm">Row States</a>" in Chapter 5. If this is a null pointer, no status information is returned.</p>
<p class=tl>
The rowset allocates memory for the row statuses and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the row statuses. This argument is ignored if <i>pcPendingRows</i> is a null pointer. If *<i>pcPendingRows</i> is zero on output or an error occurs, the provider does not allocate any memory and ensures that *<i>prgPendingStatus</i> is a null pointer on output.</P><p class=tl>
</P><p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded and changes were pending.</p>
<p class=dt>
</p>
<p class=indent>
S_FALSE<br>
The method succeeded and no changes were pending.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>dwRowStatus</i> was DBPENDINGSTATUS_INVALIDROW, DBPENDINGSTATUS_UNCHANGED, or any other invalid value.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return the handles of rows with pending changes or the array of DBPENDINGSTATUS values.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=tl>
</P><p class=label>
<b>Comments</b></p>
<p>
<b>GetPendingRows</b> increments the reference of each row handle it returns in *<i>prgPendingRows</i>. The consumer must call <b>ReleaseRows</b> for these rows. If multiple changes are made to a single row, <b>GetPendingRows</b> returns the status as follows. 
<ul type=disc>
<li>
If <b>IRowsetChange::SetData</b> is called for a pending insert row, the row is still considered a pending insert row.<br><br></li>
<li>
If <b>IRowsetChange::DeleteRows</b> is called for a pending update row, the row is considered a pending delete row.<br><br></li>
<li>
If <b>IRowsetChange::DeleteRows</b> is called for a pending insert row, the row is considered a transmitted delete row; such rows are not returned by <b>GetPendingRows</b>.<br><br></li>
<li>
If <b>IRowsetRefresh::RefreshVisibleData</b> is called for a pending insert row, the row is still considered a pending insert row.</li>
</ul>
<p>
For a complete description of pending change states, see "<a href="ch05pr_3b5f.htm">Row States</a>" in Chapter 5.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowupd_1ar7.htm">IRowsetUpdate::GetRowStatus</a></p>
</font></BODY>
</HTML>
