<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Commands</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h2><a name="oledbusing_commands"></a>Using Commands</h2>
<p>
Before a consumer can use a command, it must determine whether commands are supported. To do this, the consumer calls <b>QueryInterface</b> for <b>IDBCreateCommand</b> on a session. If this interface is exposed, the provider supports commands. To create a command, the consumer then calls <b>IDBCreateCommand::CreateCommand</b> on the session. You can use a single session to create multiple commands.</p>
<p>
When the command is first created, it does not contain command text. The consumer sets the command text with <b>ICommandText::SetCommandText</b>. Because the text command syntax is provider specific, the consumer passes the GUID of the syntax to use. This can be one of the following values, or a provider-specific value specifying some provider specific syntax.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Dialect Value</b></td>
<td class=label width=50%><b>Meaning</b></td>
</tr>
<tr valign=top>
<td width=50%>DBGUID_DEFAULT</td>
<td width=50%>The command text is to be interpreted according to the provider's default grammar. If the provider supports multiple syntax including SQL, it must be able to recognize SQL syntax when DBGUID_DEFAULT is passed.</td>
</tr>
<tr valign=top>
<td width=50%>DBGUID_SQL</td>
<td width=50%>The command text is to be interpreted according to a superset of ANSI SQL syntax rules. To determine the level of ANSI SQL syntax supported by a provider, a consumer calls <b>IDBProperties::GetProperties</b> for the DBPROP_SQLSUPPORT property. Providers reporting this syntax are free to use extensions to ANSI SQL, or any subset of ANSI SQL according to their reported level of support, but must comply with the rules defined in ANSI SQL for any supported syntax defined in that specification. <p class=indent>
<B><b>Note</b></B> &nbsp; DBGUID__SQL was added in version 1.5 and is not supported in earlier providers. Consumers should use DBGUID_SQL only when calling a version 1.5 or greater provider that supports DBPROP_SQLSUPPORT. In most cases, unless the provider is trying to distinguish between different dialects, the consumer can just pass DBGUID_DEFAULT. Providers that support multiple syntaxes including SQL must be able to recognize SQL syntax when DBGUID_DEFAULT is passed.</p>
</td>
</tr>
</table><br>
<p>
To execute the command, the consumer calls <b>ICommand::Execute</b>. If the command text specifies a rowset, such as an SQL <b>SELECT</b> statement, <b>Execute</b> creates an instance of the rowset and returns an interface pointer to it.</p>
<p>
Before executing a command that creates a rowset, the consumer can specify various properties of the rowset—such as the interfaces to expose and degree of scrollability—by calling <b>ICommandProperties::SetProperties</b>. For more information, see "<a href="ch04pr_02ib.htm">Setting Rowset Properties</a>" in Chapter 4. The consumer can also get information about the columns of the rowset by calling <b>IColumnsInfo::GetColumnInfo</b>, which all providers support, or <b>IColumnsRowset::GetColumnsRowset</b>, which providers may support on the command. The command text must be set to use these methods and, if the command supports preparation, it must be prepared.</p>
<p>
If a command is to be executed multiple times with the same text command, or if the consumer needs information about the rowset it will create, the consumer can <i>prepare</i> the command by calling <b>ICommandPrepare::Prepare</b>. This is equivalent to compiling the command. Providers are not required to support command preparation.</p>
<p>
Prepared commands are more versatile when used with <i>parameters</i>, which are variables in the text command. For example, if the provider supports SQL, the consumer might prepare and repeatedly execute the parameterized SQL statement <b>UPDATE Employees SET (Salary = ?) WHERE EmployeeID = ?</b> to update the salaries of a number of employees.</p>
<p>
Parameter support is optional for commands, prepared or otherwise; providers that support them expose <b>ICommandWithParameters</b> on the command. To use parameters, the consumer first describes the parameters to the provider by calling <b>ICommandWithParameters::SetParameterInfo</b>. Some providers can describe parameters themselves and do not need consumers to call <b>SetParameterInfo</b>. The consumer then creates an accessor that specifies the structure of a buffer and places parameter values in this buffer. Finally, it passes the handle of the accessor and a pointer to the buffer to <b>Execute</b>. On later calls to <b>Execute</b>, the consumer simply places new parameter values in the buffer and calls <b>Execute</b> with the accessor handle and buffer pointer. For more information, see Chapter 6, "<a href="ch06pr_92ap.htm">Getting and Setting Data</a>."</p>
</font></BODY>
</HTML>
