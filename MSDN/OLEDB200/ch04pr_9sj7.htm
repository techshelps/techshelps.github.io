<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Bookmark Types</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbbookmark_types"></a>Bookmark Types</h1>
<p>
OLE DB supports two kinds of bookmarks—numeric and key value. The DBPROP_BOOKMARKTYPE property indicates the bookmarks that a provider supports.</p>
<h1>Numeric Bookmarks</h1>
<p>
Numeric bookmarks are based on a position or index into the rows selected for a rowset. In most cases, the rowset builds a set of information about the rows, which enables the same row to be retrieved easily. It does not guarantee the existence or consistency of those rows throughout the transaction; that still depends on the transaction isolation level. It returns the same row entity if it can.</p>
<p>
The numeric value can be of any size. A small rowset might use a 16-bit index, whereas a rowset against an Oracle table might use Oracle ROWIDs, which are around 6 bytes each. There is no significance to the ordering of numeric values, either logical or physical. The implementation should simply be fast.</p>
<p>
If the primary key value of a row is changed while working with a row for which the consumer has a numeric bookmark, the bookmark still points to the <i>same row instance</i>. This is required for a numeric bookmark. Suppose the row also had a nonoverlapping candidate key. The primary key may be entirely changed, but the same value would remain in the candidate key column. </p>
<h1>Key Value Bookmarks</h1>
<p>
When a rowset is ordered and there is some combination of columns (not necessarily the primary keys of the base tables) that form a unique key for each row, it becomes useful to use these values as a bookmark. At first it may seem redundant, because one could expect an interface such as <b>IRowsetIndex</b> to take key values and rapidly return a numeric bookmark. However, the numeric bookmark itself may be costly and unwanted. In some cases the key values enable the provider to access the underlying tables without storing any kind of temporary table.</p>
<p>
With a key value bookmark, a consumer could, in theory, synthesize a set of values that could occur but do not. The result of doing this is undefined; that is, providers are not required to detect forgeries.</p>
<p>
If the key value columns of a row are changed while working with a row for which the consumer has a key value bookmark, the bookmark can become disassociated, or pointing to a new row that usurps the old values.</p>
</font></BODY>
</HTML>
