<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetFind::FindNextRow</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="irowsetfindfindnextrow"></a>IRowsetFind::FindNextRow</h1>
<p>
Begins at the specified bookmark and finds the next row matching the specified value. <b>IRowsetFind</b> does not affect the next fetch position used by <b>IRowset::GetNextRows</b>.</p>
<pre><code>HRESULT FindNextRow (
HCHAPTER                  hChapter,
HACCESSOR               hAccessor,
void *                        pFindValue,
DBCOMPAREOP            CompareOp,
ULONG                     cbBookmark,
const BYTE *               pBookmark,
BOOL                        fSkipCurrent,
LONG                        cRows,
ULONG *                     pcRowsObtained,
HROW **                     prghRows);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i> [in]</p>
<p class=indent>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored. If this is the first time the chapter is used, the chapter is opened and a reference count is taken to hold the chapter’s state. This reference count is released by calling <b>ReleaseChapter</b>.</p>
<p class=dt>
<i>hAccessor</i> [in]</p>
<p class=indent>
Accessor describing the value to be matched. This accessor must describe only a single column. If it describes more than one column, <b>FindNextRow</b> returns DB_E_BADBINDINFO. <i>Valid coercions for FindNextRow are the same as those for SetData. </i></p>
<p class=dt>
<i>pFindValue</i>[in]</p>
<p class=indent>
Pointer to the value to be matched. If this value is NULL, it is compared to other values according to the DBPROP_NULLCOLLATION property returned in the Data Source Information property set.</p>
<p class=dt>
<i>CompareOp [in]</i></p>
<p class=indent>
Operation to use in comparing the row values.</p>
<p class=dt>
<i>cbBookmark</i> [in]</p>
<p class=indent>
Length in bytes of the bookmark, or zero to start from the last row found by <b>IRowsetFind</b>.</p>
<p class=dt>
<i>pBookmark</i> [in]</p>
<p class=indent>
Pointer to a bookmark that identifies the row from which to start searching for a match. The consumer is not required to have access rights to this row. However, if this row matches the seek criteria, the provider cannot return it unless the consumer has read permission for it. The consumer can specify a<i> cbBookmark </i>value of zero, and set<i> pBookmark </i>to null, to request that the find occur starting with the last row found by<i> </i><b>IRowsetFind</b>. If<i> </i>cRows was greater than 1, this is different than the last row returned by <b>IRowsetFind</b><i>. </i>Thus, forward-only cursors that support<i> </i><b>IRowsetFind</b><i> </i>return<i> E_INVALIDARG </i>if cRows is greater than 1. If this is the first time<i> </i><b>IRowsetFind</b><i> </i>has been called on the rowset, specifying a null bookmark starts at the beginning of the rowset. If the rowset does not support <b>IRowsetLocate</b>, only the special bookmarks DBBMK_FIRST and DBBMK_LAST, and the null value, can be used. If the rowset does not support scrolling backward, only the null bookmark value can be used. If the rowset is chaptered, the identified row must fall within the specified chapter.</p>
<p class=dt>
<i>fSkipCurrent</i> [in]</p>
<p class=indent>
Whether or not to try and match the current row. If FALSE, the current row is compared and, if it matches the criteria, returned. If TRUE, the comparison starts at the first row following the current row in the direction indicated by <i>cRows</i>.</p>
<p class=dt>
<i>cRows</i> [in]</p>
<p class=indent>
The number of rows to fetch from the rowset, starting with the first row found. A negative number indicates a backward fetch. Check the DBPROP_CANFETCHBACKWARDS property returned in <b>IRowsetInfo::GetProperties</b> to determine whether this is supported. The search direction is the same as the fetch direction, so a negative count searches backward from the starting position and returns successively earlier rows as subsequent obtained rows. If <i>cRows</i> is zero and there are no other errors, no rows are fetched, but the fetch position for <b>FindNextRow</b> is moved to the next match or off the end of the rowset if no match is found.<i> </i></p>
<p class=dt>
<i>pcRowsObtained</i> [out]</p>
<p class=indent>
A pointer to memory in which to return the actual number of fetched rows.</p>
<p class=dt>
<i>prghRows</i> [out]</p>
<p class=indent>
A pointer to memory in which to return an array of handles of the retrieved rows. If *<i>prghRows</i> is not a null pointer on input, it must be a pointer to memory large enough to return the handles of the requested number of rows. If *<i>prghRows</i> is a null pointer on input, the rowset allocates memory for the row handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> after it releases the row handles. If *<i>prghRows</i> was a null pointer on input and *<i>pcRowsObtained</i> is zero on output, the provider does not allocate any memory and ensures that *<i>prghRows</i> is a null pointer on output.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=dt>
S_OK</p>
<p class=indent>
The method succeeded.</p>
<p class=dt>
DB_S_ENDOFROWSET</p>
<p class=indent>
<b>FindNextRow</b> reached the start or the end of the rowset or (in a hierarchical rowset) the start or the end of the chapter, and could not fetch all requested rows because the count extended beyond the end. The next fetch position is before the start or after the end of the rowset. The number of rows actually returned is returned in *<i>pcRowsObtained</i>; this will be less than <i>cRows</i>.</p>
<p class=dt>
DB_S_ROWLIMITEXCEEDED</p>
<p class=indent>
Fetching the number of rows specified in <i>cRows</i> would have exceeded the total number of active rows supported by the rowset. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. This condition can occur only when there are more rows available than can be handled by the rowset. Thus, this condition never conflicts with those described in DB_S_ENDOFROWSET and DB_S_STOPLIMITREACHED, both of which imply that no more rows were available.</p>
<p class=dt>
DB_S_STOPLIMITREACHED</p>
<p class=indent>
Returning rows requires further execution of the command, such as when the rowset uses a server-side cursor. Execution has been stopped because a resource limit has been reached. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. Execution cannot be resumed.</p>
<p class=dt>
DB_S_BOOKMARKSKIPPED</p>
<p class=indent>
The following behavior is supported only on rowsets that set the DBPROP_BOOKMARKSKIPPED property to VARIANT_TRUE. If this property is VARIANT_FALSE, this return code is never returned. The row specified by *<i>pBookmark</i> was deleted, is no longer a member of the rowset, or is a row to which the consumer does not have access rights. <b>FindNextRow</b> skipped that row and began searching with the next row in the direction indicated by <i>cRows</i>. If this condition occurs along with another warning condition, the method returns the code for the other warning condition. Thus, whenever a consumer receives the return code for another warning condition, it should check to see if this condition occurred.</p>
<p class=dt>
E_FAIL</p>
<p class=indent>
A provider-specific error occurred.</p>
<p class=dt>
E_INVALIDARG</p>
<p class=indent>
<i>pcRowsObtained</i> or <i>prghRows</i> was a null pointer. <i>cbBookmark</i> was not zero and <i>pBookmark</i> was a null pointer.</p>
<p class=dt>
E_OUTOFMEMORY</p>
<p class=indent>
The provider was unable to allocate sufficient memory in which to create instances of the rows or return the row handles.</p>
<p class=dt>
E_UNEXPECTED</p>
<p class=indent>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
DB_E_BADBINDINFO</p>
<p class=indent>
The specified accessor specified binding information for more than one column.</p>
<p class=dt>
DB_E_BADBOOKMARK</p>
<p class=indent>
<i>*pBookmark</i> was invalid; for example, it was incorrectly formed. <i>*pBookmark</i> did not match any rows in the rowset (this includes the case when the row corresponding to the bookmark has been deleted). The rowset was chaptered and *<i>pBookmark</i> did not apply to the specified chapter.</p>
<p class=dt>
DB_E_BADCHAPTER</p>
<p class=indent>
The rowset was chaptered and <i>hChapter</i> was invalid. The rowset was single chaptered and the specified chapter was not the open chapter. The consumer must use the open chapter or release the open chapter before specifying a new chapter.</p>
<p class=dt>
DB_E_BADCOMPAREOP</p>
<p class=indent>
<i>CompareOp </i>was an invalid value. <i>CompareOp </i>was DBCOMPAREOPS_BEGINSWITH or DBCOMPAREOPS_CONTAINS and <i>pFindValue </i>was not bound as a string value.</p>
<p class=dt>
DB_E_CANTFETCHBACKWARDS</p>
<p class=indent>
<i>cRows</i> was negative and the rowset cannot fetch backward<i>.</i></p>
<p class=dt>
DB_E_CANTSCROLLBACKWARDS</p>
<p class=indent>
A bookmark value of DBBMK_FIRST or DBBMK_LAST was specified and the rowset cannot scroll backward. <i>cRows was greater than 1 and the rowset is forward-only.</i></p>
<p class=dt>
DB_E_NOTREENTRANT</p>
<p class=indent>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
DB_E_ROWSNOTRELEASED</p>
<p class=indent>
The provider requires release of prior HROWs before new ones can be obtained (see <b>IDBPropertyInfo::GetPropertyInfo</b>, DBPROP_CANHOLDROWS).</p>
<p class=dt>
DB_SEC_E_PERMISSIONDENIED</p>
<p class=indent>
The consumer did not have sufficient permission to get the rows.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
See <b>IRowsetLocate::GetRowsAt</b> for a complete description of the results for given values for a bookmark, offset, and number of rows to fetch.</p>
<p>
<b>FindNextRow</b> searches the rowset in the direction indicated by <i>cRows</i> for a row that matches <i>pFindValue</i> according to the specified <i>CompareOp</i>. Once a match is found, if <i>cRows</i> is greater than 1, additional rows are returned in rowset order as if the consumer called <b>GetNextRows</b> starting with the first matching row. If no rows match the criteria, <b>FindNextRow</b> returns DB_S_ENDOFROWSET and <i>pcRowsObtained</i> is set to zero.</p>
<p>
When passing a null bookmark value to <b>FindNextRow</b>, the provider starts from the last row <i>found</i>, not from the last row <i>returned,</i> by <b>FindNextRow</b>. This allows the consumer to search for values within the last set of rows returned.</p>
<p>
The rowset does not have to be ordered on the column searched. <b>FindNextRow</b> always finds the next row according to the criteria, regardless of the sort order. </p>
<p>
<b>FindNextRow</b> increments by one the reference count of each row for which it returns a handle. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned. </p>
<p>
If the provider encounters a problem fetching a row—for example, data stored in a text file contains a letter in a numeric column—<b>FindNextRow</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
<b>FindNextRow</b> must always check for the conditions that cause E_INVALIDARG, E_UNEXPECTED, DB_E_CANTFETCHBACKWARDS, DB_E_CANTSCROLLBACKWARDS, DB_E_NOTREENTRANT, and DB_E_ROWSNOTRELEASED before changing the next fetch position. If it returns any other error, the next fetch position is unknown. For example, the provider might have to perform actions that change the next fetch position to determine that the error DB_E_BADSTARTPOSITION occurred. When the next fetch position is unknown, the consumer usually calls <b>RestartPosition</b> to return it to a known position.</p>
<p>
For information about the actions of <b>FindNextRow</b> when it fetches a row that it already has in its internal buffers, see “Uniqueness of Rows in the Rowset” in Chapter 4 of the <i>OLE DB Programmer’s Reference</i>. For information about whether <b>FindNextRow</b> can detect changes made to rows in the rowset, see “Visibility of Changes” in Chapter 5 in the same reference.</p>
<p class=label>
<b>See Also</b></p>
<p>
<b>IRowset::GetData, IRowsetLocate::GetRowsAt, IRowsetLocate::GetRowsByBookmark</b></p>
</font></BODY>
</HTML>
