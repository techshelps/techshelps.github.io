<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>HIERARCHIZE</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="hierarchize"></a>HIERARCHIZE</h1>
<p>
The first method discussed is how HIERARCHIZE works for a set whose dimensionality is 1. This method will be generalized to sets with arbitrary dimensionality.</p>
<h2>Sets with Dimensionality = 1</h2>
<p>
Consider HIERARCHIZE(S), where S = {Kansas, USA, Canada, Buffalo, Topeka}
<ol>
<li>
Gather information:<ol>
<li>
As detailed in "Literal Sets," make two tables — S1 and S2 — that contain the fully qualified member names in the sets S1 and S2, respectively. <p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;In a full-fledged MDX expression, there may be no need to do this because the input set to HIERARCHIZE may be derived from another expression.</p></li>
<li>
Use the following query to verify that all members belong to the same dimension. If the returned count is greater than 1, then it is an invalid set.<pre><code>SELECT COUNT DISTINCT COMPONENT(S.Name, -1)
FROM S
</code></pre>
</li>
<li>
Get the dimension name by using this query:<pre><code>SELECT DISTINCT COMPONENT(S.Name, -1)
FROM S
</code></pre>
</li>
<li>
Get the level number of each level represented in the input set:<pre><code>SELECT DISTINCT LEVEL(S.Name)
FROM S
</code></pre>
</li>
</ol>
</li>
<li>
The objective is to create a table T that looks like this:</li>
</ol>
<table border=1 cellpadding=5 cols=5 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=45%><b>Name</b></td>
<td class=label width=12%><b>Level</b></td>
<td class=label width=14%><b>Rank1</b></td>
<td class=label width=15%><b>Rank2</b></td>
<td class=label width=14%><b>Rank3</b></td>
</tr>
<tr valign=top>
<td width=45%>Geography.All.USA.Kansas</td>
<td width=12%>2</td>
<td width=14%>1</td>
<td width=15%>14</td>
<td width=14%>NULL</td>
</tr>
<tr valign=top>
<td width=45%>Geography.All.USA</td>
<td width=12%>1</td>
<td width=14%>1</td>
<td width=15%>NULL</td>
<td width=14%>NULL</td>
</tr>
<tr valign=top>
<td width=45%>Geography.All.Canada</td>
<td width=12%>1</td>
<td width=14%>3</td>
<td width=15%>NULL</td>
<td width=14%>NULL</td>
</tr>
<tr valign=top>
<td width=45%>Geography.All.USA.NewYork.Buffalo</td>
<td width=12%>3</td>
<td width=14%>1</td>
<td width=15%>27</td>
<td width=14%>5</td>
</tr>
<tr valign=top>
<td width=45%>Geography.All.USA.Kansas.Topeka</td>
<td width=12%>3</td>
<td width=14%>1</td>
<td width=15%>14</td>
<td width=14%>1</td>
</tr>
</table><br>
<p class=tl>
For each member of set S, there should be a RANKX column, which contains the rank of each of its ancestors. To get the hierarchized set from T, just use this:</P><pre><code>SELECT Name, Rank
FROM 
SELECT * FROM T
 &nbsp;&nbsp; RANK ROWS AS Rank RANKORDER BY Rank1, Rank2, Rank3 
ORDER BY Rank
</code></pre>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The number of RANKX columns in T is <i>m</i> + 1 where <i>m</i> = maximum level in the set S. This is the case even if there are unrepresented levels in S, such as when there are members from COUNTRY and CITY level, but none from the STATE level.</p>
<p class=tl>
To do this, you:</P><ol>
<li>
Define a table that has elements of set S and its levelo:<pre><code>CREATE LOCAL TEMPORARY VIEW S1(Name)
AS
SELECT S.Name
FROM S JOIN members AS M ON(S.Name = M.Level_Name)
</code></pre>
</li>
<li>
Now make a UNION of three SELECT operations (three is the level of the lowermost member in S):<pre><code>SELECT S1.*, M1.Natural_Sort_Rank AS Rank1, 
 &nbsp; NULL AS Rank2, NULL AS Rank3
FROM S1 JOIN Members AS M1 ON S1.Name = M1.Member_Name
WHERE S1.Level = 0
UNION
SELECT S1.*, M1.Natural_Sort_Rank AS Rank1, 
 &nbsp; M2.Natural_Sort_Rank AS Rank2, NULL AS Rank3
FROM (S1 JOIN Members AS M2 ON S1.Name = M2.Member_Name) 
JOIN Members AS M1 ON ANCESTOR(S1.Name, 1)= M1.Member_Name
WHERE S1.Level = 1 
UNION
SELECT S1.*, M1.Natural_Sort_Rank AS Rank1, 
 &nbsp; M2.Natural_Sort_Rank AS Rank2, M3.Natural_Sort_Rank AS M3
FROM (((S1 JOIN Members AS M3 ON S1.Name = M3.Name)
JOIN Members AS M2 ON ANCESTOR(S1.Name, 2) = M2.Name)
JOIN Members AS M1 ON ANCESTOR(S1.Name, 3) = M1.Name)
WHERE S1.Level = 2
</code></pre>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The WHERE clause on each UNION iterates from Level = 0 through the level of the lowermost member in S1. Note also that the ANCESTOR function in the FROM iterates from 1 through 1 + the level of the lowermost member in S1.</p></li>
</ol>
<h2>Generalizing for Sets with Arbitrary Dimensionality</h2>
<p>
Consider HIERARCHIZE(S), where</p>
<p>
S = {(Kansas, 1996), (Buffalo, 1995.Q4), (USA, 1995.Mar), (Buffalo, 1995), (USA, 1995), (Kansas, 1996.Q4), (Kansas, 1996.Q1), (USA, 1995.Q1)}</p>
<p>
The steps in hierarchizing this set are:
<ol>
<li>
Let S(Name1, Name2, Rank) be the table associated with the set S.<br><br></li>
<li>
Let S1, S2 be tables:<ul type=disc>
<li>
First step:<pre><code>CREATE LOCAL TEMPORARY VIEW S1(Name, Rank)
AS
SELECT DISTINCT Name1, Rank FROM S
</code></pre>
</li>
<li>
Second step:<pre><code>CREATE LOCAL TEMPORARY VIEW S2(Name, Rank)
AS
SELECT DISTINCT Name2, Rank FROM S
</code></pre>
</li>
</ul>
</li>
<li>
HIERARCHIZE S1 and S2 as explained in "Sets with Dimensionality = 1." Let the resulting hierarchized sets be D1 and D2.<br><br></li>
<li>
Now use the following query to yield the hierarchized set:<pre><code>SELECT S.Name1, S.Name2, NewRank as Rank
FROM 
 &nbsp; (SELECT S.Name1, S.Name2 
 &nbsp; FROM (S JOIN D1 ON S.Name1 = D1.Name)
 &nbsp;&nbsp;&nbsp;&nbsp; JOIN D2 ON S.Name2 = D2.Name)
 &nbsp; RANK ROWS AS NewRank RANKORDER BY D1.Rank, D2.Rank
</code></pre>
</li>
</ol>
<p>
Generalizing this to sets with dimensionality greater than two should be straightforward.</p>
</font></BODY>
</HTML>
