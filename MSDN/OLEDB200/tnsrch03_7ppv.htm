<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Set Value Expressions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="setvalueexpressions"></a>Set Value Expressions</h1>
<p>
For any expression examples in the following sections, SampleSet is defined to be</p>
<pre><code>{USA, Buffalo, France, NYC, London, California, LA, Nice, UK, Paris}
</code></pre>
<p>
with sales data as indicated in this table:</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=444>
<tr valign=top>
<td class=label width=33%><b>Location</b></td>
<td class=label width=34%><b>1995 sales</b></td>
<td class=label width=33%><b>1996 sales</b></td>
</tr>
<tr valign=top>
<td width=33%>UK</td>
<td width=34%>1900</td>
<td width=33%>1700</td>
</tr>
<tr valign=top>
<td width=33%>London</td>
<td width=34%>250</td>
<td width=33%>300</td>
</tr>
<tr valign=top>
<td width=33%>France</td>
<td width=34%>2500</td>
<td width=33%>2500</td>
</tr>
<tr valign=top>
<td width=33%>Paris</td>
<td width=34%>365</td>
<td width=33%>250</td>
</tr>
<tr valign=top>
<td width=33%>Nice</td>
<td width=34%>27</td>
<td width=33%>100</td>
</tr>
<tr valign=top>
<td width=33%>USA</td>
<td width=34%>5000</td>
<td width=33%>6500</td>
</tr>
<tr valign=top>
<td width=33%>NYC</td>
<td width=34%>900</td>
<td width=33%>1100</td>
</tr>
<tr valign=top>
<td width=33%>Buffalo</td>
<td width=34%>300</td>
<td width=33%>200</td>
</tr>
<tr valign=top>
<td width=33%>California</td>
<td width=34%>2000</td>
<td width=33%>3500</td>
</tr>
<tr valign=top>
<td width=33%>LA</td>
<td width=34%>500</td>
<td width=33%>900</td>
</tr>
</table><br>
<p>
<b>&lt;dimension&gt;.MEMBERS</b></p>
<p class=tl>
The set of all members in <i>dimension</i>.</P><p class=tl>
For example,</P><pre><code>Geography.MEMBERS
</code></pre>
<p class=tl>
is the set of all members in the Geography dimension.</P><p>
<b>&lt;hierarchy&gt;.MEMBERS</b></p>
<p class=tl>
The set of all members in <i>hierarchy</i>.</P><p class=tl>
For example,</P><pre><code>Time.Quarterly.MEMBERS
</code></pre>
<p class=tl>
is the set of all members in the Quarters hierarchy of the Time dimension.</P><p>
<b>&lt;level&gt;.MEMBERS</b></p>
<p class=tl>
All members at a given level in a dimension.</P><p>
<b>&lt;member&gt;.CHILDREN</b></p>
<p class=tl>
All children of <i>member</i>.</P><p>
<b>DESCENDANTS(&lt;member&gt;, &lt;level&gt; [, &lt;desc_flags&gt;])</b></p>
<p class=tl>
All descendants of <i>member</i> at <i>level</i>. By default, only members at the specified level will be included. This corresponds to a <i>desc_flag</i> value of SELF. By changing the value of <i>desc_flag</i>, the consumer can include or exclude descendants at <i>level</i>, the children before <i>level</i>, and the children after <i>level</i> (until the leaf).</P><p class=tl>
For example,</P><pre><code>DESCENDANTS(USA, Counties)
</code></pre>
<p class=tl>
yields all Counties in USA, and is the same as</P><pre><code>DESCENDANTS(USA, Counties, SELF)
</code></pre>
<p class=tl>
The statement</P><pre><code>DESCENDANTS(USA, Counties, BEFORE)
</code></pre>
<p class=tl>
yields all states in USA. If another level exists between Countries and States, members from that level will also be returned.</P><p class=tl>
And the statement</P><pre><code>DESCENDANTS(USA, Counties, AFTER)
</code></pre>
<p class=tl>
yields all cities in USA. If another level exists after Cities, members from that level will also be returned.</P><pre><code>DESCENDANTS(USA, Counties, BEFORE_AND_AFTER)
</code></pre>
<p class=tl>
yields all states and cities in USA.</P><p>
<b>ORDER(&lt;set&gt;, {&lt;string_value_expression&gt; | &lt;numeric_value_expression&gt;} <br>
 &nbsp; [, ASC | DESC | BASC | BDESC])</b></p>
<p class=tl>
There are two varieties of <b>ORDER</b>: hierarchized (<b>ASC</b> or <b>DESC</b>) and nonhierarchized (<b>BASC</b> or <b>BDESC</b> where “B” indicates “Break hierarchy”). The hierarchized ordering first arranges members according to their position in the hierarchy. Then it orders each level. The nonhierarchized ordering arranges members in the set without regard to the hierarchy. In the absence of an explicit specification, <b>ASC</b> is the default.</P><pre><code>ORDER(SampleSet, ([1995], Sales), DESC)
</code></pre>
<p class=tl>
hierarchizes all members and sorts each level according to Sales. Sales are compared at the highest level when constructing the sorted list. Therefore, if the sum of Sales in all California cities is less than the sum of Sales in all New York cities, California and California.LA will appear below NYC in the sorted, descending list. </P><p class=tl>
The result of </P><pre><code>ORDER(SampleSet, ([1995], Sales), DESC)
</code></pre>
<p class=tl>
is as follows.</P><table border=1 cellpadding=5 cols=4 frame=below rules=rows width=390>
<tr valign=top>
<td class=label width=19%><b>Location</b></td>
<td class=label width=22%></td>
<td class=label width=23%></td>
<td class=label width=36%><b>1995 sales</b></td>
</tr>
<tr valign=top>
<td width=19%>USA</td>
<td width=22%></td>
<td width=23%></td>
<td width=36%>5000</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%>California</td>
<td width=23%></td>
<td width=36%>2000</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>LA</td>
<td width=36%>500</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>Buffalo</td>
<td width=36%>300</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>NYC</td>
<td width=36%>900</td>
</tr>
<tr valign=top>
<td width=19%>France</td>
<td width=22%></td>
<td width=23%></td>
<td width=36%>2500</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>Paris</td>
<td width=36%>365</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>Nice</td>
<td width=36%>27</td>
</tr>
<tr valign=top>
<td width=19%>UK</td>
<td width=22%></td>
<td width=23%></td>
<td width=36%>1900</td>
</tr>
<tr valign=top>
<td width=19%></td>
<td width=22%></td>
<td width=23%>London</td>
<td width=36%>250</td>
</tr>
</table><br>
<pre><code>ORDER(SampleSet, ([1995], Sales), BDESC)
</code></pre>
<p class=tl>
sorts the members according to their values without regard for their relative positions in the member hierarchy. In this example, numeric values are sorted by 1995 sales per city, including aggregate sales values by state and country.</P><p class=tl>
The result of</P><pre><code>ORDER(SampleSet, ([1995], Sales), BDESC)
</code></pre>
<p class=tl>
is as follows.</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows width=318>
<tr valign=top>
<td class=label width=45%><b>Location</b></td>
<td class=label width=55%><b>1995 sales</b></td>
</tr>
<tr valign=top>
<td width=45%>USA</td>
<td width=55%>5000</td>
</tr>
<tr valign=top>
<td width=45%>France</td>
<td width=55%>2500</td>
</tr>
<tr valign=top>
<td width=45%>California</td>
<td width=55%>2000</td>
</tr>
<tr valign=top>
<td width=45%>UK</td>
<td width=55%>1900</td>
</tr>
<tr valign=top>
<td width=45%>NYC</td>
<td width=55%>900</td>
</tr>
<tr valign=top>
<td width=45%>LA</td>
<td width=55%>500</td>
</tr>
<tr valign=top>
<td width=45%>Paris</td>
<td width=55%>365</td>
</tr>
<tr valign=top>
<td width=45%>Buffalo</td>
<td width=55%>300</td>
</tr>
<tr valign=top>
<td width=45%>London</td>
<td width=55%>250</td>
</tr>
<tr valign=top>
<td width=45%>Nice</td>
<td width=55%>27</td>
</tr>
</table><br>
<p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;When the input set has 2 elements for which the <i>string_value_expression</i> or <i>numeric_value_expression</i> has the same value, then the input order is preserved. For example if the sales for USA &amp; Europe is 300 each, and that for Asia is 100, then the call:</p><pre><code>ORDER({USA, Europe, Asia}, Sales, BASC)
</code></pre>
<p class=atl>
returns the set {Asia, USA, Europe}, and <b>not</b> the set {Asia, Europe, USA}.</p><p>
<b>HIERARCHIZE(&lt;set&gt;)</b></p>
<p class=tl>
Hierarchizes the set. Members in a level are sorted in their <i>natural order</i>, the default ordering of the members along a dimension when no other sort conditions are specified. <b>HIERARCHIZE</b> will always retain duplicates.</P><pre><code>HIERARCHIZE(SampleSet)
</code></pre>
<p class=tl>
returns the set in natural order. The hierarchized dataset follows (assuming that the natural order for the data source is alphabetical):</P><table border=1 cellpadding=5 cols=3 frame=below rules=rows width=210>
<tr valign=top>
<td class=tl width=28%>France</P><td class=tl width=37%></P><td class=tl width=35%></P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>Nice</P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>Paris</P></tr>
<tr valign=top>
<td class=tl width=28%>UK</P><td class=tl width=37%></P><td class=tl width=35%></P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>London</P></tr>
<tr valign=top>
<td class=tl width=28%>USA</P><td class=tl width=37%></P><td class=tl width=35%></P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%>California</P><td class=tl width=35%></P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>LA</P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>Buffalo</P></tr>
<tr valign=top>
<td class=tl width=28%></P><td class=tl width=37%></P><td class=tl width=35%>NYC</P></tr>
</table><br>
<p>
<b>TOPCOUNT(&lt;set&gt;, &lt;index&gt; [, &lt;numeric_value_expression&gt;])</b></p>
<p class=tl>
Sorts on the numeric value expression (if any) and picks up the top <i>index</i> items. This function always breaks the hierarchy. The <b>BOTTOMCOUNT</b> function is similar.</P><p>
<b>TOPPERCENT(&lt;set&gt;, &lt;percentage&gt;, &lt;numeric_value_expression&gt;)</b></p>
<p class=tl>
Sorts on <i>numeric_value_expression</i> and picks up the top <i>x</i> (the smallest number possible) elements such that their percentage of the result of <i>numeric_value_expression</i> is at least <i>percentage</i>. This function always breaks the hierarchy. The <b>BOTTOMPERCENT</b> function is similar.</P><p>
<b>TOPSUM(&lt;set&gt;, &lt;value&gt;, &lt;numeric_value_expression&gt;)</b></p>
<p class=tl>
Sorts on <i>numeric_value_expression</i> and picks up the top <i>x</i> (the smallest number possible) elements such that their sum is at least <i>value</i>. This function always breaks the hierarchy. The <b>BOTTOMSUM</b> function is similar.</P><p>
<b>FILTER(&lt;set&gt;, &lt;search_condition&gt;)</b></p>
<p class=tl>
Filters set based on <i>search_condition</i>.</P><p class=tl>
For the expression </P><pre><code>FILTER(SampleSet, (Sales,[1996]) &lt; (Sales, [1995]))
</code></pre>
<p class=tl>
the following result is returned:</P><pre><code>{UK, Paris, Buffalo}
</code></pre>
<p>
<b>UNION(&lt;set1&gt;, &lt;set2&gt; [, ALL])</b></p>
<p class=tl>
Joins the two input sets by union, eliminating duplicates by default. The <b>ALL</b> flag keeps duplicates in the joined set. Duplicates are deleted from the tail. The expression {<i>set1</i>, <i>set2</i>} does not remove duplicates.</P><p class=tl>
Another way of joining by union is to use a comma-separated list of sets within braces. For example,</P><pre><code>{USA.CHILDREN, CANADA.CHILDREN}
</code></pre>
<p class=tl>
is an implicit union and is equivalent to</P><pre><code>UNION(USA.CHILDREN, CANADA.CHILDREN, ALL)
</code></pre>
<p class=tl>
Duplicated members are always retained in an implicit union.</P><p>
<b>DISTINCT(&lt;set&gt;)</b></p>
<p class=tl>
Deletes duplicate tuples from a set. Duplicates are deleted from the tail.</P><p>
<b>INTERSECT(&lt;set1&gt;, &lt;set2&gt; [,ALL])</b></p>
<p class=tl>
Finds the intersection of two input sets. By default, duplicates are eliminated from both sets prior to intersection. The optional ALL retains duplicates. Because there are several ways for ALL to work, it is worth mentioning the algorithm: Nonduplicated elements are intersected as usual. For each duplicate in <i>set1</i>, match it with a duplicate in <i>set2</i>, if one exists, and keep matching duplicates in the intersected set.</P><p>
<b>EXCEPT(&lt;<i>set1&gt;</i>, &lt;<i>set2&gt;</i> [,ALL])</b></p>
<p class=tl>
Finds the difference between two sets. Duplicates are eliminated from both sets prior to finding the difference. The optional ALL flag retains duplicates. Matching duplicates in <i>set1</i> are eliminated and non-matching duplicates are retained.</P><p>
<b>CROSSJOIN(&lt;<i>set1&gt;</i>, &lt;<i>set2&gt;</i>)</b></p>
<p class=tl>
Generates the cross product of the input sets. The order of tuples in the resulting set is as follows: </P><p class=tl>
If <i>set1</i> = {<i>x1</i>, <i>x2</i>,…,<i>xn</i>} and <i>set2</i> = {<i>y1</i>, <i>y2</i>, …, <i>yn</i>}, then <b>CROSSJOIN(</b><i>set1</i><b>, </b><i>set2</i><b>)</b> is:</P><pre><code>{(<i>x1</i>, <i>y1</i>), (<i>x1</i>, <i>y2</i>),...,(<i>x1</i>, <i>yn</i>), (<i>x2</i>, <i>y1</i>), (<i>x2</i>, <i>y2</i>),..., 
(<i>x2</i>, <i>yn</i>),..., (<i>xn</i>, <i>y1</i>), (<i>xn</i>, <i>y2</i>),..., (<i>xn</i>, <i>yn</i>)}
</code></pre>
<p>
<b>EXTRACT(&lt;set&gt;, &lt;dimension&gt;[, &lt;dimension&gt;...])</b></p>
<p class=tl>
This is the opposite of the <b>CROSSJOIN</b> function. The resulting set consists of tuples from the extracted <i>dimension</i> elements. This function always removes the duplicates.</P><p>
<b>GENERATE(&lt;set1&gt;, &lt;set2&gt; [,ALL])</b></p>
<p class=tl>
This is best explained with an example:</P><pre><code>GENERATE({USA, France}, DESCENDANTS(Geography.CURRENTMEMBER, Cities))
</code></pre>
<p class=tl>
This will repeatedly go through for each member of the set {USA, France} and apply the expression DESCENDANTS(Geography.CURRENTMEMBER, Cities). Each such application results in a set. (Application to USA will generate the set of all cities in USA; application to France will generate all cities in France.) These sets are joined by union to get the result of this function. In this example, all cities in USA and France will be the result. In general, GENERATE(&lt;set1&gt;, &lt;set_expression&gt;) will apply the set expression to each member of <i>set1</i> and join the results by union.</P><p class=tl>
If <i>set1</i> is not related to <i>set_expression</i> by means of <b>CURRENTMEMBER</b>, then <b>GENERATE</b> results in a simple replication of the set implied by <i>set_expression</i>, with as many replications as there are tuples in <i>set1</i>. If the optional ALL flag is specified, then all duplicates are retained in the result. If ALL is not specified, then duplicates are removed. For example,</P><pre><code>GENERATE({USA, FRANCE}, {SEATTLE, BOSTON}, ALL)
</code></pre>
<p class=tl>
will result in</P><pre><code>{SEATTLE, BOSTON, SEATTLE, BOSTON}
</code></pre>
<p class=tl>
However, if ALL was not specified, then the result is</P><pre><code>{SEATTLE, BOSTON}
</code></pre>
</font></BODY>
</HTML>
