<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetScroll::GetRowsAtRatio</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetscroll__getrowsatratio"></a>IRowsetScroll::GetRowsAtRatio</h1>
<p>
Fetches rows starting from a fractional position in the rowset.</p>
<pre><code>HRESULT GetRowsAtRatio (
   HWATCHREGION   hReserved1,
   HCHAPTER            hChapter,
   ULONG               ulNumerator,
   ULONG               ulDenominator,
   LONG                  cRows,
   ULONG *               pcRowsObtained,
   HROW **               prghRows);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hReserved1</i></p>
<p class=indent>
[in]<br>
Reserved for future use. Providers ignore this parameter.</p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>ulNumerator</i></p>
<p class=indent>
[in]<br>
See <i>ulDenominator</i> below.</p>
<p class=dt>
<i>ulDenominator</i></p>
<p class=indent>
[in]<br>
The provider determines the first row to fetch from the ratio of <i>ulNumerator</i> to <i>ulDenominator</i>, roughly using the formula:</p>
<pre><code>(ulNumerator x Number of Rows in Rowset) / ulDenominator
</code></pre>
<p class=tl>
If the rowset is being populated asynchronously, <i>ulNumerator</i> and <i>ulDenominator</i> specify the relative position within the rows fetched so far.</P><p class=tl>
How accurately the provider applies this ratio is provider-specific. For example, if <i>ulNumerator</i> is 1 and <i>ulDenominator</i> is 2, some providers will fetch rows starting exactly halfway through the rowset while other providers will fetch rows starting 40 percent of the way through the rowset.</P><p class=tl>
However, all providers must handle the following conditions correctly.</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=50%><b>Condition</b></td>
<td class=label width=50%><b>GetRowsAtRatio action</b></td>
</tr>
<tr valign=top>
<td width=50%>(<i>ulNumerator</i> = 0) AND (<i>cRows</i> &gt; 0)</td>
<td width=50%>Fetches rows starting with the first row in the rowset.</td>
</tr>
<tr valign=top>
<td width=50%>(<i>ulNumerator</i> = 0) AND (<i>cRows</i> &lt; 0)</td>
<td width=50%>Returns DB_S_ENDOFROWSET.</td>
</tr>
<tr valign=top>
<td width=50%>(<i>ulNumerator</i> = <i>ulDenominator</i>) AND<br>
(<i>cRows</i> &gt; 0)</td>
<td width=50%>Returns DB_S_ENDOFROWSET.</td>
</tr>
<tr valign=top>
<td width=50%>(<i>ulNumerator</i> = <i>ulDenominator</i>) AND<br>
(<i>cRows</i> &lt; 0)</td>
<td width=50%>Fetches rows starting with the last row in the rowset.</td>
</tr>
</table><br>
<p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The number of rows to fetch. A negative number means to fetch backward. <i>cRows</i> can be a negative number only if the value of the DBPROP_CANFETCHBACKWARDS property is VARIANT_TRUE. The rows are returned in rowset-traversal order; that is, the direction in which they were fetched.</p>
<p class=tl>
If <i>cRows</i> is zero, no rows are fetched. If the provider does not discover any other errors, the method returns S_OK; whether the provider checks for any other errors is provider-specific.</P><p class=dt>
<i>pcRowsObtained</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of rows fetched. If the consumer has insufficient permissions to return all rows, <b>GetRowsAtRatio</b> fetches all rows for which the consumer has sufficient permission and skips all other rows. If the method fails, *<i>pcRowsObtained</i> is set to 0.</p>
<p class=dt>
<i>prghRows</i></p>
<p class=indent>
[in/out]<br>
A pointer to memory in which to return an array of handles of the fetched rows. If *<i>prghRows</i> is not a null pointer on input, it must be a pointer to memory large enough to return the handles of the requested number of rows. If *<i>prghRows</i> is a null pointer on input, the rowset allocates memory for the row handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> after it releases the row handles. If *<i>prghRows</i> was a null pointer on input and *<i>pcRowsObtained</i> is zero on output or the method fails, the provider does not allocate any memory and ensures that *<i>prghRows</i> is a null pointer on output.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ENDOFROWSET<br>
<b>GetRowsAtRatio</b> reached the start or the end of the rowset or chapter and could not fetch all requested rows because the count extended beyond the end. The number of rows actually fetched is returned in *<i>pcRowsObtained</i>; this will be less than <i>cRows</i>.</p>
<p class=tl>
The rowset is being populated asynchronously and no additional rows are available at this time. To determine whether additional rows may be available, the consumer should call <b>IDBAsynchStatus::GetStatus</b> or listen for the <b>IDBAsynchNotify::OnStop</b> notification.</P><p class=dt>
</p>
<p class=indent>
DB_S_ROWLIMITEXCEEDED<br>
Fetching the number of rows specified in <i>cRows</i> would have exceeded the total number of active rows supported by the rowset. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. This condition can occur only when there are more rows available than can be handled by the rowset. Thus, this condition never conflicts with those described in DB_S_ENDOFROWSET and DB_S_STOPLIMITREACHED, both of which imply that no more rows were available.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_STOPLIMITREACHED<br>
Fetching rows required further execution of the command, such as when the rowset uses a server-side cursor. Execution was stopped because a resource limit was reached. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pcRowsObtained</i> or <i>prghRows</i> was a null pointer.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to instantiate the rows or return the row handles.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADRATIO<br>
<i>ulNumerator</i> was greater than <i>ulDenominator</i>.</p>
<p class=tl>
<i>ulDenominator</i> was zero.</P><p class=dt>
</p>
<p class=indent>
DB_E_CANTFETCHBACKWARDS<br>
<i>cRows</i> was negative and the rowset cannot fetch backward.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of existing rows before new ones can be fetched. For more information, see DBPROP_CANHOLDROWS in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to fetch any of the rows; no rows were fetched.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>GetRowsAtRatio</b> increments the reference count of each row for which it returns a handle by 1. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned.</p>
<p>
If the provider encounters a problem fetching a row—for example, data stored in a text file contains a letter in what is supposed to be a numeric column—<b>GetRowsAtRatio</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>IRowset::GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
For information about what <b>GetRowsAtRatio</b> does when it fetches a row that it already has in its internal buffers, see "<a href="ch04pr_6pmc.htm">Uniqueness of Rows in the Rowset</a>" in Chapter 4. For information about whether <b>GetRowsAtRatio</b> can detect changes made to rows in the rowset, see "<a href="ch05pr_18oj.htm">Visibility of Changes</a>" in Chapter 5.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowloc_2oj8.htm">IRowsetLocate::GetRowsAt</a>, <a href="rowloc_3nfv.htm">IRowsetLocate::GetRowsByBookmark</a>, <a href="rowscr_8dny.htm">IRowsetScroll::GetApproximatePosition</a></p>
</font></BODY>
</HTML>
