<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetRefresh::RefreshVisibleData</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetrefresh__refreshvisibledata"></a>IRowsetRefresh::RefreshVisibleData</h1>
<p>
Retrieves the data values from the data source that are visible to the transaction for the specified rows.</p>
<pre><code>HRESULT RefreshVisibleData (
HCHAPTER          hChapter,
ULONG             cRows,
const HROW       rghRows[],
BOOL                fOverwrite,
ULONG*            pcRowsRefreshed,
HROW**            prghRowsRefreshed,
DBROWSTATUS**&nbsp;    prgRowStatus);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored. </p>
<p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The count of rows to refresh. If <i>cRows</i> is zero, <b>RefreshVisibleData</b> ignores <i>rghRows</i> and reads in current values for all active rows. </p>
<p class=dt>
<i>rghRows</i></p>
<p class=indent>
[in]<br>
An array of <i>cRows</i> row handles to be refreshed. If <i>cRows</i> is zero, this argument is ignored.</p>
<p class=dt>
<i>fOverwrite</i></p>
<p class=indent>
[in]<br>
TRUE if the provider should discard any pending changes to a given row and accept the visible values as the new current values; FALSE otherwise.</p>
<p class=dt>
<i>pcRowsRefreshed</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of rows the method attempted to refresh. If this is a null pointer, no count of rows is returned. If an error occurs, the provider sets *<i>pcRowsRefreshed</i> to zero.</p>
<p class=dt>
<i>prghRowsRefreshed</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the array of row handles the method attempted to refresh. If <i>cRows</i> is not zero, then the elements of this array are in one-to-one correspondence with those of <i>rghRows</i>. If <i>cRows</i> is zero, the elements of this array are the handles of all active rows with pending changes in the chapter, or all active rows with pending changes in the rowset if <i>hChapter</i> is DB_NULL_HCHAPTER. When <i>cRows</i> is zero, <b>RefreshVisibleData</b> will add to the reference count of the rows whose handles are returned in <i>prghRowsRefreshed</i>. </p>
<p class=indent>
The rowset allocates memory for the handles and the client should release this memory with <b>IMalloc::Free</b> when no longer needed. This argument is ignored if <i>pcRowsRefreshed</i> is a null pointer and must not be a null pointer otherwise. If *<i>pcRowsRefreshed</i> is zero on output or the method fails, the provider does not allocate any memory and ensures that *<i>prghRowsRefreshed</i> is a null pointer on output.</p>
<p class=dt>
<i>prgRowStatus</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of row status values. The elements of this array correspond one-to-one with the elements of *<i>prghRowsRefreshed</i>. If no errors occur while refreshing a row, the corresponding element of *<i>prgRowStatus</i> is set to DBROWSTATUS_S_OK if the row is successfully resynchronized, or DBROWSTATUS_S_NOCHANGE if the provider can easily determine that there was no change to the value. If an error occurs while refreshing a row, the corresponding element is set as specified in DB_S_ERRORSOCCURRED. If <i>prgRowStatus</i> is a null pointer, no row status values are returned. </p>
<p class=indent>
The rowset allocates memory for the row status values and returns the address to this memory; the client releases this memory with <b>IMalloc::Free</b> when it is no longer needed. This argument is ignored if <i>pcRowsRefreshed</i> is a null pointer. If *<i>pcRowsRefreshed</i> is zero on output or the method fails, the provider does not allocate any memory and ensures that *<i>prgRowStatus</i> is a null pointer on output.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=dt>
S_OK</p>
<p class=indent>
The method succeeded. All rows were successfully processed. For each row, <i>prgRowStatus</i> contains one of the following: 
<ul type=disc>
<li class=indent>
DBROWSTATUS_S_NOCHANGE if the row in the rowset had no pending changes when <b>RefreshVisibleData</b> was called, or if the provider could easily detect that there were no changes made to the data source for this row. <br><br></li>
<li class=indent>
DBROWSTATUS_S_OK in all other cases. </li>
</ul>
<p class=dt>
DB_S_ERRORSOCCURRED</p>
<p class=indent>
An error occurred while refreshing a row, but at least one row was successfully refreshed. Successes can occur for the reason listed under S_OK. The following errors can occur: 
<ul type=disc>
<li class=indent>
An element of <i>rghRows</i> was invalid. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li class=indent>
Refreshing a row was canceled during notification. The row was not refreshed and the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_CANCELED.<br><br></li>
<li class=indent>
An element of <i>rghRows</i> referred to a row for which a deletion had been transmitted to the data source. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_DELETED.<br><br></li>
<li class=indent>
The row was not refreshed due to reaching a limit on the server, such as a query execution timing out. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_LIMITREACHED.<br><br></li>
<li class=indent>
An element of <i>rghRows</i> referred to a row on which a storage object was open. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_OBJECTOPEN.<br><br></li>
<li class=indent>
An element of <i>rghRows</i> referred to a pending insert row. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_PENDINGINSERT.<br><br></li>
<li class=indent>
DBPROP_STRONGIDENTITY was VARIANT_FALSE and an element of <i>rghRows</i> referred to a row for which an insertion had been transmitted to the data source. The row was not refreshed and the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_NEWLYINSERTED. </li>
</ul>
<p class=dt>
E_FAIL</p>
<p class=indent>
A provider-specific error occurred.</p>
<p class=dt>
E_INVALIDARG</p>
<p class=indent>
<i>cRows</i> was not zero and <i>rghRows</i> was a null pointer. </p>
<p class=indent>
<i>pcRowsRefreshed</i> was not a null pointer and <i>prghRowsRefreshed</i> was a null pointer.</p>
<p class=dt>
E_UNEXPECTED</p>
<p class=indent>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
DB_E_ERRORSOCCURRED</p>
<p class=indent>
Errors occurred while refreshing all of the rows. Errors can occur for the reasons listed under DB_S_ERRORSOCCURRED.</p>
<p class=dt>
DB_E_NOTREENTRANT</p>
<p class=indent>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
DB_SEC_E_PERMISSIONDENIED</p>
<p class=indent>
The consumer did not have sufficient permission to refresh the rows.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>RefreshVisibleData</b> retrieves the data values from the data source that are visible to the transaction for the specified rows. Changes made to the row by the current transaction are always visible to <b>RefreshVisibleData</b>, including changes made by other rowsets in the same transaction. Whether changes made by other transactions are visible to <b>RefreshVisibleData</b> depends on the isolation level of the current transaction. Thus, <b>RefreshVisibleData</b> uses values as follows: 
<ul type=disc>
<li>
Read Uncommitted. The changes most recently made, committed or uncommitted, by any transaction are used. If no changes have been made by any transaction, the original row is used.<br><br></li>
<li>
Read Committed. The changes most recently made by the current transaction or committed by other transactions are used. If no changes have been made by the current transaction or committed by other transactions, the original row is used.<br><br></li>
<li>
Repeatable Read and higher. The changes most recently made by the current transaction are used. If no changes have been made by the current transaction, the original row is used. </li>
</ul>
<p>
For providers that keep a local copy of visible data, <b>RefreshVisibleData</b> updates the provider's local copy of the visible data for any indicated rows with pending changes.</p>
<p>
When <i>fOverwrite</i> is TRUE, the provider discards any pending changes to a given row and accepts the visible values as the new current values that will be returned by calling <b>GetData</b> or <b>GetOriginalData</b>. This affects rows with or without pending changes. Any changes already transmitted to the data source are not lost; they will be committed or aborted when the transaction is committed or aborted. But all pending changes are lost because they exist only in the rowset’s copy of the row and the <i>fOverwrite</i> TRUE option overwrites the contents of this copy. The pending change status in this case is removed from the row.</p>
<p>
When <i>fOverwrite</i> is FALSE, the provider makes no change to the pending status of the row. It does not affect the current values of the row (available through <b>IRowset::GetData</b>) or the original values of the row (available through <b>IRowsetUpdate::GetOriginalData</b>). If the provider keeps a local copy of the visible data values, it refreshes the values for the indicated rows. If the provider does not keep a local copy of the visible data values, the indicated row has no pending changes, or all columns in the row are deferred, the provider reports success without taking any action. </p>
<p>
Providers that perform optimistic updates in a disconnected scenario usually use the cached visible values on a pending row as the source of concurrency conflict detection values. For example, the values used to identify the row to a SQL-based provider through a WHERE clause would come from this buffer. Thus, refreshing the visible values buffer for a row with pending changes via <b>RefreshVisibleData</b> potentially affects the behavior of a subsequent call to <b>IRowsetUpdate::Update</b> for that row because it may introduce new acceptable identity values into the conflict-detection mechanism of the provider. </p>
<p>
If a specified row has been deleted from the data source and this deletion is visible, <b>RefreshVisibleData</b> returns DBROWSTATUS_E_DELETED in the error status array for the row. This row is subsequently treated as a deleted row for the purposes of <b>IRowset::GetData</b> (if <i>fOverwrite</i> is TRUE) or for <b>GetLastVisibleData</b> (if <i>fOverwrite</i> is FALSE).</p>
<p>
If <b>RefreshVisibleData</b> encounters an error while attempting to refresh a row, such as a bad row handle, it notes the error in *<i>prgRowStatus</i>, continues processing, and returns DB_S_ERRORSOCCURRED or DB_E_ERRORSOCCURRED. Although the rows are refreshed in undefined order, the ordering of *<i>prgRowStatus</i> must match the order of the row handle array, so the consumer can perform a side-by-side scan of each array to determine which rows were not refreshed.</p>
<p>
If <i>cRows</i> is zero and <i>pcRowsRefreshed</i> and <i>prghRowsRefreshed</i> are not null pointers, <b>RefreshVisibleData</b> adds to the reference count of the rows it returns in *<i>prghRowsRefreshed</i> to ensure that the consumer has these row handles.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowres_2v6p.htm">IRowsetRefresh::GetLastVisibleData</a></p>
</font></BODY>
</HTML>
