<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Structure of Integrated Indexes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbstructure_of_integrated_indexes"></a>Structure of Integrated Indexes</h1>
<p>
The structure of a nonintegrated index rowset is rigidly defined: The key columns of the index occur in order and there is a separate column—not column 0—that contains the bookmarks that point to the base table rowset.</p>
<p>
These restrictions do not apply to rowsets with integrated indexes. Forcing the key columns to occur in order could force the rowset to reorder the rowset columns each time the consumer changes the current index, an unacceptable result. The separate column of bookmarks pointing to base tables is not needed, as was explained earlier in this chapter in "Using Integrated Indexes."</p>
<p>
To determine which columns are key columns and the order in which they occur, the consumer calls <b>IRowsetIndex::GetIndexInfo</b>. The provider returns an array of DBINDEXCOLUMNDESC structures with the DBIDs of the key columns and the key types (ascending or descending) of each column. The arrays are returned in order from most significant to least significant. To determine the ordinals of the key columns, the consumer calls <b>IColumnsInfo::MapColumnIDs</b> with the returned DBIDs.</p>
</font></BODY>
</HTML>
