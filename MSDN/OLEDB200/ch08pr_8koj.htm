<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Indexes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbindexes"></a>Overview of Indexes</h1>
<p>
An OLE DB index, also known as an <i>index rowset</i>, is a rowset built over an index in a data source. It is generally used in conjunction with a rowset built over a base table in the same data source. Each row of the index rowset contains a bookmark that points to a row in the base table rowset. Thus, the consumer can traverse the index rowset and use it to access rows in the base table rowset. This chapter discusses the interfaces, use, and structure of an index rowset. Index structures comprise either of two types: one or more columns that form a key value, or a column containing a bookmark. An index example is also provided.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=603>
<tr valign=top>
<td class=label width=50%><b>For more information on</b></td>
<td class=label width=50%><b>Go to</b></td>
</tr>
<tr valign=top>
<td width=50%>Data source</td>
<td width=50%>“<a href="ch01pr_26b7.htm">OLE DB Components</a>” in Chapter 1, “Overview of OLE DB”</td>
</tr>
<tr valign=top>
<td width=50%>Rowset</td>
<td width=50%>Chapter 4, “<a href="ch04pr_3sdv.htm">Rowsets</a>” </td>
</tr>
<tr valign=top>
<td width=50%>Bookmark</td>
<td width=50%>“<a href="ch04pr_9h6b.htm">Bookmarks</a>” in Chapter 4, “Rowsets”</td>
</tr>
<tr valign=top>
<td width=50%>Structure</td>
<td width=50%>“<a href="ch08pr_7kdv.htm">Structure of Index Rowsets</a>” in this chapter</td>
</tr>
<tr valign=top>
<td width=50%>Use of indexes</td>
<td width=50%>“<a href="ch08pr_562b.htm">Using Index Rowsets</a>” in this chapter</td>
</tr>
<tr valign=top>
<td width=50%>Example provided</td>
<td width=50%>“<a href="ch08pr_40rp.htm">Index Example</a>” in this chapter</td>
</tr>
</table><br>
<p>
Indexes:</p>
<pre><code>CoType TIndex {
   [mandatory] interface IAccessor;
   [mandatory] interface IColumnsInfo;
   [mandatory] interface IConvertType;
   [mandatory] interface IRowset;
   [mandatory] interface IRowsetIndex;
   [mandatory] interface IRowsetInfo;
   [optional]&nbsp; interface IRowsetChange;
   [optional]&nbsp; interface IRowsetFind;
   [optional]&nbsp; interface IRowsetIdentity;
   [optional]&nbsp; interface IRowsetLocate;
   [optional]&nbsp; interface IRowsetRefresh;
   [optional]&nbsp; interface IRowsetScroll;
   [optional]&nbsp; interface IRowsetUpdate;
   [optional]&nbsp; interface IRowsetView;
   [optional]&nbsp; interface ISupportErrorInfo;
};
</code></pre>
<p>
The primary consumer for the <b>IRowsetIndex</b> interface is a query processor component that uses it during query execution. Although an SQL provider can expose <b>IRowsetIndex</b> by translating <b>IRowsetIndex</b> methods into SQL statements, this is not efficient. Instead, typical consumers of SQL providers should use the <b>ICommand</b> interface as the primary data access mechanism and rely on the query processor in the SQL provider to optimize access to data.</p>
<p>
The primary index interface, <b>IRowsetIndex</b>, exposes the functionality required by file access methods based on ISAM and B+-trees. It does not support functionality, such as hashing, required by unordered indexes; R+-trees, required by access methods for spatial data; or signature files, required by access methods for text.</p>
<p>
Index rowsets can be used in the following situations:
<ul type=disc>
<li>
Reading records efficiently by means of a key, which is one or more columns whose values identify a row. The following are example SQL queries whose execution plans can exploit the capabilities of the <b>IRowsetIndex</b> interface:<ul type=disc>
<li>
Retrieving rows ordered by some column. For example, <b>SELECT * FROM Table ORDER BY Table.x</b>, where x is indexed.<br><br></li>
<li>
Scanning records having a column value within a continuous range. For example, <b>SELECT * FROM Table WHERE Table.x BETWEEN 4 AND 20</b>.<br><br></li>
<li>
Computing joins. For example, <b>SELECT * FROM R INNER JOIN S ON R.x = S.x</b>.<br><br></li>
<li>
Retrieving distinct rows. For example, <b>SELECT DISTINCT R.x FROM R</b>, where R.x is indexed.<br><br></li>
<li>
Positioning at a particular index entry, such as skipping over key entries within a range.</li>
</ul>
</li>
<li>
Supporting indexes with multicolumn keys. The values in each column can be in ascending or descending order.<br><br></li>
<li>
Traversing indexes in ascending or descending order to support <b>ORDER BY</b> clauses.</li>
</ul>
</font></BODY>
</HTML>
