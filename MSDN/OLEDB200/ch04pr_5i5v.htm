<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Comparing Bookmarks</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbcomparing_bookmarks"></a>Comparing Bookmarks</h1>
<p>
The optimal way to compare bookmarks is by a direct memory comparison. However, some rowsets may include hints within the bookmark that depend on time or rowset generation. This might cause binary comparisons between two bookmarks for the same row to fail. If the provider does put hints in the bookmarks, they must expose <b>IRowsetLocate</b>, which has methods to compare two bookmarks and to return a stable hash value for a bookmark. If the provider does put hints in the bookmarks, it must be able to support <b>IRowsetLocate</b>, if requested, in order to compare two bookmarks and return a stable hash value for a bookmark.</p>
<p>
If the DBPROP_LITERALBOOKMARKS property is VARIANT_TRUE, then consumers can do the comparison themselves. The method used depends on the scalar type of the bookmark. For example, if the bookmark was defined as a sequence of DBTYPE_BYTES, then the comparison is of unsigned bytes, with the most-significant byte in position 0.</p>
<p>
Bookmarks can be compared only if they belong to the same rowset and are used within the lifetime of that rowset. The results of comparing bookmarks from different rowsets, or outside the lifetime of the rowset to which they belong, are undefined.</p>
<p>
A consumer does not need an ordered query to have ordered bookmarks. In particular, it does not need an SQL <b>ORDER BY</b> clause. If a consumer requests <b>SELECT * FROM &lt;table-name&gt;</b> and the smart query processor delivers the scan in the least-cost physical seek order (meaningless ordering in terms of content), then the consumer may still be given a rowset with ordered bookmarks. To guarantee ordered bookmarks, the consumer specifies the DBPROP_ORDEREDBOOKMARKS property as VARIANT_TRUE in <b>ICommandProperties::SetProperties</b>. For some providers, bookmarks are always ordered.</p>
<p>
If DBPROP_ORDEREDBOOKMARKS is VARIANT_TRUE, the order of the bookmarks reflects the order of delivery. That is, if the consumer has bookmark <i>i</i> &lt; <i>j</i>, then it calls <b>IRowsetLocate::GetRowsAt</b> for bookmark <i>i</i> and keeps scanning. It is guaranteed to find <i>j</i> unless it is deleted; and if it is deleted, the consumer can see the gap in order as it passes it by. Conversely, if the consumer starts at <i>j</i> and scans forward, it never sees <i>i</i>. It just reaches the end of the rowset.</p>
</font></BODY>
</HTML>
