<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IDBInfo::GetLiteralInfo</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbidbinfo__getliteralinfo"></a>IDBInfo::GetLiteralInfo</h1>
<p>
Returns information about literals used in text commands, <b>ITableDefinition</b>, <b>IIndexDefinition</b>, and <b>IOpenRowset</b>, or any interface that takes DBIDs as arguments.</p>
<pre><code>HRESULT GetLiteralInfo(
   ULONG                  cLiterals,
   const DBLITERAL         rgLiterals[],
   ULONG *                  pcLiteralInfo,
   DBLITERALINFO **   prgLiteralInfo,
   OLECHAR **            ppCharBuffer);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>cLiterals</i></p>
<p class=indent>
[in]<br>
The number of literals being asked about. If this is 0, the provider ignores <i>rgLiterals</i> and returns information about all of the literals it supports.</p>
<p class=dt>
<i>rgLiterals</i></p>
<p class=indent>
[in]<br>
An array of <i>cLiterals</i> literals about which to return information. If the consumer specifies an invalid DBLITERAL value in this array, <b>GetLiteralInfo</b> returns FALSE in <i>fSupported</i> in the corresponding element of the *<i>prgLiteralInfo</i> array.</p>
<p class=tl>
If <i>cLiterals</i> is 0, this parameter is ignored.</P><p class=dt>
<i>pcLiteralInfo</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of literals for which information was returned. If <i>cLiterals</i> is 0, this is the total number of literals supported by the provider. If an error other than DB_E_ERRORSOCCURRED occurs, *<i>pcLiteralInfo</i> is set to 0.</p>
<p class=dt>
<i>prgLiteralInfo</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return a pointer to an array of DBLITERALINFO structures. One structure is returned for each literal. The provider allocates memory for the structures and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the structures. If *<i>pcLiteralInfo</i> is 0 on output or an error other than DB_E_ERRORSOCCURRED occurs, the provider does not allocate any memory and ensures that *<i>prgLiteralInfo</i> is a null pointer on output. For information about DBLITERALINFO structures, see the Comments section.</p>
<p class=dt>
<i>ppCharBuffer</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return a pointer for all string values (<i>pwszLiteralValue</i>, <i>pwszInvalidChars</i>, and <i>pwszInvalidStartingChars</i>) within a single allocation block. The provider allocates this memory and the consumer releases it with <b>IMalloc::Free</b> when it no longer needs it. If *<i>pcLiteralInfo</i> is 0 on output or an error occurs, the provider does not allocate any memory and ensures that *<i>ppCharBuffer</i> is a null pointer on output. Each of the individual string values stored in this buffer is terminated by a null-termination character. Therefore, the buffer may contain one or more strings, each with its own null-termination character, and may contain embedded null-termination characters.</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. In each structure returned in *<i>prgLiteralInfo</i>, the <i>fSupported</i> element is set to TRUE.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
<i>rgLiterals</i> contained at least one unsupported or invalid literal. In the structures returned in *<i>prgLiteralInfo</i> for unsupported or invalid literals, the <i>fSupported</i> element is set to FALSE.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>cLiterals</i> was not equal to zero and <i>rgLiterals</i> was a null pointer.</p>
<p class=tl>
<i>pcLiteralInfo</i>, <i>prgLiteralInfo</i>, or <i>ppCharBuffer</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return the DBLITERALINFO structures or the strings containing the valid and starting characters.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
The data source object was in an uninitialized state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
All literals were either invalid or unsupported. The provider allocates memory for *<i>prgLiteralInfo</i> and sets the value of the <i>fSupported</i> element in all of the structures to FALSE. The consumer frees this memory when it no longer needs the information.</p>
<p class=label>
<b>Comments</b></p>
<p>
In the context of <b>GetLiteralInfo</b>, a literal is one of several things:
<ul type=disc>
<li>
A special character or characters used by text commands, such as the character used to quote identifiers. <b>GetLiteralInfo</b> returns the character or characters.<br><br></li>
<li>
A literal data value, such as a character literal in an SQL statement. For such literal data values, <b>GetLiteralInfo</b> returns the maximum length of the literal in characters, a list of the characters that cannot be used in the literal, and a list of the characters that cannot be used as the first character of the literal.<br><br></li>
<li>
The name of a database object such as a column or table. For such names, <b>GetLiteralInfo</b> returns the maximum length of the name in characters, a list of the characters that cannot be used in the name, and a list of the characters that cannot be used as the first character of the name.</li>
</ul>
<p>
Information about literals is returned in the DBLITERALINFO structure:</p>
<pre><code>typedef struct tagDBLITERALINFO {
 LPOLESTR&nbsp; pwszLiteralValue;
 LPOLESTR&nbsp; pwszInvalidChars;
 LPOLESTR&nbsp; pwszInvalidStartingChars;
 DBLITERAL lt;
 BOOL&nbsp;&nbsp;&nbsp; fSupported;
 ULONG&nbsp;&nbsp; cchMaxLen;
} DBLITERALINFO;
</code></pre>
<p>
The elements of this structure are used as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=31%><b>Element</b></td>
<td class=label width=69%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=31%><i>pwszLiteralValue</i></td>
<td width=69%>A pointer to a string in the *<i>ppCharBuffer</i> buffer containing the actual literal value.<p>
For example, if <i>lt</i> is DBLITERAL_LIKE_PERCENT, and the percent character (%) is used to match zero or more characters in a LIKE clause, this would be "%". This is used for DBLITERAL_CATALOG_SEPARATOR, DBLITERAL_ESCAPE_PERCENT_PREFIX, DBLITERAL_ESCAPE_UNDERSCORE_PREFIX, DBLITERAL_LIKE_PERCENT, DBLITERAL_LIKE_UNDERSCORE, DBLITERAL_QUOTE_PREFIX, and DBLITERAL_SCHEMA_SEPARATOR. For all other DBLITERAL values, <i>pwszLiteralValue</i> is not used and is set to a null pointer.</p>
</td>
</tr>
<tr valign=top>
<td width=31%><i>pwszInvalidChars</i></td>
<td width=69%>A pointer to a string in the *<i>ppCharBuffer</i> buffer containing the characters that are not valid in the literal.<p>
For example, if table names can contain anything other than a numeric character, this would be "0123456789" when <i>lt</i> is DBLITERAL_TABLE_NAME. If the literal can contain any valid character, this is a null pointer. This is not used for DBLITERAL_BINARY_LITERAL, DBLITERAL_CATALOG_SEPARATOR, DBLITERAL_ESCAPE_PERCENT_PREFIX, DBLITERAL_ESCAPE_UNDERSCORE_PREFIX, DBLITERAL_LIKE_PERCENT, DBLITERAL_LIKE_UNDERSCORE, DBLITERAL_QUOTE_PREFIX, and DBLITERAL_SCHEMA_SEPARATOR; <i>pwszInvalidChars</i> is set to a null pointer for these DBLITERAL values.</p>
</td>
</tr>
<tr valign=top>
<td width=31%><i>pwszInvalidStartingChars</i></td>
<td width=69%>A pointer to a string in the *<i>ppCharBuffer</i> buffer containing the characters that are not valid as the first character of the literal. If the literal can start with any valid character, this is a null pointer.<p>
For example, if table names can begin with anything other than a numeric character, this would be "0123456789" when <i>lt</i> is DBLITERAL_TABLE_NAME. This is not used for DBLITERAL_BINARY_LITERAL, DBLITERAL_CATALOG_SEPARATOR, DBLITERAL_ESCAPE_PERCENT_PREFIX, DBLITERAL_ESCAPE_UNDERSCORE_PREFIX, DBLITERAL_LIKE_PERCENT, DBLITERAL_LIKE_UNDERSCORE, DBLITERAL_QUOTE_PREFIX, and DBLITERAL_SCHEMA_SEPARATOR; <i>pwszInvalidStartingChars</i> is set to a null pointer for these DBLITERAL values.</p>
</td>
</tr>
<tr valign=top>
<td width=31%><i>lt</i></td>
<td width=69%>The literal described in the structure. For more information, see the following section.</td>
</tr>
<tr valign=top>
<td width=31%><i>fSupported</i></td>
<td width=69%>TRUE if the provider supports the literal specified by <i>lt</i>. If <i>cLiterals</i> is 0, this is always TRUE, because <b>GetLiteralInfo</b> only returns information about literals it supports in this case.<p>
FALSE if the provider does not support the literal; or the value of the corresponding element of the <i>rgLiterals</i> array was not a valid value in the DBLITERAL enumerated type.</p>
</td>
</tr>
<tr valign=top>
<td width=31%><i>cchMaxLen</i></td>
<td width=69%>The maximum number of characters in the literal. If there is no maximum or the maximum is unknown, <i>cchMaxLen</i> is set to ~0 (bitwise, the value is not 0; that is, all bits are set to 1). For DBLITERAL_CATALOG_SEPARATOR, DBLITERAL_ESCAPE_PERCENT_PREFIX, DBLITERAL_ESCAPE_UNDERSCORE_PREFIX, DBLITERAL_LIKE_PERCENT, DBLITERAL_LIKE_UNDERSCORE, DBLITERAL_QUOTE_PREFIX, and DBLITERAL_SCHEMA_SEPARATOR, this is the actual number of characters in the literal.</td>
</tr>
</table><br>
<p>
The following values of DBLITERAL are supported.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=34%><b>Value</b></td>
<td class=label width=66%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_INVALID</td>
<td width=66%>An invalid value.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
BINARY_LITERAL</td>
<td width=66%>A binary literal in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
CATALOG_NAME</td>
<td width=66%>A catalog name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
CATALOG_SEPARATOR</td>
<td width=66%>The character that separates the catalog name from the rest of the identifier in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
CHAR_LITERAL</td>
<td width=66%>A character literal in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
COLUMN_ALIAS</td>
<td width=66%>A column alias in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
COLUMN_NAME</td>
<td width=66%>A column name used in a text command or in a data-definition interface.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
CORRELATION_NAME</td>
<td width=66%>A correlation name (table alias) in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
CURSOR_NAME</td>
<td width=66%>A cursor name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
ESCAPE_PERCENT_PREFIX</td>
<td width=66%>The character used in a <b>LIKE</b> clause to escape the character returned for the DBLITERAL_LIKE_PERCENT literal. For example, if a percent sign (%) is used to match zero or more characters and this is a backslash (\), the characters "abc\%%" match all character values that start with "abc%".</td>
</tr>
<tr valign=top>
<td width=34%></td>
<td width=66%>Some SQL dialects support a clause (the <b>ESCAPE</b> clause) that can be used to override this value.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_ESCAPE_PERCENT_SUFFIX</td>
<td width=66%>The escape character, if any, used to suffix the character returned for the DBLITERAL_LIKE_PERCENT literal. For example, if a percent sign (%) is used to match zero or more characters, and percent signs are escaped by enclosing in open and close square brackets, DBLITERAL_ESCAPE_PERCENT_PREFIX is "[", DBLITERAL_ESCAPE_PERCENT_SUFFIX is "]", and the characters "abc[%]%" match all character values that start with "abc%". Providers that do not use a suffix character to escape the DBLITERAL_ESCAPE_PERCENT character do not return this literal value, and set the <i>lt</i> member of the DBLITERAL structure to DBLITERAL_INVALID if requested.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
ESCAPE_UNDERSCORE_PREFIX</td>
<td width=66%>The character used in a <b>LIKE</b> clause to escape the character returned for the DBLITERAL_LIKE_UNDERSCORE literal. For example, if an underscore (_) is used to match exactly one character and this is a backslash (\), the characters "abc\_&nbsp;_" match all character values that are five characters long and start with "abc_".<p>
Some SQL dialects support a clause (the <b>ESCAPE</b> clause) that can be used to override this value.</p>
</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX</td>
<td width=66%>The escape character, if any, used to suffix the character returned for the DBLITERAL_LIKE_UNDERSCORE literal. For example, if an underscore (_) is used to match exactly one character, and underscores are escaped by enclosing in open and close square brackets, DBLITERAL_ESCAPE_UNDERSCORE_PREFIX is "[", DBLITERAL_ESCAPE_UNDERSCORE_SUFFIX is "]", and the characters "abc[_]_" match all character values that are five characters long and start with "abc_". Providers that do not use a suffix character to escape the DBLITERAL_ESCAPE_UNDERSCORE character do not return this literal value, and set the <i>lt</i> member of the DBLITERAL structure to DBLITERAL_INVALID if requested.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
INDEX_NAME</td>
<td width=66%>An index name used in a text command or in a data-definition interface.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
LIKE_PERCENT</td>
<td width=66%>The character used in a <b>LIKE</b> clause to match zero or more characters. For example, if this is a percent sign (%), the characters "abc%" match all character values that start with "abc".</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
LIKE_UNDERSCORE</td>
<td width=66%>The character used in a <b>LIKE</b> clause to match exactly one character. For example, if this is an underscore (_), the characters "abc_" match all character values that are four characters long and start with "abc".</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
PROCEDURE_NAME</td>
<td width=66%>A procedure name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
SCHEMA_NAME</td>
<td width=66%>A schema name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
SCHEMA_SEPARATOR</td>
<td width=66%>The character that separates the schema name from the rest of the identifier in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
TABLE_NAME</td>
<td width=66%>A table name used in a text command or in a data-definition interface.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
TEXT_COMMAND</td>
<td width=66%>A text command, such as an SQL statement.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
USER_NAME</td>
<td width=66%>A user name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_<br>
VIEW_NAME</td>
<td width=66%>A view name in a text command.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_QUOTE_PREFIX</td>
<td width=66%>The character used in a text command as the opening quote for quoting identifiers that contain special characters.</td>
</tr>
<tr valign=top>
<td width=34%>DBLITERAL_QUOTE_SUFFIX</td>
<td width=66%>The character used in a text command as the closing quote for quoting identifiers that contain special characters. 1.x providers that use the same character as the prefix and suffix may not return this literal value, and set the <i>lt</i> member of the DBLITERAL structure to DBLITERAL_INVALID if requested.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note&nbsp; </b></B> If a provider returns non-NULL CATALOG or SCHEMA column values in schema rowsets, then it must support <b>IDBInfo</b> to describe how a fully qualified name is assembled. A provider that does not support <b>IDBInfo</b> must return NULL values for CATALOG and SCHEMA columns in all schema rowsets.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="dbinfo_2m0j.htm">IDBInfo::GetKeywords</a>, <a href="dbprop_3vzn.htm">IDBProperties::GetProperties</a></p>
</font></BODY>
</HTML>
