<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Reference Accessors</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbreference_accessors"></a>Reference Accessors</h1>
<p>
A special type of accessor, called a <i>reference accessor</i>, enables consumers to get rowset data directly from the provider's buffer and providers to get input parameter data directly from the consumer's buffer. You cannot use these accessors with output parameters or when setting row data.</p>
<p>
Reference accessors require the consumer to have prior knowledge of the provider's buffer layout; the consumer cannot discover this information at run time. Because of this, reference accessors are designed for use by tightly coupled consumer/provider pairs. Because they allow direct access to the provider's buffers, providers are not required to support them. Consumers determine whether providers support reference accessors through the DBPROP_BYREFACCESSORS property.</p>
<p>
To use reference accessors, the layout of the consumer's buffer must exactly match the layout of the provider's buffer. That is, both buffers must allocate space for the same parts (data value, length, and status), these parts must appear at the same offset in both buffers, the data value parts must have the same type and buffer length in both buffers, and so on. If the provider's buffer does not contain length or status parts, the consumer cannot bind these parts, and must determine length and whether the data value is NULL in the same manner as the provider.</p>
<p>
To use a reference accessor, the consumer passes the handle of the accessor and a pointer to a buffer to the provider. For rowset data, the provider returns a pointer to its internal buffer in the buffer supplied by the consumer. The consumer then dereferences this pointer and reads directly from the provider's buffer. For input parameter data, the consumer's buffer contains a pointer to the buffer that actually contains the data. The provider dereferences this pointer and reads directly from the consumer's other buffer.</p>
<p>
For example, the following code shows how a consumer would read data directly from the provider's buffer using a reference accessor:
<ol>
<li>
Assume that the consumer already has a pointer to <b>IAccessor</b> on a rowset (pIAccessor) and a pointer to <b>IRowset</b> on the same rowset (pIRowset).<pre><code>void *&nbsp; pv;
ULONG&nbsp;&nbsp; cRowsObtained;
HACCESSOR hReferenceAccessor;
HROW&nbsp; rghRows[1];
DBBINDING rgBindings[5];</code></pre>
</li>
</ol>
<pre></pre>
<ol start=2>
<li>
Fill in the <b>rgBinding</b> array. The bindings must match the layout of the provider's buffer.<br><br></li>
<li>
Create a reference accessor.<pre><code>pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA | DBACCESSOR_PASSBYREF, 5, rgBindings, 0, &amp;hReferenceAccessor, NULL);</code></pre>
</li>
</ol>
<pre></pre>
<ol start=4>
<li>
Get a row.<pre><code>pIRowset-&gt;GetNextRows(NULL, 0, 1, &amp;cRowsObtained, rghRows);</code></pre>
</li>
</ol>
<pre></pre>
<ol start=5>
<li>
Get a pointer to the start of the provider's buffer for the row.<pre><code>pIRowset-&gt;GetData(rghRows[0], hReferenceAccessor, &amp;pv);</code></pre>
</li>
</ol>
<pre></pre>
<ol start=6>
<li>
Access the data in the provider's buffer, starting at the address *pv. (Code not shown.)</li>
</ol>
<pre></pre>
<p>
The pointer returned by the provider, for rowset data, or passed by the consumer, for input parameter data, does not need to point to the start of the buffer. The only requirement is that the relative offsets of the elements stored in the buffer match the offsets specified in the accessor. The consumer, for rowset data, or provider, for input parameter data, must not write to this buffer, nor can it free this buffer.</p>
<p>
For rowset data, the pointer is guaranteed to remain valid until the consumer calls <b>IRowsetChange::SetData</b>, <b>IRowsetChange::DeleteRows</b>, <b>IRowsetRefresh::RefreshVisibleData</b>, <b>IRowsetUpdate::Undo</b>, or <b>IRowsetUpdate::Update</b> for the row, calls <b>IRowset::ReleaseRows</b> for the row and the reference count falls to zero, or releases the rowset. For input parameter data, the pointer is guaranteed to remain valid only until <b>ICommand::Execute</b> returns.</p>
</font></BODY>
</HTML>
