<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowset</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowset"></a>IRowset</h1>
<p>
<b>IRowset</b> is the base rowset interface. It provides methods for fetching rows sequentially, getting the data from those rows, and managing rows.</p>
<p>
<b>IRowset</b> requires <b>IAccessor</b> and <b>IRowsetInfo</b>.</p>
<h1>When to Implement</h1>
<p>
<b>IRowset</b> is required for all providers that support general consumers.</p>
<h1>When to Call</h1>
<p>
Consumers use the methods in <b>IRowset</b> for all basic rowset operations, including fetching and releasing rows and getting column values.</p>
<p>
When a consumer first gets an interface pointer on a rowset, usually its first step is to determine the rowset's capabilities using <b>IRowsetInfo::GetProperties</b>. This returns information about the interfaces exposed by the rowset as well as those capabilities of the rowset which do not show up as distinct interfaces, such as the maximum number of active rows and how many rows can have pending updates at the same time.</p>
<p>
For most consumers, the next step is to determine the characteristics, or metadata, of the columns in the rowset. For this they use either <b>IColumnsInfo</b> or <b>IColumnsRowset</b>, for simple or extended column information, respectively. These interfaces are also available on prepared commands prior to execution, allowing advance planning.</p>
<p>
The consumer determines which columns it needs, either from the metadata or on the basis of knowing the text command that generated the rowset. It determines the ordinals of the needed columns from the ordering of the column information returned by <b>IColumnsInfo</b> or from ordinals in the column metadata rowset returned by <b>IColumnsRowset</b>.</p>
<p>
Some consumers do not use a command or do not want to browse the column information: they may know the name or property identifier for the columns they want to use. They call <b>IColumnsInfo</b>::<b>MapColumnIDs</b> to retrieve the column ordinals.</p>
<p>
The ordinals are used to specify a binding to a column. A binding is a structure that associates an element of the consumer's structure with a column. The binding can bind the column's data value, length, and status value. For more information about bindings, see "<a href="ch06pr_03zn.htm">Bindings</a>" in chapter 6.</p>
<p>
A set of bindings is gathered together in an <i>accessor</i>, which is created with <b>IAccessor::CreateAccessor</b>. An accessor can contain multiple bindings so that the data for multiple columns can be retrieved or set in a single call. The consumer can create several accessors to match different usage patterns in different parts of the application. It can create and release accessors at any time while the rowset remains in existence. For more information about accessors, see "<a href="ch06pr_74kz.htm">Accessors</a>" in Chapter 6.</p>
<p>
To fetch rows from the database, the consumer calls a method such as <b>GetNextRows </b>or <b>IRowsetLocate::GetRowsAt</b>. To create and initialize a new row to be inserted into the data source, the consumer calls <b>IRowsetChange::InsertRow</b>.</p>
<p>
The methods that fetch rows do not actually return data to the consumer. Instead, they return the handles to these rows, and a local copy of the rows is stored in the rowset.</p>
<p>
After the rows are returned, the consumer can access the data in the rows. The consumer calls <b>GetData</b> and passes it the handle to a row, the handle to an accessor, and a pointer to a consumer-allocated buffer. <b>GetData</b> converts the data (if it does not match the native provider storage) and returns the columns as specified in the bindings used to create the accessor. The consumer can call <b>GetData</b> more than once for a row, using different accessors and buffers; thus, the consumer can have multiple copies of the same data. For example, if a column contains a text document, the consumer might call <b>GetData</b> with an accessor that binds the first 50 bytes of the document. When the user double-clicks on the displayed heading text, the consumer could then call <b>GetData</b> with a different accessor to retrieve the entire document.</p>
<p>
Data from variable-length columns may be treated several ways. First, such columns can be bound to a finite section of the consumer's structure, which causes truncation when the length of the data exceeds the length of the buffer. The consumer can determine that truncation has occurred by checking if the status is DBSTATUS_S_TRUNCATED. The returned length is always the true length in bytes, so the consumer also can determine how much data was truncated. Another way to obtain data from such columns is by reference. For example, if a binary column is bound with a type indicator of DBTYPE_BYTES | DBTYPE_BYREF, the provider allocates memory for all of the data in the column and returns this memory to the consumer.</p>
<p>
In both cases, it is likely that such large values may be best optimized as deferred columns and accessed only when necessary. Performance varies with different servers, but in general BLOB columns are stored separately from other records and may be more costly to access than ordinary columns, so they would not routinely be pulled in for browsing or scanning. For more information, see "<a href="ch04pr_4ewj.htm">Deferred Columns</a>" in Chapter 4.</p>
<p>
Another way to handle BLOB columns may be implemented on some providers, and that is to request they be delivered as OLE <b>ILockBytes</b>, <b>IStorage</b>, <b>ISequentialStream</b>, or <b>IStream</b> objects. For more information, see "<a href="ch07pr_3zlf.htm">BLOBs as Storage Objects</a>" in Chapter 7.</p>
<p>
For a description of how to update and delete rows, see Chapter 5, "<a href="ch05pr_96gj.htm">Updating Data in Rowsets</a>."</p>
<p>
When the consumer is finished fetching or updating rows, it releases them with <b>ReleaseRows</b>. This releases resources from the rowset's copy of the rows and makes room for new rows. The consumer can then repeat its cycle of fetching or creating rows and accessing the data in them.</p>
<p>
When the consumer is done with the rowset, it calls <b>IAccessor::ReleaseAccessor</b> to release any accessors. It calls <b>IUnknown::Release</b> on all interfaces exposed by the rowset to release the rowset. When the rowset is released, it forces the release of any remaining rows or accessors the consumer may hold. Such handle objects are subordinate to the rowset. That is, they do not take reference counts upon the rowset and cannot cause the rowset to linger beyond the point where all the interfaces for the rowset have been released. The rowset must clean up all such subordinate objects.</p>
<p class=indent>
<B><b>Note&nbsp; </b></B> If the rowset was generated as a result of executing a command that contained output parameters and the provider populates output parameters when the rowset is released (that is, DBPROP_OUTPUTPARAMETERAVAILABILITY is DBPROP_OA_ATROWRELEASE), the memory for the output parameters bound at <b>Execute</b> time must be valid when the rowset is released. Not doing so is considered a serious programming error and likely will cause a crash.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Method</b></td>
<td class=label width=75%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=25%><a href="rowset_6zlf.htm">AddRefRows</a></td>
<td width=75%>Adds a reference count to an existing row handle.</td>
</tr>
<tr valign=top>
<td width=25%><a href="rowset_64f5.htm">GetData</a></td>
<td width=75%>Retrieves data from the rowset's copy of the row.</td>
</tr>
<tr valign=top>
<td width=25%><a href="rowset_7z5f.htm">GetNextRows</a></td>
<td width=75%>Fetches rows sequentially, remembering the previous position.</td>
</tr>
<tr valign=top>
<td width=25%><a href="rowset_1v03.htm">ReleaseRows</a></td>
<td width=75%>Releases rows.</td>
</tr>
<tr valign=top>
<td width=25%><a href="rowset_1dm6.htm">RestartPosition</a></td>
<td width=75%>Repositions the next fetch position to its initial position; that is, its position when the rowset was first created.</td>
</tr>
</table><br>
</font></BODY>
</HTML>
