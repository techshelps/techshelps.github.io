<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Rowset with IOpenRowset</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbcreating_a_rowset_with_iopenrowset"></a>Creating a Rowset with IOpenRowset</h1>
<p>
Some providers need to expose very simple rowsets to their consumers. These rowsets represent the result set of the simple query <b>SELECT * FROM </b><i>table-name</i>. To allow providers to interpret this simple query without the overhead of supporting a complete query language, OLE DB provides a simple rowset interface, <b>IOpenRowset</b>. <b>IOpenRowset</b> effectively exposes a rowset in the absence of a command. <b>IOpenRowset</b> is implemented on the session as shown in the following figure.</p>
<p class=label>
<b>Getting a rowset directly from a session</b></p>
<p>
<img src="ch0401.gif" border=0></p>
<h1>Fully Qualified Names</h1>
<p>
A consumer may need to construct a fully qualified table name incorporating the names of the associated schema and catalog. To construct a fully qualified name, a consumer should follow these steps:</p>
<p class=tl>
If DBPROP_CATALOGLOCATION is DBPROPVAL_CL_START:</P><ol>
<li>
If DBLITERAL_CATALOG_NAME is not NULL (<i>fSupported</i> is TRUE in DBLITERALINFO), get the appropriate catalog name for the table (for instance, from the TABLES schema rowset) and append the value of DBLITERAL_CATALOG_SEPARATOR (<i>pwszLiteralValue</i> in DBLITERALINFO).<br><br></li>
<li>
If DBLITERAL_SCHEMA_NAME is not NULL (<i>fSupported</i> is TRUE in DBLITERALINFO), get the appropriate schema name for the table (for instance, from the TABLES schema rowset) and append the value of DBLITERAL_SCHEMA_SEPARATOR (<i>pwszLiteralValue</i> in DBLITERALINFO). Append this to the catalog information from the previous step.<br><br></li>
<li>
Append the object (table) name.</li>
</ol>
<p class=tl>
If DBPROP_CATALOGLOCATION is DBPROPVAL_CL_END:</P><ol>
<li>
If DBLITERAL_SCHEMA_NAME is not NULL (<i>fSupported</i> is TRUE in DBLITERALINFO), get the appropriate schema name for the table (for instance, from the TABLES schema rowset) and append the value of DBLITERAL_SCHEMA_SEPARATOR (<i>pwszLiteralValue</i> in DBLITERALINFO).<br><br></li>
<li>
Append the object (table) name.<br><br></li>
<li>
If DBLITERAL_CATALOG_NAME is not NULL (<i>fSupported</i> is TRUE in DBLITERALINFO), append the value of DBLITERAL_CATALOG_SEPARATOR (<i>pwszLiteralValue</i> in DBLITERALINFO) and the appropriate catalog name for the table (for instance, from the TABLES schema rowset).</li>
</ol>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If a DBLITERAL_QUOTE_* character is supported, the provider must support enclosing names/identifiers in this quote character (with each part of the name individually quoted—for example, "catalog"."schema"."table", not "catalog.schema.table"). If a DBLITERAL_QUOTE_* character is not supported, the consumer should not quote identifiers. In addition, a provider should not quote the information passed to it.</p>
</font></BODY>
</HTML>
