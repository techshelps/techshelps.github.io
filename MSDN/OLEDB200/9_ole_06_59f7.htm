<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Command Parameters</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="command_parameters"></a>Command Parameters</h1>
<p>
Parameters are marked in command text with the ODBC-specified question mark character. For example, the following ODBC SQL statement is marked for a single input parameter:</p>
<pre><code>{call SalesByCategory('Produce', ?)}
<b><i>  </i></b></code></pre>
<h3>Example</h3>
<p>
SQLOLEDB supports input parameters in SQL statement commands. On procedure-call commands, SQLOLEDB supports input, output, and input/output parameters. Output parameter values are returned to the application either on execution or when all returned rowsets are exhausted by the application. To ensure that returned values are valid, use <b>IMultipleResults</b> to force rowset consumption.</p>
<pre><code>// Macro used in the example.
#define COUNTRY_MAX_CHARS&nbsp;&nbsp;&nbsp;&nbsp; 15
<b><i>  </i></b>
// Structure supporting the parameters of the example stored procedure.
typedef struct tagSPROCPARAMS
  {
  long&nbsp;&nbsp;&nbsp; lReturnValue;
  char&nbsp;&nbsp;&nbsp; acCountry[COUNTRY_MAX_CHARS + 1];
  } SPROCPARAMS;
<b><i>  </i></b>
  // Interfaces used in the example.
  ICommandText*&nbsp;&nbsp; pICommandText = NULL;
  ICommandWithParameters* pICommandWithParameters = NULL;
  IAccessor*&nbsp;&nbsp;&nbsp; pIAccessor = NULL;
  IMultipleResults* pIMultipleResults = NULL;
  IRowset*&nbsp;&nbsp;&nbsp; pIRowset = NULL;
<b><i>  </i></b>
  // Command parameter data.
  DBPARAMS&nbsp;&nbsp;&nbsp; Params;
  const ULONG&nbsp;&nbsp; nParams = 2;
  DBPARAMBINDINFO&nbsp;&nbsp; rgParamBindInfo[nParams] = 
 &nbsp;&nbsp; {
 &nbsp;&nbsp; L"DBTYPE_I4",
 &nbsp;&nbsp; L"ReturnVal",
 &nbsp;&nbsp; sizeof(long),
 &nbsp;&nbsp; DBPARAMFLAGS_ISOUTPUT,
 &nbsp;&nbsp; 11,
 &nbsp;&nbsp; 0,
 &nbsp;&nbsp; L"DBTYPE_VARCHAR",
 &nbsp;&nbsp; L"@Country",
 &nbsp;&nbsp; COUNTRY_MAX_CHARS,
 &nbsp;&nbsp; DBPARAMFLAGS_ISINPUT,
 &nbsp;&nbsp; 0,
 &nbsp;&nbsp; 0 };
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; rgParamOrdinals[nParams] = {1,2};
<b><i>  </i></b>
  // Parameter accessor data.
  HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp; hAccessor;
  DBBINDING&nbsp;&nbsp;&nbsp;&nbsp; acDBBinding[nParams];
  DBBINDSTATUS&nbsp;&nbsp;&nbsp; acDBBindStatus[nParams];
<b><i>  </i></b>
  // The command and parameter data.
  WCHAR*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wszSQLString =
 &nbsp;&nbsp; L"{? = call CustomersInCountry(?)}";
  SPROCPARAMS&nbsp;&nbsp; sprocparams = {0, "USA"};
<b><i>  </i></b>
  // Returned count of rows affected.
  LONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected = 0;
<b><i>  </i></b>
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;
  
  // Create the command.
  if (FAILED(hr = pIDBCreateCommand-&gt;CreateCommand(NULL, 
 &nbsp;&nbsp; IID_ICommandText, (IUnknown**) &amp;pICommandText)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from IDBCreateCommand and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Set the command text value.
  if (FAILED(hr = pICommandText-&gt;SetCommandText(DBGUID_DBSQL,
 &nbsp;&nbsp; wszSQLString)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from ICommand and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Get the ICommandWithParameters interface to set up parameter
  // values.
  if (FAILED(hr = pICommandText-&gt;QueryInterface(
 &nbsp;&nbsp; IID_ICommandWithParameters,
 &nbsp;&nbsp; (void**) &amp;pICommandWithParameters)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from ICommand and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Set parameter information.
  if (FAILED(hr = pICommandWithParameters-&gt;SetParameterInfo(nParams, 
 &nbsp;&nbsp; rgParamOrdinals, rgParamBindInfo)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from ICommandWithParameters and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Create parameter accessor, but first set binding structures
  // to indicate the characteristics of each parameter.
  for (ULONG i = 0; i &lt; nParams; i++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; acDBBinding[i].obLength = 0;
 &nbsp;&nbsp; acDBBinding[i].obStatus = 0;
 &nbsp;&nbsp; acDBBinding[i].pTypeInfo = NULL;
 &nbsp;&nbsp; acDBBinding[i].pObject = NULL;
 &nbsp;&nbsp; acDBBinding[i].pBindExt = NULL;
 &nbsp;&nbsp; acDBBinding[i].dwPart = DBPART_VALUE;
 &nbsp;&nbsp; acDBBinding[i].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
 &nbsp;&nbsp; acDBBinding[i].dwFlags = 0;
 &nbsp;&nbsp; acDBBinding[i].bScale = 0;
 &nbsp;&nbsp; }
<b><i>  </i></b>
  acDBBinding[0].iOrdinal = 1;
  acDBBinding[0].obValue = offsetof(SPROCPARAMS, lReturnValue);
  acDBBinding[0].eParamIO = DBPARAMIO_OUTPUT;
  acDBBinding[0].cbMaxLen = sizeof(long);
  acDBBinding[0].wType = DBTYPE_I4;
  acDBBinding[0].bPrecision = 11;
<b><i>  </i></b>
  acDBBinding[1].iOrdinal = 2;
  acDBBinding[1].obValue = offsetof(SPROCPARAMS, acCountry);
  acDBBinding[1].eParamIO = DBPARAMIO_INPUT;
  acDBBinding[1].cbMaxLen = COUNTRY_MAX_CHARS;
  acDBBinding[1].wType = DBTYPE_STR;
  acDBBinding[1].bPrecision = 0;
<b><i>  </i></b>
  // Get the IAccessor interface, then create the accessor for
  // the defined parameters.
  pICommandWithParameters-&gt;QueryInterface(IID_IAccessor,
 &nbsp;&nbsp; (void**) &amp;pIAccessor);
<b><i>  </i></b>
  hr = pIAccessor-&gt;CreateAccessor(DBACCESSOR_PARAMETERDATA,
 &nbsp;&nbsp; nParams, acDBBinding, sizeof(SPROCPARAMS), &amp;hAccessor,
 &nbsp;&nbsp; acDBBindStatus);
  if (FAILED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from IAccessor and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Fill the DBPARAMS structure for the command execution.
  Params.pData = &amp;sprocparams;
  Params.cParamSets = 1;
  Params.hAccessor = hAccessor;
  
  // Execute the command.
  if (FAILED(hr = pICommandText-&gt;Execute(NULL, IID_IMultipleResults,
 &nbsp;&nbsp; &amp;Params, &amp;cRowsAffected, (IUnknown**) &amp;pIMultipleResults)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Process error from ICommand and return.
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // For each rowset or count of rows affected...
  do
 &nbsp;&nbsp; {
 &nbsp;&nbsp; hr = ((IMultipleResults*) pIResults)-&gt;GetResult(NULL, 0,
 &nbsp;&nbsp; IID_IRowset, &amp;cRowsAffected, (IUnknown**) &amp;pIRowset);
<b><i>  </i></b>
 &nbsp;&nbsp; switch (hr)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; case S_OK:
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; if (pIRowset != NULL)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Process data from the rowset and release.
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset-&gt;Release();
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else if (cRowsAffected != -1)
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Command succeeded. %ld rows affected.\n\n",
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRowsAffected);
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp;&nbsp;&nbsp; else
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("Command succeeded.\n\n");
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
<b><i>  </i></b>
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
<b><i>  </i></b>
 &nbsp;&nbsp; case DB_S_NORESULT:
 &nbsp;&nbsp; case DB_S_STOPLIMITREACHED:
 &nbsp;&nbsp;&nbsp;&nbsp; break;
<b><i>  </i></b>
 &nbsp;&nbsp; default:
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; DumpError(pIResults, IID_IMultipleResults);
 &nbsp;&nbsp;&nbsp;&nbsp; break;
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; }
  while (hr == S_OK);
<b><i>  </i></b>
  if (SUCCEEDED(hr))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // At this point, the value of the return is guaranteed correct.
 &nbsp;&nbsp; // If any other output parameters had been specified, then they
 &nbsp;&nbsp; // too would now contain their correct values.
 &nbsp;&nbsp; printf("Return value %d\n", sprocparams.lReturnValue);
 &nbsp;&nbsp; }
<b><i>  </i></b></code></pre>
<p>
The names of stored procedure parameters need not be specified in a DBPARAMBINDINFO structure. Use NULL for the value of the <i>pwszName</i> member to indicate that SQLOLEDB should ignore the parameter name and use only the ordinal specified in the <i>rgParamOrdinals</i> member of <b>ICommandWithParameters::SetParameterInfo</b>.</p>
<p>
If the name of a stored procedure parameter is specified, SQLOLEDB checks the name to ensure that it is valid. SQLOLEDB returns an error when it receives an erroneous parameter name from the consumer.</p>
</font></BODY>
</HTML>
