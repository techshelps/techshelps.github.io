<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetIndex::Seek</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetindex__seek"></a>IRowsetIndex::Seek</h1>
<p>
Allows direct positioning at a key value within the current range established by the <b>IRowsetIndex::SetRange</b> method.</p>
<pre><code>HRESULT Seek (
   HACCESSOR   hAccessor,
   ULONG         cKeyValues,
   void *            pData,
   DBSEEK         dwSeekOptions);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
The handle of the accessor to use. This accessor must meet the following criteria, which are illustrated with a key that consists of columns A, B, and C, where A is the most significant column and C is the least significant column:
<ul type=disc>
<li>
For each key column this accessor binds, it must also bind all more significant key columns. For example, the accessor can bind column A, columns A and B, or columns A, B, and C.<br><br></li>
<li>
Key columns must be bound in order from most significant key column to least significant key column. For example, if the accessor binds columns A and B, then the first binding must bind column A and the second binding must bind column B.<br><br></li>
<li>
If the accessor binds any non-key columns, key columns must be bound first. For example, if the accessor binds columns A, B, and the bookmark column, then the first binding must bind column A, the second binding must bind column B, and the third binding must bind the bookmark column.<p class=tl>
If the accessor does not meet these criteria, the method returns DB_E_BADBINDINFO or a status of DBSTATUS_E_BADACCESSOR for the offending column.</P><p class=tl>
If <i>hAccessor</i> is the handle of a null accessor (<i>cBindings</i> in <b>IAccessor::CreateAccessor</b> was zero), then <b>Seek</b> does not change the next fetch position.</P></li>
</ul>
<p class=dt>
<i>cKeyValues</i></p>
<p class=indent>
[in]<br>
The number of bindings in <i>hAccessor</i> for which *<i>pData</i> contains valid data. <b>SetRange</b> retrieves data from the first <i>cKeyValues</i> key columns from *<i>pData</i>. For example, suppose the accessor binds columns A, B, and C of the key in the previous example and <i>cKeyValues</i> is 2. <b>SetRange</b> retrieves data for columns A <br>
and B.</p>
<p class=dt>
<i>pData</i></p>
<p class=indent>
[in]<br>
A pointer to a buffer containing the key values to which to seek, at offsets that correspond to the bindings in the accessor.</p>
<p class=dt>
<i>dwSeekOptions</i></p>
<p class=indent>
[in]<br>
A bitmask describing the options for the <b>Seek</b> method. The values in DBSEEKENUM have the following meanings:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=29%><b>Value</b></td>
<td class=label width=71%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_FIRSTEQ</td>
<td width=71%>First key with values equal to the values in *<i>pData</i>.</td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_LASTEQ</td>
<td width=71%>Last key with values equal to the values in *<i>pData</i>.</td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_GE</td>
<td width=71%>First key with values greater than or equal to the values in *<i>pData</i>.</td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_GT</td>
<td width=71%>First key with values greater than the values in *<i>pData</i>.</td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_LE</td>
<td width=71%>First key with values less than or equal to the values in *<i>pData</i>.</td>
</tr>
<tr valign=top>
<td width=29%>DBSEEK_LT</td>
<td width=71%>First key with values less than the values in *<i>pData</i>.</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>dwSeekOptions</i> was invalid.</p>
<p class=tl>
<i>hAccessor</i> was the handle of a null accessor.</P><p class=tl>
<i>cKeyValues</i> was zero.</P><p class=tl>
<i>pData</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
An error occurred while transferring data for one or more key columns. To determine the columns for which values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOINDEX<br>
The rowset uses integrated indexes and there is no current index.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTFOUND<br>
No key value matching the described characteristics could be found within the current range.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor</b>:</p>
<p>
E_NOINTERFACE<br>
DB_E_BADBINDINFO<br>
DB_E_BADORDINAL<br>
DB_E_BADSTORAGEFLAGS<br>
DB_E_UNSUPPORTEDCONVERSION</p>
<p class=label>
<b>Comments</b></p>
<p>
The <b>Seek</b> method provides the caller more control over the traversal of an index. Consider a relational query processor component implementing a merge join over inputs R1 and R2. R1, the outer input, is a rowset ordered by the joining column R1.X. R2, the inner input, is an indexed rowset on column R2.X. Suppose that R1.X has values {10, 20, 100, 110} and that R2.X has values {10, 20, ..., 30, ..., 40, ..., 50, ..., 100, ...}, then when searching R2.X, one could seek directly from 20 to 100 knowing the values of the input R1.X. In some cases, this strategy could be cost effective.</p>
<p>
For information about how <b>Seek</b> transfers data from *<i>pData</i>, see "<a href="ch06pr_5iap.htm">Setting Data</a>" in Chapter 6.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowidx_7v6t.htm">IRowsetIndex::SetRange</a></p>
</font></BODY>
</HTML>
