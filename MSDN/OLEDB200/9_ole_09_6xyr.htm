<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Updating Data in SQL Server Cursors</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="updating_data_in_sql_server_cursors"></a>Updating Data in SQL Server Cursors</h1>
<p>
When fetching and updating data through SQL Server cursors, an SQLOLEDB consumer application is bound by the same considerations and constraints that apply to any other client application.</p>
<p>
Only rows in SQL Server cursors participate in concurrent data-access control. By default, SQLOLEDB uses optimistic concurrency control, SSPROPVAL_CONCUR_ROWVER, when the consumer requests a modifiable rowset. To alter the level of concurrent access control, the consumer sets the DBPROPSET_SQLSERVERROWSET SSPROP_CONCURRENCY value prior to opening the rowset.</p>
<p>
Transaction isolation levels can cause significant lags in row positioning if client application design allows transactions to remain open for long periods of time. By default, SQLOLEDB uses the read-committed isolation level specified by DBPROPVAL_TI_READCOMMITTED. SQLOLEDB supports dirty read isolation when the rowset concurrency is read-only. Therefore, the consumer can request a higher level of isolation in a modifiable rowset but cannot request any lower level successfully.</p>
<h3>Immediate and Delayed Update Modes</h3>
<p>
In immediate update mode, each call to <b>IRowsetChange::SetData</b> results in a roundtrip to the SQL Server. If the consumer makes multiple changes to a single row, it is more efficient to submit all changes with a single <b>SetData</b> call.</p>
<p>
In delayed update mode, a roundtrip is made to the SQL Server for each row indicated in the <i>cRows</i> and <i>rghRows</i> parameters of <b>IRowsetUpdate::Update</b>.</p>
<p>
In either mode, a roundtrip represents a distinct transaction when no transaction object is open for the rowset.</p>
<p>
When using <b>IRowsetUpdate::Update</b>, SQLOLEDB attempts to process each indicated row. An error occurring due to invalid data, length, or status values for any row does not stop SQLOLEDB processing. All other rows participating in the update may be modified or none may. The consumer must check the returned <i>prgRowStatus</i> array to determine failure for any specific row when SQLOLEDB returns DB_S_ERRORSOCCURED.</p>
<p>
A consumer should not assume that rows are processed in any specific order. If a consumer requires ordered processing of data modification over more than a single row, then the consumer should establish that order in application logic and open a transaction to enclose the process.</p>
</font></BODY>
</HTML>
