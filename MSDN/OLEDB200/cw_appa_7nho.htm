<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Working with Your ActiveX Control</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="workingwithyouractivexcontrol"></a>Working with Your ActiveX Control</h1>
<p>
Once your control is up and running, you can extend its functionality.</p>
<p>
In many ways, your control is much like a regular Windows program. Even if your control doesn't have a window (for example, it uses the windowless features of the ActiveX specification), you’re using a window process so you have to paint the client area yourself using regular windows-drawing APIs and handles to device contexts (DC).</p>
<p>
To declare your control, use either <b>DEFINE_CONTROLOBJECT</b> or <b>DEFINE_WINDOWLESSCONTROLOBJECT</b> in your control's header file. These structures are self-documenting, but two parameters are worth a little extra discussion.</p>
<p>
The first is the <i>dwActivationPolicy</i> parameter. The framework allows your control to take advantage of the delayed-activation features provided by <b>IPointerInactive</b>. If your control uses any of these, you should insert an activation policy into this field. By default, it is 0. Subclassed windows controls should not change this. Other control authors may wish to take advantage of this interface, and should consult the ActiveX specification for more information.</p>
<p>
The second parameter is a Boolean value passed in to the <b>DEFINE_WINDOWLESSCONTROL</b> macro, which indicates whether your control has any transparent regions. If this parameter is True, the host has to ensure that your control paints correctly in the z-order of things. If False, your control is required to paint its entire client area, but the host has to do a little less work.</p>
<h1>Structure of a Control</h1>
<p>
Every control in the framework must implement a core set of methods, based on creation semantics and methods that aren’t provided by <b>COleControl</b>. You may also want to override and provide an implementation for several routines. The following table notes many of these methods and routines.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=36%><b>Method/routine</b></td>
<td class=label width=64%><b>Discussion</b></td>
</tr>
<tr valign=top>
<td width=36%><b>static Create</b></td>
<td width=64%>The control wizard generates this routine for you. Every control must create its control object in this routine and then return a pointer to its private unknown (for aggregation support).</td>
</tr>
<tr valign=top>
<td width=36%><b>Constructor </b>and <b>Destructor</b></td>
<td width=64%>These are generated for you. You should minimize initializations in the constructor to prevent load time from degrading.</td>
</tr>
<tr valign=top>
<td width=36%><b>RegisterClassData</b></td>
<td width=64%>Required. Even if your control is windowless for the most part, a user may place your control in a host that doesn't support all of the ActiveX features, and the framework will be forced to create an HWND for your control. In this case, you will need a window class. This routine is called only the first time a control of the given type is loaded in a process in which it must have an HWND. Controls should register their window class (using <b>RegisterClass</b> and the WNDCLASS structure) here. In addition, subclassed windows controls should get a pointer to the parent control's <b>WindowProc</b> and set that up in the <b>g_ObjectInfo</b> table using the <b>SUBCLASSWNDPROCOFCONTROL</b> macro. Controls that are invisible at run time should return <b>FALSE</b> in this routine, because it should never get called.</td>
</tr>
<tr valign=top>
<td width=36%><b>BeforeCreateWindow</b> and <b>AfterCreateWindow</b></td>
<td width=64%>Optional. <b>BeforeCreateWindow</b> is called right before the call to <b>CreateWindow</b> if your control is windowed, but after persistent state has been loaded. Controls should use this opportunity to set the window title for their control in <i>m_szWindowTitle</i>, and can also set up bits in <i>pdwWindowStyle</i> and <i>pdwWindowStyleEx</i> parameters that are passed in. In addition, controls can set their initial caption here in the parameter passed in for this purpose. This does, however, have a limit as defined in <b>CreateInPlaceWindow</b> in Ctlmisc.cpp. Control writers should use this opportunity to set up these defaults as much as possible, as opposed to in the message handler for <b>WM_CREATE</b>, because it typically results in much better performance.</td>
</tr>
<tr valign=top>
<td width=36%><b>InternalQueryInterface </b></td>
<td width=64%>Your control implements this to support <b>QueryInterface</b> for the control's primary Automation interface, such as IMyControl. You can also use this method to support additional interfaces in your control. For example, if you want to support <b>IPerPropertyBrowsing</b>, set up your control's <b>CMyControl</b> class to inherit from <b>IPerPropertyBrowsing</b>, and support the <b>QueryInterface</b> for <b>IID_IPerPropertyBrowsing</b> in <b>InternalQueryInterface</b>. If the control fails the <b>QueryInterface</b>, then the control should delegate back to <b>COleControl::InternalQueryInterface</b> to see if it accepts the IID.</td>
</tr>
<tr valign=top>
<td width=36%><b>LoadTextState</b>, <b>LoadBinaryState</b>, <b>SaveTextState</b>, and <b>SaveBinaryState</b> </td>
<td width=64%>Required. All controls must implement these persistence routines. See “Persistence” later in this appendix for a discussion of these interfaces.</td>
</tr>
<tr valign=top>
<td width=36%><b>OnDraw </b></td>
<td width=64%>This routine is called when your control is expected to draw itself. At design time, this call originates from a container calling <b>IViewObject2::Draw</b>. At run time, the controls framework intercepts the <b>WM_PAINT</b> message and translates it into a call to your <b>OnDraw</b> routine. See “Painting a Control” later in this section for more information.</td>
</tr>
<tr valign=top>
<td width=36%><b>WindowProc</b> </td>
<td width=64%>Messages that are not handled in the framework code (such as <b>SimpleFrame</b> messages and <b>WM_PAINT</b>) are sent to your control here. Your control should deal with these messages here. See “Handling Messages in a Control” later in this section for a discussion of this routine.</td>
</tr>
<tr valign=top>
<td width=36%><b>OnSpecialKey</b> </td>
<td width=64%>Messages for various keyboard events, such as moving cursor keys, function keys, and other nonstandard keys, do not go to the <b>WindowProc</b>. Instead, they are sent to the <b>OnSpecialKey</b> routine. If you want your control to handle special keys and accelerators, you should override and implement this routine. The control should return <b>TRUE</b> if it handles a key, or <b>FALSE</b> if it ignores the key.</td>
</tr>
<tr valign=top>
<td width=36%><b>DoCustomVerb</b> </td>
<td width=64%>If your control implements custom verbs in addition to the default property page verb (provided your control has a property page), you should implement this routine and take appropriate action depending on what verb was sent in. Return <b>OLEOBJ_S_INVALIDVERB</b> if you don't recognize the verb given.</td>
</tr>
<tr valign=top>
<td width=36%><b>OnSetExtent</b> </td>
<td width=64%>This is called every time your control is resized. The m_Size SIZEL structure is your control's current size in pixels. Controls should look in here for size information and override <b>OnSetExtent</b> if they want to control how their control is sized.</td>
</tr>
<tr valign=top>
<td width=36%><b>OnQuickActivate</b> </td>
<td width=64%>This routine is called if your control is in a host that supports quick activation and has used <b>IQuickActivate::QuickActivate</b> to activate your control. Your control is given a pointer to a QACONTAINER structure, and should examine the data in it. A nontrivial number of ambients are passed to the control in this way and will save later calls to <b>GetAmbientProperty</b>. See the documentation for <b>IQuickActivate</b> in the ActiveX specification for more information.</td>
</tr>
</table><br>
<p>
In addition, the following methods and routines can be called by an ActiveX control, and often prove to be extremely useful.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=36%><b>Method/routine</b></td>
<td class=label width=64%><b>Discussion</b></td>
</tr>
<tr valign=top>
<td width=36%><b>DoSuperClassPaint</b> </td>
<td width=64%>Subclassed window controls can call this from their <b>OnDraw</b> routines to paint themselves. For most window controls, this routine paints them correctly in design time and run time. Some Windows controls, however, require more attention.</td>
</tr>
<tr valign=top>
<td width=36%><b>RecreateControlWindow</b> </td>
<td width=64%>Used for subclassed controls; re-creates the control's hWnd. This is useful if the control is changing a style bit that can't be changed with a SetWindowLong(GWL_STYLE ...) call.</td>
</tr>
<tr valign=top>
<td width=36%><b>DesignMode</b></td>
<td width=64%>Returns a Boolean value indicating its best guess as to whether the environment is in design mode. If it can't figure it out, it returns False.</td>
</tr>
<tr valign=top>
<td width=36%><b>GetAmbientProperty</b></td>
<td width=64%>Gets an ambient property from the container. Not all containers return these (they might not support them), so be careful to check the return code.</td>
</tr>
<tr valign=top>
<td width=36%><b>GetAmbientFont</b></td>
<td width=64%>Gets the current ambient font. A container may not implement this. Controls are encouraged to look for the ambient font in the QACONTAINER structure passed in to <b>OnQuickActivate</b>. Avoid calling <b>GetAmbientFont</b> to save time. Don't forget to release the font once you're finished with it.&nbsp; </td>
</tr>
<tr valign=top>
<td width=36%><b>ModalDialog</b></td>
<td width=64%>Controls must call <b>ModalDialog</b> before they show a modal dialog box. You can see this when the control is about to show its <b>About Box</b> dialog box.</td>
</tr>
<tr valign=top>
<td width=36%><b>InvalidateControl</b></td>
<td width=64%>Forces a control to be repainted if you pass in NULL for the rectangle, or invalidates the given area if it's not NULL. This is similar to the <b>InvalidateRect</b> API, but also operates in design mode.</td>
</tr>
<tr valign=top>
<td width=36%><b>SetControlSize</b></td>
<td width=64%>Controls that change their size out of <b>OnSetExtent</b> should use this routine to set their size. The control passes in a SIZEL structure in pixels and expects a call to <b>OnSetExtent</b>. Be careful of some recursive situations.</td>
</tr>
<tr valign=top>
<td width=36%><b>PropertyChanged</b></td>
<td width=64%>Whenever the value of a property changes, this routine should be called to notify a host. This causes the host to update any property browsers (such as those in Microsoft Visual Basic 5.0).</td>
</tr>
<tr valign=top>
<td width=36%><b>RequestPropertyEdit</b></td>
<td width=64%>Whenever a control wants to change a property that is marked as <b>requestedit</b> in the .odl file, the control must call this first and check the return code (<b>TRUE</b> or <b>FALSE</b>).</td>
</tr>
<tr valign=top>
<td width=36%><b>GetResourceHandle</b></td>
<td width=64%>Controls should call this whenever they're loading a resource that could be localized. This routine gets the handle to the appropriate DLL and deals with satellite DLLs or the lack thereof. </td>
</tr>
<tr valign=top>
<td width=36%><b>FireEvent</b></td>
<td width=64%>A control passes this routine an EVENTINFO structure, and an event as described in the EVENTINFO is fired. The control also passes parameters to this routine because it is a <b>varargs</b> method.</td>
</tr>
<tr valign=top>
<td width=36%><b>ControlFromUnknown</b></td>
<td width=64%>Property page code often finds it useful to get the <b>COleControl</b> * pointer from the <b>IUnknown</b> for a control object. This routine does just that.</td>
</tr>
<tr valign=top>
<td width=36%><b>Exception </b></td>
<td width=64%>Your control, or any Automation object, can use this to send the user an error message. See “Throwing an Exception” later in this section for more information about using this routine.</td>
</tr>
</table><br>
<p>
Windowless controls that want to support windowless in-place activation have routines they must call instead of the Win32<sup>®</sup> APIs to get the correct functionality. The following is a list of the Win32 functions and their replacements.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=50%><b>Win32 function</b></td>
<td class=label width=50%><b>Replacement function</b></td>
</tr>
<tr valign=top>
<td width=50%><b>GetFocus</b></td>
<td width=50%><b>OcxGetFocus</b>. Returns a Boolean value indicating whether the control has keyboard focus.</td>
</tr>
<tr valign=top>
<td width=50%><b>SetFocus</b></td>
<td width=50%><b>OcxSetFocus</b>. Takes a Boolean parameter indicating whether you want to take the focus or give it up.</td>
</tr>
<tr valign=top>
<td width=50%><b>GetCapture</b></td>
<td width=50%><b>OcxGetCapture</b>. Indicates whether or not you have the keyboard capture.</td>
</tr>
<tr valign=top>
<td width=50%><b>SetCapture</b></td>
<td width=50%><b>OcxSetCapture</b>.<b> </b>Used to ask for or release the keyboard capture.</td>
</tr>
<tr valign=top>
<td width=50%><b>GetDC/ReleaseDC</b></td>
<td width=50%><b>OcxGetDC</b> and <b>OcxReleaseDC</b>. Provides this functionality for windowless controls.</td>
</tr>
<tr valign=top>
<td width=50%><b>InvalidateRect</b></td>
<td width=50%><b>OcxInvalidateRect</b>. Lets you force a repaint of your control.</td>
</tr>
</table><br>
<p>
These routines all work correctly if your control has an HWND. If you don’t intend for your control to work without an HWND, then you can safely use the regular Win32 APIs.</p>
<h1>Painting a Control</h1>
<p>
The <b>OnDraw</b> routine is called whenever the control needs to paint. Sometimes the origin of the call is <b>IViewObject2::Draw</b> (as in design mode), and other times it comes from being sent a <b>WM_PAINT</b> message (as handled in <b>ControlWindowProc</b>).</p>
<p>
Your control is given a device context (DC), a rectangle to describe where to paint, a rectangle for describing a metafile, and an Information Context (IC, passed in as an HDC) that describes the device. If the device is a metafile, the control must do a little different work. However, if the device is a raster display, the control typically paints to the screen.</p>
<p>
Your control must be careful not to make any assumptions about the device context, except that it will be in <b>MM_TEXT</b> mapping mode. Often, there are no default pens, brushes, fonts, or colors selected into the device context. Your control has to do this work itself. This typically means your control will look slightly different in design and run modes.</p>
<p>
If the <i>fOptimize</i> parameter passed in is <b>TRUE</b>, then the control writer can take advantage of the optimizations described in the ActiveX specification for not fully cleaning up the device context on exit. Writers are still responsible for deleting GDI objects they create and load, but they can leave things selected in the device context on exit if this parameter is <b>TRUE</b>. See the ActiveX specification for more information.</p>
<p>
Finally, the <i>dvAspect</i> parameter is passed in to the <b>OnDraw</b> routine. This is used for multipass drawing, as described in the ActiveX specification (<b>IViewObjectEx</b>).&nbsp; Authors not wishing to support multipass drawing should ignore this parameter; the default setting does not support it.</p>
<h1>Handling Messages in a Control</h1>
<p>
Your control has a method called <b>WindowProc</b>, which is called whenever a message is sent to your control. Your control should respond to messages here. If your control has an HWND, try to reduce the amount of work that is done in the <b>WM_CREATE</b> message handler; instead, try to place it in <b>BeforeCreateWindow</b>.</p>
<p>
For certain types of messages, such as keyboard messages for arrow keys and other special keys, your <b>WindowProc</b> routine is not called. <b>OnSpecialKey</b> is called instead. The code in <b>OnSpecialKey</b> should look for <b>WM_KEYDOWN</b>, <b>WM_KEYUP</b>, <b>WM_CHAR</b>, and other messages, and handle them appropriately.</p>
<p>
A certain class of messages typically involves notifying a window about events that are usually sent to a window's parent. These include <b>WM_COMMAND</b>, <b>WM_NOTIFY</b>, and <b>WM_CTLCOLOR</b>. These messages are reflected by the host to your control in the form of <b>OCM_COMMAND</b>, <b>OCM_NOTIFY</b>, and <b>OCM_CTLCOLOR</b>. Your controls should look for these messages instead of WM_ messages. See Olectl.h for other OCM_ messages of interest to the control. This discussion does not apply to windowless controls.</p>
<h1>Adding a Property</h1>
<p>
One of the more important parts of a control is often its set of properties. When you create a control with the wizard, you have no properties by default. Adding them is relatively simple.</p>
<p>
First, modify the primary dispatch interface for your control in the .odl file. For example, you may have a control called SuperScroll, and you want to add a <b>LargeChange</b> method to the control. You would add the following to the <b>ISuperScroll</b> interface description in the .odl:</p>
<pre><code>&nbsp;[id(DISPID_LARGECHANGE), propget, helpstring("The largechange property")]
   HRESULT LargeChange([out, retval] long *plLargeChange);
 [id(DISPID_LARGECHANGE), propput]
   HRESULT LargeChange([in] long lLargeChange);
</code></pre>
<p>
Next, you define DISPID_LARGECHANGE in dispids.h. You then regenerate the type library (.tlb) file by typing this: <b>make SuperScroll.tlb</b></p>
<p>
This also regenerates SuperScrollInterfaces.h. You can then cut and paste the following two lines from SuperScrollInterfaces.h:</p>
<pre><code>STDMETHOD(get_LargeChange)(THIS_ long FAR* plLargeChange) PURE;
STDMETHOD(put_LargeChange)(THIS_ long lLargeChange) PURE;
</code></pre>
<p>
Finally, take these two lines and add them to your class description for <b>CSuperScroll</b>, and make sure that you remove the PURE declarators at the end. For example:</p>
<pre><code>STDMETHOD(get_LargeChange)(long FAR* plLargeChange);
STDMETHOD(put_LargeChange)(long lLargeChange);
</code></pre>
<p>
You can now implement these methods in your control file to implement your property.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>A few standard dispids are defined for you in olectl.h. Whenever you want to declare a property, look in this header first to see if there is a standard dispid for it.</p>
<h1>Adding a Method</h1>
<p>
Adding a method is much like adding a property to your control.&nbsp; </p>
<p>
First, you define a dispid for the method. Once you've done that, it's as simple as adding the method to the primary interface for your control. Controls generated with the control wizard already have an <b>About</b> method defined for them.&nbsp; </p>
<p>
As an example, define a method called <b>MooCow</b> with three parameters, the last of which is optional. Here is one such method:</p>
<pre><code>&nbsp;[id(DISPID_MOOCOW), helpstring("Makes your Cow moo")]
   HRESULT MooCow([in] long lSeconds, [in] boolean fLowPitch,
         [in, optional] VARIANT vPitch);
</code></pre>
<p>
Again, as with properties, you regenerate the type library and then paste the declaration into your control header (without the PURE declarator) and implement it.</p>
<h1>Adding an Event</h1>
<p>
In many situations, you may want your control to fire an event. For example, when a control gets a <b>WM_LBUTTONDOWN</b> message, it often makes sense to fire a MouseDown event. This turns out to be easy.</p>
<p>
First, you must define the event in an EVENTINFO structure. There are many ways to do this, including declaring a new global variable for each event type or using an array; an array is neater and is discussed here. Say you want to have KeyDown, KeyUp, and KeyPushed events.</p>
<p>
Here's how you might declare them:</p>
<pre><code>typedef enum {
   MyCtlEvent_KeyDown = 0,
   MyCtlEvent_KeyUp = 1,
   MyCtlEvent_KeyPushed = 2
} MYCTLEVENTS;

VARTYPE rgI2 [] = { VT_I2 };

EVENTINFO m_rgMyCtlEvents [] = {
   { DISPID_KEYDOWN, 1, rgI2 },
   { DISPID_KEYUP, 1, rgI2 },
   { DISPID_KEYPUSHED, 1, rgI2 }
};
</code></pre>
<p>
The EVENTINFO structure has three members: the dispid of the event, the count of arguments in the event, and a pointer to an array of <b>VARTYPE</b> that describes the types of the parameters to the event. Remember, there are dispids defined for you in Olectl.h; whenever you're adding an event, check there first to see if adispid exists for it.</p>
<p>
To fire these events from code, just call the following:</p>
<pre><code>FireEvent(&amp;(m_rgMyCtlEvents[MyCtlEvent_KeyDown]), sKeyValue);
</code></pre>
<h1>Using Standard ActiveX Types</h1>
<p>
For many controls, you may find it useful to declare properties of types provided by OLE, such as Font, Picture, and Color. Many hosts detect properties of these types and put up convenient browsers for the user to select values for these types.</p>
<p>
To declare a property of one of these types, you must first make sure its .odl file includes the following at the top:</p>
<pre><code>importlib(STDTYPE_TLB);
</code></pre>
<p>
Then, to declare a property of type<b> </b>Font, Picture, or Color, your code would be similar to the following, depending on the type:</p>
<pre><code>[id(DISPID_FONT), propget]
   HRESULT Font([out, retval] IFontDisp **ppFont);
[id(DISPID_FONT), propputref]
   HRESULT Font([in] IFontDisp *pFont);

[id(DISPID_MOUSEICON), propget]
   HRESULT MouseIcon([out, retval] IPictureDisp **ppMouseIcon);
[id(DISPID_MOUSEICON), propputref]
   HRESULT MouseIcon([in] IPictureDisp *pMouseIcon);

[id(DISPID_FORECOLOR), propget]
   HRESULT ForeColor([out, retval] OLE_COLOR *pocForeColor);
[id(DISPID_FORECOLOR), propput]
   HRESULT ForeColor([in] OLE_COLOR ocForeColor);
</code></pre>
<p>
For the get_ and put_ methods for these types, the control gets a property as declared above. For fonts and pictures, the control probably will use <b>QueryInterface</b> for <b>IFont </b>and <b>IPicture</b>, respectively. </p>
<p>
For your control to use a font object, the control typically calls the <b>get_hFont</b> method and passes the resulting HFONT to the control's device context. It handles pictures in much the same way. For fuller descriptions of using these fonts in your application, see the Microsoft Developer Network (MSDN).</p>
<p>
To use a color, the control calls <b>OleTranslateColor</b> to convert it to a real <b>COLORREF</b>. An <b>OLE_COLOR</b> is basically a <b>COLORREF</b> with some support for "generic" colors, such as <b>COLOR_WINDOW</b> and <b>COLOR_WINDOWTEXT</b>. To convert one of these into an <b>OLE_COLOR</b>, just join it in a logical OR (|)with 0x80000000. For example, to initialize the control's background to <b>COLOR_WINDOW</b>, set the <b>backcolor</b> property to <code>COLOR_WINDOW | 0x80000000</code>. Then, to paint the backdrop, just call <b>OleTranslateColor</b> and use the resulting <b>COLORREF</b>.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>The framework uses dual/vtable bound Automation interfaces, and uses Automation functionality to support <b>IDispatch</b> methods on the Automation objects. </p>
<h1>Throwing an Exception</h1>
<p>
Every once in a while, during an operation, your control may need to communicate problems to the user. It does so by throwing an exception. In any of the control's Automation methods or property operators, the control can call the <b>Exception</b> method when exiting, and the method sets up all the appropriate information to trigger the error.</p>
<p>
For example:</p>
<pre><code>CMyControl::put_Appearance(long lAppearance)
{
   if (lAppearance == 10)
      return Exception(MYCTL_E_INVALIDPROPERTYVALUE, IDS_ERR_INVALIDPROPERTYVALUE, 0);
   m_lAppearance = lAppearance;
   return S_OK;
}
</code></pre>
<p>
The arguments to the <b>Exception</b> routine are as follows: the first is the SCODE of the error the control wants to trigger. For errors unique to the control, you should define them like so:</p>
<pre><code>#define MYCTL_E_INVALIDPROPERTYVALUE MAKE_SCODE(SEVERITY_ERROR, FACILITY_CONTROL, 34500)
</code></pre>
<p>
The second argument is the resource identifier of the string that the control should display. The <b>Exception</b> code correctly gets this information from the control's localized satellite DLL.</p>
<p>
The last argument is the <i>helpcontextid</i> that is passed to the help file that is defined in your control's structure.</p>
</font></BODY>
</HTML>
