<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IColumnsInfo::GetColumnInfo</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbicolumnsinfo__getcolumninfo"></a>IColumnsInfo::GetColumnInfo</h1>
<p>
Returns the column metadata needed by most consumers.</p>
<pre><code>HRESULT GetColumnInfo (
   ULONG *                  pcColumns,
   DBCOLUMNINFO **   prgInfo,
   OLECHAR **            ppStringsBuffer);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>pcColumns</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of columns in the rowset; this number includes the bookmark column, if there is one. If <b>GetColumnInfo</b> is called on a command that does not return rows, *<i>pcColumns</i> is set to zero. If this method terminates due to an error, *<i>pcColumns</i> is set to zero.</p>
<p class=dt>
<i>prgInfo</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of DBCOLUMNINFO structures. One structure is returned for each column in the rowset. The provider allocates memory for the structures and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the column information. If *<i>pcColumns</i> is 0 on output or terminates due to an error, the provider does not allocate any memory and ensures that *<i>prgInfo</i> is a null pointer on output. For more information, see "DBCOLUMNINFO Structures" in the Comments section.</p>
<p class=dt>
<i>ppStringsBuffer</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return a pointer to storage for all string values (names used either within <i>columnid</i> or for *<i>pwszName</i>) within a single allocation block. If no returned columns have either form of string name, or if this method terminates due to error, this parameter returns a null pointer. If there are any string names, then this will be a buffer containing all the values of those names. The consumer should free the buffer with <b>IMalloc::Free</b> when finished working with the names. If *<i>pcColumns</i> is zero on output, the provider does not allocate any memory and ensures that *<i>ppStringsBuffer</i> is a null pointer on output. Each of the individual string values stored in this buffer is terminated by a null-termination character. Therefore, the buffer may contain one or more strings, each with its own null-termination character, and may contain embedded null-termination characters.</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pcColumns</i>, <i>prgInfo</i>, or <i>ppStringsBuffer</i> was a null pointer.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return the column information structures.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state. This error can be returned only when the method is called on a rowset.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSINCOMMAND<br>
The command text contained one or more errors. Providers should use OLE DB error objects to return details about the errors.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOCOMMAND<br>
No command text was set. This error can be returned only when this method is called from the Command object.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTPREPARED<br>
The command exposed <b>ICommandPrepare</b> and the command text was set, but the command was not prepared. This error can be returned only when this method is called from the Command object.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to retrieve the column information.</p>
<p class=label>
<b>Comments</b></p>
<p>
This function makes no logical change to the state of the object.</p>
<p>
<b>GetColumnInfo</b> returns a fixed set of column metadata in an array of DBCOLUMNINFO structures, one per column. The returned metadata is that most commonly used by consumers, such as the data type and column ID.</p>
<p>
The order of the structures is the order in which the columns appear in the rowset (column ordinal order). This is the same order as they appear in <b>IColumnsRowset</b>, and is predictable from the ordering of requested columns in the command text.</p>
<p>
Bookmark columns may be returned on any rowset, regardless of its source (for example, <b>ICommand::Execute</b>, <b>IOpenRowset::OpenRowset</b>, <b>IColumnsRowset::GetColumnsRowset</b>, or <b>IDBSchemaRowset::GetRowset</b>) or whether bookmarks were requested. When bookmarks are returned, they will always appear as the first element of *<i>prgInfo</i> with <i>iOrdinal</i> equal to zero. When processing the columns returned by <b>GetColumnInfo</b>, generic consumers should be prepared to receive and handle bookmark columns appropriately (that is, not display them to the user if not appropriate for the application).</p>
<p>
<b>GetColumnInfo</b> provides a quick alternative to <b>GetColumnsRowset</b>. While <b>GetColumnsRowset</b> returns all available column metadata, it does so in a rowset. To get the metadata, the consumer must therefore create the column metadata rowset, create one or more accessors, fetch each row in the rowset, and get the data from the rowset.</p>
<p>
Calling <b>GetColumnInfo</b> on a command before the command is executed may be an expensive operation.</p>
<h1>DBCOLUMNINFO Structures</h1>
<p>
<b>GetColumnInfo</b> returns column metadata in DBCOLUMNINFO structures.</p>
<pre><code>typedef struct tagDBCOLUMNINFO {
 LPOLESTR&nbsp; pwszName;
 ITypeInfo * pTypeInfo;
 ULONG&nbsp;&nbsp; iOrdinal;
 DBCOLUMNFLAGS dwFlags;
 ULONG&nbsp;&nbsp; ulColumnSize;
 DBTYPE&nbsp;&nbsp;&nbsp; wType;
 BYTE&nbsp;&nbsp;&nbsp; bPrecision;
 BYTE&nbsp;&nbsp;&nbsp; bScale;
 DBID&nbsp;&nbsp;&nbsp; columnid;
} DBCOLUMNINFO;
</code></pre>
<p>
The elements of this structure are used as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=20%><b>Element</b></td>
<td class=label width=80%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=20%><i>pwszName</i></td>
<td width=80%>Pointer to the name of the column; this might not be unique. If this cannot be determined, a null pointer is returned.<p>
The name can be different from the string part of the column ID if the column has been renamed by the command text. This name always reflects the most recent renaming of the column in the current view or command text.</p>
</td>
</tr>
<tr valign=top>
<td width=20%><i>pTypeInfo</i></td>
<td width=80%>Reserved for future use. Providers should return a null pointer in <i>pTypeInfo</i>.</td>
</tr>
<tr valign=top>
<td width=20%><i>iOrdinal</i></td>
<td width=80%>The ordinal of the column. This is zero for the bookmark column of the row, if any. Other columns are numbered starting from one.</td>
</tr>
<tr valign=top>
<td width=20%><i>dwFlags</i></td>
<td width=80%>A bitmask that describes column characteristics. The DBCOLUMNFLAGS enumerated type specifies the bits in the bitmask. For more information, see the following section.</td>
</tr>
<tr valign=top>
<td width=20%><i>ulColumnSize</i></td>
<td width=80%>The maximum possible length of a value in the column. For columns that use a fixed-length data type, this is the size of the data type. For columns that use a variable-length data type, this is one of the following:<ul type=disc>
<li>
The maximum length of the column in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if one is defined. For example, a CHAR(5) column in an SQL table has a maximum length of 5.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=20%></td>
<td width=80%><ul type=disc>
<li>
The maximum length of the data type in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if the column does not have a defined length.<p>
For data types that do not have a length, this is set to ~0 (bitwise, the value is not 0; that is, all bits are set to 1).
</li>
<li>
~0 (bitwise, the value is not 0; that is, all bits are set to 1) if neither the column nor the data type has a defined maximum length.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=20%><i>wType</i></td>
<td width=80%>The indicator of the column's data type. If the data type of the column varies from row to row, this must be DBTYPE_VARIANT. For a list of valid type indicators, see "<a href="appapr_9nub.htm">Type Indicators</a>" in Appendix A.</td>
</tr>
<tr valign=top>
<td width=20%><i>bPrecision</i></td>
<td width=80%>If <i>wType</i> is a numeric data type, this is the maximum precision of the column. The precision of columns with a data type of DBTYPE_DECIMAL or DBTYPE_NUMERIC depends on the definition of the column. For the precision of all other numeric data types, see "<a href="appapr_04hf.htm">Precision of Numeric Data Types</a>" in Appendix A.<p>
For DBTYPE_DBTIMESTAMP data types, this is the length of the string representation (assuming the maximum allowed precision of the fractional seconds component).</p>
<p>
If the column's data type is not numeric or datetime, this is ~0 (bitwise, the value is not 0; that is, all bits are set to 1).</p>
</td>
</tr>
<tr valign=top>
<td width=20%><i>bScale</i></td>
<td width=80%>If <i>wType</i> is DBTYPE_DECIMAL or DBTYPE_NUMERIC, this is the number of digits to the right of the decimal point. Otherwise, this is ~0 (bitwise, the value is not 0; that is, all bits are set to 1).<p>
For DBTYPE_DBTIMESTAMP data types, this is the length of the string representation of the fractional seconds component.</p>
</td>
</tr>
<tr valign=top>
<td width=20%><i>columnid</i></td>
<td width=80%>The column ID of the column.<p>
The column ID of a base table should be invariant under views.</p>
<p>
For more information, see "Column IDs," Chapter 4.</p>
</td>
</tr>
</table><br>
<h1>DBCOLUMNFLAGS Enumerated Type</h1>
<p>
The <i>dwFlags</i> element of the DBCOLUMNINFO structure is a bitmask that describes column characteristics. The DBCOLUMNFLAGS enumerated type specifies the bits in the bitmask; the meanings of these values are as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=32%><b>Value</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
CACHEDEFERRED</td>
<td width=68%>Set if, when a deferred column is first read, its value is cached by the provider. Later reads of the column are done from this cache. The contents of the cache can be overwritten by <b>IRowsetChange::SetData</b> or <b>IRowsetRefresh::RefreshVisibleData</b>. The cached value is released when the row handle is released. Otherwise, not set.<p>
This flag can be set through the DBPROP_CACHEDEFERRED property in the Rowset property group.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISBOOKMARK</td>
<td width=68%>Set if the column contains a bookmark. Otherwise, not set.</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISCHAPTER</td>
<td width=68%>Set if the column contains a chapter value. Otherwise, not set.</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISFIXEDLENGTH</td>
<td width=68%>Set if all data in the column has the same length.&nbsp; Otherwise, not set.<p>
The flag is always set for fixed length data types except DBTYPE_BSTR. The flag is set for variable-length data types (DBTYPE_STR, DBTYPE_WSTR, DBTYPE_BSTR, and DBTYPE_BYTES) if all the values are the same length. The flag is set for DBTYPE_VECTOR or DBTYPE_ARRAY columns if all elements in each vector or array are of the same length and each vector or array has the same number of elements. Otherwise, the flag is not set.</p>
<p>
The flag is not affected by DBTYPE_BYREF.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISLONG</td>
<td width=68%>Set if the column contains a BLOB that contains very long data. The definition of very long data is provider-specific. The setting of this flag corresponds to the value of the IS_LONG column in the PROVIDER_TYPES schema rowset for the data type.<p>
When this flag is set, the provider supports reading the value through a storage interface. Although such BLOBs can be retrieved in a single piece with <b>IRowset::GetData</b>, there may be provider-specific problems in doing so. For example, the BLOB might be truncated due to machine limits on memory or <b>GetData</b> might fail if called more than once for the BLOB. Furthermore, when this flag is set, the provider might not be able to accurately return the maximum length of the BLOB data in <i>ulColumnSize</i> in the DBCOLUMNINFO structure.</p>
<p>
When this flag is not set, the BLOB can be accessed directly through <b>GetData</b>. It is provider-specific whether columns without this flag can be read through a storage interface.</p>
<p>
For more information, see "<a href="ch07pr_47dt.htm">Accessing BLOB Data</a>" in Chapter 7.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISNULLABLE</td>
<td width=68%>Set if the column can be set to NULL or if the provider cannot determine whether or not the column can be set to NULL. Otherwise, not set. This reflects only declarative rules. DBCOLUMNFLAGS_ISNULLABLE is generally used by consumers attempting to set data to determine whether or not a particular column might be able to hold a null value.</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISROWID</td>
<td width=68%>Set if the column contains a persistent row identifier that cannot be written to and has no meaningful value except to identify the row.</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
ISROWVER</td>
<td width=68%>Set if the column contains a timestamp or other versioning mechanism that cannot be written to directly and that is automatically updated to a new, increasing value when the row is updated and committed. The data type of a version column is provider-specific. How a version column is used—for example, how two version values are compared—is also provider-specific.</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
MAYBENULL</td>
<td width=68%>Set if NULL can be gotten from the column, or if the provider cannot guarantee that NULLs cannot be gotten from the column. Otherwise, not set. DBCOLUMNFLAGS_MAYBENULL is generally used by consumers reading data to determine whether or not they might encounter a null value. When DBCOLUMNINFO is returned in the COLUMNS rowset, DBCOLUMNFLAGS_MAYBENULL should not be set if a simple select over the single column of that table would return no null values.<p>
DBCOLUMFLAGS_MAYBENULL can be set even if DBCOLUMNFLAGS_ISNULLABLE is not set. For example, in a left outer join, if there is no row on the right side that matches a row on the left side, the columns from the right side in the joined row contain NULLs, even if the underlying columns are non-nullable; that is, if DBCOLUMNFLAGS_ISNULLABLE is not set.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
MAYDEFER</td>
<td width=68%>Set if the column is deferred. Otherwise, not set.<p>
A deferred column is one for which the data is not fetched from the data source until the consumer attempts to get it. That is, the data is not fetched when the row is fetched, but when <b>IRowset::GetData</b> is called. This flag can be set through the DBPROP_DEFERRED property in the Rowset property group.</p>
<p>
For more information, see "<a href="ch04pr_4ewj.htm">Deferred Columns</a>" in Chapter 4.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
WRITE</td>
<td width=68%>Set if <b>IRowsetChange::SetData</b> can be called for the column. Otherwise, not set.<p>
This flag can be set through the DBPROP_MAYWRITECOLUMN property in the Rowset property group.</p>
<p>
Providers never set both DBCOLUMNFLAGS_WRITE and DBCOLUMNFLAGS_WRITEUNKNOWN; they are mutually exclusive. Absence of these flags means the column is read-only.</p>
</td>
</tr>
<tr valign=top>
<td width=32%>DBCOLUMNFLAGS_<br>
WRITEUNKNOWN</td>
<td width=68%>Set if it is not known whether <b>IRowsetChange::SetData</b> can be called for the column.<p>
Providers never set both DBCOLUMNFLAGS_WRITE and DBCOLUMNFLAGS_WRITEUNKNOWN; they are mutually exclusive. Absence of these flags means the column is read-only.</p>
</td>
</tr>
</table><br>
<p class=label>
<b>See Also</b></p>
<p>
<a href="colrow_83p0.htm">IColumnsRowset::GetColumnsRowset</a>, <a href="colinf_8msz.htm">IColumnsInfo::MapColumnIDs</a>, <a href="rowinf_1pgz.htm">IRowsetInfo::GetProperties</a></p>
</font></BODY>
</HTML>
