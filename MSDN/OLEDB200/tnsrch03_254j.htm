<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Preserving State During UI Operations</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="preservingstateduringuioperations"></a>Preserving State During UI Operations</h1>
<p>
Many graphical user interface (GUI) OLAP tools do the following:
<ul type=disc>
<li>
Create a dataset based on some initial criteria.<br><br></li>
<li>
Enable the user to “operate” on the dataset by using UI operations such as drill down and drill up.</li>
</ul>
<p>
The brute-force way to accommodate such UI operations is to recreate the MDX query by going into the axis expressions. This is not only cumbersome, but can also be inefficient. MDX provides a powerful and simple alternative.</p>
<p>
The idea is to represent each axis expression as a named set. When the user does roll upand drill downs, functions such as <b>DRILLDOWNMEMBER</b>, <b>DRILLDOWNLEVEL</b>, or <b>DRILLDOWNMEMBER</b> can be used on the named set. That way, the application does not have to peek into the axis expression and modify it.</p>
<p>
For example, consider the dataset described in the section “Cube and Dataset Example” of chapter 2. By using named sets, the MDX statement for this dataset looks like this:</p>
<pre><code>CREATE SalesCube.ColumnsAxisSet AS 
  CROSSJOIN({Venkatrao, Netz},
  {USA_North.CHILDREN, USA_South, Japan})
CREATE SalesCube.RowsAxisSet AS 
  {Qtr1.CHILDREN, Qtr2, Qtr3, Qtr4.CHILDREN}
SELECT ColumnsAxisSet ON COLUMNS, RowsAxisSet ON ROWS
FROM SalesCube
WHERE (Sales, [1991], Products.All)
</code></pre>
<p>
Now, suppose that the user drills down on Qtr2. This operation can be expressed easily by using the following MDX statement (which occurs in the same session, so the named sets ColumnsAxisSet and RowsAxisSet are still visible and alive):</p>
<pre><code>SELECT 
  DRILLDOWNMEMBER(ColumnsAxisSet, {Qtr2}) ON COLUMNS, 
  RowsAxisSet ON ROWS
FROM SalesCube
WHERE (Sales, [1991], Products.All)
</code></pre>
<p>
Now the user drills up on Qtr1, which can be expressed by </p>
<pre><code>SELECT 
  DRILLUPMEMBER(DRILLDOWNMEMBER(ColumnsAxisSet, 
 &nbsp;&nbsp; {Qtr2}), {Qtr1}) ON COLUMNS, 
 &nbsp;&nbsp; RowsAxisSet ON ROWS
FROM SalesCube
WHERE (Sales, [1991], Products.All)
</code></pre>
<p>
Essentially, using named sets provides a way to preserve the state of the dataset when it was created. Further operations on the dataset can be modeled as set function calls on these named sets.</p>
</font></BODY>
</HTML>
