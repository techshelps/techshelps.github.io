<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating SQL Server Tables</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="creating_sql_server_tables"></a>Creating SQL Server Tables</h1>
<p>
SQLOLEDB exposes <b>ITableDefinition::CreateTable</b> allowing consumers to create SQL Server tables. Consumers use <b>CreateTable</b> to create consumer-named permanent and temporary tables, and permanent or temporary tables with unique names generated by SQLOLEDB.</p>
<p>
When consumers specify the table name in the <i>pwszName </i>member of the <i>uName</i> union in the <i>pTableID</i> parameter, SQLOLEDB creates a SQL Server table with that name. SQL Server table naming constraints apply, and the table name can indicate a permanent table or either a local or global temporary table. For more information, see CREATE TABLE. The <i>ppTableID</i> parameter can be NULL.</p>
<p>
SQLOLEDB can generate the names of permanent or temporary tables. When the consumer sets the <i>pTableID</i> parameter to NULL and sets <i>ppTableID</i> to point to a valid DBID*, SQLOLEDB returns the generated name of the table in the <i>pwszName</i> member of the <i>uName</i> union of the DBID pointed to by the value of <i>ppTableID</i>. To create a temporary, SQLOLEDB-named table, the consumer includes the OLE DB table property DBPROP_TBL_TEMPTABLE in a table property set referenced in the <i>rgPropertySets</i> parameter. SQLOLEDB-named temporary tables are local. For more information, see CREATE TABLE.</p>
<p>
<b>CreateTable</b> returns DB_E_BADID if the <i>eKind</i> member of the <i>pTableID</i> parameter does not indicate DBKIND_NAME.</p>
<h3>DBCOLUMNDESC Usage</h3>
<p>
The consumer can indicate a column data type by using either the <i>pwszTypeName</i> member or the <i>wType</i> member. If the consumer specifies the data type in <i>pwszTypeName</i>, SQLOLEDB ignores the value of <i>wType</i>.</p>
<p>
If using the <i>pwszTypeName</i> member, the consumer specifies the data type by using SQL Server data type names. Valid data type names are returned in the TYPE_NAME column of the PROVIDER_TYPES schema rowset.</p>
<p>
SQLOLEDB recognizes a subset of OLE DB-enumerated DBTYPE values in the <i>wType</i> member. For more information, see Data Type Mapping in <b>ITableDefinition</b>.</p>
<p>
<b>CreateTable</b> returns DB_E_BADTYPE if consumer sets either the <i>pTypeInfo</i> or <i>pclsid</i> member to specify the column data type.</p>
<p>
The consumer specifies the column name in the <i>pwszName</i> member of the <i>uName</i> union of the DBCOLUMNDESC <i>dbcid</i> member. The column name is specified as a Unicode character string. The <i>eKind</i> member of <i>dbcid</i> must be DBKIND_NAME. <b>CreateTable</b> returns DB_E_COLUMNID if <i>eKind</i> is invalid, <i>pwszName</i> is NULL, or if the value of <i>pwszName</i> is not a valid SQL Server identifier.</p>
<p>
All column properties are available on all columns defined for the table. <b>CreateTable</b> can return DB_S_ERRORSOCCURRED if property values are set in conflict. <b>CreateTable</b> returns an error when invalid column property settings cause SQL Server table-creation failure.</p>
<p>
Column properties in a DBCOLUMNDESC are interpreted as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=43%><b>Property ID</b></td>
<td class=label width=57%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_<br>
AUTOINCREMENT</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: Sets the identity property on the column created. For SQL Server, the identity property is valid for a single column within a table. Setting the property to VARIANT_TRUE for more than a single column generates an error when SQLOLEDB attempts to create the table on the server.<p>
The SQL Server identity property is only valid for the integral types and the <b>numeric</b> and <b>decimal</b> types when the scale is 0. Setting the property to VARIANT_TRUE on a column of any other data type generates an error when SQLOLEDB attempts to create the table on the server.</p>
<p>
SQLOLEDB returns DB_S_<br>
ERRORSOCCURRED when DBPROP_<br>
COL_AUTOINCREMENT and DBPROP_<br>
COL_NULLABLE are both VARIANT_<br>
TRUE. The column is defined with the SQL Server identity property and the DBPROP_<br>
COL_NULLABLE <i>dwStatus</i> member is set to DBPROPSTATUS_CONFLICTING.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_DEFAULT</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: Creates a SQL Server DEFAULT constraint for the column.<p>
The <i>vValue</i> DBPROP member can be any of a number of types. The <i>vValue.vt</i> member should specify a type compatible with the data type of the column. For example, defining the BSTR N/A as the default value for a column defined as DBTYPE_WSTR is a compatible match. Defining the same default on a column defined as DBTYPE_R8 generates an error when SQLOLEDB attempts to create the table on the server.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_DESCRIPTION</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: The DBPROP_COL_<br>
DESCRIPTION column property is not implemented by SQLOLEDB. <p>
The <i>dwStatus</i> member of the DBPROP structure returns DBPROPSTATUS_<br>
NOTSUPPORTED when the consumer attempts to write the property value.</p>
<p>
Setting the property does not constitute a fatal error for SQLOLEDB. If all other parameter values are valid, the SQL Server table is created.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_FIXEDLENGTH</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: SQLOLEDB uses DBPROP_<br>
COL_FIXEDLENGTH to determine data type-mapping when the consumer defines a column’s data type by using the <i>wType</i> member of the DBCOLUMNDESC. For more information, see Data Type Mapping in <b>ITableDefinition</b>.</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_NULLABLE</td>
<td width=57%>R/W: Read/write<br>
Default: None<br>
Description: When creating the table, SQLOLEDB indicates whether the column should accept null values if the property is set. When the property is not set, the ability of the column to accept NULL as a value is determined by the SQL Server ANSI NULL default database option.<p>
SQLOLEDB is an ANSI SQL-compliant provider. Connected sessions exhibit ANSI behaviors. If the consumer does not set DBPROP_COL_NULLABLE, columns accept null values.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_PRIMARYKEY</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: When VARIANT_TRUE, SQLOLEDB creates the column with a primary key constraint.<p>
When defined as a column property, only a single column can determine the constraint. Setting the property VARIANT_TRUE for more than a single column returns an error when SQLOLEDB attempts to create the SQL Server table.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;The consumer can use <b>IIndexDefinition::CreateIndex</b> to create a primary key constraint on two or more columns.</p>
<p>
SQLOLEDB returns DB_S_<br>
ERRORSOCCURRED when DBPROP_<br>
COL_PRIMARYKEY and DBPROP_COL_<br>
UNIQUE are both VARIANT_TRUE. SQLOLEDB creates the column with the unique constraint and sets the <i>dwStatus</i> member of the DBPROP_COL_<br>
PRIMARYKEY property to DBPROPSTATUS_CONFLICTING.</p>
<p>
SQLOLEDB returns an error when DBPROP_<br>
COL_PRIMARYKEY and DBPROP_COL_<br>
NULLABLE are both VARIANT_TRUE.</p>
<p>
SQLOLEDB returns an error from SQL Server when&nbsp; the consumer attempts to create a primary key constraint on a column of invalid SQL Server data type. Primary key constraints cannot be defined on columns created with the SQL Server data types <b>bit</b>, <b>text</b>, <b>ntext</b>, and <b>image</b>.</p>
</td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_COL_UNIQUE</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: Applies a SQL Server unique constraint to the column.<p>
When defined as a column property, the constraint is applied on a single column only. The consumer can use <b>IIndexDefinition::<br>
CreateIndex</b> to apply a unique constraint on the combined values of two or more columns.</p>
<p>
SQLOLEDB returns DB_S_<br>
ERRORSOCCURRED when DBPROP_COL_<br>
UNIQUE and DBPROP_COL_<br>
PRIMARYKEY are both VARIANT_TRUE. SQLOLEDB creates the column with the unique constraint and sets the <i>dwStatus</i> member of the DBPROP_COL_<br>
PRIMARYKEY property to DBPROPSTATUS_CONFLICTING.</p>
<p>
SQLOLEDB returns DB_S_<br>
ERRORSOCCURRED when DBPROP_COL_UNIQUE and DBPROP_<br>
COL_NULLABLE are both VARIANT_<br>
TRUE. SQLOLEDB creates the column with the unique constraint and sets the <i>dwStatus</i> member of the DBPROP_COL_<br>
NULLABLE property to DBPROPSTATUS_CONFLICTING.</p>
<p>
SQLOLEDB returns an error from SQL Server when&nbsp; the consumer attempts to create a unique constraint on a column of invalid SQL Server data type. Unique constraints cannot be defined on columns created with the SQL Server data type <b>bit</b>.</p>
</td>
</tr>
</table><br>
<p>
When the consumer calls <b>ITableDefinition::CreateTable</b>, SQLOLEDB interprets table properties as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=43%><b>Property ID</b></td>
<td class=label width=57%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=43%>DBPROP_TBL_TEMPTABLE</td>
<td width=57%>R/W: Read/write<br>
Default: VARIANT_FALSE<br>
Description: By default, SQLOLEDB creates tables named by the consumer. When VARIANT_TRUE, SQLOLEDB generates a temporary table name for the consumer. The consumer sets the <i>pTableID</i> parameter of <b>CreateTable</b> to NULL. The <i>ppTableID</i> parameter must contain a valid pointer.</td>
</tr>
</table><br>
<p>
If the consumer requests that a rowset be opened on a successfully created table, SQLOLEDB opens a cursor-supported rowset. Any rowset properties can be indicated in the property sets passed.</p>
<h3>Example</h3>
<p>
This example creates a SQL Server table.</p>
<pre><code>////////////////////////////////////////////////////////////////////////
// Create the OrderDetails table as follows:
//
// CREATE TABLE OrderDetails
// (
//&nbsp; OrderID      int      NOT NULL
//&nbsp; ProductID   int      NOT NULL
//&nbsp; CONSTRAINT PK_OrderDetails
//&nbsp;&nbsp; PRIMARY KEY CLUSTERED (OrderID, ProductID),
//&nbsp; UnitPrice   money      NOT NULL,
//&nbsp; Quantity   int      NOT NULL,
//&nbsp; Discount   decimal(2,2)   NOT NULL
//&nbsp;&nbsp;&nbsp; DEFAULT 0
// )
//
// The primary key constraint is created in an additional example.
HRESULT CreateTable
  (
  ITableDefinition* pITableDefinition
  )
  {
  DBID&nbsp;&nbsp;&nbsp; dbidTable;
  const ULONG&nbsp;&nbsp; nCols = 5;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nCol;
  ULONG&nbsp;&nbsp;&nbsp;&nbsp; nProp;
  DBCOLUMNDESC&nbsp; dbcoldesc[nCols];
  
  HRESULT&nbsp;&nbsp; hr;
<b><i>  </i></b>
  // Set up column descriptions. First set default property values for
  //&nbsp; the columns.
  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; dbcoldesc[nCol].pwszTypeName = NULL;
 &nbsp;&nbsp; dbcoldesc[nCol].pTypeInfo = NULL;
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets = new DBPROPSET;
 &nbsp;&nbsp; dbcoldesc[nCol].pclsid = NULL;
 &nbsp;&nbsp; dbcoldesc[nCol].cPropertySets = 1;
 &nbsp;&nbsp; dbcoldesc[nCol].ulColumnSize = 0;
 &nbsp;&nbsp; dbcoldesc[nCol].dbcid.eKind = DBKIND_NAME;
 &nbsp;&nbsp; dbcoldesc[nCol].wType = DBTYPE_I4;
 &nbsp;&nbsp; dbcoldesc[nCol].bPrecision = 0;
 &nbsp;&nbsp; dbcoldesc[nCol].bScale = 0;
<b><i>  </i></b>
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].rgProperties = 
 &nbsp;&nbsp; new DBPROP[NCOLPROPS_MAX];
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].cProperties = NCOLPROPS_MAX;
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].guidPropertySet =
 &nbsp;&nbsp; DBPROPSET_COLUMN;
<b><i>  </i></b>
 &nbsp;&nbsp; for (nProp = 0; nProp &lt; NCOLPROPS_MAX; nProp++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].rgProperties[nProp].
 &nbsp;&nbsp;&nbsp;&nbsp; dwOptions = DBPROPOPTIONS_REQUIRED;
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].rgProperties[nProp].colid
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DB_NULLID;
<b><i>  </i></b>
 &nbsp;&nbsp; VariantInit(
 &nbsp;&nbsp;&nbsp;&nbsp; &amp;(dbcoldesc[nCol].rgPropertySets[0].rgProperties[nProp].
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; vValue));
 &nbsp;&nbsp; 
 &nbsp;&nbsp; dbcoldesc[nCol].rgPropertySets[0].rgProperties[nProp].
 &nbsp;&nbsp;&nbsp;&nbsp; vValue.vt = VT_BOOL;
 &nbsp;&nbsp; }
 &nbsp;&nbsp; }
<b><i>  </i></b>
  // Set the column-specific information.
  dbcoldesc[0].dbcid.uName.pwszName = L"OrderID";
  dbcoldesc[0].rgPropertySets[0].rgProperties[0].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_NULLABLE;
  dbcoldesc[0].rgPropertySets[0].rgProperties[0].vValue.boolVal = 
 &nbsp;&nbsp; VARIANT_FALSE;
  dbcoldesc[0].rgPropertySets[0].cProperties = 1;
<b><i>  </i></b>
  dbcoldesc[1].dbcid.uName.pwszName = L"ProductID";
  dbcoldesc[1].rgPropertySets[0].rgProperties[0].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_NULLABLE;
  dbcoldesc[1].rgPropertySets[0].rgProperties[0].vValue.boolVal = 
 &nbsp;&nbsp; VARIANT_FALSE;
  dbcoldesc[1].rgPropertySets[0].cProperties = 1;
<b><i>  </i></b>
  dbcoldesc[2].dbcid.uName.pwszName = L"UnitPrice";
  dbcoldesc[2].wType = DBTYPE_CY;
  dbcoldesc[2].rgPropertySets[0].rgProperties[0].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_NULLABLE;
  dbcoldesc[2].rgPropertySets[0].rgProperties[0].vValue.boolVal = 
 &nbsp;&nbsp; VARIANT_FALSE;
  dbcoldesc[2].rgPropertySets[0].cProperties = 1;
<b><i>  </i></b>
  dbcoldesc[3].dbcid.uName.pwszName = L"Quantity";
  dbcoldesc[3].rgPropertySets[0].rgProperties[0].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_NULLABLE;
  dbcoldesc[3].rgPropertySets[0].rgProperties[0].vValue.boolVal = 
 &nbsp;&nbsp; VARIANT_FALSE;
  dbcoldesc[3].rgPropertySets[0].cProperties = 1;
<b><i>  </i></b>
  dbcoldesc[4].dbcid.uName.pwszName = L"Discount";
  dbcoldesc[4].wType = DBTYPE_NUMERIC;
  dbcoldesc[4].bPrecision = 2;
  dbcoldesc[4].bScale = 2;
  dbcoldesc[4].rgPropertySets[0].rgProperties[0].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_NULLABLE;
  dbcoldesc[4].rgPropertySets[0].rgProperties[0].vValue.boolVal = 
 &nbsp;&nbsp; VARIANT_FALSE;
  dbcoldesc[4].rgPropertySets[0].rgProperties[1].dwPropertyID = 
 &nbsp;&nbsp; DBPROP_COL_DEFAULT;
  dbcoldesc[4].rgPropertySets[0].rgProperties[1].vValue.vt = VT_BSTR;
  dbcoldesc[4].rgPropertySets[0].rgProperties[1].vValue.bstrVal =
 &nbsp;&nbsp; SysAllocString(L"0");
  dbcoldesc[4].rgPropertySets[0].cProperties = 2;
<b><i>  </i></b>
  // Set up the dbid for OrderDetails.
  dbidTable.eKind = DBKIND_NAME;
  dbidTable.uName.pwszName = L"OrderDetails";
<b><i>  </i></b>
  if (FAILED(hr = pITableDefinition-&gt;CreateTable(NULL, &amp;dbidTable,
 &nbsp;&nbsp; nCols, dbcoldesc, NULL, 0, NULL, NULL, NULL)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; DumpError(pITableDefinition, IID_ITableDefinition);
 &nbsp;&nbsp; goto SAFE_EXIT;
 &nbsp;&nbsp; }
<b><i>  </i></b>
SAFE_EXIT:
  // Clean up dynamic allocation in the property sets.
  for (nCol = 0; nCol &lt; nCols; nCol++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; for (nProp = 0; nProp &lt; NCOLPROPS_MAX; nProp++)
 &nbsp;&nbsp; {
 &nbsp;&nbsp; if (dbcoldesc[nCol].rgPropertySets[0].rgProperties[nProp].
 &nbsp;&nbsp;&nbsp;&nbsp; vValue.vt == VT_BSTR)
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp; SysFreeString(dbcoldesc[nCol].rgPropertySets[0].
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rgProperties[nProp].vValue.bstrVal);
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp;&nbsp; }
 &nbsp;&nbsp; 
 &nbsp;&nbsp; delete [] dbcoldesc[nCol].rgPropertySets[0].rgProperties;
 &nbsp;&nbsp; delete [] dbcoldesc[nCol].rgPropertySets;
 &nbsp;&nbsp; }
  
  return (hr);
  }
<b><i>  </i></b></code></pre>
<p class=label>
<b>See Also</b></p>
<p>
<a href="9_ole_13_0bse.htm">Data Type Mapping in ITableDefinition</a></p>
</font></BODY>
</HTML>
