<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>BLOBs as In-Memory Data</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbblobs_as_in_memory_data"></a>BLOBs as In-Memory Data</h1>
<p>
When a BLOB is treated as in-memory data, it is sent or retrieved in a single piece of memory. If the consumer allocates the memory for the BLOB, it usually binds the column with a type indicator of DBTYPE_BYTES, DBTYPE_STR, or DBTYPE_WSTR, depending on the data contained in the BLOB. When getting data, if the consumer wants the provider to allocate the memory for the BLOB, it usually binds the column with one of the preceding type indicators combined with DBTYPE_BYREF.</p>
<p>
To get the BLOB data, the consumer calls a method such as <b>IRowset::GetData</b> with an accessor containing this binding, and the provider returns the entire contents of the BLOB to the consumer. To set the BLOB data, the consumer calls a method such as <b>IRowsetChange::SetData</b> with an accessor containing this binding and sends the entire contents of the BLOB to the provider. This is no different from binding and getting or setting data in other columns, such as getting or setting data in an integer column. If you get or set character data in this manner, the data is null terminated.</p>
<p>
For example, the following code retrieves a 5000-byte BLOB and stores it in consumer memory:</p>
<pre><code>#include&lt;oledb.h&gt;

IMalloc* pIMalloc;
IAccessor* pIAccessor;
IRowset* pIRowset;

int main() {
 HACCESSOR&nbsp; hAccessor;
 DBBINDSTATUS rgStatus[1];
 DBBINDING&nbsp; rgBinding[1] = {
  1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Column 1
  0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to data
  5000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to length 
  5004,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Offset to status
  NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No type info
  NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not an object 
  NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No binding extensions
  DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS, // Bind value, length, status
  DBMEMOWNER_CLIENTOWNED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Memory owned by consumer
  DBPARAMIO_NOTPARAM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not a parameter
  5000,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Max length 
  0 ,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Reserved
  DBTYPE_BYTES,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Type DBTYPE_BYTES
  0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Precision not applicable
  0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Scale not applicable
 };

 pIRowset-&gt;QueryInterface(IID_IAccessor, (void**) &amp;pIAccessor);
 pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1, rgBinding, 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (5000 + sizeof(ULONG) + sizeof(DBSTATUS)), &amp;hAccessor, rgStatus);
 pIAccessor-&gt;Release();

 // Allocate memory for the in-memory data. The first 5000 bytes are for the data,
 // the next sizeof(ULONG) bytes are for the length, and the final sizeof(DBSTATUS)
 // bytes are for the status.

 void * pData = pIMalloc-&gt;Alloc(5000 + sizeof(ULONG) + sizeof(DBSTATUS));

 // Get the next row, get the data in that row, and process the data. Assume the
 // length of the data is known to be &lt;=5000 bytes, so no need to check truncation.
 HROW* rghRows = NULL;
 ULONG cRows;

 pIRowset-&gt;GetNextRows(NULL, 0, 1, &amp;cRows, &amp;rghRows);
 pIRowset-&gt;GetData(rghRows[0], hAccessor, pData);


 if ((DBSTATUS)(((BYTE*) pData)[rgBinding[0].obStatus]) == DBSTATUS_S_ISNULL) {
  // Process NULL data
 } else if ((DBSTATUS)((BYTE*)pData)[rgBinding[0].obStatus] == DBSTATUS_S_OK) {
  // Process data.&nbsp; Length is (ULONG)pData[rgBinding[0].obLength].
 }

 pIMalloc-&gt;Free(rghRows); </code></pre>
<p>
};</p>
<pre></pre>
</font></BODY>
</HTML>
