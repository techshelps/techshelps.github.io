<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Data Types</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcproviderdata_types"></a><sup></sup>Data Types</h1>
<p>
This section describes data types in the ODBC Provider.</p>
<h1>Default Data Type Mappings</h1>
<p>
The ODBC Provider binds to the ODBC data source using the types in the table below. The SQL type is queried using <b>SQLDescribeCol</b>. The sign of the data type (signed/unsigned) is determined using <b>SQLColAttributes</b>. It is used in deciding which C type to use in internal buffers and which type indicator to return through <b>IColumnsInfo::GetColumnInfo</b>.</p>
<p>
Note that the GUID mapping is for an OBDC 3.x driver only.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=38%><b><br>
<br>
SQL type indicator</b></td>
<td class=label width=34%><b><br>
Indicator of C type used for internal buffers</b></td>
<td class=label width=28%><b><br>
OLE DB type indicator</b></td>
</tr>
<tr valign=top>
<td width=38%>SQL_CHAR, SQL_VARCHAR, SQL_LONGVARCHAR, SQL_DECIMAL, SQL_NUMERIC</td>
<td width=34%>SQL_C_CHAR</td>
<td width=28%>DBTYPE_STR</td>
</tr>
<tr valign=top>
<td width=38%>SQL_GUID</td>
<td width=34%>SQL_C_GUID[1]</td>
<td width=28%>DBTYPE_GUID</td>
</tr>
<tr valign=top>
<td width=38%>SQL_BIT</td>
<td width=34%>SQL_C_BIT</td>
<td width=28%>DBTYPE_BOOL</td>
</tr>
<tr valign=top>
<td width=38%>SQL_TINYINT, SQL_SMALLINT</td>
<td width=34%>SQL_C_USHORT, SQL_C_SSHORT</td>
<td width=28%>DBTYPE_I2</td>
</tr>
<tr valign=top>
<td width=38%>SQL_INTEGER</td>
<td width=34%>SQL_C_ULONG, SQL_C_SLONG</td>
<td width=28%>DBTYPE_I4</td>
</tr>
<tr valign=top>
<td width=38%>SQL_BIGINT</td>
<td width=34%>SQL_C_STR [<sup>2]</sup><p>
<sup>SQL_C_BIGINT [3]</sup></p>
</td>
<td width=28%>DBTYPE_STR</td>
</tr>
<tr valign=top>
<td width=38%>SQL_REAL</td>
<td width=34%>SQL_C_FLOAT</td>
<td width=28%>DBTYPE_R4</td>
</tr>
<tr valign=top>
<td width=38%>SQL_FLOAT, SQL_DOUBLE</td>
<td width=34%>SQL_C_DOUBLE</td>
<td width=28%>DBTYPE_R8</td>
</tr>
<tr valign=top>
<td width=38%>SQL_BINARY, SQL_VARBINARY, SQL_LONGVARBINARY</td>
<td width=34%>SQL_C_BINARY</td>
<td width=28%>DBTYPE_BYTES</td>
</tr>
<tr valign=top>
<td width=38%>SQL_DATE</td>
<td width=34%>SQL_C_DATE</td>
<td width=28%>DBTYPE_DATE</td>
</tr>
<tr valign=top>
<td width=38%>SQL_TIME</td>
<td width=34%>SQL_C_TIME</td>
<td width=28%>DBTYPE_DATE</td>
</tr>
<tr valign=top>
<td width=38%>SQL_TIMESTAMP</td>
<td width=34%>SQL_C_TIMESTAMP</td>
<td width=28%>DBTYPE_DATE</td>
</tr>
<tr valign=top>
<td class=mini colspan=3 width=100%>1For ODBC 3.5 drivers only.<p class=mini>
2This is due to lack of support in the ODBC specification for a SQL_C type for 8-byte integers. For ODBC 3.x drivers, the indicator is SQL_C_BIGINT.</p>
<p class=mini>
3 For ODBC 3.x drivers only.</p>
</td>
</tr>
</table><br>
<h1>Length Binding for Numerics</h1>
<p>
For types DBTYPE_UI1, DBTYPE_I2, DBTYPE_I4, DBTYPE_I8, DBTYPE_R4, DBTYPE_R8, DBTYPE_CY, DBTYPE_NUMERIC, the length binding is always set to the fixed size of the destination binding type, rather than the internal source type.</p>
<h1>String Truncation</h1>
<p>
Strings are truncated without warning when the destination length is smaller than the source length.</p>
<h1>Support for Long Data Types</h1>
<p>
Consumer applications can bind to long data columns by binding to <b>IUnknown</b> and querying for the <b>ISequentialStream</b> interface on the data or by binding to _BYTES or _STR (depending on the underlying data type) to get the data in line. If the consumer chooses to use the <b>ISequentialStream</b> approach, support is limited to one BLOB per accessor.</p>
<p>
The ODBC Provider supports STGM_READ on <b>IRowset::GetData, IRowsetChange::InsertRow</b> or <b>IRowsetChange::SetData</b>; STGM_WRITE is not supported for any one of these methods. </p>
<p>
To write long data using <b>IRowsetChange::InsertRow</b> or <b>IRowsetChange::SetData</b>, follow these steps:
<ol>
<li>
Set pObject-&gt;dwFlags == STGM_READ;<br>
set pObject-&gt;iid==IID_ISequentialStream.<br>
(Only IID_ISequentialStream is supported; IStream, IStorage, and ILockBytes are not.)<br><br></li>
<li>
Bind the storage columns. Both <b>IRowsetChange::InsertRow</b> and <b>IRowsetChange::SetData</b> allow binding more than one storage column at a time.<br><br></li>
<li>
Pass the instantiated <b>ISequentialStream</b> pointer in the <i>pData</i> buffer at the correct offset (specified by <i>obValue</i>).</li>
</ol>
<p>
<b>IRowsetChange::SetData</b> reads the data by calling <b>ISequentialStream::Read</b> on the object until it reaches the end of the stream.</p>
<p>
To read long data using <b>IRowset::GetData</b> follow these steps:
<ol>
<li>
Set pObject-&gt;dwFlags == STGM_READ;<br>
set pObject-&gt;iid==IID_ISequentialStream.<br>
(Only IID_ISequentialStream is supported; IStream, IStorage, and ILockBytes are not.)<br><br></li>
<li>
Bind the storage columns. <b>IRowset::GetData </b>permits only one storage column to be bound at a time.&nbsp; If there is a storage object bound, no other storage objects or long BLOBs can be bound. <br><br></li>
<li>
The <i>pData</i> buffer would then contain <b>ISequentialStream</b> pointer.</li>
</ol>
<p>
To support long data types, the consumer application must meet at least one of the following conditions:
<ul type=disc>
<li>
The OLE DB <b>IRowsetLocate</b> interface is available.<br><br></li>
<li>
<b>SQLExtendedFetch</b> and <b>SQLSetPos(SQL_POSITION)</b> are available in the underlying ODBC driver and DBPROP_CANHOLDROWS is set to VARIANT_FALSE.<br><br></li>
<li>
If the underlying ODBC cursor is forward-only, BLOB data is available if there are no non-BLOB columns following a BLOB column or, BLOB data is available regardless of position, if the KAGPROP_BLOBSONFOCURSOR property is set to VARIANT_TRUE.</li>
</ul>
<p>
Long data in a newly inserted row that contains BLOB data columns cannot be read immediately after the row is inserted if the insertion occurred in immediate update mode or if the BLOB data was provided through an <b>ISequentialStream</b> object. The consumer must use <b>IRowset::GetNextRows</b>, <b>IRowsetLocate::GetRowsAt</b>, or <b>IRowsetLocate::GetRowsByBookmark</b> to reposition on the newly inserted row and gain access to the long data columns.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If you are using Query-By-Example, you cannot retrieve BLOB data.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Attempting to use a storage object on a non-BLOB column may result in a crash or memory corruption; no error will be returned.</p>
<h3>Using the KAGPROP_BLOBSONFOCURSOR Property</h3>
<p>
The KAGPROP_BLOBSONFOCURSOR property enables users to access BLOB data in a forward-only rowset regardless of the position of the column containing the BLOB data in the column list. If this property is set to VARIANT_TRUE, users can access BLOB data in columns other than the last column in forward-only rowsets; if it set to VARIANT_FALSE, users can access BLOB data only if there are no additional BLOB columns following a BLOB column in the forward-only rowset. If any non-BLOB columns follow a BLOB column in this case, those columns will be inaccessible.</p>
<p>
BLOBs can be accessed only from the most recent row. Users must access the BLOB data columns, as well as all other columns, in the ascending column order; data in any columns skipped in the process of traversing the row will be lost. There is no change to the behavior of the columns preceding the first BLOB column; these columns are buffered in the usual manner.</p>
<h1>Data Type Conversion</h1>
<p>
The ODBC Provider supports limited conversions. Only the default types returned in <b>IColumnsInfo</b> are supported, and DBTYPE_BYREF is supported only on variable length types. Also, some types returned by <b>IColumnsInfo</b> currently cannot be converted to or from DBTYPE_WSTR, which should be valid for all types.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Supported data conversions can be determined through the <b>IConvertType</b> interface.</p>
<p>
In the following table, click on the data type you want to convert from to view the supported conversions. In the conversion tables, an <b>X</b> indicates that the conversion is supported in the ODBC Provider.</p>
<p class=label>
<b>Data types to convert from</b></p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td width=19%><a href="msdasql_6kj5.htm">I1</a></td>
<td width=23%><a href="msdasql_6kz8.htm">R4</a></td>
<td width=34%><a href="msdasql_2apc.htm">DBTIMESTAMP</a></td>
<td width=24%><a href="msdasql_45v2.htm">IUNKNOWN</a></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_6kj6.htm">I2</a></td>
<td width=23%><a href="msdasql_6kzc.htm">R8</a></td>
<td width=34%><a href="msdasql_8b70.htm">BOOL</a></td>
<td width=24%><a href="msdasql_699o.htm">NULL</a></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_6kj8.htm">I4</a></td>
<td width=23%><a href="msdasql_6kah.htm">CY</a></td>
<td width=34%><a href="msdasql_8o36.htm">BSTR</a></td>
<td width=24%><a href="msdasql_1h0y.htm">STR</a></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_6kjc.htm">I8</a></td>
<td width=23%><a href="msdasql_8soc.htm">DECIMAL</a></td>
<td width=34%><a href="msdasql_8ipf.htm">BYTES</a></td>
<td width=24%><a href="msdasql_9f1w.htm">VARIANT</a></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_1mr5.htm">UI1</a></td>
<td width=23%><a href="msdasql_5pk3.htm">NUMERIC</a></td>
<td width=34%><a href="msdasql_9jp5.htm">Empty</a></td>
<td width=24%><a href="msdasql_6nsi.htm">WSTR</a></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_1mr6.htm">UI2</a></td>
<td width=23%><a href="msdasql_8bqd.htm">DATE</a></td>
<td width=34%><a href="msdasql_7t4i.htm">ERROR</a></td>
<td width=24%></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_1mr8.htm">UI4</a></td>
<td width=23%><a href="msdasql_2did.htm">DBDATE</a></td>
<td width=34%><a href="msdasql_6x7o.htm">GUID</a></td>
<td width=24%></td>
</tr>
<tr valign=top>
<td width=19%><a href="msdasql_1mrc.htm">UI8</a></td>
<td width=23%><a href="msdasql_2ysl.htm">DBTIME</a></td>
<td width=34%><a href="msdasql_17zc.htm">IDISPATCH</a></td>
<td width=24%></td>
</tr>
</table><br>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>When converting DBTYPE_NUMERIC types that correspond to ODBC types SQL_NUMERIC and SQL_DECIMAL, the ODBC Provider exposes additional conversions that are not listed as supported. This occurs because these types are internally bound to SQL_CHAR. Therefore, any conversions supported for CHAR data types in ODBC can be <i>attempted</i> for DBTYPE_NUMERIC types. There are some conversions that will fail, due to incompatibility, and some that will succeed, depending on the data.</p>
</font></BODY>
</HTML>
