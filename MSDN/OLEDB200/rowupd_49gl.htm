<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetUpdate::Update</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetupdate__update"></a>IRowsetUpdate::Update</h1>
<p>
Transmits any changes made to a row since it was last fetched or <b>Update</b> was called for it.</p>
<pre><code>HRESULT Update (
   HCHAPTER            hChapter,
   ULONG               cRows,
   const HROW            rghRows[],
   ULONG *               pcRows,
   HROW **               prgRows,
   DBROWSTATUS**   prgRowStatus);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The count of rows to update. If <i>cRows</i> is nonzero, <b>Update</b> updates all pending changes in the rows specified in <i>rghRows</i>. If <i>cRows</i> is zero, <b>Update</b> ignores <i>rghRows</i> and updates all pending changes to all rows in the rowset.</p>
<p class=dt>
<i>rghRows</i></p>
<p class=indent>
[in]<br>
An array of handles of the rows to update.</p>
<p class=tl>
If <i>rghRows</i> includes a row that does not have any pending changes, <b>Update</b> does not return an error. Instead, the row remains unchanged and hence has no pending changes after <b>Update</b> returns—which is the intention of <b>Update</b>—and the row status value associated with that row is DBROWSTATUS_S_OK. Furthermore, <b>Update</b> guarantees not to transmit any value for the row to the data source.</P><p class=tl>
If <i>rghRows</i> includes a duplicate row, <b>Update</b> behaves as follows. If the row handle is valid, no errors occur and *<i>prgRowStatus</i> contains DBROWSTATUS_S_OK for each occurrence. If the row handle is invalid, *<i>prgRowStatus</i> contains the appropriate error for each occurrence.</P><p class=dt>
<i>pcRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of rows <b>Update</b> attempted to update. If this is a null pointer, no count of rows is returned. If the method fails with an error other than DB_E_ERRORSOCCURRED, *<i>pcRows</i> is set to zero.</p>
<p class=dt>
<i>prgRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array containing the handles of all the rows <b>Update</b> attempted to update. If <i>rghRows</i> is not a null pointer, then the elements of this array are in one-to-one correspondence with those in <i>rghRows</i>. For example, if a row appears twice in <i>rghRows</i>, it appears twice in *<i>prgRows</i>. When <i>rghRows</i> is not a null pointer, <b>Update</b> does not add to the reference count of the rows it returns in *<i>prgRows</i>; the reason is that the consumer already has these row handles.</p>
<p class=tl>
If <i>rghRows</i> is a null pointer, the elements of this array are handles of all the rows that had pending changes, regardless of whether <b>Update</b> was successful at transmitting those changes to the data source. The consumer checks *<i>prgRowStatus</i> to determine which rows were updated. When <i>rghRows</i> is a null pointer, <b>Update</b> adds to the reference count of the rows it returns in *<i>prgRows</i>; the reason is that the consumer is not guaranteed to already have these row handles. A side effect of this is that rows with a reference count of zero, but with pending changes at the time <b>Update</b> is called, are brought back into existence; that is, their reference count is increased to 1 and they must be rereleased.</P><p class=tl>
The rowset allocates memory for the array of handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the handles. This argument is ignored if <i>pcRows</i> is a null pointer, and must not be a null pointer otherwise. If *<i>pcRows</i> is zero on output or the method fails with an error other than DB_E_ERRORSOCCURRED, the provider does not allocate any memory and ensures that *<i>prgRows</i> is a null pointer on output.</P><p class=dt>
<i>prgRowStatus</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of row status values. The elements of this array correspond one-to-one with the elements of <i>rghRows</i> (if <i>rghRows</i> is not a null pointer) or *<i>prgRows</i> (if <i>rghRows</i> is a null pointer). If no errors or warnings occur while updating a row, the corresponding element of *<i>prgRowStatus</i> is set to DBROWSTATUS_S_OK. If an error or warning occurs while updating a row, the corresponding element is set as specified in DB_S_ERRORSOCCURRED. If <i>prgRowStatus</i> is a null pointer, no row status values are returned. For information about the DBROWSTATUS enumerated type, see "<a href="ch13pr_5ib7.htm">Arrays of Errors</a>" in Chapter 13.</p>
<p class=tl>
The rowset allocates memory for the row status values and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the row status values. This argument is ignored if <i>cRows</i> is zero and <i>pcRows</i> is a null pointer. If <b>Update</b> does not attempt to update any rows or the method fails with an error other than DB_E_ERRORSOCCURRED, the provider does not allocate any memory and ensures that *<i>prgRowStatus</i> is a null pointer on output.</P><p class=tl>
</P><p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The changes in all rows were successfully updated. The following values can be returned in *<i>prgRowStatus</i>:
<ul type=disc>
<li>
The changes in the row were successfully updated. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_S_OK.<br><br></li>
<li>
Updating or deleting a single row caused more than one row to be updated or deleted in the data source. For more information, see DBPROP_REPORTMULTIPLECHANGES in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_S_MULTIPLECHANGES.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while updating a row, but at least one row was successfully updated. Successes can occur for the reasons listed under S_OK. The following errors can occur:
<ul type=disc>
<li>
Updating a row was canceled during notification. The row was not updated and the corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_CANCELED.<br><br></li>
<li>
The rowset was using optimistic concurrency, a row was being updated or deleted, and the value of a column in that row has been changed since it was last fetched. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_CONCURRENCYVIOLATION.<br><br></li>
<li>
An element of <i>rghRows</i> referred to a row for which a deletion had been transmitted to the data source. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_DELETED.<br><br></li>
<li>
A row was being inserted or updated and a value specified for that row violated the integrity constraints for the column or table. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_INTEGRITYVIOLATION.<br><br></li>
<li>
A row was being deleted, and doing so violated the integrity constraints for the column or table. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_INTEGRITYVIOLATION.<br><br></li>
<li>
An element of <i>rghRows</i> was invalid. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
The consumer did not have sufficient permission to update, delete, or insert a row. This error can be returned only if the value of the DBPROP_ROWRESTRICT property is VARIANT_TRUE. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_PERMISSIONDENIED.<br><br></li>
<li>
The update, delete, or insert failed due to reaching a limit on the server, such as a query execution timing out. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_LIMITREACHED.<br><br></li>
<li>
A column value did not meet the schema requirements for the column. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_SCHEMAVIOLATION.<br><br></li>
<li>
The values for two or more columns did not meet the multiple-column schema requirements for those columns. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_SCHEMAVIOLATION.<br><br></li>
<li>
A row was being inserted, no value was specified for a column, the column does not have a default, and the column is non-nullable. The error in the corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_SCHEMAVIOLATION.<br><br></li>
<li>
The consumer encountered a recoverable, provider-specific error, such as an RPC failure when transmitting the change to a remote server. The corresponding element of <i>*prgRowStatus</i> contains DBROWSTATUS_E_FAIL.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>cRows</i> was not zero and <i>rghRows</i> was a null pointer.</p>
<p class=tl>
<i>pcRows</i> was not a null pointer and <i>prgRows</i> was a null pointer on input.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return either the handles of the rows <b>Update</b> attempted to update or the array of row status values.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Errors occurred while updating all of the rows. The provider allocates memory for *<i>prgRows</i> and *<i>prgRowStatus</i> and the consumer checks the values in *<i>prgRowStatus</i> to determine why the pending changes were not updated. The consumer frees this memory when it no longer needs the information. Errors can occur for the reasons listed under DB_S_ERRORSOCCURRED.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>Update</b> transmits pending changes for the specified rows to the data source and clears their pending change status. That is, it transmits any changes made to the row since it was last fetched or <b>Update</b> was called for the row. For more information about pending changes, see "<a href="ch05pr_0ue9.htm">Changing Data</a>" in Chapter 5.</p>
<p>
The order in which <b>Update</b> processes rows is provider-specific. If <b>Update</b> encounters an error, it continues processing rows until it has attempted to update all specified rows, then it returns the appropriate warning. This might leave the rowset in a state where changes have been transmitted for some rows but not others. When the consumer repairs the cause of the error, it can call <b>Update</b> again and the provider guarantees it will not transmit data to the data source for those rows for which data was already successfully transmitted.</p>
<p>
If any consumer of the rowset is using notifications, the provider sends notifications that pending changes for the specified rows are being transmitted to the data source.</p>
<p>
If <b>Update</b> is called for a row that has a reference count of zero and exists only because the row has a pending change, <b>Update</b> releases the row and all its resources. The only exception to this is when the handle to the row is returned in *<i>prgRows</i>, in which case the reference count is set to 1.</p>
<p>
If the provider cached original values to implement <b>GetOriginalData</b> and <b>Undo</b>, it discards them as part of <b>Update</b>.</p>
<p>
If the rowset is released with <b>IUnknown::Release</b> before <b>Update</b> is called, all pending changes are lost.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowchg_4dk5.htm">IRowsetChange</a>, <a href="rowupd_2xyn.htm">IRowsetUpdate::Undo</a></p>
</font></BODY>
</HTML>
