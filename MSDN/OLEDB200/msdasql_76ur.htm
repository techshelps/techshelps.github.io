<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Known Limitations</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcproviderknown_limitations"></a><sup></sup>Known Limitations</h1>
<p>
The following are known limitations with the ODBC Provider:</p>
<h1>General</h1>
<ul type=disc>
<li>
The ODBC Provider does not return precision correctly for any numeric data types except DBTYPE_NUMERIC and DBTYPE_DECIMAL. For example, the COLUMNS schema rowset, <b>IColumnsInfo::GetColumnInfo</b>, and <b>IColumnsRowset::GetColumnsRowset</b> return a precision of zero for integer data types.<br><br></li>
<li>
The ODBC Desktop Database Driver cannot start a transaction when it has a rowset open. The ODBC Provider returns E_FAIL if <b>ITransactionLocal::StartTransaction</b> is called when any rowset is held open by this driver. This limitation does not necessarily affect other ODBC drivers.<br><br></li>
<li>
The ODBC Provider does not quote table names passed through DBIDs; for instance, in <b>IOpenRowset</b>. Therefore, when trying to open a table against the ODBC Provider that requires quoting the name (such as when the table name contains extended characters), the consumer must add the quotes to the table name manually or simply execute "Select * from &lt;quoted table name&gt;".<br><br></li>
<li>
Query-based updates cannot be used to update BLOB data or other long data.<br><br></li>
<li>
The query-based update scheme implemented in the ODBC Provider may not allow for correct repositioning in the rowset after performing an update involving the key columns which were used to generate a keyset cursor-based rowset.<br><br></li>
<li>
The ODBC Provider does not support output or input/output parameters as storage objects.<br><br></li>
<li>
Using the ODBC Provider, if the underlying ODBC driver does not support <b>SQLDescribeParam</b>, and the OLE DB consumer does not specify the type of the parameter, the ODBC Provider will convert Boolean parameter values to "-1" and "0" when the data type of the parameter is string. This is in contrast to the<i> OLE DB Programmer's Reference,</i> which calls for Booleans converted to string data types to appear as the strings "True" or "False". In order to ensure proper conversion against ODBC drivers that do not support describing parameters, the OLE DB consumer should always call <b>SetParameterInfo</b> to specify the types of parameters.<br><br></li>
<li>
If DBMEMOWNER_PROVIDEROWNED was set in <i>dwMemOwner</i> in a binding structure and the binding structure binds to a long data column, the ODBC Provider returns DB_E_BADBINDINFO.<br><br></li>
<li>
If DBPROP_REMOVEDELETED is set to VARIANT_TRUE on the rowset and a dynamic ODBC cursor is requested and the ODBC Provider cannot provide this type of cursor, any deleted rows scheduled to be removed from the rowset are removed at fetch time. In this situation, it is possible for row-fetching methods (such as <b>GetNextRows</b> or <b>GetRowsAt</b>) to return both S_OK and fewer rows than requested. This irregular behavior is caused by the ODBC Provider requirement to maintain a one-to-one correspondence between OLE DB and ODBC rowsets. Note that this behavior does not signify the DB_S_ENDOFROWSET condition and that the number of rows returned by the fetching method will never be zero if there are any remaining rows (although the number of rows fetched may be smaller than the number requested).<br><br></li>
<li>
With non-ODBC 3.x drivers, the ODBC Provider cannot return bookmarks on newly inserted rows. The ODBC Provider marks the status of the bookmark column of the newly inserted row as DBSTATUS_E_UNAVAILABLE. Since ODBC 3.x drivers retrieve bookmarks, updates can be performed on newly inserted rows.<br><br></li>
<li>
The ODBC Provider does not allow BLOB data to be set via <b>ISequentialStream</b> on newly inserted rows.<br><br></li>
<li>
In a deferred update mode, the ODBC Provider does not support retrieving data set into blob columns via ISequentialStream, unless that data has been updated on the provider using IRowsetUpdate::Update.<br><br></li>
<li>
When performing deferred updates with the DBCOLUMNFLAGS_ISLONG flag, the following two limitations exist:<ul type=disc>
<li>
If you call <b>SetData</b> for a BLOB column bound as DBTYPE_IUNKNOWN, you cannot retrieve the interface pointer in subsequent calls to <b>GetData</b>. After calling <b>IRowsetUpdate::Update</b>, you can retrieve the value as usual.<br><br></li>
<li>
If you call <b>IRowsetUpdate::SetData</b> for a BLOB column not bound in the accessor as DBTYPE_IUNKNOWN, you may retrieve that value as any legal binding other than DBTYPE_IUNKNOWN. After calling <b>IRowsetUpdate::Update</b>, you may retrieve the value in the usual manner. </li>
</ul>
</li>
</ul>
<h1>Microsoft ODBC Driver for Oracle</h1>
<p>
There are currently no known limitations to using this driver with version 3.0 of the ODBC Provider.</p>
<h1>Microsoft SQL Server ODBC Driver</h1>
<ul type=disc>
<li>
When using a Microsoft SQL Server database as the data source, if the consumer specifies a long column in the WHERE clause of a SELECT statement, the long column cannot contain more than 255 characters.<br><br></li>
<li>
Using a Microsoft SQL Server database as the data source, if the consumer uses <b>SetData</b> to update a BLOB column through an <b>ISequentialStream</b> interface, the length part of the binding must contain the total length of the BLOB data. This differs from other data sources, which require the length part of the binding to contain only the length of the pointer to the <b>ISequentialStream</b> object.<br><br></li>
<li>
Using a Microsoft SQL Server database as the data source, if the consumer opens a forward-only cursor using a query-based update, any method of the <b>IRowsetChange</b> interface may cause a deadlock situation.</li>
</ul>
<p>
The following schema and schema restrictions are supported through the Microsoft SQL Server ODBC driver.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=50%><b>Supported schema</b></td>
<td class=label width=50%><b>Supported restrictions</b></td>
</tr>
<tr valign=top>
<td width=50%>CATALOGS</td>
<td width=50%>None</td>
</tr>
<tr valign=top>
<td width=50%>COLUMNS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>TABLES</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>PROVIDER_TYPES</td>
<td width=50%>None</td>
</tr>
<tr valign=top>
<td width=50%>INDEXES</td>
<td width=50%>1, 2, and 5</td>
</tr>
<tr valign=top>
<td width=50%>PROCEDURES</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>PROCEDURE_PARAMETERS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>COLUMN_PRIVILEGES</td>
<td width=50%>1, 2, 3, and 4</td>
</tr>
<tr valign=top>
<td width=50%>FOREIGN_KEYS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>PRIMARY_KEYS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>SCHEMATA</td>
<td width=50%>None</td>
</tr>
</table><br>
<h1>Microsoft Access ODBC Driver</h1>
<ul type=disc>
<li>
When a consumer specifies a value to be inserted or updated in a command that causes a data overflow, but has not called <b>ICommandWithParameters::SetParameterInfo,</b> and the provider cannot determine the column type used by the data source, the ODBC Provider returns DB_E_DATAOVERFLOW (rather than DB_E_ERRORSOCCURRED with the offending parameter marked with the DBSTATUS_E_DATAOVERFLOW flag). This occurs because the ODBC Provider cannot detect which parameter caused the overflow error.<br><br></li>
<li>
In delayed-update mode, consumers who attempt to delete or update rows in a read-only rowset receive the status DBROWSTATUS_DELETED. This differs from the expected status, which is DBROWSTATUS_INTEGRITYVIOLATION.<br><br></li>
<li>
The rowset property DBPROP_MAXROWS does not affect the number of rows returned by the Microsoft Access ODBC driver.<br><br></li>
<li>
When run against the Access driver, the ODBC Provider reports output parameter availability as DBPROPVAL_OA_ATROWRELEASE, rather than the expected value of DBPROPVAL_OA_NOTSUPPORTED.</li>
</ul>
<p>
The following schema and schema restrictions are supported through the Microsoft Access ODBC driver.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=50%><b>Supported schema</b></td>
<td class=label width=50%><b>Supported restrictions</b></td>
</tr>
<tr valign=top>
<td width=50%>CATALOGS</td>
<td width=50%>None</td>
</tr>
<tr valign=top>
<td width=50%>COLUMNS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>TABLES</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>PROVIDER_TYPES</td>
<td width=50%>None</td>
</tr>
<tr valign=top>
<td width=50%>INDEXES</td>
<td width=50%>1, 2, and 5</td>
</tr>
<tr valign=top>
<td width=50%>PROCEDURE_PARAMETERS</td>
<td width=50%>All</td>
</tr>
<tr valign=top>
<td width=50%>PROCEDURE_COLUMNS</td>
<td width=50%>All</td>
</tr>
</table><br>
<h1>Notifications</h1>
<ul type=disc>
<li>
On the first change to a row from <b>SetData</b>, the ODBC Provider does not interleave the SynchAfter and DidEvent notifications. The ordering of OKTODO and ABOUTTODO is correct.</li>
</ul>
<h1>Rowset Properties</h1>
<ul type=disc>
<li>
The rowset properties DBPROP_OTHERINSERT and DBPROP_CANHOLDROWS cannot be used together. If you attempt to create a rowset with this combination of properties, the ODBC Provider returns DB_E_ERRORSOCCURRED and returns _NOTSUPPORTED for both properties.</li>
</ul>
<h1>Setting Read-Only Properties to Their Default Values</h1>
<ul type=disc>
<li>
The ODBC Provider does not support the OLE DB version 1.1 behavior of allowing consumers to set the value of a read-only property to its default. Although the OLE DB version 1.1 specification clearly indicates that a status of DBPROPSTATUS_OK is returned in "the case where the value of a read-only property was set to its current value," the ODBC Provider returns DBPROPSTATUS_NOTSETTABLE.</li>
</ul>
<h1>Threading</h1>
<ul type=disc>
<li>
The ODBC Provider supports the Free Threaded multithreading model; there is no support for Apartment model or mixed threading.</li>
</ul>
<h1>ICommandWithParameters</h1>
<ul type=disc>
<li>
The ODBC Provider returns zero for precision and scale when these values do not apply. These values are incorrect and should be ~0 (bitwise NOT 0).<br><br></li>
<li>
If the consumer doesn't allocate enough space, a stored procedure that returns a variable length parameter will not detect the truncation that might have occurred. Instead of returning S_OK and setting the status to DBSTATUS_S_TRUNCATED, the ODBC Provider will return DB_S_ERRORSOCCURRED, and set the status to DBSTATUS_S_OK.</li>
</ul>
<h1>IConvertType</h1>
<ul type=disc>
<li>
<b>IConvertType::CanConvert</b> returns E_INVALIDARG when a bad <i>dwConvert</i> flag is passed in. This is incorrect; the ODBC Provider should return DB_E_BADCONVERTFLAG.</li>
</ul>
<h1>IDBSchemaRowset</h1>
<ul type=disc>
<li>
The ODBC Provider may not support restrictions on the CATALOGS and SCHEMATA schema rowsets.<br><br></li>
<li>
<b>IDBSchemaRowset::GetSchema</b> may not support the schema restriction on any schema on any ODBC driver. The ODBC Provider will incorrectly report this as a supported restriction because ODBC drivers cannot export information about their support of restrictions to the ODBC Provider.<br><br></li>
<li>
<b>IDBSchemaRowset::GetRowset</b> features limited support for the following schema rowsets with most data sources:<br>
FOREIGN_KEYS<br>
PRIMARY_KEYS<br>
STATISTICS<br>
Consumers must restrict their calls by table name or the ODBC Provider will return an empty result set. This limitation does not occur on Microsoft SQL Server 4.21.<br><br></li>
<li>
On Microsoft SQL Server data sources, <b>IDBSchemaRowset::GetRowset( DBSCHEMA_PROCEDURE_COLUMNS)</b> is unsupported. Consumers who need rowset information about stored procedures should prepare a query that includes the stored procedure and call <b>IColumnsInfo::GetColumnInfo</b>.<br><br></li>
<li>
A restriction on table name is required when calling <b>IDBSchemaRowset::GetRowset(DBSCHEMA_INDEXES)</b>. This restriction must be used because ODBC function <b>SQLStatistics</b> returns information about a single table and the ODBC Provider uses this function to return information from the data source. If the restriction is not applied, the ODBC Provider returns an empty result set.<br><br></li>
<li>
The PROVIDER_TYPES schema rowset is not sorted by the ODBC Provider.<br><br></li>
<li>
SQL Server will return names similar but not matching when restrictions are placed on the PROCEDURE_NAMES column. When <b>GetRowset</b> is called for PROCEDURES and PROCEDURE_PARAMETERS schema rowsets, and a name restriction is specified, then the PROCEDURE NAMES returned in the result set may not exactly match the restriction value, but may have ";N" appended, where N is a number. Also, if the ";N" is used in the PROCEDURE NAME restriction, then the provider will return an empty result set even if a procedure name is appended with that number.</li>
</ul>
<h1>IRowset</h1>
<ul type=disc>
<li>
The ODBC Provider does not support execution of <b>RestartPosition</b> when the command text contains parameters; the underlying ODBC driver must, however, support <b>SQLExtendedFetch</b>.<br><br></li>
<li>
With <b>IRowset::RestartPosition</b>, the ODBC Provider does not return DB_S_COLUMNSCHANGED when it is supposed to. Instead, it returns E_FAIL.<br><br></li>
<li>
If the row on which the rowset is currently positioned is deleted, the consumer must first execute<b> IRowset::RestartPosition</b>, before retrieving additional row handles with <b>IRowset::GetNextRows</b>. <br><br></li>
<li>
If the columns in the underlying data source change and the consumer requests additional rows with <b>IRowset::GetNextRows</b>, the ODBC Provider will fail with the return code E_FAIL.<br><br></li>
<li>
If the columns in the underlying data source change, the consumer calls <b>IRowset::RestartPosition</b>, and the reposition operation causes the command to be re-executed, the ODBC Provider will fail with the return code E_FAIL. The rowset is now invalid and any method other than <b>ReleaseRows</b> or <b>ReleaseAccessor</b> will fail. If this occurs, the consumer must release all accessors, row handles, and the rowset and must execute the command that created the rowset again.<br><br></li>
<li>
When using <b>IRowset::GetData</b>, you can bind to only one long data column based on <b>ISequentialStream</b>; the ODBC Provider can bind to any number of long data columns not based on <b>ISequentialStream</b>.</li>
</ul>
<h1>IRowsetLocate</h1>
<ul type=disc>
<li>
When the consumer fetches a row with <b>IRowsetLocate::GetRowsAt</b>, saves the bookmark value corresponding to the row, releases the row, and attempts to fetch the row again using <b>IRowsetLocate::GetRowsAt</b> with the saved bookmark, the second fetch operation may fail. The ODBC Provider returns DB_E_BADBOOKMARK if the underlying ODBC call to <b>SQLExtendedFetch</b> returns S1111 (invalid bookmark value); otherwise, the ODBC Provider returns E_FAIL.</li>
</ul>
<h1>IRowsetResynch</h1>
<ul type=disc>
<li>
To enable the ODBC Provider to expose the <b>IRowsetResynch</b> interface, at least one of the following conditions must be met:<ul type=disc>
<li>
The <b>IRowsetLocate</b> interface is implemented.<br><br></li>
<li>
The transaction isolation level is set to SQL_TXN_REPEATABLE_READ.<br><br></li>
<li>
The transaction isolation level is set to SQL_TXN_SERIALIZABLE.<br><br></li>
<li>
The transaction isolation level is set to SQL_TXN_VERSIONING.<br><br></li>
<li>
DBPROP_CANHOLDROWS is set to VARIANT_FALSE, <b>SQLExtendedFetch</b> and <b>SQLSetPos </b>with REFRESH are available from the underlying ODBC driver, and the cursor is not a forward-only cursor.</li>
</ul>
</li>
</ul>
<h1>IRowsetScroll</h1>
<p>
<b>IRowsetScroll</b> is supported on ODBC 3.x drivers. If a driver cannot determine the current row position, a value of 1 is returned for the row number in <b>GetApproximatePosition</b>.</p>
</font></BODY>
</HTML>
