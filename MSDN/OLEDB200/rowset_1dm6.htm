<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowset::RestartPosition</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowset__restartposition"></a>IRowset::RestartPosition</h1>
<p>
Repositions the next fetch position used by <b>GetNextRows</b> or <b>FindNextRow</b> to its initial position; that is, its position when the rowset was first created.</p>
<pre><code>HRESULT RestartPosition (
   HCHAPTER   hChapter);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The provider did not have to reexecute the command, either because the rowset supports positioning on the first row without reexecuting the command or because the rowset is already positioned on the first row.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_COLUMNSCHANGED<br>
The order of the columns was not specified in the object that created the rowset. The provider had to reexecute the command to reposition the next fetch position to its initial position, and the order of the columns changed.</p>
<p class=tl>
The provider had to reexecute the command to reposition the next fetch position to its initial position, and columns were added or removed from the rowset. This is generally due to a change in the underlying schema and is extremely uncommon.</P><p class=tl>
This return code takes precedence over DB_S_COMMANDREEXECUTED. That is, if the conditions described here and in those described in DB_S_COMMANDREEXECUTED both occur, the provider returns this code. A change to the columns generally implies that the command was reexecuted.</P><p class=dt>
</p>
<p class=indent>
DB_S_COMMANDREEXECUTED<br>
The command associated with this rowset was reexecuted. If the properties DBPROP_OWNINSERT and DBPROP_OWNUPDATEDELETE are VARIANT_TRUE, then the consumer will see its own changes. If the properties DBPROP_OWNINSERT or DBPROP_OWNUPDATEDELETE are VARIANT_FALSE, then the rowset may see its changes. The order of the columns remains unchanged.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_CANCELED<br>
<b>RestartPosition</b> was canceled during notification. The next fetch position remains unmodified.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANNOTRESTART<br>
The rowset was built over a live data stream (for example, a stock feed) and the position cannot be restarted.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The provider called a method from <b>IRowsetNotify</b> in the consumer and the method has not yet returned.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of existing rows before restarting because the Rowset will be regenerated. This may be required even if the provider supports a value of VARIANT_TRUE for DBPROP_CANHOLDROWS. For more information, see DBPROP_CANHOLDROWS and DPPROP_QUICKRESTART in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to reposition the next fetch position.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
For information about the next fetch position when the rowset is first created, see <a href="rowset_7z5f.htm">GetNextRows</a>.</p>
<p>
If the underlying command contains output parameters, <b>RestartPosition</b> should not reset those parameters.</p>
<p>
If the rowset was generated as a result of a procedure call, and the rowset is forward-only, the procedure may be reexecuted in order to satisfy the call to <b>RestartPosition</b>. This may cause other side effects. Additionally, if the stored procedure has been changed, the rowset may have a different schema. If the rowset is able to restart the next fetch position without reexecuting the procedure, <b>RestartPosition</b> should not reexecute it.</p>
<p>
How expensive <b>RestartPosition</b> is depends on the provider, the rowset characteristics, and the tables underlying the rowset. If the rowset supports <b>IRowsetLocate</b>, then <b>RestartPosition</b> is always an inexpensive operation.</p>
<p>
If the rowset is sequential, then <b>RestartPosition</b> might require reexecution of the underlying command. For some providers, this is always the case. For other providers, a rule of thumb is that rowsets built from a single table are not expensive to restart, but rowsets built by joining two or more tables are expensive to restart. If the provider reexecutes the command to restart the next fetch position, then the new rowset might return a different set of rows, differently ordered columns, and, in extreme cases, a different set of columns. Reexecution of a command by <b>RestartPosition</b> does not reinherit accessors.</p>
<p>
A provider that reports DBPROP_QUICKRESTART as VARIANT_FALSE may require that all existing row handles are released prior to successfully processing a call to <b>RestartPosition</b>.</p>
<p>
A consumer can determine whether a provider can quickly restart the next fetch position by attempting to set DBPROP_QUICKRESTART to VARIANT_TRUE. Setting this property to VARIANT_TRUE does not guarantee that the rowset can be quickly restarted because the provider is not required to honor the property. This behavior is necessary because the provider cannot evaluate the command at the time the property is set. For example, the consumer can set DBPROP_QUICKRESTART to VARIANT_TRUE and then change the command text.</p>
<p>
In implementations that require reexecution of a command to reposition the next fetch position to its initial position, the provider is responsible for caching all parameters required by the command.</p>
<p>
If <b>RestartPosition</b> returns DB_S_COLUMNSCHANGED and the consumer subsequently calls methods in <b>IColumnsInfo</b> or <b>IColumnsRowset</b>, these methods must reflect the new metadata. Existing rowset accessors are not updated to reflect the new metadata. That is, <b>IAccessor::GetBindings</b> returns exactly the same information it would have returned before <b>RestartPosition</b> was called. If such accessors are subsequently used, such as in a call to <b>GetData</b>, the provider must revalidate them. If none of the columns bound by the accessor have changed, the accessor can be used successfully. If any of the columns have changed, the appropriate error or warning is returned.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowfnd_0gfr.htm">IRowsetFind::FindNextRow</a></p>
</font></BODY>
</HTML>
