<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowset</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="irowset"></a>IRowset</h1>
<p>
<b>IRowset</b> is the base rowset interface. It provides methods for fetching rows sequentially, getting the data from those rows, and managing rows.</p>
<p>
<b>IRowset</b> requires <b>IAccessor</b> and <b>IRowsetInfo</b>.</p>
<p>
Consumers use the methods in <b>IRowset</b> for all basic rowset operations, including fetching and releasing rows and getting column values.</p>
<p>
When a consumer gets an interface pointer on a rowset, usually its first step is to determine the rowset’s capabilities by using <b>IRowsetInfo::GetProperties</b>. This returns information about the interfaces exposed by the rowset, as well as those capabilities of the rowset that do not show up as distinct interfaces. These can include the maximum number of active rows and how many rows may have pending updates at the same time.</p>
<p>
For most consumers, the next step is to determine the characteristics, or metadata, or the columns in the rowset. For simple or extended column information, they use <b>IColumnsInfo</b> or <b>IColumnsRowset</b>, respectively. These interfaces are also available on prepared commands prior to execution, allowing advance planning.</p>
<p>
The consumer determines which columns it needs, either from the metadata or on the basis of knowing the text command that generated the rowset. It determines the ordinals of the needed columns from the ordering of the column information returned by <b>IColumnsInfo</b> or from ordinals in the column metadata rowset returned by <b>IColumnsRowset</b>.</p>
<p>
Some consumers do not use a command or do not want to browse the column information They may know the name or property identifier for the columns they want to use. They call <b>IColumnsInfo::MapColumnIDs</b> to retrieve the column ordinals.</p>
<p>
The ordinals are used to specify a binding to a column. A binding is a structure that associates an element of the consumer’s structure with a column. The binding can bind the column’s data value, length, and status value. </p>
<p>
A set of bindings is gathered together in an accessor, which is created with <b>IAccessor::CreateAccessor</b>. An accessor can contain multiple bindings so that the data for multiple columns can be retrieved or set in a a single call. The consumer can create several accessors to match different usage patterns in different parts of the application. It can create and release accessors at any time while the rowset remains in existence. </p>
<p>
To fetch rows from the database, the consumer calls a method such as <b>GetNextRows</b> or <b>IRowsetLocate::GetRowsAt</b>. To create and initialize a new row to be inserted into the data source, the consumer calls <b>IRowsetChange::InsertRow</b>.</p>
<p>
The methods that fetch rows do not actually return data to the consumer. Instead, they return the handles to these rows. A local copy of the rows is stored in the rowset. </p>
<p>
After the rows are returned, the consumer can access the data in the rows. The consumer calls <b>GetData</b> and passes the handle to a row, the handle to an accessor, and a pointer to a consumer-allocated buffer. <b>GetData</b> converts the data (if it does not match the native provider storage) and returns the columns as specified in the bindings used to create the accessor. The consumer can call <b>GetData</b> more than once for a row, using different accessors and buffers. Thus, the consumer can have multiple copies of the same data. For example, if a column contains a text document, the consumer might call <b>GetData</b> with an accessor that binds the first 50 bytes of the document. When the user double-clicks the displayed heading text, the consumer can then call <b>GetData</b> with a different accessor to retrieve the entire document. </p>
<p>
Data from variable-length columns may be treated several ways. First, such columns can be bound to a finite section of the consumer’s structure, which causes truncation when the length of the data exceeds the length of the buffer. The consumer can determine that truncation has occurred by checking if the status is DBSTATUS_S_TRUNCATED. The returned length is always true length in bytes, so the consumer also determines how much data was truncated. Another way to obtain data from such columns is by reference. For example, if a binary column is bound with a type indicator of DBTYPE_BYTES|DBTYPE_BYREF, the provider allocates memory for all of the data in the column and returns this memory to the consumer.</p>
<p>
In both cases, it is likely that such large values may be best optimized as deferred columns and accessed only when necessary. Performance varies with different servers, but BLOB columns usually are stored separately from other records and may be more costly to access than ordinary columns. Therefore, they would not routinely be pulled in for browsing or scanning. </p>
<p>
Other providers may handle BLOB columns by requesting that they be delivered as OLE <b>ILockBytes</b>, <b>IStorage</b>, <b>ISequentialStream</b>, or <b>IStream</b> objects.</p>
<p>
When the consumer is finished fetching or updating rows, it releases them with <b>ReleaseRows</b>. This releases resources from the rowset’s copy of the rows and makes room for new rows. The consumer can then repeat its cycle of fetching or creating rows and accessing the data in them.</p>
<p>
When the consumer is done with the rowset, it calls <b>IAccessor:ReleaseAccessor</b> to release any accessors. To release the rowset, it calls <b>IUnknown::Release</b> on all interfaces exposed by the rowset. When the rowset is released, it forces the release of any remaining rows or accessors the consumer holds. Such handle objects are subordinate to the rowset. That is, they do not take reference counts upon the rowset and cannot cause the rowset to linger after all the interfaces for the rowset have been released. The rowset must clean up all such subordinate objects. </p>
<p>
This section discusses the Jet-specific implementation of the <b>IRowset</b> interface and its subsequent methods. This includes <b>IRowset::AddRefRows</b>,<b> IRowset::GetData</b>,<b> IRowset::GetNextRows</b>,<b> IRowset::ReleaseRows</b>, and <b>IRowset::RestartPosition</b>.</p>
<h2>Cursor and Cursor Promotion</h2>
<p>
Cursor types may be promoted or demoted by the OLE DB Driver for Access data. This cursor promotion or demotion is based upon guessing the type of cursor requested by the user, and as such is determined by the properties that are passed to the driver. Cursor types may be promoted without it being requested by the user. The driver will try to promote the cursor type if possible. This means that basetables may be updatable. If the consumer asks for properties that don’t match up with a particular cursor type, then the consumer will be promoted to the next cursor level above the minimum match. A consumer that calls <b>ICommandExecute</b> with no properties, expecting the default behavior, will be given a forward-only snapshot.</p>
<p>
Cursor types in order of precedence:
<ol>
<li>
Forward-only snapshot<br><br></li>
<li>
Snapshot<br><br></li>
<li>
Keyset<br><br></li>
<li>
Basetables — Dynaset<br><br></li>
<li>
Append-only dynasets</li>
</ol>
<h2>Regular Rowset</h2>
<h3>Becoming a Zombie </h3>
<p>
Rowsets can become zombies if the internal resource on which they depend goes away because of another transaction completing. </p>
<h3>Data type coercion </h3>
<p>
This OLE DB driver supports all the data type coercions that exist in OLE DB. For better performance, bind to the native data types.</p>
<h3>By Reference Data Binding</h3>
<p>
This OLE DB driver does not support “by reference” data binding only by value as described above.</p>
<h3>Delayed Update Mode</h3>
<p>
In delayed update mode, this driver supports at most one pending change at a time on a rowset.</p>
<h3>BLOB Support</h3>
<p>
The OLE DB Provider for Microsoft Jet supports two kinds of structured storage: <b>ISequentialStream</b> and <b>ILockBytes</b>. <b>ISequentialStream</b> can be used for long text and long binary (memo and OLE object) data types, and must read the whole BLOB. <b>ILockbytes</b> only works on the Red ISAM 3.<i>x</i> and 4.<i>x</i>. <b>ISequentialStream</b> works on any BLOB data that Jet reads. You do not read the whole BLOB with <b>ILockBytes</b>; instead, it provides random access to the user. </p>
<p>
There are restrictions on rowsets when using <b>ILockbytes</b> and <b>ISequentialStream</b>. If you have a structured storage interface open on a rowset, it may prevent you from editing a row in delayed update mode. You must release your pointers to structured interfaces to change other rows. Structured storage pointer may be invalid if you abort transactions, resulting in rowsets in a zombie state.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=50%><b>Method</b></td>
<td class=label width=50%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=50%><b>AddRefRows</b></td>
<td width=50%>Adds a reference count to an existing row handle.</td>
</tr>
<tr valign=top>
<td width=50%><b>GetData</b></td>
<td width=50%>Retrieves data from the rowset’s copy of the row.</td>
</tr>
<tr valign=top>
<td width=50%><b>GetNextRows</b></td>
<td width=50%>Fetches rows sequentially, remembering the previous position.</td>
</tr>
<tr valign=top>
<td width=50%><b>ReleaseRows</b></td>
<td width=50%>Releases rows.</td>
</tr>
<tr valign=top>
<td width=50%><b>RestartPosition</b></td>
<td width=50%>Repositions the next fetch position to its initial position; that is, its position when the rowset was first created.</td>
</tr>
</table><br>
<h3>IRowset::AddRefRows</h3>
<p>
Adds a reference count to an existing row handle. For information on how this interface is implemented, see the <i>OLE DB Programmer’s Reference</i>.</p>
<h3>IRowset::GetData</h3>
<p>
Retrieves data from the rowset’s copy of the row. For information on how this interface is implemented, see the <i>OLE DB Programmer’s Reference</i>.</p>
<h3>IRowset::GetNextRows<i> </i></h3>
<p>
Fetches rows sequentially, remembering the previous position. For information on how this interface is implemented, see the <i>OLE DB Programmer’s Reference</i>.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>If possible, try to access rows sequentially by using this routine. This will minimize the amount of work that Jet has to do to move to new rows. That is, call <b>GNR(NULL, 0, 1…)</b> to traverse through the rowset in your “default” behavior instead of using <b>GetRowsAtBookmark</b>.</p>
<h3>IRowset::ReleaseRows</h3>
<p>
Releases rows. For information on how this interface is implemented, see the <i>OLE DB Programmer’s Reference</i>.</p>
<h3>IRowset::RestartPosition</h3>
<p>
Repositions the next fetch position used by <b>GetNextRows</b> or <b>FindNextRow</b> to its initial position, that is, its position when the rowset was first created. For information on how this interface is implemented, see the <i>OLE DB Programmer’s Reference</i>. </p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>This is not an expensive operation on scrollable cursors, but it can cause query re-execution on nonscrollable cursors.</p>
</font></BODY>
</HTML>
