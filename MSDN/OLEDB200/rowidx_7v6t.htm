<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetIndex::SetRange</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetindex__setrange"></a>IRowsetIndex::SetRange</h1>
<p>
Restricts the set of row entries visible through calls to <b>IRowset::GetNextRows</b> and <b>IRowsetIndex::Seek</b>.</p>
<pre><code>HRESULT SetRange (
   HACCESSOR   hAccessor,
   ULONG         cStartKeyColumns,
   void *            pStartData,
   ULONG         cEndKeyColumns,
   void *            pEndData,
   DBRANGE      dwRangeOptions);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
The handle of the accessor to use for both *<i>pStartData</i> and *<i>pEndData</i>. This accessor must meet the following criteria, which are illustrated with a key that consists of columns A, B, and C, where A is the most significant column and C is the least significant column:
<ul type=disc>
<li>
For each key column this accessor binds, it must also bind all more significant key columns. For example, the accessor can bind column A, columns A and B, or columns A, B, and C.<br><br></li>
<li>
Key columns must be bound in order from most significant key column to least significant key column. For example, if the accessor binds columns A and B, then the first binding must bind column A and the second binding must bind column B.<br><br></li>
<li>
If the accessor binds any nonkey columns, key columns must be bound first. For example, if the accessor binds columns A, B, and the bookmark column, then the first binding must bind column A, the second binding must bind column B, and the third binding must bind the bookmark column.<p class=tl>
If the accessor does not meet these criteria, the method returns DB_E_BADBINDINFO or a status of DBSTATUS_E_BADACCESSOR for the offending column.</P><p class=tl>
If <i>hAccessor</i> is the handle of a null accessor (<i>cBindings</i> in <b>IAccessor::CreateAccessor</b> was zero), then <b>SetRange</b> does not set a range.</P></li>
</ul>
<p class=dt>
<i>cStartKeyColumns</i></p>
<p class=indent>
[in]<br>
The number of bindings in <i>hAccessor</i> for which *<i>pStartData</i> contains valid data. <b>SetRange</b> retrieves data from the first <i>cStartKeyValues</i> key columns from *<i>pStartData</i>. For example, suppose the accessor binds columns A, B, and C of the key in the previous example and <i>cStartKeyValues</i> is 2. <b>SetRange</b> retrieves data for columns A and B.</p>
<p class=dt>
<i>pStartData</i></p>
<p class=indent>
[in]<br>
A pointer to a buffer containing the starting key values of the range, at offsets that correspond to the bindings in the accessor.</p>
<p class=dt>
<i>cEndKeyColumns</i></p>
<p class=indent>
[in]<br>
The number of bindings in <i>hAccessor</i> for which *<i>pEndData</i> contains valid data. <b>SetRange</b> retrieves data from the first <i>cEndKeyValues</i> key columns from *<i>pEndData</i>. For example, suppose the accessor binds columns A, B, and C of the key in the previous example and <i>cEndKeyValues</i> is 2. <b>SetRange</b> retrieves data for columns A and B.</p>
<p class=dt>
<i>pEndData</i></p>
<p class=indent>
[in]<br>
A pointer to a buffer containing the ending key values of the range, at offsets that correspond to the bindings in the accessor.</p>
<p class=dt>
<i>dwRangeOptions</i></p>
<p class=indent>
[in]<br>
A bitmask describing the options of the range. The values in DBRANGEENUM have the following meanings:</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=32%><b>Value</b></td>
<td class=label width=68%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_<br>
INCLUSIVESTART</td>
<td width=68%>The start boundary is inclusive (the default).</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_<br>
EXCLUSIVESTART</td>
<td width=68%>The start boundary is exclusive.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_<br>
INCLUSIVEEND</td>
<td width=68%>The end boundary is inclusive (the default).</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_<br>
EXCLUSIVEEND</td>
<td width=68%>The end boundary is exclusive.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_<br>
EXCLUDENULLS</td>
<td width=68%>Exclude NULLs from the range.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_PREFIX</td>
<td width=68%>Use *<i>pStartData</i> as a prefix<i>.</i> *<i>pEndData</i> must be a null pointer. Prefix matching can be specified entirely using the inclusive and exclusive flags. However, because prefix matching is an important common case, this flag enables the consumer to specify only the *<i>pStartData</i> values, and enables the provider to interpret this request quickly.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_MATCH</td>
<td width=68%>Set the range to all keys that match *<i>pStartData</i>. *<i>pStartData</i> must specify a full key. *<i>pEndData</i> must be a null pointer. Used for fast equality match.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_MATCH_N_MASK</td>
<td width=68%>Equal to 0xFF000000.</td>
</tr>
<tr valign=top>
<td width=32%>DBRANGE_MATCH_N_SHIFT</td>
<td width=68%>Equal to 24 to indicate the number of bits to shift to get the number N.</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>dwRangeOptions</i> was invalid.</p>
<p class=tl>
<i>cStartKeyValues</i> was not zero and <i>pStartData</i> was a null pointer.</P><p class=tl>
<i>cEndKeyValues</i> was not zero and <i>pEndData</i> was a null pointer.</P><p class=tl>
<i>hAccessor</i> was the handle of a null accessor.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
An error occurred while transferring data for one or more key columns. To determine the columns for which values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOINDEX<br>
The rowset uses integrated indexes and there is no current index.</p>
<p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor</b>:</p>
<p>
E_NOINTERFACE<br>
DB_E_BADBINDINFO<br>
DB_E_BADORDINAL<br>
DB_E_BADSTORAGEFLAGS<br>
DB_E_UNSUPPORTEDCONVERSION</p>
<p class=label>
<b>Comments</b></p>
<p>
A range defines a view in the index containing a contiguous set of key values. The *<i>pStartData </i>and *<i>pEndData </i>values always specify the starting and ending positions in the range, respectively. Thus, for an ascending index, *<i>pStartData </i>contains the smaller value and *<i>pEndData </i>contains the larger value; for a descending index, *<i>pStartData </i>contains the larger value and *<i>pEndData </i>contains the smaller value.</p>
<p>
A range on the entire index is defined by calling <b>SetRange (</b><i>hAcc</i>, 0, NULL, 0, NULL, 0<b>)</b>. When a range is set, <b>Seek</b> can only position to rows in the current range.</p>
<p>
For information about how <b>SetRange</b> transfers data from *<i>pDataStart</i> and *<i>pDataEnd</i>, see "<a href="ch06pr_5iap.htm">Setting Data</a>" in Chapter 6.</p>
<h1>Inclusive and Exclusive Ranges with Ascending Indexes</h1>
<p>
The DBRANGE_INCLUSIVE* and DBRANGE_EXCLUSIVE* flags apply only to the last value in the *<i>pStartData </i>and *<i>pEndData</i> buffers. The other values are always inclusive.</p>
<p class=label>
<b>Examples with full keys</b></p>
<p class=label>
<b>a) open ranges (single column key)</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_EXCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_INCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &le; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>b) closed ranges (single column key)</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5 and <br>
X &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {10}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5 and <br>
X &lt; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {10}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5 and <br>
X &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {10}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5 and <br>
X &lt; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {10}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>c) open ranges (multicolumn key [A, B])</b></p>
<p>
The only way to specify open ranges with multicolumn indexes is by using partial keys. See the examples with partial keys below.</p>
<p>
Notice that the range A &gt; 5 and B = 1 cannot be specified because it does not correspond to a contiguous range.</p>
<p class=label>
</p>
<p class=label>
<b>d) closed ranges (multicolumn key [A, B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and<br>
B &ge; 5 and <br>
B &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {1, 5}, 2, {1, 10}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and B &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {1, 5}, 1, {1}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and B &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {1}, 2, {1, 5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>Examples with partial keys</b></p>
<p class=label>
<b>e) open ranges (multicolumn key [A, B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_EXCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &ge; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_INCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1,{5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &le; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>f) closed ranges (multicolumn key [A,B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A &gt; 5 and A &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {10}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<h1>Prefix Matching</h1>
<p>
<b>SetRange</b> provides the DBRANGE_PREFIX flag to make it easier for a consumer to formulate ranges involving keys whose value represents a prefix. Consider the text command <b>SELECT * FROM T WHERE T.A LIKE "abc*"</b>. This range can be formulated using only the inclusive and exclusive flags as follows for an ascending index:</p>
<pre><code>SetRange (hAcc, 1, {"abc"}, 1, {"abd"}, DBRANGE_INCLUSIVESTART | DBRANGE_EXCLUSIVEEND);
</code></pre>
<p>
This requires the consumer to know the collation order. The DBRANGE_PREFIX flag is provided to make it easier for the consumer to formulate this very common case as follows:</p>
<pre><code>SetRange(hAcc, 1, {"abc"}, 0, NULL, DBRANGE_PREFIX);
</code></pre>
<p class=label>
<b>Examples</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and<br>
B like "abc*"</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {1, "abc"}, 0, NULL, 
DBRANGE_PREFIX);</code></pre>
</td>
</tr>
</table><br>
<p>
This call is the same regardless of whether DBRANGE_PREFIX is used with an ascending or descending index.</p>
<h1>Equality Matching</h1>
<p>
To facilitate the formulation of ranges involving equality, the <b>SetRange</b> method offers the DBRANGE_MATCH option flag. Consider the example <b>SELECT * FROM T WHERE T.X = 5</b>. The corresponding range can be formulated in terms of the inclusive and exclusive flags as follows:</p>
<pre><code>SetRange(hAcc, 1, {5}, 1, {5}, DBRANGE_INCLUSIVESTART | DBRANGE_INCLUSIVEEND);
</code></pre>
<p>
The same range can be formulated using the match flags as follows:</p>
<pre><code>SetRange(hAcc, 1, {5}, 0, NULL, DBRANGE_MATCH);
</code></pre>
<p class=label>
<b>Example</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A = 5 and B= 6</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {5, 6}, 2, {5, 6}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 5 and B= 6</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {5, 6}, 0, NULL, 
DBRANGE_MATCH);</code></pre>
</td>
</tr>
</table><br>
<p>
These calls are the same regardless of whether DBRANGE_MATCH is used with an ascending or descending index.</p>
<p>
DBRANGE_MATCH_N is an extension of DBRANGE_MATCH, which indicates to the provider that the first N key values should be assumed to define comparison on equality. This is achieved by reserving the 8 high-order bits of <i>dwRangeOptions</i> to encode the value N. The defined values are DBRANGE_MATCH_N_SHIFT and DBRANGE_MATCH_N_MASK.</p>
<p class=label>
<b>Example</b></p>
<p>
&nbsp;a = 5, b = 6, c = 7, d = 8, e = 9, f &gt;= 10 and f &lt;= 20 becomes:</p>
<pre><code>   SetRange (hAcc, 
      6, {5,6,7,8,9,10},
      6, {5,6,7,8,9,20},
      (5 &lt;&lt; DBRANGE_MATCH_N_SHIFT) | DB_RANGE_INCLUSIVESTART | DB_RANGE_INCLUSIVEEND);
</code></pre>
<p>
Providers will check whether (<i>dwRangeOptions</i> and DBRANGE_MATCH_N_MASK) is non-zero. If so, then the key values will be interpreted by taking the first N keys encoded in the high-order bits as the keys on which to perform an equality match.</p>
<h1>Ranges That Include NULLs</h1>
<p>
To save consumers from having to determine whether NULL values sort at the start or the end of an index, DBRANGE_EXCLUDENULLS excludes NULL values from the final column specified in *<i>pStartData </i>or *<i>pEndData</i>. This value of <i>dwRangeOptions</i> can only be used with partial keys. It is equivalent to one of the following:
<ul type=disc>
<li>
If NULL values sort at the start of the index, it is equivalent to specifying an additional column in *<i>pStartData</i>, setting the value of the status of that column to DBSTATUS_S_ISNULL, and setting the DBRANGE_EXCLUSIVESTART value in <i>dwRangeOptions</i>. Thus, the range will start after the last NULL value in the column.<br><br></li>
<li>
If NULL values sort at the end of the index, it is equivalent to specifying an additional column in *<i>pEndData</i>, setting the value of the status of that column to DBSTATUS_S_ISNULL, and setting the DBRANGE_EXCLUSIVEEND value in <i>dwRangeOptions</i>. Thus, the range will end before the first NULL value in the column.</li>
</ul>
<p>
Thus, the consumer does not need to know if NULL values sort at the start or end of the index. </p>
<p>
The DBRANGE_EXCLUDENULLS flag is defined to allow consumers to easily obtain contiguous key values excluding NULLs at the start or end of the range. For multicolumn indexes (for example, [X, Y]), this means that key values for the prefix of the key must be an equality match. For example, it makes sense to set a range on <b>X = 5</b> and DBRANGE_EXCLUDENULLS, but not on <b>X BETWEEN 4 AND 6</b> and DBRANGE_EXCLUDENULLS because the range <b>X BETWEEN 4 AND 6</b> and <b>Y IS NOT NULL</b> is not contiguous. Therefore, to use DBRANGE_EXCLUDENULLS a consumer must use an equality comparison or MATCH on the prefix of a multicolumn key.</p>
<p>
To determine how an index treats NULLs, a consumer checks the information returned by <b>GetIndexInfo</b> method or the INDEXES schema rowset of <b>IDBSchemaRowset</b>.</p>
<p class=label>
</p>
<p class=label>
<b>Examples</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>X is NULL</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {NULL}, 1, {NULL}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X is not NULL</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 0, NULL, 
DBRANGE_EXCLUDENULLS);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 4 and<br>
B is not NULL</td>
<td width=75%><pre><code>SetRange(hAcc, 1,{4}, 1, {4}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND | 
DBRANGE_EXCLUDENULLS);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 4 and<br>
B is not NULL</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {4}, 0, NULL, 
DBRANGE_MATCH | DBRANGE_EXCLUDENULLS );</code></pre>
</td>
</tr>
</table><br>
<h1>Duplicate Keys</h1>
<p>
A <b>SetRange</b> request (with the exclusive flag on an ascending index allowing duplicate keys) sets the index position at the first index entry greater than the *<i>pStartData </i>value. If the index is descending, then <b>SetRange</b> sets the position at the first entry less than the *<i>pStartData </i>value.</p>
<h1>End of Range</h1>
<p>
An index is traversed using <b>IRowset::GetNextRows</b>. This method returns DB_S_ENDOFROWSET when it reaches the end of the currently set range, or when it tries to read before the beginning or after the end of the index. This method also returns DB_S_ENDOFROWSET when the rowset is being populated asynchronously and no additional rows are available at this time. To determine whether additional rows may be available, the consumer should call <b>IDBAsynchStatus::GetStatus</b> or listen for the <b>IDBAsynchNotify::OnStop</b> notification.</p>
<h1>Inclusive and Exclusive Ranges with Descending Indexes</h1>
<p>
As mentioned earlier, with descending indexes the user specifies the values that determine the start of the range using *<i>pStartData </i>and the values that determine the end of the range using *<i>pEndData</i>. The following are some examples.</p>
<p class=label>
</p>
<p class=label>
<b>Examples with full keys</b></p>
<p class=label>
<b>a) open ranges (single column key)</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_EXCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &le; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_INCLUSIVESTART);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>b) closed ranges (single column key)</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5 and <br>
X &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {10}, 1, {5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &ge; 5 and <br>
X &lt; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {10}, 1, {5}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5 and <br>
X &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {10}, 1, {5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>X &gt; 5 and <br>
X &lt; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {10}, 1, {5}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>c) open ranges (multicolumn key [A, B])</b></p>
<p>
The only way to specify open ranges with multicolumn indexes is by using partial keys. See examples with partial keys below.</p>
<p>
The range A &gt; 5 and B = 1 cannot be specified because it does not correspond to a contiguous range.</p>
<p class=label>
</p>
<p class=label>
<b>d) closed ranges (multicolumn key [A, B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and<br>
B &ge; 5 and <br>
B &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {1, 10}, 2, {1, 5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and B &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {1}, 2, {1, 5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 1 and B &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 2, {1, 5}, 1, {1}, 
DBRANGE_EXCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>Examples with partial keys</b></p>
<p class=label>
<b>e) open ranges (multicolumn key [A, B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A &gt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &ge; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 0, NULL, 1, {5}, 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A = 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 1, {5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_INCLUSIVEEND);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &lt; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_EXCLUSIVESTART);</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%>A &le; 5</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {5}, 0, NULL, 
DBRANGE_INCLUSIVESTART);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>f) closed ranges (multicolumn key [A,B])</b></p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Desired range</b></td>
<td class=label width=75%><b>SetRange call</b></td>
</tr>
<tr valign=top>
<td width=25%>A &gt; 5 and <br>
A &le; 10</td>
<td width=75%><pre><code>SetRange(hAcc, 1, {10}, 1, {5}, 
DBRANGE_INCLUSIVESTART | 
DBRANGE_EXCLUSIVEEND);</code></pre>
</td>
</tr>
</table><br>
<p class=label>
</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowidx_646j.htm">IRowsetIndex::Seek</a></p>
</font></BODY>
</HTML>
