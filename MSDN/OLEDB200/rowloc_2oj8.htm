<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetLocate::GetRowsAt</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetlocate__getrowsat"></a>IRowsetLocate::GetRowsAt</h1>
<p>
Fetches rows starting with the row specified by an offset from a bookmark.</p>
<pre><code>HRESULT GetRowsAt (
   HWATCHREGION   hReserved1,
   HCHAPTER            hChapter
   ULONG               cbBookmark,
   const BYTE *            pBookmark,
   LONG                  lRowsOffset,
   LONG                  cRows,
   ULONG *               pcRowsObtained,
   HROW **               prghRows);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hReserved1</i></p>
<p class=indent>
[in]<br>
Reserved for future use. Providers ignore this parameter.</p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>cbBookmark</i></p>
<p class=indent>
[in]<br>
The length in bytes of the bookmark. This must not be zero.</p>
<p class=dt>
<i>pBookmark</i></p>
<p class=indent>
[in]<br>
A pointer to a bookmark that identifies the base row to be used. This can be a pointer to DBBMK_FIRST or DBBMK_LAST. If <i>lRowsOffset</i> is zero, then the provider fetches this row first; otherwise the provider skips this and subsequent rows up to the count specified in the offset, then fetches the following rows.</p>
<p class=dt>
<i>lRowsOffset</i></p>
<p class=indent>
[in]<br>
The signed count of rows from the origin bookmark to the target row. Deleted rows that the provider has removed from the rowset are not counted in the skip. The first row fetched is determined by the bookmark and this offset. For example, if <i>lRowsOffset</i> is zero, the first row fetched is the bookmarked row; if <i>lRowsOffset</i> is 1, the first row fetched is the row after the bookmarked row; if <i>lRowsOffset</i> is –1, the first row fetched is the row before the bookmarked row.</p>
<p class=tl>
<i>lRowsOffset</i> can be a negative number only if the value of the DBPROP_CANSCROLLBACKWARDS property is VARIANT_TRUE.</P><p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The number of rows to fetch. A negative number means to fetch backward. <i>cRows</i> can be a negative number only if the value of the DBPROP_CANFETCHBACKWARDS property is VARIANT_TRUE.</p>
<p class=tl>
If <i>cRows</i> is zero, no rows are fetched; the fetch direction and the next fetch position are unchanged, and the provider performs no processing, returning immediately from the method invocation. Specifically, <i>lRowsOffset</i> is ignored in this situation.</P><p class=tl>
If the provider does not discover any other errors, the method returns S_OK; whether the provider checks for any other errors is provider-specific.</P><p class=tl>
See the Comments section for a full description of the semantics of <i>lRowsOffset</i> and <i>cRows</i> parameters.</P><p class=dt>
<i>pcRowsObtained</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the actual number of fetched rows. If the consumer has insufficient permission to fetch all rows, <b>GetRowsAt</b> fetches all rows for which the consumer has sufficient permission and skips all other rows. If the method fails, *<i>pcRowsObtained</i> is set to zero.</p>
<p class=dt>
<i>prghRows</i></p>
<p class=indent>
[in/out]<br>
A pointer to memory in which to return an array of handles of the fetched rows. If *<i>prghRows</i> is not a null pointer on input, it must be a pointer to memory large enough to return the handles of the requested number of rows. If *<i>prghRows</i> is a null pointer on input, the rowset allocates memory for the row handles and returns the address to this memory. The consumer releases this memory with <b>IMalloc::Free</b> after it releases the row handles. If *<i>prghRows</i> was a null pointer on input and *<i>pcRowsObtained</i> is zero on output or if the method fails, the provider does not allocate any memory and ensures that *<i>prghRows</i> is a null pointer on output.<br>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_BOOKMARKSKIPPED<br>
The following behavior is only supported on rowsets that set the DBPROP_BOOKMARKSKIPPED property to VARIANT_TRUE. If this property is VARIANT_FALSE, this return code is never returned.</p>
<p class=tl>
<i>lRowsOffset</i> was zero and the row specified by *<i>pBookmark</i> was deleted or is no longer a member of the rowset, or the row specified by the combination of *<i>pBookmark</i> and <i>lRowsOffset</i> is a row to which the consumer does not have access rights. <b>GetRowsAt</b> skipped that row. The full count of actual rows (<i>cRows</i>) will be met if there are enough rows available. The array of returned row handles does not have gaps for missing rows; the returned count is the number of rows actually fetched.</P><p class=tl>
If a row is skipped, it is counted as one of the rows to be skipped for <i>lRowsOffset</i>. For example, if an offset of 1 is requested and the bookmark points to a row which is now missing, the offset is decremented by 1 and the provider begins by fetching the next row.</P><p class=tl>
If this condition occurs along with another warning condition, the method returns the code for the other warning condition. Thus, whenever a consumer receives the return code for another warning condition, it should check to see whether this condition occurred.</P><p class=dt>
</p>
<p class=indent>
DB_S_ENDOFROWSET<br>
<b>GetRowsAt</b> reached the start or the end of the rowset or chapter and could not fetch all of the requested rows because the count extended beyond the end. The number of rows actually fetched is returned in *<i>pcRowsObtained</i>; this will be less than <i>cRows</i>.</p>
<p class=tl>
The rowset is being populated asynchronously and no additional rows are available at this time. To determine whether additional rows may be available, the consumer should call <b>IDBAsynchStatus::GetStatus</b> or listen for the <b>IDBAsynchNotify::OnStop</b> notification.</P><p class=tl>
<i>lRowsOffset</i> indicated a position either more than one row before the first row of the rowset or more than one row after the last row, and the provider was a version 2.0 or greater provider. <i>*pcRowsObtained</i> is set to zero and no rows are returned.</P><p class=dt>
</p>
<p class=indent>
DB_S_ROWLIMITEXCEEDED<br>
Fetching the number of rows specified in <i>cRows</i> would have exceeded the total number of active rows supported by the rowset. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>. This condition can occur only when there are more rows available than can be handled by the rowset. Thus, this condition never conflicts with those described in DB_S_ENDOFROWSET and DB_S_STOPLIMITREACHED, both of which imply that no more rows were available.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_STOPLIMITREACHED<br>
Fetching rows required further execution of the command, such as when the rowset uses a server-side cursor. Execution has been stopped because a resource limit has been reached. The number of rows that were actually fetched is returned in *<i>pcRowsObtained</i>.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>cbBookmark</i> was zero or <i>pBookmark</i> was a null pointer.</p>
<p class=tl>
<i>pcRowsObtained</i> or <i>prghRows</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to instantiate the rows or return the row handles.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADBOOKMARK<br>
<i>*pBookmark</i> was invalid, incorrectly formed, or DBBMK_INVALID.</p>
<p class=tl>
*<i>pBookmark</i> did not match any rows in the rowset. This includes the case when the row corresponding to the bookmark has been deleted and DBPROP_BOOKMARKSKIPPED was VARIANT_FALSE.</P><p class=atl>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Consumers should only attempt to use bookmarks that they have received from the provider. The provider is guaranteed only to handle bookmarks it gives out in a predictable manner. Attempting to use a random value as a bookmark is undefined; the provider may return DB_E_BADBOOKMARK, may return an unexpected row, or may terminate abnormally.</p><p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADSTARTPOSITION<br>
<i>lRowsOffset</i> indicated a position either more than one row before the first row of the rowset or more than one row after the last row, and the provider was a 1.<i>x</i> provider,</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTFETCHBACKWARDS<br>
<i>cRows</i> was negative and the rowset cannot fetch backward.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTSCROLLBACKWARDS<br>
<i>lRowsOffset</i> was negative and the rowset cannot scroll backward.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ROWSNOTRELEASED<br>
The provider requires release of existing rows before new ones can be fetched. For more information, see DBPROP_CANHOLDROWS in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to fetch any of the rows; no rows were fetched.<br>
</p>
<p class=label>
<b>Comments</b></p>
<p>
Given values for a bookmark, offset, and number of rows to fetch:
<ul type=disc>
<li>
The provider determines a starting position for the fetch as the bookmark plus the offset.<br><br></li>
<li>
If the starting position is off either end of the rowset, the method returns DB_E_BADSTARTPOSITION.<br><br></li>
<li>
If the starting position is in the rowset, the provider fetches rows in the specified direction until it has fetched the requested number of rows or hits the end of the rowset.<br><br></li>
<li>
If it fetches the requested number of rows, it returns S_OK. If it hits the end of the rowset, it stops fetching, returns DB_S_ENDOFROWSET, and returns the rows it has fetched.<br><br></li>
<li>
The rows are returned in rowset traversal order; that is, the direction in which they were fetched. For example, if the consumer passes the bookmark for row 10 to <b>GetRowsAt</b> and specifies <i>cRows</i> equal to –&nbsp;5 and <i>lRowsOffset</i> equal to 0, <b>GetRowsAt</b> returns rows 10 through 6. That is, *<i>prghRows</i>[0] is the handle for row 10 and *<i>prghRows</i>[4] is the handle for row 6.</li>
</ul>
<p>
The following table defines the behavior of <b>GetRowsAt</b> for all combinations of these parameters.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=19%><b>Variable</b></td>
<td class=label width=81%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=19%>N</td>
<td width=81%>Total rows in the rowset.</td>
</tr>
<tr valign=top>
<td width=19%>B</td>
<td width=81%>Row in the rowset specified by the bookmark parameters <i>cbBookmark</i> and <i>pBookmark</i>. Assume 1 &le; B &le; N, DBBMK_FIRST is equivalent to B = 1, and DBBMK_LAST is equivalent to B = N.</td>
</tr>
<tr valign=top>
<td width=19%>F</td>
<td width=81%><i>lRowsOffset</i></td>
</tr>
<tr valign=top>
<td width=19%>r</td>
<td width=81%><i>cRows</i></td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=19%><b>B + F</b></td>
<td class=label width=26%><b>r</b></td>
<td class=label width=20%><b><i>cRowsObtained</i></b></td>
<td class=label width=35%><b>Return code</b></td>
</tr>
<tr valign=top>
<td width=19%>B + F &lt; 1 or<br>
B + F &gt; N</td>
<td width=26%>N/A</td>
<td width=20%>0</td>
<td width=35%>DB_E_BADSTARTPOSITION</td>
</tr>
<tr valign=top>
<td width=19%>1 &le; B + F &le; N</td>
<td width=26%>0</td>
<td width=20%>0</td>
<td width=35%>S_OK</td>
</tr>
<tr valign=top>
<td width=19%>1 &le; B + F &le; N</td>
<td width=26%>1 &le; r &le; N&nbsp; –  B&nbsp; –  F + 1</td>
<td width=20%>r</td>
<td width=35%>S_OK</td>
</tr>
<tr valign=top>
<td width=19%>1 &le; B + F &le; N</td>
<td width=26%>r &gt; N&nbsp; –  B&nbsp; –  F + 1</td>
<td width=20%>N&nbsp; –  B&nbsp; –  F+1</td>
<td width=35%>DB_S_ENDOFROWSET</td>
</tr>
<tr valign=top>
<td width=19%>1 &le; B + F &le; N</td>
<td width=26%>r &lt; 0 and<br>
abs(r) &le; B + F</td>
<td width=20%>abs(r)</td>
<td width=35%>S_OK</td>
</tr>
<tr valign=top>
<td width=19%>1 &le; B + F &le; N</td>
<td width=26%>r &lt; 0 and<br>
abs(r) &gt; B + F</td>
<td width=20%>B + F</td>
<td width=35%>DB_S_ENDOFROWSET</td>
</tr>
</table><br>
<p>
Consumers that want to fetch forward, for example, 20 rows at a time, can use the call <b>GetRowsAt</b>( ..., B, 1, 20, ...) which allows for an easy check when reaching the end of the rowset. Similarly, consumers that want to fetch backward can use the call <b>GetRowsAt</b>(..., B, –&nbsp;1, –&nbsp;20, ...) to facilitate the detection of the beginning of the rowset. In the latter case, DBPROP_CANFETCHBACKWARDS must be set to VARIANT_TRUE.</p>
<p>
The DBPROP_BOOKMARKSKIPPED property defines the behavior for cases in which there is no exact match for the bookmark pointed to by <i>pBookmark</i>. If this property is set to VARIANT_FALSE, then DB_E_BADBOOKMARK will be returned because the corresponding position is not well-defined. The behavior when this property is set to VARIANT_TRUE is as follows:
<ul type=disc>
<li>
If <i>lRowsOffset</i> is zero, then the row is skipped, the requested number of rows are fetched from subsequent rows, and a DB_S_BOOKMARKSKIPPED warning is returned.<br><br></li>
<li>
If <i>lRowsOffset</i> and <i>cRows</i> are any value except zero, the fetch succeeds, based on the position of the row before it became invalid. For example, suppose row 20 is deleted. If a consumer calls <b>GetRowsAt</b> with <i>lRowsOffset</i> set to 5 and a bookmark that points to row 20, then <b>GetRowsAt</b> moves to row 25.</li>
</ul>
<p>
If the provider encounters a problem fetching a row&nbsp;— for example, data stored in a text file contains a letter in a numeric column&nbsp;— <b>GetRowsAt</b> fetches the row normally, returns the row handle, and returns S_OK. However, when the consumer calls <b>IRowset::GetData</b> for the row, the provider returns DBSTATUS_E_CANTCONVERTVALUE as the status for the offending column.</p>
<p>
For information about what <b>GetRowsAt</b> does when it fetches a row that it already has in its internal buffers, see "<a href="ch04pr_6pmc.htm">Uniqueness of Rows in the Rowset</a>" in Chapter 4. For information about whether <b>GetRowsAt</b> can detect changes made to rows in the rowset, see "<a href="ch05pr_18oj.htm">Visibility of Changes</a>" in Chapter 5.</p>
<p>
<b>GetRowsAt</b> increments the reference count of each row for which it returns a handle by 1. Thus, if a handle is returned for a row that has already been fetched, the reference count of that row will be greater than 1. <b>ReleaseRows</b> must be called once for each time the handle to a row has been returned.</p>
<p>
In order to use <b>GetRowsAt</b> several times in sequence to obtain successive rows, the consumer should obtain the bookmark of the last row of the previous set and use that, with a skip of 1, to position for fetching the next rows.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowloc_3nfv.htm">IRowsetLocate::GetRowsByBookmark</a>, <a href="rowscr_8vu7.htm">IRowsetScroll::GetRowsAtRatio</a></p>
</font></BODY>
</HTML>
