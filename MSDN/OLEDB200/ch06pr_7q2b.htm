<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBBINDING Structures</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbdbbinding_structures"></a>DBBINDING Structures</h1>
<p>
A binding associates a single column or parameter to the consumer's buffer, and contains information about the buffer.</p>
<p>
The DBBINDING structure describes a single binding.</p>
<pre><code>typedef struct tagDBBINDING {
   ULONG&nbsp;&nbsp;&nbsp;iOrdinal;
   ULONG&nbsp;&nbsp;&nbsp;obValue;
   ULONG&nbsp;&nbsp;&nbsp;obLength;
   ULONG&nbsp;&nbsp;&nbsp;obStatus;
   ITypeInfo * pTypeInfo;
   DBOBJECT * pObject;
   DBBINDEXT * pBindExt;
   DBPART&nbsp;&nbsp;&nbsp;dwPart;
   DBMEMOWNER&nbsp;&nbsp;&nbsp;dwMemOwner;
   DBPARAMIO eParamIO;
   ULONG&nbsp;&nbsp;&nbsp;cbMaxLen;
   DWORD&nbsp;&nbsp;&nbsp;dwFlags;
   DBTYPE&nbsp;&nbsp;&nbsp;wType;
   BYTE&nbsp;&nbsp;&nbsp;bPrecision;
   BYTE&nbsp;&nbsp;&nbsp;bScale;
} DBBINDING;
</code></pre>
<p>
The elements of this structure are used as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=25%><b>Element </b></td>
<td class=label width=75%><b>Description </b></td>
</tr>
<tr valign=top>
<td width=25%><i>iOrdinal</i></td>
<td width=75%>The ordinal of the column or parameter to which the binding applies.<p>
Column ordinals are fixed for the lifetime of the rowset. The self bookmark column is column 0 and other columns start with column 1. To retrieve column ordinals, consumers call <b>IColumnsInfo::GetColumnInfo</b>, <b>IColumnsRowset::GetColumnsRowset</b>, or <b>IColumnsInfo::MapColumnIDs</b>. If the rowset is generated from a command, the column ordinals returned by <b>GetColumnInfo</b> or <b>GetColumnsRowset</b> on the rowset must match the column ordinals returned by the same methods on the command.</p>
<p>
Parameter ordinals are determined from the text command. The first parameter is parameter one. To retrieve parameter ordinals, consumers call <b>ICommandWithParameters::GetParameterInfo</b>.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>obValue</i></td>
<td width=75%>The offset in bytes in the consumer's buffer to the value part. <i>obValue</i> is ignored unless the DBPART_VALUE bit is set in <i>dwPart</i>. For more information about the value part, see "<a href="ch06pr_5fdx.htm">Value</a>" earlier in this chapter.<p>
This offset must be properly aligned for the processor architecture of the consumer's machine. If data is improperly aligned, consumers can expect alignment faults to occur when getting and setting data values. Consumers should use addresses that are multiples of the size of the data type. For example, if <i>wType</i> is DBTYPE_I4, the value part should be DWORD aligned.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>obLength</i></td>
<td width=75%>The offset in bytes in the consumer's buffer to the length part. <i>obLength</i> is ignored unless the DBPART_LENGTH bit is set in <i>dwPart</i>. For more information about the length part, see "<a href="ch06pr_5mg8.htm">Length</a>" earlier in this chapter.<p>
The length itself is a ULONG. This offset must be properly aligned for the processor architecture of the consumer's machine; that is, it should be a multiple of <b>sizeof(ULONG)</b>. If it is improperly aligned, consumers can expect alignment faults when getting and setting length values.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>obStatus</i></td>
<td width=75%>The offset in bytes in the consumer's buffer to the status part. <i>obStatus</i> is ignored unless the DBPART_STATUS bit is set in <i>dwPart</i>. For more information about the status part, see "<a href="ch06pr_5q9f.htm">Status</a>" earlier in this chapter.<p>
The status part itself is a DBSTATUS value, which is a DWORD. This offset must be properly aligned for the processor architecture of the consumer's machine; that is, it should be a multiple of <b>sizeof(DWORD)</b>. If it is improperly aligned, consumers can expect alignment faults when getting and setting status values.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>pTypeInfo</i></td>
<td width=75%>Reserved for future use. Consumers should set <i>pTypeInfo</i> to a null pointer.</td>
</tr>
<tr valign=top>
<td width=25%><i>pObject</i></td>
<td width=75%>Pointer to a DBOBJECT structure. This structure describes how OLE objects in columns or parameters should be accessed.<pre><code>typedef struct tagDBOBJECT {
 DWORD dwFlags;
 IID iid;
} DBOBJECT;
</code></pre>
<p>
The elements of this structure are used as follows:
<ul type=disc>
<li>
<i>dwFlags</i>—The combined storage mode flags to use when creating an instance of the OLE object.<i> </i><br><br></li>
<li>
<i>iid</i>—The interface to be exposed on the OLE object.</li>
</ul>
<p>
The storage mode flags are defined by the Structured Storage model in OLE. These are:
<ul type=disc>
<li>
STGM_READ = OF_READ<br><br></li>
<li>
STGM_WRITE = OF_WRITE<br><br></li>
<li>
STGM_READWRITE = OF_READWRITE<br><br></li>
<li>
STGM_SHARE_DENY_NONE = OF_SHARE_DENY_NONE<br><br></li>
<li>
STGM_SHARE_DENY_READ = OF_SHARE_DENY_READ<br><br></li>
<li>
STGM_SHARE_DENY_WRITE = OF_SHARE_DENY_WRITE<br><br></li>
<li>
STGM_SHARE_EXCLUSIVE = OF_SHARE_EXCLUSIVE<br><br></li>
<li>
STGM_DIRECT<br><br></li>
<li>
STGM_TRANSACTED<br><br></li>
<li>
STGM_CREATE = OF_CREATE<br><br></li>
<li>
STGM_CONVERT<br><br></li>
<li>
STGM_FAILIFTHERE<br><br></li>
<li>
STGM_PRIORITY<br><br></li>
<li>
STGM_DELETEONRELEASE</li>
</ul>
<p>
<i>pObject</i> is ignored unless the DBPART_VALUE bit is set in <i>dwPart</i> and <i>wType</i> is DBTYPE_IUNKNOWN. If neither of these conditions is true, it should be set to a null pointer.</p>
<p class=indent>
<B><b>Note&nbsp; </b></B> Consumers should not set <i>wType</i> to DBTYPE_IUNKNOWN and the DBPART_VALUE bit in <i>dwPart</i> without specifying a non-null value for <i>pObject</i>. However, providers can assume in this case that the interface to be bound is IID_IUnknown.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>pBindExt</i></td>
<td width=75%>The DBBINDEXT structure can be used for future extensions to the binding structure. <i>pBindExt</i> is reserved for future use and consumers should set it to a null pointer.<pre><code>typedef struct tagDBBINDEXT{
 BYTE * pExtension;
 ULONG&nbsp; ulExtension;
} DBBINDEXT;</code></pre>
</td>
</tr>
<tr valign=top>
<td width=25%><i>dwPart</i></td>
<td width=75%>Specifies which buffer parts are to be bound to the column or parameter. It is one or more DBPARTENUM values combined; these values have the following meaning:<ul type=disc>
<li>
DBPART_VALUE—The binding includes a value part.<br><br></li>
<li>
DBPART_LENGTH—The binding includes a length part.<br><br></li>
<li>
DBPART_STATUS—The binding includes a status part.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=25%><i>dwMemOwner</i></td>
<td width=75%>For bindings in row accessors, specifies who owns memory allocated by the provider for a column and for which a pointer is returned to the consumer. For example, when <i>wType</i> is DBTYPE_BYREF | DBTYPE_STR, the provider allocates memory for the string and returns a pointer to the string to the consumer; <i>dwMemOwner</i> specifies whether the consumer or provider owns this memory. The provider ignores this when setting rowset data.<p>
The following is a description of each of these values:
<ul type=disc>
<li>
DBMEMOWNER_CLIENTOWNED—The consumer owns the memory and is responsible for freeing it.<br><br></li>
<li>
DBMEMOWNER_PROVIDEROWNED—The provider owns the memory and is responsible for freeing it. When getting data, the provider returns a pointer into its copy of the row. When using provider-owned memory, the consumer's type must exactly match the provider's type, except that if <i>wType</i> is X | DBTYPE_BYREF, the provider's type can be X or X | DBTYPE_BYREF. If a column is NULL, the provider returns a null pointer for the data value.<p class=tl>
The consumer must not write to or free the memory to which the pointer points. The lifetime of the pointer is provider specific. However, pointers to row data are guaranteed to be valid until <b>IRowset::ReleaseRows</b> is called for the row and its reference count falls to zero; a method is called for the row that might invalidate the pointer; or the rowset is released, whichever occurs first. The methods that might invalidate the pointer depend on the method that returned it. These are as follows:</P><p class=tl>
<b>Ptr returned by:Might be invalidated by:</b></P><p class=tl>
<b>GetData</b><b>DeleteRows</b> (immediate update mode)<br>
<b>RefreshVisibleData</b><br>
<b>SetData</b><br>
<b>Update</b><br>
<b>Undo</b></P><p class=tl>
<b>GetLastVisibleData</b><b>GetLastVisibleData</b></P><p class=tl>
<b>GetOriginalData</b><b>RefreshVisibleData</b><br>
<b>SetData</b><br>
<b>Update</b></P><p class=tl>
Although the consumer must not write to provider-owned memory, it can pass pointers to provider-owned memory when setting data. For example, suppose that the consumer wants to copy data efficiently from row A to row B. The consumer creates an accessor to the columns in row A in which <i>wType</i> is X | DBTYPE_BYREF and sets <i>dwMemOwner</i> to DBMEMOWNER_PROVIDEROWNED. When the consumer calls <b>IRowset::GetData</b>, the provider returns pointers to its copy of row A. The consumer then calls <b>IRowsetChange::SetData</b> for row B with the same accessor and a pointer to the memory passed to <b>GetData</b>. The provider dereferences the pointers and copies the data from the rowset's copy of row A to the rowset's copy of row B.</P></li>
</ul>
<p>
For bindings in row accessors, consumer-owned memory must be used unless <i>wType</i> is DBTYPE_BSTR, X | DBTYPE_BYREF, X | DBTYPE_ARRAY, or X | DBTYPE_VECTOR, in which case either consumer- or provider-owned memory can be used. However, provider-owned memory cannot be used if <b>IColumnsInfo::GetColumnInfo</b> returns the DBCOLUMNFLAGS_ISLONG for the column. Consumers can mix bindings for provider- and consumer-owned memory in the same accessor.</p>
<p>
For bindings in parameter accessors, consumer-owned memory must always be used.</p>
<p>
<i>dwMemOwner</i> is ignored in reference accessors.</p>
<p>
All providers must support binding to client-owned memory. Providers support provider-owned memory only if they can efficiently return a pointer to a cached value. Providers are not required to support binding deferred columns to provider-owned memory.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>eParamIO</i></td>
<td width=75%>For parameter accessors, <i>eParamIO</i> specifies whether the parameter with which the binding is associated is an input, input/output, or output parameter. Providers support only those parameter I/O types that are supported by their underlying data source. <i>eParamIO</i> is one or more DBPARAMIOENUM values combined. These values have the following meaning:<ul type=disc>
<li>
DBPARAMIO_NOTPARAM—The accessor is not used for parameters. In most cases <i>eParamIO</i> is set to this value in row accessors to remind the programmer that it is ignored.<br><br></li>
<li>
DBPARAMIO_INPUT—The parameter is an input parameter.<br><br></li>
<li>
DBPARAMIO_OUTPUT—The parameter is an output parameter.</li>
</ul>
<p>
For row accessors, <i>eParamIO</i> is ignored.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>cbMaxLen</i></td>
<td width=75%>The length in bytes of the consumer's data structure allocated for the data value. That is, it is the number of bytes allocated at offset <i>obValue</i> for the data value. <i>cbMaxLen</i> is ignored unless the DBPART_VALUE bit is set in <i>dwPart</i> and the data value stored at that location is of variable length. For information about variable-length data types, see "<a href="ch10pr_4jhv.htm">Fixed- and Variable-Length Data Types</a>" in Chapter 10.<p>
<i>cbMaxLen</i> is used as follows:
<ul type=disc>
<li>
<b>Variable-length data types</b>—The provider checks the length in bytes of variable-length data types against <i>cbMaxLen</i>. If the length is greater than <i>cbMaxLen</i>, the provider truncates the data to <i>cbMaxLen</i> bytes.<p class=tl>
When getting data, this is a warning and the provider sets the status to DBSTATUS_S_TRUNCATED and sets the length to the actual number of bytes of data available after conversion and before truncation. Thus, the consumer can determine the actual number of bytes of data available.</P><p class=tl>
When setting data, this is an error and the provider sets the status to DBSTATUS_E_CANTCONVERTVALUE; in most cases, this is a consumer programming error.</P></li>
<li>
<b>Fixed-length data types</b>—The provider ignores <i>cbMaxLen</i> for fixed-length data types and assumes that the number of bytes available in the consumer's buffer for the data is the size of the data type.<br><br></li>
<li>
<b>DBTYPE_BYREF, DBTYPE_VECTOR, DBTYPE_ARRAY</b>—The provider ignores <i>cbMaxLen</i> and assumes that the number of bytes available in the consumer's buffer is the size dictated by DBTYPE_BYREF, DBTYPE_VECTOR, or DBTYPE_ARRAY. For DBTYPE_BYREF and DBTYPE_ARRAY, this is <b>sizeof(void *)</b>. For DBTYPE_VECTOR, this is <b>sizeof(DBVECTOR)</b>.<p class=tl>
It is important to note that if DBTYPE_BYREF is combined with the type indicator for a variable-length data type, the data is not truncated to <i>cbMaxLen</i> bytes. This is because the data is in separately allocated memory, not the consumer's buffer, and <i>cbMaxLen</i> does not apply to this memory. The provider allocates this memory based on the length of the data, as bound at the offset <i>obLength</i>, so consumers can guarantee that variable-length data is not truncated if it is retrieved in this manner.</P></li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=25%><i>dwFlags</i></td>
<td width=75%><i>dwFlags</i> specifies information about how data is returned. The following flag is recognized:<pre><code>DBBINDFLAG_HTML
</code></pre>
<p>
The provider should format the returned data in HTML. If the provider does not support HTML formatting, the bit is ignored and regular text is returned. The provider will not be able to use an accessor created with the HTML flag to set data.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>wType</i></td>
<td width=75%>The indicator of the data type of the value part of the buffer. For more information about type indicators, see "<a href="appapr_9nub.htm">Type Indicators</a>" in Appendix A.<p>
This type forms an implied conversion between the buffer type and the type of the column or parameter. For information about conversions providers are required to support, see "<a href="ch10pr_5wry.htm">Data Type Conversion</a>" in Chapter 10.</p>
</td>
</tr>
<tr valign=top>
<td width=25%><i>bPrecision</i></td>
<td width=75%>The maximum precision to use when getting data and <i>wType</i> is DBTYPE_NUMERIC. This is ignored when setting data, <i>wType</i> is not DBTYPE_NUMERIC, or the DBPART_VALUE bit is not set in <i>dwPart</i>. For more information, see "<a href="appapr_0y7g.htm">Conversions Involving DBTYPE_NUMERIC or DBTYPE_DECIMAL</a>" in Appendix A.</td>
</tr>
<tr valign=top>
<td width=25%><i>bScale</i></td>
<td width=75%>The scale to use when getting data and <i>wType</i> is DBTYPE_NUMERIC or DBTYPE_DECIMAL. This is ignored when setting data, <i>wType</i> is not DBTYPE_NUMERIC or DBTYPE_DECIMAL, or the DBPART_VALUE bit is not set in <i>dwPart</i>. For more information, see "<a href="appapr_0y7g.htm">Conversions Involving DBTYPE_NUMERIC or DBTYPE_DECIMAL</a>" in Appendix A.</td>
</tr>
</table><br>
<p class=indent>
<B><b>Note&nbsp; </b></B> The offsets specified in <i>obValue</i>, <i>obLength</i>, and <i>obStatus</i> must not point to overlapping areas of memory. The provider is not required to check if this condition occurs, and consumers must be careful to avoid this condition when constructing bindings.</p>
</font></BODY>
</HTML>
