<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetUpdate::Undo</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetupdate__undo"></a>IRowsetUpdate::Undo</h1>
<p>
Undoes any changes made to a row since it was last fetched or <b>Update</b> was called for it.</p>
<pre><code>HRESULT Undo (
   HCHAPTER            hChapter,
   ULONG               cRows,
   const HROW            rghRows[],
   ULONG *               pcRows,
   HROW **               prgRows,
   DBROWSTATUS **   prgRowStatus);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hChapter</i></p>
<p class=indent>
[in]<br>
The chapter handle. For nonchaptered rowsets, <i>hChapter</i> is ignored.</p>
<p class=dt>
<i>cRows</i></p>
<p class=indent>
[in]<br>
The count of rows to undo. If <i>cRows</i> is nonzero, <b>Undo</b> undoes all pending changes in the rows specified in <i>rghRows</i>. If <i>cRows</i> is zero, <b>Undo</b> ignores <i>rghRows</i> and undoes all pending changes to all rows in the rowset.</p>
<p class=dt>
<i>rghRows</i></p>
<p class=indent>
[in]<br>
An array of handles of the rows to undo. Elements of this array can refer to rows with pending deletes.</p>
<p class=tl>
If <i>rghRows</i> includes a row that does not have any pending changes, <b>Undo</b> does not return an error. Instead, the row remains unchanged from its original state—which is the intention of <b>Undo</b>—and its row status is set to DBROWSTATUS_S_OK.</P><p class=tl>
If <i>rghRows</i> includes a duplicate row, <b>Undo</b> treats the occurrences as if the row were passed to the method two times sequentially. Thus, on the first occurrence, <b>Undo</b> undoes any pending changes. On the second occurrence, <b>Undo</b> treats the row as a row with no pending changes and leaves it in its current (now original) state.</P><p class=dt>
<i>pcRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the number of rows <b>Undo</b> attempted to undo. If this is a null pointer, no count of rows is returned. If the method fails with an error other than DB_E_ERRORSOCCURRED, *<i>pcRows</i> is set to zero.</p>
<p class=dt>
<i>prgRows</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array containing the handles of all the rows <b>Undo</b> attempted to undo. If <i>rghRows</i> is not a null pointer, then the elements of this array are in one-to-one correspondence with those in <i>rghRows</i>. For example, if a row appears twice in <i>rghRows</i>, it appears twice in *<i>prgRows</i>. When <i>rghRows</i> is not a null pointer, <b>Undo</b> does not add to the reference count of the rows it returns in *<i>prgRows</i>; the reason is that the consumer already has these row handles.</p>
<p class=tl>
If <i>rghRows</i> is a null pointer, the elements of this array are the handles of all the rows that had pending changes, regardless of whether <b>Undo</b> was successful at undoing those changes. The consumer checks *<i>prgRowStatus</i> to determine which rows were undone. When <i>rghRows</i> is a null pointer, <b>Undo</b> adds to the reference count of the rows it returns in *<i>prgRows</i>; the reason is that the consumer is not guaranteed to already have these row handles. A side effect of this is that rows with a reference count of zero but with pending changes at the time <b>Undo</b> is called are brought back into existence; that is, their reference count is increased to 1 and they must be rereleased.</P><p class=tl>
The rowset allocates memory for the array of handles and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the handles. This argument is ignored if <i>pcRows</i> is a null pointer, and must not be a null pointer otherwise. If *<i>pcRows</i> is zero on output or the method fails with an error other than DB_E_ERRORSOCCURRED, the provider does not allocate any memory and ensures that *<i>prgRows</i> is a null pointer on output.</P><p class=dt>
<i>prgRowStatus</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return an array of row status values. The elements of this array correspond one-to-one with the elements of <i>rghRows</i> (if <i>rghRows</i> is not a null pointer) or *<i>prgRows</i> (if <i>rghRows</i> is a null pointer). If no errors occur while undoing a row, the corresponding element of *<i>prgRowStatus</i> is set to DBROWSTATUS_S_OK. If an error occurs while undoing a row, the corresponding element is set as specified in DB_S_ERRORSOCCURRED. If <i>prgRowStatus</i> is a null pointer, no row status values are returned. For information about the DBROWSTATUS enumerated type, see "<a href="ch13pr_5ib7.htm">Arrays of Errors</a>" in Chapter 13.</p>
<p class=tl>
The rowset allocates memory for the row status values and returns the address to this memory; the consumer releases this memory with <b>IMalloc::Free</b> when it no longer needs the row status values. This argument is ignored if <i>cRows</i> is zero and <i>pcRows</i> is a null pointer. If <b>Undo</b> does not attempt to undo any rows or the method fails with an error other than DB_E_ERRORSOCCURRED, the provider does not allocate any memory and ensures that *<i>prgRowStatus</i> is a null pointer on output.</P><p class=tl>
</P><p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The changes in all rows were successfully undone. The following value can be returned in *<i>prgRowStatus</i>:
<ul type=disc>
<li>
The changes in the row were successfully undone. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_S_OK.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while undoing the changes in a row, but the changes in at least one row were successfully undone. Successes can occur for the reasons listed under S_OK. The following errors can occur:
<ul type=disc>
<li>
Undoing the changes in a row was canceled during notification. Changes made to the row were not undone and the corresponding element of <i>rgRowStatus</i> contains DBROWSTATUS_E_CANCELED.<br><br></li>
<li>
A row handle in <i>rghRows</i> referred to a row for which a delete had been transmitted to the data source. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_DELETED.<br><br></li>
<li>
A row handle in <i>rghRows</i> was invalid. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_INVALID.<br><br></li>
<li>
A row handle in <i>rghRows</i> referred to a row on which a storage object or OLE object was open. The corresponding element of *<i>prgRowStatus</i> contains DBROWSTATUS_E_OBJECTOPEN.<br><br></li>
<li>
The consumer encountered a recoverable, provider-specific error, such as an RPC failure when transmitting the change to a remote server. The corresponding element of <i>*prgRowStatus</i> contains DBROWSTATUS_E_FAIL.</li>
</ul>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>cRows</i> was not 0 and <i>rghRows</i> was a null pointer.</p>
<p class=tl>
<i>pcRows</i> was not a null pointer and <i>prgRows</i> was a null pointer.</P><p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to return either the handles of the rows <b>Undo</b> attempted to undo or the array of row status values.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADCHAPTER<br>
The rowset was chaptered and <i>hChapter</i> was invalid.</p>
<p class=tl>
The rowset was single-chaptered and the specified chapter was not the currently open chapter. The consumer must use the currently open chapter or release the currently open chapter before specifying a new chapter.</P><p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Errors occurred while undoing all of the rows. The provider allocates memory for *<i>prgRows</i> and *<i>prgRowStatus</i> and the consumer checks the values in *<i>prgRowStatus</i> to determine why the pending changes were not undone. The consumer frees this memory when it no longer needs the information. Errors can occur for the reasons listed under DB_S_ERRORSOCCURRED.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>Undo</b> backs any pending changes out of the specified rows and clears their pending change status. That is, it undoes any changes made to the row since it was last fetched or <b>Update</b> was called for the row. If multiple changes were made to a row, <b>Undo</b> undoes all of these changes; the provider does not remember intermediate steps. If <b>Update</b> is called for a row immediately after <b>Undo</b> is called for the row, <b>Update</b> does not transmit any changes to the data source for the row. For more information about pending changes, see "<a href="ch05pr_0ue9.htm">Changing Data</a>" in Chapter 5.</p>
<p>
How <b>Undo</b> works is best illustrated in the following examples. In the first example, <b>Undo</b> backs out any changes made since the row was last fetched from the data source:
<ol>
<li>
The consumer fetches a row.<br><br></li>
<li>
The consumer deletes the row with <b>IRowsetChange::DeleteRows</b> or updates value in it with <b>IRowsetChange::SetData</b>.<br><br></li>
<li>
The consumer repeats step 2 as often as it likes for the row, except that after it calls <b>DeleteRows</b> for the row it cannot call either <b>SetData</b> or <b>DeleteRows</b> for the row.<br><br></li>
<li>
The consumer calls <b>Undo</b> for the row. The values in the row are changed to those it had after completing step 1.</li>
</ol>
<p>
In the second example, <b>Undo</b> backs out any changes made since values were last transmitted to the data source:
<ol>
<li>
The consumer fetches a row.<br><br></li>
<li>
The consumer updates the value in a row with <b>SetData</b>.<br><br></li>
<li>
The consumer repeats step 2 as often as it likes for the row.<br><br></li>
<li>
The consumer calls <b>Update</b> for the row.<br><br></li>
<li>
The consumer deletes the row with <b>DeleteRows</b> or updates the value in it with <b>SetData</b>.<br><br></li>
<li>
The consumer repeats step 5 as often as it likes for the row, except that after it calls <b>DeleteRows</b> for the row it cannot call either <b>SetData</b> or <b>DeleteRows</b> for the row.<br><br></li>
<li>
The consumer calls <b>Undo</b> for the row. The values in the row are changed to those it had after completing step 4.</li>
</ol>
<p>
To implement <b>Undo</b>, the provider generally caches the original values just before making a change to a row and discards the cached values when <b>Undo</b> or <b>Update</b> is called for the row. This same cache can be used by <b>GetOriginalData</b> to retrieve the original data for the row.</p>
<p>
If <b>Undo</b> is called for a row with a pending insert, the row is deleted from the rowset. That is, calls to <b>IRowset::GetData</b> or <b>SetData</b> for the row fail with DB_E_DELETEDROW. The consumer must still call <b>IRowset::ReleaseRows</b> to release the row.</p>
<p>
Whether <b>Undo</b> can undo changes made to an OLE object stored in a column or to a storage object created over a BLOB depends on the value of the DBPROP_DELAYSTORAGEOBJECTS rowset property.</p>
<p>
If <b>Undo</b> is called for a row that has a reference count of zero and exists only because the row has a pending change, <b>Undo</b> releases the row and all its resources. The only exception to this is when the handle to the row is returned in *<i>prgRows</i>, in which case the reference count is set to one.</p>
<p>
The order in which <b>Undo</b> processes rows is provider-specific. If <b>Undo</b> encounters an error, it continues processing rows until it has attempted to undo all specified rows, then returns the appropriate warning. Because <b>Undo</b> is generally implemented by copying data from a cache of original data, such errors should be extremely rare and generally represent a consumer programming error, such as passing an invalid row handle.</p>
<p>
If any consumer of the rowset is using notifications, the provider sends notifications that pending changes for the specified rows are being undone.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowchg_4dk5.htm">IRowsetChange</a>, <a href="rowupd_74yp.htm">IRowsetUpdate::GetOriginalData</a>, <a href="rowupd_49gl.htm">IRowsetUpdate::Update</a></p>
</font></BODY>
</HTML>
