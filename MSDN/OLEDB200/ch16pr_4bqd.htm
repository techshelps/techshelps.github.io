<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Integrated Index Example</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbintegrated_index_example"></a>Integrated Index Example</h1>
<p>
The following code performs the same function as the code example in "Index Example," except that the index is integrated, not separate. It gains access to the Employees table through the Emp_LastName_Index index, using <b>IRowsetIndex</b> to specify and seek that range. The index has a single key column, Emp_LastName, of type DBTYPE_WSTR with a length of 30 characters.</p>
<p>
The code sample performs the following actions:
<ol>
<li>
Initializes the database and creates a session (not shown).<br><br></li>
<li>
Sets properties to request <b>IRowsetIndex</b>, which tells the rowset to use integrated indexes.<br><br></li>
<li>
Opens the Employees table with the Emp_LastName_Index index and obtains interfaces for the rowset.<br><br></li>
<li>
Gets information about the key columns in the Emp_LastName_Index.<br><br></li>
<li>
Establishes bindings for the index columns and creates an accessor for the key column.<br><br></li>
<li>
Sets a range on the rowset.<br><br></li>
<li>
Reads rows from the rowset in the specified range.</li>
</ol>
<pre><code>#include &lt;oledb.h&gt;
#include &lt;stddef.h&gt;

PrintData(OLECHAR*, DWORD);

int main() {
 &nbsp; IOpenRowset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pIOpenRowset = NULL;
 &nbsp; DBID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; IndexId, TableId;
 &nbsp; IRowsetIndex&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pIRowsetIndex = NULL;
 &nbsp; IRowset&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pIRowset = NULL;
 &nbsp; IColumnsInfo&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pIColumnsInfo = NULL;
 &nbsp; IAccessor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pIAccessor = NULL;
 &nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cColumns, cKeyCols, cProperties;
 &nbsp; DBCOLUMNINFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *rgInfo;
 &nbsp; OLECHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *pStringsBuffer;
 &nbsp; DBINDEXCOLUMNDESC&nbsp;&nbsp; *rgIndexColDesc;
 &nbsp; DBPROPSET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *rgProperties;
 &nbsp; HACCESSOR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hIndexAccessor = DB_NULL_HACCESSOR;
 &nbsp; HRESULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hr;

 &nbsp; // Initialize the database, create a session, and obtain, from the session object, a
 &nbsp; // pointer pIOpenRowset to an IOpenRowset interface. Code not shown.

 &nbsp; // Set the DBIDs for the table and the index.
 &nbsp; TableId.eKind = DBKIND_NAME;
 &nbsp; TableId.uName.pwszName = OLESTR("Employees");
 &nbsp; IndexId.eKind = DBKIND_NAME;
 &nbsp; IndexId.uName.pwszName = OLESTR("Emp_LastName_Index");

 &nbsp; // Set properties to request IRowsetIndex. 
 &nbsp; DBPROPSET rgPropSet[1];
 &nbsp; DBPROP&nbsp;&nbsp;&nbsp; rgProp[1];

 &nbsp; rgPropSet[0].rgProperties&nbsp;&nbsp;&nbsp; = rgProp;
 &nbsp; rgPropSet[0].cProperties&nbsp;&nbsp;&nbsp;&nbsp; = 1;
 &nbsp; rgPropSet[0].guidPropertySet = DBPROPSET_ROWSET;

 &nbsp; rgProp[0].dwPropertyID&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DBPROP_IRowsetIndex;
 &nbsp; rgProp[0].dwOptions&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DBPROPOPTIONS_REQUIRED;
 &nbsp; rgProp[0].dwStatus&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DBPROPSTATUS_OK;
 &nbsp; rgProp[0].colid&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = DB_NULLID;
 &nbsp; V_VT(&amp;(rgProp[0].vValue))&nbsp;&nbsp; = VT_BOOL;
 &nbsp; V_BOOL(&amp;(rgProp[0].vValue)) = VARIANT_TRUE;

 &nbsp; // Use IOpenRowset::OpenRowset to open the table with the Emp_LastName_Index index
 &nbsp; // and get a pointer to IRowsetIndex. Call QueryInterface to get pointers to
 &nbsp; // IRowset, IAccessor, and IColumnsInfo. Note that all of these interfaces are on
 &nbsp; // the base table rowset.
 &nbsp; pIOpenRowset-&gt;OpenRowset(NULL, &amp;TableId, &amp;IndexId, IID_IRowsetIndex, 1, rgPropSet,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (IUnknown**) &amp;pIRowsetIndex);
 &nbsp; pIRowsetIndex-&gt;QueryInterface(IID_IRowset, (LPVOID FAR*) &amp;pIRowset);
 &nbsp; pIRowsetIndex-&gt;QueryInterface(IID_IAccessor, (LPVOID FAR*) &amp;pIAccessor);
 &nbsp; pIRowsetIndex-&gt;QueryInterface(IID_IColumnsInfo, (LPVOID FAR*) &amp;pIColumnsInfo);

 &nbsp; // Get information about the rowset columns and information about the index.
 &nbsp; pIColumnsInfo-&gt;GetColumnInfo(&amp;cColumns, &amp;rgInfo, &amp;pStringsBuffer);
 &nbsp; pIRowsetIndex-&gt;GetIndexInfo(&amp;cKeyCols, &amp;rgIndexColDesc, &amp;cProperties, rgProperties);

 &nbsp; // Explore the DBINDEXCOLUMNDESC and DBCOLUMNINFO structures to determine which
 &nbsp; // columns are key columns and what their metadata is. For each key column, call
 &nbsp; // IColumnsInfo::MapColumnIds to determine the ordinal of the column. Suppose that
 &nbsp; // these structures show that there is a single key column (column 1) that contains
 &nbsp; // a 30-byte string. Free the structures allocated by the methods. Code not shown.

 &nbsp; // Create an accessor to use when setting the index range and seeking for values.
 &nbsp; typedef struct tagNameStruct {
 &nbsp;&nbsp;&nbsp;&nbsp; DWORD&nbsp;&nbsp; dwStatus;
 &nbsp;&nbsp;&nbsp;&nbsp; OLECHAR szLastName[30];
 &nbsp; } NameStruct;
 &nbsp; DBBINDSTATUS&nbsp;&nbsp;&nbsp;&nbsp; rgStatus[1];
 &nbsp; static DBBINDING rgIndexBinding[1] = {
 &nbsp;&nbsp;&nbsp;&nbsp; {
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Ordinal of key column
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(NameStruct, szLastName), // Offset to value
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length -- assume null termination
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; offsetof(NameStruct, dwStatus),&nbsp;&nbsp; // Offset to status
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No object
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No binding extensions
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPART_VALUE | DBPART_STATUS,&nbsp;&nbsp;&nbsp;&nbsp; // Bind value and status
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBMEMOWNER_CLIENTOWNED,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Client-owned memory
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBPARAMIO_NOTPARAM,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Not a parameter
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 30,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // cbMaxLen
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Flags ignored
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; DBTYPE_WSTR,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Bind as fixed-length string
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No scale
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No precision
 &nbsp;&nbsp;&nbsp;&nbsp; }
 &nbsp; };

 &nbsp; pIAccessor-&gt;CreateAccessor(DBACCESSOR_ROWDATA, 1, rgIndexBinding, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hIndexAccessor, rgStatus);

 &nbsp; // Set the range LastName LIKE "Smith*" and position the next fetch position to the
 &nbsp; // start of this range.
 &nbsp; NameStruct nsNameStruct;
 &nbsp; nsNameStruct.szLastName = OLESTR("Smith");
 &nbsp; nsNameStruct.dwStatus = DBSTATUS_S_OK;
 &nbsp; pIRowsetIndex-&gt;SetRange(hIndexAccessor, 1, &amp;nsNameStruct, 0, NULL, DBRANGE_PREFIX);
 
 &nbsp; // Traverse the Employees table within the range and print each name found.
 &nbsp; ULONG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cRows = 0;
 &nbsp; HROW&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *rghRows = NULL;
 &nbsp; DBROWSTATUS&nbsp; rgRowStatus[1];

 &nbsp; while(SUCCEEDED(hr=pIRowset-&gt;GetNextRows(0, 0, 1, &amp;cRows, &amp;rghRows)) &amp;&amp; cRows &gt; 0) {
 &nbsp;&nbsp;&nbsp;&nbsp; // Reuse the same accessor to get the name from the row and print it.
 &nbsp;&nbsp;&nbsp;&nbsp; pIRowset-&gt;GetData(rghRows[0], hIndexAccessor, &amp;nsNameStruct);
 &nbsp;&nbsp;&nbsp;&nbsp; PrintData(nsNameStruct.szLastName, nsNameStruct.dwStatus);

 &nbsp;&nbsp;&nbsp;&nbsp; // Release the row.
 &nbsp;&nbsp;&nbsp;&nbsp; pIRowset-&gt;ReleaseRows(cRows, rghRows, NULL, NULL, rgRowStatus);
 &nbsp; };

 &nbsp; // Release the accessor.
 &nbsp; pIAccessor-&gt;ReleaseAccessor(hIndexAccessor);

 &nbsp; // Release the rowset.
 &nbsp; pIRowsetIndex-&gt;Release();
 &nbsp; pIColumnsInfo-&gt;Release();
 &nbsp; pIAccessor-&gt;Release();
 &nbsp; pIRowset-&gt;Release();
};
</code></pre>
</font></BODY>
</HTML>
