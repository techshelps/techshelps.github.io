<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetNotify</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetnotify"></a>IRowsetNotify</h1>
<p>
<b>IRowsetNotify</b> is the <i>callback</i> interface that a <i>consumer</i> must support to connect to local notifications provided by a rowset. The notifications are intended to synchronize objects that are attached to the same rowset instance. The notifications do not reflect changes in underlying shared tables that occur through other programs or users.</p>
<p>
The notifications use the standard OLE connection point scheme for events. A rowset supports <b>IConnectionPointContainer</b> and the consumer calls <b>FindConnectionPoint</b> for IID_IRowsetNotify to obtain the correct <b>IConnectionPoint</b> interface. The consumer then advises that connection point to connect and supplies a pointer to the consumer's <b>IRowsetNotify </b>interface.</p>
<p>
For more information about notifications, see Chapter 9, "<a href="ch09pr_0ho3.htm">Notifications</a>."</p>
<h1>When to Implement</h1>
<p>
<b>IRowsetNotify</b> is implemented by consumers that require notification. If the command requests support for <b>IConnectionPointContainer</b>, then the rowset is required to support a connection point for <b>IRowsetNotify</b>. Providers should implement this connection point if they expect to work directly with general purpose consumers.</p>
<p>
Notification about transactions is not handled through rowsets. There may be multiple rowsets for each transaction, leading to a flood of events. Consumers that need to be notified of transaction activity should connect to the transaction coordinator. For more information, see "<a href="ch12pr_4lbn.htm">Notification Events</a>" in Chapter 12.</p>
<p>
<b>IRowset</b> is a prerequisite for notification.</p>
<h1>DBEVENTPHASE</h1>
<p>
Events may have phases. A phased event is a notification method that is called multiple times, each time with a different phase in the sequence. Some events do not have phases. The phases are similar to phases in two-phase commit protocol, because ensuring that all controls authorize and succeed in handling an event is a problem very similar to ensuring resource managers all agree to, and succeed in, committing a transaction.</p>
<p>
In the following descriptions, all consumer objects that connect their <b>IRowsetNotify</b> interface to the rowset are the <i>listeners</i>.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=28%><b>Value</b></td>
<td class=label width=72%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=28%>DBEVENTPHASE_<br>
OKTODO</td>
<td width=72%>Informs a listener of an impending event. All listeners must return S_OK from DBEVENTPHASE_OKTODO for the event to proceed. Any listener can cancel the event by returning S_FALSE. The listener can prepare for the event, but should do nothing irreversible or time consuming.</td>
</tr>
<tr valign=top>
<td width=28%></td>
<td width=72%>If a listener cancels the event, all listeners that have already been called will be called again with DBEVENTPHASE_FAILEDTODO.</td>
</tr>
<tr valign=top>
<td width=28%>DBEVENTPHASE_<br>
ABOUTTODO</td>
<td width=72%>Informs a listener that DBEVENTPHASE_OKTODO has been approved and all listeners can proceed to final preparations which must be reversible, but which may be lengthy. The listener should cancel this phase only if it is stopped by an error; it should have cleared all logical objections at the earlier DBEVENTPHASE_OKTODO phase.<p>
If a listener cancels the event by returning S_FALSE, all listeners that have already been called will be called again with DBEVENTPHASE_FAILEDTODO.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>DBEVENTPHASE_<br>
SYNCHAFTER</td>
<td width=72%>Informs a listener that the event has occurred after the rowset's copy of the row has been modified, but before the data source has received the change. The listener can synchronize itself with the rowset and ensure that it has no physical reason not to agree to commit the event's changes.<p>
If a listener cancels the event by returning S_FALSE, all listeners that have already been called will be called again with DBEVENTPHASE_FAILEDTODO.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>DBEVENTPHASE_<br>
FAILEDTODO</td>
<td width=72%>Informs a listener that has previously been called for this event that the event has failed. The listener should reverse all changes and synchronize with the state of the rowset.</td>
</tr>
<tr valign=top>
<td width=28%>DBEVENTPHASE_<br>
DIDEVENT</td>
<td width=72%>Informs a listener that all consumers have synchronized themselves and agreed to commit the event's changes. The listener should now commit its changes. It must comply.</td>
</tr>
</table><br>
<p>
The final phase of an event is always either DBEVENTPHASE_FAILEDTODO or DBEVENTPHASE_DIDEVENT. If the event has no phases, it is equivalent to DBEVENTPHASE_DIDEVENT.</p>
<p>
All providers must support the DBEVENTPHASE_FAILEDTODO and DBEVENTPHASE_DIDEVENT phases. Whether providers support DBEVENTPHASE_OKTODO, DBEVENTPHASE_ABOUTTODO, and DBEVENTPHASE_SYNCHAFTER is provider specific, although all but the most simple providers support these phases. To determine which phases a provider supports, a consumer calls <b>IDBProperties::GetProperties</b> for the DBPROP_NOTIFICATIONPHASES property.</p>
<p>
If a method changes multiple rows and generates a single-phased event, such as DBREASON_ROW_ACTIVATE or DBREASON_ROW_RELEASE, the provider makes a single call to <b>IRowsetNotify::OnRowChange</b> and passes an array containing the handles of all of the affected rows.</p>
<p>
If a method changes multiple rows and generates a multiphased event, such as DBREASON_ROW_UPDATE or DBREASON_ROW_UNDOCHANGE, the number of calls to <b>OnRowChange</b> for each phase depends on the DBPROP_NOTIFICATIONGRANULARITY property.</p>
<p>
It is provider-specific whether or not listeners who register after some but not all of the phases of an event have been fired are called for the remaining phases of that event. Listeners must be prepared to get only the final phases of an event upon registering for notifications on an object that is already firing notifications.</p>
<h1>DBREASON</h1>
<p>
<i>Reasons</i> are fine tunings of events. The receiver of events is expected to care only about the general effect of the event, but there may be other effects that more specialized consumers need to know about. The DBEVENT is the basic event, and the DBREASON is a single level of derived subevent.</p>
<p class=indent>
<B><b>Important</b></B> The DBREASON types may be expanded in later versions of OLE DB. <b>IRowsetNotify</b> methods must return S_OK or DB_S_UNWANTEDREASON when they receive a DBREASON value they do not recognize.</p>
<p class=indent>
Providers are not expected to add new DBREASONs to the defined set. Providers defining new DBREASONs should do so through an entirely new notification interface with its own IID.</p>
<p>
The following <b>#define</b> values are valid for DBREASON.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=39%><b>Value</b></td>
<td class=label width=61%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_ROW_<br>
ASYNCHINSERT</td>
<td width=61%>The rowset is being <i>randomly asynchronously populated</i> and one or more rows have been inserted. Only the DBEVENTPHASE_DIDEVENT phase occurs.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROWSET_<br>
FETCHPOSITIONCHANGE</td>
<td width=61%>The next fetch position changed as a result of a call to <b>IRowset::GetNextRows</b> or <b>IRowset::RestartPosition</b>. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROWSET_RELEASE</td>
<td width=61%>The rowset is being released; that is, its reference count is zero. Only the DBEVENTPHASE_DIDEVENT phase occurs. The rowset no longer exists when this event is sent out, so recipients must not make any calls upon it. Due to OLE rules, there is no way to deny permission to <b>IUnknown::Release</b>.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROWSET_CHANGED</td>
<td width=61%>The rowset metadata has changed.<p>
Pointers to interfaces on the rowset remain valid.</p>
<p>
Providers must revalidate accessors against the metadata, and this might fail due to the changes in the metadata. For example, the accessor might now specify an unsupported conversion.</p>
<p>
Consumers should free any held row handles when a notification with this DBREASON is generated, because handles to rows are likely to have become invalid. For example, <b>IRowset::GetData</b> might return DB_E_BADROWHANDLE, or <b>IRowsetUpdate::Update</b> might return DBROWSTATUS_E_INVALID. The result of passing such a row handle is provider-specific, although the provider cannot terminate abnormally.</p>
<p>
Only the DBEVENTPHASE_DIDEVENT phase occurs.</p>
</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
COLUMN_SET</td>
<td width=61%>A column value is set. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
COLUMN_RECALCULATED</td>
<td width=61%>A calculated column takes a new value because its input columns change. Only the DBEVENTPHASE_DIDEVENT phase occurs.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_ACTIVATE</td>
<td width=61%>A function, such as <b>IRowset::GetNextRows</b> or <b>IRowsetLocate::GetRowsAt</b>, caused a new set of rows to be fetched. Only the DBEVENTPHASE_DIDEVENT phase occurs.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_RELEASE</td>
<td width=61%><b>IRowset::ReleaseRows</b> was called and the row's reference count is zero. The array of row handles the provider passed to the listeners is the subset of the original array of row handles passed to <b>ReleaseRows</b>; that is, those row handles for which the reference count is zero. Only the DBEVENTPHASE_DIDEVENT phase occurs. The returned row handles might be invalid and, therefore, should not be used with any methods.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_DELETE</td>
<td width=61%><b>IRowsetChange::DeleteRows</b> has been called. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_FIRSTCHANGE</td>
<td width=61%>The first time any column in the row is set, this notification occurs. It precedes DBREASON_COLUMN_SET. All phases can occur. This event occurs only when the rowset is in delayed update mode. It occurs the first time a column in a row is modified after the row was fetched or after the last call to <b>IRowsetUpdate::Update</b> or <b>IRowsetUpdate::Undo</b>, whichever is more recent.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_INSERT</td>
<td width=61%><b>IRowsetChange::InsertRow</b> has been called. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_RESYNCH</td>
<td width=61%><b>IRowsetRefresh::RefreshVisibleData</b> has been called. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_UNDOCHANGE</td>
<td width=61%><b>IRowsetUpdate::Undo</b> has been called on a pending change row. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_UNDOINSERT</td>
<td width=61%><b>IRowsetUpdate::Undo</b> has been called on a pending insert row. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_UNDODELETE</td>
<td width=61%><b>IRowsetUpdate::Undo</b> has been called on a pending delete row. All phases can occur.</td>
</tr>
<tr valign=top>
<td width=39%>DBREASON_<br>
ROW_UPDATE</td>
<td width=61%><b>IRowsetUpdate::Update</b> has been called on a row with a pending change. All phases can occur.</td>
</tr>
</table><br>
<p>
The following table lists all rowset methods, the DBREASON values they generate, and the phases for each reason. Nested notifications occur when the consumer calls another rowset method while processing a notification.</p>
<table border=1 cellpadding=5 cols=3 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=42%><b>Method</b></td>
<td class=label width=38%><b>DBREASON generated <sup>1</sup></b></td>
<td class=label width=20%><b>Phases</b></td>
</tr>
<tr valign=top>
<td width=42%><b>IUnknown::AddRef</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IUnknown::QueryInterface</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IUnknown::Release</b></td>
<td width=38%>_ROWSET_RELEASE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowset::AddRefRows</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowset::GetData</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowset::GetNextRows</b></td>
<td width=38%>_ROW_ACTIVATE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_ROWSET_FETCHPOSITION<br>
CHANGE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowset::ReleaseRows</b></td>
<td width=38%>_ROW_RELEASE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowset::RestartPosition</b></td>
<td width=38%>_ROWSET_FETCHPOSITION<br>
CHANGE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_ROWSET_CHANGED <sup>2</sup></td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetChange::DeleteRows</b></td>
<td width=38%>_ROW_DELETE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetChange::InsertRow</b></td>
<td width=38%>_ROW_INSERT</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetChange::SetData</b></td>
<td width=38%>_ROW_FIRSTCHANGE <sup>3</sup></td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_COLUMN_SET</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_COLUMN_<br>
RECALCULATED</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetIndex::Seek</b></td>
<td width=38%>_ROWSET_FETCHPOSITION<br>
CHANGE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetLocate::Compare</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetLocate::GetRowsAt</b></td>
<td width=38%>_ROW_ACTIVATE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetLocate::<br>
GetRowsByBookmark</b></td>
<td width=38%>_ROW_ACTIVATE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetLocate::Hash</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetRefresh::GetLastVisibleData</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetRefresh::RefreshVisibleData</b></td>
<td width=38%>_ROW_RESYNCH</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetScroll::<br>
GetApproximatePosition</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetScroll::GetRowsAtRatio</b></td>
<td width=38%>_ROW_ACTIVATE</td>
<td width=20%>DIDEVENT</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetUpdate::GetOriginalData</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetUpdate::GetPendingRows</b></td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetUpdate::Undo</b></td>
<td width=38%>_ROW_UNDOCHANGE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_ROW_UNDOINSERT</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%></td>
<td width=38%>_ROW_UNDODELETE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%><b>IRowsetUpdate::Update</b></td>
<td width=38%>_ROW_UPDATE</td>
<td width=20%>All Phases</td>
</tr>
<tr valign=top>
<td width=42%>All other rowset methods</td>
<td width=38%>None</td>
<td width=20%>N/A</td>
</tr>
<tr valign=top>
<td class=mini colspan=3 width=100%><sup>1</sup>Methods generate only the listed DBREASON values, even though other reasons might seem appropriate. For example, <b>InsertRow</b> generates only DBREASON_ROW_INSERT even though DBREASON_COLUMN_SET, DBREASON_ROW_FIRSTCHANGE, and DBREASON_ROW_ACTIVATE might appear to be applicable.<p class=mini>
<sup>2</sup><b>IRowset::RestartPosition</b> generates this DBREASON only when the metadata for the columns has changed.</p>
<p class=mini>
<sup>3</sup>DBREASON_ROW_FIRSTCHANGE is generated only the first time a column in the row is changed. For more information, see the table earlier in this section.</p>
</td>
</tr>
</table><br>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=30%><b>Method</b></td>
<td class=label width=70%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=30%><a href="rownfy_9smd.htm">OnFieldChange</a></td>
<td width=70%>Notifies the consumer of any change to the value of a column.</td>
</tr>
<tr valign=top>
<td width=30%><a href="rownfy_63ol.htm">OnRowChange</a></td>
<td width=70%>Notifies the consumer of the first change to a row, or any change that affects the entire row.</td>
</tr>
<tr valign=top>
<td width=30%><a href="rownfy_5rmt.htm">OnRowsetChange</a></td>
<td width=70%>Notifies the consumer of any change affecting the entire rowset.</td>
</tr>
</table><br>
</font></BODY>
</HTML>
