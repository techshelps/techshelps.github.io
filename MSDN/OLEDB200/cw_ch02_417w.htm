<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating a Simple Control</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="creatingsimplecontrol"></a>Creating a Simple Control</h1>
<p>
To create a simple bound control, you simply add a few attributes to the control’s Object Description Language (ODL) file. The .odl file is compiled into the control’s type library and is read by the control’s container. Adding the <b>bindable</b> attribute to a property declaration tells containers that the property can be bound to a data field. Only one bindable property can have the <b>defaultbind</b> attribute, which tells containers that the property may be bound by default if the user specifies no other bindable property for binding. Adding the <b>displaybind</b> attribute to a bindable property tells containers that the property can be displayed in a list that allows a user to select properties for binding at design time. Once the control is loaded, the container exposes additional properties to allow its user to set the source and column from which data will be exchanged. </p>
<p>
For example, when the data-binding attributes are set in a control’s type library, Microsoft<sup>®</sup> Visual Basic<sup>®</sup> 5.0 exposes the <b>DataSource</b> and <b>DataField</b> extender properties on behalf of the control for the property marked <b>defaultbind</b>. The default bound property is used by the container to exchange data with the data sources. Some containers may provide additional design time UI. This allows users to add bindings for properties with the <b>bindable</b> and <b>displaybind</b> attributes. Visual Basic provides this UI through the DATABINDINGS extender property.</p>
<p>
The container transfers the property value to and from the control through standard Automation procedures. The control notifies the container of a change in the property, or requests permission to update the property using <b>IPropertyNotifySink</b>. This notifies the container whether the control is “dirty” and whether it has to retrieve the bound property’s value.</p>
<p>
When the control’s bound property is going to change, it can query the container to determine whether the data can be updated by calling <b>IPropertyNotifySink::OnRequestEdit</b>. If it is granted permission by the container, the control signals its acceptance of the new value by calling <b>IPropertyNotifySink::OnChanged</b>. This type of updating is called <i>pessimistic</i> updating.</p>
<p class=indent>
<B><b>Note&nbsp;&nbsp;&nbsp;</b></B>Although this chapter addresses control creation using the ActiveX Controls Framework, you can modify any control that you create with little effort for use with any control framework.</p>
<h1>Adding Attributes to the .odl File</h1>
<p>
The first step in creating a simple bound OLE control is to add data-binding attribute flags to desired properties in the control’s .odl file. The following table lists the possible .odl data binding attribute flags.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=21%><b>Attribute flag</b></td>
<td class=label width=79%><b>Flag description</b></td>
</tr>
<tr valign=top>
<td width=21%><b>Bindable</b></td>
<td width=79%>Set on properties supporting the <b>IPropertyNotifySink::OnChanged</b> notification. You must set this when using simple or complex data binding.</td>
</tr>
<tr valign=top>
<td width=21%><b>Requestedit</b></td>
<td width=79%>Set on properties supporting the <b>IPropertyNotifySink::OnRequestEdit</b> notification.</td>
</tr>
<tr valign=top>
<td width=21%><b>Displaybind</b></td>
<td width=79%>Set on those properties that the control recommends should be displayed to the user as bindable at design time. This is a user interface hint to the container. It must be used with the <b>bindable</b> attribute flag. If <b>bindable</b> is used without <b>displaybind</b>, properties will be accessible at run time and will not appear in the IDE.</td>
</tr>
<tr valign=top>
<td width=21%><b>Defaultbind</b></td>
<td width=79%>Indicates the single bindable property that best represents the control as a whole. The default bind property will be accessible at design time. This attribute must be used with the <b>bindable</b> attribute. Use of the <b>displaybind</b> attribute is optional if there is only one bindable property, which is the default bind property.</td>
</tr>
</table><br>
<p>
Your control's .odl file should include code similar to this:</p>
<pre><code>[id(DISPID_TEXT), propget, bindable, requestedit, displaybind, defaultbind] HRESULT get_Text([out, retval] BSTR *pbstrText);
[id(DISPID_TEXT), propput, bindable, requestedit, displaybind, defaultbind] HRESULT put_Text([in] BSTR bstrText);
</code></pre>
<p>
In Visual Basic 5.0, setting the <b>bindable</b> and <b>defaultbind</b> attributes is enough for Visual Basic to display the <b>DataSource</b> and <b>DataField</b> extender properties. Visual Basic 5.0 also recognizes <b>displaybind</b> to determine whether the control would like to have this property appear in the DataBindings dialog. If Visual Basic 5.0 finds properties marked as <b>bindable</b> and <b>displaybind</b>, it adds the DataBindings extender collection. This allows users to describe property-to-data field associations at design time. If properties are marked <b>bindable</b> without the <b>displaybind</b> attribute, the collection does not appear in the Visual Basic 5.0 property browser but is accessible at run time.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Our sample control’s Text property contains the <b>displaybind</b> attribute. This directs Visual Basic to add the DataBindings collection and allows users to add bindings through the DataBindings dialog box. You may choose to remove this attribute to eliminate the DataBindings collection if you have only one bindable property.</p>
<h1>Notifying the Container</h1>
<p>
The <b>IPropertyNotifySink</b> interface is a property notification interface used by containers that want to be notified of changes made to a property value, or sometimes disallow changes made to a property value. With the <b>bindable</b> and <b>requestedit</b> attribute flags set, the control has the responsibility to call the appropriate notifications of the <b>IPropertyNotifySink</b> interface. To query the container as to whether it allows changes on a specific property, the control calls <b>IPropertyNotifySink::OnRequestEdit</b>. If the property change is allowed, the control changes the property value and then calls <b>IPropertyNotifySink::OnChanged</b>. Without the <b>requestedit</b> attribute set, there is no need to call the <b>IPropertyNotifySink::OnRequestEdit</b> method; however, you must call <b>IPropertyNotifySink::OnChanged</b> if the <b>bindable</b> attribute is set. This ensures that the container detects changes in the bound property and performs data updates accordingly. The following is a description of the <b>IPropertyNotifySink</b> interface and its methods.</p>
<h1>IPropertyNotifySink Interface</h1>
<p>
By specifying the attributes in the .odl file and implementing the correct interfaces (such as <b>IConnectionPoint</b> and <b>IConnectionPointContainer</b>), the control can call the <b>OnRequestEdit</b> and <b>OnChanged</b> notifications. Refer to the <i>COM Programmer’s Reference </i>for more information about connectable objects. </p>
<p>
Here is a description of the <b>IPropertyNotifySink</b> interface and its member methods:</p>
<pre><code>interface IPropertyNotifySink : IUnknown
{
   HRESULT OnChanged(DISPID dispid);
   HRESULT OnRequestEdit(DISPID dispid);
};
</code></pre>
<p>
<B><b>HRESULT OnChanged(DISPID dispid)&nbsp; <br>
</b></B>The <b>OnChanged </b>method is called by the bound control to indicate that the given property has changed its value. It is the responsibility of the bound control to cause an <b>OnChanged</b> notification any time the value of the property changes, regardless of why it changed.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=16%><b>Parameter</b></td>
<td class=label width=84%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=16%><i>dispid</i></td>
<td width=84%>Indicates the property that has changed. DISPID_UNKNOWN may be passed to represent that an unspecified set of properties has changed (the sink must assume that all have changed). For efficiency, it is recommended that controls generate DISPID_UNKNOWN only when a significant number of properties change simultaneously. Note: Visual Basic 5.0 must have a valid DISPID and doesn't assume all properties have changed when DISPID_UNKNOWN is passed in.</td>
</tr>
</table><br>
<p>
<B><b>HRESULT OnRequestEdit(DISPID dispid)</b></B>  <br>
<b>OnRequestEdit</b> is called by the bound control to indicate that the given property is about to change value. <b>OnRequestEdit</b> notifications must occur before the property actually changes its value because the return value indicates whether the bound control should actually let the property change its value. This may be used by containers to implement read-only links, but it is more commonly used for pessimistic locking on records in a database.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=20%><b>Parameter/<br>
HResult</b></td>
<td class=label width=80%><b><br>
Description</b></td>
</tr>
<tr valign=top>
<td width=20%><i>dispid</i></td>
<td width=80%>Indicates the property that is about to change. DISPID_UNKNOWN may be passed to represent that an unspecified set of properties will change. For efficiency, it is recommended that controls generate DISPID_UNKNOWN only when a significant number of properties change simultaneously.</td>
</tr>
<tr valign=top>
<td width=20%>S_OK</td>
<td width=80%>Indicates that the property may change the value (for example, the record was successfully locked). Other values indicate that the property change may not occur.</td>
</tr>
</table><br>
<p>
Assuming that you have an interface pointer to the <b>IPropertyNotifySink</b> interface, the C++ code is as follows:</p>
<pre><code>if (pPropNotifySink-&gt;OnRequestEdit(dispid) != S_OK)
   // Do some action to indicate that the property cannot change.
else
   {

   // This is where you put code that changes the property.

   // Call OnChanged to notify the container that the property has changed.
   pPropNotifySink-&gt;OnChanged(dispid);
   }   
</code></pre>
<p>
For controls written using the ActiveX Controls Framework, the previous code would change to look as follows:</p>
<pre><code>if (RequestPropertyEdit(dispid))
   // Do some action to indicate that the property cannot change.
else
   {

   // This is where you put code that changes the property.

   //
   // Call PropertyChanged to notify the container that the property has changed.
   PropertyChanged(dispid);
   }
</code></pre>
<p>
<b>RequestPropertyEdit</b> and <b>PropertyChanged</b> respectively broadcast <b>OnRequestEdit</b> and <b>OnChanged</b> properly to all hosts that have an active <b>IPropertyNotifySink</b> connection to the control.</p>
</font></BODY>
</HTML>
