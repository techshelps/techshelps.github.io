<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ICommandWithParameters:: SetParameterInfo</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbicommandwithparameters__setparameterinfo"></a>ICommandWithParameters:: SetParameterInfo</h1>
<p>
Specifies the native data type of each parameter.</p>
<pre><code>HRESULT SetParameterInfo (
   ULONG                        cParams,
   const ULONG                  rgParamOrdinals[],
   const DBPARAMBINDINFO   rgParamBindInfo[]);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>cParams</i></p>
<p class=indent>
[in]<br>
The number of parameters for which to set type information. If <i>cParams</i> is zero, the type information for all parameters is discarded, and <i>rgParamOrdinals</i> and <i>rgParamBindInfo</i> are ignored.</p>
<p class=dt>
<i>rgParamOrdinals</i></p>
<p class=indent>
[in]<br>
An array of <i>cParams</i> ordinals. These are the ordinals of the parameters for which to set type information. Type information for parameters whose ordinals are not specified is not affected.</p>
<p class=dt>
<i>rgParamBindInfo</i></p>
<p class=indent>
[in]<br>
An array of <i>cParams</i> DBPARAMBINDINFO structures. If <i>rgParamBindInfo</i> is a null pointer, then the type information for the parameters specified by the ordinals in <i>rgParamOrdinals</i> is discarded.</p>
<p class=tl>
The DBPARAMBINDINFO structure is:</P><pre><code>typedef struct tagDBPARAMBINDINFO {
 LPOLESTR&nbsp;&nbsp; pwszDataSourceType;
 LPOLESTR&nbsp;&nbsp; pwszName;
 ULONG&nbsp;&nbsp;&nbsp; ulParamSize;
 DBPARAMFLAGS dwFlags;
 BYTE&nbsp;&nbsp;&nbsp;&nbsp; bPrecision;
 BYTE&nbsp;&nbsp;&nbsp;&nbsp; bScale;
} DBPARAMBINDINFO;
</code></pre>
<p class=tl>
The elements of this structure are used as follows.</P><table border=1 cellpadding=5 cols=2 frame=below rules=rows width=571>
<tr valign=top>
<td class=label width=35%><b>Element</b></td>
<td class=label width=65%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=35%><i>pwszDataSourceType</i></td>
<td width=65%>A pointer to the provider-specific name of the parameter’s data type or a standard data type name. This name is not returned by <b>GetParameterInfo</b>; instead, the provider maps the data type specified by this name to an OLE DB type indicator and returns that type indicator. For a list of standard data type names, see ""Comments.""<p>
If <i>pwszDataSourceType</i> is null, the provider attempts a default conversion from the data type specified in the binding for the parameter, or returns E_INVALIDARG if it cannot perform default parameter conversions.</p>
</td>
</tr>
<tr valign=top>
<td width=35%><i>pwszName</i></td>
<td width=65%>The name of the parameter. This is a null pointer if the parameter does not have a name.<p>
The consumer must specify a name for all or none of the parameters set at any time. If the provider does not support named parameters, this argument is ignored and the provider is not required to verify that all or none of the parameters are named.</p>
</td>
</tr>
<tr valign=top>
<td width=35%><i>ulParamSize</i></td>
<td width=65%>The maximum possible length of a value in the parameter. For parameters that use a fixed-length data type, this is the size of the data type. For parameters that use a variable-length data type, this is one of the following:<ul type=disc>
<li>
The maximum length of the parameters in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if one is defined. For example, a parameter for a CHAR(5) column in an SQL table has a maximum length of 5.<br><br></li>
<li>
The maximum length of the data type in characters, for DBTYPE_STR and DBTYPE_WSTR, or bytes, for DBTYPE_BYTES, if the parameter does not have a defined length.<br><br></li>
<li>
~0 (bitwise, the value is not 0; that is, all bits are set to 1) if neither the parameter nor the data type has a defined maximum length.</li>
</ul>
<p>
For data types that do not have a length, this is set to ~0 (bitwise, the value is not 0; that is, all bits are set to 1).</p>
<p>
This argument is ignored if <i>pwszDataSourceType</i> is null.</p>
</td>
</tr>
<tr valign=top>
<td width=35%><i>dwFlags</i></td>
<td width=65%>See the <i>dwFlags</i> element of the DBPARAMINFO structure in <a href="cmdprm_5ka7.htm">GetParameterInfo</a>.</td>
</tr>
<tr valign=top>
<td width=35%><i>bPrecision</i></td>
<td width=65%>If <i>pwszDataSourceType</i> is a numeric type, <i>bPrecision</i> is the maximum number of digits, expressed in base 10. Otherwise, it is ignored.<p>
This argument is ignored if <i>pwszDataSourceType</i> is null.</p>
</td>
</tr>
<tr valign=top>
<td width=35%><i>bScale</i></td>
<td width=65%>If <i>pwszDataSourceType</i> is a numeric type with a fixed scale, <i>bScale</i> is the number of digits to the right (if <i>bScale</i> is positive) or left (if <i>bScale</i> is negative) of the decimal point. Otherwise, it is ignored.<p>
This argument is ignored if <i>pwszDataSourceType</i> is null.</p>
</td>
</tr>
</table><br>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_TYPEINFOOVERRIDDEN<br>
The provider was capable of deriving the parameter type information and <b>SetParameterInfo</b> was called. The parameter type information specified in <b>SetParameterInfo</b> was used.</p>
<p class=tl>
<b>SetParameterInfo</b> replaced parameter type information specified in a previous call to <b>SetParameterInfo</b>.</P><p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>cParams</i> was not zero and <i>rgParamOrdinals</i> was a null pointer.</p>
<p class=tl>
An element of <i>rgParamOrdinals</i> was zero.</P><p class=tl>
In an element of <i>rgParamBindInfo</i>, the <i>pwszDataSourceType</i> element was a null pointer, and the provider does not support default parameter conversions.</P><p class=tl>
In an element of <i>rgParamBindInfo</i>, the <i>dwFlags</i> element was invalid.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADPARAMETERNAME<br>
In an element of <i>rgParamBindInfo</i>, the <i>pwszName</i> element specified an invalid parameter name. The provider does not check whether the name was correct for the specified parameter, just whether it was a valid parameter name.</p>
<p class=tl>
In one or more elements of <i>rgParamBindInfo</i>, but not all, <i>pwszName</i> was null.</P><p class=tl>
In one or more elements of <i>rgParamBindInfo</i>, <i>pwszName</i> was null and one or more parameters previously set and not overridden were specified with a non-null <i>pwszName</i>.</P><p class=tl>
In one or more elements of <i>rgParamBindInfo</i>, <i>pwszName</i> was non-null and one or more parameters previously set and not overridden were specified with a null <i>pwszName</i>.</P><p class=dt>
</p>
<p class=indent>
DB_E_BADTYPENAME<br>
In an element of <i>rgParamBindInfo</i>, the <i>pwszDataSourceType</i> element specified an invalid data type name. The provider does not check whether the data type was correct for the specified parameter, just whether it was a data type name supported by the provider.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_OBJECTOPEN<br>
A rowset was open on the command.</p>
<p class=label>
<b>Comments</b></p>
<p>
Providers generally derive parameter type information from the data source and return it to the consumer through <b>GetParameterInfo</b>. Consumers then use this information to build parameter accessors for use with <b>ICommand::Execute</b>.</p>
<p>
Some providers—notably many SQL database providers—cannot derive parameter type information from the data source. For these providers, the consumer must supply the native parameter type information through <b>SetParameterInfo</b>. The provider uses the type information specified by <b>SetParameterInfo</b> to determine how to convert parameter data from the type supplied by the consumer (as indicated by the <i>wType</i> value in the binding structure) to the native type used by the data source. When the consumer specifies a data type with known precision, scale, and size values, any information supplied by the consumer for precision, scale, or size should be ignored by the provider.</p>
<p>
The information that the consumer supplies must be correct and must be supplied for all parameters. Providers that cannot derive parameter type information cannot verify the supplied information against the parameter metadata, although they can determine that the specified values are legal values for the provider. Such providers sometimes cannot even determine the number of parameters in the command. The result of executing a command using incorrect parameter information or passing parameter information for the wrong number of parameters is undefined. For example, if the parameter type is LONG and the consumer specifies a type indicator of DBTYPE_STR in <b>SetParameterInfo</b>, the provider converts the data to a string before sending it to the data source. Because the data source is expecting a LONG, this will likely result in an error.</p>
<p>
When the consumer calls <b>SetParameterInfo</b>, it specifies a provider-specific data type name (as derived from the PROVIDER_TYPES schema rowset) or a standard type name. If the consumer passes a standard type name, the provider maps it to a provider-specific type name. For example, a provider for an SQL DBMS might map ""DBTYPE_I2"" to ""SMALLINT"".</p>
<p>
The following is a list of standard type names and their associated type indicators. This list contains many commonly known types. Individual providers may allow other, provider-specific names as well.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=48%><b>Standard type name</b></td>
<td class=label width=52%><b>Type indicator</b></td>
</tr>
<tr valign=top>
<td width=48%>""DBTYPE_I1""</td>
<td width=52%>DBTYPE_I1</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_I2"</td>
<td width=52%>DBTYPE_I2</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_I4"</td>
<td width=52%>DBTYPE_I4</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_I8"</td>
<td width=52%>DBTYPE_I8</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_UI1"</td>
<td width=52%>DBTYPE_UI1</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_UI2"</td>
<td width=52%>DBTYPE_UI2</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_UI4"</td>
<td width=52%>DBTYPE_UI4</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_UI8"</td>
<td width=52%>DBTYPE_UI8</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_R4"</td>
<td width=52%>DBTYPE_R4</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_R8"</td>
<td width=52%>DBTYPE_R8</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_CY"</td>
<td width=52%>DBTYPE_CY</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_DECIMAL"</td>
<td width=52%>DBTYPE_DECIMAL</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_NUMERIC"</td>
<td width=52%>DBTYPE_NUMERIC</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_BOOL"</td>
<td width=52%>DBTYPE_BOOL</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_ERROR"</td>
<td width=52%>DBTYPE_ERROR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_UDT"</td>
<td width=52%>DBTYPE_UDT</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_VARIANT"</td>
<td width=52%>DBTYPE_VARIANT</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_IDISPATCH"</td>
<td width=52%>DBTYPE_IDISPATCH</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_IUNKNOWN"</td>
<td width=52%>DBTYPE_IUNKNOWN</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_GUID"</td>
<td width=52%>DBTYPE_GUID</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_DATE"</td>
<td width=52%>DBTYPE_DATE</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_DBDATE"</td>
<td width=52%>DBTYPE_DBDATE</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_DBTIME"</td>
<td width=52%>DBTYPE_DBTIME</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_DBTIMESTAMP"</td>
<td width=52%>DBTYPE_DBTIMESTAMP</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_BSTR"</td>
<td width=52%>DBTYPE_BSTR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_CHAR"</td>
<td width=52%>DBTYPE_STR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_VARCHAR"</td>
<td width=52%>DBTYPE_STR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_LONGVARCHAR"</td>
<td width=52%>DBTYPE_STR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_WCHAR"</td>
<td width=52%>DBTYPE_WSTR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_WVARCHAR"</td>
<td width=52%>DBTYPE_WSTR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_WLONGVARCHAR"</td>
<td width=52%>DBTYPE_WSTR</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_BINARY"</td>
<td width=52%>DBTYPE_BYTES</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_VARBINARY"</td>
<td width=52%>DBTYPE_BYTES</td>
</tr>
<tr valign=top>
<td width=48%>"DBTYPE_LONGVARBINARY"</td>
<td width=52%>DBTYPE_BYTES</td>
</tr>
</table><br>
<p>
After the consumer calls <b>SetParameterInfo</b> to specify the parameter type information, it can call <b>GetParameterInfo</b> to retrieve the type indicator for each parameter. These values—which are based on the information specified in <b>SetParameterInfo</b>—represent the best fit of OLE DB types to the native parameter types. The provider guarantees that, if the consumer uses these types in a parameter accessor, it will be able to convert the data from the OLE DB type to the native parameter type.</p>
<p>
If the provider can derive parameter type information and the consumer calls <b>SetParameterInfo</b>, <b>SetParameterInfo</b> uses the specified type information and returns DB_S_TYPEINFOOVERRIDDEN. Because deriving type information can be an expensive operation, this may result in more efficient code.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="cmdprm_5ka7.htm">ICommandWithParameters::GetParameterInfo</a></p>
</font></BODY>
</HTML>
