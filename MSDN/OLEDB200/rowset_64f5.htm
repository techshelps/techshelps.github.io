<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowset::GetData</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowset__getdata"></a>IRowset::GetData</h1>
<p>
Retrieves data from the rowset's copy of the row.</p>
<pre><code>HRESULT GetData (
   HROW            hRow,
   HACCESSOR   hAccessor,
   void *            pData);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hRow</i></p>
<p class=indent>
[in]<br>
The handle of the row from which to get the data.</p>
<p class=atl>
<B><b>Caution&nbsp;&nbsp; </b></B>The consumer must ensure that <i>hRow</i> contains a valid row handle; the provider might not validate <i>hRow</i> before using it. The result of passing the handle of a deleted row is provider-specific, although the provider cannot terminate abnormally. For example, the provider might return DB_E_BADROWHANDLE, DB_E_DELETEDROW, or it might get data from a different row. The result of passing an invalid row handle in <i>hRow</i> is undefined.</p><p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
The handle of the accessor to use. If <i>hAccessor</i> is the handle of a null accessor (<i>cBindings</i> in <b>IAccessor::CreateAccessor</b> was zero), then <b>GetData</b> does not get any data values.</p>
<p class=atl>
<B><b>Caution&nbsp;&nbsp; </b></B>The consumer must ensure that <i>hAccessor</i> contains a valid accessor handle; the provider might not validate <i>hAccessor</i> before using it. The result of passing an invalid accessor handle in <i>hAccessor</i> is undefined.</p><p class=dt>
<i>pData</i></p>
<p class=indent>
[out]<br>
A pointer to a buffer in which to return the data. The consumer allocates memory for this buffer. This pointer must be a valid pointer to a contiguous block of consumer-owned memory into which the data will be written.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The status of all columns bound by the accessor is set to DBSTATUS_S_OK, DBSTATUS_S_ISNULL, or DBSTATUS_S_TRUNCATED.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while returning data for one or more columns, but data was successfully returned for at least one column. To determine the columns for which data was returned, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Getting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pData</i> was a null pointer and the accessor was not a null accessor.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid. Providers are not required to check for this condition, because doing so might slow the method significantly.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADROWHANDLE<br>
<i>hRow</i> was invalid. Providers are not required to check for this condition, because doing so might slow the method significantly.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DELETEDROW<br>
<i>hRow</i> referred to a pending delete row or a row for which a deletion had been transmitted to the data source. Providers are not required to check for this condition, because doing so might slow the method significantly. </p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Errors occurred while returning data for all columns. To determine what errors occurred, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Getting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor:</b></p>
<p>
E_NOINTERFACE<br>
DB_E_BADBINDINFO<br>
DB_E_BADORDINAL<br>
DB_E_BADSTORAGEFLAGS<br>
DB_E_UNSUPPORTEDCONVERSION</p>
<p class=label>
<b>Comments</b></p>
<p>
This method makes no logical change to the state of the object.</p>
<p>
A consumer calls <b>GetData</b> to retrieve data from rows that have been fetched by prior calls to methods such as <b>GetNextRows</b>. For a complete description of how <b>GetData</b> retrieves data, see "<a href="ch06pr_54dd.htm">Getting Data</a>" in Chapter 6.</p>
<p>
A consumer can call <b>GetData</b> any number of times. In each call, it can pass a different accessor and the address of a different buffer. This means that the consumer can get as many copies of the data as it wants, and it can get data in different types if alternate conversions are available.</p>
<p>
<b>GetData</b> does not enforce any security restrictions. The provider must not create a rowset that includes columns for which the consumer does not have read privileges, so <b>GetData</b> never encounters problems accessing the data for a column. The rowset can contain columns to which the consumer does not have write permission if DBPROP_COLUMNRESTRICT is VARIANT_TRUE. The methods that fetch rows must not return the handles of rows for which the consumer does not have read privileges, so <b>GetData</b> never encounters problems accessing a row. Such rows might exist if the DBPROP_ROWRESTRICT property is VARIANT_TRUE.</p>
<p>
If <b>GetData</b> fails, the memory to which <i>pData</i> points is not freed but its contents are undefined. If, before <b>GetData</b> failed, the provider allocated any memory for return to the consumer, the provider frees this memory and does not return it to the consumer.</p>
<p>
<b>GetData</b> must be reentrant during notifications. If the provider calls a method from <b>IRowsetNotify</b> in the consumer, the consumer must be able to call <b>GetData</b> while processing the notification method.</p>
<p>
The following example shows how a reference accessor is used.</p>
<pre><code>#include &lt;oledb.h&gt; 
#include &lt;stddef.h&gt;

IRowset *TheRowset;
IAccessor *TheRowsetAccessor;
HROW&nbsp;&nbsp; hRow;

int main() {
 struct ExactlyTheSame {
  long l;
  double d;
  short&nbsp; i;
 };
 HACCESSOR hRawAccess;

 static DBBINDING ExactBindings [3] = {
  {
 &nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (ExactlyTheSame,l), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,&nbsp; // Ignored
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (long),
 &nbsp; 0,
 &nbsp; DBTYPE_I4,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  },
  {
 &nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (ExactlyTheSame, d), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,&nbsp;&nbsp; // Ignored
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (double),
 &nbsp; 0,
 &nbsp; DBTYPE_R8,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  },
  {
 &nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (ExactlyTheSame,i), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,&nbsp; // Ignored
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (short),
 &nbsp; 0,
 &nbsp; DBTYPE_I2,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  }
 };

 TheRowsetAccessor-&gt;CreateAccessor (DBACCESSOR_PASSBYREF, 3, ExactBindings, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hRawAccess, NULL);
</code></pre>
<p>
To read the column <i>i</i> of some row, the consumer should do the following:</p>
<pre><code>short&nbsp;&nbsp;&nbsp;&nbsp; value;
ExactlyTheSame *pRow;

TheRowset-&gt;GetData(hRow, hRawAccess, &amp;pRow);

value = pRow-&gt;i;
</code></pre>
<p>
The following example shows how provider-owned memory is used.</p>
<pre><code>#include &lt;oledb.h&gt; 
#include &lt;stddef.h&gt;

IRowset *TheRowset;
IAccessor *TheRowsetAccessor;
HROW&nbsp;&nbsp; hRow;

int main() {
 struct IndirectlySimilar {
  long * pl;
  double * pd;
  short * pi;
 };
 HACCESSOR hFastAccess;

 static DBBINDING IndirectBindings [3] = {
  {
 &nbsp; 1,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (IndirectlySimilar, pl), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (long*),
 &nbsp; 0,
 &nbsp; DBTYPE_BYREF|DBTYPE_I4,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  },
  {
 &nbsp; 2,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (IndirectlySimilar, pd), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof (double*),
 &nbsp; 0,
 &nbsp; DBTYPE_BYREF|DBTYPE_R8,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  },
  {
 &nbsp; 3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // iOrdinal
 &nbsp; offsetof (IndirectlySimilar,pi), // obValue
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No length binding
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Status binding
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No TypeInfo
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Object
 &nbsp; NULL,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Extensions
 &nbsp; DBPART_VALUE,
 &nbsp; DBMEMOWNER_PROVIDEROWNED,
 &nbsp; DBPARAMIO_NOTPARAM,
 &nbsp; sizeof(short*),
 &nbsp; 0,
 &nbsp; DBTYPE_BYREF|DBTYPE_I2,
 &nbsp; 0,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Precision
 &nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // No Scale
  }
 };

 TheRowsetAccessor-&gt;CreateAccessor (DBACCESSOR_ROWDATA, 3, IndirectBindings, 0,
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &amp;hFastAccess, NULL );
</code></pre>
<p>
To read the column <i>i</i> of some row, the consumer should do the following:</p>
<pre><code>short&nbsp;&nbsp;&nbsp;&nbsp;    value;
IndirectlySimilar   rowPs;

TheRowset-&gt;GetData (hRow, hFastAccess, &amp;rowPs);

if (rowPs.pi)&nbsp;&nbsp;&nbsp; // Avoid null pointers
 value = *(rowPs.pi);
</code></pre>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_7z5f.htm">IRowset::GetNextRows</a>, <a href="rowchg_0c81.htm">IRowsetChange::SetData</a></p>
</font></BODY>
</HTML>
