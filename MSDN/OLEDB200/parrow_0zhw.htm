<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IParentRowset</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbiparentrowset"></a>IParentRowset</h1>
<p>
<b>IParentRowset</b> is used to retrieve child rowsets from a hierarchical rowset. For more information, see "<a href="ch04pr_5enn.htm">Hierarchical Rowsets</a>" in Chapter 4.</p>
<h1>When to Implement</h1>
<p>
<b>IParentRowset</b> is a mandatory interface on a hierarchical rowset. </p>
<h1>When to Call</h1>
<p>
The consumer calls <b>IParentRowset::GetChildRowset</b> in order to create an aggregated instance of the child rowset corresponding to a chapter-valued column in the parent rowset.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=27%><b>Method</b></td>
<td class=label width=73%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=27%><a href="#oledbiparentrowset__getchildrowset">GetChildRowset</a></td>
<td width=73%>Returns the child rowset corresponding to a chapter-valued column in the parent rowset.</td>
</tr>
</table><br>

<h1><a name="oledbiparentrowset__getchildrowset"></a>IParentRowset::GetChildRowset</h1>
<p>
Returns the child rowset corresponding to a chapter-valued column in the parent rowset.</p>
<pre><code>HRESULT GetChildRowset(
   IUnknown *      pUnkOuter,
   ULONG            iOrdinal,
   REFIID         riid,
   IUnknown **   ppRowset);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>pUnkOuter</i></p>
<p class=indent>
[in]<br>
A pointer to the controlling <b>IUnknown</b> interface if the object is being created as part of an aggregate; otherwise, it is a null pointer.</p>
<p class=dt>
<i>iOrdinal</i></p>
<p class=indent>
[in]<br>
The ordinal of the chapter-valued column in the parent rowset. </p>
<p class=dt>
<i>riid</i></p>
<p class=indent>
[in]<br>
The requested interface to return in <i>*ppRowset</i>.</p>
<p class=dt>
<i>ppRowset</i></p>
<p class=indent>
[out]<br>
A pointer to memory in which to return the interface for the child rowset. If an error occurs, *<i>ppRowset</i> is set to a null pointer.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Value</b></p>
<p class=dt>
</p>
<p class=indent>
S_OK<br>
The method succeeded.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>ppRowset</i> was a null pointer.</p>
<p class=dt>
</p>
<p class=indent>
E_NOINTERFACE<br>
The interface specified in <i>riid</i> was not supported on the rowset.</p>
<p class=dt>
</p>
<p class=indent>
E_OUTOFMEMORY<br>
The provider was unable to allocate sufficient memory in which to create the rowset.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOAGGREGATION<br>
<i>pUnkOuter</i> was not a null pointer, and <i>riid</i> was not IID_IUnknown. </p>
<p class=dt>
</p>
<p class=dt>
DB_E_OBJECTOPEN</p>
<p class=indent>
The referenced rowset has already been opened. </p>
<p class=dt>
The provider is single-chaptered, and a child rowset is still open.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADORDINAL<br>
The column specified by <i>iOrdinal</i> was not a chapter-valued column, or did not exist.</p>
<p class=dt>
</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>GetChildRowset</b> can be called only once for each child rowset and, if called, must be called before any calls to <b>GetReferencedRowset</b> for that child. The <i>pUnkOuter</i> argument specified in <b>GetChildRowset</b> defines the controlling unknown for all references to that child rowset for the lifetime of the parent.&nbsp; The parent rowset must use <i>addref</i> on this controlling unknown to guarantee that it doesn’t go away before the parent. Even though the controlling unknown is constant for the lifetime of the parent, the consumer must not assume that rowset state, such as accessors, row position, and so on, are held when all references to the rowset are released. Furthermore, providers must ensure that the next fetch position within the child rowset is reset once all references to that child rowset have been released. Calling <b>GetChildRowset</b> for a child rowset that has already been obtained returns DB_E_OBJECTOPEN.</p>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowinf_70dw.htm">IRowsetInfo::GetReferencedRowset</a></p>
</font></BODY>
</HTML>
