<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>String Manipulation</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="stringmanipulation"></a>String Manipulation</h1>
<p>
The ActiveX controls framework provides a robust system of macros for manipulating strings in all the ways that you will see while working with an ActiveX control.</p>
<h1>Types of Strings</h1>
<p>
There are different types of strings in Automation. It’s important to understand them when working with COM, because the potential for memory leaks and bugs associated with strings is very great.</p>
<p>
There are two fundamental types of strings: multibyte (which can be ANSI or double byte) and unicode strings. Of the former, you almost always work with some sort of char * pointer (LPSTR, LPCSTR). Of the latter, a few types are commonly used—most notably WCHAR * (LPWSTR, LPWCSTR), BSTR, and OLESTR strings.</p>
<p>
LPWSTR pointers are just that— pointers to a wide string. An LPOLESTR pointer is much the same, with some additional COM rules added to it. An OLESTR is merely a wide string, but when it is an out-parameter to a function, it should be allocated using the host's <b>IMalloc</b> allocator (for example, <b>CoTaskMemAlloc</b>).</p>
<p>
A BSTR is a string with a length prefix in the memory location preceding the string. To work with a BSTR, you need to use special APIs designed exclusively for them, notably <b>SysAllocString</b>, <b>SysFreeString</b>, and <b>SysStringLen</b>. For more details, see the <i>Automation Programmer’s Reference,</i> available on MSDN and from Microsoft Press<sup>®</sup>.</p>
<p>
These data types are fully interchangeable in terms of compares and copies, but they are not interchangeable in terms of allocation and freeing. It is not acceptable to call <b>SysFreeString</b> on an OLESTR or LPWSTR string.</p>
<p>
Variables of type BSTR and OLESTR as <i>in</i> parameters to functions should not be freed as per standard OLE COM conventions. Variables of type BSTR and OLESTR as <i>out</i> parameters should be expected to be freed, and should thus be allocated appropriately.</p>
<h1>Working with Strings</h1>
<p>
For the most part, your controls will be working with multibyte strings, except when you work with OLE. Therefore, in various scenarios you'll either be given a wide string, and need the multibyte version of it, or you'll have a multibyte string, and need a wide string for it.</p>
<p>
To solve these problems, the ActiveX controls framework includes the following macros to work with:
<ul type=disc>
<li>
<b>MAKE_WIDEPTR_FROMANSI</b>(<i>newstringname, convertme</i>)<br><br></li>
<li>
<b>MAKE_ANSIPTR_FROMWIDE</b>(<i>newstringname, convertme</i>)<br><br></li>
<li>
<b>BSTRFROMANSI</b>(<i>ansistr</i>)<br><br></li>
<li>
<b>OLESTRFROMANSI</b>(<i>ansistr</i>)<br><br></li>
<li>
<b>BSTRFROMRESID</b>(<i>resourceid</i>)<br><br></li>
<li>
<b>OLESTRFROMRESID</b>(<i>resourceid</i>)<br><br></li>
<li>
<b>COPYOLESTR</b>(<i>copyme</i>)<br><br></li>
<li>
<b>COPYBSTR</b>(<i>copyme</i>)</li>
</ul>
<p>
The first two macros take a string of a given type and name, and create a variable of the new name; do not declare a variable of this name yourself and then convert the other string into the new variable. This cannot be used as an rvalue in C/C++ expressions, nor can it be an lvalue; it needs to sit on a line by itself.</p>
<p>
The last set of macros does all the remaining interesting work. You can get a variable of type BSTR or use a variable of type OLESTR, created by the <b>IMalloc</b> interface, from an ANSI string, or you can copy the OLESTR and BSTR variables. The only additional functions of interest are those that take a WORD, which is a resource ID, and load in a string from your localization DLL (or the main DLL if you don't do satellite localization) and make either a BSTR or OLESTR out of it. This proves useful in a few places where you need a localized string.</p>
<p>
Remember that while these macros were designed with a certain amount of speed in mind, converting strings is not a cheap operation. Control writers should try to avoid string conversions.</p>
</font></BODY>
</HTML>
