<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Column IDs</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbcolumn_ids"></a>Column IDs</h1>
<p>
Consumers use column IDs to identify columns, primarily in commands where there are no stable ordinals. Because column IDs are relatively slow to use, consumers use column ordinals to identify columns in bindings. A consumer calls <b>IColumnsInfo::MapColumnIDs</b> to retrieve a column ordinal from a column ID:</p>
<pre><code>typedef struct&nbsp; tagDBID {
 union {
  GUID guid;
  GUID * pguid;
 } uGuid;
 DBKIND eKind;
 union {
  LPOLESTR pwszName;
  ULONG&nbsp; ulPropid;
 } uName;
} DBID;
</code></pre>
<p>
The values of DBKIND are described in the following table.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=41%><b>Value</b></td>
<td class=label width=59%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID_NAME</td>
<td width=59%>Use the <i>guid</i> and <i>pwszName</i> elements.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID_PROPID</td>
<td width=59%>Use the <i>guid</i> and <i>ulPropid</i> elements.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_NAME</td>
<td width=59%>Use only the <i>pwszName</i> element; ignore the <i>uGuid</i> element.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PGUID_NAME</td>
<td width=59%>Use the <i>pGuid</i> and <i>pwszName</i> elements.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PGUID_PROPID</td>
<td width=59%>Use the <i>pGuid</i> and <i>ulPropid</i> elements.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PROPID</td>
<td width=59%>Use only the <i>ulPropid</i> element; ignore the <i>uGuid</i> element.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID</td>
<td width=59%>Use only the <i>guid</i> element; ignore the <i>uName</i> element.</td>
</tr>
</table><br>
<p>
The members of a DBID are represented in schema rowset columns as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=587>
<tr valign=top>
<td class=label width=41%><b>DBID <i>eKind</i></b></td>
<td class=label width=59%><b>Schema columns</b></td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID_NAME</td>
<td width=59%>_GUID and _NAME column values must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID_PROPID</td>
<td width=59%>_GUID and _PROPID column values must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_NAME</td>
<td width=59%>_NAME column value must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PGUID_NAME</td>
<td width=59%>_GUID and _NAME column values must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PGUID_PROPID</td>
<td width=59%>_GUID and _PROPID column values must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_PROPID</td>
<td width=59%>_PROPID column value must be provided.</td>
</tr>
<tr valign=top>
<td width=41%>DBKIND_GUID</td>
<td width=59%>_GUID column value must be provided.</td>
</tr>
</table><br>
<p>
OLE DB providers never return <i>pGuid</i>-style bindings (for example, when the consumer inquires about the bindings for an accessor). They are provided as a convenient shortcut for consumers supplying bindings all covered by the same GUID, which is expected to be common.</p>
<p>
The value DB_NULLID is defined as the DBID structure containing all zeroes. Because <i>pwszName</i> is a null pointer for DB_NULLID, you should not attempt to free this string.</p>
<p>
When constructing DBIDs to identify tables, indexes, or columns, consumers use the non-null columns in the appropriate schema rowset to determine the DBKIND value of the DBID. For example, when specifying a table ID, a consumer would call <b>IDBSchemaRowset::GetRowset</b> and examine the TABLES rowset. On discovering that TABLE_NAME has a value and TABLE_GUID is NULL, the consumer specifies DBKIND_NAME for the table ID. In methods that take column DBIDs as parameters, the validation of the DBID should include a check on the validity of the DBID's <i>eKind</i>.</p>
</font></BODY>
</HTML>
