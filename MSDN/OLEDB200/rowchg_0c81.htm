<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IRowsetChange::SetData</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbirowsetchange__setdata"></a>IRowsetChange::SetData</h1>
<p>
Sets data values in one or more columns in a row.</p>
<pre><code>HRESULT SetData (
   HROW            hRow,
   HACCESSOR   hAccessor,
   void *            pData);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hRow</i></p>
<p class=indent>
[in]<br>
The handle of the row in which to set data.</p>
<p class=dt>
<i>hAccessor</i></p>
<p class=indent>
[in]<br>
The handle of the accessor to use. If <i>hAccessor</i> is the handle of a null accessor (<i>cBindings</i> in <b>IAccessor::CreateAccessor</b> was zero), then <b>SetData</b> does not set any data values.</p>
<p class=dt>
<i>pData</i></p>
<p class=indent>
[in]<br>
A pointer to memory containing the new data values, at offsets that correspond to the bindings in the accessor.</p>
<p class=dt>
</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The status of all columns bound by the accessor is set to DBSTATUS_S_OK or DBSTATUS_S_ISNULL</p>
<p class=dt>
</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while setting data for one or more columns, but data was successfully set for at least one column. To determine the columns for which data was returned, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
DB_S_MULTIPLECHANGES<br>
The rowset was in immediate update mode and updating the row caused more than one row to be updated in the data source. For more information, see DBPROP_REPORTMULTIPLECHANGES in "<a href="appcpr_8u7n.htm#oledbrowset_properties">Rowset Properties</a>" in Appendix C.</p>
<p class=tl>
This return code takes precedence over DB_S_ERRORSOCCURRED. That is, if the conditions described here and in those described in DB_S_ERRORSOCCURRED both occur, the provider returns this code. When the consumer receives this return code, it should also check for the conditions described in DB_S_ERRORSOCCURRED.</P><p class=dt>
</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=dt>
</p>
<p class=indent>
E_INVALIDARG<br>
<i>pData</i> was a null pointer and the accessor was not a null accessor.</p>
<p class=dt>
</p>
<p class=indent>
E_UNEXPECTED<br>
<b>ITransaction::Commit</b> or <b>ITransaction::Abort</b> was called and the object is in a zombie state.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ABORTLIMITREACHED<br>
The rowset was in immediate update mode and the row was not updated due to reaching a limit on the server, such as a query execution timing out.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor or was a reference accessor.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_BADROWHANDLE<br>
<i>hRow</i> was invalid.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANCELED<br>
The change was canceled during notification. No columns are changed.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CANTCONVERTVALUE<br>
The data value for one or more columns couldn't be converted for reasons other than sign mismatch or data overflow, and the provider was unable to determine which columns couldn't be converted. Providers that can detect which columns could not be converted return DB_S_ERRORSOCCURRED and set the status flag for the columns that couldn't be converted to DBSTATUS_E_CANTCONVERTVALUE.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_CONCURRENCYVIOLATION<br>
The rowset was using optimistic concurrency and the value of a column has been changed since the containing row was last fetched or resynchronized. <b>SetData</b> returns this error only when the rowset is in immediate update mode.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DATAOVERFLOW<br>
Conversion failed because the data value for one or more columns overflowed the type used by the provider and the provider was unable to determine which columns caused the overflow. Providers that can detect which columns caused the overflow return DB_S_ERRORSOCCURRED and set the status flag for the columns in violation to DBSTATUS_E_DATAOVERFLOW.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_DELETEDROW<br>
<i>hRow</i> referred to a row with a pending delete or for which a deletion had been transmitted to the data source.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
An error occurred while setting data for one or more columns and data was not successfully set for any columns. To determine the columns for which values were invalid, the consumer checks the status values. For a list of status values that can be returned by this method, see "Status Values Used When Setting Data" in "<a href="ch06pr_5q9f.htm">Status</a>" in Chapter 6.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_INTEGRITYVIOLATION<br>
The data violated the integrity constraints for one or more columns of the rowset and the provider was unable to determine which columns violated the integrity constraints. Providers that can detect which columns violated the integrity constraints return DB_S_ERRORSOCCURRED and set the status flag for the columns in violation to DBSTATUS_E_INTEGRITYVIOLATION.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_MAXPENDCHANGESEXCEEDED<br>
The number of rows that have pending changes has exceeded the limit specified by the DBPROP_MAXPENDINGROWS property.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NEWLYINSERTED<br>
DBPROP_CHANGEINSERTEDROWS was VARIANT_FALSE and <i>hRow</i> referred to a row for which the insertion has been transmitted to the data source.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTREENTRANT<br>
The consumer called this method while it was processing a notification, and it is an error to call this method while processing the specified DBREASON value.</p>
<p class=dt>
</p>
<p class=indent>
DB_E_NOTSUPPORTED<br>
The provider does not support this method. </p>
<p class=dt>
</p>
<p class=indent>
DB_SEC_E_PERMISSIONDENIED<br>
The consumer did not have sufficient permission to update the row. This error can be returned only if the value of the DBPROP_ROWRESTRICT property is VARIANT_TRUE. If the rowset is in delayed update mode, this error might not be returned until <b>IRowsetUpdate::Update</b> is called.</p>
<p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return any of the following return codes for the applicable reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor:</b></p>
<p>
E_NOINTERFACE<br>
DB_E_BADBINDINFO<br>
DB_E_BADORDINAL<br>
DB_E_BADSTORAGEFLAGS<br>
DB_E_UNSUPPORTEDCONVERSION</p>
<p class=label>
<b>Comments</b></p>
<p>
<b>SetData</b> sets data values in one or more columns in a row. For a complete description of how <b>SetData</b> sets data, see "<a href="ch06pr_5iap.htm">Setting Data</a>" in Chapter 6.</p>
<p>
In delayed update mode, these changes are buffered locally in the rowset and are transmitted to the data source only when <b>IRowsetUpdate::Update</b> is called. In immediate update mode, the changes are immediately transmitted to the data source. For more information, see "<a href="ch05pr_0ue9.htm">Changing Data</a>" in Chapter 5.</p>
<p>
If a computed column depends on a column that is changed with <b>SetData</b>, the provider is not required to compute the new value of the computed column. If the provider computes the new value, it sends a notification to the consumer. If the provider does not compute the new value but lets the data source do so, then the computed value is not available until after the change is transmitted to the data source—that is, after <b>SetData</b> is called in immediate update mode or after <b>IRowsetUpdate::Update</b> if <b>SetData</b> is called in delayed update mode. To retrieve the computed value in this case, the consumer calls <b>RefreshVisibleData</b> or <b>GetLastVisibleData</b> in <b>IRowsetRefresh</b>. Bookmark columns are often computed, such as when the bookmark is the primary key or is a ROWID assigned by the data source.</p>
<p>
If <b>SetData</b> changes a column that is used to order the rowset, the DBPROP_IMMOBILEROWS property describes whether the row is moved based on its new value. If this property is VARIANT_TRUE, the row is not moved. If this property is VARIANT_FALSE, the row is moved. If the rowset is not ordered, then the position of updated rows is not changed. Note that, if the rowset is built on a set of key columns (typically a rowset for which DBPROP_OTHERUPDATEDELETE is VARIANT_TRUE but DBPROP_OTHERINSERT is VARIANT_FALSE), changing the value of key column is generally equivalent to deleting the current row and inserting a new one. Thus, the row may appear to move or even disappear from the rowset (if DBPROP_OWNINSERT is VARIANT_FALSE), even though the DBPROP_IMMOBILEROWS property is VARIANT_TRUE.</p>
<p>
When the consumer passes a pointer to a storage object to <b>SetData</b>, <b>SetData</b> replaces the data in the column with the data in the new storage object. If the consumer wants only to delete the data in the column, it sets the column status to DBSTATUS_S_OK and passes a null pointer instead of a pointer to a storage object. For more information, see "<a href="ch07pr_2wdv.htm">Getting and Setting BLOB Data with Storage Objects</a>" in Chapter 7. If the rowset is in immediate update mode, storage object data is always transmitted immediately to the data source. If it is in delayed update mode, whether it is transmitted immediately or delayed depends on the DBPROP_DELAYSTORAGEOBJECTS property.</p>
<p>
Although <b>SetData</b> can detect domain constraint and some table constraint schema violations, it is not required to do so. Such validation can be delayed until the changes are transmitted to the data source with <b>Update</b> or the transaction is committed with <b>ITransaction::Commit</b>. This delay is often necessary because of dependencies on values in other columns or tables.</p>
<p>
<b>SetData</b> cannot be called for rows with pending or transmitted deletes.</p>
<p>
The DBPROP_COLUMNRESTRICT and DBPROP_ROWRESTRICT properties affect how security is enforced and how security errors are returned. If DBPROP_COLUMNRESTRICT is VARIANT_TRUE, the consumer might not have write permission on some columns. If the consumer attempts to write to these columns, <b>SetData</b> returns a column status of DBSTATUS_E_PERMISSIONDENIED and a return code of DB_S_ERRORSOCCURRED. If the DBPROP_ROWRESTRICT property is VARIANT_TRUE, the consumer might not have permission to update some rows. If the consumer attempts to update one of <br>
these rows, <b>SetData</b> returns a code of DB_SEC_E_PERMISSIONDENIED and no data is set.</p>
<p>
If any consumer of the rowset is using notifications, the provider sends notifications. These notifications can be vetoed, in which case the provider sends the DBEVENTPHASE_FAILEDTODO phase of the notification. When the consumer then calls <b>Update</b>, if the update is in delayed mode, the provider does not send additional DBREASON_COLUMN_SET notifications for the rows. However, if <b>Update</b> computes the value of computed columns, it sends DBREASON_COLUMN_RECALCULATED notifications. In this case, the provider must either be prepared to undo all pending changes for the row, and return DBREASON_ROW_UNDOCHANGE, or set the <i>fCantDeny</i> flag to TRUE.</p>
<p>
The following sequence of notifications occurs for a rowset operating in delayed update mode:
<ol>
<li>
If the row is being changed for the first time since it was created, or changes were transmitted, the provider sends the DBEVENTPHASE_OKTODO and DBEVENTPHASE_ABOUTTODO phases of the DBREASON_ROW_FIRSTCHANGE notification.<br><br></li>
<li>
The provider sends the DBEVENTPHASE_OKTODO, DBEVENTPHASE_ABOUTTODO, and DBEVENTPHASE_SYNCHAFTER phases of the DBREASON_COLUMN_SET notification, in that order, provided none of the listeners veto any of the phases. The notification covers all the columns defined by the accessor used in the call to <b>SetData</b>.<br><br></li>
<li>
The provider sends the DBEVENTPHASE_SYNCHAFTER phase of the DBREASON_ROW_FIRSTCHANGE notification, assuming the provider sent the earlier phases of this notification.<br><br></li>
<li>
The provider sends the DBEVENTPHASE_DIDEVENT phase of the DBREASON_COLUMN_SET notification.<br><br></li>
<li>
The provider sends the DBEVENTPHASE_DIDEVENT phase of the ROW_FIRSTCHANGE notification.<br><br></li>
</ol>
<p class=label>
<b>See Also</b></p>
<p>
<a href="rowset_64f5.htm">IRowset::GetData</a>, <a href="rowchg_4v93.htm">IRowsetChange::InsertRow</a>, <a href="rowupd_2xyn.htm">IRowsetUpdate::Undo</a>, <a href="rowupd_49gl.htm">IRowsetUpdate::Update</a></p>
</font></BODY>
</HTML>
