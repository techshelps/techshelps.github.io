<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Interface Implementation Notes</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="odbcproviderinterface_implementation_notes"></a><sup></sup>Interface Implementation Notes</h1>
<p>
The following sections discuss how the ODBC Provider implements some interfaces.</p>
<h1>IAccessor</h1>
<ul type=disc>
<li>
Accessors may not always be validated immediately at the time of creation. Instead, they may be validated at the time the first row is fetched. Errors will be returned at the first attempt to use such an accessor.<br><br></li>
<li>
The ODBC Provider supports DBACCESSOR_PASSBYREF accessors. These accessors return a single pointer to the ODBC Provider’s internal row buffer. This provides a significant speed improvement over copy or <b>IMalloc</b> bindings. The pointer is only valid while the row handle is active (until <b>ReleaseRows</b> is called).<br><br></li>
<li>
The OLE DB specification does not enable a consumer to query for the layout of the internal buffer. The ODBC Provider will return DB_E_BADBINDINFO if the type does not match exactly, or if the location of the status or length is incorrect.<br><br></li>
<li>
The ODBC Provider does not support the DBACCESSOR_OPTIMIZED flag. The flag is ignored (for example, there is no special processing) if it is specified on an accessor.</li>
</ul>
<h1>IColumnsInfo</h1>
<ul type=disc>
<li>
Columns that have an ODBC SQL type of SQL_LONGVARCHAR or SQL_LONGVARBINARY are returned as type DBTYPE_BYTES or DBTYPE_STR, and the DBCOLUMNFLAG_ISLONG is set in the <i>dwFlags</i> element of the DBCOLUMNINFO structure. The ODBC Provider does not instantiate an object for these columns. Instead these settings signify that the bytes stored in the column can be retrieved or stored by requesting an <b>ISequentialStream</b> interface, through which the bytes may be read from or written to.<br><br></li>
<li>
In some ODBC drivers, duplicate columns in an unprepared command cause the ODBC Provider to receive unexpected column names. If the command contains duplicate columns and the consumer prepares the command, unprepares the command, then executes the command, these drivers do not generate column names for the duplicate columns. This causes a warning, DB_S_ERRORSOCCURRED, in <b>IColumnsInfo::MapColumnsID</b>.<br><br></li>
<li>
The ODBC Provider does not support the following DBCOLUMNFLAGS in <b>IColumnsInfo::GetColumnInfo</b>:<p class=tl>
DBCOLUMNFLAGS_MAYDEFER</P><p class=tl>
DBCOLUMNFLAGS_WRITE</P><p class=tl>
DBCOLUMNFLAGS_CACHEDEFERRED</P></li>
</ul>
<h1>IColumnsRowset</h1>
<ul type=disc>
<li>
The following columns return NULL values:<p class=tl>
DBCOLUMN_COLLATINGSEQUENCE</P><p class=tl>
DBCOLUMN_COMPUTEMODE</P><p class=tl>
DBCOLUMN_DEFAULTVALUE</P><p class=tl>
DBCOLUMN_DOMAIN</P><p class=tl>
DBCOLUMN_HASDEFAULT</P><p class=tl>
DBCOLUMN_ISUNIQUE.</P></li>
<li>
Driver-specific columns can be requested. There is no way to return the list of what these may be for the driver in use. Consumers should specify a COLUMNID of type DBCOLKIND_GUID_PROPID, with <i>guid</i> equal to GUID_NULL, and <i>ulPropid</i> equal to value of the ODBC driver-specific option (the <i>fDescType</i> parameter in <b>SQLColAttributes</b>). A heuristic is used to determine the data type of the option from the ODBC driver.</li>
</ul>
<h1>ICommandProperties</h1>
<ul type=disc>
<li>
When used with the Microsoft SQL Server ODBC driver, the ODBC Provider cannot support both DBPROP_CANHOLDROWS and DBPROP_OTHERINSERT if each is set to VARIANT_TRUE.</li>
</ul>
<h1>ICommandText</h1>
<ul type=disc>
<li>
If <b>SQLNativeSQL</b> is supported in the underlying ODBC driver, the ODBC Provider will initiate a call to this ODBC function when the consumer calls <b>ICommandText::GetCommandText</b> with <i>pguidDialect</i> set to NULL. The string returned from this call is not cached; users must call <b>ICommandText::SetCommandText</b> with the string returned by the ODBC driver to use the native SQL statement.<br><br></li>
<li>
If <i>pguidDialect</i> is set to NULL on input, the ODBC Provider returns the command in <i>ppwszCommand</i> in the dialect used to set the command text. The ODBC Provider also returns S_OK (barring any other errors) rather than DB_S_DIALECTIGNORED.</li>
</ul>
<h1>ICommandWithParameters</h1>
<ul type=disc>
<li>
The data type returned in <b>ICommandWithParameters::GetParameterInfo</b> should be considered without regard to sign. For example, if a database server is expected to return DBTYPE_I2, the ODBC Provider can return DBTYPE_UI2; this ambiguity occurs because the underlying ODBC function <b>SQLDescribeParam</b> does not return the sign of the data type. In addition, the following flags are not set because the ODBC Provider has no mechanism to obtain the status from the ODBC driver with <b>SQLDescribeParam</b>:<p class=tl>
DBPARAMFLAGS_ISSIGNED</P><p class=tl>
DBPARAMFLAGS_ISINPUT</P><p class=tl>
DBPARAMFLAGS_ISOUTPUT</P></li>
</ul>
<p>
The last two of the above flags can be set for stored procedures against SQL Server.
<ul type=disc>
<li>
If the ODBC driver returns SQL_NULLABLE_UNKNOWN for a parameter, the ODBC Provider will return DBPARAMFLAGS_ISNULLABLE for that parameter.</li>
</ul>
<h1>IDBSchemaRowset</h1>
<ul type=disc>
<li>
The ODBC Provider cannot support restrictions on schema columns if the restrictions are not supported in the underlying ODBC driver.<br><br></li>
<li>
NULL values are returned in many columns that ANSI SQL 92 specifies as NOT NULL. These are cases in which the information is not available by means of ODBC.<br><br></li>
<li>
Schema rowsets do not expose <b>IColumnsRowset</b> or <b>IRowsetLocate</b>.<br><br></li>
<li>
The COLUMNS schema rowset is dependent on the information returned in the ODBC driver’s implementation of <b>SQLColumns</b>. Since ODBC does not return ordinal information, the ODBC Provider always sets the value of ORDINAL_POSITION to NULL.<p class=tl>
The ODBC Provider returns any driver-specific columns that the ODBC driver returns in <b>SQLColumns</b>. This information is returned in columns beyond those described in the OLE DB specification.</P><p class=tl>
These additional columns include:</P><p class=tl>
ORDINAL, which is returned by the Microsoft Access ODBC driver.</P><p class=tl>
ss_data_type and <i>colid</i>, which are returned by the Microsoft SQL Server 6.0 ODBC driver.</P><p class=tl>
"COLUMN_DEF", "SQL_DATA_TYPE", "SQL_DATETIME_SUB", "CHAR_OCTET_LENGTH", "ORDINAL_POSITION", "IS_NULLABLE", and "SS_DATA_TYPE", which are returned by the Microsoft SQL Server 6.5 ODBC driver.</P></li>
<li>
In the INDEXES schema rowset, the value of the TYPE column is set to DBPROPVAL_IT_BTREE if the value of the TYPE column returned by <b>SQLStatistics</b> is SQL_INDEX_CLUSTERED. The value of the NULL_COLLATION column is set to the value returned by <b>SQLGetInfo</b> for the SQL_NULL_COLLATION option.<br><br></li>
<li>
In the PROVIDER_TYPES schema rowset, the value of the DATA_TYPE column is set to DBTYPE_BYTES or DBTYPE_IUNKNOWN if the value of the DATA_TYPE column returned by <b>SQLGetTypeInfo</b> is a driver-specific SQL data type indicator.<br><br></li>
<li>
The PROVIDER_TYPES schema rowset does not support any restrictions.</li>
</ul>
<h1>IRowset</h1>
<ul type=disc>
<li>
<b>GetNextRows</b> may skip over rows if the underlying ODBC driver compacts data and some rows of the current rowset have been deleted. </li>
</ul>
<h1>IRowsetChange</h1>
<ul type=disc>
<li>
<b>IRowsetChange</b> is implemented using the ODBC function <b>SQLSetPos</b>. It therefore can be exposed only when the underlying ODBC driver supports <b>SQLSetPos</b>. If the underlying driver does not support <b>SQLSetPos</b>, query-based updating will be used based on an optimistic, by-value scheme.<br><br></li>
<li>
Newly inserted rows can be updated or deleted only through query-based updates; if query-based updating is unavailable, newly-inserted rows cannot be updated. This is not the case for ODBC 3.x drivers, which return bookmarks for newly inserted rows and allow updates.<br><br></li>
<li>
You need to have an index on the table or else <b>IRowsetChange::Insert Row</b> will fail with any ISLONG column, returning an E_FAIL HRESULT.</li>
</ul>
<h1>IRowsetScroll</h1>
<ul type=disc>
<li>
If the ODBC driver supports the SQL_DIAG_CURSOR_ROW_COUNT diagnostic identifier, the two methods <b>GetApproximatePosition</b> and <b>GetRowsAtRatio</b> (which are methods of <b>IRowsetScroll</b>), are implemented. Depending on the type of cursor, GetInfo methods can be called to determine whether the row count is exact or approximate.</li>
</ul>
<h1>ISequentialStream</h1>
<p>
In deferred update mode, when a row's update fails, this provider does not release any of the <b>ISequentialStream</b> pointers due to the lack of knowledge which pointers have and have not been read. The row is in an unknown state. If the consumer attempts to update again, failure may occur. Because responsibility for a reference on these failed interfaces still exists, this provider releases them in the following cases:
<ul type=disc>
<li>
If the consumer calls <b>SetData</b> for a given ISS-bound BLOB object, the old interface will be released and replaced with the new one in the deferred-update buffer<br><br></li>
<li>
If the consumer calls <b>Undo</b> for the row<br><br></li>
<li>
If the consumer resynchs the row<br><br></li>
<li>
If the consumer releases the rowset</li>
</ul>
<p>
Interface pointers are always released if the back-end updates succeed.</p>
<h1>ITransaction</h1>
<ul type=disc>
<li>
Consumers that use the ODBC Provider should be aware of the <b>ITransaction::Abort</b> and <b>ITransaction::Commit</b> error XACT_E_CANTRETAIN, which specifies that retaining abort and commit operations are not supported and that the specified abort or commit succeeded, leaving the session in autocommit mode. After receiving this error, consumers should check for extended error information. If extended error information is available, consumers should call <b>ITransaction::GetTransactionInfo</b> to determine the current transaction mode (manual commit or autocommit); there may be some cases in which the ODBC Provider cannot put the session in autocommit mode despite the information implied in the XACT_E_CANTRETAIN error.</li>
</ul>

<h1><a name="odbcitransactionjoin"></a>ITransactionJoin</h1>
<ul type=disc>
<li>
The ODBC Provider now supports Microsoft Transaction Server and its coordinated transaction capabilities by implementing <b>ITransactionJoin</b>. <br><br></li>
<li>
Enabling support for Microsoft Transaction Server requires:<ul type=disc>
<li>
ODBC driver support for the connection attribute SQL_ATT_ENLIST_IN_DTC, which must be set.<br><br></li>
<li>
That the consumer expose an <b>IUnknown</b> pointer from <b>ITransactionCoordinate</b>.</li>
</ul>
</li>
</ul>
</font></BODY>
</HTML>
