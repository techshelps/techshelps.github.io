<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Rowset Properties</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="rowsetproperties"></a>Rowset Properties</h1>
<p>
The DBPROPSET_ROWSET property set contains the following properties. All of these properties are in the ROWSET property group. Additional properties are defined in DBPROPSET_JETOLEDB_ROWSET.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=632>
<tr valign=top>
<td class=label width=49%><b>Property ID </b></td>
<td class=label width=51%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ABORTPRESERVE</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Preserve on Abort</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that, after an abort that preserves, the rowset remains active. Therefore, it is possible to manipulate rows.<br><br></li>
<li>
VARIANT_FALSE, which indicates that, after an abort, or an abort that preserves, the only operations allowed on a rowset are to release row and accessor handles and to release the rowset.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_APPENDONLY</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Append-Only Rowset</p>
<p>
If the value is VARIANT_TRUE, when a rowset is opened it will initially be empty. If the rowset was obtained by <b>IOpenRowset::OpenRowset</b>, this is equivalent to positioning the start of the rowset at the end of the table. If the rowset was obtained by executing a command, this is equivalent to placing the start of the rowset at the end of the command’s results. A rowset opened with VARIANT_TRUE will be populated only by those rows inserted in it.</p>
<p>
DBPROP_APPENDONLY set to VARIANT_TRUE implies:
<ul type=disc>
<li>
DBPROP_<b>IrowsetChange</b> is VARIANT_TRUE.<br><br></li>
<li>
DBPROP_OWNINSERT is VARIANT_TRUE<br><br></li>
<li>
DBPROP_UPDATABILITY has the flag DBPROPVAL_UP_INSERT set.<br><br></li>
<li>
DBPROP_OTHERINSERT is VARIANT_TRUE.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_BLOCKINGSTORAGEOBJECTS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Blocking Storage Objects</p>
<p>
Specifies whether storage objects might prevent use of other methods on the rowset, that is:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that, after creating an instance of a storage object, use of other methods on the rowset might be prevented. That is, after a storage object is created and before it is released, methods other than those on the storage objects might return E_UNEXPECTED.<br><br></li>
<li>
VARIANT_FALSE, which indicates that creating instances of storage objects does not prevent the use of other methods.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_BOOKMARKS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Use Bookmarks</p>
<p>
Specifies whether the rowset supports bookmarks, that is:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset supports bookmarks. Column 0 is the bookmark for the rows. Getting this column obtains a bookmark value, which can be used to reposition to the row.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the rowset does not support bookmarks. The rowset is sequential and the values of the DBPROP_LITERALBOOKMARKS and DBPROP_ORDEREDBOOKMARKS properties are ignored.</li>
</ul>
<p>
The value of this property is automatically set to VARIANT_TRUE if the value of DBPROP_IROWSETLOCATE, DBPROP_LITERALBOOKMARKS, or DBPROP_ORDEREDBOOKMARKS is set to VARIANT_TRUE</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_BOOKMARKSKIPPED</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Skip Deleted Bookmarks</p>
<p>
Specifies whether the rowset allows <b>IRowsetLocate::GetRowsAt</b> or <b>IRowsetFind::FindNextRow</b> to continue if a bookmark row was deleted, is a row to which the consumer does not have access rights, or is no longer a member of the rowset.</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that <b>GetRowsAt</b> or <b>FindNextRow</b> skips the bookmark row and continues with the next row.<br><br></li>
<li>
VARIANT_FALSE, which indicates that <b>GetRowsAt</b> or <b>FindNextRow</b> returns DB_E_BADBOOKMARK</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_BOOKMARKTYPE</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: BookMark Type</p>
<p>
Specifies the bookmark type supported by the rowset, that is:
<ul type=disc>
<li>
DBPROPVAL_BMK_NUMERIC, which indicates that the bookmark type is numeric. Numeric bookmarks are based on a row's properties that are not dependent on the values of the row’s columns. For instance, a numeric bookmark can be based on the absolute position of the row within rowset, or on a row ID that the storage engine assigned to a tuple when it was created. The validity of numeric bookmarks is not changed by modifying the row’s columns.<br><br></li>
<li>
DBPROPVAL_BMK_KEY, which indicates that the bookmark type is key. Key bookmarks are based on the values of one or more of the row’s columns.These values form a unique key for each row. A key bookmark may be left dangling if the key values of the corresponding row are changed. </li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_CACHEDEFERRED</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Cache Deferred Columns</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the provider caches the value of a deferred column when the consumer first gets a value from this column. When the consumer later gets values from this column, the provider returns the value in the cache. The contents of the cache can be overwritten by <b>IRowsetChange::SetData</b> or <b>IRowsetResynch::ResynchRows</b>. The cached value is released when the row is released. Consumers should set the value of this property to VARIANT_TRUE&nbsp; only when this is absolutely necessary, as this might require a large amount of memory in the provider. This could limit the number of rows that can be held at one time. Setting the values of this property to VARIANT_TRUE automatically sets the DBPROP_DEFERRED property to VARIANT_TRUE. <br><br></li>
<li>
VARIANT_FALSE, which indicates that the provider does not cache the value of a deferred column and multiple calls to <b>IRowset::GetData</b> as the column can return different values.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_CANFETCHBACKWARDS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Fetch Backwards</p>
<p>
Specifies whether the rowset can fetch backwards, that is:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that <i>cRows</i> in <b>IRowset::GetNextRows</b>, <b>IRowsetLocate::GetRowsAt</b>, and <b>IRowsetScroll::GetRowsAtRatio</b> can be negative. When it is negative, these methods fetch rows backwards from the specified row.<br><br></li>
<li>
VARIANT_FALSE, which indicates that <i>cRows</i> must be non-negative.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_CANHOLDROWS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Hold Rows</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset allows the consumer to retrieve more rows, or change the next fetch position, while holding previously fetched rows with pending changes.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the rowset requires pending changes to be transmitted to the data source and all rows to be released before fetching additional rows, inserting new rows, or changing the next fetch position.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_CANSCROLLBACKWARDS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Scroll Backwards</p>
<p>
Specifies whether the rowset can scroll backward, that is:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that <b>IRowsOffset</b> in <b>IRowset::GetNextRows</b> or <b>IRowsetLocate::GetRowsAt</b> can be negative.<br><br></li>
<li>
VARIANT_FALSE, which indicates that <b>IRowsOffset</b> must be non-negative.</li>
</ul>
<p>
If the rowset supports <b>IRowsetLocate</b>, the value of this property is VARIANT_TRUE, as this method supports backward scrolling by definition.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_CHANGEINSERTEDROWS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Change Inserted Rows</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the consumer can call <b>IRowsetChange::DeleteRows</b> or <b>IRowsetChange::SetData</b> for newly inserted rows.<br><br></li>
<li>
VARIANT_FALSE, which indicates whether the consumer calls <b>DeleteRows</b> or <b>SetData</b> for newly inserted rows. <b>DeleteRows</b> returns a status of DBROWSTATUS_E_NEWLYINSERTED for the row and <b>SetData</b> returns DB_E_NEWLYINSERTED.</li>
</ul>
<p>
A newly inserted row is defined as a row for which the insertion has been transmitted to the data source, as opposed to a pending insert row. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_COLUMNRESTRICT</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Column Privileges</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicats that access rights are restricted on a column-by-column basis. If the rowset exposes <b>IRowsetChange</b>, <b>IRowsetChange::SetData</b> cannot be called for at least one column. A provider must not execute a query that would specify a column for which the consumer has no read access rights.<br><br></li>
<li>
VARIANT_FALSE, which indicates that access rights are not restricted on a column-by-column basis. If the rowset exposes <b>IRowsetChange</b>, <b>SetData</b> can be called for any column in the rowset.</li>
</ul>
<p>
If access is restricted both by row and by column, individual columns of particular rows might have their own stricter access rights, and the consumer may not be permitted to read such columns. The column values will be null. If a null value is contrary to schema rules (Nulls not permitted) then the rowset should not count or return any rows that would have this condition.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_COMMANDTIMEOUT</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: Not Supported</p>
<p>
Description: Command Time-out</p>
<p>
Specifies the number of seconds before a command times out. A value of 0 indicates an infinite time-out.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_COMMITPRESERVE</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Preserve On Commit</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that after a commit that preserves, the rowset remains active. That is, it is possible to fetch new rows, update, delete, and insert rows, and so on.<br><br></li>
<li>
VARIANT_FALSE, which indicates that after a commit or a commit that preserves, the only operations allowed on a rowset are to release row and accessor handles and to release the rowset.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_DEFERRED</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Defer Column</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the data in the column is not fetched until an accessor is used on the column.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the data in the column is fetched when the row containing it is fetched.</li>
</ul>
<p>
The value of this property is automatically set to VARIANT_TRUE if the value of the DBPROP_CACHEDEFERRED property is set to VARIANT_TRUE.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_DELAYSTORAGEOBJECTS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Delay Storage Object Updates</p>
<p>
In delayed update mode, if the value of this property is VARIANT_TRUE, then storage objects are also used in delayed update mode. In particular:
<ul type=disc>
<li>
Changes to the object are not transmitted to the data source until <b>IRowsetUpdate::Update</b> is called.<br><br></li>
<li>
<b>IRowsetUpdate::Undo</b> undoes any pending changes, and <b>IRowsetUpdate::GetOriginalData</b> retrieves the original value of the object; that is, the object’s value when the row was last fetched or updated and excluding any changes made since then.</li>
</ul>
<p>
In delayed update mode, if the value of this property is VARIANT_FALSE, then storage objects are used in immediate update mode. In particular:
<ul type=disc>
<li>
Changes to the object are immediately transmitted to the data source,<br><br></li>
<li>
<b>Update</b> has no effect on the object.<br><br></li>
<li>
<b>Undo </b>does not undo changes made to the object since the row was last fetched or updated, and <b>GetOriginalData </b>retrieves the current value of the object, including changes made since the row was last fetched or updated.</li>
</ul>
<p>
In immediate update mode, this property has no effect on storage objects.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_IACCESSOR<p>
DBPROP_ICOLUMNSINFO</p>
<p>
DBPROP_ICOLUMNSROWSET</p>
<p>
DBPROP_ICONNECTIONPOINTCONTAINER</p>
<p>
DBPROP_ICONVERTTYPE</p>
<p>
DBPROP_IROWSET</p>
<p>
DBPROP_IROWSETCHANGE</p>
<p>
DBPROP_IROWSETIDENTITY</p>
<p>
DBPROP_IROWSETINFO</p>
<p>
DBPROP_IROWSETLOCATE</p>
<p>
DBPROP_IROWSETRESYNCH</p>
<p>
DBPROP_IROWSETSCROLL</p>
<p>
DBPROP_IROWSETUPDATE</p>
<p>
DBPROP_ISUPPORTERRORINFO</p>
</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W, except as noted below.</p>
<p>
Description: <b>IAccessor</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IColumnsInfo</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IColumnsRowset</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IConnectionPointContainer</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IConvertType</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowset</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetChange</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetIdentity</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetInfo</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetLocate</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetResynch</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetScroll</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>IRowsetUpdate</b></p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>ISupportErrorInfo</b></p>
<p>
If the value of any of these properties is set to VARIANT_TRUE, the rowset supports the specified interface. These properties are primarily used to request interfaces through <b>ICommandProperties::SetProperties</b>.<b> </b></p>
<p>
The values of the DBPROP_IROWSET, DBPROP_IACCESSOR, and DBPROP_IROWSETINFO properties are read-only and are always VARIANT_TRUE. They cannot be set to VARIANT_FALSE. If the consumer does not set the value of any of these properties to true, the resulting rowset supports <b>IRowset</b>, <b>IAccessor</b>, <b>IColumnsInfo</b>, <b>IConvertType</b>, and <b>IRowsetInfo</b>. </p>
<p>
Setting DBPROP_IROWSETLOCATE to VARIANT_TRUE automatically sets DBPROP_BOOKMARKS to VARIANT_TRUE. Setting DBPROP_IROWSETUPDATE to VARIANT_TRUE automatically sets DBPROP_IROWSETCHANGE to VARIANT_TRUE.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ILOCKBYTES<p>
DBPROP_ISEQUENTIALSTREAM</p>
<p>
DBPROP_ISTORAGE</p>
<p>
DBPROP_ISTREAM</p>
</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: <b>ILockBytes</b></p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ISequentialStream</b></p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IStorage</b></p>
<p>
<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IStream </b></p>
<p>
If the value of this property is set to VARIANT_TRUE, the specified column is treated as storage object that exposes the specified interface.</p>
<p>
If this property is set on all columns, the provider must be capable of exposing all columns of the rowset as storage objects.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_IMMOBILEROWS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Immobile Rows</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which specifies that the rowset will not reorder inserted or updated rows. For <b>IRowsetChange::InsertRow</b>, rows will appear at the end of the rowset.<br><br></li>
<li>
VARIANT_FALSE, which indicates that if the rowset is ordered, then inserted rows and updated rows (where one or more of the columns in the ordering criteria are updated) obey the ordering criteria of the rowset. If the rowset is not ordered, then inserted rows are not guaranteed to appear in a determinate position and the position of updated rows is not changed.</li>
</ul>
<p>
This property is meaningful only if DBPROP_OWNINSERT is VARIANT_TRUE.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_LITERALBOOKMARKS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Literal Bookmarks</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that bookmarks can be compared literally. That is, they can be compared as a sequence of bytes. Furthermore, if the bookmarks are ordered (as specified by the DBPROP_ORDEREDBOOKMARKS property), the bytes are guaranteed to be ordered so that an arithmetic comparison as their scalar type yields the same result as a call to <b>IRowsetLocate::Compare</b>. Setting the value of this property to VARIANT_TRUE automatically sets the value of DBPROP_BOOKMARKS to VARIANT_TRUE. <br><br></li>
<li>
VARIANT_FALSE, which indicates that bookmarks can only be compared with <b>IRowsetLocate::Compare</b>. </li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_LITERALIDENTITY</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Literal Row Identity</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the consumer can perform a binary comparison of two row handles to determine whether they point to the same row.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the consumer must call <b>IRowsetIdentity::IsSameRow</b> to determine whether two row handles point to the same row.</li>
</ul>
<p>
Whether the handle of a newly inserted row can be successfully compared to another handle is specified by the DBPROP_STRONGIDENTITY property.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_MAXOPENROWS</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: Maximum Open Rows</p>
<p>
Specifies the maximum number of rows that can be active at the same time. This limit does not reflect resource limitations such as RAM, but does apply if the rowset implementation uses some strategy that results in a limit. If there is no limit, the value of this property is zero.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_MAXPENDINGROWS</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R only</p>
<p>
Description: Maximum Pending Rows</p>
<p>
Specifies the maximum number of rows that can have pending changes at the same time. This limit does not reflect resource limitations such as RAM, but does apply if the rowset implementation uses some strategy that results in a limit. If there is no limit, this value is zero.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_MAXROWS</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: Maximum Rows</p>
<p>
Specifies the maximum number of rows that can be returned in a rowset. If there is no limit, this value is zero.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_MAYWRITECOLUMN</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Column Writable</p>
<p>
Specifies whether a particular column is writable or not. Note that this property can be set implicitly through the command used to create the rowset. For example, if the rowset is created by the SQL statement <b>SELECT A,B FROM MyTable FOR UPDATE OF A</b>, then this property is VARIANT_TRUE for column A and VARIANT_FALSE for column B.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_MEMORYUSAGE</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: Memory Usage</p>
<p>
Estimates the amount of memory that can be used by the rowset. If it is 0, the rowset can use unlimited memory. If it is 1–99 inclusive, the rowset can use the specified percentage of total available virtual memory (physical and page file). If it is greater than or equal to 100, the rowset can use up to the specified number of kilobytes of memory.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_NOTIFICATIONGRANULARITY</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R/W</p>
<p>
Description: Notification Granularity</p>
<p>
Specifies values as one of:
<ul type=disc>
<li>
DBPROPVAL_NT_SINGLEROW, which indicates that, for methods that operate on multiple rows and generate multiphased notifications, the provider calls <b>IRowsetNotify::OnRowChange</b> separately for each phase for each row. A cancellation affects a single row. It does not affect the other rows, and notifications are still sent for these rows.<br><br></li>
<li>
DBPROPVAL_NT_MULTIPLEROWS, which indicates that, for methods that operate on multiple rows and generate multiphased notifications, then for each phase, the provider calls <b>OnRowChange</b> once for all rows that succeed and once for all rows that fail. This separation can occur at each phase where a change can fail. For example, if <b>IRowsetChange::DeleteRows</b> deletes some rows and fails to delete others during the preliminary work phase, it calls <b>OnRowChange</b> twice: once with DBEVENTPHASE_SYNCHAFTER and the array of handles of rows that it deleted, and once with DBEVENTPHASE_FAILEDTODO and the array of handles of rows it failed to delete. A cancellation affects all rows with handles that were passed to <b>OnRowChange</b>.<br><br></li>
<li>
DBPROP_NOTIFICATIONGRANULARITY does not affect how providers return notifications about events that affect columns or the entire rowset.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_NOTIFICATIONPHASES</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: Notification Phases</p>
<p>
Specifies a bitmask that indicates the notification phases supported by the provider. A combination of two or more of the following:
<ul type=disc>
<li>
DBPROPVAL_NP_OKTODO<br><br></li>
<li>
DBPROPVAL_NP_ABOUTTODO<br><br></li>
<li>
DBPROPVAL_NP_SYNCHAFTER<br><br></li>
<li>
DBPROPVAL_NP_FAILEDTODO<br><br></li>
<li>
DBPROPVAL_NP_DIDEVENT</li>
</ul>
<p>
The DBPROPVAL_NP_FAILEDTODO and DBPROPVAL_NP_DIDEVENT bits must be returned by all providers that support notifications.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_NOTIFYCOLUMNSET<p>
DBPROP_NOTIFYROWDELETE</p>
<p>
DBPROP_NOTIFYROWFIRSTCHANGE</p>
<p>
DBPROP_NOTIFYROWINSERT</p>
<p>
DBPROP_NOTIFYROWRESYNCH</p>
<p>
DBPROP_NOTIFYROWSETRELEASE</p>
<p>
DBPROP_NOTIFYROWSETFETCHPOSITIONCHANGE</p>
<p>
DBPROP_NOTIFYROWUNDOCHANGE</p>
<p>
DBPROP_NOTIFYROWUNDODELETE</p>
<p>
DBPROP_NOTIFYROWUNDOINSERT</p>
<p>
DBPROP_NOTIFYROWUPDATE</p>
</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R Only</p>
<p>
Description: Column Set Notification.</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Delete Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row First Change Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Insert Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Resynchronization Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rowset Release Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Rowset Fetch Position Change Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Undo Change Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Undo Delete Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Undo Insert Notification</p>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Row Update Notification</p>
<p>
Specifies a bitmask that indicates whether the notification phase can be cancelled, that is zero or more of:
<ul type=disc>
<li>
DBPROPVAL_NP_OKTODO<br><br></li>
<li>
DBPROPVAL_NP_ABOUTTODO<br><br></li>
<li>
DBPROPVAL_NP_SYNCHAFTER</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ORDEREDBOOKMARKS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Bookmarks Ordered</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that bookmarks can be compared to determine the relative position of their associated rows in the rowset. Setting the value of this property to VARIANT_TRUE automatically sets the value of DBPROP_BOOKMARKS to VARIANT_TRUE.<br><br></li>
<li>
VARIANT_FALSE, which indicates that bookmarks can be compared only for equality. Whether bookmarks can be compared byte-by-byte or must be compared with <b>IRowsetLocate::Compare</b> depends on the value of the DBPROP_LITERALBOOKMARKS property.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_OTHERINSERT</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Other’s Inserts Visible</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset can see rows inserted by someone other than a consumer of the rowset. That is, if someone other than a consumer of the rowset inserts a row, any consumer of the rowset can see that row the next time it fetches a set of rows containing it. Note that this includes rows inserted by other parties in the same transaction, as well as rows inserted by parties outside the transaction.<p class=tl>
The transaction isolation level does not affect the ability of the rowset to see rows inserted by other parties in the same transaction, such as other rowsets in the same session. However, it does restrict the ability of the rowset to see rows inserted by parties outside the transaction.</P></li>
<li>
VARIANT_FALSE, which indicates that the rowset cannot see rows inserted by others.</li>
</ul>
<p>
For programmers accustomed to the cursor model in ODBC, the DBPROP_OTHERUPDATEDDELETE and DBPROP_OTHERINSERT properties correspond to ODBC cursors as follows:</p>
<p>
<b>Static Cursor</b>
<ul type=disc>
<li>
DBPROP_OTHERINSERT = VARIANT_FALSE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE = VARIANT_FALSE</li>
</ul>
<p>
<b>Keyset-driven cursor</b>
<ul type=disc>
<li>
DBPROP_OTHERINSERT = VARIANT_FALSE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE = VARIANT_TRUE</li>
</ul>
<p>
<b>Dynamic cursor</b>
<ul type=disc>
<li>
DBPROP_OTHERINSERT = VARIANT_TRUE<br><br></li>
<li>
DBPROP_OTHERUPDATEDELETE = VARIANT_TRUE</li>
</ul>
<p>
Furthermore, the DBPROP_OWNUPDATEDELETE and DBPROP_OWNINSERT properties correspond to the values returned by the SQL_STATIC_SENSITIVITY information type in <b>SQLGetInfo</b> in ODBC.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_OTHERUPDATEDELETE</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Other’s Changes Visible</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset can see updates and deletes made by someone other than a consumer of the rowset. That is, suppose someone other than a consumer of the rowset updates the data underlying a row or deletes the row. If the row is released completely, any consumer of the rowset will see that change the next time it fetches the row. Note that this includes updates and deletes made by other parties in the same transaction, as well as updates and deletes by parties outside the transaction.<p class=tl>
The transaction isolation level does not affect the ability of the rowset to see updates or deletes by other parties in the same transaction, such as other rowsets in the same session. However, it does restrict the ability of the rowset to see updates or deletes by parties outside the transaction.</P></li>
<li>
VARIANT_FALSE, which indicates that the rowset cannot see updates and deletes by others.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_OWNINSERT</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Own Inserts Visible</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset can see its own inserts. That is, if a consumer of a rowset inserts a row, any consumer of the rowset can see that row the next time it fetches a set of rows containing it.<p class=tl>
This ability is independent of the transaction isolation level, because all consumers of the rowset share the same transaction.</P></li>
<li>
VARIANT_FALSE, which indicates that the rowset cannot see rows inserted by consumers of the rowset unless the command is re-executed.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_OWNUPDATEDELETE</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Own Changes Visible</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the rowset can see its own updates and deletes. That is, suppose a consumer of the rowset updates or deletes a row. If the row is released completely, any consumer of the rowset will see the update or delete the next time it fetches that row.<p class=tl>
This ability is independent of the transaction isolation level because all consumers of the rowset share the same transaction.</P></li>
<li>
VARIANT_FALSE, which indicates that the rowset cannot see updates and deletes by consumers of the rowset unless the command is re-executed.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_QUICKRESTART</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Quick Restart</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that <b>IRowset::RestartPosition</b> is relatively quick to execute. In particular, it does not re-execute the command that created the rowset.<br><br></li>
<li>
VARIANT_FALSE, which indicates that <b>RestartPosition</b> is expensive to execute and requires re-executing the command that created the rowset.</li>
</ul>
<p>
Although the value of this property can be set to VARIANT_TRUE, the provider is not required to honor it. The reason for this is that the provider does not know what the command is at the time the property is set. In particular, the consumer can set this property and then change the command text. However, the provider can fail this property if it is never able to quickly restart the next fetch position. Thus, if a consumer successfully sets this property, it must still check this flag on the rowset to determine if the next fetch position can be quickly set.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_REENTRANTEVENTS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Re-entrant events</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the provider supports re-entrancy during callbacks to the <b>IRowsetNotify</b> interface. The provider might not support re-entrancy on all rowset methods. These methods return DB_E_NOTREENTRANT.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the provider does not support such re-entrancy. The provider returns DB_E_NOTREENTRANT on methods called during the notification.</li>
</ul>
<p>
Regardless of this flag, all providers must support <b>IRowset::GetData</b> and <b>IRowset::ReleaseRows</b> calls during notifications, so long as the columns being accessed do not include deferred columns. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_REMOVEDELETED</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Remove Deleted Rows</p>
<p>
If the value of this property is VARIANT_TRUE, the provider removes rows it detects as having been deleted from the rowset. That is, fetching a block of rows that formerly included a deleted row does not return a handle to that row.</p>
<p>
Which rows the rowset detects as having been deleted is determined by the DBRPOP_OWNUPDATEDELETE and DBPROP_OTHERUPDATEDELETE properties. Whether the rowset removes these rows is determined by this property.</p>
<p>
Note that this property is independent of the transaction isolation level. While the transaction isolation level in some cases determines whether the rowset can detect a row as having been deleted, it has no effect on whether or not the rowset removes that row.</p>
<p>
For programmers accustomed to the cursor model in ODBC, this value of the property is always VARIANT_TRUE for rowsets implemented through dynamic cursors. That is, dynamic cursors always remove deleted rows. Whether static and keyset-driven cursors remove deleted rows depends on the value of this property.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_REPORTMULTIPLECHANGES</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Report Multiple Changes</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that an update or delete can affect multiple rows and the provider can detect that multiple rows have been updated or deleted. This happens when a provider cannot uniquely identify a row. For example, the provider might use the values of all the columns in the row to identify the row. If these columns do not include a unique key, an update or delete might affect more than one row.<br><br></li>
<li>
VARIANT_FALSE, which indicates that an update or delete always affects a single row or the provider cannot detect whether it affects multiple rows.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_RETURNPENDINGINSERTS</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Return Pending Inserts</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the methods that fetch rows, such as <b>IRowset::GetNextRows</b>, can return pending insert rows; that is, rows that have been inserted in delayed update mode but for which <b>IRowsetUpdate::Update</b> has not yet been called.<br><br></li>
<li>
VARIANT_FALSE, which indicates that the methods that fetch rows cannot return pending insert rows.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ROWRESTRICT</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Row Privileges</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that access rights are restricted on a row-by-row basis. If the rowset supports <b>IRowsetChange</b>, <b>IRowsetChange::SetData</b> can be called for some but not all rows. A rowset must never count or return a handle for a row for which the consumer does not have read access rights.<br><br></li>
<li>
VARIANT_FALSE, which indicates that access rights are not restricted on a row-by-row basis. If the rowset supports <b>IRowsetChange</b>, <b>SetData</b> can be called for any row.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ROWSET_ASYNCH</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R/W</p>
<p>
Description: Asynchronous Rowset Processing</p>
<p>
Specifies a bitmask that indicates the asynchronous processing performed on the rowset. </p>
<p>
Specifies values as zero or more of:
<ul type=disc>
<li>
DBPROPVAL_ASYNCH_INITIALIZE, which indicates that the rowset is initialized asynchronously. The method requesting the rowset returns immediately, but attempting to call any interface other than <b>IConnectionPointContainer</b> to obtain the IID_IDBStatusNotify connection point may fail and the full set of interfaces may not be available on the rowset until asynchronous initialization has completed.<br><br></li>
<li>
DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION, which indicates that the rowset is randomly asynchronously populated. Requests for rows may return DB_E_ENDOFROWSET before the end of the rowset is actually reached. Asynchronously populated rows may be inserted anywhere in the rowset.<br><br></li>
<li>
The consumer may set both DBPROPVALUE_ASYNCH_SEQUENTIALPOPULATION and DBPROPVALUE_ASYNCH_RANDOMPOPULATION bits to request that the rowset be asynchronously populated either sequentially or randomly. The consumer is prepared for asynchronous notifications in <b>OnRowChange</b> as well as from <b>IDBAsynchStatus</b>. Only one property is returned by the rowset. If the rowset is asynchronously populated it returns either DBPROPVAL_ASYNCH_RANDOM or DBPROPVAL_ASYNCH_SEQUENTIAL.</li>
</ul>
<p>
If no bits are set (the default) the rowset is initialized and populated synchronously. All requested interfaces are available when the method requesting the rowset returns and requesting rows block until the requested number of <i>hRows</i> are obtained or the end of the rowset is reached.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_ROWTHREADMODEL</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R/W</p>
<p>
Description: Row Threading Model</p>
<p>
Specifies the threading model of the rowsets generated by the command, that is:
<ul type=disc>
<li>
DBPROPVAL_RT_FREETHREAD<br><br></li>
<li>
DBPROPVAL_RT_APTMTTHREAD<br><br></li>
<li>
DBPROPVAL_RT_SINGLETHREAD</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_SERVERCURSOR</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Server Cursor</p>
<p>
If the value of this property is set to VARIANT_TRUE with <b>ICommandProperties::SetProperties</b>, the cursor underlying the rowset (if any) must be materialized on the server.</p>
<p>
If the value of this property is not set with <b>SetProperties</b>, it is up to the provider to decide where to materialize the cursor.</p>
<p>
The consumer can determine where the cursor was materialized by checking the value of this property on the rowset.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_STRONGIDENTITY</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R Only</p>
<p>
Description: Strong Row Identity</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that the handles of newly inserted rows can be compared as specified by DBPROP_LITERALIDENTITY. <br><br></li>
<li>
VARIANT_FALSE, which indicates that there is no guarantee that the handles of newly inserted rows can be compared successfully. In this case, <b>IRowsetIdentity::IsSameRow</b> might return DB_E_NEWLYINSERTED.</li>
</ul>
<p>
A newly inserted row is defined to be a&nbsp; row for which an insertion has been transmitted to the data source, as opposed to a pending insert row. </p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_TRANSACTEDOBJECT</td>
<td width=51%>Type: VT_BOOL<p>
Typical R/W: R/W</p>
<p>
Description: Objects Transacted</p>
<p>
Specifies values as either of:
<ul type=disc>
<li>
VARIANT_TRUE, which indicates that any object created on the specified column is transacted. That is, data made visible to the data source through the object can be committed with <b>ITransaction::Commit</b> or aborted with <b>ITransaction::Abort</b>.<br><br></li>
<li>
VARIANT_FALSE, which indicates that any object created on the specified column is not transacted. That is, all changes to the object are permanent once they are made visible to the data source.</li>
</ul>
<p>
If this property is set on a column that does not contain an object, it is ignored.</p>
</td>
</tr>
<tr valign=top>
<td width=49%>DBPROP_UPDATABILITY</td>
<td width=51%>Type: VT_I4<p>
Typical R/W: R/W</p>
<p>
Description: Updatability</p>
<p>
Specifies a bitmask that indicates the supported methods on <b>IRowsetChange</b>, that is, zero or more of:
<ul type=disc>
<li>
DBPROPVAL_UP_CHANGE, which indicates that <b>SetData</b> is supported.<br><br></li>
<li>
DBPROPVAL_UP_DELETE, which indicates that <b>DeleteRows</b> is supported.<br><br></li>
<li>
DBPROPVAL_UP_INSERT, which indicates that <b>InsertRow</b> is supported.<br><br></li>
<li>
DBPROP_UPDATABILITY, which should be used in conjunction with DBPROP_IROWSETCHANGE. If DBPROP_IROWSETCHANGE is VARIANT_TRUE and DBPROP_UPDATABILITY is not set, then it is provider-specific what methods are supported on <b>IRowsetChange</b>.</li>
</ul>
</td>
</tr>
</table><br>
</font></BODY>
</HTML>
