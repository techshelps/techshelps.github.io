<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>IMDDataset::GetCellData</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="imddatasetgetcelldata"></a>IMDDataset::GetCellData</h1>
<p>
Returns the cell value, formatted value, cell ordinal number, and other requested properties of a range of cells.</p>
<pre><code>HRESULT GetCellData(
   HACCESSOR         hAccessor,
   ULONG               ulStartCell,
   ULONG               ulEndCell,
   VOID*               pData);
</code></pre>
<p class=label>
<b>Parameters</b></p>
<p class=dt>
<i>hAccessor</i>[in]</p>
<p class=indent>
The handle of the accessor to use. If <i>hAccessor</i> is the handle of a null accessor, then <b>IMDDataset::GetCellData</b> doesn’t get any data or property values.</p>
<p class=dt>
<i>ulStartCell</i>[in]</p>
<p class=indent>
The cell ordinal of the first cell in the range.</p>
<p class=dt>
<i>ulEndCell</i>[in]</p>
<p class=indent>
The cell ordinal of the last cell in the range.</p>
<p class=dt>
<i>pData</i>[out]</p>
<p class=indent>
A pointer to the buffer in which to return the data. The consumer allocates memory for this buffer.</p>
<p class=label>
<b>Return Code</b></p>
<p class=indent>
S_OK<br>
The method succeeded. The status of all columns (cell properties) for all rows (cells) bound by the accessor is set to one of DBSTATUS_S_OK, DBSTATUS_S_ISNULL, or DBSTATUS_S_TRUNCATED.</p>
<p class=indent>
DB_S_ERRORSOCCURRED<br>
An error occurred while returning data for one or more columns (cell properties) in one or more rows (cells), but data was successfully returned for at least one property of one cell. To determine the cells or properties for which data was returned, the consumer checks the status values. For a list of status values that can be returned by this method, see “Possible Return and Status Values” in the comments section.</p>
<p class=indent>
E_FAIL<br>
A provider-specific error occurred.</p>
<p class=indent>
E_INVALIDARG<br>
<i>pData</i> was a null pointer and the accessor wasn’t a null accessor.</p>
<p class=tl>
<i>ulStartCell</i> or <i>ulEndCell</i> is invalid.</P><p class=indent>
DB_E_BADACCESSORHANDLE<br>
<i>hAccessor</i> was invalid. Providers aren’t required to check for this condition, because doing so might slow the method significantly.</p>
<p class=indent>
DB_E_BADACCESSORTYPE<br>
The specified accessor was not a row accessor.</p>
<p class=indent>
DB_E_ERRORSOCCURRED<br>
Errors occurred while returning data for all properties of all cells. To determine what errors occurred, the consumer checks the status values. For a list of status values that can be returned by this method, see “Possible Return and Status Values” in the comments section.</p>
<p class=indent>
MD_E_INVALIDCELLRANGE<br>
<i>cbRowSize</i> of the <b>IAccessor::CreateAccessor</b> call that created <i>hAccessor</i> was 0, and <i>ulStartCell</i> was not equal to <i>ulEndCell</i>.</p>
<p class=tl>
<i>ulStartCell</i> was greater than <i>ulEndCell</i> and <i>ulEndCell</i> wasn’t zero.</P><p class=tl>
<i>ulStartCell</i>, <i>ulEndCell</i>, or both specified a cell ordinal that wasn’t in the dataset.</P><p>
If this method performs deferred accessor validation and that validation takes place before any data is transferred, it can also return for the reasons listed in the corresponding DBBINDSTATUS values in <b>IAccessor::CreateAccessor</b> any of the following return codes:
<ul type=disc>
<li>
E_NOINTERFACE<br><br></li>
<li>
DB_E_BADBINDINFO<br><br></li>
<li>
DB_E_BADORDINAL<br><br></li>
<li>
DB_E_BADSTORAGEFLAGS<br><br></li>
<li>
DB_E_UNSUPPORTEDCONVERSION</li>
</ul>
<p class=label>
<b>Comments</b></p>
<p>
This method allows for the retrieval of a dataset slice. The consumer identifies the desired slice by specifying the <i>ulStartCell</i> and <i>ulEndCell</i> parameters; <i>ulStartCell</i> is the upper left corner of the slice and <i>ulEndCell</i> is the lower right corner of the slice. Because these parameters are used to identify the slice, not all cells between <i>ulStartCell</i> and <i>ulEndCell</i> are necessarily fetched. This is illustrated in the following diagram of a two-axis dataset. The heavily outlined cells are the slice of the dataset identified by <i>ulStartCell</i> and <i>ulEndCell.</i> They are fetched. The shaded cells have ordinal values less that <i>ulEndCell</i> and greater than <i>ulStartCell</i>, but are not fetched.</p>
<p>
<img src="te_mddata01.gif" border=0></p>
<h2>Determining Cell Ordinals</h2>
<p>
To facilitate navigation among cells, OLE DB for OLAP uses an ordinal value system to uniquely identify cells within a dataset. The ordinal value is computed from the tuple ordinals of the tuples forming the cell coordinates. The tuple ordinal is the zero-based distance of the tuple from the origin of that axis.</p>
<p>
Conceptually, cells are numbered in a dataset as if the dataset were a <i>p</i>-dimensional array, where <i>p</i> is the number of axes. Cells are addressed in row-major order. Below is the formula for calculating the ordinal number of a cell:</p>
<p>
<img src="te_mddata02.gif" border=0></p>
<h2>Available Data</h2>
<p>
Each cell is treated as a row in a rowset, and cell properties are treated as columns. The actual properties available depend on the MDX expression that generated the dataset. For a detailed discussion of cell properties, see “Retrieving Cell Properties” in Chapter 2. <b>IColumnsInfo</b> can also be used to find out the number of columns or properties available, and name, data type, and so on.</p>
<h2>Special Cases</h2>
<p>
If the consumer specifies zero for <i>ulStartCell</i> and a nonzero value for <i>ulEndCell</i>, the provider fetches the cells in the slice identified by the first cell in the dataset and the specified ending cell. If the consumer specifies a nonzero value for <i>ulStartCell</i> and zero for <i>ulEndCell</i>, the provider fetches the cells in the slice identified by the specified start cell and the last cell in the dataset. Except for this case, it is an error to have <i>ulStartCell</i> greater than <i>ulEndCell</i>.</p>
<p>
If the consumer specifies a <i>ulStartCell</i> or <i>ulEndCell</i> value that falls outside the dataset, the method fails.</p>
<h2>Possible Return and Status Values</h2>
<p>
As the provider returns cell data, it sets the status field of each bound property value buffer. Using this value, the consumer can determine which property values were successfully fetched.</p>
<p class=indent>
<B><b>Note</b></B>&nbsp;&nbsp;&nbsp;Consumers are strongly encouraged to bind to status values. If the status is other than DBSTATUS_S_OK, the provider is not obligated to touch the value part of the consumer’s buffer.</p>
<p>
The method produces return values as follows:
<ul type=disc>
<li>
Success. Return code is S_OK. No errors occurred while getting data for any properties. There may have been warnings (for example, data truncation warnings) when fetching property values for certain cells.<br><br></li>
<li>
Partial success. Return code is DB_S_ERRORSOCCURRED. There were errors while retrieving cell properties for one or more cells. At least one property value was successfully retrieved for at least one cell.<br><br></li>
<li>
Failure. Return code is DB_E_ERRORSOCCURRED. No property was successfully retrieved.</li>
</ul>
<p>
The following table lists all possible status values:</p>
<table border=1 cellpadding=5 cols=4 frame=below rules=rows width=576>
<tr valign=top>
<td class=label width=35%><b><br>
<br>
Status value</b></td>
<td class=label width=14%><b>Success, warning, or error</b></td>
<td class=label width=14%><b><br>
Data <br>
returned</b></td>
<td class=label width=37%><b><br>
<br>
Description</b></td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_S_OK</td>
<td width=14%>Success</td>
<td width=14%>Y</td>
<td width=37%>A non-NULL value was returned by the provider.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_S_<br>
ISNULL</td>
<td width=14%>Success</td>
<td width=14%>Y</td>
<td width=37%>A NULL value was returned by the provider.</td>
</tr>
<tr valign=top>
<td width=35%>MDSTATUS_S_<br>
CELLEMPTY</td>
<td width=14%>Success</td>
<td width=14%>Y</td>
<td width=37%>The cell was empty. This occurs when there is no data in the cube at the coordinates of the cell. Using the NON EMPTY clause of the MDX statement guarantees that there are no empty cells.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_S_<br>
TRUNCATED</td>
<td width=14%>Warning</td>
<td width=14%>Y</td>
<td width=37%>Variable length data or nonsignificant digits of numeric data were truncated.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_<br>
BADACCESSOR</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>Accessor validation was deferred and was performed while the method returned data. The binding was invalid for this column or parameter.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_<br>
CANTCONVERTVALUE</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>The data value couldn’t be converted for reasons other than sign mismatch or data overflow. For example, the data in the data source was corrupted but the row was still retrievable.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_CANTCREATE</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>One of the following conditions:<ul type=disc>
<li>
The provider couldn’t allocate memory in which to return data.<br><br></li>
<li>
The type indicator for the column was DBTYPE_IUNKNOWN and a storage object was already open on the column.<br><br></li>
<li>
The type indicator for the column was DBTYPE_IUNKNOWN, the provider supports only one open storage object at a time (DBPROP_MULTIPLESTORAGEOBJECTS was VARIANT_FALSE), and a storage object was already open on the rowset.</li>
</ul>
</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_<br>
DATAOVERFLOW</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>Conversion failed because the data value overflowed the type specified for the value part in the consumer’s buffer.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_<br>
SIGNMISMATCH</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>Conversion failed because the data value was signed and the type specified for the value part in the consumer’s buffer was unsigned.</td>
</tr>
<tr valign=top>
<td width=35%>DBSTATUS_E_UNAVAILABLE</td>
<td width=14%>Error</td>
<td width=14%>N</td>
<td width=37%>Value couldn’t be determined by the provider. For example, the row was just created, the default for the column wasn’t available, and the consumer hadn’t yet set a new value.</td>
</tr>
</table><br>
<h2>Errors During Cell Fetch</h2>
<p>
When fetching a range of cells, there can be errors in fetching a given column or property of a given row or cell. Examples of such errors include truncation and arithmetic overflow. This does not necessarily invalidate all the data fetched. Errors are localized to individual columns and are indicated in the STATUS part of the consumer’s buffer for each column. This is a 2-byte field containing manifest constants denoting different error and status indicators. The status indicators are listed and their meanings are defined in the <i>OLE DB Programmer’s Reference.</i></p>
<h2>Using <i>cbRowSize</i> of IAccessor::CreateAccessor</h2>
<p>
Because this method fetches properties for more than one cell, the provider should know how long each row is. A “row” in this context means the area allocated in the consumer’s buffer to hold all properties pertaining to one cell. This information should be given in the <i>cbRowSize</i> parameter of <b>IAccessor::CreateAccessor</b>. If the value of this parameter is zero, it means that the consumer wants to fetch only one row of data (one cell). In this case, it is an error to specify a <i>ulStartCell</i> different from the <i>ulEndCell</i>.</p>
<p>
The consumer’s buffer for holding cell data must be laid out in such a way that each row is directly adjacent to the next row. Within a row, the columns must be laid out at the offsets specified by the DBBINDING structure. There must be enough space allocated to fetch the requested number of cells. Consumers are advised to pad <i>cbRowSize</i> appropriately for machine alignment (Intel<sup>®</sup>, 4-byte).</p>
</font></BODY>
</HTML>
