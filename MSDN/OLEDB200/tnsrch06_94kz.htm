<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Literal Sets</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="literalsets"></a>Literal Sets</h1>
<p>
<i>Literal set</i>, as used here, means a set that is specified by an enumerated list of tuples. Consider the set</p>
<pre><code>{(x,y), (a,b)}
</code></pre>
<p>
In this set, x and a are members of dimension Name1; y and b belong to dimension Name2. The literal set shown above can be expanded into a table value expression such as the following:</p>
<pre><code>CREATE LOCAL TEMPORARY VIEW T1(Name1, Name2, Rank) AS
SELECT Name1, Name2 
FROM ( VALUES (x,y,1), (a,b, 2) ) AS T2(Name1, Name2, Rank) 
ORDER BY Rank
</code></pre>
<p>
In the above statement, the FROM clause contains a table specification, which is in the form of an enumerated list of rows. The SQL-92 &lt;table_value_constructor&gt; syntax has been used for this purpose.</p>
<p>
The detailed syntax, derived from SQL-92, is as follows:</p>
<pre><code>&lt;table_reference&gt; ::= &lt;derived_table&gt; [AS] &lt;correlation_name&gt;
 &nbsp;&nbsp;&nbsp; [&lt;left_paren&gt; &lt;derived_column_list&gt; &lt;right_paren&gt; ] | ...
&lt;derived_table&gt; ::= &lt;table_subquery&gt;
&lt;table_subquery&gt; ::= ( &lt;simple_table&gt; | ... )
&lt;simple_table&gt; ::= &lt;table_value_constructor&gt; |... 
&lt;table_value_constructor&gt; ::= 
 &nbsp;&nbsp;&nbsp; VALUES &lt;row_value_constructor&gt; [ {, &lt;row_value_constructor&gt;} ... ]
&lt;row_value_constructor&gt; = ::=&nbsp; 
 &nbsp;&nbsp;&nbsp; ( &lt;value_expression&gt; [ {, &lt;value_expression&gt; ... ] ) | ...
</code></pre>
<p>
This nets out to the fact that a table can be defined from literals as:</p>
<pre><code>&lt;literal_table&gt; ::= (VALUES(&lt;literal&gt;[{, &lt;literal&gt;}...) 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [{,( &lt;literal&gt; [ {,&lt;literal&gt;}...)}...] )
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [AS] &lt;correlation_name&gt;[ &lt;left_paren&gt; 
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;derived_column_list&gt; &lt;right_paren&gt; ]
</code></pre>
<p>
The result is a table T for which each row is a tuple of the input set. OLE DB for OLAP requires that the member names x, y, z, a, b, and c be unambiguous names. Unambiguous names need not be fully qualified. They are just qualified to the extent needed to make them unique. When generating an SQL expression for it, the expression must return fully qualified names for these members. This is required because the MEMBER table has fully qualified names, and it does equijoins with this table while evaluating an MDX expression.</p>
<p>
In order to get a table T from T1, which contains the fully qualified names, you must use the following:</p>
<pre><code>CREATE LOCAL TEMPORARY VIEW T(Name1, Name2, Rank) AS
SELECT M1.Name1, M2.Name2, T1.Rank
FROM MEMBER M1, MEMBER M2, T1
WHERE M1.Name LIKE ("%." || T.Name1)
AND M2.Name LIKE ("%." || T.Name2)
ORDER BY T1.Rank
</code></pre>
<p>
In the above query, “||” is the string concatenation operator.</p>
</font></BODY>
</HTML>
