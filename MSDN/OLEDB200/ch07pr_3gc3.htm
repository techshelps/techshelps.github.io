<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Storage Objects and Transactions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="oledbstorage_objects_and_transactions"></a>Storage Objects and Transactions</h1>
<p>
Whether storage objects are transacted on the data source depends on the DBPROP_TRANSACTEDOBJECT property, which can be set on a per-column basis. If the value of this property is VARIANT_TRUE, then any storage object created on the column is transacted. That is, when a consumer calls <b>ITransaction::Commit</b> and the provider commits all data visible to the rowset, this includes data made visible to the rowset through storage objects. When a consumer calls <b>ITransaction::Abort</b> and the provider rolls back all data visible to the rowset, this includes data made visible to the rowset through storage objects. For information about what data in storage objects is visible to the rowset, see "<a href="ch07pr_5z1v.htm">Storage Objects and Rowset Update Semantics</a>" earlier in this chapter.</p>
<p>
Whether uncommitted data in transacted storage objects remains valid and whether the storage objects themselves remain valid when the transaction is committed or aborted depends on the retaining flag (<i>f</i>Retaining) used in the call to <b>Commit</b> or <b>Abort</b>. The retaining flag set to TRUE implicitly begins a new unit of work. If a commit is retaining, then the storage objects and any uncommitted data in them remain valid. If an abort is retaining, then the storage objects remain valid, but any uncommitted data in them is lost; furthermore, the provider must synchronize the object with its state in the data source after the transaction was aborted there. If the rowset is not preserved after a commit or abort, then the storage objects enter zombie states and any uncommitted data in them is lost; the consumer can only call <b>Release</b> on such objects—all other methods return E_UNEXPECTED. Whether the rowset is preserved depends on the DBPROP_COMMITPRESERVE and DBPROP_ABORTPRESERVE properties. For more information on committing and aborting a transaction, see “<a href="ch12pr_2dmb.htm">Transaction Objects</a>” in Chapter 12, “Transactions.”</p>
<p>
If the value of DBPROP_TRANSACTEDOBJECT is VARIANT_FALSE, then any storage object created on the column is not transacted. That is, all changes to the storage object are permanent once they are made visible to the data source. Whether a nontransacted storage object remains valid after <b>Commit</b> or <b>Abort</b> is called depends on the implementation of the rowset and the object itself.</p>
</font></BODY>
</HTML>
