<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Supporting Distributed Transactions</title>
<link disabled rel=stylesheet href=msdn_ie3.css>
<style type="text/css">
@import url(msdn_ie4.css);
</style>
</HEAD>
<BODY>
<FONT FACE="Verdana, Arial, Helvetica" SIZE="2">

	<!--TOOLBAR_START-->
	<!--TOOLBAR_EXEMPT-->
	<!--TOOLBAR_END-->


<h1><a name="supporting_distributed_transactions"></a>Supporting Distributed Transactions</h1>
<p>
SQLOLEDB consumers can use <b>ITransactionJoin::JoinTransaction</b> to participate in a distributed transaction coordinated by MS DTC.</p>
<p>
MS DTC exposes COM objects that allow clients to initiate and participate in coordinated transactions across multiple connections to variety of data stores. To initiate a transaction, the SQLOLEDB consumer uses the MS DTC <b>ITransactionDispenser </b>interface. The <b>BeginTransaction</b> member of <b>ITransactionDispenser</b> returns a reference on a distributed transaction object. This reference is passed to SQLOLEDB using <b>JoinTransaction</b>.</p>
<p>
MS DTC supports asynchronous commit and abort on distributed transactions. For notification on asynchronous transaction status, the consumer implements the <b>ITransactionOutcomeEvents</b> interface and connects the interface to an MS DTC transaction object.</p>
<p>
For distributed transactions, SQLOLEDB implements <b>ITransactionJoin::JoinTransaction</b> parameters as follows.</p>
<table border=1 cellpadding=5 cols=2 frame=below rules=rows width=595>
<tr valign=top>
<td class=label width=33%><b>Parameter</b></td>
<td class=label width=67%><b>Description</b></td>
</tr>
<tr valign=top>
<td width=33%><i>punkTransactionCoord</i></td>
<td width=67%>A pointer to an MS DTC transaction object.</td>
</tr>
<tr valign=top>
<td width=33%><i>IsoLevel</i></td>
<td width=67%>Ignored by SQLOLEDB. The isolation level for MS DTC-coordinated transactions is determined when the consumer acquires a transaction object from MS DTC.</td>
</tr>
<tr valign=top>
<td width=33%><i>IsoFlags</i></td>
<td width=67%>Must be 0. SQLOLEDB returns XACT_E_<br>
NOISORETAIN if any other value is specified by the consumer.</td>
</tr>
<tr valign=top>
<td width=33%><i>POtherOptions</i></td>
<td width=67%>If not NULL, SQLOLEDB requests the options object from the interface. SQLOLEDB returns XACT_E_<br>
NOTIMEOUT if the options object’s ulTimeout member is not zero. SQLOLEDB ignores the value of the szDescription member.</td>
</tr>
</table><br>
<h3>Example</h3>
<p>
This example coordinates transaction by using MS DTC.</p>
<pre><code>// SQLOLEDB interfaces used in the example.
IDBCreateSession*&nbsp;&nbsp; pIDBCreateSession = NULL;
ITransactionJoin*&nbsp;&nbsp; pITransactionJoin = NULL;
IDBCreateCommand*&nbsp;&nbsp; pIDBCreateCommand = NULL;
IRowset*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pIRowset&nbsp;&nbsp;&nbsp; = NULL;
<b><i>  </i></b>
// Transaction dispenser and transaction from MS DTC.
ITransactionDispenser*&nbsp; pITransactionDispenser = NULL;
ITransaction*&nbsp;&nbsp;&nbsp;&nbsp; pITransaction&nbsp;&nbsp; = NULL;
<b><i>  </i></b>
  HRESULT&nbsp;&nbsp;&nbsp;&nbsp; hr;
<b><i>  </i></b>
// Get the command creation interface for the session.
if (FAILED(hr = pIDBCreateSession-&gt;CreateSession(NULL,
 &nbsp; IID_IDBCreateCommand, (IUnknown**) &amp;pIDBCreateCommand)))
  {
  // Process error from session creation. Release any references and
  // return.
  }
<b><i>  </i></b>
// Get a transaction dispenser object from MS DTC and
// start a transaction.
if (FAILED(hr = DtcGetTransactionManager(NULL, NULL,
  IID_ITransactionDispenser, 0, 0, NULL,
  (void**) &amp;pITransactionDispenser)))
  {
  // Process error message from MS DTC, release any references,
  // and then return.
  }
if (FAILED(hr = pITransactionDispenser-&gt;BeginTransaction(
  NULL, ISOLATIONLEVEL_READCOMMITTED, ISOFLAG_RETAIN_DONTCARE,
  NULL, &amp;pITransaction)))
  {
  // Process error message from MS DTC, release any references,
  // and then return.
  }
<b><i>  </i></b>
// Join the transaction.
if (FAILED(pIDBCreateCommand-&gt;QueryInterface(IID_ITransactionJoin,
  (void**) &amp;pITransactionJoin)))
  {
  // Process failure to get an interface, release any references, and
  // then return.
  }
if (FAILED(pITransactionJoin-&gt;JoinTransaction(
  (IUnknown*) pITransaction, 0, 0, NULL)))
  {
  // Process join failure, release any references, and then return.
  }
<b><i>  </i></b>
// Get data into a rowset, then update the data. Functions not
// illustrated in this example.
if (FAILED(hr = ExecuteCommand(pIDBCreateCommand, &amp;pIRowset)))
  {
  // Release any references and return.
  }
<b><i>  </i></b>
// If rowset data update fails, then Abort the transaction, else
// commit. The example is not retaining.
if (FAILED(hr = UpdateDataInRowset(pIRowset, bDelayedUpdate)))
  {
  // Get error from update, then abort.
  pITransaction-&gt;Abort(NULL, FALSE, FALSE);
  }
else
  {
  if (FAILED(hr = pITransaction-&gt;Commit(FALSE, 0, 0)))
 &nbsp;&nbsp; {
 &nbsp;&nbsp; // Get error from failed commit.
 &nbsp;&nbsp; //
 &nbsp;&nbsp; // If a distributed commit fails, Application logic could
 &nbsp;&nbsp; // analyze failure and retry. We’ll abort. The consumer
 &nbsp;&nbsp; // must resolve this somehow.
 &nbsp;&nbsp; pITransaction-&gt;Abort(NULL, FALSE, FALSE);
 &nbsp;&nbsp; }
  }
<b><i>  </i></b>
if (FAILED(hr))
  {
  // Update of data or commit failed. Release any references and
  // return.
  }
<b><i>  </i></b>
// Release any references and continue.</code></pre>
</font></BODY>
</HTML>
