<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PACKET_BUFFER</title>
<link disabled rel=stylesheet href=../../backsdk3.css>
<style type="text/css">
@import url(../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_bpc_packet_buffer"></a>PACKET_BUFFER</h1>
<p>
<span style=color:#FF0000>[This is preliminary documentation and subject to change.]</span> </p>
<p>
The <b>PACKET_BUFFER </b>structure contains information about a packet of data that a virtual interface sends to its output system.</p>
<pre><code>typedef struct PACKET_BUFFER {
    LPBYTE                 Data;    // storage for packet data
    DWORD                  Start;   // where the data begins
    DWORD                  End;     // where the data ends
    DWORD                  Max;     // the physical length of Data
    DWORD                  Context;
    WORD                   Protocol;
    WORD                   AddressLength;
    BYTE                   Address[16];
    PACKET_COMPLETION_FUNC CompletionFunc;
} PACKET_BUFFER;
 </code></pre>
<h4>Members</h4>
<dl>
<dt>
<b>Data</b></dt>
<dd>
Buffer containing the data that the virtual interface transmits.</dd>
<dt>
<b>Start</b></dt>
<dd>
The beginning memory location of the transmitted data.</dd>
<dt>
<b>End</b></dt>
<dd>
The ending memory location of the transmitted data.</dd>
<dt>
<b>Max</b></dt>
<dd>
The maximum physical length of the transmitted data. The <b>End</b> member can never be increased beyond the value of <b>Max</b>.</dd>
<dt>
<b>Context</b></dt>
<dd>
Value specifying the context of the transmitted data.</dd>
<dt>
<b>Protocol</b></dt>
<dd>
Value specifying the format of the data. The following table lists and describes the valid format values.
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=46%>Value</th>
<th align=left width=54%>Meaning</th>
</tr>
<tr valign=top>
<td width=46%>PACKET_BUFFER_PROTOCOL_IP</td>
<td width=54%>The packet body is a full IP packet, including header and body. Virtual interfaces should extract an IP address from the message body. The <b>Address</b> member of <b>PACKET_BUFFER</b> is not used.</td>
</tr>
<tr valign=top>
<td width=46%>PACKET_BUFFER_PROTOCOL_VBI_RAW</td>
<td width=54%>The packet is a VBI frame. The <b>Address</b> member of <b>PACKET_BUFFER</b> is not used.</td>
</tr>
</table><br>

</dd>
<dt>
<b>AddressLength</b></dt>
<dd>
Size, in bytes, of the <b>Address</b> array. If <b>Address</b> is null, <b>AddressLength</b> is zero. </dd>
<dt>
<b>Address</b></dt>
<dd>
An array of bytes specifying an address to which the packet belongs. This array can be no longer than 16 bytes.</dd>
<dt>
<b>CompletionFunc</b></dt>
<dd>
Pointer to a function that a virtual interface DLL calls to inform the MMR that the DLL is done processing the packet buffer. In this call, the DLL provides status on the completed packet. 
</dd>
</dl>
<h4>Remarks</h4>
<p>
The MMR keeps track of packets with the <b>PACKET_BUFFER</b> structure. A virtual interface uses <b>PACKET_BUFFER</b> to route packets from the MMR to a specific output system. </p>
<p>
The <b>PACKET_BUFFER</b> structure provides virtual interfaces with an easy way to add or remove packet headers without requiring memory allocation and copy operations. For example, to remove an IP header from a packet, advance the <b>Start</b> member of <b>PACKET_BUFFER</b> by the length of the IP header. To add an Ethernet frame header to the front of a packet, first insure that there is sufficient space at the beginning of the packet buffer by checking to make sure that the <b>Start</b> member is greater than or equal to the length of an Ethernet header. Then, subtract the length of the Ethernet header from the <b>Start</b> member and fill in the appropriate members in the Ethernet header. </p>
<p>
When the MMR calls the <a href="outrf_08fo.htm"><b>msbdnOutputSendPacket</b></a> function on a specific instance of a virtual interface, such a virtual interface takes responsibility for the passed <b>PACKET_BUFFER</b> while processing it. This virtual interface must eventually call the <a href="outrf_0s4l.htm"><b>PacketBufferComplete</b></a> function to indicate to the MMR that the virtual interface is done processing.</p>
<h4>See Also</h4>
<p>
<a href="outrf_08fo.htm"><b>msbdnOutputSendPacket</b></a>, <a href="outrf_0s4l.htm"><b>PacketBufferComplete</b></a> </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
