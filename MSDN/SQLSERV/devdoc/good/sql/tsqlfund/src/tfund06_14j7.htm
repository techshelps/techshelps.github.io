<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Expanding Networks</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_expanding_networks"></a>Expanding Networks</h1>
<p>
In the example in the preceding section, each item had only one superior. In a network, an item can have more than one superior. The following data, for example, is a representation of airline flights among a number of cities:</p>
<pre>Departure    Destination
---------    -------------
Chicago    New York
Chicago    Milwaukee
Denver    Chicago
Seattle    Chicago
Seattle    Denver
Seattle    San Francisco</pre>
<p>
A common problem you can have with this data is finding all routes between a given pair of cities:</p>
<pre>Itineraries
----------------------------------
Seattle, Chicago, New York
Seattle, Denver, Chicago, New York</pre>
<p>
A few changes to the example in the preceding section can accomplish this:
<ul>
<li>
Two additional input parameters are required: the goal city and the depth-of-search limit.</li>
<li>
The current itinerary is saved in another temporary table and displayed only when a goal is reached.</li>
<li>
To avoid expanding around a cycle in the network, don't expand cities that appear in the current itinerary.</li>
</ul>
<p>
These changes are illustrated in the following example (not from <i>pubs</i>):</p>
<pre>create proc route 
(@current char(20), @dest char(20), @maxlevel int = 5) as
set nocount on
declare @level int
create table #stack (city char(20), level int)
create table #list (city char(20), level int)
insert #stack values (@current, 1)
select @level = 1
while @level &gt; 0
begin
    if exists (select * from #stack where level = @level)
        begin
            select @current = city
            from #stack
            where level = @level
            delete from #stack 
            where level = @level 
                and city = @current
            delete from #list 
            where level &gt;= @level
            if exists(select * from #list where city = @current)
                continue
            insert #list values(@current, @level)
            if(@current = @dest)
            begin
                select itinerary = city
                from #list
                continue
            end
            insert #stack
            select destination, @level  1
            from flights
            where departure = @current
                and @level &lt; @maxlevel
            if @@rowcount &gt; 0
                select @level = @level  1
        end
    else
        select @level = @level - 1
end</pre>
<p>
In this example, when <i>@level</i> is greater than 0, the process follows several steps:
<ol>
<li>
The current city is added to <i>#list</i> by clearing anything at the current level or below (DELETE FROM <i>#list</i> WHERE <i>level</i> &gt; = <i>@level</i>) and then adding the current city (INSERT <i>#list</i> VALUES(<i>@current</i>, <i>@level</i>)).</li>
<li>
Whenever the goal city is reached (<i>@current</i> = <i>@dest</i>), this example displays the path (SELECT <i>itinerary</i> = <i>city</i> FROM <i>#list</i>) and doesn't expand the path any further (CONTINUE).</li>
<li>
The depth of search is limited by adding a condition (<i>@level</i> &lt; <i>@maxlevel</i>) to the INSERT statement that adds cities to the stack.</li>
</ol>
<p>
The IF EXISTS statement at the beginning of the WHILE loop skips the current city if it's already in the current itinerary.</p>
<p>
If the <i>flights </i>table in the preceding example also contains cost information, the lowest cost route can be found by saving the current itinerary if its total cost is less than the best cost so far:</p>
<pre>select @cost = sum(cost)
from #list
if @cost &lt; @lowest_cost
begin
    @lowest_cost = @cost
    truncate table #best_route
    insert #best_route
        select *
        from #list
end</pre>
<p>
For greater efficiency, you can stop expanding the current route if the current cost far exceeds the cost of the best route:</p>
<pre>if (select sum(cost) from #list) &gt; @lowest_cost
    continue</pre>
<p>
If the <i>flights</i> table also includes a departure and arrival time, you can add an IF statement to expand only the routes that have a departure time at least one hour after the arrival time of the current route:</p>
<pre>if ((select sum(cost) from #list) &gt; @lowest_cost)
    and datediff(hh, departuretime, @arrivaltime) &gt; 1)
continue</pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
