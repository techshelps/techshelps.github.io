<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Preventing Deadlocks and Lock Starvation</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="preventing_deadlocks_and_lock_starvation"></a>Preventing Deadlocks and Lock Starvation</h2>
<p>
SQL Server automatically detects and resolves <i>deadlocks</i>. A deadlock occurs when two users have locks on separate objects and each user wants a lock on the other's object. Each user waits for the other to release their lock. A deadlock typically occurs when several long-running transactions execute concurrently in the same database.</p>
<p>
SQL Server ends a deadlock by automatically choosing the user that can break the deadlock. SQL Server rolls back the breaking user's transaction, notifies the user's application (with message number 1205), cancels the user's current request, and then allows the nonbreaking user's process to continue.</p>
<p>
In a multiuser situation, each application should check for message 1205. This indicates that the transaction was rolled back. If so, the user's application must restart the transaction.</p>
<p>
<b>Note</b>  To reduce the chance of a deadlock, minimize indexing (and the possibility of index locking) on appropriate tables, shorten transactions and transaction times, and use resources in the same order in all transactions.</p>
<p>
SQL Server automatically prevents <i>lock starvation</i>. Lock starvation occurs when read transactions can monopolize a table or page, forcing a write transaction to wait indefinitely. SQL Server handles read and write transactions on a first-come first-served basis, which prevents lock starvation.</p>
<p>&nbsp;</p></body>
</HTML>
