<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Resource-intensive Queries</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="resource.2d.intensive_queries"></a>Resource-intensive Queries</h2>
<p>
Some types of queries are inherently resource-intensive. This is related to fundamental database and index issues common to most relational databases, including SQL Server. They are not inefficient, as the optimizer will execute the queries in the most efficient fashion possible. However, they are resource-intensive, and the set-oriented nature of SQL Server may make them appear inefficient. No degree of optimizer intelligence can eliminate the inherent resource cost of these constructs. They are intrinsically costly when compared to a more simple query. Although SQL Server will use the most optimum access plan, this is limited by what is fundamentally possible.</p>
<p>
For example, the following query characteristics are resource-intensive:
<ul>
<li>
Large results sets</li>
<li>
IN, NOT IN, and OR queries</li>
<li>
&lt;&gt; (not equal)</li>
<li>
Row aggregate functions, such as SUM</li>
<li>
Local variables, expressions, or data conversions in the WHERE clause</li>
<li>
Highly nonunique WHERE clause</li>
<li>
Complex views with GROUP BY or ORDER BY</li>
</ul>
<p>
Various factors may require the use of some of these query constructs. The effect of these will be lessened if the optimizer can restrict the results set before applying the resource-intensive portion of the query. For example, the following restricted query is efficient:</p>
<pre>SELECT SUM(qty) FROM sales
WHERE stor_id = 7131</pre>
<p>
If an index exists on the <i>department</i> column, the optimizer will likely use it to restrict the results set before applying the SUM operation, which can improve performance. Compare that with the following unrestricted and inefficient query, in which the sum operation must read every row in the table:</p>
<pre>SELECT SUM(qty) FROM sales</pre>
<p>
For example, the following query is efficient:</p>
<pre>SELECT * FROM phonebook
WHERE last_name = @var
AND zip_code = 98052</pre>
<p>
If an index exists on the <i>zip_code</i> column, the optimizer will likely use it to restrict the results set, which can improve performance. Compare that with the following inefficient query:</p>
<pre>SELECT * FROM phonebook
WHERE last_name = @var</pre>
<p>
The value in the local variable is only known at run time. Because the optimizer builds the access plan and makes index usage decisions at compile time, the optimizer cannot use the value in the local variable to restrict the results set, even with an index on the <i>zip_code</i> column.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
