<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Testing Data Modifications Against the Trigger Test Tables</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_testing_data_modifications_against_the_trigger_test_tables_tfund06"></a>Testing Data Modifications Against the Trigger Test Tables</h2>
<p>
Two special tables are used in trigger statements: the <i>deleted</i> table and the <i>inserted</i> table. These temporary tables are used in trigger tests. Use these tables to test the effects of certain data modifications and to set conditions for trigger actions. You cannot directly alter the data in the trigger test tables, but you can use the tables in SELECT statements to detect the effects of an INSERT, UPDATE, or DELETE statement.
<ul>
<li>
The <i>deleted</i> table stores copies of the affected rows during DELETE and UPDATE statements. During the execution of a DELETE or UPDATE statement, rows are removed from the trigger table and transferred to the <i>deleted</i> table. The <i>deleted</i> table and the trigger table ordinarily have no rows in common.</li>
<li>
The <i>inserted</i> table stores copies of the affected rows during INSERT and UPDATE statements. During an INSERT or an UPDATE transaction, new rows are added to <i>inserted</i> and the trigger table at the same time. The rows in <i>inserted</i> are copies of the new rows in the trigger table.</li>
<li>
An UPDATE transaction is, conceptually, a delete followed by an insert; the old rows are copied to the <i>deleted</i> table first, and then the new rows are copied to the trigger table and to the <i>inserted</i> table.</li>
</ul>
<p>
When setting trigger conditions, use trigger test tables that are appropriate for modifying data. Although it is not wrong to reference <i>deleted</i> while testing an INSERT, or <i>inserted</i> while testing a DELETE, these trigger test tables won't contain any rows in these cases.</p>
<p>
<b>Note</b>  A given trigger fires only once per statement. If trigger actions depend on the number of rows a data modification affects, you should use tests (such as an examination of @@ROWCOUNT) for multirow data modifications (an INSERT, DELETE, or UPDATE based on a SELECT statement), and take appropriate actions.</p>
<p>
The trigger examples in the following sections accommodate multirow data modifications as necessary. The @@ROWCOUNT variable, which stores the number of rows affected by the most recent data modification operation, tests for a multirow insert, delete, or update. If any other SELECT statement precedes the test on @@ROWCOUNT within the trigger, you should use local variables to store the value for later examination. (All Transact-SQL statements that don't return values reset @@ROWCOUNT to 0).</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
