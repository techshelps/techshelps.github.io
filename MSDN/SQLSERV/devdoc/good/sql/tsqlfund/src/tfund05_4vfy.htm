<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Normalizing Logical Database Design</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_normalizing_logical_database_design"></a>Normalizing Logical Database Design</h2>
<p>
Normalizing a logical database design involves using formal methods to separate the data into multiple, related tables. A greater number of narrow tables (with <br>
fewer columns) is characteristic of a <i>normalized database</i>. A few wide tables <br>
(with more columns) is characteristic of an <i>unnormalized database</i>.</p>
<p>
Reasonable normalization will often improve performance. When useful indexes are available, the SQL Server optimizer is very efficient at selecting rapid, efficient joins between a reasonable number of tables.</p>
<p>
These are some of the benefits of normalization:
<ul>
<li>
Faster sorting and index creation because tables are narrower.</li>
<li>
More clustered indexes are allowed because there are more tables.</li>
<li>
Narrower and more compact indexes.</li>
<li>
Fewer indexes per table, helping INSERT, UPDATE and DELETE performance.</li>
<li>
Fewer NULLs and less redundant data, increasing database compactness.</li>
<li>
Improved concurrency when running DBCC diagnostics, because the necessary table locks will affect less data.</li>
</ul>
<p>
As normalization increases, so will the number and complexity of joins required to retrieve data. Too many complex relational joins between too many tables can hinder performance. Reasonable normalization often includes very few regularly executed queries that use more than four-way joins.</p>
<p>
Sometimes the logical database design is already fixed and total redesign is not feasible. Even then, however, it might be possible to selectively normalize a large table into several smaller tables. If access to the database is conducted through stored procedures, this schema change could take place without affecting applications. If not, it might be possible to create a view that hides the schema change from the applications.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
