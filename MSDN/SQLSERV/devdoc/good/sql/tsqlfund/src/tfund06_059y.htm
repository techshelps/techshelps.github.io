<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Conditional Insert Trigger</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_conditional_insert_trigger_tfund06"></a>Conditional Insert Trigger</h2>
<p>
The triggers examined so far have looked at each data modification statement as a whole; if one row of a four-row insert was unacceptable, the whole insert was unacceptable and the transaction was rolled back. This is the way triggers work. A trigger rejects or accepts each data modification transaction as a whole.</p>
<p>
However, you don't have to roll back all data modifications simply because some of them are unacceptable. Using a correlated subquery in a trigger can force the trigger to examine the modified rows one by one.</p>
<p>
The following example assumes the existence of a table called <i>newsale</i>. Here is the CREATE statement for <i>newsale</i>:</p>
<pre>CREATE TABLE newsale
(stor_id char(4),
ord_num varchar(20),
date datetime,
qty smallint,
payterms varchar(12),
title_id tid)</pre>
<p>
What if you want to examine each of the records you are trying to insert? The trigger <b>conditionalinsert</b> analyzes the insert row by row, and then deletes the rows that do not have a <i>title_id</i> in <i>titles</i>. Here's how:</p>
<pre>CREATE TRIGGER conditionalinsert
ON sales
FOR INSERT AS
IF
(SELECT COUNT(*) FROM titles, inserted
WHERE titles.title_id = inserted.title_id) &lt;&gt; @@rowcount
BEGIN
    DELETE sales FROM sales, inserted
    WHERE sales.title_id = inserted.title_id AND
        inserted.title_id NOT IN
            (SELECT title_id
            FROM titles)
    PRINT 'Only sales records with matching title_ids added.'
END</pre>
<p>
The trigger test is the same as the one in the insert trigger (<b>intrig</b>) example shown earlier, but the transaction is not rolled back. Instead, the trigger deletes the unwanted rows. This ability to delete rows that have been inserted relies on the order in which processing occurs when triggers are fired. First rows are inserted into the table and the <i>inserted</i> table, and then the trigger fires.</p>
<p>
To test the conditional trigger, insert four rows in the <i>newsale</i> table. Two of the <i>newsale</i> rows have <i>title_ids</i> that do not match any of those already in the <i>titles</i> table. Here is the data to insert:</p>
<pre>newsale
</pre>
<table cellspacing=4 cols=6>
<tr valign=top>
<td width=13%><pre>stor_id</pre>
</td>
<td width=16%><pre>ord_num</pre>
</td>
<td width=33%><pre>date</pre>
</td>
<td width=8%><pre>qty</pre>
</td>
<td width=15%><pre>payterms</pre>
</td>
<td width=15%><pre>title_id</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>-------</pre>
</td>
<td width=16%><pre>--------</pre>
</td>
<td width=33%><pre>-------------------</pre>
</td>
<td width=8%><pre>---</pre>
</td>
<td width=15%><pre>--------</pre>
</td>
<td width=15%><pre>--------</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>7066</pre>
</td>
<td width=16%><pre>QA7442.3</pre>
</td>
<td width=33%><pre>Jul 25 1995 8:35AM</pre>
</td>
<td width=8%><pre>75</pre>
</td>
<td width=15%><pre>Net 30</pre>
</td>
<td width=15%><pre>PS1372</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>7066</pre>
</td>
<td width=16%><pre>QA7442.3</pre>
</td>
<td width=33%><pre>Jul 24 1995 8:35AM</pre>
</td>
<td width=8%><pre>75</pre>
</td>
<td width=15%><pre>Net 60</pre>
</td>
<td width=15%><pre>BU7832</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>7067</pre>
</td>
<td width=16%><pre>D4482</pre>
</td>
<td width=33%><pre>Jul 27 1995 12:00AM</pre>
</td>
<td width=8%><pre>10</pre>
</td>
<td width=15%><pre>Net 30</pre>
</td>
<td width=15%><pre>PSxxxx</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>7131</pre>
</td>
<td width=16%><pre>N914008</pre>
</td>
<td width=33%><pre>Jul 27 1995 12:00AM</pre>
</td>
<td width=8%><pre>20</pre>
</td>
<td width=15%><pre>Net 30</pre>
</td>
<td width=15%><pre>PSyyyy</pre>
</td>
</tr>
</table><br>
<pre></pre>
<p>
Next insert data from <i>newsale</i> into <i>sales</i>. The statement looks like this:</p>
<pre>INSERT sales
SELECT * FROM newsale</pre>
<p>
The<i> title_id</i>s PSxxxx and PSyyyy do not match any in the <i>titles</i> table, and the <b>conditionalinsert</b> trigger deletes these two rows from the <i>sales</i> and <i>inserted</i> tables.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
