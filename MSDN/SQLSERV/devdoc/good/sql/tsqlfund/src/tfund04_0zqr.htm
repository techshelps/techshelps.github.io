<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Outer Joins</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_outer_joins"></a>Outer Joins</h3>
<p>
In the joins discussed so far, only matching rows (rows with values in the specified columns that satisfy the join condition) are included in the results. In a sense, these join operations eliminate the information contained in the rows that do not match.</p>
<p>
However, it is sometimes desirable to retain the nonmatching information by including nonmatching rows in the results of a join. To do this, you can use an <i>outer join</i>. Transact-SQL provides two outer join operators: *=, which includes all rows from the first-named table, and =*, which includes all rows from the second-named table.</p>
<p>
Consider a join of the <i>authors</i> table and the <i>publishers</i> table on their <i>city</i> columns. The results show only the authors who live in cities where a publisher is located (in this case, Abraham Bennet and Cheryl Carson).</p>
<p>
To include all authors in the results, regardless of whether a publisher is located in the same city, use an outer join. Here's what the query and results of the outer join look like:</p>
<pre>SELECT au_fname, au_lname, pub_name
FROM authors, publishers
WHERE authors.city *= publishers.city
</pre>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=26%><pre>au_fname</pre>
</td>
<td width=31%><pre>au_lname</pre>
</td>
<td width=43%><pre>pub_name</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>-----------</pre>
</td>
<td width=31%><pre>--------------</pre>
</td>
<td width=43%><pre>--------------------</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Johnson</pre>
</td>
<td width=31%><pre>White</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Marjorie</pre>
</td>
<td width=31%><pre>Green</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Cheryl</pre>
</td>
<td width=31%><pre>Carson</pre>
</td>
<td width=43%><pre>Algodata Infosystems</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Michael</pre>
</td>
<td width=31%><pre>O'Leary</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Dean</pre>
</td>
<td width=31%><pre>Straight</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Meander</pre>
</td>
<td width=31%><pre>Smith</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Abraham</pre>
</td>
<td width=31%><pre>Bennet</pre>
</td>
<td width=43%><pre>Algodata Infosystems</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Ann</pre>
</td>
<td width=31%><pre>Dull</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Burt</pre>
</td>
<td width=31%><pre>Gringlesby</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Charlene</pre>
</td>
<td width=31%><pre>Locksley</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Morningstar</pre>
</td>
<td width=31%><pre>Greene</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Reginald</pre>
</td>
<td width=31%><pre>Blotchet-Halls</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Akiko</pre>
</td>
<td width=31%><pre>Yokomoto</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Innes</pre>
</td>
<td width=31%><pre>del Castillo</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Michel</pre>
</td>
<td width=31%><pre>DeFrance</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Dirk</pre>
</td>
<td width=31%><pre>Stringer</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Stearns</pre>
</td>
<td width=31%><pre>MacFeather</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Livia</pre>
</td>
<td width=31%><pre>Karsen</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Sylvia</pre>
</td>
<td width=31%><pre>Panteley</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Sheryl</pre>
</td>
<td width=31%><pre>Hunter</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Heather</pre>
</td>
<td width=31%><pre>McBadden</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Anne</pre>
</td>
<td width=31%><pre>Ringer</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre>Albert</pre>
</td>
<td width=31%><pre>Ringer</pre>
</td>
<td width=43%><pre>(null)</pre>
</td>
</tr>
<tr valign=top>
<td width=26%><pre></pre>
</td>
<td width=31%><pre></pre>
</td>
<td width=43%><pre></pre>
</td>
</tr>
</table><br>
<pre>(23 row(s) affected)
</pre>
<p>
The *= operator distinguishes the outer join from an ordinary (equijoin) join. It tells SQL Server to include all rows in the <i>authors</i> table in the results, whether or not there is a match on the <i>city</i> column in the <i>publishers</i> table. Notice that in the results, there is no matching data for most of the authors listed, so these rows contain null values in the <i>pub_name</i> column.</p>
<p>
<b>Note</b>  Because <i>bit</i> columns do not permit null values, a value of 0 appears in an outer join when there is no match for a <i>bit</i> column in the inner table.</p>
<p>
The other outer join operator, =*, indicates that all rows in the second table are to be included in the results, regardless of whether there is matching data in the first table:</p>
<pre>SELECT au_fname, au_lname, pub_name
FROM authors, publishers
WHERE authors.city =* publishers.city
</pre>
<p>
An outer join can be further restricted by comparing it to a constant. This means that you can zoom in on precisely the value or values you want to see, and use the outer join to list the rows that didn't make the cut. For example, to find out which title has sold more than 50 copies, use this query:</p>
<pre>SELECT stor_id, qty, title
FROM sales, titles
WHERE qty &gt; 50
    AND sales.title_id = titles.title_id
</pre>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=25%><pre>stor_id</pre>
</td>
<td width=75%><pre>title</pre>
</td>
</tr>
<tr valign=top>
<td width=25%><pre>-------</pre>
</td>
<td width=75%><pre>--------------------</pre>
</td>
</tr>
<tr valign=top>
<td width=25%><pre>7066</pre>
</td>
<td width=75%><pre>Is Anger the Enemy?</pre>
</td>
</tr>
<tr valign=top>
<td width=25%><pre></pre>
</td>
<td width=75%><pre></pre>
</td>
</tr>
</table><br>
<pre>(1 row(s) affected)
</pre>
<p>
To also show the titles that didn't sell more than 50 copies in any one store, use an outer join:</p>
<pre>SELECT stor_id, qty, title
FROM sales, titles
WHERE qty &gt; 50
    AND sales.title_id =* titles.title_id
</pre>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=13%><pre>stor_id</pre>
</td>
<td colspan=2 width=87%><pre>title</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>------- </pre>
</td>
<td colspan=2 width=87%><pre>-----------------------------------------------------------</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>The Busy Executive's Database Guide</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Cooking with Computers: Surreptitious Balance Sheets</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>You Can Combat Computer Stress!</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Straight Talk About Computers</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Silicon Valley Gastronomic Treats</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>The Gourmet Microwave</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>The Psychology of Computer Cooking</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>But Is It User Friendly?</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Secrets of Silicon Valley</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Net Etiquette</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Computer Phobic and Non-Phobic Individuals: Behavior 
Variations</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>7066</pre>
</td>
<td colspan=2 width=87%><pre>Is Anger the Enemy?</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Life Without Fear</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Prolonged Data Deprivation: Four Case Studies</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Emotional Security: A New Algorithm</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Onions, Leeks, and Garlic: Cooking Secrets of the 
Mediterranean</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Fifty Years in Buckingham Palace Kitchens</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre>(null)</pre>
</td>
<td colspan=2 width=87%><pre>Sushi, Anyone?</pre>
</td>
</tr>
<tr valign=top>
<td width=13%><pre></pre>
</td>
</tr>
<tr valign=top>
<td colspan=2 width=43%><pre>(18 row(s) affected)</pre>
</td>
</tr>
</table><br>
<pre></pre>

<h4><a name="_outer_join_restrictions"></a>Outer Join Restrictions</h4>
<p>
Transact-SQL does not allow both nested outer joins and inner joins nested within an outer join. A table can, however, participate in an inner join and be the outer table in an outer join, as illustrated in this example:</p>
<pre>SELECT royaltyper, au_lname, pub_name
FROM titleauthor, authors, publishers
WHERE titleauthor.au_id = authors.au_id
    AND authors.city *= publishers.city
</pre>
<p>
The following shorthand can also be used to express the above example:</p>
<pre>titleauthor = authors *= publishers
</pre>
<p>
Generalizing and removing table names, this becomes:</p>
<pre>T1 = T2 *= T3
</pre>
<p>
Using this notation, the following illustration shows both legal and illegal combinations of inner and outer joins.</p>
<p>
<img src="images/tblart.gif" border=0></p>
<p>
The following example is not valid because <i>publishers</i> cannot be the inner table in an outer join and still participate in an inner join:</p>
<pre>SELECT title, au_lname, pub_name
FROM authors, publishers, titles
WHERE authors.city *= publishers.city
    AND publishers.pub_id = titles.pub_id
</pre>
<p>
The qualification in the query does not restrict the number of rows returned; instead, it affects which rows contain null values. For rows that do not meet the qualification, NULL appears in the inner table's columns of those rows.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
