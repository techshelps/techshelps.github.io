<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Defining Keys</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_defining_keys"></a>Defining Keys</h2>
<p>
Defining primary keys, foreign keys, and "candidate" keys are an important part of normalization. </p>
<p>
These are some of the characteristics of a normalized database:
<ul>
<li>
The columns of a table depend on the primary key of the table.</li>
<li>
A foreign key of a table is related to the primary or "candidate" key of another table.</li>
<li>
The rows in related tables are retrieved using relational joins.</li>
</ul>
<p>
For tables that will be regularly joined, it is recommended that the columns used to specify the join have the same base datatype, not including nullability or length. For example, these datatypes are considered to be the same base datatype:
<ul>
<li>
<i>char</i>(10) and <i>char</i>(20) <i>null</i> and <i>varchar</i>(30)</li>
<li>
<i>int</i> and <i>int null</i></li>
</ul>
<p>
These datatypes are considered to be different base datatypes:
<ul>
<li>
<i>int</i> and <i>smallint</i> and <i>tinyint</i></li>
<li>
<i>char</i>(10) and <i>int</i></li>
</ul>
<p>
Note that when defining a FOREIGN KEY constraint using the REFERENCES clause of a CREATE TABLE or ALTER TABLE statement, SQL Server requires that the number of columns and the datatypes of each column in the table exactly match the columns listed in the REFERENCES clause.</p>
<p>
For two columns of the same base datatype used to specify a join, the SQL Server optimizer can use any indexes defined on the columns to speed up the join. For example, given the following query using the <i>pubs</i> database:</p>
<pre>SELECT * FROM sales, titles
WHERE sales.title_id = titles.title_id</pre>
<p>
it would be best to define the <i>title_id</i> column in both the <i>sales</i> and <i>titles</i> tables as the same base datatype, and to have indexes on one or both <i>title_id</i> columns.</p>
<p>
SQL Server automatically creates an index for a PRIMARY KEY or UNIQUE constraint. Consider creating an index manually (using the CREATE INDEX statement) for a FOREIGN KEY constraint.</p>
<p>
Note that because each referenced table requires some overhead, you should avoid creating redundant or overlapping FOREIGN KEY constraints. If an existing FOREIGN KEY constraint references <i>table1</i>..<i>id_column</i>:
<ul>
<li>
Another FOREIGN KEY constraint that includes a reference to <i>table1</i>..<i>id_column </i>is usually overlapping.</li>
<li>
Another FOREIGN KEY constraint that includes a reference to <i>table2</i>..<i>id_column </i>is usually redundant.</li>
</ul>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
