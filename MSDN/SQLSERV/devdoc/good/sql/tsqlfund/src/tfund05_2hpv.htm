<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Useful Indexes</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_creating_useful_indexes"></a>Creating Useful Indexes</h2>
<p>
The usefulness of an index depends on the selectivity of the data for a query. Selectivity is an estimate of the percentage of the rows in a table that are returned for a query. The SQL Server optimizer uses the distribution page statistics to evaluate available indexes, estimate the number of page I/Os required, and chooses the method that will result in the fewest number of logical page I/Os.</p>
<p>
Examine the WHERE clause of your queries, since that is the primary focus of the optimizer. Each column included in the WHERE clause is a possible candidate for an index. For optimal performance, consider the following useful indexes for a given <i>column1</i> in the WHERE clause:
<ul>
<li>
A single-column index on <i>column1</i></li>
<li>
A multicolumn index, where <i>column1</i> is the first column of the index</li>
</ul>
<p>
Avoid defining a multicolumn index where <i>column1</i> is the second or later column in the index. This would not be a useful index.</p>
<p>
For example, given the following query using the <i>pubs</i> database:</p>
<pre>SELECT au_id, au_lname, au_fname FROM authors
WHERE au_lname = 'White'</pre>
<p>
an index on the following columns could be useful to the optimizer:
<ul>
<li>
<i>au_lname</i></li>
<li>
<i>au_lname</i>, <i>au_fname</i></li>
</ul>
<p>
but an index on these columns would not be useful to the optimizer:
<ul>
<li>
<i>au_address</i></li>
<li>
<i>au_fname</i>, <i>au_lname</i></li>
</ul>
<p>
Consider using narrow indexes with one or two columns. Narrow indexes are often more effective than multicolumn, compound indexes. Narrow indexes have more rows per page and fewer index levels, boosting performance. The optimizer can rapidly and effectively analyze hundreds, or even thousands, of index and join possibilities. Having a greater number of narrow indexes provides the optimizer with more possibilities to choose from, which usually helps performance. Having a lesser number of wide, multicolumn indexes provides the optimizer with fewer possibilities to choose from, which may hurt performance.</p>
<p>
For multicolumn indexes, SQL Server maintains density statistics (used for joins) on all columns of the index and histogram statistics on the first column of the index. Note that if the first column of a compound index has poor selectivity, the optimizer may not use the index for some queries.</p>
<p>
Useful indexes can improve the performance of SELECT statements, as well as INSERT, UPDATE, and DELETE statements. However, because changes to a table might affect the indexes on that table, each indexes can slow down INSERT, UPDATE, and DELETE performance to some degree. Experiment with a new index and examine its effect on performance. Avoid a large number of indexes on a single table, and avoid overlapping indexes that contain shared columns.</p>
<p>
Examine the number of unique data values in a column and compare it to the number of rows in the table. This is the selectivity of that column, which can help you decide if a column is a candidate for an index and, if so, what type of index.</p>
<p>
You can use the following query to return the number of unique values for a column:</p>
<p>
<b>SELECT COUNT (DISTINCT </b><i>column_name</i><b>) FROM </b><i>table_name</i></p>
<p>
This table shows some example return values and the type of index you might consider putting on <i>column_name</i> for a 10,000-row <i>table_name</i>:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=25%></th>
<th align=left width=75%></th>
</tr>
<tr valign=top>
<th align=left width=25%></th>
<th align=left width=75%></th>
</tr>
<tr valign=top>
<th align=left width=25%>Unique values</th>
<th align=left width=75%>Index</th>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=75%></td>
</tr>
<tr valign=top>
<td width=25%>5000</td>
<td width=75%>Nonclustered index</td>
</tr>
<tr valign=top>
<td width=25%>20</td>
<td width=75%>Clustered index</td>
</tr>
<tr valign=top>
<td width=25%>3</td>
<td width=75%>No index</td>
</tr>
</table><br>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
