<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Connecting to a Remote Database</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_connecting_to_a_remote_database"></a>Connecting to a Remote Database</h2>
<p>
This example shows one method of connecting to a remote database, as used by the gateway sample application. Since the connection is to a SQL Server database, DB-Library structures and function calls are used to establish the connection and to communicate with the remote database.
<ol>
<li>
Declare a structure to hold connection information for accessing a remote database. This structure is passed to Open Data Services event handlers in the SRV_PROC structure:<pre><code>{
    LOGINREC * login     // Pointer to a LOGINREC structure   
    DBPROCESS * dbproc;  // Pointer to a DBPROCESS structure  
} REMOTE_DBMS
</code></pre>
<p>
where
<dl>
<dt>
<i>login</i></dt>
<dd>
Is a pointer to a LOGINREC structure. This structure is defined by the client and contains login and connection information to connect a client to a server.</dd>
<dt>
<i>dbproc</i></dt>
<dd>
Is a pointer to a DBPROCESS structure. This structure is defined by Open Data Services and contains information to manage communications between the client and the server.</dd>
</dl>
</li>
<li>
Add the <b>init_remote</b> function to the gateway callback program, GATECBS.C:<pre><code>int init_remote (srvproc)
SRV_PROC * srvproc;
</code></pre>
</li>
<li>
Allocate a REMOTE_DBMS information structure, which holds the private data space associated with a remote database connection:<pre><code>// Private data area to keep track of remote database connection. 

REMOTE_DBMS * remote;
remote = (REMOTE_DBMS *) srv_alloc ((DBINT)sizeof(*remote));
</code></pre>
</li>
<li>
Use the DB-Library call <b>dblogin</b> to allocate and return a pointer to a LOGINREC structure, which is used to make the connection to the remote server. Put the pointer to LOGINREC in remote-&gt;login:<pre><code>// Now we'll allocate our LOGINREC structure that     
// we'll use to make connections to the               
// remote server. We'll actually open the connection  
// in the SRV_CONNECT handler.                        

remote-&gt;login = dblogin();
</code></pre>
</li>
<li>
Use the ODS Library <b>srv_pfield</b> function to copy the user name, password, application name, and language defined in the client's SRV_PROC structure to remote-&gt;login:<pre><code>// Set the user name, password, application name for the   
// remote database.                                        

DBSETLUSER (remote-&gt;login, srv_pfield(srvproc, SRV_USER, (int *)
NULL));

DBSETLPWD (remote-&gt;login, srv_pfield(srvproc, SRV_PWD, (int *)
NULL));

DBSETLAPP (remote-&gt;login, srv_pfield(srvproc, SRV_APPLNAME, (int *)
NULL));

DBSETLNATLANG(remote-&gt;login, srv_pfield(srvproc, SRV_NATLANG, 
    (int *) NULL));
</code></pre>
</li>
<li>
Use the DB-Library <b>dbopen</b> function with the parameters in remote-&gt;login and the server name to connect to the host:<pre><code>// Try to open a connection to the remote database.         

if ((remote-&gt;dbproc = dbopen(remote-&gt;login, remote_server))
== (DBPROCESS *) NULL)
{

//  Send a message to the Open Data Services client if the remote 
//  connection cannot be made.                                    

srv_sendmsg    (srvproc,
               SRV_MSG_ERROR,
               (DBINT)REMOTE_FAIL,
               (DBTINYINT)0,
               (DBTINYINT)0,
               NULL,
               0,
               0,
               "Login to remote DBMS failed.",
               SRV_NULLTERM);

//  Deallocate remote structure and set the user data pointer in  
//  the SRV_PROC connection structure to NULL so that the         
//  disconnect handler won't try to disconnect from the remote    
//  database.                                                     
srv_free (remote);
srv_setuserdata (srvproc, (BYTE *) NULL);
</code></pre>
</li>
<li>
After the connection is made, save the remote data structure in the SRV_PROC connection structure so that it will be available to the other handlers using <b>srv_setuserdata</b> and <b>dbsetuserdata</b>, and return the SRV_CONTINUE constant:<pre><code>// Connection to the remote database is successful. Save remote    
// data structure in the SRV_PROC connection structure so that it  
// will be available to the other handlers. Map the remote         
// database connection to the SRV_PROC connection structure.       

srv_setuserdata(srvproc, (VOID *)remote);
dbsetuserdata(remote-&gt;dbproc, (VOID *)srvproc);
</code></pre>
</li>
</ol>
<p>
</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
