<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Database Developer's Companion Errata</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_database_developer.92.s_companion_errata"></a><i>Database Developer's Companion </i>Errata</h2>
<p>
The following changes should be made to the <i>Microsoft SQL Server Database Developer's Companion</i> for Microsoft SQL Server 6.0.
<ul>
<li>
On page 47, the example for deleting records with the DELETE statement should be:<pre>DELETE titles
FROM authors, titles, titleauthor
WHERE titles.title_id = titleauthor.title_id
AND authors.au_id = titleauthor.au_id
AND city = 'Oakland'
<b><i>  </i></b></pre>
</li>
<li>
On page 58, the SELECT statement example before the "Choosing Specific Columns" topic should be:<pre>SELECT pub_id, pub_name, city, state, country
FROM publishers</pre>
</li>
<li>
On page 66, in the "Datatype Precedence in Mixed-mode Arithmetic" section, the sentence that begins with "The only execption" should be:<p>
The only exeception to this rule is when converting <i>money </i>and other number datatypes such as <i>float</i>, <i>real</i>, <i>decimal</i>, and <i>numeric</i>; <i>money </i>takes precedence, even though its type is lower, except when using <i>float </i>where the result is <i>float</i>.
</li>
<li>
On page 72, the "Note" about WHERE conditions should be:<p>
<b>Note</b>  The only WHERE conditions that you can use on <i>text</i> columns with certain functions such as <b>patindex()</b> are IS NULL, IS NOT NULL, LIKE, and NOT LIKE.
</li>
<li>
On page 72, in the WHERE clause of the SELECT statement, the list of <i>search_condition</i> should be:</li>
<li>
Comparison Operators (such as =, &lt;&gt;, &lt;, and &gt;)</li>
<li>
All records (=ALL, &gt;ALL)<pre>SELECT au_lname, au_fname, zip FROM authors where zip = all
(SELECT zip FROM authors WHERE zip = '94609')
<b><i>  </i></b>
SELECT  t1.title, t1.advance
FROM  titles t1
WHERE t1.advance &gt; ALL
(SELECT ISNULL(t2.advance,$0.0)
FROM publishers p2, titles t2
WHERE t2.pub_id = p2.pub_id
AND p2.pub_name = 'Algodata Infosystems')
<b><i>  </i></b></pre>
</li>
<li>
Ranges (BETWEEN and NOT BETWEEN)</li>
<li>
Lists (IN, NOT IN)</li>
<li>
Pattern Matches (LIKE and NOT LIKE)</li>
<li>
Unknown values (IS NULL and IS NOT NULL)</li>
<li>
Combinations of these conditions (AND, OR)</li>
<li>
On page 78, the IS NOT NULL clause supports Wildcards and the LIKE clause. For example, the following query retrieves telephone numbers from the <i>authors</i> table where the telephone number begins with 415 and IS NOT NULL:<pre>SELECT phone
FROM authors
WHERE phone LIKE '415%' and phone IS NOT NULL
<b><i>  </i></b></pre>
</li>
<li>
On page 175, the sentence that begins "Narrow indexes are often more effective" should be:<p>
Narrow indexes are often more effective than multicolumn, composite indexes.
</li>
<li>
On page 175, the sentence that begins "Note that if the first column" should be:<p>
Note that if the first column of a composite index has poor selectivity, the optimizer may not use the index for some queries.
</li>
<li>
On page 184, add the following text to the "Analyzing Locks" topic:<p>
Intent locks are used to let high-level lock granules such as table locks know about the intentions of those, such as page locks, placing locks at lower levels in the lock hierarchy.
<p>
Two transactions A and B execute concurrently. Transaction A uses page locking, acquires page locks, and does not encounter any lock conflicts. Transaction B protects its activity in the same table with a table lock and requests the table lock without lock conflict because Transaction A is placing locks on pages and Transaction B is placing a lock on the entire table object. Because both transactions believe they have exclusive access to the table, incorrect behavior results. To prevent problems, Transaction A, which locks at the page level, acquires an <i>intent</i> lock on the table. Transaction A's table intent lock is incompatible with transaction B's table lock request.
<p>
<b>Note</b>  There are different types of intent locks: Intent Share (IS), Intent Exclusive (IX), and Share with Intent Exclusive (SIX).
<p>
Update locks prevent a common form of deadlock. A typical update pattern consists of a transaction reading a record, acquiring a share mode lock (S) on the resource (page or row), and then modifying the row, which requires lock conversion to an exclusive lock (X). Share mode locks are compatible with other share mode locks, so if the two transactions acquire share mode locks on a resource and then attempt to update data concurrently, both transactions will get the share mode lock and one transaction attempts the lock conversion to an exclusive lock. The share mode to exclusive lock conversion must wait since the exclusive lock for the one transaction is not compatible with the other transaction's share mode lock. A lock wait occurs. The second transaction involved attempts to acquire an exclusive lock for its update. Because both transactions converting to exclusive locks are waiting for the other transaction to release their share mode lock, a deadlock occurs.
<p>
To resolve the deadlock problem, update locks are used. Because an update lock in one transaction is not compatible with an update lock in another transaction, only one transaction can obtain an update lock to a resource at a time. If a transaction modifies a resource, the update lock is converted to an exclusive lock. Otherwise, the lock is converted to a share mode lock.
</li>
<li>
On page 203, under Stored Procedure Rules, the sixth bullet should be:<ul>
<li>
If you execute a procedure that calls another procedure, the called procedure can access all objects created by the first procedure, including temporary tables.</li>
</ul>
</li>
</ul>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
