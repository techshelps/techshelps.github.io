<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DECLARE CURSOR Statement</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_declare_cursor_statement"></a>DECLARE CURSOR Statement (version 6.5)</h2>
<p>
Allows individual row operations to be performed on a given results set. There are several cursor improvements in SQL Server 6.5: 
<ul>
<li>
Dynamic cursors allow updates on underlying tables without requiring a unique index on the table.</li>
<li>
Forward-only cursors are significantly faster on large tables.</li>
<li>
Cursors automatically close upon COMMIT when SET CURSOR_CLOSE_ON_COMMIT option is set to ON. </li>
<li>
Forward-only cursors are dynamic by default, which allows faster cursor opening and also allows the results set to display updates made to the underlying tables.</li>
<li>
The results sets from read-only dynamic cursors no longer use temporary tables in <i>tempdb</i>.</li>
</ul>
<p>
DECLARE CURSOR cannot be used on a table that was created in the same batch or stored procedure.  </p>
<p>
If you need to use these statements in the same batch or stored procedure, you must put the DECLARE CURSOR statement inside a dynamic EXECUTE. Using a dynamic EXECUTE enables the cursor to benefit from any indexes on the temporary table, which allows a sensitive scrollable cursor. </p>
<p>
An exception to this is when the created table is a temporary table (indicated by a leading number sign (#)). You can create a temporary table and declare a cursor on it in the same batch or stored procedure. However, the cursor will not recognize any of the table's indexes. Scroll cursors and any cursor with an ORDER BY statement will be created as INSENSITIVE and READ ONLY. Forward-only cursors (those that do not require an interim work table) will be dynamic and can be updated. </p>
<p>
<b>Note</b>  If the definition of the forward-only cursor contains interim work tables for outer joins or aggregate functions,<i> </i>then the forward-only cursor does not default to a dynamic cursor.</p>
<h4>Example</h4>
<p>
This example illustrates the dynamic behavior of a forward-only cursor. There are two processes: User One declares and opens a cursor, then User Two makes a change to the underlying table, which affects the first row of the cursor. Finally, the update is displayed when User One fetches the first row.  </p>
<p>
These are the connections that illustrate the dynamic behavior of a forward-only cursor.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<th align=left width=52%></th>
<th align=left width=48%></th>
</tr>
<tr valign=top>
<th align=left width=52%></th>
<th align=left width=48%></th>
</tr>
<tr valign=top>
<th align=left width=52%>User One</th>
<th align=left width=48%>User Two</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=52%><pre>DECLARE forwardcursor CURSOR FOR
SELECT au_lname FROM authors
OPEN forwardcursor</pre>
</td>
<td width=48%><pre></pre>
</td>
</tr>
<tr valign=top>
<td width=52%><pre></pre>
</td>
<td width=48%><pre>UPDATE authors 
SET au_lname = 'Whittacker'
WHERE au_lname = 'White'</pre>
</td>
</tr>
<tr valign=top>
<td width=52%><pre>FETCH NEXT FROM forwardcursor</pre>
</td>
<td width=48%><pre></pre>
</td>
</tr>
</table><br>
<p>
This is the results set for User One: </p>
<pre>--------------------------------
au_lname
--------------------------------
Whittacker

(1 row(s) affected)
<b><i>  </i></b></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
