<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SELECT Statement</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_select_statement_addnfeat"></a>SELECT Statement (version 6.5)</h2>
<p>
Provides the WITH CUBE and WITH ROLLUP options as part of the GROUP BY clause. These operators produce an <i>n</i>-dimensional results set rather than the typical zero or one-dimensional results set. </p>
<p>
In SQL Server 6.5, the LIKE operator will search on strings that contain wildcard characters by using an ESCAPE option. </p>
<p>
For additional syntax information for <a href="../../../tsqlref/src/tsql12_654k.htm">SELECT statement</a>, see the <i>Microsoft SQL Server Transact-SQL Reference</i>. </p>
<h4>Syntax</h4>
<p>
SELECT [ALL | DISTINCT] <i>select_list</i><br>
&nbsp;&nbsp;&nbsp;&nbsp;INTO [<i>new_table_name</i>]<br>
[FROM <i>table_name</i> [<b>, </b><i>table_name2</i> […<b>,</b> <i>table_name16</i>]]<br>
[WHERE <i>clause</i>]<br>
[GROUP BY <i>clause</i>]<br>
[HAVING <i>clause</i>]<br>
[ORDER BY <i>clause</i>]<br>
[COMPUTE <i>clause</i>]<br>
[FOR BROWSE]]</p>
<p>
where 
<dl>
<dt>
ALL</dt>
<dd>
Specifies that duplicate rows can appear in the results set.</dd>
<dt>
DISTINCT</dt>
<dd>
Specifies that only unique rows can appear in the results set. Null values are considered equal for the purposes of the DISTINCT keyword; only one NULL is selected no matter how many are encountered.</dd>
<dt>
<i>select_list</i></dt>
<dd>
Is the list of columns to select and can be one or more of the following.
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=44%></th>
<th align=left width=56%></th>
</tr>
<tr valign=top>
<th align=left width=44%></th>
<th align=left width=56%></th>
</tr>
<tr valign=top>
<th align=left width=44%>Column</th>
<th align=left width=56%>Description</th>
</tr>
<tr valign=top>
<td width=44%>Asterisk (*)</td>
<td width=56%>Represents all columns in the order in which they were specified in the CREATE TABLE statement. Affects all tables in the FROM clause.</td>
</tr>
<tr valign=top>
<td width=44%>A list of column names</td>
<td width=56%>Specifies the order in which you want to see column names. If the <i>select_list</i> contains multiple column names, separate the names with commas.</td>
</tr>
<tr valign=top>
<td width=44%>A column name and column heading</td>
<td width=56%>Specifies a heading to replace the default column heading (the column name), in the following form:<p>
<i>column_heading</i><b> =</b> <i>column_name</i></p>
<p>
Or</p>
<p>
<i>column_name</i> <i>column_heading</i></p>
<p>
Or</p>
<p>
<i>column_name</i> AS <i>column_heading</i></p>
</td>
</tr>
<tr valign=top>
<td width=44%>An expression </td>
<td width=56%>Specifies a column name, constant, function, or any combination of column names, constants, and functions connected by an operator(s), or a subquery.<p>
The expression can be used to set up an identity column by using the IDENTITY() function with SELECT INTO. For example, ID = IDENTITY(int,1,1).</p>
</td>
</tr>
<tr valign=top>
<td width=44%>IDENTITYCOL keyword </td>
<td width=56%>Specifies the IDENTITYCOL keyword instead of the name of a column that has the IDENTITY property.</td>
</tr>
<tr valign=top>
<td width=44%>Local or global variable</td>
<td width=56%>Specifies a local or global variable.</td>
</tr>
<tr valign=top>
<td width=44%>Local variable assignment </td>
<td width=56%>Specifies a local variable assignment in the form:<p>
<b>@</b>variable <b>=</b> expression</p>
</td>
</tr>
</table><br>

</dd>
<dt>
INTO <i>new_table_name</i></dt>
<dd>
Is the name of a new table to be created based on the columns specified in the <i>select_list</i> and the rows chosen in the WHERE clause.</dd>
<dt>
FROM</dt>
<dd>
Specifies the table(s) and view(s) used in the SELECT statement. </dd>
<dt>
<i>table_name</i> = </dt>
<dd>
{<i>simple_table_name</i> | <i>derived_table</i> | <i>joined_table</i>}</dd>
</dl>
<p>
&nbsp;&nbsp;&nbsp;&nbsp;where 
<dl>
<dt>
<i>simple_table_name </i>= <br>
[[<i>database</i><b>.</b>] <i>owner</i><b>.</b>]<i> </i>{<i>table_name</i> | <i>view_name</i>} [[AS] <i>alias_name</i>] <br>
[(<i>optimizer_hints</i>)]</dt>
<dd>
Specifies the name of the table or view used in the SELECT statement.
<p>
where
</dd>
<dt>
<i>table_name</i> | <i>view_name</i></dt>
<dd>
Is the name(s) of the table(s) and view(s) used in the SELECT statement. If the list contains more than one table or view, separate the names with commas. If the table(s) or view(s) exist in another database(s), use a fully qualified table or view name, such as <i>database</i><b>.</b><i>owner</i><b>.</b><i>object_name</i>.
<p>
In SQL Server 6.5, errors are reported when redundant table names appear in the FROM clause. For example, these SELECT statements were supported in earlier releases but generate errors in SQL Server 6.5. In the first SELECT statement the tables were treated as two different tables. In the second SELECT statement the second <i>authors</i> reference is discarded. 

<pre>SELECT * FROM pubs..authors,pubs.dbo.authors

SELECT * FROM authors,authors
</pre>

<p>
To avoid generating these errors, use trace flag 110. This flag causes SQL Server to revert to the table resolution methods of earlier releases. For more information about trace flag 110, see <a href="addnfeat_76t0.htm">Trace Flags</a>.
</dd>
<dt>
<i>alias_name</i></dt>
<dd>
Is the name of an alias. Each <i>table_name</i> or <i>view_name</i> can be given an alias, either for convenience or to distinguish a table or view in a self-join or subquery.</dd>
<dt>
<i>optimizer_hints</i></dt>
<dd>
Specify a locking method, an index, or no index (table scan) be used by the optimizer with this table and for this SELECT. Although this is an option, the optimizer can usually pick the best optimization method without hints being specified.</dd>
<dt>
<i>derived_table</i> = <br>
(<i>select_statement</i>) [AS] <i>alias_name</i></dt>
<dd>
Is a subquery as specified in <i>select_statement</i> and uses the results set of the subquery as the input to the query being executed.
<p>
where
</dd>
<dt>
<i>select_statement</i></dt>
<dd>
Is the statement that retrieves rows from the database.</dd>
<dt>
<i>joined_table</i> = <br>
{<i>table_name</i> CROSS JOIN <i>table_name</i> <br>
| <i>table_name</i> [<i>join_type</i>] JOIN <i>table_name</i> ON <i>search_conditions</i>}</dt>
<dd>
Is the results set that is the product of two or more tables being combined.</dd>
<dt>
<i>join_type</i> = <br>
{INNER | LEFT [OUTER] | RIGHT [OUTER] | FULL [OUTER]}</dt>
<dd>
</dd>
</dl>
<p>
The following types of ANSI joins are permitted: 
<dl>
<dt>
CROSS JOIN</dt>
<dd>
Is the cross product of two tables. Returns the same rows as if no WHERE clause was specified in an old-style join.</dd>
<dt>
INNER</dt>
<dd>
Specifies that all inner rows be returned. Discards unmatched rows.</dd>
<dt>
LEFT [OUTER]</dt>
<dd>
Specifies that all left outer rows be returned. Specifies that all rows from the left table that did not meet the condition specified be included in the results set, and output columns from the other table be set to NULL.</dd>
<dt>
RIGHT [OUTER]</dt>
<dd>
Specifies that all rows from the right table that did not meet the condition specified will be included in the results set, and output columns that correspond to the other table be set to NULL.</dd>
<dt>
FULL [OUTER]</dt>
<dd>
If a row from either table does not match the selection criteria, specifies the row be included in the results set and its output columns that correspond to the other table be set to NULL.
</dd>
</dl>
<p>
Earlier versions of SQL Server outer joins are supported in the following examples:</p>
<h5>&nbsp;&nbsp;&nbsp;&nbsp;Right Outer Join (*=)</h5>
<pre>Select authors.au_name, titleauthor.title_id
FROM authors.titleauthor
WHERE authors.au_id *=titleauthor.au_id
</pre>
<h5>&nbsp;&nbsp;&nbsp;&nbsp;Left Outer Join (=*)</h5>
<pre>SELECT authors.au_lname, titleauthor.title_id
FROM authors, titleauthor
WHERE titleauthor.au_id =* authors.au_id
</pre>
<p>
<b>Note</b>  Earlier versions of SQL Server joins cannot be used within the same statement as ANSI-style joins.</p>
<dl>
<dt>
WHERE <i>clause</i> =</dt>
<dd>
WHERE <i>search_conditions</i>
<p>
Specifies the conditions for the rows returned in the results set. There is no limit to the number of <i>search_conditions</i> that can be included in an SQL statement.

<p>
The LIKE operator has an ESCAPE option, which allows wildcard characters to be searched for in strings.

<p>
Consider the column <i>description</i> in a table, <i>finances</i> contains the value <b>'</b>lending_rate%<b>'</b>. 

<p>
The characters <b>'%'</b> and <b>'_'</b> are wildcard characters. If you want to search for rows where the column contains the sequence <b>'</b>g<b>_'</b>, you need to use the ESCAPE option because <b>'_'</b> is a wildcard character.

<pre>SELECT * FROM finances 
WHERE description LIKE 'gS_' ESCAPE 'S'
</pre>

<p>
The ESCAPE clause uses "S" as an escape character and if the search comes across "S" in the pattern string, it will take the next character "_" as a normal character rather than a wildcard character. 
</dd>
<dt>
GROUP BY <i>clause</i> =<br>
GROUP BY [ALL] <i>aggregate_free_expression</i><br>
[<b>,</b> <i>aggregate_free_expression</i>]...[<b>,</b> <i>aggregate_free_expression</i>] <br>
[WITH {CUBE | ROLLUP}]</dt>
<dd>
Specifies the groups into which the table will be partitioned and, if aggregate functions are included in the <i>select_list</i>, finds a summary value for each group.
<p>
The maximum number of bytes allowed in the GROUP BY clause is 900. 

<p>
When the CUBE operator is specified, in addition to the usual aggregate rows, <i>super-aggregate</i> rows are introduced into the results set. A super-aggregate row is a summary row for all of the aggregate rows produced for one of the aggregate-free expressions in the GROUP BY clause.

<p>
For example, if your query was computing the average price of an automobile, grouped by manufacturer, a single super-aggregate row would be added that contained the average price of all cars. Suppose your query was grouped instead by manufacturer and color. The results set would then contain super-aggregates for each manufacturer, regardless of color, and separate super-aggregates for each color, regardless of manufacturer.

<p>
If the WITH ROLLUP clause is specified, a subset of super-aggregates is computed along with the usual aggregate rows. This is useful when you have sets within sets. Consider grouping by the expressions, column1, column2, and column3. Applying the ROLLUP operator results in these rows:

<pre>column1        column2        column3
column1        column2        (null)
column1        (null)        (null)
(null)        (null)        (null)
<b><i>  </i></b></pre>

<p>
A maximum of 10 grouping expressions are permitted in a GROUP BY clause when WITH CUBE or WITH ROLLUP is specified. Otherwise, 16 grouping expressions are permitted.

<p>
You cannot specify the GROUP BY ALL clause when you use the CUBE or ROLLUP operators.

<p>
The CUBE and ROLLUP operators can be disabled when trace flag 204 is ON.
</dd>
<dt>
HAVING <i>clause</i> =</dt>
<dd>
HAVING <i>search_conditions</i>
<p>
Specifies the conditions for aggregate functions in the <i>select_list</i>; the <i>search_conditions</i> restrict the rows returned by the query but do not affect the calculations of the aggregate function(s).
</dd>
<dt>
ORDER BY <i>clause</i></dt>
<dd>
Is the sort order used on columns returned. </dd>
<dt>
COMPUTE <i>clause</i> =</dt>
<dd>
COMPUTE <i>row_aggregate</i><b>(</b><i>column_name</i><b>)</b><br>
[<b>,</b><i> row_aggregate</i><b>(</b><i>column_name</i><b>)</b>...]<br>
[BY <i>column_name</i> [<b>,</b> <i>column_name</i>]...]</dd>
</dl>
<p>
where 
<dl>
<dt>
COMPUTE </dt>
<dd>
Specifies that control-break summary changes be generated for row aggregate functions (SUM, AVG, MIN, MAX, and COUNT). </dd>
<dt>
BY </dt>
<dd>
Specifies that the values for row-aggregate functions be calculated for subgroups. </dd>
<dt>
FOR BROWSE</dt>
<dd>
Specifies that updates be allowed while viewing data in client applications that use DB-Library.
</dd>
</dl>
<h4>Remarks</h4>
<p>
<b>Important</b>  When creating a derived table, the SELECT statement does not support the use of the INTO, ORDER BY, COMPUTE, or COMPUTE BY clauses.</p>
<p>
The FROM clause has been changed to support the ANSI-SQL syntax for joined tables and derived tables. ANSI-SQL syntax provides the INNER, LEFT OUTER, RIGHT OUTER, and FULL OUTER join operators.  </p>
<p>
Although the outer join operators <b>*=</b> and <b>=*</b> from earlier versions of SQL Server are supported, you cannot use both outer join operators and ANSI-SQL style joined tables in the same query.  </p>
<p>
When trace flag 204 is enabled, only the SQL Server version 6.0 and earlier SELECT statement syntax is permitted: joined tables, derived tables, and other ANSI features are not. Trace flag 204 is otherwise unchanged. Also, trace flag 330 enables full output that contains information about joins when you are using SHOWPLAN. For more information about trace flags 204 and 330, see <a href="addnfeat_76t0.htm">Trace Flags </a>.  </p>
<p>
UNION and JOIN within a FROM clause are supported within views as well as in derived tables and subqueries.  </p>
<p>
A self-join is a table that joins upon itself. Inserts or updates that are based on a self-join follow the order in the FROM clause. </p>
<p>
<b>Note</b>  In SQL Server version 6.5, an error occurs if no column name is given to a column created by a SELECT INTO or CREATE VIEW statement. For more information, see the discussion of trace flag 246 in <a href="addnfeat_76t0.htm">Trace Flags</a>.</p>
<p>
The CUBE operator provides a superset of data in the results set. Not only is the typical joined data returned, each operand (column) in the GROUP BY clause is bound under the NULL keyword and applied to all other operands (columns). </p>
<p>
The NULL keyword in this case represents all the values in a particular column. </p>
<p>
<b>Note</b>  Using the HAVING clause in the SELECT statement does not effect the way the CUBE operator groups the results set and returns summary aggregate rows.</p>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Use an Aggregate Function in a SELECT Statement</h5>
<p>
This example uses the following table to demonstrate how the CUBE operator affects the results set.</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=28%><pre>product_ID</pre>
</td>
<td width=34%><pre>customer_ID</pre>
</td>
<td width=38%><pre>number_of_orders</pre>
</td>
</tr>
<tr valign=top>
<td width=28%><pre>----------</pre>
</td>
<td width=34%><pre>-----------</pre>
</td>
<td width=38%><pre>----------------</pre>
</td>
</tr>
<tr valign=top>
<td width=28%>10</td>
<td width=34%>a</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>20</td>
<td width=34%>b</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>10</td>
<td width=34%>a</td>
<td width=38%>20</td>
</tr>
<tr valign=top>
<td width=28%>30</td>
<td width=34%>b</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>30</td>
<td width=34%>a</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>20</td>
<td width=34%>b</td>
<td width=38%>20</td>
</tr>
<tr valign=top>
<td width=28%>10</td>
<td width=34%>b</td>
<td width=38%>30</td>
</tr>
<tr valign=top>
<td width=28%>10</td>
<td width=34%>c</td>
<td width=38%>40</td>
</tr>
<tr valign=top>
<td width=28%>20</td>
<td width=34%>c</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>30</td>
<td width=34%>b</td>
<td width=38%>40</td>
</tr>
<tr valign=top>
<td width=28%>30</td>
<td width=34%>a</td>
<td width=38%>10</td>
</tr>
<tr valign=top>
<td width=28%>10</td>
<td width=34%>a</td>
<td width=38%>50</td>
</tr>
</table><br>
<p>
First, issue a typical query with a GROUP BY clause and the results set.</p>
<pre>SELECT product_ID, customer_ID, SUM(number_of_orders)
FROM sales
GROUP BY product_ID, customer_ID
</pre>
<p>
The GROUP BY causes the results set to form groups within groups. This is the results set:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=23%><pre>
product_ID</pre>
</td>
<td width=30%><pre>
customer_ID</pre>
</td>
<td width=47%><pre>Sum 
(number_of_orders)</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>---------</pre>
</td>
<td width=30%><pre>---------</pre>
</td>
<td width=47%><pre>---------------</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>10</pre>
</td>
<td width=30%><pre>a</pre>
</td>
<td width=47%><pre>80</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>10</pre>
</td>
<td width=30%><pre>b</pre>
</td>
<td width=47%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>10</pre>
</td>
<td width=30%><pre>c</pre>
</td>
<td width=47%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>20</pre>
</td>
<td width=30%><pre>b</pre>
</td>
<td width=47%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>20</pre>
</td>
<td width=30%><pre>c</pre>
</td>
<td width=47%><pre>10</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>30</pre>
</td>
<td width=30%><pre>a</pre>
</td>
<td width=47%><pre>20</pre>
</td>
</tr>
<tr valign=top>
<td width=23%><pre>30</pre>
</td>
<td width=30%><pre>b</pre>
</td>
<td width=47%><pre>50</pre>
</td>
</tr>
</table><br>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Use the CUBE Operator</h5>
<p>
Next, do a query with a GROUP BY clause by using the CUBE operator. The results set should include the same information plus super-aggregate information for each of the GROUP BY columns.</p>
<pre>SELECT product_ID, customer_ID, SUM(number_of_orders)
FROM sales
GROUP BY product_ID, customer_ID
WITH CUBE
</pre>
<p>
The results set for the CUBE operator holds the values from the simple GROUP BY result set above and adds the super-aggregates for each column in the GROUP BY clause. (null) represents all values in the set from which the aggregate is computed.</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=24%><pre>
product_ID</pre>
</td>
<td width=31%><pre>
customer_ID</pre>
</td>
<td width=45%><pre>SUM
(number_of_orders)</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>-----------</pre>
</td>
<td width=31%><pre>------------</pre>
</td>
<td width=45%><pre>------------------</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=31%><pre>a</pre>
</td>
<td width=45%><pre>80</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=31%><pre>b</pre>
</td>
<td width=45%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=31%><pre>c</pre>
</td>
<td width=45%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=31%><pre>(null)</pre>
</td>
<td width=45%><pre>150</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=31%><pre>b</pre>
</td>
<td width=45%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=31%><pre>c</pre>
</td>
<td width=45%><pre>10</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=31%><pre>(null)</pre>
</td>
<td width=45%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=31%><pre>a</pre>
</td>
<td width=45%><pre>20</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=31%><pre>b</pre>
</td>
<td width=45%><pre>50</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=31%><pre>(null)</pre>
</td>
<td width=45%><pre>70</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>(null)</pre>
</td>
<td width=31%><pre>(null)</pre>
</td>
<td width=45%><pre>260</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>(null)</pre>
</td>
<td width=31%><pre>a</pre>
</td>
<td width=45%><pre>100</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>(null)</pre>
</td>
<td width=31%><pre>b</pre>
</td>
<td width=45%><pre>110</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>(null)</pre>
</td>
<td width=31%><pre>c</pre>
</td>
<td width=45%><pre>50</pre>
</td>
</tr>
</table><br>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Use the ROLLUP Operator with the COUNT Aggregate</h5>
<p>
This example performs a ROLLUP operation on the company and department columns and totals the number of employees. </p>
<p>
The ROLLUP operator produces a summary of aggregates. This is useful in situations where summary information is needed but a full CUBE provides extraneous data. This is also useful when you have sets within sets. For example, you could think of departments within a company as a set within a set. </p>
<pre>SELECT company, department COUNT(*) FROM personnel GROUP BY company, department WITH ROLLUP
<b><i>  </i></b></pre>
<p>
This is the results set:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=18%><pre>company</pre>
</td>
<td width=34%><pre>department</pre>
</td>
<td width=48%><pre>Number of Employees</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>abc</pre>
</td>
<td width=34%><pre>finance</pre>
</td>
<td width=48%><pre>10</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>abc</pre>
</td>
<td width=34%><pre>engineering</pre>
</td>
<td width=48%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>abc</pre>
</td>
<td width=34%><pre>marketing</pre>
</td>
<td width=48%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>abc</pre>
</td>
<td width=34%><pre>(null)</pre>
</td>
<td width=48%><pre>90</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>def</pre>
</td>
<td width=34%><pre>accounting</pre>
</td>
<td width=48%><pre>20</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>def</pre>
</td>
<td width=34%><pre>personnel</pre>
</td>
<td width=48%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>def</pre>
</td>
<td width=34%><pre>payroll</pre>
</td>
<td width=48%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>def</pre>
</td>
<td width=34%><pre>(null)</pre>
</td>
<td width=48%><pre>90</pre>
</td>
</tr>
<tr valign=top>
<td width=18%><pre>(null)</pre>
</td>
<td width=34%><pre>(null)</pre>
</td>
<td width=48%><pre>180</pre>
</td>
</tr>
</table><br>
<pre></pre>
<h5>D.&nbsp;&nbsp;&nbsp;&nbsp;Use the ROLLUP Operator</h5>
<p>
This example modifies the SELECT statement above to use the ROLLUP operator.</p>
<pre>SELECT product_ID, customer_ID, SUM(number_of_orders) 
AS 'Sum number_of_orders'
FROM sales
GROUP BY product_ID, customer_ID
WITH ROLLUP
</pre>
<p>
This is the results set:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=24%><pre>product_ID</pre>
</td>
<td width=29%><pre>customer_ID</pre>
</td>
<td width=47%><pre>Sum 
number_of_orders</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>----------</pre>
</td>
<td width=29%><pre>-----------</pre>
</td>
<td width=47%><pre>----------------</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=29%><pre>a</pre>
</td>
<td width=47%><pre>80</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=29%><pre>b</pre>
</td>
<td width=47%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=29%><pre>c</pre>
</td>
<td width=47%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>10</pre>
</td>
<td width=29%><pre>(null)</pre>
</td>
<td width=47%><pre>150</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=29%><pre>b</pre>
</td>
<td width=47%><pre>30</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=29%><pre>c</pre>
</td>
<td width=47%><pre>10</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>20</pre>
</td>
<td width=29%><pre>(null)</pre>
</td>
<td width=47%><pre>40</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=29%><pre>a</pre>
</td>
<td width=47%><pre>20</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=29%><pre>b</pre>
</td>
<td width=47%><pre>50</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>30</pre>
</td>
<td width=29%><pre>(null)</pre>
</td>
<td width=47%><pre>70</pre>
</td>
</tr>
<tr valign=top>
<td width=24%><pre>(null)</pre>
</td>
<td width=29%><pre>(null)</pre>
</td>
<td width=47%><pre>260</pre>
</td>
</tr>
</table><br>
<p>
The GROUPING function allows you to discriminate between a true null value and a null value representing an ALL value. </p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=31%></th>
<th align=left width=34%></th>
<th align=left width=35%></th>
</tr>
<tr valign=top>
<th align=left width=31%></th>
<th align=left width=34%></th>
<th align=left width=35%></th>
</tr>
<tr valign=top>
<th align=left width=31%>Expression <br>
evaluation</th>
<th align=left width=34%>GROUPING <br>
returns</th>
<th align=left width=35%><br>
Description</th>
</tr>
<tr valign=top>
<td width=31%>(null)</td>
<td width=34%>1</td>
<td width=35%>Represents the set of all values.</td>
</tr>
<tr valign=top>
<td width=31%>any other value</td>
<td width=34%>0</td>
<td width=35%>Represents a particular value.</td>
</tr>
</table><br>
<p>
A new function GROUPING can be used only with CUBE or ROLLUP. The GROUPING function returns 1 when an expression evaluates to NULL because the column value is (null) and represents the set of all values. The GROUPING function returns 0 when the column has a value other than (null). The returned value has a <i>tinyint </i>datatype. </p>
<h5>E.&nbsp;&nbsp;&nbsp;&nbsp;Use the GROUPING Function</h5>
<p>
This example modifies the SELECT statement that was used in the previous example.</p>
<pre>SELECT product_ID, customer_ID, SUM(number_of_orders) 
AS 'Sum number_of_orders',
GROUPING(product_ID) AS 'Grouping product_ID',GROUPING(customer_ID) AS 'Grouping customer_ID'
FROM sales
GROUP BY product_ID, customer_ID
WITH ROLLUP
<b><i>  </i></b></pre>
<p>
This is the results set:</p>
<table cellspacing=4 cols=5>
<tr valign=top>
<td width=19%><pre>
product_ID</pre>
</td>
<td width=21%><pre>
customer_ID</pre>
</td>
<td width=19%><pre>Sum number
_of_orders</pre>
</td>
<td width=20%><pre>Grouping
product_ID</pre>
</td>
<td width=21%><pre>Grouping
customer_ID</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>----------</pre>
</td>
<td width=21%><pre>-----------</pre>
</td>
<td width=19%><pre>----------</pre>
</td>
<td width=20%><pre>----------</pre>
</td>
<td width=21%><pre>----------</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>10</pre>
</td>
<td width=21%><pre>a</pre>
</td>
<td width=19%><pre>80</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>10</pre>
</td>
<td width=21%><pre>b</pre>
</td>
<td width=19%><pre>30</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>10</pre>
</td>
<td width=21%><pre>c</pre>
</td>
<td width=19%><pre>40</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>10</pre>
</td>
<td width=21%><pre>(null)</pre>
</td>
<td width=19%><pre>150</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>1</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>20</pre>
</td>
<td width=21%><pre>b</pre>
</td>
<td width=19%><pre>30</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>20</pre>
</td>
<td width=21%><pre>c</pre>
</td>
<td width=19%><pre>10</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>20</pre>
</td>
<td width=21%><pre>(null)</pre>
</td>
<td width=19%><pre>40</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>1</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>30</pre>
</td>
<td width=21%><pre>a</pre>
</td>
<td width=19%><pre>20</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>30</pre>
</td>
<td width=21%><pre>b</pre>
</td>
<td width=19%><pre>50</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>0</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>30</pre>
</td>
<td width=21%><pre>(null)</pre>
</td>
<td width=19%><pre>70</pre>
</td>
<td width=20%><pre>0</pre>
</td>
<td width=21%><pre>1</pre>
</td>
</tr>
<tr valign=top>
<td width=19%><pre>(null)</pre>
</td>
<td width=21%><pre>(null)</pre>
</td>
<td width=19%><pre>260</pre>
</td>
<td width=20%><pre>1</pre>
</td>
<td width=21%><pre>1</pre>
</td>
</tr>
</table><br>
<h5>F.&nbsp;&nbsp;&nbsp;&nbsp;Use Left Outer Join</h5>
<p>
This example joins two tables on <i>au_id</i> and preserves the unmatched rows from the left table. The <i>authors </i>table is matched with the <i>titleauthor</i> table on the <i>au_id </i>columns in each table. All authors appear in the results set, whether or not they have published any books.</p>
<pre>SELECT authors.au_lname, authors.au_fname, titleauthor.title_id
FROM authors LEFT OUTER JOIN titleauthor 
ON authors.au_id =titleauthor.au_id
</pre>
<h5>G.&nbsp;&nbsp;&nbsp;&nbsp;Use Inner Join with Three Tables</h5>
<p>
This example joins three tables: <i>authors, titleauthors and titles</i>. The results set contains a list of authors and royalties paid to date.</p>
<pre>SELECT authors.au_fname, authors.au_lname, sum(titles.royalty * titles.ytd_sales/100)
FROM authors 
JOIN titleauthor ON authors.au_id=titleauthor.au_id
JOIN titles ON titleauthor.title_id = titles.title_id
GROUP BY authors.au_lname, authors.au_fname
ORDER BY authors.au_lname
</pre>
<h5>H.&nbsp;&nbsp;&nbsp;&nbsp;Use Full Outer Join</h5>
<p>
This example returns the book title and its corresponding publisher in the <i>titles</i> table. It also returns any publishers who have not published books listed in the <i>titles</i> table, and any book titles with a publisher other than the one listed in the <i>publishers</i> table.</p>
<pre>SELECT titles.title, publishers.pub_name
FROM publishers FULL OUTER JOIN titles
ON titles.pub_id = publishers.pub_id
WHERE titles.pub_id IS NULL OR publishers.pub_id IS NULL
<b><i>  </i></b></pre>
<h5>I.&nbsp;&nbsp;&nbsp;&nbsp;Use Right Outer Join</h5>
<p>
This example joins two tables on <i>pub_id</i> and preserves the unmatched rows from the right table. The <i>publishers</i> table is matched with the <i>titles </i>table on the <i>pub_id</i> column in each table. All publishers appear in the results set, whether or not they have published any books.</p>
<pre>SELECT publishers.pub_id, titles.title, titles.title_id
FROM titles RIGHT OUTER JOIN publishers 
ON publishers.pub_id = titles.pub_id
<b><i>  </i></b></pre>
<h5>J.&nbsp;&nbsp;&nbsp;&nbsp;Use Cross Join</h5>
<p>
This example returns the cross product of the two tables <i>authors</i> and <i>publishers</i>. A list of all possible combinations of <i>au_lname</i> rows and all <i>pub_name</i> rows are returned.</p>
<pre>SELECT au_lname, pub_name 
FROM authors CROSS JOIN publishers
<b><i>  </i></b></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
