<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>sp_coalesce_fragments</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sp_coalesce_fragments"></a>sp_coalesce_fragments (version 6.5)</h2>
<p>
Deletes and updates rows in the <i>sysusages </i>system table and combines <i>sysusage</i> entries where possible.</p>
<h4>Syntax</h4>
<p>
<b>sp_coalesce_fragments</b> [<i>DBNamePattern</i>]</p>
<p>
where
<dl>
<dt>
<i>DBNamePattern</i></dt>
<dd>
Specifies the database name pattern. The name pattern must adhere to the LIKE operator standards for string arguments. The default is <b>'%'</b> (all databases will be affected).
<p>
For more information about the LIKE operator, see <a href="../../../tsqlref/src/tsql30_6far.htm">Wildcard Characters</a> in the <i>Microsoft SQL Server Transact-SQL Reference</i>. 

</dd>
</dl>
<h4>Remarks</h4>
<p>
System administrators sometimes load a database or table backup file from a production database into a database on another server. Requirements for cross-database dump and load activities are documented under the LOAD Statement in the <i>Microsoft SQL Server Transact-SQL Reference</i>. One requirement is that two databases must have compatible <i>lpage</i> (logical page) and <i>segmap</i> (segment map) column information in the <i>sysusages </i>table. The target database must be created so the <i>segmap</i> for each range of logical pages (<i>lpage</i>) is compatible with the same information in the dumped database.</p>
<p>
Two databases have compatible <i>lpage</i> and <i>segmap</i> structures if for every <i>lpage</i> number they have the same <i>segmap</i> value. If one database is larger than the other, some of the larger database's <i>lpage</i> numbers will not exist for the smaller database. A smaller database can be dumped into a larger database, but a larger database cannot be dumped into a smaller database.</p>
<p>
<b>Important</b>  If the target and destination databases have different <i>segmap</i> structures, dump or load operations can cause data access problems, error messages can appear, or the load can fail if recovery must run.</p>
<p>
For more information about logical pages, see the <i>Microsoft SQL Server Administrator's Companion</i>.</p>
<p>
The <b>sp_coalesce_fragments</b> procedure simplifies the output from <b>sp_help_revdatabase</b> by replacing multiple rows in the <i>sysusages</i> system table with one row. For every row in the <i>sysusages</i> system table, <b>sp_help_revdatabase</b> produces an ALTER DATABASE statement. With fewer rows in the <i>sysusages</i> system table, fewer ALTER DATABASE statements are produced by <b>sp_help_revdatabase</b>, and fewer rows in <i>sysusages </i>makes it easier to verify compatible logical page and segment map combinations between databases. System administrators can execute <b>sp_coalesce_fragments</b> after ALTER DATABASE statements are issued.</p>
<p>
This stored procedure is used with <b>sp_help_revdatabase</b>. Output from <b>sp_help_revdatabase</b> can help create a compatible database.</p>
<p>
For more information about creating a compatible database, see <a href="addsproc_7vol.htm"><b>sp_help_revdatabase</b></a> later in this document.</p>
<p>
The <i>sysusages</i> system table records the device fragments defined for each database during the CREATE DATABASE and ALTER DATABASE statements. Sometimes several fragments for a database on one device are physically contiguous. The <i>sysusages</i> rows for these contiguous fragments can be reduced to one row by running <b>sp_coalesce_fragments</b>. This reduction is safe because the fragments for a database on any device always have the same value for <i>sysusages.segmap</i>.</p>
<p>
For more information about creating a database script that can replicate an existing database structure, see <a href="addsproc_7vol.htm"><b>sp_help_revdatabase</b></a> later in this document.</p>
<p>
For more information about altering a database, see the <a href="../../../tsqlref/src/tsql01_9b04.htm">ALTER DATABASE statement</a> in the <i>Microsoft SQL Server Transact-SQL Reference</i>. </p>
<p>
For more information about performing a database load, see the <a href="../../../tsqlref/src/tsql11_756c.htm">LOAD statement</a> in the <i>Microsoft SQL Server Transact-SQL Reference.</i></p>
<p>
For more information about performing a database backup, see the <a href="../../../tsqlref/src/tsql08_2zxw.htm">DUMP statement</a> in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<h4>Example</h4>
<p>
This example compares the output of a SELECT statement before and after <b>sp_coalesce_fragments</b> is run. Comments delimited by two hyphens (--) are interspersed throughout this example.</p>
<pre>SELECT
'dbname'=substring(db_name(ug.dbid),1,10)
,ug.segmap,ug.lstart -- page number within a database
,ug.size,ug.vstart -- page number within dv    
,'(vstart+size)' = ug.vstart + ug.size
,'device'=substring(dv.name,1,10)
FROM
master.dbo.sysusages ug,master.dbo.sysdevices dv 
WHERE ug.vstart between dv.low and dv.high     AND
dv.status &amp; 2 = 2 --physical disk
AND
db_name(ug.dbid) in ('DB1','DB22','db_junk3')
ORDER BY ug.vstart
<b><i>  </i></b></pre>
<p>
This is the results set:</p>
<pre>dbname      segmap  lstart  size  vstart       (vstart+size)  device     
----------  ------  ------  ----  -----------  -------------  ---------- 
DB1              3       0  2048    352321536      352323584  dvdata1    
DB22             3       0  1024    352323584      352324608  dvdata1    
DB22             3    1024  1024    352324608      352325632  dvdata1    
DB22             4    2048  1024    369098752      369099776  dvlog1     
db_junk3         7       0  1024    369099776      369100800  dvlog1     
DB22             4    3072  1024    369100800      369101824  dvlog1     
DB1              4    2048  1024    369101824      369102848  dvlog1     
DB1              4    3072   768    369102848      369103616  dvlog1     
<b><i>  </i></b></pre>
<p>
<b>Note</b>  In the results set the size of 768 for one of the DB1 fragments is not an even multiple of 512. These fragment sizes are difficult to mimic when building compatible work databases for dump and load activities.</p>
<p>
Compare the two results sets after <b>sp_coalesce_fragments</b> is executed:</p>
<pre>EXECUTE sp_coalesce_fragments
<b><i>  </i></b></pre>
<p>
This is the results set:</p>
<pre>dbname      segmap  lstart  size  vstart       (vstart+size)  device     
----------  ------  ------  ----  -----------  -------------  ----------
DB1              3       0  2048    352321536      352323584  dvdata1    
DB22             3       0  2048    352323584      352325632  dvdata1    
DB22             4    2048  1024    369098752      369099776  dvlog1     
db_junk3         7       0  1024    369099776      369100800  dvlog1     
DB22             4    3072  1024    369100800      369101824  dvlog1     
DB1              4    2048  1792    369101824      369103616  dvlog1     
<b><i>  </i></b></pre>
<p>
The number of <i>sysusages</i> fragments is reduced by two.</p>
<p>
<b>Note</b>  The two DB22 fragments that have segment map 4 cannot be coalesced because they are not contiguous. The <i>lpage</i> 1029 for database DB22 was in a <i>coalesced</i> fragment, and note that its corresponding <i>segmap</i> value remained 3 (<b>system tables</b> and <b>data</b> usage). Similarly, <i>lpage</i> 3081 in DB1 remained on a fragment where <i>segmap</i> is 4 (<b>log</b> usage).</p>
<h4>Permission</h4>
<p>
Only the system administrator can run this procedure.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
