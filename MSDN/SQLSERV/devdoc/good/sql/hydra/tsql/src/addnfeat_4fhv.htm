<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Data Definition Language in Transactions</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_data_definition_language_in_transactions"></a>Data Definition Language in Transactions (version 6.5)</h1>
<p>
Data definition language (DDL) statements can appear within a user transaction. This allows the new CREATE SCHEMA statement to function. You can build a batch of schema-building statements and they will all be committed simultaneously. This eases the strict instruction order that was required by earlier releases. </p>
<p>
The following statements can appear in transactions:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%>ALTER TABLE </td>
<td width=52%>DROP PROCEDURE</td>
</tr>
<tr valign=top>
<td width=48%>CREATE DEFAULT</td>
<td width=52%>DROP RULE</td>
</tr>
<tr valign=top>
<td width=48%>CREATE INDEX</td>
<td width=52%>DROP TABLE</td>
</tr>
<tr valign=top>
<td width=48%>CREATE PROCEDURE</td>
<td width=52%>DROP TRIGGER</td>
</tr>
<tr valign=top>
<td width=48%>CREATE RULE</td>
<td width=52%>DROP VIEW</td>
</tr>
<tr valign=top>
<td width=48%>CREATE TABLE </td>
<td width=52%>GRANT</td>
</tr>
<tr valign=top>
<td width=48%>CREATE TRIGGER</td>
<td width=52%>REVOKE</td>
</tr>
<tr valign=top>
<td width=48%>CREATE VIEW</td>
<td width=52%>SELECT INTO</td>
</tr>
<tr valign=top>
<td width=48%>DROP DEFAULT</td>
<td width=52%>TRUNCATE TABLE</td>
</tr>
<tr valign=top>
<td width=48%>DROP INDEX</td>
<td width=52%></td>
</tr>
</table><br>
<p>
A database object (including a global temporary table) cannot be dropped while it is in use. If the object is in use and a drop is attempted, the transaction will be rolled back. The only exception to this is the implicit drop that is done to a global-temporary object when the creating connection disconnects.  </p>
<p>
The SELECT INTO statement is now supported within a transaction. This means that tables can be created by using SELECT INTO within a transaction. The data is removed and the table is dropped if the transaction is rolled back. </p>
<p>
User transactions are not rolled back when a batch contains a syntax or compile-time error. A batch with this type of error will not execute. This situation can cause unexpected behavior if the BEGIN TRANSACTION statement was executed in a previous batch, because the transaction will be active even though the rest of the batch will not run. </p>
<p>
If an uncommitted procedure or trigger is executed and causes a rollback, it will drop itself but continue executing the cached copy. This copy will be removed when the procedure or trigger completes execution. </p>
<p>
The <b>sp_bindrule</b>, <b>sp_unbindrule</b>, <b>sp_bindefault</b>, and <b>sp_unbindefault</b> stored procedures can also be used within a transaction whether or not the rule or table has been modified within that transaction or within another transaction. </p>
<p>
All resources (such as pages, extents, and locks) used by a transaction are freed only at the end of the transaction. For DDL statements on large tables, this can affect a significant number of pages. </p>
<p>
<b>Important</b>  While implicit drops of temporary tables can occur successfully at any time, the resources for the temporary table (including locks on system tables in <i>tempdb</i>) are not freed until the end of the transaction.</p>
<p>
Use caution when you create temporary tables inside a transaction. Until the transaction commits or rolls back, exclusive locks are held on several system tables in the <i>tempdb</i> database to ensure recovery. These locks are held even if the temporary tables are dropped, and they can block other users' attempts to create temporary tables or other objects in <i>tempdb</i>.  </p>
<p>
This caution also applies to stored procedures that create temporary tables. If the stored procedure is executed within a transaction, the locks are held on the system tables until the transaction completes, even though the temporary table is automatically dropped when the procedure completes execution.  </p>
<p>
When invoked inside a user transaction, SELECT INTO has the ACID transaction properties (atomicity, consistency, isolation, durability): either the transaction is completely committed or it is completely rolled back.  </p>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Create a Table and Insert Values in One Transaction</h5>
<p>
This example creates and fills a table in a single transaction. The table is created and filled with data simultaneously. Either the table is not created and the transaction is rolled back, or the table is created, filled with data, and then committed.  </p>
<pre>BEGIN TRAN
CREATE TABLE pay_type_table (pay_id int, pay_type varchar(20))
INSERT pay_type_table (1, 'Cash')
INSERT pay_type_table (2, 'Check')
INSERT pay_type_table (3, 'Credit Card')
INSERT pay_type_table (4, 'Electronic Wire')
INSERT pay_type_table (5, 'Banker Draft')
COMMIT TRAN
<b><i>  </i></b></pre>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Demonstrate Exclusive Locks on a Temporary Table in a Transaction</h5>
<p>
This example attempts a second session to access a newly created but uncommitted object; it results in the second session waiting until the creating transaction is complete. If the first transaction results in the object being removed and also creates another object by the same name and the waiting session is attempting to open the object by name, the waiting session will open the second (and newest) object.  </p>
<p>
This table illustrates the relationship between the two connections.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<th align=left width=47%></th>
<th align=left width=53%></th>
</tr>
<tr valign=top>
<th align=left width=47%></th>
<th align=left width=53%></th>
</tr>
<tr valign=top>
<th align=left width=47%>User One</th>
<th align=left width=53%>User Two</th>
</tr>
<tr valign=top>
<td colspan=2 width=100%></td>
</tr>
<tr valign=top>
<td width=47%><pre>BEGIN TRAN
CREATE TABLE test (c1 int)
INSERT test VALUES (1)
go</pre>
</td>
<td width=53%><pre></pre>
</td>
</tr>
<tr valign=top>
<td width=47%><pre></pre>
</td>
<td width=53%><pre>SELECT * FROM test</pre>
</td>
</tr>
<tr valign=top>
<td width=47%><pre>DROP TABLE test
go
CREATE TABLE test (c1 int, c2 int)
INSERT test VALUES (1,2)
go
COMMIT TRAN</pre>
</td>
<td width=53%><pre></pre>
</td>
</tr>
<tr valign=top>
<td width=47%><pre></pre>
</td>
<td width=53%><pre>Results Set
c1    c
------------
1     2
(1 row(s) affected)</pre>
</td>
</tr>
</table><br>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Use SELECT INTO Within a Transaction</h5>
<p>
Before running this example, <b>sp_dboption</b> <b>select into\bulk copy</b> must be set to TRUE. </p>
<p>
The SELECT INTO statement creates a new table called <i>authors2</i>,<i> </i>into which the records in the <i>authors</i> table are copied. After the transaction is rolled back the <i>authors2</i> table has been dropped and the final SELECT statement causes an error.</p>
<pre>GO
BEGIN TRANSACTION
SELECT * INTO authors2 FROM authors
SELECT * FROM authors2
ROLLBACK TRANSACTION 
SELECT * FROM authors2
GO
<b><i>  </i></b></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
