<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CREATE INDEX Statement</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_create_index_statement_addnfeatwn"></a>CREATE INDEX Statement (version 6.5)</h2>
<p>
Creates an index on a given table. The CREATE INDEX statement either changes the physical ordering of the table or provides the optimizer with a logical ordering of the table to increase efficiency for queries. When you create an index for the primary key, use the table- and column-level Primary Key constraint provided with the CREATE TABLE or ALTER TABLE statements. </p>
<p>
For additional syntax information for the <a href="../../../tsqlref/src/tsql03_46t0.htm">CREATE INDEX statement</a>, see the <i>Microsoft SQL Server Transact-SQL Reference</i>. </p>
<h4>Syntax</h4>
<p>
CREATE [UNIQUE] [CLUSTERED | NONCLUSTERED] INDEX <i>index_name</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp;ON [[<i>database</i><b>.</b>]<i>owner</i><b>.</b>]<i>table_name</i> <b>(</b><i>column_name</i> [<b>,</b> <i>column_name</i>]...<b>)</b><br>
[WITH<br>
&nbsp;&nbsp;&nbsp;&nbsp;[PAD_INDEX<b>,</b> ]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] FILLFACTOR <b>=</b> <i>fillfactor</i>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] IGNORE_DUP_KEY]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] SORTED_DATA | SORTED_DATA_REORG]<br>
&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] IGNORE_DUP_ROW | ALLOW_DUP_ROW]]<br>
[ON <i>segment_name</i>]</p>
<p>
where 
<dl>
<dt>
PAD_INDEX</dt>
<dd>
Specifies that the FILLFACTOR setting should be applied to the index node pages as well as to the data pages in the index. 
</dd>
</dl>
<p>
<b>Note</b>  The number of items on an index page is never less than two, regardless of how low the value of FILLFACTOR.</p>
<h4>Remarks</h4>
<p>
Indexes are made up of pages that form a branching structure known as a B-tree. The starting page records ranges of values within the table. Each range on the starting page branches to another page that contains a more detailed range of values in the table. In turn, these index pages branch out to more layers, which increase the number of pages in the layer and narrow the range of data on each page. </p>
<p>
The branching index pages are called <i>node pages</i>. The final layer in the branching structure is called the <i>leaf layer</i>. In a unique, non-clustered index, the ranges on each leaf layer page point to a specific row of data in the table. In a clustered index, the leaf layer is the data pages because the data is stored in the physical order specified in the index.</p>
<p>
Setting FILLFACTOR to 100 in SQL Server version 6.5 has the same behavior as it does in SQL Server 6.0. Index node pages are filled completely and have no space for additional items. </p>
<h4>Example</h4>
<p>
This example creates an index on the author's identification number in the <i>authors </i>table. Without the PAD_INDEX option, SQL Server version 6.5 creates leaf pages that are 10 percent full, but the node pages are filled almost completely. With PAD_INDEX the node pages are also 10 percent full.</p>
<p>
<b>Note</b>  At least two entries appear on the index pages of unique clustered indexes when PAD_INDEX is not specified. </p>
<pre>CREATE INDEX au_id_ind
    ON authors (au_id)
    WITH PAD_INDEX, FILLFACTOR=10
<b><i>  </i></b></pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
