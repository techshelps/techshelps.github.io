<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Datatype Usage</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_datatype_usage_odbcapb"></a>Datatype Usage</h1>
<p>
The SQL&nbsp;Server driver and SQL&nbsp;Server impose the following usage of data types.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=31%>Datatype</th>
<th align=left width=69%>Limitation</th>
</tr>
<tr valign=top>
<td width=31%>Date literals</td>
<td width=69%>Date literals, when stored in an SQL_TIMESTAMP column (SQL&nbsp;Server datatypes of <i>datetime </i>or <i>smalldatetime</i>), have a time value of 12:00:00.000 a.m. (midnight).</td>
</tr>
<tr valign=top>
<td width=31%><i>money </i>and <i>smallmoney</i></td>
<td width=69%>Only the integer parts of the <i>money</i> and the <i>smallmoney</i> datatypes are significant. If the decimal part of SQL <i>money </i>data is truncated during datatype conversion, the SQL&nbsp;Server driver returns a warning, not an error.</td>
</tr>
<tr valign=top>
<td width=31%>SQL_BINARY (nullable)</td>
<td width=69%>When connected to SQL&nbsp;Server version 6.0 and earlier, if an SQL_BINARY column is nullable, the data that is stored in the data source is not padded with zeroes. When data from such a column is retrieved, the SQL&nbsp;Server driver pads it with zeroes on the right. However, data that is created in operations performed by SQL&nbsp;Server, such as concatenation, does not have such padding.</td>
</tr>
<tr valign=top>
<td width=31%>SQL_CHAR (truncation)</td>
<td width=69%>When connected to SQL&nbsp;Server version 6.0 and earlier, and data is placed into a SQL_CHAR column, SQL&nbsp;Server truncates it on the right without warning if the data is too long to fit into the column.</td>
</tr>
<tr valign=top>
<td width=31%>SQL_CHAR (nullable)</td>
<td width=69%>When connected to SQL&nbsp;Server version 6.0 and earlier, if a SQL_CHAR column is nullable, the data that is stored in the data source is not padded with blanks. When data from such a column is retrieved, the SQL&nbsp;Server driver pads it with blanks on the right. However, data that is created in operations performed by SQL&nbsp;Server, such as concatenation, does not have such padding.</td>
</tr>
<tr valign=top>
<td width=31%>SQL_LONGVAR BINARY, SQL_LONGVAR CHAR</td>
<td width=69%>Updates of columns with SQL_LONGVARBINARY or SQL_LONGVARCHAR data types (using a WHERE clause) that affect multiple rows are fully supported when connected to SQL&nbsp;Server 6.<i>x</i>. When connected to SQL&nbsp;Server 4.2<i>x</i>, an S1000 error "Partial insert/update. The insert/update of a text or image column(s) did not succeed" is returned if the update affects more than one row.</td>
</tr>
<tr valign=top>
<td width=31%>String function parameters</td>
<td width=69%><i>string_exp</i> parameters to the string functions must be of data type SQL_CHAR or SQL_VARCHAR. SQL_LONG_VARCHAR data types are not supported in the string functions. The <i>count</i> parameter must be less than or equal to 255, because the SQL_CHAR and SQL_VARCHAR data types are limited to a maximum length of 255 characters.</td>
</tr>
<tr valign=top>
<td width=31%>Time literals</td>
<td width=69%>Time literals, when stored in an SQL_TIMESTAMP column (SQL&nbsp;Server datatypes of <i>datetime </i>or <i>smalldatetime</i>), have a date value of January 1, 1900.</td>
</tr>
<tr valign=top>
<td width=31%><i>timestamp</i></td>
<td width=69%>Only a NULL value can be manually inserted into a <i>timestamp </i>column. However, because <i>timestamp </i>columns are automatically updated by SQL&nbsp;Server, a NULL value is overwritten.</td>
</tr>
<tr valign=top>
<td width=31%><i>tinyint</i></td>
<td width=69%>The SQL&nbsp;Server <i>tinyint</i> datatype is unsigned. A <i>tinyint</i> column is bound to a variable of data type SQL_C_UTINYINT by default.</td>
</tr>
<tr valign=top>
<td width=31%>User-defined data types</td>
<td width=69%>When connected to SQL&nbsp;Server 4.2<i>x</i>, the SQL&nbsp;Server driver adds <a href="odbc05_8pth.htm">NULL</a> to a column definition that does not explicitly declare a column's nullability. Therefore, the nullability that is stored in the definition of a user-defined datatype is ignored.<p>
When connected to SQL&nbsp;Server 4.2<i>x</i>, columns with a user-defined datatype that has a base datatype of <i>char </i>or <i>binary </i>and for which no nullability is declared are created as datatype <i>varchar </i>or <i>varbinary</i>. <b>SQLColAttributes</b>, <b>SQLColumns</b>, and <b>SQLDescribeCol</b> return SQL_VARCHAR or SQL_VARBINARY as the data type for these columns. Data that is retrieved from these columns is not padded.</p>
</td>
</tr>
<tr valign=top>
<td width=31%>LONG data types</td>
<td width=69%>SQL_LONGVARBINARY data must be passed to <b>SQLPutData</b> as raw binary data, not as binary data that is converted to character data. Also, <i>data-at-execution</i> parameters are restricted for both the SQL_LONGVARBINARY and the SQL_LONGVARCHAR data types.</td>
</tr>
</table><br>
<p>
For details, see the <a href="odbc05_2u2d.htm">Data-at-Execution Parameter Limitations</a> topic.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
