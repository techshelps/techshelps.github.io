<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Retrieving Data Through Cursors</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_retrieving_data_through_cursors"></a>Retrieving Data Through Cursors</h1>
<p>
There are two ways to retrieve data through cursors:
<ul>
<li>
You can bind columns of the results set to storage locations by using <b>SQLBindCol</b>, and then use <b>SQLFetch</b> to move to the next row in the results set. For bulk fetches, you could bind columns to an array and use <b>SQLExtendedFetch</b>. The SQL&nbsp;Server driver supports row-wise as well as column-wise binding. Keep in mind that when using server cursors, each <b>SQLFetch</b> or <b>SQLExtendedFetch</b> operation involves a round trip to the server and the connection remains free between these operations. The server tracks all required state information (for example, current cursor position). Also, cursor operations do not have to be sequential. The server allows you to traverse the cursor in the forward or backward directions relative to the current position. You can also directly set the position to an absolute row number (except for Dynamic cursors) in the results set.</li>
<li>
You can retrieve data for unbound columns (columns for which storage has not been allocated). Use <b>SQLFetch</b> or <b>SQLExtendedFetch</b> to position the cursor on the next row, and call <b>SQLGetData</b> to retrieve data for specific unbound columns. You can call <b>SQLGetData</b> multiple times on the same column to incrementally retrieve data. This is useful if you are retrieving large amounts of data from a <i>text </i>or <i>image </i>column. Keep in mind, however, that the connection is busy until you read all the data associated with the column. If you issue an <b>SQLSetPos</b> with the Position option, the SQL&nbsp;Server driver flushes the remaining data and frees up the connection, thereby allowing you to use it for processing on another <i>hstmt</i>.</li>
</ul>
<p>
You can retrieve data from both bound and unbound columns in the same row.</p>
<p>
When retrieving rows involving potentially large <i>text</i> and <i>image</i> columns, if you do not want to access the text data column in the row, do not bind that column. When you do an <b>SQLExtendedFetch</b>, the retrieved row will only contain the text pointer for the unbound column as opposed to the previous behavior of returning the complete row including the text data. </p>
<p>
The following ODBC functions are relevant:</p>
<p>
</p>
<p>
</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="odbc07_85vb.htm"><b>SQLFetch</b></a></td>
<td width=52%><a href="odbc07_17ch.htm"><b>SQLRowCount</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="odbc07_4lkn.htm"><b>SQLExtendedFetch</b></a></td>
<td width=52%></td>
</tr>
</table><br>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
