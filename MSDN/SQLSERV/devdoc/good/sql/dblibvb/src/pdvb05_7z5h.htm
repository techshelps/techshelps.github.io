<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SqlCursorFetch%</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sqlcursorfetch.25"></a>SqlCursorFetch%</h1>
<p>
Fetches a block of rows (called the fetch buffer) from a client cursor or transparent server cursor, and makes the rows available using <b>SqlCursorData$</b>. If you are connected to SQL Server 6.0, you should use <b>SqlCursorFetchEx%</b>.</p>
<h4>Syntax</h4>
<p>
<b>SqlCursorFetch% ( </b><i>cursorhandle%</i><b>, </b><i>fetchtype%</i><b>, </b><i>rownum%</i><b> )</b></p>
<p>
where
<dl>
<dt>
<i>cursorhandle%</i></dt>
<dd>
Is the cursor handle created by <b>SqlCursorOpen%</b>.</dd>
<dt>
<i>fetchtype%</i></dt>
<dd>
Specifies the type of fetch to execute, changing the position of the fetch buffer within the cursor results set. The following table describes the different <i>fetchtype%</i> values:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%><i>fetchtype%</i></th>
<th align=left width=72%>Description</th>
</tr>
<tr valign=top>
<td width=28%></td>
<td width=72%></td>
</tr>
<tr valign=top>
<td width=28%>FETCHFIRST%</td>
<td width=72%>Fetches the first block of rows from a dynamic or keyset cursor. The first row of the new fetch buffer is the first row in the cursor results set.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHNEXT%</td>
<td width=72%>Fetches the next block of rows from a dynamic or keyset cursor. The first row of the new fetch buffer is the row after the last row of the current fetch buffer.<p>
If this is the first fetch using a new cursor, it behaves the same as FETCHFIRST%.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>FETCHPREV%</td>
<td width=72%>Fetches the previous block of rows from a fully dynamic or keyset cursor. The first row of the new fetch buffer is <i>nrows%</i> (specified in <b>SqlCursorOpen%</b>) before the first row of the current fetch buffer.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHRANDOM%</td>
<td width=72%>Fetches a block of rows from a keyset cursor. The first row of the new fetch buffer is the specified <i>rownum%</i> row in the keyset cursor results set.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHRELATIVE%</td>
<td width=72%>Fetches a block of rows from a keyset cursor. The first row of the new fetch buffer is <i>rownum%</i> rows before or after the first row of the current fetch buffer.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHLAST%</td>
<td width=72%>Fetches the last block of rows from a keyset cursor. The last row of the new fetch buffer is the last row of the cursor results set.</td>
</tr>
</table><br>


<p>
The block of rows retrieved by a fetch is called the fetch buffer. The number of rows in the fetch buffer is determined by the <i>nrows%</i> parameter of <b>SqlCursorOpen%</b>.

<p>
For a forward-only dynamic cursor (<i>scrollopt%</i> is CURFORWARD% in <b>SqlCursorOpen%</b>), you can use only FETCHFIRST% or FETCHNEXT%.
</dd>
<dt>
<i>rownum%</i></dt>
<dd>
Is the specified random or relative row number to use as the first row of the new fetch buffer. Use this parameter only with a <i>fetchtype%</i> of FETCHRANDOM% or FETCHRELATIVE%. Specify 0 for any other <i>fetchtype%</i>.
<p>
When <i>fetchtype%</i> is FETCHRANDOM%, the first row of the new fetch buffer is the <i>rownum%</i> row (counting forward from the beginning) of the keyset cursor results set. The <i>rownum%</i> parameter must be positive.

<p>
When <i>fetchtype%</i> is FETCHRELATIVE%:

<ul>
<li>
A positive <i>rownum%</i> means that the first row of the new fetch buffer is <i>rownum%</i> rows after the first row of the current fetch buffer.</li>
<li>
A negative <i>rownum%</i> means that the first row of the new fetch buffer is <i>rownum%</i> rows before the first row of the current fetch buffer.</li>
<li>
A <i>rownum%</i> of 0 means that all rows in the fetch buffer are refreshed with current data from SQL Server without moving the current cursor position. This is identical to calling <b>SqlCursor%</b> with <i>optype%</i> set to CRSREFRESH%.</li>
</ul>
</dd>
</dl>
<h4>Returns</h4>
<p>
SUCCEED (1) or FAIL (0).</p>
<p>
SUCCEED (1) is returned if every row was fetched successfully. Note that for a keyset cursor, a fetch that results in a missing row will not cause <b>SqlCursorFetch%</b> to FAIL (0).</p>
<p>
FAIL (0) is returned if at least one of the following is true:
<ul>
<li>
A <i>fetchtype%</i> of FETCHRANDOM%, FETCHRELATIVE%, or FETCHLAST% was used on a dynamic cursor.</li>
<li>
A fetchtype other than FETCHFIRST% or FETCHNEXT% was used on a forward-only dynamic cursor.</li>
<li>
The SQL Server connection is broken or times out.</li>
<li>
DB-Library is out of memory.</li>
</ul>
<h4>Remarks</h4>
<p>
Specify the size of the fetch buffer in the <i>nrows%</i> parameter of <b>SqlCursorOpen%</b>.</p>
<p>
After the fetch, the elements of the array of row status indicators (<i>pstatus&amp;</i>() in <b>SqlCursorOpen%</b>) are filled with row status values, one for each row in the fetch buffer. Each row status value is a series of fetch status values ORed together. The following table shows the meaning of each row status value:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=35%></th>
<th align=left width=65%></th>
</tr>
<tr valign=top>
<th align=left width=35%></th>
<th align=left width=65%></th>
</tr>
<tr valign=top>
<th align=left width=35%>Fetch status</th>
<th align=left width=65%>Description</th>
</tr>
<tr valign=top>
<td width=35%></td>
<td width=65%></td>
</tr>
<tr valign=top>
<td width=35%>FTCSUCCEED%</td>
<td width=65%>The row was successfully fetched. <b>SqlCursorData$</b> will return valid data for the row.</td>
</tr>
<tr valign=top>
<td width=35%>FTCMISSING%</td>
<td width=65%>The row has been deleted or a unique index column of the row has been changed. Do not use <b>SqlCursorData$ </b>for the row.<p>
For keyset cursors, this fetch status can appear at any time. For dynamic cursors, this fetch status can appear only after the current fetch buffer is refreshed.</p>
</td>
</tr>
<tr valign=top>
<td width=35%>FTCENDOFKEYSET%</td>
<td width=65%>Is the end of the keyset. This fetch status is set for backward compatibility with "mixed" client cursors used by existing applications.</td>
</tr>
<tr valign=top>
<td width=35%>FTCENDOFRESULTS%</td>
<td width=65%>Is the end of the results set of a dynamic or keyset cursor. Rows in the fetch buffer after this row are invalid and will have a row status indicator of 0; do not use <b>SqlCursorData$ </b>for those rows.<p>
If ORed with FTCSUCCEED%, this is the last row in the cursor results set; it contains valid data.</p>
<p>
If ORed with FTCMISSING%, this is the last row in the cursor results set, but the row is missing.</p>
<p>
If not ORed with FTCSUCCEED% or FTCMISSING%, this row is invalid.</p>
</td>
</tr>
</table><br>
<p>
A row status indicator of 0 means that the row is invalid, and <b>SqlCursorData$</b> will not return valid data. This usually happens when the row is before the beginning (first row) or after the end (last row) of the cursor results set.</p>
<p>
After the fetch, <b>SqlCursorData$</b> returns:
<ul>
<li>
Valid data for all rows with a fetch status of FTCSUCCEED%.</li>
<li>
Invalid data for all rows <i>without</i> a fetch status of FTCSUCCEED%.</li>
</ul>
<p>
If no fetches have been performed on a cursor, the current cursor position is before the beginning (first row) of the cursor results set.</p>
<p>
After a fetch is complete, the new cursor position is one of the following:
<ul>
<li>
The first row of the new fetch buffer, as specified under <i>fetchtype%</i>, if the first row of the new fetch buffer stayed within the cursor results set.</li>
<li>
Adjusted to the first row of the cursor results set if the first row of the new fetch buffer would have been before the first row of the cursor results set and the last row of the new fetch buffer would have stayed within the cursor results set due to a FETCHPREV% operation.</li>
<li>
Unchanged from the current position if all rows of the new fetch buffer would have been before the first row of the cursor results set, if the first row (and thus all rows) of the new fetch buffer would have been after the last row of the cursor results set, or, if for a keyset cursor, if the first row of the new fetch buffer would have been before the first row of the cursor results set and the last row of the new fetch buffer would have stayed within the cursor results set due to a FETCHRELATIVE% attempt with a negative <i>rownum%</i>.</li>
</ul>
<p>
When the new cursor position is unchanged because the first row (and thus all rows) of the new fetch buffer would have been after the last row of the cursor results set, all rows in the fetch buffer are invalid and will not have a fetch status of FTCSUCCEED%. In the case of dynamic cursors, the first row of the fetch buffer will have a fetch status of FTCENDOFRESULTS%, and later rows will have a row status of 0. In the case of keyset cursors, all rows in the fetch buffer will have a row status of 0.</p>
<p>
When the new position of a dynamic cursor is unchanged because all rows of the new fetch buffer would have been before the first row of the cursor results set, all rows in the fetch buffer are invalid and will not have a fetch status of FTCSUCCEED%. The first row of the fetch buffer will have a fetch status of FTCENDOFRESULTS%, and later rows will have a row status of 0.</p>
<p>
When the new cursor position is unchanged and all rows in the fetch buffer are invalid, you can use <b>SqlCursor%</b> to refresh the rows in the fetch buffer with current data from SQL Server. This will result in valid rows that reflect the current cursor position.</p>
<p>
Each call to <b>SqlCursorFetch%</b> leaves the connection available for use with no pending results.</p>
<p>
<b>Note</b>  This function works with client cursors and transparent server cursors. Do not use both <b>SqlCursorFetch%</b> and <b>SqlCursorFetchEx%</b> with the same cursor handle. Once one of these functions is used on a specific cursor handle, any attempt to use the other function will return fail (0).</p>
<p>
If rows in the current fetch buffer of a dynamic cursor are deleted, a fetch using a client cursor might behave differently than a fetch using a transparent server cursor.</p>
<h5>Client cursor:</h5>
<p>
When the new position of a dynamic cursor is adjusted to be the first row of the cursor results set (which happens when the first row of the new fetch buffer would have been before the first row of the dynamic cursor results set and the last row of the new fetch buffer would have stayed within the dynamic cursor results set due to a FETCHPREV% operation), some rows at the end of the new fetch buffer might be invalid. Any invalid rows will have a row status indicator of 0.</p>
<p>
If rows in the current fetch buffer of a dynamic cursor are deleted, a fetch next or fetch previous might result in a new fetch buffer that skips rows in the cursor results set or includes rows from the current fetch buffer again.</p>
<h5>Transparent server cursor:</h5>
<p>
A <i>fetchtype%</i> of FETCHNEXT% or FETCHPREV% using a dynamic cursor is actually mapped to a relative fetch on SQL Server 6.0. Because of this, if the first row in the current fetch buffer is deleted before a FETCHNEXT% (mapped to a forward relative fetch on SQL Server 6.0) is performed, the current cursor position becomes invalid. For more information about the fetch behavior in this case, see <b>SqlCursorFetchEx%</b>.</p>
<h4>See Also</h4>
<p>
<a href="pdvb05_34xh.htm"><b>SqlCursor%</b></a>, <a href="pdvb05_1tbp.htm"><b>SqlCursorColInfo%</b></a>, <a href="pdvb05_8ihx.htm"><b>SqlCursorClose</b></a>, <a href="pdvb05_8cad.htm"><b>SqlCursorInfo%</b></a>, <a href="pdvb05_2f91.htm"><b>SqlCursorOpen%</b></a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
