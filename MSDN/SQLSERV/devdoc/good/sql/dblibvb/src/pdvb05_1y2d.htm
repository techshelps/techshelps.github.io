<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SqlCursorFetchEx%</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_sqlcursorfetchex.25"></a>SqlCursorFetchEx%</h1>
<p>
Fetches a block of rows (called the fetch buffer) from an explicit server cursor and makes the rows available using <b>SqlCursorData$</b>.</p>
<h4>Syntax</h4>
<p>
<b>SqlCursorFetchEx% ( </b><i>cursorhandle%</i><b>, </b><i>fetchtype%</i><b>, </b><i>rownum%</i><b>, </b><i>nfetchrows%</i><b>, </b><i>reserved&amp; </i><b>)</b></p>
<p>
where
<dl>
<dt>
<i>cursorhandle%</i></dt>
<dd>
Is an explicit server cursor handle returned by <b>SqlCursorOpen%</b>.</dd>
<dt>
<i>fetchtype%</i></dt>
<dd>
Specifies the type of fetch to execute, changing the position of the fetch buffer within the cursor results set. The following table describes the different <i>fetchtype%</i> values:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%><i>fetchtype%</i></th>
<th align=left width=72%>Description</th>
</tr>
<tr valign=top>
<td width=28%></td>
<td width=72%></td>
</tr>
<tr valign=top>
<td width=28%>FETCHFIRST%</td>
<td width=72%>Fetches the first block of rows from a dynamic or keyset cursor. The first row of the new fetch buffer is the first row in the cursor results set.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHNEXT%</td>
<td width=72%>Fetches the next block of rows from a dynamic or keyset cursor. The first row of the new fetch buffer is the row after the last row of the current fetch buffer.<p>
If this is the first fetch using a new cursor, it behaves the same as FETCHFIRST%.</p>
</td>
</tr>
<tr valign=top>
<td width=28%>FETCHPREV%</td>
<td width=72%>Fetches the previous block of rows from a fully dynamic or keyset cursor. The first row of the new fetch buffer is <i>nrows%</i> (specified in <b>SqlCursorOpen%</b>) before the first row of the current fetch buffer.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHRANDOM%</td>
<td width=72%>Fetches a block of rows from a keyset cursor. The first row of the new fetch buffer is the specified <i>rownum%</i> row in the cursor results set.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHRELATIVE%</td>
<td width=72%>Fetches a block of rows from a dynamic or keyset cursor. The first row of the new fetch buffer is <i>rownum%</i> rows before or after the first row of the current fetch buffer.</td>
</tr>
<tr valign=top>
<td width=28%>FETCHLAST%</td>
<td width=72%>Fetches the last block of rows from a dynamic or keyset cursor. The last row of the new fetch buffer is the last row of the cursor results set.</td>
</tr>
</table><br>


<p>
The block of rows retrieved by a fetch is called the fetch buffer. The number of rows in the fetch buffer is determined by the <i>nfetchrows%</i> parameter.

<p>
For a forward-only dynamic cursor (<i>scrollopt%</i> is CURFORWARD% in <b>SqlCursorOpen%</b>), you can only use the FETCHFIRST%, FETCHNEXT%, or FETCHRELATIVE% (with a positive <i>rownum%</i>) types.
</dd>
<dt>
<i>rownum%</i></dt>
<dd>
Is the specified random or relative row number to use as the first row of the new fetch buffer. Use this parameter only with a <i>fetchtype%</i> of FETCHRANDOM% or FETCHRELATIVE%. Specify 0 for any other <i>fetchtype%</i>.
<p>
When <i>fetchtype%</i> is FETCHRANDOM%:

<ul>
<li>
A positive <i>rownum%</i> means that the first row of the new fetch buffer is the <i>rownum%</i> row (counting forward from the beginning) of the cursor results set.</li>
<li>
A negative <i>rownum%</i> means that the first row of the new fetch buffer is <i>rownum%</i> rows backward from the end of the cursor results set. Given N rows in the cursor results set, the first row of the new fetch buffer is row N+1+<i>rownum%</i> of the cursor results set.<p>
For example, a <i>rownum%</i> of - 1 means the first row of the new fetch buffer is row N (N+1 - 1), or the last row, of the current results set. A <i>rownum%</i> of - N means the first row of the new fetch buffer is row 1 (N+1 - N), or the first row, of the current results set.
</li>
<li>
A <i>rownum%</i> of 0 means that the first row of the new fetch buffer is before the beginning (first row) of the cursor results set.</li>
</ul>

<p>
When <i>fetchtype%</i> is FETCHRELATIVE%:

<ul>
<li>
A positive <i>rownum%</i> means that the first row of the new fetch buffer is <i>rownum%</i> rows after the first row of the current fetch buffer.<p>
For dynamic cursors, if the first row in the current fetch buffer is deleted before a relative fetch, the current cursor position becomes invalid. Let D be the number of contiguous rows, including the first row, deleted from the beginning of the current fetch buffer. Before executing a relative fetch, the current cursor position is set to before the first non-deleted row (row D+1) in the current fetch buffer.
<p>
In this case, when a relative fetch is performed with a positive <i>rownum%</i>, the first row of the new fetch buffer is row <i>rownum%</i>+D of the current fetch buffer.
</li>
<li>
A negative <i>rownum%</i> means that the first row of the new fetch buffer is <i>rownum%</i> rows before the first row of the current fetch buffer.</li>
<li>
For dynamic cursors, a <i>rownum%</i> of 0 means that all the rows in the current fetch buffer are fetched again without moving the current cursor position. This is different from a refresh because the rows in the new fetch buffer can differ from the rows in the current fetch buffer. New rows can appear, and old rows can disappear.<p>
In the case given above, after D contiguous rows have been deleted from the beginning of the current fetch buffer, when a relative fetch is performed with a <i>rownum%</i> of 0, the first row of the new fetch buffer is the first non-deleted row (row D+1) of the current fetch buffer.
<p>
For keyset cursors, a <i>rownum%</i> of 0 means that the current fetch buffer is refreshed with current data from SQL Server without moving the current cursor position. This is identical to calling <b>SqlCursor%</b> with <i>optype%</i> set to CRSREFRESH%.
</li>
</ul>
</dd>
<dt>
<i>nfetchrows%</i></dt>
<dd>
Is the number of rows in the new fetch buffer. This value must be less than or equal to the <i>nrows%</i> parameter specified for this cursor in <b>SqlCursorOpen%</b>. The <i>poutlen</i> and <i>pvaraddr</i> arrays specified in calls to <b>dbcursorbind</b> must have at least <i>nfetchrows%</i> elements. If these arrays are not large enough, you must break the existing bindings and then rebind with large enough arrays (at least <i>nfetchrows%</i> elements) before calling <b>SqlCursorFetchEx%</b>.
<p>
When <i>fetchtype%</i> is FETCHFIRST%, an <i>nfetchrows% </i>value of 0 means that the new cursor position is set to before the beginning (first row) of the cursor results set.

<p>
When <i>fetchtype%</i> is FETCHLAST%, an <i>nfetchrows% </i>value of 0 means that the new cursor position is set to after the end (last row) of the cursor results set.
</dd>
<dt>
<i>reserved&amp;</i></dt>
<dd>
Reserved for future use. Use 0.
</dd>
</dl>
<h4>Returns</h4>
<p>
succeed (1) or fail (0).</p>
<p>
SUCCEED (1) is returned if every row was fetched successfully. Note that for a keyset cursor, a fetch that results in a missing row will not cause <b>SqlCursorFetchEx%</b> to FAIL (0).</p>
<p>
FAIL (0) is returned if at least one of the following is true:
<ul>
<li>
A <i>fetchtype%</i> of FETCHRANDOM% was used on a dynamic cursor.</li>
<li>
A fetchtype other than FETCHFIRST%, FETCHNEXT%, or FETCHRELATIVE% (with a positive <i>rownum%</i>) was used on a forward-only dynamic cursor.</li>
<li>
The SQL Server connection is broken or times out.</li>
<li>
DB-Library is out of memory.</li>
</ul>
<h4>Remarks</h4>
<p>
After the fetch, the elements of the array of row status indicators (<i>pstatus&amp;</i>() in <b>SqlCursorOpen%</b>) are filled with row status values, one for each row in the fetch buffer. Each row status value is a series of fetch status values ORed together. The following table shows the meaning of each row status value:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=29%></th>
<th align=left width=71%></th>
</tr>
<tr valign=top>
<th align=left width=29%></th>
<th align=left width=71%></th>
</tr>
<tr valign=top>
<th align=left width=29%>Fetch status</th>
<th align=left width=71%>Description</th>
</tr>
<tr valign=top>
<td width=29%></td>
<td width=71%></td>
</tr>
<tr valign=top>
<td width=29%>FTCSUCCEED%</td>
<td width=71%>The row was successfully fetched. <b>SqlCursorData$</b> will return valid data for the row.</td>
</tr>
<tr valign=top>
<td width=29%>FTCMISSING%</td>
<td width=71%>The row has been deleted or a unique index column of the row has been changed. Do not use the values returned by <b>SqlCursorData$</b> for the row.<p>
For keyset cursors, this fetch status can appear at any time. For dynamic cursors, this fetch status can appear only after the current fetch buffer is refreshed.</p>
</td>
</tr>
</table><br>
<p>
A row status indicator of 0 means that the row is invalid, and <b>SqlCursorData$</b> will not return valid data. This happens when the row is before the beginning (first row) or after the end (last row) of the cursor results set.</p>
<p>
After the fetch, <b>SqlCursorData$</b> returns:
<ul>
<li>
Valid data for all rows with a fetch status of FTCSUCCEED%.</li>
<li>
Invalid data for all rows <i>without</i> a fetch status of FTCSUCCEED%.</li>
</ul>
<p>
If no fetches have been performed on a cursor, the current cursor position is before the beginning (first row) of the cursor results set.</p>
<p>
After a fetch is complete, the new explicit server cursor position is one of the following:
<ul>
<li>
The first row of the new fetch buffer, as specified under <i>fetchtype%</i>, if the first row of the new fetch buffer stayed within the cursor results set.</li>
<li>
Adjusted to the first row of the cursor results set if the first row of the new fetch buffer would have been before the first row of the cursor results set and the last row of the new fetch buffer would have stayed within the cursor results set.</li>
<li>
Before the beginning of the cursor results set if all rows of the new fetch buffer are before the first row of the cursor results set, or if any backward fetch (FETCHPREV% or FETCHRELATIVE% with a negative <i>rownum%</i>) is performed when the first row of the current fetch buffer is the first row of the cursor results set.</li>
<li>
After the end of the cursor results set if the first row (and thus all rows) of the new fetch buffer is after the last row of the cursor results set.</li>
</ul>
<p>
When the current cursor position is before the beginning of the cursor, a FETCHNEXT% operation is identical to a FETCHFIRST% operation. When the current cursor position is after the end of the cursor, a FETCHPREV% operation is identical to a FETCHLAST% operation.</p>
<p>
<b>Note</b>  This function works with explicit server cursors in SQL Server 6.0. Do not use both <b>SqlCursorFetchEx%</b> and <b>SqlCursorFetch%</b> with the same server cursor handle. Once one of these functions is used on a specific cursor handle, any attempt to use the other function will return fail (0).</p>
<p>
Each call to <b>SqlCursorFetch%</b> leaves the connection available for use with no pending results.</p>
<h4>See Also</h4>
<p>
<a href="pdvb05_34xh.htm"><b>SqlCursor%</b></a>, <a href="pdvb05_1tbp.htm"><b>SqlCursorColInfo%</b></a>, <a href="pdvb05_8ihx.htm"><b>SqlCursorClose</b></a>, <a href="pdvb05_8cad.htm"><b>SqlCursorInfo%</b></a>, <a href="pdvb05_2f91.htm"><b>SqlCursorOpen%</b></a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
