<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Error 2558</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_error_2558"></a>Error 2558</h1>
<h4>Severity Level 16</h4>
<h4>Message Text</h4>
<pre>Extent not within segment: Object %ld, indid %d includes extents on allocation page %ld which is not in segment %d.
</pre>
<h4>Explanation</h4>
<p>
This error occurs when a portion of a database resides on a segment that was not defined to contain that type of data. The database can still function, possibly generating 1105 errors. There can also be problems with recoverability. Running DBCC CHECKALLOC will find this problem. There are no run-time errors associated with this error.</p>
<p>
Segments are used to map where future allocations of different types of data can occur. By default, when SQL Server creates a database, it creates three segments: a <i>system</i> segment, a <i>default</i> segment, and a <i>log</i> segment.
<ul>
<li>
The <i>system</i> segment allows system tables to be placed on devices that contain the system segment for the database.</li>
<li>
The <i>default</i> segment allows user tables or indexes to be placed on devices that contain the default segment without specifying the ON clause for the database. For example:<pre>CREATE TABLE test (i int) ON segment_1</pre>
</li>
<li>
The <i>log</i> segment allows the transaction log to be placed on devices that contain the log segment for the database.</li>
</ul>
<p>
For example, this statement creates the log segments on the <i>example</i> database:</p>
<pre>create database example
on device_1 = 10
log on device_2 = 2
</pre>
<p>
The <i>system</i> and <i>default</i> segments are mapped to device_1 and the <i>log</i> segment is mapped to device_2. For the <i>example</i> database, all future space allocations for system or user objects occur on device_1, and all transaction log records are placed on device_2. Other databases can use other portions of device_1 or device_2, and these devices can have different segment mappings for that database. More than one segment can be mapped to the same device for a database.</p>
<p>
If system or user objects are located on device_2 or transaction log records are located on device_1, a 2558 error results in the <i>example</i> database. Although several situations can cause a 2558 error, these are the most common:
<ul>
<li>
Loading a database that has different data and log mapping or different user segment definitions than the dumped database.</li>
<li>
Using the <b>sp_placeobject</b> system procedure.</li>
</ul>
<h5>Different data and log mapping</h5>
<p>
If this error occurred after you re-created and loaded a database from a dump, there were probably incorrect entries in the <i>master..sysusages</i> table. A database loaded from a dump must be created in exactly the same way as the database that was dumped. If it isn't, there might be different entries in <i>master..sysusages</i> and error 2558 results. Keep an up-to-date copy of the <i>master..sysusages</i> system table as well as scripts to re-create all databases.</p>
<p>
The resulting <i>master..sysusages</i> entries for the newly created database must be exactly the same as the database that was dumped. If a 2558 error occurs, the error falls into one of two cases:</p>
<p>
<b>Case 1</b>  The data and log mappings on the newly created database do not match the mappings of the dumped database. The database being loaded into was not created in the same way as the database that was dumped.</p>
<p>
This can cause a "data on log" situation, where user or system objects are loaded into a log segment, which results in less log space available to the database. The data is still accessible, but processing might be slowed, if not totally stopped, by the shortage of log space.</p>
<p>
There can also be a "log on data" situation, where portions of the transaction log are loaded into a data segment. This isn't as serious as the "data on log" scenario, because the portion of the transaction log on the data segment is eventually truncated via the DUMP TRANSACTION statement, which frees up the space. All future transaction log allocations will be correctly placed on the log segment.</p>
<p>
Suppose that the above <i>example</i> database was altered as follows:</p>
<pre>alter database example on device_1 = 2
</pre>
<p>
The logical order of the database pages is:
<ul>
<li>
10 MB of data (<i>default</i> and <i>system</i> segments)</li>
<li>
2 MB of log</li>
<li>
2 MB of data</li>
</ul>
<p>
A 2558 error could result if the database were dumped, then dropped and re-created with different segment mappings. For example:</p>
<pre>create database example on device_1 = 12
log on device_2 = 2
</pre>
<p>
Although both ways of creating the database (CREATE and ALTER, or only CREATE) allocate the same amount of data and log space on the same devices, the mapping of data and log space is not the same. Here is an example:</p>
<p>
<img src="images/error01.gif" border=0></p>
<p>
In this example, Database 1 is dumped and loaded into Database 2, resulting in incorrect mapping of data and log space.</p>
<p>
SQL Server DUMP and LOAD statements operate at the logical page level. In this example, logical pages 5120 through 6143 on Database 1 might contain transaction log records but, when loaded on Database 2, they are mapped onto a data segment. Similarly, pages 6144 through 7167 are mapped for data on Database 1, but are mapped for log on Database 2.</p>
<p>
If the 2 MB data segment in this example was completely full on Database 1, there would be absolutely no log space available on Database 2 after the load. Dumping the transaction log at this point would have no effect since the log segment is filled with data.</p>
<p>
All space allocations that occur on Database 2 after the load completes are correctly mapped.</p>
<p>
<b>Case 2</b>  The mapping of user-defined segments in <i>sysusages</i> for the database being loaded does not match the segments of the database that was dumped. This can result from:
<ul>
<li>
Creating user-defined segments in a different order on the database being loaded than on the database that was dumped.</li>
<li>
Dropping user-defined segments on the database that was dumped and not reflecting this change on the database being loaded into.</li>
</ul>
<p>
After you execute a LOAD DATABASE statement with one of these error conditions, the 2558 error exists but is not reported until you run DBCC CHECKALLOC on the loaded database.</p>
<h5>sp_placeobject</h5>
<p>
Error 2558 can also occur if you execute the <b>sp_placeobject</b> system procedure, which places future allocations for a table or index on a particular segment. It does this by updating the <i>sysindexes.segment</i> column to contain the number of the segment where the object was placed.</p>
<p>
This type of 2558 error is due to existing allocations not residing on the segment specified in <b>sp_placeobject</b> and is not related to the segment type. There is no negative impact of this type of 2558 error and you can ignore it. For a procedure to clear the error, see the following section.</p>
<h4>Action</h4>
<p>
The action to correct error 2558 depends on the type of page on which the error occurred. Error 2558 occurs on four types of pages:
<ul>
<li>
Data pages or clustered index pages</li>
<li>
Nonclustered index pages</li>
<li>
Text or image data pages</li>
<li>
System table pages</li>
</ul>
<p>
If you have 2558 errors and cannot re-create the database from scripts or hard copy, use the following table to match the object ID value (<i>Object</i> in the error message) and index ID (<i>indid</i> in the error message) with the corresponding data page type, and then refer to the appropriate section below.</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=34%></th>
<th align=left width=22%></th>
<th align=left width=44%></th>
</tr>
<tr valign=top>
<th align=left width=34%></th>
<th align=left width=22%></th>
<th align=left width=44%></th>
</tr>
<tr valign=top>
<th align=left width=34%>Type of data</th>
<th align=left width=22%>Object ID</th>
<th align=left width=44%>Index ID</th>
</tr>
<tr valign=top>
<td width=34%>Data or clustered index pages</td>
<td width=22%>&gt; 99</td>
<td width=44%>0 or 1</td>
</tr>
<tr valign=top>
<td width=34%>Nonclustered index pages</td>
<td width=22%>&gt; 99</td>
<td width=44%>&gt;1 or &lt; 255</td>
</tr>
<tr valign=top>
<td width=34%>Text or image data pages</td>
<td width=22%>&gt; 99</td>
<td width=44%>255</td>
</tr>
<tr valign=top>
<td width=34%>System table pages</td>
<td width=22%>&lt; 100</td>
<td width=44%></td>
</tr>
</table><br>
<h5>Data pages or clustered index pages</h5>
<p>
The error occurred on the data page or the clustered index of a user table. Resolve the problem as follows:
<ol>
<li>
Create a clustered index on the table. If a clustered index already exists, drop and re-create it. If not, creating one will clear the error. You can then drop the clustered index.</li>
<li>
Copy the data out of the table, drop and re-create the table, and copy the data back in using <b>bcp</b> or SELECT INTO.</li>
</ol>
<h5>Nonclustered index pages</h5>
<p>
The error occurred on the index of a user table. The error can be cleared by dropping and re-creating the index. Creating a clustered index causes all nonclustered indexes to be rebuilt as well. Therefore, if 2558 errors are occurring on several indexes on the same table, you can create a clustered index on that table to clear all these errors.</p>
<h5>Text or image data pages</h5>
<p>
The error occurred on text or image data. Use one of the following methods to correct the situation:
<ul>
<li>
Select all the information from the corrupted table into a new table, drop the corrupted table, and then use <b>sp_rename</b> to rename the new table with the old table name. (Any subsequent DBCC CHECKALLOC statement will continue to show this error until the corrupted table is dropped.)</li>
</ul>
<p>
Or
<ul>
<li>
Copy the table data out using <b>bcp</b> or SELECT INTO, drop and re-create the table, and then copy the contents of the table back in using <b>bcp</b> or SELECT INTO.</li>
</ul>
<p>
Or
<ul>
<li>
Restore the database from a known clean backup.</li>
</ul>
<h5>System table pages</h5>
<p>
The error occurred on a system table. Recover from a known clean backup or contact your primary support provider for assistance.</p>
<h4>Additional Information</h4>
<p>
If this error occurred after re-creating and loading a database from a dump, you can prevent it by ensuring that the entries in the <i>master..sysusages</i> table for the database being loaded match the corresponding entries for the database that was dumped. </p>
<p>
More specifically, the <i>segmap</i>, <i>lstart</i>, and <i>size</i> columns of <i>sysusages</i> must be identical in content and order. Verify this before beginning the LOAD DATABASE statement.</p>
<p>
The entries in <i>sysusages</i> will be correct on the database being loaded into if you execute the following with the same parameters and in the same order as on the dumped database:
<ul>
<li>
CREATE DATABASE</li>
<li>
ALTER DATABASE</li>
<li>
<b>sp_addsegment</b></li>
<li>
<b>sp_dropsegment</b></li>
<li>
<b>sp_extendsegment</b></li>
<li>
<b>sp_MSlogdevice</b></li>
</ul>
<p>
<b>Note</b>  You cannot depend on the output of the <b>sp_helpdb</b> system procedure to compare the contents of the <i>sysusages</i> table because it does not necessarily display rows from <i>sysusages</i> in the actual logical page order. Instead, execute direct SELECT statements against the <i>sysusages</i> table.</p>
<p>
If a substantial number of 2558 errors occur due to an incorrect LOAD DATABASE action, it might be a good idea to drop and correctly re-create the database, and then reload it.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
