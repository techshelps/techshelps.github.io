<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Error 624</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_error_624"></a>Error 624</h1>
<h4>Severity Level 24</h4>
<h4>Message Text </h4>
<pre>Attempt to retrieve row from page via RID failed because the requested RID has a higher number than the last RID on the page. %S_RID.%S_PAGE.
</pre>
<h4>Explanation</h4>
<p>
This error occurs when an attempt to retrieve a row from a data page by specifying the row ID (RID) failed because the requested RID was a higher number than the last RID on the page. This can happen:
<ul>
<li>
During normal processing, if the leaf page of a corrupt nonclustered index points to an incorrect or nonexistent RID on a data page. </li>
<li>
During database recovery, if the data structure that contains the last checkpoint record in the transaction log points to an incorrect or nonexistent record in the log. The database recovery process occurs during startup and when a load database statement executes.</li>
</ul>
<p>
If the error occurs on a system table during a read-only operation while other users are updating system tables (executing DDL), it is probably a transient 624 error (rather than a corrupted index). To confirm that there is no corruption, run DBCC CHECKTABLE.</p>
<h4>Action</h4>
<p>
The recovery procedure depends on when the error occurred. If problems persist, the following procedures might not be sufficient to clean up the index corruption. In this case, contact your primary support provider. Have the output from the appropriate DBCC statements available for review.</p>
<h5>If the error occurred during normal processing</h5>
<p>
For instructions on using the dbcc page statement to determine the table involved, see "Associating a Page with an Object" in Chapter 24, "Additional Problem-solving Techniques." Save this information and use it in the appropriate section below.</p>
<p>
The specific action you take depends on whether or not you know which index and/or query caused the problem. In general, dropping and re-creating the index should resolve the index corruption.</p>
<h5>Index unknown, query known</h5>
<p>
If you do not know which index is causing the problem but you do know which query encounters the problem, follow the instructions below. If you don't know the index or the query, follow the instructions under the next section, "Index and query both unknown."
<ol>
<li>
Determine which index should be dropped by reading the showplan output for the query that encounters the error. If you set SHOWPLAN on, set NO EXECUTE on, and then run the query in question, the output will indicate which nonclustered index the query is using to access the table in question. <p>
For example:
<pre>set showplan on
go
set noexec on
go
select title from titles where title &gt; "Cooking"
go
STEP 1
The type of query is SELECT
FROM TABLE
titles
Nested iteration
Index: titleind</pre>
</li>
<li>
Set NOEXEC off and showplan off again:<pre>set noexec off
go
set showplan off
go</pre>
</li>
<li>
Drop and re-create the index identified in step 1 (in this example, <i>titleind</i>).</li>
</ol>
<h5>Index and query both unknown</h5>
<p>
If you do not know the index or the query, rebuild all nonclustered indexes on the table as follows:
<ol>
<li>
Look at the output you created with dbcc page when you obtained the table name:<ul>
<li>
If the object ID is less than 100, you cannot drop and re-create the indexes. Do not continue with steps 2 or 3. You must restore the database from a known clean backup.</li>
<li>
If the object ID is 100 or greater, continue with step 2.</li>
</ul>
</li>
<li>
Use <b>sp_helpindex</b> to list all indexes on the table, and then rebuild all the nonclustered indexes using one of the following methods:<ul>
<li>
Drop and re-create each nonclustered index on the table. </li>
<li>
If the table has a clustered index, drop and re-create it. This causes all nonclustered indexes to be rebuilt automatically. If your table is large, you might not have the space to do this. Generally, 120 percent of your table size must be available. </li>
</ul>
</li>
<li>
After the appropriate index has been re-created, run dbcc checktable on the table to confirm that the problem has been resolved. </li>
</ol>
<h5>If the error occurred during database recovery</h5>
<p>
When this error occurs during recovery, the database is marked "suspect" and is not accessible. In this case, you usually need to load the database from a known clean backup, as follows:
<ol>
<li>
Drop the suspect database using the instructions in Chapter 24, "Additional Problem-solving Techniques."</li>
<li>
Create a database to receive the load using the CREATE DATABASE statement.</li>
<li>
Load the database from a backup using the load database statement.</li>
</ol>
<p>
For information about using the CREATE DATABASE and LOAD DATABASE statements, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
