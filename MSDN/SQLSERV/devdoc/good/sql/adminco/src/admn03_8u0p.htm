<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>More About Memory</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_more_about_memory"></a>More About Memory</h3>
<p>
This topic discusses the amount of memory that should be allocated to SQL Server in various machine memory configurations.</p>
<p>
Microsoft Windows NT provides each Win32 application a 4-GB virtual address<b> </b>space, the lower 2 GB of which is private per process and available for<b> </b>application use. The upper 2 GB is reserved for system use.</p>
<p>
The 4-GB address space is mapped to the available physical memory by the Windows NT<b> </b>Virtual Memory Manager (VMM). The available physical memory can be up to 4<b> </b>GB, depending on hardware platform support.</p>
<p>
A Win32 application such as SQL Server only perceives virtual or logical<b> </b>addresses, not physical addresses. How much physical memory an application<b> </b>uses at a given time (the working set) is determined by available physical<b> </b>memory and the VMM. The application cannot directly control memory residency.</p>
<p>
Virtual address systems such as Windows NT allow the over committing of<b> </b>virtual memory, such that the ratio of virtual to physical memory exceeds<b> </b>1:1. As a result, larger programs can run on machines with a variety of<b> </b>physical memory configurations. However, in most cases, using significantly<b> </b>more virtual memory than the combined average working sets of all the<b> </b>processes will result in poor performance.</p>
<p>
For better performance, SQL Server "locks" memory and <i>tempdb</i> (if using <b>tempdb in ram</b>) as a working set. Because of this, it is possible for you to receive "out of memory" errors when running other applications. The <b>set working set size</b> parameter (set with <b>sp_configure</b> or SQL Enterprise Manager) can disable the "locking" of memory as a working set. If "out of memory" errors occur, you may have too much memory assigned to SQL Server.</p>
<p>
Configuring SQL Server for more virtual memory than there is physical memory can result in poor performance. Also, the Windows NT<b> </b>operating system memory requirement must be considered (about 12 MB with<b> </b>some variation depending on application-induced overhead). This system overhead requirement can grow as SQL Server parameters are configured upward and Windows NT needs more resident memory to support such things as additional threads, page<b> </b>tables, and so on.</p>
<p>
This results in a varying amount of memory that can be given to SQL Server,<b> </b>depending on the machine memory configuration. The following table presents<b> </b>a rough figure of this and assumes a dedicated database server. If the<b> </b>machine is shared between multiple uses, such as a file server, a database<b> </b>server, and a client workstation, less memory should be given to SQL Server<b> </b>and more left for the operating system and other uses.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%></th>
<th align=left width=72%></th>
</tr>
<tr valign=top>
<th align=left width=28%>Machine <br>
memory (MB)</th>
<th align=left width=72%>Approximate SQL Server <br>
memory allocation (MB)</th>
</tr>
<tr valign=top>
<td width=28%>16</td>
<td width=72%>4</td>
</tr>
<tr valign=top>
<td width=28%>24</td>
<td width=72%>8</td>
</tr>
<tr valign=top>
<td width=28%>32</td>
<td width=72%>16</td>
</tr>
<tr valign=top>
<td width=28%>48</td>
<td width=72%>28</td>
</tr>
<tr valign=top>
<td width=28%>64</td>
<td width=72%>40</td>
</tr>
<tr valign=top>
<td width=28%>128</td>
<td width=72%>100</td>
</tr>
<tr valign=top>
<td width=28%>256</td>
<td width=72%>216</td>
</tr>
<tr valign=top>
<td width=28%>512</td>
<td width=72%>464</td>
</tr>
</table><br>
<p>
<b>Note</b>  These are only rough figures and are presented to give an approximate<b> </b>idea of SQL Server memory allocation over different memory states. For more<b> </b>information, you can use the many monitoring features of SQL Performance Monitor to<b> </b>determine your system memory behavior. Another good source of information is<b> </b><i>Optimizing Windows NT</i>, from the Windows NT Resource Kit, which devotes nearly 600 pages to various<b> </b>aspects of monitoring and optimizing Windows NT and Win32 applications.</p>
<p>
16 MB is the minimum available memory for SQL Server on Intel-based computers. SQL Server on Alpha AXP- and MIPS-based computers will require more memory because of the<b> </b>average lower density of RISC machine instructions. However, considering<b> </b>the overall software, hardware, application, and personnel investment in<b> </b>typical client/server systems, adding more memory is usually a wise (and by<b> </b>comparison inexpensive) investment. Many sites report that 32 MB is a good<b> </b>starting point, and it is not uncommon for servers to be configured for<b> </b>128 MB or more memory, which they put to beneficial use.</p>
<p>
The point at which additional memory fails to provide worthwhile benefits<b> </b>is entirely situation-dependent and is determined primarily by the<b> </b>locality of reference of the database accesses. The important point to<b> </b>remember is that memory increases that are small as a percentage of total<b> </b>memory rarely afford any significant benefit. Two things control this<b> </b>point: 
<ul>
<li>
SQL Server uses extra memory primarily as buffer cache</li>
<li>
Most cache<b> </b>hit ratio studies indicate a fairly flat curve beyond several megabytes</li>
</ul>
<p>
For this reason, whether 14 MB, 16 MB, or 18 MB is given<b> </b>to SQL Server on a 32 MB computer will rarely make a significant difference in SQL performance.<b> </b>Conversely, attempting to crowd Windows NT by giving excessive memory to<b> </b>SQL Server can result in poor performance because of excessive paging.</p>
<p>
The implication is that you should add physical memory to the machine in<b> </b>significant amounts before allocating this to SQL Server. Whether adding memory<b> </b>will be beneficial should be studied beforehand. The easiest way to<b> </b>determine this is by using SQL Performance Monitor to check the SQL Server cache hit ratio while the system is under a typical load. If the hit ratio is relatively<b> </b>high (over 90%), adding more memory will usually not be beneficial. This is<b> </b>because additional memory can mainly be used for additional SQL Server data<b> </b>cache, thereby increasing the hit ratio. In this case, the hit ratio is<b> </b>already high, and the maximum available improvement quite small.</p>
<p>
If the hit ratio is consistently lower than this, adding more memory may<b> </b>improve the hit ratio (and thereby performance) if the locality of reference<b> </b>is such that it can be bracketed by economically or technically feasible<b> </b>amounts of memory.</p>
<p>
For more information about SQL Performance Monitor, see Chapter 19, <a href="admn19_3vs5.htm">Monitoring Server Activity and Performance</a>. </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
