<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>The update mode is deferred</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_the_update_mode_is_deferred"></a>The update mode is deferred</h2>
<p>
There are two methods, or <i>modes</i>, that SQL Server can use to perform update operations such as INSERT, DELETE, UPDATE, and SELECT INTO. These methods are called <i>deferred update</i> and <i>direct update</i>. When the deferred method is used, the changes are applied to all rows of the table by making log records in the transaction log to reflect the old and new value of the column(s) being modified (in the case of UPDATE operations), or the values that will be inserted or deleted (in the case of INSERT and DELETE, respectively).</p>
<p>
When all the log records have been constructed, the changes are then applied to the data pages. This method may generate more log records than a direct update (discussed later in this chapter), but it has the advantage of allowing the execution of statements that might cascade changes throughout a table.</p>
<p>
For example, consider a table that has a fixed-length column <i>col1</i> with a unique index on it and data values numbered consecutively from 1 through 100 in that column. Assume that an UPDATE statement is executed to increase the value in each row by 1:</p>
<h4>Query 1:</h4>
<pre>UPDATE Mytable
SET col1 = col1  1
</pre>
<h4>SHOWPLAN 1:</h4>
<pre>STEP 1
The type of query is UPDATE
The update mode is deferred
FROM TABLE
Mytable
Nested iteration
Table Scan
TO TABLE
Mytable
</pre>
<p>
Consider the consequences of starting at the first row in the table and updating each row, through the end of the table. Updating the first row (which has an initial value of 1) to 2 would cause an error because the unique index would be violated (there is already a value of 2 in the table); similarly, updating the second row (which has an initial value of 2) to 3 would also cause a unique key violation, as would all rows through the end of the table, except for the last row. By using deferred updates, this problem is easily avoided. The log records are first constructed to show what the new values for each row will be, the existing rows are deleted, and then the new values inserted.</p>
<p>
As with UPDATE statements, INSERT statements can also be deferred for similar reasons. Consider the following query (there is no clustered index or unique index on the <i>Mytable2 </i>table):</p>
<h4>Query 2:</h4>
<pre>INSERT Mytable2 SELECT * FROM Mytable2
</pre>
<h4>SHOWPLAN 2:</h4>
<pre>STEP 1
The type of query is INSERT
The update mode is deferred
FROM TABLE
Mytable2
Nested iteration
Table Scan
TO TABLE
Mytable2
</pre>
<p>
Because there is no clustered index on the table, the new rows will be added to the end of the table. The query processor needs to be able to differentiate between the existing rows that are currently in the table (prior to the INSERT statement) and the rows that will be inserted, so as to not get into a continuous loop of selecting a row, inserting it at the end of the table, selecting the row just inserted, and re-inserting it.</p>
<p>
By using the deferred method of inserting, the log records can first be constructed to show all the existing values in the table, and then SQL Server will re-read those log records to insert them into the table.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
