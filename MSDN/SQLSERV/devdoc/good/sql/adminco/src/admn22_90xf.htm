<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Detecting Long-running Transactions</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_detecting_long.2d.running_transactions"></a>Detecting Long-running Transactions</h1>
<p>
In some instances, a single long-running transaction can prevent the log from being truncated. These transactions are usually a result of application errors or badly formed queries. It is important to detect the presence of these transactions and act accordingly. Otherwise, the transaction log eventually fills up, even if DUMP TRANSACTION statements have been executed.</p>
<p>
The easiest way to detect a long-running transaction is by using DBCC OPENTRAN, which displays information on the oldest active transaction and the oldest distributed and nondistributed replicated transactions, if any, within the specified database. Using the WITH TABLERESULTS option, you can insert the results into a table for easy comparison.</p>
<p>
DBCC OPENTRAN is extremely useful in determining whether or not an open transaction exists within the log. When using the DUMP TRANSACTION statement, only the inactive portion of the log can be truncated, so an open transaction could cause the log not to be truncated completely. In earlier versions of SQL Server, all users needed to log off or the server needed to be shut down and restarted to clear the uncommitted transactions from the log. With DBCC OPENTRAN, an open transaction can be identified (the <i>spid</i>, system process ID taken from the <b>sp_who </b>system stored procedure output, is returned) and terminated, if necessary.</p>
<p>
After this condition has been detected, your knowledge of any applications using the database can tell you whether or not it represents a problem. For example, suppose that the longest running transaction on a database takes an average of 2 minutes and that the log could not be purged over a 5-minute interval. The average of 2 minutes might have been exceeded because of computer load or SQL Server load, so there is a good chance that no problem exists. </p>
<p>
A problem might exist if the log repeatedly fails to be purged over a long period of time, perhaps after several DUMP TRANSACTION statements. This problem can result from any of the following:
<ul>
<li>
A badly formed query that might run for many hours (for example, a query with an incorrectly specified join that results in a Cartesian product)</li>
<li>
An application error that starts a transaction but never completes it</li>
<li>
An operating-system, network, or SQL Server error</li>
<li>
A hardware problem</li>
</ul>
<p>
If the blocking transaction is due to a runaway query and the transaction has been identified, use the KILL statement to stop the process. This clears the transaction and allows the log to be truncated. For additional information about stopping processes, see Chapter 24, "Additional Problem-Solving Techniques."</p>
<p>
If the KILL statement cannot stop the process, you must restart SQL Server to resolve the problem. Restarting SQL Server causes the database to go through normal recovery, so any outstanding transactions are either committed or rolled back. </p>
<p>&nbsp;</p></body>
</HTML>
