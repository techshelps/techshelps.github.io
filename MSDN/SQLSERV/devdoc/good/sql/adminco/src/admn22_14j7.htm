<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Mass Updates</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_mass_updates"></a>Mass Updates</h2>
<p>
The following SQL statement updates every row in the table <i>large_tab</i>:</p>
<pre>update large_tab set col1 = 0</pre>
<p>
Each individual row update resulting from this statement is part of one transaction. If <i>large_tab</i> is a large table, this statement results in extensive logging, which can fill the transaction log before it completes, and results in the 1105 error (which indicates that the transaction log is full). If the transaction log is filled before the statement completes, the portion of the transaction that was processed is rolled back. This process can require significant time and server resources.</p>
<p>
In addition to causing excessive logging, unnecessarily large transactions have disadvantages in terms of both the number and the type of locks held as a result. For example, an exclusive table lock is usually acquired for a mass update to reduce locking overhead and complete it as soon as possible, and this type of lock prevents all other users from modifying the table during the update.</p>
<p>
You can sometimes avoid problems associated with mass updates by breaking up large transactions into several smaller ones and then executing DUMP TRANSACTION statements between the different parts. For example, the single update statement in the previous example could be broken into two or more pieces as follows:</p>
<pre>update large_tab set col1 = 0 
where col2 &lt; x
go
dump transaction database_name with truncate_only 
go

update large_tab set col1 = 0
where col2 &gt;= x
go

dump transaction database_name with truncate only
go
</pre>
<p>
In this example, <i>x</i> is a value selected so that about half the rows in the table meet the condition <i>col2</i>  &lt;  <i>x</i> and the remaining rows meet the condition <i>col2</i>  &gt;=  <i>x</i>.</p>
<p>
Transaction logs saved for media failure recovery should be dumped to a device, and the WITH TRUNCATE_ONLY option of the DUMP TRANSACTION statement should not be used. After you execute a DUMP TRANSACTION WITH TRUNCATE_ONLY statement, you must dump the database before you can dump the transaction log to a device.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
