<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Trace Flags</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_using_trace_flags"></a>Using Trace Flags</h1>
<p>
SQL Server trace flags provide additional information about SQL Server operations or change certain behaviors, usually for backward compatibility. In general, trace flags should be used to temporarily work around a problem until a permanent solution is put in place. Although the information provided by trace flags can help you diagnose problems, keep in mind that <i>trace flags are not part of the supported feature set</i>. This means that future compatibility or continued use is not assured. In addition, your primary support provider, including Microsoft, will usually not have further information and will not answer questions regarding the trace flags or their output. In other words, the information provided in this section is to be used "as is."</p>
<p>
<b>Caution</b>  It is generally recommended that you use trace flags only when directed by your primary support provider or by this chapter. Beware against experimenting with trace flags not documented here. They can cause unexpected and potentially serious problems.</p>
<p>
Trace Flags are used to temporarily set a specific server characteristic. Trace flags can be activated through three methods: by using the DBCC statement, with the <b>-T </b>option with the <b>sqlservr</b> command-line executable, or in <b>setup</b>. Once set, and trace flags are in effect only until reset (for options set with the DBCC statement) or until the server is stopped and restarted without the trace flag. For details, see the Trace Flags topic, the Utilities topic, and the DBCC statement in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<p>
These are the trace flags available in SQL Server 6.0. Trace flags noted with an asterisk (*) are for information only. Others are used to change program behavior.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=23%></th>
<th align=left width=77%></th>
</tr>
<tr valign=top>
<th align=left width=23%></th>
<th align=left width=77%></th>
</tr>
<tr valign=top>
<th align=left width=23%>Trace flag</th>
<th align=left width=77%>Description</th>
</tr>
<tr valign=top>
<td width=23%> - 1</td>
<td width=77%>Sets trace flags for all client connections, rather than for a single client connection. Because trace flags set using the<b> -T</b> command-line option (with <b>sqlservr</b>) automatically apply to all connections, this trace flag is used only when setting trace flags using DBCC TRACEON and DBCC TRACEOFF. For details, see the <b>sqlservr</b> command-line executable and DBCC statement in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</td>
</tr>
<tr valign=top>
<td width=23%>106*</td>
<td width=77%>Disables line number information for syntax errors.</td>
</tr>
<tr valign=top>
<td width=23%>107</td>
<td width=77%>Interprets numbers with a decimal point as <i>float </i>instead of <i>decimal</i>. For details, see the Datatypes topic in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</td>
</tr>
<tr valign=top>
<td width=23%>204</td>
<td width=77%>Generally, allows non-ANSI-standard behavior for various features for backward compatibility with earlier version of SQL Server:<p>
Allows queries that contain aggregates or a GROUP BY clause to have items in the select list that are not in the GROUP BY clause and are not aggregate functions. ANSI-standard SQL does not allow this.</p>
<p>
Ignores trailing blanks in the LIKE pattern. For details, see the Search Conditions and Wildcard Characters topics in the <i>Microsoft SQL Server Transact-SQL Reference</i>. </p>
</td>
</tr>
<tr valign=top>
<td width=23%>206</td>
<td width=77%>Provides backward compatibility for the SETUSER statement. For details, see the SETUSER statement.</td>
</tr>
<tr valign=top>
<td width=23%>242</td>
<td width=77%>Provides backward compatibility for correlated subqueries where non-ANSI-standard results are desired.</td>
</tr>
<tr valign=top>
<td width=23%>243</td>
<td width=77%>Provides backward compatibility for nullability behavior. When set, SQL Server has the same nullability violation behavior as that of a 4.2 server:<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Processing of the entire batch will be terminated if <br>
&nbsp;&nbsp;&nbsp;&nbsp;the nullability error (for example, inserting NULL into<br>
&nbsp;&nbsp;&nbsp;&nbsp;a NOT NULL field) can be detected at compile time.<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Processing of the offending row will be skipped, <br>
&nbsp;&nbsp;&nbsp;&nbsp;but the command will continue if the nullability <br>
&nbsp;&nbsp;&nbsp;&nbsp;violation is detected at run time.<br>
<br>
The behavior of SQL Server 6.0 is now more consistent ¾ all nullability checks are made at run time and a nullability violation results in the command terminating but the batch/transaction continuing to process.</td>
</tr>
<tr valign=top>
<td width=23%>244</td>
<td width=77%>Disables checking for allowed interim constraint violations. By default, SQL Server checks for and allows interim constraint violations. An interim constraint violation is caused by a change that initially violates a constraint, followed by another change that removes the violation such that the constraint is met, all within a single statement and transaction. SQL Server checks for interim constraint violations for self-referencing DELETE statements, INSERT statements based on a SELECT, and multi-row UPDATE statements. This checking requires more work tables. With this trace flag you can disallow interim constraint violations, thus requiring fewer work tables.</td>
</tr>
<tr valign=top>
<td width=23%>302*</td>
<td width=77%>Prints information about whether the statistics page is used, the actual selectivity (if available), and what SQL Server estimated the physical and logical I/O would be for the indexes. Trace flag 302 should be used with trace flag 310 to show the actual join ordering.</td>
</tr>
<tr valign=top>
<td width=23%>310*</td>
<td width=77%>Prints information about join order. Index selection information is also available in a more readable format using SET SHOWPLAN ON, as described in the SET statement.</td>
</tr>
<tr valign=top>
<td width=23%>325*</td>
<td width=77%>Prints information about the cost of using a nonclustered index or a sort to process an ORDER BY clause.</td>
</tr>
<tr valign=top>
<td width=23%>326*</td>
<td width=77%>Prints information about the estimated and actual cost of sorts.</td>
</tr>
<tr valign=top>
<td width=23%>652</td>
<td width=77%>Disables read ahead for the server.</td>
</tr>
<tr valign=top>
<td width=23%>653</td>
<td width=77%>Disables read ahead for the current connection.</td>
</tr>
<tr valign=top>
<td width=23%>1200*</td>
<td width=77%>Prints lock information (the process ID and type of lock requested).</td>
</tr>
<tr valign=top>
<td width=23%>1204*</td>
<td width=77%>Returns the type of locks participating in the deadlock and the current command affected.</td>
</tr>
<tr valign=top>
<td width=23%>1205*</td>
<td width=77%>Returns detailed information about the commands being executed at the time of a deadlock.</td>
</tr>
<tr valign=top>
<td width=23%>1609</td>
<td width=77%>Turns on the unpacking and checking of RPC information with the execution of the <b>sp_sqlexec</b> extended stored procedure in Open Data Services. Use this flag only when applications depend on the old behavior. The application should be changed to use EXECUTE <i>sql_string </i>rather than <b>sp_sqlexec</b>. For details, see the EXECUTE statement in the <i>Microsoft SQL Server Transact-SQL Reference</i>.</td>
</tr>
<tr valign=top>
<td width=23%>1704</td>
<td width=77%>Prints information when a temporary table is created or dropped.</td>
</tr>
<tr valign=top>
<td width=23%>3502*</td>
<td width=77%>Prints a message to the log at the start and end of each checkpoint.</td>
</tr>
<tr valign=top>
<td width=23%>3205</td>
<td width=77%>By default, if a tape drive supports hardware compression, the DUMP statement will use it. With this trace flag, you can disable hardware compression for tape drives. This might be useful when you want to exchange tapes with other sites or tape drives that do not support compression.</td>
</tr>
<tr valign=top>
<td width=23%>3503*</td>
<td width=77%>Indicates whether the checkpoint at the end of automatic recovery was skipped for a database (this applies only to read-only databases). For details, see the <b>sp_dboption </b>system stored procedure.</td>
</tr>
<tr valign=top>
<td width=23%>3604*</td>
<td width=77%>Sends trace output to the client. ( ) This trace flag is used only when setting trace flags with DBCC TRACEON and DBCC TRACEOFF.</td>
</tr>
<tr valign=top>
<td width=23%>3605*</td>
<td width=77%>Sends trace output to the error log. (If you start SQL Server from the command line, the output will also appear on the screen.)</td>
</tr>
<tr valign=top>
<td width=23%>3607</td>
<td width=77%>Skips automatic recovery (at startup) for all databases.</td>
</tr>
<tr valign=top>
<td width=23%>3608</td>
<td width=77%>Skips automatic recovery (at startup) for all databases except the <i>master </i>database.</td>
</tr>
<tr valign=top>
<td width=23%>3609</td>
<td width=77%>Skips the creation of the <i>tempdb</i> database at startup. Use this trace flag if the device or devices on which <i>tempdb </i>resides are problematic or problems exist in the <i>model </i>database.</td>
</tr>
<tr valign=top>
<td width=23%>3640</td>
<td width=77%>Eliminates the sending of DONE_IN_PROC messages to the client for each statement in a stored procedure. This is similar to the session setting NOCOUNT, but when set as a trace flag every client session is handled this way. For details, see the SET statement.</td>
</tr>
<tr valign=top>
<td width=23%>4022</td>
<td width=77%>Skips the execution of all startup stored procedures. For more information, see the CREATE PROCEDURE statement and the <b>sp_makestartup </b>system stored procedure.</td>
</tr>
<tr valign=top>
<td width=23%>4030*</td>
<td width=77%>Prints both a byte and ASCII representation of the receive buffer. This trace flag is usually used when you need to see what queries a client is sending to SQL Server. You might use this trace flag if you experience a protection violation and need to determine which statement caused it. Typically, you would set this flag globally. You can also use DBCC INPUTBUFFER. For details, see the DBCC statement.</td>
</tr>
<tr valign=top>
<td width=23%>4031*</td>
<td width=77%>Prints both a byte and ASCII representation of the send buffers (what SQL Server sends back to the client). You can also use DBCC OUTPUTBUFFER. For details, see the DBCC statement.</td>
</tr>
<tr valign=top>
<td width=23%>4032*</td>
<td width=77%>Prints only an ASCII representation of the receive buffer. Usually used in place of trace flag 4030 (if trace output speed is important) when you need to see what queries a client is sending to SQL Server.</td>
</tr>
</table><br>
<p>
Unlike the other trace flags, the trace flag  - 1 activates tracing only in processes that were open when the DBCC TRACEON ( - 1) statement was issued. Because new connections are <i>not</i> traced, you should periodically set the  - 1 trace flag using DBCC TRACEON ( - 1) if you want to pick up new connections.</p>
<p>
Setting trace flags using DBCC TRACEON ( - 1) differs from using the <b>-T</b> command-line option (as described in "Starting SQL Server with Trace Flags," later in this chapter):
<ul>
<li>
You can invoke trace flags globally on a production server without shutting down SQL Server.</li>
<li>
If you know a particular problem tends to occur during a certain period in the day, you can invoke the trace flag globally at that time (and avoid filling up the error log with irrelevant data from startup).</li>
</ul>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
