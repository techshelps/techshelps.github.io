<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Ownership Chains</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="_ownership_chains"></a>Ownership Chains</h3>
<p>
Views can depend on other views and/or tables. Procedures can depend on other procedures, views, and/or tables. These dependencies can be thought of as an ownership chain.</p>
<p>
Typically, the owner of a view also owns its underlying objects (other views and tables), and the owner of a stored procedure often owns all the procedures, tables, and views that the procedure references. Also, a view and its underlying objects are usually all in the same database, as are a stored procedure and all the objects it references.</p>
<p>
For efficiency, when a user with permission to access a view does so, SQL Server does not check permissions on any of the view's underlying objects if these objects and the view are all owned by the same user, and if the view and all its underlying objects are in the same database.</p>
<p>
Similarly, if the same user owns a stored procedure and all the views or tables it references, and if the procedure and the objects it references are all in the same database, SQL Server checks only the permissions on the procedure.</p>
<p>
However, if the ownership chain of a procedure or view is broken – that is, if not all the objects in the chain are owned by the same user – SQL Server checks permissions on each object in the chain whose next lower link is owned by a different user. In this way, SQL Server allows the owner of the original data to retain control over who is authorized to access it.</p>
<p>
Ordinarily, a user who creates a view only has to grant permissions on that view. For example, say Mary has created a view called <i>auview1</i> on the <i>authors</i> table, which she also owns. If Mary grants Sue permission to use <i>auview1</i>, SQL Server will let Sue access it without checking permissions on <i>authors</i>.</p>
<p>
However, a user who creates a view or stored procedure that depends on an object owned by another user must be aware that any permissions he or she grants depend on the permissions allowed by those other owners.</p>
<p>
For example, Joe creates a view called <i>auview2</i>, which depends on Mary's view <i>auview1</i>. Joe grants Sue permission to use <i>auview2</i>. The object owner is given in parentheses after the object name:</p>
<p>
<img src="images/14_1.gif" border=0></p>
<p>
SQL Server checks the permissions on <i>auview2</i> and <i>auview1</i> and finds that Sue is allowed to use them.</p>
<p>
SQL Server performs no authorization checks at the time the view is created but performs authorization checks when the view is used. In fact, if Joe has permission on the CREATE VIEW statement, he can define a view based on the <i>authors</i> table even if he does not have SELECT permission on <i>authors</i>. However, the view would be useless to everyone, including Joe.</p>
<p>
Taking this example a step further, suppose that Joe's view, <i>auview2</i>, depends on <i>auview1</i>, which depends on <i>authors</i>. Mary decides that she likes Joe's <i>auview2</i> and creates <i>auview3</i> on top of it. As you may recall, both <i>auview1</i> and <i>authors</i> are owned by Mary. The situation can be depicted like this, with the object owner given in parentheses after the object name:</p>
<p>
<img src="images/14_2.gif" border=0></p>
<p>
When Sue tries to access <i>auview3</i>, SQL Server checks permissions on <i>auview3</i>, <i>auview2</i>, and <i>auview1</i>. If Joe has granted Sue access on <i>auview2</i> and Mary has granted her permission on <i>auview3</i> and <i>auview1</i>, SQL Server allows the access. SQL Server checks permissions only if the object immediately before it in the chain has a different owner (or if it is the first object in the chain). For example, it checks <i>auview2</i> because the object before it – <i>auview3</i> – is owned by a different user. It does not check permission on <i>authors</i> because the object which immediately depends on it, <i>auview1</i>, is owned by the same user.</p>
<p>
Procedures follow the same rules. As an example, suppose the situation is this:</p>
<p>
<img src="images/14_3.gif" border=0></p>
<p>
To execute P4, Sue must have permission to execute P4, P2, and P1. Permission to execute P3 is not necessary, since P3 and P4 have the same owner.</p>
<p>
SQL Server checks Sue's permissions on P4 and all objects it references each time she executes P4. However, SQL Server knows which referenced objects to check because it has determined this the first time Sue executes P4 and has saved this information with the procedure's execution plan. Unless one of the objects referenced by the procedure is dropped or otherwise redefined, SQL Server sticks with its initial decision about which objects to check.</p>
<p>
The following illustration shows a situation in which procedures and views owned by two different users depend on each other in a fairly complex way.</p>
<p>
<img src="images/fig7_2.gif" border=0></p>
<p>
If a user tries to execute <i>procedure1</i>, SQL Server checks permissions on <i>procedure1</i>, <i>procedure3</i>, <i>view2</i>, <i>table2</i>, and <i>table3</i>.</p>
<p>
In summary, the purpose of this permission hierarchy is to allow every object's owner to fully control access to the object. Owners can control access to views and stored procedures, as well as to tables.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
