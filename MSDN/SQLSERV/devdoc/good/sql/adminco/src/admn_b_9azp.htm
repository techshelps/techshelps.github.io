<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Appendix B   Estimating Database Size</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_estimating_database_size"></a>Estimating Database Size</h1>
<p>
This appendix contains formulas and examples that show how to estimate the size of tables and indexes in a database. </p>
<p>
The following examples are used:
<ul>
<li>
Calculating the size of a 9,000,000-row table with a clustered index.</li>
<li>
Calculating the size of a 9,000,000-row table with a nonclustered index.</li>
</ul>
<p>
Since the amount of overhead in tables containing variable-length fields is greater, two sets of formulas are presented in each example ¾ one for fixed-length fields and one for variable-length fields.</p>
<p>
To calculate the size of a database, add the number of bytes of data and associated overhead and divide that number by the number of bytes available on a data page. Each 2K data page uses 32 bytes of overhead, so there are 2016 (2048 - 32) bytes available for data on each data page.</p>
<p>
For best accuracy, round down divisions that calculate the number of rows per page, and round up divisions that calculate the number of pages.</p>
<p>
If you are using FILL FACTOR in your CREATE INDEX statement, it will change some of the equations. For more information, see <a href="admn_b_5svn.htm">Other Factors</a>, later in this appendix.</p>
<p>
If a table includes <i>text</i> or <i>image</i> datatypes, use 16K (the size of the text pointer that is stored in the row) as indicated in the following examples, and see <a href="admn_b_6ilv.htm">Using Average Sizes for text/image Data Pages</a>, later in this appendix.</p>
<p>
The following are the storage sizes for SQL Server datatypes:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=21%></th>
<th align=left width=79%></th>
</tr>
<tr valign=top>
<th align=left width=21%></th>
<th align=left width=79%></th>
</tr>
<tr valign=top>
<th align=left width=21%>Datatype</th>
<th align=left width=79%>Size</th>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=79%></td>
</tr>
<tr valign=top>
<td width=21%></td>
<td width=79%></td>
</tr>
<tr valign=top>
<td width=21%><i>char</i></td>
<td width=79%>Defined size</td>
</tr>
<tr valign=top>
<td width=21%><i>varchar</i></td>
<td width=79%>Data size</td>
</tr>
<tr valign=top>
<td width=21%><i>binary</i></td>
<td width=79%>Defined size</td>
</tr>
<tr valign=top>
<td width=21%><i>varbinary</i></td>
<td width=79%>Data size</td>
</tr>
<tr valign=top>
<td width=21%><i>int</i></td>
<td width=79%>4</td>
</tr>
<tr valign=top>
<td width=21%><i>smallint</i></td>
<td width=79%>2</td>
</tr>
<tr valign=top>
<td width=21%><i>tinyint</i></td>
<td width=79%>1</td>
</tr>
<tr valign=top>
<td width=21%><i>float</i></td>
<td width=79%>8</td>
</tr>
<tr valign=top>
<td width=21%><i>float(b)</i></td>
<td width=79%>4 (for precision of 1-7), 8 (for precision of 8-15)</td>
</tr>
<tr valign=top>
<td width=21%><i>double precision</i></td>
<td width=79%>8</td>
</tr>
<tr valign=top>
<td width=21%><i>real</i></td>
<td width=79%>4</td>
</tr>
<tr valign=top>
<td width=21%><i>money</i></td>
<td width=79%>8</td>
</tr>
<tr valign=top>
<td width=21%><i>smallmoney</i></td>
<td width=79%>4</td>
</tr>
<tr valign=top>
<td width=21%><i>datetime</i></td>
<td width=79%>8</td>
</tr>
<tr valign=top>
<td width=21%><i>smalldatetime</i></td>
<td width=79%>4</td>
</tr>
<tr valign=top>
<td width=21%><i>bit</i></td>
<td width=79%>1</td>
</tr>
<tr valign=top>
<td width=21%><i>decimal</i></td>
<td width=79%>2-17 bytes, depending on precision (see the following table)</td>
</tr>
<tr valign=top>
<td width=21%><i>numeric</i></td>
<td width=79%>2-17 bytes, depending on precision (see the following table)</td>
</tr>
<tr valign=top>
<td width=21%><i>text</i></td>
<td width=79%>16 bytes + 2K per initialized column</td>
</tr>
<tr valign=top>
<td width=21%><i>image</i></td>
<td width=79%>16 bytes + 2K per initialized column</td>
</tr>
<tr valign=top>
<td width=21%><i>timestamp</i></td>
<td width=79%>8</td>
</tr>
</table><br>
<p>
<b>Note</b>  Any columns defined to accept NULL values must be considered variable-length columns, since they involve the overhead associated with the variable-length columns.</p>
<p>
The <i>decimal</i> and <i>numeric</i> datatypes have a maximum precision of 38. Based on the precision specified, a length is computed and used as the size of the array to store the datatype. The following table shows the mapping from precision to length.</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=24%></th>
<th align=left width=76%></th>
</tr>
<tr valign=top>
<th align=left width=24%></th>
<th align=left width=76%></th>
</tr>
<tr valign=top>
<th align=left width=24%>Precision</th>
<th align=left width=76%>Size (bytes)</th>
</tr>
<tr valign=top>
<td width=24%></td>
<td width=76%></td>
</tr>
<tr valign=top>
<td width=24%></td>
<td width=76%></td>
</tr>
<tr valign=top>
<td width=24%>0 - 2</td>
<td width=76%>2</td>
</tr>
<tr valign=top>
<td width=24%>3 - 4</td>
<td width=76%>3</td>
</tr>
<tr valign=top>
<td width=24%>5 - 7</td>
<td width=76%>4</td>
</tr>
<tr valign=top>
<td width=24%>8 - 9</td>
<td width=76%>5</td>
</tr>
<tr valign=top>
<td width=24%>10 - 12</td>
<td width=76%>6</td>
</tr>
<tr valign=top>
<td width=24%>13 - 14</td>
<td width=76%>7</td>
</tr>
<tr valign=top>
<td width=24%>15 - 16</td>
<td width=76%>8</td>
</tr>
<tr valign=top>
<td width=24%>17 - 19</td>
<td width=76%>9</td>
</tr>
<tr valign=top>
<td width=24%>20 - 21</td>
<td width=76%>10</td>
</tr>
<tr valign=top>
<td width=24%>22 - 24</td>
<td width=76%>11</td>
</tr>
<tr valign=top>
<td width=24%>25 - 26</td>
<td width=76%>12</td>
</tr>
<tr valign=top>
<td width=24%>27 - 28</td>
<td width=76%>13</td>
</tr>
<tr valign=top>
<td width=24%>29 - 31</td>
<td width=76%>14</td>
</tr>
<tr valign=top>
<td width=24%>32 - 33</td>
<td width=76%>15</td>
</tr>
<tr valign=top>
<td width=24%>34 - 36</td>
<td width=76%>16</td>
</tr>
<tr valign=top>
<td width=24%>37 - 38</td>
<td width=76%>17</td>
</tr>
</table><br>
<p>
All calculations in the following examples are based on the maximum size for <i>varchar</i> and <i>varbinary</i> data ¾ the defined size of the columns. They also assume that columns were defined as NOT NULL. If you want to use average values for variable-length columns, see <a href="admn_b_4uib.htm">Using Average Sizes for Variable Fields</a>, later in this appendix. </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
