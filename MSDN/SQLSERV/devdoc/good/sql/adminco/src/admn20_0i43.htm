<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Examining the Error Log and DBCC Output</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_reproducing_problems"></a>Examining the Error Log and DBCC Output</h1>
<p>
As part of troubleshooting, it is necessary to frequently examine the SQL Server error log and DBCC output to check for problems. This can be an error-prone or laborious process, especially if you must do this on several servers, each of which may have multiple databases.</p>
<p>
Use DBCC with the WITH NO_INFOMSGS option to isolate error messages in the error log. Informational messages (severity levels 0 through 10) are excluded from the check.</p>
<p>
To make this examination process easier, you can use the Windows NT <b>findstr</b> utility (FINDSTR.EXE). This powerful pattern-searching utility helps to automate troubleshooting. It is even possible to conditionally execute a batch file based on whether certain error strings are found.</p>
<p>
The <b>findstr</b> utility uses Win32 asynchronous and file-mapped I/O for best throughput. It allows the use of regular expressions, recursive searching through  a directory tree, and the ability to exclude patterns (achieving a NOT function). For details, see your documentation for Windows NT.</p>
<p>
There are two basic approaches to searching the SQL Server error log or DBCC output for errors: 
<ol>
<li>
State explicitly what strings to find.</li>
<li>
State what strings you do <i>not</i> want to find (the search will find all but those strings).</li>
</ol>
<p>
In the first approach, you build a list of strings that define errors you want <b>findstr</b> to match. This list of strings can be supplied as an input file to <b>findstr</b>.</p>
<p>
For example, to find all occurrences of the strings "table corrupt" (which accompanies many serious data errors) and "msg 605" (which is a specific type of error), place these strings into a <i>search.txt</i> file. The content looks like this:</p>
<pre>table corrupt
msg 605
</pre>
<p>
Run <b>findstr</b> on the DBCC output files using this syntax:</p>
<p>
<b>findstr</b> <b>/i /g:</b><i>search.txt</i> <b>dbcc.* &gt; findstr.out</b></p>
<p>
where 
<dl>
<dt>
<i>search.txt</i></dt>
<dd>
Is the file containing the search strings.</dd>
<dt>
<b>dbcc.*</b></dt>
<dd>
Matches a group of DBCC output files to search.</dd>
<dt>
<b>findstr.out</b></dt>
<dd>
Is the file where the search results are placed.
</dd>
</dl>
<p>
The challenge with this approach is knowing ahead of time which error strings to search for. Unfortunately, there is no comprehensive list of SQL Server error strings that encompasses all possible errors. However, searching for the following strings may provide fairly good coverage as a starting point: "table corrupt," "level 16" ... "level 21," "Severity: 16" ... "Severity: 21." It is usually possible to refine the search, resulting in reliable checking (certainly more reliable than doing a visual search).</p>
<p>
In the second approach. you build a list of strings that you do <i>not</i> want to find (in other words, exclude these strings from the search).</p>
<p>
This sample exclusion list for error logs will filter out nonessential messages and trap the most significant errors:</p>
<pre>Copyright
All rights reserved
Logging SQL Server
initconfig: number
SQL Server is start
initializing virtual
Opening Master Data
Loading SQL Server
Recovering Database
Recovery dbid
transactions roll
Activating disk
initializing virtual
server name is
Clearing
rolled forward
default sort
nocase
default character
recovery complete
terminating due
windows nt
(id =
killed by hostname
17824
17825
1608
17832
OS error : 109
OS error : 232
unable to write to
restrictions
contracts
server is unnamed
no_log
working thread
network error
united states
unable to read login
duplication
subdivision
clause
number of buffers
using asynchronous disk
pipe name is
number of proc buffers
network information
file descriptors
transactions before ckpt
shutdown by request
</pre>
<p>
For example, to run <b>findstr</b> on the error log and have the above text saved as SEARCH.TXT, use:</p>
<pre>run findstr /v /i /g:search.txt errorlog *.* &gt; f.out</pre>
<p>
In some cases, combining the inclusion and exclusion approaches works well, combining the best characteristics of each.</p>
<p>
For example, when searching error logs for the strings "Severity: 16" ... "Severity: 21," which should match most serious errors, you notice in the search output several communication-related errors that normally do not indicate a serious problem. To refine the search, keep the original search conditions and exclude only these specific unwanted errors from the search output by piping one <b>findstr</b> command into another:</p>
<p>
<b>findstr /i /g:</b><i>search.txt errorlog<b>*.*</b></i><b> | findstr /v /i /g:</b><i>exclude.txt</i><b> &gt; f.out</b></p>
<p>
where 
<dl>
<dt>
<i>search.txt </i></dt>
<dd>
Is the file containing the search strings.</dd>
<dt>
<i>errorlog*.*</i></dt>
<dd>
Specifies which SQL Server error log files to search.</dd>
<dt>
<i>exclude.txt</i></dt>
<dd>
Is the file containing the search strings to exclude.</dd>
<dt>
<b>f.out</b></dt>
<dd>
Is the file where the search results are placed.</dd>
</dl>
<p>
</p>
<p>
This approach can be cascaded several levels deep, excluding successively more at each level.</p>
<p>&nbsp;</p></body>
</HTML>
