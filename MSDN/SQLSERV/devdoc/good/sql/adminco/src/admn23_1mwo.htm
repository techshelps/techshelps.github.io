<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using Dynamic Index</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_using_dynamic_index"></a>Using Dynamic Index</h2>
<p>
This statement indicates that the query optimizer has built its own index during the execution of the query, for use in its OR strategy. Because queries involving OR clauses are generally not very efficient in terms of quickly accessing the data, the SQL Server optimizer might use the OR strategy. When the OR strategy is used, the optimizer makes several passes through the table ¾ one pass for each argument to each OR clause. The results of each pass are added to a single worktable, and the worktable is then sorted to remove any duplicate rows.</p>
<p>
The worktable does not contain the actual data rows from the table; rather, it contains the row IDs for the matching rows. The row IDs are simply a combination of the page number and row number on that page for each of the rows. </p>
<p>
When the duplicates have been eliminated, the optimizer considers the worktable of row IDs to be, essentially, its own index (Dynamic Index) pointing to the table's data rows. It can then simply scan through the worktable, get each row ID, and return the data row from the table that has that row ID.</p>
<p>
The OR strategy is not limited to queries that contain OR clauses. When an IN clause is used to list a group of possible values, SQL Server interprets this as though the query had a separate equality clause for each of the values in the IN clause.</p>
<p>
To illustrate the OR strategy and the use of the Dynamic Index, the following queries are based on a table with 10,000 unique data rows, a unique nonclustered index on column <i>col1</i>, and a unique nonclustered index on column <i>col2</i>.</p>
<h4>Query 1:</h4>
<pre>SELECT *
FROM Mytable
WHERE col1 = 355
OR col2 = 732
</pre>
<h4>SHOWPLAN 1:</h4>
<pre>STEP 1
The type of query is SELECT
FROM TABLE
Mytable
Nested iteration
Index : col1_idx
FROM TABLE
Mytable
Nested iteration
Index : col2_idx
FROM TABLE
Mytable
Nested iteration
Using Dynamic Index

</pre>
<h4>Query 2:</h4>
<pre>SELECT *
FROM Mytable
WHERE col1 IN (700, 1503, 311)
</pre>
<h4>SHOWPLAN 2:</h4>
<pre>STEP 1
The type of query is SELECT
FROM TABLE
Mytable
Nested iteration
Index : col1_idx
FROM TABLE
Mytable
Nested iteration
Index : col1_idx
FROM TABLE
Mytable
Nested iteration
Index : col1_idx
FROM TABLE
Mytable
Nested iteration
Using Dynamic Index
</pre>
<p>
SQL Server does not always resort to using the OR strategy for every query that contains OR clauses. The following conditions must be met before SQL Server uses the OR strategy:
<ul>
<li>
All columns in the OR clause must belong to the same table.</li>
<li>
If any portion of the OR clause requires a table scan (due to lack of index or poor selectivity of a given index), a table scan will be used for the entire query, rather than the OR strategy.</li>
<li>
The decision to use the OR strategy is made after all indexes and costs are evaluated. If any other access plan is less costly (in terms of page I/Os), SQL Server uses the plan with the least cost. In the examples, if a straight table scan would result in less page I/Os than using the OR strategy, the queries would be processed as a table scan instead of using the Dynamic Index.</li>
</ul>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
