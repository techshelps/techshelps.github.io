<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Creating Database Objects on Segments</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_creating_database_objects_on_segments"></a>Creating Database Objects on Segments</h2>
<p>
After you add a segment, you can explicitly place database objects on that segment. The CREATE TABLE and the CREATE INDEX statements use the ON <i>segment_name</i> clause to create objects on a specific segment. If you do not use the ON <i>segment_name</i> clause, the object is created on the default segment.</p>
<h5><img src="../../../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To create a table on a specified segment</h5>
<p>
CREATE TABLE <i>table_name</i> <b>(</b><i>column_name</i> <i>datatype</i> <br>
&nbsp;&nbsp;&nbsp;&nbsp;[<b>,</b> <i>column_name</i> <i>datatype</i>...]<b>) </b>ON <i>segment_name</i> </p>
<p>
where
<dl>
<dt>
<i>table_name</i></dt>
<dd>
Is the name of the table.</dd>
<dt>
<i>column_name</i></dt>
<dd>
Is a column name in the table.</dd>
<dt>
<i>datatype</i></dt>
<dd>
Specifies the datatype of the column. System or user-defined datatypes are accepted.</dd>
<dt>
<i>segment_name</i></dt>
<dd>
Identifies the segment to create the table on.
</dd>
</dl>
<h5><img src="../../../../images/wedge.gif" border=0>&nbsp;&nbsp;&nbsp;&nbsp;To create the index for a table on a segment</h5>
<p>
CREATE [CLUSTERED | NONCLUSTERED] INDEX <i>index_name</i> <br>
ON <i>table_name</i> <b>(</b><i>column_name </i>[<b>,</b><i> column_name</i>...]<b>)</b> ON <i>segment_name</i> </p>
<p>
where
<dl>
<dt>
CLUSTERED | NONCLUSTERED</dt>
<dd>
Specifies whether the index is clustered or nonclustered.
<p>
CLUSTERED means that the physical order of rows on the database device is the same as the indexed order of the rows. NONCLUSTERED means that there is a level of indirection between the index structure and the data itself. For more information about indexes, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.

<p>
A clustered index, where the bottom, or leaf, level of the index contains the actual data, resides on the same segment as the table. If you create a table on one segment and then create its clustered index on a different segment, the table travels with its index to the new segment. If you create a clustered index without specifying a segment name, the entire table moves to the DEFAULT segment. A nonclustered index can reside on a different segment from the table.
</dd>
<dt>
<i>index_name</i></dt>
<dd>
Specifies the index to add to the segment.</dd>
<dt>
<i>table_name</i></dt>
<dd>
Identifies the table containing the index to add to the segment.</dd>
<dt>
<i>column_name</i></dt>
<dd>
Identifies the columns in the table.</dd>
<dt>
<i>segment_name</i></dt>
<dd>
Is the name of the segment on which you want the index created.
</dd>
</dl>
<p>
For example, to place the <i>mytable</i> table on the segment <i>seg_mydisk1</i> and its nonclustered index on segment <i>seg_mydisk2</i>, type:</p>
<pre>CREATE TABLE mytable (c1 varchar(30), c2 char(15), c3 datetime) 
    ON seg_mydisk1 

CREATE NONCLUSTERED INDEX my_index ON mytable (c1, c2) ON seg_mydisk2 
</pre>
<p>
For the full syntax of the CREATE TABLE and CREATE INDEX statements, see the <i>Microsoft SQL Server Transact-SQL Reference</i>.</p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
