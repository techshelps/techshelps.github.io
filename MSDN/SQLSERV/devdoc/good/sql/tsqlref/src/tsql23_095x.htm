<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>sp_processmail System Stored Procedure</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sp_processmail_system_stored_procedure"></a>sp_processmail System Stored Procedure</h2>
<p>
Uses extended stored procedures (<b>xp_findnextmsg</b>, <b>xp_readmail</b>, and <b>xp_deletemail</b>) to process incoming mail messages (expected to be only a single query) from the inbox for SQL Server. It uses the <b>xp_sendmail </b>extended stored procedure to return the results set back to the message sender.</p>
<h4>Syntax</h4>
<p>
<b>sp_processmail</b> [@subject <b>=</b> <i>subject</i>] [[<b>,</b>] @filetype <b>=</b> <i>filetype</i>] <br>
&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] @separator <b>=</b> <i>separator</i>] [[<b>,</b>] @set_user <b>=</b> <i>user</i>] [[<b>,</b>] @dbuse <b>= </b><i>dbname</i>]</p>
<p>
where
<dl>
<dt>
@subject = <i>subject</i></dt>
<dd>
Specifies the subject line of mail messages to interpret as queries for SQL Server. When specified, <b>sp_processmail</b> will process only messages that have this subject. By default, SQL Server processes all mail messages as though they were queries.</dd>
<dt>
@filetype <b>=</b> <i>filetype</i></dt>
<dd>
Specifies the file extension to be used when sending the results set file back to the message sender. The default is .TXT.</dd>
<dt>
@separator <b>=</b> <i>separator</i></dt>
<dd>
Specifies the column separator (field terminator) for each column of the results set (this information is passed to the <b>xp_sendmail</b> extended stored procedure to return the results set back to the message sender). The default is <b>'</b>TAB<b>'</b>, which is a special case for the tab character to be used between columns.</dd>
<dt>
@set_user <b>=</b> <i>user</i></dt>
<dd>
Specifies the security context in which the query should be run. The default is <b>'</b>guest<b>'</b> (the <i>guest </i>user).</dd>
<dt>
@dbuse <b>= </b><i>dbname</i></dt>
<dd>
Specifies the database context in which the query should be run. The default is the <i>master </i>database.
</dd>
</dl>
<h4>Remarks</h4>
<p>
Incoming e-mail is expected to have a single valid SQL Server query as the message text. The results of the query are returned to the message sender and copied to any e-mail users on the CC: list of the original message. After messages are processed, they are deleted from the inbox. If e-mail is often sent to the server, <b>sp_processmail</b> should be run frequently. To set up regular e-mail processing, you can use the SQL Executive to schedule an <b>sp_processmail</b> task. This will process mail at the specified frequency and record an informational message with the number of queries processed in the task history.</p>
<p>
Results are sent as an attached file. The complete filename sent consists of "SQL" followed by a random string of numbers and then the specified extension (@filetype), for example, SQL356.TXT.</p>
<p>
<b>Important</b>  To get an appropriate icon attached to the mail message, make sure that the file type is associated properly. Create a file association by using the Windows NT File Manager. To associate the appropriate application with the file from the File Manager File menu, choose Associate. For example, to return .CSV files to a client as Excel files, associate the .CSV extension with the Microsoft Excel program. Any existing associations (for example, .TXT files are associated with NOTEPAD.EXE) will be handled correctly. If the mail recipient has the same association, he or she can double-click on the icon (in the returned mail message) and automatically load the application.</p>
<p>
Errors received when the query is processed will be returned to the message sender through the message text. When the results set is returned to the client, <b>xp_sendmail </b>is called with the @echo_error parameter set to <b>'true'</b>. The messages sent also include a row count (number of rows affected) by the query.</p>
<p>
If desired, different <b>sp_processmail</b> tasks can be set up for queries in different databases. For example, you could adopt the convention that queries to the <i>pubs </i>database must have a subject of "SQL:pubs". Then you could run <b>sp_processmail</b> with @subject <b>= '</b>SQL:pubs<b>'</b> and @dbuse <b>= '</b>pubs<b>'</b>. Different database queries and groupings could have other formatting structures. For example, distribution tasks could have @subject <b>= '</b>SQL:distribution<b>'</b> and @dbuse = <b>'</b>distribution<b>'</b>. Any of these can be scheduled tasks with the SQL Executive. For more information on scheduling events, see the <i>Microsoft SQL Server Administrator's Companion</i>.</p>
<p>
The <b>sp_processmail</b> system stored procedure can also be customized in many ways by retrieving the text of the procedure with the <b>sp_helptext </b>system stored procedure and then modifying the Transact-SQL code. Possible changes include:
<ul>
<li>
Process only certain custom message types using the @type parameter with the <b>xp_readmail </b>extended stored procedure.</li>
<li>
Mark the message as <b>'read'</b> but don't delete the message after processing, (issue the <b>xp_readmail</b> a second time with @peek set to <b>'false'</b>).</li>
<li>
Send the query results in the body of the e-mail message by calling the <b>xp_sendmail </b>extended stored procedure with @attach_results set to <b>'false'</b>.</li>
<li>
Set the security context to run the query in a user context based on the message sender. If the e-mail usernames are the same as your SQL Server usernames, this is as simple as changing the call to <b>xp_sendmail</b> to use @set_user <b>=</b> @originator. If your mail usernames are not valid SQL Server usernames (if, for example, they contain embedded blanks), you could do a table lookup or character substitution to get the appropriate SQL Server username to pass to <b>xp_sendmail</b>.</li>
</ul>
<h4>Example</h4>
<p>
This example processes all messages in the <i>pubs </i>database with results sets returned to the client in CSV (comma separated values) format.</p>
<pre>sp_processmail @filetype <b>=</b> 'CSV', @separator <b>=</b> ',', @dbuse <b>= </b>'pubs'
</pre>
<h4>Permission</h4>
<p>
Permission to use this procedure defaults to the system administrator.</p>
<h4>See Also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql17_1qw5.htm"><b>sp_addtask</b></a></td>
<td width=52%><a href="tsql14_4dph.htm"><b>xp_readmail</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql14_7vfp.htm"><b>xp_deletemail</b></a></td>
<td width=52%><a href="tsql14_4nad.htm"><b>xp_sendmail</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql14_7ylh.htm"><b>xp_findnextmsg</b></a></td>
<td width=52%></td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
