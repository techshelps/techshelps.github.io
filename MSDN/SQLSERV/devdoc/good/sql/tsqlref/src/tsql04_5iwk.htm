<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CREATE TABLE Statement</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_create_table_statement"></a>CREATE TABLE Statement </h1>
<p>
For SQL Server 6.5 information, see <a href="../../hydra/tsql/src/addnfeat_9qgk.htm">CREATE TABLE Statement</a> in the <i>What's New for SQL Server 6.5</i>.</p>
<p>
Creates a new table.</p>
<h4>Syntax</h4>
<p>
CREATE TABLE [<i>database</i><b>.</b>[<i>owner</i>]<b>.</b>]<i>table_name</i> <br>
<b>(</b><br>
&nbsp;&nbsp;&nbsp;&nbsp;{<i>col_name column_properties </i>[<i>constraint</i> [<i>constraint </i>[...<i>constraint</i>]]]<br>
&nbsp;&nbsp;&nbsp;&nbsp;| [[<b>,</b>] <i>constraint</i>]}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[[<b>,</b>] {<i>next_col_name</i> | <i>next_constraint</i>}...]<br>
<b>)<br>
</b>[ON <i>segment_name</i>]</p>
<p>
where
<dl>
<dt>
<i>table_name</i></dt>
<dd>
Is the name of the new table. Table names must conform to the rules for identifiers and must be unique within the database and for its owner.
<p>
You can create local and global temporary tables. Local temporary tables are visible in the current session only; global temporary tables are visible to all sessions. Temporary tables names are stored in the <i>tempdb..sysobjects</i> table by their names and a system-supplied numeric suffix. Local temporary tables are automatically dropped at the end of the current session or, for global temporary tables, at the end of the last session using the table. Normally, this is when the session that created the table ends.

<p>
Signify temporary tables by preceding the <i>table_name</i> with a single pound sign (#<i>table_name</i>) for local temporary tables and a double pound sign (##<i>table_name</i>) for global temporary tables. For local temporary tables, the complete name, including #, cannot exceed 20 characters. 

<p>
When creating local or global temporary tables, the CREATE TABLE syntax supports constraint definitions; however, FOREIGN KEY constraints are not enforced on temporary tables.

<p>
If you are listed in that database's <i>sysusers</i> table and have CREATE TABLE permission in that database, you can create a table in a database different from the current one by fully qualifying the <i>table_name</i>.
</dd>
<dt>
<i>col_name</i></dt>
<dd>
Is the name of a column in the table. Column names must conform to the rules for identifiers and must be unique in the table.</dd>
<dt>
<i>column_properties</i> <b>=</b></dt>
<dd>
<i>datatype</i> [NULL | NOT NULL | IDENTITY[<b>(</b><i>seed</i><b>,</b> <i>increment</i><b>)</b>]]
<dl>
<dt>
<i>datatype</i></dt>
<dd>
Specifies the datatype of the column. System or user-defined datatypes are acceptable. </dd>
<dt>
IDENTITY[<b>(</b><i>seed</i><b>,</b> <i>increment</i><b>)</b>]</dt>
<dd>
Generates incremental values for new rows based on the <i>seed</i> and <i>increment</i> parameters. If used, the <i>seed</i> value will be assigned to the first row in the table and each subsequent row will receive the next identity value, equal to the last identity plus the <i>increment </i>value. If neither argument is given, both will default to 1. 
<p>
The IDENTITY property can be assigned to a <i>tinyint</i>, <i>smallint</i>, <i>int</i>, <i>decimal</i><b>(</b><i>p</i><b>,</b>0<b>)</b>, or <i>numeric</i><b>(</b><i>p</i><b>,</b>0<b>)</b> column that does not allow null values. Only one column per table can be defined as an identity column. Defaults and DEFAULT constraints cannot be bound to an identity column, and an identity value cannot be changed. For more information, see "IDENTITY Property," later in this topic. 
</dd>
</dl>
</dd>
<dt>
<i>constraint</i> <b>=</b></dt>
<dd>
Can include a table- or column-level constraint(s) where there are at most, one PRIMARY KEY per table, no more than 249 UNIQUE constraints, no more than 31 FOREIGN KEY constraints per table (each of which can reference at most 16 columns), one DEFAULT constraint per column, and any number of CHECK constraints. All can be entered within the same CREATE TABLE statement.
<dl>
<dt>
<b>For a PRIMARY KEY constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
PRIMARY KEY [CLUSTERED | NONCLUSTERED]<br>
<b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
[ON <i>segment_name</i>] </dd>
<dt>
<b>For a UNIQUE constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
UNIQUE [CLUSTERED | NONCLUSTERED]<br>
<b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
[ON <i>segment_name</i>] </dd>
<dt>
<b>For a FOREIGN KEY constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
[FOREIGN KEY <b>(</b><i>col_name</i> [<b>,</b> <i>col_name2 </i>[...<b>,</b> <i>col_name16</i>]]<b>)</b>]<br>
REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i> [<b>, </b><i>ref_col2</i> <br>
[...<b>, </b><i>ref_col16</i>]]<b>)</b>]</dd>
<dt>
<b>For a DEFAULT constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
DEFAULT {<i>constant</i>_<i>expression</i> | <i>niladic-function</i> | NULL}<br>
[FOR <i>col_name</i>]</dd>
<dt>
<b>For a CHECK constraint(s):</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
CHECK [NOT FOR REPLICATION] <b>(</b><i>expression</i><b>) </b></dd>
</dl>
</dd>
<dt>
CONSTRAINT <i>constraint_name</i></dt>
<dd>
Names the given constraint within the database. Constraint names must follow the rules for identifiers, except that the name cannot begin with a pound sign (#). If <i>constraint_name</i> is not supplied, a system-generated name is assigned to the constraint. The <i>constraint_name</i> will appear in any error message about constraint violations. If constraint requirements change, the constraint must be dropped and re-created using the ALTER TABLE statement.</dd>
<dt>
PRIMARY KEY [CLUSTERED | NONCLUSTERED]</dt>
<dd>
Enforces entity integrity for a given column or columns. All columns defined within a PRIMARY KEY constraint must be defined as NOT NULL. If nullability is not specified, all columns participating in a PRIMARY KEY constraint will have their nullability set to NOT NULL.
<p>
To enforce uniqueness of a primary key, SQL Server automatically creates a unique index on that column or columns. This unique index can be dropped only by dropping the associated table or the PRIMARY KEY constraint. 

<p>
If no index type is specified, a CLUSTERED index is created by default. If NONCLUSTERED is specified or if CLUSTERED is specified for a different constraint in the same statement block, a NONCLUSTERED index is created.

<p>
Only one PRIMARY KEY constraint can be specified for a given table. However, "alternate" or "candidate" keys can be effectively created with a UNIQUE constraint.
</dd>
<dt>
UNIQUE [CLUSTERED | NONCLUSTERED]</dt>
<dd>
Provides entity integrity for a given column or columns. Although columns participating in UNIQUE constraints can allow null values, it is not recommended that you use null values. If null values are necessary, the complete key (a single column or multiple columns for a composite index) cannot be NULL for more than one row. Multiple UNIQUE constraints can be defined on any given table. SQL Server automatically creates a unique index on this column or columns. Indexes created for use in UNIQUE constraint enforcement can be dropped only by dropping the associated table or constraint. If no index type is specified, a NONCLUSTERED index is created by default. </dd>
<dt>
[FOREIGN KEY <b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b>]<br>
REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i> [<b>, </b><i>ref_col2</i> [...<b>, </b><i>ref_col16</i>]]<b>)</b>]</dt>
<dd>
Provide single- or multicolumn referential integrity. When defined, the number of columns and datatypes of each column specified in the FOREIGN KEY clause must identically match the REFERENCES clause. A non-null value entered in this column(s) must exist in the table and column(s) defined in the REFERENCES clause, and the referenced table's columns should have a PRIMARY KEY or UNIQUE constraint defined on them. For column-level constraints, using the FOREIGN KEY and <i>col_name</i> identifiers are optional. 

<p>
<b>Important</b>  REFERENCE constraints can reference only tables within the same database; this can include the same table on which the reference is defined (self-referenced tables). If you want cross-database referential integrity or custom messaging, implement these through triggers.

<p>
A table can have a maximum of 31 FOREIGN KEY references. This limit is an absolute upper limit, but the maximum may be lower depending on the number of work tables the server has to create to enforce the constraint, and the limit varies by the type of query being executed. FOREIGN KEY constraints are not enforced for temporary tables. 

<p>
FOREIGN KEY constraints, unlike PRIMARY KEY constraints, do not create an index. To improve performance for data retrieval operations, use the CREATE INDEX statement to create an index on a foreign key column. This will allow for quicker execution times when a referenced key is modified.


<p>
For a FOREIGN KEY to be successfully created, the user must have SELECT or REFERENCES permission on the column or columns to which the FOREIGN KEY refers. For details, see the GRANT statement. When a specific reference column(s) is not provided, the primary key for the referenced table is used.
</dd>
<dt>
DEFAULT <i>constant_expression</i> | <i>niladic-function</i> | NULL</dt>
<dd>
Specifies the value that will be provided for the column when a value is not explicitly supplied during an insert. A DEFAULT constraint can contain constant values, functions, built-in functions that do not take arguments (niladic-functions), or NULL. If used, a <i>constant_expression</i> must follow the same rules as defaults. 
<p>
DEFAULT constraints can be created on columns of any datatype except columns that are the <i>timestamp </i>datatype or have the IDENTITY property. If a DEFAULT constraint is bound to a column defined with a user-defined datatype that has a default bound to it, the DEFAULT constraint is not allowed and the CREATE TABLE statement will fail. The default must be unbound from the user-defined datatype before that datatype can be used in a table definition with a DEFAULT constraint.

<p>
Niladic-functions allow a system-supplied value to be inserted when no value is specified. ANSI-standard niladic-functions include: 

<ul>
<li>
USER</li>
<li>
CURRENT_USER</li>
<li>
SESSION_USER</li>
<li>
SYSTEM_USER</li>
<li>
CURRENT_TIMESTAMP</li>
</ul>

<p>
In SQL Server 6.0, USER, CURRENT_USER, and SESSION_USER all default to the database username of the user performing the insert or update. SYSTEM_USER will provide the login ID, and CURRENT_TIMESTAMP will provide the same information as the GETDATE<b>()</b> function. 

<p>
Benefits to using a DEFAULT constraint instead of a default (created with the CREATE DEFAULT statement) are that no explicit binding/unbinding is required and DEFAULT constraints are removed when the table is dropped. 

<p>
When a DEFAULT is created as a table-level constraint, the column to which it applies is specified with FOR <i>col_name</i>.
</dd>
<dt>
CHECK <b>(</b><i>expression</i><b>)</b></dt>
<dd>
Enforces domain integrity by limiting the possible values that can be entered into a column or columns. The search condition must evaluate to a Boolean expression and cannot contain subqueries. CHECK constraints adhere to the same policies as rules; however, they are automatically bound to the columns on which they are defined. A column-level CHECK constraint can only reference the constrained column, and a table-level CHECK constraint can only reference columns of the constrained table. Multiple CHECK constraints can be defined for a table; however, only one can be defined per column per CREATE TABLE statement (although each column constraint can have multiple conditions). When a rule and one or more CHECK constraints exist for a column or columns, all restrictions are evaluated. If defined on multiple columns, CHECK constraints must be defined as table-level constraints.
<dl>
<dt>
NOT FOR REPLICATION</dt>
<dd>
Prevents the specified CHECK constraint from being enforced for the distribution process used by replication; however, CHECK constraints will be enforced for all other users (including the system administrator). NOT FOR REPLICATION is used to protect horizontally partitioned tables that receive "source" data from a publishing server of data modifications to the replicated data. When replication is in effect, any modifications to the data that is replicated should be made on the publishing server (the main source of the data) and not on any of the subscribing servers (each of which receives exact copies of the publishing server's data). 
<p>
The NOT FOR REPLICATION CHECK constraint will be applied to both the "before" and "after" image of an updated record to prevent records from being added to or deleted from the replicated range. All deletes and inserts will be checked; if they fall within the replicated range, they will be rejected. 
</dd>
</dl>
</dd>
<dt>
ON <i>segment_name</i></dt>
<dd>
If specified with a PRIMARY KEY or UNIQUE constraint, creates only the index on the named segment. If that key is defined with a clustered index, the entire table will be placed on the named segment. For more information, see the CREATE INDEX statement. 
<p>
If not specified with a constraint, ON <i>segment_name </i>creates the table on the named segment.


<p>
<b>Caution</b>  If you create a table on a segment and then create a clustered index on that table without specifying a segment name, the entire table migrates to the default segment (unless the SORTED_DATA option is used).


<p>
When using ON <i>segment_name</i>, the logical device must already be assigned to the database by the CREATE DATABASE statement or the ALTER DATABASE statement, and the segment must have been previously created in the database with the <b>sp_addsegment </b>system stored procedure. To see a list of segment names available in your database, use the <b>sp_helpsegment</b> system stored procedure. 


</dd>
</dl>
<p>
<b>Important</b>  Constraints are not enforced in the same batch as CREATE TABLE. If you want constraints to take effect for all new rows, do not insert, delete, or update data in the batch in which CREATE TABLE is executed.</p>
<p>
When a constraint is violated, the command is terminated. However, the transaction (if the statement is part of an explicit transaction) will continue to be processed. If desired, use the ROLLBACK TRANSACTION statement with the transaction definition by checking the <i>@@error </i>global variable.</p>
<p>
FOREIGN KEY constraints are not enforced on temporary tables.</p>
<h4>Remarks</h4>
<p>
SQL Server can have as many as 2 billion tables per database and 250 columns per table. The number of rows and total size of the table are limited only by the available storage. The maximum size of a database is 1 terabyte (TB). A table can be as large as 1 TB minus the size of the database catalog and any other objects. The maximum number of bytes per row is 1962. If you create tables with <i>varchar</i> or <i>varbinary</i> columns whose total defined width exceeds 1962 bytes, the table is created but a warning message appears. Trying to insert more than 1962 bytes into such a row or to update a row so that its total row size exceeds 1962, produces an error message and the statement fails. For details on calculating row size, see the <i>Microsoft SQL Server Administrator's Companion</i>.</p>
<p>
The table is created in the currently open database unless a different database is explicitly specified in the CREATE TABLE statement with the optional database name. (Cross-database creation of tables and indexes is allowed as long as the creator is listed in the <i>sysusers</i> table of the other database and has CREATE TABLE permission in that database. However, cross-database creation of views, rules, defaults, stored procedures, and triggers is not allowed.)</p>
<p>
User-defined datatypes are defined in terms of system datatypes. User-defined datatypes permit frequently used type information to be accessed by a name you choose with a specified rule, default, and display format attached to it. User-defined datatypes are created with the <b>sp_addtype</b> system stored procedure before they can be used in a table definition.</p>
<p>
The NULL/NOT NULL assignment for a user-defined datatype can be overridden during the CREATE TABLE statement. However, the length specification cannot be changed; you cannot specify a length for a user-defined datatype in a CREATE TABLE statement.</p>
<p>
For a report on a table and its columns, use the <b>sp_help</b> or <b>sp_helpconstraint</b> system stored procedure. To rename a table, use the <b>sp_rename </b>system stored procedure. For a report on the views and stored procedures that depend on a table, use the <b>sp_depends </b>system stored procedure. </p>
<p>
Space is allocated to tables and indexes in increments of one extent, (eight pages) at a time. An extent is allocated when the table or index is created, and another extent is allocated each time the previous extent becomes full. For a report on the amount of space allocated and used by a table, execute the <b>sp_spaceused </b>system stored procedure. </p>
<p>&nbsp;</p></body>
</HTML>
