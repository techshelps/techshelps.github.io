<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>sp_configure System Stored Procedure</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_sp_configure_system_stored_procedure"></a>sp_configure System Stored Procedure </h2>
<p>
For SQL Server 6.5 information, see <a href="../../hydra/tsql/src/addsproc_0put.htm"><b>sp_configure</b></a> in <i>What's New for SQL Server 6.5</i>.</p>
<p>
Displays or changes configuration options.</p>
<h4>Syntax</h4>
<p>
<b>sp_configure</b> [<i>config_name</i> [<b>,</b> <i>config_value</i>]]</p>
<p>
where
<dl>
<dt>
<i>config_name</i></dt>
<dd>
Specifies a configuration option. SQL Server understands any unique string that is part of the configuration name. This parameter must be enclosed in quotation marks if it contains embedded blanks or is a keyword.</dd>
<dt>
<i>config_value</i></dt>
<dd>
Is the value for the configuration option. 
</dd>
</dl>
<h4>Remarks</h4>
<p>
All users can execute the <b>sp_configure</b> system stored procedure with no parameters (SQL Server displays a list of all configuration options and their current values) or with <i>config_name</i> (SQL Server displays the current value for the specified configuration option).</p>
<p>
Only the system administrator can execute <b>sp_configure</b> with both parameters and change the configuration option value. After using <b>sp_configure</b>, the system administrator must execute the RECONFIGURE statement to install the changed value. Dynamic options take effect immediately after the RECONFIGURE statement has been run. For all non-dynamic options, SQL Server must be stopped and restarted before the options can take effect. For details, see the RECONFIGURE statement. </p>
<p>
The information returned by <b>sp_configure</b>, when executed with no parameters, shows a <i>config_value</i> column and a <i>run_value</i> column. The <i>config_value</i> column contains the value to which the configuration option was set with <b>sp_configure</b> (the value in <i>sysconfigures.value</i>). The <i>run_value</i> column contains the value for that option (the value in <i>syscurconfigs.value</i>) for SQL Server. These values do not necessarily have to be equivalent. For example, the system administrator may have changed an option with <b>sp_configure</b> but has not executed the RECONFIGURE statement (for dynamic options) or restarted SQL Server (for non-dynamic options). </p>
<p>
The <i>run_value</i> column contains the value that SQL Server is using. This value changes for dynamic configuration options (listed in the Configuration Option Overview and marked with an asterisk) after the system administrator runs the RECONFIGURE statement. This value specifies changes for static configuration options after you shut down and restart SQL Server. This is the value in <i>syscurconfigs.value</i>.</p>
<h3>Configuration Option Overview</h3>
<p>
Many configuration options are often considered advanced and should be changed only under very special and often rare circumstances. In the following table, advanced options are shown in bold type; dynamic options are marked with an asterisk (*).</p>
<table cellspacing=4 cols=5>
<tr valign=top>
<th align=left width=31%></th>
<th align=left width=15%></th>
<th align=left width=20%></th>
<th align=left width=18%></th>
<th align=left width=16%></th>
</tr>
<tr valign=top>
<th align=left width=31%></th>
<th align=left width=15%></th>
<th align=left width=20%></th>
<th align=left width=18%></th>
<th align=left width=16%></th>
</tr>
<tr valign=top>
<th align=left width=31%><i>config_name</i></th>
<th align=left width=15%>Minimum</th>
<th align=left width=20%>Maximum</th>
<th align=left width=18%><i>config_value</i></th>
<th align=left width=16%>run_value</th>
</tr>
<tr valign=top>
<td width=31%>allow updates*</td>
<td width=15%>0</td>
<td width=20%>1</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%>backup buffer size*</td>
<td width=15%>1</td>
<td width=20%>10</td>
<td width=18%>1</td>
<td width=16%>1</td>
</tr>
<tr valign=top>
<td width=31%>backup threads</td>
<td width=15%>0</td>
<td width=20%>32</td>
<td width=18%>5</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=31%><b>cursor threshold*</b></td>
<td width=15%><b>-1</b></td>
<td width=20%><b>2147483647</b></td>
<td width=18%><b>100</b></td>
<td width=16%><b>100</b></td>
</tr>
<tr valign=top>
<td width=31%>database size</td>
<td width=15%>1</td>
<td width=20%>10000</td>
<td width=18%>2</td>
<td width=16%>2</td>
</tr>
<tr valign=top>
<td width=31%>default language</td>
<td width=15%>0</td>
<td width=20%>9999</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%><b>default sortorder id</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>255</b></td>
<td width=18%><b>52</b></td>
<td width=16%><b>52</b></td>
</tr>
<tr valign=top>
<td width=31%>fill factor</td>
<td width=15%>0</td>
<td width=20%>100</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%><b>free buffers*</b></td>
<td width=15%><b>20</b></td>
<td width=20%><b>524288</b></td>
<td width=18%><b>204</b></td>
<td width=16%><b>204</b></td>
</tr>
<tr valign=top>
<td width=31%><b>hash buckets</b></td>
<td width=15%><b>4999</b></td>
<td width=20%><b>265003</b></td>
<td width=18%><b>7993</b></td>
<td width=16%><b>7993</b></td>
</tr>
<tr valign=top>
<td width=31%>language in cache</td>
<td width=15%>3</td>
<td width=20%>100</td>
<td width=18%>3</td>
<td width=16%>3</td>
</tr>
<tr valign=top>
<td width=31%>LE threshold maximum*</td>
<td width=15%>2</td>
<td width=20%>500000</td>
<td width=18%>200</td>
<td width=16%>200</td>
</tr>
<tr valign=top>
<td width=31%><b>LE threshold minimum*</b></td>
<td width=15%><b>2</b></td>
<td width=20%><b>500000</b></td>
<td width=18%><b>20</b></td>
<td width=16%><b>20</b></td>
</tr>
<tr valign=top>
<td width=31%>LE threshold percent*</td>
<td width=15%>1</td>
<td width=20%>100</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%>locks</td>
<td width=15%>5000</td>
<td width=20%>2147483647</td>
<td width=18%>5000</td>
<td width=16%>5000</td>
</tr>
<tr valign=top>
<td width=31%><b>logwrite sleep (ms)*</b></td>
<td width=15%><b>-1</b></td>
<td width=20%><b>500</b></td>
<td width=18%><b>0</b></td>
<td width=16%><b>0</b></td>
</tr>
<tr valign=top>
<td width=31%>max async IO</td>
<td width=15%>1</td>
<td width=20%>255</td>
<td width=18%>8</td>
<td width=16%>8</td>
</tr>
<tr valign=top>
<td width=31%><b>max lazywrite IO*</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>255</b></td>
<td width=18%><b>8</b></td>
<td width=16%><b>8</b></td>
</tr>
<tr valign=top>
<td width=31%>max worker threads*</td>
<td width=15%>10</td>
<td width=20%>1024</td>
<td width=18%>255</td>
<td width=16%>255</td>
</tr>
<tr valign=top>
<td width=31%>media retention</td>
<td width=15%>0</td>
<td width=20%>365</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%>memory</td>
<td width=15%>1000</td>
<td width=20%>1048576</td>
<td width=18%>4096</td>
<td width=16%>4096</td>
</tr>
<tr valign=top>
<td width=31%>nested triggers*</td>
<td width=15%>0</td>
<td width=20%>1</td>
<td width=18%>1</td>
<td width=16%>1</td>
</tr>
<tr valign=top>
<td width=31%>network packet size*</td>
<td width=15%>512</td>
<td width=20%>32767</td>
<td width=18%>4096</td>
<td width=16%>4096</td>
</tr>
<tr valign=top>
<td width=31%>open databases</td>
<td width=15%>5</td>
<td width=20%>32767</td>
<td width=18%>20</td>
<td width=16%>20</td>
</tr>
<tr valign=top>
<td width=31%>open objects</td>
<td width=15%>100</td>
<td width=20%>2147483647</td>
<td width=18%>500</td>
<td width=16%>500</td>
</tr>
<tr valign=top>
<td width=31%><b>priority boost</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>1</b></td>
<td width=18%><b>0</b></td>
<td width=16%><b>0</b></td>
</tr>
<tr valign=top>
<td width=31%>procedure cache</td>
<td width=15%>1</td>
<td width=20%>99</td>
<td width=18%>30</td>
<td width=16%>30</td>
</tr>
<tr valign=top>
<td width=31%><b>RA cache hit limit*</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>255</b></td>
<td width=18%><b>4</b></td>
<td width=16%><b>4</b></td>
</tr>
<tr valign=top>
<td width=31%><b>RA cache miss limit*</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>255</b></td>
<td width=18%><b>3</b></td>
<td width=16%><b>3</b></td>
</tr>
<tr valign=top>
<td width=31%><b>RA delay*</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>500</b></td>
<td width=18%><b>15</b></td>
<td width=16%><b>15</b></td>
</tr>
<tr valign=top>
<td width=31%><b>RA pre-fetches*</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>1000</b></td>
<td width=18%><b>3</b></td>
<td width=16%><b>3</b></td>
</tr>
<tr valign=top>
<td width=31%><b>RA slots per thread</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>255</b></td>
<td width=18%><b>5</b></td>
<td width=16%><b>5</b></td>
</tr>
<tr valign=top>
<td width=31%>RA worker threads</td>
<td width=15%>0</td>
<td width=20%>255</td>
<td width=18%>3</td>
<td width=16%>3</td>
</tr>
<tr valign=top>
<td width=31%>recovery flags</td>
<td width=15%>0</td>
<td width=20%>1</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%>recovery interval*</td>
<td width=15%>1</td>
<td width=20%>32767</td>
<td width=18%>5</td>
<td width=16%>5</td>
</tr>
<tr valign=top>
<td width=31%>remote access</td>
<td width=15%>0</td>
<td width=20%>1</td>
<td width=18%>1</td>
<td width=16%>1</td>
</tr>
<tr valign=top>
<td width=31%><b>remote login timeout*</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>2147483647</b></td>
<td width=18%><b>5</b></td>
<td width=16%><b>5</b></td>
</tr>
<tr valign=top>
<td width=31%><b>remote query timeout*</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>2147483647</b></td>
<td width=18%><b>0</b></td>
<td width=16%><b>0</b></td>
</tr>
<tr valign=top>
<td width=31%><b>resource timeout*</b></td>
<td width=15%><b>-1</b></td>
<td width=20%><b>2147483647</b></td>
<td width=18%><b>100</b></td>
<td width=16%><b>100</b></td>
</tr>
<tr valign=top>
<td width=31%><b>set working set size</b></td>
<td width=15%><b>0</b></td>
<td width=20%><b>1</b></td>
<td width=18%><b>0</b></td>
<td width=16%><b>0</b></td>
</tr>
<tr valign=top>
<td width=31%>show advanced option*</td>
<td width=15%>0</td>
<td width=20%>1</td>
<td width=18%>1</td>
<td width=16%>1</td>
</tr>
<tr valign=top>
<td width=31%><b>SMP concurrency</b></td>
<td width=15%><b>-1</b></td>
<td width=20%><b>64</b></td>
<td width=18%><b>0</b></td>
<td width=16%><b>1</b></td>
</tr>
<tr valign=top>
<td width=31%><b>sort pages*</b></td>
<td width=15%><b>64</b></td>
<td width=20%><b>511</b></td>
<td width=18%><b>64</b></td>
<td width=16%><b>64</b></td>
</tr>
<tr valign=top>
<td width=31%><b>spin counter*</b></td>
<td width=15%><b>1</b></td>
<td width=20%><b>2147483647</b></td>
<td width=18%><b>10000</b></td>
<td width=16%><b>10</b></td>
</tr>
<tr valign=top>
<td width=31%>tempdb in ram (MB)</td>
<td width=15%>0</td>
<td width=20%>2044</td>
<td width=18%>0</td>
<td width=16%>0</td>
</tr>
<tr valign=top>
<td width=31%>user connections</td>
<td width=15%>5</td>
<td width=20%>32767</td>
<td width=18%>20</td>
<td width=16%>20</td>
</tr>
</table><br>
<p>
Advanced options are displayed only when "show advanced option" is set to 1 (the default is 0).</p>
<h3>Configuration Option Details</h3>
<p>
Many configuration options can be grouped and are often changed together. </p>
<p>
In the following listings, advanced configuration options are noted in bold type and dynamic options are marked with an asterisk (*).
<dl>
<dt>
allow updates*</dt>
<dd>
Specifies whether or not direct updates are allowed against system tables. Can be on (1) or off (0). By default, this option is off (0); system tables can be updated only through system procedures, not through ad hoc updates. 
<p>
When allow updates is on (1), any user who has appropriate permissions can update the system tables directly with ad hoc updates and can create stored procedures that update the system tables.


<p>
<b>Important</b>  Allowing direct updates to the system tables is risky. Updating certain fields in the system tables can prevent SQL Server from running. Stored procedures created while allow updates is on (1) will always be able to update the system tables, even after the option has been turned off.


<p>
Because the system tables are critical, it is best to turn on this option only in tightly controlled situations. To guarantee that no other users can access SQL Server while the system tables can be directly updated, restart SQL Server from the Win32 command prompt with the <b>/m</b> option. For more information, see the <b>sqlservr</b> Command-line Executable.

<p>
This command starts SQL Server in a single-user mode, which allows only one system administrator to log in and turns on the allow updates configuration option.

<p>
The allow updates option is a dynamic option, which means that a new value takes effect as soon as you use the RECONFIGURE WITH OVERRIDE statement. As an added protection, the WITH OVERRIDE clause is always required for this configuration option. 
</dd>
<dt>
backup buffer size*</dt>
<dd>
Specifies the size of the dump and load buffer (used to increase backup speed). This value determines the size, in 32-page increments, of the backup buffer. For example, a backup buffer size of 5 means that a buffer of 160 pages (5 <i>*</i> 32 pages) will be created. This option, when reconfigured, takes effect immediately.</dd>
<dt>
backup threads</dt>
<dd>
Specifies the number of threads to be reserved for striped dump and load operations. A value of 0 turns off striped dumps. This option does not take effect until the server is stopped and restarted.</dd>
<dt>
<b>cursor threshold*</b></dt>
<dd>
Specifies the value where keyset generation occurs asynchronously. When cursors generate a keyset for a results set, the optimizer estimates the number of rows that will be returned by that results set. If the optimizer estimates that the number of returned rows is greater than this threshold, the cursor is generated asynchronously. Otherwise, the cursor is generated synchronously. When set to -1, all keysets are generated synchronously. If the cursor threshold is set to 0, all keysets will be generated asynchronously. Normally you would not want to set this value too low, as small results sets are faster to build synchronously. 
<p>
The accuracy of the optimizer to determine an estimate for the number of rows in a keyset depends on the currency of the statistics for each of the tables in the cursor. For more information on updating table statistics, see the DBCC and the UPDATE STATISTICS statements.
</dd>
<dt>
database size</dt>
<dd>
Sets the default number of megabytes allocated to each new user database. The default is 2 MB; however, the minimum allowable database size is 1 MB, which allows databases to exist on removable media such as floppy disks. A database size specified in a CREATE DATABASE statement takes precedence over the value set by this configuration option.
<p>
If most of the new databases on your SQL Server require more than 2 MB, you might want to increase this value. You also must increase it if your <i>model</i> database grows larger than 2 MB, because the CREATE DATABASE statement causes SQL Server to copy <i>model</i> when creating a new user database.


<p>
<b>Note</b>  The <i>model</i> database is 1 MB by default.

</dd>
<dt>
default language</dt>
<dd>
Specifies the ID of the language that is used by the server to display system messages, unless a user has chosen another language from those available on the server. The language <b>us_english </b>always has an ID of 0. Additional languages are assigned unique numbers when they are added.</dd>
<dt>
<b>default sortorder id</b></dt>
<dd>
Specifies the number of the sort order currently installed as the default on the server. 

<p>
<b>Note</b>  Do not use the <b>sp_configure</b> system stored procedure to change sort orders. For more information about changing sort orders, see the <i>Microsoft SQL Server Administrators Companion</i>.

</dd>
<dt>
fill factor</dt>
<dd>
Determines how full SQL Server makes each page when it is creating a new index on existing data (unless the user specifies some other value using the CREATE INDEX statement). The <b>fill factor</b> percentage affects performance because SQL Server must take time to split pages when they fill up.
<p>
The <b>fill factor</b> percentage is used only at the time the index is created and becomes less important as changes to the data are made. The pages are not maintained at any particular level of fullness.

<p>
The default for this configuration option is 0; legal values range from 0 through 100. A <b>fill factor</b> of 0 does not mean that pages are 0 percent full. It is treated similarly to a <b>fill factor</b> of 100 in that SQL Server creates clustered indexes with full data pages and nonclustered indexes with full leaf pages. It is different from 100 in that SQL Server leaves a space within the index B-tree. There is seldom a reason to change the default <b>fill factor</b>, especially since you can override it with the CREATE INDEX statement.

<p>
If <b>fill factor</b> is set to 100, SQL Server creates both clustered and nonclustered indexes with each page 100 percent full. A <b>fill factor</b> of 100 makes sense only for read-only tables ¾ tables to which no additional data will ever be added.

<p>
Smaller <b>fill factor</b> values cause SQL Server to create new indexes with pages that are not full. For example, a <b>fill factor</b> of 10 is a reasonable choice if you are creating an index on a table that you know contains only a small portion of the data that it will eventually hold. Smaller <b>fill factor</b> values cause each index to take more storage space.
</dd>
<dt>
<b>free buffers*</b></dt>
<dd>
Determines the threshold of free buffers available to the system. The minimum value is 20 and the maximum value is equal to one-half the number of buffers available when the server is started. The lazy writer process ensures that the number of free buffers available to the system does not fall below this threshold.
<p>
This option is automatically changed by the system whenever the <b>memory</b> option<b> </b>is changed; <b>free buffers </b>will be equal to 5 percent of the available <b>memory</b>. After the <b>memory</b> option is changed, a message will be displayed describing the change to <b>free buffers</b>. After this change, <b>free buffers </b>can be manually reconfigured to any legal value.
</dd>
<dt>
<b>hash buckets</b></dt>
<dd>
Sets the number of buckets used for hashing pages to buffers in memory. If the value specified is not a prime number, the closest prime number is used. For example, specifying 8000 creates 7993 hash buckets (the default). On systems with a large amount of memory, this value can be increased to allow faster access to data residing in data cache. For systems with 160 MB or less, 7993 is an appropriate value. This option does not take effect until the server is stopped and restarted.</dd>
<dt>
language in cache</dt>
<dd>
Indicates the maximum number of languages that can be simultaneously held in the language cache. The default is 3.</dd>
</dl>

<h4><a name="_lock_escalation_options"></a>Lock Escalation Options</h4>
<p>
Many configuration options can be grouped and are often changed together. </p>
<p>
When queries request a large number of rows from a particular table or tables, SQL Server generates page-level locks. If a query requests a large percentage of the rows from the table (see LE threshold percent), then lock escalation will occur. This makes table scans and operations against a large results set more efficient. The lock escalation options apply per statement, and not per transaction. The lock escalation options are:
<ul>
<li>
LE threshold maximum*</li>
<li>
<b>LE threshold minimum*</b></li>
<li>
LE threshold percent*</li>
</ul>
<dl>
<dt>
LE threshold maximum*</dt>
<dd>
Determines the maximum number of page locks to hold before escalating to a table lock. If the number of page locks is greater than the escalation maximum, a table lock will occur regardless of whether or not the <b>LE threshold percent</b> has been exceeded. The default is 200.</dd>
<dt>
<b>LE threshold minimum*</b></dt>
<dd>
Determines the minimum number of page locks required before escalating to a table lock. A table lock will occur only if this minimum is reached when the <b>LE threshold percent</b> is exceeded. <b>LE threshold minimum</b> prevents the server from escalating to a table lock for small tables where the <b>LE threshold percentage</b> is reached quickly. The default is 20.</dd>
<dt>
LE threshold percent*</dt>
<dd>
Specifies the percentage of page locks needed on a table before a table lock is requested. The default (0) causes a table lock to occur only when the <b>LE threshold maximum</b> has been reached.

<p>
<b>Note</b>  To override these values for a given request, see the <i>optimizer_hints</i> option with the SELECT statement. The HOLDLOCK table lock options include UPDLOCK, TABLOCK, TABLOCKX, and PAGLOCK.

</dd>
<dt>
locks</dt>
<dd>
Sets the number of available locks. Locks are not shared the way open databases and database objects are shared. The default is 5000.
<p>
Increase this value if SQL Server displays a message saying that you have exceeded the number of available locks. Since each lock consumes memory (32 bytes per lock), increasing this value can make it necessary to increase the amount of memory dedicated to the server.
</dd>
<dt>
<b>logwrite sleep (ms)*</b></dt>
<dd>
Specifies the number of milliseconds that a write to the log will be delayed if the buffer is not full. This increases the chance that more data will be added to the log buffer by other users, so that fewer physical log writes will be needed. Acceptable values for this option are -1 through 500. The special value of -1 means that the log write will not be delayed. The default is 0, which causes the server to wait only if other users are ready to execute. </dd>
<dt>
max async IO</dt>
<dd>
Configures the number of asynchronous I/Os that can be issued. The default is 8. This value should be changed only on systems with databases defined on multiple physical database devices that reside on separate physical disks, or on systems taking advantage of disk striping. </dd>
<dt>
<b>max lazywrite IO*</b></dt>
<dd>
Tunes the priority of batched asynchronous I/Os performed by the lazy writer. This is comparable to <b>max async IO</b>, which controls batch I/O such as bulk copy and checkpoints, but <b>max lazywrite IO</b> is specific to the lazy writer. This option should be configured only on systems that have multiple hard disks. It is dynamically configurable up to the value specified by <b>max async IO</b>. Do not change this option unless your primary support provider instructs you to do so.</dd>
<dt>
max worker threads*</dt>
<dd>
Configures the number of worker threads that are available to SQL Server processes. SQL Server makes use of the native thread services of the operating system. Instead of one worker thread, there are many. Each network that SQL Server simultaneously supports is supported by one or more threads, another thread handles database checkpoints, and a pool of threads handles all users. 
<p>
The <b>max worker threads</b> option allows you to control the number of threads allocated to the user pool. When the number of user connections is less than <b>max worker threads</b>, one thread handles each connection. However, if the number of connections exceeds <b>max worker threads</b>, thread pooling occurs. Additionally, if the configured value for worker threads is exceeded, the request is handled by the next worker thread that completes its current task. The default is 255.
</dd>
<dt>
media retention</dt>
<dd>
Sets the number of days that you expect to retain each backup medium after it has been used for a database or transaction log dump. The default is 0. Unless you change this value, no warning is issued. A typical value might be 7 (days).
<p>
If you try to use the backup medium before the set number of days have passed, SQL Server issues a warning message.
</dd>
<dt>
memory</dt>
<dd>
Sets the size of available memory, in 2K units. The default run value is determined by the <b>setup</b> program based on the amount of memory in your computer.
<p>
To optimize this number for your system, subtract the memory required for Windows NT (and other system uses, if the computer is not wholly dedicated to SQL Server) from the total physical memory. 

<p>
Ideally, you want to allocate as much memory as possible to SQL Server without causing the system to page. You can use the Windows NT Performance Monitor to help determine what the threshold is for your system ¾ the Page Faults/sec counter of the Memory Object indicates whether you are generating any page faults. If so, SQL Server is running with too much memory. The threshold varies depending on your system. For example, on a 32-MB system, 16 MB might be appropriate for SQL Server; on a 64-MB system, 48 MB might be appropriate.

<p>
The amount of memory specified must be sufficient for the SQL Server static memory needs (kernel overhead, user stack space, and so on), as well as for the procedure cache and the data cache (also called buffer cache).

<p>
The memory left over after the SQL Server memory needs are met is divided between the procedure cache and the data cache. The percentage allocated to the procedure cache is set with the <b>procedure cache</b> configuration option.

<p>
You can use DBCC MEMUSAGE and statistics from the Windows NT Performance Monitor to help you adjust this value. Change this value only when you add or remove memory, or when you change how you use your system.

<p>
When the <b>memory </b>option is reconfigured, it will automatically cause a possible change to the configured <b>free buffers </b>configuration option. The <b>free buffers </b>configuration value will be set to 5 percent of the new <b>memory</b> size.

<p>
The maximum value for the <b>memory</b> option is 2 GB. Note, however, that the <b>memory</b> option does not include memory needs for <i>tempdb</i> if you have placed <i>tempdb</i> in RAM using the <b>tempdb in ram (MB) </b>option.
</dd>
<dt>
nested triggers*</dt>
<dd>
Controls the use of nested triggers. When this option is 0, triggers will not cascade. Set it to 1 to enable nested (or cascading) triggers. The default is 1.</dd>
<dt>
network packet size*</dt>
<dd>
Sets the server-wide value for the default network packet size. The client application can override this value. On systems using differing network protocols, this option should be set to the size of the most common protocol used. This option can improve network performance when network protocols support larger packets. If reconfigured, the change takes effect immediately. The default is 4096.</dd>
<dt>
open databases</dt>
<dd>
Sets the maximum number of databases that can be open at one time on SQL Server. The default is 20.</dd>
<dt>
open objects</dt>
<dd>
Sets the maximum number of database objects that can be open at one time on SQL Server. The default is 500.
<p>
Increase this value if SQL Server displays a message saying that you have exceeded the number of open objects. Because open objects consume memory, increasing this value can make it necessary to increase the amount of memory dedicated to the server.
</dd>
<dt>
<b>priority boost</b></dt>
<dd>
Determines whether or not SQL Server should run at a higher priority than other processes on the same computer. If this option is set to 1, SQL Server will run at a higher priority in the Windows NT scheduler. The default is 0 and should be changed only on Windows NT systems dedicated to SQL Server.</dd>
<dt>
procedure cache</dt>
<dd>
Specifies the percentage of memory allocated to the procedure cache after the SQL Server memory needs are met. The SQL Server memory needs are the sum of memory necessary for locks, user connections, the code itself, and so on. The remaining memory is divided between the procedure cache and the data cache according to the percentage set by this configuration option.
<p>
The procedure cache is the area of memory where the most recently used procedures are stored. The procedure cache is also used when a procedure is being created and when a query is being compiled. If SQL Server finds a procedure or a compilation already in the cache, SQL Server does not need to read it from the disk.

<p>
The data cache is the area of memory where the most recently used data pages and index pages are stored. If SQL Server finds a data page or index page that has already been called by a user in the cache, SQL Server does not need to read it from the disk.

<p>
Information in both caches is stored in least recently used, most recently used (LRU-MRU) fashion.

<p>
The default for the <b>procedure cache</b> configuration option is 30, which gives the procedure cache 30 percent of the remaining memory after the SQL Server requirements are met. By default, the data cache gets the other 70 percent.

<p>
Since the optimum value for this configuration option is different from application to application, resetting it can improve SQL Server performance. For example, if you run many different procedures or ad hoc queries, your application will use the procedure cache more, so you might want to increase this value. Many applications fall into this category while they are being developed. You might want to set this option to 50 during your development cycle and then reset it to 30 when your application has stabilized.

<p>
You can use DBCC MEMUSAGE to help you adjust this value.
</dd>
</dl>

<h4><a name="_read_ahead_configuration_options"></a>Read Ahead Configuration Options</h4>
<p>
Many configuration options can be grouped and are often changed together. </p>
<p>
Read ahead configuration options control "parallel data scan" capabilities, which enable asynchronous read ahead of data when SQL Server determines that pages are being retrieved in sequential order. With read ahead (RA), separate background threads will be used to pre-fetch pages for a given results set. Read ahead is used by queries, DBCC CHECKTABLE, DBCC CHECKDB, DBCC CHECKALLOC, UPDATE STATISTICS, CREATE INDEX, exporting with bulk copy, and the retrieval of text and image data. Read ahead pre-fetches are configured based on extents. The Read Ahead configuration options are:
<ul>
<li>
<b>RA cache hit limit*</b></li>
<li>
<b>RA cache miss limit*</b></li>
<li>
<b>RA delay*</b></li>
<li>
<b>RA pre-fetches*</b></li>
<li>
<b>RA slots per thread</b></li>
<li>
RA worker threads</li>
</ul>
<dl>
<dt>
<b>RA cache hit limit*</b></dt>
<dd>
Is the number of cache hits that a read-ahead request can have before it is canceled. This is used for detecting situations in which the Read Ahead manager finds everything in cache and is of little help to the query. The default value '4' should suffice for most systems. Do not change this option unless your primary support provider instructs you to do so.</dd>
<dt>
<b>RA cache miss limit*</b></dt>
<dd>
Is the number of cache misses that occur during a horizontal traversal before read ahead starts for that command. Avoid setting this value lower than 3. Setting the <b>RA cache miss limit</b> to 1 causes a read-ahead request to be made whenever a data page is accessed from disk, and it can lead to thrashing and poor performance. Do not change this option unless your primary support provider instructs you to do so.</dd>
<dt>
<b>RA delay*</b></dt>
<dd>
Specifies the delay of read ahead, in milliseconds. This is required to account for the latency to "prime" the RA Manager before it starts servicing an initial RA request. The default value '15' should suffice for most systems. For SMP machines, this value should be set to 15.</dd>
<dt>
<b>RA pre-fetches*</b></dt>
<dd>
Determines how far ahead the read-ahead (RA) manager will read (on an extent basis) before the pre-fetch manager idles. A value of 3 means that for each request posted, the RA manager keeps three extents ahead of the current scan position. </dd>
<dt>
<b>RA slots per thread</b></dt>
<dd>
Is the number of simultaneous requests each read-ahead (RA) service thread will manage. The number of threads multiplied by the number of slots is equivalent to the total number of concurrent RA scans that the system will support. The default value should be sufficient for most systems. If your system has an efficient IO subsystem, you may be able to increase the number of scans that a single thread can handle.</dd>
<dt>
RA worker threads</dt>
<dd>
Specifies the number of threads used to service read-ahead requests. Each thread will manage a configurable number of structures (see the <b>RA slots per thread </b>option), where each of these structures (slots) represents an individual range scan. This option should be set to the maximum number of concurrent users on the system. A warning will be logged in the error log if the number of threads requesting RA scans exceeds the number of configured RA slots.</dd>
<dt>
recovery flags</dt>
<dd>
Determines what information SQL Server displays in the error log during recovery. Can be 0 or 1. The default is 0, which means that SQL Server writes only the database name and a message stating that recovery is in progress. 1 means that SQL Server displays information about each individual transaction, including whether it was canceled or committed.</dd>
<dt>
recovery interval*</dt>
<dd>
Sets the maximum number of minutes per database that SQL Server needs to complete its recovery procedures in case of a system failure. The default is 5 minutes per database.
<p>
SQL Server uses this number and the amount of activity on each database to decide when to do a checkpoint on each database. When SQL Server does a checkpoint, it writes all dirty pages (data pages that have been changed by data modification statements) to the disk. The checkpoint also performs a few other housekeeping tasks, including truncating the transaction log if this option has been set using the <b>sp_dboption </b>system stored procedure. A typical checkpoint takes about 1 second.

<p>
You might want to change the recovery interval as your application and its use change. For example, to guarantee that changes are frequently written to the disk, you can shorten the recovery interval when there is a lot of update activity. Shortening the recovery interval causes more frequent checkpoints, which slows the system slightly. On the other hand, setting the recovery interval too high might cause the recovery time to be unacceptably long.
</dd>
<dt>
remote access</dt>
<dd>
Controls logins from remote SQL Servers. Can be 0 or 1. The default is 1. Set <b>remote access</b> to 0 to discontinue allowing remote access to or from a server.</dd>
<dt>
<b>remote login timeout*</b></dt>
<dd>
Specifies the number of seconds to wait before returning from a remote login attempt. A value of 0 will allow an infinite wait.</dd>
<dt>
<b>remote query timeout*</b></dt>
<dd>
Specifies the number of seconds to wait before returning from processing a remote query. A value of 0 will allow an infinite wait.</dd>
<dt>
<b>resource timeout*</b></dt>
<dd>
Specifies the number of seconds to wait for a resource to be released. The default is 10. Increase this value if the SQL Server error log shows a lot of "logwrite" or "bufwait" timeout warnings.</dd>
<dt>
<b>set working set size</b></dt>
<dd>
Directs Windows NT to reserve physical memory space for SQL Server equal to the sum of the <b>memory</b> setting and the size of <i>tempdb</i> if it is in RAM.</dd>
<dt>
show advanced option*</dt>
<dd>
Determines whether or not the advanced options should be displayed by the <b>sp_configure </b>system stored procedure. When set to 1, the advanced options are displayed. The default is 0.</dd>
<dt>
<b>SMP concurrency</b></dt>
<dd>
Controls the number of threads that SQL Server will release to Windows NT for execution which, in effect, limits the number of CPUs used by SQL Server. On a uniprocessor computer, the optimal value is 1. On a symmetric multiprocessor (SMP) computer, the limit depends on whether or not the server is a dedicated SQL Server. If the server is not dedicated, reconfiguring this value can cause poor response time to other applications running on the same machine. If response time for other applications is not an issue, set <b>SMP concurrency</b> to -1, "Dedicated SMP Support," which means that there is no limit. 
<p>
When SQL Server is installed, <b>SMP concurrency</b> will be set to 0, which means auto configure. In auto configure mode, the limit is set to <i>N-1</i>, where <i>N </i>is the number of processors detected at SQL Server startup. On a uni-processor machine this value will be set to 1. If "Dedicated SMP Support" is chosen, then <b>SMP concurrency</b> will be set to -1. 
</dd>
<dt>
<b>sort pages*</b></dt>
<dd>
Specifies the maximum number of pages that will be allocated to sorting per user. On systems that perform large sorts, increasing this number can improve performance. Since additional sort pages will consume memory, increasing this value can make it necessary to increase the amount of memory dedicated to the server.</dd>
<dt>
<b>spin counter*</b></dt>
<dd>
Specifies the maximum number of attempts a process will perform to obtain a resource. By default, SQL Server will attempt to set this value to 10000. This is the default for multiprocessor machines. On uniprocessor machines, the run value will default to 10.</dd>
<dt>
tempdb in ram (MB)</dt>
<dd>
Accepts a value for the size of the <i>tempdb</i> database, in megabytes. Zero causes <i>tempdb</i> to reside on a disk device; the default is the MASTER device. A non-zero value is the size of the <i>tempdb</i> in RAM. Regardless of whether it exists on disk or in RAM, <i>tempdb</i> is altered in the same way as any other database; however, when <i>tempdb</i> resides in RAM, it can be altered only 10 times without requiring the server to be shut down and restarted.
<p>
Altering <i>tempdb</i> while it is in RAM causes each alteration of the database to allocate a new "chunk" of contiguous memory to <i>tempdb</i>. This chunk of memory, although it is contiguous, is not necessarily located next to the existing portion(s) of <i>tempdb</i> in RAM. In order to obtain maximum performance, the server should be stopped and restarted after <i>tempdb</i> is altered.


<p>
<b>Important</b>  If <i>tempdb</i> is in RAM at the time of an upgrade, it will subsequently be moved out of RAM. The default disk device(s) must have the minimum amount free (2 MB) to create <i>tempdb</i>. If not, SQL Server startup will fail. To temporarily force a 2-MB <i>tempdb</i> in RAM, use the <b>-f</b> flag on the command line with SQLSERVR.EXE. This will allow the server to start. Once it has started, you must perform one of the following options immediately:

<ul>
<li>
Increase the size of a default device</li>
<li>
Free space on a default device</li>
<li>
Add a default device</li>
</ul>
</dd>
<dt>
<b>time slice</b></dt>
<dd>
Sets the number of times that a user process is allowed to pass through a yield point without voluntarily yielding. If the <b>time slice</b> is set too low, SQL Server can spend too much time switching processes. If it is set too high, users can experience long response time.
<p>
The default is 100. There is seldom reason to change it.
</dd>
<dt>
user connections</dt>
<dd>
Sets the maximum number of simultaneous connections to SQL Server allowed. The actual number of possible connections might be less than this value, depending on your database environment.
<p>
The number of user connections allowed depends on your version. For SQL Workstation, the number is 15, and for SQL Server the number is 32,767. However, the actual number is based on practical limits that vary depending on your application and hardware.

<p>
Use this statement to get a report on the maximum number of user connections that your system can use:

<pre>select @@max_connections
</pre>

<p>
The memory overhead per connection is about 40K.

<p>
There is no formula for determining how many connections to allow for each user. Rather, you must estimate this number based on system and user requirements. Users executing DB-Library applications need one connection for each process started with a call to <b>dbopen</b>. On a system with many users, there is more likelihood that connections needed only occasionally can be shared among users. 

</dd>
</dl>
<h4>Permission</h4>
<p>
Execute permission on <b>sp_configure</b> with no parameters or with only the first parameter defaults to all users. Execute permission for <b>sp_configure</b> with both parameters, used to change a configuration option, defaults to the system administrator. RECONFIGURE permission defaults to the system administrator and is not transferable.</p>
<h4>Tables Used</h4>
<p>
<i>master.dbo</i>, <i>master.dbo.syslanguages</i>, <i>sysconfigures</i>, <i>syscurconfigs</i>, <i>spt_values</i></p>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;List the Advanced Configuration Options</h5>
<p>
This example shows how to set and list all configuration options. Advanced configuration options are displayed by first setting the <b>show advanced</b> <b>option</b> to 1. After this has been changed, executing <b>sp_configure</b> with no parameters will display all configuration options. </p>
<pre>sp_configure 'show advanced option', 1
go
    Configuration option changed. Run the RECONFIGURE command to install.
RECONFIGURE
go
sp_configure</pre>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Change a Configuration Option</h5>
<p>
This example sets the system recovery interval to 3 minutes.</p>
<pre>sp_configure 'recovery interval', 3</pre>
<h4>See Also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql11_7dv8.htm">RECONFIGURE</a></td>
<td width=52%><a href="tsql20_6mp1.htm"><b>sp_defaultlanguage</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql20_1tnp.htm"><b>sp_dboption</b></a></td>
<td width=52%><a href="tsql21_8s4l.htm"><b>sp_droplanguage</b></a></td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
