<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Trace Flags</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_trace_flags"></a>Trace Flags </h1>
<p>
For SQL Server 6.5 information, see <a href="../../hydra/tsql/src/addnfeat_76t0.htm">Trace Flags</a> in <i>What's New for SQL Server 6.5</i>.</p>
<p>
Trace Flags are used to temporarily set a specific server characteristic. Trace flags can be activated through two methods: by using the DBCC statement and with the <b>-T </b>option with the <b>sqlservr</b> command-line executable. When set, trace flags are in effect only until reset (for options set with the DBCC statement) or until the server is stopped and restarted. For details, see the Utilities topic and the DBCC statement. For details on troubleshooting and setting and using trace flags, see the <i>Microsoft SQL Server Administrator's Companion</i>. </p>
<p>
The following table summarizes the trace flags available in SQL Server 6.0. These trace flags are provided primarily for backward compatibility. In general, trace flags should be used to temporarily work around a problem until a permanent solution is put in place. Trace flags are not a part of the supported feature set, and future compatibility or continued use is not assured. </p>
<p>
These are the trace flags available in SQL Server 6.0:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=15%></th>
<th align=left width=85%></th>
</tr>
<tr valign=top>
<th align=left width=15%></th>
<th align=left width=85%></th>
</tr>
<tr valign=top>
<th align=left width=15%>Trace <br>
flag</th>
<th align=left width=85%><br>
Description</th>
</tr>
<tr valign=top>
<td width=15%>- 1</td>
<td width=85%>Sets trace flags for all client connections, rather than for a single client connection. Because trace flags set using the <b>-T</b> command-line option (with <b>sqlservr</b>) automatically apply to all connections, this trace flag is used only when setting trace flags using DBCC TRACEON and DBCC TRACEOFF. For details, see the <b>sqlservr </b>command-line executable and DBCC statement.</td>
</tr>
<tr valign=top>
<td width=15%>106</td>
<td width=85%>Disables line number information for syntax errors.</td>
</tr>
<tr valign=top>
<td width=15%>107</td>
<td width=85%>Interprets numbers with a decimal point as <i>float </i>instead of <i>decimal</i>. For details, see the Datatypes topic.</td>
</tr>
<tr valign=top>
<td width=15%>204</td>
<td width=85%>Generally, allows non-ANSI-standard behavior for various features:<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Allows queries that contain aggregates or a <br>
&nbsp;&nbsp;&nbsp;&nbsp;GROUP BY clause to have items in the select list <br>
&nbsp;&nbsp;&nbsp;&nbsp;that are not in the GROUP BY clause and are not <br>
&nbsp;&nbsp;&nbsp;&nbsp;aggregate functions. ANSI-standard SQL does not <br>
&nbsp;&nbsp;&nbsp;&nbsp;allow this.<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Ignores trailing blanks in the LIKE pattern. For details, <br>
&nbsp;&nbsp;&nbsp;&nbsp;see the Search Conditions and Wildcard Characters <br>
&nbsp;&nbsp;&nbsp;&nbsp;topics. </td>
</tr>
<tr valign=top>
<td width=15%>206</td>
<td width=85%>Provides backward compatibility for the SETUSER statement. For details, see the SETUSER statement.</td>
</tr>
<tr valign=top>
<td width=15%>243</td>
<td width=85%>Provides backward compatibility for nullability behavior. When set, SQL Server has the same nullability violation behavior as that of a 4.2 server:<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Processing of the entire batch will be terminated if <br>
&nbsp;&nbsp;&nbsp;&nbsp;the nullability error (inserting NULL into a NOT <br>
&nbsp;&nbsp;&nbsp;&nbsp;NULL field) can be detected at compile time<br>
·&nbsp;&nbsp;&nbsp;&nbsp;Processing of the offending row will be skipped <br>
&nbsp;&nbsp;&nbsp;&nbsp;but the command will continue if the nullability <br>
&nbsp;&nbsp;&nbsp;&nbsp;violation is detected at run time<br>
<br>
The behavior of SQL Server 6.0 is now more consistent ¾ all nullability checks are made at run time and a nullability violation results in the command terminating but the batch/transaction continuing to process.</td>
</tr>
<tr valign=top>
<td width=15%>244</td>
<td width=85%>Disables checking for allowed interim constraint violations. By default, SQL Server checks for and allows interim constraint violations. An interim constraint violation is caused by a change that initially violates a constraint, followed by another change that removes the violation such that the constraint is met, all within a single statement and transaction. SQL Server checks for interim constraint violations for self-referencing DELETE statements, INSERT statements based on a SELECT, and multi-row UPDATE statements. This checking requires more work tables. With this trace flag you can disallow interim constraint violations, thus requiring fewer work tables.</td>
</tr>
<tr valign=top>
<td width=15%>302</td>
<td width=85%>Prints information about whether the statistics page is used, the actual selectivity (if available), and what SQL Server estimated the physical and logical I/O would be for the indexes. Index selection information is also available in a more readable format using SET SHOWPLAN ON, as described with the SET statement. Trace flag 302 should be used with trace flag 310 to show the actual join ordering.</td>
</tr>
<tr valign=top>
<td width=15%>310</td>
<td width=85%>Prints information about join order. </td>
</tr>
<tr valign=top>
<td width=15%>325</td>
<td width=85%>Prints information about the cost of using a nonclustered index or a sort to process an ORDER BY clause.</td>
</tr>
<tr valign=top>
<td width=15%>326</td>
<td width=85%>Prints information about the estimated and actual cost of sorts.</td>
</tr>
<tr valign=top>
<td width=15%>652</td>
<td width=85%>Disables read ahead for the server.</td>
</tr>
<tr valign=top>
<td width=15%>653</td>
<td width=85%>Disables read ahead for the current connection.</td>
</tr>
<tr valign=top>
<td width=15%>1200</td>
<td width=85%>Prints lock information (the process ID and type of lock requested).</td>
</tr>
<tr valign=top>
<td width=15%>1204</td>
<td width=85%>Returns the type of locks participating in the deadlock and the current command affected.</td>
</tr>
<tr valign=top>
<td width=15%>1205</td>
<td width=85%>Returns more detailed information on the command being executed at the time of a deadlock.</td>
</tr>
<tr valign=top>
<td width=15%>1609</td>
<td width=85%>Turns on the unpacking and checking of RPC information with the execution of the <b>sp_sqlexec </b>extended stored procedure in Open Data Services. Use this flag only when applications depend on the old behavior. The application should be changed to use EXECUTE <i>sql_string </i>rather than <b>sp_sqlexec</b>. For details, see the EXECUTE statement.</td>
</tr>
<tr valign=top>
<td width=15%>1704</td>
<td width=85%>Prints information when a temporary table is created or dropped.</td>
</tr>
<tr valign=top>
<td width=15%>3502</td>
<td width=85%>Prints a message to the log at the start and end of each checkpoint.</td>
</tr>
<tr valign=top>
<td width=15%>3205</td>
<td width=85%>By default, if a tape drive supports hardware compression, the DUMP statement will use it. With this trace flag, you can disable hardware compression for tape drives. This might be useful when you want to exchange tapes with other sites or tape drives that do not support compression.</td>
</tr>
<tr valign=top>
<td width=15%>3503</td>
<td width=85%>Indicates whether the checkpoint at the end of automatic recovery was skipped for a database (this applies only to READ ONLY databases). For details, see the <b>sp_dboption </b>system stored procedure.</td>
</tr>
<tr valign=top>
<td width=15%>3604</td>
<td width=85%>Sends trace output to the client. ( ) This trace flag is used only when setting trace flags with DBCC TRACEON and DBCC TRACEOFF.</td>
</tr>
<tr valign=top>
<td width=15%>3605</td>
<td width=85%>Sends trace output to the error log. (If you start SQL Server from the command line, the output will also appear on the screen.)</td>
</tr>
<tr valign=top>
<td width=15%>3607</td>
<td width=85%>Skips automatic recovery for all databases.</td>
</tr>
<tr valign=top>
<td width=15%>3608</td>
<td width=85%>Skips automatic recovery for all databases except the <i>master </i>database.</td>
</tr>
<tr valign=top>
<td width=15%>3609</td>
<td width=85%>Skips the creation of the <i>tempdb</i> database. Use this trace flag if the device or devices on which <i>tempdb </i>resides are problematic or problems exist in the <i>model </i>database.</td>
</tr>
<tr valign=top>
<td width=15%>3640</td>
<td width=85%>Eliminates the sending of DONE_IN_PROC messages to the client for each statement in a stored procedure. This is similar to the session setting NOCOUNT, but when set as a trace flag every client session is handled this way. For details, see the SET statement.</td>
</tr>
<tr valign=top>
<td width=15%>4022</td>
<td width=85%>Skips the execution of all startup stored procedures. For more information, see the CREATE PROCEDURE statement and the <b>sp_makestartup </b>system stored procedure.</td>
</tr>
<tr valign=top>
<td width=15%>4030</td>
<td width=85%>Prints both a byte and ASCII representation of the receive buffer. This trace flag is usually used when you need to see what queries a client is sending to SQL Server. You might use this trace flag if you experience a protection violation and need to determine which statement caused it. Typically, you would set this flag globally or use SQL Enterprise Manager. You can also use DBCC INPUTBUFFER. For details, see the DBCC statement.</td>
</tr>
<tr valign=top>
<td width=15%>4031</td>
<td width=85%>Prints both a byte and ASCII representation of the send buffers (what SQL Server sends back to the client). You can also use DBCC OUTPUTBUFFER. For details, see the DBCC statement.</td>
</tr>
<tr valign=top>
<td width=15%>4032</td>
<td width=85%>Prints only an ASCII representation of the receive buffer. Usually used in place of trace flag 4030 (if trace output speed is important) when you need to see what queries a client is sending to SQL Server.</td>
</tr>
</table><br>
<h4>See also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql06_2oxi.htm">Datatypes</a></td>
<td width=52%><a href="tsql12_8mt0.htm">SET</a> </td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql06_0yus.htm">DBCC</a></td>
<td width=52%><a href="tsql30_2fdx.htm"><b>sqlservr</b> Command-line Executable</a></td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
