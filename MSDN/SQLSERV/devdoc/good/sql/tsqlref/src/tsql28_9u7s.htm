<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Transactions</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_transactions_tsql28"></a>Transactions</h1>
<p>
A transaction is a single unit of work. Any single SQL statement is considered to be a single unit of work whether it affects only a single row or multiple rows within a table. In SQL Server, a transaction is implicit (due to the nature of the statements executed) or explicit (as defined by the user). An explicit transaction is a grouping of SQL statements surrounded by the transaction delimiters: BEGIN TRANSACTION, COMMIT TRANSACTION, and optionally, one of the following statements. In creating explicitly defined transactions, the following statements are used:
<ul>
<li>
BEGIN TRANSACTION </li>
<li>
COMMIT TRANSACTION </li>
<li>
ROLLBACK TRANSACTION </li>
<li>
SAVE TRANSACTION </li>
</ul>
<p>
All transactions must be enclosed within BEGIN TRANSACTION...COMMIT TRANSACTION statements. The outermost pair actually creates and commits the transaction; the inner pairs track the nesting level. When a nested transaction is encountered, the global variable @@TRANCOUNT is incremented. </p>
<p>
Naming nested transactions with a <i>transaction_name</i> has little effect on the outermost transaction. Only the first (outermost) transaction name is registered with the system, and a rollback to any other name (other than a valid savepoint name) generates an error. None of the statements executed before the rollback are rolled back when this error occurs. No portion of the transaction is committed until the outermost COMMIT TRANSACTION is issued. Normally, this apparent transaction nesting occurs as stored procedures or triggers with BEGIN...COMMIT pairs call each other. </p>
<p>
Although transactions can be nested, they have little effect on the behavior of ROLLBACK TRANSACTION statements, except for generating errors if not handled properly. The syntax allows stored procedures and triggers to be called from within transactions if they contain BEGIN TRANSACTION and COMMIT TRANSACTION statements.</p>
<p>
Grouping a large number of Transact-SQL statements into one long-running transaction can negatively affect recovery time and cause concurrency problems. If SQL Server fails during such a transaction, recovery time can increase because SQL Server must first undo the transaction. Wherever possible, it is wise to break transactions into smaller transactions. Make sure each transaction is well-defined within a single batch. To minimize possible concurrency conflicts, transactions should not span multiple batches nor wait for user input.</p>
<p>
In stored procedures and triggers, the number of BEGIN TRANSACTION statements must match the number of COMMIT TRANSACTION statements. A procedure or trigger that contains unpaired BEGIN TRANSACTION and COMMIT TRANSACTION statements produces an error message when it is executed.</p>
<h3>Transaction Rules</h3>
<p>
To define a transaction, place Transact-SQL statements and/or stored procedures between the statements BEGIN TRANSACTION and COMMIT TRANSACTION. Within a user-defined (or explicit) transaction, there are some important rules to follow:
<ul>
<li>
Do not use the following statements inside a user-defined transaction: </li>
</ul>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=31%></td>
<td width=34%></td>
<td width=35%></td>
</tr>
<tr valign=top>
<td width=31%>ALTER DATABASE</td>
<td width=34%>DISK INIT</td>
<td width=35%>LOAD TRANSACTION</td>
</tr>
<tr valign=top>
<td width=31%>CREATE DATABASE</td>
<td width=34%>DROP <i>&lt;objname&gt;</i></td>
<td width=35%>RECONFIGURE</td>
</tr>
<tr valign=top>
<td width=31%>CREATE INDEX</td>
<td width=34%>DUMP TRANSACTION</td>
<td width=35%>SELECT INTO</td>
</tr>
<tr valign=top>
<td width=31%>CREATE PROCEDURE</td>
<td width=34%>GRANT or REVOKE</td>
<td width=35%>TRUNCATE TABLE</td>
</tr>
<tr valign=top>
<td width=31%>CREATE TABLE</td>
<td width=34%>LOAD DATABASE</td>
<td width=35%>UPDATE STATISTICS</td>
</tr>
<tr valign=top>
<td width=31%>CREATE VIEW</td>
<td width=34%></td>
<td width=35%></td>
</tr>
</table><br>
<ul>
<li>
If they create a temporary table, you cannot use a system stored procedure inside a user-defined transaction.<p>
<b>Note</b>  Additionally, you cannot use the <b>sp_dboption</b> system stored procedure to set database options or use any system procedures that change the <i>master</i> database inside user-defined transactions. 
</li>
<li>
To cancel all or part of a transaction (to a previously defined savepoint), use the statement ROLLBACK TRANSACTION <i>transaction_name</i>. The transaction's statements or procedures that have changed the database are undone. The ROLLBACK TRANSACTION statement must appear within a transaction. You cannot roll back a transaction after COMMIT TRANSACTION has been entered.</li>
<li>
Calls to remote stored procedures are executed independently of any transaction in which they're included.<p>
<b>Important</b>  Statements executed with calls to remote stored procedures are not rolled back with ROLLBACK TRANSACTION, and they do not depend on COMMIT TRANSACTION to be executed. In other words, statements executed on a remote server through remote stored procedures happen outside the scope of the local user-defined transaction.
</li>
</ul>
<p>
No explicit permission is necessary to define a transaction. By default, all users can define a transaction. All statements used within a transaction follow their specific permission rules. </p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
