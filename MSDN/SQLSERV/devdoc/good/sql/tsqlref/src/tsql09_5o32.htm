<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>CONVERT Function</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="_convert_function"></a>CONVERT Function </h2>
<p>
The CONVERT function converts an <i>expression</i> of one datatype to another datatype. Also obtains a variety of special date formats.</p>
<h4>Syntax</h4>
<p>
CONVERT <b>(</b><i>datatype</i>[<b>(</b><i>length</i><b>)</b>]<b>,</b> <i>expression</i> [<b>,</b> <i>style</i>]<b>)</b></p>
<p>
where
<dl>
<dt>
<i>datatype</i></dt>
<dd>
Is any system datatype (for example, <i>char</i>(10), <i>varbinary</i>, <i>int</i>) into which the expression is to be converted. User-defined datatypes cannot be used.</dd>
<dt>
<i>length</i></dt>
<dd>
Is an optional parameter with <i>char</i>, <i>varchar</i>, <i>binary</i>, and <i>varbinary</i> datatypes. 

<p>
<b>Note</b>  For datatypes where specifying length (<i>n)</i> is optional ¾ (<i>binary</i>[<b>(</b><i>n</i><b>)</b>], <i>char</i>[<b>(</b><i>n</i><b>)</b>], <i>varbinary</i>[<b>(</b><i>n</i><b>)</b>], and <i>varchar</i>[<b>(</b><i>n</i><b>)</b>]) ¾ SQL Server uses 30 for the length.


<p>
The maximum allowable length is 255.
</dd>
<dt>
<i>expression</i></dt>
<dd>
Follows the rules for expressions. For more information, see the Expressions topic.</dd>
<dt>
<i>style</i></dt>
<dd>
Is the style of date representation you want when converting <i>datetime</i> or <i>smalldatetime</i> data to character data. In the following table, the two columns on the left represent the <i>style</i> values. Add 100 to a <i>style</i> value to get a four-place year that includes the century (yyyy).

<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=18%></th>
<th align=left width=22%></th>
<th align=left width=26%></th>
<th align=left width=34%></th>
</tr>
<tr valign=top>
<th align=left width=18%></th>
<th align=left width=22%></th>
<th align=left width=26%></th>
<th align=left width=34%></th>
</tr>
<tr valign=top>
<th align=left width=18%>Without <br>
century <br>
(yy)</th>
<th align=left width=22%>With <br>
century <br>
(yyyy)</th>
<th align=left width=26%><br>
<br>
Standard</th>
<th align=left width=34%><br>
<br>
Output</th>
</tr>
<tr valign=top>
<td width=18%>-</td>
<td width=22%>0 or 100 (*) </td>
<td width=26%>Default</td>
<td width=34%>mon dd yyyy hh:miAM (or PM)</td>
</tr>
<tr valign=top>
<td width=18%>1</td>
<td width=22%>101</td>
<td width=26%>USA</td>
<td width=34%>mm/dd/yy</td>
</tr>
<tr valign=top>
<td width=18%>2</td>
<td width=22%>102</td>
<td width=26%>ANSI</td>
<td width=34%>yy.mm.dd</td>
</tr>
<tr valign=top>
<td width=18%>3</td>
<td width=22%>103</td>
<td width=26%>British/French</td>
<td width=34%>dd/mm/yy</td>
</tr>
<tr valign=top>
<td width=18%>4</td>
<td width=22%>104</td>
<td width=26%>German</td>
<td width=34%>dd.mm.yy</td>
</tr>
<tr valign=top>
<td width=18%>5</td>
<td width=22%>105</td>
<td width=26%>Italian</td>
<td width=34%>dd-mm-yy</td>
</tr>
<tr valign=top>
<td width=18%>6</td>
<td width=22%>106</td>
<td width=26%>-</td>
<td width=34%>dd mon yy</td>
</tr>
<tr valign=top>
<td width=18%>7</td>
<td width=22%>107</td>
<td width=26%>-</td>
<td width=34%>mon dd, yy</td>
</tr>
<tr valign=top>
<td width=18%>8</td>
<td width=22%>108</td>
<td width=26%>-</td>
<td width=34%>hh:mm:ss</td>
</tr>
<tr valign=top>
<td width=18%>-</td>
<td width=22%>9 or 109 (*) </td>
<td width=26%>Default  milliseconds</td>
<td width=34%>mon dd yyyy hh:mi:ss:mmmAM (or PM)</td>
</tr>
<tr valign=top>
<td width=18%>10</td>
<td width=22%>110</td>
<td width=26%>USA</td>
<td width=34%>mm-dd-yy</td>
</tr>
<tr valign=top>
<td width=18%>11</td>
<td width=22%>111</td>
<td width=26%>JAPAN</td>
<td width=34%>yy/mm/dd</td>
</tr>
<tr valign=top>
<td width=18%>12</td>
<td width=22%>112</td>
<td width=26%>ISO</td>
<td width=34%>yymmdd</td>
</tr>
<tr valign=top>
<td width=18%>-</td>
<td width=22%>13 or 113 (*) </td>
<td width=26%>Europe default  milliseconds</td>
<td width=34%>dd mon yyyy hh:mm:ss:mmm(24h)</td>
</tr>
<tr valign=top>
<td width=18%>14</td>
<td width=22%>114</td>
<td width=26%>-</td>
<td width=34%>hh:mi:ss:mmm(24h)</td>
</tr>
<tr valign=top>
<td colspan=4 width=100%>*&nbsp;&nbsp;&nbsp;&nbsp;The default values (<i>style</i> 0 or 100, 9 or 109, and 13 or 113) always return the <br>
&nbsp;&nbsp;&nbsp;&nbsp;century (yyyy).</td>
</tr>
</table><br>


<p>
When converting to character data from <i>smalldatetime</i>, the styles that include seconds or milliseconds show zeros in these positions. You can truncate unwanted date parts when converting from <i>datetime</i> or <i>smalldatetime</i> values by using an appropriate <i>char</i> or <i>varchar</i> datatype length.

</dd>
</dl>
<h4>Remarks</h4>
<p>
SQL Server automatically handles certain datatype conversions. For example, if you compare a character expression and a <i>datetime</i> expression, or a <i>smallint</i> expression and an <i>int</i> expression, or character expressions of different lengths, SQL Server makes the conversion automatically for the comparison. You are not required to use CONVERT; however, it is never wrong to use the CONVERT function even when you are comparing two expressions of exactly the same datatype. CONVERT can be used in a select list or in a WHERE clause.</p>
<p>
When concatenating noncharacter, nonbinary expressions, always use the CONVERT function. For example:</p>
<pre>SELECT 'The date is ' + CONVERT(varchar(12), getdate())
</pre>
<p>
Automatic conversion is not supported for the <i>text</i> and <i>image</i> datatypes. You can explicitly convert <i>text</i> data to character data, and <i>image</i> data to <i>binary</i> or <i>varbinary</i>, but the maximum length you can specify is 255. If you attempt a conversion that is not possible (for example, if you try to convert a character expression that includes letters to an <i>int</i>), SQL Server generates an error message.</p>
<p>
When converting between types with a different number of decimal places, the value is rounded to the most precise digit. The result of the following is 10:</p>
<pre>SELECT CONVERT(int, 10.6496)
</pre>
<p>
This table shows the possible datatype conversions.</p>
<p>
<img src="images/lrdatahd.gif" border=0></p>
<table cellspacing=4 cols=3>
<tr valign=top>
<td width=8%>Key:</td>
<td width=90%>I&nbsp;&nbsp;&nbsp;&nbsp;Implicit conversion</td>
</tr>
<tr valign=top>
<td width=8%></td>
<td colspan=2 width=92%>E&nbsp;&nbsp;&nbsp;&nbsp;Explicit conversion, CONVERT function must be used</td>
</tr>
<tr valign=top>
<td width=8%></td>
<td colspan=2 width=92%>N&nbsp;&nbsp;&nbsp;&nbsp;Conversion not allowed</td>
</tr>
<tr valign=top>
<td width=8%></td>
<td colspan=2 width=92%>*&nbsp;&nbsp;&nbsp;&nbsp;Converting from <i>decimal</i> or <i>numeric</i> to <i>decimal</i> or <i>numeric</i> requires CONVERT when<br>
&nbsp;&nbsp;&nbsp;&nbsp; a loss of precision or scale will occur.</td>
</tr>
<tr valign=top>
<td width=8%></td>
<td colspan=2 width=92%>-&nbsp;&nbsp;&nbsp;&nbsp;Conversion of a datatype to itself; allowed but meaningless</td>
</tr>
</table><br>
<h4><i>binary </i>and <i>varbinary</i></h4>
<p>
Convert to <i>binary</i> to display the internal representation of a value. If lengths differ, the binary value is padded with zeros on the left.</p>
<p>
You can convert <i>int</i>, <i>smallint</i>, and <i>tinyint</i> to <i>binary</i> or <i>varbinary</i>, but if you convert the binary value back to an integer value, it may be different from the original integer value. In addition, if the integer is longer than the specified <i>binary</i> length, it is truncated. For example, a conversion from a long <i>binary</i> to an <i>int</i> value uses only the 4 rightmost bytes of the <i>binary</i> value. The following example shows why <i>binary</i> and <i>varbinary</i> datatypes should be used only for hexadecimal numbers that are interpreted as type streams, and should not be used in calculations. </p>
<pre>SELECT CONVERT(int,0x0001000008ae36f0)
SELECT CONVERT(int,0x00010000)

------

145635056

(1 row affected)

------

65536

(1 row affected)
</pre>
<h4><i>bit</i></h4>
<p>
Converting to <i>bit</i> promotes any nonzero value to 1.</p>
<h4>Character data</h4>
<p>
When character expressions are converted to a character datatype of a different size, values too long for the new datatype are truncated.</p>
<p>
Character expressions being converted to an approximate numeric datatype can include optional exponential notation (a lowercase e or uppercase E followed by an optional plus () or minus (-) sign and then a number).</p>
<p>
Character expressions being converted to an exact numeric datatype must consist of digits, a decimal point, and an optional plus () or minus (-) sign. Leading blanks are ignored. </p>
<p>
Character expressions being converted to money datatypes can also include an optional decimal point and dollar sign ($).</p>
<h4><i>datetime </i>and <i>smalldatetime</i></h4>
<p>
When converting to <i>datetime</i>, SQL Server rejects all values it cannot recognize as dates (including dates earlier than January 1, 1753). You can convert <i>datetime</i> values to <i>smalldatetime</i> when the date is in the proper range (January 1, 1900 to June 6, 2079). The time value is rounded up to the nearest minute.</p>
<h4><i>float</i></h4>
<p>
Values of <i>float</i> are truncated when converted to any integer type.</p>
<p>
When you are converting from <i>float</i> or <i>real</i> to character data, the string function STR( ) is usually a better choice than CONVERT( ), because STR( ) gives you more control over formatting. For more information, see the String Functions topic.</p>
<h4><i>money</i></h4>
<p>
When converting to <i>money</i> from integer datatypes, units are assumed to be dollars. For example, the integer value of 4 is converted to the money equivalent of 4 dollars.</p>
<h4><i>decimal</i> and <i>numeric</i></h4>
<p>
For the <i>decimal</i> and <i>numeric</i> datatypes, SQL Server considers each specific combination of precision and scale as a different datatype. For example, <i>decimal</i>(5,5) and <i>decimal</i>(5,0) are considered different datatypes.</p>
<p>
In Transact-SQL statements, a constant with a decimal point is automatically converted into a <i>numeric</i> data value, using the minimum precision and scale necessary. For example, the constant 12.345 is converted into a <i>numeric</i> value with a precision of 5 and a scale of 3. This behavior is different from earlier versions of SQL Server, which converted constants with a decimal point to <i>float</i>. Therefore, calculations can return slightly different (but more precise) results.</p>
<p>
Converting from <i>decimal</i> or <i>numeric</i> to <i>float</i> or <i>real</i> can result in some loss of precision. Converting from <i>int</i>, <i>smallint</i>, <i>tinyint</i>, <i>float</i>, <i>real</i>, <i>money</i>, or <i>smallmoney</i> to either <i>decimal</i> or <i>numeric</i> can result in overflow.</p>
<p>
If you perform arithmetic on two exact numeric values, <i>v1</i> and <i>v2</i>, where <i>v1</i> has a precision of <i>p1</i> and a scale of <i>s1</i>, and where <i>v2</i> has a precision of <i>p2</i> and <i>s2</i>, the precision and scale of the result depends on the operator (with an absolute maximum of @@MAX_PRECISION) and is determined as follows:</p>
<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=20%></th>
<th align=left width=45%></th>
<th align=left width=35%></th>
</tr>
<tr valign=top>
<th align=left width=20%></th>
<th align=left width=45%></th>
<th align=left width=35%></th>
</tr>
<tr valign=top>
<th align=left width=20%>Operation</th>
<th align=left width=45%>Precision</th>
<th align=left width=35%>Scale</th>
</tr>
<tr valign=top>
<td width=20%>v1  v2</td>
<td width=45%>max(s1,s2)  max(p1-s1,p2-s2)</td>
<td width=35%>max(s1,s2)</td>
</tr>
<tr valign=top>
<td width=20%>v1 - v2</td>
<td width=45%>max(s1,s2)  max(p1-s1,p2-s2)</td>
<td width=35%>max(s2,s2)</td>
</tr>
<tr valign=top>
<td width=20%>v1 * v2</td>
<td width=45%>s1  s2  (p1-s1)  (p2-s2)  1</td>
<td width=35%>s1  s2</td>
</tr>
<tr valign=top>
<td width=20%>v1 / v2</td>
<td width=45%>max(s1+p2-s2+1,6)  p1  p2  1</td>
<td width=35%>max(s1+p2-s2+1,6)</td>
</tr>
</table><br>
<p>
By default, SQL Server uses rounding when converting a number to a <i>decimal</i> or <i>numeric</i> value with a lower precision and scale. However, if the ARITHABORT option is enabled (using the SET statement), SQL Server cancels a query and raises a precision error when an exact numeric operation would result in a loss of precision and scale.</p>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Convert to Character Data with SELECT</h5>
<p>
This example shows how to convert data for display.</p>
<pre>SELECT title, CONVERT(char(12), ytd_sales)
    FROM titles
</pre>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Convert to Character Data in WHERE Clause</h5>
<p>
This example converts sales data to character data prior to performing a string comparison.</p>
<pre>SELECT title, ytd_sales
    FROM titles
        WHERE CONVERT(char(20), ytd_sales) LIKE '1%'
</pre>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Convert to Character Data from the Date Function GETDATE( )</h5>
<p>
This example converts the current date to style 3, dd/mm/yy.</p>
<pre>SELECT CONVERT(char(12), GETDATE(), 3)
</pre>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
