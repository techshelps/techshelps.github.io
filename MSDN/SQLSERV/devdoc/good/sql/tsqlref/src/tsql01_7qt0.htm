<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ALTER TABLE Statement</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_alter_table_statement"></a>ALTER TABLE Statement</h1>
<p>
For SQL Server 6.5 information, see <a href="../../hydra/tsql/src/addnfeat_2ed0.htm">ALTER TABLE Statement</a> in <i>What's New for SQL Server 6.5</i>.</p>
<p>
Adds new columns or constraints to an existing table.</p>
<h4>Syntax</h4>
<p>
ALTER TABLE [<i>database</i><b>.</b>[<i>owner</i>]<b>.</b>]<i>table_name</i> <br>
[WITH NOCHECK]<br>
[ADD<br>
&nbsp;&nbsp;&nbsp;&nbsp;{<i>col_name column_properties </i>[<i>column_constraints</i>]<br>
&nbsp;&nbsp;&nbsp;&nbsp;| [[<b>,</b>] <i>table_constraint</i>]}<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<b>,</b> {<i>next_col_name</i> | <i>next_table_constraint</i>}]...]<br>
| <br>
[DROP [CONSTRAINT] <br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>constraint_name</i> [<b>,</b> <i>constraint_name2</i>]...]</p>
<p>
where
<dl>
<dt>
<i>table_name</i></dt>
<dd>
Specifies which table to alter. You can include local or global temporary tables, but FOREIGN KEY constraints are not enforced on temporary tables.</dd>
<dt>
WITH NOCHECK</dt>
<dd>
Allows CHECK or FOREIGN KEY constraints to be added to a table without verifying existing data for constraint violations. PRIMARY KEY and UNIQUE constraints are always checked. When this option is not specified (the default), any added constraints will be validated against existing data. If there are any constraint violations, the ALTER TABLE statement fails and a message is returned, stating the type of constraint and name that caused the violation. Use this option with extreme caution. This option is useful when you know your data already meets the new constraints or when a business rule requires the constraint to be enforced only from this point forward.

<p>
<b>Note</b>  The WITH NOCHECK option will bypass checking FOREIGN KEY and CHECK constraints only at the time the table is altered. Future data modifications made against any column will demand that all columns satisfy all CHECK constraints, even those columns not included in the UPDATE column list.

</dd>
<dt>
ADD</dt>
<dd>
Allows a column or table-level constraint to be added to an existing table.</dd>
<dt>
<i>col_name</i></dt>
<dd>
Is a new column for the table. Column names must conform to the rules for identifiers and must be unique in the table.</dd>
<dt>
<i>column_properties</i> <b>=</b></dt>
<dd>
<i>datatype</i> [NULL | IDENTITY[<b>(</b><i>seed</i>, <i>increment</i><b>)</b>]]
<dl>
<dt>
<i>datatype</i></dt>
<dd>
Specifies the datatype of the column. System or user-defined datatypes are acceptable. Columns added to a table must be defined as NULL. When a column is added, the initial value for the column will be set to NULL. This restriction forces the ALTER TABLE statement to fail if the <i>bit </i>or <i>timestamp </i>datatypes are used.</dd>
<dt>
IDENTITY[<b>(</b><i>seed</i><b>,</b> <i>increment</i><b>)</b>]</dt>
<dd>
Generates values for existing rows based on the <i>seed</i> and <i>increment</i> parameters. If used, the <i>seed</i> value will be assigned to the first row in the table and each subsequent row will receive the next identity value, equal to the last identity plus the <i>increment </i>value. If neither argument is given, both default to 1. 
</dd>
</dl>

<p>
<b>Note</b>  If the maximum value, based on the datatype for the identity column, is exceeded during the generation of identity values, the ALTER TABLE statement fails and an error is returned.


<p>
The IDENTITY property cannot be added to an existing column; it can be added only to a new column. The IDENTITY property can be assigned a <i>tinyint</i>, <i>smallint</i>, <i>int</i>, <i>decimal</i><b>(</b><i>p</i><b>,</b>0<b>)</b> or <i>numeric</i><b>(</b><i>p</i><b>,</b>0<b>)</b> column that does not allow null values. Defaults and DEFAULT constraints cannot be bound to an identity column, and an identity value cannot be changed. Only one column per table can be defined as an identity column. 
</dd>
<dt>
<i>column_constraints</i> <b>=</b></dt>
<dd>
Can include up to one UNIQUE or FOREIGN KEY constraint, one DEFAULT constraint, and any number of CHECK constraints for each new or existing column. All can be entered within the same ALTER TABLE statement.
<dl>
<dt>
<b>For a column-level UNIQUE constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
UNIQUE [CLUSTERED | NONCLUSTERED] [<b>(</b><i>col_name</i><b>)</b>]<br>
[WITH FILLFACTOR <b>=</b> <i>fillfactor</i>]<br>
[ON <i>segment_name</i>] </dd>
<dt>
<b>For a column-level FOREIGN KEY constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
[FOREIGN KEY [<b>(</b><i>col_name</i><b>)</b>]] <br>
REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i><b>)</b>]</dd>
<dt>
<b>For a column-level DEFAULT constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
DEFAULT {<i>constant</i>_<i>expression</i> | <i>niladic-function</i> | NULL}</dd>
<dt>
<b>For a column-level CHECK constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
CHECK [NOT FOR REPLICATION] <b>(</b><i>expression</i><b>) </b></dd>
</dl>
</dd>
<dt>
<i>table_constraint </i><b>=</b> </dt>
<dd>
Can include up to one PRIMARY KEY constraint per table, one DEFAULT constraint per column, and any number of FOREIGN KEY, UNIQUE, or CHECK constraints on any column or columns. All can be entered within the same ALTER TABLE statement.
<dl>
<dt>
<b>For a table-level PRIMARY KEY constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
PRIMARY KEY [CLUSTERED | NONCLUSTERED]<br>
<b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
[WITH FILLFACTOR <b>=</b> <i>fillfactor</i>]<br>
[ON <i>segment_name</i>] </dd>
<dt>
<b>For a table-level UNIQUE constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
UNIQUE [CLUSTERED | NONCLUSTERED]<br>
<b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
[WITH FILLFACTOR <b>=</b> <i>fillfactor</i>]<br>
[ON <i>segment_name</i>] </dd>
<dt>
<b>For a table-level FOREIGN KEY constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
FOREIGN KEY <b>(</b><i>col_name</i> [<b>,</b> <i>col_name2 </i>[...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i> [<b>, </b><i>ref_col2</i> <br>
[...<b>, </b><i>ref_col16</i>]]<b>)</b>]</dd>
<dt>
<b>For a table-level DEFAULT constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
DEFAULT {<i>constant</i>_<i>expression</i> | <i>niladic-function</i> | NULL}<br>
FOR <i>col_name</i></dd>
<dt>
<b>For a table-level CHECK constraint:</b></dt>
<dd>
[CONSTRAINT <i>constraint_name</i>]<br>
CHECK [NOT FOR REPLICATION] <b>(</b><i>expression</i><b>) </b>
</dd>
</dl>

<p>
<b>Important</b>  When a PRIMARY KEY or UNIQUE constraint is added, an index is automatically created to enforce the constraint. If the constraint creates a clustered index, other indexes (previously created with CREATE INDEX or with other constraints) will need to be rebuilt by the system. Rebuilding indexes can be a potentially time-intensive operation with numerous concurrency ramifications. Whenever possible, make data definition changes when database activity is minimal.

</dd>
<dt>
CONSTRAINT <i>constraint_name</i></dt>
<dd>
Names the given constraint within the database. Constraint names must follow the rules for identifiers, except that the name cannot begin with a pound sign (#). If <i>constraint_name</i> is not supplied, a system-generated name is assigned to the constraint. </dd>
<dt>
UNIQUE [CLUSTERED | NONCLUSTERED]</dt>
<dd>
Provides entity integrity for a given column or columns. Although columns participating in UNIQUE constraints can allow null values, it is not recommended that you use null values. If null values are necessary, the complete key (a single column or multiple columns for a composite index) cannot be NULL for more than one row. Multiple UNIQUE constraints can be defined on a specific table. SQL Server automatically creates a UNIQUE index on this column or columns. UNIQUE key constraints can be dropped only by dropping the associated table or constraint. If no index type is specified, a NONCLUSTERED index is created by default. 
<dl>
<dt>
WITH FILLFACTOR <b>=</b> <i>fillfactor</i></dt>
<dd>
Specifies how full SQL Server makes each index page when creating an index with existing data. </dd>
<dt>
ON <i>segment_name</i></dt>
<dd>
Creates the index on the specified segment. If the index specified is a clustered index, the entire table will be moved to the specified segment. It is important that the segment have at least 1.2 times the space required for the entire table. For more information, see the CREATE INDEX statement.</dd>
</dl>
</dd>
<dt>
[FOREIGN KEY [<b>(</b><i>col_name</i><b>)</b>]] REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i><b>)</b>] </dt>
<dt>
or</dt>
<dt>
FOREIGN KEY <b>(</b><i>col_name</i> [<b>,</b> <i>col_name2</i> [...<b>,</b> <i>col_name16</i>]]<b>)</b><br>
REFERENCES [<i>owner</i><b>.</b>]<i>ref_table</i> [<b>(</b><i>ref_col</i> [<b>,</b> <i>ref_col2 </i>[...<b>,</b> <i>ref_col16</i>]]<b>)</b>]</dt>
<dd>
Provides single- or multicolumn referential integrity. When defined, the number of columns and datatypes of each column specified in the FOREIGN KEY clause must identically match the columns in the REFERENCES clause. Values entered in this column or columns must exist in the table, and column(s) defined in the REFERENCES clause and the referenced table's columns should have a PRIMARY KEY or UNIQUE constraint defined on them. For column-level constraints, using the FOREIGN KEY and <i>col_name</i> identifiers are optional. 
<p>
When a FOREIGN KEY constraint is added to a table, all non-null values in the foreign key column(s) must reference an existing key within the referenced table. If any rows are invalid, the ALTER TABLE statement will fail.


<p>
<b>Important</b>  REFERENCE constraints can reference only tables within the same database; this can include the same table on which the reference is defined (self-referenced tables). If you want cross-database referential integrity or custom messaging, implement these through triggers.

<p>
A table can have a maximum of 31 FOREIGN KEY constraints. This limit is an absolute upper limit; the maximum may be lower depending on the number of work tables the server has to create to enforce the constraint and varies by the type of query being executed. FOREIGN KEY constraints are not enforced for temporary tables. 

<p>
FOREIGN KEY constraints, unlike PRIMARY KEY constraints, do not create an index. To improve performance of data retrieval operations, use the CREATE INDEX statement to create an index on a column with a FOREIGN KEY constraint. This will allow for quicker execution times when a referenced key is modified.


<p>
For a FOREIGN KEY to be successfully created, the user must have SELECT or REFERENCES permission on the referenced column or columns. For details, see the GRANT statement. When a specific reference column(s) is not provided, the primary key for the referenced table is used.


<p>
<b>Note</b>  If REFERENCE constraints are added or altered, any stored procedures that reference the table will be recompiled. This allows changes made to a table definition (through the ALTER TABLE statement) to be visible to procedures created prior to the schema change.

</dd>
<dt>
DEFAULT <i>constant</i>_<i>expression</i> | <i>niladic-function</i> | NULL</dt>
<dd>
Specifies the value that will be provided for the column when one is not explicitly supplied during an insert. A DEFAULT constraint can contain constant values, functions, built-in functions that do not take arguments (<i>niladic-function</i>), or NULL. A <i>constant_expression</i> must follow the same rules as defaults. 
<p>
DEFAULT constraints can be added to columns that are not the <i>timestamp </i>datatype or have the IDENTITY property. If the column was defined with a user-defined datatype that has a default bound to it or if the column has a default bound to it, the DEFAULT constraint will not be allowed and the ALTER TABLE statement will fail. If a default or a DEFAULT constraint already exists for that column, it must be dropped before a DEFAULT constraint can be added. If the default exists on a user-defined datatype, the default must be unbound before that datatype can be used in a table definition with a DEFAULT constraint.

<p>
Niladic-functions allow a system-supplied value to be inserted when no value is specified. ANSI-standard niladic-functions include: 

<ul>
<li>
USER</li>
<li>
CURRENT_USER</li>
<li>
SESSION_USER</li>
<li>
SYSTEM_USER</li>
<li>
CURRENT_TIMESTAMP</li>
</ul>

<p>
USER, CURRENT_USER, and SESSION_USER all default to the database username of the user performing the insert or update. SYSTEM_USER will provide the login ID, and CURRENT_TIMESTAMP will provide the same information as the GETDATE<b>()</b> function. 

<p>
A benefit to using a DEFAULT constraint instead of a default (created with the CREATE DEFAULT statement) is that no explicit binding/unbinding is required and DEFAULT constraints are removed when the table is dropped. 

<p>
When a DEFAULT is added for an existing column (as a table-level constraint), the column to which it applies is specified with FOR <i>col_name</i>.
</dd>
<dt>
CHECK <b>(</b><i>expression</i><b>)</b></dt>
<dd>
Enforces domain integrity by limiting the possible values that can be entered into a column or columns. The search condition must evaluate to a Boolean expression and cannot contain subqueries. CHECK constraints adhere to the same policies as rules, but they are automatically bound to the column(s) on which they are defined. A column-level CHECK constraint can only reference the constrained column, and a table-level CHECK constraint can only reference columns of the constrained table. Multiple CHECK constraints can be defined for a table; however, only one can be defined per column per ALTER TABLE statement (although each column constraint can have multiple conditions). When a rule and one or more CHECK constraints exist for a column or columns, all restrictions are evaluated. If defined on multiple columns, they must be defined as table-level constraints.
<dl>
<dt>
NOT FOR REPLICATION</dt>
<dd>
Prevents the specified CHECK constraint from being enforced for the distribution process used by replication; however, CHECK constraints will be enforced for all other users (including the system administrator). NOT FOR REPLICATION is used to protect horizontally partitioned tables that receive "source" data from a publishing server from data modifications made to the replicated data. When replication is in effect, any modifications to the data that is replicated should be made on the publishing server (the main source of the data) and not on any of the subscribing servers (each of which receives exact copies of the publishing server's data). 
<p>
The NOT FOR REPLICATION CHECK constraint will be applied to both the "before" and "after" image of an updated record to prevent records from being added to or deleted from the replicated range. All deletes and inserts will be checked; if they fall within the replicated range, they will be rejected. 

<p>
When NOT FOR REPLICATION is used with ALTER TABLE, existing data is not checked to see if it meets the requirements of the constraint. The NOT FOR REPLICATION clause behaves as though the NOCHECK option were used on the column(s). All future data modifications, except those occurring through replication, will be checked. 
</dd>
</dl>
</dd>
<dt>
PRIMARY KEY [CLUSTERED | NONCLUSTERED]</dt>
<dd>
Enforces entity integrity only for an existing column or columns. New columns can only be added as a PRIMARY KEY if they have the identity property, because a new non-identity column cannot be defined NOT NULL and a PRIMARY KEY constraint must be NOT NULL. All columns changed to PRIMARY KEY constraint columns must have been defined as NOT NULL.
<p>
To enforce uniqueness of a primary key, SQL Server automatically creates a unique index on this column or columns. This unique index can be dropped only by dropping the associated table or PRIMARY KEY constraint. 

<p>
If no index type is specified, a clustered index is created by default. If NONCLUSTERED is specified or if CLUSTERED is specified for a different UNIQUE constraint in the same statement block, a nonclustered index is created.

<p>
Only one PRIMARY KEY constraint can be specified for a given table. However, "alternate" or "candidate" keys can be effectively created with a UNIQUE constraint.
</dd>
<dt>
DROP CONSTRAINT <i>constraint_name</i></dt>
<dd>
Allows an existing column- or table-level constraint to be removed from the table definition. 
</dd>
</dl>
<h4>Remarks</h4>
<p>
ALTER TABLE adds columns or constraints to a table, or drops constraints from a table, but it does not allow columns to be removed. When constraints are added, all existing data will be verified for constraint violations. If you do not want to verify new CHECK or FOREIGN KEY constraints against existing data, use the WITH NOCHECK option; but this is not recommended.</p>
<p>
The number of columns in a table cannot exceed 250. The maximum number of bytes per row is 1962, not including <i>text</i> or <i>image</i> columns, which are stored with their own separate chain of data pages.</p>
<p>
<b>Important</b>  If a stored procedure using SELECT * references a table that has been altered with new columns, the procedure (even if you use the WITH RECOMPILE option) does not recognize the columns you added to the table. In order for the new columns to be visible to the procedure, you must drop the stored procedure and then re-create it.</p>
<p>
To rename a table, execute the <a href="tsql24_0sx1.htm"><b>sp_rename</b> system stored procedure</a>. To get information on a table and its columns, use the <a href="tsql22_73l1.htm"><b>sp_help </b>system stored procedure</a><b> </b>or the <b>sp_helpconstraint</b> system stored procedure. </p>
<h4>Permission</h4>
<p>
ALTER TABLE permission defaults to the table owner. Permission cannot be transferred; however, the database owner can impersonate the table owner by using the <a href="tsql13_4cfo.htm">SETUSER statement</a>. The system administrator can also alter users' tables.</p>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Add a PRIMARY KEY Constraint</h5>
<p>
The <i>authors </i>table in SQL Server 6.0 includes a PRIMARY KEY constraint on the <i>au_id </i>column. This example shows how to add only this constraint (with an explicit name).</p>
<pre>ALTER TABLE authors
ADD
CONSTRAINT UPKCL_auidind PRIMARY KEY CLUSTERED (au_id) 
</pre>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Add a FOREIGN KEY Constraint</h5>
<p>
The <i>titles </i>table in SQL Server 6.0 includes a foreign key reference to the <i>authors </i>table. This example adds only this constraint (allowing the system to supply a name).</p>
<pre>ALTER TABLE titles
ADD
CONSTRAINT FK_pub_id FOREIGN KEY (pub_id) REFERENCES publishers(pub_id)
</pre>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Add a UNIQUE Constraint</h5>
<p>
The <i>stores </i>table has columns of <i>stor_id</i>, <i>stor_name</i>,<i> </i>and <i>city</i>, where <i>stor_id</i> is the primary key; however, no two stores in the same city should have the same name. This example adds only this constraint.</p>
<pre>ALTER TABLE stores
ADD
CONSTRAINT UNC_name_city UNIQUE NONCLUSTERED (stor_name, city)
</pre>
<h5>D.&nbsp;&nbsp;&nbsp;&nbsp;Add a DEFAULT Constraint</h5>
<p>
The <i>authors </i>table has a <i>phone </i>column where a value is required. This example adds a default value of UNKNOWN for future inserts that do not explicitly enter a phone number.</p>
<pre>ALTER TABLE authors
ADD
DEFAULT 'UNKNOWN' FOR phone
</pre>
<h5>E.&nbsp;&nbsp;&nbsp;&nbsp;Add a CHECK Constraint</h5>
<p>
The <i>authors </i>table has a <i>zip </i>column where a 5-digit character string is required. This example adds a CHECK constraint to guarantee that only numbers are entered.</p>
<pre>ALTER TABLE authors
ADD
CONSTRAINT CK_zip CHECK (zip LIKE '[0-9][0-9][0-9][0-9][0-9]')
</pre>
<h5>F.&nbsp;&nbsp;&nbsp;&nbsp;Add a New Column with Constraints</h5>
<p>
In SQL Server 6.0, the <i>publishers </i>table has a new column called <i>country</i> with a default value of USA. This example adds the <i>country</i> column.</p>
<pre>ALTER TABLE publishers
ADD
country varchar(30)        NULL
        DEFAULT('USA')
</pre>
<h5>G.&nbsp;&nbsp;&nbsp;&nbsp;Complex ALTER TABLE Statement with Multiple Changes</h5>
<p>
In SQL Server 6.0, the <i>publishers</i> table has a CHECK and PRIMARY KEY constraint on the <i>pub_id </i>column and a new column called <i>country</i> with a default value of USA. This example alters the table with all of these changes.</p>
<pre>ALTER TABLE publishers
ADD
country varchar(30)        NULL
        DEFAULT('USA'),
CONSTRAINT UPKCL_pubind PRIMARY KEY CLUSTERED (pub_id) ,
CHECK (pub_id IN ('1389', '0736', '0877', '1622', '1756')
    OR pub_id LIKE '99[0-9][0-9]')
</pre>
<h5>H.&nbsp;&nbsp;&nbsp;&nbsp;Drop a Constraint</h5>
<p>
To drop a constraint, you must first know the constraint name. If the constraint names were not explicitly entered, use either the <b>sp_help </b>or the <b>sp_helpconstraint </b>system stored procedure to retrieve the system-supplied constraint names.</p>
<p>
This example drops the <i>UPKCL_auidind </i>created in example A. </p>
<pre>ALTER TABLE authors
    DROP CONSTRAINT UPKCL_auidind
</pre>
<h4>See Also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql04_5iwk.htm">CREATE TABLE</a></td>
<td width=52%><a href="tsql22_73l1.htm"><b>sp_help</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql07_9v90.htm">DROP TABLE</a></td>
<td width=52%><a href="tsql24_0sx1.htm"><b>sp_rename</b></a></td>
</tr>
</table><br>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
