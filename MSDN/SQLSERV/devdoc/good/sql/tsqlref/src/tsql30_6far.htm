<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Wildcard Characters</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_wildcard_characters"></a>Wildcard Characters </h1>
<p>
Wildcard characters are used with the LIKE keyword to represent any character in a string when searching for a <i>char</i>, <i>varchar</i>, or <i>datetime </i>value.</p>
<h4>Syntax</h4>
<p>
<i>expression</i> [NOT] LIKE <b>'</b><i>string</i><b>'</b></p>
<p>
The <i>string </i>can include these wildcard characters:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=22%></th>
<th align=left width=78%></th>
</tr>
<tr valign=top>
<th align=left width=22%></th>
<th align=left width=78%></th>
</tr>
<tr valign=top>
<th align=left width=22%>Wildcard</th>
<th align=left width=78%>Meaning</th>
</tr>
<tr valign=top>
<td width=22%>%</td>
<td width=78%>Any string of zero or more characters</td>
</tr>
<tr valign=top>
<td width=22%>_&nbsp;(underscore)</td>
<td width=78%>Any single character</td>
</tr>
<tr valign=top>
<td width=22%>[ ]</td>
<td width=78%>Any single character within the specified range ([a-f]) or set ([abcdef])</td>
</tr>
<tr valign=top>
<td width=22%>[^]</td>
<td width=78%>Any single character not within the specified range ([^a-f]) or set ([^abcdef])</td>
</tr>
</table><br>
<h4>Remarks</h4>
<p>
You can use the LIKE keyword and wildcard characters with <i>datetime</i> data as well as with <i>char</i> and <i>varchar</i> data. When you use LIKE with <i>datetime</i> values, SQL Server converts the dates to the standard <i>datetime</i> format and then to <i>varchar</i>. Since the standard storage format doesn't include seconds or milliseconds, you cannot search for seconds or milliseconds with LIKE and a pattern. It is a good idea to use LIKE when you search for <i>datetime</i> values, since <i>datetime</i> entries can contain a variety of date parts. For example, if you insert the value 9:20 into a column named <i>arrival_time</i>, the clause WHERE arrival_time = <b>'</b>9:20<b>'</b> does not find the value because SQL Server converts the entry into <b>'</b>Jan 1, 1900 9:20 AM<b>'</b>. However, the clause WHERE <i>arrival_time</i> LIKE <b>'</b>%9:20%<b>'</b> does find the value.</p>
<p>
To use %, _, [ ], or [^] as literal characters in a LIKE string rather than as wildcards, use square brackets around the percent sign, the underscore, and the open bracket. Use the close bracket by itself. Use the dash as the first character inside a set of square brackets, as shown here:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=21%></th>
<th align=left width=79%></th>
</tr>
<tr valign=top>
<th align=left width=21%></th>
<th align=left width=79%></th>
</tr>
<tr valign=top>
<th align=left width=21%>Symbol</th>
<th align=left width=79%>Meaning</th>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>5%<b>'</b></td>
<td width=79%>5 followed by any string of 0 or more characters</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>5[%]<b>'</b></td>
<td width=79%>5%</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>_n<b>'</b></td>
<td width=79%>an, in, on, and so on</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>[_]n<b>'</b></td>
<td width=79%>_n</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>[a-cdf]<b>'</b></td>
<td width=79%>a, b, c, d, or f</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>[-acdf]<b>'</b></td>
<td width=79%>-, a, c, d, or f</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>[ [ ]<b>'</b></td>
<td width=79%>[</td>
</tr>
<tr valign=top>
<td width=21%>LIKE <b>'</b>]<b>'</b></td>
<td width=79%>]</td>
</tr>
</table><br>
<p>
You can't always duplicate NOT LIKE patterns with LIKE and the negative wildcard [^] because NOT LIKE finds the items that do not match the entire LIKE pattern; LIKE with negative wildcards is evaluated one character at a time.</p>
<p>
For example, this query shows all system tables in a database, because they all begin with the letters <i>sys</i>:</p>
<pre>SELECT name
FROM sysobjects
WHERE name LIKE 'sys%'
</pre>
<p>
To see all objects that are not system tables, use NOT LIKE <b>'</b>sys%<b>'</b>. If you have a total of 32 objects and LIKE finds 13 names that match the pattern, NOT LIKE finds the 19 objects that do not match the LIKE pattern.</p>
<p>
You won't always find the same names with a pattern such as LIKE <b>'</b>[^s][^y][^s]%<b>'</b>. Instead of 19 names, you might get only 14, with all the names that begin with "s" or have "y" as the second letter or have "s" as the third letter eliminated from the results as well as the system table names. This result occurs because match strings with negative wildcards are evaluated in steps, one wildcard at a time. If the match fails at any point in the evaluation, it is eliminated.</p>
<h3>Pattern Matching with Blanks</h3>
<p>
When performing string comparisons with LIKE, all characters in the pattern string are significant, including every leading and/or trailing blank (space).  If a comparison to return all rows with a string LIKE <b>'</b>abc <b>'</b> (abc followed by a single space) is requested, a row where the value of that column is <b>'</b>abc<b>'</b> (abc without a space) will not be returned. The reverse, however, is not true. Trailing blanks in the expression to which the pattern is matched are ignored. If a comparison to return all rows with a string LIKE <b>'</b>abc<b>'</b> (abc without a space) is requested, all rows that start with <b>'</b>abc<b>'</b> and have zero or more trailing blanks would be returned.</p>
<p>
A string comparison using a pattern <i>char </i>and <i>varchar </i>data may not pass a LIKE comparison because of how the data is stored. It is important to understand the storage for each datatype and where a LIKE comparison may fail. In the following example, a local <i>char </i>variable is passed to a stored procedure and then pattern matching is used to find all of the books by a certain author. In this procedure, the author's last name is passed as a variable.</p>
<pre>CREATE PROCEDURE find_books @au_lname char(20)
AS
SELECT @au_lname = RTRIM(@au_lname)  '%'
SELECT t.title_id, t.title 
    FROM authors a, titleauthor ta, titles t
        WHERE a.au_id = ta.au_id AND ta.title_id = t.title_id
        AND a.au_lname LIKE @au_lname
</pre>
<p>
In the <i>find_books</i> procedure, no rows will be returned because the <i>char</i> variable (<i>@au_lname</i>) will contain trailing blanks whenever the name contains fewer than 20 characters. Because the <i>au_lname</i> column is <i>varchar</i>, there are no trailing blanks. This procedure will fail because the trailing blanks are significant. </p>
<p>
This example succeeds because trailing blanks are not added to a <i>varchar</i> variable:</p>
<pre>CREATE PROCEDURE find_books2 @au_lname varchar(20)
AS
SELECT t.title_id, t.title 
    FROM authors a, titleauthor ta, titles t
        WHERE a.au_id = ta.au_id AND ta.title_id = t.title_id
        AND a.au_lname LIKE @au_lname  '%'
</pre>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Pattern Matching with LIKE and %</h5>
<p>
This example finds all phone numbers in the <i>authors</i> table that begin with the 415 area code:</p>
<pre>SELECT phone
    FROM authors
        WHERE phone LIKE '415%'
</pre>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Pattern Matching and Placement of NOT</h5>
<p>
These two queries are equivalent: they find all phone numbers in the <i>authors</i> table that do not begin with the 415 area code:</p>
<pre>SELECT phone
    FROM authors
        WHERE phone NOT LIKE '415%'

SELECT phone
    FROM authors
        WHERE NOT phone LIKE '415%'
</pre>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Multiple Wildcards</h5>
<p>
This example finds all names that have the characters "en" in them (Bennet, Green, McBadden):</p>
<pre>SELECT au_lname
    FROM authors
        WHERE au_lname LIKE '%en%'
</pre>
<h5>D.&nbsp;&nbsp;&nbsp;&nbsp;Single Character Wildcard</h5>
<p>
This example finds six-letter names that end with "heryl" (Cheryl or Sheryl):</p>
<pre>SELECT au_fname
    FROM authors
        WHERE au_fname LIKE '_heryl'
</pre>
<h5>E.&nbsp;&nbsp;&nbsp;&nbsp;Single Character Range</h5>
<p>
This example finds names ending with "inger" and beginning with any single character between "M" and "Z":</p>
<pre>SELECT au_lname
    FROM authors
        WHERE au_lname LIKE '[M-Z]inger'
</pre>
<h5>F.&nbsp;&nbsp;&nbsp;&nbsp;Single Character Listing</h5>
<p>
This example finds both DeFrance and deFrance:</p>
<pre>SELECT au_lname
    FROM authors
        WHERE au_lname LIKE '[dD]eFrance'
</pre>
<h5>G.&nbsp;&nbsp;&nbsp;&nbsp;NOT a Single Character</h5>
<p>
This example finds names beginning with "M" that have a second letter that is not "c":</p>
<pre>SELECT au_lname
    FROM authors
        WHERE au_lname LIKE 'M[^c]%'
</pre>
<h4>See Also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql08_4aur.htm">Expressions</a></td>
<td width=52%><a href="tsql11_33w3.htm">Search Conditions</a></td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
