<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBCC Statement</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_dbcc_statement"></a>DBCC Statement</h1>
<p>
Used to check the logical and physical consistency of a database, check memory usage, decrease the size of a database, check performance statistics, and so on. DBCC is the SQL Server "database consistency checker." DBCC helps ensure the physical and logical consistency of a database; however, DBCC is not corrective. It is recommended that you make periodic checks to ensure the logical and physical consistency of your data.</p>
<h4>Syntax</h4>
<p>
DBCC {<br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECKALLOC [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECKCATALOG [<b>(</b><i>database_name</i><b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECKTABLE <b>(</b><i>table_name</i> [<b>,</b> NOINDEX | <i>index_id</i>]<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECKDB [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;CHECKIDENT [<b>(</b><i>table_name</i><b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;DBREPAIR <b>(</b><i>database_name</i><b>,</b> DROPDB [<b>,</b> NOINIT]<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;<i>dllname </i><b>(</b>FREE<b>) | <br>
&nbsp;&nbsp;&nbsp;&nbsp;</b>INPUTBUFFER <b>(</b><i>spid</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;MEMUSAGE | <br>
&nbsp;&nbsp;&nbsp;&nbsp;NEWALLOC [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;OPENTRAN <b>(</b>{<i>database_name</i>} | {<i>database_id</i>}<b>)</b> <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[WITH TABLERESULTS] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;OUTPUTBUFFER <b>(</b><i>spid</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;PERFMON | <br>
&nbsp;&nbsp;&nbsp;&nbsp;PINTABLE <b>(</b><i>database_id</i>, <i>table_id</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;SHOW_STATISTICS <b>(</b><i>table_name</i><b>,</b> <i>index_name</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;SHOWCONTIG <b>(</b><i>table_id</i><b>,</b> [<i>index_id</i>]<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;SHRINKDB <b>(</b><i>database_name</i> [<b>,</b> <i>new_size </i>[<b>,</b> <b>'</b>MASTEROVERRIDE<b>'</b>]]<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;SQLPERF <b>(</b>{IOSTATS | LRUSTATS | NETSTATS | RASTATS [<b>, </b>CLEAR]} |<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{THREADS} | {LOGSPACE}<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;TEXTALL [<b>(</b>{<i>database_name </i>| <i>database_id</i>}[<b>, </b>FULL | FAST]<b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;TEXTALLOC [<b>(</b>{<i>table_name</i> | <i>table_id</i>}[<b>,</b> FULL | FAST]<b>)</b>] | <br>
&nbsp;&nbsp;&nbsp;&nbsp;TRACEOFF <b>(</b><i>trace#</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;TRACEON <b>(</b><i>trace#</i><b>)</b> |<br>
&nbsp;&nbsp;&nbsp;&nbsp;TRACESTATUS <b>(</b><i>trace# </i>[<b>,</b> <i>trace#</i>...]<b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;UNPINTABLE <b>(</b><i>database_id</i><b>,</b> <i>table_id</i><b>)</b> | <br>
&nbsp;&nbsp;&nbsp;&nbsp;UPDATEUSAGE <b>(</b>{0 | <i>database_name</i>} [<b>,</b> <i>table_name</i> [<b>,</b> <i>index_id</i>]]<b>)</b> |<br>
&nbsp;&nbsp;&nbsp;&nbsp;USEROPTIONS} <br>
[WITH NO_INFOMSGS]</p>
<p>
where
<dl>
<dt>
<i>database_id</i></dt>
<dd>
Specifies the ID of the database in which the command is to be run. If <i>database_id</i> is not supplied, the current database is assumed.</dd>
<dt>
<i>database_name</i></dt>
<dd>
Specifies the database in which the command is to be run. If <i>database_name</i> is not supplied, the current database is assumed.</dd>
<dt>
<i>index_id</i></dt>
<dd>
Specifies the ID of the index to be used. When optional and not specified, the statement is used against all indexes for the specified table. </dd>
<dt>
<i>index_name</i></dt>
<dd>
Specifies the index to be used. </dd>
<dt>
<i>table_id</i></dt>
<dd>
Specifies the ID of the table to be used. When optional and not specified, the statement is used against all tables in the current or specified database. </dd>
<dt>
<i>table_name</i></dt>
<dd>
Specifies the table to be used. </dd>
<dt>
CHECKALLOC [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)]</b></dt>
<dd>
Checks the specified database to make sure that all pages are correctly allocated and used. If no database name is given, CHECKALLOC checks the current database. CHECKALLOC reports on the amount of space allocated and used. 
<p>
DBCC CHECKALLOC is provided for backward compatibility. The preferred DBCC statement is NEWALLOC. NEWALLOC provides more detailed information and will continue to execute even after errors are encountered. For information on the output provided by NEWALLOC, see the NEWALLOC option.


<p>
<b>Note</b>  Before running DBCC CHECKALLOC or DBCC NEWALLOC on a database installed on read-only removable media, set the database status to 'read only' using <b>sp_dboption</b>. This will prevent the SHUTDOWN command from doing a checkpoint in the database. (Otherwise, checkpoint would attempt to write the allocation pages used by DBCC CHECKALLOC or DBCC NEWALLOC for scratch space and encounter I/O errors on the read-only media.
</dd>
</dl>
<p>
As an additional precaution, shut down and restart the server after DBCC has completed to prevent the possibility of a manual checkpoint attempting to write the allocation pages. </p>
<p>
Also note that DBCC CHECKALLOC or DBCC NEWALLOC may print warning message 2558 for user objects residing on a removable device. You can ignore these messages. They arise because the segmap in <i>sysusages</i> for fragments corresponding to these devices is intentionally set to zero.</p>
<p class=indent1>
<b>Important</b>  DBCC CHECKALLOC should be executed while minimal database activity is occurring. If DBCC CHECKALLOC is executed while transactions are in progress, the output may return spurious errors. To ensure that no other users have transactions in progress, set the database to <b>readonly </b>or <b>single user </b>with the <b>sp_dboption </b>system stored procedure.</p>
<dl>
<dt>
CHECKCATALOG [<b>(</b><i>database_name</i><b>)</b>]</dt>
<dd>
Checks for consistency in and between system tables. For example, CHECKCATALOG makes sure that every type in <i>syscolumns</i> has a matching entry in <i>systypes</i>, that every table and view in <i>sysobjects</i> has at least one column in <i>syscolumns</i>, and that the last checkpoint in <i>syslogs</i> is valid. CHECKCATALOG also reports on any segments that have been defined. If no database name is given, CHECKCATALOG checks the current database.</dd>
<dt>
CHECKTABLE <b>(</b><i>table_name</i> [<b>,</b> NOINDEX | <i>index_id</i>]<b>)</b></dt>
<dd>
Checks the specified table to see that index and data pages are correctly linked, that indexes are in proper sorted order, that all pointers are consistent, that the data information on each page is reasonable, and that page offsets are reasonable. If the log segment is on its own device, running DBCC CHECKTABLE on the <i>syslogs</i> table reports the log's used and free space.
<p>
In SQL Server 6.0, the performance of DBCC CHECKTABLE has been significantly improved by spawning multiple threads to automatically check nonclustered indexes in parallel. Because the table will be loaded in the data cache, each of the simultaneous threads will see an improvement because of an increase in the cache hit ratio.

<p>
If an <i>index_id </i>is specified, CHECKTABLE will check only that index.
</dd>
<dt>
CHECKDB [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)]</b></dt>
<dd>
Runs the same checks as CHECKTABLE, but on every table in the specified database. If <i>database_name </i>is not supplied, CHECKDB checks the current database.</dd>
<dt>
CHECKIDENT [<b>(</b><i>table_name</i><b>)</b>]</dt>
<dd>
Checks the current identity value and compares it with the maximum value in the identity column. If the current identity value is invalid, it will be reset using the maximum value in the identity column. Invalid identity information can cause SQL Server message 2627 when a PRIMARY KEY or UNIQUE KEY constraint exists on an identity column.</dd>
<dt>
NOINDEX</dt>
<dd>
Specifies that only the clustered index (the B-Tree and the data itself) is to be checked for user-defined tables. If no clustered index exists, only the data is checked. The NOINDEX option decreases the overall execution time of CHECKALLOC, CHECKDB, CHECKTABLE, and NEWALLOC because it does not check nonclustered indexes for user-defined tables. The NOINDEX option does not affect a check made against the system tables. When used against a system table(s), all clustered and nonclustered indexes are checked.</dd>
<dt>
DBREPAIR <b>(</b><i>database_name</i><b>,</b> DROPDB [<b>,</b> NOINIT]<b>)</b></dt>
<dd>
Drops the specified, and usually damaged, database. No user, including the person executing the statement, can be using the specified database when this DBCC statement is executed. When the NOINIT option is specified, the allocation pages of the dropped database are not modified. DBCC DBREPAIR is used for backward compatibility only. To drop a damaged database, use the DROP DATABASE statement. If the DROP DATABASE statement fails, use the <b>sp_dbremove </b>system stored procedure.</dd>
<dt>
<i>dllname </i><b>(</b>FREE<b>)</b></dt>
<dd>
Unloads the specified dynamic-link library (DLL) from SQL Server memory. After you execute an extended stored procedure, the DLL is loaded by SQL Server until the server is shut down. This statement also allows a DLL to be unloaded without shutting down SQL Server.</dd>
<dt>
INPUTBUFFER <b>(</b><i>spid</i><b>)</b></dt>
<dd>
Returns one row containing the first 255 bytes of the "current input" buffer for the specified <i>spid </i>(system process ID taken from the <b>sp_who </b>system stored procedure output). This can be used to see the last query sent from the client. For processes that do not contain input streams, an error message is returned. DBCC INPUTBUFFER can be executed only by the system administrator. </dd>
<dt>
MEMUSAGE</dt>
<dd>
Provides detailed reports on memory use. DBCC MEMUSAGE reports three different types of information:
<ul>
<li>
How the server's memory was allocated at start-up time. </li>
<li>
How much memory is used by the 20 largest objects in the buffer cache (including "pinned" tables).</li>
<li>
How much memory is used by the 12 largest objects in the procedure cache  ¾ stored procedures, triggers, views, rules, and defaults. If multiple copies of an object are in the procedure cache, DBCC MEMUSAGE sums the total memory used by them. Of the multiple copies, some are precompiled versions of the object (trees) and some are compiled versions (plans). DBCC MEMUSAGE shows the sizes of both the trees and plans, and it shows the total trees and plans used to evaluate the largest objects. </li>
</ul>
</dd>
<dt>
NEWALLOC [<b>(</b><i>database_name </i>[<b>,</b> NOINDEX]<b>)</b>]</dt>
<dd>
Checks data and index pages against corresponding extent structures. DBCC NEWALLOC details all table information as well as provides the same summary information provided by DBCC CHECKALLOC, which is retained for compatibility. Unlike DBCC CHECKALLOC, DBCC NEWALLOC will not stop processing if it encounters an error.
<p>
DBCC NEWALLOC returns a listing for each allocation unit of the number of extents currently reserved for use by objects, the number of pages marked as being used by objects, and the actual number of pages being used by objects. An allocation unit can hold, at most, 32 database objects. An allocation unit is 512K (0.5 MB) made up of 32 extents (8 2K pages). From this, 512K/16K results in 32 objects. The used pages value and the ref pages value should be equivalent for most, if not all, allocation units. A difference of 7 is possible due to the transaction log. A slightly larger difference is acceptable when <i>text </i>or <i>image </i>data exists within the database. 

<p>
The number of extents tells whether or not you can create new objects on that allocation unit. To estimate the total amount of space reserved by database objects (tables and indexes), multiply the total number of extents by 16K. To estimate the amount of that space being used by data or index information, multiply the total number of used pages by 2K.


<p>
<b>Note</b>  Before running DBCC CHECKALLOC or DBCC NEWALLOC on a database installed on read-only removable media, set the database status to 'read only' using <b>sp_dboption</b>. This will prevent the SHUTDOWN command from doing a checkpoint in the database. (Otherwise, checkpoint would attempt to write the allocation pages used by DBCC CHECKALLOC or DBCC NEWALLOC for scratch space and encounter I/O errors on the read-only media.
</dd>
</dl>
<p>
As an additional precaution, shut down and restart the server after DBCC has completed to prevent the possibility of a manual checkpoint attempting to write the allocation pages. </p>
<p>
Also note that DBCC CHECKALLOC or DBCC NEWALLOC may print warning message 2558 for user objects residing on a removable device. You can ignore these messages. They arise because the segmap in <i>sysusages</i> for fragments corresponding to these devices is intentionally set to zero.</p>
<p class=indent1>
<b>Important</b>  DBCC NEWALLOC should be executed while minimal database activity is occurring. If DBCC NEWALLOC is executed while transactions are in progress, the output may return errors. To ensure that no other users have transactions in progress, set the database to <b>read only </b>or <b>single user </b>with the <b>sp_dboption </b>system stored procedure.</p>
<dl>
<dt>
OPENTRAN <b>(</b>{<i>database_name</i>} | {<i>database_id</i>}<b>)</b> [WITH TABLERESULTS]</dt>
<dd>
Displays information on the oldest active transaction and the oldest distributed and nondistributed replicated transactions, if any, within the specified database. When the WITH TABLERESULTS option is not used, the results returned are formatted for easy readability. Use the WITH TABLERESULTS option for a table of results that can be inserted into a table for comparisons.

<p>
<b>Note</b>  Results are displayed only if there is an active transaction or if the database contains replication information.


<p>
DBCC OPENTRAN is extremely useful in determining whether or not an open transaction exists within the log. When using the DUMP TRANSACTION statement, only the inactive portion of the log can be truncated, so an open transaction could cause the log not to be truncated completely. In earlier versions of SQL Server, all users needed to log off or the server needed to be shut down and restarted in order to clear the uncommitted transactions from the log. With DBCC OPENTRAN, an open transaction can be identified (the <i>spid</i>, the system process ID taken from the <b>sp_who </b>system stored procedure output, is returned) and terminated, if necessary.
</dd>
<dt>
OUTPUTBUFFER <b>(</b><i>spid</i><b>)</b></dt>
<dd>
Returns the "current output" buffer in hexadecimal and ASCII format for the specified <i>spid</i>. This can be used to see the results that were sent to the specified client (<i>spid</i>). For processes that do not contain output streams, an error message is returned. DBCC OUTPUTBUFFER can be executed only by the system administrator.</dd>
<dt>
PERFMON</dt>
<dd>
Provides a way to view all three types of SQLPERF statistics in order (IOSTATS, LRUSTATS, and NETSTATS). It takes no parameters.</dd>
<dt>
PINTABLE <b>(</b><i>database_id</i><b>,</b> <i>table_id</i><b>)</b></dt>
<dd>
Marks a table (data pages, <i>text</i> pages, and index pages) to remain in data cache (once used) until "unpinned." DBCC PINTABLE does not automatically read the table into cache; instead, as pages of the table are accessed and put into cache, they are marked so that they do not get flushed later. Once "pinned," data modifications are fully logged and the table can be recovered. Although this can provide performance improvements for some tables, it should be used with caution. As the table is read into cache, the size of the table is limited only by the available cache. If you are not careful, a large table could consume all the data cache, the server need to be restarted, and then the table unpinned. For more information, see DBCC UNPINTABLE, later in this section.</dd>
<dt>
SHOW_STATISTICS <b>(</b><i>table_name</i><b>,</b> <i>index_name</i><b>)</b></dt>
<dd>
Displays all the statistical information in the distribution page for an index (<i>index_name</i>) on a specified table (<i>table_name</i>). The results returned indicate the selectivity of an index (the lower the density returned, the higher the selectivity) and provide the basis for determining whether or not an index would be useful to the optimizer. The results returned are based on distribution steps of the index. To understand the output of SHOW_STATISTICS, see the examples, later in this section.
<p>
To see the last date the statistics were updated, use the system function <b>STATS_DATE</b>. For details, see the Functions topic.
</dd>
<dt>
SHOWCONTIG <b>(</b><i>table_id</i><b>,</b> [<i>index_id</i>]<b>)</b></dt>
<dd>
Traverses the page chain at the leaf level of the specified index (<i>index_id</i>) or data level (if only <i>table_id</i> is specified) and determines whether the table is heavily fragmented. Table fragmentation occurs through the process of data modifications (INSERT, UPDATE, and DELETE statements) made against the table. Because the normal distribution of these modifications are not usually equally distributed among the records of the table, the "fullness" of each page will begin to vary over time. For queries that scan part of or all of a table, this can cause additional page reads. When the table is heavily fragmented, you can reduce fragmentation and improve read-ahead (parallel data scan) performance by dropping and re-creating a clustered index (without using the SORTED_DATA option). Re-creating a clustered index will "compact" the data such that data pages are essentially full again; however, the level of "fullness" can also be configured with the FILLFACTOR option. 
<p>
To find the <i>index_id</i> of a nonclustered index, specify the nonclustered index name (<i>nc_index_name</i>) in the following query:
</dd>
</dl>
<pre>SELECT indid FROM sysindexes
    WHERE name = 'nc_index_name'
</pre>
<p>
DBCC SHOWCONTIG returns these statistics:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=37%></th>
<th align=left width=63%></th>
</tr>
<tr valign=top>
<th align=left width=37%></th>
<th align=left width=63%></th>
</tr>
<tr valign=top>
<th align=left width=37%>Statistic</th>
<th align=left width=63%>Description</th>
</tr>
<tr valign=top>
<td width=37%>Pages Scanned</td>
<td width=63%>Number of pages in the table or index.</td>
</tr>
<tr valign=top>
<td width=37%>Extent Switches</td>
<td width=63%>The number of times the DBCC statement left an extent while it was traversing the pages of the extent.</td>
</tr>
<tr valign=top>
<td width=37%>Avg. Pages per Extent</td>
<td width=63%>The number of pages per extent in the page chain.</td>
</tr>
<tr valign=top>
<td width=37%>Scan Density [Best Count: Actual Count]</td>
<td width=63%>Best Count is the ideal number of extent changes if everything is contiguously linked. Actual Count is the actual number of extent changes. The number in Scan Density is 100 if everything is contiguous; if it is below 100, some fragmentation exists. The Scan Density is a percentage.</td>
</tr>
<tr valign=top>
<td width=37%>Avg. Bytes free per page</td>
<td width=63%>The average number of free bytes on the pages scanned. The higher the number, the less full the pages are; lower numbers are better. Be aware, however, that this number is also affected by row size, so a large row size may result in a higher number.</td>
</tr>
<tr valign=top>
<td width=37%>Avg. Page density (full)</td>
<td width=63%>The average page density shows how full a page is (as a percentage). This value takes into account row size, so it is a more accurate indication of how full your pages are. The higher the percentage, the better.</td>
</tr>
<tr valign=top>
<td width=37%>Overflow Pages</td>
<td width=63%>This value is for internal use.</td>
</tr>
<tr valign=top>
<td width=37%>Disconnected Overflow Pages</td>
<td width=63%>This value is for internal use.</td>
</tr>
</table><br>
<dl>
<dt>
SHRINKDB <b>(</b><i>database_name</i> [<b>,</b> <i>new_size </i>[<b>,</b> <b>'</b>MASTEROVERRIDE<b>'</b>]]<b>)</b></dt>
<dd>
When specified with only the <i>database_name</i> parameter, DBCC SHRINKDB returns the minimum size to which this database can shrink, and it lists all objects and indexes that are preventing you from shrinking it further. You cannot shrink the database to a size smaller than the one returned; use caution and drop or move the database objects until the returned size is acceptable.
<p>
When <i>new_size</i> is specified, DBCC SHRINKDB shrinks the size of the specified database to the value, as specified in 2K pages by the <i>new_size</i> parameter. DBCC SHRINKDB may shrink both the data and log portions of the database. To change the size of only the data or the log, shrink the entire database first and then use the ALTER DATABASE statement to increase the size of the data or log portion of the database.

<p>
To shrink a user database, the database must be set to <b>single user mode</b>. Use the <b>sp_dboption</b> system stored procedure to set this database option. After setting the database to single-user mode, it is recommended that you dump both the <i>master</i> database and the database you are shrinking, prior to using DBCC SHRINKDB. 

<p>
To shrink the <i>master </i>or <i>tempdb </i>databases you must start the server in single-user mode (use the <b>sqlservr </b>command-line executable with the <b>-m</b> parameter). 


<p>
<b>Important</b>  The database cannot be shrunk beyond either the size of the <i>model</i> database or to a size that is not a valid increment of allocation units. That is, <i>new_size</i> must be equal to or greater than the minimum size as returned by DBCC SHRINKDB plus any number of 512-byte increments (each of which is 256 2K pages). For example, if DBCC SHRINKDB returned a message that the 'Database can be shrunk to 5376 pages', the database can be shrunk to 5376 (10.5 MB), 5632 (11 MB), 5888 (11.5 MB), and so on. For more information, see the "Shrink a Database" example, later in this section.

<p>
After successfully shrinking a database to the desired size, back up both the <i>master </i>database and the database that has been shrunk.


<p>
DBCC SHRINKDB is fully logged and recoverable except when used on the <i>master</i> database. The MASTEROVERRIDE clause is required when decreasing the size of the <i>master</i> database. However, use caution if you need to shrink the size of the <i>master</i> database, because recovery could fail if the system fails while shrinking the <i>master</i> database. Back up the <i>master </i>database prior to shrinking it. You must be the system administrator or database owner to execute this statement. 
</dd>
<dt>
SQLPERF <b>(</b>{IOSTATS | LRUSTATS | NETSTATS | RASTATS [<b>, </b>CLEAR]} <br>
{THREADS} {LOGSPACE}<b>)</b></dt>
<dd>
Can provide information about performance statistics. Four performance options are available for this statement: IOSTATS, LRUSTATS, NETSTATS, and RASTATS. You can view replication statistics by using the <b>sp_distcounters </b>(subscription server statistics) and <b>sp_replcounters </b>(publication server statistics) system stored procedures.
<p>
IOSTATS generates the I/O statistics since the server was last started or since the statistics were last cleared. 

<p>
LRUSTATS generates statistics about cache use since the server was last started or since the statistics were last cleared. (LRU stands for "least recently used" and is the algorithm used by the SQL Server cache manager.) 

<p>
NETSTATS provides statistics about network use. 

<p>
RASTATS provides statistics about Read Ahead.

<p>
The CLEAR option clears the statistics and does not display them. 

<p>
The following list describes the statistics generated for each option:

<p>
<b>IOSTATS</b>


<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=42%></th>
<th align=left width=58%></th>
</tr>
<tr valign=top>
<th align=left width=42%></th>
<th align=left width=58%></th>
</tr>
<tr valign=top>
<th align=left width=42%>Statistic</th>
<th align=left width=58%>Definition</th>
</tr>
<tr valign=top>
<td width=42%>Batch Average Size</td>
<td width=58%>The average number of pages written in a batch.</td>
</tr>
<tr valign=top>
<td width=42%>Batch Max. Size</td>
<td width=58%>The maximum number of simultaneous outstanding physical I/Os.</td>
</tr>
<tr valign=top>
<td width=42%>Batch Writes</td>
<td width=58%>The number of times multiple pages were written to disk in a batch.</td>
</tr>
<tr valign=top>
<td width=42%>Log Flush Average</td>
<td width=58%>Log flush requests per physical write.</td>
</tr>
<tr valign=top>
<td width=42%>Log Flush Requests</td>
<td width=58%>Number of requests to flush the log to disk.</td>
</tr>
<tr valign=top>
<td width=42%>Log Logical IO Average</td>
<td width=58%>Logical pages written per physical write.</td>
</tr>
<tr valign=top>
<td width=42%>Log Logical Page IO</td>
<td width=58%>Logical page I/O for transaction log.</td>
</tr>
<tr valign=top>
<td width=42%>Log Physical IO</td>
<td width=58%>Physical I/O for transaction log.</td>
</tr>
<tr valign=top>
<td width=42%>Log Writes</td>
<td width=58%>Total writes for the log.</td>
</tr>
<tr valign=top>
<td width=42%>Page Reads</td>
<td width=58%>The number of 2K pages read from disk (physical reads).</td>
</tr>
<tr valign=top>
<td width=42%>Reads Outstanding</td>
<td width=58%>The number of read requests issued to the operating system that have not been completed.</td>
</tr>
<tr valign=top>
<td width=42%>Single Page Writes</td>
<td width=58%>The number of 2K pages written individually to disk (physical writes, including log writes).</td>
</tr>
<tr valign=top>
<td width=42%>Transactions</td>
<td width=58%>The number of Transact-SQL batches executed. This value is useful in computing ratios involving log write numbers.</td>
</tr>
<tr valign=top>
<td width=42%>Transactions/Log Write</td>
<td width=58%>The number of transaction records written to disk during each physical log write.</td>
</tr>
<tr valign=top>
<td width=42%>Writes Outstanding</td>
<td width=58%>The number of write requests issued to the operating system that have not completed.</td>
</tr>
</table><br>


<p>
<b>LRUSTATS</b>


<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%></th>
<th align=left width=61%></th>
</tr>
<tr valign=top>
<th align=left width=39%></th>
<th align=left width=61%></th>
</tr>
<tr valign=top>
<th align=left width=39%>Statistic</th>
<th align=left width=61%>Definition</th>
</tr>
<tr valign=top>
<td width=39%>Cache Flushes</td>
<td width=61%>The number of times a page needed to be flushed from cache to make room for another page.</td>
</tr>
<tr valign=top>
<td width=39%>Cache Hit Ratio</td>
<td width=61%>The percentage of times a data page was found in the cache.</td>
</tr>
<tr valign=top>
<td width=39%>Cache Size</td>
<td width=61%>The total number of pages in the cache.</td>
</tr>
<tr valign=top>
<td width=39%>Free Page Scan (Avg.)</td>
<td width=61%>The average number of buffer pages that had to be scanned in order to find a free page.</td>
</tr>
<tr valign=top>
<td width=39%>Free Page Scan (Max.)</td>
<td width=61%>The maximum number of buffer pages that had to be scanned in order to find a free page.</td>
</tr>
<tr valign=top>
<td width=39%>Free Buffers</td>
<td width=61%>The number of buffers currently on the free list.</td>
</tr>
<tr valign=top>
<td width=39%>Min. Free Buffers</td>
<td width=61%>The lazy writer will attempt to maintain at least this number of buffers on the free list.</td>
</tr>
</table><br>


<p>
DBCC SQLPERF <b>(</b>LRUSTATS<b>)</b> statistics are useful in determining whether you have a large enough cache in your system. After running SQL Server for a day or two, check the Cache Flushes and Average Free Page Scan. For optimal performance, Average Free Page Scan should be less than 10 and Cache Flushes should be less than 100. If you get higher numbers, it means that the SQL Server cache is not big enough to hold your working set. You can improve your server performance by increasing its cache size (adding more memory). If these numbers are below the recommended limits, it means that adding more memory to your system will not make a large difference in performance and that you have a cache big enough to cover the server's working set. 

<p>
<b>NETSTATS</b>


<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=38%></th>
<th align=left width=62%></th>
</tr>
<tr valign=top>
<th align=left width=38%></th>
<th align=left width=62%></th>
</tr>
<tr valign=top>
<th align=left width=38%>Statistic</th>
<th align=left width=62%>Definition</th>
</tr>
<tr valign=top>
<td width=38%>Max. Worker Threads</td>
<td width=62%>The highest number of worker threads that serviced the command queue since the network application was started or since the statistics were cleared.</td>
</tr>
<tr valign=top>
<td width=38%>Network Reads</td>
<td width=62%>The total number of reads from the network.</td>
</tr>
<tr valign=top>
<td width=38%>Network Writes</td>
<td width=62%>The total number of writes to the network.</td>
</tr>
<tr valign=top>
<td width=38%>Worker Threads</td>
<td width=62%>The current number of worker threads servicing the command queue.</td>
</tr>
</table><br>


<p>
<b>RASTATS</b>


<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=39%></th>
<th align=left width=61%></th>
</tr>
<tr valign=top>
<th align=left width=39%></th>
<th align=left width=61%></th>
</tr>
<tr valign=top>
<th align=left width=39%>Statistic</th>
<th align=left width=61%>Definition</th>
</tr>
<tr valign=top>
<td width=39%>RA Pages Found in Cache</td>
<td width=61%>How many pages the RA Manager found already in the cache when trying to perform scans.</td>
</tr>
<tr valign=top>
<td width=39%>RA Pages Placed in Cache</td>
<td width=61%>How many pages were brought into the cache by the RA Manager.</td>
</tr>
<tr valign=top>
<td width=39%>RA Physical IO</td>
<td width=61%>How many 16K reads were done by the RA Manager.</td>
</tr>
<tr valign=top>
<td width=39%>Used Slots</td>
<td width=61%>How many RA slots are being used by active queries. Note that a single query may use multiple RA slots.</td>
</tr>
</table><br>

</dd>
<dt>
SQLPERF <b>(</b>THREADS<b>)</b> </dt>
<dd>
Provides a mechanism to map the Windows NT system thread ID to a SQL Server <i>spid</i>. Because of thread pooling, many different Windows NT threads will service a single SQL Server <i>spid</i> over time, so this Windows NT system thread ID is usually not useful. This statement also returns the login name, the number of I/Os, and CPU and MEMUSAGE totals. </dd>
<dt>
SQLPERF <b>(</b>LOGSPACE<b>)</b></dt>
<dd>
Returns the percentage of log space used at the time the statement is executed. This statement can be used only on a log that is on a separate device from its database.</dd>
<dt>
TEXTALL [<b>(</b>{<i>database_name </i>| <i>database_id</i>}[<b>, </b>FULL | FAST]<b>)</b>]</dt>
<dd>
Selects tables in the database that have <i>text </i>or <i>image </i>columns and runs TEXTALLOC on them. To select the speed at which the report is generated, choose FULL (all allocation pages in the database will be checked by the report) or FAST (does not generate an allocation report, but checks the linkage of the text chains and verifies that the pages in the chain are allocated). The default is FULL.</dd>
<dt>
TEXTALLOC [<b>(</b>{<i>table_name</i> | <i>table_id</i>}[<b>,</b> FULL | FAST]<b>)</b>]</dt>
<dd>
Checks the allocation of <i>text </i>or <i>image </i>columns for one table. To select the speed at which the report is generated, choose FULL (all allocation pages in the database will be looked at by the report) or FAST (does not generate an allocation report, but checks the linkage of the text chains and verifies that the pages in the chain are allocated). The default is FULL. </dd>
<dt>
TRACEOFF <b>(</b><i>trace#</i><b>)</b></dt>
<dd>
Turns off the specified trace flag <i>trace#</i>. For a list of trace flags, see the Trace Flags topic.</dd>
<dt>
TRACEON <b>(</b><i>trace#</i><b>)</b></dt>
<dd>
Turns on the specified trace flag <i>trace#</i>.</dd>
<dt>
TRACESTATUS <b>(</b><i>trace# </i>[<b>,</b> <i>trace#</i>...]<b>)</b></dt>
<dd>
Displays the status for the specified trace flag(s). Can be 1 (on) or 0 (off). You can specify more than one trace flag by separating the numbers with a comma. If you specify - 1 for <i>trace#</i>, status information about all trace flags currently turned on will be returned.</dd>
<dt>
UNPINTABLE <b>(</b><i>database_id</i>, <i>table_id</i><b>)</b></dt>
<dd>
Marks the table as no longer being RAM resident; however, the table will remain in cache until it is aged out of cache (and flushed to disk). "Pinning" a table is not recommended for widespread use; see DBCC PINTABLE, earlier in this section.</dd>
<dt>
UPDATEUSAGE <b>(</b>{0 | <i>database_name</i>} [<b>,</b> <i>table_name</i> [<b>,</b> <i>index_id</i>]]<b>)</b></dt>
<dd>
Reports and corrects inaccuracies in the <i>sysindexes</i> table that may result in incorrect space usage reports by the <b>sp_spaceused </b>system stored procedure. This command corrects the <i>rows</i>, <i>used</i>, <i>reserved</i>, and <i>dpages</i> columns of the <i>sysindexes</i> table for any clustered indexes on objects of the type U (user-defined table) or S (system table). Size information is not maintained for nonclustered indexes. It can be used to synchronize space usage counters in <i>sysindexes</i>, which will result in accurate usage information being returned. When 0 is used instead of the <i>database_name</i>, the update is performed in the current database.
<p>
When processing, UPDATEUSAGE acquires a shared table lock on the table being processed, so updates to the <i>sysindexes</i> row for <i>syslogs</i> can be performed only if the database is in <b>single user mode </b>and when the <i>syslogs</i> table is specified. This prevents any logging during the update and ensures accurate changes. All other changes to <i>sysindexes</i> are fully logged.

<p>
If there are no inaccuracies in <i>sysindexes</i>, DBCC UPDATEUSAGE will return no data. Otherwise, data will be returned that shows you what rows and columns are being updated in <i>sysindexes</i>. 


<p>
<b>Note</b>  This command may take some time to run if you run it on large tables or databases, so it should typically be used only when you suspect incorrect values returned by the <b>sp_spaceused </b>system stored procedure or via a timed operation to run during off hours. 

</dd>
<dt>
USEROPTIONS</dt>
<dd>
Returns the list of SET options that are active (or set) for the current connection. It takes no parameters. For details and a listing of the session options available, see the SET statement.</dd>
<dt>
WITH NO_INFOMSGS</dt>
<dd>
Prevent the printing of informational messages (severity 1 through 10). This helps to determine real problems when using verbose commands such as DBCC CHECKDB.
</dd>
</dl>
<h4>Permission</h4>
<p>
Permission to execute the DBCC statement varies for each of the DBCC options. Permission is not transferable. DBCC permissions are:</p>
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%></th>
<th align=left width=52%></th>
</tr>
<tr valign=top>
<th align=left width=48%></th>
<th align=left width=52%></th>
</tr>
<tr valign=top>
<th align=left width=48%>DBCC option</th>
<th align=left width=52%>Permission defaults to</th>
</tr>
<tr valign=top>
<td width=48%>CHECKALLOC</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>CHECKCATALOG</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>CHECKDB</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>CHECKTABLE</td>
<td width=52%>SA, DBO, or the table owner</td>
</tr>
<tr valign=top>
<td width=48%>DBREPAIR</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%><i>dllname</i></td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>INPUTBUFFER</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>MEMUSAGE</td>
<td width=52%>Any user</td>
</tr>
<tr valign=top>
<td width=48%>NEWALLOC</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>OPENTRAN</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>OUTPUTBUFFER</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>PERFMON</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>PINTABLE</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>SHOW_STATISTICS</td>
<td width=52%>SA, DBO, or the table owner</td>
</tr>
<tr valign=top>
<td width=48%>SHOWCONTIG</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>SHRINKDB</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>SQLPERF</td>
<td width=52%>Any user</td>
</tr>
<tr valign=top>
<td width=48%>TEXTALL</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>TEXTALLOC</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>TRACEOFF</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>TRACEON</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>TRACESTATUS</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>UNPINTABLE</td>
<td width=52%>SA only</td>
</tr>
<tr valign=top>
<td width=48%>UPDATEUSAGE</td>
<td width=52%>SA or DBO</td>
</tr>
<tr valign=top>
<td width=48%>USEROPTIONS</td>
<td width=52%>Any user</td>
</tr>
</table><br>
<h4>Examples</h4>
<h5>A.&nbsp;&nbsp;&nbsp;&nbsp;Check the Allocation Units (CHECKALLOC)</h5>
<p>
This example runs the DBCC CHECKALLOC command against the <i>pubs</i> database.</p>
<pre>DBCC CHECKALLOC(pubs)
go
Checking pubs
Alloc page 0 (# of extent=32 used pages=58 ref pages=58)
Alloc page 256 (# of extent=26 used pages=37 ref pages=37)
Alloc page 512 (# of extent=14 used pages=40 ref pages=40)
Alloc page 768 (# of extent=1 used pages=8 ref pages=2)
Alloc page 1024 (# of extent=1 used pages=0 ref pages=0)
Alloc page 1280 (# of extent=1 used pages=0 ref pages=0)
Total (# of extent=75 used pages=143 ref pages=137) in this database
DBCC execution completed. If DBCC printed error messages, see your System Administrator.
</pre>
<p>
This database contains six allocation units of 256 2K pages (0.5 MB) each, giving 1536 2K pages in all (3 MB). Of that 3 MB, 88 extents (88 * 16K <b>=</b> 1408K), is reserved and 215 pages (or 215 * 2K <b>=</b> 430K) are used by data and indexes. The reserved 88 extents include objects that have been created but not yet completely populated with data. Used pages refer to those pages that do contain actual data or index pages.</p>
<h5>B.&nbsp;&nbsp;&nbsp;&nbsp;Check a Single Table (CHECKTABLE)</h5>
<p>
This example runs the DBCC CHECKTABLE command against all indexes and data on the <i>employee</i> table in the <i>pubs</i> database.</p>
<pre>USE pubs
go
DBCC CHECKTABLE(employee)
go
Checking employee
The total number of data pages in this table is 2.
Table has 43 data rows.
DBCC execution completed. If DBCC printed error messages, see your System Administrator.
</pre>
<h5>C.&nbsp;&nbsp;&nbsp;&nbsp;Check a Table with NOINDEX (CHECKTABLE)</h5>
<p>
This example skips all of the nonclustered indexes. </p>
<pre>USE pubs
go
DBCC CHECKTABLE(employee, NOINDEX)
go
Checking employee
WARNING: NOINDEX option of 'CHECKTABLE' being used, checks on non-system indexes will be skipped
The total number of data pages in this table is 2.
Table has 43 data rows.
DBCC execution completed. If DBCC printed error messages, see your System Administrator.</pre>
<h5>D.&nbsp;&nbsp;&nbsp;&nbsp;Check the Transaction Log (CHECKTABLE)</h5>
<p>
This example runs the DBCC CHECKTABLE command against the <i>syslogs</i> table within the <i>sales</i> database.</p>
<pre>USE sales
go
DBCC CHECKTABLE(syslogs)
go
Checking syslogs
The total number of data pages in this table is 145.
*** NOTICE:  Space used on the log segment is 0.29 Mbytes, 4.72.
*** NOTICE:  Space free on the log segment is 5.85 Mbytes, 95.28.
Table has 3194 data rows.
DBCC execution completed. If DBCC printed error messages, see your System Administrator.</pre>
<h5>E.&nbsp;&nbsp;&nbsp;&nbsp;Report Memory Usage (MEMUSAGE)</h5>
<p>
The report given by DBCC MEMUSAGE is broken down into three parts. Only 3 of the 20 procedures are shown here.</p>
<pre>DBCC MEMUSAGE
go
Memory Usage:
 
 
                    Meg.         2K Blks           Bytes
 
      Configured Memory:  8.0000        4096     8388608
              Code size:  1.7166         879     1800000
      Static Structures:  0.2385         123      250064
                  Locks:  0.2480         127      260000
           Open Objects:  0.1068          55      112000
         Open Databases:  0.0031           2        3220
     User Context Areas:  0.8246         423      864688
             Page Cache:  3.3040        1692     3464544
           Proc Headers:  0.0796          41       83448
        Proc Cache Bufs:  1.3379         685     1402880
 
Buffer Cache, Top 20:
 
       DB Id     Object Id    Index Id    2K Buffers
 
           4             5           0          26
           1            56           0          20
           1                 1       0          16
           1     576005083           0          11
           4             3           0          10
           4            99           0           6
           1             2           0           5
           1             1           2          17
           1             5           2           4
           1           399           0           4
           4             1           0           4
           4             2           0           4
           1             3           0           3
           4             1           0           3
           4             6           0           3
           4     192003715           0           3
           1             5           0           2
           1            45           1           2
           2             2         255           2
           2            99           0           2
 
 
 
Procedure Cache, Top 5:
 
 
Procedure Name: sp_helpconstraint sp_server_info
Database Id: 1
Object Id: 1516532436
Version: 1
Uid: 1
Type: stored procedure
Number of trees: 0
Size of trees: 0.000000 Mb, 0.000000 bytes, 0 pages
Number of plans: 1
Size of plans: 0.002974 Mb, 3118.000000 bytes, 42 pages
 
 
Procedure Name: CA only
Database Id: 4
Object Id: 1104006964
Version: 0
Uid: 1
Type: stored view
Number of trees: 1
Size of trees: 0.001659 Mb, 1740.000 bytes, 1 pages
Number of plans: 0
Size of plans: 0.000000 Mb, 00000.000000 bytes, 0 pages
 
 
Procedure Name: categories
Database Id: 4
Object Id: 1168007192
Version: 0
Uid: 1
Type: stored view
Number of trees: 1
Size of trees: 0.001883 Mb, 1974.00000 bytes, 1 pages
Number of plans: 0
Size of plans: 0.000000 Mb, 0.000000 bytes, 0 pages
.
.
.
</pre>
<h5>F.&nbsp;&nbsp;&nbsp;&nbsp;View Index Statistics (SHOW_STATISTICS)</h5>
<p>
This table is a copy of the <i>authors </i>table created in the <i>pubs </i>database. The <i>authors </i>table includes a clustered index on the primary key (<i>au_id</i>) column and a nonclustered index on the composite key (<i>au_lname</i>, <i>au_fname</i>). This example shows the DBCC output for each index after 1500 rows are inserted and the statistics have been updated. </p>
<p>
The first example shows statistics for the clustered primary key index on the <i>au_id </i>column. Because a PRIMARY KEY constraint enforces uniqueness, the selectivity of this index is highly selective (only 1 row will match). In this case, the Density * Rows is 1.0, showing that there is only 1 match. If a query were executed against the <i>authors </i>table using a WHERE clause specifying equality with an <i>au_id</i>,<i> </i>this index would be used.</p>
<pre>DBCC SHOW_STATISTICS (authors, UPKCL_auidind)
go

 Updated                  Rows    Steps       Density              
 -------------------- -------- -------- ------------- 
 Apr 17 1995  1:22PM      1520      109      0.000658 

(1 row affected)

 All density          Columns                        
 -------------------- ------------------------------ 
             0.000658 au_id                          

(1 row affected)

 Steps       
 ----------- 
 100-10-1000 
.
.
.
 724-08-9931 

(109 rows affected)

DBCC execution completed. If DBCC printed error messages, see your
System Administrator.
</pre>
<p>
The second example shows statistics for the nonclustered index on the <i>au_lname</i> and <i>au_fname </i>columns. Because this index is not unique, the selectivity is based on the distribution of the data and the likelihood of duplicates. In this case, the Density * Rows is 20.8, showing that there are roughly 21 duplicates based on the <i>au_lname</i>, column alone, not counting any values in more than one step (values with an extremely high number of duplicates and low selectivity). </p>
<p>
The All Density is more accurate and shows the selectivity of each column, including those that are more than two steps (lowering the selectivity further and emphasizing how a large number of duplicates can affect the effectiveness of an index). Looking at the <i>au_lname </i>column only, the selectivity is not very high (48 potential duplicates) and an index might be used; however, the selectivity of <i>au_lname</i>, <i>au_fname </i>is much higher (only 3 potential duplicates). If both the <i>au_lname</i> and <i>au_fname</i> are specified with a WHERE clause, it is likely that this index will be used. </p>
<pre>DBCC SHOW_STATISTICS (authors, aunmind)
go

 Updated                  Rows    Steps       Density              
 -------------------- -------- -------- ------------- 
 Apr 17 1995  1:22PM      1520       39      0.013674 

(1 row affected)

 All density          Columns                        
 -------------------- ------------------------------ 
             0.031665 au_lname                       
             0.002028 au_lname, au_fname             

(2 rows affected)

 Steps                                    
 ---------------------------------------- 
 Abbott                                   
.
.
.
 Xenon                                    

(39 rows affected)

DBCC execution completed. If DBCC printed error messages, see your
System Administrator.
The inserts are performed and DBCC is executed again.
</pre>
<h5>G.&nbsp;&nbsp;&nbsp;&nbsp;Shrink a Database (SHRINKDB)</h5>
<p>
This example defines the steps to ensure a proper decrease in size of a database:
<ol>
<li>
Set the database to single-user mode using the <b>sp_dboption</b> system stored procedure.</li>
<li>
Change your current database to the database you want to shrink.</li>
<li>
Verify how small you can make the database. (Run DBCC SHRINKDB without specifying a new_size.)</li>
<li>
Shrink the database.</li>
</ol>
<pre>USE master
go
sp_dboption 'sales', 'single user', true
go
USE sales
go
DBCC SHRINKDB(sales)
go
Current size of database Size database can be shrunk to 
------------------------ ------------------------------ 
1536                     1024                           

(1 row(s) affected)

DBCC execution completed. If DBCC printed error messages, see your System Administrator.
</pre>
<p>
DBCC SHRINKDB reported a minimum size of 5376 pages. Because the absolute minimum is not always necessary, shrink the <i>sales</i> database down to a new size of 12 MB.</p>
<pre>DBCC SHRINKDB(sales, 6144)
go
DBCC SHRINKDB running on database "sales"...
DBCC execution completed. If DBCC printed error messages, see your System Administrator.
</pre>
<h4>See Also</h4>
<table cellspacing=4 cols=2>
<tr valign=top>
<td width=48%><a href="tsql07_0rg4.htm">DROP DATABASE</a></td>
<td width=52%><a href="tsql19_3yzp.htm"><b>sp_configure</b></a></td>
</tr>
<tr valign=top>
<td width=48%><a href="tsql11_7dv8.htm">RECONFIGURE</a></td>
<td width=52%><a href="tsql22_0nl1.htm"><b>sp_helpdb</b></a></td>
</tr>
</table><br>
<p>&nbsp;</p></body>
</HTML>
