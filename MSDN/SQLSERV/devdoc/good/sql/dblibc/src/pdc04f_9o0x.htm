<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>dbsetuserdata</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_dbsetuserdata"></a>dbsetuserdata</h1>
<p>
Saves, in a DBPROCESS structure, a pointer to user-allocated data.</p>
<h4>Syntax</h4>
<p>
<b>void dbsetuserdata ( PDBPROCESS </b><i>dbproc</i><b>, LPVOID </b><i>ptr</i><b> );</b></p>
<p>
where
<dl>
<dt>
<i>dbproc</i></dt>
<dd>
Is the DBPROCESS structure that is the handle for a particular workstation/ SQL Server process. It contains all the information that DB-Library uses to manage communications and data between the workstation and SQL Server.</dd>
<dt>
<i>ptr</i></dt>
<dd>
Is a generic BYTE pointer to the user's private data space.
</dd>
</dl>
<h4>Remarks</h4>
<p>
The <b>dbsetuserdata</b> function lets an application associate user data with a particular DBPROCESS, eliminating the need for global variables. This function is especially useful when an application has more than one DBPROCESS.</p>
<p>
Make sure each application allocates the data that <i>ptr</i> points to. DB-Library never manipulates this data; it merely saves the pointer so the application can use it later.</p>
<h4>Example</h4>
<p>
The following example shows how <b>dbsetuserdata</b> handles deadlock, an occasional occurrence in high-volume applications. For more information about deadlock, see the <i>Microsoft SQL Server Administrator's Companion.</i></p>
<p>
This program fragment sends updates to the SQL Server and reruns the transaction when its message handler detects deadlock:</p>
<pre>// Deadlock detection:
// In the DBPROCESS structure, save a pointer to a DBBOOL variable.
// The message handler sets the variable when deadlock occurs.
// The result processing logic checks the variable and resends the
// transaction in case of deadlock.

// Allocate the space for the DBBOOL variable and save it in
// the DBPROCESS structure.

dbsetuserdata(dbproc, malloc(sizeof(DBBOOL)));

// Initialize the variable to FALSE. 
*((DBBOOL *) dbgetuserdata(dbproc)) = FALSE;
// Run queries and check for deadlock. 
deadlock:

// Did the application get here via deadlock?
// If so, the server has already canceled the transaction.
// Start the application again. In a real application,
// the deadlock handling may need to be somewhat more
// sophisticated. For instance, you may want to keep a
// counter and retry the transaction a fixed number
// of times.

if (*((DBBOOL *) dbgetuserdata(dbproc)) == TRUE)
{
    // Reset the variable to FALSE. 
    *((DBBOOL *) dbgetuserdata(dbproc)) = FALSE;
}

// Start the transaction. 
dbcmd(dbproc, "begin transaction ");

// Run the first UPDATE command. 
dbcmd(dbproc, "update ......");
dbsqlexec(dbproc);
while (dbresults(dbproc) ! = NO_MORE_RESULTS)
{
// application code 
}

// Did the application deadlock? 
if (*(DBBOOL *) dbgetuserdata(dbproc)) == TRUE)
    goto deadlock;

// Run the second UPDATE command. 
dbcmd(dbproc, "update ......");
dbsqlexec(dbproc);
while (dbresults(dbproc) ! = NO_MORE_RESULTS
{
    // application code 
}

// Did the application deadlock? 
if (*((DBBOOL *) dbgetuserdata(dbproc)) == TRUE)
    goto deadlock;

// No deadlock -- Commit the transaction. 
dbcmd(dbproc, "commit transaction");
dbsqlexec(dbproc);
dbresults(dbproc);

// SERVERMSGS
// This is the server message handler. Assume that the dbmsghandle
// function installed it earlier in the application.

servermsgs(dbproc, msgno, msgstate, severity, msgtext, srvname, procname, line)
DBPROCESS    *dbproc;
DBINT        msgno;
int            msgstate;
int            severity;
char            *msgtext;
char            srvname;
char            *procname;
DBUSMALLINT    line;
{

// Is this a deadlock message? 
if (msgno = 1205)
{
    // Set the deadlock indicator. 
    * ((DBBOOL *) dbgetuserdata(dbproc)) = TRUE;
    return (O);
}

// Normal message handling code here. 
}</pre>
<h4>See Also</h4>
<p>
<a href="pdc04c_2bfl.htm"><b>dbgetuserdata</b></a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
