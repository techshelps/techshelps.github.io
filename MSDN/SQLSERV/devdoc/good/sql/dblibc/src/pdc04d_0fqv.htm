<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>dbnextrow</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_dbnextrow"></a>dbnextrow</h1>
<p>
Reads in the next row.</p>
<h4>Syntax</h4>
<p>
<b>STATUS dbnextrow ( PDBPROCESS </b><i>dbproc</i><b> );</b></p>
<p>
where
<dl>
<dt>
<i>dbproc</i></dt>
<dd>
Is the DBPROCESS structure that is the handle for a particular workstation/ SQL Server process. It contains all the information that DB-Library uses to manage communications and data between the workstation and SQL Server.
</dd>
</dl>
<h4>Returns</h4>
<p>
One of five different types of values:
<ul>
<li>
If a regular row is read, REG_ROW is returned. Regular rows contain data from columns designated by a SELECT statement.</li>
<li>
If a compute row is read, the <i>computeid</i> of the row is returned. (For information about <i>computeid</i>, see "<b>dbaltbind</b>.")</li>
<li>
If there are no more rows to be read, if the statement didn't return any rows, or if the server was unable to return more rows (for example, when a deadlock occurs), NO_MORE_ROWS is returned.</li>
<li>
If buffering is turned on and reading the next row would cause the buffer to be exceeded, BUF_FULL is returned. In this case, no row has been read. To read more rows, first clear at least one row from the top of the row buffer. To clear the row buffer, call <b>dbclrbuf</b>.</li>
<li>
If the function was unsuccessful, FAIL is returned.</li>
</ul>
<h4>Remarks</h4>
<p>
The <b>dbnextrow</b> function causes the next data row to be made available through the <i>dbproc</i>. If the DBBUFFER option is turned on and rows have been read out of order by calling <b>dbgetrow</b>, the next data row is read from the buffered rows. Any specified binding of row data to program variables takes effect.</p>
<p>
The <b>dbresults</b> function must be called and must have returned SUCCEED before you make any calls to <b>dbnextrow</b>.</p>
<p>
Even if <b>dbrows</b> or <b>dbcmdrow</b> returns FAIL (indicating that no rows were returned), you must process the results by calling <b>dbnextrow</b> until it returns NO_MORE_ROWS.</p>
<p>
Normally, each row is processed in turn by repeatedly calling <b>dbnextrow</b>. If row buffering is enabled and the row buffer has been cleared by the <b>dbclrbuf</b> function, the discarded rows are no longer available (even if <b>dbgetrow</b> tries to position to a discarded row). When row buffering is disabled, the last row is cleared when <b>dbnextrow</b> returns no_more_rows.</p>
<p>
SQL Server can return two types of rows:
<ul>
<li>
Regular rows containing data from columns designated by a SELECT statement's select list.</li>
<li>
Compute rows resulting from the COMPUTE clause.</li>
</ul>
<p>
To help process data rows from SQL Server, <b>dbnextrow</b> returns different values according to the type of row. For details, see the previous section, "Returns."</p>
<p>
If you want data returned from SQL Server to be displayed on the default output device, use <b>dbprrow</b> instead of <b>dbnextrow</b> (except with the Windows operating system).</p>
<p>
<b>Note</b>  This function is one of the four that do not return control to the application until the server sends the required response. The application can be blocked for a considerable time if the server is waiting for a lock or is processing a large sort. If this is unacceptable, always call <b>dbdataready</b> before <b>dbnextrow</b> and set the DB-Library timeout to regain control periodically.</p>
<h4>Example</h4>
<p>
The typical sequence of calls is:</p>
<pre>DBINT    xvariable;
DBCHAR    yvariable[10];

// Read the query into the command buffer. 
dbcmd(dbproc, "select x = 100, y = 'hello'");

// Send the query to SQL Server. 
dbsqlexec(dbproc);

// Get ready to process the results of the query. 
dbresults(dbproc);

// Bind column data to program variables. 
dbbind(dbproc, 1, INTBIND, (DBINT) 0, (BYTE *)&amp;xvariable);
dbbind(dbproc, 2, STRINGBIND, (DBINT) 0, yvariable);

// Now process each row. 
while (dbnextrow(dbproc) != NO_MORE_ROWS)
{
    //    C-code to print or process row data 
}
</pre>
<p>
Note that if you are not using row buffering, you must continue calling <b>dbnextrow</b> until it returns NO_MORE_ROWS. This is true even if you are sure that your query only generates one results row. The <b>while</b> loop in the preceding example illustrates the correct way to use <b>dbnextrow</b>.</p>
<h4>See Also</h4>
<p>
<a href="pdc04a_8tes.htm"><b>dbaltbind</b></a>, <a href="pdc04b_4zc4.htm"><b>dbbind</b></a>, <a href="pdc04b_9r8m.htm"><b>dbclrbuf</b></a>, <a href="pdc04c_1ad3.htm"><b>dbgetrow</b></a>, <a href="pdc04e_42lz.htm"><b>dbprrow</b></a>, <a href="pdc04e_52sz.htm"><b>dbresults</b></a>; <a href="pdc09_7e7t.htm">Bulk-Copy Functions</a>, and <a href="pdca_9kbl.htm">DB-Library Options</a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
