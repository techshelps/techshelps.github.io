<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>dbaltbind</title>
<link disabled rel=stylesheet href=../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="_dbaltbind"></a>dbaltbind</h1>
<p>
Binds a <i>compute column</i> (column of results from a COMPUTE clause) to a program variable.</p>
<h4>Syntax</h4>
<p>
<b>RETCODE dbaltbind ( <br>
PDBPROCESS </b><i>dbproc</i><b>, <br>
INT </b><i>computeid</i><b>, <br>
INT </b><i>column</i><b>, <br>
INT </b><i>vartype</i><b>, <br>
DBINT </b><i>varlen</i><b>, <br>
LPCBYTE </b><i>varaddr</i><b> );</b></p>
<p>
where
<dl>
<dt>
<i>dbproc</i></dt>
<dd>
Is the DBPROCESS structure that is the handle for a particular workstation/ SQL Server process. It contains all the information that DB-Library uses to manage communications and data between the workstation and SQL Server.</dd>
<dt>
<i>computeid</i></dt>
<dd>
Is the ID of the COMPUTE clause to which the <b>dbaltbind</b> function refers. Since a SELECT statement can have more than one COMPUTE clause, the <i>computeid</i> is necessary to distinguish between them. The <i>computeid</i> is returned by <b>dbnextrow</b> or <b>dbgetrow</b>.</dd>
<dt>
<i>column</i></dt>
<dd>
Is the column number of the compute data that is to be copied to a program variable. The first column is number 1. </dd>
<dt>
<i>vartype</i></dt>
<dd>
Is a description of the binding's datatype. It corresponds to the datatype of the program variable that receives the copy of the data from the DBPROCESS.
<p>
The <b>dbaltbind</b> function supports a wide range of type conversions, so the binding's datatype can be different from the type returned by the SQL query. For instance, a SQLMONEY result can be bound to a DBFLT8 program variable, using FLT8BIND, and the appropriate data conversion happens automatically.

<p>
For a list of the data conversions provided by DB-Library, see <a href="pdc04f_1c38.htm">dbwillconvert</a>. For a list of the type definitions used by DB-Library, see <a href="pdcb_852a.htm">DB-Library Datatypes</a>. The following table lists the legal <i>vartypes</i> recognized by <b>dbaltbind</b> and the program variable and SQL Server types that each refers to. 

<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=33%></th>
<th align=left width=33%></th>
<th align=left width=34%></th>
</tr>
<tr valign=top>
<th align=left width=33%></th>
<th align=left width=33%></th>
<th align=left width=34%></th>
</tr>
<tr valign=top>
<th align=left width=33%><i><br>
vartype</i></th>
<th align=left width=33%>Program variable <br>
type</th>
<th align=left width=34%><br>
SQL Server type</th>
</tr>
<tr valign=top>
<td width=33%></td>
<td width=33%></td>
<td width=34%></td>
</tr>
<tr valign=top>
<td width=33%>CHARBIND</td>
<td width=33%>DBCHAR</td>
<td width=34%>SQLCHAR </td>
</tr>
<tr valign=top>
<td width=33%>STRINGBIND</td>
<td width=33%>DBCHAR</td>
<td width=34%>SQLCHAR</td>
</tr>
<tr valign=top>
<td width=33%>NTBSTRINGBIND</td>
<td width=33%>DBCHAR</td>
<td width=34%>SQLCHAR</td>
</tr>
<tr valign=top>
<td width=33%>VARYCHARBIND</td>
<td width=33%>DBVARYCHAR</td>
<td width=34%>SQLCHAR </td>
</tr>
<tr valign=top>
<td width=33%>BINARYBIND</td>
<td width=33%>DBBINARY</td>
<td width=34%>SQLBINARY</td>
</tr>
<tr valign=top>
<td width=33%>VARYBINBIND</td>
<td width=33%>DBVARYBIN</td>
<td width=34%>SQLBINARY</td>
</tr>
<tr valign=top>
<td width=33%>TINYBIND</td>
<td width=33%>DBTINYINT</td>
<td width=34%>SQLINT1 </td>
</tr>
<tr valign=top>
<td width=33%>SMALLBIND</td>
<td width=33%>DBSMALLINT</td>
<td width=34%>SQLINT2</td>
</tr>
<tr valign=top>
<td width=33%>INTBIND</td>
<td width=33%>DBINT</td>
<td width=34%>SQLINT4</td>
</tr>
<tr valign=top>
<td width=33%>FLT8BIND</td>
<td width=33%>DBFLT8</td>
<td width=34%>SQLFLT8 </td>
</tr>
<tr valign=top>
<td width=33%>BITBIND</td>
<td width=33%>DBBIT</td>
<td width=34%>SQLBIT</td>
</tr>
<tr valign=top>
<td width=33%>DATETIMEBIND</td>
<td width=33%>DBDATETIME</td>
<td width=34%>SQLDATETIME</td>
</tr>
<tr valign=top>
<td width=33%>MONEYBIND</td>
<td width=33%>DBMONEY</td>
<td width=34%>SQLMONEY</td>
</tr>
<tr valign=top>
<td width=33%>SMALLMONEYBIND</td>
<td width=33%>DBMONEY4</td>
<td width=34%>SQLMONEY4</td>
</tr>
<tr valign=top>
<td width=33%>SMALLDATETIBIND</td>
<td width=33%>DBDATETIM4</td>
<td width=34%>SQLDATETIM4</td>
</tr>
<tr valign=top>
<td width=33%>FLT4BIND</td>
<td width=33%>DBFLT4</td>
<td width=34%>SQLFLT4</td>
</tr>
<tr valign=top>
<td width=33%>DECIMALBIND</td>
<td width=33%>DBDECIMAL</td>
<td width=34%>SQLDECIMAL</td>
</tr>
<tr valign=top>
<td width=33%>NUMERICBIND</td>
<td width=33%>DBNUMERIC</td>
<td width=34%>SQLNUMERIC</td>
</tr>
<tr valign=top>
<td width=33%>SRCDECIMALBIND</td>
<td width=33%>DBDECIMAL</td>
<td width=34%>SQLDECIMAL</td>
</tr>
<tr valign=top>
<td width=33%>SRCNUMERICBIND</td>
<td width=33%>DBNUMERIC</td>
<td width=34%>SQLNUMERIC</td>
</tr>
</table><br>


<p>
Because SQLTEXT and SQLIMAGE data are never returned through a <i>compute row</i> (a row of results generated by a COMPUTE clause), these datatypes are not included in the preceding table. The SQL Server type is listed for your reference. The <i>vartype</i> you specify does not necessarily have to correspond to a particular SQL Server type because, as mentioned earlier, <b>dbaltbind</b> converts SQL Server data into the specified <i>vartype</i>.

<p>
The following table lists the four representations for character data. They differ according to whether the data is padded with blanks or is null-terminated:


<table cellspacing=4 cols=4>
<tr valign=top>
<th align=left width=25%></th>
<th align=left width=28%></th>
<th align=left width=22%></th>
<th align=left width=25%></th>
</tr>
<tr valign=top>
<th align=left width=25%></th>
<th align=left width=28%></th>
<th align=left width=22%></th>
<th align=left width=25%></th>
</tr>
<tr valign=top>
<th align=left width=25%><i>vartype</i></th>
<th align=left width=28%>Program type</th>
<th align=left width=22%>Padding</th>
<th align=left width=25%>Terminator</th>
</tr>
<tr valign=top>
<td width=25%></td>
<td width=28%></td>
<td width=22%></td>
<td width=25%></td>
</tr>
<tr valign=top>
<td width=25%>CHARBIND</td>
<td width=28%>DBCHAR</td>
<td width=22%>blanks</td>
<td width=25%>none </td>
</tr>
<tr valign=top>
<td width=25%>STRINGBIND</td>
<td width=28%>DBCHAR</td>
<td width=22%>blanks</td>
<td width=25%>\0</td>
</tr>
<tr valign=top>
<td width=25%>NTBSTRINGBIND</td>
<td width=28%>DBCHAR</td>
<td width=22%>none</td>
<td width=25%>\0</td>
</tr>
<tr valign=top>
<td width=25%>VARYCHARBIND</td>
<td width=28%>DBVARYCHAR</td>
<td width=22%>none</td>
<td width=25%>none </td>
</tr>
</table><br>


<p>
Note that "\0" is the null terminator character. Similarly, binary data can be stored in two different ways:


<table cellspacing=4 cols=3>
<tr valign=top>
<th align=left width=26%></th>
<th align=left width=28%></th>
<th align=left width=46%></th>
</tr>
<tr valign=top>
<th align=left width=26%></th>
<th align=left width=28%></th>
<th align=left width=46%></th>
</tr>
<tr valign=top>
<th align=left width=26%><i>vartype</i></th>
<th align=left width=28%>Program type</th>
<th align=left width=46%>Padding</th>
</tr>
<tr valign=top>
<td width=26%></td>
<td width=28%></td>
<td width=46%></td>
</tr>
<tr valign=top>
<td width=26%>BINARYBIND</td>
<td width=28%>DBBINARY</td>
<td width=46%>nulls</td>
</tr>
<tr valign=top>
<td width=26%>VARYBINBIND</td>
<td width=28%>DBVARBINARY</td>
<td width=46%>none </td>
</tr>
</table><br>


<p>
When a column of integer data is summed or averaged, SQL Server always returns a four-byte integer, regardless of the size of the column. Therefore, be sure that the variable that is to contain the result from such a compute is declared as DBINT and that the <i>vartype</i> of the binding is INTBIND.

<p>
When the source column specified by the <i>column</i> parameter has a type of SQLDECIMAL or SQLNUMERIC, you can keep the same precision and scale in your bound C variable by using SRCDECIMALBIND or SRCNUMERICBIND.
</dd>
<dt>
<i>varlen</i></dt>
<dd>
Is the length of the program variable in bytes. For fixed-length <i>vartypes</i>, such as MONEYBIND or FLT8BIND, this length is ignored. For character and binary types, <i>varlen</i> must describe the total length of the available destination buffer space, including any space required for special terminating bytes, such as a null terminator. If <i>varlen</i> is 0, the total number of bytes available is copied into the program variable. (For <i>char</i> and <i>binary</i> SQL Server data, the total number of bytes available is equal to the defined length of the database column, including any blank padding. For <i>varchar</i> and <i>varbinary</i> data, the total number of bytes available is equal to the actual data contained in the column.) Therefore, if you are sure that your program variable is large enough to handle the results, set <i>varlen</i> to 0. The <i>varlen</i> is ignored for VARYCHARBIND and VARYBINBIND data.</dd>
<dt>
<i>varaddr</i></dt>
<dd>
Is the address of the program variable to which the data is copied. Calling <b>dbaltbind</b> with a null <i>var</i> address parameter breaks previously set bindings.
<p>
When binding using DECIMALBIND or NUMERICBIND, the <i>varaddr</i> parameter must be a pointer to a DBNUMERIC or DBDECIMAL C variable, respectively, with the <i>precision</i> and <i>scale</i> fields of the structure already set to the desired values. You can use DEFAULTPRECISION to specify a default precision and DEFAULTSCALE to specify a default scale.

</dd>
</dl>
<h4>Returns</h4>
<p>
SUCCEED or FAIL. The <b>dbaltbind</b> function returns FAIL if <i>vartype</i> isn't compatible with the SQL Server type being returned, or if <i>varaddr</i> is null.</p>
<h4>Remarks</h4>
<p>
This function directs DB-Library to copy compute column data returned by SQL Server into a program variable. (A <i>compute column</i> is a column of results from a COMPUTE clause in a Transact-SQL SELECT statement.) When each new row containing computed data is read by <b>dbnextrow</b> or <b>dbgetrow</b>, the data from the designated <i>column</i> in that compute row is copied into the program variable with the address <i>varaddr</i>. (A <i>compute row</i> is a row of results from a COMPUTE clause in a Transact-SQL SELECT statement.) There must be a separate <b>dbaltbind</b> call for each compute column to be copied. It is not necessary to bind every compute column to a program variable.</p>
<p>
SQL Server can return two types of rows: regular rows containing data from columns designated by a SELECT statement's select list, and compute rows resulting from the COMPUTE clause. The <b>dbaltbind</b> function binds data from compute rows. Use <b>dbbind</b> for binding data from regular rows.</p>
<p>
The calls to <b>dbaltbind</b> must be made after a call to <b>dbresults</b> and before the first call to <b>dbnextrow</b>.</p>
<p>
Using <b>dbaltbind</b> causes some overhead because it always copies the row data into the designated program variable. To avoid this copying, the returned data can be accessed more directly with <b>dbadlen</b> and <b>dbadata</b>.</p>
<p>
Since null values can be returned from SQL Server, there is a set of default values, one for each datatype, that is substituted when binding null values. You can explicitly set your own values to be substituted for the default null values with the <b>dbsetnull</b> function. (For a list of the default substitution values, see <a href="pdc04e_2zxo.htm">dbsetnull</a>.) </p>
<h4>Example</h4>
<p>
This example shows the typical sequence of calls:</p>
<pre>DBCHAR    name[20];
DBINT    namecount;

// Read the query into the command buffer. 
dbcmd(dbproc, "select name from employee compute count(name)");
// Send the query to SQL Server. 
dbsqlexec(dbproc);
// Get ready to process the results of the query. 
dbresults(dbproc);
// Bind the regular row data - name. 
dbbind(dbproc, 1, STRINGBIND, (DBINT) 0, name);
// Bind the compute column data - count of name. 
dbaltbind(dbproc, 1, 1, INTBIND, (DBINT) 0, (BYTE *) &amp;namecount);
// Now process each row. 
while (dbnextrow(dbproc) != NO_MORE_ROWS)
{
    //C-code to print or process row data
}
</pre>
<h4>See Also</h4>
<p>
<a href="pdc04a_00kh.htm"><b>dbadata</b></a>, <a href="pdc04a_0ylq.htm"><b>dbadlen</b></a>, <a href="pdc04b_3lk4.htm"><b>dbanullbind</b></a>, <a href="pdc04b_4zc4.htm"><b>dbbind</b></a>, <a href="pdc04b_92t0.htm"><b>dbconvert</b></a>, <a href="pdc04c_1ad3.htm"><b>dbgetrow</b></a>, <a href="pdc04d_0fqv.htm"><b>dbnextrow</b></a>, <a href="pdc04e_52sz.htm"><b>dbresults</b></a>, <a href="pdc04e_2zxo.htm"><b>dbsetnull</b></a>, <a href="pdc04f_1c38.htm"><b>dbwillconvert</b></a>; <a href="pdcb_852a.htm">DB-Library Datatypes</a></p>
<p>
</p>
<p>&nbsp;</p></body>
</HTML>
