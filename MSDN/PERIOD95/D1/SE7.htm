<HTML><HEAD><script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Finding the Shortest Path Between Two Points</TITLE><META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset= iso-8859-1">
<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">
<H1>Finding the Shortest Path Between Two Points</H1><P><I>We'd like to thank Dr. Andrew Wright, from the University of Louisville Computer Information Systems Department, for lending technical advice to this article.</I></P>
<P>When commuter traffic companies such as air travel agencies or bus lines book your trip, they use software to determine the best route between your point of departure and your destination. Their software takes into account the number of people traveling on the particular vehicle, the amount of time involved, and the shortest distance between the two points, among other things. Thanks to an early computer scientist named E. W. Dijkstra, finding the shortest path between two points is a relatively easy process, though an involved one. </P>
<P>Dijkstra developed an algorithm commonly, and appropriately, called the Shortest Path Algorithm. If you've had formal training in computer science, you've probably encountered Dijkstra's algorithm. If you haven't crossed paths with the Shortest Path Algorithm, hold onto your hats. We're going to learn about this algorithm and discover its usefulness. We'll also show you a program that implements this algorithm, but first, let's see how it works.</P>
<H2><A NAME="sec0"></A>Dijkstra's Algorithm</H2><P>If you've looked in almost any computer science books that contain the Shortest Path Algorithm, you've probably seen something that you'd think only a person with an advanced degree in mathematics could decipher. Many books list the algorithm in cryptic codes that look something like this:</P>
<OL><LI>    [Initialization.] Set <I>L</I>(<I>a</I>) := 0. For all vertices <I>x </I><FONT FACE="Symbol"><I>¹</I></FONT><I> a</I>, set <I>L(x)</I> := <FONT FACE="Symbol">¥</FONT>. Let <I>T</I> be the set of vertices.</LI><LI>    [Done?] If <I>z</I> <FONT FACE="Symbol">Î</FONT> <I>T</I>, stop. (<I>L</I>(<I>z</I>) is the length of a shortest path from <I>a</I> to <I>z</I>.)</LI><LI>   [ Get next vertex.] Choose v <FONT FACE="Symbol">Î</FONT> T with the smallest value of <I>L</I>(<I>v</I>). Set <I>T</I> := <I>T</I> - {<I>v</I>}.</LI><LI>    [Revise labels.] For each vertex <I>x</I> <FONT FACE="Symbol">Î</FONT> <I>T</I> adjacent to <I>v</I>, set  <I>L</I>(<I>x</I>) := min {<I>L</I>(<I>x</I>),<I> L</I>(<I>v</I>) + <I>w</I>(<I>v</I>,<I> x</I>)}.</LI><LI>    Go to step 2.</LI></OL><P>Although there is plenty to be said about brevity in our current Information Age, unless you're a mathematically trained person, the above notation probably doesn't make a lot of sense to you. Don't let the cryptic formula intimidate you, though. Once you convert the algorithm to plain terms, it is elegantly simple. Listing A shows the Shortest Path Algorithm in its basic algorithmic form.</P>
<P><BR></P>
<PRE>DO
    Find the node N that hasn't been included and has the smallest distance.
   Mark node N as included (Included(N) = True)
   For each N2 that isn't included
      IF Weight(N2, N) &gt; 0 THEN
         IF Distance(N) + Weight(N,N2) &lt; Distance(N2) THEN
            Distance(N2) = Distance(N) + Weight(N2,N)
            Path(N2) = N
         END IF
      END IF
   Next N2
LOOP UNTIL all nodes are included</PRE>
<P><B>Listing A. Shortest Path Algorithm</B></P>
<P>The algorithm depends on an element called a <I>weighted graph</I>. A weighted graph is simply a graph that shows the distances between two points. The lines in a weighted graph that connect two points are called edges and each point in the graph is called a node. Each edge in the graph is assigned the distance between the two nodes it connects. For example, Figure A shows a map of the United States with paths connecting several cities, depicting shipping routes for MadeUp Trucking, Inc. We've assigned each path, or edge, the ground traveling distance between the two cities, or nodes, each edge connects. </P>
<P><img src="1563.gif"></P>
<P><B>Figure A. Any graph showing the distance between two points is a weighted graph.</B></P>
<P>Before the algorithm can work, you need to do some preliminary initialization of three arrays. We'll call these three arrays Included, Distance, and Path. All three arrays should be of integer type. However, we'll use Included to contain boolean data. </P>
<P>Assume that <I>From</I> is the point from which you want to start, <I>To</I> is where you want to go, and <I>N</I> is any other node. You initialize Included(From) to True and the rest of Included(N) to False. You initialize Distance(N) according to the rule shown in Figure B.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="131pt" VALIGN="TOP"><COL WIDTH="332pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>0 if N = From</P></TD></TR><TR><TD VALIGN="TOP"><P>Distance</P></TD><TD VALIGN="TOP"><P>Weight(From,N) if Weight(From,N) &lt;&gt; 0</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>Infinity if N isn't connected to From by a direct path (if Weight(From, N) = 0)</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Figure B. Initialize the Distance array according to this rule.</B></P>
<P>The Weight( ) function simply returns the distance between the two points you pass to it. If the two points are not connected by a direct path, then Weight returns the value 0. You then initialize the Path array according to the rule shown in Figure C.</P>

<TABLE COLS="2" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="171pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P>Path(N) = </P></TD><TD VALIGN="TOP"><P>From if Weight(From,N) &lt;&gt; 0</P></TD></TR><TR><TD VALIGN="TOP"><P></P></TD><TD VALIGN="TOP"><P>Undefined if Weight(From,N) = 0</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Figure C. Initialize the Path array according to this rule.</B></P>
<H2><A NAME="sec1"></A>The ShortPath Program</H2><P>Now, let's look at the Microsoft&reg; Visual Basic&reg; (VB) program that determines the shortest path to see what actually happens. Listing B shows the code for Form2, our program for finding the shortest path between two points. The ShortPath program uses four user-defined functions: AllIncluded( ), which checks to see whether all the nodes have been included; MinNode( ), which returns the unincluded node with the minimum distance; Weight( ), which returns the weight of the edge connecting two points; and Initialize ( ), which initializes our three arrays.</P>
<P><BR></P>
<PRE>' [Declarations Section]
Dim NumNodes  As Integer
Dim Infinity  As Integer
Dim Street()  As StreetType
Dim Distance()  As Integer
Dim Path()  As Integer
Dim Included()  As Integer
Dim A_Show As Integer

'***************************************************
Function AllIncluded ()
RetVal = True             ' Assume all are included
For X% = 1 To NumNodes
    If Included(X%) = False Then RetVal = False
Next
AllIncluded = RetVal
End Function

'***************************************************
Sub Command1_Click ()
Unload Me
End Sub

'***************************************************
Sub Command2_Click ()
FindPath
End Sub

'***************************************************
Sub Command3_Click ()
A_Show = Not A_Show
Command3.Caption = IIf(A_Show, "Hide Arrays", "Show Arrays")
End Sub

'***************************************************
Sub FindPath ()
' Now, get data from file
For X% = 1 To NumStreets%
    Get #1, X%, Street(X%)
Next X%
s% = 0
t% = 0
' Convert city to number
For X% = 1 To NumCities%
    Get #2, X%, GetCity
    test$ = UCase$(LTrim$(Trim$(GetCity)))
    If UCase$(LTrim$(RTrim$(Source.Text))) = test$ Then s% = X%
    If UCase$(LTrim$(RTrim$(target.Text))) = test$ Then t% = X%
    If (s% &lt;&gt; 0) And (t% &lt;&gt; 0) Then Exit For
Next
If (s% = 0) Or (t% = 0) Then
    Beep
    MsgBox "*****  Location(s) not found **** " + IIf(s% = 0, Chr(13)  
         + Source.Text, "") + IIf(t% = 0, Chr(13) + target.Text, "")
    Exit Sub
End If
Initialize s%, t%
'***
'* Begin Shortest Path function
spath$ = ""
Do
    If A_Show Then
        tt$ = ""
        For XX% = 1 To NumNodes%
            tt$ = tt$ + Format$(XX%, "00") &amp; " " &amp; Format$(Distance(XX%), 
              "00000") &amp; "  " &amp; Format$(Path(XX%), "00") &amp; "  " &amp; 
              Format$(Included(XX%), "00") + Chr$(13)
        Next
        If MsgBox(tt$, 1) = 2 Then   ' cancel
            command3_click
        End If
    End If
    j% = MinNode()
    Included(j%) = True
    For X% = 1 To NumNodes
        If Included(X%) = False Then
            ' Prevent overflowing on any system
            If (Weight(j%, X%) &lt; Infinity) And (Distance(j%) &lt; 
                Infinity) Then
                If Distance(j%) + Weight(j%, X%) &lt; Distance(X%) Then
                  Distance(X%) = Distance(j%) + Weight(j%, X%)
                    Path(X%) = j%
                End If
            End If
        End If
    Next
Loop Until AllIncluded() = True
j% = t%
spath$ = LTrim$(RTrim$(Str$(j%)))

Do
    X% = Path(j%)
    spath$ = LTrim$(RTrim$(Str$(X%))) + ", " + spath$
    j% = X%
    If X% = -1 Then
        MsgBox "No Path Possible"
        Exit Sub
    End If
Loop Until (X% = Path(X%))
list1.Clear
list1.AddItem "The Shortest Path between the two is:"
location = InStr(spath$, ",")

Do While location &gt; 0
    t% = Val(Mid$(spath$, 1, location - 1))
    Get #2, t%, GetCity
    list1.AddItem "---- " &amp; GetCity
    spath$ = Mid$(spath$, location + 1)
    location = InStr(spath$, ",")
Loop
t% = Val(spath$)
Get #2, t%, GetCity
list1.AddItem "---- " &amp; GetCity
Mileage.Caption = Distance(t%)
Source.SetFocus
End Sub

'***************************************************
Sub Form_Load ()
NumNodes% = NumCities%
Infinity = 32767
Source = String$(20, " ")
Target = Source
ReDim Street(1 To NumStreets%)   As StreetType
ReDim Distance(1 To NumNodes%)  As Integer
ReDim Path(1 To NumNodes%)  As Integer
ReDim Included(1 To NumNodes%)  As Integer
A_Show = True
End Sub

'***************************************************
Sub Initialize (s%, t%)
For X% = 1 To NumNodes%
    Wgt% = Weight(s%, X%)
    Distance(X%) = Wgt%
    If s% = X% Then
        Included(X%) = True
    Else
        Included(X%) = False
    End If
    If Wgt% &gt;= 0 And Wgt% &lt;&gt; Infinity Then
        Path(X%) = s%       ' source
    Else
        Path(X%) = -1
    End If
Next
End Sub

'***************************************************
Function MinNode ()
'* Searches the unincluded nodes for the shortest distance and returns 
'* that node's number. Requires global arrays Included() and Distance()
Dim temp As Integer
min% = Infinity     ' Max number for Integer
For X% = 1 To NumNodes
    If Included(X%) = False Then        ' Not included
        temp% = X%
        If Distance(X%) &lt; min% Then
            min% = Distance(X%)
            node% = X%
        End If
    End If
Next
If min% = Infinity Then
    node% = temp%
End If
MinNode = node%
End Function

'***************************************************
Function Weight (Source%, j%)
'* Returns the weight, or distance, between the two nodes Source and j.  
'* If Source is the same as j, Weight returns 0. If the two nodes 
'* aren't connected by a path, Weight returns Infinity.
RetVal = 0
If j% = Source% Then
    Weight = 0
    Exit Function
End If
For X% = 1 To UBound(Street)
    If (Street(X%).from = Source% And Street(X%).to = j%) Or  
           (Street(X%).from = j% And Street(X%).to = Source%) Then
        RetVal = Street(X%).Wgt
        Exit For
    End If
Next
If RetVal = 0 Then
    RetVal = Infinity
End If
Weight = RetVal
End Function</PRE>
<P><B>Listing B. The Shortest Path program</B></P>
<P>After you choose the Find Shortest Path button from our demonstration form shown in Figure D, our shortest path system executes the code found in Listing C, which is stored in the system's module. We called the module SHORTPAT.BAS. The code in the module declares the type StreetType, which houses the structure for our street records (From, To, and Wgt). The module code also declares several other variables and opens the files we'll use in our system. Notice that we also calculate the number of records in each file (NumCities% and NumStreets%). These values are required for our algorithm to function properly.</P>
<P><img src="1564.gif"></P>
<P><B>Figure D. This is the main form in our Shortest Path demonstration.</B></P>
<P><BR></P>
<PRE>Type StreetType
    From As Integer
    To As Integer
    Wgt As Integer
End Type
Dim Street As StreetType
Global GetCity As String * 20
Global FromCity As String * 20
Global ToCity As String * 20
Global TString As String * 20
Global NumCities As Integer
Global NumStreets As Integer
Global fCity As String * 20
Global tCity As String * 20
Sub MainInit (&nbsp;)
RecSize% = Len(Street)
Open "i:\articles\VBW\ivb0395\street.dat" For Random Access Read Write 
       Lock Read Write As #1 Len = RecSize%
NumStreets% = LOF(1) / RecSize%
GetCity = String$(20, " ")
RecSize2% = Len(GetCity)
Open "i:\articles\VBW\ivb0395\City.dat" For Random Access Read Write 
       Lock Read Write As #2 Len = RecSize2%
NumCities% = LOF(2) / RecSize2%
End Sub</PRE>
<P><B>Listing C. The module SHORTPAT.BAS</B></P>
<P>The Form_Load( ) event—back in Listing B—then initializes a couple more variables. The variable <I>NumNodes%</I> stores the number of cities (or nodes) on file. Since we don't have an Infinity value in VB, we assign a large number to the variable <I>Infinity</I>. The function then declares and initializes the three arrays we previously mentioned. You'll see that we dimension the array Street using <I>NumStreets%</I>, since it stores the number of streets (or edges). Next, we initialize a logical variable <I>A_Show</I>, which we'll use to show us how the arrays' values change through each iteration.</P>
<P>Once you load this form, you'll see that the system is waiting for you to enter two locations: a starting point and a destination. Using Figure E as an example, suppose you want to ship a package from Topeka, Kansas, to Louisville, Kentucky. Enter <I>Topeka</I> as the Starting Point and <I>Louisville</I> as the Destination. Then, click the FindPath button to start the search for the shortest path between these two cities.</P>
<P><img src="1565.gif"></P>
<P><B>Figure E. Our Find Shortest Path form lets you enter a starting point and a destination; then it calculates the distance of the shortest path between those two points.</B></P>
<H2><A NAME="sec2"></A>The FindPath Subroutine</H2><P>FindPath first fills the Street array with data. When the For-Next loop finishes, Street will contain every From-To-Wgt combination we have on file. The subroutine then initializes the variables <I>s%</I> and <I>t%</I>, which will contain the numbers of the cities you entered.</P>
<P>We naturally refer to the cities on our map by their names. The algorithm, however, works better by referring to the cities as numbers. FindPath's routine converts the cities' names to numbers for us. If the Source or Target city is found on file, that city's record number is stored in either s% or t% for source or target, respectively (remember the city's record number is the index used in STREET.DAT). </P>
<P>If either s% or t% is equal to zero after the file search, that means one of the cities hasn't been found. FindPath informs you and loops back for data re-entry. </P>
<P>Next, FindPath calls the Initialize( ) routine. After initialization, ShortPat's three arrays look similar to the ones in Figure F. You can see that all the X data is in numeric form. There are no city names listed because the record number shown in column X represents the city. That is, each X number is the index for a particular city in CITY.DAT. (If you'd like to stop tracing through the arrays as each iteration completes, you can click the Hide Arrays button. This disables the function that displays a list—for reference purposes only—similar to the one in Figure F. </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>x</B></P></TD><TD VALIGN="TOP"><P><B>Distance</B></P></TD><TD VALIGN="TOP"><P><B>Path</B></P></TD><TD VALIGN="TOP"><P><B>Included</B></P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>557</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>514</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>578</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>13</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>16</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>17</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>18</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>21</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>22</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>23</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>24</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Figure F. The three arrays ShortPat uses look like this after initialization with our sample data.</B></P>
<P>This month's Software Developer's Resource Disk contains our sample data. So, if you look at record 8 in CITY.DAT, you'll see that <I>Topeka</I> is the city name. Table A shows the city index table for the sample data. You can generate your own listing by using the Add City option of our Shortest Path Demonstration form, shown in Figure D earlier in this article.</P>
<P><B>Table A. This is the city index table, CITY.DAT, for our sample data. </B></P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="99pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"><COL WIDTH="100pt" VALIGN="TOP"><COL WIDTH="54pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>City</B></P></TD><TD VALIGN="TOP"><P><B>Index</B></P></TD><TD VALIGN="TOP"><P><B>City</B></P></TD><TD VALIGN="TOP"><P><B>Index</B></P></TD></TR><TR><TD VALIGN="TOP"><P>Los Angeles</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>Des Moines</P></TD><TD VALIGN="TOP"><P>13</P></TD></TR><TR><TD VALIGN="TOP"><P>Carson City</P></TD><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>Milwaukee</P></TD><TD VALIGN="TOP"><P>14</P></TD></TR><TR><TD VALIGN="TOP"><P>Salt Lake City</P></TD><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>Lansing</P></TD><TD VALIGN="TOP"><P>15</P></TD></TR><TR><TD VALIGN="TOP"><P>Denver</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>Louisville</P></TD><TD VALIGN="TOP"><P>16</P></TD></TR><TR><TD VALIGN="TOP"><P>Phoenix</P></TD><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>Pittsburgh</P></TD><TD VALIGN="TOP"><P>17</P></TD></TR><TR><TD VALIGN="TOP"><P>Helena</P></TD><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>New York</P></TD><TD VALIGN="TOP"><P>18</P></TD></TR><TR><TD VALIGN="TOP"><P>Bismarck</P></TD><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>Atlanta</P></TD><TD VALIGN="TOP"><P>19</P></TD></TR><TR><TD VALIGN="TOP"><P>Topeka</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>Nashville</P></TD><TD VALIGN="TOP"><P>20</P></TD></TR><TR><TD VALIGN="TOP"><P>Dallas</P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>Birmingham</P></TD><TD VALIGN="TOP"><P>21</P></TD></TR><TR><TD VALIGN="TOP"><P>Austin</P></TD><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>Tampa</P></TD><TD VALIGN="TOP"><P>22</P></TD></TR><TR><TD VALIGN="TOP"><P>Jackson</P></TD><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>Jacksonville</P></TD><TD VALIGN="TOP"><P>23</P></TD></TR><TR><TD VALIGN="TOP"><P>Chicago</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>Miami</P></TD><TD VALIGN="TOP"><P>24</P></TD></TR></TBODY></TABLE>
<P><BR></P><P>If any node is connected to the starting point, or Source node, the Distance array contains the distance from Source to that node. For example, Distance(4) contains 557, which is the distance from Topeka to Denver, as you can see in Figure A. Likewise, Distance(9) contains 514—the distance from Topeka to Dallas. Since there is no direct path from Topeka to Louisville, Distance(16) contains our value for infinity. </P>
<P>The program initializes all paths to the Source variable if an edge exists between the Source and the node. Otherwise, FindPath assigns the value -1 (for undefined, in this case) to the path. The Included array contains a logical True for our Source node and a logical False for all others.</P>
<P>Next, the program initializes the <I>SPath$</I> variable to null and enters a DO loop. The routine then checks to see whether it should show the iteration's array values. If so, it builds a string, then displays the string using the MsgBox( ) function. </P>
<P>FindPath uses the variable <I>j%</I> to act as another node counter. The FindPath program first assigns the node with the minimum distance to j% by calling the function MinNode( ). Following the algorithm, the program marks this node as included. Then, the program checks the weights (distances) between all the unincluded nodes and the MinNode node. If the value stored in Distance(j%) plus the weight of the edge between the new nodes is less than the distance stored for the unincluded node, then the shorter distance is stored. Finally, the program updates Path(unincluded node) with the MinNode value. Path(X) always contains the last node visited before X.</P>
<P>Let's clear things up a bit. If you look at Figure G, you'll see what the data arrays look like after the first iteration of the DO loop. Since, from Figure F (above), node 9 contains the smallest distance of all the nodes not yet included, FindPath uses it as the MinNode value and then marks it included with a value of .T.. Next, the program checks the distances between node 9 and the rest of the unincluded nodes to see whether it can find a shorter path. </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>x</B></P></TD><TD VALIGN="TOP"><P><B>Distance</B></P></TD><TD VALIGN="TOP"><P><B>Path</B></P></TD><TD VALIGN="TOP"><P><B>Included</B></P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>557</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>514</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>713</P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>933</P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>578</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>13</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>16</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>17</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>18</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>21</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>22</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>23</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR><TR><TD VALIGN="TOP"><P>24</P></TD><TD VALIGN="TOP"><P>32767</P></TD><TD VALIGN="TOP"><P>-1</P></TD><TD VALIGN="TOP"><P>0</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Figure G. This is the state of the arrays after the first iteration of the DO loop.</B></P>
<P>In our example, the program doesn't find a shorter path until it checks node 10. Since the distance from Topeka through Dallas to Austin—713 miles—is shorter than Infinity, ShortPat stores the new value in Distance(10)—10 is the index for Austin. It then stores the MinNode value—9— in Path(10) and proceeds with the rest of the loop in like manner.</P>
<P>When the program finishes, the arrays contain data like that shown in Figure H. You can see that all the nodes are now marked included, which is the condition under which the program terminates. If you follow the trail from your destination node, in this case, Louisville—Path(16)—you'll end up at Path(8), which is the index for Topeka. To see what we mean, check Path(16). It refers you to 12, which is Chicago. Now check Path(12). It refers you to Path(8), which is Topeka. Path(8) refers to itself, so you know your path-finding is finished. The total distance for the trip is stored in the Distance node for your destination. So, checking the Distance array for Louisville, Distance(16), you see that 875 is the length of the trip, which Figure E (earlier in this article) shows. </P>

<TABLE COLS="4" BORDER="0" CELLPADDING="7"><COLGROUP><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"><COL WIDTH="72pt" VALIGN="TOP"></COLGROUP><TBODY><TR><TD VALIGN="TOP"><P><B>x</B></P></TD><TD VALIGN="TOP"><P><B>Distance</B></P></TD><TD VALIGN="TOP"><P><B>Path</B></P></TD><TD VALIGN="TOP"><P><B>Included</B></P></TD></TR><TR><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>1751</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>2</P></TD><TD VALIGN="TOP"><P>2205</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>3</P></TD><TD VALIGN="TOP"><P>1075</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>557</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>5</P></TD><TD VALIGN="TOP"><P>2143</P></TD><TD VALIGN="TOP"><P>1</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>6</P></TD><TD VALIGN="TOP"><P>1395</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>7</P></TD><TD VALIGN="TOP"><P>1282</P></TD><TD VALIGN="TOP"><P>4</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>0</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>514</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>10</P></TD><TD VALIGN="TOP"><P>713</P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>11</P></TD><TD VALIGN="TOP"><P>933</P></TD><TD VALIGN="TOP"><P>9</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>578</P></TD><TD VALIGN="TOP"><P>8</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>13</P></TD><TD VALIGN="TOP"><P>920</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>14</P></TD><TD VALIGN="TOP"><P>666</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>15</P></TD><TD VALIGN="TOP"><P>783</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>16</P></TD><TD VALIGN="TOP"><P>875</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>17</P></TD><TD VALIGN="TOP"><P>1042</P></TD><TD VALIGN="TOP"><P>12</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>18</P></TD><TD VALIGN="TOP"><P>1410</P></TD><TD VALIGN="TOP"><P>17</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>1317</P></TD><TD VALIGN="TOP"><P>16</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>20</P></TD><TD VALIGN="TOP"><P>1574</P></TD><TD VALIGN="TOP"><P>16</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>21</P></TD><TD VALIGN="TOP"><P>1484</P></TD><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>22</P></TD><TD VALIGN="TOP"><P>1788</P></TD><TD VALIGN="TOP"><P>19</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>23</P></TD><TD VALIGN="TOP"><P>1988</P></TD><TD VALIGN="TOP"><P>22</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR><TR><TD VALIGN="TOP"><P>24</P></TD><TD VALIGN="TOP"><P>2057</P></TD><TD VALIGN="TOP"><P>22</P></TD><TD VALIGN="TOP"><P>-1</P></TD></TR></TBODY></TABLE>
<P><BR></P><P><B>Figure H. ShortPat terminates after it includes all nodes. Upon termination, the arrays look like this.</B></P>
<H2><A NAME="sec3"></A>Creating the Data Files</H2><P>The program isn't functional without data files in the proper format, so we've included a form entitled <I>Add City and Distance to File</I> that lets you create them. The code for the form, shown in Listing D, asks you for two points and the distance between them. It checks to see whether the cities you've entered are already in the CITY.DAT file. If they aren't, the code adds the cities. If they are, the code uses their index numbers to build STREET.DAT. The CITY.DAT file contains one city name per record. The STREET.DAT file contains two city index numbers and a distance per record. </P>
<P><BR></P>
<PRE>'[Declarations Section]
Dim street As StreetType
Dim Tstring As String * 20

'***************************************************
Sub Command1_Click ( )
MsgBox "There should be " &amp; NumCities% &amp; " cities on file."
Unload Me
End Sub

'***************************************************
Sub Command2_Click ( )
X% = 1
If LOF(2) &gt; 0 Then
    street.from = 0
    street.to = 0
    Do
        Get #2, X%, GetCity
        If Not EOF(2) Then
            Test$ = UCase$(LTrim$(RTrim$(GetCity)))
            If UCase$(LTrim$(RTrim$(FromCity.Text))) = Test$ Then 
                 street.from = X%
            If UCase$(LTrim$(RTrim$(ToCity.Text))) = Test$ Then 
                 street.to = X%
                X% = X% + 1
        End If
    Loop Until EOF(2) Or ((street.from &lt;&gt; 0) And (street.to &lt;&gt; 0))
End If
'*) if we've reached EOF(&nbsp;) and either street record is 0, then the 
'*) city isn't on file
If street.from = 0 Then
    Tstring = Mid$(FromCity.Text, 1, 20)
    Beep
    MsgBox "Adding city " &amp; Tstring
    Put #2, X%, Tstring
    street.from = X%
    X% = X% + 1
End If
If street.to = 0 Then
    Tstring = ToCity.Text
    Beep
    MsgBox "Adding city " &amp; Tstring
    Put #2, X%, Tstring
    street.to = X%
End If
street.Wgt = Val(Distance.Text)
NumStreets% = NumStreets% + 1
Put #1, NumStreets%, street
List1.AddItem FromCity.Text &amp; "  " &amp; ToCity.Text &amp; "  " &amp; street.Wgt
List1.ListIndex = List1.ListCount - 1
FromCity.SetFocus
End Sub

'***************************************************
Sub command3_click (&nbsp;)
ListCity
End Sub

'***************************************************
Sub Form_Load (&nbsp;)
FromCity.Text = GetCity
ToCity.Text = GetCity
ListCity
End Sub

'***************************************************
Sub ListCity (&nbsp;)
RecSize% = Len(street)
NumStreets% = LOF(1) / RecSize%
List1.Clear
For X% = 1 To NumStreets%
    fCity = String$(20, " ")
    tCity = String$(20, " ")
    Get #1, X%, street
    f% = street.from
    t% = street.to
    Get #2, f%, fCity
    Get #2, t%, tCity
    List1.AddItem Left(fCity, 15) &amp; " " &amp; Left(tCity, 15) &amp; " " &amp; 
        street.Wgt
Next X%
GetCity = String$(20, " ")
RecSize2% = Len(GetCity)
NumCities% = LOF(2) / RecSize2%
MsgBox "There are currently " &amp; NumCities% &amp; " cities and " &amp; 
     NumStreets% &amp; " streets on file."
End Sub</PRE>
<P><B>Listing D. Add City and Distance to the form's Code</B></P>
<H2><A NAME="sec4"></A>So What Good Is It?</H2><P>The Shortest Path program obviously fills the bill quite well for an application like the one we've presented here. However, it doesn't have to be used only for finding the shortest travel distances. You may wish to assign the cost of plane tickets to the edges of your own graph. Then, you could determine the cheapest route from Helena, Montana, to Miami, Florida. Or, perhaps you may decide to let the edges represent project roads and their weights equal the cost of building the road. This could tell you the most economical route to build. In a situation in which you're experimenting with several hundred vertices, you can see how this program would come in handy.</P>
<P>You'll find all the files from this article on this month's Software Developer's Resource Disk. To order the disk, call Customer Relations at (800) 223-8720.</P>
<P><I>This article is reproduced from the March 1995 issue of </I>Inside Visual Basic for Windows<I>. Copyright 1995, The Cobb Group. All rights are reserved. </I>Inside Visual Basic for Windows<I> is an independently produced publication of The Cobb Group. No part of this article may be used or reproduced in any fashion (except in brief quotations used in critical articles and reviews) without prior consent of The Cobb Group. To contact The Cobb Group, please call (800) 223-8720 or (502) 491-1900.</I></P>
<P></P></font></body></HTML>
