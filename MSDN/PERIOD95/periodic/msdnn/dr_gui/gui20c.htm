<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Setting View Properties with MFC</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<p><font color="#000000" size="5" face="verdana,arial,helvetica">Setting
View Properties with MFC</font><font color="#000000"
face="verdana,arial,helvetica"> </font></p>

<h2><font color="#000000" size="2" face="verdana,arial,helvetica">Dear
Dr. GUI:</font></h2>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">What
is the best way to change the background color of a <b>CFormView</b>?
I would rather not use <b>OnEraseBackground</b> because the code
would execute repeatedly. I would rather register the correct
window class background color and pass that to <b>CFormView</b>
to use during initialization. How do you initialize the
properties of a <b>CFormView</b>? </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Don
Baechtel </font></p>

<h2><font color="#000000" size="2" face="verdana,arial,helvetica">Dr.
GUI replies:</font></h2>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Now
Don has touched on an insidious subject that afflicts a
substantial, but silent (and subsequently Dr. GUI T-shirtless),
portion of the Hippocratic faithful. When your <b>CFormView</b>
derived object's window is created, you are actually using <b>CreateDialog</b>,
rather than the <b>CreateWindow</b> function, to create the
window as a child dialog box from the dialog template you
designed with App Studio. Because <b>CreateDialog</b> will use
only the Windows internal window class, WC_DIALOG, you are forced
to accept some unmodifiable window properties, one of which is
the background color. A brief foray into the realm of OOP-madness
might lead you to try setting the background color with <b>CWinApp::SetDialogBkColor</b>;
however, slightly more sane logic would remind you that <b>CFormView</b>
is not derived from <b>CDialog</b> and that this method would
have no effect on your view's background color. Hmmmm...let's try
to trace back to what Windows does when we're not tinkering with
the system. That seems easy enough, because Windows just sends a
WM_ERASEBKGND message when the window's background needs to be
redrawn. Does this mean we write a message handler for
WM_ERASEBKGND? Doing so would repaint the background as we want,
but how would the background of the controls on the view be
redrawn? Once again, the answer lies in how Windows does it.
Investigate the default dialog procedure (check the Visual C++
1.5 DEFPROCS sample in the Development Library for DEFDLG.C) and
you will find that WM_ERASEBKGND is dealt with by a call to <b>FillWindow</b>
before returning a value of TRUE: </font></p>

<pre><code>case WM_ERASEBKGND:
   FillWindow(hwnd, hwnd, (HDC) wParam, (HBRUSH) CTLCOLOR_DLG);
   return ((LRESULT) (LONG) TRUE);</code></pre>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">If
you've skipped ahead and tried to find <b>FillWindow</b> in any
of the documentation sources, you will have noticed that it isn't
anywhere to be found. Fortunately, Dr. GUI, diviner of all
functions obscure and nested, can help demystify this for you.
Drum roll, please...it fills a window!! Admittedly, that was a
bit anticlimactic, but only because I haven't told you the
interesting bit yet. If the <b>HBRUSH</b> parameter with which <b>FillWindow</b>
is called is one of a few special values, such as CTLCOLOR_DLG as
above, it will send a WM_CTLCOLOR message to the window's parent.
This is where we should step in with a message handler in our <b>CFormView</b>
derived class. Specifically, we want to create a WM_CTLCOLOR
message handler, <b>OnCtlColor</b>, that returns a handle to a
brush of the desired background color when it is passed a
CTLCOLOR_DLG value. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">With
the view's background dealt with properly, we need to start
thinking about redrawing the controls on our view. Conveniently
enough, the other CTLCOLOR_<i>XXX</i> values that accompany
WM_CTLCOLOR correspond to the different types of controls, so all
we need to do is check for the appropriate values in our <b>OnCtlColor</b>
function. Controls that have text attached to them, such as radio
buttons and static controls, require an additional processing
step to color the background beneath the text. For example, to
differentiate text tags with a different color, call <b>CDC::SetBkColor</b>
from the appropriate CTLCOLOR_<i>XXX</i> handler inside <b>OnCtlColor</b>.
If, on the other hand, you'd like to maintain a consistent
background color, use <b>CDC::SetBkMode</b> to change the
background mode to TRANSPARENT. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">The
condensed version of all of this is pretty simple: Set the
background color of a <b>CFormView</b> derived object and the
controls on it by checking for the appropriate CTLCOLOR_<i>XXX</i>
in the <b>OnCtlColor</b> message handler of your <b>CFormView</b>
derived class. </font></p>

<p><font color="#000000" size="2" face="verdana,arial,helvetica">Now
that we've dealt with the fundamentals, someone has invariably
done a bit of exploring and found that CTLCOLOR_LISTBOX and
CTLCOLOR_EDIT do not take care of the corresponding components of
a combo-box control. A brief review of the WM_CTLCOLOR message
will remind you that this message is passed to the parent of the
window that needs to be redrawn, which, in our case, is the <b>CFormView</b>
derived class for the view's background and &quot;simple&quot;
controls. Combo boxes are a bit more complex than their brethren,
however, as there are child windows for the edit control and list
box components of the combo-box control. Herein lies our problem.
When the child windows need to have their backgrounds redrawn,
they are sending WM_CTLCOLOR messages to the combo-box control
object rather than to the parent's parent, <b>CFormView</b>. The
solution is to derive a class from <b>CComboBox</b> to augment
its behavior and then attach it to the control object via
subclassing. Because this subject is outside the scope of our
discussion, I will simply point you to an excellent treatment of
the subject by my gifted cohort, Dale Rogerson, titled
&quot;Subclassing Windows with the Microsoft Foundation Class
Library,&quot; which can be found in the Technical Articles
section of the Microsoft Development Library. For specific
implementation issues, please review the VIEWPROP sample that is
included in the January 1995 Development Library. This sample
demonstrates everything we have talked about, including how to
subclass combo boxes so that you can change their background
color. </font></p>
</font></body>
</html>
