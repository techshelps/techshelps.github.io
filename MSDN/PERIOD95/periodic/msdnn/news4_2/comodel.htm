<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>COM: A Model Problem Solver</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>COM: A Model Problem Solver</b></font></p>
    <p><font size="3"><b>Binary standard lays foundation for
    component software</b></font></p>
    <p><font size="2">Paul Stafford</font><font color="#0000FF"
    size="2"> <br>
    </font><font size="2">Joel Powell</font></p>
    <p><font size="2">March 10, 1995</font></p>
    <p><font size="2">Are you curious about what the Component
    Object Model (COM) is and what it can do for your
    applications? Knowing what types of problems you can address
    and solve using COM is a key part of deciding if it is for
    you. Before discussing that, a brief look at the basics is in
    order.</font></p>
    <p><font size="2">COM is a component software architecture
    that allows binary components supplied by different software
    vendors to interoperate in a reliable, controlled manner. In
    the past, independent software vendors (ISVs) developed
    applications that operated in their own world; those
    applications <i>were</i> their own world. The products that
    emerged resulted in little or no interaction among
    applications. Even when ISVs made a sincere effort to get
    their programs to interact, there was no clear standard and,
    as a result, getting different applications to interact was
    difficult at best.</font></p>
    <p><font size="2">Now, the programming mind-set is changing.
    Terms such as &quot;document-centric&quot; and
    &quot;component software&quot; are taking hold. The shift has
    opened a new world&#151;and challenge&#151;to today's
    programmers. COM helps jump-start this process by defining a
    binary standard that extends component capabilities at the
    system level.</font></p>
    <p><font size="2">But why should developers care about COM?</font></p>
    <p><font size="2">Put simply, COM lays the groundwork on
    which we can build component software.</font></p>
    <p><font size="2">COM represents a binary interface standard
    that allows developers to build specialized software
    components that interface in a common way with other software
    components. OLE is built on the foundation that COM provides.</font></p>
    <p><font size="2">Software vendors don't need to communicate
    with each other to exchange specifications or in any way
    coordinate the design and assembly of their specialized
    software components. They just need to build components that
    adhere to the OLE interface standards.</font></p>
    <p><font size="2">The idea is to enable the software industry
    to achieve greater rates of innovation, more specialized
    customer solutions, higher quality applications, and a
    faster, less expensive development process. (See &quot;The
    benefits of component software&quot; by Gregory Leake, <i>Developer
    Network News</i>,<i> </i>November 1994.)</font></p>
    <p><font size="3"><b>Four problems that COM solves</b></font></p>
    <p><font size="2">Here are four basic problems that arise in
    a component-based system. We'll discuss how COM solves these
    problems:</font></p>
    <blockquote>
        <p><font size="2">&#149; <b>Interoperability:</b> How can
        components supplied by different software vendors
        interoperate safely?</font></p>
        <p><font size="2">&#149; <b>Versioning:</b> How can one
        system component be updated without replacing the other
        components in the system? How does COM let you provide
        new versions of components while maintaining reliable
        backward compatibility?</font></p>
        <p><font size="2">&#149; <b>Language independence:</b>
        How can function calls be made between components written
        in different programming languages?</font></p>
        <p><font size="2">&#149; <b>Transparent remoting:</b> How
        can clients communicate with component objects without
        being concerned whether those components are running in
        the same process, in a different process, or even on
        another computer?</font></p>
    </blockquote>
    <p><font size="3"><b>Basic COM terminology</b></font></p>
    <p><font size="2">Before we look at how COM solves these
    problems, let's define some essential terms.</font></p>
    <p><font size="2"><b>V-table</b></font></p>
    <blockquote>
        <blockquote>
            <p><font size="2">When you have a pointer to a COM
            component, you actually have a pointer to a pointer
            to a virtual function table, or v-table. This v-table
            contains pointers to the functions within the
            component (Figure 1):</font></p>
        </blockquote>
    </blockquote>
    <p><font size="2">-<img src="Image359.gif" width="539"
    height="352"></font></p>
    <p><font size="2"><b>Figure 1. Representation of a v-table in
    a component object</b></font></p>
    <p><font size="2"><b>Interface</b></font></p>
    <blockquote>
        <blockquote>
            <p><font size="2">An interface is a group of
            semantically related functions, or
            &quot;methods.&quot; Taken together, the methods in
            an interface define a logical group of services that
            a component object can provide to the system.</font></p>
        </blockquote>
    </blockquote>
    <p><font size="2">The definition of an interface forms a
    contract between COM components and component users. This
    contract is a definition of expected behavior and
    responsibilities. Interfaces are immutable&#151;methods
    cannot be added to or removed from an interface. Once
    defined, the syntax and semantics of interface methods can
    never change.</font></p>
    <p><font size="2">An interface itself has no implementation;
    therefore, it cannot be instantiated. It is the programmer's
    responsibility to provide an implementation for the
    interface. Different COM components may implement the same
    interface differently; however, the contract states that the <i>behavior</i>
    must be the same.</font></p>
    <p><font size="2">Microsoft already defines many standard
    interfaces. For example, there are general interfaces (such
    as <b>IDataObject</b> and <b>IDropTarget</b>), OLE interfaces
    (such as <b>IOleObject</b> and <b>IOleContainer</b>), and
    many others supporting OLE Automation and OLE Controls. If
    you cannot find an interface that defines the services your
    component wants to provide, you can create your own <i>custom</i>
    interface.</font></p>
    <p><font size="2">Interfaces are strongly typed; each
    interface has its own unique interface ID, or IID. An IID is
    actually a globally unique identifier (GUID). A GUID is a
    unique 128-bit value that allows COM to properly identify a
    specific interface. You can generate your own GUIDs with
    GUIDGEN, a tool provided with Microsoft Visual C++ 2.0.</font></p>
    <p><font size="3"><b>COM components and the component object
    library</b></font></p>
    <p><font size="2">Basically, a COM component consists of
    compiled code that provides services to the system. It
    differs from a C++ object in that its data is always private;
    the only way to access a COM component's data is through one
    of its interfaces.</font></p>
    <p><font size="2">In C++ you instantiate an object by using
    the new operator, which returns a pointer to the C++ object's
    v-table. With COM, you must communicate with the Component
    Object Library to obtain an initial interface pointer on a
    component. This library is provided as part of the operating
    system&#151;to date on Windows, Windows NT, Windows 95, and
    the Macintosh&#151;and contains the basic
    &quot;plumbing&quot; that enables components to find, connect
    to, and communicate with other components in the system.</font></p>
    <p><font size="2">All COM component interfaces must derive
    from a base interface named <b>IUnknown</b>. <b>IUnknown</b>
    has three methods: <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>.
    <b>QueryInterface</b> lets a client obtain a pointer to
    another interface supported by the component (if it exists). <b>AddRef</b>
    and <b>Release</b> are counting methods that allow a
    component to control its own lifetime.</font></p>
    <p><font size="2">COM components are housed in either a
    dynamic-link library (DLL) or an EXE; this housing is the
    component <i>server</i>. DLL component servers are labeled <i>in-process
    servers</i> or <i>in-proc servers</i>. EXE component servers
    are labeled <i>local servers</i> if the component is running
    in a different process but on the same computer. EXE
    component servers are labeled <i>remote servers</i> if they
    are running on a different computer.</font></p>
    <p><font size="2">COM components are often referred to as
    &quot;Windows objects,&quot; &quot;component objects,&quot;
    or &quot;components.&quot; All these terms mean the same
    thing. Using such terms separates them from C++ objects,
    which, hopefully, reduces confusion between the two. We'll
    use the term &quot;client&quot; to refer to any piece of code
    that calls a component's interface methods.</font></p>
    <p><font size="2">Armed with these terms and a brief
    definition of a COM component, let's look at the solutions
    COM provides for the four problems we outlined earlier.</font></p>
    <p><font size="3"><b>Solving the problem of interoperability:
    The binary standard</b></font></p>
    <p><font size="2">A client obtains the services of a COM
    component by calling interface methods provided by the
    component. When one component makes a call to another, an
    important question arises: How can such a call be made safely
    when the other component may have been written at a different
    time, by developers in a different software company, and in a
    different programming language?</font></p>
    <p><font size="2">COM enables calls to be made between
    components by specifying a <i>binary standard</i> for such
    calls. The standard specifies how a component constructs the
    v-tables for its interfaces, and how the client calls
    interface functions indirectly, through the v-tables. COM's
    binary standard allows clients to safely call a component's
    interface methods, without concern for the component's
    implementation language.</font></p>
    <p><font size="3"><b>Interface &quot;contracts&quot;</b></font></p>
    <p><font size="2">Once the client is successfully making
    calls to the component server, it needs to know exactly what
    services it will receive. COM interfaces specify the
    semantics of interactions between components.</font></p>
    <p><font size="2">The specification of a COM interface serves
    as a contract between the client calling the interface's
    methods and the component providing an implementation of the
    interface. This contract specifies the services that the
    client can expect to receive from that component. The
    contract is good for all time, because COM interfaces are
    immutable. Once an interface is defined, the semantics and
    syntax of its methods can never change.</font></p>
    <p><font size="3"><b>Encapsulation</b></font></p>
    <p><font size="2">For a component object system to be robust,
    components must always be able to protect themselves from
    direct access by other components. The use of interfaces
    allows COM to ensure complete encapsulation of a component's
    internal data and processing.</font></p>
    <p><font size="2">Clients never have direct access to a
    component's internals. Instead, clients have interface
    pointers on the component, and obtain all services by calling
    interface methods indirectly through that pointer. The
    interface pointer is opaque; all implementation details and
    internal data are hidden from the caller.</font></p>
    <p><font size="3"><b>The Component Object Library</b></font></p>
    <p><font size="2">The Component Object Model is a
    specification, but it also has an implementation&#151;the
    Component Object Library.</font></p>
    <p><font size="2">A client wanting to use the services
    provided by some particular component object class starts by
    calling the Component Object Library, asking for an interface
    pointer on a component of that class. The Component Object
    Library then does the &quot;legwork&quot; necessary to hook
    up the client and component. First it finds and runs the
    server executable (DLL or EXE) associated with the component
    class and asks the server to create an instance of the
    component. It then obtains an interface pointer on the
    component, and finally returns that pointer to the client.</font></p>
    <p><font size="2">The client can now make calls to the
    component through the interface pointer. It can also obtain
    additional services from the component by obtaining
    additional interface pointers (via <b>IUnknown::QueryInterface</b>).</font></p>
    <p><font size="3"><b>Versioning and backward compatibility</b></font></p>
    <p><font size="2">COM provides a versioning mechanism that
    allows seamless evolution of components. When one system
    component is updated, it is not necessary to replace the
    other components in the system. Existing clients of the
    component do not need to be recompiled, rebuilt, or even
    notified. The new version of a component can easily maintain
    backward compatibility with old clients, while at the same
    time adding new features to be used by new clients.</font></p>
    <p><font size="2">The first key to versioning in COM is that
    interfaces are immutable. Because it is not possible to add
    new functionality to an old interface, the only way that a
    component can add new features is to expose those features
    via a new interface. This interface is not a new version of
    the old interface&#151;interfaces are never versioned.
    Instead, it is a completely new interface, with its own
    unique IID.</font></p>
    <p><font size="2">The second key is <b>IUnknown::QueryInterface</b>.
    This call allows clients to determine the capabilities of a
    component at run time. Clients that want to use the new
    features will simply use <b>QueryInterface</b> for the new
    interface.</font></p>
    <p><font size="2">Maintaining backward compatibility with old
    clients is simple&#151;just continue to support the old
    interface. Because interfaces are immutable, existing client
    code is not broken.</font></p>
    <p><font size="2">Note that as long as the syntax and
    semantics of the interface methods are preserved, the methods
    can be reimplemented internally&#151;for example, to improve
    performance. Existing clients will call the methods just as
    they always have, and benefit from the increased performance
    &quot;for free.&quot;</font></p>
    <p><font size="3"><b>language independence</b></font></p>
    <p><font size="2">COM is language independent. By specifying
    a binary object standard (as opposed to a source code
    standard, such as C++), COM enables calls to be made between
    components written in different programming languages (C,
    C++, Small Talk, and so on).</font></p>
    <p><font size="2">Components can be implemented in any
    language that supports the creation of v-tables. They can be
    called from any language that supports indirect calls through
    function pointers. Typically, the various components in the
    system have been written in many different languages.</font></p>
    <p><font size="3"><b>Transparent cross-process
    interoperability</b></font></p>
    <p><font size="2">As described earlier, COM component servers
    can be implemented in three flavors: in-process, local, and
    remote. Fortunately, clients do not need to know (or care)
    which kind of server they are calling. COM provides
    &quot;transparent cross-process interoperability.&quot; This
    means that clients use the same simple programming model when
    calling any component. The Component Object Library insulates
    the client from the specifics of where the component is
    actually running.</font></p>
    <p><font size="2">The three possible scenarios are shown in
    Figure 2. Calls to in-proc components are simply direct calls
    to the component. Overhead is minimal, allowing in-proc
    components to provide the best performance.</font></p>
    <p><font size="2"><img src="Image360.gif" width="572"
    height="728"></font></p>
    <p><font size="2"><b>Figure 2. In-process, local, and remote
    server interoperability</b></font></p>
    <p><font size="2">Local components cannot be called directly,
    because they are running in a different process space than
    the client. Calls to local components are intercepted by a
    &quot;proxy&quot; object provided by the Component Object
    Library. The proxy generates a call through the LRPC
    (lightweight remote procedure call) channel to a
    &quot;stub&quot; object (also provided by the Component
    Object Library) that runs in the process space of the local
    component. The stub object then completes the procedure by
    making an in-proc call to the local component.</font></p>
    <p><font size="2">The key point is that any differences
    between the in-process and cross-process cases are
    transparent to both clients and components. Clients always
    make calls through an in-process pointer, and components are
    always called via some in-process pointer. Any extra work
    needed when making calls across process boundaries is handled
    &quot;magically&quot; by the Component Object Library.</font></p>
    <p><font size="2">In 1996, Microsoft plans to release a
    version of the Component Object Library that will extend
    transparent remoting to include calls between two machines on
    a network. Existing components will not need to be rebuilt
    then; components that can make cross-process calls today will
    gain the ability to make cross-network calls &quot;for
    free.&quot;</font></p>
    <p><font size="3"><b>Getting started</b></font></p>
    <p><font size="2">A host of information is at your disposal.
    To name just a few sources: <i>Inside OLE 2</i> by Kraig
    Brockschmidt (available in the Developer Network Development
    Library) and the <i>OLE Programmer's Reference Volume 1 </i>and<i>
    Volume 2</i> provide a good head start; they are all
    available from Microsoft Press. Also, check out the full COM
    specification provided in both the Development Library and
    with the Visual C++ 2.0 CD. If you have any problems,
    concerns, or ideas, feel free to contact Microsoft on
    CompuServe (GO WINOBJ).</font></p>
    <p><font size="2"><i>Joel Powell is a support engineer
    specializing in COM and OLE. He is also a published author of
    books ranging from Win32 programming to computer gaming.</i></font></p>
    <p><font size="2"><i>Paul Stafford is an engineer in the
    Windows Developer Support Group, specializing in all things
    OLE. Joel's books occupy the place of honor on Paul's
    bookshelf, right next to the </i>OLE Programmer's Reference<i>.</i></font></p>
</blockquote>
</font></body>
</html>
