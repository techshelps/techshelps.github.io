<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic: Tips and Tradeoffs in Data Access Performance </title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Visual Basic: Tips and Tradeoffs in Data
    Access Performance </b></font></p>
    <p><font size="2">Robert Eineigl</font></p>
    <p><font size="2">March 10, 1995</font></p>
    <p><font size="2">When Visual Basic version 3.0 arrived, with
    its rich set of data access capabilities, the increased power
    and flexibility also provided, in terms of performance, more
    rope to hang yourself with (pun intended!). When Visual Basic
    3.0 became the predominant platform for building clients for
    mission-critical, vertical data access systems, many
    programmers experienced the joys of system analysis and
    database management for the first time.</font></p>
    <p><font size="2">As easy access to information becomes more
    essential to remaining competitive, it also escalates
    expectations and makes system users increasingly impatient
    with unresponsive client applications.</font></p>
    <p><font size="2">This article surveys the many choices
    available to the programmer writing data-centric applications
    in Visual Basic, and offers recommendations aimed at
    maximizing the perceived responsiveness and performance of
    data access client applications.</font></p>
    <p><font size="3"><b>The choices</b></font></p>
    <p><font size="2">From a design perspective, the programmer
    of a data access client application faces four major choices
    affecting performance:</font></p>
    <blockquote>
        <p><font size="2">&#149; Which back-end relational
        database to use.</font></p>
        <p><font size="2">&#149; Which data access method to
        employ&#151;whether to use the Visual Basic data access
        object (DAO) layer, open database connectivity (ODBC), or
        a proprietary back-end interface or interfaces.</font></p>
        <p><font size="2">&#149; Which back-end database system
        design data model to use, with its associated triggers
        and procedures.</font></p>
        <p><font size="2">&#149; If using the DAO layer, making
        the correct choice of data access objects, and where to
        use transactions, attached tables, and the pass-through
        flag.</font></p>
    </blockquote>
    <p><font size="2">By using speed and efficiency as the
    scalpel, the endless feature requests for the system can be
    pared down to a finite, implementable list. Keeping
    performance implications at the forefront of the design
    process helps narrow choices and develop an architecture that
    is both scalable and responsive. Performance considerations
    should be second in priority only to the critical analysis
    needed to define clearly the rules of the business that the
    system must satisfy.</font></p>
    <p><font size="3"><b>First choice: Which RDBMS?</b></font></p>
    <p><font size="2">The choice of a relational database
    management system (RDBMS) depends on both present and future
    business needs, as well as resources available. This decision
    is logically the starting point for the system design,
    because all the decisions pertaining to performance depend on
    the capabilities and limitations of the back end.</font></p>
    <p><font size="2">Several questions need to be considered:</font></p>
    <blockquote>
        <p><font size="2">&#149; How many users will the system
        serve, now and in the next two years?</font></p>
        <p><font size="2">&#149; Does data need to be distributed
        to more than one site?</font></p>
        <p><font size="2">&#149; How often can the system
        requirements be expected to change? How quickly will
        those changes need to be made?</font></p>
        <p><font size="2">&#149; What level of expertise is
        reasonable to expect from users?</font></p>
        <p><font size="2">&#149; What resources are available to
        purchase hardware, software, and development/training
        time?</font></p>
    </blockquote>
    <p><font size="2">A comprehensive discussion of the tradeoffs
    involved with this first area of choice is beyond the scope
    of this article. However, let me propose a simple scenario
    for the purposes of illustration. Let's assume these answers
    to our checklist of questions:</font></p>
    <blockquote>
        <p><font size="2">&#149; 70 users now, increasing to as
        many as 150 users in two years.</font></p>
        <p><font size="2">&#149; Yes, there's a need for
        distributed data.</font></p>
        <p><font size="2">&#149; The system will need revision
        every six months.</font></p>
        <p><font size="2">&#149; All users are novices to
        database concepts.</font></p>
        <p><font size="2">&#149; Money is available for a
        dedicated server box, a site license for SQL Server for
        Windows NT, and sufficient development time if Visual
        Basic is used as the front-end development tool.</font></p>
    </blockquote>
    <p><font size="2">The answers here favor a true client-server
    RDBMS, especially because of the large number of users
    anticipated and the need for administrative tools for data
    replication. A dedicated server is essential to multiuser
    systems with more than 50 users. Client-side database
    engines, such as Microsoft Access, also require that all
    clients voluntarily close their connections to the .MDB file
    before the database can be copied, compacted, and so on.</font></p>
    <p><font size="2">The need for frequent or fast system
    revisions also favors a dedicated back-end approach, with the
    rules of the business stored in the back end. Making system
    changes is easier to accomplish and synchronize from one
    central location.</font></p>
    <p><font size="3"><b>Second choice: Which data access method?</b></font></p>
    <p><font size="2">With Visual Basic as the front-end
    development platform, there are several methods of data
    access:</font></p>
    <blockquote>
        <p><font size="2">&#149; Write code that leverages the
        built-in DAO layer, directly to Microsoft Access, FoxPro,
        dBASE, Btrieve, and Paradox databases or through the DAO
        to ODBC databases.</font></p>
        <p><font size="2">&#149; Code directly to the ODBC API,
        bypassing the DAO, starting with sample code from the
        ODBC SDK.</font></p>
        <p><font size="2">&#149; Code directly to a
        back-end-specific protocol, such as the VBSQL library for
        SQL Server or a gateway to a mainframe database.</font></p>
    </blockquote>
    <p><font size="3"><b>When to use the DAO layer</b></font></p>
    <p><font size="2">The Visual Basic DAO layer was designed to
    provide a generic set of data-aware objects and functions for
    use as a built-in library. This design insulates the
    programmer from the proprietary details of the back end. In
    the case of ODBC databases, the DAO layer provides the
    interface to the ODBC API. If the databases are local or
    client-based, such as Microsoft Access or FoxPro, the DAO
    layer provides a single interface, via the Microsoft Access
    engine, to the divergent database formats. The generic DAO
    layer in Visual Basic provides the leverage of a built-in
    data-aware library. Its disadvantage is that you can't modify
    or extend that library's functionality.</font></p>
    <p><font size="2">(Because using database objects raises some
    complicated issues, I will discuss how to use the DAO layer
    efficiently in the May/June 1995 issue of the<i> Developer
    Network News</i>.)</font></p>
    <p><font size="3"><b>Go directly to the ODBC layer...</b></font></p>
    <p><font size="2">If the system must access heterogeneous
    data sources and be scalable enough to add new data sources
    as needed, the advantages of the ODBC approach should be
    apparent.</font></p>
    <p><font size="2">If the choice is made to code directly to
    the ODBC API, the development process can be similar to using
    the DAO layer, once the investment in creating a generic data
    access library or engine is made. The leverage begins once
    this ODBC interface library is written, because the Visual
    Basic code can be generic and insulated from the proprietary
    details&#151;in the same way as code written to the DAO. And
    as with the code written to the DAO, the Visual Basic code
    written to the homegrown ODBC library is reusable as target
    back-end databases change.</font></p>
    <p><font size="2">Because Visual Basic and Microsoft Access
    were the first high-volume applications to exploit the ODBC
    standard, the general first impression of the ODBC mechanism
    was that it was much slower than the proprietary access
    protocols. In reality most performance decreases could be
    traced to one particular ODBC interface: the Microsoft Access
    engine.</font></p>
    <p><font size="2">This engine was designed for high
    generality and to provide a generic library of data access
    functions to make Visual Basic code written to the DAO
    independent of the data source. To achieve this, some
    flexibility and optimization for specific functions were
    sacrificed.</font></p>
    <p><font size="2">In bench tests against Microsoft SQL
    Server, comparing direct ODBC calls to VBSQL(DBLIB) calls,
    the average performance numbers were comparable, with some
    ODBC functions being faster than some DBLIB calls and vice
    versa. Getting a connection through the ODBC API, for
    example, took longer than through VBSQL calls, though not by
    an order of magnitude.</font></p>
    <p><font size="3"><b>...or to a proprietary protocol</b></font></p>
    <p><font size="2">For application architectures where
    connections are created, used, and then immediately broken,
    the bench test results would seem to favor the proprietary
    protocol. Bear in mind, however, that this architecture arose
    from the need to &quot;go easy&quot; on older operating
    systems and networks, and may be less imperative with the
    latest operating systems/networks.</font></p>
    <p><font size="2">If the set of data sources is limited for
    the foreseeable future, having several proprietary libraries
    coexist in the front end may be the best solution. This
    leverages existing expertise and investments to get a
    production system up as soon as possible. In this case,
    maintaining the performance level of existing legacy systems
    in any new system is the appropriate choice.</font></p>
    <p><font size="3"><b>Third choice: Which database design?</b></font></p>
    <p><font size="2">The actual design of the
    database&#151;including normalization of tables, architecture
    of stored procedures, security, and data integrity&#151;is a
    major area for performance considerations. Designing database
    systems for optimal performance is a broad topic; here we
    consider only questions directly affecting Visual Basic
    developers.</font></p>
    <p><font size="2">Assuming that we are discussing systems
    using client-server databases, the first architectural
    decision is how much processing logic should reside in the
    Visual Basic application, in the back-end, or in intermediary
    layers. For example, should the front end perform all data
    validation, none, or a mixture of front- and back-end logic
    based on performance considerations?</font></p>
    <p><font size="2">Other architectural decisions: Should the
    client handle security separately from the database's
    intrinsic security model or leave it entirely to the
    back-end's security model? Should the user's preferences be
    stored locally in an .INI file or on the back end in a user
    preferences table?</font></p>
    <p><font size="2">The answers to such questions have
    performance implications, as do the more back-end-centric
    issues of data modeling, enforcing business rules, or
    optimizing transaction throughput. These design decisions can
    only be made in the precise context of the particular
    project. Generally, programmers can increase the overall
    client performance by letting the client and server each do
    what it can do fastest, provided that doing so doesn't
    violate any architectural specifications for the system.</font></p>
    <p><font size="3"><b>Next issue</b></font></p>
    <p><font size="2">Keeping the performance tradeoffs in mind
    during design of Visual Basic data access systems can reap
    large performance gains. In the next Visual Basic column,
    I'll discuss which DAO object is appropriate for which task,
    where to use transactions, when to use the pass-through flag,
    and when to use attached tables.</font></p>
    <p><font size="2"><i>Robert Eineigl works in Microsoft's
    Information Technology Group, building database systems
    coupled to clients written in Visual Basic. He also disturbs
    wildlife by playing his custom-made, oversized trumpet.</i></font></p>
    <p><font size="5"><b>Additional Reading</b></font></p>
    <p><font size="2">Note: All of these articles are in the
    Developer Network Development Library.</font></p>
    <p><font size="2">&quot;Summary article: INF: Article List
    for Visual Basic: Data Access w/ MS Access/Jet&quot; ID:
    Q122723</font></p>
    <p><font size="2">&quot;LONG: Overview of Data Access in
    Visual Basic Version 3.0&quot; ID: Q108379</font></p>
    <p><font size="2">&quot;Using Table Objects Versus
    Dynaset/Snapshot Objects in Visual Basic&quot; ID: Q109218</font></p>
    <p><font size="2">&quot;INF: Database Normalization
    Basics&quot; ID: Q100139</font></p>
    <p><font size="2">&quot;Differences Between the Object
    Variables in Visual Basic Version 3.0&quot; ID: Q103442</font></p>
    <p><font size="2">&quot;Differences Among the Installable
    ISAMs&quot; ID: Q104918</font></p>
    <p><font size="2">&quot;Comparison of Seek Versus Find
    Methods, for Visual Basic Data Access&quot; ID: Q108149</font></p>
    <p><font size="2">&quot;How to Speed Up Data Access by Using
    BeginTrans &amp; CommitTrans&quot; ID: Q109830</font></p>
    <p><font size="2">&quot;How to Optimize Memory Management in
    Visual Basic 3.0 for Windows&quot; ID: Q112860</font></p>
    <p><font size="2">&quot;How to Access Multiple Databases in
    an SQL Query&quot; ID: Q113701</font></p>
    <p><font size="2">&quot;PRB: ODBC Error &#145;Connection is
    busy with results...'&quot; ID: Q119023</font></p>
    <p><font size="2">&quot;LONG: Visual Basic 3.0 EXTERNAL.TXT:
    Using External Database Tables&quot; ID: Q108422</font></p>
    <p><font size="2">&quot;LONG: PERFORM.TXT&#151;Performance
    Tuning Tips for Visual Basic and MS Access&quot; ID: Q107751</font></p>
    <p><font size="2">&quot;INF: Five Parameters to Set in ISAM
    Section of MSACCESS.INI&quot; ID: Q101323</font></p>
</blockquote>
</font></body>
</html>
