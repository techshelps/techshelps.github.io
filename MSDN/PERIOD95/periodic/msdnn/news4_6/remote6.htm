<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template"
content="C:\MSOFFICE\WINWORD\TEMPLATE\msin60b.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Use Visual Basic 4.0 to Distribute the Load with Remote Automation</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Use Visual Basic 4.0 to Distribute the
    Load with Remote Automation</b></font></p>
    <p><font size="3"><b>Visual Basic 4.0 and OLE 2.0 now provide
    the tools to build distributed solutions</b></font></p>
    <p><font size="2">Robert Eineigl and Randy Morgan</font></p>
    <p><font size="2">November 1, 1995</font></p>
    <p><font size="2">Previously in <i>Developer Network News</i>,
    we gave a taste of the increased power of Visual Basic 4.0.
    Specifically, we covered the new features in Visual Basic 4.0
    and built a simple remote automation server. (See
    &quot;Visual Basic 4.0 Goes Live: 16-Bit/32-Bit Rapid
    Application Development,&quot; <i>Developer Network News</i>,
    Sept/Oct 1995.)</font></p>
    <p><font size="2">In this article, we'll go into greater
    depth by building a skeletal distributed processing system
    that allows clients to pass processing tasks to remote nodes
    branched off a central pool manager. This architecture
    extends the application server model to allow clients located
    anywhere on the network to call OLE servers by means of a
    central pool manager.</font></p>
    <p><font size="2"><img src="Image383.gif" width="387"
    height="239"></font></p>
    <p><font size="2"><b>Three-tiered distributed client/server
    architecture</b></font></p>
    <p><font size="2">The promise of distributed processing has
    tantalized developers since the proliferation of networked
    personal computers began. A system where components of a
    business system do not reside either exclusively on a central
    big-iron computer or on every user's computer, but instead
    are managed from nodes throughout the network, carries many
    advantages. These include better disk space utilization, ease
    of maintenance, increased processing power, granular
    management of business policies, and the ability to balance
    processing loads. </font></p>
    <p><font size="2">But until now, developers interested in
    distributed solutions either had to write their own
    customized solutions&#151;reinventing the wheel many times
    over&#151;or were forced to wait for operating systems to
    evolve to the point of providing the enabling infrastructure
    to allow more general, portable solutions.</font></p>
    <p><font size="2">Visual Basic 4.0 and OLE 2.0 now provide
    the tools to build distributed solutions for Windows-based
    platforms. Additionally, because OLE 2.0 serves as the
    technology springboard for Microsoft's future Windows NT
    distributed operating system (code-named &quot;Cairo&quot;),
    the solutions developed today should migrate smoothly to
    Cairo.</font></p>
    <p><font size="3"><b>Distributed architecture</b></font></p>
    <p><font size="2">Once the dependency on a central mainframe
    or on single-tier client/server architecture is removed, the
    possible topologies for distributed systems are practically
    infinite.</font></p>
    <p><font size="2">In our example, we chose a three-tier
    topology where the clients, connecting through a central
    server, obtain services from satellite servers called from
    the central server. We created a simplified pool manager that
    runs on the central server, accepts requests from clients for
    object handles, and, in turn, requests object handles from a
    third-tier satellite or local object manager.</font></p>
    <p><font size="3"><b>The system design</b></font></p>
    <p><font size="2">In our example, we built three main pieces
    to provide the basic structure and an additional OLE server
    to perform the distributed processing task. The three main
    pieces are the client, a central pool manager (<b>ObjectPoolMgr</b>),
    and the satellite (or local) object manager (<b>CreateObjectLocalMgr</b>).
    The satellite object manager is configured to launch a
    specified number of objects when it first runs, thereby
    taking the overhead hit up front and removing a later
    bottleneck to system response. This pool of objects is
    managed locally, so the central pool manager is unaware of
    those details. At the client's request, the satellite object
    manager instantiates either a Visual Basic 4.0 OLE server
    object or a Microsoft Excel workbook object locally to
    perform the processing.</font></p>
    <p><font size="2">The sequence of events is as follows: The
    client requests a service from the central pool manager. The
    central pool manager then requests an object managed by the
    satellite object manager. The satellite object manager passes
    the object handle back to the client, transparently by means
    of the central pool manager, and the client calls a method of
    the object to perform the processing. At the conclusion of
    the processing, the client frees the object handle for reuse
    by another client.</font></p>
    <p><font size="3"><b>The example</b></font></p>
    <p><font size="2">Due to the limited scope of this column, we
    opted to write a streamlined, simplified central pool manager
    and satellite object manager, along with an elementary
    client. The client asks for a loan payment calculation&#151;a
    simple calculation that doesn't require farming out to
    another processor but is included as a placeholder for
    testing a more extensive algorithm. </font></p>
    <p><font size="2">We concentrated on providing a
    comprehensible example of the essential mechanics that you
    can build upon to create a more realistic and useful system.
    The full code for this three-tier system exceeds our space
    limitations in this column, but can be found by going to the
    online version of this article at
    http://www.microsoft.com/devnews and downloading the sample
    code file.</font></p>
    <p><font size="3"><b>The client</b></font></p>
    <p><font size="2">Since OLE handles the thunking between
    16-bit and 32-bit clients and servers, the client application
    could be either 16-bit or 32-bit. The servers created with
    Visual Basic 4.0 can be only 32-bit. Windows 95 and Windows
    NT can each be either clients or servers. The remote
    automation code in the client gets a handle to the central
    pool manager, which provides class functions to pass handles
    to satellite object servers back to the client for use.</font></p>
    <p><font size="2" face="Courier New">Dim objExcel As Object,
    objFinCalc As Object,</font></p>
    <p><font size="2" face="Courier New">objFinCalcDLL As </font></p>
    <p><font size="2" face="Courier New">Object, objCreateMgr As
    Object</font></p>
    <p><font size="2" face="Courier New">Dim cResults As
    Currency, nRet As Long</font></p>
    <p><font size="2" face="Courier New">Set objCreateMgr = _ </font></p>
    <p><font size="2" face="Courier New">CreateObject(&quot;ObjectPoolMgr.ObjectMgr&quot;)</font></p>
    <p><font size="2" face="Courier New">objCreateMgr.SetObjectLocalMgr</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">' For illustrative
    purposes only.</font></p>
    <p><font size="2" face="Courier New">' If Excel is not
    installed on satellite </font></p>
    <p><font size="2" face="Courier New">' computer, comment out
    following lines.</font></p>
    <p><font size="2" face="Courier New">nRet =
    objCreateMgr.GetPoolObject _</font></p>
    <p><font size="2" face="Courier New">(objExcel,
    &quot;Excel&quot;)</font></p>
    <p><font size="2" face="Courier New">' Place code to call
    native Excel function</font></p>
    <p><font size="2" face="Courier New">' or load a workbook and
    call a custom macro.</font></p>
    <p><font size="2" face="Courier New">If nRet = True Then</font></p>
    <p><font size="2" face="Courier New">' Finished with objExcel
    object; call </font></p>
    <p><font size="2" face="Courier New">' function in
    ObjectPoolMgr to release it.</font></p>
    <p><font size="2" face="Courier New">objCreateMgr.ReleasePoolObject
    &quot;Excel&quot;</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">nRet =
    objCreateMgr.GetPoolObject _</font></p>
    <p><font size="2" face="Courier New">(objFinCalc,
    &quot;FinCalc&quot;)</font></p>
    <p><font size="2" face="Courier New">If nRet = True Then</font></p>
    <p><font size="2" face="Courier New">' Call method in FinCalc
    object.</font></p>
    <p><font size="2" face="Courier New">cResults =
    objFinCalc.Payment _</font></p>
    <p><font size="2" face="Courier New">(Text1.Text, Text2.Text,
    Text3.Text, _</font></p>
    <p><font size="2" face="Courier New">Text4.Text, Text5.Text)</font></p>
    <p><font size="2" face="Courier New">' Display results.</font></p>
    <p><font size="2" face="Courier New">Text6 = CStr(cResults)</font></p>
    <p><font size="2" face="Courier New">' Finished with FinCalc
    object; call</font></p>
    <p><font size="2" face="Courier New">' function in
    ObjectPoolMgr to release it.</font></p>
    <p><font size="2" face="Courier New">objCreateMgr.ReleasePoolObject
    &quot;FinCalc&quot;</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">' Call same function in
    an in-process DLL on</font></p>
    <p><font size="2" face="Courier New">' central pool manager
    computer.</font></p>
    <p><font size="2" face="Courier New">' DLL is loaded on
    demand (created multi-use)</font></p>
    <p><font size="2" face="Courier New">' and unloaded when pool
    manager closes.</font></p>
    <p><font size="2" face="Courier New">nRet =
    objCreateMgr.GetPoolObject _</font></p>
    <p><font size="2" face="Courier New">(objFinCalcDLL,
    &quot;FinCalcDLL&quot;)</font></p>
    <p><font size="2" face="Courier New">If nRet = True Then</font></p>
    <p><font size="2" face="Courier New">' Call method in
    FinCalcDLL DLL.</font></p>
    <p><font size="2" face="Courier New">cResults =
    objFinCalcDLL.Payment _</font></p>
    <p><font size="2" face="Courier New">(Text1.Text, Text2.Text,
    Text3.Text, _</font></p>
    <p><font size="2" face="Courier New">Text4.Text, Text5.Text)</font></p>
    <p><font size="2" face="Courier New">Text7 = CStr(cResults)</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2">Note that the function used to instantiate
    the remote objects is <b>CreateObject</b>, not <b>GetObject</b>.
    This is because of a limitation in Visual Basic 4.0, which is
    documented in the Help file (a note in the <b>GetObject</b>
    description states that you can't use <b>GetObject</b> to
    obtain a reference to a class created with Visual Basic). To
    make the code consistent, we used <b>CreateObject</b>
    throughout the example.</font></p>
    <p><font size="3"><b>The central pool manager</b></font></p>
    <p><font size="2">The remote automation code in the pool
    manager (<b>ObjectPoolMgr</b>) is contained in three class
    functions: <b>SetObjectLocalMgr</b>, <b>GetPoolObject</b>,
    and <b>ReleasePoolObject</b>. The first function instantiates
    a specific satellite object manager called <b>CreateObjectLocalMgr</b>.</font></p>
    <p><font size="2">To increase the number of satellite servers
    in the third tier, you would have to make the class names
    (Visual Basic 4.0 project names) unique, perhaps by adopting
    a numeric scheme, for example, <b>CreateObjectLocalMgr1</b>, <b>CreateObjectLocalMgr2</b>,
    and so on.</font></p>
    <p><font size="2">The implementation of an algorithm to
    balance the load by time of day or demand is an exercise left
    to the reader. Visual Basic 4.0 comes with an extensive
    sample pool manager, located under
    \VB\SAMPLES\REMAUTO\POOLMNGR, that points the way. (This
    sample is also included in the October 1995 edition of the
    Microsoft Development Library, under Sample Code, Product
    Samples.)</font></p>
    <p><font size="2">Back to our simpler example. The following
    code obtains the handle to one specific instance of a
    satellite:</font></p>
    <p><font size="2" face="Courier New">Public Sub
    SetObjectLocalMgr()</font></p>
    <p><font size="2" face="Courier New">' Get handle to
    satellite object manager.</font></p>
    <p><font size="2" face="Courier New">Set objCreateLocalMgr =
    CreateObject _</font></p>
    <p><font size="2" face="Courier New">(&quot;CreateObjectLocalMgr.CreateObjectMgr&quot;)</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2"><b>GetPoolObject</b> and <b>ReleasePoolObject</b>
    call functions in the satellite object manager to obtain the
    object handles that belong to objects local to the satellite
    object manager. It is important to realize that the central
    pool manager has no need to know which objects are being
    handed back to the client, or even their locations. The
    Remote Automation Connection Manager (RACMan) does need to
    know network addresses when setting up the system, but the
    code does not care.</font></p>
    <p><font size="2" face="Courier New">Public Function
    GetPoolObject(ObjPoolObject As </font></p>
    <p><font size="2" face="Courier New">Object, sObjectRequested
    As String)</font></p>
    <p><font size="2" face="Courier New">Dim nRet As Integer</font></p>
    <p><font size="2" face="Courier New">nRet = False</font></p>
    <p><font size="2" face="Courier New">' Call class functions
    in the satellite</font></p>
    <p><font size="2" face="Courier New">' object manager,
    CreateObjectLocalMgr.</font></p>
    <p><font size="2" face="Courier New">Select Case
    sObjectRequested</font></p>
    <p><font size="2" face="Courier New">Case &quot;Excel&quot;</font></p>
    <p><font size="2" face="Courier New">If
    objCreateLocalMgr.ExcelObjectAvailable _</font></p>
    <p><font size="2" face="Courier New">= True Then</font></p>
    <p><font size="2" face="Courier New">Set ObjPoolObject = _</font></p>
    <p><font size="2" face="Courier New">objCreateLocalMgr.GetExcelObjectHandle</font></p>
    <p><font size="2" face="Courier New">nRet = True</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">Case &quot;FinCalc&quot;</font></p>
    <p><font size="2" face="Courier New">If
    objCreateLocalMgr.FinCalcObjectAvailable _</font></p>
    <p><font size="2" face="Courier New">= True Then</font></p>
    <p><font size="2" face="Courier New">Set ObjPoolObject = _</font></p>
    <p><font size="2" face="Courier New">objCreateLocalMgr.GetFinCalcObjectHandle</font></p>
    <p><font size="2" face="Courier New">nRet = True</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">Case
    &quot;FinCalcDLL&quot;</font></p>
    <p><font size="2" face="Courier New">' Call local, in-process
    DLL, registered</font></p>
    <p><font size="2" face="Courier New">' via REGSVR32.exe.</font></p>
    <p><font size="2" face="Courier New">Set ObjPoolObject = _</font></p>
    <p><font size="2" face="Courier New">CreateObject(&quot;FinancialCalcDLL.FinCalcDLL&quot;)</font></p>
    <p><font size="2" face="Courier New">nRet = True</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">GetPoolObject = nRet</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">Public Sub
    ReleasePoolObject(sObjectRelease </font></p>
    <p><font size="2" face="Courier New">As String)</font></p>
    <p><font size="2" face="Courier New">Select Case
    sObjectRelease</font></p>
    <p><font size="2" face="Courier New">' Calls functions in
    CreateObjectLocalMgr.</font></p>
    <p><font size="2" face="Courier New">Case &quot;Excel&quot;</font></p>
    <p><font size="2" face="Courier New">objCreateLocalMgr.FreeExcelObjectHandle</font></p>
    <p><font size="2" face="Courier New">Case &quot;FinCalc&quot;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">objCreateLocalMgr.FreeFinCalcObjectHandle</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="3"><b>The in-process DLL</b></font></p>
    <p><font size="2">To show the use of an in-process
    dynamic-link library (DLL), we chose to hang an OLE DLL
    directly off the central pool manager (<b>ObjectPoolMgr</b>).
    This DLL duplicates the loan processing code in the Visual
    Basic OLE server executable (the cross-process server)
    running on the third-tier computer. This exemplifies that the
    pool manager could choose to utilize its own processing time,
    if a load balancing algorithm finds spare cycles on the
    central pool manager computer. The DLL also allows us to
    compare in-process vs. out-of-process servers, and
    second-tier vs. third-tier performance.</font></p>
    <p><font size="3"><b>The satellite object manager</b></font></p>
    <p><font size="2">In the third tier, we have the satellite
    object manager and the actual processing servers. The
    satellite object manager, <b>CreateObjectLocalMgr</b>,
    contains six class functions&#151;that is, three functions
    for each of the two OLE objects: the Visual Basic 4.0 server
    (FinancialCalc.exe) and the Microsoft Excel 5.0 (or higher)
    executable, which can be accessed as an OLE server via OLE
    Automation calls. Two functions simply manage the array of
    object handles:</font></p>
    <p><font size="2" face="Courier New">Public Function
    FinCalcObjectAvailable()</font></p>
    <p><font size="2" face="Courier New">Public Sub
    FreeFinCalcObjectHandle()</font></p>
    <p><font size="2">The third function actually instantiates
    the objects, based on the array limits. The form load event
    for <b>CreateObjectLocalMgr</b> sets up a default pool size
    of one, for both the Microsoft Excel and Visual Basic 4.0 OLE
    server objects, and allows manual resetting of the pool size.</font></p>
    <p><font size="2" face="Courier New">Public Function
    GetFinCalcObjectHandle() As </font></p>
    <p><font size="2" face="Courier New">Object</font></p>
    <p><font size="2" face="Courier New">'Checks to see if there
    are FinCalc Objects </font></p>
    <p><font size="2" face="Courier New">'left.</font></p>
    <p><font size="2" face="Courier New">If nFinCalcObjCount &lt;
    UBound(objFinCalc)</font></p>
    <p><font size="2" face="Courier New">Then </font></p>
    <p><font size="2" face="Courier New">Set
    GetFinCalcObjectHandle = _</font></p>
    <p><font size="2" face="Courier New">objFinCalc(nFinCalcObjCount)</font></p>
    <p><font size="2" face="Courier New">nFinCalcObjCount =
    nFinCalcObjCount + 1</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="3"><b>The Visual Basic OLE server</b></font></p>
    <p><font size="2">The object of this exercise (pun intended)
    is to pass the handle of an OLE server that actually performs
    the distributed processing back to the client. Our object of
    desire is a bare-bones OLE server created by Visual Basic 4.0
    (FinancialCalc), which has one class function, <b>Payment</b>,
    as a wrapper around the intrinsic function <b>Pmt</b>. The
    function header looks like this:</font></p>
    <p><font size="2" face="Courier New">Public Function
    Payment(APR As Currency, </font></p>
    <p><font size="2" face="Courier New">TotalPayments As Long,
    TotalAmount As Currency, </font></p>
    <p><font size="2" face="Courier New">FutureValue As Currency,
    WhenDue </font></p>
    <p><font size="2" face="Courier New">As Long) As Currency</font></p>
    <p><font size="3"><b>Development tips</b></font></p>
    <p><font size="2">Now that the Visual Basic 4.0 Integrated
    Development Environment (IDE) is flagged as a multi-instance
    executable, you can debug the three tiers and the server by
    running multiple instances of the IDE, each loaded with a
    different layer. This will work, provided that you have not
    used RACMan to point the client to remote computers. If you
    have, just reset the addresses for the objects involved back
    to (NONE) and toggle the Register menu to Local.</font></p>
    <p><font size="2">When a watch expression is evaluated, the
    end result must be a text string that can be displayed in the
    watch window. For this reason, if you set a watch on an
    object variable pointing to an object created by Visual Basic
    4.0, you will get the message &quot;Object doesn't support
    this property or method.&quot; Visual Basic tries to evaluate
    the default property of the object to which the variable
    refers. For the Microsoft Excel application object, this is
    the Name property, which is a string.</font></p>
    <p><font size="2">If the default property of the object is a
    reference to another object, Visual Basic looks for the
    default property of that object. As long as the watch
    expression can be evaluated to a string, it can be displayed.</font></p>
    <p><font size="2">The problem with references to objects
    created from Visual Basic 4.0 class modules is that there is
    no way to designate one property or method of a class module
    as the default. Therefore, if you want to watch a variable
    that contains such an object reference, your watch expression
    should specify either the <b>TypeName</b> function or a
    property of the object:</font></p>
    <p><font size="2" face="Courier New">TypeName(objTest) (or)
    objTest.Name</font></p>
    <p><font size="3"><b>Setup</b></font></p>
    <p><font size="2">To simplify setup, we made the assumption
    that Visual Basic 4.0 Enterprise Edition is already installed
    on the three computers needed to test the example. For a
    real-world implementation, use the Setup Wizard to create
    setup images containing all the DLLs and OLE Controls needed
    to run the compiled executables. Note that the Automation
    Manager, \SYSTEM32\AUTMGR32.EXE, must be running on all the
    server computers for the system to function. Once the objects
    are compiled and copied to the respective computers, here are
    the steps for setting up the three-tier system:</font></p>
    <blockquote>
        <p><font size="2">&#149; <b>On the client computer:</b>
        Run the pool manager (<b>ObjectPoolMgr</b>) on the
        client, as it is the next link in the chain, and the only
        link that the client needs to know about. Running it once
        registers the object so that RACMan can be used to
        specify network address, protocol, and authentication
        level. Then set the access to remote. (For more on
        RACMan, see &quot;Visual Basic 4.0 Goes Live:
        16-Bit/32-Bit Rapid Application Development,&quot; <i>Developer
        Network News</i>, Sept/Oct 1995.)</font></p>
        <p><font size="2">&#149; <b>On the pool manager computer:</b>
        Run the satellite object manager (<b>CreateObjectLocalMgr</b>)
        and <b>ObjectPoolMgr</b> to register them, and then use
        RACMan to set up the satellite for remote access,
        supplying the same three parameters as above (with
        different values, of course). Additionally, you must set
        up the server to allow all remote activations. You must
        also register the DLL by running the REGSVR32 utility
        from the command line:</font></p>
        <p><font size="2">REGSVR32 &lt;path to
        DLL&gt;\FinancialCalcDLL.DLL</font></p>
        <p><font size="2">&#149; <b>On the satellite object
        manager computer:</b> Run the <b>CreateObjectLocalMgr</b>
        server and the Visual Basic OLE server FinancialCalc to
        register them. Then use RACMan to set up the access
        control list (ACL). In our security model, all users can
        hit the central pool manager, but only the central pool
        manager can access the satellite object managers.</font></p>
    </blockquote>
    <p><font size="3"><b>Security</b></font></p>
    <p><font size="2">There are two types of security in remote
    automation. The first is access control, which makes sure
    that only certain types of objects are remotely available, or
    that only specified users have access to certain objects. The
    second is authentication, which ensures that data sent from
    one application is identical to the data received by the
    other, and that no one intercepts it in between.
    Authentication merits its own article, so we will address
    only access control in this example.</font></p>
    <p><font size="2">Many security architectures are possible
    with distributed processing, ranging from no security (except
    for the default domain security), where anyone on the domain
    can activate OLE servers remotely, to hermetic security,
    where no one but the logged-on user can run OLE servers on
    that computer.</font></p>
    <p><font size="2">For computers running Windows NT, the
    preferred option (see the ambiguously labeled Client Access
    tab in RACMan) is Allow Remote Creates By ACL. This option
    uses Windows NT access control lists to determine whether a
    user running the client application has permission to access
    the class. Access to the server is tested by the Automation
    Manager impersonating the client user and attempting to open
    the object's CLSID key with query permissions. If the open
    fails, the Automation Manager returns an error. If the open
    succeeds, the Automation Manager quits impersonating the
    client user, creates the object, and returns a reference as
    usual. (Note that this security policy is dependent on the
    Windows NT ACLs and security impersonation, therefore it is
    not available on Windows 95-based server computers.)</font></p>
    <p><font size="2">For Windows 95 servers, the only secure
    option available is Allow Remote Creates By Key. Choosing
    this option in RACMan and selecting the Allow Remote
    Activation check box enables the system to grant access to an
    application that has the correct value stored under the
    object's CLSID in the registry. For Windows 95 servers, you
    should also set the authentication level to No
    Authentication.</font></p>
    <p><font size="2">We designed our architecture to allow
    unrestricted access (Allow All Remote Creates option) to the
    central pool manager by all clients. All the clients are set
    up to point the object reference for <b>ObjectPoolMgr</b> to
    the central server. The computer running <b>ObjectPoolMgr</b>
    is configured to know where all the satellite object managers
    are located, again using RACMan.</font></p>
    <p><font size="2">When setting up the satellite computers,
    the Client Access tab on RACMan is used to select the Allow
    By ACL option. At that point, the Edit ACL button is enabled
    and the Remote Class Permissions dialog box is displayed.</font></p>
    <p><font size="2">To restrict access to the OLE objects on
    each satellite to one external trusted login, remove the
    default entries in the Name list box for System and Everyone
    and then add back the domain logon used to launch the central
    pool manager, ObjectPoolMgr.exe. Only clients requesting
    services from the <b>ObjectPoolMgr</b> can launch remote
    servers on the satellites&#151;a requirement if the satellite
    computers are also users' workstations. The same approach
    could be used to restrict access to the central computer
    running <b>ObjectPoolMgr</b> to an approved client list,
    should another security layer be desired.</font></p>
    <p><font size="3"><b>Summary</b></font></p>
    <p><font size="2">We now have in place the skeleton of an
    extensible, three-tier distributed system with basic
    security. The simplicity of the basic building blocks should
    allow you to enhance this model easily according to your
    needs.</font></p>
    <p><font size="2"><i>Robert Eineigl works in Microsoft's
    Information Technology Group. His nocturnal interests include
    bicycle design, keyboard improvisation, and wildlife
    serenades with his custom-made trumpet. Randy Morgan is a
    strategic account engineer at Microsoft. He hikes, bikes, and
    kayaks, and his friends describe him as an adrenaline junkie.</i></font></p>
</blockquote>
</font></body>
</html>
