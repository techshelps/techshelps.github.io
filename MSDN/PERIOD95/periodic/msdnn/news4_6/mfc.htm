<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template"
content="C:\MSOFFICE\WINWORD\TEMPLATE\msin60b.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MFC 4.0: The Story Can Be Told</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>MFC 4.0: The Story Can Be Told</b></font></p>
    <p><font size="3"><b>New version adds control views and OLE
    container/control support</b></font></p>
    <p><font size="2">Sal Coco</font></p>
    <p><font size="2">November 1, 1995</font></p>
    <p><font size="2">One of the most significant products
    available for Windows-based software development is the
    Microsoft Foundation Class Library (MFC) version 4.0. MFC 4.0
    fully supports 32-bit programming for Microsoft Windows 95.
    Your MFC applications will run on Windows 95, Windows NT
    3.51, or Win32s 1.3. Applications developed with MFC 4.0 will
    automatically have the visual look and feel appropriate for
    any of these operating systems.</font></p>
    <p><font size="2">Using Visual C++ 4.0 and MFC 4.0 simplifies
    the task of meeting the Windows 95 logo requirements. Of
    course, it is virtually impossible for a development tool to
    automatically satisfy all of the logo requirements, since a
    lot depends on what your application is doing. However, using
    Visual C++ 4.0 and MFC 4.0 allows you to satisfy some of the
    requirements automatically, including the stipulation for
    providing a Win32 executable in a portable executable (PE)
    format, Windows NT compatibility, and long file name support.</font></p>
    <p><font size="3"><b>New Win32 common control classes</b></font></p>
    <p><font size="2">Windows 95 common controls are now
    available in Windows NT 3.51 and Win32s 1.3. MFC 4.0 offers
    new common control classes that encapsulate the following
    controls: rich text edit, slider, list, tree, spin button,
    header, progress, hot key, tool tip, tab, animate, tool bar,
    status bar, image list, drag list box, and check list box.
    The new common control classes are as easy to use as familiar
    standard control classes such as <b>CEdit</b>.</font></p>
    <p><font size="2">MFC 4.0 has a new view control base class, <b>CCtrlView</b>,
    that allows you to create a view from one of the new common
    control classes with little effort. Although previously it
    was technically possible to attach a control class to a <b>CView</b>
    object, <b>CCtrlView</b> hammers out all the details of
    making your own control view. <b>CCtrlView</b> can also be
    used with third-party controls and with controls you design
    yourself.</font></p>
    <p><font size="2">MFC 4.0 exploits the new <b>CCtrlView</b>
    class by introducing several new common control view classes:
    <b>CListView</b>, <b>CTreeView</b>, and <b>CRichEditView</b>.</font></p>
    <p><font size="2">Use a common control class when you need a
    plain child window control; for example, in a dialog box or
    form view. Plain common control classes are especially useful
    in the same window with other child control windows, as in a
    typical dialog box.</font></p>
    <p><font size="2">Use a common control view when you want the
    control to behave as a view window, such as in document/view
    architecture. A control view will occupy the entire client
    area of a single splitter window pane or frame window, and
    will automatically resize itself when the parent window is
    resized. In addition, command messages from menus,
    accelerator keys, and toolbars will be routed to the view
    automatically. Of course, the user of these control views can
    override most of the default functionality and customize the
    behavior as needed.</font></p>
    <p><font size="3"><b>A simple example</b></font></p>
    <p><font size="2">To illustrate the power of these common
    control classes and control views, let's use them to build a
    simple application that allows a user to preview animation
    files. To make this application user-friendly, let's add a
    splitter window with two vertical panes: one that displays a
    list of animation file names (organized into several
    categories), and one that plays the animation.</font></p>
    <p><font size="2">The application will behave similarly to
    the Windows 95 Explorer. A tree view is used in the left pane
    and an animation view is used in the right pane of the
    vertical splitter window. The user will select an animation
    file by drilling down into the tree view user interface and
    finding its file name. Once the animation file is selected,
    the application will play it in the right pane of the
    splitter window.</font></p>
    <p><font size="2">One approach to implementing this simple
    application is to have AppWizard generate the code for a
    basic application, using the <b>CView</b> class. After the
    application is built, we can edit the code and add a splitter
    window using the <b>CSplitterWnd</b> class. After creating
    the individual panes of the splitter window, we just need to
    add the appropriate view classes. Since the tree view is
    already implemented, we can use <b>CTreeView</b>. At this
    time, MFC does not contain an animation view class, so we
    have to create one ourselves using the <b>CCtrlView</b> base
    class. A brief example of the code needed to declare a <b>CAnimateView</b>
    class is shown below. This code is by no means complete; its
    purpose is to illustrate the basic idea of creating your own
    view control object.</font></p>
    <p><font size="2">Here's the <b>CAnimateView</b> header file:</font></p>
    <p><font size="2" face="Courier New">// CAnimateView header
    file</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">class CAnimateView :
    public CCtrlView</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">DECLARE_DYNCREATE(CAnimateView)</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">public:</font></p>
    <p><font size="2" face="Courier New">// CAnimateView
    constructor</font></p>
    <p><font size="2" face="Courier New">CAnimateView();</font></p>
    <p><font size="2" face="Courier New">// CAnimateView
    destructor</font></p>
    <p><font size="2" face="Courier New">~CAnimateView();</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Returns a reference
    to the animation</font></p>
    <p><font size="2" face="Courier New">// control.</font></p>
    <p><font size="2" face="Courier New">CAnimateCtrl&amp;
    GetAnimateCtrl() const;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Perform control
    initialization. </font></p>
    <p><font size="2" face="Courier New">virtual BOOL
    PreCreateWindow(CREATESTRUCT&amp; </font></p>
    <p><font size="2" face="Courier New">cs);</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Open the animation
    file.</font></p>
    <p><font size="2" face="Courier New">void OnInitialUpdate();</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">//{{AFX_MSG(CAnimateView)</font></p>
    <p><font size="2" face="Courier New">//}}AFX_MSG</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">DECLARE_MESSAGE_MAP()</font></p>
    <p><font size="2" face="Courier New">};</font></p>
    <p><font size="2">As you can see, creating a custom control
    view class based on the <b>CCtrlView</b> class is an easy and
    straightforward task.</font></p>
    <p><font size="2" face="Courier New">// CAnimateView source
    file</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">IMPLEMENT_DYNCREATE(CAnimateView,
    CCtrlView)</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">BEGIN_MESSAGE_MAP(CAnimateView,
    CCtrlView)</font></p>
    <p><font size="2" face="Courier New">//{{AFX_MSG_MAP(CAnimateView)</font></p>
    <p><font size="2" face="Courier New">//}}AFX_MSG_MAP</font></p>
    <p><font size="2" face="Courier New">END_MESSAGE_MAP()</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// CAnimateView
    constructor.</font></p>
    <p><font size="2" face="Courier New">// This is where
    CCtrlView uses the control </font></p>
    <p><font size="2" face="Courier New">// class name
    &quot;SysAnimate32&quot; to create the</font></p>
    <p><font size="2" face="Courier New">// view object.</font></p>
    <p><font size="2" face="Courier New">CAnimateView::CAnimateView()
    : CCtrlView(&quot;SysAnimate32&quot;, AFX_WS_DEFAULT_VIEW)</font></p>
    <p><font size="2" face="Courier New">{ }</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Destructor.</font></p>
    <p><font size="2" face="Courier New">CAnimateView::~CAnimateView()</font></p>
    <p><font size="2" face="Courier New">{ }</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Code used to return
    the reference of the CAnimateCtrl.</font></p>
    <p><font size="2" face="Courier New">CAnimateCtrl&amp;
    CAnimateView::GetAnimateCtrl() const</font></p>
    <p><font size="2" face="Courier New">{ return
    *(CAnimateCtrl*)this; }</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Called by the
    framework before the creation </font></p>
    <p><font size="2" face="Courier New">// of the window
    attached to this CWnd object.</font></p>
    <p><font size="2" face="Courier New">BOOL </font></p>
    <p><font size="2" face="Courier New">CAnimateView::PreCreateWindow(CREATESTRUCT&amp;
    cs)</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">static BOOL bInit =
    FALSE;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Initialize the common
    controls once.</font></p>
    <p><font size="2" face="Courier New">if ( bInit == FALSE )</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">// The
    InitCommonControls function ensures</font></p>
    <p><font size="2" face="Courier New">// that the common
    control DLL is loaded.</font></p>
    <p><font size="2" face="Courier New">InitCommonControls();</font></p>
    <p><font size="2" face="Courier New">bInit = TRUE;</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New">return
    CCtrlView::PreCreateWindow(cs);</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Write your
    initialization code here.</font></p>
    <p><font size="2" face="Courier New">void
    CAnimateView::OnInitialUpdate(void)</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">CCtrlView::OnInitialUpdate();</font></p>
    <p><font size="2" face="Courier New">// Open an animation AVI
    file for the animation control.</font></p>
    <p><font size="2" face="Courier New">GetAnimateCtrl().Open(&quot;c:\\myavi.avi&quot;);</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2">Now that we have the animation control view
    object and the tree view object, we can use these two views
    when we create the panes for the splitter window. And presto,
    we have an application.</font></p>
    <p><font size="3"><b>New common dialogs</b></font></p>
    <p><font size="2">MFC 4.0 also introduces two common dialog
    classes&#151;<b>CPageSetupDialog</b> and <b>COlePropertiesDialog</b>&#151;that
    encapsulate the common dialog boxes in Windows. These provide
    easy-to-use implementations of complicated dialog boxes. MFC
    4.0 also adds new functionality to the <b>CFileDialog</b>
    class.</font></p>
    <p><font size="2">The services provided by the Windows common
    OLE Page Setup dialog box are now encapsulated by the <b>CPageSetupDialog</b>
    class, which also provides support for setting and modifying
    print margins. The <b>CPageSetupDialog</b> class is derived
    from <b>CCommonDialog</b> and replaces the Print Setup dialog
    box. The Windows common OLE Object Properties dialog box is
    now encapsulated by the <b>COlePropertiesDialog</b> class.
    This dialog box provides a way to display and modify the
    properties of an OLE document item in a manner consistent
    with the Windows standards.</font></p>
    <p><font size="2">The old <b>CFileDialog</b> class also has
    new member functions for customizing the File Open dialog
    box, allowing you to add your own controls.</font></p>
    <p><font size="3"><b>OLE container and control support</b></font></p>
    <p><font size="2">The introduction of the OLE Control
    Development Kit (CDK) provided the tools necessary to develop
    OLE Controls. Today the CDK has disappeared, and all of its
    components and classes have been integrated into MFC 4.0,
    which now offers OLE Control container and OLE Control
    implementation support. AppWizard now allows developers to
    add OLE Control support to their applications automatically,
    without writing code. (See companion story &quot;MFC 4.0
    Helps You Contain Your OLE Controls&quot; in this issue of <i>Developer
    Network News</i>).</font></p>
    <p><font size="2">The new OLE Control container makes it easy
    to add OLE Controls to any window, similar to adding a
    standard Windows control. A developer who uses an OLE Control
    container does not need to know all the tedious
    implementation details of an OLE container application, only
    that the OLE Control container support is based on the <b>CWnd</b>
    class. An OLE Control becomes a unique kind of child window,
    inheriting new OLE functionality from the <b>CWnd</b> class,
    including a new method, <b>CWnd::CreateControl</b>. This
    method allows the dynamic creation of an OLE Control instead
    of an ordinary window.</font></p>
    <p><font size="2">AppWizard has become smarter with the
    introduction of a visual approach to adding OLE Control
    support. Use AppWizard to turn on the support for OLE
    Controls. OLE Control support is provided for dialog
    box-based or window-based applications. AppWizard will
    generate the code necessary to set up and prepare the OLE
    Control container. Your AppWizard-generated application is
    now ready to use OLE Controls.</font></p>
    <p><font size="3"><b>New Data Access Object classes</b></font></p>
    <p><font size="2">The Data Access Object (DAO) classes allow
    you to set up and use workspaces, and to create and
    manipulate tables, queries, and indexes for tables using the
    SQL Data Definition Language (DDL). DAOs allow direct access
    to the Jet database engine, which is also used in the
    Microsoft Access and Microsoft Visual Basic 4.0 development
    environments. Overall data access performance improves when
    using the DAO classes with the Jet database engine. The Jet
    database engine is used when manipulating Microsoft Access
    databases.</font></p>
    <p><font size="2">The DAO classes allow you to connect to
    open database connectivity (ODBC) data sources. This allows
    you to connect to tables stored on SQL Server, Oracle, or
    other databases.</font></p>
    <p><font size="3"><b>Multithreaded synchronization classes</b></font></p>
    <p><font size="2">MFC 4.0 includes several multithreaded
    classes, which provide synchronization methods to ensure the
    integrity of a resource and to gain access to the protected
    resource. These synchronization classes have been organized
    into two categories: <i>synchronization object classes</i>
    and <i>synchronization access object classes</i>.</font></p>
    <p><font size="2">The synchronization object classes control
    access to a resource and ensure its integrity. Classes in
    this category are <b>CSyncObject</b> and its derived classes <b>CEvent</b>,
    <b>CSemaphore</b>, <b>CMutex</b>, and <b>CCriticalSection</b>.</font></p>
    <p><font size="2">The synchronization access object classes
    allow the application to gain access to resources controlled
    by the synchronization object classes. These methods are <b>CSingleLock</b>
    and <b>CMultiLock</b>. Use <b>CSingleLock</b> when your
    application accesses a single controlled resource; use <b>CMultiLock</b>
    when your application accesses multiple controlled resources.</font></p>
    <p><font size="3"><b>How to get MFC 4.0</b></font></p>
    <p><font size="2">MFC 4.0 can be purchased with Visual C++
    4.0. Visual C++ subscriptions, which provide three releases
    per year, are now available in the United States, Canada, and
    Europe. Elsewhere, contact your local Microsoft subsidiary.
    MFC 4.0 is also available from licensed software vendors.</font></p>
    <p><font size="2"><i>Sal Coco is a strategic account engineer
    in the Premier Developer Support division of Microsoft
    Product Support Services.</i></font></p>
</blockquote>
</font></body>
</html>
