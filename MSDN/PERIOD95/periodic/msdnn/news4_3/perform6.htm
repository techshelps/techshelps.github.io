<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm"
content="The Unused style macro was run!_05/03/95_11:57 AM">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>High-Performance Tuning for Win32</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>High-Performance Tuning for Win32</b></font></p>
    <p><font size="2">May 9, 1995</font></p>
    <p><font size="2">Your cool Win32-based application is up and
    running and you are pretty darn excited about the 32-bit
    world. But then doubt starts to creep into your mind and you
    say, &quot;Hey, I know this app isn't performing to its
    potential. There must be some things I can do to make this
    faster.&quot;</font></p>
    <p><font size="2">So, how do you get the most bang for your
    bits? That's where this article comes in. Here are six easy
    tuning tips from Microsoft's performance gang.</font></p>
    <p><font size="3"><b>#1. Do page tuning</b></font></p>
    <p><font size="2">The <b>wstune</b> utility is a valuable
    tool that runs on Windows NT and has been in the Win32 SDK
    since its earliest version. Using <b>wstune</b> to page tune
    your application on Windows NT can also help your
    application's boot time on Windows 95.</font></p>
    <p><font size="2">The program's working set is a collection
    of recently referenced pages in its virtual address space. As
    the working set size decreases, so does memory demand. Since
    it is advantageous to minimize the memory demand, the working
    set tuner's dynamic-link library (DLL) is developed to
    measure the code working set and to produce an ordering of
    the functions (procedures) within the code that will be
    small, if not minimal, in a paging environment.</font></p>
    <p><font size="3"><b>#2. Prebase your DLLs</b></font></p>
    <p><font size="2">Make sure your DLLs are prebased
    contiguously in memory. This lets the system avoid the
    necessity of calculating an appropriate load address for the
    DLLs. You can look in your map files to see how big they are,
    and from that calculate their load addresses manually if you
    have to. Or you could write the appropriate makefiles to do
    this automatically.</font></p>
    <p><font size="2">If you are using the Microsoft Visual C++
    tools, you can just run the Rebase applet that comes with it.
    Rebase automatically calculates the appropriate load
    addresses for your DLLs if you feed them to the applet.</font></p>
    <p><font size="3"><b>#3. Properly prebind</b></font></p>
    <p><font size="2">Make sure your DLLs are properly prebound
    by using the &quot;bind&quot; utility that comes with your
    favorite compiler. This marks the import address table (IAT)
    as read-only, so the loader does not have to privatize a new
    page for the IAT for each <b>LoadLibrary</b> call.</font></p>
    <p><font size="2">The IAT provides the system with the
    specific addresses for all APIs called by a third-party DLL.
    These addresses are then used to jump to the appropriate API
    in the system code. The IAT<i> </i>is a minimum of one page
    (4K) of pagelocked data per client of the DLL.</font></p>
    <p><font size="2">For every <i>n</i> clients of a particular
    DLL, the loader would need to first create and then copy <i>n</i>
    private copies of the IAT for each client. This is a much
    more expensive operation than a simple page fault.</font></p>
    <p><font size="2">Note that you must prebind your DLLs
    against a set of specific target DLLs. The bind utility will
    automatically calculate the sizes of your DLLs versus the
    system DLLs. This technique allows you to optimize for only
    one platform. It probably makes most sense for developers to
    prebind against Windows 95 rather than Windows NT, because
    the latter is more likely to be running on a system with more
    RAM.</font></p>
    <p><font size="3"><b>#4. Turn on page faulting in Windows 95</b></font></p>
    <p><font size="2">You can use page-fault tracing by
    installing the debug version of Windows 95 and then running
    SWITCH.BAT to install the retail GUI (graphical user
    interface). SWITCH.BAT is a batch file supplied with the
    Win32 SDK. It switches from debug to retail and back,
    depending upon the options you give. To turn on page-fault
    tracing, type &quot;.mff&quot; (without the quotation marks)
    into the wdeb386 kernel debugger. This will dump all faults
    to your debug terminal. An analysis of this data can tell you
    all sorts of things, such as how many page faults you're
    taking, as well as when you're faulting due to reading in
    code versus data.</font></p>
    <p><font size="2">It is important to finish one complete
    initialization before starting something else. In some cases
    an application calls the <b>OleInitialize</b> routines too
    early. This can cause thrashing when the application is
    started in low memory conditions because both the application
    and the OLE libraries are trying to finish initialization,
    but neither one can fully fit into memory simultaneously.</font></p>
    <p><font size="3"><b>#5. Load later</b></font></p>
    <p><font size="2">To help application boot time specifically,
    try to delay loading certain components, such as MPR
    (network), SHELL.DLL, COMMDLG.DLL, printer drivers, the
    spooler, and so on, until they are actually needed. Delaying
    the loading of just one DLL doesn't help as much, but when
    you can do it for multiple DLLs on an 8-MG (megabyte)
    computer, your wins start increasing geometrically.</font></p>
    <p><font size="2">Are you doing small file reads? Sequences
    of 8-byte file reads at bootup can hinder performance. Do you
    do unnecessary disk writes at bootup? Look at any large
    allocations or files you create at boot time that could be
    moved to later on. Make sure you aren't loading any system
    DLLs you don't really need, such as the messaging API (MAPI)
    or the multimedia components</font></p>
    <p><font size="3"><b>#6. Use Windows 95 call tracing</b></font></p>
    <p><font size="2">Use call tracing. Make sure you aren't
    passing in any bogus search paths for DLLs, or possibly
    looking for malformed DLLs. In some cases searching the path
    for DLLs is more expensive than explicitly changing
    directories to the application directory, loading the DLL,
    and then changing back to the working directory.</font></p>
    <p><font size="2">Often applications load six or seven of
    their own random DLLs, thus allocating and touching huge
    chunks of memory at bootup, and opening/closing temp files.</font></p>
    <p><font size="2">You can turn on call tracing in wdeb386
    using this sequence of commands:</font></p>
    <p><font size="2">.c &lt;return&gt; 3 &lt;return&gt; 4
    &lt;return&gt; y &lt;return&gt; n &lt;return&gt; ESC</font></p>
    <p><font size="2">Then watch what calls are made on your
    behalf down to the file system.</font></p>
    <p><font size="3"><b>Tuning on Windows 95</b></font></p>
    <p><font size="2">Remember that it is especially important to
    tune your applications on Windows 95, because you may be
    running on computers with less memory than those running
    Windows NT.</font></p>
</blockquote>
</font></body>
</html>
