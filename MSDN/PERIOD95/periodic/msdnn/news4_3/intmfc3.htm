<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm"
content="The Unused style macro was run!_05/03/95_11:35 AM">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Globalizing Applications with MFC</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Globalizing Applications with MFC</b></font></p>
    <p><font size="2">F. Avery Bishop</font></p>
    <p><font size="2">May 9, 1995</font></p>
    <p><font size="2">Two features provided by the Visual C++
    development system are designed to reduce a developer's time
    from concept to product ship: a class library that implements
    a large part of the Win32 API in C++ classes, and an
    integrated development environment (IDE) consisting of App
    Studio, AppWizard, and ClassWizard that practically writes
    your applications for you.</font></p>
    <p><font size="2">These tools can save time for developers
    writing internationalized applications as well.</font></p>
    <p><font size="2">Let's take a look first at what Microsoft
    Foundation Class Library (MFC) provides writers of
    international applications, and then go through an example of
    how to use MFC in such an application, employing ClassWizard.</font></p>
    <p><font size="3"><b>Where did the NLS APIs go?</b></font></p>
    <p><font size="2">MFC is designed to implement Windows
    handles as classes. Thus, the device context (DC) class <b>CDC</b>
    corresponds to <b>HDC</b>, a handle to a device context.
    Similarly, <b>CWnd</b> corresponds to <b>HWND</b>, <b>CWinApp</b>
    to <b>HINSTANCE</b>, and so on. In general, those functions
    in the Win32 API associated with a handle became member
    functions of the corresponding MFC class. For example, you
    call <b>SetMenu</b> as a member of a <b>CWnd</b> object, <b>LoadMenu</b>
    as a member of a <b>CMenu</b> object, and <b>LoadString</b>
    as a member of a <b>CString</b> object (see below).</font></p>
    <p><font size="2">Those functions not logically associated
    with a class remain available as simple C-style functions.
    For example, you can still use the familiar NLS (National
    Language Support) API functions&#151;such as <b>GetLocaleInfo</b>,
    <b>SetThreadLocale</b>, <b>FindResourceEx</b>, <b>WideCharToMultiByte</b>,
    and <b>MultiByteToWideChar</b>&#151;as you always have.</font></p>
    <p><font size="2">On the other hand, the encapsulation of
    those functions that <i>are</i> directly related to an object
    helps application writers avoid such pitfalls as passing the
    wrong type of handle or otherwise misusing handles and other
    data types.</font></p>
    <p><font size="3"><b>The CString class</b></font></p>
    <p><font size="2">MFC also provides utility classes not
    covered by the Win32 API. The <b>CString</b> class provides
    an assortment of member functions and overloaded operators
    for encapsulating textual data that helps speed the process
    of writing international applications. The <b>CString</b>
    class operators&#151;such as + and += (concatenation), ==
    (comparison), and so on&#151;have the semantics of an actual
    string, rather than a pointer to a string, similar to
    string-handling conventions in Basic.</font></p>
    <p><font size="2">Where applicable, the member functions are
    locale or code-page sensitive. For example, the <b>CString::Compare</b>
    function uses the current locale setting to provide
    locale-sensitive comparison or sorting. As expected, the <b>OemToAnsi</b>
    and <b>AnsiToOem</b> member functions use the current OEM and
    ANSI code page settings to convert between the two.</font></p>
    <p><font size="2">The other convenient feature of <b>CString</b>
    objects is that the string buffer is based on the _TCHAR data
    type, so an application that makes full use of <b>CString</b>
    can be based on Unicode, single-byte character set (SBCS), or
    multibyte character set (MBCS). (See &quot;Internationalizing
    with Visual C++&quot; by Chris Weight in the September 1994 <i>Developer
    Network News.</i>)</font></p>
    <p><font size="3"><b>Message handlers</b></font></p>
    <p><font size="2">ClassWizard uses message handlers to let
    you add processing for a specific Windows message or control
    without paging through a huge switch statement, as was
    necessary in straight ANSI C.</font></p>
    <p><font size="2">To implement a message handler using
    ClassWizard, you first select either the message that you
    want to process, such as WM_IME_NOTIFY, or a new command that
    you add yourself, such as ID_SELECTFONT. You also decide
    which of your application's modules should process it.</font></p>
    <p><font size="2">ClassWizard then inserts lines in a <i>message
    map</i> in your implementation of that module's class,
    indicating that the message or command is to be processed by
    a member function that you write, called a <i>handler</i>. It
    also puts a prototype of the handler in the appropriate
    header file, and gives you the option of editing a skeletal
    version of the handler in the source file for the module. A
    message handler is generally given a name of the form <b>On</b>&lt;<i>message
    name</i>&gt;&#151;for example, <b>OnImeNotify</b>.</font></p>
    <p><font size="3"><b>Japanese example</b></font></p>
    <p><font size="2">Let's look at some examples of how these
    various classes and member functions can be used together.
    Suppose you have an application that needs to change the
    language used in its user interface&#151;that is, in its menu
    prompts, message text, and so on. One way to do that is to
    use the <b>LANGUAGE</b> keyword in the resource file. (This
    keyword is not directly supported by Visual C++ 2.0, but will
    be supported in a future version. See the &quot;Resource
    Statements Not Supported by Visual C++&quot; Help file in
    Books Online for an explanation of how to use this keyword
    using Visual C++2.0.)</font></p>
    <p><font size="2">For example, here is a Japanese menu.</font></p>
    <p><font size="2"><img src="Image368.gif" width="568"
    height="417"></font></p>
    <p><font size="2">The corresponding UK English menu is as
    follows:</font></p>
    <p><font size="2" face="Courier New">#define LANG_ENGLISH
    0x09</font></p>
    <p><font size="2" face="Courier New">#define
    SUBLANG_ENGLISH_UK 0x02</font></p>
    <p><font size="2" face="Courier New">//</font></p>
    <p><font size="2" face="Courier New">// English menu</font></p>
    <p><font size="2" face="Courier New">//</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">IDR_MAINFRAME MENU
    PRELOAD DISCARDABLE</font></p>
    <p><font size="2" face="Courier New">LANGUAGE LANG_ENGLISH
    SUBLANG_ENGLISH_UK</font></p>
    <p><font size="2" face="Courier New">BEGIN</font></p>
    <p><font size="2" face="Courier New">POPUP
    &quot;&amp;File&quot;</font></p>
    <p><font size="2" face="Courier New">BEGIN</font></p>
    <p><font size="2" face="Courier New">MENUITEM
    &quot;&amp;New\tCtrl+N&quot;, ID_FILE_NEW</font></p>
    <p><font size="2" face="Courier New">MENUITEM
    &quot;&amp;Open...\tCtrl+O&quot;, ID_FILE_OPEN</font></p>
    <p><font size="2" face="Courier New">MENUITEM
    &quot;&amp;Save...\tCtrl+S&quot;, ID_FILE_SAVE</font></p>
    <p><font size="2" face="Courier New">MENUITEM &quot;Save
    &amp;As...&quot;, ID_FILE_SAVE_AS</font></p>
    <p><font size="2" face="Courier New">/* etc. */</font></p>
    <p><font size="2" face="Courier New">MENUITEM
    &quot;E&amp;xit&quot;, ID_APP_EXIT</font></p>
    <p><font size="2" face="Courier New">END</font></p>
    <p><font size="2" face="Courier New">POPUP
    &quot;&amp;Edit&quot;</font></p>
    <p><font size="2" face="Courier New">/* etc. */</font></p>
    <p><font size="2" face="Courier New">POPUP
    &quot;&amp;Options&quot;</font></p>
    <p><font size="2" face="Courier New">BEGIN</font></p>
    <p><font size="2" face="Courier New">MENUITEM &quot;Change UI
    Language (&amp;L)&quot;, ID_OPTIONS_LANGUAGE</font></p>
    <p><font size="2" face="Courier New">END</font></p>
    <p><font size="2" face="Courier New">/* etc. */</font></p>
    <p><font size="2" face="Courier New">END</font></p>
    <p><font size="2">One can then select a locale and change the
    language used in menus and strings as follows:</font></p>
    <p><font size="2" face="Courier New">void
    CMainFrame::OnOptionsMenuUI() </font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">CMenu *pmnMenu ;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">CString Error, Format,
    AppName ;</font></p>
    <p><font size="2" face="Courier New">LCID dwSelected_LCID = </font></p>
    <p><font size="2" face="Courier New">MAKELCID(MAKELANGID(LANG_ENGLISH,
    </font></p>
    <p><font size="2" face="Courier New">SUBLANG_ENGLISH_UK),
    SORT_DEFAULT) ; </font></p>
    <p><font size="2" face="Courier New">// Default locale.</font></p>
    <p><font size="2" face="Courier New">// Omitted: Code to
    select locale, e.g., from </font></p>
    <p><font size="2" face="Courier New">// a list box, and set
    dwSelected_LCID.</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">if(!SetThreadLocale(dwSelected_LCID))</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">VERIFY(Format.LoadString(ID_SETLOCALE_ERROR))
    </font></p>
    <p><font size="2" face="Courier New">;</font></p>
    <p><font size="2" face="Courier New">VERIFY(AppName.LoadString(ID_APPNAME))
    ;</font></p>
    <p><font size="2" face="Courier New">Error.Format(Format,
    dwSelected_LCID) ;</font></p>
    <p><font size="2" face="Courier New">VERIFY(MessageBox(Error,
    AppName , MB_OK | </font></p>
    <p><font size="2" face="Courier New">MB_ICONEXCLAMATION)) ;</font></p>
    <p><font size="2" face="Courier New">return ;</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">VERIFY(SetMenu(NULL)) ;
    // Erases the </font></p>
    <p><font size="2" face="Courier New">// current menu</font></p>
    <p><font size="2" face="Courier New">pmnMenu =
    &amp;mnLocalizedMenu ; // This is a</font></p>
    <p><font size="2" face="Courier New">// global instance of
    CMenu</font></p>
    <p><font size="2" face="Courier New">ASSERT(pmnMenu != 0) ;
    // Make sure the </font></p>
    <p><font size="2" face="Courier New">// intialization </font></p>
    <p><font size="2" face="Courier New">// worked</font></p>
    <p><font size="2" face="Courier New">VERIFY(pmnMenu-&gt;LoadMenu(IDR_MAINFRAME))
    ; </font></p>
    <p><font size="2" face="Courier New">// Load menu of language
    ID matching </font></p>
    <p><font size="2" face="Courier New">// current locale</font></p>
    <p><font size="2" face="Courier New">VERIFY(SetMenu(pmnMenu))
    ; // Set the menu </font></p>
    <p><font size="2" face="Courier New">// in the main </font></p>
    <p><font size="2" face="Courier New">// frame window</font></p>
    <p><font size="2" face="Courier New">VERIFY(NULL!=pmnMenu-&gt;Detach())
    ; // Local </font></p>
    <p><font size="2" face="Courier New">// object will </font></p>
    <p><font size="2" face="Courier New">// go out of </font></p>
    <p><font size="2" face="Courier New">// scope</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2">The <b>VERIFY</b> macro is a debugging
    device that does nothing in retail (nondebug) mode, but
    displays a warning message box and lets the user abort or
    ignore the error when the argument returns FALSE in debug
    mode. In the case of <b>SetThreadLocale</b>, an error message
    is displayed explicitly, because this error is likely to
    occur even in a &quot;bug-free&quot; retail version. To
    report the error, we have used the <b>LoadString</b> and <b>Format</b>
    (similar to <b>sprintf</b>) member functions of the <b>CString</b>
    object, and passed the formatted <b>CString</b> object to <b>MessageBox</b>,
    a member function of <b>CWnd</b>.</font></p>
    <p><font size="2">Note that <b>SetThreadLocale</b> is a
    simple Win32 function, rather than a member function of any
    class. <b>SetMenu</b> also appears to be a stand-alone
    function in this example, but it is actually a member
    function of the current object, <b>CMainFrame</b> (which is
    derived ultimately from the <b>CWnd</b> class). Thus, no
    class name is needed. In contrast, <b>LoadMenu</b> and <b>Detach</b>
    are member functions of the <b>CMenu</b> class, which must be
    explicitly indicated.</font></p>
    <p><font size="2">Text in a string table can also be marked
    with the <b>Language</b> keyword, enabling the language to be
    switched in the user interface. Any call to <b>CString::LoadString</b>
    will now load the string of the appropriate language, as
    defined by the current locale setting.</font></p>
    <p><font size="3"><b>Anything Win32 can do...</b></font></p>
    <p><font size="2">Anything you can do in the Win32 API, you
    can do in MFC. Some of the Win32 NLS functions have been
    moved to member functions of classes, while others remain as
    stand-alone C-style functions.</font></p>
    <p><font size="2">The easiest way to find out where one of
    your favorite functions went is to highlight it in the Visual
    C++ 2.0 editor, and press F1. If the function is a member
    function of some class, the WinHelp application will give you
    a choice of the MFC version or the Win32 version of the help
    for that function. Otherwise, it will go straight to the
    Win32 description.</font></p>
    <p><font size="2"><i>F. Avery Bishop, a technical evangelist
    in Microsoft's Developer Division, brews his own beer, speaks
    and reads Japanese, and will kill for good sushi.</i></font></p>
    <p><font size="5"><b>An MFC Application's Basic Structure</b></font></p>
    <p><font size="2">The standard MFC-based application consists
    of four basic modules:</font></p>
    <blockquote>
        <p><font size="2">&#149; <b>CWinApp</b>, the main module
        controlling the initialization and processing of the rest
        of an application. It corresponds roughly to a <b>WinMain</b>
        function in C-based Windows source code.</font></p>
        <p><font size="2">&#149; A <b>CMainFrame</b> object and
        member functions, which make up the main window of your
        application.</font></p>
        <p><font size="2">&#149; Single-document interface (SDI)
        and multiple-document interface (MDI) <b>CDocument</b>
        objects and member functions. These objects perform any
        direct processing of the data in the user's document.</font></p>
        <p><font size="2">&#149; One <b>CView</b> object (or a
        derived class such as <b>CEditView</b> or <b>CScrollView</b>)
        for each <b>CDocument</b> object. This object is for
        display of the document and for receiving the user's
        input into the document.</font></p>
    </blockquote>
    <p><font size="2">The AppWizard in Visual C++ creates basic
    versions of these classes that an application writer edits
    and enhances.</font></p>
</blockquote>
</font></body>
</html>
