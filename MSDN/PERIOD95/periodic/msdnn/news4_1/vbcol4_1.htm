<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm"
content="The CleanBullets macro was run!_01/06/95_2:26 PM">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Programming with Microsoft Visual Basic: Error Handling for Multiuser Database Applications</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Visually Basic: Error Handling for
    Multiuser Database Applications</b></font></p>
    <p><font size="2">Robert Eineigl<br>
    Information Technology Group</font></p>
    <p><font size="2">January 9, 1995</font></p>
    <p><font size="2">Error handling. Not a popular topic among
    programmers. It's like doing the dishes&#151;necessary, but
    not exactly most people's idea of a good time. This article
    will change all that. Wait! Before you get too excited, I was
    only kidding!</font></p>
    <p><font size="2">While I can't promise that error handling
    will be fun, I do want to emphasize that for programs whose
    focus is data access for multiple concurrent users, error
    handling is absolutely necessary and requires important
    design consideration.</font></p>
    <p><font size="2">In the past, single-user programs needed
    error-handling routines to cover contingencies that
    programmers couldn't control, such as a user supplying
    incorrect information to a prompt or removing a floppy disk
    from the drive while the program was accessing the disk.</font></p>
    <p><font size="2">But with the transition from procedural,
    sequential programs for single-tasking operating systems such
    as MS-DOS, to event-driven, GUI-centric programs for Windows,
    the code required to handle unforeseen states or
    unpredictable contingencies has increased considerably.</font></p>
    <p><font size="2">Indeed, the need for adroit handling of the
    inevitable conflicts for programs that provide multiple-user
    access to shared data sources may require the dedication of
    up to half the code to error-handling logic.</font></p>
    <p><font size="2">This article provides a starting point for
    designing data access programs to incorporate robust error
    handling.</font></p>
    <p><font size="3"><b>The basics</b></font></p>
    <p><font size="2">Visual Basic has no centralized
    error-handling mechanism. Because of its event-driven
    architecture, the procedure call stack mechanism does not
    provide a predictable order of events upon which to base
    error-handling logic. Instead, each event procedure or
    user-defined <b>Sub</b> or <b>Function</b> must contain a
    local scope handler.</font></p>
    <p><font size="2">The following code snippet shows the
    skeleton for a local error handler in a Click event
    procedure:</font></p>
    <p><font size="2" face="Courier New">Sub ClickMeYouFool_Click
    ()On Error GoTo </font></p>
    <p><font size="2" face="Courier New">localh</font></p>
    <p><font size="2" face="Courier New">' Label for local
    resume.</font></p>
    <p><font size="2" face="Courier New">reslabel:</font></p>
    <p><font size="2" face="Courier New">' Code body here.</font></p>
    <p><font size="2" face="Courier New">' Exit sub to bypass
    local handler.</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">localh:</font></p>
    <p><font size="2" face="Courier New">' Case on value of
    built-in Err function.</font></p>
    <p><font size="2" face="Courier New">Select Case Err</font></p>
    <p><font size="2" face="Courier New">Case 3009, 3046, 3202:</font></p>
    <p><font size="2" face="Courier New">Resume reslabel</font></p>
    <p><font size="2" face="Courier New">Case 3008, 3188, 3189:</font></p>
    <p><font size="2" face="Courier New">Resume Next</font></p>
    <p><font size="2" face="Courier New">Case 3046:</font></p>
    <p><font size="2" face="Courier New">' Display error to user.</font></p>
    <p><font size="2" face="Courier New">MsgBox Error$</font></p>
    <p><font size="2" face="Courier New">Resume reslabel</font></p>
    <p><font size="2" face="Courier New">Case Else</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">This approach requires that all the logic
    needed to cover every possible consequence in this local
    procedure reside in the local handler. In cases where the
    local procedure is fine-grained, with code that has a precise
    focus or few resultant error scenarios, this approach works
    fine. The error logic is located only in the procedure where
    it's required and thus easily maintained.</font></p>
    <p><font size="2">However, typically in event-driven programs
    the same error-handling logic is needed to cover many
    procedures. Here a single, central error-handling function or
    a suite of central, globally scoped error-handling functions
    is better than placing duplicate code in every procedure that
    needs coverage.</font></p>
    <p><font size="2">The advantages of this architecture include
    easier maintenance and troubleshooting, smaller executables,
    and a program designed around error logic.</font></p>
    <p><font size="3"><b>Error central</b></font></p>
    <p><font size="2">&quot;Well,&quot; you may have the
    impertinence to ask, &quot;if Visual Basic provides no
    central global error-handling mechanism, how do I implement
    one?&quot; (Thank you for asking; your check is in the mail.)</font></p>
    <p><font size="2">The answer is: We still need a local-scope
    error trap for each procedure where data-access contention or
    network jitters may cause errors. <i>But</i>, we call a
    central error function from the local handler, passing the
    values <b>Err</b>, <b>Error$</b>, and <b>Erl</b>&#151;the
    error-related internal functions&#151;to the global handler.</font></p>
    <p><font size="2">The advantage is that the local error
    handler can start out totally generic and can be pasted into
    every procedure that needs coverage, with one minor
    modification&#151;the label for the handler. Because line
    labels, whether alphabetic or numeric, are form or module
    level in scope, the label must be altered slightly for each
    procedure. Note that when used in the <b>On Error GoTo</b> <i>linelabel</i>
    statement, the corresponding label must be defined in the
    same local procedure as the <b>On Error</b> statement.</font></p>
    <p><font size="2">The following snippet is a generic template
    for a local handler that calls a central error handler for
    instructions and interprets the instructions for the local
    procedure's context.</font></p>
    <p><font size="2" face="Courier New">localh:</font></p>
    <p><font size="2" face="Courier New">Dim rc as Integer</font></p>
    <p><font size="2" face="Courier New">rc = ErrorAll(Err,
    Error$, Erl, localh)</font></p>
    <p><font size="2" face="Courier New">Select Case rc</font></p>
    <p><font size="2" face="Courier New">Case ABORT: ' 1</font></p>
    <p><font size="2" face="Courier New">Case GO_ON: ' 2</font></p>
    <p><font size="2" face="Courier New">Case RE_TRY: ' 3</font></p>
    <p><font size="2" face="Courier New">Case COMMITIT: ' 4</font></p>
    <p><font size="2" face="Courier New">Case ROLLITBACK: ' 5</font></p>
    <p><font size="2" face="Courier New">Case PROMPTUSER: ' 6</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2">The line label, <i>localh</i>, would have a
    suffix added to it to match each procedure into which it is
    pasted.</font></p>
    <p><font size="2">I have chosen six actions to take upon
    return from the central handler, <b>ErrorAll</b>. Although
    somewhat arbitrary, these six choices cover the major
    responses to multiuser contention or network errors such as
    time-outs. The important point is to locate the decision
    logic in one global function.</font></p>
    <p><font size="2">The central function, <b>ErrorAll</b>,
    accepts as parameters the current value of the built-in error
    functions. We must store the value of the built-in functions
    in variables to pass them because these functions are reset
    to zero when a <b>Resume</b> or <b>Exit Function</b> is
    encountered. (Please search the online Help under <i>Err</i>
    for more information.)</font></p>
    <p><font size="2">The following illustrates the idea:</font></p>
    <p><font size="2" face="Courier New">Function ErrorAll
    (errnum As Integer, </font></p>
    <p><font size="2" face="Courier New">errstring As String,
    errline As Integer, </font></p>
    <p><font size="2" face="Courier New">localh As String) As
    Integer</font></p>
    <p><font size="2" face="Courier New">' In case of errors in
    this handler!</font></p>
    <p><font size="2" face="Courier New">On Error GoTo
    localh_ErrorAll</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.Errnum =
    errnum</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.ErrorString
    = errstring</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.Errline =
    errline</font></p>
    <p><font size="2" face="Courier New">' Now walk the list of
    handled errors.</font></p>
    <p><font size="2" face="Courier New">Select Case
    ErrorStruct.Errnum</font></p>
    <p><font size="2" face="Courier New">Case 602 ' general ODBC
    error</font></p>
    <p><font size="2" face="Courier New">' Call central parsing
    function</font></p>
    <p><font size="2" face="Courier New">' and pass in
    initialized structure.</font></p>
    <p><font size="2" face="Courier New">Select Case
    ODBC_Parse(ErrorStruct)</font></p>
    <p><font size="2" face="Courier New">Case ABORT</font></p>
    <p><font size="2" face="Courier New">ErrorAll = ABORT</font></p>
    <p><font size="2" face="Courier New">' Etc.</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">Case 3022 ' duplicate
    key</font></p>
    <p><font size="2" face="Courier New">ErrorAll = PROMPTUSER</font></p>
    <p><font size="2" face="Courier New">Case 3008, 3188, 3189:</font></p>
    <p><font size="2" face="Courier New">If localh =
    &quot;localh_Edit&quot; Then </font></p>
    <p><font size="2" face="Courier New">ErrorAll = ABORT</font></p>
    <p><font size="2" face="Courier New">Else</font></p>
    <p><font size="2" face="Courier New">ErrorAll = RE_TRY</font></p>
    <p><font size="2" face="Courier New">EndIf</font></p>
    <p><font size="2" face="Courier New">Case 3046:</font></p>
    <p><font size="2" face="Courier New">ErrorAll = ROLLITBACK</font></p>
    <p><font size="2" face="Courier New">Case Else 'an unforeseen
    problem</font></p>
    <p><font size="2" face="Courier New">ErrorAll = GO_ON</font></p>
    <p><font size="2" face="Courier New">End Select </font></p>
    <p><font size="2" face="Courier New">Exit Function</font></p>
    <p><font size="2" face="Courier New">localh_ErrorAll:</font></p>
    <p><font size="2" face="Courier New">' Display local errors
    to debug window.</font></p>
    <p><font size="2" face="Courier New">' Debug.Print Err,
    Error$.</font></p>
    <p><font size="2" face="Courier New">Resume Next</font></p>
    <p><font size="2" face="Courier New">End Function</font></p>
    <p><font size="2">The use of the ERRORSTRUCT structure allows
    a generic form or MsgBox to display information to the user,
    if needed, particularly if the action chosen is PROMPTUSER.
    For example, the string type fields would be filled with
    specific information for each error, to be used in a MsgBox
    or error form:</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.Headline =
    &quot;Error: Could Not Lock Table&quot;</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.ResponseMsg
    = &quot;If the problem persists, check</font></p>
    <p><font size="2" face="Courier New">with co-workers&quot;</font></p>
    <p><font size="2">In the full-blown <b>ErrorAll</b>, every
    contingency would be covered in the <b>Select Case</b>
    statement and the appropriate action chosen to return to the
    local handler.</font></p>
    <p><font size="2">Notice that we pass an additional
    parameter, <i>localh As String</i>, to the <b>ErrorAll</b>
    central function. This allows the central logic to
    differentiate between different local handlers and customize
    the response for that particular procedure.</font></p>
    <p><font size="2">Also note the call to another function,<b>
    ODBC_Parse</b>, in response to a general open database
    connectivity (ODBC) error. The <b>Error$</b> (or the variant
    form <b>Error</b>) function contains the full error message
    returned from whatever ODBC component caused the error. A
    common mistake with ODBC errors is to try <b>Error$(Err)</b>
    to retrieve the full error message. Instead, the contents of
    the unqualified function, passed into the central handler and
    saved in ERRORSTRUCT, can be passed to a function such as <b>ODBC_Parse</b>
    and parsed to find the root cause of the error, such as a
    Microsoft SQL Server error, with the appropriate response
    scenario returned.</font></p>
    <p><font size="2">The following code would be placed in the
    module containing the ErrorAll function:</font></p>
    <p><font size="2" face="Courier New">Type ErrorType</font></p>
    <p><font size="2" face="Courier New">Errnum As Integer</font></p>
    <p><font size="2" face="Courier New">ErrorString As String</font></p>
    <p><font size="2" face="Courier New">Errline As Integer</font></p>
    <p><font size="2" face="Courier New">Headline As String</font></p>
    <p><font size="2" face="Courier New">ProblemMsg As String</font></p>
    <p><font size="2" face="Courier New">ResponseMsg As String</font></p>
    <p><font size="2" face="Courier New">End Type</font></p>
    <p><font size="2" face="Courier New">Global ErrorStruct As
    ErrorType</font></p>
    <p><font size="2" face="Courier New">Global gbErroroff As
    Integer</font></p>
    <p><font size="2" face="Courier New">' Constants for the
    major response scenarios.</font></p>
    <p><font size="2" face="Courier New">Global Const ABORT = 1</font></p>
    <p><font size="2" face="Courier New">Global Const GO_ON = 2</font></p>
    <p><font size="2" face="Courier New">Global Const RE_TRY = 3</font></p>
    <p><font size="2" face="Courier New">Global Const COMMITIT =
    4</font></p>
    <p><font size="2" face="Courier New">Global Const ROLLITBACK
    = 5</font></p>
    <p><font size="2" face="Courier New">Global Const PROMPTUSER
    = 6</font></p>
    <p><font size="2" face="Courier New">Global Const MaxRetries
    = 20</font></p>
    <p><font size="3"><b>Customizing the local handler</b></font></p>
    <p><font size="2">Now that we have the central error handler
    in place, we need to tune the central logic for the
    particular application being created. The advantage is that,
    if the design team decides that the proper response to a
    certain locking error should change from a RE_TRY to ABORT,
    the change is simply made in <b>ErrorAll</b> and is
    automatically propagated to the appropriate local handler.</font></p>
    <p><font size="2">Taking the generic local handler and
    customizing it for use with the central handler, we have the
    following code:</font></p>
    <p><font size="2" face="Courier New">Sub Edit_A_Record ()</font></p>
    <p><font size="2" face="Courier New">Dim Retries As Integer</font></p>
    <p><font size="2" face="Courier New">On Error GoTo
    localh_Edit</font></p>
    <p><font size="2" face="Courier New">If gb_erroroff Then On
    Error GoTo 0</font></p>
    <p><font size="2" face="Courier New">retry_label:</font></p>
    <p><font size="2" face="Courier New">Select Case
    g_whichrecordset</font></p>
    <p><font size="2" face="Courier New">Case &quot;Dynaset&quot;</font></p>
    <p><font size="2" face="Courier New">ds.Edit</font></p>
    <p><font size="2" face="Courier New">Case &quot;Table&quot;</font></p>
    <p><font size="2" face="Courier New">tb.Edit</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">localh_Edit:</font></p>
    <p><font size="2" face="Courier New">rc = ErrorAll(Err,
    Error$, Erl,&quot;localh_Edit&quot; )</font></p>
    <p><font size="2" face="Courier New">Select Case rc</font></p>
    <p><font size="2" face="Courier New">Case ABORT: ' 1</font></p>
    <p><font size="2" face="Courier New">msg$ = &quot;Due to
    interference from other </font></p>
    <p><font size="2" face="Courier New">insufferable users,
    &quot;</font></p>
    <p><font size="2" face="Courier New">msg$ = msg$ &amp;
    Chr$(13) &amp; Chr$(10) &amp; &quot;I am</font></p>
    <p><font size="2" face="Courier New">aborting this
    transaction!&quot;</font></p>
    <p><font size="2" face="Courier New">MsgBox msg$</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">Case GO_ON: ' 2</font></p>
    <p><font size="2" face="Courier New">Resume Next</font></p>
    <p><font size="2" face="Courier New">Case RE_TRY: ' 3</font></p>
    <p><font size="2" face="Courier New">FreeLocks</font></p>
    <p><font size="2" face="Courier New">Retries = Retries + 1</font></p>
    <p><font size="2" face="Courier New">If Retries &gt;
    MaxRetries Then</font></p>
    <p><font size="2" face="Courier New">msg$ = &quot;20 attempts
    to obtain an edit lock</font></p>
    <p><font size="2" face="Courier New">have failed.&quot;</font></p>
    <p><font size="2" face="Courier New">msg$ = msg$ &amp;
    Chr$(13) &amp; Chr$(10) &amp;</font></p>
    <p><font size="2" face="Courier New">&quot; Aborting this
    transaction!&quot;</font></p>
    <p><font size="2" face="Courier New">MsgBox msg$</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End If</font></p>
    <p><font size="2" face="Courier New">tm = Timer</font></p>
    <p><font size="2" face="Courier New">' Wait 1 second then
    retry.</font></p>
    <p><font size="2" face="Courier New">While Timer - tm &lt; 1</font></p>
    <p><font size="2" face="Courier New">DoEvents</font></p>
    <p><font size="2" face="Courier New">Wend</font></p>
    <p><font size="2" face="Courier New">Resume retry_label</font></p>
    <p><font size="2" face="Courier New">Case COMMITIT: ' 4</font></p>
    <p><font size="2" face="Courier New">CommitTrans</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">Case ROLLITBACK: ' 5</font></p>
    <p><font size="2" face="Courier New">Rollback</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">Case PROMPTUSER: ' 6</font></p>
    <p><font size="2" face="Courier New">MsgBox
    CStr(ErrorStruct.Errnum) &amp; &quot; &quot; &amp;</font></p>
    <p><font size="2" face="Courier New">ErrorStruct.ErrorString</font></p>
    <p><font size="2" face="Courier New">Resume retry_label</font></p>
    <p><font size="2" face="Courier New">Case Else</font></p>
    <p><font size="2" face="Courier New">MsgBox &quot;I am
    clue-free. Now quitting!&quot;</font></p>
    <p><font size="2" face="Courier New">Exit Sub</font></p>
    <p><font size="2" face="Courier New">End Select</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">A global Boolean variable, <i>gbErroroff</i>,
    is a recommended technique to disable error trapping for the
    entire project. Setting it to <b>True</b> during the
    debugging process helps find errors masked by the active
    error trap.</font></p>
    <p><font size="2">The local handler is the best place to glue
    the central handler's logic to the case at hand. The local
    handler need only deal with the major action scenarios, such
    as those I have chosen to illustrate, while the central
    handler does all the parsing and sorting of the raw errors.</font></p>
    <p><font size="3"><b>Summary</b></font></p>
    <p><font size="2">The use of a central error handler can
    simplify the process of making a multiuser program robust and
    responsive. By setting up the handler from the project's
    inception and adding new scenarios as needed, some
    frustration and duplicated effort can be avoided. An
    additional benefit is that once the central error logic is
    developed for one Visual Basic application, it can be reused
    with minimal changes in other multiuser programs.</font></p>
    <p><font size="2"><i>Robert Eineigl works in Microsoft's
    Information Technology Group, building database systems
    coupled to clients written in Visual Basic. He also disturbs
    wildlife by playing his custom-made, oversized trumpet.</i></font></p>
</blockquote>
</font></body>
</html>
