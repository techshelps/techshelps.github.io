<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Deep C: Reusable Code Battle</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Deep C: Reusable Code Battle</b></font></p>
    <p><font size="2">Brian Overland<br>
    Senior Technical Writer, Advanced Technology Division</font></p>
    <p><font size="2">One of the more evocative adjectives heard
    around the halls at Microsoft is the word
    &quot;religious.&quot; Coding style as a religious issue.
    Operating systems as religion. Languages such as C and
    Pascal, each with their religious followers&#151;and
    detractors.</font></p>
    <p><font size="2">In the hallways of software companies, the
    use of the word &quot;religious&quot; alludes not to a
    connection to a higher power but to its more specifically
    human connotations. A &quot;religious&quot; software issue is
    one that arouses strong emotions, divides people into
    opposing camps, and defies the power of pure reason to
    produce a universally accepted resolution.</font></p>
    <p><font size="2">In C++, one of the more hotly debated
    subjects these days concerns inheritance. Some of the
    stronger advocates of the object-oriented programming (OOP)
    language school invoke the holy words&#151;inheritance,
    polymorphism, and virtual&#151;with reverence, hoping to
    usher in the millennium. Meanwhile, devotees of a newer
    school, that of the Component Object Model, question whether
    inheritance is the best tool for creating reusable code, and
    suggest containment and aggregation as superior techniques.</font></p>
    <p><font size="2">A true appreciation of object-oriented
    design&#151;with emphasis on the idea of design, not language
    features&#151;suggests that each technique has its place. </font></p>
    <p><font size="2">Good design dictates that you structure
    your system according to the relationships you're trying to
    model, not through slogans such as &quot;contain, don't
    inherit&quot; or vice versa.</font></p>
    <p><font size="2">The Component Object Model (COM) is a
    binary standard, part of systems architecture at Microsoft
    and other companies, that extends object capabilities to the
    system level. I refer to it frequently here because it's the
    future direction of object orientation. COM supports
    containment and aggregation (a variation on containment)
    because of their flexibility. At the same time, COM requires
    some inheritance relationships.</font></p>
    <p><font size="3"><b>Code reuse: what's it all about?</b></font></p>
    <p><font size="2">What the shouting is all about is the issue
    of code reuse. Inheritance and containment both do
    essentially the same thing&#151;they bring a chunk of
    existing code and data into your own objects.</font></p>
    <p><font size="2">In essence, it's a simple issue. Consider
    the real world for a moment. Designing a house could take
    thousands of years if you had to invent every light bulb,
    every plumbing fixture, and every material that made up the
    house.</font></p>
    <p><font size="2">No one works that way, of course. Every
    inventor and architect stands on the shoulders of countless
    others before them, reusing, modifying, and adapting the work
    and ideas of their predecessors.</font></p>
    <p><font size="2">A major goal in computer science is to
    bring this concept of reuse to the writing of software. It's
    an illusion, however, to think there isn't any reuse now.
    It's been there for a long time.</font></p>
    <p><font size="2">Device drivers, for example, are highly
    reusable code. Every time you read or write to the terminal,
    you're using the same device-driver routines. The Windows API
    and operating system functions are reused constantly. Common
    MS-DOS functions are called billions of times a day all over
    the world.</font></p>
    <p><font size="2">The reuse of these functions has nothing to
    do with how they are written (device drivers are typically
    written in primitive assembly) and everything to do with how
    useful they are.</font></p>
    <p><font size="3"><b>So what about objects?</b></font></p>
    <p><font size="2">That said, advances in language features
    are still important. Structured languages make it easier to
    write functions and control the scope of data. The use of
    classes in C++ takes this ability somewhat further,
    associating the scope of data to an entire set of related
    functions. As environments become more
    complex&#151;especially ones that deal with self-contained,
    graphical objects&#151;this method of program organization is
    very helpful.</font></p>
    <p><font size="2">Without the use of an OOP language such as
    C++, you could only get the same benefits through extensive
    documentation and self-discipline (which is hard work) or by
    placing each object in a separate source module (which is not
    always convenient).</font></p>
    <p><font size="2">Both approaches require additional work if
    you want to create multiple instances (or
    &quot;objects&quot;) of the same class. You'd have to
    allocate a new block of memory each time you wanted another
    instance.</font></p>
    <p><font size="3"><b>Now, for inheritance</b></font></p>
    <p><font size="2">Once we've established the usefulness of
    classes and objects, it's easier to see where inheritance and
    containment come into play. When you create a new class
    derived from an existing class, you're grabbing some existing
    chunk of software (code plus data) and adding some features
    of your own. Anyone else could have written the existing
    chunk, although you need to understand something about how to
    use it.</font></p>
    <p><font size="2">For example, in the following code, my dog
    gets all the attributes of an animal, and then some:</font></p>
    <p><font size="2" face="Courier New">class CDog : public
    CAnimal</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">int breed;</font></p>
    <p><font size="2" face="Courier New">CString name;</font></p>
    <p><font size="2" face="Courier New">} mydog;</font></p>
    <p><font size="2">In this simple case, the results are
    essentially the same as the following example of containment:</font></p>
    <p><font size="2" face="Courier New">class CDog</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">CAnimal animal;</font></p>
    <p><font size="2" face="Courier New">int breed;</font></p>
    <p><font size="2" face="Courier New">CString name;</font></p>
    <p><font size="2" face="Courier New">} mydog;</font></p>
    <p><font size="2">What's the difference? Only a minor one,
    actually. In the first case, all of <b>CAnimal'</b>s public
    members become members of the object <b>mydog</b>. In the
    second, you access the same members through a member
    variable, <i>animal</i>:</font></p>
    <p><font size="2" face="Courier New">mydog.animal.weight =
    100;</font></p>
    <p><font size="2">(Protected members create a true difference
    between the two cases, but let's ignore that difference for
    now.)</font></p>
    <p><font size="3"><b>Pros of inheritance</b></font></p>
    <p><font size="2">In C++, inheritance does have an exclusive
    role: It is required for the creation and exploitation of
    virtual functions. This aspect of inheritance is natural, for
    it imposes discipline on what would otherwise be chaotic,
    free-wheeling late binding of functions. C++ forces you to be
    deliberate about virtual functions by saying, &quot;All these
    classes are variations on the same base class, and they all
    implement the function F() in the base class.&quot;</font></p>
    <p><font size="2">What's really going on is that when you
    declare a base class with a virtual function, you're leaving
    the field open for a whole range of child classes, each with
    their own implementation of that function. New types of
    objects can be added later with as-yet-unwritten
    implementations, and client code need not be recompiled.</font></p>
    <p><font size="2">You can do all of this in C with callback
    functions and function tables. But in C++ the process is
    easier and more systematic.</font></p>
    <p><font size="2">Even in the Component Object Model,
    inheritance is necessary. In this model, you must be able to
    query each interface, as well as reference and release it, so
    each and every interface must implement functions inherited
    from <b>IUnknown</b>.</font></p>
    <p><font size="3"><b>Pros of containment</b></font></p>
    <p><font size="2">Although inheritance is more powerful in
    terms of functions, it is less flexible, because you can
    inherit from a base class only once. Suppose you want to make
    multiple use of an existing class. For example, my dog has
    four legs:</font></p>
    <p><font size="2" face="Courier New">class CDog</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">CLeg left_front,
    right_front;</font></p>
    <p><font size="2" face="Courier New">CLeg left_rear,
    right_rear;</font></p>
    <p><font size="2" face="Courier New">int breed;</font></p>
    <p><font size="2" face="Courier New">CString name;</font></p>
    <p><font size="2" face="Courier New">} mydog;</font></p>
    <p><font size="2">You couldn't inherit from <b>CLeg</b> and
    thereby get four copies of <b>CLeg</b> objects&#151;at least
    not directly.</font></p>
    <p><font size="2">Another issue concerns multiple
    inheritance. If you want each instance of my class to get all
    the material in two existing classes (say, <b>CLeg</b> and <b>CTail</b>),
    you could only inherit from both by using multiple
    inheritance. This kind of inheritance raises some messy
    issues, not the least of which is that it is extremely
    difficult to implement in C when virtual functions are added.
    (This is an issue in the Component Object Model, which
    creates a binary standard extensible to C.)</font></p>
    <p><font size="3"><b>Containment/inheritance harmony</b></font></p>
    <p><font size="2">Both approaches have distinct advantages.
    It's a mistake, however, to think that one is basically more
    efficient or easier to use than the other in all cases.
    You've probably heard claims that the proper use of
    inheritance requires access to source code and that you don't
    always know what you're getting. Yet this is equally true of
    containment. In either case, it helps to know what you're
    bringing in, and you might not know without adequate
    documentation.</font></p>
    <p><font size="2">Ultimately, the point of view that
    emphasizes modeling principles, and the role of inheritance
    and containment in both, is well taken. To return to our
    first example, <b>CDog</b> really should inherit from <b>CAnimal</b>
    after all, because dog has a &quot;kind of&quot; relationship
    to animal. At the same time, dog &quot;is made up of&quot;
    legs. A little common sense tells us that the relationships
    in the model provide the key to the most suitable design.</font></p>
    <p><font size="2" face="Courier New">class CDog : public
    CAnimal</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">Cleg left_front,
    right_front;</font></p>
    <p><font size="2" face="Courier New">Cleg left_rear,
    right_rear;</font></p>
    <p><font size="2" face="Courier New">int breed;</font></p>
    <p><font size="2" face="Courier New">CString name;</font></p>
    <p><font size="2" face="Courier New">} mydog;</font></p>
    <p><font size="2"><i>Brian Overland, a published author,
    sometime programmer, and veteran of several Microsoft
    languages groups, now works in interactive television. He
    fights inheritance wars there every day.</i></font></p>
</blockquote>
</font></body>
</html>
