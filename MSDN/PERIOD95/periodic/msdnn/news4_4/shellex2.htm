<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Extending the Windows 95 Shell</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Extending the Windows 95 Shell</b></font></p>
    <p><font size="2">Nancy Winnick Cluts</font></p>
    <p><font size="2">July 13, 1995</font></p>
    <p><font size="2">The Windows 95 shell is extensible. You can
    access tools that manipulate objects in the shell name space,
    and you can browse through the file system and networks.</font></p>
    <p><font size="2">All shell extensions are implemented as
    Component Object Model (COM) objects and reside in
    dynamic-link libraries (DLLs). Once you grasp the basics of
    how to implement COM objects, the additional information you
    need to understand to implement a shell extension should be
    fairly simple.</font></p>
    <p><font size="2">The Windows 95 shell supports seven types
    of shell extensions (referred to as handlers):</font></p>
    <blockquote>
        <p><font size="2">&#149; <b>Context menu handlers.</b>
        Add menu items to the context menu for a particular file
        object. The context menu is displayed when a user clicks
        a file object with the alternate (usually the right)
        mouse button. Context menu handlers implement the <b>IContextMenu</b>
        and <b>IShellExtInit</b> interfaces.</font></p>
        <p><font size="2">&#149; <b>Drag-and-drop handlers.</b>
        Context menu handlers that are accessed when a user drops
        an object after dragging it to a new location.
        Drag-and-drop handlers implement the <b>IContextMenu</b>
        and <b>IShellExtInit</b> interfaces. The only difference
        between a context menu handler and a drag-and-drop
        handler is the way it is registered in the registration
        database.</font></p>
        <p><font size="2">&#149; <b>Icon handlers.</b> Add
        instance-specific icons for file objects or add icons for
        specific file classes. Icon handlers implement the <b>IExtractIcon</b>
        and <b>IPersistFile</b> interfaces.</font></p>
        <p><font size="2">&#149; <b>Property sheet handlers.</b>
        Add pages to the property sheet dialog box the shell
        displays for a file object. Property sheet handlers
        implement the <b>IShellPropSheetExt</b> and <b>IShellExtInit</b>
        interfaces.</font></p>
        <p><font size="2">&#149; <b>Copy hook handlers.</b>
        Prevent a folder or printer object from being copied,
        moved, deleted, or renamed. Copy hook handlers implement
        the <b>ICopyHook</b> interface.</font></p>
        <p><font size="2">&#149; <b>Drop target handler.</b>
        Controls the action that occurs when the shell drops
        objects on other objects. Drop target handlers implement
        the <b>IDropTarget</b> and <b>IPersistFile</b>
        interfaces.</font></p>
        <p><font size="2">&#149; <b>Data object handler.</b>
        Supplies the object when files are being dragged and
        dropped or copied and pasted. Data object handlers
        implement the <b>IDataObject</b> and <b>IPersistFile</b>
        interfaces.</font></p>
    </blockquote>
    <p><font size="3"><b>Register now</b></font></p>
    <p><font size="2">Like all COM objects, shell extensions must
    be registered in the registration database, or they won't
    work. Each extension must register its class ID (CLSID) under
    HKEY_CLASSES_ROOT\CLSID in the registry. Within this key, the
    extension adds an <b>InProcServer32</b> key that gives the
    location of the extension's DLL. The first line in the sample
    below registers the CLSID of a property sheet extension
    called NancyPropSheet. The second line specifies the location
    of the DLL containing the extension and the threading model.</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\CLSID\{771a9da0-731a-11ce-993c-00aa004adb6c}]</font></p>
    <p><font size="2" face="Courier New">@=&quot;NancyPropSheet&quot;</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\CLSID\{771a9da0-731a-11ce-993c-00aa004adb6c}\InprocServer32]</font></p>
    <p><font size="2" face="Courier New">@=&quot;c:\\windows\\system\\propext.dll&quot;</font></p>
    <p><font size="2" face="Courier New">&quot;ThreadingModel&quot;=&quot;Apartment&quot;</font></p>
    <p><font size="2">Your shell extension must also be
    registered under the <b>shellex </b>key, which contains the
    information the shell uses to associate a shell extension
    with a file type. You can map your shell extension to a
    particular class of file (based upon the file extension), or
    you can specify that the shell extension is valid for files
    of all types. In the property sheet extension sample above,
    the property sheet was registered specifically for NWCFile as
    follows:</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\.NWC]</font></p>
    <p><font size="2" face="Courier New">@=&quot;NWCFile&quot;</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\NWCFile]</font></p>
    <p><font size="2" face="Courier New">@=&quot;Shell Extension
    file&quot;</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\NWCFile\shellex\PropertySheetHandlers]</font></p>
    <p><font size="2" face="Courier New">@=&quot;NWCPage&quot;</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\NWCFile\shellex\PropertySheetHandlers\NWCPage]</font></p>
    <p><font size="2" face="Courier New">@=
    &quot;{771a9da0-731a-11ce-993c-00aa004adb6c}&quot;</font></p>
    <p><font size="2">Now say you want all files to reap the
    benefits of your special property page. To do this, you
    specify '*' after HKEY_CLASSES_ROOT as seen in the following
    example:</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\*\shellex\PropertySheetHandlers]</font></p>
    <p><font size="2" face="Courier New">@=&quot;NWCPage&quot;</font></p>
    <p><font size="2" face="Courier New">[HKEY_CLASSES_ROOT\*\shellex\PropertySheetHandlers\NWCPage]</font></p>
    <p><font size="2" face="Courier New">@=
    &quot;{771a9da0-731a-11ce-993c-00aa004adb6c}&quot;</font></p>
    <p><font size="3"><b>Initial impressions</b></font></p>
    <p><font size="2">Besides registration in the registration
    database, shell extensions share the way in which they are
    initialized. The shell uses two interfaces to initialize
    instances of shell extensions: <b>IShellExtInit</b> and <b>IPersistFile</b>.</font></p>
    <p><font size="2">The <b>IShellExtInit</b> interface is used
    to initialize context menu handlers, drag-and-drop handlers,
    and property sheet handlers, while <b>IPersistFile</b> is
    employed to initialize instances of icon handlers, data
    object handlers, and drop target handlers. (Copy hook
    handlers don't use the <b>IShellExtInit</b> or <b>IPersistFile</b>
    interface.)</font></p>
    <p><font size="2">After implementing the initialization
    interface for your shell extension, you need to implement the
    actual interface for the particular shell extension you are
    writing. For example, if you are writing a property sheet
    extension, you will need to implement the <b>IShellPropSheetExt</b>
    interface.</font></p>
    <p><font size="3"><b>Debugging shell extensions</b></font></p>
    <p><font size="2">When your shell extension is written and
    registered, what do you do if it doesn't work? It's not like
    most applications, where you can simply include <b>DebugBreak</b>
    calls in your code or run the Visual C++ development system
    in debug mode, set some breakpoints, and go.</font></p>
    <p><font size="2">Because shell extensions are loaded at the
    startup of the Explorer, you have to find a way to start the
    Explorer without loading all of its DLLs. Here's how:</font></p>
    <blockquote>
        <p><font size="2">1. Go into your project settings and,
        under the Debug tab, type the path to EXPLORER.EXE in the
        Executable For Debug Session edit box.</font></p>
        <p><font size="2">2. Close all applications you are
        running, and turn off your computer.</font></p>
        <p><font size="2">3. Restart Windows 95 and Visual C++,
        loading your shell extension.</font></p>
        <p><font size="2">4. Click the Start button and choose
        Shutdown.</font></p>
        <p><font size="2">5. Now, hold down the CTRL+ALT+SHIFT
        keys and simultaneously click No. (Sounds a bit like
        playing Twister, doesn't it?)</font></p>
        <p><font size="2">6. The desktop will go blank and your
        heart will start palpitating, but don't worry. Pressing
        ALT+TAB will get you to your instance of Visual C++.</font></p>
        <p><font size="2">7. At this point you are ready to
        debug. Set your breakpoints and go<i>.</i></font></p>
    </blockquote>
    <p><font size="2">If you want to be able to force the shell
    to unload DLLs very quickly so you don't need to exit it to
    debug your shell extension, you can do this through a setting
    in the registry. Under HKEY_LOCAL_
    MACHINE\SOFTWARE\Microsoft\Windows\ CurrentVersion\Explorer,
    add the <b>AlwaysUnloadDll</b> key and set its value to a
    number (I set it to 1 because that's the kind of gal I am).
    Adding this key sets the time-out value for DLLs to a very
    small value. </font></p>
    <p><font size="3"><b>Shell extensions and Windows NT</b></font></p>
    <p><font size="2">You may wonder whether your shell extension
    will run on the Windows NT operating system. Windows 95 shell
    extensions can work on Windows NT 3.51<i>.</i> This version
    gives a user the option of running Windows NT 3.51 with the
    Windows 95 shell. To do so, however, there is one additional
    step that your application must take in its setup process and
    registration.</font></p>
    <p><font size="2">For the Windows NT shell to recognize and
    run a shell extension, the handler's CLSID must also be
    listed under a new registry key (in addition to the registry
    entries you need to make for Windows 95) that contains a list
    of the handlers approved for the shell to run. By default,
    this key's access control permissions allow only someone with
    administrator privileges to modify the list. The CLSID must
    be registered under Windows NT at the following location:</font></p>
    <p><font size="2">HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\<br>
    Shell Extensions\Approved</font></p>
    <p><font size="2">To register the extension, a &quot;named
    value&quot; should be added to the <b>Approved</b> key. The
    name of the value must be the string form of the CLSID that
    can be obtained through the <b>StringFromCLSID</b> function.</font></p>
    <p><font size="2">For example, to register the property sheet
    extension shown above, you can add the following line to your
    registration file:</font></p>
    <p><font size="2" face="Courier New">[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Shell
    Extensions\</font></p>
    <p><font size="2" face="Courier New">Approved\{771a9da0-731a-11ce-993c-00aa004adb6c}]
    @=&quot;NancyPropSheet&quot;</font></p>
    <p><font size="3"><b>Security questions</b></font></p>
    <p><font size="2">If you haven't written applications for
    Windows NT, it may seem odd that your setup application may
    not be able to write to this key. The ability to write to the
    key depends on the access privileges of the person installing
    the application. The setup application should attempt to open
    the key described above, requesting the KEY_SET_VALUE
    permission. If it succeeds, the new CLSID can be added to
    fully register the corresponding shell extension.</font></p>
    <p><font size="2">If the request fails due to a security
    violation, the user installing the application does not have
    permission to register new shell extensions. In this case,
    the setup application might warn the user that some
    application features will not be available unless an
    administrator turns them on (by installing the application,
    or by writing the registry keys directly). Or, if the shell
    extension is crucial to the application's functioning, the
    setup application might cause the installation to fail
    completely, notifying the user that the program must be
    installed by an administrator.</font></p>
    <p><font size="2">The following sample code demonstrates how
    an application can register its shell extension under Windows
    NT:</font></p>
    <p><font size="2" face="Courier New">// First, attempt to
    open the registry key where approved extensions are listed.</font></p>
    <p><font size="2" face="Courier New">long err;</font></p>
    <p><font size="2" face="Courier New">HKEY hkApproved;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">err = RegOpenKeyEx(</font></p>
    <p><font size="2" face="Courier New">HKEY_LOCAL_MACHINE, </font></p>
    <p><font size="2" face="Courier New">&quot;Software\\Microsoft\\Windows\\CurrentVersion\\Shell
    Extensions\\Approved&quot;,</font></p>
    <p><font size="2" face="Courier New">0,</font></p>
    <p><font size="2" face="Courier New">KEY_SET_VALUE,</font></p>
    <p><font size="2" face="Courier New">&amp;hkApproved);</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">if (err ==
    ERROR_ACCESS_DENIED)</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">// The user does not
    have permissions to add a new value to this key.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New">else if (err ==
    ERROR_FILE_NOT_FOUND)</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">// The key does not
    exist. This should only happen if setup is running on </font></p>
    <p><font size="2" face="Courier New">// Windows 95 instead of
    Windows NT, or if you are installing on an older </font></p>
    <p><font size="2" face="Courier New">// version of either
    operating system that does not have the Win95 UI.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">.</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New">else if (err !=
    ERROR_SUCCESS)</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">// Some other problem...</font></p>
    <p><font size="2" face="Courier New">}</font></p>
    <p><font size="2" face="Courier New">else</font></p>
    <p><font size="2" face="Courier New">{</font></p>
    <p><font size="2" face="Courier New">// Assume that
    lpstrProgID contains our ProgID string.</font></p>
    <p><font size="2" face="Courier New">LPSTR lpstrProgID =
    &quot;My Bogus Class&quot;;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">// Assume that
    clsidExtension contains the CLSID struct. The code below
    creates </font></p>
    <p><font size="2" face="Courier New">// a string from this
    CLSID. If a string version of the CLSID is already handy, </font></p>
    <p><font size="2" face="Courier New">// skip this code.</font></p>
    <p><font size="2" face="Courier New">CLSID clsidExtension =
    {0x11111111, 0x1111, 0x1111, 0x11, 0x11, 0x11, 0x11, </font></p>
    <p><font size="2" face="Courier New">0x11, 0x11, 0x11, 0x11};</font></p>
    <p><font size="2" face="Courier New">HRESULT hr;</font></p>
    <p><font size="2" face="Courier New">LPOLESTR lpolestrCLSID;</font></p>
    <p><font size="2" face="Courier New">CHAR rgchCLSID[40];</font></p>
    <p><font size="2" face="Courier New">CoInitialize(NULL);</font></p>
    <p><font size="2" face="Courier New">hr =
    StringFromCLSID(clsidExtension, &amp;lpolestrCLSID);</font></p>
    <p><font size="2" face="Courier New">// StringFromCLSID
    returns a Unicode string, so convert to ANSI for calling the </font></p>
    <p><font size="2" face="Courier New">// registry. Note that
    on Windows NT you can call the Unicode version of the </font></p>
    <p><font size="2" face="Courier New">// registry API instead.</font></p>
    <p><font size="2" face="Courier New">WideCharToMultiByte(CP_ACP,
    0, lpolestrCLSID, -1, rgchCLSID, 40, NULL, NULL);</font></p>
    <p><font size="2" face="Courier New">CoTaskMemFree(lpolestrCLSID);</font></p>
    <p><font size="2" face="Courier New">CoUninitialize();</font></p>
    <p><font size="2" face="Courier New">// Now add the new value
    to the registry.</font></p>
    <p><font size="2" face="Courier New">err = RegSetValueEx(</font></p>
    <p><font size="2" face="Courier New">hkApproved,</font></p>
    <p><font size="2" face="Courier New">rgchCLSID,</font></p>
    <p><font size="2" face="Courier New">0,</font></p>
    <p><font size="2" face="Courier New">REG_SZ,</font></p>
    <p><font size="2" face="Courier New">(const BYTE
    *)lpstrProgID,</font></p>
    <p><font size="2" face="Courier New">strlen(lpstrProgID));</font></p>
    <p><font size="2" face="Courier New">// Finally, close the
    key.</font></p>
    <p><font size="2" face="Courier New">err =
    RegCloseKey(hkApprovedt);</font></p>
    <p><font size="2">That's all there is to it. For more
    detailed information about how to implement the different
    shell extensions, consult the Microsoft Development Library.
    Some sample code is also available in the merged Win32
    Software Development Kit<i>.</i></font></p>
    <p><font size="2"><i>Nancy Winnick Cluts, a Developer Network
    writer, retired from a highly successful career as an
    international super-model to write</i> Programming the
    Windows 95 User Interface <i>(Microsoft Press, August 1995).</i></font></p>
</blockquote>
</font></body>
</html>
