<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template" content="C:\WINWORD\TEMPLATE\MSIN60B.DOT">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Using OLE Automation in Visual FoxPro</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Using OLE Automation in Visual FoxPro</b></font></p>
    <p><font size="2">Paul Bienick</font></p>
    <p><font size="2">July 13, 1995</font></p>
    <p><font size="2">Since the introduction of the Microsoft
    FoxPro database management system for Windows, developers
    have been able to use OLE technology to embed or link
    documents from other applications directly into FoxPro
    tables. Now Visual FoxPro 3.0 goes much further, allowing you
    to use OLE Automation to add the functionality in Microsoft
    Office products&#151;such as Microsoft Word and Microsoft
    Excel&#151;to applications created with FoxPro.</font></p>
    <p><font size="2">An OLE Automation server application allows
    other, external applications to control it by exposing
    certain parts of its internal structure in the form of
    objects. These objects have properties and methods.
    Properties allow you to set or retrieve values that might
    represent the state of the object. Methods allow you to
    perform an action on a specific object, such as opening a new
    document, printing a file, or recalculating a range of cells.</font></p>
    <p><font size="3"><b>Quick review</b></font></p>
    <p><font size="2">You need to consider only two FoxPro
    functions to retrieve another application's objects: <b>CreateObject</b>
    and <b>GetObject</b>. Once you have obtained the object, you
    can immediately begin to access its properties and methods.</font></p>
    <p><font size="2"><b>CreateObject</b> creates an object from
    a class definition or an OLE object. It is also used to
    create objects of built-in FoxPro or user-defined classes:</font></p>
    <p><font size="2" face="Courier New">&lt;memvar&gt; =
    CREATEOBJECT(cClassName)</font></p>
    <p><font size="2"><i>cClassName</i> specifies the OLE object
    from which the new object is created. FoxPro will search for
    the class name you specify in the following order:</font></p>
    <blockquote>
        <p><font size="2">1. Visual FoxPro base classes.</font></p>
        <p><font size="2">2. User-defined class definitions in
        memory in the order they were loaded.</font></p>
        <p><font size="2">3. Classes in the current program.</font></p>
        <p><font size="2">4. Classes in .VCX class libraries
        opened with SET CLASSLIB.</font></p>
        <p><font size="2">5. Classes in procedure files opened
        with SET PROCEDURE.</font></p>
        <p><font size="2">6. Classes in the Visual FoxPro program
        execution chain.</font></p>
        <p><font size="2">7. The Windows registry (for OLE
        objects).</font></p>
    </blockquote>
    <p><font size="2">OLE objects are created using the following
    syntax for <i>cClassName</i>:</font></p>
    <p><font size="2" face="Courier New">ApplicationName.Class</font></p>
    <p><font size="2">For example, to create a Microsoft Excel
    object using OLE Automation, use the following:</font></p>
    <p><font size="2" face="Courier New">xl =
    CREATEOBJECT(&quot;Excel.Application&quot;)</font></p>
    <p><font size="2">When this code is run, Microsoft Excel is
    started but is not visible. If Microsoft Excel is already
    running, another separate instance is created when you
    execute this command.</font></p>
    <p><font size="2"><b>GetObject</b> activates an OLE
    Automation object and creates a reference to the object. For
    example:</font></p>
    <p><font size="2" face="Courier New">GETOBJECT([cFileName [,
    cClassName]])</font></p>
    <p><font size="2"><i>cFileName</i> specifies the full path
    and filename to activate. The application does not need to be
    specified, because the OLE dynamic-link libraries (DLLs)
    determine which application to start based on the filename
    provided.</font></p>
    <p><font size="2">For example, the following code launches
    Microsoft Excel, opens a file named BUDGET.XLS, and creates a
    reference through an object memory variable named <i>xlBudget</i>:</font></p>
    <p><font size="2" face="Courier New">xlBudget =
    GETOBJECT(&quot;C:\EXCEL\WORK\BUDGET.XLS&quot;)</font></p>
    <p><font size="2"><i>cClassName</i> specifies the class name
    of the object to retrieve. Some applications can store more
    than one object type in the same file, allowing you to use
    the class name to specify the object to activate. For
    example, if a word-processing application stores its
    documents, macro definitions, and toolbar objects in the same
    file, you can create a reference to the document file with
    the following command:</font></p>
    <p><font size="2" face="Courier New">mDocFile =
    GETOBJECT(&quot;C:\WRDPROC\MYDOC.DOC&quot;,
    &quot;WrdProc.Document&quot;)</font></p>
    <p><font size="2">With some server applications, each time a <b>GetObject</b>
    function is called an additional instance of the application
    is started, which uses additional memory. For example, if
    Microsoft Excel is already running, you can prevent
    additional instances from starting by omitting <i>cFileName</i>
    and including <i>cClassName</i>, as in this example:</font></p>
    <p><font size="2" face="Courier New">xl = GETOBJECT(,
    &quot;Excel.Application&quot;)</font></p>
    <p><font size="2">If Microsoft Excel is not running, a
    trappable error will be generated. Trapping the error and
    resorting to the <b>CreateObject</b> function is a common
    technique to test if an application is already running. An
    alternative technique is to use dynamic data exchange (DDE)
    to establish a link with the server application on the System
    topic, which all DDE applications support. If the link is
    successfully established, the application is running.</font></p>
    <p><font size="3"><b>The registration database</b></font></p>
    <p><font size="2">The registration database is where FoxPro
    looks for the class name you specify with the <b>CreateObject</b>
    and <b>GetObject</b> functions. Under the Windows 3.11 and
    Windows for Workgroups 3.11 operating systems, entries into
    the registration database are stored as keys, with a
    corresponding value for each key in a tree-like structure.
    You can view the registration database with a program called
    REGEDIT.EXE, which is located in the directory where you
    installed Windows. Run REGEDIT with the <b>/V</b> option to
    see more detail.</font></p>
    <p><font size="2">Under the Windows NT and Windows 95
    operating systems, look under the HKEY_CLASSES_ROOT category
    or window to find entries for OLE Automation objects. The
    Windows NT 3.5 registration database editor was invoked by
    running the REGEDT32.EXE program with no options, as
    illustrated in the following figure.</font></p>
    <p><font size="2"><img src="Image372.gif" width="593"
    height="462"></font></p>
    <p><font size="2"><b>Windows NT registration database</b></font></p>
    <p><font size="3"><b>Object-oriented extensions in Visual
    FoxPro 3.0</b></font></p>
    <p><font size="2">One of the greatest advantages of using OLE
    Automation from within Visual FoxPro is the new
    object-oriented extensions. Because you now can create custom
    classes, and because classes serve to encapsulate both data
    and behavior, you can build classes that shield you from the
    peculiarities of a specific type of OLE server application.</font></p>
    <p><font size="2">To illustrate this, let's look at the
    differences between controlling Word and Microsoft Excel.
    Begin by developing an abstract class that defines how to
    control all OLE applications. A subclass of this class can
    then be created for each specific OLE application that you
    want to control.</font></p>
    <p><font size="2" face="Courier New">#INCLUDE
    &quot;FOXPRO.H&quot;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">DEFINE CLASS
    OLEApplication AS Custom</font></p>
    <p><font size="2" face="Courier New">PROTECTED oOLEApp, ;</font></p>
    <p><font size="2" face="Courier New">cOLERegName, ;</font></p>
    <p><font size="2" face="Courier New">lCloseAppWhenDone</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">oOLEApp = &quot;&quot;</font></p>
    <p><font size="2" face="Courier New">cOLERegName =
    &quot;&quot;</font></p>
    <p><font size="2" face="Courier New">lCloseAppWhenDone = .T.</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">*&#151; Methods</font></p>
    <p><font size="2" face="Courier New">FUNCTION Init()</font></p>
    <p><font size="2" face="Courier New">IF
    EMPTY(this.cOLERegName)</font></p>
    <p><font size="2" face="Courier New">=MESSAGEBOX(&quot;Cannot
    create object </font></p>
    <p><font size="2" face="Courier New">directly from class </font></p>
    <p><font size="2" face="Courier New">OLEApplication&quot;, ;</font></p>
    <p><font size="2" face="Courier New">MB_ICONSTOP, ;</font></p>
    <p><font size="2" face="Courier New">&quot;&quot;)</font></p>
    <p><font size="2" face="Courier New">RETURN .F.</font></p>
    <p><font size="2" face="Courier New">ENDIF</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">IF this.AppRunning()</font></p>
    <p><font size="2" face="Courier New">this.oOLEApp =
    this.GetCurrentInstance()</font></p>
    <p><font size="2" face="Courier New">ELSE</font></p>
    <p><font size="2" face="Courier New">this.oOLEApp =
    this.CreateNewInstance()</font></p>
    <p><font size="2" face="Courier New">ENDIF</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">*&#151; Additional
    methods get inserted here</font></p>
    <p><font size="2" face="Courier New">ENDDEFINE</font></p>
    <p><font size="2">This defines the core functionality of your
    abstract OLEApplication class. First check to ensure that a
    user of the class is not trying to instantiate it directly.
    If so, just cancel the INIT method, which prevents the object
    from being created. Then check to see if the application is
    running. If it is, create a reference to it. If not, create a
    new instance.</font></p>
    <p><font size="2">You need to determine if the application
    you're trying to control is currently running because certain
    applications, such as Microsoft Excel, let you create
    multiple instances, while others, such as Word, don't. Here
    are two suggestions to determine if an application is already
    running.</font></p>
    <p><font size="2">The first involves using the <b>GetObject </b>function
    to attempt to retrieve a reference to an OLE Automation
    server. At the time of this writing, this option works fine
    with Microsoft Excel, but not with Word. Override this
    function when you define a Word for Windows class, but for
    now, define this option as a protected function within your
    OLEApplication class. (You define the function as protected
    because you will only be calling this function from within
    the OLEApplication class or any class that you derive from
    it. There is no need to expose it to the &quot;outside
    world.&quot;)</font></p>
    <p><font size="2" face="Courier New">PROTECTED FUNCTION
    AppRunning()</font></p>
    <p><font size="2" face="Courier New">*&#151; Returns .T. if
    app is already running</font></p>
    <p><font size="2" face="Courier New">LOCAL lcOldError, ;</font></p>
    <p><font size="2" face="Courier New">llRunning</font></p>
    <p><font size="2" face="Courier New">llRunning = .T.</font></p>
    <p><font size="2" face="Courier New">lcOldError =
    ON(&quot;ERROR&quot;)</font></p>
    <p><font size="2" face="Courier New">ON ERROR llRunning = .F.</font></p>
    <p><font size="2" face="Courier New">*&#151; Attempt to get a
    reference to a running application</font></p>
    <p><font size="2" face="Courier New">=GETOBJECT(,
    this.cOLERegName)</font></p>
    <p><font size="2" face="Courier New">ON ERROR &amp;lcOldError</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">this.lCloseAppWhenDone =
    !llRunning</font></p>
    <p><font size="2" face="Courier New">RETURN llRunning</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="2">To complete the definition of the
    OLEApplication class, create two methods, also defined as
    protected functions, that you will use to create references
    to new instances or retrieve references to current instances.
    Notice that each method contains only one statement. You
    could eliminate the overhead of the function call and place
    the <b>CreateObject</b> and <b>GetObject</b> calls directly
    in the INIT method, but then you wouldn't be able to
    customize the behavior of these methods in your subclasses.</font></p>
    <p><font size="2" face="Courier New">PROTECTED FUNCTION
    CreateNewInstance()</font></p>
    <p><font size="2" face="Courier New">RETURN
    CREATEOBJECT(this.cOLERegName)</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">PROTECTED FUNCTION
    GetCurrentInstance()</font></p>
    <p><font size="2" face="Courier New">RETURN GETOBJECT(,
    this.cOLERegName)</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="3"><b>The Microsoft Excel class</b></font></p>
    <p><font size="2">Define your first subclass to handle OLE
    Automation with Microsoft Excel. Most of the inherited
    functionality from the OLEApplication class works just fine
    with Microsoft Excel. The first thing you need to do is
    initialize the <b>cOLERegName</b> property with the
    appropriate name of the Microsoft Excel application object as
    it appears in the registration database. Then set up a
    Destroy event method that sends the <b>Quit</b> command to
    Microsoft Excel whenever the object is being destroyed. The
    Destroy event method will fire whenever you explicitly
    release a Microsoft Excel object, or whenever the Microsoft
    Excel object goes out of scope.</font></p>
    <p><font size="2" face="Courier New">DEFINE CLASS Excel AS
    OLEApplication</font></p>
    <p><font size="2" face="Courier New">*&#151; Inherited
    properties</font></p>
    <p><font size="2" face="Courier New">cOLERegName =
    &quot;Excel.Application&quot;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">*&#151; Methods</font></p>
    <p><font size="2" face="Courier New">FUNCTION Destroy()</font></p>
    <p><font size="2" face="Courier New">IF
    TYPE(&quot;this.oOLEApp&quot;) == &quot;O&quot; AND ;</font></p>
    <p><font size="2" face="Courier New">this.lCloseAppWhenDone</font></p>
    <p><font size="2" face="Courier New">this.oOLEApp.Quit()</font></p>
    <p><font size="2" face="Courier New">ENDIF</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="2" face="Courier New">ENDDEFINE</font></p>
    <p><font size="3"><b>The Word for Windows class</b></font></p>
    <p><font size="2">The second way to determine if an
    application is already running involves the use of DDE. This
    is useful in Word because the <b>GetObject</b> function
    doesn't work properly with Word. To check if an instance is
    running, it's necessary to use DDE to attempt to establish a
    link with Word. If you are successful, you know that Word is
    running, so you immediately terminate the link.</font></p>
    <p><font size="2">In doing so, you also define a new
    implementation for the <b>GetCurrentInstance</b> method. This
    is because of Word's inability to respond to the <b>GetObject</b>
    function. To get the current instance of Word, you can safely
    use the <b>GetObject</b> function, passing an empty string as
    the first parameter.</font></p>
    <p><font size="2" face="Courier New">DEFINE CLASS WinWord AS
    OLEApplication</font></p>
    <p><font size="2" face="Courier New">*&#151; Inherited
    properties</font></p>
    <p><font size="2" face="Courier New">cOLERegName =
    &quot;Word.Basic&quot;</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">PROTECTED FUNCTION
    AppRunning()</font></p>
    <p><font size="2" face="Courier New">LOCAL lnChannel, ;</font></p>
    <p><font size="2" face="Courier New">llRunning, ;</font></p>
    <p><font size="2" face="Courier New">llDDEOldSafety</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">llDDEOldSafety =
    DDESETOPTION(&quot;Safety&quot;)</font></p>
    <p><font size="2" face="Courier New">=DDESETOPTION(&quot;Safety&quot;,
    .F.)</font></p>
    <p><font size="2" face="Courier New">lnChannel =
    DDEINITIATE(&quot;WinWord&quot;, &quot;System&quot;)</font></p>
    <p><font size="2" face="Courier New">IF lnChannel &lt;&gt; -1</font></p>
    <p><font size="2" face="Courier New">*&#151; It's running</font></p>
    <p><font size="2" face="Courier New">this.lCloseAppWhenDone =
    .F.</font></p>
    <p><font size="2" face="Courier New">=DDETERMINATE(lnChannel)</font></p>
    <p><font size="2" face="Courier New">llRunning = .T.</font></p>
    <p><font size="2" face="Courier New">ENDIF</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">=DDESETOPTION(&quot;Safety&quot;,
    llDDEOldSafety)</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">RETURN llRunning</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">PROTECTED FUNCTION
    GetCurrentInstance()</font></p>
    <p><font size="2" face="Courier New">RETURN
    GETOBJECT(&quot;&quot;, this.cOLERegName)</font></p>
    <p><font size="2" face="Courier New">ENDFUNC</font></p>
    <p><font size="2" face="Courier New"></font>&nbsp;</p>
    <p><font size="2" face="Courier New">ENDDEFINE</font></p>
    <p><font size="2">It is interesting to note that Word does
    not support creating multiple instances of itself through OLE
    Automation, while Microsoft Excel does. Using the classes
    presented here will prevent you from having to worry about
    inadvertently creating another instance of Microsoft Excel.</font></p>
    <p><font size="2">Another interesting difference between
    these two applications is that when releasing a reference to
    Word that was started through OLE Automation, the Word
    instance is automatically terminated. However, a reference to
    Microsoft Excel will not terminate in this fashion. Instead,
    we must send the Quit method to the Microsoft Excel object,
    explicitly instructing it to terminate. Furthermore,
    Microsoft Excel will terminate even if the reference to it
    was created from a previously running instance.</font></p>
    <p><font size="3"><b>Providing access to the reference</b></font></p>
    <p><font size="2">Note that the reference to the OLE
    Automation server is a protected member of the OLEApplication
    class. This means that you can only access this reference
    through methods of the class or one of its subclasses. There
    are three approaches you can take to provide access to the
    reference:</font></p>
    <blockquote>
        <p><font size="2">&#149; Unprotect the <b>oOLEApp</b>
        property. This will provide direct access to the
        reference from outside the class's methods. This is the
        most dangerous option, as you then lose control of the
        reference.</font></p>
        <p><font size="2">&#149; Create a method that simply
        returns the reference. This is somewhat less dangerous
        than the first option, but care must be taken since you
        now have two references to the same object.</font></p>
        <p><font size="2">&#149; Create custom methods to
        manipulate the protected reference. This option is
        preferred, as you maintain almost complete control over
        the reference, even though more work must be done
        initially.</font></p>
    </blockquote>
    <p><font size="3"><b>For more details</b></font></p>
    <p><font size="2">This article is based on a presentation
    made by the author at Tech&#149;Ed 95. For a more detailed
    discussion of this material, please see &quot;Using OLE in
    Microsoft Visual FoxPro&quot; by Paul Bienick in the July
    1995 release of the Microsoft Development Library.</font></p>
    <p><font size="2"><i>Paul Bienick is a software engineer at
    Flash Creative Management, a New Jersey firm specializing in
    helping companies improve business processes. He can be
    reached on CompuServe at 71510,3217.</i></font></p>
    <p><font size="5"><b>Dealing with Complex Object Models</b></font></p>
    <p><font size="2">Microsoft Excel provides more than 100
    objects, each of which has a myriad of properties and
    methods. You don't have to memorize each property and method
    to be productive with Microsoft Excel but it does help to
    become familiar with what's there.</font></p>
    <p><font size="2">A great way to learn how to use these
    properties and methods is through Visual Basic for
    Applications, which includes the Microsoft Excel built-in
    macro language. Visual Basic for Applications uses the same
    objects, properties, and methods available to FoxPro through
    OLE Automation. In fact, Visual Basic for Applications itself
    uses OLE Automation to communicate with Microsoft Excel.</font></p>
    <p><font size="2">Knowing this, you can use the macro
    recorder built into Microsoft Excel to record the
    functionality you are trying to model. The macro recorder
    generates Visual Basic code, which you can examine to see how
    various objects are being used. Granted, not every construct
    in the Visual Basic programming system is directly portable
    to FoxPro, but Visual Basic interacts with Microsoft Excel in
    much the same way as FoxPro, and the syntax when dealing with
    Microsoft Excel objects is almost identical. In many cases
    you may discover new objects or techniques.</font></p>
    <p><font size="2">Another great way to become familiar with
    an application's objects is through the command window, from
    which you can interactively create objects, set object
    properties, and call object methods.</font></p>
</blockquote>
</font></body>
</html>
