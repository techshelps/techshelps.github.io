<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template"
content="C:\MSOFFICE\WINWORD\TEMPLATE\msin60b.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Above and Beyond the Windows 95 Logo</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Above and Beyond the Windows 95 Logo</b></font></p>
    <p><font size="2">Scott Henson</font></p>
    <p><font size="2">September 12, 1995</font></p>
    <p><font size="2">You're ready to ship your new application
    to the hungry masses. You've been working hard on it and have
    diligently followed the logo requirements for the Windows 95
    operating system. What more can there possibly be?</font></p>
    <p><font size="2">Actually, there is more you can do to make
    your application a model citizen of the Windows 95 universe.
    Let's look at some ways you can tightly integrate your
    application design with Windows 95 to make the user's OBE
    (out-of-box experience) a time of exultation.</font></p>
    <p><font size="3"><b>No code need apply</b></font></p>
    <p><font size="2">There are six quick and easy things you can
    do to integrate well with the shell without writing any code.</font></p>
    <p><font size="2"><b>1.</b><b><i> Provide all appropriate
    icons</i></b>. In addition to providing an icon for your
    application, make sure you use a separate icon for every
    single file type your app understands. Keep in mind that
    extensions will be turned off by default, so users will need
    a visual cue.</font></p>
    <p><font size="2">The Windows 95 shell supports three icon
    resolutions: the familiar 16 x 16 and 32 x 32 icon
    formats&#151;which are authored in 16 colors&#151;plus a
    higher-resolution 48 x 48 format, which you should author in
    256 colors.</font></p>
    <p><font size="2">Currently there are no commercial tools
    available to author the 48 x 48 x 256 icon format, so
    Microsoft has provided a MAKEICON utility that lets you make
    these icons from bitmaps. </font></p>
    <p><font size="2"><b>2.</b><b><i> Add custom commands for
    file objects</i></b><b>.</b> Windows 95 allows users to focus
    directly on their documents and manipulate them directly from
    the shell through the selection of commands (also known as
    verbs) on pop-up and system File menus. You should provide
    users with a list of the most common commands for your
    document types. A simple (yet good) example of this is when
    you right-click an .AVI file and you get the Open and Play
    commands. A quick look in the registry (run REGEDIT.EXE for
    Windows 95 or REGEDT32.EXE for Windows NT) reveals that these
    commands have been registered under the HKEY_CLASSES_ROOT
    main key as follows:</font></p>
    <p><font size="2" face="Courier New">avifile = &quot;Video
    Clip&quot; (this is where you </font></p>
    <p><font size="2" face="Courier New">register your friendly
    name)</font></p>
    <p><font size="2" face="Courier New">shell = &quot;play&quot;
    (the default verb)</font></p>
    <p><font size="2" face="Courier New">open = &quot;Open&quot;
    (what shows up on your menu)</font></p>
    <p><font size="2" face="Courier New">command =
    &quot;c:\windows\mplayer.exe %1&quot; (what </font></p>
    <p><font size="2" face="Courier New">gets executed)</font></p>
    <p><font size="2" face="Courier New">play = &quot;Play&quot;</font></p>
    <p><font size="2" face="Courier New">command =
    &quot;c:\windows\mplayer.exe /play /close </font></p>
    <p><font size="2" face="Courier New">%1&quot;</font></p>
    <p><font size="2"><b>3.</b><b><i> Support ShellNew for
    documents. </i></b>This feature allows the user to create a
    new document without launching an application or using the
    Open/Save As commands on the File menu. This is a great
    example of the new &quot;document-centric&quot; paradigm in
    Windows 95, enabling users to concentrate more on their
    documents and less on the tool that authors them. All <b>ShellNew</b>
    entries are entered as a value in the registry under the
    HKEY_CLASSES_ROOT\<i>&lt;filename extension&gt;</i> key. For
    example, the path for a text file would be
    HKEY_CLASSES_ROOT\.txt\ShellNew.</font></p>
    <p><font size="2"><b>ShellNew</b> supports four types of
    document creation:</font></p>
    <blockquote>
        <p><font size="2">&#149; Empty File: Creates a
        zero-length file. Use <b>NullFile</b> with &quot;&quot;
        as its value</font></p>
        <p><font size="2">&#149; Data Stream: The document will
        begin with the data stream you enter. Use <b>Data</b>
        with string, binary, or DWORD values.</font></p>
        <p><font size="2">&#149; Template: Points to a document
        that is used as the standard template every time you
        create a new file from the shell. Use <b>FileName</b>
        with the value being a fully qualified path to the
        template file.</font></p>
        <p><font size="2">&#149; Command: Allows an application
        to launch when the user wants to create a new file. This
        is great for wizard support. Use <b>Command</b> with a
        value pointing to the command to be executed.</font></p>
    </blockquote>
    <p><font size="2"><b>4.</b><b><i> Support the PrintTo verb</i></b><b>.</b>
    This allows the user to drag and drop a document to any
    printer (and is a must for interoperating well with the
    faxing services in Windows 95). Consider implementing this
    feature in your application design so that no user interface
    appears (you may want to put up a Print dialog box to
    indicate progress). Here's a quick example of how .BMP files
    (Paint.Picture is the application identifier for .BMP files)
    implement the PrintTo verb:</font></p>
    <p><font size="2" face="Courier New">HKEY_CLASSES_ROOT\Paint.Picture\shell\printto\</font></p>
    <p><font size="2" face="Courier New">command =
    &quot;C:\PROGRAM FILES\ACCESSORIES\</font></p>
    <p><font size="2" face="Courier New">MSPAINT.EXE&quot; /pt
    &quot;%1&quot; &quot;%2&quot; &quot;%3&quot; &quot;%4&quot;</font></p>
    <p><font size="2"><b>5.</b><b><i> Register user-specific
    custom sound events</i></b><b>.</b> Your application can
    register specific events to which the user can assign sound
    files. To register a sound event, create a key under the
    HKEY_CURRENT_USER key. For example:</font></p>
    <p><font size="2" face="Courier New">HKEY_CURRENT_USER\AppEvents\Event
    Labels\</font></p>
    <p><font size="2" face="Courier New">EventName = Event Name</font></p>
    <p><font size="2">Set the value for <b>EventName</b> to a
    user-readable name.</font></p>
    <p><font size="2">Registering a sound event only makes it
    available in Control Panel so the user can assign a sound
    file. Your application must provide the code to process that
    event.</font></p>
    <p><font size="2"><b>6. Use OLE structured storage compound
    file format for your documents.</b> Additional property
    sheets are added to your document property page in the system
    if you use structured storage as your document format. You
    will get two new tabs, one for Summary Information and one
    for Statistics, that allow the user to add and track richer
    information on documents. Author, Keywords, Comments, Title,
    Subject, and Last Saved By are some of the attributes that
    structured storage allows to be displayed in the shell. In
    addition, summary information will show up as extended
    attributes in Microsoft Exchange.</font></p>
    <p><font size="3"><b>Do as Windows 95 does</b></font></p>
    <p><font size="2">The ultimate application for Windows 95
    will behave just as the system does&#151;not only in look and
    feel, but also in the way that operations such as drag and
    drop are performed. The key thing to concentrate on is
    leveraging users' experience with the system and not forcing
    them to relearn how to perform the same task in your
    application.</font></p>
    <p><font size="2">Here are the six key components to being
    consistent with Windows 95.</font></p>
    <p><font size="2"><b>1.</b><b><i> Display long filenames
    correctly</i></b><b>.</b> Displaying filenames correctly
    means stripping the .3 extension from the end of the
    filename, so users see names such as &quot;My Amazing
    Document&quot; instead of &quot;My Amazing
    Document.DOC&quot;.</font></p>
    <p><font size="2">Users can toggle this option in the user
    interface, so make sure you are consistent with what should
    be displayed. To get the proper display name, use the <b>SHGetFileInfo</b>
    API. This recommendation applies to all places in which you
    display filenames; make sure your most recently used (MRU)
    list reflects it. If your application is designed as a
    single-document interface (SDI),<i> make sure the document
    name is first</i>, followed by the application name.</font></p>
    <p><font size="2"><b>2.</b><b><i> Handle data transfers
    consistently with the shell</i></b><b>.</b> Keep these
    critical things in mind when transferring data around the
    shell:</font></p>
    <blockquote>
        <p><font size="2">&#149; Support OLE drag and drop
        extensively to enable users to move data to and from the
        desktop, folders, and other applications. You no longer
        need to support Windows 3.1 drag-and-drop messages in
        Windows 95. OLE does this for you. Your container should
        accept both default (using the primary mouse button) and
        nondefault (using the secondary mouse button)
        drag-and-drop operations. For a primary drag, accept a
        data object using the clipboard formats CF_HDROP (a
        double-null-terminated list of fully qualified filenames)
        and CFSTR_FILECONTENTS (the contents of one or more files
        in a format that can be written to a file). This will
        allow you to accept files from either the system or
        another application.</font></p>
        <p><font size="2">&#149; Be sure to support dragging with
        the secondary mouse button with a context menu at the
        end. If your application supports links into its
        documents, be sure to offer a link in your document on a
        drag out. This applies to drag and drops into and out of
        your container. If data is selected, include link support
        using the CF_LINKSOURCE clipboard format, as well as the
        CF_EMBEDDING format for creating a scrap.</font></p>
        <p><font size="2">&#149; Be sure the menu-based transfer
        model in your app will work well with the one in the
        shell. Test such scenarios as copying a shortcut or file
        in the system, and then pasting it into your application.</font></p>
    </blockquote>
    <p><font size="2"><b>3.</b><b><i> Use the common dialog boxes</i></b><b>,</b>
    especially for the Open and Save As commands on the File
    menu. If you use the system-supplied Open/Save As dialog
    boxes, you will get shortcuts, long filenames, and direct
    browsing of the Network Neighborhood for free. You can still
    extend the dialog boxes using dialog templates similar to
    Windows 3.1. If you don't use these templates (or if, for
    other reasons, you need to display files or the system
    hierarchy), be sure your Open/Save As dialog boxes support
    all of the following features to maintain consistency:</font></p>
    <blockquote>
        <p><font size="2">&#149; Display a name space hierarchy
        that's the same as the one in Windows 95. This means
        Desktop is the root, followed by everything on the
        desktop: My Computer, Network Neighborhood, and so on.</font></p>
        <p><font size="2">&#149; Display shortcuts (.LNK files)
        to the document type that has been chosen as the File
        Type in the dialog box. For instance, if a user wants to
        see all of the .BMP files (either by entering *.bmp as a
        file filter or by choosing Bitmap Image as the file
        type), you should display all shortcuts to .BMP files
        with the bitmap files themselves.</font></p>
        <p><font size="2">&#149; Display files with their correct
        icons and with their .3 extensions stripped (if the user
        has chosen this option).</font></p>
        <p><font size="2">&#149; Browse the Network Neighborhood
        hierarchy directly.</font></p>
        <p><font size="2">&#149; Take advantage of other
        miscellaneous features (context menus, property sheets
        with extensions, details view, and the ability to delete,
        rename, quickview, and move files).</font></p>
    </blockquote>
    <p><font size="2">This is a great deal to have to implement
    on your own, but if you still want to roll your own, Nancy
    Cluts provides a great example of using the <b>IShellFolder</b>
    API to do a lot of this in <i>Programming the Windows 95 User
    Interface</i>, available in the Development Library or from
    Microsoft Press. (Look for the ENUMDESK example in Chapter
    14.)</font></p>
    <p><font size="2">Be sure your visuals and control
    interactions are consistent with Windows 95. Users can change
    just about everything visually in Windows 95. So, here are
    the things you should pay attention to:</font></p>
    <blockquote>
        <p><font size="2">&#149; Respond to the WM_SETTINGCHANGE
        message, and query the system colors and system metrics
        by using <b>GetSysColor</b> and <b>GetSystemMetrics</b>,
        respectively. Ensure that you make no assumptions about
        the size of controls and the color of system visuals,
        especially the 3-D gray color.</font></p>
        <p><font size="2">&#149; Respond to the WM_DISPLAYCHANGE
        message (which is sent when the user changes the
        resolution of the system on the fly), and adjust your UI
        according to the amount of screen real estate available.</font></p>
        <p><font size="2">&#149; Take advantage of new
        system-supplied common controls, and use them in the same
        consistent manner as Windows 95.</font></p>
        <p><font size="2">&#149; If you're adding 256-color
        support, use the halftone palette like the shell. This
        will avoid palette hits when you switch between the shell
        and your application.</font></p>
    </blockquote>
    <p><font size="2"><b>4.</b><b><i> Maintain a consistent
    object paradigm.</i></b> This means you should use the
    document name as the primary title bar text for your
    application window. It also means that, just as the shell
    does, you should use context menus on the mouse-up of the
    secondary mouse button on controls and application content.</font></p>
    <p><font size="2">In addition, follow the new OLE UI
    guidelines. Update your OLE UI to include these items:</font></p>
    <blockquote>
        <p><font size="2">&#149; Support the new &quot;object
        properties&quot; dialog box for your embeddings.</font></p>
        <p><font size="2">&#149; Make sure your icon
        visualization for embeddings is consistent with the
        shell. When a user drags an icon from the shell into your
        container, the icon and name should be the same as it is
        in the system.</font></p>
        <p><font size="2">&#149; Make sure you support
        interactions with icon embeddings the same way the shell
        does. Icon embeddings should select like icons in the
        shell, with a highlight-color dither rather than a
        rectangle with resize handles. The OLE links icon should
        have arrow-like system shortcuts, and OLE links that are
        viewable data should get a shortcut arrow on a resize
        handle when selected.</font></p>
        <p><font size="2">&#149; Support shortcuts correctly. If
        the user opens a shortcut (even by dragging and dropping
        it onto your application), be sure to dereference it
        before opening it. There are helper member functions in
        the <b>IShellLink</b> interface. Also, be sure to
        preserve the creation and modification dates if you edit
        files by creating a temp file. Shortcuts rely on the
        creation date to reconcile a lost shortcut target. You
        can use the <b>Stat</b> and <b>StgSetTimes</b> member
        functions of the <b>IStorage</b> interface.</font></p>
    </blockquote>
    <p><font size="2"><b>5.</b><b><i> Facilitate consistent
    installation and removal</i></b> <b><i>of your application.</i></b>
    Some key points:</font></p>
    <blockquote>
        <p><font size="2">&#149; Place a single icon (shortcut)
        for your main application directly in the Start
        Menu/Programs folder so your application can be easily
        launched from the Start menu. Do not overpopulate this
        menu. Consider prompting the user during setup to choose
        which icons to add.</font></p>
        <p><font size="2">&#149; Support the AutoPlay feature by
        using the AUTORUN.INF file in your root directory so that
        the system automatically runs your installation program
        when the user inserts a CD. It's best to allow users to
        express their intentions when the CD is inserted. They
        may want to open some clip art, execute a tutorial, or
        just browse the contents. Provide a splash screen that
        allows the user to choose from all of the intended
        options and, at a minimum, to cancel.</font></p>
        <p><font size="2">&#149; Register your application
        properly according to the guidelines so that users can
        see friendly names for your document types, and so they
        can uninstall your application from the system-supplied
        Add/Remove Programs applet in Control Panel.</font></p>
        <p><font size="2">&#149; Install all of your applications
        under the Program Files directory.</font></p>
        <p><font size="2">&#149; Support uninstall (this one is
        required to get the logo).</font></p>
    </blockquote>
    <p><font size="2"><b>6.</b><b><i> Support Windows-specific
    Help features.</i></b> To be consistent with the way the new
    WinHelp works in the Windows 95 UI, applications should at
    least provide context-sensitive pop-up help for the controls
    in your dialog boxes and UI, and use secondary windows for
    procedural help. Take advantage of shortcut buttons and
    resizable topic windows to make Help shorter and easier to
    read.</font></p>
    <p><font size="3"><b>But wait, there's even more...</b></font></p>
    <p><font size="2">There's lots, lots more. For the ultimate
    in UI flexibility, there are some exciting ways to tie into
    the Windows 95 UI. These include useful shell extensions
    (property sheet handlers, icon handlers, context menu
    handlers, data handlers, drop target handlers), taskbar
    status notification icons, Passwords Control Panel
    integration, file viewers and file parsers, and briefcase
    reconcilers. Here are two excellent starting points to get
    the inside scoop:</font></p>
    <blockquote>
        <p><font size="2">&#149; <i>Programming the Windows 95
        User Interface</i> by Nancy Cluts</font></p>
        <p><font size="2">&#149; <i>The Windows Interface
        Guidelines for Software Design</i> (especially Chapter
        10, &quot;Integrating with the System&quot;)</font></p>
    </blockquote>
    <p><font size="2">But what about Windows NT? Good question.
    &quot;Extending the Windows 95 Shell&quot; by Nancy Cluts <i>(Developer
    Network News</i>, July/August 1995) outlines considerations
    for running shell extensions on Windows NT (it's good
    reading). Ultimately all of this will simply work on Windows
    NT, with no additional code needed, when the Windows 95 shell
    for Windows NT is released (sometime early next year). You
    can get a head start now with the pre-release version of the
    Windows 95 shell update for Windows NT, which is included on
    the Development Platform.</font></p>
    <p><font size="2"><i>Special thanks to Joe Belfiore, the
    program manager for the Windows 95 shell, for providing
    initial inspiration for this article (and for helping put
    together a pretty cool UI).</i></font></p>
    <p><font size="2"><i>Scott Henson works in the Developer
    Relations Group, where he spends his every waking moment
    (between noon and 3 p.m.) trying to help developers unravel
    the mysteries of writing great apps for Windows 95 and
    Windows NT.</i></font></p>
    <p><font size="2"></font>&nbsp;</p>
</blockquote>
</font></body>
</html>
