<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="doccomm" content="generated by an Aldus application">
<meta name="Template"
content="C:\MSOFFICE\WINWORD\TEMPLATE\msin60b.dot">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Visual Basic 4</title>

<meta name=href content="msdn_ie4.css">                
<style>@import url(msdn_ie4.css);</style>
<link disabled rel="stylesheet" href="msdn_ie3.css"></HEAD><basefont face="verdana,arial,helvetica" color="#000000" size=2>

<BODY bgcolor="#FFFFFF">
<font face="verdana,arial,helvetica" size="2">

<blockquote>
    <p><font size="5"><b>Visual Basic 4.0 Goes Live:
    16-Bit/32-Bit Rapid Application Development</b></font></p>
    <p><font size="2">Robert Eineigl and Randy Morgan</font></p>
    <p><font size="2">September 12, 1995</font></p>
    <p><font size="2">At last, it can be proclaimed from the Web
    sites: Visual Basic 4.0 comes to the table and raises the
    ante again!</font></p>
    <p><font size="2">The software jocks of Microsoft's Developer
    Division have given Visual Basic 4.0 full 32-bit performance,
    16-bit/32-bit source compatibility, integrated version
    control, new Windows 95 controls, and the ability to create
    and use OLE components. Visual Basic 4.0 is now poised to
    take full advantage of all 32-bit Windows platforms.</font></p>
    <p><font size="2">For the hardened veteran of too many
    vaporous claims about software, only hands-on use will
    provide the acid test. But, we hope this article will open
    over-caffeinated eyes to some of the cooler capabilities of
    Visual Basic 4.0. It will also detail remote automation
    technology, which essentially adds distributed processing
    (yes, you read that correctly!) to the Visual Basic
    developer's arsenal.</font></p>
    <p><font size="3"><b>Three versions</b></font></p>
    <p><font size="2">Visual Basic 4.0 comes in three flavors:
    Standard, Professional, and Enterprise Editions. The
    Professional Edition adds more custom controls, full
    programmatic control of the database engine, a new Crystal
    Reports writer, Windows 95 and Windows NT support, OLE
    Automation server creation, and client-server connectivity to
    the feature list of the Standard edition. The Enterprise
    Edition stacks Microsoft Visual SourceSafe version control,
    remote data objects/remote data control, and remote
    automation on top of the Professional Edition. For brevity,
    this article will assume that you will be using the
    Enterprise edition.</font></p>
    <p><font size="2">Enough introduction. On to the feature
    presentation!</font></p>
    <p><font size="3"><b>Features</b></font></p>
    <p><font size="2">Because a programming language allows
    creative and unforeseen application of its features, the
    following list doesn't presume to rank the new capabilities
    in order of importance:</font></p>
    <blockquote>
        <p><font size="2">&#149; <b>Coexistence of 16/32-bit
        versions.</b> The 16- and 32-bit versions of Visual Basic
        4.0 are completely source-code-compatible. Visual Basic
        4.0 includes 16- and 32-bit OLE versions of every VBX
        ever shipped by Microsoft (except the Pen VBX), making
        porting 16-bit apps to 32-bits a matter of recompiling,
        aside from API usage.</font></p>
        <p><font size="2">&#149; <b>Conditional compilation.</b>
        This allows parallel development on both 16- and 32-bit
        platforms. The declarations of API calls, for example,
        can be wrapped in <b>#If Win16 Then #Else #End If</b>
        syntax. Debug code can also be wrapped to exclude it from
        the final executable.</font></p>
        <p><font size="2">&#149; <b>New 32-bit Jet database
        engine.</b> Visual Basic 4.0 adds many new features to
        the Jet engine, including enhanced performance, database
        replication, and full programmatic access to all
        features.</font></p>
        <p><font size="2">&#149; <b>Add-ins.</b> The Visual Basic
        development environment itself has been exposed as an OLE
        object that can be manipulated programmatically via OLE
        Automation to enhance its extensibility. Third parties
        can create CASE tools, add menus, and modify projects
        with two-way communication between Visual Basic and
        add-in tools. Best of all, you can write your own add-ins
        in Visual Basic 4.0.</font></p>
        <p><font size="2">&#149; <b>Support for resource files.</b>
        This allows bitmaps, strings, and data to be loaded on
        demand from the resource file and produces one central
        file to modify in order to localize an application for
        international markets.</font></p>
        <p><font size="2">&#149; <b>Remote Data Objects.</b> Open
        database connectivity (ODBC)-based remote data objects
        (RDOs) give developers a programmatic interface for
        accessing data. Performance-tuned for Microsoft SQL
        Server 6.0 and Oracle7.<i>x </i>database servers, RDOs
        offer server-specific features not accessible through the
        Jet database engine in Visual Basic. RDOs provide full
        ODBC 2.5 support and require a very small memory
        footprint because they are simply a thin
        &quot;wrapper&quot; on the ODBC API. RDOs can return
        multiple result sets, control server-side cursors,
        perform asynchronous queries, limit the number of rows
        returned from a query, set the fatal error threshold, and
        access underlying ODBC handles.</font></p>
        <p><font size="2">&#149; <b>Remote data control.</b> The
        remote data control (RDC) is a new GUI interface for
        binding data-aware controls to RDOs. This leverages the
        power of bound controls for client-server development.
        New data-aware controls&#151;DB Grid, DB List, and DB
        Combo&#151;accompany the RDC. An OLE Control can now be
        bound to a data-source control, making it easy to view
        and edit stored OLE documents. This control can display
        any OLE document, such as a compound document, bitmap, or
        AVI video clip, contained in a database.</font></p>
        <p><font size="2">&#149; <b>Visual source code version
        control.</b> Visual SourceSafe is provided, fully
        integrated with the Enterprise Edition's design
        environment. Development teams can work in concert
        without having to leave the environment of Visual Basic
        4.0. Visual<i> </i>SourceSafe is a source-code
        control/configuration management system designed to
        manage multiple releases and promote code reuse while
        preventing accidental code loss or alteration. Developers
        employing other Microsoft tools can use it as a central
        development manager.</font></p>
        <p><font size="2">&#149; <b>OLE server creation.</b>
        Visual Basic 4.0 is now the easiest tool to create both
        in-process and out-of-process OLE servers. An in-process
        server is a dynamic-link library (DLL) with an OLE
        wrapper on it. That means it can be browsed with any OLE
        object browser, and is loaded and run in-process, like a
        DLL, for best performance. An out-of-process OLE server
        is an EXE that runs in its own process space but can in
        turn call in-process servers and DLLs.</font></p>
    </blockquote>
    <p><font size="2">OLE servers provide robust, encapsulated,
    binary reusability. They allow developers to create remotely
    executable OLE servers, dynamically shareable code modules,
    and libraries of commonly used forms; perform operations
    asynchronously (web agents, report generators, and so on);
    and package business rules, commonly used code libraries, and
    any legacy code into reusable, programmable OLE Automation
    servers.</font></p>
    <p><font size="3"><b>Remote automation technology</b></font></p>
    <p><font size="2">Remote automation technology provides the
    means to perform distributed processing, as promised in the
    introduction. The Enterprise Edition allows any OLE
    Automation-enabled client to call out-of-process OLE servers
    created with Visual Basic 4.0 over a network. These aren't
    loaded over the net into the calling CPU but rather utilize
    the remote computer's resources. This capability allows
    developers to take frequently changing code or business rules
    (which have traditionally been hard-coded into every client
    application) and centralize them on a remote server. This
    provides several advantages:</font></p>
    <blockquote>
        <p><font size="2">&#149; Moving code from each client
        application to a centralized server simplifies
        application maintenance and reduces administration costs.
        Remote automation servers can easily be created and
        debugged on a single computer before deploying them to
        the network.</font></p>
        <p><font size="2">&#149; Complex business rules are
        difficult to create and maintain using the SQL language.
        By creating a remote automation server and placing it in
        a three-tier architecture between the client and the
        server, developers can create and maintain business rules
        using Visual Basic instead of SQL. They can also take
        advantage of the source-code control, better debugging,
        richer math routines, and more powerful control-of-flow
        syntax of Visual Basic.</font></p>
        <p><font size="2">&#149; Remote automation allows
        developers to take advantage of often more powerful
        server computers and offload large, time-intensive and
        computationally intensive tasks to remote server
        computers, or to their neighbor's computer.</font></p>
        <p><font size="2">&#149; Any OLE Automation client
        application can easily employ servers using remote
        automation technology across all major network
        transports, including TCP/IP (think Internet!), NetBEUI,
        IPX, and named pipes.</font></p>
    </blockquote>
    <p><font size="2">Note that the OLE proxy and OLE stub handle
    the negotiation between the client and the server
    transparently. Automation Manager (AUTMGR32.EXE), a tool
    provided with the Enterprise Edition, must be running on the
    server to handle the remote procedure calls (RPCs).</font></p>
    <p><font size="3"><b>Scenarios, scenarios</b></font></p>
    <p><font size="2">Now, let's throw out a few possible
    scenarios. You can probably dream up many more of greater
    vision; when you do, please think kindly of us!</font></p>
    <p><font size="2"><b>Scenario 1: Taking stock</b></font></p>
    <p><font size="2">You are head of development at a large
    brokerage firm. (Hey, it's hypothetical; think BIG!) You
    write an OLE server for your Dual Pentium-based server that
    accepts raw feeds from a stock quote service. But the volume
    of data is more than any one broker needs to see in near
    real-time. So, you set up asynchronous, two-way communication
    between an individual broker's computer and the server
    computer. This allows a broker to subscribe to just the feeds
    she is interested in, freeing her CPU for browsing the
    pertinent information.</font></p>
    <p><font size="2"><b>Scenario 2: Hey buddy, can you lend some
    time?</b></font></p>
    <p><font size="2">You manage the IS department at a large
    mortgage company. Your problem is that you have limited
    computing resources but a large number of intensive numerical
    algorithms running on different computers throughout the day.
    There is idle CPU time available throughout the company but
    no way to distribute that power to the loan officers who need
    it.</font></p>
    <p><font size="2">Your solution is to write an OLE server
    that knows all the algorithms (in-process), and another that
    acts as the remote server (out-of-process). These servers are
    set up on every computer with enough CPU power and RAM to
    perform the calculations efficiently. When a client needs a
    calculation done, she merely starts a program on her
    computer, which calls a single centralized pool manager
    program remotely. This, in turn, assigns the task to an idle
    remote server, which calls its local DLL to process the
    calculation and return the result to the client's computer.
    Meanwhile, the client is able to use the full power of her
    CPU locally and is notified when the results are ready.</font></p>
    <p><font size="2"><b>Creating a simple remote server</b></font></p>
    <p><font size="2">Just how easy is it to create a simple
    remote server?</font></p>
    <p><font size="2">The explanation of the steps will take more
    bytes than the code. This simple example obtains the logon
    name of the user of a remote computer, through a Win32 API
    call executed on the remote computer.</font></p>
    <p><font size="3"><b>Phase One: Create the server</b></font></p>
    <p><font size="2">Create a new project (UserName) with a
    default form (Form1). Next, from the File menu, choose Remove
    File to remove Form1 since we don't need it for the server.
    From the Insert menu, add a module (Module1) and a class
    module (<b>clsUserName</b>) to your project. Now place the
    following code in the General Declarations section of
    Module1:</font></p>
    <p><font size="2" face="Courier New">Declare Function
    GetUserName Lib advapi32.dll</font></p>
    <p><font size="2" face="Courier New">Alias
    &quot;GetUserNameA&quot; (ByVal lpBuffer As </font></p>
    <p><font size="2" face="Courier New">String, nSize As Long)
    As Long</font></p>
    <p><font size="2" face="Courier New">Sub Main ()</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">The next step is to add the following code
    to the General Declarations section of <b>clsUserName</b>:</font></p>
    <p><font size="2" face="Courier New">Property Get sUserName()
    As String</font></p>
    <p><font size="2" face="Courier New">Dim lpBuffer As String *
    255</font></p>
    <p><font size="2" face="Courier New">Dim lRet As Long</font></p>
    <p><font size="2" face="Courier New">lRet =
    GetUserName(lpBuffer, 255)</font></p>
    <p><font size="2" face="Courier New">sUserName = lpBuffer</font></p>
    <p><font size="2" face="Courier New">End Property</font></p>
    <p><font size="2">In the Properties window for <b>clsUserName</b>,
    set the following properties:</font></p>
</blockquote>

<table border="0" cellpadding="7" cellspacing="0" width="301">
    <tr>
        <td width="44%"><blockquote>
            <p><font size="1"><b>Property</b></font></p>
        </blockquote>
        </td>
        <td width="56%"><blockquote>
            <p><font size="1"><b>Value</b></font></p>
        </blockquote>
        </td>
    </tr>
    <tr>
        <td width="44%"><blockquote>
            <p><font size="1">Instancing</font></p>
        </blockquote>
        </td>
        <td width="56%"><blockquote>
            <p><font size="1">2 - Creatable MultiUse</font></p>
        </blockquote>
        </td>
    </tr>
    <tr>
        <td width="44%"><blockquote>
            <p><font size="1">Public</font></p>
        </blockquote>
        </td>
        <td width="56%"><blockquote>
            <p><font size="1">True</font></p>
        </blockquote>
        </td>
    </tr>
</table>

<blockquote>
    <p><font size="2">Now, from the Tools menu, choose Options.
    In the StartMode group of the Project tab, choose OLE Server
    and SubMain For Startup Form.</font></p>
    <p><font size="2">You now have a complete, albeit elementary,
    OLE Automation server. Start the program by choosing Start
    from the Run menu or by pressing the f</font><font size="1">5</font><font
    size="2"> key and minimizing that instance of Visual Basic.</font></p>
    <p><font size="3"><b>Phase Two: Create a client to access the
    server</b></font></p>
    <p><font size="2">Start a second copy of Visual Basic. A new
    project (UseUserName) with a default form (Form1) is created.
    Add the following code to the appropriate events of the
    bGetUserName button:</font></p>
    <p><font size="2" face="Courier New">Private Sub
    bGetUserName_Click()</font></p>
    <p><font size="2" face="Courier New">Dim us As Object</font></p>
    <p><font size="2" face="Courier New">Set us =
    CreateObject(&quot;UserName.clsUserName&quot;)</font></p>
    <p><font size="2" face="Courier New">Text1 = us.sUserName</font></p>
    <p><font size="2" face="Courier New">Set us = Nothing</font></p>
    <p><font size="2" face="Courier New">End Sub</font></p>
    <p><font size="2">Now, start the program by choosing Start
    from the Run menu or by pressing the F5 key, and then click
    the bGetUserName button. The logon name should appear in the
    text box.</font></p>
    <p><font size="2">Now that you have tested it locally, to
    execute this remotely, perform the following steps:</font></p>
    <blockquote>
        <p><font size="2">1. Compile the server, using
        Tools/Options/Project to set the option button to OLE
        Server (vs. Standalone), then File/Make Exe/Options and
        check the box marked Remote Server Support Files. Close
        that instance of the Visual Basic 4.0 design environment.</font></p>
        <p><font size="2">2. Copy the .EXE to another computer
        (for simplicity, that computer should have Visual Basic
        4.0 already installed).</font></p>
        <p><font size="2">3. Start the Automation Manager
        (AUTMGR32.EXE) on that remote computer. It must be
        running for remote automation to succeed.</font></p>
    </blockquote>
    <p><font size="2">The OLE server must be registered on the
    remote server. You can do this by simply executing it once on
    the server; it registers itself when run. The registry must
    be set up before remote automation will work.</font></p>
    <p><font size="3"><b>Security</b></font></p>
    <p><font size="2">The remote automation architecture defines
    two levels of security: access control to the server (and its
    classes) and data authentication.</font></p>
    <p><font size="2">RPC data authentication refers to the level
    of data integrity guaranteed for communication between two
    computers across the network. For servers running on Windows
    NT, RPC provides seven levels of data authentication. You
    must set the authentication level from the client using the
    Remote Automation Connection Manager (or RACMan), written in
    Visual Basic 4.0 and provided with the Enterprise Edition.</font></p>
    <p><font size="2">Run RACMan on the client, select the server
    (UserName.clsUserName) from the list of OLE classes, and then
    choose the Server Connection tab. Note that there are three
    edit fields to satisfy: </font></p>
    <p><font size="2"><b>Network Address:</b> On Windows NT-based
    networks, this means simply the friendly computer name. On
    other networks and depending on which network protocol is
    used, this may mean an alphanumeric address.</font></p>
    <p><font size="2"><b>Network Protocol:</b> The protocol you
    choose for the client must be common to both client and
    server.</font></p>
    <p><font size="2"><b>Authentication Level:</b> Set this to
    Default for this example.</font></p>
    <p><font size="2">Now choose Remote from RACMan's Register
    menu and note the icon change. The client is now ready for
    remote automation. On the server box, since you have
    registered the OLE server by running it once, all that
    remains is to set the access control level for the server.</font></p>
    <p><font size="2">To do this, run RACMan on the server.
    Choose the Client Access tab and select Allow All Remote
    Creates, which enables all remote server activations. This is
    too permissive for real-world applications, but set it to
    this level just for this example. The registry on the server
    box is updated immediately.</font></p>
    <p><font size="2">Now the client running in the environment
    on your local computer will retrieve the user logon from the
    remote computer, with no change to the client code.</font></p>
    <p><font size="3"><b>Pricing and availability</b></font></p>
    <p><font size="2">Visual Basic 4.0 is scheduled to be
    available by mid-September in North America, with an
    estimated retail price of US$499 for the Professional
    Edition, and US$999 for the Enterprise Edition. Users of
    previous versions can upgrade for US$99.95 (Professional) or
    US$499 (Enterprise). For price and availability information
    outside North America, contact your local Microsoft
    subsidiary.</font></p>
    <p><font size="3"><b>Coming up...</b></font></p>
    <p><font size="2">In a future article, we'll go into greater
    depth on the issues surrounding the creation of OLE servers,
    both in-process and remote automation servers.</font></p>
    <p><font size="2"><i>Robert Eineigl works in Microsoft's
    Information Technology Group. His nocturnal interests include
    bicycle design, keyboard improvisation, and wildlife
    serenades with his custom-made trumpet. Randy Morgan is a
    strategic account engineer at Microsoft. He hikes, bikes, and
    kayaks, and his friends describe him as an adrenaline junkie.</i></font></p>
</blockquote>
</font></body>
</html>
