<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Retrieve persistent filters</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="sms_retrieve_persistent_filters_proc2"></a>Retrieve persistent filters</h3>
<p>
After a filter container is opened, it is populated with persistent filters. You can read the contents of each filter in the filter container and the tokens within each filter.</p>
<p>
There are two methods for retrieving persistent filters from a filter container:
<ul>
<li>
Retrieve filters in sequence. After a filter container is opened, the order of the filters within that particular filter container is fixed. The sequence is determined by the order of retrieval of the persistent filters. Using the <a href="sheapi_92uq.htm"><b>SmsGetNextFilter</b></a> function, your application can access the filters in the filter container sequentially. <b>SmsGetNextFilter</b> returns the handle to the next filter in the list of filters within a filter container. To start at the beginning of the list again, use the <a href="sheapi_1gx0.htm"><b>SmsRewind</b></a> to reset a filter container's internal filter index so that the filter container's filters can be reiterated.<p>
Example:
<pre><code>// Get the handles to first 30 filters in the filter container
// and put them into an array of handles.

HANDLE hFilter;
DWORD numFilters = 30;
DWORD dwI = 0;
// Allocate memory for the filter handles.
HANDLE *phFilters = (HANDLE *)malloc(numFilters * sizeof(HANDLE));

// Loop to get handles to all filters 
// and write them to the allocated array.
  // Initial value for loop.
  stat = SMS_OK;
  while(stat = SMS_OK)
  {
    // Get the next filter in the filter container.
    stat = SmsGetNextFilter( hFContainer, // Handle to filter 
                             F_MACHINE,   // For machine filters.
                             &amp;hFilter     // Assign handle to 
                                          // filter to hFilter. 
                           );

      // Check if this is the last filter in the filter container.
      // If last, break.
      if (stat == SMS_NO_MORE_DATA) {
          //last filter
          break;
      }
      // Check if there is an error retrieving the filter.
      if (stat != SMS_OK) {
          printf("Error in retrieving a filter: %d\n", stat);
          break;
      }
      // Assign the filter handle to the next handle in the array.
      phFilters[dwI] = hFilter;
      dwi++;
  }
</code></pre>
</li>
<li>
Retrieve filters by filter identifier. Using the <a href="sheapi_83ac.htm"><b>SmsGetFilterByID</b></a> function, your application can access a particular filter by its identifier. The identifier uniquely identifies the filter. The identifier is an eight-character identifier that the SMS system assigns to the persistent filter (which represents a query). Note that the default queries provided with SMS have a six-character identifier.<p>
Example:
<pre><code>// Get the "TIM00001" filter for 
// the filter container with handle hFContainer.
char *pszID = "TIM00001";
HANDLE hMyFilter;
stat = SmsGetFilterByID(hFContainer, // Handle to filter 
                                     // container.
                        F_MACHNE,    // Type is machine.
                        pszID,       // ID to retrieve.
                        &amp;hMyFilter   // Assign handle to 
                                     // hMyFilter.
                        );
</code></pre>
</li>
</ul>
<p>&nbsp;</p></body>
</HTML>
