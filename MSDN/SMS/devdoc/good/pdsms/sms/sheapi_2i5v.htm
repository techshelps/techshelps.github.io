<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Sample Decryption and Encryption Functions</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="sms_sample_decryption_and_encryption_functions"></a>Sample Decryption and Encryption Functions</h3>
<p>
This sample contains three functions that show the usage of an example decryption function, an encryption function, and a connection function that uses the decryption and encryption functions when calling <b>SmsDataSourceConnect</b>.</p>
<pre><code>// **************************************
// ConnectToSiteDatabase
// Function to make a datasource connection to
// a site database. This function prompts for
// SQL server, loginID, password, and database,
// and then calls SmsDataSourceConnect to get 
// a connection handle.

SMS_STATUS ConnectToSiteDatabase (HANDLE *phConnect)
                              // Pointer to handle to receive
                              // connection handle.
{

SMS_STATUS stat;

char *pszKey = "ABCDEFGHIJ";
    char szBuffer[100];

//Structure that specifies the site database to connect to.
DATASOURCE dsParams;
// Create string buffers for connecting to the database.
char szServer[33];
char szDb[31]; //maximum length of SQL Server database name is 30.
char szUser[31]; //maximum length of SQL Server Login ID is 30.
char szPasswd[31];

// Get database information from user and establish connection.
printf("Connect to site database.\n");

printf("SQL Server: ");
gets( szServer );

printf("Database: ");
gets( szDb );

printf("SQL Server Login ID: ");
gets( szBuffer );
// Encrypt the login ID.
Encrypt( szBuffer, szUser, pszKey );
printf("Encrypted: &lt;%s&gt;\n", szUser);

printf("Password: ");
    gets( szBuffer );
    Encrypt( szBuffer, szPasswd, pszKey );
    printf("Encrypted: &lt;%s&gt;\n", szPasswd);

// Assign connection information to dsParams structure.
// The type of database.
dsParams.sqlParams.ds          = DB_SQL;
// SQL Server name.
dsParams.sqlParams.pszServer   = szServer;
// Login ID.
dsParams.sqlParams.pszUserName = szUser;
// Password for Login ID.
dsParams.sqlParams.pszPasswd   = szPasswd;
// Name of the site database.
dsParams.sqlParams.pszDbName   = szDb;
// Pointer to encryption function.
// Callback function for decryption is Decrypt.
dsParams.sqlParams.pFunc       = Decrypt;
//Encryption key. Encryption key is specified by pszKey.
dsParams.sqlParams.pszKey      = pszKey;

// Use SmsDataSourceConnect to make a connection to the site database
// and assign the connection handle to hConnect.
stat = SmsDataSourceConnect( &amp;dsParams, phConnect );

if (stat == SMS_OK) {
    // Decrypt user name for display.
    char szPlainUser[31];
    Decrypt( szPlainUser, szUser, pszKey );
    printf("Connected to database %s on SQL Server %s as %s.\n",
            szDb, szServer, szPlainUser);
}
else {
    printf("Cannot connect to SQL Server. Error code: %d\n", stat);
}

return stat;

} /* ConnectToSiteDatabase */


// **************************************
// Encrypt
//  This function produces a 10-character encryption.
//  The key must be at least 9 characters.
//  The first byte of the encrypted string is the 
//  length of the plain text plus 1.
//  After calculating and storing that, add together the
//  values of the plain text and the key. If the 
//  plain text is shorter than the key, just 
//  use the value of the key.
//  Note that the encrypted string doesn't contain
//  a terminating NULL byte.
//  This algorithm for illustrative purposes only.

void Encrypt( const char *pszPlain, char *pszEncrypted, const char *pszKey )
{
    // Clear encrypted buffer to zeros. Buffer is 10 bytes long.
    // ---------------------------------------------------------
    memset( pszEncrypted, 0, 10 );

    // First byte is the length of the plain text plus 1.
    // --------------------------------------------------
    *pszEncrypted++ = strlen(pszPlain) + 1;
    // Fill the remaining 9 bytes with encrypted data.
    // As long as you still have plain text, add the corresponding
    // byte values of the plain text and the key.
    // When you run out of plain text, just use the key byte value.
    // -------------------------------------------------------------
    for (int i = 0; i &lt; 9; i++) {
        *pszEncrypted = *pszKey;
        if (*pszPlain != NULL) {
            *pszEncrypted += *pszPlain++;
        }
        pszEncrypted++;
        pszKey++;
    }
} /* Encrypt */


// **************************************
// Decrypt
//  This function is the decryption function for Encrypt.
//  It decrypts the encrypted string specified
//  by pszEncrypted using the key specified by pszKey.
//  The key must be at least 9 characters.

void Decrypt( char *pszPlain, char *pszEncrypted, char *pszKey )
{
    // Retrieve the length of the plain text.
    int len = *pszEncrypted++ - 1;

    // Only bother with the first 'len' bytes.
    for (int i = 0; i &lt; len; i++) {
        *pszPlain++ = *pszEncrypted++ - *pszKey++;
    }
    *pszPlain = NULL;
}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
