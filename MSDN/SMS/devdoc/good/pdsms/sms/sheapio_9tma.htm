<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Machine Filter (MACHINE_FILTER)</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h3><a name="sms_machine_filter"></a>Machine Filters (MACHINE_FILTER)</h3>
<p>
A machine filter specifies that the objects (machine folders) with the specified attributes should be retrieved.</p>
<p>
Machine filters can be applied only to the following containers: site containers, site group containers, and machine containers. If no machine filter (or other filter type) is set on a site container or machine container, all machines in the site database are retrieved for the container.</p>
<p>
Machine filters can also be stored in an SMS site database as persistent filters. Persistent machine filters are represented as queries in the SMS Administrator.</p>
<p>
Although machine filters and attribute filters both handle attributes, the two filters are used for different purposes. A machine filter specifies the attributes used to select the machine folders that will populate a container. An attribute filter specifies the criteria used to select the group folders and attribute scalars that are retrieved for each machine folder in a container.</p>
<p>
<b>Note</b>  When a machine filter is applied to a container that also has an architecture filter set, the architectures specified in the machine filter are implicitly added to the list of architectures specified in the architecture filter.</p>
<p>
Using the <a href="sheapi_6c6m.htm"><b>SmsAddToken</b></a> function, your application can add tokens to a machine filter. Each expression token represents an attribute. For machine filters, the tokens can be connected using an OP_OR or OP_AND control token.</p>
<p>
The <b>TOKEN</b> structure that contains the expression token must have the following members:
<dl>
<dt>
<b>szArchitecture</b></dt>
<dd>
A string that specifies the name of the architecture that contains the attribute to evaluate.
<p>
For example, Personal Computer.
</dd>
<dt>
<b>SzGroupClass</b></dt>
<dd>
A string that specifies the name of the group class that contains the attribute to evaluate.
<p>
For example, MICROSOFT|IDENTIFICATION|1.0.
</dd>
<dt>
<b>szAttributeName</b></dt>
<dd>
A string that specifies the name of the attribute that you want to evaluate.
<p>
For example, SMSLocation.
</dd>
<dt>
<b>DwOp</b></dt>
<dd>
A DWORD value that specifies the operator used to evaluate the expression.
<p>
The types of relational operators available depend on the data type of the attribute. The data types are numerical (integer), string, and date/time. See <a href="sheapi_0ghf.htm">Expression Token Operators</a>.
</dd>
<dt>
<b>SzValue</b></dt>
<dd>
A string that contains the value to evaluate for the specified attribute. Note that integers, dates, and times must also be specified as strings. For example, the integer 123 is specified as "123" and the date November 25, 1994 can be specified as a date format supported by Microsoft SQL Server such as "11/24/1994".
</dd>
</dl>
<p>
For example, your application could create a machine filter with a token with Personal Computer architecture and MICROSOFT|OPERATING_SYSTEM|1.0 group class with attribute Operating System Name is Microsoft Windows NT. Your application could set this filter as the only filter on a machine container. When your application populates the machine container, the container contains folders that represent all computers that have the Windows NT operating system.</p>
<h4>Example</h4>
<pre><code>// Function to add a token to a machine filter so that the 
// filter finds computers with 486 processors.
// Verifies filter handle type and prints all tokens
// set in the filter.

SMS_STATUS AddTokenToMachineFilter(HANDLE hFilter)
                              // Handle to machine filter.
{
SMS_STATUS stat;
char szTag[BUFF_SIZE];
char *pszTag = szTag;
DWORD filterType;
stat = SmsGetFilterType(
    hFilter, // Handle to filter.
    &amp;filterType, // Pointer to DWORD that will receive the filter type.
    pszTag // Pointer to string that will receive the filter tag.
    );

// If SmsGetFilterType succeeds, check that the filter
// is a MACHINE_FILTER. If not, return parameter error.
if (stat == SMS_OK) {
    if (filterType != MACHINE_FILTER) {
        printf("Invalid filter type.\n");
        return SMS_PARAMETER_ERROR;
    }
}
else {
    printf("SmsGetFilterType error: %d\n", stat);
    return stat;
}

// Create a TOKEN structure containing the criteria for finding
// the 486 processors.
TOKEN Token;
memset( &amp;Token, 0, sizeof (TOKEN) ); // Clear the Token structure.
// Set the expression token to "Processor Name is like 
// %486%".

// Set the architecture to Personal Computer.
strcpy( Token.szArchitecture, "Personal Computer");

// Set the group class to MICROSOFT|PROCESSOR|1.0.
strcpy( Token.szGroupClass, "MICROSOFT|PROCESSOR|1.0");

// Set the attribute name to "Processor Name".
strcpy( Token.szAttributeName, "Processor Name");

// Set the operator used to evaluate the expression.
// Use the string is like operator so that you get 
// all types, for example, 486SX, 486, and so on.
Token.dwOp = QOP_STR_LIKE;

// Set the value to evaulate. Use the % wildcard to
// to find any name containing 486.
strcpy( Token.szValue, "%486%"); 

// Add the token to the machine filter.
stat = SmsAddToken( hFilter, // Specifies the handle to filter.
                    OP_AND,  // Use AND control token to connect
                             // expression to adjacent expressions.
                    &amp;Token,  // Specifies the structure containing
                             // the expression token.
                    AT_END   // Add the token to the end of 
                             // the filter.
                  );

if (stat == SMS_OK)    
    printf("The token was successfully added to the filter.\n");
else {
    printf("SmsAddToken error: %d\n", stat);
    return stat;
}

// Print all tokens set in the filter.
DWORD ctTokens;
printf("The filter contains the following tokens:\n");
stat = SmsGetTokenCount( hFilter,    // Handle to filter.
                            &amp;ctTokens    // Pointer to token count.
                          );    
// If the filter contains tokens, print all tokens for the filter.
if (stat == SMS_OK) {
    for (DWORD iLoop = 0; iLoop &lt; ctTokens; iLoop++) {
       stat = SmsGetToken( hFilter, // Handle to filter.
                        iLoop,    // Index of token to retrieve.
                        &amp;Token );// Pointer to TOKEN.
           if (stat == SMS_OK)
               printf("%s\n", Token.szTokenString);
        else {
            printf("SmsGetToken error: %d\n", stat);
            return stat;
        }
    }
}
else 
    printf("SmsGetTokenCount error: %d\n", stat);

return stat;
}
</code></pre>
<p>&nbsp;</p></body>
</HTML>
