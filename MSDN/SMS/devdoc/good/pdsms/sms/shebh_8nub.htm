<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>Protocols that resolve network names</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h2><a name="sms_protocols_that_resolve_network_names"></a>Protocols That Resolve Network Names</h2>
<p>
Protocols that can identify the name of the computer sending or receiving the frame can resolve network names, but only in such a way that the friendly name is detached from the protocol. Detaching the friendly name from the protocol means that the parser adding the name is not required to know the protocols below it.</p>
<p>
For example, when the Server Message Block (SMB) parser sees a session setup with a computer name in it, it should not have to know that TCP/IP was the protocol used to transport the SMB. If the SMB parser was coded to recognize the protocol, it would have to be recoded when a new low-level protocol (such as XNS or OSI) was used to transport SMBs.</p>
<p>
The SMB parser should identify the friendly name as either a SourceFriendlyName or a DestinationFriendlyName and point only to the name, not the network identification. This allows the user interface (or some other component located above the parsing level) to associate the friendly name with the network identification address. Changing the user interface so that it understands OSI eliminates the problem of having to change the SMB parser.</p>
<p>
Two property data types (PROP_TYPE_SRCFRIENDLYNAME and PROP_TYPE_DSTFRIENDLYNAME) have been added to the property types. A property of these data types is assumed to be an array of bytes that is null terminated (a string).</p>
<p>
The following example shows how to use PROP_DST_FRIENDLYNAME:</p>
<pre><code>// We have a path name that includes a server name. Extract the server
// name and attach it as a DestinationFriendlyName.
{

    char  * pStr;
    char    szName[50];

    if ( IsUnicode )
        strncpy ( szName, szPath+2, 17 );  // copy the converted unicode 
        // string
    else
        strncpy ( szName, chptr+2, 17 );  // get at least one \ char

    // remove the last bytes.
    pStr = strchr ( szName, '\\' );
    *pStr = '\0';

    // Note that you should always deal with the friendly name as a 
    // AttachPropertyInstanceEx() instead of a AttachPropertyInstance() 
    // call. Even if the protocol has the friendly name terminated with 
    // a null, the frame might be clipped.

    AttachPropertyInstanceEx(fhandle,
                 property_table[PROP_DST_FRIENDLYNAME].hProperty,
                 0,
                 NULL,
                 16,
                 szName,
                 SMBtconX,
                 15, 0);

}
 </code></pre>
<p>&nbsp;</p></body>
</HTML>
