<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>RecognizeFrame</title>
<link disabled rel=stylesheet href=../../../backsdk3.css>
<style type="text/css">
@import url(../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>

<h1><a name="sms_recognizeframe"></a>RecognizeFrame</h1>
<p>
The <b>RecognizeFrame</b> entry point is called to quickly determine if the raw data (starting at <i>lpProtocol</i> passed in) belongs to the protocol the parser understands.</p>
<pre><code><b>LPBYTE RecognizeFrame(
  HFRAME</b><i> hFrame</i><b>,              </b>
<b>  LPBYTE</b><i> lpFrame</i><b>,             </b>
<b>  LPBYTE</b><i> lpProtocol</i><b>,          </b>
<b>  DWORD</b><i> MacType</i><b>,              </b>
<b>  DWORD</b><i> BytesLeft</i><b>,            </b>
<b>  HPROTOCOL</b><i> hPreviousProtocol</i><b>,  </b>
<b>  DWORD</b><i> nPreviousProtocolOffset</i><b>,  </b>
<b>  LPDWORD</b><i> ProtocolStatusCode</i><b>,  </b>
<b>  LPHPROTOCOL</b><i> hNextProtocol</i><b>,  </b>
<b>  LPDWORD</b><i> lpInstData          </i>
<b>);</b>
 </code></pre>
<h4>Parameters</h4>
<dl>
<dt>
<i>hFrame</i></dt>
<dd>
Specifies the handle to the frame being recognized.</dd>
<dt>
<i>lpFrame</i></dt>
<dd>
Specifies the pointer to the first byte of the whole frame.</dd>
<dt>
<i>lpProtocol</i></dt>
<dd>
Specifies the pointer to the current unclaimed portion of the frame.

<p>
<b>Note</b>  This data is probably somewhere in the middle of the frame, because a previous parser has claimed data before this parser.

</dd>
<dt>
<i>MacType</i></dt>
<dd>
Specifies a value as follows:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=48%>MacType</th>
<th align=left width=52%>Meaning</th>
</tr>
<tr valign=top>
<td width=48%>MAC_TYPE_ETHERNET</td>
<td width=52%>802.3</td>
</tr>
<tr valign=top>
<td width=48%>MAC_TYPE_TOKENRING</td>
<td width=52%>802.5</td>
</tr>
<tr valign=top>
<td width=48%>MAC_TYPE_FDDI</td>
<td width=52%>ANSI X3T9.5</td>
</tr>
</table><br>

</dd>
<dt>
<i>BytesLeft</i></dt>
<dd>
Specifies the number of bytes in the frame left to process.</dd>
<dt>
<i>hPreviousProtocol</i></dt>
<dd>
Specifies the handle of the previous protocol.</dd>
<dt>
<i>nPreviousProtocolOffset</i></dt>
<dd>
Specifies the offset of the previous protocol.</dd>
<dt>
<i>ProtocolStatusCode</i></dt>
<dd>
When a protocol parser gets called in its recognize function, it can return one of four return codes:
<table cellspacing=4 cols=2>
<tr valign=top>
<th align=left width=57%>Value</th>
<th align=left width=43%>Meaning</th>
</tr>
<tr valign=top>
<td width=57%>PROTOCOL_STATUS_RECOGNIZED</td>
<td width=43%>The parser recognized the frame and moved the pointer to the end of its protocol header. Network Monitor uses the protocol's follow set to continue parsing.</td>
</tr>
<tr valign=top>
<td width=57%>PROTOCOL_STATUS_NOT_RECOGNIZED</td>
<td width=43%>The parser did not recognize the frame and did not move the pointer (that is, the start data pointer which was passed in). Network Monitor uses the previous protocol's follow set to continue parsing.</td>
</tr>
<tr valign=top>
<td width=57%>PROTOCOL_STATUS_CLAIMED</td>
<td width=43%>The parser recognized the frame, claimed it all for itself, and parser recognition terminates.</td>
</tr>
<tr valign=top>
<td width=57%>PROTOCOL_STATUS_NEXT_PROTOCOL</td>
<td width=43%>The parser recognized the frame and moved the pointer to the end of its protocol header. The current protocol requests that Network Monitor continue parsing at a known next protocol by returning the next protocol's handle to Network Monitor. In this case, the FollowSet of the current protocol, if any, is not used.</td>
</tr>
</table><br>

</dd>
<dt>
<i>hNextProtocol</i></dt>
<dd>
The spot to return the handle of the next protocol.</dd>
<dt>
<i>lpInstData</i></dt>
<dd>
Instance data from the previous protocol, and where instance data is passed to the next protocol parser.
</dd>
</dl>
<h4>Return Values</h4>
<p>
The return value is a pointer to the next place in the frame. If the parser recognizes the frame, then it should return a pointer to the first byte beyond its recognized data. If the parser does not recognize the frame, then it should return the <i>lpProtocol</i> as passed in. If the parser wishes to claim all of the rest of the data, the parser should return NULL.</p>
<h4>Remarks</h4>
<p>
The task of <b>RecognizeFrame</b> is to as quickly as possible determine if the raw data (starting at <i>lpProtocol</i> passed in) is pointing to data that the parser recognizes as data belonging to the protocol it understands. It should not attach any properties or do any more processing beyond noting the end point of the data belonging to its protocol, or determining that no such data is present.<i> </i>A parser should not search for data beyond <i>lpProtocol</i>.</p>
<p>
<b>Note</b>  <b>RecognizeFrame</b> may still be called even if <b>Register</b> has not been called. Thus, <b>RecognizeFrame</b> should not rely on any properties or structures that are created or initialized in the <b>Register</b> entry point.</p>
<p>&nbsp;</p></body>
</HTML>
