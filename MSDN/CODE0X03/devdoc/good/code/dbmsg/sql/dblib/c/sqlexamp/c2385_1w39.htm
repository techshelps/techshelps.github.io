<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLEXAMP.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2385"></a>SQLEXAMP.C</h2>
<pre><code>/* SQLEXAMP.C - Copyright (c) 1990 - 1995 by Craig Henry.  This program may <br>** be freely distributed and copied, without charge.  However, any attempt to <br>** charge for this program will be considered a copyright infringement and <br>** will be prosecuted to the fullest extent. <br>** <br>** This program provides a simple example of logging onto a SQL Server, <br>** sending down commands, retrieving metadata, and result rows.  Formatting <br>** and printing those results on the console. <br>** <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include "stdio.h"// include standard header <br>#include "sqlfront.h"// include dblib macro/manifest defines <br>#include "sqldb.h"// include dblib datatype, prottypes, etc <br>#include "string.h"// include for string functions <br>#include "malloc.h"// include for malloc and free <br> <br> <br>// prototypes for internal functions <br>extern int DetermineRowSize(DBPROCESS *,int); <br>extern RETCODE PrintHeaders(DBPROCESS *); <br>extern RETCODE PrintRow(DBPROCESS *); <br> <br>/* <br>** DetermineRowSize(DBPROCESS *,int) <br>** <br>** This function returns either the size of all columns in the row, converted <br>** to character data (SQLCHAR) with one space between each column, or <br>** if col is non-zero, the length of the input column converted to string. <br>** It is used to build the header strings, and each row of data, and is <br>** called to allocate the memory needed for each row, and determine how <br>** much of that space is to be used for each column <br>*/ <br>int DetermineRowSize(dbproc,col) <br>DBPROCESS *dbproc;// The SQL Server connection structure <br>int col;// column size to get, 0 for all <br>{ <br>    int x,cols;// counters <br>    int length=0;// total length of column(row). <br>    int namelength;// length of name of column <br>    int prlength;// printable length <br>    char *name;// pointer to column name <br>    if(!col)        // get number of columns <br>       cols = dbnumcols(dbproc); <br>    // count from 1 to numcols if col is 0, else x will = col only <br>    for(x=((col) ? col : 1);x&lt;=((col) ? col : cols);x++) <br>    { <br>        switch(dbcoltype(dbproc,x))// get column type, determine SQLCHAR <br>        {// converted length <br>case SQLNUMERIC: <br>case SQLDECIMAL: <br>{ <br>DBCOL Col; <br>dbcolinfo(dbproc,CI_REGULAR,x,0,&amp;Col); <br>prlength = Col.Precision + 2; <br>} <br>break; <br> <br>    case SQLBIT:// The PR... values are found in the <br>        prlength = PRBIT;// SQLDB.H header file. <br>        break; <br>    case SQLINT1: <br>           prlength = PRINT1; <br>        break; <br>    case SQLINT2: <br>          prlength = PRINT2; <br>        break; <br>    case SQLINT4: <br>        prlength = PRINT4; <br>        break; <br>    case SQLFLT8: <br>        prlength = PRFLT8; <br>        break; <br>    case SQLDATETIME: <br>        prlength = PRDATETIME; <br>        break; <br>    case SQLMONEY: <br>        prlength = PRMONEY; <br>        break; <br>            case SQLVARBINARY :// VARBINARY IMAGE, and BINARY <br>            case SQLBINARY:// convert to 2 times length <br>            case SQLIMAGE: <br>                prlength = dbcollen(dbproc,x)*2; <br>                break; <br>    default : <br>        prlength = dbcollen(dbproc,x); // other types are maximum of <br>        break; // actual column length <br>        } <br>        name = (char *)dbcolname(dbproc,x); // names may be longer than <br>        namelength =  (name) ? strlen(name) : 0; // column so use name len if <br>        if(prlength&lt;namelength) // longer of two. <br>           length+=namelength+1; // add one for space between <br>        else // columns <br>           length+=prlength+1; <br>    } <br>    return length;// return the length of the <br>    // field <br>} <br>/* <br>** RETCODE PrintHeaders(DBPROCESS *) <br>** <br>** This function builds the string that contains the names of each column, <br>** and a string containing '=' as a separator line.  It does this by finding <br>** the print size of each column, allocating a buffer to hold all column names <br>** plus one space between each column name, then copying that name into the <br>** appropriate location into the buffer.  Finally the two lines are <br>** printed. <br>*/ <br>RETCODE PrintHeaders(dbproc) <br>DBPROCESS *dbproc;// The SQL Server connection structure pointer <br>{ <br>    int x,cols,size;// counters <br>    char *header;// pointer for separator buffer <br>    char *colnames;// pointer for column name buffer <br>    char *colname;// scratch pointers <br>    char *ptr,*hptr; <br>    size = DetermineRowSize(dbproc,0);// get size of buffers <br>    ptr = colnames = malloc(size+1); // get name buffer <br>    hptr = header = malloc(size+1); // get separator buf <br>    memset (header,' ',size);// set buffers to all spaces <br>    memset (colnames,' ',size); <br>    cols = dbnumcols(dbproc);// get number of columns <br>    for(x=1;x&lt;=cols;x++)// loop on all columns <br>    { <br>        size = DetermineRowSize(dbproc,x); // get size of this column <br>        colname = (char *)dbcolname(dbproc,x);// get column name <br>        strncpy(ptr,colname,strlen(colname));// copy name <br>        memset(hptr,'=',size-1);// set ='s in separator line <br>        hptr+=size;// move to next position <br>        ptr+=size;// move to next position <br>    } <br>    *ptr = '\0';// null term both strings <br>    *hptr = '\0'; <br>    printf("%s\n",colnames);// print both strings <br>    printf("%s\n",header); <br>    free(colnames);// free both buffers <br>    free(header); <br>    return SUCCEED;// done <br>} <br>/* <br>** RETCODE PrintRow(DBPROCESS *) <br>** <br>** This function prints out one row.  dbnextrow() must be called to fetch the <br>** row to print.  This routine could be used to print the current row as <br>** many times as wanted, as the current row data is always available until <br>** dbnextrow() is called to fetch the next row.  This routine works like <br>** PrintHeaders above, but each column's data is obtained instead of a row <br>** name, and converted to a string.  It is then set into the buffer. <br>*/ <br>RETCODE PrintRow(dbproc) <br>DBPROCESS *dbproc;// SQL Server connection structure <br>{ <br>    int x,cols,size,datasize,colwidth,coltype;// counters <br>    char *datavals;// data buffer pointer <br>    char *data;// column data pointer <br>    char *ptr;// scratch pointer <br> colwidth = DetermineRowSize(dbproc,0); <br>    ptr = datavals = malloc(colwidth+1); // get buffer <br>    cols = dbnumcols(dbproc);// get number of columns <br>    for(x=1;x&lt;=cols;x++)// do all columns <br>    { <br>   coltype = dbcoltype(dbproc,x); <br>        size = DetermineRowSize(dbproc,x); // determine size of this column <br>        memset(ptr,' ',size);// set it to spaces <br>        data = (char *)dbdata(dbproc,x);// get pointer to column's data <br>        if(data == (BYTE *)NULL)// if NULL, use "NULL" <br>        { <br>            strncpy(ptr,"NULL",4);// set NULL into buffer <br>            ptr += size;// point past this column in output buf <br>        } <br>        else// else have data, so convert to char <br>        { <br>            datasize = dbconvert(dbproc,coltype,data,dbdatlen(dbproc,x), <br>                SQLCHAR,ptr,(DBINT)size-1); <br>if (datasize &lt; size &amp;&amp; (coltype == SQLNUMERIC || coltype == SQLDECIMAL || coltype == SQLINT1 || <br>    coltype == SQLINT2 || coltype == SQLINT4 || coltype == SQLFLT8 || coltype == SQLFLT4)) <br>{ <br>memmove(ptr+size-1-datasize,ptr,datasize); <br>memset(ptr,' ',size-1-datasize); <br>} <br>            ptr+=size; <br>        } <br>    } <br>    *ptr = '\0';// null term string <br>    printf("%s\n",datavals);// print row <br>    free(datavals);// free buffer <br>    return SUCCEED;// done <br>} <br> <br>/* <br>** <br>** The below main is a mini isql interpreter and as such is only <br>** used for demonstration purposes.  Command line args include the Server <br>** name as arg 1, User ID as arg 2, assumes the password is null. <br>** This routine requests opens the connection after obtaining the login record <br>** and filling it with the necessary info.  Once the connection is established <br>** it accpets command input, set's it into the dbproc.  On "go" it executes <br>** the command against the server, processes each results set and then returns <br>** to accepting command input.  If "quit" or "exit" is input the program <br>** is terminated.  This interpreter will not process COMPUTE statements, <br>** and will not work with commands that return text/image data. <br>*/ <br>int main(argc, argv) <br>int argc; <br>char *argv[]; <br>{ <br>    LOGINREC *login;// login rec pointer <br>    DBPROCESS *dbproc;// SQL Server connection structure pointer <br> <br>    char cmd[150];// command buffer <br>    char server[30];// server name buffer <br>    int x=1;// command line counter <br>    STATUS retc;// return code <br>    const char * sqlversion;// pointer for version string <br>    int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>    int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br>    *server = '\0';// null start these two buffers <br>    *cmd = '\0'; <br> <br>    if(argc == 1)// if no server name, request it <br>    { <br>printf("Enter Server Name: "); <br>gets(server); <br>    } <br>    else// else it was input as first arg <br>       strcpy(server,argv[1]); <br>    if(argc &lt; 2)// if no login id, request it <br>    { <br>       printf("Enter User Name: "); <br>       gets(cmd); <br>    } <br>    else// otherwise it was input as second arg. <br>       strcpy(cmd,argv[2]); <br> <br>    // check to see if communications layer was loaded (DOS ONLY) <br>    if((sqlversion = dbinit()) == (BYTE *)NULL) <br>    { <br>       // DOS TSR (DBNMPIPE.EXE) is not loaded, don't bother going any farther <br>       printf("Error in DB-Library initialization, exiting\n"); <br>       return 1; <br>    } <br>    else <br>       printf("DB-Library version: %s\n",sqlversion); // print dblib version <br> <br>    dbsettime(30);// set timeouts to 30 seconds <br>     <br>    // set error/msg handlers for this program <br>    dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>    dberrhandle((DBERRHANDLE_PROC)err_handler); <br>     <br>    login = dblogin();// get a login rec <br> <br>    DBSETLUSER(login,cmd);// set login id <br>    DBSETLHOST(login,"SQL EXAMPLE");// set host name for sp_who <br>    DBSETLVERSION(login, DBVER60); <br> <br>    // open connection to requested server.  Pass null server name for local <br>    // connection, if name not entered. <br>    if((dbproc = dbopen(login,(*server) ? server : (char *)NULL)) == (DBPROCESS *)NULL) <br>    { <br>        // no one answered, so couldn't connect or error occurred <br>printf("Login failed\n"); <br>return 1; <br>    } <br>    else <br>    { <br>        // loop on command input until quit or exit appears in first 4 bytes. <br>while((strnicmp(cmd,"quit",4) != 0) &amp;&amp; (strnicmp(cmd,"exit",4)!=0)) <br>{ <br>   printf("%d&gt; ",x++);// print command prompt <br>   gets(cmd);// get command <br>   if(strnicmp(cmd,"go",2) == 0)// is it go <br>   { <br>      if(dbsqlexec(dbproc) == FAIL)// execute command <br>              { <br>                 // problem occurred, just try another command <br>                 printf("Error in executing command batch!\n"); <br>                 x = 1; <br>                 continue; <br>              } <br>              // command executed correctly, get results information <br>      while((retc = dbresults(dbproc)) != NO_MORE_RESULTS) <br>      { <br> if (retc == FAIL)// if error get out of loop <br>     break; <br> // headers and data could be printed here with only two <br>                 // function calls, dbprhead(dbproc), and dbprrow(dbproc), <br>                 // which would output the headers, and all the data to <br>                 // standard output.  However, that isn't very informative <br>                 // toward understanding how this data is obtained and <br>                 // processed, so I do it the hard way, one column at a time. <br> <br>                 PrintHeaders(dbproc);// print header data <br> <br>                 // loop on each row, until all read <br>                 while((retc= dbnextrow(dbproc))!=NO_MORE_ROWS) <br>                 { <br>                    if(retc == FAIL)// if fail, then clear <br>                    {// connection completely, just <br>                       dbcancel(dbproc);// in case. <br>                       break; <br>                    } <br>                    else <br>                        PrintRow(dbproc);// else print the current row <br>                 } <br> if(DBCOUNT(dbproc) == 1L)// print the row count <br>      printf("(1 row effected)\n"); <br>  else <br>      printf("(%ld rows effected)\n",DBCOUNT(dbproc)); <br> <br>      } // end while(dbresults()) <br> <br>              x = 1;// reset command line counter <br>   } <br>   else <br>   { <br>      strcat(cmd," ");// go not detected, so put space <br>      dbcmd(dbproc,cmd);// between each command and set in <br>   }// dbproc. <br> <br>        } // end while() <br> <br>        dbclose(dbproc);// quit/exit input, close connection <br> <br>        // print adios and exit. <br>        printf("SQL Server Connection to %s closed, bye bye.\n",server); <br>return 0; <br>     } <br>} <br>/* <br>** msg_handler(char *buffer, long len); <br>** <br>** This routine is a local isql message handler call back function that <br>** is invoked whenever the SQL Server is sending a message back to <br>** the program. <br>** <br>*/ <br>int msg_handler(dbproc, Msg, State, Severity, Message) <br>DBPROCESS *dbproc;// SQL Server connection structure <br>DBINT Msg;// SQL Server message number <br>int State;// State of the message <br>int Severity;// Severity of the message <br>char *Message;// The message itself (read only) <br>{ <br>    printf("Message No.: %ld, Msg. State: %d, Msg. Severity: %d\n", <br>Msg,State,Severity); <br>    if(Message != NULL) <br>       printf("%s\n",Message); <br>    return (0); <br>} <br> <br>/* <br>** err_handler(char *buffer, long len); <br>** <br>** This routine is a local error handler called by dblib if an internal <br>** error occurs, also to notify when a server message has been sent, which is <br>** obtained through the above message handler. <br>** <br>*/ <br>int err_handler(dbproc, Severity,dberr, oserr, errstr, oserrstr) <br>DBPROCESS *dbproc;// SQL Server connection structure <br>int Severity;// Severity of Dblib error <br>int dberr;// dblib error, all dblib errors start at 10000 <br>int oserr;// OS error from, C runtime <br>char *errstr;// dblib error string <br>char *oserrstr;// OS error string (if any) <br>{ <br> <br>    printf("DB-LIBRARY Error - Severity: %d, Error No: %d, OS Error No: %d\n", <br>       Severity, dberr, oserr); <br>    if(errstr != NULL) <br>       printf("%s\n",errstr); <br>    if(oserrstr != NULL) <br>       printf("%s\n",oserrstr); <br>    return INT_CANCEL; <br>} <br> <br>/*****************************************************************************/ <br>/*======================== E N D - O F - F I L E ============================*/ <br>/*****************************************************************************/ <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
