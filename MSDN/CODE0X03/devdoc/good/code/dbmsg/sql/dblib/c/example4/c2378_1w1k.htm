<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXAMPLE4.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2378"></a>EXAMPLE4.C</h2>
<pre><code>/*example4.c */ <br>/* <br>** This example accesses the data within each row without using dbbind() <br>** and illustrates the use of row buffering. <br>** <br>** It runs a query, saves all of the returned rows (up to a maximum <br>** of 100) using DB-LIBRARY row buffering, and allows the user to <br>** examine data rows at random. <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>DBPROCESS*dbproc;/* Our connection with SQL Server. */ <br>LOGINREC*login;/* Our login information. */ <br> <br>#define TYPELEN 2 <br>#define DATELEN 25 <br> <br>/* Forward declarations of the error handler and message handler. <br>*/ <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br>main(argc, argv) <br>intargc; <br>char*argv[]; <br>{ <br>/* Here are the variables which will be used to store the <br>* data being examined. <br>*/ <br>DBCHARname[MAXNAME+1];/* MAXNAME is defined in <br>* "sqldb.h" as the maximum <br>* length for names of database <br>* objects, such as tables, <br>* columns, and procedures. <br>*/ <br>DBCHARtype[TYPELEN+1]; <br>DBINTid; <br> <br>DBCHARdatebuf[64]; <br>DBINTlen; <br>charnumstring[32]; <br>intquitflag = 0; <br>RETCODErow_code; <br>DBINTrownum; <br> <br>        dbinit();/* initialize dblib */ <br> <br>/* Install the user-supplied error-handling and message-handling <br>* functions. They are defined at the bottom of this source file. <br>*/ <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br>/* <br>** Get a LOGINREC structure and fill it with the necessary <br>** login information. <br>*/ <br> <br>login = dblogin(); <br>DBSETLUSER (login, "user"); <br>DBSETLPWD(login, "my_passwd"); <br>DBSETLAPP(login, "example4"); <br>DBSETLVERSION(login, DBVER60); <br> <br>dbproc = dbopen(login, "my_server"); <br>dbcmd(dbproc, "select name, type, id, crdate from sysobjects"); <br>dbcmd(dbproc, " where type = 'S'"); <br> <br>/* <br>        ** Set row buffering to 100 rows, via dbsetopt(). <br>** Note that this parameter must be passed as an ASCII string. <br>*/ <br> <br>dbsetopt(dbproc, DBBUFFER, "100"); <br>dbsqlexec(dbproc); <br>if (dbresults(dbproc) == SUCCEED) <br>{ <br>/* Read all of the rows into DB-LIBRARY's buffer */ <br>while ((row_code = dbnextrow(dbproc)) != NO_MORE_ROWS) <br>{ <br>/* If DB-LIBRARY's row buffer is full, throw <br>* away the oldest row to allow the newest <br>* row to be read in. <br>*/ <br>if (row_code == BUF_FULL) <br>dbclrbuf(dbproc, (DBINT) 1); <br>} <br> <br>/* Print out the column headers. */ <br> <br>puts("NAME                 TYPE DATE                   ID"); <br>puts("-------------------- ---- ---------------------- ----"); <br> <br> <br>/* Let the user view any row in the table. */ <br> <br>printf("Type the number of the row you want to see.\n"); <br>printf("The first row is number 1.\n"); <br>printf("Asking for row 0 will terminate the program.\n"); <br> <br>while (quitflag == 0) <br>{ <br>printf("Row number: "); <br>gets(numstring); <br>rownum = atoi(numstring); <br> <br>if (rownum == 0) <br>quitflag = 1; <br>else <br>{ <br>/* Print out the requested row. */ <br>if (dbgetrow(dbproc, rownum) == NO_MORE_ROWS) <br>printf <br>("That row is not in the table.\n"); <br>else <br>{ <br>/* Copy variable-length character data <br>* (colname). <br>*/ <br> <br>strncpy <br>(name, (DBCHAR *)dbdata(dbproc, 1), <br>(len = dbdatlen(dbproc, 1))); <br> <br>/* String needs terminating null. */ <br> <br>name[len] = '\0'; <br> <br>/* Copy fixed-length character data. */ <br> <br>strncpy <br>(type, (DBCHAR *)dbdata(dbproc, 2), <br>(len = dbdatlen(dbproc, 2))); <br>type[len] = '\0'; <br> <br>/* Copy integer data. */ <br>id = *((DBINT *)dbdata(dbproc, 3)); <br> <br>/* Convert datetime data to a printable <br>* string. <br>*/ <br> <br>dbconvert(dbproc, SQLDATETIME, (dbdata(dbproc, 4)), <br>(DBINT)-1, SQLCHAR, datebuf, (DBINT)-1); <br> <br> <br>printf("%-20s %-4s %-22s %-4ld \n", <br>name, type, datebuf, id); <br>} <br>} <br>} <br>} <br> <br>dbexit(); <br>return(STDEXIT); <br>} <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br>    printf("DB-LIBRARY error:\n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf("Operating-system error:\n\t%s\n", oserrstr); <br> <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return(INT_EXIT); <br> <br>return(INT_CANCEL); <br>} <br> <br>int msg_handler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br>printf <br>("SQL Server message %ld, state %d, severity %d:\n\t%s\n", <br>msgno, msgstate, severity, msgtext); <br>return(0); <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
