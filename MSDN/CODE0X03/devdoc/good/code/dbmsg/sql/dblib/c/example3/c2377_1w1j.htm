<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXAMPLE3.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2377"></a>EXAMPLE3.C</h2>
<pre><code>/*example3.c */ <br>/* <br>** This example selects some information from the "pubs" database. <br>** It illustrates binding of both aggregate and compute results. <br>** <br>** Note that this example only work if the "pubs" database exists <br>** on your SQL Server. <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>#define PLEN 4 <br>#define DATEPRINT 26 <br>#define MONEYPRINT 12 <br> <br>/* Forward declarations of the error handler and message handler. <br>*/ <br>interr_handler(); <br>intmsg_handler(); <br> <br>main(argc,argv) <br>intargc; <br>char*argv[]; <br>{ <br>LOGINREC*login; <br>DBPROCESS*dbproc; <br> <br>/* Declare the datatypes for the columns in the table "titles". */ <br>DBINTpcount; <br>DBINTsales; <br>DBINTsalesavg; <br>DBINTsumsale; <br>DBCHARdate[DATEPRINT+1]; <br>DBCHARprice[MONEYPRINT+1]; <br>DBCHARpriceavg[MONEYPRINT+1]; <br>DBCHARpubid[PLEN+1]; <br>RETCODEresult_code; /* to hold the results of dbresults(). */ <br>STATUSrow_code;/* to hold the results of dbnextrow(). */ <br> <br>        dbinit();/* initialize dblib */ <br> <br> <br>/* Install the user-supplied error-handling and message-handling <br>* functions. They are defined at the bottom of this source file. <br>*/ <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br>/* Set up the login information. */ <br> <br>login = dblogin(); <br>DBSETLUSER(login, "user"); <br>DBSETLPWD(login, "my_passwd"); <br>DBSETLAPP(login, "example3"); <br>DBSETLVERSION(login, DBVER60); <br> <br>dbproc = dbopen(login, "my_server"); <br> <br>/* Send a "use database" command. */ <br>dbuse(dbproc,"pubs"); <br> <br>/* Put the SQL statement into the command buffer. */ <br>dbcmd(dbproc, "select pub_id, pubdate, price, avg(price), ytd_sales,"); <br>dbcmd(dbproc, " avg(ytd_sales), sum(ytd_sales) from titles"); <br>        dbcmd(dbproc, " group by pub_id, pubdate, price, ytd_sales"); <br>dbcmd(dbproc, " order by pub_id"); <br>dbcmd(dbproc, " compute count(pub_id) by pub_id"); <br> <br>/* Send the command buffer to SQL Server for execution. */ <br>dbsqlexec(dbproc); <br> <br>/* <br>** Using the aggregates "sum" and "avg" with the COMPUTE clause <br>** necessitates special handling when binding the results. Since each <br>** aggregate creates a new column, this is accounted for in the bind. <br>** Notice that avg(price) is the fourth column in the select list <br>** and is also specified as the fourth column in the dbbind() function. <br>** <br>** The COMPUTE clause creates a compute row, which requires a <br>** special bind function called dbaltbind(). <br>*/ <br> <br>while ((result_code = dbresults(dbproc)) != NO_MORE_RESULTS) <br>{ <br>if (result_code == SUCCEED) <br>{ <br>dbbind(dbproc,1,NTBSTRINGBIND, (DBINT) 0,pubid); <br>dbbind(dbproc,2,NTBSTRINGBIND, (DBINT) 0,date); <br>dbbind(dbproc,3,NTBSTRINGBIND, (DBINT) 0,price); <br>dbbind(dbproc,4,NTBSTRINGBIND, (DBINT) 0,priceavg); <br>dbbind(dbproc,5,INTBIND, (DBINT) 0, (BYTE *) &amp;sales); <br>dbbind(dbproc,6,INTBIND, (DBINT) 0, (BYTE *) &amp;salesavg); <br>dbbind(dbproc,7,INTBIND, (DBINT) 0, (BYTE *) &amp;sumsale); <br> <br>/* dbaltbind() binds compute columns. */ <br>dbaltbind(dbproc,1,1,INTBIND,(DBINT) 0,(BYTE *)&amp;pcount); <br> <br>printf("\nAccounts:\n"); <br>printf("---------\n\n"); <br>printf <br>("%-5s%-19s%-6s%-10s%-5s%-10s%-10s\n\n", <br>"pubid", "date", "price", "avg(price)", <br>"sales", "avg(sales)", "sum(sales)"); <br> <br>/* <br>** Print out each result row, using different statements <br>** depending on whether the row is a regular row or a <br>** compute row. <br>*/ <br> <br>while ((row_code = dbnextrow(dbproc)) != NO_MORE_ROWS) <br>{ <br>if (row_code == REG_ROW) <br>{ <br>printf <br>("%5s%19s%6s%10s%5ld%10ld%10ld\n", <br>pubid, date, price, priceavg, sales, <br>salesavg, sumsale); <br>} <br>else <br>printf("title count:%ld\n\n",pcount); <br>} <br>} <br>} <br> <br>dbexit(); <br>return(STDEXIT); <br>} <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br>    printf("DB-LIBRARY error:\n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf("Operating-system error:\n\t%s\n", oserrstr); <br> <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return(INT_EXIT); <br> <br>return(INT_CANCEL); <br>} <br> <br>int msg_handler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br>printf <br>("SQL Server message %ld, state %d, severity %d:\n\t%s\n", <br>msgno, msgstate, severity, msgtext); <br>return(0); <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
