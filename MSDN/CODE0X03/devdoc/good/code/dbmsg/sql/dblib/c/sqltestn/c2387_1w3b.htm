<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLTESTN.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2387"></a>SQLTESTN.C</h2>
<pre><code>/**************************************************************************** <br> <br>PROGRAM: SqlTestn.c <br>Copyright 1995 - 1998 Microsoft Corp. <br> <br>PURPOSE: SqlTest sample Windows applications <br> <br>FUNCTIONS: <br> <br>WinMain() - calls initialization function, processes message loop <br>SqlTestInit() - initializes window data and registers window <br>SqlTestWndProc() - processes messages <br>AboutSQL() - processes messages for "About" dialog box <br>SelectSQL() - processes input of author name <br>ConnectSQL() - processes input of server name and connects to server <br> <br>COMMENTS: <br> <br>WIN32 can have several copies of your application running at the <br>same time.  The variable hInst keeps track of which instance this <br>application is so that processing will be to the correct window. <br> <br>You only need to initialize the application once.  After it is <br>initialized, all other copies of the application will use the same <br>window class, and do not need to be separately initialized. <br> <br>****************************************************************************/ <br> <br>#include "windows.h"      /* required for all NT Windows applications*/ <br>#include "stdio.h" <br>#define DBNTWIN32         /* needed to define environment     */ <br>#include "sqlfront.h"     /* standard dblib include file    */ <br>#include "sqldb.h"        /* standard dblib include file    */ <br>#include "sqltestn.h"     /* specific to this program    */ <br> <br>PDBPROCESS dbproc = (PDBPROCESS)NULL; <br>              /* dbprocess pointer for dblib connection*/ <br>HINSTANCE hInst;    /* current instance    */ <br>HWND ghWnd;      /* global window handle for handlers    */ <br>HWND errhWnd;    /* global window handle for current error*/ <br> <br>/**************************************************************************** <br> <br>FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int) <br> <br>PURPOSE: calls initialization function, processes message loop <br> <br>COMMENTS: <br> <br>This will initialize the window class if it is the first time this <br>application is run.  It then creates the window, and processes the <br>message loop until a PostQuitMessage is received.  It exits the <br>application by returning the value passed by the PostQuitMessage. <br> <br>****************************************************************************/ <br> <br>int PASCAL WinMain(hInstance, hPrevInstance, lpCmdLine, nCmdShow) <br>HINSTANCE hInstance;     /* current instance     */ <br>HINSTANCE hPrevInstance;     /* previous instance     */ <br>LPSTR lpCmdLine;     /* command line     */ <br>int nCmdShow;     /* show-window type (open/icon) */ <br>{ <br>HWND hWnd;     /* window handle     */ <br>MSG msg;     /* message     */ <br> <br> <br>if (!hPrevInstance)/* Has application been initialized? */ <br>if (!SqlTestInit(hInstance)) <br>return (0);/* Exits if unable to initialize     */ <br> <br>hInst = hInstance;/* Saves the current instance     */ <br> <br>hWnd = CreateWindow("SQL Test",               /* window class     */ <br>"SQL Server Sample Windows NT Application", /* window name     */ <br>WS_OVERLAPPEDWINDOW|WS_VISIBLE,            /* window style     */ <br>CW_USEDEFAULT,                             /* x position     */ <br>CW_USEDEFAULT,                             /* y position     */ <br>CW_USEDEFAULT,                             /* width     */ <br>CW_USEDEFAULT,                             /* height     */ <br>NULL,                                      /* parent handle     */ <br>NULL,                                      /* menu or child ID     */ <br>hInstance,                                 /* instance     */ <br>NULL);                                     /* additional info     */ <br> <br>if (!hWnd)  /* Was the window created? */ <br>return (0); <br> <br>ghWnd = hWnd;  /* set global handle     */ <br>errhWnd = hWnd; <br> <br>ShowWindow(hWnd, SW_SHOW); /* Shows the window        */ <br>UpdateWindow(hWnd);        /* Sends WM_PAINT message  */ <br> <br>while (GetMessage(&amp;msg, /* message structure */ <br>NULL,      /* handle of window receiving the message */ <br>0,             /* lowest message to examine */ <br>0))            /* highest message to examine*/ <br>{ <br>TranslateMessage(&amp;msg);   /* Translates virtual key codes     */ <br>DispatchMessage(&amp;msg);   /* Dispatches message to window     */ <br>} <br>return (msg.wParam);   /* Returns the value from PostQuitMessage */ <br>} <br> <br> <br>/**************************************************************************** <br> <br>FUNCTION: SqlTestInit(HANDLE) <br> <br>PURPOSE: Initializes window data and registers window class <br> <br>COMMENTS: <br> <br>Sets up a structure to register the window class.  Structure includes <br>such information as what function will process messages, what cursor <br>and icon to use, etc. <br> <br>****************************************************************************/ <br> <br>BOOL SqlTestInit(hInstance) <br>HANDLE hInstance;       /* current instance     */ <br>{ <br>HANDLE hMemory;       /* handle to allocated memory */ <br>PWNDCLASS pWndClass;       /* structure pointer     */ <br>BOOL bSuccess;       /* RegisterClass() result     */ <br> <br>hMemory = LocalAlloc(LPTR, sizeof(WNDCLASS)); <br>pWndClass = (PWNDCLASS)hMemory; <br> <br>pWndClass-&gt;style = 0; /*CS_HREDRAW | CS_VREDRAW; */ <br>pWndClass-&gt;lpfnWndProc = (WNDPROC)SqlTestWndProc; <br>pWndClass-&gt;hInstance = hInstance; <br>pWndClass-&gt;hIcon = LoadIcon(hInstance, "SQLITEST"); <br>pWndClass-&gt;hCursor = LoadCursor(NULL, IDC_ARROW); <br>pWndClass-&gt;hbrBackground = GetStockObject(WHITE_BRUSH); <br>pWndClass-&gt;lpszMenuName = (LPSTR)"SQLTest"; <br>pWndClass-&gt;lpszClassName = (LPSTR)"SQL Test"; <br> <br>bSuccess = RegisterClass(pWndClass); <br> <br>LocalFree(hMemory);    /* Returns it to NT */ <br>return (bSuccess); /* Returns result of registering the window */ <br>} <br> <br>/**************************************************************************** <br> <br>FUNCTION: SqlTestWndProc(HWND, unsigned, WORD, LONG) <br> <br>PURPOSE:  Processes messages <br> <br>MESSAGES: <br> <br>WM_SYSCOMMAND - system menu (About dialog box) <br>WM_CREATE     - create window <br>WM_DESTROY    - destroy window <br>WM_COMMAND    - application menus (Connect and Select dialog boxes <br> <br>COMMENTS: <br> <br>To process the ID_ABOUTSQL message. Call Dialog <br>box which will create the box according to the information in your <br>SqlTest.rc file and turn control over to the About() function.When <br>it returns, free the intance address. <br>This same action will take place for the two menu items Connect and <br>Select. <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY SqlTestWndProc(hWnd, message, wParam, lParam) <br>HWND hWnd;  /* window handle     */ <br>UINT message;          /* type of message     */ <br>DWORD wParam;  /* additional information     */ <br>LONG lParam;  /* additional information     */ <br>{ <br>  /* functions      */ <br>HMENU hMenu;  /* handle to the System menu     */ <br> <br>switch (message) <br>{ <br>case WM_SYSCOMMAND:/* message: command from system menu */ <br>if (wParam == ID_ABOUTSQL) <br>{ <br>DialogBox(hInst, /* current instance     */ <br>(LPTSTR)"ABOUTSQL", /* resource to use     */ <br>hWnd, /* parent handle     */ <br>(DLGPROC) AboutSQL); /* About() instance address */ <br> <br>break; <br>} <br>else    /* Lets NT process it     */ <br>return (DefWindowProc(hWnd, message, wParam, lParam)); <br> <br>case WM_CREATE:    /* message: window being created */ <br> <br>/* Get the handle of the System menu */ <br>hMenu = GetSystemMenu(hWnd, FALSE); <br> <br>/* Add a separator to the menu */ <br>AppendMenu(hMenu,      /* menu handle     */ <br>MF_SEPARATOR,      /* menu item to change */ <br>0,      /* new menu item     */ <br>0);      /* menu identifier     */ <br> <br>/* Add new menu item to the System menu */ <br>      AppendMenu(hMenu,      /* menu handle     */ <br>MF_STRING,      /* menu item to change */ <br>ID_ABOUTSQL,      /* menu identifier     */ <br>"A&amp;bout SQL Test...");      /* new menu item     */ <br> <br>dbinit();                                 /* initialize dblib    */ <br> <br>/* Now make the message and error    */ <br>/* Install the handler into dblib */ <br>dberrhandle((DBERRHANDLE_PROC)dbwinErrorHandler); <br>dbmsghandle((DBMSGHANDLE_PROC)dbwinMessageHandler); <br>break; <br> <br>case WM_COMMAND :/* menu selections generate */ <br> <br>/* the WM_COMMAND message   */ <br>switch(wParam)/* menu in WORD parameter   */ <br>{ <br>case IDM_CONNECT :/* connect to server    */ <br>DialogBox(hInst,/* current instance     */ <br>"CONNECT", /* resource to use     */ <br>hWnd,/* parent handle     */ <br>(DLGPROC) ConnectSQL); /* ConnectSQL() instance address */ <br> <br>break; <br> <br>case IDM_SELECT :/* select an author    */ <br> <br>DialogBox(hInst, /* current instance     */ <br>"SELECT", /* resource to use     */ <br>hWnd, /* parent handle     */ <br>(DLGPROC) SelectSQL); /* About() instance address */ <br> <br>break; <br>} <br>break; <br> <br>case WM_DBRESULTS :/* a select has been issued */ <br>SqlTestProcessResults(hWnd);/* process results    */ <br>break; <br> <br>case WM_DESTROY:  /* message: window being destroyed */ <br>dbexit();  /* free any active dbprocesses     */ <br>PostQuitMessage(0); <br>break; <br> <br>default:  /* Passes it on if unproccessed    */ <br>return (DefWindowProc(hWnd, message, wParam, lParam)); <br>} <br> <br>return (0L); <br>} <br> <br> <br>/**************************************************************************** <br> <br>FUNCTION: AboutSQL(HWND, unsigned, WORD, LONG) <br> <br>PURPOSE:  Processes messages for "AboutSQL" dialog box <br> <br>MESSAGES: <br> <br>WM_INITDIALOG - initialize dialog box <br>WM_COMMAND    - Input received <br> <br>COMMENTS: <br> <br>No initialization is needed for this particular dialog box, but TRUE <br>must be returned to NT. <br> <br>Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY AboutSQL(hDlg, message, wParam, lParam) <br>HWND hDlg; <br>UINT message; <br>DWORD wParam; <br>LONG lParam; <br>{ <br>switch (message) <br>{ <br>case WM_INITDIALOG:   /* message: initialize dialog box */ <br>return (TRUE); <br> <br>case WM_COMMAND:      /* message: received a command */ <br>if (wParam == IDOK) <br>{      /* "OK" box selected?     */ <br>EndDialog(hDlg, 0);      /* Exits the dialog box     */ <br>return (TRUE); <br>} <br>break; <br>} <br>return (FALSE);      /* Didn't process a message    */ <br>} <br>/**************************************************************************** <br> <br>FUNCTION: SelectSQL(HWND, unsigned, WORD, LONG) <br> <br>PURPOSE:  Processes messages for "SelectSQL" dialog box <br> <br>MESSAGES: <br> <br>WM_INITDIALOG - initialize dialog box <br>WM_COMMAND    - Input received <br> <br>COMMENTS: <br> <br>No initialization is needed for this particular dialog box, but TRUE <br>must be returned to NT. <br> <br>Let user input into edit control the name of an author (the select <br>IS case sensitive).  When user presses OK, format the select statement <br>then send it to the server and execute it via dbsqlexec(). If the <br>dbsqlexec() SUCCEED's post a WM_DBRESULTS message so the results <br>may be retrieved and processed. <br> <br>Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY SelectSQL(hDlg, message, wParam, lParam) <br>HWND hDlg; <br>UINT message; <br>DWORD wParam; <br>LONG lParam; <br>{ <br>char szSelectAuthor[41];  /* string for authors name    */ <br>char szServerMess[45];  /* string for server response    */ <br>char szAName[40];  /* format string for author    */ <br>switch (message) <br>{ <br>case WM_INITDIALOG:   /* message: initialize dialog box */ <br>SendDlgItemMessage(hDlg,       /* limit input to 40 characters   */ <br>AUTHORNAME,EM_LIMITTEXT,40,0L); <br>return (TRUE); <br> <br>case WM_COMMAND:      /* message: received a command */ <br>errhWnd = hDlg; <br>switch(wParam) <br>{ <br>case IDOK :      /* "OK" box selected?     */ <br>*szSelectAuthor = '\0';   /* Null author     */ <br>GetDlgItemText(hDlg,AUTHORNAME, (LPSTR)szSelectAuthor, MAX_ANAME); <br>if(dbproc == (PDBPROCESS)NULL) /* if not a valid process*/ <br>{ <br>/* No server to query*/ <br>MessageBox(hDlg, <br>"No SQL Server Connected to Query", <br>"SQL Test",MB_ICONHAND | MB_OK); <br>} <br>else <br>if(*szSelectAuthor != '\0') /* if a name exists */ <br>{ <br>DBLOCKLIB();/* lock down the library */ <br>/* format the select statement */ <br>dbcmd(dbproc, <br>(LPSTR)"select au_id, au_lname," <br>"au_fname, phone, address, city, state, zip"); <br>dbcmd(dbproc, (LPSTR)" from authors"); <br>dbcmd(dbproc, (LPSTR)" where au_lname = "); <br>sprintf(szAName,"'%s'",szSelectAuthor); <br>dbcmd(dbproc,(LPSTR)szAName); <br>if (dbsqlexec(dbproc) == FAIL) <br>{ <br>sprintf(szServerMess,/* error, not in db */ <br>"%s not found in database pubs", <br>szSelectAuthor); <br>MessageBox(hDlg, <br>(LPSTR)szServerMess,(LPSTR)"SQL Test", <br>MB_ICONHAND | MB_OK); <br>} <br>else/* query SUCCEEDed so */ <br>{/* post message to process results*/ <br>PostMessage(GetParent(hDlg),WM_DBRESULTS,0,0L); <br>} <br>DBUNLOCKLIB();/* unlock library*/ <br>} <br>EndDialog(hDlg, 0);      /* Exits the dialog box     */ <br>return (TRUE); <br>break; <br> <br>case IDCANCEL : <br>EndDialog(hDlg, 0);      /* cancelled select */ <br>return(TRUE); <br>break; <br>} <br>break; <br>} <br> <br>return (FALSE); /* Didn't process a message    */ <br>} <br>/**************************************************************************** <br> <br>FUNCTION: ConnectSQL(HWND, unsigned, WORD, LONG) <br> <br>PURPOSE:  Processes messages for "Connect" dialog box <br> <br>MESSAGES: <br> <br>WM_INITDIALOG - initialize dialog box <br>WM_COMMAND    - Input received <br> <br>COMMENTS: <br> <br>No initialization is needed for this particular dialog box, but TRUE <br>must be returned to NT. <br> <br>Wait for user to click on "Ok" button, then close the dialog box. <br> <br>****************************************************************************/ <br> <br>LONG APIENTRY ConnectSQL(hDlg, message, wParam, lParam) <br>HWND hDlg; <br>UINT message; <br>DWORD wParam; <br>LONG lParam; <br>{ <br>char szSQLServer[31]; <br>static PLOGINREC LoginRec; <br> <br>*szSQLServer = '\0'; <br>switch (message) <br>{ <br>case WM_INITDIALOG:   /* message: initialize dialog box*/ <br>SendDlgItemMessage(hDlg,       /* limit input to 30 characters  */ <br>SQL_SERVER,EM_LIMITTEXT,30,0L); <br>return (TRUE); <br> <br>case WM_COMMAND:      /* message: received a command*/ <br>errhWnd = hDlg; <br>switch(wParam) <br>{ <br>case IDOK :      /* "OK" box selected?    */ <br>GetDlgItemText(hDlg,SQL_SERVER, <br>(LPSTR)szSQLServer, <br>MAX_SERVERNAME); /* get Server name */ <br>if(*szSQLServer != '\0') /* was something input    */ <br>{ <br>DBLOCKLIB();/* lock down library    */ <br>if (dbproc != (PDBPROCESS)NULL) /* if an active     */ <br>/* process close it */ <br>dbclose(dbproc); <br>if ((LoginRec = dblogin()) != (PLOGINREC)NULL) /* get loginrec */ <br>{ <br>DBSETLUSER(LoginRec,(char far *)"sa"); /* set user  */ <br>DBSETLVERSION(LoginRec,DBVER60); <br> <br>/* now open the connection to server */ <br>if((dbproc = dbopen(LoginRec,(LPSTR)szSQLServer)) <br>== (PDBPROCESS)NULL) <br>{ <br>/* if NULL couldn't connect*/ <br>dbfreelogin(LoginRec); <br>} <br>else /* got connect so use the pubs database */ <br>{ <br>dbuse(dbproc,(LPSTR)"pubs"); <br>dbfreelogin(LoginRec); <br>} <br>} <br>else /* memory allocation problem */ <br>MessageBox(hDlg, "Could not allocate Login Record","System Error", MB_ICONHAND | MB_OK); <br>DBUNLOCKLIB(); /* done unlock library*/ <br>} <br>EndDialog(hDlg, 0);      /* Exits the dialog box     */ <br>return (TRUE); <br>break; <br> <br>case IDCANCEL : <br>EndDialog(hDlg, 0); <br>return(TRUE); <br>break; <br> <br>} <br>break; <br>} <br> <br>return (FALSE); /* Didn't process a message */ <br>} <br> <br>/**************************************************************************** <br> <br>FUNCTION: CheckForScroll(HWND, int, int, int) <br> <br>PURPOSE:  Check if next output line will be out of client area <br> <br>PARAMETERS: <br>hWnd - Handle to the window. <br>CurrentPosition - Current y coordinate for the line of <br>text just written to the client area. <br>Spacing - The height of the line (including the space <br>separating lines) of the text just written. <br>Length - The length of the line just written in device units. <br> <br>RETURN:Returns the Y coordinate for the next line of text. <br> <br>COMMENTS: <br> <br>Will determine if the next line of text will be out of the client <br>area.  If so will scroll the window for the next line.  Also validates <br>the current line of text so that a WM_PAINT will not clear it. <br> <br>****************************************************************************/ <br>int CheckForScroll(hWnd,CurrentPosition,Spacing, Length) <br>HWND hWnd; <br>int CurrentPosition; <br>int Spacing; <br>int Length; <br>{ <br>RECT rect;/* RECT structure for validation */ <br>rect.top = CurrentPosition; /* top of last line of text */ <br>rect.bottom = CurrentPosition+Spacing+1; /* bottom of last line */ <br>rect.left = 1;/* left most column of line */ <br>rect.right = Length+1;/* right most column of line */ <br>ValidateRect(hWnd,(LPRECT)&amp;rect);   /* validate line so that it is   */ <br> <br>/* not blanked on next paint */ <br> <br>GetClientRect(hWnd,(LPRECT)&amp;rect);/* get rect for current client   */ <br>if(CurrentPosition + (Spacing*2) &gt; rect.bottom) /* will line fit */ <br>{ <br>/* if not scroll window and  */ <br>/* update client window */ <br>ScrollWindow(hWnd,0,-(Spacing+1),NULL,NULL); <br>UpdateWindow(hWnd); <br>return(CurrentPosition); <br>} <br> <br>return(CurrentPosition+Spacing); <br>} <br> <br>/**************************************************************************** <br> <br>FUNCTION: SQLTestProcessResults(HWND) <br> <br>PURPOSE:  If a valid dbprocess is present process all results from pending <br>select statement, output each field to client area.  Whenever <br>a new line is written to client area it is checked to see if <br>the client area needs to be scrolled. <br> <br>PARAMETERS: hWnd - Handle to the window. <br> <br>RETURN:Returns the Y coordinate for the next line of text. <br> <br>COMMENTS: <br>This function will bind the fields in the select statement <br>to local variables, format an output string then <br>write that string to the client area via TextOut. <br>It is called by the main message processing loop <br>SQLTestWndProc via the message WM_DBRESULTS. <br> <br>****************************************************************************/ <br>BOOL SqlTestProcessResults(hWnd) <br>HWND hWnd; <br>{ <br>HDC hDC;/* display context */ <br>TEXTMETRIC tm;/* text metric structure */ <br>char szId[12];/* Author ID for binding */ <br>char szLastName[41];/* Author last name for binding */ <br>char szFirstName[21];/* Author first name for binding */ <br>char szPhone[13];/* Author phone for binding */ <br>char szAddress[41];/* Author address for binding */ <br>char szCity[21];/* Author city for binding */ <br>char szState[3];/* Author state for binding */ <br>char szZip[6];/* Author zipcode for binding */ <br>char szOutputString[81];/* general output string */ <br>RETCODE result_code;/* results code from dbresults */ <br>int Y;/* Y coordinate for text output  */ <br>int Spacing;/* Spacing between lines */ <br>errhWnd = hWnd; <br> <br>hDC = GetDC(hWnd);/* get display context */ <br>GetTextMetrics(hDC, (LPTEXTMETRIC)&amp;tm); /* get font info */ <br>Spacing = tm.tmExternalLeading + tm.tmHeight; /* set up spacing */ <br>Y = 1;/* start at line 1 */ <br> <br>if(dbproc == (PDBPROCESS)NULL)/* if process null, no results */ <br>{ <br>ReleaseDC(hWnd,hDC);/* free resources and return */ <br>return(TRUE); <br>} <br> <br>SendMessage(hWnd,WM_ERASEBKGND,(DWORD)hDC,0L); /* always erase background */ <br>UpdateWindow(hWnd);/* force painting of window */ <br>DBLOCKLIB();/* lock down library */ <br> <br>/* get all results from the query*/ <br>while(((result_code = dbresults(dbproc)) != NO_MORE_RESULTS) &amp;&amp; result_code != FAIL) <br>{ <br>if(result_code == SUCCEED)/* if results ready */ <br>{ <br>/* Bind all data of interest */ <br>dbbind(dbproc,1,NTBSTRINGBIND, 12L, (LPSTR)szId); <br>dbbind(dbproc,2,NTBSTRINGBIND, 41L, (LPSTR)szLastName); <br>dbbind(dbproc,3,NTBSTRINGBIND, 21L, (LPSTR)szFirstName); <br>dbbind(dbproc,4,NTBSTRINGBIND, 13L, (LPSTR)szPhone); <br>dbbind(dbproc,5,NTBSTRINGBIND, 41L, (LPSTR)szAddress); <br>dbbind(dbproc,6,NTBSTRINGBIND, 21L, (LPSTR)szCity); <br>dbbind(dbproc,7,NTBSTRINGBIND, 3L, (LPSTR)szState); <br>dbbind(dbproc,8,NTBSTRINGBIND, 6L, (LPSTR)szZip); <br>while(dbnextrow(dbproc) != NO_MORE_ROWS) /* get all rows */ <br>{ <br>/* here we format each field and write it to client */ <br>/* area checking to see if the client area needs to */ <br>/* be scrolled after each line is written    */ <br>sprintf(szOutputString,"Author ID: %s",szId); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"Last Name: %s",szLastName); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"Address:   %s",szAddress); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"City:      %s",szCity); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"State:     %s",szState); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"ZipCode:   %s",szZip); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>sprintf(szOutputString,"Telephone: %s",szPhone); <br>TextOut(hDC,1,Y,szOutputString,strlen(szOutputString)); <br>Y = CheckForScroll(hWnd,Y,Spacing,strlen(szOutputString) * tm.tmMaxCharWidth); <br> <br>Y = CheckForScroll(hWnd,Y,Spacing,0); /* add extra line     */ <br>/* after each results */ <br>} <br>} <br>} <br> <br>DBUNLOCKLIB();/* unlock library   */ <br>ReleaseDC(hWnd,hDC);/* free resource   */ <br>return(TRUE); <br>} <br> <br>/**************************************************************************** <br> <br>FUNCTION: dbwinMessageHandler(PDBPROCESS, DBINT, DBSMALLINT, DBSMALLINT, <br>LPSTR) <br> <br>PURPOSE:  When the Data Server returns a message to dblib this function <br>will be called to process that message.  This function is <br>installed into dblib via MakeProcInstance.  It must be declared <br>as a FAR cdecl function, not as a FAR PASCAL function, unlike <br>other call back routines, as dblib conducts all of it's calls <br>in the cdecl fashion.  You must return 0 to dblib. <br> <br>RETURN: Return 0 <br> <br>COMMENTS: <br> <br>****************************************************************************/ <br> <br>int API dbwinMessageHandler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS        *dbproc; <br>DBINT            msgno; <br>INT              msgstate; <br>INT              severity; <br>CHAR             *msgtext; <br>{ <br>MessageBox(errhWnd,msgtext,(LPSTR)"SQL DataServer Message",MB_OK); <br>return(0); <br>} <br> <br>/**************************************************************************** <br> <br>FUNCTION: dbwinErrorHandler(PDBPROCESS, int, int, int, LPSTR, LPSTR) <br> <br>PURPOSE: When dblib returns an error message to the application this <br>function will be called to process that error.  This function is <br>installed into dblib via MakeProcInstance.  It must be declared <br>as a FAR cdecl function, not as a FAR PASCAL function, unlike <br>other call back routines, as dblib conducts all of it's calls <br>in the cdecl fashion.  You must return either INT_CANCEL, <br>INT_CONTINUE, or INT_EXIT to dblib. <br> <br>RETURN: Return continuation code. <br> <br>COMMENTS: <br> <br>****************************************************************************/ <br> <br>int API dbwinErrorHandler(dbproc, severity, errno, oserr, dberrstr, oserrstr) <br>PDBPROCESS dbproc; <br>int severity; <br>int errno; <br>int oserr; <br>LPSTR dberrstr; <br>LPSTR oserrstr; <br>{ <br>MessageBox(errhWnd,dberrstr,(LPSTR)"DB-LIBRARY error",MB_ICONHAND | MB_OK); <br> <br>if (oserr != DBNOERR)/* os error*/ <br>MessageBox(errhWnd,oserrstr,(LPSTR)"Operating-System error",MB_ICONHAND | MB_OK); <br> <br>return(INT_CANCEL);/* cancel command */ <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
