<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TEXTCOPY.CPP</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2391"></a>TEXTCOPY.CPP</h2>
<pre><code>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FILE: textcopy.cpp <br>//               <br>//      Text and image copy application <br>// <br>//  FUNCTIONS: <br>// <br>//      main() - Main application <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>#include &lt;afx.h&gt;                // MFC  <br>#include &lt;iostream.h&gt;           // iostream <br>#include &lt;stdlib.h&gt;             // C run-time <br> <br>#if defined (_DEBUG) <br>#undef THIS_FILE <br>static char BASED_CODE THIS_FILE[] = __FILE__; <br>#endif <br> <br>#define DBNTWIN32               // Win32 DB-Library for Windows NT <br>#include &lt;sqlfront.h&gt;           // DB-Library <br>#include &lt;sqldb.h&gt;              // DB-Library <br> <br>extern "C" <br>{ <br>    #include "getopt.h"         // GetOption <br>} <br> <br>#include "textcopy.h"           // specific to this program <br> <br>// GLOBAL VARIABLES <br>BOOL bDebug = FALSE;            // debug info <br>BYTE* aBuf; <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: main() <br>// <br>//      Main application <br>// <br>//  PARAMETERS: <br>// <br>//      argc - count of command line arguments <br>//      argv - array of command line argument strings <br>//      envp - array of environment strings <br>// <br>//  RETURNS: 0 <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br>  <br>int main ( <br>    int argc, <br>    char** argv, <br>    char** envp) <br>{ <br>    char chOpt;                 // gotten option character <br>    char* pszParam;             // gotten parameter <br>    int nChunkSize = 4096;          // chunk size <br>    CString strChunkSize = "4096";  // chunk size <br>    CString strColumnType; <br> <br>    CString strServer,          // SQL Server <br>        strLogin,               // login <br>        strPassword,            // password <br>        strDatabase,            // database <br>        strTable,               // table <br>        strColumn,              // column <br>        strWhere,               // where clause <br>        strFile;                // file <br>    BOOL bServer = FALSE,       // flags for tracking options <br>        bLogin = FALSE, <br>        bPassword = FALSE, <br>        bDatabase = FALSE, <br>        bTable = FALSE, <br>        bColumn = FALSE, <br>        bWhere = FALSE, <br>        bFile = FALSE, <br>        bIn = FALSE, <br>        bOut = FALSE; <br> <br>    // banner <br>    cout &lt;&lt; "TEXTCOPY Version 1.0" &lt;&lt; endl; <br> <br>    // initialize DB-Library, get DB-Library version number <br>    CString strDblibVersion; <br>    strDblibVersion = dbinit(); <br>    if (strDblibVersion.IsEmpty()) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Could not initialize DB-Library" &lt;&lt; endl; <br>        return (1); <br>    } <br>    cout &lt;&lt; strDblibVersion &lt;&lt; endl; <br>     <br>    // get command-line options and parameters <br>    while (TRUE) <br>    { <br>        // all the following command-line options are valid, they <br>        // are neither case sensitive nor white-space sensitive, and <br>        // both '/' and '-' are valid switch characters <br>        // <br>        //  OPTION  PARAMETER           DESCRIPTION <br>        // <br>        //  /S      [sqlserver]         SQL Server <br>        //  /U      [login]             Login <br>        //  /P      [password]          Password <br>        //  /D      [database]          Database <br>        //  /T      table               Table <br>        //  /C      column              Column <br>        //  /W      "where clause"      Where clause in double quotes <br>        //  /F      file                File <br>        //  /I                          Into SQL Server from file <br>        //  /O                          Out of SQL Server into file <br>        //  /K      chunksize           Chunk size in bytes <br>        //  /Z                          Debug information <br>        //  /?                          Usage information <br>        // <br>        // for example, all of the following are valid ways to specify <br>        // a connection to a SQL Server named 'gizmo' <br>        // <br>        //  /Sgizmo     /sgizmo     -Sgizmo     -sgizmo <br>        //  /S gizmo    /s gizmo    -S gizmo    -s gizmo <br> <br>        chOpt = GetOption(argc, argv, "s:S:u:U:p:P:d:D:t:T:c:C:w:W:f:F:k:K:iIoOzZ?", &amp;pszParam); <br>        if (chOpt &gt; 1) <br>        { <br>            // chOpt is valid argument <br>            switch (chOpt) <br>            { <br>            case 's':   // SQL Server <br>            case 'S': <br>                bServer = TRUE; <br>                strServer = pszParam; <br>                break; <br>            case 'u':   // login <br>            case 'U': <br>                bLogin = TRUE; <br>                strLogin = pszParam; <br>                break; <br>            case 'p':   // password <br>            case 'P': <br>                bPassword = TRUE; <br>                strPassword = pszParam; <br>                break; <br>            case 'd':   // database <br>            case 'D': <br>                bDatabase = TRUE; <br>                strDatabase = pszParam; <br>                break; <br>            case 't':   // table <br>            case 'T': <br>                bTable = TRUE; <br>                strTable = pszParam; <br>                break; <br>            case 'c':   // column <br>            case 'C': <br>                bColumn = TRUE; <br>                strColumn = pszParam; <br>                break; <br>            case 'w':   // where clause <br>            case 'W': <br>                bWhere = TRUE; <br>                strWhere = pszParam; <br>                break; <br>            case 'f':   // file <br>            case 'F': <br>                bFile = TRUE; <br>                strFile = pszParam; <br>                break; <br>            case 'i':   // direction: into SQL Server from file <br>            case 'I': <br>                bIn = TRUE; <br>                break; <br>            case 'o':   // direction: out of SQL Server into file <br>            case 'O': <br>                bOut = TRUE; <br>                break; <br>            case 'k':   // chunk size in bytes <br>            case 'K': <br>                if (pszParam != NULL) <br>                { <br>                    nChunkSize = atoi (pszParam); <br>                    _itoa (nChunkSize, strChunkSize.GetBuffer(20), 10); <br>                    strChunkSize.ReleaseBuffer(); <br>                    if (strChunkSize != pszParam) <br>                    { <br>                        cout &lt;&lt; err &lt;&lt; "Converted chunk size '" &lt;&lt; pszParam &lt;&lt; "' to " &lt;&lt; nChunkSize &lt;&lt; endl; <br>                        return (0); <br>                    } <br>                } <br>                break; <br>            case 'z':   // debug <br>            case 'Z': <br>                bDebug = TRUE; <br>                break; <br>            case '?':   // usage info <br>                DisplayUsage(); <br>                return(0); <br>                break; <br>            } <br>        } <br>        if (chOpt == 0) <br>        { <br>            // end of argument list <br>            break; <br>        } <br>        if ((chOpt == 1) || (chOpt == -1)) <br>        { <br>            // standalone param or error <br>            cout &lt;&lt; err &lt;&lt; "Argument '" &lt;&lt; pszParam &lt;&lt; "' not recognized" &lt;&lt; endl; <br>            break; <br>        } <br>    } <br> <br>    if ((chOpt == 1) || (chOpt == -1)) <br>    { <br>        // exit on error <br>        return (1); <br>    } <br> <br>    // prompt the user for any unspecified options <br>    if (!bServer) <br>    { <br>        cout &lt;&lt; "Type the SQL Server to connect to: "; <br>        cinstr (strServer); <br>    } <br> <br>    if (!bLogin) <br>    { <br>        cout &lt;&lt; "Type your login: "; <br>        cinstr (strLogin); <br>    } <br> <br>    if (!bPassword) <br>    { <br>        cout &lt;&lt; "Type your password: "; <br>        cinstr (strPassword); <br>    } <br> <br>    if (!bDatabase) <br>    { <br>        cout &lt;&lt; "Type the database: "; <br>        cinstr (strDatabase); <br>    } <br> <br>    if (!bTable) <br>    { <br>        cout &lt;&lt; "Type the table: "; <br>        cinstr (strTable); <br>    } <br>     <br>    if (!bColumn) <br>    { <br>        cout &lt;&lt; "Type the text or image column: "; <br>        cinstr (strColumn); <br>    } <br>     <br>    if (!bWhere) <br>    { <br>        cout &lt;&lt; "Type the where clause: "; <br>        cinstr (strWhere); <br>    } <br>     <br>    if (!bFile) <br>    { <br>        cout &lt;&lt; "Type the file: "; <br>        cinstr (strFile); <br>    } <br> <br>    if (!bIn &amp;&amp; !bOut) <br>    { <br>        while (TRUE) <br>        { <br>            CString strDirection; <br>            cout &lt;&lt; "Type the direction ('I' for in, 'O' for out): "; <br>            cinstr (strDirection); <br>            if (strDirection.CompareNoCase("i") == 0) <br>            { <br>                bIn = TRUE; <br>                break; <br>            } <br>            else <br>            { <br>                if (strDirection.CompareNoCase("o") == 0) <br>                { <br>                    bOut = TRUE; <br>                    break; <br>                } <br>                else <br>                { <br>                    cout &lt;&lt; err &lt;&lt; "The value '" &lt;&lt; strDirection &lt;&lt; "' is invalid." &lt;&lt; endl; <br>                } <br>            } <br>        } <br>    } <br> <br>    // parameter validation <br>    if (strTable.IsEmpty()) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "You did not specify a table." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    if (strColumn.IsEmpty()) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "You did not specify a column." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    if (strWhere.IsEmpty()) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "You did not specify a where clause." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    /* <br>    CString strLowerWhere = strWhere; <br>    strLowerWhere.MakeLower(); <br>    if (strLowerWhere.Find ("where ") == -1) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Your where clause '" &lt;&lt; strWhere &lt;&lt; "' did not contain the keyword 'where'." &lt;&lt; endl; <br>        return (1); <br>    } <br>    */ <br> <br>    if (strFile.IsEmpty()) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "You did not specify a file." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    if (bIn &amp;&amp; bOut) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "You cannot specify both 'in' and 'out' directions." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    if (nChunkSize &lt; 1024) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Your specified chunk size of " &lt;&lt; nChunkSize &lt;&lt; " bytes is too small." &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    if (bDebug) <br>    { <br>        cout &lt;&lt; dbg &lt;&lt; "Final parameters:" &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Server: " &lt;&lt; strServer &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Login: " &lt;&lt; strLogin &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Password: " &lt;&lt; strPassword &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Database: " &lt;&lt; strDatabase &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Table: " &lt;&lt; strTable &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Column: " &lt;&lt; strColumn &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Where clause: " &lt;&lt; strWhere &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  File: " &lt;&lt; strFile &lt;&lt; endl; <br>        cout &lt;&lt; dbg &lt;&lt; "  Direction: "; <br>        if (bIn) <br>        { <br>            cout &lt;&lt; "Into SQL Server from file." &lt;&lt; endl; <br>        } <br>        if (bOut) <br>        { <br>            cout &lt;&lt; "Out of SQL Server into file." &lt;&lt; endl; <br>        } <br>        cout &lt;&lt; dbg &lt;&lt; "  Chunk size: " &lt;&lt; nChunkSize &lt;&lt; " bytes" &lt;&lt; endl; <br>    } <br> <br>    // install error and message handlers <br>    dberrhandle (ErrorHandler); <br>    dbmsghandle (MessageHandler); <br> <br>    // set DB-Library options <br>    dbsettime(30); <br>    dbsetlogintime(10); <br> <br>    // get login record <br>    PLOGINREC pLoginRec; <br>    pLoginRec = dblogin(); <br>    if (pLoginRec == NULL) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Could not allocate a login record" &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    // fill the login record  <br>    DBSETLUSER (pLoginRec, strLogin);       // set the login <br>    DBSETLPWD (pLoginRec, strPassword);     // set the password <br>    DBSETLAPP (pLoginRec, "textcopy");      // set the app name <br>    DBSETLHOST (pLoginRec, "textcopy");     // set the host name <br> <br>    // attempt to connect to SQL Server <br>    PDBPROCESS pDbproc; <br>    pDbproc = dbopen (pLoginRec, strServer); <br>    dbfreelogin (pLoginRec); <br>    if (pDbproc == NULL) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Could not connect to SQL Server '" &lt;&lt; strServer &lt;&lt; "'" &lt;&lt; endl; <br>        return (1); <br>    } <br> <br>    // re-used DB-Library return code <br>    RETCODE r; <br> <br>    // set textlimit and textsize options for this connection <br>    if (bOut) <br>    { <br>        dbsetopt (pDbproc, DBTEXTLIMIT, strChunkSize); <br>        dbsetopt (pDbproc, DBTEXTSIZE, "2147483647"); <br>    } <br> <br>    if (bIn) <br>    { <br>        dbsetopt (pDbproc, DBTEXTSIZE, "1024"); <br>    } <br> <br>    // must send and execute batch to set options <br>    r = dbsqlexec (pDbproc); <br>    if (r == FAIL) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Query execution failed." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // get empty result set(s) from setting options <br>    while (TRUE) <br>    { <br>        r = dbresults (pDbproc); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Query results failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br>        if (r == NO_MORE_RESULTS) <br>            break; // while loop <br>    } <br> <br>    // use specified database <br>    if (!strDatabase.IsEmpty()) <br>    { <br>        r = dbuse (pDbproc, strDatabase); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Could not use database '" &lt;&lt; strDatabase &lt;&lt; "'" &lt;&lt; endl; <br>            Cleanup(pDbproc); <br>            return (1); <br>        } <br>    } <br> <br>    // build query <br>    CString strQuery; <br> <br>    strQuery = "select " + strColumn + " from " + strTable + " " + strWhere; <br>    D(cout &lt;&lt; "Query: " &lt;&lt; strQuery &lt;&lt; endl); <br> <br>    r = dbcmd (pDbproc, strQuery); <br> <br>    // send and execute query  <br>    r = dbsqlexec (pDbproc); <br>    if (r == FAIL) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Query execution failed." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // get first result set <br>    r = dbresults (pDbproc); <br>    if (r != SUCCEED) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Query results failed." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // verify that only a single column was selected     <br>    if (dbnumcols (pDbproc) != 1) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "More than one column specified." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // verify that the single column selected is either text or image <br>    int nColumnType; <br>    nColumnType = dbcoltype (pDbproc, 1); <br>    if ((nColumnType != SQLTEXT) &amp;&amp; (nColumnType != SQLIMAGE)) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Specified column is not a text or image column." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br>    else <br>    { <br>        if (nColumnType == SQLTEXT) <br>        { <br>            strColumnType = "text"; <br>        } <br>        if (nColumnType == SQLIMAGE) <br>        { <br>            strColumnType = "image"; <br>        } <br>    } <br> <br>    // buffer for data transfer between DB-Library and file <br>    aBuf = new BYTE[nChunkSize]; <br>    if (aBuf == 0) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Unable to allocate transfer buffer of '" &lt;&lt; nChunkSize &lt;&lt; "' bytes." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // if the data is coming out of SQL Server and into a file, use dbreadtext <br>    // (instead of dbnextrow) to read the text or image data from the row <br>    // in chunks <br>    if (bOut) <br>    { <br>    try <br>    { <br>        // set up file  <br>        CFile file (strFile, CFile::modeCreate | CFile::modeWrite); <br>        D(cout &lt;&lt; "File '" &lt;&lt; strFile &lt;&lt; "' opened for write" &lt;&lt; endl); <br> <br>        DBINT lWriteBytes; <br>        while (TRUE) <br>        { <br>            // read chunk of text or image data from SQL Server into aBuf <br>            lWriteBytes = dbreadtext (pDbproc, aBuf, nChunkSize); <br>            switch (lWriteBytes) <br>            { <br>            case 0: <br>                // end of text or image row <br>                //D(cout &lt;&lt; "End of row" &lt;&lt; endl); <br>                break; <br>            case -1: <br>                // dbreadtext failed <br>                cout &lt;&lt; err &lt;&lt; "Text or image data retrieval failed." &lt;&lt; endl; <br>                Cleanup (pDbproc); <br>                return (1); <br>                break; <br>            case NO_MORE_ROWS: <br>                //D(cout &lt;&lt; "No more rows" &lt;&lt; endl); <br>                break; <br>            default: <br>                // dbreadtext has placed lBytes of text or image data <br>                // into aBuf, now write that chunk to the file <br>                file.Write (aBuf, lWriteBytes); <br>                D(cout &lt;&lt; "Wrote " &lt;&lt; lWriteBytes &lt;&lt; " bytes to file" &lt;&lt; endl); <br>                break; <br>            } <br>            if ((lWriteBytes == -1) || (lWriteBytes == NO_MORE_ROWS)) <br>                break; // while loop <br>        } <br>        file.Close(); <br>        D(cout &lt;&lt; "File closed" &lt;&lt; endl); <br>    } <br>    catch (CFileException* e) <br>    { <br>        //if (e-&gt;m_cause == CFileException::fileNotFound) <br>        cout &lt;&lt; err &lt;&lt; "Problem with file '" &lt;&lt; strFile &lt;&lt; "'." &lt;&lt; endl; <br>        e-&gt;Delete(); <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    } <br> <br>    DBBINARY aTextPointer[DBTXPLEN], aTextTimestamp[DBTXTSLEN]; <br>    DBBINARY *pTextPointer, *pTextTimestamp; <br>     <br>    // if the data is going into SQL Server from a file, copy the text <br>    // pointer and text timestamp values into private buffers <br>    if (bIn) <br>    { <br>        // get the single row <br>        STATUS s; <br>        s = dbnextrow (pDbproc); <br>        if (s != REG_ROW) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Row retrieval failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br> <br>        // get the pointers to the text pointer and text timestamp values <br>        pTextPointer = dbtxptr (pDbproc, 1); <br>        pTextTimestamp = dbtxtimestamp (pDbproc, 1); <br>        if ((pTextPointer == NULL) || (pTextTimestamp == NULL)) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Text or image pointer and timestamp retrieval failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br> <br>        // copy the actual text pointer and text timestamp values into <br>        // private buffers <br>        memcpy (aTextPointer, pTextPointer, DBTXPLEN); <br>        memcpy (aTextTimestamp, pTextTimestamp, DBTXTSLEN); <br> <br>        // we should only have received one row, so call dbnextrow <br>        // to get NO_MORE_ROWS <br>        s = dbnextrow (pDbproc); <br>        switch (s) <br>        { <br>        case NO_MORE_ROWS: <br>            // this is what we expect <br>            break; <br>        case REG_ROW: <br>            cout &lt;&lt; err &lt;&lt; "Where clause returned more than one row." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>            break; <br>        default: <br>            cout &lt;&lt; err &lt;&lt; "Row retrieval failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>            break; <br>        } <br>    } <br>     <br>    // get NO_MORE_RESULTS to clear out all results <br>    r = dbresults (pDbproc); <br>    if (r != NO_MORE_RESULTS) <br>    { <br>        cout &lt;&lt; err &lt;&lt; "Query results failed." &lt;&lt; endl; <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    // if the data is going into SQL Server from a file, use dbwritetext <br>    // (with the private copies of the text or image pointer and timestamp <br>    // values) and dbmoretext to write the text or image data to <br>    // SQL Server in chunks <br>    if (bIn) <br>    { <br>    try <br>    { <br>        // set up file <br>        CFile file (strFile, CFile::modeRead); <br>        D(cout &lt;&lt; "File '" &lt;&lt; strFile &lt;&lt; "' opened for read" &lt;&lt; endl); <br>        D(cout &lt;&lt; "File is " &lt;&lt; file.GetLength() &lt;&lt; " bytes long" &lt;&lt; endl); <br> <br>        // call dbwritetext will NULL text value to indicate that the text <br>        // values will be sent in chunks using dbmoretext <br>        r = dbwritetext (pDbproc, strTable + "." + strColumn, <br>            aTextPointer, DBTXPLEN, aTextTimestamp, <br>            TRUE, file.GetLength(), NULL); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Text or image write failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br>         <br>        // call dbsqlok and dbresults to prepare for calling dbmoretext <br>        r = dbsqlok (pDbproc); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Text or image write failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br>        r = dbresults (pDbproc); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Query results failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br> <br>        // read each chunk from the file and write it to SQL Server <br>        UINT nReadBytes = nChunkSize; <br>        while (nReadBytes == UINT(nChunkSize)) <br>        { <br>            // read chunk from file into aBuf <br>            nReadBytes = file.Read (aBuf, nChunkSize); <br>            D(cout &lt;&lt; "Read "&lt;&lt; nReadBytes &lt;&lt; " bytes from file" &lt;&lt; endl); <br>             <br>            // write chunk of text or image data from aBuf to SQL Server <br>            r = dbmoretext (pDbproc, nReadBytes, aBuf); <br>            if (r == FAIL) <br>            { <br>                cout &lt;&lt; err &lt;&lt; "Text or image write failed." &lt;&lt; endl; <br>                Cleanup (pDbproc); <br>                return (1); <br>            } <br>        } <br> <br>        file.Close(); <br>        D(cout &lt;&lt; "File closed" &lt;&lt; endl); <br> <br>        // call dbsqlok and dbresults to signal end of calls to <br>        // dbmoretext and completion of text or image write <br>        r = dbsqlok (pDbproc); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Text or image write failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br>        r = dbresults (pDbproc); <br>        if (r == FAIL) <br>        { <br>            cout &lt;&lt; err &lt;&lt; "Query results failed." &lt;&lt; endl; <br>            Cleanup (pDbproc); <br>            return (1); <br>        } <br>    } <br>    catch (CFileException* e) <br>    { <br>        //if (e-&gt;m_cause == CFileException::fileNotFound) <br>        cout &lt;&lt; err &lt;&lt; "Problem with file '" &lt;&lt; strFile &lt;&lt; "'." &lt;&lt; endl; <br>        e-&gt;Delete(); <br>        Cleanup (pDbproc); <br>        return (1); <br>    } <br> <br>    } <br> <br>    // display success message <br>    if (bIn) <br>    { <br>        cout &lt;&lt; "Data copied into SQL Server " &lt;&lt; strColumnType &lt;&lt; " column from file '" &lt;&lt; strFile &lt;&lt; "'." &lt;&lt; endl; <br>    } <br>    if (bOut) <br>    { <br>        cout &lt;&lt; "Data copied out of SQL Server " &lt;&lt; strColumnType &lt;&lt; " column into file '" &lt;&lt; strFile &lt;&lt; "'." &lt;&lt; endl; <br>    } <br> <br>    // prepare DB-Library for exit <br>    Cleanup (pDbproc); <br> <br>    return (0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: Cleanup() <br>// <br>//      Prepare DB-Library for exit <br>// <br>//  PARAMETERS: <br>// <br>//      pDbproc - pointer to DBPROCESS connection <br>// <br>//  RETURNS: 0 <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>int Cleanup (PDBPROCESS pDbproc) <br>{ <br>    delete [] aBuf; <br>    dbcancel (pDbproc); <br>    dbclose (pDbproc); <br>    return (0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: ErrorHandler() <br>// <br>//      Called when a DB-Library error occurs <br>// <br>//  PARAMETERS: <br>// <br>//      pDbproc - pointer to DBPROCESS connection <br>//      nDblibSeverity - DB-Library error severity <br>//      nDblibErrorNo - DB-Library error number <br>//      nOSErrorNo - operating system error number <br>//      lpstrDblibError - DB-Library error string <br>//      lpstrOSError - operating system error string <br>// <br>//  RETURNS: One of three DB-Library return continuation codes: <br>// <br>//      INT_CANCEL <br>//      INT_CONTINUE <br>//      INT_EXIT <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>extern "C" int ErrorHandler ( <br>    PDBPROCESS pDbproc, <br>    INT nSeverity, <br>    INT nDBLibError, <br>    INT nOSError, <br>    LPCSTR pszDBLibError, <br>    LPCSTR pszOSError) <br>{ <br>    // display DB-Library error information <br>    cout &lt;&lt; "DB-Library Error " &lt;&lt; nDBLibError &lt;&lt; ": " &lt;&lt; pszDBLibError &lt;&lt; endl; <br> <br>    if ((pDbproc == NULL) || (DBDEAD(pDbproc))) <br>    { <br>        return(INT_EXIT); <br>    } <br>    else <br>    { <br>        if (nOSError != DBNOERR) <br>        { <br>            // this DB-Library error was caused by an operating system <br>            // error, so display OS error information <br>            cout &lt;&lt; "Operating System Error " &lt;&lt; nOSError &lt;&lt; ": " &lt;&lt; pszOSError &lt;&lt; endl; <br>        } <br> <br>        return(INT_CANCEL); <br>    } <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: MessageHandler() <br>// <br>//      Called when a SQL Server message is received <br>// <br>//  PARAMETERS: <br>// <br>//      pDbproc - pointer to DBPROCESS connection <br>//      lMessage - SQL Server message number <br>//      nState - SQL Server message state <br>//      nSeverity - SQL Server message severity <br>//      pszMessage - SQL Server message string <br>//      pszServer - the SQL Server that sent this message <br>//      pszProcedure - the stored procedure (if any) where the message <br>//                     occurred <br>//      usLine - the line number (if any) of the batch or stored procedure <br>//             where the message occurred <br>// <br>//  RETURNS: 0 <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>extern "C" int MessageHandler ( <br>    PDBPROCESS pDbproc, <br>    DBINT lMessage, <br>    INT nState, <br>    INT nSeverity, <br>    LPCSTR pszMessage, <br>    LPCSTR pszServer, <br>    LPCSTR pszProcedure, <br>    DBUSMALLINT usLine) <br>{ <br>    // only display certain SQL Serve messages when debug info enabled <br>    switch (lMessage) <br>    { <br>    case 5701: <br>        if (!bDebug) <br>        { <br>            return (0); <br>        } <br>        break; <br>    } <br> <br>    // display SQL Server message information <br>    cout &lt;&lt; "SQL Server"; <br> <br>    if (pszServer != NULL) <br>    { <br>        if (*pszServer != '\0') <br>        { <br>            cout &lt;&lt; " '" &lt;&lt; pszServer &lt;&lt; "'"; <br>        } <br>    } <br> <br>    cout &lt;&lt; " Message " &lt;&lt; lMessage &lt;&lt; ": " &lt;&lt; pszMessage; <br> <br>    if (usLine != 0) <br>    { <br>        cout &lt;&lt; " (Concerning line " &lt;&lt; usLine; <br>        if (pszProcedure != NULL) <br>        { <br>            cout &lt;&lt; " of stored procedure '" &lt;&lt; pszProcedure &lt;&lt; "'"; <br>        } <br>        cout &lt;&lt; ")"; <br>    } <br> <br>    cout &lt;&lt; endl; <br> <br>    return(0); <br>} <br> <br>/////////////////////////////////////////////////////////////////////////////// <br>// <br>//  FUNCTION: DisplayUsage() <br>// <br>//      Display usage information <br>// <br>//  PARAMETERS: <br>// <br>//  RETURNS: 0 <br>// <br>//  COMMENTS: <br>// <br>/////////////////////////////////////////////////////////////////////////////// <br> <br>int DisplayUsage (void) <br>{ <br>    cout &lt;&lt; endl; <br>    cout &lt;&lt; "Copies a single text or image value into or out of SQL Server. The value" &lt;&lt; endl; <br>    cout &lt;&lt; "is a specified text or image 'column' of a single row (specified by the" &lt;&lt; endl; <br>    cout &lt;&lt; "\"where clause\") of the specified 'table'." &lt;&lt; endl; <br>    cout &lt;&lt; endl; <br>    cout &lt;&lt; "If the direction is IN (/I) then the data from the specified 'file' is" &lt;&lt; endl; <br>    cout &lt;&lt; "copied into SQL Server, replacing the existing text or image value. If the" &lt;&lt; endl; <br>    cout &lt;&lt; "direction is OUT (/O) then the text or image value is copied from" &lt;&lt; endl; <br>    cout &lt;&lt; "SQL Server into the specified 'file', replacing any existing file." &lt;&lt; endl; <br>    cout &lt;&lt; endl; <br>    cout &lt;&lt; "TEXTCOPY [/S [sqlserver]] [/U [login]] [/P [password]]" &lt;&lt; endl; <br>    cout &lt;&lt; "  [/D [database]] [/T table] [/C column] [/W\"where clause\"]" &lt;&lt; endl; <br>    cout &lt;&lt; "  [/F file] [{/I | /O}] [/K chunksize] [/Z] [/?]" &lt;&lt; endl; <br>    cout &lt;&lt; endl; <br>    cout &lt;&lt; "  /S sqlserver       The SQL Server to connect to. If 'sqlserver' is not" &lt;&lt; endl; <br>    cout &lt;&lt; "                     specified, the local SQL Server is used." &lt;&lt; endl; <br>    cout &lt;&lt; "  /U login           The login to connect with. If 'login' is not specified," &lt;&lt; endl; <br>    cout &lt;&lt; "                     a trusted connection will be used." &lt;&lt; endl; <br>    cout &lt;&lt; "  /P password        The password for 'login'. If 'password' is not" &lt;&lt; endl; <br>    cout &lt;&lt; "                     specified, a NULL password will be used." &lt;&lt; endl; <br>    cout &lt;&lt; "  /D database        The database that contains the table with the text or" &lt;&lt; endl; <br>    cout &lt;&lt; "                     image data. If 'database' is not specified, the default" &lt;&lt; endl; <br>    cout &lt;&lt; "                     database of 'login' is used." &lt;&lt; endl; <br>    cout &lt;&lt; "  /T table           The table that contains the text or image value." &lt;&lt; endl; <br>    cout &lt;&lt; "  /C column          The text or image column of 'table'." &lt;&lt; endl; <br>    cout &lt;&lt; "  /W \"where clause\"  A complete where clause (including the WHERE keyword)" &lt;&lt; endl; <br>    cout &lt;&lt; "                     that specifies a single row of 'table'." &lt;&lt; endl; <br>    cout &lt;&lt; "  /F file            The file name." &lt;&lt; endl; <br>    cout &lt;&lt; "  /I                 Copy text or image value into SQL Server from 'file'." &lt;&lt; endl; <br>    cout &lt;&lt; "  /O                 Copy text or image value out of SQL Server into 'file'." &lt;&lt; endl; <br>    cout &lt;&lt; "  /K chunksize       Size of the data transfer buffer in bytes. Minimum" &lt;&lt; endl; <br>    cout &lt;&lt; "                     value is 1024 bytes, default value is 4096 bytes." &lt;&lt; endl; <br>    cout &lt;&lt; "  /Z                 Display debug information while running." &lt;&lt; endl; <br>    cout &lt;&lt; "  /?                 Display this usage information and exit." &lt;&lt; endl; <br>    cout &lt;&lt; endl; <br>    cout &lt;&lt; "You will be prompted for any required options you did not specify." &lt;&lt; endl; <br> <br>    return (0); <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
