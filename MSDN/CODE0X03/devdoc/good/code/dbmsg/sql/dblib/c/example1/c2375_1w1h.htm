<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXAMPLE1.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2375"></a>EXAMPLE1.C</h2>
<pre><code>/*example1.c */ <br>/* <br>**This example illustrates how to send two queries to <br>**SQL Server in a command batch.It binds each set <br>**of results and prints the rows. <br>** <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>#define DATELEN26 <br>#define TYPELEN2 <br> <br>/* Forward declarations of the error handler and message handler. <br>*/ <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br>main(argc, argv) <br>intargc; <br>char*argv[]; <br>{ <br>DBPROCESS*dbproc;/* Our connection with SQL Server. */ <br>LOGINREC*login;/* Our login information. */ <br> <br>/* These are the variables used to store the returning data. */ <br> <br>DBCHARcrdate[DATELEN+1]; <br>DBINTid; <br>DBCHARname[MAXNAME+1];/* MAXNAME is defined in <br>* "sqldb.h" as the maximum <br>* length for names of database <br>* objects, such as tables, <br>* columns, and procedures. <br>*/ <br>DBCHARtype[TYPELEN+1]; <br>RETCODEresult_code; <br> <br>        dbinit();/* initialize dblib */ <br> <br>/* Install the user-supplied error-handling and message-handling <br>* functions. They are defined at the bottom of this source file. <br>*/ <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br>/* <br>** Get a LOGINREC structure and fill it with the necessary <br>** login information. <br>*/ <br> <br>login = dblogin(); <br>DBSETLUSER(login, "user"); <br>DBSETLPWD(login, "my_passwd"); <br>DBSETLAPP(login, "example1"); <br>DBSETLVERSION(login, DBVER60); <br> <br>/* <br>** Get a DBPROCESS structure for communicating with SQL Server. <br>*/ <br> <br>dbproc = dbopen(login, "my_server"); <br> <br>/* <br>** We are going to retrieve some information from a table <br>** named "sysobjects", regarding names of system tables and <br>** stored procedures. <br>** We will submit two queries.The first finds all the rows <br>** that describe system tables.The second finds all the rows <br>** that describe stored procedures.The program will only look <br>** at the first 10 rows that describe stored procedures. <br>*/ <br> <br>/* First, put the commands into the command buffer. */ <br> <br>dbcmd(dbproc, "select name, type, id, crdate from sysobjects"); <br>dbcmd(dbproc, " where type = 'S' "); <br>dbcmd(dbproc, "select name, type, id, crdate from sysobjects"); <br>dbcmd(dbproc, " where type = 'P' "); <br> <br>/* <br>** SQL Server processes the command batch in the following <br>** order: <br>** <br>** 1)It checks for syntax errors (i.e., "use database pubs" <br>**is syntactically incorrect; it should be "use pubs"). <br>** 2)The second check is a semantic check (i.e., "select * from <br>**titels" is incorrect because the spelling should be <br>**"titles".) <br>** 3) The third check occurs in the actual execution phase. This <br>**check involves issues like permissions or memory problems. <br>** <br>** In the execution phase, dbsqlexec() and dbresults() can return <br>** the value "SUCCEED", which means there are more commands in the <br>** batch to process and that command was successful. A value <br>** of "FAIL" means that the query failed but there may be more <br>** commands in the batch to process. A value of "NO_MORE_RESULTS" <br>** means that there are no more commands in the batch to process. <br>** Therefore, the programmer must check the return values after <br>** dbsqlexec() and dbresults(), as illustrated below. <br>** <br>*/ <br> <br>/* Send the commands to SQL Server and start execution. */ <br>dbsqlexec(dbproc); <br> <br>/* Process each command until there are no more. */ <br> <br>while ((result_code = dbresults(dbproc)) != NO_MORE_RESULTS) <br>{ <br>if (result_code == SUCCEED) <br>{ <br>/* Bind program variables. */ <br> <br>dbbind(dbproc, 1, NTBSTRINGBIND, (DBINT) 0, name); <br>dbbind(dbproc, 2, NTBSTRINGBIND, (DBINT) 0, type); <br>dbbind(dbproc, 3, INTBIND, (DBINT) 0, (BYTE *) &amp;id); <br>dbbind(dbproc, 4, NTBSTRINGBIND, (DBINT) 0, crdate); <br> <br>/* Print appropriate header for the type of <br>* data coming back. <br>*/ <br> <br>printf("\n %s Objects: \n\n", <br>DBCURCMD(dbproc) == 1 ? "System Table": "Procedure"); <br> <br>/* Now print the rows. */ <br> <br>while (dbnextrow(dbproc) != NO_MORE_ROWS) <br>{ <br>/* <br>** If this is the 2nd command and <br>** 10th row, flush the rest of the <br>** rows for that command. <br>*/ <br> <br>if ((DBCURCMD(dbproc) == 2) <br>&amp;&amp; (DBCURROW(dbproc) &gt; 10)) <br>    continue; <br> <br>printf <br>("%s %s %ld %s\n", name, type, id, crdate); <br>} <br>} <br>} <br> <br> <br>/* Close our connection and exit the program. */ <br> <br>dbexit(); <br>return(STDEXIT); <br>} <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br>    printf("DB-LIBRARY error:\n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf("Operating-system error:\n\t%s\n", oserrstr); <br> <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return(INT_EXIT); <br> <br>return(INT_CANCEL); <br>} <br> <br>int msg_handler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br>printf <br>("SQL Server message %ld, state %d, severity %d:\n\t%s\n", <br>msgno, msgstate, severity, msgtext); <br>return(0); <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
