<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>NMPSDMP.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2383"></a>NMPSDMP.C</h2>
<pre><code>// NMPSDMP.C <br>// <br>// DBLIB program for using named pipe dump devices for backup and restore data <br>// from SQL Server 95.This program is an example and shows the usage of named pipe <br>// dump devices on the client side. <br>// <br>// <br>// The program needs the following arguments (it asks from the user interactively) : <br>//Operation: DUMP/LOAD <br>//Servername: Name of the server to dump from/load into <br>//Databasename: Name of the database to be dumped/loaded <br>//Stripenum: How many pipes are to be used for dump/load <br>//Dumpname: Prefix of the files to write/read the dumped/load data (DMP postfix) <br> <br>#define DBNTWIN32 <br>#include &lt;windows.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>// definitions <br>#define MAX_DEVICES32// maximum number of stripe devices <br>#define PIPE_WAIT_TIME500// wait time in milliseconds <br>#defineDBPAGESIZE2048// size of physical page dumped <br> <br>// status values for dump/load threads <br>#define STAT_SUCCESS0x0// default status <br>#define STAT_ERROR0x1  // error in the current thread <br>#define STAT_ENDTHREAD0x2// the current thread has terminated <br> <br>// opcode values <br>#define DUMP_MODE0x1// dump mode of operation <br>#define LOAD_MODE0x2// load mode of operation <br> <br>// this structure is maintained on a global basis among all threads that <br>// are doing reads/writes from pipe <br>typedef struct ginfo <br>{ <br>char servername[30];// server name <br>char dbname[30];// database name <br>char dumpname[80];// dump file prefix <br>charpassword[30];// dblogin password of SA <br>longstatus;// global status flag for error recovery <br>shortopcode;// operation code <br>shortstripenum;// number of pipe devices to be used <br>} GINFO; <br> <br>// this structure contains pipe specific info to be run by different threads <br>// that read/write data during the stripe dump/load <br>typedef struct pipeinfo <br>{ <br>charpipename[80];// Physical name of pipe used for client <br>charspipename[80];// Physical name of pipe sent to SQL Server <br>chardumpname[80];// Physical name of the dump file <br>shortslot;// which device slot <br>GINFO*curinfo;// pointer to global info buffer <br>longstatus;// thread local status <br>} PIPEINFO; <br> <br>// Macros <br># define NEWARG(i)   (*(argv[i]) == '-' || *(argv[i]) == '/') <br># define BUFALIGN(a)    ( (BYTE *) ( ((long)a + 64) &amp; 0xffffffc0) ) <br> <br> <br>// function prototypes <br>void parse_parms(int argc, char *argv[], GINFO *curinfo); <br>void argvalue(int i, int argc, char* argv[], char* out); <br>int set_up_pipes(GINFO *curinfo, PIPEINFO **pipes); <br>void close_up_pipes(GINFO *curinfo, PIPEINFO **pipes); <br>void dump_proc(PIPEINFO*curpipe); <br>void load_proc(PIPEINFO*curpipe); <br>INT msg_handler(PDBPROCESS,DBINT,INT,INT,LPCSTR,LPCSTR,LPCSTR,DBUSMALLINT); <br>INT err_handler(PDBPROCESS,INT,INT,INT,LPCSTR,LPCSTR); <br> <br>// start of the progam <br>main(int argc, char *argv[]) <br>{ <br> <br>RETCODEretcode;// DBLIB return code <br>LOGINREC *loginrec = NULL;// DBLIB LOGINREC pointer <br>DBPROCESS *dbproc = NULL;// DBLIB DBPROC pointer <br>GINFOinfo;// to store global info &amp; status <br>PIPEINFO*pipes[MAX_DEVICES];// array of PIPEINFO pointers <br>charcmd[1024];// SQL command buffer <br> <br>   // scratch variables <br>  charscratch[80]; <br>inti; <br> <br>  // Initialize <br>for (i=0; i&lt;MAX_DEVICES; i++) <br>pipes[i] = NULL; <br> <br>info.servername[0] = 0; <br>info.dbname[0] = 0; <br>info.dumpname[0] = 0; <br>info.password[0] = 0; <br>info.stripenum = 1; <br>info.opcode = DUMP_MODE; <br>info.status = STAT_SUCCESS; <br> <br>// read the user input <br>parse_parms(argc, argv, &amp;info); <br> <br>// Install the DBLIB handlers <br>dberrhandle(err_handler); <br>dbmsghandle(msg_handler); <br> <br>printf("Logging on to server...\n"); <br> <br>loginrec = dblogin(); <br>DBSETLUSER(loginrec, "sa"); <br>DBSETLPWD(loginrec,""); <br> <br>if ((dbproc = dbopen(loginrec, info.servername)) == (DBPROCESS *)NULL) <br>{ <br>  printf("dbopen() failed"); <br>  info.status |= STAT_ERROR; <br>  goto clean_up; <br>}; <br> <br>// Set up the thread(s) for reading/writing the pipe device <br>if (!set_up_pipes(&amp;info, pipes)) <br>{ <br>info.status |= STAT_ERROR; <br>goto clean_up; <br>} <br> <br>// prepare the command now <br>if (info.opcode == DUMP_MODE) <br>strcpy(cmd, "dump database "); <br>else <br>strcpy(cmd, "load database "); <br>strcat(cmd, info.dbname); <br>if (info.opcode == DUMP_MODE) <br>strcat(cmd, " to "); <br>else <br>strcat(cmd, " from "); <br>for (i=0; i &lt; info.stripenum; i++) <br>{ <br>sprintf(scratch, "pipe = '%s'", &amp;pipes[i]-&gt;spipename); <br>strcat(cmd, scratch); <br>if ((i+1) &lt; info.stripenum) <br>strcat(cmd, ", "); <br>} <br>printf("Command : &lt;%s&gt;\n", cmd); <br> <br>// this thread will be blocked till the dump/load command is not <br>// completed; for changing the behavior to non blocking, use <br>// dbsqlsend(), dbdataready() and dbsqlok() instead of dbsqlexec() <br>retcode = dbcmd(dbproc, cmd); <br>    retcode = dbsqlexec(dbproc); <br> <br>   if (retcode != SUCCEED) <br>{ <br>printf("dbsqlexec failed\n"); <br>info.status |= STAT_ERROR; <br>goto clean_up; <br>} <br> <br>   // discard results ; we do not need it <br>   while (dbresults(dbproc) == SUCCEED) <br>    while (dbnextrow(dbproc) != NO_MORE_ROWS) <br>; <br> <br>// We are done with all the work ; clean up the resources and exit <br>// strictly speaking, cleanup is not necessary for this since we <br>// will exit the program (but for implementing this as a procedures <br>// would involve cleanup) <br>clean_up: <br> <br>if (dbproc) <br>   dbclose(dbproc); <br>if (loginrec) <br>dbfreelogin(loginrec); <br> <br>close_up_pipes(&amp;info, pipes); <br>exit(1); <br>    return(0); <br>} <br> <br>// procedure to get all the parameters <br>void  parse_parms(int argc, char *argv[], GINFO *curinfo) <br>{ <br>int     i; <br>char    argval[30]; <br> <br>for (i = 0 ; i &lt; argc; i++) <br>{ <br>if (NEWARG(i)) <br>{ <br>switch(*(argv[i] + 1)) <br>{ <br>case 'S' : // Servername <br>argvalue(i,argc,argv,curinfo-&gt;servername); <br>break; <br> <br>case 'D' : // Databasename <br>argvalue(i,argc,argv,curinfo-&gt;dbname); <br>break; <br> <br>case 'P' : // SA password <br>argvalue(i,argc,argv,curinfo-&gt;password); <br>break; <br> <br>case 'N' : // Stripe Number <br>argvalue(i,argc,argv,argval); <br>if ((curinfo-&gt;stripenum = (short)atoi(argval)) &lt; 1) <br>{ <br>printf("Invalid value %d for stripe device. Setting to 1\n"); <br>curinfo-&gt;stripenum = 1; <br>} <br>else if (curinfo-&gt;stripenum &gt; MAX_DEVICES) <br>{ <br>printf("Invalid value %d for stripe device. Setting to %d\n", <br>MAX_DEVICES); <br>curinfo-&gt;stripenum = MAX_DEVICES; <br>} <br>break; <br> <br>case 'F' : // Dump file prefix <br>argvalue(i,argc,argv,curinfo-&gt;dumpname); <br>break; <br> <br>case 'O' : // Mode of operation <br>argvalue(i,argc,argv,argval); <br>if ( (!strcmp(argval, "DUMP")) || (!strcmp(argval, "dump")) ) <br>curinfo-&gt;opcode = DUMP_MODE; <br>else if ( (!strcmp(argval, "LOAD")) || (!strcmp(argval, "load")) ) <br>curinfo-&gt;opcode = LOAD_MODE; <br>else <br>{ <br>printf("Invalid mode %s specified\n", argval); <br>exit(1); <br>} <br>break; <br> <br>case '?' : // Help message <br>printf("NMPSDMP -Sservername -Ppassword -O{dump | load} -Ddatabasename -Nstripenumber -Fdumpprefix\n"); <br>exit(1); <br>break; <br> <br>default: <br>printf("Invalidparameter option : %s\n", *(argv[i] + 1) ); <br>printf("NMPSDMP -Sservername -Ppassword -O{dump | load} -Ddatabasename -Nstripenumber -Fdumpprefix\n"); <br>exit(1); <br>} <br>} <br>} <br>return; <br>} <br> <br>// argument reading routine for parse_parms() <br>void argvalue( <br>    int   i,                           // parameter number <br>    int   argc,                        // #args <br>    char* argv[],                      // arglist <br>    char* out                          // receives parm 'i' <br>){ <br>if( *(argv[i]+2) ) <br>strcpy(out, argv[i]+2); <br>else <br>{ <br>if( i+1&lt;argc &amp;&amp; !( NEWARG(i+1) ) ) <br>            strcpy(out, argv[i+1]); <br>} <br>} <br> <br>// procedure to setup all the threads for reading pipes <br>// <br>// return : 1 if success <br>//0 otherwise <br>int set_up_pipes(GINFO *curinfo, PIPEINFO **pipes) <br>{ <br> <br>inti; <br>PIPEINFO*curpipe; <br>charpipebuf[30]; <br> <br>// for every device <br>for (i=0; i &lt; curinfo-&gt;stripenum; i++) <br>{ <br>// allocate for the current pipe <br>if ((curpipe = malloc(sizeof(PIPEINFO))) == NULL) <br>return 0; <br>curpipe-&gt;slot = i; <br>curpipe-&gt;curinfo = curinfo; <br>curpipe-&gt;status = STAT_SUCCESS; <br> <br>// prepare the pipe name <br>strcpy(curpipe-&gt;pipename, "\\\\"); <br>strcpy(curpipe-&gt;spipename, "\\\\"); <br>if (curinfo-&gt;servername[0]) <br>strcat(curpipe-&gt;pipename, curinfo-&gt;servername); <br>else <br>strcat(curpipe-&gt;pipename, "."); <br>strcat(curpipe-&gt;spipename, "."); <br>strcat(curpipe-&gt;pipename, "\\pipe\\"); <br>strcat(curpipe-&gt;spipename, "\\pipe\\"); <br>sprintf(pipebuf, "sqldmpld%d", i); <br>strcat(curpipe-&gt;pipename, pipebuf); <br>strcat(curpipe-&gt;spipename, pipebuf); <br> <br>// prepare the dump file name <br>sprintf(curpipe-&gt;dumpname, "%s%d.dmp", curinfo-&gt;dumpname, i); <br> <br>// now start the thread for this device <br>pipes[i] = curpipe; <br>if (curinfo-&gt;opcode == DUMP_MODE) <br>{ <br>if (!(_beginthread(dump_proc, 0, (LPVOID)curpipe))) <br>{ <br>printf("beginthread failed for slot %d\n", i); <br>return 0; <br>} <br>} <br>else <br>{ <br>if (!(_beginthread(load_proc, 0, (LPVOID)curpipe))) <br>{ <br>printf("beginthread failed for slot %d\n", i); <br>return 0; <br>} <br>} <br>} <br> <br>// started all the threads <br>return 1; <br>} <br> <br>// procedure to close all the threads for reading/writing pipes <br>// <br>// return : nothing <br>// <br>void close_up_pipes(GINFO *curinfo, PIPEINFO **pipes) <br>{ <br>inti; <br>PIPEINFO*curpipe; <br> <br>// check if we need to clean up <br>if (!curinfo-&gt;stripenum) <br>return; <br> <br>// for every open device <br>for (i=0; i &lt; curinfo-&gt;stripenum; i++) <br>{ <br>if (!(curpipe = pipes[i])) <br>continue; <br> <br>// wait for the thread to close itself <br>while (!(curpipe-&gt;status &amp; STAT_ENDTHREAD)) <br>SleepEx(10, TRUE); <br> <br>// free the allocated memory <br>free(curpipe); <br>} <br>} <br> <br>// DUMP_PROC <br>// This procedure does the opening and reading of dumped data sent <br>//by the SQL Server. Each thread invoked with this routine services <br>//one named pipe (instance) connection; for simplicity we are creating <br>//separate named pipes for each stripe number. <br>// <br>//For dump process, the thread opens the pipe created by SQL Server <br>// and connects to it. Then keeps reading data and writing it <br>//out to the dumpfile till the SQL Server is done. <br> <br>void dump_proc(PIPEINFO*curpipe) <br>{ <br>GINFO*curinfo = curpipe-&gt;curinfo; <br>HANDLEhpipe = NULL; <br>HANDLEhfile = NULL; <br>BYTE*buf_start = NULL; <br>BYTE*buf_ptr; <br>DWORDbufsize, cbread, cbwritten, mode; <br>DWORDerrcode = 0; <br>DWORDoffl, offh; <br> <br>// Open the pipe <br>while (1) <br>{ <br> <br>// check the global flag <br>if (curinfo-&gt;status &amp; STAT_ERROR) <br>goto dump_proc_cleanup; <br> <br>hpipe = CreateFile(curpipe-&gt;pipename, <br>GENERIC_READ | GENERIC_WRITE, 0, NULL, <br>OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL); <br> <br>// break if handle is valid <br>if (hpipe != INVALID_HANDLE_VALUE) <br>break; <br> <br>// check the pipe state <br>errcode = GetLastError(); <br>if (errcode == ERROR_FILE_NOT_FOUND) <br>{ <br>// SQL Server has not yet created the pipe; wait <br>SleepEx(PIPE_WAIT_TIME, TRUE); <br>continue; <br>} <br>else if (errcode != ERROR_PIPE_BUSY) <br>{ <br>printf("Error in %s : %d\n", "CreateFile", errcode); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br> <br>// Wait for sometime if pipe is busy <br>if (!WaitNamedPipe(curpipe-&gt;pipename, PIPE_WAIT_TIME)) <br>{ <br>printf("Error in %s : %d\n", "WaitNamedPipe", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br>} <br> <br>printf("dump thread : %d : connected to server\n", curpipe-&gt;slot); <br> <br>// get the buffer size <br>if ((!GetNamedPipeInfo(hpipe, NULL, NULL, &amp;bufsize, NULL)) || (bufsize == 0)) <br>{ <br>printf("Error in %s : %d\n", "GetNamedPipeInfo", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br> <br>// Align the buffer size to database pagesize if necessary <br>if (bufsize % DBPAGESIZE) <br>bufsize = ((bufsize / DBPAGESIZE) - 1) * DBPAGESIZE; <br>//printf("dump thread : %d : buffer size %d \n", curpipe-&gt;slot, bufsize); <br> <br>// allocate the buffer for reading incoming data and align it <br>if ((buf_start = malloc(bufsize + 64)) == NULL) <br>{ <br>printf("malloc failed\n"); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br>buf_ptr = BUFALIGN(buf_start); <br> <br>// Set the pipe mode to message read mode  <br>mode = PIPE_READMODE_MESSAGE; <br>if (!SetNamedPipeHandleState(hpipe, &amp;mode, NULL, NULL)) <br>{ <br>printf("Error in %s : %d\n", "SetNamedPipeHandleState", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br> <br>// open the dump file ; if it exists then overwrite it <br>// otherwise open a new file <br>hfile = CreateFile(curpipe-&gt;dumpname, <br>            GENERIC_READ | GENERIC_WRITE, 0, NULL, <br>            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0); <br>if (hfile == INVALID_HANDLE_VALUE) <br>{ <br>printf("Error in %s : %d\n", "CreateFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br> <br>// set the file pointer to start of file <br>offh = 0; <br>if ((offl = SetFilePointer(hfile, 0, &amp;offh, FILE_BEGIN)) == -1) <br>{ <br>printf("Error in %s : %d\n", "SetFilePointer", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br> <br>// now we are all set to read from the pipe; keep reading till the pipe is <br>// closed. <br>while (1) <br>{ <br>// check the global flag <br>if (curinfo-&gt;status &amp; STAT_ERROR) <br>goto dump_proc_cleanup; <br> <br>if (!ReadFile(hpipe, buf_ptr, bufsize, &amp;cbread, NULL)) <br>{ <br>// Are we done reading <br>if ((errcode = GetLastError()) == ERROR_BROKEN_PIPE) <br>break; <br>if (errcode != ERROR_MORE_DATA) <br>{ <br>printf("Error in %s : %d\n", "ReadFile", errcode); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br>} <br>//printf("dump thread : %d : read %d bytes\n", curpipe-&gt;slot, cbread); <br>if (!WriteFile(hfile, buf_ptr, cbread, &amp;cbwritten, NULL)) <br>{ <br>printf("Error in %s : %d\n", "WriteFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto dump_proc_cleanup; <br>} <br>} <br> <br>dump_proc_cleanup: <br> <br>// release the resources <br>if (buf_start) <br>free(buf_start); <br>if (hfile) <br>{ <br>FlushFileBuffers(hfile); <br>CloseHandle(hfile); <br>} <br>if (hpipe) <br>CloseHandle(hpipe); <br> <br>// set the status flags <br>curpipe-&gt;status |= STAT_ENDTHREAD; <br>if (curpipe-&gt;status &amp; STAT_ERROR) <br>curinfo-&gt;status |= STAT_ERROR; <br> <br>return; <br>} <br> <br>// LOAD_PROC <br>// This procedure does the opening and writing of dumped data sent <br>//to the SQL Server. Each thread invoked with this routine services <br>//one named pipe (instance) connection; we are create <br>//separate named pipes for each stripe number. <br>// <br>//For load process, the thread opens the pipe created by SQL Server <br>// and connects to it. Then keeps reading data from the dumpfile till end <br>//  and writes to the pipe; Finally closes the pipe when done. <br> <br>void load_proc(PIPEINFO*curpipe) <br>{ <br>GINFO*curinfo = curpipe-&gt;curinfo; <br>HANDLEhpipe = NULL; <br>HANDLEhfile = NULL; <br>BYTE*buf_start = NULL; <br>BYTE*buf_ptr; <br>DWORDbufsize, cbread, cbwritten, mode; <br>DWORDerrcode = 0; <br>DWORDoffl, offh; <br> <br>// Open the pipe <br>while (1) <br>{ <br> <br>// check the global flag <br>if (curinfo-&gt;status &amp; STAT_ERROR) <br>goto load_proc_cleanup; <br> <br>hpipe = CreateFile(curpipe-&gt;pipename, <br>GENERIC_READ | GENERIC_WRITE, 0, NULL, <br>OPEN_EXISTING, FILE_FLAG_WRITE_THROUGH, NULL); <br> <br>// break if handle is valid <br>if (hpipe != INVALID_HANDLE_VALUE) <br>break; <br> <br>// check the pipe state <br>errcode = GetLastError(); <br>if (errcode == ERROR_FILE_NOT_FOUND) <br>{ <br>// SQL Server has not yet created the pipe; wait <br>SleepEx(PIPE_WAIT_TIME, TRUE); <br>continue; <br>} <br>else if (errcode != ERROR_PIPE_BUSY) <br>{ <br>printf("Error in %s : %d\n", "CreateFile", errcode); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// Wait for sometime if pipe is busy <br>if (!WaitNamedPipe(curpipe-&gt;pipename, PIPE_WAIT_TIME)) <br>{ <br>printf("Error in %s : %d\n", "WaitNamedPipe", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br>} <br> <br>printf("load thread : %d : connected to server\n", curpipe-&gt;slot); <br> <br>// get the buffer size <br>if ((!GetNamedPipeInfo(hpipe, NULL, NULL, &amp;bufsize, NULL)) || (bufsize == 0)) <br>{ <br>printf("Error in %s : %d\n", "GetNamedPipeInfo", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// Align the buffer size to database pagesize if necessary <br>if (bufsize % DBPAGESIZE) <br>bufsize = ((bufsize / DBPAGESIZE) - 1) * DBPAGESIZE; <br>//printf("load thread : %d : buffer size %d \n", curpipe-&gt;slot, bufsize); <br> <br>// allocate the buffer for reading incoming data and align it <br>if ((buf_start = malloc(bufsize + 64)) == NULL) <br>{ <br>printf("malloc failed\n"); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br>buf_ptr = BUFALIGN(buf_start); <br> <br>// Set the pipe mode to message read mode  <br>mode = PIPE_READMODE_MESSAGE; <br>if (!SetNamedPipeHandleState(hpipe, &amp;mode, NULL, NULL)) <br>{ <br>printf("Error in %s : %d\n", "SetNamedPipeHandleState", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// open the dump file ; it should exist <br>hfile = CreateFile(curpipe-&gt;dumpname, <br>            GENERIC_READ | GENERIC_WRITE, 0, NULL, <br>            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0); <br>if (hfile == INVALID_HANDLE_VALUE) <br>{ <br>printf("Error in %s : %d\n", "CreateFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// set the file pointer to start of file <br>offh = 0; <br>if ((offl = SetFilePointer(hfile, 0, &amp;offh, FILE_BEGIN)) == -1) <br>{ <br>printf("Error in %s : %d\n", "SetFilePointer", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// <br>// Read the first page and write it to the pipe <br>// <br>if ((!ReadFile(hfile, buf_ptr, DBPAGESIZE, &amp;cbread, NULL)) ||  <br>(cbread != DBPAGESIZE)) <br>{ <br>printf("Error in %s : %d\n", "ReadFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br>if (!WriteFile(hpipe, buf_ptr, DBPAGESIZE, &amp;cbwritten, NULL)) <br>{ <br>printf("Error in %s : %d\n", "WriteFile", errcode); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br>//printf("load thread : %d : wrote %d bytes\n", curpipe-&gt;slot, cbwritten); <br> <br>// now we are all set to read from the dumpfile; keep reading till we reach <br>// the end of dumpfile <br>while (1) <br>{ <br>// check the global flag <br>if (curinfo-&gt;status &amp; STAT_ERROR) <br>goto load_proc_cleanup; <br> <br>// read from the dump file <br>if (!ReadFile(hfile, buf_ptr, bufsize, &amp;cbread, NULL)) <br>{ <br>// check if we are done reading <br>if ((errcode = GetLastError()) == ERROR_HANDLE_EOF) <br>break; <br> <br>printf("Error in %s : %d\n", "ReadFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br> <br>// Done reading the dump file <br>if (cbread == 0) <br>break; <br> <br>// write to the pipe <br>if (!WriteFile(hpipe, buf_ptr, cbread, &amp;cbwritten, NULL)) <br>{ <br>printf("Error in %s : %d\n", "WriteFile", GetLastError()); <br>curpipe-&gt;status |= STAT_ERROR; <br>goto load_proc_cleanup; <br>} <br>//printf("load thread : %d : wrote %d bytes\n", curpipe-&gt;slot, cbwritten); <br>} <br> <br>load_proc_cleanup: <br> <br>// release the resources <br>if (buf_start) <br>free(buf_start); <br>if (hfile) <br>CloseHandle(hfile); <br>if (hpipe) <br>{ <br>FlushFileBuffers(hpipe); <br>CloseHandle(hpipe); <br>} <br> <br>// set the status flags <br>curpipe-&gt;status |= STAT_ENDTHREAD; <br>if (curpipe-&gt;status &amp; STAT_ERROR) <br>curinfo-&gt;status |= STAT_ERROR; <br> <br>return; <br>} <br> <br> <br>INT msg_handler(dbproc,msgno,msgstate, severity, msgtext,server,proc,line) <br>PDBPROCESS dbproc; <br>DBINT msgno; <br>INT msgstate; <br>INT severity; <br>LPCSTRmsgtext; <br>LPCSTRserver; <br>LPCSTRproc; <br>DBUSMALLINT line; <br>{ <br>   if (severity) <br>      printf("\nDB-LIB message: %s \n", msgtext); <br>   return (0); <br>}; <br> <br>INT err_handler(dbproc,severity, herrno, oserr, dberrstr, oserrstr) <br>PDBPROCESS dbproc; <br>INT    severity; <br>INT herrno; <br>INT oserr; <br>LPCSTR dberrstr; <br>LPCSTR oserrstr; <br>{ <br>if (severity) <br>      printf("\nDB-LIBRARY error: %s \n", dberrstr); <br>    return (INT_CANCEL); <br>}; <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
