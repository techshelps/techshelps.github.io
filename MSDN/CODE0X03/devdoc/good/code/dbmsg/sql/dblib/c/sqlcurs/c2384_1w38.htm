<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>SQLCURS.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2384"></a>SQLCURS.C</h2>
<pre><code>/************************************************************************* <br> <br>PROGRAM: SQLCURS - SQL DB-Library cursors sample program <br> Copyright (c), 1995 by Microsoft Corp. <br> <br>*************************************************************************/ <br> <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt;/* DBLIB header files (should always be included    */ <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#include &lt;string.h&gt; <br> <br>#ifndef NULL <br>#define    NULL    0 <br>#endif <br> <br>#define INVALID_VALUE (short)-100 <br> <br>/* Forward declarations of the error handler and message handler. */ <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br>void ProcessResults(void); <br> <br>#define NROWS    5/* Number of rows to be scrolled at a time   */ <br> <br> <br>/* Select statement to be used in the cursor case */ <br> <br>char stmt[] = " select au_lname, au_fname, city, state from authors where contract = 1 "; <br> <br> <br>/* Status array, and results set */ <br> <br>DBINT    pstat[NROWS]; <br>char    au_lname[NROWS][41]; <br>char    au_fname[NROWS][21]; <br>char    au_city[NROWS][21]; <br>char    au_state[NROWS][3]; <br>DBINT    au_citlen[NROWS]; <br>DBINT    au_statlen[NROWS]; <br>DBINT    au_fnamlen[NROWS]; <br>char    *stats[NROWS]; <br>char    values[250]; <br>short     ScrollOpt; <br>short     ConcurOpt; <br>int       ch; <br> <br>main () <br>{ <br>DBPROCESS *dbproc;/* allocate a DB-LIB process structure*/ <br>LOGINREC  *login;/* allocate a DB-LIB login structure*/ <br>DBCURSOR  *hcursor; /* allocate a DB-LIB cursor structure*/ <br> <br>char       Servername[21] = ""; <br>RETCODE    result_code; <br>int     fetch, optype; <br>int     nrow; <br>char    sfetch[3], soptype[3]; <br>char    srow[3], stab[31]; <br> <br>/* Install the user-supplied error-handlingand message-handling <br> * routines. They are defined at the bottomof thissource file. <br> */ <br> <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br> <br>/* Get server's computer name */ <br>printf ("\nEnter Name of SQL Server: "); <br>gets (Servername); <br> <br>ScrollOpt = INVALID_VALUE; <br>do  <br>{ <br>printf ("\nEnter Scroll Option: F)orward  K)eyset  D)ynamic  I)nsensitive: "); <br>ch = tolower(_getch()); <br>switch (ch) <br>{ <br>case 'f': ScrollOpt = CUR_FORWARD; break; <br>case 'k': ScrollOpt = CUR_KEYSET;  break; <br>case 'd': ScrollOpt = CUR_DYNAMIC; break; <br>case 'i': ScrollOpt = CUR_INSENSITIVE; break; <br>default:  printf("Invalid character entered."); break; <br>} <br>} while (ScrollOpt == INVALID_VALUE); <br> <br>ConcurOpt = INVALID_VALUE; <br>do  <br>{ <br>printf ("\nEnter Concurrency Option: R)ead Only   L)ock CC   O)opt CC   V)al Opt CC: "); <br>ch = tolower(_getch()); <br>switch (ch) <br>{ <br>case 'r': ConcurOpt = CUR_READONLY; break; <br>case 'l': ConcurOpt = CUR_LOCKCC;   break; <br>case 'o': ConcurOpt = CUR_OPTCC;    break; <br>case 'v': ConcurOpt = CUR_OPTCCVAL; break; <br>default:  printf("Invalid character entered."); break; <br>} <br>} while (ConcurOpt == INVALID_VALUE); <br>printf("\n"); <br>login = dblogin();    /* get login recordfrom DB-LIB */ <br>DBSETLUSER (login, (char far *)"sa");     /* set the username*/ <br>DBSETLAPP (login, (char far *)"curtest"); /* set the application name */ <br>DBSETLPWD (login, (char far *)"");      /* set the SQL Server password */ <br>DBSETLVERSION(login, DBVER60); <br> <br>/* Now attempt to create and initialize a DBPROCESSstructure */ <br>if((dbproc = dbopen (login, Servername)) == NULL) <br>{ <br>printf ("dbopen failed\n"); <br>return (1); /* exit program */ <br>} <br> <br>dbuse (dbproc, "pubs");  /* use the "pubs" database */ <br> <br>/* Open the cursor */ <br>hcursor = dbcursoropen(dbproc, stmt, ScrollOpt, ConcurOpt, NROWS, pstat); <br>if (hcursor == (DBCURSOR *)NULL) <br>{ <br>printf("\ndbcursoropen failed\n"); <br>return(1); <br>} <br> <br>/* Bind variables */ <br>result_code = dbcursorbind(hcursor, 1, NTBSTRINGBIND, 41, NULL, (char *)au_lname); <br>if (result_code == FAIL) <br>{ <br>printf("\ndbcursorbind failed, column 1\n"); <br>return(1); <br>} <br>result_code = dbcursorbind(hcursor, 2, NTBSTRINGBIND, 21, au_fnamlen, (char *)au_fname); <br>if (result_code == FAIL) <br>{ <br>printf("\ndbcursorbind failed, column 2\n"); <br>return(1); <br>} <br>result_code = dbcursorbind(hcursor, 3, NTBSTRINGBIND, 21, au_citlen, (char *)au_city); <br>if (result_code == FAIL) <br>{ <br>printf("\ndbcursorbind failed, column 3\n"); <br>return(1); <br>} <br> <br>result_code = dbcursorbind(hcursor, 4, NOBIND, 0, au_statlen, (char *)stats); <br>if (result_code == FAIL) <br>{ <br>printf("\ndbcursorbind failed, column 4\n"); <br>return(1); <br>} <br> <br>/* Begin transaction. Will exit without committing the transaction so that <br>** none of the data modifications will actually be committed */ <br>if ((dbcmd(dbproc, "begin transaction") == FAIL) || <br>(dbsqlexec(dbproc) == FAIL) || (dbresults(dbproc) == FAIL)) <br>{ <br>printf("\n BEGIN TRAN failed"); <br>return(1); <br>} <br> <br>/* Now fetch and print the rows */ <br>while (TRUE) <br>{ <br>printf("\n0)Leave  1)First  2)Next  3)Previous  4)Random  5)Relative  6)Last  7)By Value"); <br>printf("\nEnter fetch value: "); <br>fetch = atoi(gets(sfetch)); <br>if (fetch != 0) <br>{ <br>if ((fetch == FETCH_RANDOM) || (fetch == FETCH_RELATIVE)) <br>{ <br>printf("\n Enter row number: "); <br>nrow = atoi(gets(srow)); <br>} <br>else <br>nrow = 0; <br> <br>if (dbcursorfetchex(hcursor, fetch, nrow, NROWS, 0) == FAIL) <br>printf("\ndbcursorfetchex() failed\n"); <br> <br>ProcessResults(); <br>continue;/* Fetch again */ <br>} <br> <br>/* Do updates */ <br>while (TRUE) <br>{ <br>printf("\n0)Leave  1)Update  2)Delete  3)Insert  4)Refresh  5)Lock  6)Cursor Fetch"); <br>printf("\nEnter operation: "); <br>optype = atoi(gets(soptype)); <br> <br>if ((optype == 0) || (optype == 6))/* Exit condition */ <br>break; <br> <br>if (optype &gt; 6) <br>continue; <br> <br>printf("\nEnter buffer number: "); <br>nrow = atoi(gets(srow)); <br>printf("\nEnter table: "); <br>gets(stab); <br>printf("\nEnter values: "); <br>gets(values); <br>if (values == (char *)NULL) <br>values[0] = '\0'; <br>if ((result_code=dbcursor(hcursor, optype, nrow, stab, values)) == FAIL) <br>printf("\n dbcursor failed"); <br>else <br>if (optype == CRS_REFRESH) <br>ProcessResults(); <br>else <br>printf("\ndbcursor() succeeded"); <br> <br>} /* Exit dbcursor() loop */ <br> <br>if (optype == 0) <br>break;   /* Close cursor */ <br>} <br> <br>dbcursorclose(hcursor); <br> <br>dbexit(); <br>} <br> <br>void ProcessResults() <br>{ <br>int i, len; <br> <br>printf(" Row       First Name                 Last Name                City       State\n"); <br>printf("----- -------------------- ------------------------------ --------------- -----\n"); <br>for (i = 0 ; i &lt; NROWS ; i++) <br>{/* Process results */ <br>if(pstat[i] &amp; FTC_SUCCEED) <br>{ <br>len = 0; <br>if (au_statlen[i] != 0) /* This is a NOBIND type */ <br>{ <br>len = min(2, (SHORT)au_statlen[i]); <br>memcpy(au_state[i], stats[i], len); <br>} <br>au_state[i][len] = '\0'; <br>  printf("%5d %-20s %-30s %-15s %-2s\n",i+1,au_fname[i],au_lname[i],au_city[i],au_state[i]); <br>} <br>else <br>if (pstat[i] &amp;  FTC_MISSING) <br>printf("\n Row no. %d is missing", i+1); <br> <br>/* <br> <br>The following code could be used if dbcursorfetch() <br>was used instead of dbcursorfetchex(). <br> <br>if (pstat[i] &amp; FTC_ENDOFRESULTS) <br>{ <br>printf("\n End of results"); <br>break; <br>} <br>if (pstat[i] &amp; FTC_ENDOFKEYSET) <br>{ <br>printf("\nEnd of keyset"); <br>break; <br>} <br>*/ <br> <br>} <br>return; <br>} <br> <br>int err_handler(dbproc,severity, dberr, oserr,dberrstr, oserrstr) <br>DBPROCESS *dbproc; <br>int severity; <br>int dberr; <br>int oserr; <br>char    *dberrstr; <br>char    *oserrstr; <br>{ <br>printf("DB-LIBRARY error:\n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf("Operating-system error:\n\t%s\n", oserrstr); <br> <br>if ((dbproc == NULL) ||(DBDEAD(dbproc))) <br>return(INT_EXIT); <br>else <br>{ <br>return(INT_CANCEL); <br>} <br>} <br> <br>int msg_handler(dbproc,msgno, msgstate, severity, msgtext) <br>DBPROCESS *dbproc; <br>DBINT msgno; <br>int msgstate; <br>int severity; <br>char    *msgtext; <br>{ <br>printf("SQL Server message %ld, state %d, severity %d:\n\t%s\n", <br>msgno,msgstate, severity, msgtext); <br>return(0); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
