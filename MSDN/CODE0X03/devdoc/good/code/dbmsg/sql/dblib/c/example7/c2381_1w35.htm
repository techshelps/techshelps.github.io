<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>EXAMPLE7.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2381"></a>EXAMPLE7.C</h2>
<pre><code>/*example7.c */ <br>/* <br>** This example illustrates the use of browse mode functions to <br>** determine the source of result columns from ad hoc queries. <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>voidexamine_results(); <br>BOOL send_command(); <br> <br>/* Forward declarations of the error-handling and message-handling <br>functions. */ <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br>main() <br>{ <br>LOGINREC*login; <br>DBPROCESS*dbproc; <br> <br>intcommand_count = 0; <br>RETCODEretcode; <br> <br>        dbinit();/* initialize dblib */ <br> <br>/* Install the user-supplied error-handling and message-handling <br>* functions. They are defined at the bottom of this source file. <br>*/ <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br>/* Allocate and initialize the LOGINREC structure to be used <br>* to open a connection to SQL Server. <br>*/ <br> <br>login = dblogin(); <br>DBSETLUSER(login, "user"); <br>DBSETLPWD(login, "my_passwd"); <br>DBSETLAPP(login, "example7"); <br>DBSETLVERSION(login, DBVER60); <br> <br>dbproc = dbopen(login, "my_server"); <br> <br>/* Allow the user to type in a series of queries. This program <br>* is terminated by the word "quit" appearing at the <br>* beginning of the line. <br>*/ <br>while (1) <br>{ <br>// Send a user-generated query to SQL Server. <br>// Exit if user typed in quit. <br> <br>if (!send_command(dbproc)) <br>break; <br> <br>/* Now, examine the results of any queries the user has <br>* typed in. <br>*/ <br> <br>command_count = 1; <br>while ((retcode = dbresults(dbproc)) != NO_MORE_RESULTS) <br>{ <br>command_count++ ; <br>if (retcode == FAIL) <br>printf("Command %d failed.\n", command_count); <br>else <br>{ <br>if (!(DBCMDROW(dbproc))) <br>printf <br>("Command %d returned no rows.\n", <br>command_count); <br>else <br>{ <br>/* This is a command that can return <br>* rows. Let's take a closer look at it. <br>*/ <br>printf("Command %d:\n", command_count); <br>examine_results(dbproc); <br> <br>/* Throw away all data rows. */ <br>dbcanquery(dbproc); <br>} <br>} <br>} <br>} <br> <br>return(STDEXIT); <br>} <br> <br>void examine_results(dbproc) <br>DBPROCESS*dbproc; <br>{ <br>intcolcount; <br>intcolnum; <br>charfullsource[128]; <br>const char *sourcecolname; <br>inttabcount; <br>const char *tabname; <br>inttabnum; <br> <br>/* Determine which tables were used to generate the query results.*/ <br> <br>tabcount = dbtabcount(dbproc); <br>printf <br>("The following tables were used to generate these query results:\n"); <br> <br>for (tabnum = 1; tabnum &lt;= tabcount; tabnum++) <br>{ <br>if ((tabname = dbtabname(dbproc, tabnum)) != NULL) <br>printf <br>("\t%s (%s)\n", tabname, <br>(dbtabbrowse(dbproc, tabnum) <br>? "browsable" : "not browsable")); <br>} <br> <br>/* Determine which tables were used to generate each result column.*/ <br> <br>colcount = dbnumcols(dbproc); <br>printf("Here are the columns of the target list and their sources:\n"); <br> <br>printf <br>("\t%-20s%-30s%s\n\n", <br>"Result column:", "Source:", "Browsable?"); <br>for (colnum = 1; colnum &lt;= colcount; colnum++) <br>{ <br>tabname = dbtabsource(dbproc, colnum, NULL); <br>sourcecolname = dbcolsource(dbproc, colnum); <br> <br>if (tabname == NULL) <br>strcpy(fullsource, "(result of expression)"); <br>else <br>sprintf(fullsource, "%s.%s", tabname, sourcecolname); <br> <br>printf <br>("\t%-20s%-30s%s\n", <br>dbcolname(dbproc, colnum), <br>fullsource, <br>(dbcolbrowse(dbproc, colnum) ? "yes" : "no")); <br>} <br>} <br> <br> <br>BOOL send_command(dbproc) <br>DBPROCESS*dbproc; <br>{ <br> <br>static charcmdbuf[2048]; <br> <br>/* Allow the user to type in an ad hoc query. This query <br>* is terminated by the word "go" appearing at the <br>* beginning of the line. <br>* <br>* If the user types the word "quit" at the beginning of a line, <br>* we'll quit the program. <br>*/ <br>printf("Enter SQL query (or 'quit'):\n"); <br> <br>while (1) <br>{ <br>printf("&gt; "); <br>gets(cmdbuf); <br> <br>if (strcmp(cmdbuf, "go") == 0) <br>{ <br>dbsqlexec(dbproc); <br>break; <br>} <br>else if (strcmp(cmdbuf, "quit") == 0) <br>{ <br>return FALSE; <br>} <br>else <br>{ <br>/* Keep reading SQL commands. */ <br>dbcmd(dbproc, cmdbuf); <br>} <br>} <br> <br>return TRUE; <br>} <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br>    printf("DB-LIBRARY error:\n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf("Operating-system error:\n\t%s\n", oserrstr); <br> <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return(INT_EXIT); <br> <br>return(INT_CANCEL); <br>} <br> <br>int msg_handler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br>printf <br>("SQL Server message %ld, state %d, severity %d:\n\t%s\n", <br>msgno, msgstate, severity, msgtext); <br>return(0); <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
