<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>TWOPHASE.C</title>
<link disabled rel=stylesheet href=../../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2393"></a>TWOPHASE.C</h2>
<pre><code>/*Demo of Two-Phase Commit Service <br>** <br>**This example uses the two-phase commit service <br>**to perform a simultaneous update on two servers. <br>**In this example, one of the servers participating <br>**in the distributed transaction also functions as <br>**the commit service. <br>** <br>**In this particular example, the same update is <br>**performed on both servers. You can, however, use <br>**the commit server to perform completely different <br>**updates on each server. <br>** <br>*/ <br> <br>#if defined(DBNTWIN32) <br>#include &lt;windows.h&gt; <br>#endif <br> <br>#include &lt;stdio.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>charcmdbuf[256]; <br>charxact_string[128]; <br> <br>/* Forward declarations of the error handler and message handler.  <br>*/ <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br>void abortall (DBPROCESS * dbproc_server1, DBPROCESS * dbproc_server2, DBPROCESS * dbproc_commit, DBINT commid); <br> <br>void main(argv,argc) <br>int argc; <br>char *argv[]; <br>{ <br> <br>DBPROCESS*dbproc_server1; <br>DBPROCESS*dbproc_server2; <br>DBPROCESS*dbproc_commit; <br>LOGINREC*login; <br>DBINTcommid; <br> <br>RETCODEret_server1; <br>RETCODEret_server2; <br> <br>// set error/msg handlers for this program <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br> <br>/* Open connections with the servers and the commit service. */ <br>printf("Demo of Two Phase Commit\n"); <br>login = dblogin(); <br>DBSETLUSER(login, "user"); <br>DBSETLPWD(login, "my_passwd"); <br>DBSETLAPP(login, "example"); <br>DBSETLVERSION(login, DBVER60); <br>     <br>dbproc_server1 = dbopen (login, "my_server1"); <br>dbproc_server2 = dbopen (login, "my_server2"); <br>dbproc_commit = open_commit (login, "my_commitsrv"); <br> <br>if (dbproc_server1 == NULL || <br>dbproc_server2 == NULL || <br>dbproc_commit== NULL) <br>{ <br>printf (" Connections failed!\n"); <br>exit (ERREXIT); <br>} <br> <br>/* Use the "pubs" database. */ <br>dbuse(dbproc_server1, "pubs"); <br>dbuse(dbproc_server2, "pubs"); <br> <br>/* Start the distributed transaction on the commit service. */ <br>commid = start_xact(dbproc_commit, "demo", "test", 2); <br> <br>/* Build the transaction name. */ <br>build_xact_string ("test", "my_commitsrv", commid, xact_string); <br> <br>/* Build the first command buffer. */ <br>sprintf(cmdbuf, "BEGIN TRANSACTION %s", xact_string); <br> <br>/* Begin the transactions on the different servers. */ <br>dbcmd(dbproc_server1, cmdbuf); <br>dbsqlexec(dbproc_server1); <br>dbcmd(dbproc_server2, cmdbuf); <br>dbsqlexec(dbproc_server2); <br> <br>dbcancel(dbproc_server1); <br>dbcancel(dbproc_server2); <br> <br>/* Do various updates. */ <br>sprintf(cmdbuf, " update titles set price = $1.50 where"); <br>strcat(cmdbuf, " title_id = 'BU1032'"); <br>dbcmd(dbproc_server1, cmdbuf); <br>ret_server1 = dbsqlexec(dbproc_server1); <br>dbcmd(dbproc_server2, cmdbuf); <br>ret_server2 =dbsqlexec(dbproc_server2); <br>if (ret_server1 == FAIL || ret_server2 == FAIL) <br>{ <br>/* Some part of the transaction failed. */ <br>printf(" Transaction aborted -- dbsqlexec failed\n"); <br>abortall(dbproc_server1, dbproc_server2, dbproc_commit, commid); <br>} <br> <br>dbcancel(dbproc_server1); <br>dbcancel(dbproc_server2); <br> <br>/* Find out if all servers can commit the transaction. */ <br>sprintf(cmdbuf, "PREPARE TRANSACTION"); <br>dbcmd(dbproc_server1, cmdbuf); <br>dbcmd(dbproc_server2, cmdbuf); <br>ret_server1 = dbsqlexec(dbproc_server1); <br>ret_server2 = dbsqlexec(dbproc_server2); <br>if (ret_server1 == FAIL || ret_server2 == FAIL) <br>{ <br>/* One or both of the servers failed to prepare. */ <br>printf(" Transaction aborted -- PREPARE failed\n"); <br>abortall(dbproc_server1, dbproc_server2, dbproc_commit, commid); <br>} <br> <br>dbcancel(dbproc_server1); <br>dbcancel(dbproc_server2); <br> <br>/* Commit the transaction. */ <br>if (commit_xact(dbproc_commit, commid) == FAIL) <br>{ <br>/* The commit server failed to record the commit. */ <br>printf( " Transaction aborted -- commit_xact failed\n"); <br>abortall(dbproc_server1, dbproc_server2, dbproc_commit, commid); <br>exit(ERREXIT); <br>} <br> <br>/* The transaction has successfully committed.Inform the servers.  <br>*/ <br>sprintf(cmdbuf, "COMMIT TRANSACTION"); <br>dbcmd(dbproc_server1, cmdbuf); <br>if (dbsqlexec(dbproc_server1) != FAIL) <br>remove_xact(dbproc_commit, commid, 1); <br>dbcmd(dbproc_server2, cmdbuf); <br>if (dbsqlexec(dbproc_server2) != FAIL) <br>remove_xact(dbproc_commit, commid, 1); <br> <br>/* Close the connection to the commit server. */ <br>close_commit(dbproc_commit); <br> <br>printf( "We made it!\n"); <br>dbexit(); <br>exit(STDEXIT); <br>} <br> <br>/* Function to abort the distributed transaction. */ <br> <br>void abortall( dbproc_server1, dbproc_server2, dbproc_commit, commid ) <br>DBPROCESS*dbproc_server1; <br>DBPROCESS*dbproc_server2; <br>DBPROCESS*dbproc_commit; <br>DBINTcommid; <br>{ <br>/* Some part of the transaction failed. */ <br> <br>/* Inform the commit server of the failure. */ <br>abort_xact(dbproc_commit, commid); <br> <br>/* Roll back the transactions on the different servers. */ <br>sprintf(cmdbuf, "ROLLBACK TRANSACTION"); <br>dbcmd(dbproc_server1, cmdbuf); <br>if (dbsqlexec(dbproc_server1) != FAIL) <br>remove_xact(dbproc_commit, commid, 1); <br>dbcmd(dbproc_server2, cmdbuf); <br>if (dbsqlexec(dbproc_server2) != FAIL) <br>remove_xact(dbproc_commit, commid, 1); <br> <br>dbexit(); <br>exit(ERREXIT); <br>} <br>/* Message and error handling functions. */ <br>int msg_handler(dbproc,msgno,msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br>/*Msg 5701 is just a USE DATABASE message, so skip it.*/ <br>if (msgno == 5701) <br>return (0); <br>/*Print any severity 0 message as is, without extra stuff.*/ <br>if (severity == 0) <br>{ <br>printf ("%s\n",msgtext); <br>return (0); <br>} <br> <br>printf("SQL Server message %ld, severity %d:\n\t%s\n", <br>msgno, severity, msgtext); <br> <br>if (severity &gt;&gt;= 16) <br>{ <br>printf("Program Terminated! Fatal SQL Server error.\n"); <br>exit(ERREXIT); <br>} <br>return (0); <br>} <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return (INT_EXIT); <br>else <br>{ <br>printf ("DB-LIBRARY error: \n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf ("Operating system error:\n\t%s\n", oserrstr); <br>} <br>return (INT_CANCEL); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
