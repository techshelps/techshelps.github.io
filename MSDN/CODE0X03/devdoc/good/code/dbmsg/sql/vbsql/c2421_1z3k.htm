<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>VBSQLGEN.BAS</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2450"></a>VBSQLGEN.BAS</h2>
<pre><code>'$INCLUDE: 'VBQUERY.BI' <br>'$INCLUDE: 'VBDSQL.BI' <br> <br>Sub ChangePrimaryWindowCaption () <br>PrimaryWindow.Caption = PrimaryWindowTitle + " - " + Servername$ + "/" + DatabaseName$ <br>End Sub <br> <br>Function CheckServerConnection () As Integer <br>If SqlConn &lt;&gt; 0 Then <br>    CheckServerConnection = 1 <br>Else <br>    CheckServerConnection = 0 <br>End If <br>End Function <br> <br>Sub DoubleQuotes (InString As String) <br> <br>Rem <br>Rem This will replace all double quotes with "" <br>Rem and all single quotes with '' <br>Rem <br> <br>DOUBLEQUOTE$ = Chr$(34) + Chr$(34) <br>SINGLEQUOTE$ = Chr$(39) + Chr$(39) <br>Static mychar As String * 1 <br> <br>Rem <br>Rem Get the length of the string coming in <br>Rem Set the length of TmpString to length of string coming in + 100 new chars <br>Rem <br> <br>y% = Len(InString) <br>TmpString$ = Space$(y% + 100) <br>i% = 1 <br> <br>For x% = 1 To y% <br> <br>mychar$ = Mid$(InString, x%, 1) <br>If mychar$ = Chr$(34) Then <br>Mid$(TmpString$, i%, 2) = DOUBLEQUOTE$ <br>i% = i% + 1 <br>Else <br>If mychar$ = Chr$(39) Then <br>Mid$(TmpString$, i%, 2) = SINGLEQUOTE$ <br>i% = i% + 1 <br>Else <br>mychar$ = Mid$(InString, x%, 1) <br>Mid$(TmpString$, i%) = mychar$ <br>End If <br>End If <br>i% = i% + 1 <br>Next x% <br> <br>InString$ = RTrim$(TmpString$) <br> <br>End Sub <br> <br>Function ExecuteSQLCommand (cmd As String) As Integer <br> <br>Rem <br>Rem This routine executes a command(s) and returns whether the <br>Rem execute succeeded or failed. <br>Rem <br> <br>SQLStatus% = SUCCEED <br>ExecuteSQLCommand = SUCCEED <br>If SqlCmd(SqlConn, cmd$) = FAIL% Then <br>SQLStatus% = FAIL <br>ExecuteSQLCommand = FAIL <br>End If <br>If SqlExec(SqlConn) = FAIL% Then <br>SQLStatus% = FAIL <br>ExecuteSQLCommand = FAIL <br>End If <br>End Function <br> <br>Sub FixTextLineFeeds (InString As String) <br> <br>Rem <br>Rem This will replace all LF characters in the InString with CRLF <br>Rem <br> <br>CRLF$ = Chr$(13) + Chr$(10) <br>LF$ = Chr$(10) <br> <br>Rem <br>Rem Get the length of the string coming in <br>Rem Set the length of TmpString to length of string coming in + 100 new chars <br>Rem <br> <br>y% = Len(InString) <br>TmpString$ = Space$(y% + 100) <br>i% = 1 <br> <br>For x% = 1 To y% <br> <br>mychar$ = Mid$(InString, x%, 1) <br>If mychar$ = LF$ Then <br>Mid$(TmpString$, i%, 1) = CRLF$ <br>i% = i% + 1 <br>Else <br>mychar$ = Mid$(InString, x%, 1) <br>Mid$(TmpString$, i%) = mychar$ <br>End If <br>i% = i% + 1 <br>Next x% <br> <br>InString$ = RTrim$(TmpString$) <br>End Sub <br> <br>Function GetDatabases (Database_Control As Control) As Integer <br> <br>Rem <br>Rem This routine gets the name of all the databases on the SQL Server. <br>Rem Fill each element in the combobox or list box which is passed into this procedure <br>Rem execute the command.  Get each database name and fill the combobox. <br>Rem <br> <br>If ExecuteSQLCommand("Select name from master..sysdatabases") = FAIL% Then <br>GetDatabases = FAIL <br>Exit Function <br>Else <br>If SqlResults(SqlConn) = FAIL% Then Exit Function <br>While SqlNextRow(SqlConn) &lt;&gt; NOMOREROWS% <br>Database_Control.AddItem SqlData(SqlConn, 1) <br>Wend <br>End If <br> <br>Rem If this is a combobox we are filling, then display the first database in the list to start with <br> <br>If TypeOf Database_Control Is ComboBox Then <br>Database_Control.Text = Database_Control.List(0) <br>End If <br> <br>GetDatabases = SUCCEED <br>End Function <br> <br>Function LoginToServer () As Integer <br> <br>LoginToServer = SUCCEED <br> <br>Rem <br>Rem Check to see if the connection is live, if so, then close it <br>Rem Set the max time to login to 30 seconds <br>Rem Open the new connection <br>Rem Change the caption of the application to reflect the server name and the database <br>Rem Set the max time we will wait for a SQL Server response <br>Rem <br> <br>If SqlConn &lt;&gt; 0 Then SqlClose (SqlConn) <br>Status% = SqlSetLoginTime%(LoginTimeout%) <br>SqlConn = SqlOpenConnection(Servername$, LoginID$, password$, ProgramName$, ProgramName$) <br>If SqlConn &lt;&gt; 0 Then <br>DatabaseName$ = SqlName(SqlConn) <br>ChangePrimaryWindowCaption <br>Result% = SqlSetTime%(QueryTimeout%) <br>Else <br>DatabaseName$ = "" <br>Servername$ = "" <br>LoginToServer = FAIL <br>End If <br> <br>End Function <br> <br>Sub Logoff () <br>If SqlConn &lt;&gt; 0 Then <br>SqlClose (SqlConn) <br>Servername$ = "[No server]" <br>DatabaseName$ = "[no database]" <br>ChangePrimaryWindowCaption <br>End If <br>End Sub <br> <br>Function MakeRuleList (Rawtext As String) As String <br> <br>Rem <br>Rem This functions takes a rule of type "IN" from sp_helptext and makes it a <br>Rem comma delimited list for easy use in list boxes <br>Rem <br> <br>start% = InStr(1, Rawtext$, "'") <br>MakeRuleList = Mid$(Rawtext$, start%, Len(Rawtext$) - 2) <br>End Function <br> <br>Sub ParseRule (Rulename() As String) <br> <br>Rem <br>Rem This routine takes the comma delimeted rules,which came from the <br>Rem MakeRuleList procedure, removes the quotes and stores the values <br>Rem in an array.  This is good for use in combo and list boxes. <br>Rem <br> <br>in$ = Rulename$(0) <br> <br>start% = 1 <br>For i% = 0 To 100 <br>endpos% = InStr(start% + 1, in$, "'") <br>Rulename(i%) = Mid$(in$, start% + 1, (endpos% - start%) - 1) <br>start% = InStr(endpos% + 1, in$, "'") <br>If start% = 0 Then Exit For <br>Next i% <br> <br>End Sub <br> <br>Function Process_SQL_query (cmd As String, OutputData() As String) As Long <br> <br>Rem <br>Rem This routine will process query rows and output the total number <br>Rem of rows which reflects the number of items in the output array. <br>Rem <br>Rem Define array for column lengths, column positions, and column types <br>Rem Define structures for getting a compute column's information and getting <br>Rem a regular column's information <br>Rem <br> <br>Rem Declare a local error handler for string overflows <br>On Error GoTo CancelQuery <br> <br>Static ColValue$ <br>Static collengths() As Long <br>ReDim Preserve collengths(255) As Long <br>Static colpositions() As Integer <br>ReDim Preserve colpositions(255) As Integer <br>Static Coltypes() As Integer <br>ReDim Preserve Coltypes(50) As Integer <br> <br>Process_SQL_query = 0 <br> <br>Rem <br>Rem Define the new line character and the tab key <br>Rem Get the command from the QUERY_FIELD. <br>Rem Fill the command buffer. If fail, then exit the subroutine. <br>Rem Execute the command <br>Rem <br> <br>NL$ = Chr$(13) + Chr$(10) <br>COLSEP$ = " " <br> <br>If cmd$ &lt;&gt; "" Then <br>If ExecuteSQLCommand(cmd$) = FAIL% Then Exit Function <br>End If <br> <br>outputrowcnt% = 0 <br> <br>Rem <br>Rem Get each set of results <br>Rem Get the number of compute columns, order by columns, and select columns <br>Rem Get the exact position of each column (for lining up compute columns) <br>Rem <br> <br>Do Until ResultProcess% = NOMORERESULTS% <br>    ResultProcess% = SqlResults(SqlConn) <br>    If ResultProcess% = NOMORERESULTS% Or ResultProcess% = FAIL Then Exit Do <br> <br>    numcol% = SqlNumCols%(SqlConn) <br>    If numcol% &gt; 0 Then <br>numorder% = SqlNumOrders%(SqlConn) <br>colline$ = "" <br>coluline$ = "" <br> <br>Rem <br>Rem Get the column name and length for each column <br>Rem Format and output the column headings (max 256 chars wide). <br>Rem <br> <br>For x% = 1 To numcol% <br>colname$ = SqlColName(SqlConn, x%) <br>Coltypes(x%) = SqlColType(SqlConn, x%) <br>collengths(x%) = SqlColLen(SqlConn, x%) <br> <br>' templen holds length of column data.  truncate text and image <br>tmplen% = collengths(x%) <br>If tmplen% &gt; 255 Then tmplen% = 255 <br> <br>actuallen&amp; = Len(colname$) <br> <br>If x% = 1 Then <br>   colpositions(x%) = 1 <br>Else <br>colpositions(x%) = Len(colline$) + Len(COLSEP$) <br>End If <br>  <br>If actuallen&amp; &lt; tmplen% Then <br>colline$ = colline$ + colname$ + Space$((tmplen% - actuallen&amp;) + 1) + COLSEP$ <br>coluline$ = coluline$ + String$(Len(colname$), "_") + Space$((tmplen% - actuallen&amp;) + 1) + COLSEP$ <br>Else <br>colline$ = colline$ + colname$ + COLSEP$ <br>coluline$ = coluline$ + String$(Len(colname$), "_") + COLSEP$ <br>End If <br> <br>Next x% <br> <br>     <br>OutputData(outputrowcnt%) = colline$ <br>outputrowcnt% = outputrowcnt% + 1 <br>OutputData(outputrowcnt%) = coluline$ <br>outputrowcnt% = outputrowcnt% + 1 <br>OutputData(outputrowcnt%) = " " <br>outputrowcnt% = outputrowcnt% + 1 <br> <br>    End If   'end of numcol% &gt; 0 test <br> <br> <br>Rem <br>Rem Get each row of data, and process according to type of row <br>Rem Output each row into the list box <br>Rem <br> <br>    RowProcess% = 99 <br>    Do Until RowProcess% = NOMOREROWS% <br>DataStr$ = "" <br>Result% = SqlNextRow(SqlConn) <br>If Result% = NOMOREROWS% Or Result% = FAIL Then Exit Do <br> <br>Rem <br>Rem Process a COMPUTE Row  (Available in VB Win only). <br>Rem In DOS, this function pops up a message box saying COMPUTE rows are not supported. <br>Rem <br> <br>If Result% &lt;&gt; REGROW Then <br>Process_altrows Result%, OutputData(), outputrowcnt%, colpositions() <br>Else <br> <br>Rem <br>Rem Process a regular row. <br>Rem Get the column value and length. <br>Rem If it is a Text column, then change the LF to CRLF if they exist <br>Rem Align columns even with the column headings. <br>Rem <br>For x% = 1 To numcol% <br>ColValue$ = SqlData(SqlConn, x%) <br>actuallen&amp; = Len(ColValue$) <br>If actuallen&amp; &gt; 255 Then <br>ColValue$ = Left$(ColValue$, 255) <br>actuallen&amp; = 255 <br>End If <br>   <br>If Coltypes(x%) = SQLTEXT% Then <br>FixTextLineFeeds ColValue$ <br>End If <br> <br>If x% &lt;&gt; numcol% Then <br>DataStr$ = DataStr$ + ColValue$ + Space$(colpositions(x% + 1) - colpositions(x%) - actuallen&amp;) <br>Else <br>DataStr$ = DataStr$ + ColValue$ <br>End If <br> <br>ColValue$ = "" <br>Next x% <br> <br>OutputData(outputrowcnt%) = DataStr$ <br>End If <br>outputrowcnt% = outputrowcnt% + 1 <br> <br>    Loop        'End of row loop <br> <br>Rem <br>Rem Output the number of rows affected by the query (if applicable) <br>Rem Output the sort order (if applicable) <br>Rem <br> <br>    rowcnt&amp; = SqlCount(SqlConn) <br>    If SqlIsCount(SqlConn) Then <br>DataStr$ = "(" + Str$(rowcnt&amp;) + " rows affected)" <br>OutputData(outputrowcnt%) = " " <br>OutputData(outputrowcnt% + 1) = DataStr$ <br>outputrowcnt% = outputrowcnt% + 2 <br>    End If <br> <br>    If numorder% &gt; 0 Then <br>OutputData(outputrowcnt%) = " " <br>DataStr$ = "Sort Order: " <br>For y% = 1 To numorder% <br>ordercol$ = SqlColName(SqlConn, SqlOrderCol(SqlConn, y%)) <br>DataStr$ = DataStr$ + " " + ordercol$ <br>Next y% <br>OutputData(outputrowcnt% + 1) = DataStr$ <br>outputrowcnt% = outputrowcnt% + 2 <br>    End If <br> <br>Loop        'End of result loop <br> <br>Rem <br>Rem Check for return parameters and return status from stored procedures at the end <br>Rem of every result set.  Available in VBWin only. <br>Rem <br> <br>Process_rpc_returns OutputData(), outputrowcnt% <br>Process_SQL_query = outputrowcnt% <br> <br>Exit Function <br> <br>CancelQuery: <br>Result% = SqlCancel%(SqlConn) <br>Msg$ = "Error number " + Str$(Err) + ":  " + Error$ + NL$ <br>Msg$ = Msg$ + "Query Cancelled" + NL$ <br>MsgBox Msg$, MB_ICONEXCLAMATION, "Visual Basic Error" <br>Exit Function <br> <br>End Function <br> <br>Function UserSqlErrorHandler% (SqlConn As Integer, Severity As Integer, ErrorNum As Integer, OsErr As Integer, ErrorStr As String, OsErrStr As String) <br>'UserSqlErrorHander% - This function is REQUIRED for all VBDSQL applications.  It <br>'is called by the VB-DOS interface code for DB-LIBRARY whenever a <br>'DB-LIBRARY error occurs.  In VB-Win, it can be called from the error event handler. <br> <br>'This function can do anything EXCEPT call another <br>'DB-LIBRARY function (with the exception of SqlDead%, which you can <br>'call to determine if the connection is still intact). <br>' <br>'You can return 1 of 3 values: <br>' INTEXIT     - exit the program <br>' INTCANCEL   - cancel the operation <br>' INTCONTINUE - continue the operation (can only continue on timeout read <br>'                    errors, which usually occur if a table that is locked <br>'                    is updated or read) <br>' <br> <br>Rem <br>Rem Only display message if it's not a notification that there's a server error <br>Rem <br> <br>If ErrorNum% &lt;&gt; SQLESMSG% Then <br>MsgBox ("DBLibrary Error: " + Str$(ErrorNum%) + " " + ErrorStr$) <br>End If <br> <br> <br> <br>'If an operating-system error occurred, print the error string. <br> If OsErr% &lt;&gt; -1 Then <br>MsgBox ("Operating-System Error: " + OsErrStr$) <br> End If <br> <br>'Exit if the error is fatal. <br>If Severity% = EXFATAL Then <br>UserSqlErrorHandler% = INTEXIT <br>Else <br>UserSqlErrorHandler% = INTCANCEL <br>End If <br> <br> <br>End Function <br> <br>Sub UserSqlMsgHandler (SqlConn As Integer, Message As Long, State As Integer, Severity As Integer, MsgStr As String) <br>'UserSqlMsgHandler - This procedure is REQUIRED for VBDSQL applicaitons. <br>'In VB-DOS, it is called by BASIC DB-LIBRARY whenever a connected server needs to <br>'issue a message to the client.  You can call it from the message handler event <br>'in VB-Win <br> <br>NL$ = Chr$(13) + Chr$(10) <br> <br>Rem <br>Rem Only display the message if it's not a general msg or a change language message <br>Rem <br> <br>If Message&amp; &lt;&gt; 5701 And Message&amp; &lt;&gt; 5703 Then <br>Msg$ = "SQL Server Error: " + Str$(Message&amp;) + " " + MsgStr$ + NL$ <br>Msg$ = Msg$ + "State=" + Str$(State%) + ", Severity=" + Str$(Severity) <br> <br>MsgBox Msg$ <br>End If <br> <br> <br>End Sub <br> <br>Function WarningMessage (MsgStr As String) As Integer <br> <br>Rem <br>Rem This routine displays a warning message with a YES and NO button <br>Rem and returns the result. <br>Rem <br> <br>Const MB_YESNO = 4 <br>Const MB_ICONEXLAMATION = 48 <br>Const IDYES = 6 <br>Const IDNO = 7 <br>Const DEFBUTTON2 = 256 <br> <br>DgDef% = MB_YESNO + MB_ICONEXCLAMATION + MB_DEFBUTTON2 <br>Response% = MsgBox(MsgStr$, DgDef%, "System Warning") <br>If Response% = IDNO Then <br>WarningMessage = 0 <br>Else <br>WarningMessage = 1 <br>End If <br>End Function <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
