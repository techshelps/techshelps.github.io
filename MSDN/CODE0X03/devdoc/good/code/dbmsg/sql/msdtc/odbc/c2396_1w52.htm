<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>ODBC.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2396"></a>ODBC.CPP</h2>
<pre><code><br>/*MS DTC Sample <br>** <br>**This example uses MS DTC (distributed transaction <br>**coordinator) to perform simultaneous updates on two <br>**SQL servers.  The transaction in this example is  <br>**client initiated. The client also initiates the <br>**commit operation. <br>** <br>**  As this sample uses the ODBC interface, you'll need <br>**  to configure ODBC data source names for 2 SQL servers <br>**  that you can use to run this sample.  Each DSN; data <br>**  source name,  must point to the pubs database in <br>**  a separate SQL server. The authors table in the pubs <br>**  database is used in this sample. <br>** <br>**  Build Instructions: <br>**  This sample must link with the following files:  xolehlp.lib, odbc32.lib, odbccp32.lib <br>** <br>**  Usage Instructions: <br>**  Please run this program with the '-h' flag. <br>** <br>*/ <br> <br>//------------------------------------------------------------------------------ <br>// Include standard header files <br>//------------------------------------------------------------------------------ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>//------------------------------------------------------------------------------ <br>// Include MS DTC specific header files. <br>//------------------------------------------------------------------------------ <br>#define INITGUID <br> <br>#include "txdtc.h" <br>#include "xolehlp.h" <br> <br> <br>//------------------------------------------------------------------------------ <br>// Include ODBC specific header file. <br>//------------------------------------------------------------------------------ <br>#ifndef DBNTWIN32 <br>#define DBNTWIN32 <br> <br>#include &lt;SQL.h&gt; <br>#include &lt;SQLEXT.h&gt; <br>#include "odbcss.h" <br>#include &lt;ODBCINST.h&gt; <br> <br>#endif /* DBNTWIN32 */ <br> <br>//------------------------------------------------------------------------------ <br>// Define constants <br>//------------------------------------------------------------------------------ <br>#define STR_LEN40 <br> <br>//------------------------------------------------------------------------------ <br>// Define datatypes <br>//------------------------------------------------------------------------------ <br>typedef struct DBCONN <br>{ <br>TCHARpszSrv[STR_LEN];// data source name, configured through control panel <br>TCHARpszUser [STR_LEN];// Login user name <br>TCHARpszPasswd[STR_LEN];// Login user password <br>HDBChdbc;// handle to an ODBC database connection <br>HSTMThstmt;// an ODBC statement handle, for use with SQLExecDirect <br> <br>}DBCONN; <br> <br> <br>//------------------------------------------------------------------------------ <br>// Define Globals <br>//------------------------------------------------------------------------------ <br>static DBCONNgSrv1, gSrv2;// global DB connection struct for server 1 and 2 <br> <br>static TCHARgAuthorID[STR_LEN];// use 11 chars only - per Authors table. <br>static TCHARgNewAddress[STR_LEN+1];// max. address length in the Author's table. <br> <br>//------------------------------------------------------------------------------- <br>//  ODBC specific global vars... <br>//------------------------------------------------------------------------------- <br>HENVgHenv = SQL_NULL_HENV; <br> <br>//------------------------------------------------------------------------------- <br>// Forward declaration of routines used. <br>//------------------------------------------------------------------------------- <br> <br>void InitGlobals(int argc, char **argv); <br>void LogonToDB(DBCONN *ptr); <br>void Enlist(DBCONN *ptr, ITransaction *pTransaction); <br>void ExecuteStatement(DBCONN *ptr, LPTSTR pszBuf); <br>BOOL ProcessRC(LPTSTR pszFuncName, DBCONN *ptr, RETCODE rc); <br>void DoSQLError(DBCONN *ptr); <br>void FreeODBCHandles(DBCONN *ptr); <br> <br> <br>//------------------------------------------------------------------------------- <br>// main() <br>//------------------------------------------------------------------------------- <br> <br>void main(int argc, char **argv) <br>{ <br> <br>ITransactionDispenser*pTransactionDispenser; <br>ITransaction*pTransaction; <br>HRESULThr = S_OK ; <br>BOOLtf = 0 ; <br>TCHARSqlStatement[STR_LEN*2]; <br> <br> <br>// Initialize globals &amp; validate command line arguments <br>InitGlobals(argc,argv); <br> <br> <br>// Obtain the ITransactionDispenser Interface pointer <br>// by calling DtcGetTransactionManager() <br>hr = DtcGetTransactionManager( <br>NULL,// LPTSTR pszHost, <br>NULL,// LPTSTR pszTmName, <br>IID_ITransactionDispenser,// /* in  */ REFIID rid, <br>0,// /* in  */ DWORDdwReserved1, <br>0, // /* in  */ WORDwcbReserved2, <br>NULL,// /* in  */ void FAR * pvReserved2, <br>(void **)&amp;pTransactionDispenser // /* out */ void** ppvObject <br>); <br> <br>if (FAILED (hr)) <br>{ <br>printf("DtcGetTransactionManager failed: %x\n", hr); <br>   exit (1); <br>} <br> <br>// Initialize the ODBC environment handle. <br>if (SQL_NULL_HENV == gHenv) <br>{ <br>ProcessRC("SQLAllocEnv",0,SQLAllocEnv(&amp;gHenv)); <br>} <br> <br>// Establish connection to database on server#1 <br>LogonToDB(&amp;gSrv1); <br>  <br>// Establish connection to database on server#2 <br>LogonToDB(&amp;gSrv2); <br> <br> <br>// Loop performing distributed transactions <br>for (INT i = 0; i &lt; 5; i++) <br>{ <br> <br>// Initiate an MS DTC transaction <br>hr = pTransactionDispenser-&gt;BeginTransaction(  <br>NULL,///* [in]  */ IUnknown __RPC_FAR *punkOuter, <br>ISOLATIONLEVEL_ISOLATED,///* [in]  */ ISOLEVEL isoLevel, <br>ISOFLAG_RETAIN_DONTCARE,// /* [in]  */ ULONG isoFlags, <br>NULL,///* [in]  */ ITransactionOptions *pOptions  <br>&amp;pTransaction///* [out] */ ITransaction **ppTransaction <br>) ; <br> <br>if (FAILED (hr)) <br>{ <br>printf("BeginTransaction failed: %x\n",hr); <br>exit(1); <br>} <br> <br>// Enlist each of the data sources in the transaction <br>Enlist(&amp;gSrv1,pTransaction); <br>Enlist(&amp;gSrv2,pTransaction); <br> <br>// Generate the SQL statement to execute on each of the databases <br>sprintf(SqlStatement, <br>"update authors set address = '%s_%d' where au_id = '%s'", <br> gNewAddress,i,gAuthorID); <br> <br>// Perform updates on both of the DBs participating in the transaction <br>ExecuteStatement(&amp;gSrv1,SqlStatement); <br>ExecuteStatement(&amp;gSrv2,SqlStatement); <br> <br>// Commit the transaction  <br>hr = pTransaction-&gt;Commit(0,0,0); <br>if (FAILED(hr)) <br>{ <br>printf("pTransaction-&gt;Commit() failed: %x\n",hr); <br>exit(1); <br>} <br> <br>// At end of each transaction, pTransaction-Release() must be called. <br>hr = pTransaction-&gt;Release(); <br>if (FAILED(hr)) <br>{ <br>printf("pTransaction-&gt;Release() failed: %x\n",hr); <br>exit(1); <br>} <br> <br>printf("Successfully committed Transaction #%d\n",i); <br> <br>} // for  <br> <br> <br>// release the transaction dispenser <br>pTransactionDispenser-&gt;Release(); <br> <br>// Free ODBC handles <br>FreeODBCHandles(&amp;gSrv1); <br>FreeODBCHandles(&amp;gSrv2); <br> <br>// Free the global ODBC environment handle. <br>SQLFreeEnv(gHenv); <br>} <br> <br> <br> <br>//------------------------------------------------------------------------------- <br> <br>void InitGlobals(INT argc, char **argv) <br>{ <br> <br>TCHAR Usage[] = "\n           [-S1  server_1] \n"\ <br>"           [-U1  user_name_1]\n"\ <br>"           [-P1  passwd_1]\n"\ <br>"           [-S2  server_2]\n"\ <br>"           [-U2  user_name_2]\n"\ <br>"           [-P2  passwd_2]\n"\ <br>        "           [-ID  au_id]\n"\ <br>"           [-Ad  new_address\n"\ <br>"           [-h   Usage]\n"; <br> <br> <br>// Init ODBC handles to be invalid <br>    gSrv1.hdbc = SQL_NULL_HDBC; <br>gSrv1.hstmt= SQL_NULL_HSTMT; <br> <br>    gSrv2.hdbc = SQL_NULL_HDBC; <br>gSrv2.hstmt= SQL_NULL_HSTMT; <br> <br>// Null login info, set defaults as appropriate <br> <br>lstrcpy(gSrv1.pszSrv,""); <br>lstrcpy(gSrv1.pszUser,"sa"); <br>lstrcpy(gSrv1.pszPasswd,""); <br>lstrcpy(gSrv2.pszSrv,""); <br>lstrcpy(gSrv2.pszUser,"sa"); <br>lstrcpy(gSrv2.pszPasswd,""); <br> <br>lstrcpy(gAuthorID,"172-32-1176");// default au_id value from authors table in pubs db. <br> <br>// scan command line arguments for user input. <br>for (INT i = 1; i &lt; argc; i++) <br>{ <br>if (*argv[i] == '-' || *argv[i] == '/') <br>{ <br>switch (argv[i][1]) <br>{ <br>// get the server or DSN name <br>case 's': <br>case 'S': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszSrv,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszSrv,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br> }; <br> break; <br> <br>// get user name <br>case 'u': <br>case 'U': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszUser,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszUser,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br> }; <br> break; <br> <br>// get password <br>case 'p': <br>case 'P': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszPasswd,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszPasswd,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br>  }; <br> break; <br> <br>// get au_id, overriding default value. <br>case 'i': <br>case 'I': <br>lstrcpy(gAuthorID,argv[++i]); <br>break; <br>// get new address to associate with the au_id <br>case 'a': <br>case 'A': <br>lstrcpy(gNewAddress,argv[++i]); <br>break; <br>case '?': <br>case 'h': <br>case 'H': <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>break; <br> <br>default: <br>printf("Invalid Input: %s\n",argv[i]); <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>} <br>} <br>else  <br>{ <br>printf("Illegal command line argument #%d, %s\n",i,argv[i]); <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>} <br>} <br> <br>printf("-----------------------------\n"); <br> <br>printf("MS DTC/ODBC Sample Configuration parameters\n"); <br>printf( "server_1:      %s\n"\ <br>"user_name_1:   %s\n"\ <br>"passwd_1:      %s\n"\ <br>"server_2:      %s\n"\ <br>"user_name_2:   %s\n"\ <br>"passwd_2:      %s\n", <br> <br>gSrv1.pszSrv,gSrv1.pszUser,gSrv1.pszPasswd, <br>gSrv2.pszSrv,gSrv2.pszUser,gSrv2.pszPasswd); <br> <br>printf("-----------------------------\n"); <br> <br>} <br> <br>//------------------------------------------------------------------------------- <br> <br>void LogonToDB(DBCONN *ptr) <br>{ <br>RETCODE rc = 0; <br> <br>rc = SQLAllocConnect(gHenv, &amp;(ptr-&gt;hdbc) ); <br> <br>if (ProcessRC("SQLAllocConnect",ptr,rc)) <br>{ <br>rc = SQLConnect(ptr-&gt;hdbc,  <br>(UCHAR *)(ptr-&gt;pszSrv), <br>SQL_NTS, <br>(UCHAR *)(ptr-&gt;pszUser), <br>SQL_NTS, <br>(UCHAR *)(ptr-&gt;pszPasswd), <br>SQL_NTS <br>); <br> <br>ProcessRC("SQLConnect",ptr,rc); <br>} <br>} <br> <br>//------------------------------------------------------------------------------- <br> <br>void Enlist(DBCONN *ptr, ITransaction *pTransaction) <br>{ <br>RETCODE rc = 0; <br> <br>// Enlist database in the transaction <br> <br>    rc = SQLSetConnectOption (ptr-&gt;hdbc, SQL_COPT_SS_ENLIST_IN_DTC, (UDWORD)pTransaction); <br> <br>ProcessRC("SQLSetConnectOption",ptr,rc); <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void ExecuteStatement(DBCONN *ptr, LPTSTR pszBuf) <br>{ <br>RETCODE rc = 0; <br> <br>// Allocate a statement handle for use with SQLExecDirect <br>rc = SQLAllocStmt(ptr-&gt;hdbc,&amp;(ptr-&gt;hstmt)); <br> <br>ProcessRC("SQLAllocStmt",ptr,rc); <br> <br>// Execute the passed string as a SQL statement <br>    rc = SQLExecDirect(ptr-&gt;hstmt,(UCHAR *)pszBuf,SQL_NTS); <br> <br>ProcessRC("SQLExecDirect",ptr,rc); <br> <br>// Free the statement handle  <br>rc = SQLFreeStmt(ptr-&gt;hstmt, SQL_DROP); <br>ptr-&gt;hstmt = SQL_NULL_HSTMT; <br> <br>ProcessRC("SQLFreeStmt",ptr,rc); <br> <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void FreeODBCHandles(DBCONN *ptr) <br>{ <br>SQLDisconnect(ptr-&gt;hdbc); <br> <br>SQLFreeConnect(ptr-&gt;hdbc); <br> <br>ptr-&gt;hdbc   = SQL_NULL_HDBC; <br>ptr-&gt;hstmt  = SQL_NULL_HSTMT; <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br> <br>BOOL ProcessRC(LPTSTR pszFuncName, DBCONN *ptr,RETCODE rc) <br>{ <br> <br>switch (rc) <br>{ <br> <br>case SQL_SUCCESS: <br>return TRUE; <br>break; <br> <br>case SQL_SUCCESS_WITH_INFO: <br>DoSQLError(ptr); <br>return TRUE; <br>break; <br> <br>case SQL_ERROR: <br>printf("%s Failed - see more info\n",pszFuncName); <br>DoSQLError(ptr); <br>exit(-1); <br>return FALSE; <br>break; <br> <br>case SQL_INVALID_HANDLE: <br>printf("%s Failed - SQL_INVALID_HANDLE\n",pszFuncName); <br>exit(-1); <br>return FALSE; <br>break; <br> <br>case SQL_NO_DATA_FOUND: <br>printf("%s Failed - SQL_NO_DATA_FOUND\n",pszFuncName); <br>return FALSE; <br>break; <br> <br>case SQL_STILL_EXECUTING: <br>printf("%s Failed - SQL_STILL_EXECUTING\n",pszFuncName); <br>return FALSE; <br>break; <br> <br>case SQL_NEED_DATA: <br>printf("%s Failed - SQL_NEED_DATA\n",pszFuncName); <br>return FALSE; <br>break; <br> <br>default: <br>printf("%s Failed - unexpected error, rc = %x\n",pszFuncName,rc); <br>DoSQLError(ptr); <br>exit(-1); <br>return FALSE; <br>break; <br>} <br> <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>void DoSQLError(DBCONN *ptr) <br>{ <br> <br>const INTMSG_BUF_SIZE = 300; <br>UCHAR  szSqlState[MSG_BUF_SIZE]; <br>UCHARszErrorMsg[MSG_BUF_SIZE]; <br> <br>SQLINTEGERfNativeError= 0; <br>SWORDcbErrorMsg= MSG_BUF_SIZE; <br>RETCODErc; <br> <br>rc = SQLError(gHenv, <br>  ptr ? ptr-&gt;hdbc : 0, <br>  ptr ? ptr-&gt;hstmt : 0, <br>  szSqlState, <br>  &amp;fNativeError, <br>  szErrorMsg, <br>  MSG_BUF_SIZE, <br>  &amp;cbErrorMsg <br>  ); <br> <br>if (rc != SQL_NO_DATA_FOUND || rc != SQL_ERROR) <br>{ <br>if (fNativeError != 0x1645)// ignore change database to master context message <br>{ <br>printf("SQLError info:\n"); <br>printf("SqlState: %s, fNativeError: %x\n",szSqlState,fNativeError); <br>printf("Error Message: %s\n",szErrorMsg); <br>} <br>} <br>else <br>{ <br>printf("SQLError() failed: %x, NO_DATA_FOUND OR SQL_ERROR\n",rc); <br>} <br> <br>} <br>// --------------------------------------------------------------------------- <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
