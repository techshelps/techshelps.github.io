<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>DBLIB.CPP</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2395"></a>DBLIB.CPP</h2>
<pre><code>/*MS DTC Sample <br>** <br>**This example uses MS DTC (distributed transaction <br>**coordinator) to perform simultaneous updates on two <br>**SQL servers.  The transaction in this example is  <br>**client initiated. The client also initiates the <br>**commit operation. <br>** <br>**  This sample uses the DBLib interface to communicate <br>**  with both MS DTC and SQL server. <br>** <br>**In this particular example, the pre-installed SQL server <br>**table "Authors" is used. <br>** <br>**  Build Instructions: <br>**  This sample must link with the following files:  ntwdblib.lib, xolehlp.lib <br>** <br>**  Usage Instructions: <br>**  Please run this program with the '-h' flag. <br>** <br>*/ <br> <br> <br>//------------------------------------------------------------------------------ <br>// Include standard header files <br>//------------------------------------------------------------------------------ <br>#include &lt;windows.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;ctype.h&gt; <br> <br>//------------------------------------------------------------------------------ <br>// Include MS DTC specific header files. <br>//------------------------------------------------------------------------------ <br>#define INITGUID <br> <br>#include "txdtc.h" <br>#include "xolehlp.h" <br> <br>//------------------------------------------------------------------------------ <br>// Include DBLib specific header files <br>//------------------------------------------------------------------------------ <br>#ifndef DBNTWIN32 <br>#define DBNTWIN32 <br> <br>#include &lt;SQL.h&gt; <br>#include &lt;SQLEXT.h&gt; <br>#include &lt;sqlfront.h&gt; <br>#include &lt;sqldb.h&gt; <br> <br>#endif /* DBNTWIN32 */ <br> <br>//------------------------------------------------------------------------------ <br>// Define constants <br>//------------------------------------------------------------------------------ <br>#define STR_LEN40 <br> <br>#define TABLE_NAME"Authors"     <br> <br>//------------------------------------------------------------------------------ <br>// Define datatypes <br>//------------------------------------------------------------------------------ <br>typedef struct DBCONN <br>{ <br>TCHARpszSrv[STR_LEN];// data source name, configured through control panel <br>TCHARpszUser [STR_LEN];// Login user name <br>TCHARpszPasswd[STR_LEN];// Login user password <br>TCHARpszTableName[STR_LEN];// not used - should remove. <br> <br>}DBCONN; <br> <br> <br>//------------------------------------------------------------------------------ <br>// Define Globals <br>//------------------------------------------------------------------------------ <br>static DBCONNgSrv1, gSrv2;// global DB connection struct for server 1 and 2 <br> <br>static TCHAR gAuthorID[STR_LEN];// use 11 chars only - per Authors table. <br>static TCHAR gNewAddress[STR_LEN+1];// max. address length in the Author's table. <br> <br>//------------------------------------------------------------------------------- <br>//  DBLib specific global vars... <br>//------------------------------------------------------------------------------- <br>DBPROCESS*dbproc_server1; <br>DBPROCESS*dbproc_server2; <br>LOGINREC*login; <br> <br> <br>//------------------------------------------------------------------------------- <br>// Forward declaration of routines used. <br>//------------------------------------------------------------------------------- <br> <br>void InitGlobals(int argc, char **argv); <br>void LogonToDB(DBPROCESS **dbp, DBCONN *ptr); <br>void Enlist(DBCONN *ptr,DBPROCESS *dbp, ITransaction *pTransaction); <br>void ExecuteStatement(DBCONN *ptr, DBPROCESS *dbp, LPTSTR pszBuf); <br> <br>//------------------------------------------------------------------------------- <br>// DBLib error and message handlers <br>//------------------------------------------------------------------------------- <br>int err_handler(DBPROCESS*, int, int, int, char*, char*); <br>int msg_handler(DBPROCESS*, DBINT, int, int, char*); <br> <br> <br>//------------------------------------------------------------------------------- <br>// main() <br>//------------------------------------------------------------------------------- <br> <br>void main(int argc, char **argv) <br>{ <br> <br>ITransactionDispenser*pTransactionDispenser; <br>ITransaction*pTransaction; <br>HRESULThr = S_OK ; <br>TCHARSqlStatement[STR_LEN*2]; <br> <br> <br>// Initialize globals &amp; validate command line arguments <br>InitGlobals(argc,argv); <br> <br>// set error/msg handlers for this program <br>dbmsghandle((DBMSGHANDLE_PROC)msg_handler); <br>dberrhandle((DBERRHANDLE_PROC)err_handler); <br> <br>// initialize LOGINREC structure <br>login = dblogin(); <br> <br>// Obtain the ITransactionDispenser Interface pointer <br>// by calling DtcGetTransactionManager() <br>hr = DtcGetTransactionManager( NULL, // LPTSTRpszHost, <br>NULL, // LPTSTRpszTmName, <br>IID_ITransactionDispenser,// /* in */ REFIIDrid, <br>    0,// /* in */ DWORDdwReserved1, <br>    0, // /* in */ WORDwcbReserved2, <br>    0,// /* in */ voidFAR * pvReserved2, <br>(void **)&amp;pTransactionDispenser // /*out */ void**ppvObject <br>) ; <br>if (FAILED (hr)) <br>    { <br>printf("DtcGetTransactionManager failed: %x\n", hr); <br>   exit (1); <br>    } <br> <br>// Establish connection to database on server#1 <br>LogonToDB(&amp;dbproc_server1,&amp;gSrv1); <br>  <br>// Establish connection to database on server#2 <br>LogonToDB(&amp;dbproc_server2,&amp;gSrv2); <br> <br>// Loop performing distributed transactions <br>for (INT i = 0; i &lt; 5; i++) <br>{ <br> <br>// Initiate an MS DTC transaction <br>hr = pTransactionDispenser-&gt;BeginTransaction(  <br>NULL,///* [in]  */ IUnknown __RPC_FAR *punkOuter, <br>ISOLATIONLEVEL_ISOLATED,///* [in]  */ ISOLEVEL isoLevel, <br>ISOFLAG_RETAIN_DONTCARE,// /* [in]  */ ULONG isoFlags, <br>NULL,///* [in]  */ITransactionOptions *pOptions  <br>&amp;pTransaction///* [out] */ ITransaction **ppTransaction <br>) ; <br> <br>if (FAILED (hr)) <br>{ <br>printf("BeginTransaction failed: %x\n",hr); <br>exit(1); <br>} <br> <br>// Enlist each of the data sources on the transaction <br>Enlist(&amp;gSrv1,dbproc_server1,pTransaction); <br>Enlist(&amp;gSrv2,dbproc_server2,pTransaction); <br> <br>// Generate the SQL statement to execute on each of the databases <br>sprintf(SqlStatement, <br>"update authors set address = '%s_%d' where au_id = '%s'", <br> gNewAddress,i,gAuthorID); <br> <br>// Perform updates on both of the DBs participating in the transaction <br>ExecuteStatement(&amp;gSrv1,dbproc_server1,SqlStatement); <br>ExecuteStatement(&amp;gSrv2,dbproc_server2,SqlStatement); <br> <br>// Commit the transaction  <br>hr = pTransaction-&gt;Commit(0,0,0); <br>if (FAILED(hr)) <br>{ <br>printf("pTransaction-&gt;Commit() failed: %x\n",hr); <br>exit(1); <br>} <br> <br>// At end of each transaction, pTransaction-Release() must be called. <br>hr = pTransaction-&gt;Release(); <br>if (FAILED(hr)) <br>{ <br>printf("pTransaction-&gt;Release() failed: %x\n",hr); <br>exit(1); <br>} <br> <br>printf("Successfully committed Transaction #%d\n",i); <br> <br>} // for  <br> <br> <br>// release the transaction dispenser <br>pTransactionDispenser-&gt;Release(); <br> <br>// release DBLib resources and exit <br>dbexit(); <br>} <br> <br> <br> <br>//------------------------------------------------------------------------------- <br> <br>void InitGlobals(INT argc, char **argv) <br>{ <br> <br>TCHAR Usage[] = "\n           [-S1  server_1] \n"\ <br>"           [-U1  user_name_1]\n"\ <br>"           [-P1  passwd_1]\n"\ <br>"           [-S2  server_2]\n"\ <br>"           [-U2  user_name_2]\n"\ <br>"           [-P2  passwd_2]\n"\ <br>        "           [-ID  au_id]\n"\ <br>"           [-Ad  new_address\n"\ <br>"           [-h   Usage]\n"; <br> <br>// Init Table name  <br>lstrcpy(gSrv1.pszTableName,TABLE_NAME); <br>lstrcpy(gSrv2.pszTableName,TABLE_NAME); <br> <br> <br>// Null login info, set defaults as appropriate <br> <br>lstrcpy(gSrv1.pszSrv,""); <br>lstrcpy(gSrv1.pszUser,"sa"); <br>lstrcpy(gSrv1.pszPasswd,""); <br>lstrcpy(gSrv2.pszSrv,""); <br>lstrcpy(gSrv2.pszUser,"sa"); <br>lstrcpy(gSrv2.pszPasswd,""); <br> <br>lstrcpy(gAuthorID,"172-32-1176");// default au_id value from authors table in pubs db. <br> <br>// scan command line arguments for user input. <br>for (INT i = 1; i &lt; argc; i++) <br>{ <br>if (*argv[i] == '-' || *argv[i] == '/') <br>{ <br>switch (argv[i][1]) <br>{ <br>// get the server or DSN name <br>case 's': <br>case 'S': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszSrv,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszSrv,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br> }; <br> break; <br> <br>// get user name <br>case 'u': <br>case 'U': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszUser,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszUser,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br> }; <br> break; <br> <br>// get password <br>case 'p': <br>case 'P': <br> switch (argv[i][2]) <br> { <br> <br> case '1': <br> lstrcpy(gSrv1.pszPasswd,argv[++i]); <br> break; <br> <br> case '2': <br> lstrcpy(gSrv2.pszPasswd,argv[++i]); <br> break; <br> <br> default: <br> printf("Invalid Input %s\n",argv[i]); <br> printf("\nUsage: %s %s",argv[0],Usage); <br> exit(1); <br>  }; <br> break; <br> <br>// get au_id, overriding default value. <br>case 'i': <br>case 'I': <br>lstrcpy(gAuthorID,argv[++i]); <br>break; <br>// get new address to associate with the au_id <br>case 'a': <br>case 'A': <br>lstrcpy(gNewAddress,argv[++i]); <br>break; <br>case '?': <br>case 'h': <br>case 'H': <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>break; <br> <br>default: <br>printf("Invalid Input: %s\n",argv[i]); <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>} <br>} <br>else  <br>{ <br>printf("Illegal command line argument #%d, %s\n",i,argv[i]); <br>printf("\nUsage: %s %s",argv[0],Usage); <br>exit(1); <br>} <br>} <br> <br>printf("-----------------------------\n"); <br> <br>printf("MS DTC/DBLib Sample Configuration parameters\n"); <br>printf( "server_1:      %s\n"\ <br>"user_name_1:   %s\n"\ <br>"passwd_1:      %s\n"\ <br>"server_2:      %s\n"\ <br>"user_name_2:   %s\n"\ <br>"passwd_2:      %s\n", <br> <br>gSrv1.pszSrv,gSrv1.pszUser,gSrv1.pszPasswd, <br>gSrv2.pszSrv,gSrv2.pszUser,gSrv2.pszPasswd); <br> <br>printf("-----------------------------\n"); <br> <br>} <br> <br>//------------------------------------------------------------------------------- <br> <br>void LogonToDB(DBPROCESS **dbp, DBCONN *ptr) <br>{ <br> <br>DBSETLUSER(login, ptr-&gt;pszUser); <br>DBSETLPWD(login, ptr-&gt;pszPasswd); <br>DBSETLAPP(login, "example"); <br> <br>*dbp = dbopen (login, ptr-&gt;pszSrv); <br>if (*dbp == NULL) <br>{ <br>printf ("\nLogin to server: %s failed, exiting!\n",ptr-&gt;pszSrv); <br>exit (ERREXIT); <br>} <br> <br>/* Use the "pubs" database. */ <br>dbuse(*dbp, "pubs"); <br>} <br> <br> <br>//------------------------------------------------------------------------------- <br> <br>void Enlist(DBCONN *ptr, DBPROCESS *dbp, ITransaction *pTransaction) <br>{ <br>RETCODE rc = 0; <br> <br>rc = dbenlisttrans (dbp, pTransaction); <br> <br>if (FAIL == rc)  <br>{ <br>printf("\ndbenlisttrans() failed: %x\n",rc); <br>exit(1); <br>} <br> <br>} <br> <br> <br>// --------------------------------------------------------------------------- <br> <br>void ExecuteStatement(DBCONN *ptr, DBPROCESS *dbp, char *pszBuf) <br>{ <br>RETCODE rc = 0; <br> <br>dbcmd(dbp,pszBuf); <br> <br>rc = dbsqlexec(dbp); <br>if (FAIL == rc) <br>{ <br>// one or both of the servers failed to prepare <br>printf("dbsqlexec() failed\n"); <br>exit(1); <br>} <br> <br>rc = dbresults(dbp); <br>if (rc != SUCCEED) <br>{ <br>printf("dbresults() failed: %x\n",rc); <br>exit(1); <br>} <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>/* Message and error handling functions. */ <br> <br>int msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, char *msgtext) <br>{ <br>/*Msg 5701 is just a USE DATABASE message, so skip it.*/ <br>if (msgno == 5701) <br>return (0); <br> <br>/*Print any severity 0 message as is, without extra stuff.*/ <br>if (severity == 0) <br>{ <br>printf ("%s\n",msgtext); <br>return (0); <br>} <br> <br>printf("SQL Server message %ld, severity %d:\n\t%s\n", <br>msgno, severity, msgtext); <br> <br>if (severity &gt;&gt;= 16) <br>{ <br>printf("Program Terminated! Fatal SQL Server error.\n"); <br>exit(ERREXIT); <br>} <br>return (0); <br>} <br> <br>// --------------------------------------------------------------------------- <br> <br>int err_handler(DBPROCESS *dbproc, int severity, int dberr, int oserr, char *dberrstr, char *oserrstr) <br>    <br>{ <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return (INT_EXIT); <br>else <br>{ <br>printf ("DB-LIBRARY error: \n\t%s\n", dberrstr); <br> <br>if (oserr != DBNOERR) <br>printf ("Operating system error:\n\t%s\n", oserrstr); <br>} <br>return (INT_CANCEL); <br>} <br> <br>// --------------------------------------------------------------------------- <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
