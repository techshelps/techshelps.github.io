<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XP_ODBC.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2410"></a>XP_ODBC.C</h2>
<pre><code>// This is an example of an extended procedure DLL built with Open Data <br>// Services. The functions within the DLL can be invoked by using the extended <br>//stored procedures support in SQL Server.  To register the functions  <br>// and allow all users to use them run the ISQL script XP_ODBC.SQL. <br>// <br>// For further information on Open Data Services refer to the Microsoft Open  <br>// Data Services Programmer's Reference. <br>// <br>//  The extended procedures implemented in this DLL is: <br>// <br>//  XP_GETTABLEUsed to show the creation of a new connection to SQL Server <br>//using ODBC that is bound to the initial client connection <br>// <br> <br>#defineDBNTWIN32 <br> <br>#include    &lt;stdlib.h&gt; <br>#include    &lt;stdio.h&gt; <br>#include    &lt;string.h&gt; <br>#include&lt;ctype.h&gt; <br>#include&lt;time.h&gt; <br>#include    &lt;windows.h&gt; <br>#include    &lt;sql.h&gt; <br>#include    &lt;sqlext.h&gt; <br>#include    &lt;srv.h&gt; <br>#include    &lt;odbcss.h&gt; <br> <br> <br>// Miscellaneous defines <br>// <br>#define XP_NOERROR0 <br>#define XP_ERROR1 <br> <br>#define MAXNAME31// Maximum extended procedure name length <br>#define MAXLEN80// Maximum string length <br>#define COMMAND_PARAM1// Command Parameter <br>#define OUTPUT_PARAM2// Command Parameter <br> <br>#defineSQLCHAR 0x2f//used by srv_describe <br> <br> <br>// Extended procedure error codes <br>// <br>#define SRV_MAXERROR20000 <br>#define GETTABLE_ERRORSRV_MAXERROR + 1 <br>#defineCOMPUTE_ROWSRV_MAXERROR + 8 <br>#defineREMOTE_MSGSRV_MAXERROR + 9 <br>#defineSEND_FAILEDSRV_MAXERROR + 10 <br> <br> <br>#define REMOTE_FAIL4002 <br> <br>// #define Xpcnumber sizeof(Xps) / sizeof(XP_INFO) <br> <br>#define NAME_LEN30 <br>#define MAXCOLS30 <br> <br>// Stored Procedure information structure. <br>// <br>typedef struct xp_info { <br>    DBCHAR name[MAXNAME];   // Extended procedure name <br>    DBCHAR usage[MAXLEN];   // Usage string <br>} XP_INFO; <br> <br>typedef BYTE * dataptr ; <br> <br>// Array of Extended Stored Procedures supported by this DLL. <br>// <br>XP_INFO Xps[] =  <br>{ <br>    "xp_gettable", <br>//    "usage: xp_gettable &lt;@pubs_table_name&gt;", <br>    "usage: xp_gettable", <br>}; <br> <br>void handle_odbc_err(char *,RETCODE ,DBINT ,HENV ,HDBC ,HSTMT ,SRV_PROC *); <br> <br> <br>// <br>// XP_GETTABLE <br>//    Returns the result of the SQL statement <br>//select * from &lt;table_name&gt; <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client.  <br>// <br> <br>RETCODE xp_gettable(srvproc) <br>SRV_PROC *srvproc; <br>{ <br> <br>HENVhenv= SQL_NULL_HENV; <br>HDBC hdbc= SQL_NULL_HDBC; <br>HSTMThstmt= SQL_NULL_HSTMT; <br>SWORDColNameLen[MAXCOLS]; <br>SDWORDcbName= SQL_NTS; <br>UDWORDFAR ColLen[MAXCOLS]; <br>UDWORDFAR ColLenT[MAXCOLS]; <br>UCHARColName[NAME_LEN]; <br>RETCODErc; <br>SDWORDnresultcols;// number of result columns <br>dataptrdata[MAXCOLS]; <br>DBINTrows=0L;// number of rows sent <br>charbindtoken[256]; <br>    UWORDi;// Index variable          <br>UCHAR FAR *DSN= "local";// for integrated security to work you need to  <br>//   specify a local server in the ODBC setting <br>//     in the Control Panel in Windows <br>charSqlStmt[500]; <br>intbImpersonated; <br> <br>PTRrgbDesc;// pointer to storage for descriptor info <br>SWORDcbDescMax = 2550;// max length of rgbDesc buffer <br>SWORD FARpcbDesc;// number of bytes returned in rgbDesc <br>SDWORD FARpfdesc;// pointer to storage info for numeric descriptor types <br>SDWORD FARSqlType[MAXCOLS];// storage info for SQL data types <br> <br> <br>UCHAR FAR uid[50]; <br>UCHAR FAR pwd[50]; <br> <br> <br> <br>intparamnum; <br>DBCHARtable_name[500]; <br>DBINTparamtype; <br> <br>    // Get number of parameters <br>    paramnum = srv_rpcparams(srvproc); <br> <br>    // Check number of parameters <br>    if (paramnum != 1) { <br>        // Send error message and return <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, GETTABLE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error executing extended stored procedure: Invalid Parameter", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>    // Check parameters for correct type <br>    paramtype = srv_paramtype(srvproc, paramnum); <br>    if (paramtype != SRVVARCHAR) { <br>         <br>// Send error message and return <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, GETTABLE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, <br>                    "Error executing extended stored procedure: Invalid Parameter Type", <br>                    SRV_NULLTERM); <br> <br>// A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>// result set of an Extended Stored Procedure. <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>// Terminate parameter string with NULL <br>    sprintf(table_name, srv_paramdata(srvproc, 1)); <br>table_name[srv_paramlen(srvproc, 1)] = '\0'; <br> <br> <br>// Allocate an ODBC environment handle <br>rc = SQLAllocEnv(&amp;henv);              // Environment handle  <br>if (rc != SQL_SUCCESS) { <br>handle_odbc_err("SQLConnect", <br>rc,  <br>(DBINT)REMOTE_FAIL, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br>    } <br> <br>// Allocate an ODBC connection handle <br>rc = SQLAllocConnect(henv, &amp;hdbc); // Connection handle  <br>if (rc != SQL_SUCCESS) { <br>handle_odbc_err("SQLConnect", <br>rc,  <br>(DBINT)REMOTE_FAIL, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br> <br>} <br> <br>// Check for integrated security <br>if (strcmp(srv_pfield(srvproc, SRV_LSECURE, (int *)NULL), "TRUE") == 0) { <br>// Client has accessed using some form of integrated security <br>// Impersonate client and set SQL_INTEGRATED_SECURITY option <br> <br>    bImpersonated = srv_impersonate_client(srvproc); <br> <br>rc=SQLSetConnectOption(hdbc, SQL_INTEGRATED_SECURITY, SQL_IS_ON); <br> <br>// Connect to DSN using integrated security <br>rc = SQLConnect(hdbc, DSN, SQL_NTS, NULL, SQL_NTS, NULL, SQL_NTS); <br> <br>} <br>else { <br>    // Client used standard login <br>    // Set the user name, password, and application name for the remote <br>sprintf(uid, srv_pfield(srvproc, SRV_USER, (int*)NULL)); <br>sprintf(pwd, srv_pfield(srvproc, SRV_PWD, (int*)NULL)); <br>rc = SQLConnect(hdbc, DSN, SQL_NTS, uid, SQL_NTS, pwd, SQL_NTS); <br> <br>} <br>if ((rc != SQL_SUCCESS) &amp;&amp; (rc != SQL_SUCCESS_WITH_INFO)) <br>{ <br>handle_odbc_err("SQLConnect", <br>rc,  <br>(DBINT)REMOTE_FAIL, <br>henv, <br>hdbc,  <br>SQL_NULL_HSTMT,  <br>srvproc); <br>return(XP_ERROR); <br> <br>}  <br> <br> <br>// Process data after successful connection  <br>rc = SQLAllocStmt(hdbc, &amp;hstmt); // Statement handle  <br>if (rc != SQL_SUCCESS) { <br>handle_odbc_err("SQLConnect", <br>rc,  <br>(DBINT)REMOTE_FAIL, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br>    } <br> <br> <br>//get the client session token <br>rc = srv_getbindtoken(srvproc, bindtoken); <br>if (rc == FAIL){ <br>srv_sendmsg(srvproc, SRV_MSG_ERROR, GETTABLE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, <br>                    "Error with srv_getbindtoken", <br>                    SRV_NULLTERM); <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>} <br> <br>// put the SQL statement in the command buffer <br>sprintf (SqlStmt, "exec sp_bindsession \'%s\' ", bindtoken); <br> <br>rc=SQLExecDirect(hstmt, SqlStmt, SQL_NTS); <br>if (!((rc == SQL_SUCCESS) ||(rc == SQL_SUCCESS_WITH_INFO))) <br>{ <br>// if query failed, notify user &amp; acknowledge with senddone. <br>handle_odbc_err("SQLExecDirect", <br>rc,  <br>(DBINT)SEND_FAILED, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br>} <br> <br>// SELECT the result set and bind its columns to local storage <br>sprintf (SqlStmt, "SELECT * FROM  %s ", table_name); <br>rc=SQLExecDirect(hstmt, SqlStmt, SQL_NTS); <br>if (rc != SQL_SUCCESS) { <br>handle_odbc_err("SQLExecDirect", <br>rc,  <br>(DBINT)SEND_FAILED, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br>    } <br> <br>// if returnvalue was successful, must have results rows <br>SQLColAttributes(hstmt,  <br>0,  <br>SQL_COLUMN_COUNT,  <br>rgbDesc,  <br>cbDescMax,// max length of rgbDesc buffer <br>&amp;pcbDesc,// number of bytes returned in rgbDesc <br>&amp;nresultcols); <br> <br>// Build the column description for this results set. <br>for (i = 1; i &lt;= nresultcols; i++)  <br>{ <br>// get the column description <br>SQLColAttributes(hstmt,  <br>i,  <br>SQL_CA_SS_COLUMN_SSTYPE,  <br>rgbDesc,  <br>cbDescMax,// max length of rgbDesc buffer <br>&amp;pcbDesc,// number of bytes returned in rgbDesc <br>&amp;SqlType[i]); <br> <br> <br>SQLColAttributes(hstmt,  <br>i,  <br>SQL_COLUMN_NAME,  <br>&amp;ColName[i],// returned column name <br>NAME_LEN,// max length of rgbDesc buffer <br>&amp;ColNameLen[i],// number of bytes returned in rgbDesc <br> &amp;pfdesc); <br> <br>SQLColAttributes(hstmt,  <br>i,  <br>SQL_COLUMN_LENGTH,  <br>rgbDesc,  <br>cbDescMax,// max length of rgbDesc buffer <br>&amp;pcbDesc,// number of bytes returned in rgbDesc <br>&amp;ColLen[i]);// returned column length <br> <br>// Over-write the column length returned by ODBC with the correct value <br>//    to be used by ODS <br> <br>switch( SqlType[i] ){ <br> <br>case SQLMONEY://money <br>case SQLDATETIME://datetime <br>ColLen[i] = 8; <br>break; <br> <br>case SQLMONEYN://moneyn <br>if (21 == ColLen[i]) <br>ColLen[i] = 8; <br>else <br>ColLen[i] = 4; <br>break; <br> <br>case SQLDATETIMN://datetimn <br>if (23 == ColLen[i]) <br>ColLen[i] = 8; <br>else <br>ColLen[i] = 4; <br>break; <br> <br>case SQLNUMERIC://numeric <br>case SQLNUMERICN://numericn <br>case SQLDECIMAL://decimal <br>case SQLDECIMALN://decimaln <br>ColLen[i] = sizeof(DBNUMERIC); <br>break; <br> <br> <br>case SQLMONEY4://smallmoney <br>case SQLDATETIM4://smalldatetime <br>ColLen[i] = 4; <br>break; <br> <br>} <br> <br> <br>// allocate memory to hold each filed of data in a row <br>data[i] = (dataptr) malloc(ColLen[i]); <br>srv_bzero (data[i], ColLen[i] ); <br> <br> <br>// Bind column  <br>SQLBindCol(hstmt,  <br>i,  <br>SQL_C_BINARY,// no data conversion <br>data[i], // will hold 'fetched' data <br>ColLen[i], // max bytes to store in 'data' <br>&amp;ColLenT[i]);// actual bytes stored by 'fetch' <br> <br> <br>// Prepare structure that will be sent via ODS back to the caller of the  <br>//extended procedure <br>srv_describe(srvproc,  <br>i,  <br>&amp;ColName[i],  <br>SRV_NULLTERM, <br>SqlType[i],// destdata type  <br>(DBINT) ColLen[i],// dest data length <br>SqlType[i], // source data type  <br>(DBINT) ColLen[i],// source data length <br>(BYTE *)NULL); <br> <br>} <br> <br>// initialize the row counter <br> rows = 0; <br> <br>// get each row of data from ODBC until there are no more rows <br>while((rc = SQLFetch(hstmt)) != SQL_NO_DATA_FOUND) <br>{ <br>if (!((SQL_SUCCESS == rc) ||(SQL_SUCCESS_WITH_INFO == rc))) <br>{ <br>handle_odbc_err("SQLExecDirect", <br>rc,  <br>(DBINT)SEND_FAILED, <br>henv, <br>hdbc,  <br>hstmt,  <br>srvproc); <br>return(XP_ERROR); <br>} <br> <br>// For each data field in the current row, fill the structure that will <br>//    be sent back to the caller of the extended procedure <br> for (i = 1; i &lt;= nresultcols; i++)  <br>{ <br>if (SQL_NULL_DATA == ColLenT[i]) <br>ColLenT[i] = 0; <br>srv_setcollen(srvproc, i, (int)ColLenT[i]); <br>srv_setcoldata(srvproc, i, data[i]); <br>} <br> <br>// Send the data row back to SQL Server via ODS <br>if (srv_sendrow(srvproc) == SUCCEED) <br>rows++; <br>} <br> <br> <br>// free the data buffers  <br>for (i=1; i&lt;=nresultcols; i++) <br>(void)free(data[i]); <br> <br>// free handles <br>SQLFreeStmt(hstmt, SQL_DROP); <br>SQLDisconnect(hdbc); <br>SQLFreeConnect(hdbc); <br>SQLFreeEnv(henv); <br> <br> <br>if (rows &gt; 0) <br>srv_senddone(srvproc, SRV_DONE_MORE | SRV_DONE_COUNT, (DBUSMALLINT)0, rows); <br>else <br>srv_senddone(srvproc, SRV_DONE_MORE, (DBUSMALLINT)0, (DBINT)0); <br>return(XP_NOERROR); <br> <br>     <br>// Revert back to SQL Server's user account <br>    // <br>    if( bImpersonated ) <br>        srv_revert_to_self(srvproc); <br> <br>} <br> <br> <br>// HANDLE_ODBC_ERR <br>//This routine is called to send messages to clients when an ODBC function <br>//returns what could be considered an error (e.g., SQL_ERROR, <br>//SQL_INVALID_HANDLE). <br>// <br>// Parameters: <br>//rc- The return code of the function that did not SUCCESS. <br>//msgnum- The ODS user message code. <br>//connection- The ODBC connection handle. <br>//statement- The ODBC statement handle. <br>//srvproc- Contains additional client information. <br>// <br>// Returns: <br>//none <br>// <br> <br>void handle_odbc_err(char *szODBCApi, <br>RETCODE rc, <br>DBINT msgnum, <br>HENV henv, <br>HDBC hdbc, <br>HSTMT hstmt, <br>SRV_PROC *srvproc) <br>{ <br>UCHAR szSQLState[6], szErrorMsg[SQL_MAX_MESSAGE_LENGTH]; <br>SDWORD NativeError; <br>SWORD cbErrorMsg; <br>RETCODE retcode; <br> <br>// if rc is SQL_SUCCESS, return without doing anything <br>if (rc == SQL_SUCCESS) <br>return; <br> <br>retcode = SQLError(henv, <br>hdbc, <br>hstmt, <br>szSQLState, <br>&amp;NativeError, <br>szErrorMsg, <br>SQL_MAX_MESSAGE_LENGTH-1, <br>&amp;cbErrorMsg); <br> <br>// if rc is informational, sned message, else send error to client <br>if (rc == SQL_SUCCESS_WITH_INFO) <br>{ <br>srv_sendmsg(srvproc,  <br>SRV_MSG_INFO,  <br>msgnum,  <br>(DBTINYINT)0, <br>(DBTINYINT)0,  <br>NULL,  <br>0,  <br>0,  <br>szErrorMsg, <br>SRV_NULLTERM); <br> <br>printf("ODBC message(%s) = %d:%s\n", szODBCApi,rc, szErrorMsg); <br>} <br>else <br>{ <br>srv_sendmsg(srvproc,  <br>SRV_MSG_ERROR,  <br>msgnum,  <br>(DBTINYINT)11, <br>(DBTINYINT)0,  <br>NULL,  <br>0,  <br>0,  <br>szErrorMsg, <br>SRV_NULLTERM); <br> <br>printf("ODBC error(%s) = %d:%s\n", szODBCApi,rc, szErrorMsg); <br>} <br>} <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
