<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>PROCSRV.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2405"></a>PROCSRV.C</h2>
<pre><code>// <br>// This program is an example of an Open Data Services application. It accepts <br>// requests from clients to execute stored procedures either as language <br>// events or as remote stored procedure calls. <br>// It may also be invoked using the Service Control Manager. <br>// <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;conio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;process.h&gt; <br>#include &lt;srv.h&gt; <br> <br>#define VERSION "6.00.01" <br> <br>// Globals <br>// <br>BOOL         SrvCtrMan; <br>HANDLE       hServerDone; <br>SRV_SERVER * gblServer = NULL; <br>DBCHAR     * szRegistryName = "PROCSRV";  // Default registry name <br> <br>SERVICE_STATUS_HANDLE   NTBServiceHandle; <br>CRITICAL_SECTION        SCMCrtSec; <br>SERVICE_STATUS          NTBServiceStatus; <br> <br> <br>// Syscharsets query from DBLIB 4.2 NT clients <br>// <br>#define SERVER_INFO_QUERY   "exec sp_server_info 18" <br> <br>// Define some user message codes. <br>// <br>#define     SRV_MAXERROR           20000 <br>#define     SP_UNKNOWN             SRV_MAXERROR + 1 <br>#define     INVALID_SP_SYNTAX      SRV_MAXERROR + 2 <br>#define     BAD_SP_PARAMETER       SRV_MAXERROR + 3 <br>#define     BROADCAST              SRV_MAXERROR + 4 <br>#define     EXEC                   SRV_MAXERROR + 5 <br> <br>// Miscellaneous defines used by sp-handling routines. <br>// <br>#define EXEC_CMD            "exec" <br>#define MAXNAME             31 <br>#define MAXLEN              80 <br>#define MAXPARAMS           4 <br>#define VALUE               0x0000 <br>#define REFERENCE           0x0001 <br>#define CMDSTR              7 <br>#define BUF_SIZE            2048 <br>#define XBASE_HDR_SIZE      32 <br>#define XBASE_MAX_COLUMNS   128 <br> <br>// Standard error macro for reporting API errors <br>// <br>#define SETERROR( api, retstring )                          \ <br>    sprintf(retstring,"%s: Error %d from %s on line %d\n",  \ <br>            __FILE__, GetLastError(), api, __LINE__); <br> <br>// Event handlers for SP requests. <br>// <br>SRVRETCODE proclist();         // List SP associated with Server <br>SRVRETCODE sp_exec();          // Execute the specified command string <br>SRVRETCODE diskfree();         // Return the space on a given drive <br>SRVRETCODE disklist();         // List available drives and their space <br>SRVRETCODE scan_xbase();       // Open and read an xBase file <br> <br>// Stored Procedure parameter information structure. <br>// <br>typedef struct sp_params { <br>    DBCHAR name[MAXNAME];           // Parameter name <br>    int    type;                    // Parameter data type <br>    DBINT  length;                  // Parameter type length <br>    int    status;                  // Parameter return status <br>    DBCHAR defaultvalue[MAXLEN *10];// Optional default value <br>} SP_PARAMS; <br> <br>// Stored Procedure information structure. <br>// <br>typedef struct sp_info { <br>    DBCHAR      name[MAXNAME];          // Procedure name <br>    DBCHAR      usage[MAXLEN];          // Usage string <br>    int         numparams;              // Number of parameters <br>    SP_PARAMS   params[MAXPARAMS];      // Parameter array <br>    SRVRETCODE   (*handler)(VOID *, ...);  // Pointer to function with variable arguments <br>} SP_INFO; <br> <br>// Array of Stored Procedure handlers. <br>// <br>SP_INFO Sps[] = <br>{ <br>    "proclist", <br>    "usage: proclist", <br>    0, <br>       { <br>        0 <br>       }, <br>    proclist, <br> <br>    "sp_exec",              // Procedure name <br>    "usage: sp_exec &lt;[@command =] command string&gt;", // Procedure usage <br>    1,                      // Number of parameters <br>   {    // Parameter definitions <br>        "command",          // Parameter name <br>        SRVCHAR,            // Parameter type <br>        MAXLEN,             // Parameter length (0 if fixed) <br>        VALUE,              // Pass by value <br>        "dir *.*",          // Default parameter value <br>    }, <br>    sp_exec,                // Procedure function pointer <br> <br>    "disklist", <br>    "usage: disklist ", <br>    0, <br>   { <br>        0 <br>    }, <br>    disklist, <br> <br>    "diskfree", <br>    "usage: diskfree &lt;[@drive =] drive letter&gt; [,] &lt;[@space =] free space&gt;", <br>    2, <br>   { <br>        "drive", <br>        SRVCHAR, <br>        1, <br>        VALUE,              // pass by value <br>        "c", <br> <br>        "space", <br>        SRVINT4, <br>        8, <br>        REFERENCE,          // pass by reference <br>        "0", <br>    }, <br>    diskfree, <br> <br>    "scan_xbase",               // rpc name <br>    "usage: scan_xbase &lt;[@file_name =] xbase file name&gt;",   // rpc usage <br>    1,                          // number of parameters <br>   {   // parameter definitions <br>        "file_name",            // parameter name <br>        SRVCHAR,                // parameter type <br>        MAXLEN,                 // parameter length (0 if fixed) <br>        VALUE,                  // pass by value <br>        "\\sql\\opends\\samples\\procsrv\\build\\sales.dbf", // default parameter value <br>    }, <br>    scan_xbase,                 // rpc function pointer <br> <br>}; <br> <br>#define Rpcnumber sizeof(Sps) / sizeof(SP_INFO) <br> <br>// Other function prototypes <br>// <br>void main( int argc, char **argv ); <br>void WINAPI ProcSrvMain( DWORD argc, char *argv[] ); <br>void initsignal( SRV_SERVER *, char * ); <br>void ctrlc_hndl( ULONG ); <br>void WINAPI NTBServiceCtrlHandler( DWORD ); <br>void completesignal( SRV_SERVER * ); <br>void NTBShutdown( LPVOID ); <br>char * get_last_error_str(); <br> <br>SRVRETCODE chk_err( SRV_SERVER * server, <br>                 SRV_PROC   * srvproc, <br>                 int          srverror, <br>                 BYTE         severity, <br>                 BYTE         state, <br>                 int          oserrnum, <br>                 DBCHAR     * errtext, <br>                 int          errtextlen, <br>                 DBCHAR     * oserrtext, <br>                 int          oserrtextlen ); <br> <br>SRVRETCODE init_remote(SRV_PROC * srvproc); <br> <br>SRVRETCODE init_server(SRV_SERVER * server); <br> <br>SRVRETCODE sp_execute(SRV_PROC * srvproc); <br> <br>SRVRETCODE exit_remote(SRV_PROC *srvproc); <br> <br>SRVRETCODE lang_execute(SRV_PROC *srvproc); <br> <br>// Miscellaneous prototypes for sp language events <br>// <br>SRVRETCODE lang_parser(SRV_PROC *srvproc, SP_INFO **sp, <br>                    DBCHAR paramvalues[MAXPARAMS][MAXLEN]); <br> <br>DBCHAR *scan_next(DBCHAR *string, DBCHAR *word); <br> <br> <br>// =================================== main ================================== <br>// <br>void main( int argc, char *argv[] ) <br>{ <br>    SERVICE_TABLE_ENTRY DispatchTable[] = <br>    { <br>        "ProcSrv", ProcSrvMain, <br>        NULL,      NULL <br>    }; <br> <br>    // Assume ProcSrv.exe was started from the Service Control Manager or <br>    // SQL Service Manager. <br>    // <br>    SrvCtrMan = TRUE; <br> <br>    // Check for command line arguments.  The following command line arguments <br>    // are supported: <br>    // <br>    //    -c  Procsrv was started from the command line.  Avoids the timeout <br>    //        delay when an attempt is made to start procsrv as a service. <br>    // <br>    //    -r&lt;registry key name&gt; <br>    //        Look in Registry under the &lt;registry key name&gt; for the ListenOn <br>    //        values.  Also assumes procsrv.exe was started from command line. <br>    // <br>    //    -?  Displays the command usage information. <br>    // <br>    if( argc &gt; 2 ) <br>        goto Usage; <br> <br>    if( argc == 2 ) <br>    { <br>        if( !strcmp(argv[1], "-?") ) <br>            goto Usage; <br> <br>        if( !stricmp(argv[1], "-c") ) <br>            SrvCtrMan = FALSE; <br>        else if( strlen(argv[1]) &lt; 3 ) <br>            goto Usage; <br>        else if( !strnicmp(argv[1], "-r", 2) ) <br>        { <br>            szRegistryName = argv[1] + 2; <br>            SrvCtrMan = FALSE; <br>        } <br>        else <br>            goto Usage; <br>    } <br> <br>    if( SrvCtrMan ) <br>    { <br>        // Now we will attempt to start the ProcSrv.exe as a service.  The attempt <br>        // will time out if this process was started from the command line. <br>        // StartServiceCtrlDispatcher does not return until after ProcSrv has stopped. <br>        // The ProcSrvMain is called from Service Control Manager within <br>        // the context of the same process. <br>        // <br>        if( StartServiceCtrlDispatcher(DispatchTable) ) <br>        { <br>            _flushall(); <br>            return; <br>        } <br>    } <br> <br>    // The service was started from the command line or the attempt to <br>    // start the service failed.  We can assume that this process <br>    // was started from the command line. <br>    // <br>    SrvCtrMan = FALSE; <br>    ProcSrvMain( argc, argv ); <br>    return; <br> <br>Usage: <br>    printf( "Usage: procsrv [-c] | [-r&lt;registry key name&gt;] | [-?]\n" <br>            "    -c  Procsrv was started from the command line\n" <br>            "    -r  Look in Registry under &lt;registry key name&gt; for ListenOn values\n" <br>            "    -?  Displays this help message\n" ); <br>} <br> <br> <br>// ================================== ProcSrvMain ============================ <br>// <br>void WINAPI ProcSrvMain( DWORD argc, char *argv[] ) <br>{ <br>    SRV_CONFIG * config;        // The configuration structure <br>    DWORD        dwPathLength; <br>    char         szPath[1024]; <br>    char         szLogBuffer[1024]; <br> <br>    if( !SrvCtrMan ) <br>    { <br>        printf( "\nProcedure Server, Copyright 1994, Microsoft\n" ); <br>        printf( "              version: %s\n\n", VERSION ); <br>    } <br> <br>    // Allocate a configuration structure that is used to initialize <br>    // the Open Data Services application <br>    // <br>    config = srv_config_alloc(); <br> <br>    // Allow 20 connections at a time. <br>    // <br>    srv_config(config, (DBINT)SRV_CONNECTIONS, "20", SRV_NULLTERM); <br> <br>    // Set the log file. <br>    // <br>    // Get the path of this process.  We'll use it to constuct the path of the <br>    // log file. <br>    // <br>    szPath[0] = '\0'; <br>    dwPathLength = GetModuleFileName( GetModuleHandle(NULL), <br>                                      szPath, <br>                                      sizeof(szPath) ); <br> <br>    // Stip off process name (i.e. "ProcSrv.exe") <br>    // <br>    while( dwPathLength &gt; 1 ) <br>    { <br>        --dwPathLength; <br>        if( szPath[dwPathLength] == '\\' || szPath[dwPathLength] == ':' ) <br>        { <br>            dwPathLength++; <br>            szPath[dwPathLength] = '\0';    // Null terminate after back slash <br>            break; <br>        } <br>    } <br> <br>    // Append "&lt;registryname&gt;.log" to path <br>    // <br>    strcat( szPath, szRegistryName ); <br>    strcat( szPath, ".log" ); <br> <br>    srv_config(config, (DBINT)SRV_LOGFILE, szPath, SRV_NULLTERM); <br> <br>    // All data source strings will be converted from ANSI to the OEM codepage <br>    // in order to make this application behave like SQL Server. <br>    // <br>    srv_config(config, (DBINT)SRV_ANSI_CODEPAGE, "FALSE", SRV_NULLTERM); <br> <br>    // Install the error handler. <br>    // <br>    srv_errhandle(chk_err); <br> <br>    //  Initialize Procedure Server and save the server handle <br>    //  so it can be used in later functions. <br>    // <br>    gblServer = srv_init(config, szRegistryName, SRV_NULLTERM); <br> <br>    if( gblServer == NULL ) <br>    { <br>        printf( "\nUnable to initialize Procedure Server.  " <br>                "Check Event Log.\n" ); <br>        goto Exit; <br>    } <br> <br>    // Create an event flag that will tell us when ProcSrv is completely <br>    // shut down (srv_run() has returned) <br>    // <br>    hServerDone = CreateEvent( NULL, TRUE, FALSE, NULL ); <br>    if( hServerDone == NULL ) <br>    { <br>        sprintf( szLogBuffer, <br>                 "Procedure Server Service Manager Failer: %s " <br>                 "(ProcSrvMain(), line = %d), message = %s", <br>                 szRegistryName, <br>                 __LINE__, <br>                 get_last_error_str() ); <br>        srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br>        printf( "\n%s\n", szLogBuffer ); <br>        goto Exit; <br>    } <br> <br>    // When starting Procedure Server, initialize the remote server structure. <br>    // This is done in the init_server() function. <br>    // All the other event handlers are also defined in the init_server() <br>    // function. <br>    // <br>    srv_handle( gblServer, (DBINT)SRV_START, init_server ); <br> <br>    sprintf( szLogBuffer, <br>             "Procedure Server Starting, name = %s", <br>             szRegistryName ); <br> <br>    //  Now everything's ready to go with Procedure Server, so we <br>    //  start it and keep it going until we get a stop request. <br>    // <br>    srv_log( gblServer, FALSE, " ", SRV_NULLTERM );    // insert blank line <br>    srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br> <br>    // initsignal() notifies the Service Control Manager that the <br>    // service has been started and sets up the signal handlers. <br>    // <br>    initsignal( gblServer, argv[0] ); <br> <br>    // completesignal() notifies the Service Control Manager that the <br>    // service has completed its startup process. <br>    // <br>    completesignal( gblServer ); <br> <br>    // srv_run() does not return until either a FAILure occurs or a SRV_EXIT <br>    // event has been issued. <br>    // <br>    if( srv_run(gblServer) == FAIL ) <br>    { <br>        printf( "\nProcedure Server Failer, Check logs.\n" ); <br>        goto Exit; <br>    } <br> <br>    // Set flag indicating all processing completed <br>    // <br>    SetEvent( hServerDone ); <br>    return; <br> <br>Exit: <br>    // initsignal() notifies the Service Control Manager that the <br>    // service has been started and sets up the signal handlers. <br>    // This must be done even though we have an "error exit" condition. <br>    // <br>    initsignal( gblServer, argv[0] ); <br> <br>    // completesignal() notifies the Service Control Manager that the <br>    // service has completed its startup process. <br>    // <br>    completesignal( gblServer ); <br> <br>    // NTBShutdown() sets the SQL Service Manager to "Stop" and terminates <br>    // the service. <br>    // <br>    SetThreadPriority( (HANDLE)_beginthread(NTBShutdown, 0, NULL), <br>                       THREAD_PRIORITY_HIGHEST ); <br> <br>    // Set flag indicating all processing completed <br>    // <br>    SetEvent( hServerDone ); <br>} <br> <br> <br>// This section defines all the Open Data Services event handler functions for <br>// the Procedure Server application. The procedures implemented are: <br>// <br>// <br>//  PROCLIST        Returns all the supported procedures and their usuage. <br>// <br>//  SP_EXEC         Executes a command string and returns output as a rows <br>//                  of text. <br>// <br>//  DISKFREE        Returns the amount the amount of available space for a given <br>//                  drive. <br>// <br>//  DISKLIST        Returns a row for each defined drive containing its name <br>//                  and the amount of disk space available. <br>// <br>// SCAN_XBASE       Reads an xBase file and sends it to the client as if it <br>//                  were a SQL Server query result set (the equivalent of a <br>//                  'SELECT * FROM tablename' SQL statement). <br>// <br>// <br>// ================================== init_server ============================ <br>// <br>// INIT_SERVER <br>//    Initialize the server on a SRV_START event. <br>//    Event handlers for the server are installed. <br>// <br>// Parameters: <br>//    server - Pointer to SRV_SERVER structure <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>SRVRETCODE init_server( SRV_SERVER *server ) <br>{ <br>    char log_buffer[256]; <br> <br>    //  When we get a connection request from a client, we want to <br>    //  call "init_remote()" to make a connection to the remote <br>    //  server. <br>    // <br>    srv_handle(server, (DBINT)SRV_CONNECT, init_remote); <br> <br>    // When the client issues a language request, call <br>    // "lang_execute()" to send the SQL statement to the remote DBMS. <br>    // <br>    srv_handle(server, (DBINT)SRV_LANGUAGE, lang_execute); <br> <br>    // When the client issues an RSP, call "sp_execute()" <br>    // to send the RSP to the remote DBMS (the SQL Server). <br>    // <br>    srv_handle(server, (DBINT)SRV_RPC, sp_execute); <br> <br>    // When a disconnect request is issued, call "exit_remote()" <br>    // to close the connection to the remote DBMS. <br>    // <br>    srv_handle(server, (DBINT)SRV_DISCONNECT, exit_remote); <br> <br>    // Log Server information to log file <br>    // <br>    sprintf(log_buffer, "Client connections allowed = %s", <br>            srv_sfield(server, SRV_CONNECTIONS, (int *)NULL)); <br> <br>    srv_log(server, FALSE, log_buffer, SRV_NULLTERM); <br>    printf("%s\n", log_buffer); <br> <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// ================================== init_remote ============================ <br>// <br>// INIT_REMOTE <br>//    Event handler for a SRV_CONNECT event. <br>//    A connection is made to the procedure server. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>// Side Effects: <br>//    If the connection to the remote dbms cannot be made, then issue <br>//    a SRV_DISCONNECT request. <br>// <br>// <br>SRVRETCODE init_remote( SRV_PROC *srvproc ) <br>{ <br>    char *string; <br>    int   len; <br> <br>    // Set server name <br>    // <br>    srvproc-&gt;serverlen = (BYTE)strlen(szRegistryName); <br>    srvproc-&gt;servername = srv_alloc((DBINT)srvproc-&gt;serverlen); <br>    strcpy(srvproc-&gt;servername, szRegistryName); <br> <br>    // Display info on console <br>    // <br>    string = srv_pfield(srvproc, SRV_CPID, &amp;len); <br>    string[len] = '\0'; <br>    printf("\nClient process ID: %s\n", string); <br> <br>    string = srv_pfield(srvproc,    SRV_USER, &amp;len); <br>    string[len] = '\0'; <br>    printf("User name: %s\n", string); <br> <br>    string = srv_pfield(srvproc, SRV_APPLNAME, &amp;len); <br>    string[len] = '\0'; <br>    if (len &gt; 0) <br>        printf("Application program name: %s\n", string); <br> <br>    string = srv_pfield(srvproc, SRV_RMTSERVER, &amp;len); <br>    string[len] = '\0'; <br>    if (len &gt; 0) <br>        printf("Remote Server: %s\n", string); <br> <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// ================================ lang_execute ============================= <br>// <br>// LANG_EXECUTE <br>//    Execute a client language request on the procedure server. <br>// <br>// Parameters: <br>//    srvproc - process handle to the current client connection. <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>SRVRETCODE lang_execute( SRV_PROC *srvproc ) <br>{ <br>    int      i; <br>    DBCHAR   paramvalues[MAXPARAMS][MAXLEN]; <br>    BYTE     convertvalues[MAXPARAMS][MAXLEN]; <br>    SP_INFO *sp = NULL; <br> <br>    // Initialize parameter storage <br>    // <br>    for (i = 0; i &lt; MAXPARAMS; i++) { <br>        memset(paramvalues[i], 0, MAXLEN); <br>        memset(convertvalues[i], 0, MAXLEN); <br>    } <br>    if (lang_parser(srvproc, &amp;sp, paramvalues) == SUCCEED) { <br>        for (i = 0; i &lt; sp-&gt;numparams; i++) { <br>            if (sp-&gt;params[i].status == REFERENCE) { <br>                srv_sendstatus(srvproc, 1); <br>                srv_sendmsg(srvproc, SRV_MSG_ERROR, INVALID_SP_SYNTAX, <br>                            SRV_INFO, (DBTINYINT)0, NULL, 0, 0, <br>                                    "Procedure contains a return parameter.\ <br>                            Unable to execute as a language event.", <br>                             SRV_NULLTERM); <br>                srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, <br>                             0); <br>                return SRV_CONTINUE; <br> <br>            } <br>            if (strlen(paramvalues[i]) == 0 &amp;&amp; <br>                strlen(sp-&gt;params[i].defaultvalue) == 0) { <br>                srv_sendstatus(srvproc, 1); <br>                srv_sendmsg(srvproc, SRV_MSG_ERROR, INVALID_SP_SYNTAX, <br>                            SRV_INFO, (DBTINYINT)0, NULL, 0, 0, sp-&gt;usage, <br>                            SRV_NULLTERM); <br>                srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, <br>                             0); <br>                return SRV_CONTINUE; <br>            } <br>            if (strlen(paramvalues[i]) == 0 &amp;&amp; <br>                strlen(sp-&gt;params[i].defaultvalue) != 0) <br>                strcpy(paramvalues[i], sp-&gt;params[i].defaultvalue); <br> <br>            // convert parameters from character string to parmeter type <br>            // <br>            srv_convert(srvproc, SRVCHAR, paramvalues[i], -1, <br>                        sp-&gt;params[i].type, &amp;convertvalues[i], <br>                        sp-&gt;params[i].length); <br>        } <br> <br>        // Execute the procedure <br>        // <br>        (sp-&gt;handler)((VOID *)srvproc, &amp;convertvalues[0], &amp;convertvalues[1], <br>                      &amp;convertvalues[2], &amp;convertvalues[3]); <br>    } <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// ================================= lang_parser ============================= <br>// <br>// LANG_PARSER <br>//    A procedure server specific language event parser. <br>// <br>// Parameters: <br>//    srvproc - process handle to the current client connection. <br>//    sp - Pointer to the stored procedure structure <br>//    paramvalues - An array of the values of the parameters. <br>// <br>// Returns: <br>//    SUCCEED <br>// <br>SRVRETCODE lang_parser( SRV_PROC *srvproc, <br>                     SP_INFO **sp, <br>                     DBCHAR    paramvalues[MAXPARAMS][MAXLEN] ) <br>{ <br>    DBCHAR *query;      // pointer to language buffer <br>    int     i; <br>    int     numparams; <br>    DBCHAR  msg[MAXLEN *5]; <br>    DBINT   msgnum; <br>    DBCHAR  spname[MAXLEN]; <br>    BOOL    paramsyntax = FALSE; <br>    DBCHAR  paramname[MAXLEN]; <br>    DBCHAR  equalstring[2]; <br>    DBCHAR *paramvalue = NULL; <br> <br>    query = srv_langptr(srvproc); <br> <br>    // Ignore the syscharsets query from DBLIB 4.2 NT clients <br>    // <br>    if (!strncmp(query, SERVER_INFO_QUERY, strlen(SERVER_INFO_QUERY))){ <br>        srv_senddone(srvproc, SRV_DONE_FINAL, 0, 0); <br>        return FAIL; <br>    } <br> <br>    query = scan_next(query, spname); <br>    if (strlen(spname) == 0) { <br>        srv_senddone(srvproc, SRV_DONE_FINAL, 0, 0); <br>        return FAIL; <br>    } <br>    if (strnicmp(spname, EXEC_CMD, (sizeof(EXEC_CMD) - 1)) == 0) { <br>        // stored procedure name <br>        // <br>        query = scan_next(query, spname); <br>        if (strlen(spname) == 0) <br>            goto syntax_error; <br>    } <br> <br>    // Check for existence <br>    // <br>    for (i = 0; i &lt; Rpcnumber; i++) <br>        if (strcmp(Sps[i].name, spname) == 0) { <br>            *sp = &amp;Sps[i]; <br>            break; <br>        } <br>    if (*sp == NULL) { <br>        sprintf(msg, "Procedure \'%s \' not found.", spname); <br>        msgnum = SP_UNKNOWN; <br>        goto error; <br>    } <br> <br>    // Parameters <br>    // <br>    numparams = 0; <br>    while (*query != '\0') { <br>        if (++numparams &gt; (*sp)-&gt;numparams) { <br>            sprintf(msg, (*sp)-&gt;usage); <br>            msgnum = INVALID_SP_SYNTAX; <br>            goto error; <br>        } <br>        if (!paramsyntax &amp;&amp; *query == '@') <br>            paramsyntax = TRUE; // parameter name mode <br> <br>        if (!paramsyntax) <br>            if (paramvalue == NULL) <br>                paramvalue = paramvalues[0]; <br>            else <br>                paramvalue += MAXLEN; <br> <br>        if (paramsyntax) { <br>            if (*query != '@') { <br>                sprintf( msg, <br>                         "Once the form '@name = value' has been used, " <br>                         "all subsequent parameters must be passed in " <br>                         "the form '@name = value'." ); <br>                msgnum = INVALID_SP_SYNTAX; <br>                goto error; <br>            } else <br>                query++; <br> <br>            query = scan_next(query, <br>            paramname); <br>            if (strlen(paramname) == 0) <br>                goto syntax_error; <br> <br>            // Get parameter index <br>            // <br>            paramvalue = NULL; <br>            for (i = 0; i &lt; (*sp)-&gt;numparams; i++) <br>                if (strcmp((*sp)-&gt;params[i].name, paramname) == 0) { <br>                    paramvalue = paramvalues[i]; <br>                    break; <br>                } <br>            if (paramvalue == NULL) { <br>                sprintf( msg, <br>                         "Procedure '%s' does not recognize parameter name: %s", <br>                         spname, paramname ); <br>                msgnum = BAD_SP_PARAMETER; <br>                goto error; <br>            } <br> <br>            // Already assigned value <br>            // <br>            if (strlen(paramvalue) &gt; 0) <br>                goto syntax_error; <br> <br>            // Check for '=' <br>            // <br>            query = scan_next(query, <br>            equalstring); <br>            if (*equalstring != '=') <br>                goto syntax_error; <br> <br>        } <br>        query = scan_next(query, <br>        paramvalue); <br>        if (strlen(paramvalue) == 0) <br>            goto syntax_error; <br> <br>        if (*query == ',') { <br>            query++; <br>            while (*query == ' ' || *query == '\t') <br>                query++; <br>        } <br>    } <br>    return SUCCEED; <br> <br>syntax_error: <br>    sprintf(msg, "Incorrect syntax found near '%s'.", query); <br>    msgnum = INVALID_SP_SYNTAX; <br> <br>error: <br>    srv_sendstatus(srvproc, 1); <br>    srv_sendmsg(srvproc, SRV_MSG_ERROR, msgnum, SRV_INFO, (DBTINYINT)0, NULL, <br>                0, 0, msg, SRV_NULLTERM); <br>    srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>    return FAIL; <br>} <br> <br> <br>// ================================= scan_next =============================== <br>// <br>// SCAN_NEXT <br>//    Reads the next token in a string, ignoring whitespace. <br>// <br>// Parameters: <br>//    string - The language event string <br>//    word - The next token in the string <br>// <br>// Returns: <br>//    The string incremented passed the token. <br>// <br>DBCHAR *scan_next( DBCHAR *string, DBCHAR *word ) <br>{ <br>    DBCHAR *p; <br> <br>    word[0] = '\0'; <br>    if (*string == '\"' || *string == '\'') { <br>        // check for unclosed quote <br>        // <br>        p = strchr(string + 1, <br>        *string); <br>        if (p == NULL) <br>            return string; <br>        strncpy(word, string + 1, p - (string + 1)); <br>        word[p - (string + 1)] = '\0'; <br>        string += 2; <br>    } else { <br>        // clear proceeding white space <br>        // <br>        while (*string == ' ' || *string == '\t' || *string == '\n' || <br>               *string == '\r') <br>            string++; <br>        sscanf(string, "%s", word); <br> <br>        // ignore comments <br>        // <br>        while (strncmp(word, "/*", 2) == 0) { <br>            string = strstr(string, <br>            "*/"); <br>            if (string != NULL) { <br>                string += 2; <br>                word[0] = '\0'; <br>                while (*string == ' ' || *string == '\t' || *string == '\n' || <br>                       *string == '\r') <br>                    string++; <br>                sscanf(string, "%s", word); <br>            } else <br>                return string; <br>        } <br>    } <br>    if (strlen(word) &gt; 0) <br>        string += strlen(word); <br> <br>    // clear trailing white space <br>    // <br>    while (*string == ' ' || *string == '\t' || *string == '\n' || <br>           *string == '\r') <br>        string++; <br> <br>    return string; <br>} <br> <br> <br>// ================================== sp_execute ============================= <br>// <br>// SP_EXECUTE <br>//    Execute a client stored procedure. <br>// <br>//    Scans the list of defined stored procedures, checks the parameters and <br>//    executes the procedure. If results are returned it is the responsiblity <br>//    of the underlying proedure. <br>// <br>// Parameters: <br>//    srvproc - The process handle to use to send results to the client. <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>SRVRETCODE sp_execute( SRV_PROC  *srvproc ) <br>{ <br>    int      i; <br>    int      x; <br>    int      y; <br>    int      len; <br>    int      numparams; <br>    SP_INFO *sp = NULL; <br>    DBCHAR   msg[MAXLEN]; <br>    DBINT    msgnum; <br>    DBCHAR   paramvalues[MAXPARAMS][MAXLEN]; <br>    BOOL     paramnamemode = FALSE; <br>    DBCHAR  *paramname; <br>    DBINT    paramtype; <br>    DBCHAR  *value; <br>    DBINT    type; <br>    DBINT    status; <br> <br>    // Initialize parameter storage <br>    // <br>    for( i = 0; i &lt; MAXPARAMS; i++ ) <br>        memset( paramvalues[i], 0, MAXLEN ); <br> <br>    for( i = 0; i &lt; Rpcnumber; i++ ) <br>    { <br>        // Create name generated by calling server <br>        // <br>        if( strcmp(Sps[i].name, srv_rpcname(srvproc, (int *)NULL)) == 0 ) <br>        { <br>            sp = &amp;Sps[i]; <br>            break; <br>        } <br>    } <br> <br>    if( sp == NULL ) <br>    { <br>        sprintf( msg, <br>                 "Procedure \'%s \' not found.", <br>                 srv_rpcname(srvproc, (int *)NULL) ); <br> <br>        msgnum = SP_UNKNOWN; <br>        goto error; <br>    } <br> <br>    numparams = srv_rpcparams( srvproc ); <br> <br>    if( srv_paramname(srvproc, 1, &amp;len) &amp;&amp; len &gt; 0 ) <br>        paramnamemode = TRUE; <br> <br>    for( y = 1; y &lt;= numparams; y++ ) <br>    { <br>        // Find parameter number <br>        // <br>        if( paramnamemode ) <br>        { <br>            paramname = srv_paramname( srvproc, <br>                                       y, <br>                                       &amp;len ); <br> <br>            if( strlen(paramname) == 0 ) <br>                goto parameter_error; <br> <br>            if( *paramname == '@' ) <br>                paramname++; <br>            else <br>                goto parameter_error; <br> <br>            value = NULL <br>            ; <br>            for( x = 0; x &lt; sp-&gt;numparams; x++ ) <br>            { <br>                if( strcmp(sp-&gt;params[x].name, paramname) == 0 ) <br>                { <br>                    value  = paramvalues[x]; <br>                    type   = sp-&gt;params[x].type; <br>                    status = sp-&gt;params[x].status; <br>                    break; <br>                } <br>            } <br> <br>            if( value == NULL ) <br>                goto parameter_error; <br>        } <br>        else  // if( paramnamemode ) <br>        { <br>            value  = paramvalues[y - 1]; <br>            type   = sp-&gt;params[y - 1].type; <br>            status = sp-&gt;params[y - 1].status; <br>        } <br> <br>        // Check parameters for correct type <br>        // <br>        paramtype = srv_paramtype( srvproc, y ); <br> <br>        switch( paramtype ) </code></pre>
<p>
</p>
<pre><code>{ <br>        case SRVVARCHAR:    // Type sent by Servers instead of SRVCHAR <br>            paramtype = SRVCHAR; <br>            break; <br>        case SRVINTN:       // Type sent by Servers instead of SRVINT <br>            paramtype = SRVINT4; <br>            break; <br>        default: <br>            break; <br>        } <br> <br>        if( type != paramtype ) <br>        { <br>            if( paramnamemode ) <br>                sprintf( msg, "Parameter \'%s \' is incorrect type.", <br>                         paramname ); <br>            else <br>                sprintf( msg, "Parameter \'%d \' is incorrect type.", y ); <br> <br>            msgnum = BAD_SP_PARAMETER; <br>            goto error; <br>        } <br> <br>        // Check parameters for correct status <br>        // <br>        if( (DBINT)srv_paramstatus(srvproc, y) != status ) <br>        { <br>            if( paramnamemode ) <br>                sprintf( msg, "Parameter \'%s \' has incorrect status.", <br>                         paramname); <br>            else <br>                sprintf( msg, "Parameter \'%d \' had incorrect status.", y ); <br> <br>            msgnum = BAD_SP_PARAMETER; <br>            goto error; <br>        } <br> <br>        // Move SP parameters to local variables <br>        // <br>        srv_bmove( srv_paramdata(srvproc, y), value, srv_paramlen(srvproc, y) ); <br>        value[srv_paramlen(srvproc, y)] = '\0'; <br> <br>    } <br> <br>    // If unspecified, use default value <br>    // <br>    for( i = 0; i &lt; sp-&gt;numparams; i++ ) <br>    { <br>        if( strlen(paramvalues[i]) == 0 <br>        &amp;&amp;  strlen(sp-&gt;params[i].defaultvalue) == 0 ) <br>        { <br>            strcpy( msg, sp-&gt;usage ); <br>            msgnum = INVALID_SP_SYNTAX; <br>            goto error; <br>        } <br> <br>        if( strlen(paramvalues[i]) == 0 <br>        &amp;&amp;  strlen(sp-&gt;params[i].defaultvalue) != 0 ) <br>            strcpy(paramvalues[i], sp-&gt;params[i].defaultvalue); <br>    } <br> <br>    // Execute procedure <br>    // <br>    (*sp-&gt;handler)( (VOID *)srvproc, <br>                    paramvalues[0], <br>                    paramvalues[1], <br>                    paramvalues[2], <br>                    paramvalues[3] ); <br> <br>    return SRV_CONTINUE; <br> <br>parameter_error: <br>    sprintf( msg, "Procedure '%s' does not recognize parameter name: %s", <br>             sp-&gt;name, paramname ); <br>    msgnum = BAD_SP_PARAMETER; <br> <br>error: <br>    srv_sendstatus( srvproc, 1 ); <br>    srv_sendmsg( srvproc, SRV_MSG_ERROR, msgnum, SRV_INFO, (DBTINYINT)0, NULL, <br>                 0, 0, msg, SRV_NULLTERM ); <br>    srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0 ); <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// ================================= exit_remote ============================= <br>// <br>// EXIT_REMOTE <br>//    Handler for SRV_DISCONNECT events. <br>// <br>//    The code to disconnect from the procedure server. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection <br>// <br>// Returns: <br>//    SRV_DISCONNECT <br>/// <br>SRVRETCODE exit_remote( SRV_PROC  *srvproc ) <br>{ <br>    char *string; <br>    int len; <br> <br>    // Display info on console <br>    // <br>    string = srv_pfield(srvproc, SRV_CPID, &amp;len); <br>    string[len] = '\0'; <br>    printf("\nClient connection closed, process ID: %s\n", string); <br> <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// ================================== chk_err ================================================= <br>// <br>// CHK_ERR <br>//    Print out errors. <br>// <br>// Parameters: <br>//    server        - pointer to procedure server server structure. <br>//    srvproc      - pointer to client connection structure <br>//    errornum     - error number. <br>//    severity     - error severity. <br>//    state        - error state. <br>//    oserrnum     - operating system error number, if any. <br>//    errtext      - the text of the error message. <br>//    errtextlen   - length of the errtext message <br>//    oserrtext    - the text of the operating system error message. <br>//    oserrtextlen - length of the errtext message <br>// <br>// Returns: <br>//    SRV_CONTINUE, SRV_CANCEL, or SRV_EXIT_PROGRAM <br>// <br> <br>SRVRETCODE chk_err( SRV_SERVER *server, <br>                 SRV_PROC   *srvproc, <br>                 int         errornum, <br>                 BYTE        severity, <br>                 BYTE        state, <br>                 int         oserrnum, <br>                 DBCHAR     *errtext, <br>                 int         errtextlen, <br>                 DBCHAR     *oserrtext, <br>                 int         oserrtextlen ) <br>{ <br>    char log_buffer[256]; <br>    char error[256]; <br>    char oserror[256]; <br> <br>    memcpy(error, errtext, errtextlen); <br>    error[errtextlen] = '\0'; <br>    memcpy(oserror, oserrtext, oserrtextlen); <br>    oserror[oserrtextlen] = '\0'; <br> <br>    // Strip out resource information. Get the actual error number. <br>    errornum = (errornum &amp; 0x0000FFFF); <br> <br>    // Operating system error? <br>    // <br>    if (oserrnum != SRV_ENO_OS_ERR) { <br>        sprintf(log_buffer, "SERVER OS ERROR: %d: %s.", oserrnum, oserror); <br>        if (server) <br>            srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>        else    // If application not initialized log to screen <br>            printf ("%s\n", log_buffer); <br>    } <br> <br>    // Is this a fatal error for the server? <br>    // <br>    if (severity &gt;= SRV_FATAL_SERVER) { <br>        sprintf(log_buffer, <br>                    "SERVER: FATAL SERVER ERROR: errornum = %d, " <br>                    "severity = %d, state = %d: %s.", <br>                errornum, severity, state, error); <br> <br>        if (server) <br>            srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>        else    // If application not initialized log to screen <br>            printf ("%s\n", log_buffer); <br>        return SRV_EXIT; <br>    } else { <br>        // <br>        // Did the "srvproc" get a fatal error? <br>        // <br>        if (severity &gt;= SRV_FATAL_PROCESS) { <br>            sprintf(log_buffer, <br>                          "SERVER: FATAL CONNECT ERROR: errornum = %d, " <br>                          "severity = %d, state = %d: %s.", <br>                     errornum, severity, state, error); <br> <br>            if (server) <br>                srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>            else    // If application not initialized log to screen <br>                printf ("%s\n", log_buffer); <br> <br>            return SRV_CANCEL; <br>        } <br>    } <br> <br>    // A non-fatal error or an information message received. <br>    // We'll pass it through to the client. <br>    // <br>    if (srvproc != (SRV_PROC *)NULL &amp;&amp; (server != NULL)) <br>        if (severity &lt; 10) {    // if informational message <br>            srv_sendmsg(srvproc, SRV_MSG_INFO, (DBINT)errornum, severity, 0, <br>                        NULL, 0, 0, error, SRV_NULLTERM); <br>        } else {            // must be an error message <br>               srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)errornum, severity, 0, <br>                           NULL, 0, 0, error, SRV_NULLTERM); <br>    } else { <br>        sprintf(log_buffer, "ODS ERROR: errornum = %d, severity = %d: %s", <br>                errornum, severity, error); <br>        if (server) <br>            srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>        else    // If application not initialized log to screen <br>            printf ("%s\n", log_buffer); <br>    } <br>    return SRV_CONTINUE; <br>} <br> <br> <br>// The following are the supported store procedure functions <br>// <br>// ================================== proclist =============================== <br>// <br>// PROCLIST <br>//    Returns the usage for all defined stored procedures <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    SUCCEED <br>// <br>// Side Effects: <br>//    Returns a result set to client <br>// <br>SRVRETCODE proclist( SRV_PROC *srvproc ) <br>{ <br>    DBCHAR colname1[MAXNAME]; <br>    DBCHAR colname2[MAXNAME]; <br>    int i; <br> <br>    sprintf(colname1, "spname"); <br>    srv_describe(srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, MAXNAME, <br>                 SRVCHAR, 0, NULL); <br> <br>    sprintf(colname2, "spusage"); <br>    srv_describe(srvproc, 2, colname2, SRV_NULLTERM, SRVCHAR, MAXLEN, SRVCHAR, <br>                 0, NULL); <br> <br>    // Return each SP handler as a row <br>    // <br>    for (i = 0; i &lt; Rpcnumber; i++) { <br>        srv_setcoldata(srvproc, 1, Sps[i].name); <br>        srv_setcollen(srvproc, 1, strlen(Sps[i].name)); <br> <br>        srv_setcoldata(srvproc, 2, Sps[i].usage); <br>        srv_setcollen(srvproc, 2, strlen(Sps[i].usage)); <br> <br>        srv_sendrow(srvproc); <br>    } <br>    srv_senddone(srvproc, (SRV_DONE_COUNT | SRV_DONE_FINAL), 0, i); <br> <br>    return SUCCEED; <br>} <br> <br> <br>// ================================== sp_exec ================================ <br>// <br>// SP_EXEC <br>//      Execute a given command string and returns any output as rows of <br>//      text. <br>// <br>// Parameters: <br>//      srvproc - the handle to the client connection that got the SRV_CONNECT. <br>//      command - the command string to execute <br>// <br>// Returns: <br>//      SUCCEED or FAIL <br>// <br>// Side Effects: <br>//      Returns messages and/or a result set to client <br>// <br>SRVRETCODE sp_exec( SRV_PROC *srvproc, DBCHAR *command ) <br>{ <br> <br>    DBCHAR bReadBuffer[MAXLEN]; <br>    DBCHAR bErrorMsg[80]; <br>    int    cbReadBuffer; <br> <br>    DBINT   cnt; <br>    DBINT   rows = 0; <br>    DBCHAR *paramvalue; <br>    DBINT   paramlength; <br>    DBINT   cmdlength; <br>    BOOL    fSuccess; <br> <br>    STARTUPINFO         si; <br>    PROCESS_INFORMATION pi; <br> <br>    SECURITY_ATTRIBUTES saPipe; <br>    HANDLE              hReadPipe; <br>    HANDLE              hWritePipe; <br> <br>    // Allocation local storage for command string. <br>    // <br>    paramlength = strlen( command ); <br>    cmdlength   = paramlength + CMDSTR + 1; <br>    paramvalue  = (DBCHAR *)malloc( cmdlength ); <br> <br>    if( !paramvalue ) <br>    { <br>        SETERROR( "Malloc", bErrorMsg ); <br>        srv_sendstatus( srvproc, 1 ); <br>        srv_sendmsg( srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                     NULL, 0, 0, bErrorMsg, SRV_NULLTERM ); <br>        srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0 ); <br>        return FAIL; <br>    } <br> <br>    // Cancatenate "cmd /c " to command string so child process will <br>    // execute the given command and exit.  Move command string to <br>    // local variable. <br>    // <br>    memset( paramvalue, 0, cmdlength ); <br>    srv_bmove( "cmd /c ", paramvalue, CMDSTR ); <br>    srv_bmove( command, &amp;paramvalue[CMDSTR], paramlength ); <br> <br>    // Create child process to execute the command string.  Use an <br>    // anonymous pipe to read the output from the command and send <br>    // any results to the client. <br> <br>    // In order for the child process to be able to write <br>    // to the anonymous pipe, the handle must be marked as <br>    // inheritable by child processes by setting the <br>    // SECURITY_ATTRIBUTES.bInheritHandle flag to TRUE. <br>    // <br>    saPipe.nLength              = sizeof( SECURITY_ATTRIBUTES ); <br>    saPipe.lpSecurityDescriptor = NULL; <br>    saPipe.bInheritHandle       = TRUE; <br> <br>    fSuccess = CreatePipe( &amp;hReadPipe,      // read handle <br>                           &amp;hWritePipe,     // write handle <br>                           &amp;saPipe,         // security descriptor <br>                           0 );             // use default pipe buffer size <br>    if( !fSuccess ) <br>    { <br>        SETERROR( "CreatePipe", bErrorMsg ); <br>        srv_sendstatus( srvproc, 1 ); <br>        srv_sendmsg( srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                     NULL, 0, 0, bErrorMsg, SRV_NULLTERM ); <br>        srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0 ); <br>        free( paramvalue ); <br>        return FAIL; <br>    } <br> <br>    // Now we must set standard out and standard error to the <br>    // write end of the pipe.  Once standard out and standard <br>    // error are set to the pipe handle, we must close the pipe <br>    // handle so that when the child process dies, the write end <br>    // of the pipe will close, setting an EOF condition on the pipe. <br>    // <br>    memset( &amp;si, 0, sizeof(si) ); <br> <br>    si.cb          = sizeof(si); <br>    si.dwFlags     = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES; <br>    si.wShowWindow = SW_HIDE; <br>    si.hStdOutput  = hWritePipe; <br>    si.hStdError   = hWritePipe; <br> <br>    // Set the fInheritHandles parameter to TRUE so that open <br>    // file handles will be inheritied. We can close the child <br>    // process and thread handles as we won't be needing them. <br>    // The child process will not die until these handles are <br>    // closed. <br>    // <br>    fSuccess = CreateProcess( NULL,         // filename <br>                              paramvalue,   // command line for child <br>                              NULL,         // process security descriptor <br>                              NULL,         // thread security descriptor <br>                              TRUE,         // inherit handles? <br>                              0,            // creation flags <br>                              NULL,         // inherited environment address <br>                              NULL,         // startup dir; NULL = start in current <br>                              &amp;si,          // pointer to startup info (input) <br>                              &amp;pi );        // pointer to process info (output) <br>    if( !fSuccess ) <br>    { <br>        SETERROR( "CreateProcess", bErrorMsg ); <br>        srv_sendstatus( srvproc, 1 ); <br>        srv_sendmsg( srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                     NULL, 0, 0, bErrorMsg, SRV_NULLTERM ); <br>        srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0 ); <br>        free( paramvalue ); <br>        return FAIL; <br>    } <br> <br>    CloseHandle( pi.hThread ); <br>    CloseHandle( pi.hProcess ); <br> <br>    // We need to close our instance of the inherited pipe write <br>    // handle now that it's been inherited so that it will actually <br>    // close when the child process ends. This will put an EOF <br>    // condition on the pipe which we can then detect. <br>    // <br>    fSuccess = CloseHandle( hWritePipe ); <br> <br>    if( !fSuccess ) <br>    { <br>        SETERROR( "CloseHandle", bErrorMsg ); <br> <br>        srv_sendstatus( srvproc, 1 ); <br>        srv_sendmsg( srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                     NULL, 0, 0, bErrorMsg, SRV_NULLTERM ); <br>        srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0 ); <br> <br>        free( paramvalue ); <br>        return FAIL; <br>    } <br> <br>    // Now read from the pipe until EOF condition reached. <br>    // <br>    do <br>    { <br>        cnt = 0; <br> <br>        while( fSuccess = ReadFile( hReadPipe,          // read handle <br>                                    &amp;bReadBuffer[cnt],  // buffer for incoming data <br>                                    1,                  // number of bytes to read <br>                                    &amp;cbReadBuffer,      // number of bytes actually read <br>                                    NULL)) <br>        { <br>            if( !fSuccess ) <br>            { <br>                if( GetLastError() == ERROR_BROKEN_PIPE ) <br>                    break;  // child has died <br>                else <br>                { <br>                    SETERROR( "CloseHandle", bErrorMsg ); <br> <br>                    srv_sendstatus( srvproc, 1 ); <br>                    srv_sendmsg( srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, <br>                                 (DBTINYINT)0, NULL, 0, 0, bErrorMsg, <br>                                 SRV_NULLTERM ); <br>                    srv_senddone( srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), <br>                                  0, 0 ); <br> <br>                    free( paramvalue ); <br>                    return FAIL; <br>                } <br>            } <br> <br>            if (bReadBuffer[cnt] == '\n') <br>                break; <br>            else <br>                cnt++; <br>        } <br> <br>        if( fSuccess &amp;&amp; cbReadBuffer ) <br>        { <br>            if( rows == 0 ) <br>            { <br>                // Describe result row: it will be one column of size <br>                // sizeof(buf)  We do this in the retrieval loop to <br>                // ensure that the row description will occur only if <br>                // there are rows to be outputted. <br>                // <br>                srv_describe( srvproc, <br>                              1, <br>                              &amp;paramvalue[CMDSTR], <br>                              SRV_NULLTERM, <br>                              SRVCHAR, <br>                              sizeof(bReadBuffer), <br>                              SRVCHAR, <br>                              sizeof(bReadBuffer), <br>                              bReadBuffer ); <br>            } <br> <br>            // Make sure we have at least one data <br>            // <br>            if( !cnt ) <br>            { <br>                bReadBuffer[0] = ' '; <br>                cnt = 1; <br>            } <br> <br>            // Remove carriage return if it exists <br>            // <br>            if( bReadBuffer[cnt-1] == 0x0D ) <br>                cnt--; <br> <br>            // Send result rows back to client. <br>            // <br>            srv_setcollen( srvproc, 1, cnt ); <br>            srv_sendrow( srvproc ); <br>            rows++; <br>        } <br>    } while( fSuccess &amp;&amp; cbReadBuffer ); <br> <br>    // close the trace file, pipe handles <br>    // <br>    CloseHandle( hReadPipe ); <br> <br>    if( rows == 0 ) <br>    { <br>        srv_sendstatus( srvproc, 0 ); <br>        srv_sendmsg( srvproc, SRV_MSG_INFO, EXEC, SRV_INFO, (DBTINYINT)0, NULL, <br>                     0, 0, "Command executed successfully", SRV_NULLTERM ); <br>    } <br> <br>    srv_senddone( srvproc, (SRV_DONE_COUNT | SRV_DONE_FINAL), 0, rows ); <br>    free( paramvalue ); <br>    return SUCCEED; <br>} <br> <br> <br>// =================================== disklist ============================== <br>// <br>// DISKLIST <br>//     Returns a row for each defined drive containing its name and the <br>//     amount of disk space available. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    SUCCEED <br>// <br>// Side Effects: <br>//     Returns a result set to client <br>// <br>SRVRETCODE disklist( SRV_PROC  *srvproc ) <br>{ <br>    DBCHAR colname1[MAXNAME]; <br>    DBCHAR colname2[MAXNAME]; <br>    DBCHAR drivename; <br>    DBCHAR rootname[16]; <br>    int    drivenum; <br>    unsigned    secPerCluster; <br>    unsigned    bytesPerSector; <br>    unsigned    freeClusters; <br>    unsigned    totalClusters; <br>    int    drivenums; <br>    int    space_remaining; <br>    int    i = 0; <br> <br>    sprintf( colname1, "drive" ); <br>    srv_describe( srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, 1, SRVCHAR, 1, <br>                  (BYTE *)&amp;drivename ); <br> <br>    sprintf( colname2, "Kbytes free" ); <br>    srv_describe( srvproc, 2, colname2, SRV_NULLTERM, SRVINT4, 4, SRVINT4, 4, <br>                  (BYTE *)&amp;space_remaining ); <br> <br>    drivenums = GetLogicalDrives(); <br> <br>    drivenums &gt;&gt;= 2;        // Ignore drives A and B <br>    for( drivename = 'C', drivenum = 3; drivename &lt;= 'Z'; <br>         drivename++, drivenum++ ) <br>    { <br>        if( drivenums &amp; 1 ) <br>        { <br>            i++; <br> <br>            sprintf( rootname, "%c:\\", drivename ); <br>            GetDiskFreeSpace( rootname, &amp;secPerCluster, &amp;bytesPerSector, <br>                              &amp;freeClusters, &amp;totalClusters ); <br> <br>            space_remaining = secPerCluster * bytesPerSector * (freeClusters/1000) ; <br> <br>            srv_sendrow( srvproc ); <br>        } <br> <br>        drivenums &gt;&gt;= 1; <br>    } <br> <br>    srv_senddone( srvproc, (SRV_DONE_COUNT | SRV_DONE_FINAL), 0, i ); <br>    return SUCCEED; <br>} <br> <br> <br>// ================================== diskfree =============================== <br>// <br>// DISKFREE <br>//    Returns the amount of space available on a given drive. The value <br>//     is placed into the defined return parameter of the stored procedure. <br>// <br>//     NOTE: This routine can not be called via a language event. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>//     drive - the drive letter to check <br>// <br>// Returns: <br>//    SUCCEED <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client. Returns a value in the <br>//     defined return parameter. <br>// <br>SRVRETCODE diskfree( SRV_PROC *srvproc, DBCHAR *drive ) <br>{ <br>    DBCHAR colname1[MAXNAME]; <br>    int    drivenum; <br>    DBCHAR rootname[16]; <br>    int    drivenums; <br>    int    secPerCluster; <br>    int    bytesPerSector; <br>    int    freeClusters; <br>    int    totalClusters; <br>    int    space_remaining = -1; <br>    int    i = 0; <br> <br>    drive = strupr( drive ); <br> <br>    sprintf( colname1, "drive" ); <br>    srv_describe( srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, 1, SRVCHAR, 1, <br>                  (BYTE *)drive ); <br>    srv_sendrow( srvproc ); <br>    srv_senddone( srvproc, (SRV_DONE_COUNT | SRV_DONE_MORE), 0, 1 ); <br> <br>    drivenums = GetLogicalDrives(); <br> <br>    drivenum = drive[0] - 'A' + 1; <br> <br>    drivenums &gt;&gt;= drivenum - 1; //Ignore drives A and B <br>    if( drivenums &amp; 0x01 ) <br>    { <br>        sprintf( rootname, "%c:\\", drive[0] ); <br>        GetDiskFreeSpace( rootname, &amp;secPerCluster, &amp;bytesPerSector, <br>                          &amp;freeClusters, &amp;totalClusters ); <br> <br>        space_remaining = secPerCluster * freeClusters * bytesPerSector; <br> <br>    } <br> <br>    // Process return parameter <br>    // <br>    if( srv_paramstatus(srvproc, 2) &amp; 0x0001 ) <br>        srv_paramset( srvproc, 2, (BYTE *)&amp;space_remaining, 4 ); <br> <br>    srv_senddone( srvproc, SRV_DONE_FINAL, 0, 0 ); <br>    return SUCCEED; <br>} <br> <br> <br>// ================================== scan_xbase ============================= <br>// <br>// SCAN_XBASE <br>//    Reads an xBase file and sends it to the client as if it were a SQL <br>//    Server query result set (the equivalent of a 'SELECT * FROM <br>//    tablename' SQL statement). <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>//    szFileName - dbase file path name <br>// <br>// Returns: <br>//    SUCCEED or FAIL <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client <br>// <br>SRVRETCODE scan_xbase( SRV_PROC *srvproc, char *filename ) <br>{ <br>    FILE  *xbasefile; <br>    size_t count; <br>    char   buffer[BUF_SIZE]; <br>    short  numrecords; <br>    short  headerlength; <br>    short  recordlength; <br>    short  lengthlist[XBASE_MAX_COLUMNS]; <br>    int    i; <br>    short  j; <br>    short  position; <br>    short  numcolumns; <br> <br>    // now read the database header info <br>    // <br>    if ((xbasefile = fopen(filename, "r")) == NULL) { <br>        srv_sendstatus(srvproc, 1); <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>        return FAIL; <br>    } <br>    count = fread(buffer, <br>    XBASE_HDR_SIZE, <br>    1, <br>    xbasefile); <br> <br>    if (count == 0) { <br>        srv_sendstatus(srvproc, 1); <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>        fclose(xbasefile); <br>        return FAIL; <br>    } <br>    numrecords   = *((short *)&amp;buffer[4]); <br>    headerlength = *((short *)&amp;buffer[8]); <br>    recordlength = *((short *)&amp;buffer[10]); <br>    numcolumns   = (headerlength - 32 - 1) / 32; <br> <br>    // now get the column header information <br>    // <br>    for (j = 0; j &lt; numcolumns; j++) { <br>        count = fread(buffer,   XBASE_HDR_SIZE, 1, xbasefile); <br>        if (count == 0) { <br>            srv_sendstatus(srvproc, 1); <br>            srv_sendmsg(srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                        NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>            srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>            fclose(xbasefile); <br>            return FAIL; <br>        } <br> <br>        // we need to NULL terminate the column name (if it is a <br>        // full 11 characters int) <br>        // <br>        buffer[11] = '\0'; <br> <br>        // now find our the column length for this data buffer <br>        // <br>        lengthlist[j] = (short)buffer[16]; <br> <br>        // now 'describe' this column <br>        // <br>        srv_describe( srvproc, j + 1,   // column number <br>                      buffer,           // pointer to column name <br>                      SRV_NULLTERM,     // column name is NULL terminated <br>                      SRVCHAR,          // datatype is char (xBase numbers are ASCII) <br>                      lengthlist[j],    // column length <br>                      SRVCHAR,          // destination datatype is also char <br>                      lengthlist[j],    // destination column length <br>                      NULL);            // pointer to where the data will be <br> <br>    } <br> <br>    // now read the one byte 'column header seperator' <br>    // <br>    count = fread(buffer, 1, 1,  xbasefile); <br>    if (count == 0) { <br>        srv_sendstatus(srvproc, 1); <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>        fclose(xbasefile); <br>        return FAIL; <br>    } <br>    for (i = 0; i &lt; numrecords; i++) { <br>        count = fread(buffer, recordlength, 1, xbasefile); <br>        if (count == 0 &amp;&amp; !feof(xbasefile)) { <br>            srv_sendstatus(srvproc, 1); <br>            srv_sendmsg(srvproc, SRV_MSG_ERROR, EXEC, SRV_INFO, (DBTINYINT)0, <br>                        NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>            srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_FINAL), 0, 0); <br>            fclose(xbasefile); <br>            return FAIL; <br>        } <br> <br>        // check to see if this is a deleted row <br>        // <br>        if (buffer[0] == '*') <br>            break; <br> <br>        // Now set the length and data pointers for each column <br>        // <br>        for (j = 0, position = 1; j &lt; numcolumns; j++) { <br>            srv_setcollen(srvproc, j + 1, lengthlist[j]); <br>            srv_setcoldata(srvproc, j + 1, &amp;buffer[position]); <br>            position += lengthlist[j]; <br>        } <br> <br>        // send the row to the client. <br>        // <br>        srv_sendrow(srvproc); <br>    } <br>    srv_senddone(srvproc, SRV_DONE_COUNT | SRV_DONE_FINAL, 0, i); <br>    fclose(xbasefile); <br>    return SUCCEED; <br>} <br> <br> <br>// The following section defines the Service Control Manager support functions. <br>// <br>// ================================== initsignal ============================= <br>// <br>//  initsignal -- Install signal handlers for NTB Server. <br>// <br>void initsignal( SRV_SERVER * server, char * szServiceName ) <br>{ <br>    char szLogBuffer[1024]; <br> <br>    if( SrvCtrMan ) // if started from Service Control Manager <br>    { <br>        // Use RegisterServiceCtrlHandler() to communicate with <br>        // the Service Control Manager. <br>        // <br>        NTBServiceHandle = RegisterServiceCtrlHandler( "ProcSrv", <br>                                                       NTBServiceCtrlHandler ); <br>        InitializeCriticalSection( &amp;SCMCrtSec ); <br> <br>        // Now send a START_PENDING message <br>        // <br>        NTBServiceStatus.dwServiceType  = SERVICE_WIN32_OWN_PROCESS; <br>        NTBServiceStatus.dwCurrentState = SERVICE_START_PENDING; <br> <br>        NTBServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP <br>                                            | SERVICE_ACCEPT_PAUSE_CONTINUE <br>                                            | SERVICE_ACCEPT_SHUTDOWN; <br> <br>        NTBServiceStatus.dwWin32ExitCode           = NO_ERROR; <br>        NTBServiceStatus.dwServiceSpecificExitCode = 0; <br>        NTBServiceStatus.dwCheckPoint              = 1; <br>        NTBServiceStatus.dwWaitHint                = 20000L;   // 20 seconds <br> <br>        if( !SetServiceStatus(NTBServiceHandle, &amp;NTBServiceStatus) ) <br>        { <br>            sprintf( szLogBuffer, <br>                     "Procedure Server Service Manager Failer: %s " <br>                     "(initsignal(), line = %d), message = %s", <br>                     szServiceName, <br>                     __LINE__, <br>                     get_last_error_str() ); <br>            srv_log( server, TRUE, szLogBuffer, SRV_NULLTERM ); <br> <br>            // Flush all file buffers <br>            // <br>            _flushall(); <br>            ExitProcess( 1 ); <br>        } <br> <br>        // We need to increment checkpoint field in the above structure <br>        // regularly in order to notify Service Control Manager that <br>        // we aren't hung. <br>        // <br>        ++(NTBServiceStatus.dwCheckPoint); <br> <br>    } // if( SrvCtrMan ) <br> <br>    // Don't display a message box for hard errors, return the error back <br>    // to the application instead. <br>    // <br>    SetErrorMode( SEM_FAILCRITICALERRORS ); <br> <br>    // Install Ctrl-C handler <br>    // <br>    if( !SrvCtrMan ) <br>    { <br>        if( SetConsoleCtrlHandler((PHANDLER_ROUTINE)ctrlc_hndl, TRUE) <br>        != TRUE ) <br>        { <br>            sprintf( szLogBuffer, <br>                     "Procedure Server Service Manager Failer: %s " <br>                     "(SetConsoleCtrlHandler(), line = %d), message = %s", <br>                     szServiceName, <br>                     __LINE__, <br>                     get_last_error_str() ); <br>            srv_log( server, TRUE, szLogBuffer, SRV_NULLTERM ); <br>        } <br>    } <br>    return; <br>} <br> <br> <br>// ================================== ctrlc_hndl ============================= <br>// <br>//  ctrlc_hndl(ulong) -- Handles Ctrl-C and Ctrl-Break events received <br>//  by NTB Server. <br>// <br>void ctrlc_hndl( ULONG CtrlTyp ) <br>{ <br>    char c; <br>    char szLogBuffer[1024]; <br> <br>    switch( CtrlTyp ) <br>    { <br>    case CTRL_C_EVENT: <br>    case CTRL_BREAK_EVENT: <br> <br>        printf( "Terminate Procedure Server? (y/n): "); <br> <br>        do <br>        { <br>            c = getch(); </code></pre>
<p>
</p>
<pre><code>} while( c != 'y' &amp;&amp; c != 'Y' &amp;&amp; c != 'n' &amp;&amp; c != 'N' ); <br> <br>        printf( "%c\n", c ); <br> <br>        if( c == 'y' || c == 'Y' ) <br>        { <br>            sprintf( szLogBuffer, <br>                     "Procedure Server terminated by Ctrl-C or Ctrl-Break, name = %s", <br>                     szRegistryName ); <br> <br>            if( gblServer ) { <br>                srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br>                srv_setevent( gblServer, SRV_EXIT ); <br>            } <br>            WaitForSingleObject(hServerDone, INFINITE ); <br> <br>            _flushall(); <br>            ExitProcess( 0 ); <br>        } <br> <br>        break; <br> <br>    default: <br>        break; <br>    } <br>    return; <br>} <br> <br> <br>// ============================== NTBServiceCtrlHandler ====================== <br>// <br>//  NTBServiceCtrlHandler(DWORD) -- Responds to START, STOP, etc.. <br>//  requests of Service Control Manager. <br>// <br>void WINAPI NTBServiceCtrlHandler( DWORD dwCtrl ) <br>{ <br>    char szLogBuffer[1024]; <br> <br>    switch( dwCtrl ) <br>    { <br>    case SERVICE_CONTROL_SHUTDOWN: <br>        // <br>        // NT is shutting down. <br>        // <br>        // Fall through <br> <br>    case SERVICE_CONTROL_STOP: <br> <br>        EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>        NTBServiceStatus.dwCurrentState            = SERVICE_STOP_PENDING; <br>        NTBServiceStatus.dwWin32ExitCode           = NO_ERROR; <br>        NTBServiceStatus.dwServiceSpecificExitCode = 0; <br>        NTBServiceStatus.dwCheckPoint              = 1; <br>        NTBServiceStatus.dwWaitHint                = 60000L;   // 60 seconds <br> <br>        SetServiceStatus( NTBServiceHandle, &amp;NTBServiceStatus ); <br>        LeaveCriticalSection( &amp;SCMCrtSec ); <br> <br>        // NTBShutdown() sets the SQL Service Manager to "Stop" and terminates <br>        // the service. <br>        // <br>        SetThreadPriority( (HANDLE)_beginthread(NTBShutdown, 0, NULL), <br>                           THREAD_PRIORITY_HIGHEST ); <br>        break; <br> <br>    case SERVICE_CONTROL_INTERROGATE: <br> <br>        // Serialize with increment signal thread <br>        // <br>        EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>        SetServiceStatus( NTBServiceHandle, &amp;NTBServiceStatus ); <br>        LeaveCriticalSection( &amp;SCMCrtSec ); <br>        break; <br> <br>    case SERVICE_CONTROL_PAUSE: <br> <br>        // Serialize with increment signal thread <br>        // <br>        EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>        srv_setevent( gblServer, SRV_SLEEP ); <br> <br>        NTBServiceStatus.dwCurrentState            = SERVICE_PAUSED; <br>        NTBServiceStatus.dwWin32ExitCode           = NO_ERROR; <br>        NTBServiceStatus.dwServiceSpecificExitCode = 0; <br>        NTBServiceStatus.dwCheckPoint              = 1; <br>        NTBServiceStatus.dwWaitHint                = 60000L;   // 60 seconds <br> <br>        SetServiceStatus( NTBServiceHandle, &amp;NTBServiceStatus ); <br>        LeaveCriticalSection( &amp;SCMCrtSec ); <br> <br>        sprintf( szLogBuffer, <br>                 "Procedure Server PAUSED, name = %s", <br>                 szRegistryName ); <br> <br>        if( gblServer ) <br>            srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br>        break; <br> <br>    case SERVICE_CONTROL_CONTINUE: <br> <br>        EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>        srv_setevent( gblServer, SRV_RESTART ); <br> <br>        NTBServiceStatus.dwCurrentState            = SERVICE_RUNNING; <br>        NTBServiceStatus.dwWin32ExitCode           = NO_ERROR; <br>        NTBServiceStatus.dwServiceSpecificExitCode = 0; <br>        NTBServiceStatus.dwCheckPoint              = 1; <br>        NTBServiceStatus.dwWaitHint                = 60000L;   // 60 seconds <br> <br>        SetServiceStatus(NTBServiceHandle, &amp;NTBServiceStatus); <br>        LeaveCriticalSection( &amp;SCMCrtSec ); <br> <br>        sprintf( szLogBuffer, <br>                 "Procedure Server CONTINUED, name = %s", <br>                 szRegistryName ); <br> <br>        if( gblServer ) <br>            srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br>        break; <br> <br>    default: <br>        // Values 128-255 can be user app defined <br>        // <br>        ; <br>    } // switch( dwCtrl ) <br> <br>    return; <br>} <br> <br> <br>// ================================= completesignal ========================== <br>// <br>// completesignal() -- Notifies Service Control Manager that NTB Server <br>//  has started. <br>// <br>void completesignal( SRV_SERVER * server ) <br>{ <br>    char szLogBuffer[1024]; <br> <br>    if( !SrvCtrMan ) <br>        return; <br> <br>    EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>    NTBServiceStatus.dwCurrentState = SERVICE_RUNNING; <br>    NTBServiceStatus.dwCheckPoint   = 0; <br>    NTBServiceStatus.dwWaitHint     = 0; <br> <br>    if( !SetServiceStatus(NTBServiceHandle, &amp;NTBServiceStatus) ) <br>    { <br>        sprintf( szLogBuffer, <br>                 "Procedure Server Service Manager Failer: %s, (completesignal(), line = %d), message = %s", <br>                     szRegistryName, <br>                     __LINE__, <br>                 get_last_error_str() ); <br> <br>        srv_log( server, TRUE, szLogBuffer, SRV_NULLTERM ); <br>    } <br> <br>    LeaveCriticalSection( &amp;SCMCrtSec ); <br>    return; <br>} <br> <br> <br>// ==================================== NTBShutdown ========================== <br>// <br>//  NTBShutdown() -- This routine notifies ODS to terminate.  After ODS has terminate, <br>//                   the Service Control Manager is notified that everything has shut down. <br>// <br>void NTBShutdown( LPVOID notused ) <br>{ <br>    char szLogBuffer[1024]; <br> <br>    // Flush all file buffers <br>    // <br>    _flushall(); <br> <br>    // Tell ODS to terminate... <br>    // <br>    srv_setevent( gblServer, SRV_EXIT ); <br> <br>    do <br>    { <br>        // Start the checkpoint incrementer <br>        // <br>        ++(NTBServiceStatus.dwCheckPoint); <br> <br>    } while( WaitForSingleObject(hServerDone, 1000) == WAIT_TIMEOUT ); <br> <br>    sprintf( szLogBuffer, <br>             "Procedure Server STOPPED, name = %s", <br>             szRegistryName ); <br> <br>    if( gblServer ) <br>        srv_log( gblServer, TRUE, szLogBuffer, SRV_NULLTERM ); <br> <br>    _flushall(); <br> <br>    EnterCriticalSection( &amp;SCMCrtSec ); <br> <br>    NTBServiceStatus.dwCurrentState            = SERVICE_STOPPED; <br>    NTBServiceStatus.dwWin32ExitCode           = NO_ERROR; <br>    NTBServiceStatus.dwServiceSpecificExitCode = 0; <br>    NTBServiceStatus.dwCheckPoint              = 0; <br>    NTBServiceStatus.dwWaitHint                = 0; <br> <br>    SetServiceStatus( NTBServiceHandle, &amp;NTBServiceStatus ); <br>    LeaveCriticalSection( &amp;SCMCrtSec ); <br> <br>    // Flush all file buffers <br>    // <br>    _flushall(); <br> <br>    ExitProcess( 0 ); <br>} <br> <br> <br>// ============================== get_last_error_str ========================= <br>// <br>// This function returns the Operating System message text and length <br>// associated with the error value sent to it. <br>// <br>//      Inputs: <br>//              iOSerror = value of message to be returned <br>// <br>//      Outputs: <br>//              pointer to message string (NULL if message not found) <br>// <br>char * get_last_error_str() <br>{ <br>    static char * szBuffer = NULL; <br>    DWORD dwLastError = GetLastError(); <br> <br>    if( szBuffer ) <br>        LocalFree( szBuffer ); <br> <br>    szBuffer = NULL; <br> <br>    //  Attempt retrieving the message from system resource table <br>    // <br>    FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM    | <br>                   FORMAT_MESSAGE_ALLOCATE_BUFFER, <br>                   NULL, <br>                   dwLastError, <br>                   (DWORD)GetSystemDefaultLangID(), <br>                   (LPSTR)&amp;szBuffer, <br>                   255,            // maximum message length allowed <br>                   (LPVOID)NULL ); <br>    return szBuffer; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
