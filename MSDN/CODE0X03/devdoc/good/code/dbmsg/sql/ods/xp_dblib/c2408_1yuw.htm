<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XP_DBLIB.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2408"></a>XP_DBLIB.C</h2>
<pre><code>//This is an example of an extended procedure DLL built with Open Data <br>//Services. The functions within the DLL can be invoked by using the extended <br>//stored procedures support in SQL Server.  To register the functions  <br>//and allow all users to use them run the ISQL script XP_DBLIB.SQL. <br>// <br>//For further information on Open Data Services refer to the Microsoft Open  <br>//Data Services Programmer's Reference. <br>// <br>//  The extended procedures implemented in this DLL is: <br>// <br>//  XP_GETTABLEUsed to show the creation of a new connection to SQL Server <br>//using DBLIB that is bound to the initial client connection; <br>//retrieves all rows from the table &lt;table_name&gt;, which is passed  <br>//as an input parameter <br>// <br> <br>#defineDBNTWIN32 <br> <br>#include    &lt;stdlib.h&gt; <br>#include    &lt;stdio.h&gt; <br>#include    &lt;string.h&gt; <br>#include&lt;ctype.h&gt; <br>#include&lt;time.h&gt; <br>#include    &lt;windows.h&gt; <br> <br>#include    &lt;sqlfront.h&gt; <br>#include    &lt;sqldb.h&gt; <br> <br>#include    &lt;srv.h&gt; <br> <br> <br>// Miscellaneous defines <br>// <br>#define  XP_NOERROR0 <br>#define  XP_ERROR1 <br> <br>#define  MAXLEN        255// Maximum string length <br>#define  MAXNAME        31// Maximum name length <br> <br>// Extended procedure error codes <br>#define  SRV_MAXERROR           20000 <br>#define GETTABLE_ERRORSRV_MAXERROR + 1 <br>#define REMOTE_FAIL4002 <br>#define REMOTE_MSGSRV_MAXERROR + 3 <br>  <br> <br>// Stored Procedure information structure. <br>typedef struct xp_info { <br>    DBCHAR name[MAXNAME];   // Extended procedure name <br>    DBCHAR usage[MAXLEN];   // Usage string <br>} XP_INFO; <br> <br> <br>int err_handler(); <br>int msg_handler(); <br> <br> <br>// Array of Extended Stored Procedures supported by this DLL. <br>XP_INFO Xps[] =  <br>{ <br> <br>    "xp_gettable", <br>    "usage: xp_gettable &lt;table_name&gt;", <br>}; <br> <br> <br>// <br>// XP_GETTABLE <br>//    Returns the result of the SQL statement <br>//select * from &lt;table_name&gt; <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client.  <br>// <br> <br> <br>RETCODE xp_gettable(srvproc) <br>SRV_PROC *srvproc; <br>{ <br> <br>DBPROCESS*dbproc;// DBPROCESS handle for the new connection <br>LOGINREC*loginrec; <br> <br> <br>    intparamnum; <br>intbImpersonated; <br>DBCHARtable_name[MAXLEN]; <br>DBINTparamtype; <br> <br>charbindtoken[MAXLEN]; <br>charSqlStmt[MAXLEN]; <br> <br>shortcols;// Data columns returned      <br>    inti;// Index variable             <br>    DBINTrows;// Number of rows sent        <br>    RETCODErc;// Value returned from DB-Library calls       <br> <br>    // Get number of parameters <br>    paramnum = srv_rpcparams(srvproc); <br> <br>    // Check number of parameters <br>    if (paramnum != 1) { <br>        // Send error message and return <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, GETTABLE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error executing extended stored procedure: Invalid Parameter", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>    // Check parameters for correct type <br>    paramtype = srv_paramtype(srvproc, paramnum); <br>    if (paramtype != SRVVARCHAR) { <br>        // Send error message and return <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, GETTABLE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, <br>                    "Error executing extended stored procedure: Invalid Parameter Type", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>// Terminate parameter string with NULL <br>sprintf(table_name, srv_paramdata(srvproc, 1)); <br>table_name[srv_paramlen(srvproc, 1)] = '\0'; <br> <br>loginrec = dblogin(); <br> <br>dbprocerrhandle(loginrec, (DBERRHANDLE_PROC)err_handler); <br>dbprocmsghandle(loginrec, (DBMSGHANDLE_PROC)msg_handler); <br> <br> <br> <br>// Check for integrated security <br>if (strcmp(srv_pfield(srvproc, SRV_LSECURE, (int *)NULL), "TRUE") == 0) { <br>// Client has accessed using some form of integrated security <br>// Impersonate client and set DBSETLSECURE flag <br> <br>    bImpersonated = srv_impersonate_client( srvproc ); <br>DBSETLSECURE(loginrec); <br>} <br>else { <br>    // Client used standard login <br>    // Set the user name, password, and application name for the remote <br> <br>    DBSETLUSER( loginrec, srv_pfield(srvproc, SRV_USER, (int *)NULL) ); <br>    DBSETLPWD( loginrec, srv_pfield(srvproc, SRV_PWD, (int *)NULL) ); <br>} <br> <br> <br>DBSETLAPP (loginrec, "xp_gettable"); <br> <br>    // Try to open a connection to the local DBMS. <br>    // Since the servername parameter is set to NULL, the connection will be <br>    // opened to the local DBMS <br> <br>//dbproc = dbopen(loginrec, "server_name"); <br>dbproc = dbopen(loginrec, NULL); <br> <br>dbsetuserdata(dbproc, (VOID *)srvproc); <br> <br>//get the client session token <br>srv_getbindtoken (srvproc, bindtoken); <br> <br>// put the SQL statement in the command buffer <br>srv_bzero(SqlStmt, MAXLEN); <br>sprintf (SqlStmt, "exec sp_bindsession \'%s\' ", bindtoken); <br> <br>dbcmd (dbproc, SqlStmt); <br>dbsqlexec(dbproc); <br> <br>while ((rc = dbresults (dbproc)) == NO_MORE_RESULTS); <br> <br>// put the SQL statement in the command buffer <br>sprintf (SqlStmt, "select * from %s ", table_name); <br>rc=dbcmd (dbproc, SqlStmt); <br> <br>//send the command buffer to SQL Server for execution <br>rc=dbsqlexec(dbproc); <br> <br>// Process the results <br>while ((rc = dbresults (dbproc)) != NO_MORE_RESULTS) <br>{ <br> <br>        // How many data columns are in the row? <br>cols = dbnumcols (dbproc); <br> <br>        // Build the row description for the client return. <br>for (i = 1; i &lt;= cols; i++) { <br> <br>// Call srv_describe for each column that will be sent back via ODS <br>//to the caller of the extended procedure <br>srv_describe (srvproc, i, (DBCHAR *)dbcolname (dbproc, i), SRV_NULLTERM, <br>                   (DBINT)dbcoltype (dbproc, i), dbcollen (dbproc, i), <br>                   (DBINT)dbcoltype (dbproc, i), dbcollen (dbproc, i), <br>                   (BYTE *)NULL); <br> <br>} <br>rows = 0;  // Initialize a counter for the row number. <br>while (dbnextrow (dbproc) != NO_MORE_ROWS){ <br> <br>// For each data field in the current row, fill the structure that will <br>//    be sent back to the caller of the extended procedure <br>for (i = 1; i &lt;= cols; i++){ <br>srv_setcollen (srvproc, i, (short)dbdatlen (dbproc, i)); <br>        srv_setcoldata (srvproc, i, dbdata(dbproc, i)); <br>} <br> <br>// Send the data row back to SQL Server via ODS <br>if (srv_sendrow (srvproc) == SUCCEED) <br>rows++;                        // Go to the next row.  <br>} <br>} <br> <br> <br>// Send the final done packet for the execution of the command   <br>// batch. The previous batch was one that might have returned    <br>// rows, so set the DONE status accordingly.                     <br>if (rows &gt; 0) <br>srv_senddone (srvproc, SRV_DONE_COUNT | SRV_DONE_MORE, <br>              (DBUSMALLINT) 0, rows); <br>else  <br>srv_senddone (srvproc, SRV_DONE_MORE, (DBUSMALLINT) 0, (DBINT) 0); <br> <br> <br>    // Close the connection to SQL Server.  <br>    dbclose( dbproc ); <br>    dbfreelogin( loginrec ); <br> <br>    // Revert back to SQL Server's user account <br>    // <br>    if( bImpersonated ) <br>        srv_revert_to_self(srvproc); <br> <br>return(XP_NOERROR); <br> <br>} <br> <br> <br>int err_handler(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS*dbproc; <br>intseverity; <br>intdberr; <br>intoserr; <br>char*dberrstr; <br>char*oserrstr; <br>{ <br> <br>SRV_PROC *srvproc = (SRV_PROC *)NULL; <br> <br>srvproc = (SRV_PROC *)dbgetuserdata(dbproc); <br> <br>srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_MSG, <br>(DBTINYINT)severity, (DBTINYINT)0, NULL, 0, 0, dberrstr, <br>SRV_NULLTERM); <br> <br>if ((dbproc == NULL) || (DBDEAD(dbproc))) <br>return(INT_EXIT); <br> <br>return(INT_CANCEL); <br>} <br> <br> <br>int msg_handler(dbproc, msgno, msgstate, severity, msgtext) <br>DBPROCESS*dbproc; <br>DBINTmsgno; <br>intmsgstate; <br>intseverity; <br>char*msgtext; <br>{ <br> <br>SRV_PROC *srvproc = (SRV_PROC *)NULL; <br> <br>srvproc = (SRV_PROC *)dbgetuserdata(dbproc); <br> <br>if (severity &lt; 10) {    // if informational message <br> <br>srv_sendmsg(srvproc, SRV_MSG_INFO, msgno, (DBTINYINT)severity, <br>               (DBTINYINT)msgstate, NULL, 0, 0, (DBCHAR *)msgtext, SRV_NULLTERM); <br>return(0); <br>} <br> <br>    // Trap login fail message <br>    if (msgno == REMOTE_FAIL){ <br>// Send a message to the client that <br>// the remote connection failed. <br>// <br>srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)msgno, (DBTINYINT)severity, <br>                 (DBTINYINT)msgstate, NULL, 0, 0, <br>                 "Login to remote DBMS failed (dbopen).", SRV_NULLTERM); <br>    } <br> <br>     // must be an error message <br>srv_sendmsg(srvproc, SRV_MSG_ERROR, msgno, (DBTINYINT)severity, <br>     (DBTINYINT)msgstate, NULL, 0, 0, (DBCHAR *)msgtext, SRV_NULLTERM); <br> <br>return(0); <br> <br>} <br> <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
