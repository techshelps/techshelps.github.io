<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>XP.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2407"></a>XP.C</h2>
<pre><code>// This is an example of an extended procedure DLL built with Open Data <br>// Services. The functions within the DLL can be invoked by using the extended <br>//stored procedures support in SQL Server.  To register the functions  <br>// and allow all users to use them run the ISQL script INSTXP.SQL. <br>// <br>// For further information on Open Data Services refer to the Microsoft Open  <br>// Data Services Programmer's Reference. <br>// <br>//  The extended procedures implemented in this DLL are: <br>// <br>//  XP_PROCLISTReturns all this DLL's extended stored procedures and  <br>//their usuage. <br>// <br>// XP_DISKLISTReturns a row for each defined drive containing its name  <br>//and the amount of disk space available. <br>// <br>//  XP_DISKFREE   Returns the amount of space available on a given drive. <br>//             The value is placed into the defined return parameter of <br>//             the stored procedure. <br>// <br>//  XP_SCAN_XBASEReads an xBase file and sends it to the client as if it  <br>//were a SQL Server query result set (the equivalent of a  <br>//'SELECT * FROM tablename' SQL statement). <br>// <br>//  XP_ECHOUsed to demo the handling of output parameters in <br>//extended procedures. <br>// <br>//  XP_TRACEUsed to show the installation and removal of pre-handlers <br>//for language and rpc events. The pre-handlers installed <br>//just print langauge and rpc events to the console in <br>//readable form.  Start SQL Server at the command line <br>//to see the output. <br>// <br> <br>#include &lt;stdlib.h&gt; <br>#include &lt;stdio.h&gt; <br>#include &lt;string.h&gt; <br>#include &lt;ctype.h&gt; <br>#include &lt;windows.h&gt; <br>#include &lt;srv.h&gt; <br>#include &lt;time.h&gt; <br> <br>// Miscellaneous defines <br>// <br>#define  XP_NOERROR0 <br>#define  XP_ERROR1 <br> <br>#define  MAXNAME       31// Maximum extended procedure name length <br>#define  MAXLEN        80// Maximum string length <br>#define  COMMAND_PARAM1// Command Parameter <br>#define  OUTPUT_PARAM2// Command Parameter <br> <br>// Extended procedure error codes <br>// <br>#define  SRV_MAXERROR           20000 <br>#define  XP_PROCLIST_ERROR      SRV_MAXERROR + 1 <br>#define  CMDSHELL_ERROR         SRV_MAXERROR + 2 <br>#define  DISKLIST_ERROR         SRV_MAXERROR + 3 <br>#define  SCAN_XBASE_ERROR       SRV_MAXERROR + 4 <br>#define  TRACE_ERROR      SRV_MAXERROR + 6 <br> <br>// Standard error macro for reporting API errors <br>// <br>#define SETERROR( api, retstring)               \ <br>    sprintf(retstring,"%s: Error %d from %s on line %d\n",  \ <br>        __FILE__, GetLastError(), api, __LINE__); <br>  <br>// SCAN_XBASE defines <br>// <br>#define XBASE_HDR_SIZE  32 <br>#define XBASE_MAX_COLUMNS 128 <br>#define XBASE_BUF_SIZE    2048 <br> <br>// function prototypes for xp_trace callbacks <br>SRVRETCODE trace_lang(SRV_PROC *); <br>SRVRETCODE trace_rpc(SRV_PROC *); <br> <br>// Stored Procedure information structure. <br>// <br>typedef struct xp_info { <br>    DBCHAR name[MAXNAME];   // Extended procedure name <br>    DBCHAR usage[MAXLEN];   // Usage string <br>} XP_INFO; <br> <br>// Array of Extended Stored Procedures supported by this DLL. <br>// <br>XP_INFO Xps[] =  <br>{ <br>    "xp_proclist",// Procedure name <br>    "usage: xp_proclist", // Procedure usage string <br> <br>    "xp_disklist", <br>    "usage: xp_disklist", <br> <br>    "xp_diskfree", <br>    "usage: xp_diskfree &lt;[@drive =] drive letter&gt; [,] &lt;[@space =] free space&gt;", <br> <br>    "xp_scan_xbase", <br>    "usage: xp_scan_xbase &lt;xbase file name&gt;", <br> <br>    "xp_echo", <br>    "usage: xp_echo @p1=&lt;input&gt; , @p2=&lt;output-param&gt; output", <br> <br>    "xp_trace", <br>    "usage: xp_trace &lt;[@state=] 'on'|'off'&gt; [, [@users=] NULL | 'all']", <br>}; <br>#define Xpcnumber sizeof(Xps) / sizeof(XP_INFO) <br> <br>// <br>// PROCLIST <br>//    Returns the usage for all defined stored procedures <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//    Returns a result set to client <br>// <br>SRVRETCODE xp_proclist(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int paramnum; <br>    DBCHAR colname1[MAXNAME]; <br>    DBCHAR colname2[MAXNAME]; <br>    int i; <br> <br>    // Get number of parameters <br>    // <br>    paramnum = srv_rpcparams(srvproc); <br> <br>    // Check number of parameters <br>    // <br>    if (paramnum != -1) { <br>        // Send error message and return <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, XP_PROCLIST_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error executing extended stored procedure: Invalid Parameter", <br>                    SRV_NULLTERM); <br>   // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>   // result set of an Extended Stored Procedure. <br>   // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>    sprintf(colname1, "spname"); <br>    srv_describe(srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, MAXNAME, <br>                 SRVCHAR, 0, NULL); <br> <br>    sprintf(colname2, "spusage"); <br>    srv_describe(srvproc, 2, colname2, SRV_NULLTERM, SRVCHAR, MAXLEN, SRVCHAR, <br>                 0, NULL); <br> <br>    // Return each XP handler as a row <br>    // <br>    for (i = 0; i &lt; Xpcnumber; i++) { <br>        srv_setcoldata(srvproc, 1, Xps[i].name); <br>        srv_setcollen(srvproc, 1, strlen(Xps[i].name)); <br> <br>        srv_setcoldata(srvproc, 2, Xps[i].usage); <br>        srv_setcollen(srvproc, 2, strlen(Xps[i].usage)); <br> <br>        srv_sendrow(srvproc); <br>    } <br> // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br> // result set of an Extended Stored Procedure. <br> // <br>    srv_senddone(srvproc, (SRV_DONE_COUNT | SRV_DONE_MORE), 0, i); <br> <br>    return(XP_NOERROR); <br>} <br> <br>// <br>// XP_ECHO <br>//Used to demo the handling of output parameters in extended procedures. <br>//The first parameter should be the input parameter and the second <br>//parameter should be the output.  The input parameter is placed in the <br>//output parameter and returned. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// <br> <br>SRVRETCODE xp_echo(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int paramnum; <br> <br>    // Check number of parameters <br>    // <br>    if ((paramnum = srv_rpcparams(srvproc)) != 2) { <br>        // Send error message and return <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, CMDSHELL_ERROR, SRV_INFO, (DBTINYINT)0, <br>    NULL, 0, 0, "Error executing extended stored procedure: Invalid # of Parameters", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>    // Set output parameter to input parameter. <br>    // <br> <br>    srv_paramset(srvproc, 2, srv_paramdata(srvproc,1), srv_paramlen(srvproc,1)); <br> <br>    srv_senddone(srvproc, SRV_DONE_MORE, 0, 0); <br> <br>    return(XP_NOERROR); <br> <br>} <br> <br>// <br>// XP_DISKLIST <br>//     Returns a row for each defined drive containing its name and the <br>//     amount of disk space available. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//     Returns a result set to client <br>// <br>SRVRETCODE xp_disklist(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int paramnum; <br>    DBCHAR colname1[MAXNAME]; <br>    DBCHAR colname2[MAXNAME]; <br>    DBCHAR drivename; <br>    DBCHAR rootname[16]; <br>    int drivenum; <br>    int secPerCluster; <br>    int bytesPerSector; <br>    int freeClusters; <br>    int totalClusters; <br>    int drivenums; <br>    int space_remaining; <br>    int i = 0; <br> <br>    // Get number of parameters <br>    // <br>    paramnum = srv_rpcparams(srvproc); <br> <br>    // Check number of parameters <br>    // <br>    if (paramnum != -1) { <br>        // Send error message and return <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, DISKLIST_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error executing extended stored procedure: Invalid Parameter", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br>    sprintf(colname1, "drive"); <br>    srv_describe(srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, 1, SRVCHAR, 1, <br>                 (BYTE *)&amp;drivename); <br> <br>    sprintf(colname2, "bytes free"); <br>    srv_describe(srvproc, 2, colname2, SRV_NULLTERM, SRVINT4, 4, SRVINT4, 4, <br>                 (BYTE *)&amp;space_remaining); <br> <br>    drivenums = GetLogicalDrives(); <br> <br>    drivenums &gt;&gt;= 2;        //Ignore drives A and B <br>    for (drivename = 'C', drivenum = 3; drivename &lt;= 'Z'; <br>         drivename++, drivenum++) { <br> <br>        if (drivenums &amp; 1) { <br>            i++; <br>            sprintf(rootname, "%c:\\", drivename); <br>            GetDiskFreeSpace(rootname, &amp;secPerCluster, &amp;bytesPerSector, <br>                             &amp;freeClusters, &amp;totalClusters); <br>            space_remaining = secPerCluster * freeClusters * bytesPerSector; <br> <br>            srv_sendrow(srvproc); <br>        } <br>        drivenums &gt;&gt;= 1; <br>    } <br>    // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>    // result set of an Extended Stored Procedure. <br>    // <br>    srv_senddone(srvproc, (SRV_DONE_COUNT | SRV_DONE_MORE), 0, i); <br>    return(XP_NOERROR); <br>} <br> <br> <br>// <br>// XP_DISKFREE <br>//    Returns the amount of space available on a given drive. The value <br>//     is placed into the defined return parameter of the stored procedure. <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client. Returns a value in the <br>//     defined return parameter. <br>// <br>SRVRETCODE xp_diskfree(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    DBCHAR *drive; <br>    DBCHAR colname1[MAXNAME]; <br>    DBCHAR colname2[MAXNAME]; <br>    DBINT paramlength; <br>    DBCHAR rootname[16]; <br>    DBCHAR bErrorMsg[MAXLEN]; <br> <br>    int drivenum; <br>    int drivenums; <br>    int secPerCluster; <br>    int bytesPerSector; <br>    int freeClusters; <br>    int totalClusters; <br>    int space_remaining = -1; <br> <br>    // Check number of parameters <br>    // <br>    if (srv_rpcparams(srvproc) &gt; 0) { <br> <br>// Allocation local storage for drive name. <br>// <br>paramlength = srv_paramlen(srvproc, 1); <br>drive = (DBCHAR *)malloc(paramlength); <br>if (!drive) { <br> <br>    SETERROR("Malloc", bErrorMsg); <br>    srv_sendmsg(srvproc, SRV_MSG_ERROR, CMDSHELL_ERROR, SRV_INFO, (DBTINYINT)0, <br>       NULL, 0, 0, bErrorMsg, SRV_NULLTERM); <br>    // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>    // result set of an Extended Stored Procedure. <br>    // <br>    srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>    return(XP_ERROR); <br>} <br> <br>// Fetch drive letter. <br>srv_bmove(srv_paramdata(srvproc, 1), drive, paramlength); <br>drive = strupr(drive); <br> <br>    } else <br> <br>// Default drive is C. <br>drive = "C"; <br> <br>    drivenums = GetLogicalDrives(); <br>    drivenum = drive[0] - 'A' + 1; <br> <br>    drivenums &gt;&gt;= drivenum - 1; //Ignore drives A and B <br>    if (drivenums &amp; 0x01) { <br> <br>        sprintf(rootname, "%c:\\", drive[0]); <br>        GetDiskFreeSpace(rootname, &amp;secPerCluster, &amp;bytesPerSector, <br>                         &amp;freeClusters, &amp;totalClusters); <br> <br>        space_remaining = secPerCluster * freeClusters * bytesPerSector; <br> <br>    } <br> <br>    // Process return values <br>    // <br>    if (srv_paramstatus(srvproc, 2) &lt; 0 ) { <br>// Setup column heading <br>sprintf(colname1, "drive"); <br>sprintf(colname2, "space"); <br>srv_describe(srvproc, 1, colname1, SRV_NULLTERM, SRVCHAR, 1, SRVCHAR, 1, <br>     (BYTE *)drive); <br>srv_describe(srvproc, 2, colname2, SRV_NULLTERM, <br>     SRVINT4, sizeof(space_remaining), SRVINT4, <br>     sizeof(space_remaining), &amp;space_remaining); <br> <br>srv_sendrow(srvproc); <br>srv_senddone(srvproc, (SRV_DONE_COUNT | SRV_DONE_MORE), 0, 1); <br> <br>   } <br>    else { <br>srv_paramset(srvproc, 2, (BYTE *)&amp;space_remaining, 4); <br>srv_senddone(srvproc, SRV_DONE_MORE, 0, 0); <br>    } <br> <br>    return(XP_NOERROR); <br>} <br> <br> <br> <br>// <br>// XP_SCAN_XBASE <br>//    Reads an xBase file and sends it to the client as if it were a SQL <br>//    Server query result set (the equivalent of a 'SELECT * FROM <br>//    tablename' SQL statement). <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br>// Side Effects: <br>//    Returns messages and/or a result set to client <br>// <br>SRVRETCODE xp_scan_xbase(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int paramnum; <br>    DBINT paramtype; <br>    DBCHAR *filename; <br>    FILE *xbasefile; <br>    size_t count; <br>    char buffer[XBASE_BUF_SIZE]; <br>    short numrecords; <br>    short headerlength; <br>    short recordlength; <br>    short lengthlist[XBASE_MAX_COLUMNS]; <br>    int i; <br>    short j; <br>    short position; <br>    short numcolumns; <br> <br>    // Get number of parameters <br>    // <br>    paramnum = srv_rpcparams(srvproc); <br> <br>    // Check number of parameters <br>    // <br>    if (paramnum != 1) { <br>        // Send error message and return <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error executing extended stored procedure: Invalid Parameter", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br> <br>    // Check parameters for correct type <br>    // <br>    paramtype = srv_paramtype(srvproc, paramnum); <br>    if (paramtype != SRVVARCHAR) { <br>        // Send error message and return <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, <br>                    "Error executing extended stored procedure: Invalid Parameter Type", <br>                    SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br>    filename = srv_paramdata(srvproc, 1); <br> <br>    // now read the database header info <br>    // <br>    if ((xbasefile = fopen(filename, "r")) == NULL) { <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br>    } <br>    count = fread(buffer, XBASE_HDR_SIZE, 1, xbasefile); <br> <br>    if (count == 0) { <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>        fclose(xbasefile); <br>return(XP_ERROR); <br>    } <br>    numrecords = *((short *)&amp;buffer[4]); <br>    headerlength = *((short *)&amp;buffer[8]); <br>    recordlength = *((short *)&amp;buffer[10]); <br>    numcolumns = (headerlength - 32 - 1) / 32; <br> <br>    // now get the column header information <br>    // <br>    for (j = 0; j &lt; numcolumns; j++) { <br>        count = fread(buffer, <br>        XBASE_HDR_SIZE, <br>        1, <br>        xbasefile); <br>        if (count == 0) { <br>            srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                        NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>         // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>         // result set of an Extended Stored Procedure. <br>         // <br>            srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>            fclose(xbasefile); <br>    return(XP_ERROR); <br>        } <br> <br>        // we need to NULL terminate the column name (if it is a <br>        // full 11 characters int) <br>        // <br>        buffer[11] = '\0'; <br> <br>        // now find our the column length for this data buffer <br>        // <br>        lengthlist[j] = (short)buffer[16]; <br> <br>        // now 'describe' this column <br>        // <br>        srv_describe(srvproc, j + 1,// column number <br>                buffer,     // pointer to column name <br>                SRV_NULLTERM,// column name is NULL terminated <br>                SRVCHAR,    // datatype is char (xBase numbers are ASCII <br>                lengthlist[j],// column length <br>                SRVCHAR,    // destination datatype is also char <br>                lengthlist[j],// destination column length <br>                NULL);      // pointer to where the data will be <br> <br>    } <br>    // now read the one byte 'column header seperator' <br>    // <br>    count = fread(buffer, 1, 1, xbasefile); <br>    if (count == 0) { <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                    NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>     // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>     // result set of an Extended Stored Procedure. <br>     // <br>        srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>        fclose(xbasefile); <br>return(XP_ERROR); <br>    } <br>    for (i = 0; i &lt; numrecords; i++) { <br>        count = fread(buffer, recordlength, 1, xbasefile); <br>        if (count == 0 &amp;&amp; !feof(xbasefile)) { <br>            srv_sendmsg(srvproc, SRV_MSG_ERROR, SCAN_XBASE_ERROR, SRV_INFO, (DBTINYINT)0, <br>                        NULL, 0, 0, "Error reading xBase file", SRV_NULLTERM); <br>         // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br>         // result set of an Extended Stored Procedure. <br>         // <br>            srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>            fclose(xbasefile); <br>    return(XP_ERROR); <br>        } <br> <br>        // check to see if this is a deleted row <br>        // <br>        if (buffer[0] == '*') <br>            break; <br> <br>        // Now set the length and data pointers for each column <br>        for (j = 0, position = 1; j &lt; numcolumns; j++) { <br>            srv_setcollen(srvproc, j + 1, lengthlist[j]); <br>            srv_setcoldata(srvproc, j + 1, &amp;buffer[position]); <br>            position += lengthlist[j]; <br>        } <br> <br>        // send the row to the client. <br>        // <br>        srv_sendrow(srvproc); <br>    } <br> // A SRV_DONE_MORE instead of a SRV_DONE_FINAL must complete the <br> // result set of an Extended Stored Procedure. <br> // <br>    srv_senddone(srvproc, SRV_DONE_COUNT | SRV_DONE_MORE, 0, i); <br>    fclose(xbasefile); <br>    return(XP_NOERROR); <br>} <br> <br>// <br>// XP_TRACE <br>//Used to demo the proc-specific pre-handlers in extended procedures. <br>//Parameter 1 is @state, "on" or "off" to install or remove.   <br>//Parameter 2 is @users, NULL to install pre-handlers on this <br>//srvproc only , or 'all' to install server-wide pre-handlers <br>// <br>// Parameters: <br>//    srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//    XP_NOERROR <br>//    XP_ERROR <br>// <br> <br>SRVRETCODE xp_trace(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int      numparams; <br>    DBCHAR * paramname; <br>    int      i; <br>    int      position; <br>    int      len; <br>    DBINT    paramtype; <br>    DBINT    paramlength; <br>char state[4]; <br>char users[4]; <br>char timestr[9]; <br>char *errmsg; <br>SRV_SERVER *server; <br>intretcode; <br> <br>state[0] = '\0'; <br>users[0] = '\0'; <br> <br>    // Check parameters <br>// Support both named and positional parameters <br>// <br>numparams = srv_rpcparams( srvproc ); <br> <br>    if ((numparams &lt; 1) || (numparams &gt; 2)) { <br>        errmsg = "Error: Invalid number of Parameters"; <br>goto ErrorExit;                     <br>    } <br> <br>    for( i = 1; i &lt;= numparams; i++ ) <br>    { <br>        paramname = srv_paramname( srvproc, i, &amp;len ); <br> <br>        if( len ) <br>        { <br>            if( !stricmp(paramname, "@state") ) <br>                position = 1; <br>            else if( !stricmp(paramname, "@users") ) <br>                position = 2; <br>            else { <br>                srv_sendmsg( srvproc,SRV_MSG_ERROR,TRACE_ERROR, <br>                             16,(DBTINYINT)1,NULL,0,0,"Invalid Parameter",SRV_NULLTERM ); <br>                return FAIL; <br>            } <br>        } <br>        else <br>            position = i; <br> <br>        paramtype   = srv_paramtype( srvproc, i ); <br>        if ( (paramlength = srv_paramlen( srvproc, i )) &gt; 3 ) <br>        { <br>errmsg = "Error:  Parameter value too long"; <br>goto ErrorExit; <br>}         <br> <br>        switch( position ) <br>        { <br>        case 1: // @state <br>            if( paramtype != SRVVARCHAR &amp;&amp; paramtype != SRVNULL ) <br>            { <br>        errmsg = "Error:  Invalid @state parameter type, expecting varchar"; <br>goto ErrorExit;                     <br>            } <br>srv_bmove(srv_paramdata(srvproc, i), state, paramlength); <br>state[paramlength] = '\0'; <br> <br>        break; <br> <br>        case 2: // @users <br>            if( paramtype != SRVVARCHAR &amp;&amp; paramtype != SRVNULL ) <br>            { <br>        errmsg = "Error:  Invalid @users parameter type, expecting varchar"; <br>goto ErrorExit;                     <br>            } <br> <br>srv_bmove(srv_paramdata(srvproc, i), users, paramlength); <br>users[paramlength] = '\0'; <br>             <br>            if ( (stricmp(users,"all") != 0) &amp;&amp; paramlength )  <br>{ <br>        errmsg = "Error:  Invalid @users parameter, must be 'all' or NULL"; <br>goto ErrorExit;                     <br>} <br>break; <br>        } // switch( position ) <br> <br>    } // for( i = 1; i &lt;= numparams; i++ ) <br> <br>// check for required 1st parameter <br>if ( (stricmp(state,"on") != 0) &amp;&amp; (stricmp(state,"off") != 0) )  <br>{ <br>errmsg = "Error:  Required @state parameter must be 'on' or 'off'"; <br>goto ErrorExit;                     <br>}     <br> <br>if (!stricmp(state,"on") &amp;&amp; !strlen(users)) { <br>// turn on trace for just this srvproc <br>srv_pre_handle(NULL,srvproc,SRV_LANGUAGE,trace_lang,FALSE); <br>retcode = srv_pre_handle(NULL,srvproc,SRV_RPC,trace_rpc,FALSE); <br>switch (retcode) { <br>case FAIL: <br>errmsg = "Error installing pre-handlers"; <br>goto ErrorExit;                     <br>case SRV_DUPLICATE_HANDLER: <br>errmsg = "Pre-handler already installed"; <br>goto ErrorExit;                     <br>default: <br>printf("%s  starting trace for KPID %s\n", _strtime(timestr), <br>srv_pfield(srvproc, SRV_SPID, NULL)); <br>} <br>} <br>else if (!stricmp(state,"off") &amp;&amp; !strlen(users)) { <br>// set remove flag to true <br>srv_pre_handle(NULL,srvproc,SRV_LANGUAGE,trace_lang,TRUE); <br>retcode = srv_pre_handle(NULL,srvproc,SRV_RPC,trace_rpc,TRUE); <br>switch (retcode) { <br>case FAIL: <br>errmsg = "Pre-handler not found"; <br>goto ErrorExit;                     <br>default: <br>printf("%s  stopping trace for KPID %s\n", _strtime(timestr), <br>srv_pfield(srvproc, SRV_SPID, NULL)); <br>} <br>} <br>else if (!stricmp(state,"on") &amp;&amp; !stricmp(users, "all")) { <br>// turn on trace for all connections <br>server = SRV_GETSERVER(srvproc); <br>srv_pre_handle(server,NULL,SRV_LANGUAGE,trace_lang,FALSE); <br>retcode = srv_pre_handle(server,NULL,SRV_RPC,trace_rpc,FALSE); <br>switch (retcode) { <br>case FAIL: <br>errmsg = "Error installing pre-handlers"; <br>goto ErrorExit;                     <br>case SRV_DUPLICATE_HANDLER: <br>errmsg = "Pre-handler already installed"; <br>goto ErrorExit;                     <br>default: <br>printf("%s  starting trace for all connections \n", _strtime(timestr)); <br>} <br>} <br>else if (!stricmp(state,"off") &amp;&amp; !stricmp(users, "all")) { <br>// set remove flag to true <br>server = SRV_GETSERVER(srvproc); <br>srv_pre_handle(server,NULL,SRV_LANGUAGE,trace_lang,TRUE); <br>retcode = srv_pre_handle(server,NULL,SRV_RPC,trace_rpc,TRUE); <br>switch (retcode) { <br>case FAIL: <br>errmsg = "Pre-handler not found"; <br>goto ErrorExit;                     <br>default: <br>printf("%s  stopping trace for all connections \n", _strtime(timestr)); <br>} <br>} <br>else { <br>        errmsg = "Error in xp_trace logic"; <br>goto ErrorExit;                     <br>} <br>     <br>    return(XP_NOERROR); <br> <br>ErrorExit: <br>// Send error message and return <br>    // <br>    srv_sendmsg(srvproc, SRV_MSG_ERROR, TRACE_ERROR, SRV_INFO, (DBTINYINT)0, <br>    NULL, 0, 0, errmsg, SRV_NULLTERM); <br>      <br>    srv_senddone(srvproc, (SRV_DONE_ERROR | SRV_DONE_MORE), 0, 0); <br>return(XP_ERROR); <br> <br>} <br>//**************************************************************************** <br>// trace_lang <br>//      This is the pre-language handler routine to print language requests to  <br>//stdio <br>// <br>// Parameters: <br>//    srvproc - a pointer to SRV_PROC stucture <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>// Side Effects: <br>// <br>//**************************************************************************** <br>SRVRETCODE trace_lang(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    char timestr[9]; <br>DBCHAR *query; <br>int query_len; <br> <br>query= srv_langptr(srvproc); <br>query_len = srv_langlen(srvproc); <br> <br>   //print the request <br>    printf("%s  KPID %s lang:  %s\n", _strtime(timestr), <br>    srv_pfield(srvproc, SRV_SPID, (int *)NULL),query); <br>if (query[query_len-1] != '\n') <br>printf("\n"); <br> <br>    return(SRV_CONTINUE); <br>} <br> <br>//**************************************************************************** <br>// trace_rpc <br>//      This is the pre-rpc handler routine to print language requests to  <br>//stdio <br>// <br>// Parameters: <br>//    srvproc - a pointer to SRV_PROC stucture <br>// <br>// Returns: <br>//    SRV_CONTINUE <br>// <br>// Side Effects: <br>// <br>//**************************************************************************** <br>SRVRETCODE trace_rpc(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    int i;                  // Index variable <br>    short params; <br>    DBCHAR complete_rpc_name[4 * (MAXNAME + 1)]; //database.owner.name;# <br>DBCHAR *rpc_db; <br>DBCHAR *rpc_owner; <br>DBCHAR *rpc_name; <br>int rpc_number; <br>char rpc_number_char[17]; <br>DBCHAR *rpc_paramname; <br>DBCHAR * rpc_paramstatus; <br>int rpc_paramtype; <br>DBINT rpc_parammaxlen; <br>DBINT rpc_paramlen; <br>void *rpc_paramdata; <br>char rpc_paramstr[256]; <br>char timestr[9]; <br>DBCHAR * rpc_typename; <br>DBCHAR sztypestr[20]; <br>DBNUMERIC numeric; <br>     <br> <br>    // Construct full RPC name  <br>    // <br>memset (complete_rpc_name, 0, sizeof(complete_rpc_name)); <br>rpc_db = srv_rpcdb(srvproc, (int *)NULL); <br>rpc_owner = srv_rpcowner(srvproc, (int *)NULL); <br>rpc_name = srv_rpcname(srvproc, (int *)NULL); <br>rpc_number = srv_rpcnumber(srvproc); <br> <br>if (rpc_db != NULL) { <br>strcat(complete_rpc_name,rpc_db); <br>strcat(complete_rpc_name,"."); <br>}; <br>if (rpc_owner != NULL) { <br>strcat(complete_rpc_name,rpc_owner); <br>strcat(complete_rpc_name,"."); <br>}; <br>strcat(complete_rpc_name,rpc_name); <br>if (rpc_number &gt; 0) { <br>    strcat(complete_rpc_name,";"); <br>_itoa(rpc_number,rpc_number_char,10); <br>strcat(complete_rpc_name, rpc_number_char); <br>}; <br> <br>//start printing the request <br> <br>    printf("%s  KPID %s rpc:  %s", _strtime(timestr), <br>    srv_pfield(srvproc, SRV_SPID, (int *)NULL),complete_rpc_name); <br>     <br>    // Set up any RPC parameters. <br>    // <br>    params = srv_rpcparams(srvproc); <br> <br>    for (i = 1; i &lt;= params; i++) { <br> <br>rpc_paramname = srv_paramname(srvproc, i, (int *)NULL); <br>if (strlen(rpc_paramname) == 0) rpc_paramname = NULL; <br> <br>        if ((BYTE)srv_paramstatus(srvproc, i) == SRV_PARAMRETURN) <br>        rpc_paramstatus = "OUT"; <br>else <br>rpc_paramstatus = " "; <br> <br>        rpc_paramtype = srv_paramtype(srvproc, i); <br>        rpc_parammaxlen = srv_parammaxlen(srvproc, i); <br>rpc_paramlen = srv_paramlen(srvproc, i); <br>       rpc_paramdata = srv_paramdata(srvproc, i);       <br> <br>switch (rpc_paramtype) { <br>case SRVVARCHAR: <br>sprintf(sztypestr, "%s(%d)","varchar",rpc_parammaxlen); <br>break; <br>case SRVCHAR: <br>sprintf(sztypestr, "%s(%d)","char",rpc_parammaxlen); <br>break; <br>case SRVINTN: <br>switch (rpc_paramlen) { <br>case 1: <br>rpc_typename = "tinyint"; <br>break; <br>case 2: <br>rpc_typename = "smallint"; <br>break; <br>default: <br>rpc_typename = "int"; <br>break; <br>} <br>sprintf(sztypestr, "%s null",rpc_typename); <br>break; <br>case SRVINT1: <br>sprintf(sztypestr, "tinyint"); <br>break; <br>case SRVINT2: <br>sprintf(sztypestr, "smallint"); <br>break; <br>case SRVINT4: <br>sprintf(sztypestr, "int"); <br>break; <br> <br>case SRVMONEYN: <br>switch (rpc_paramlen) { <br>case 4: <br>rpc_typename = "smallmoney"; <br>break; <br>default: <br>rpc_typename = "money"; <br>break; <br>} <br>sprintf(sztypestr, "%s null",rpc_typename); <br>break; <br>case SRVMONEY4: <br>sprintf(sztypestr, "smallmoney"); <br>break; <br>case SRVMONEY: <br>sprintf(sztypestr, "money"); <br>break; <br> <br>case SRVDATETIMN: <br>switch (rpc_paramlen) { <br>case 4: <br>rpc_typename = "smalldatetime"; </code></pre>
<p>
</p>
<pre><code>break; <br>default: <br>rpc_typename = "datetime"; <br>break; <br>} <br>sprintf(sztypestr, "%s null",rpc_typename); <br>break; <br>case SRVDATETIM4: <br>sprintf(sztypestr, "smalldatetime"); <br>break; <br>case SRVDATETIME: <br>sprintf(sztypestr, "datetime"); <br>break; <br> <br>case SRVFLTN: <br>switch (rpc_paramlen) { <br>case 4: <br>rpc_typename = "real"; <br>break; <br>default: <br>rpc_typename = "float"; <br>break; <br>} <br>sprintf(sztypestr, "%s null",rpc_typename); <br>break; <br>case SRVFLT4: <br>sprintf(sztypestr, "real"); <br>break; <br>case SRVFLT8: <br>sprintf(sztypestr, "float"); <br>break; <br> <br>case SRVNUMERIC: <br>case SRVNUMERICN: <br>case SRVDECIMAL: <br>case SRVDECIMALN: <br>memset (&amp;numeric, 0, sizeof(DBNUMERIC)); <br>memmove (&amp;numeric, rpc_paramdata, rpc_paramlen); <br>rpc_paramdata = &amp;numeric; <br>switch (rpc_paramtype) { <br>case SRVNUMERIC: <br>case SRVNUMERICN: <br>rpc_typename = "numeric"; <br>break; <br>case SRVDECIMAL: <br>case SRVDECIMALN: <br>rpc_typename = "decimal"; <br>break; <br>} <br>sprintf(sztypestr, "%s(%d,%d)",rpc_typename, numeric.precision, numeric.scale); <br>if (rpc_paramlen == 2)  <br>rpc_paramlen = 0; <br>break; <br>case SRVTEXT: <br>sprintf(sztypestr, "text"); <br>break; <br>case SRVIMAGE: <br>sprintf(sztypestr, "image"); <br>break; <br> <br>case SRVVARBINARY: <br>sprintf(sztypestr, "%s(%d)","varbinary",rpc_parammaxlen); <br>break; <br>case SRVBINARY: <br>sprintf(sztypestr, "%s(%d)","binary",rpc_parammaxlen); <br>break; <br>case SRVBIT: <br>sprintf(sztypestr, "bit"); <br>break; <br> <br>case SRVNULL: <br>sprintf(sztypestr, "srvnull"); <br>break; <br> <br>default: <br>sprintf(sztypestr, "unknown type"); <br>break; <br> <br>} // end of switch (rpc_paramtype) <br> <br>        if (rpc_paramlen &gt; 0) { <br>if (rpc_paramtype != SRVVARBINARY)   <br>srv_convert(srvproc,rpc_paramtype,rpc_paramdata, <br>rpc_paramlen,SRVCHAR,rpc_paramstr,-1); <br>else <br>strcpy(rpc_paramstr,"&lt;conversion not supported&gt;"); <br>} <br>else  <br>strcpy(rpc_paramstr,"&lt;null&gt;"); <br> <br> <br>printf("\r\n   P%3d: %-10s %-15s %4s %s",i,rpc_paramname, sztypestr, rpc_paramstatus, rpc_paramstr); <br> <br>    } <br>printf("\n\n"); <br> <br>    return(SRV_CONTINUE); <br>} <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
