<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>GATECBS.C</title>
<link disabled rel=stylesheet href=../../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2398"></a>GATECBS.C</h2>
<pre><code>// This file defines all the Open Data Services event handler functions for the <br>// GATEWAY application. <br>// <br> <br>#include    &lt;stdlib.h&gt; <br>#include    &lt;stdio.h&gt; <br>#include    &lt;string.h&gt; <br>#include    &lt;windows.h&gt; <br>#include    &lt;sqlfront.h&gt; <br>#include    &lt;sqldb.h&gt; <br>#include    &lt;srv.h&gt; <br> <br>// Define some user message codes. <br>// <br>#define SRV_MAXERROR    20000 <br>#define RPC_UNKNOWN     SRV_MAXERROR + 1 <br>#define COMPUTE_ROW     SRV_MAXERROR + 2 <br>#define REMOTE_MSG      SRV_MAXERROR + 3 <br>#define SEND_FAILED     SRV_MAXERROR + 4 <br>#define BULK_CMD        "insert bulk" <br> <br>// This error value must be sent back to the client in the event <br>// of a failure to login to the target database.  It is used in the <br>// init_remote() function below. <br>// <br>#define REMOTE_FAIL 4002 <br> <br>// Declare the structure to use for our private data area. <br>// It will be passed to the event handlers in the SRV_PROC structure. <br>// It contains information to make and use a connection to the remote <br>// DBMS -- in this case a SQL Server. <br>// <br>// A gateway to a non-SQL Server DBMS would contain a different structure. <br>// <br>#define MAXPARAMS   255 <br>typedef struct remote_dbms { <br>    LOGINREC *login;    // The SQL Server login structure <br>    DBPROCESS *dbproc;  // The connection to the remote SQL Server <br>    BOOL bulk_mode;         // Flag indicating "bulk insert" mode <br>    short retparams[MAXPARAMS]; // tag return parameters <br>} REMOTE_DBMS; <br> <br>// Declare the structure to be used for packing column metadata into the user datatype <br>// field.  This is a new feature of SQL Server 6.0.  The additional column metadata <br>// is available via dbcolinfo() in DB-Lib.  <br> <br>typedef struct _typeinfo <br>{ <br>    USHORT  typeid;// used to hold the real user datatype <br>    USHORT  nullable:1, // TRUE/FALSE <br>    case_sensitive:1,// TRUE, FALSE <br>    updateable:2,// TRUE, FALSE, UNKNOWN <br>    identity:1,// TRUE/FALSE <br>    spare1:1,// spare fields <br>    spare2:2, <br>    spare3:8; <br>} TYPEINFO; <br> <br>// The remote server name of this gateway <br>// <br>DBCHAR *remote_server = NULL; <br>SRV_PROC *Newsrvproc;       // Latest SRV_PROC allocated. <br> <br>// Mutex used for init_remote() <br>HANDLE init_remote_mutex = 0; <br> <br>int dbcolntype(DBPROCESS *dbproc, int column); <br> <br>int attn_handler(SRV_PROC *srvproc); <br> <br>int chk_err(SRV_SERVER *server, SRV_PROC *srvproc, int srverror, <br>            BYTE severity, BYTE state, int oserrnum, DBCHAR *errtext, <br>            int errtextlen, DBCHAR *oserrtext, int oserrtextlen); <br> <br>int init_remote(SRV_PROC *srvproc); <br> <br>int init_server(SRV_SERVER *server); <br> <br>int rpc_execute(SRV_PROC *srvproc); <br> <br>int exit_remote(SRV_PROC *srvproc); <br> <br>int lang_execute(SRV_PROC *srvproc); <br> <br>int handle_results(DBPROCESS *rmtproc, SRV_PROC *srvproc); <br> <br>int remotemsgs(DBPROCESS *dbproc, DBINT msgno, INT msgstate, <br>               INT severity, LPCSTR msgtext, LPCSTR srvname, LPCSTR procname, <br>DBUSMALLINT line); <br> <br>int remoteerr(DBPROCESS *dbproc, INT severity, INT dberr, INT oserr, <br>              LPCSTR dberrstr, LPCSTR oserrstr); <br> <br>void set_remote_server_name(char *name); <br> <br>// <br>// This section defines the "call-back" functions supplied to the gateway <br>// application. <br>// <br>#pragma check_stack( off )  // turn off stack checking <br> <br>// <br>// SET_REMOTE_SERVER_NAME <br>// <br>//     This function sets the name of the remote server. <br>// <br>// Parameters: <br>//     name - Pointer to name of server. <br>// <br>// Returns: <br>//     none <br>// <br>void set_remote_server_name(name) <br>char *name; <br>{ <br>    remote_server = name; <br>} <br> <br>// <br>// INIT_SERVER <br>//     Initialize the server on a SRV_START event. <br>//     Event handlers for the server are installed. <br>// <br>// Parameters: <br>//     server - Pointer to SRV_SERVER structure <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>int init_server(server) <br>SRV_SERVER *server; <br>{ <br>    char log_buffer[256]; <br> <br>    // When we get a connection request from a client, we want to <br>    // call "init_remote()" to make a connection to the remote <br>    // server. <br>    // <br>    srv_handle(server, (DBINT)SRV_CONNECT, init_remote); <br> <br>    // When the client issues a language request, call <br>    // "lang_execute()" to send the SQL statement to the remote DBMS. <br>    // <br>    srv_handle(server, (DBINT)SRV_LANGUAGE, lang_execute); <br> <br>    // When the client issues an RSP, call "rpc_execute()" <br>    // to send the RSP to the remote DBMS (the SQL Server). <br>    // <br>    srv_handle(server, (DBINT)SRV_RPC, rpc_execute); <br> <br>    // When a disconnect request is issued, call "exit_remote()" <br>    // to close the connection to the remote DBMS. <br>    // <br>    srv_handle(server, (DBINT)SRV_DISCONNECT, exit_remote); <br> <br>    // Install the handler that will be called when the <br>    // gateway receives an attention from one of its <br>    // clients.  <br>    // <br>    srv_handle(server, (DBINT)SRV_ATTENTION, attn_handler); <br> <br> // Initialize dblib and configure for 100 connections <br> // <br> dbinit(); <br> dbsetmaxprocs(100); <br> <br>    // Now we'll install the message and error handlers for any <br>    // messages from the remote DBMS. <br>    // <br>    dberrhandle(remoteerr); <br>    dbmsghandle(remotemsgs); <br> <br> // Create mutex to serialize init_remote <br> // <br> init_remote_mutex = CreateMutex(NULL, FALSE, NULL); <br> <br>    //  Log Server information to log file <br>    // <br>    sprintf(log_buffer, "Client connections allowed = %s", <br>            srv_sfield(server, SRV_CONNECTIONS, (int *)NULL)); <br> <br>    srv_log(server, FALSE, log_buffer, SRV_NULLTERM); <br>    printf("%s\n", log_buffer); <br> <br>    return(SRV_CONTINUE); <br>} <br> <br>// INIT_REMOTE <br>//    Event handler for a SRV_CONNECT event. <br>//    A connection is made to the remote DBMS. <br>// <br>//    In this example program, the connection is to a SQL Server. <br>//    If using a non-SQL Server remote DBMS, the connection code <br>//    would be different, but would probably still occur here. <br>// <br>// Parameters: <br>//      srvproc - the handle to the client connection that got the SRV_CONNECT. <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>// Side Effects: <br>//     If the connection to the remote dbms cannot be made, then issue <br>//     a SRV_DISCONNECT request. <br>// <br>// <br>int init_remote(srvproc) <br>SRV_PROC *srvproc; <br>{ <br> char *string; <br> int len; <br>    REMOTE_DBMS *remote;    // the private data area to keep <br>                                // track of the remote DBMS <br>                                // connection. <br>BOOLbImpersonated; <br> <br>    // Set Newsrvproc.  This is used if we get an error on <br>    // the open from DBLIB.  Since there isn't a dbproc, <br>    // it is clear which srvproc to send the msg back on when the <br>    // DBLIB error-handler gets called. <br>    // <br>    // First lock out any other threads trying to connect using this same <br>    // function. <br>    // <br>    WaitForSingleObject(init_remote_mutex, INFINITE); <br> <br>    Newsrvproc = srvproc; <br> <br>  <br> if (SRV_TDSVERSION(srvproc) != SRV_TDS_6_0)   <br> { <br>// Send a message to the client that they must be 4.2 or 6.0 clients.   <br>// 4.2 client could be supported by  <br>// converting all decimal/numeric values to float before sending to <br>// client, and omiting the column metadata packed into srv_setutype in  <br>// the handle_results() function. <br>// <br>srv_sendmsg(srvproc,  <br>SRV_MSG_ERROR,  <br>(DBINT)REMOTE_FAIL,  <br>(DBTINYINT)0, <br>(DBTINYINT)0,  <br>NULL,  <br>0,  <br>0,  <br>"Gateway sample application only supports version 6.0 clients.", <br>SRV_NULLTERM); <br> <br>// Now allow other threads to enter this function. <br>// <br>   ReleaseMutex(init_remote_mutex); <br>return(SRV_DISCONNECT); <br>    } <br> <br>    // Allocate a REMOTE_DBMS information structure. <br>    // <br>    remote = (REMOTE_DBMS *)srv_alloc((DBINT)sizeof(*remote)); <br> <br>    // Try to open a connection to the remote DBMS. <br>    // <br>    if (remote == NULL) { <br>        // Send a message to the client that <br>        // the remote connection failed. <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_FAIL, (DBTINYINT)0, <br>                    (DBTINYINT)0, NULL, 0, 0, <br>                    "Login to remote DBMS failed (srv_alloc).", SRV_NULLTERM); <br> ReleaseMutex(init_remote_mutex); <br>        return(SRV_DISCONNECT); <br>    } <br> <br>    // Set "bulk insert" mode flag to false. <br>    // <br>    remote-&gt;bulk_mode = FALSE; <br> <br>    // Allocate the LOGINREC structure used to make connections to the <br>    // remote server. Open the connection in the SRV_CONNECT handler. <br>    // <br>    remote-&gt;login = dblogin(); <br> <br>    if (remote-&gt;login == NULL) { <br>        // Send a message to the client that the <br>        // remote connection failed. <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_FAIL, (DBTINYINT)0, <br>                    (DBTINYINT)0, NULL, 0, 0, <br>                    "Login to remote DBMS failed (dblogin).", SRV_NULLTERM); <br> <br>        // Deallocate the remote structure and set the user data <br>        // pointer in "srvproc" to null so that the disconnect <br>        // handler won't try to disconnect from the remote dbms. <br>        // <br>        srv_free(remote); <br> ReleaseMutex(init_remote_mutex); <br>        return(SRV_DISCONNECT); <br>    } <br>    remote-&gt;dbproc = (DBPROCESS *)NULL; <br> <br>    // Set the user name, password, and application name for the remote DBMS. <br>    // <br>    DBSETLUSER(remote-&gt;login, srv_pfield(srvproc, SRV_USER, (int *)NULL)); <br>    DBSETLPWD(remote-&gt;login, srv_pfield(srvproc, SRV_PWD, (int *)NULL)); <br>    DBSETLAPP(remote-&gt;login, srv_pfield(srvproc, SRV_APPLNAME, (int *)NULL)); <br>    DBSETLNATLANG(remote-&gt;login, srv_pfield(srvproc, SRV_NATLANG, (int *)NULL)); <br> <br>// following will let us pass decimal data back to client <br>DBSETLVERSION(remote-&gt;login, DBVER60); <br> <br>//if client requested a trusted connection, gateway must do so too <br>if (srv_pfield(srvproc, SRV_LSECURE, (int *)NULL) == "TRUE") <br>DBSETLSECURE(remote-&gt;login); <br> <br>// Even if client hasn't explicitly requested a trusted connection, he may be <br>// using integrated security if the server is set to mixed or integrated mode. <br>// To handle this case, always tryy to impersonate the client. <br> <br>bImpersonated = srv_impersonate_client(srvproc); <br> <br>    // See if client has set Bulk Copy flag <br>    // <br>    if (strcmp(srv_pfield(srvproc, SRV_BCPFLAG, (int *)NULL), "TRUE") == 0) <br>        BCP_SETL(remote-&gt;login, TRUE); <br>    else <br>        BCP_SETL(remote-&gt;login, FALSE); <br> <br>    // If no server name was specified as a parameter to the main program, <br>    // then assume that the name is coming from the client. <br>    // <br>    if (remote_server == NULL || remote_server[0] == '\0') { <br>        remote_server = srv_pfield(srvproc, SRV_HOST, (int *)NULL); <br>    } <br>    <br>    // Try to open a connection to the remote DBMS. <br>    // <br>    if ((remote-&gt;dbproc = dbopen(remote-&gt;login, <br>                                 remote_server)) == (DBPROCESS *)NULL) { <br> <br>// Send a message to the client that <br>// the remote connection failed. <br>// <br>srv_sendmsg(srvproc,  <br>SRV_MSG_ERROR,  <br>(DBINT)REMOTE_FAIL,  <br>(DBTINYINT)0, <br>(DBTINYINT)0,  <br>NULL,  <br>0,  <br>0,  <br>"Login to remote DBMS failed (dbopen).", <br>SRV_NULLTERM); <br> <br>        // Deallocate the remote structure and set the user data <br>        // pointer in "srvproc" to null so that the disconnect <br>        // handler won't try to disconnect from the remote DBMS. <br>        // <br>        srv_free(remote); <br>        srv_setuserdata(srvproc, (BYTE *)NULL); <br> ReleaseMutex(init_remote_mutex); <br>if( bImpersonated ) <br>        srv_revert_to_self(srvproc); <br>        return(SRV_DISCONNECT); <br>    } else { <br>        // Connection to the remote DBMS successful.  Save <br>        // remote data structure in the "srvproc" so it will be <br>        // available to the other handlers. We'll also map the remote <br>        // DBMS connection to our "srvproc". <br>        // <br>        srv_setuserdata(srvproc, (VOID *)remote); <br>        dbsetuserdata(remote-&gt;dbproc, (VOID *)srvproc); <br> <br>    } <br> <br> ReleaseMutex(init_remote_mutex); <br> <br>// if currently running in user context, don't need to any more <br>if( bImpersonated ) <br>       srv_revert_to_self(srvproc); <br> <br>    // Display connect info on console <br>    // <br> string = srv_pfield(srvproc, SRV_CPID, &amp;len); <br>    string[len] = '\0'; <br> printf("\nClient process ID: %s\n", string); <br> <br>    string = srv_pfield(srvproc, SRV_USER, &amp;len); <br>    string[len] = '\0'; <br>    printf("User name: %s\n", string); <br> <br>    string = srv_pfield(srvproc, SRV_APPLNAME, &amp;len); <br>    string[len] = '\0'; <br>    if (len &gt; 0) <br>       printf("Application program name: %s\n", string); <br> <br>    string = srv_pfield(srvproc, SRV_RMTSERVER, &amp;len); <br>    string[len] = '\0'; <br>    if (len &gt; 0) <br>       printf("Remote Server: %s\n", string); <br> <br>    return(SRV_CONTINUE); <br>} <br> <br>// <br>// LANG_EXECUTE <br>//     Execute a client language request on the remote dbms. <br>//     Any results from the remote dbms are passed back to the client. <br>// <br>//  Parameters: <br>//     srvproc -  process handle to the current client connection. <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>int lang_execute(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    REMOTE_DBMS *rmt_dbms;  // the remote database pointer <br>    DBPROCESS *rmtproc; // our DBPROCESS pointer <br>    DBCHAR *query;      // pointer to language buffer <br>    int query_len;          // length of query <br>    int status;             // status of dblib calls <br> <br>    // Get the remote dbms pointer we saved in the srvproc via <br>    // srv_setuserdata. <br>    // <br>    rmt_dbms = (REMOTE_DBMS *)srv_getuserdata(srvproc); <br> <br>    // Get the pointer to the remote DBPROCESS <br>    // <br>    rmtproc = rmt_dbms-&gt;dbproc; <br> <br>    // Get the pointer to the client language request command buffer. <br>    // <br>    query = srv_langptr(srvproc); <br> <br>    // See if the previous command was a "bulk insert" command <br>    // <br>    if (rmt_dbms-&gt;bulk_mode) { <br> <br>        // Get length of the SQL command. <br>        // <br>        query_len = srv_langlen(srvproc); <br> <br>        // If length of data is zero, then send a zero length buffer <br>        // to the destination SQL Server.  This is required in order to <br>        // signal the SQL Server that no more data follows. <br>        // <br>        if (query_len == -1L) <br>            query_len = 0L; <br> <br>        // Place buffer into target SQL server's buffer.  Use <br>        // dbfcmd() to pass all binary data from the language buffer on to <br>        // the SQL Server. <br>        // <br>        status = dbfcmd(rmtproc, query, query_len); <br> <br>        rmt_dbms-&gt;bulk_mode = FALSE; <br>    } else { <br>        // Let's check for "insert bulk" request <br>        // <br>        if (srv_langlen(srvproc) &gt; (sizeof(BULK_CMD) - 1)) <br>            if (strnicmp(query, BULK_CMD, (sizeof(BULK_CMD) - 1)) == 0) <br>                rmt_dbms-&gt;bulk_mode = TRUE; <br> <br>            // Place buffer into target SQL server's buffer. <br>            // <br>            status = dbcmd(rmtproc, <br>            query); <br>    } <br> <br>    // If previous DBLIB call successful, send command buffer to SQL Server. <br>    // <br>    if (status == SUCCEED) {    // if previous DBLIB call successful <br>        status = dbsqlexec(rmtproc); <br>    } <br>    if (!SRV_GOT_ATTENTION(srvproc) &amp;&amp; (status == SUCCEED)) { <br>        // <br>        // Get the remote dbms results and pass them back to <br>        // client. <br>        // <br>        handle_results(rmtproc, srvproc); <br>    } else { <br>        // <br>        // If an attention event was issued or the dbsqlexec failed, <br>        // acknowledge with senddone. <br>        // <br>        if (DBDEAD(rmtproc)) { <br>            printf("thread shutting down"); <br>            srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_FAIL, <br>                        (DBTINYINT)23, (DBTINYINT)17, NULL, 0, 0, "Remote Server connection no longer active: \ <br>                         thread shutting down" <br>                        , SRV_NULLTERM); <br>            srv_senddone(srvproc, SRV_DONE_FINAL | SRV_DONE_ERROR, <br>                         (DBUSMALLINT)0, (DBINT)0); <br>            srv_event(srvproc, SRV_DISCONNECT, NULL); <br>        } else { <br>            srv_senddone(srvproc, SRV_DONE_FINAL, (DBUSMALLINT)0, (DBINT)0); <br>        } <br>    } <br>    return(SRV_CONTINUE); <br>} <br> <br>// <br>// RPC_EXECUTE <br>//     Execute a client RPC. <br>// <br>//     Note that in our example, the remote DBMS is an SQL Server. <br>//     If our remote DBMS was a foreign DBMS, the code to send <br>//     the query to the remote DBMS and receive remote results <br>//     would be different.  In this example, we'll just send <br>//     the rpc along to the SQL Server. <br>// <br>// Parameters: <br>//    srvproc - The Open Server process handle to use to send results to the <br>//               client. <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>int rpc_execute(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>    DBPROCESS *rmtproc; // Our DBPROCESS pointer <br>    int i;                  // Index variable <br>    short params; <br>    short retparam; <br>    short *paramarray; <br>DBCHAR complete_rpc_name[4 * (MAXNAME + 1)]; //database.owner.name;# <br>DBCHAR *rpc_db; <br>DBCHAR *rpc_owner; <br>DBCHAR *rpc_name; <br>int rpc_number; <br>char rpc_number_char[17]; <br>DBCHAR *rpc_paramname; <br>BYTE rpc_paramstatus; <br>int rpc_paramtype; <br>DBINT rpc_parammaxlen; <br>DBINT rpc_paramlen; <br>void *rpc_paramdata; <br>DBNUMERIC  numeric;//structure to hold numeric params <br> <br>    rmtproc = ((REMOTE_DBMS *)srv_getuserdata(srvproc))-&gt;dbproc; <br>    paramarray = ((REMOTE_DBMS *)srv_getuserdata(srvproc))-&gt;retparams; <br> <br>// initialize numeric structure <br>memset (&amp;numeric, 0, sizeof(DBNUMERIC)); <br> <br>   // Construct full RPC name and initialize the RPC to the remote DBMS. <br>   // <br>memset (complete_rpc_name, 0, sizeof(complete_rpc_name)); <br>rpc_db = srv_rpcdb(srvproc, (int *)NULL); <br>rpc_owner = srv_rpcowner(srvproc, (int *)NULL); <br>rpc_name = srv_rpcname(srvproc, (int *)NULL); <br> <br>if (rpc_db != NULL) { <br>strcat(complete_rpc_name,rpc_db); <br>strcat(complete_rpc_name,"."); <br>}; <br>if (rpc_owner != NULL) { <br>strcat(complete_rpc_name,rpc_owner); <br>strcat(complete_rpc_name,"."); <br>}; <br>strcat(complete_rpc_name,rpc_name); <br> <br>rpc_number = srv_rpcnumber(srvproc); <br>if (rpc_number &gt; 0) { <br>    strcat(complete_rpc_name,";"); <br>itoa(rpc_number,rpc_number_char,10); <br>strcat(complete_rpc_name, rpc_number_char); <br>}; <br> <br>dbrpcinit(rmtproc, complete_rpc_name, (DBUSMALLINT)srv_rpcoptions(srvproc)); <br> <br>    // Set up any RPC parameters. <br>    // <br>    params = srv_rpcparams(srvproc); <br>    retparam = 1; <br> <br>    for (i = 1; i &lt;= params; i++) { <br>rpc_paramname = srv_paramname(srvproc, i, (int *)NULL); <br>    if (!strlen(rpc_paramname))  <br> rpc_paramname = NULL; <br>       rpc_paramstatus = (BYTE)srv_paramstatus(srvproc, i); <br>       rpc_paramtype = srv_paramtype(srvproc, i); <br>       rpc_parammaxlen = srv_parammaxlen(srvproc, i); <br>rpc_paramlen = srv_paramlen(srvproc, i); <br>       rpc_paramdata = srv_paramdata(srvproc, i); <br> <br>//  DB-Lib requires maxlen of -1 for fixed-length datatypes, but ODS doesn't <br>// always return this.   So set it. <br>    switch (rpc_paramtype) <br>    { <br>case SQLDECIMAL: <br>case SQLNUMERIC: <br>case SQLBIT: <br>case SQLINT1: <br>case SQLINT2: <br>case SQLINT4: <br>case SQLFLT4: <br>case SQLDATETIM4: <br>case SQLMONEY4: <br>case SQLMONEY: <br>case SQLDATETIME: <br>case SQLFLT8: <br>    rpc_parammaxlen = -1; <br>    break ; <br>default: <br>    break ; <br>} <br> <br>// Special handling for decimal types.  DB-Lib treats them as fixed length datatypes <br>// that are the full size of a DBNUMERIC.  ODS uses variable-length numeric data <br>// and only gives the exact bytes needed to represent the number  <br> <br>    switch (rpc_paramtype) <br>    { <br>case SQLDECIMAL: <br>case SQLNUMERIC: <br>memset (&amp;numeric, 0, sizeof(DBNUMERIC)); <br>memmove(&amp;numeric, rpc_paramdata, rpc_paramlen); <br>rpc_paramdata = &amp;numeric; <br>// ODS says null numeric values have a length of 2, dblib expects them to be 0 <br>if (rpc_paramlen == 2)  <br>rpc_paramlen = 0; <br>break; <br>default: <br>break; <br>} <br> <br>dbrpcparam(rmtproc,rpc_paramname,rpc_paramstatus,rpc_paramtype,  <br> rpc_parammaxlen,rpc_paramlen, rpc_paramdata); <br> <br>        // The current rpc may have three parameters, but only the <br>        // first and third are return parameters.  This means that <br>        // dbnumrets() returns two parameters, not three.  The first <br>        // call to dbretdata() referes to the rpc's first parameter, <br>        // and the second call to dbretdata() refers to the rpc's <br>        // third parameter.  To handle this, we map each return <br>        // parameter to its original parameter so we can later <br>        // reset the return value of the correct return parameters <br>        // in "handle_results()". <br>        // <br>        if ((BYTE)srv_paramstatus(srvproc, i) &amp; SRV_PARAMRETURN) { <br>            paramarray[retparam] = i; <br>            retparam++; <br>        } <br>    } <br> <br>    // Send the RPC to the remote DBMS. <br>    // <br>    dbrpcsend(rmtproc); <br>    dbsqlok(rmtproc); <br> <br>    // Now get the remote DBMS results and pass them back to <br>    // Open Server client. <br>    // <br>    handle_results(rmtproc, srvproc); <br>    return(SRV_CONTINUE); <br>} <br> <br>// <br>// HANDLE_RESULTS <br>//     Once a command has been sent to the remote DBMS by the <br>//     SRV_LANGUAGE  handler, this routine processes the results <br>//     and passes them back to the client. <br>// <br>// Parameters: <br>//     rmtproc - The DBPROCESS handle to the remote DBMS. <br>//     srvproc - The process handle to use to send results to the client. <br>// <br>// Returns: <br>//     SUCCEED or FAIL. <br>// <br>int handle_results(rmtproc, srvproc) <br>DBPROCESS *rmtproc; <br>SRV_PROC *srvproc; <br>{ <br>    short cols;             // data columns returned <br>    int i;                  // index variable <br>    BOOL results_sent;      // number of result sets sent <br>    BOOL gotcompute;        // COMPUTE row indicator <br>    short *paramarray; <br>    RETCODE returnvalue;    // value returned from dblib call <br>DBCOLdbcol;// column metadata structure <br>TYPEINFOtypeinfo;// used to send metadata in usertype  <br>int dbcolsize;// size of DBCOL struct <br>BOOL bRowsAffected;// was command one that affects or returns rows <br>DBINT nRowsAffected;// result of DBCOUNT <br>DBNUMERIC numeric;// structure to hold precision and scale for numeric cols <br>short collen = 0;// holder for col data length <br>DBINTretlen;// for sending output params <br>DBINTrpc_paramtype;// for sending output params <br> <br>    results_sent = FALSE; <br>    gotcompute = FALSE; <br>bRowsAffected = FALSE; <br>nRowsAffected = 0; <br> <br>    paramarray = ((REMOTE_DBMS *)srv_getuserdata(srvproc))-&gt;retparams; <br> <br>// initialize the DBCOL structure <br>dbcolsize = sizeof(DBCOL); <br>memset(&amp;dbcol, 0, dbcolsize); <br>dbcol.SizeOfStruct = dbcolsize; <br> <br>// initialize numeric structure <br>memset (&amp;numeric, 0, sizeof(DBNUMERIC)); <br> <br>    // Process the results from the remote DBMS. <br>    // Since a command may consist of multiple commands or a single <br>    // command that has multiple sets of results, we'll loop through <br>    // each results set. <br>    // <br>    while (TRUE) { <br> <br>        returnvalue = dbresults(rmtproc); <br>        if (returnvalue == NO_MORE_RESULTS) { <br>            break; <br>        } <br> <br>        // Check to see if the client has sent an attention event.  If <br>        // so, simply discard data from remote server <br>        // <br>        if (SRV_GOT_ATTENTION(srvproc)) { <br>    dbcancel(rmtproc);// See attn_handler comments <br>        continue; <br>        } <br> <br>        // <br>        // If this is the second time through the loop, <br>        // send a completion message to the client <br>        // for the previous results sent. <br>        // <br>        if (results_sent == TRUE) { <br> <br>            // If there are some COMPUTE rows, send a message <br>            // to the client that Data Services Library doesn't yet handle them. <br>            // <br>            if (gotcompute == TRUE) { <br>                gotcompute = FALSE; <br>                srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)COMPUTE_ROW, <br>                            (DBTINYINT)0, (DBTINYINT)0, NULL, 0, 0, <br>                          "Data Services library can't handle COMPUTE rows.", <br>                            SRV_NULLTERM); <br>            } <br> <br>            // If the previous batch was one that may <br>            // have affected rows, set the DONE status <br>            // accordingly. <br>            // <br>            if (bRowsAffected) { <br>                srv_senddone(srvproc, SRV_DONE_MORE | SRV_DONE_COUNT, <br>                             (DBUSMALLINT)0, nRowsAffected); <br>            } else <br>                srv_senddone(srvproc, SRV_DONE_MORE, (DBUSMALLINT)0, <br>                            nRowsAffected); <br> <br>        } <br> <br>        // How many data columns are in the row? <br>        // Non-"select" statements will have 0 columns. <br>        // <br>        cols = dbnumcols(rmtproc); <br> <br>        // Build the row description for the client return. <br>        // <br>        for (i = 1; i &lt;= cols; i++) { <br> <br> <br>            //  Call "srv_describe()" for each column in the row. <br>//  dbcolntype is used to preserve the nullability information <br>//that is lost by dbcoltype. <br>            // <br>            srv_describe(srvproc, i, (DBCHAR *)dbcolname(rmtproc, i), SRV_NULLTERM, <br>                         (DBINT)dbcolntype(rmtproc, i), dbcollen(rmtproc, i), <br>                         (DBINT)dbcolntype(rmtproc, i), dbcollen(rmtproc, i), <br>                         (BYTE *)NULL); <br> <br>// Now pack additional col metadata into the usertype <br>// Note this code below does "SQL 6.0" style packing used by DB-Lib,  <br>// and the ODS gateway ODBC driver if the resources DLL is set to use it <br>// "ODBC-style" metadata encoding uses a different structure, not shown here. <br>// See ODS Programmer's Reference for more details. <br>// get column metadata <br>dbcolinfo(rmtproc, CI_REGULAR, i, 0, &amp;dbcol); <br> <br>// reset to 0 <br>*(DBINT*)&amp;typeinfo = 0; <br> <br>/* Set user type */ <br>if (dbcol.UserType &lt; 0) <br>typeinfo.typeid = 0; <br>else <br>typeinfo.typeid = (USHORT) dbcol.UserType; <br> <br>if (dbcol.Identity == TRUE) <br>   typeinfo.identity = TRUE; <br> <br>if (dbcol.Null == TRUE) <br>   typeinfo.nullable = TRUE; <br>else if (dbcol.Null == DBUNKNOWN) <br>   typeinfo.nullable = DBUNKNOWN; <br> <br>if (dbcol.CaseSensitive == TRUE) <br>   typeinfo.case_sensitive = TRUE; <br>else if (dbcol.CaseSensitive == DBUNKNOWN) <br>   typeinfo.case_sensitive = DBUNKNOWN; <br> <br>if (dbcol.Updatable == TRUE) <br>typeinfo.updateable = TRUE; <br>else if (dbcol.Updatable == DBUNKNOWN) <br>typeinfo.updateable = DBUNKNOWN; <br> <br>srv_setutype(srvproc, i, *(DBINT*)&amp;typeinfo); <br> <br>// If column is a decimal or numeric, need to setup a valid precision and <br>// scale.  Normally this would be provided by dbdata() prior to srv_sendrow(). <br>// But if there are no rows in the result set, srv_sendrow() will not <br>// be called, and ODS will send the header when srv_senddone() is called. <br>if ((dbcol.Type == SQLNUMERIC) || (dbcol.Type == SQLDECIMAL)) <br>{ <br>numeric.precision = dbcol.Precision; <br>numeric.scale = dbcol.Scale; <br>                srv_setcoldata(srvproc, i, &amp;numeric); <br>} <br>        } <br> <br>        // Send each row from the remote DBMS to the client. <br>        // <br>        while (TRUE) { <br> <br>            returnvalue = dbnextrow(rmtproc); <br>            if (returnvalue == NO_MORE_ROWS) { <br>                break; <br>            } <br> <br>            // If it's not a regular row, it's a COMPUTE row. <br>            // This SQL extension is particular to Sybase <br>            // TRANSACT-SQL and is not yet supported. <br>            // <br>            if (DBROWTYPE(rmtproc) != REG_ROW) { <br>                gotcompute = TRUE; <br>                continue; <br>            } else <br>                gotcompute = FALSE; <br> <br>            // The row description is built.  Move the <br>            // rows from the remote server to the client. <br>            // <br>            for (i = 1; i &lt;= cols; i++) { <br>                srv_setcollen(srvproc, i, (collen = (short)dbdatlen(rmtproc, i))); <br>// special handling for the srv_setcoldata pointer if the value is null numeric <br>// dbdata does not point to a valid numeric structure in this case <br>// so point instead to the numeric structure set up at srv_describe time <br> if (  ((dbcoltype(rmtproc, i) == SQLDECIMAL) || (dbcoltype(rmtproc, i) == SQLNUMERIC)) <br> &amp;&amp; (collen == 0)) <br>{ <br>srv_setcoldata(srvproc, i, &amp;numeric); <br>} <br>else <br>                srv_setcoldata(srvproc, i, dbdata(rmtproc, i)); <br>            } <br> <br>            // Check to see if the client has issued an attention event. <br>            // If so, discard data from the remote server. <br>            // <br>            if (SRV_GOT_ATTENTION(srvproc)) { <br>    dbcancel(rmtproc);// See attn_handler comments <br>                continue; <br>            } <br> <br>// Now put the row in the ODS output buffer <br>srv_sendrow(srvproc); <br>        } <br>        // Check to see if any parameter were returned from <br>        // the remote DBMS.  If so, pass them through to the <br>        // client. <br>        for (i = 1; i &lt;= dbnumrets(rmtproc); i++) { <br>            // <br>            // If the return parameters are a result of <br>            // an rpc, we used srv_paramset() to set the return <br>            // value.  If the return parameters are not the <br>            // result of an rpc, we use srv_returnval(). <br>            // <br>retlen = dbretlen(rmtproc, i); <br>rpc_paramtype = dbrettype(rmtproc, i); <br> <br>// special handling for decimal types.  need to add 2 bytes for precision &amp; scale <br>// from what is returned by dbretlen </code></pre>
<p>
</p>
<pre><code>if ((rpc_paramtype == SQLNUMERIC)|| (rpc_paramtype == SQLDECIMAL)) <br>retlen += 2; <br> <br>            if (srv_rpcname(srvproc, NULL) != NULL) { <br>                // <br>                // The current rpc may have three parameters, but <br>                // only the first and third are return parameters. <br>                // This means that dbnumrets() returns two parameters, <br>                // not three.  The first call to dbretdata() refers to <br>                // the rpc's first parameter, and the second call to <br>                // dbretdata() refers to the rpc's third parameter. <br>                // To handle this, we map each return parameter to <br>                // its original parameter so we can later reset the <br>                // return value of the correct return parameters in <br>                // handle_results(). <br>                // <br>                srv_paramset(srvproc, paramarray[i], dbretdata(rmtproc, i), retlen); <br> <br>            } else { <br>                 <br>                srv_returnval(srvproc, (DBCHAR *)dbretname(rmtproc, i), SRV_NULLTERM, <br>                              SRV_PARAMRETURN, rpc_paramtype, <br>                              retlen, retlen,dbretdata(rmtproc, i)); <br> <br> <br>            } <br>        } <br>        // Check to see if we got a return status code from the <br>        // remote DBMS.  Pass it through to the client. <br>        // <br>        if (dbhasretstat(rmtproc)) <br>           srv_sendstatus(srvproc, dbretstatus(rmtproc)); <br> <br>        // If the command was one where count is meaningful <br>        // send the srv_senddone message accordingly. <br>        // <br>bRowsAffected = dbiscount(rmtproc); <br>nRowsAffected = DBCOUNT(rmtproc); <br> <br>        // Set flag so that we will send a completion <br>        // message for the current set of results. <br>        // <br>        results_sent = TRUE; <br>    } <br> <br>    // If there are some COMPUTE rows, send a message <br>    // to the client that Open Services Library doesn't handle them yet. <br>    // <br>    if (gotcompute == TRUE) { <br>        gotcompute = FALSE; <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)COMPUTE_ROW, (DBTINYINT)0, <br>                    (DBTINYINT)0, NULL, 0, 0, <br>                    "Data Services Library can't handle COMPUTE rows.", <br>                    SRV_NULLTERM); <br>    } <br> <br>    // Send the final done packet for the execution of the command batch. <br>    // <br>    // If the previous batch was one that may <br>    // have affected rows, set the DONE status <br>    // accordingly. <br>    // <br>if (bRowsAffected) { <br>    srv_senddone(srvproc, SRV_DONE_FINAL | SRV_DONE_COUNT, <br>                    (DBUSMALLINT)0, nRowsAffected); <br>   } else <br>       srv_senddone(srvproc, SRV_DONE_FINAL, (DBUSMALLINT)0, <br>                nRowsAffected); <br> <br>    return(SUCCEED); <br>} <br> <br>// EXIT_REMOTE <br>//     Handler for SRV_DISCONNECT events. <br>//     Closes remote DBMS connection if appropriate. <br>// <br>//    The code to disconnect from the remote DBMS is SQL Server specific. If <br>//    using a non-SQL Server database, the disconnect from the  remote database <br>//    would be different but would probably still occur here. <br>// <br>// Parameters: <br>//     srvproc - the handle to the client connection <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>int exit_remote(srvproc) <br>SRV_PROC *srvproc; <br>{ <br> char *string; <br> int len; <br>    REMOTE_DBMS *remote;    // pointer to target connect structure <br> <br>    remote = (REMOTE_DBMS *)srv_getuserdata(srvproc); <br> <br>    // Is there a REMOTE_DBMS structure to clean-up? <br>    // <br>    if (remote != (REMOTE_DBMS *)NULL) { <br> <br>        // Is there a live dbproc? <br>        // <br>        if (remote-&gt;dbproc != (DBPROCESS *)NULL) { <br>            dbclose(remote-&gt;dbproc); <br>        } <br>        dbfreelogin(remote-&gt;login); <br>        srv_free(remote); <br>    } <br> <br> // Display info on console <br> // <br> string = srv_pfield(srvproc, SRV_CPID, &amp;len); <br>    string[len] = '\0'; <br>   printf("\nClient connection closed, process ID: %s\n", string); <br> <br>    return(SRV_CONTINUE); <br>} <br> <br>// CHK_ERR <br>//     Print out errors. <br>// <br>// Parameters: <br>//     server        - pointer to gateway server structure. <br>//     srvproc      - pointer to client connection structure <br>//     errornum     - error number. <br>//     severity     - error severity. <br>//     state         - error state. <br>//     oserrnum     - operating system error number, if any. <br>//     errtext      - the text of the error message. <br>//     errtextlen   - length of the errtext message <br>//     oserrtext    - the text of the operating system error message. <br>//     oserrtextlen - length of the errtext message <br>// <br>// Returns: <br>//     SRV_CONTINUE, SRV_CANCEL, or SRV_EXIT <br>// <br> <br>RETCODE chk_err(server, srvproc, errornum, severity, state, oserrnum, errtext, <br>                errtextlen, oserrtext, oserrtextlen) <br>SRV_SERVER *server; <br>SRV_PROC *srvproc; <br>int errornum; <br>BYTE severity; <br>BYTE state; <br>int oserrnum; <br>DBCHAR *errtext; <br>int errtextlen; <br>DBCHAR *oserrtext; <br>int oserrtextlen; <br>{ <br>    char log_buffer[256]; <br>    char error[256]; <br>    char oserror[256]; <br> <br>    memcpy(error, errtext, errtextlen); <br>    error[errtextlen] = '\0'; <br>    memcpy(oserror, oserrtext, oserrtextlen); <br>    oserror[oserrtextlen] = '\0'; <br> <br>// Strip out resource information. Get the actual error number. <br>errornum = (errornum &amp; 0x0000FFFF); <br> <br>    // Operating system error? <br>    // <br>    if (oserrnum != SRV_ENO_OS_ERR) { <br>        sprintf(log_buffer, "SERVER OS ERROR: %d: %s.", oserrnum, oserror); <br> <br>        if (server) <br>srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>else// If application not initialized log to screen <br>    printf ("%s\n", log_buffer); <br>    } <br> <br>    // Is this a fatal error for the server? <br>    // <br>    if (severity &gt;= SRV_FATAL_SERVER) { <br>        sprintf(log_buffer,  <br>  "SERVER: FATAL SERVER ERROR: errornum = %d, severity = %d, state = %d: %s.",   <br> errornum, severity, state, error); <br>        if (server) <br>srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>else// If application not initialized log to screen <br>    printf ("%s\n", log_buffer); <br>        return(SRV_EXIT); <br>    } else { <br>        // <br>        // Did the "srvproc" get a fatal error? <br>        // <br>        if (severity &gt;= SRV_FATAL_PROCESS) { <br>            sprintf(log_buffer, <br>  "SERVER: FATAL CONNECT ERROR: errornum = %d, severity = %d, state = %d: %s.", <br>                     errornum, severity, state, error); <br>        if (server) <br>srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>else// If application not initialized log to screen <br>    printf ("%s\n", log_buffer); <br>            return(SRV_CANCEL); <br>        } <br>    } <br> <br>    // A non-fatal error or an information message received. <br>    // We'll pass it through to the client. <br>    // <br>    if (srvproc != (SRV_PROC *)NULL &amp;&amp; (server != NULL)) <br>        if (severity &lt; 10) {    // if informational message <br>            srv_sendmsg(srvproc, SRV_MSG_INFO, (DBINT)errornum, severity, 0, <br>                        NULL, 0, 0, error, SRV_NULLTERM); <br>        } else {            // must be an error message <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)errornum, severity, 0, <br>                    NULL, 0, 0, error, SRV_NULLTERM); <br>    } else { <br>        sprintf(log_buffer, "ODS ERROR: errornum = %d, severity = %d: %s", <br>                errornum, severity, error); <br>        if (server) <br>srv_log(server, TRUE, log_buffer, SRV_NULLTERM); <br>else// If application not initialized log to screen <br>    printf ("%s\n", log_buffer); <br>    } <br>    return(SRV_CONTINUE); <br>} <br> <br>// REMOTEMSGS <br>//     DBLIB calls this routine when any messages are received <br>//     from the remote DBMS. It gets the remote message information and <br>//     sends it back to the client as a message. <br>// <br>// Parameters: <br>//     dbproc    - The handler to the remote DBMS process that sent the message. <br>//     msgno     - The message number. <br>//     msgstate  - The message state. <br>//     severity  - The message severity. <br>//     msgtext   - The text of the message. <br>//     srvname   - The server name <br>//     procname  - The stored procedure name (if there was one) <br>//     line      - The line number of the procedure <br>// <br>//     The following three parameters are available in TDS4.0 and above: <br>// <br>//     srvname  - The name of the server that sent the message. <br>//     procname - The procedure name, if any, of the remote DBMS command. <br>//     line  - The remote DBMS command buffer line to which the msg applies. <br>// <br>// Returns: <br>//     0 <br>// <br> <br>int remotemsgs(dbproc, msgno, msgstate, severity, msgtext, srvname, procname, line) <br>DBPROCESS *dbproc; <br>DBINT msgno; <br>INT msgstate; <br>INT severity; <br>LPCSTR msgtext; <br>LPCSTR srvname; <br>LPCSTR procname; <br>DBUSMALLINT line; <br>{ <br>    SRV_PROC *srvproc; <br> <br>    // If a remote DBMS error was received during the remote <br>    // open, the dbproc is NULL and a message is sent back on the <br>    // most recent srvproc. <br>    // <br>    if (dbproc == (DBPROCESS *)NULL) { <br>        srvproc = Newsrvproc; <br>    } else { <br>        if ((srvproc = (SRV_PROC *)dbgetuserdata(dbproc)) == NULL) { <br>            // <br>            // An error was received after the dbproc was assigned, but <br>            // before we were able to associate our srvproc. <br>            // <br>            srvproc = Newsrvproc; <br>        } <br>    } <br>    if (severity &lt; 10) {    // if informational message <br> <br>        srv_sendmsg(srvproc, SRV_MSG_INFO, msgno, (DBTINYINT)severity, <br>                    (DBTINYINT)msgstate, NULL, 0, 0, (DBCHAR *)msgtext, SRV_NULLTERM); <br>    return(0); <br>    }  <br> <br>// Trap login fail message <br>if (msgno == REMOTE_FAIL){ <br>        // Send a message to the client that <br>        // the remote connection failed. <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)msgno, (DBTINYINT)severity, <br>                    (DBTINYINT)msgstate, NULL, 0, 0, <br>                    "Login to remote DBMS failed (dbopen).", SRV_NULLTERM); <br>} <br> <br>// must be an error message <br>    srv_sendmsg(srvproc, SRV_MSG_ERROR, msgno, (DBTINYINT)severity, <br>    (DBTINYINT)msgstate, NULL, 0, 0, (DBCHAR *)msgtext, SRV_NULLTERM); <br> <br>    return(0); <br>} <br> <br>// REMOTEERR <br>//     This is the handler for error messages from the remote DBMS, in this <br>//     case DBLIB.  It gets called whenever a DBLIB error occurs.  It takes <br>//     the error message and passes it back to the client. <br>// <br>// Parameters: <br>//     dbproc - The process handle for the remote DBMS. <br>//     severity - The severity of the error. <br>//     dberr - The DBLIB error number. <br>//     oserr - The operating system error, if any. <br>//     dberrstr - The text of the DBLIB error. <br>//     oserrstr - The text of operating system error, if any. <br>// <br>// Returns: <br>//     INT_EXIT to exit the program. <br>//     INT_CANCEL to cause a FAIL return from the DBLIB routine that got <br>//     the error. <br>// <br>int remoteerr(dbproc, severity, dberr, oserr, dberrstr, oserrstr) <br>DBPROCESS *dbproc; <br>INT severity; <br>INT dberr; <br>INT oserr; <br>LPCSTR dberrstr; <br>LPCSTR oserrstr; <br>{ <br>    SRV_PROC *srvproc = (SRV_PROC *)NULL; <br> <br>    // If the DBLIB process is dead or we get a DBLIB error SQLESMSG <br>// ("General SQL Server Error:...") then simply ignore it.  The error <br>    // message has already been sent to the client. <br>    // <br>    if (dberr == SQLESMSG) { <br>        return(INT_CANCEL); <br>    } <br> <br>    // <br>    // A remote DBMS error may have been issued during the remote <br>    // open. In this case, the dbproc will be NULL and a message <br>    // will be sent on the most recent srvproc. <br>    // <br>    if (dbproc == (DBPROCESS *)NULL) { <br>        srvproc = Newsrvproc; <br>    } else { <br>        if ((srvproc = (SRV_PROC *)dbgetuserdata(dbproc)) == NULL) { <br>            // An error was issued after the dbproc was assigned but before <br>            // we were able to associate our srvproc. <br>            // <br>            srvproc = Newsrvproc; <br>        } <br>    } <br> <br>// Trap connection failure error <br>if (dberr == SQLECONN){ <br>        // Send a message to the client that <br>        // the remote connection failed. <br>        // <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_FAIL, (DBTINYINT)severity, <br>                    (DBTINYINT)0, NULL, 0, 0, <br>                    "Unable to establish connection to remote DBMS (dbopen).", SRV_NULLTERM); <br> <br>        return(INT_CANCEL); <br>} <br> <br>    // <br>    // Send error message to client. <br>    // <br>    srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_MSG, <br>                (DBTINYINT)severity, (DBTINYINT)0, NULL, 0, 0, <br> (DBCHAR *)dberrstr, SRV_NULLTERM); <br> <br>    if (oserr != DBNOERR) { <br>        srv_sendmsg(srvproc, SRV_MSG_ERROR, (DBINT)REMOTE_MSG, <br>                    (DBTINYINT)severity, (DBTINYINT)0, NULL, 0, 0, <br>  (DBCHAR *)oserrstr, SRV_NULLTERM); <br>    } <br>    return(INT_CANCEL); <br>} <br> <br>// ATTN_HANDLER <br>//     This is an event handler that will be called when the gateway receives <br>//     an attention from a client. <br>// <br>// Parameters: <br>//     srvproc - Pointer to the client connection structure <br>//               receiving the attention. <br>// <br>// Returns: <br>//     SRV_CONTINUE <br>// <br>int attn_handler(srvproc) <br>SRV_PROC *srvproc; <br>{ <br>// Open Data Services NT receives client attention events asynchronously. <br>  // Being handle_results may be calling dbresults or dbnextrow, we can not <br>// process the attention with the dbcancel call here. Instead dbcancel <br>// will be called after the attention has been detected using  <br>// SRV_GOT_ATTENTION. <br> <br>    return(SRV_CONTINUE); <br>} <br> <br> <br>#pragma check_stack()   // set stack checking to its default setting </code></pre>
<p>&nbsp;</p></body>
</HTML>
