<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPLOGON.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2091"></a>MSPLOGON.C</h2>
<pre><code>/* <br> *  M S P L O G O N . C <br> * <br> *  Logon to a MAPI Sample Message Store. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br>#include "msprc.h" <br>#include &lt;stddef.h&gt; <br> <br>#include "..\common\wrap3d.h" <br> <br>#define MSL_CheckParameters(pobj, intf, method, arglist)        \ <br>        OBJ_CheckParameters(pobj, intf, method, sizeof(MSL), &amp;vtblMSL, arglist) <br>#define MSP_CheckParameters(pobj, intf, method, arglist)        \ <br>        OBJ_CheckParameters(pobj, intf, method, sizeof(MSP), &amp;vtblMSP, arglist) <br> <br>#ifndef MB_SETFOREGROUND <br>#define MB_SETFOREGROUND 0 <br>#endif <br> <br>#define MSL_EnterCriticalSection(pmsl)  OBJ_EnterCriticalSection((POBJ)pmsl) <br>#define MSL_LeaveCriticalSection(pmsl)  OBJ_LeaveCriticalSection((POBJ)pmsl) <br> <br>MSL_Vtbl vtblMSL = <br>{ <br>    (MSL_QueryInterface_METHOD *)       OBJ_QueryInterface, <br>    (MSL_AddRef_METHOD *)               OBJ_AddRef, <br>    MSL_Release, <br>    (MSL_GetLastError_METHOD *)         IMS_GetLastError, <br>    MSL_Logoff, <br>    (MSL_OpenEntry_METHOD *)            IMS_OpenEntry, <br>    (MSL_CompareEntryIDs_METHOD *)      IMS_CompareEntryIDs, <br>    (MSL_Advise_METHOD *)               IMS_Advise, <br>    (MSL_Unadvise_METHOD *)             IMS_Unadvise, <br>    MSL_OpenStatusEntry <br>}; <br> <br>MAPIUID uidProvider = SMPMS_UID_PROVIDER; <br> <br>/* Manifest constants */ <br> <br>#define ACCTSIZE    16          /* Our choice for maximum password length. */ <br> <br>static SPropTagArray sptaPass = <br>{ <br>    1, {PR_SMS_PASSWORD} <br>}; <br> <br>TCHAR szPropFileName[] = TEXT("msgstore.prp"); <br>TCHAR szFolderFileName[] = TEXT("recfldr.stg"); <br>TCHAR szProviderDisplayName[] = TEXT("Sample Message Store"); <br>TCHAR szDisplayPrefix[] = TEXT("Sample store at "); <br> <br>/* property tags needed for service creation or configuration */ <br>static  SizedSPropTagArray(4,ptaConfig) = {4, { PR_SMS_PATH, <br>                                            PR_SMS_PASSWORD, <br>                                            PR_SMS_REMEMBER_PW, <br>                                            PR_SMS_CREATE } }; <br> <br>/* property tags that should be removed from the profile after */ <br>/* service creation or configuration */ <br>static  SizedSPropTagArray(2,ptaDel)= {2, { PR_SMS_REMEMBER_PW, <br>                                            PR_SMS_CREATE } }; <br> <br>/* service parameter block */ <br>typedef struct _ServicePBLK <br>{ <br>    PMSP            pmsp; <br>    LPPROFSECT      pps; <br>    LPMAPISUP       psup; <br>    ULONG           ulUIParam; <br>    ULONG           ulContext; <br>    ULONG           ulSEFlags; <br>    ULONG           cvalsProf; <br>    LPSPropValue    pvalsProf; <br>    ULONG           cvalsClient; <br>    LPSPropValue    pvalsClient; <br>} SERVICEPBLK, FAR * PSERVICEPBLK; <br> <br> <br>#define LGNCRED_PATH        ((ULONG) 0x00000001) <br>#define LGNCRED_PASS        ((ULONG) 0x00000002) <br>#define LGNCRED_CREATE      ((ULONG) 0x00000004) <br>#define LGNCRED_REMEMBER    ((ULONG) 0x00000008) <br> <br>/* Typedefs */ <br> <br>typedef struct _LGNCRED <br>{ <br>    ULONG ulFieldMask; <br>    TCHAR szPath[MAX_PATH]; <br>    TCHAR szPass[ACCTSIZE]; <br>    BOOL fCreate; <br>    BOOL fRemember; <br>    BOOL fCancel; <br>    LPVOID lpCtl3d; <br>} LGNCRED, * PLGNCRED; <br> <br>typedef struct _DLGPSWD <br>{ <br>    TCHAR szPath[MAX_PATH]; <br>    TCHAR szPass[ACCTSIZE]; <br>    LPMAPISUP psup; <br>    PLMR plmr; <br>    BOOL fRemember; <br>    BOOL fCancel; <br>    LPVOID lpCtl3d; <br>} DLGPSWD, * PDLGPSWD; <br> <br>/* Internal function prototypes */ <br> <br>static HRESULT HrOpenSingleProvider(LPPROVIDERADMIN padp, <br>    LPPROFSECT FAR *lppProfSect); <br>static SCODE ScCreateOrConfigure(PSERVICEPBLK pspb); <br>static SCODE ScCreateStore(PSERVICEPBLK pspb, LPTSTR szPath, <br>    LPTSTR szPass, PMSL * ppmsl, PIMS * ppims); <br>static BOOL FAlreadyOpenStore(PMSP pmsp, LPTSTR szPath, PIMS * ppims); <br> <br>static HRESULT HrGetLogonDlgCred(HINSTANCE hInst, ULONG ulUIParam, LPTSTR szPath, <br>    LPTSTR szPass, BOOL *pfCreate, BOOL *pfRemember); <br>STDAPI_(BOOL) LogonDlgProc(HWND hDlg, UINT message, WPARAM wParam, <br>    LPARAM lParam); <br>static HRESULT HrGetPassword(HINSTANCE hInst, LPMAPISUP psup, PLMR plmr, <br>    ULONG ulUIParam, LPTSTR szPath, LPTSTR szPass, BOOL *pfRemember); <br>STDAPI_(BOOL) PasswordDlgProc(HWND hDlg, UINT message, WPARAM wParam, <br>    LPARAM lParam); <br>static HRESULT HrGetProfileCred(PLMR plmr, LPPROFSECT pps, LPTSTR szPass, <br>    BOOL *pfFound); <br>static HRESULT HrSetProfileCred(LPPROFSECT pps, LPTSTR szPass, LPTSTR szPath, <br>    BOOL fRemember, ULONG cbEntryID, LPBYTE lpEntryID, LPMAPIUID puidRK); <br>static HRESULT HrConfirmCred(LPTSTR szPath, LPTSTR szPass, LPMAPISUP psup, <br>    PLMR plmr); <br>static HRESULT HrFilePathExists(LPTSTR szStorePath, LPTSTR szFileName); <br>static HRESULT HrCheckStoreIntegrity(LPTSTR szPath); <br>static BOOL FIsValidPath(LPTSTR szPath, BOOL fCreate); <br>static void DecodeSpoolSecurity(ULONG cbSpoolSecurity, LPBYTE pbSpoolSecurity, <br>    LPTSTR szPath, LPTSTR szPass); <br>static HRESULT HrGetSpoolSecurity(LPTSTR szPath, LPTSTR szPass, <br>    PLMR plmr, ULONG * lpcbSpoolSecurity, LPBYTE * lppbSpoolSecurity); <br>static HRESULT HrCheckAndOpenStore(PMSP pmsp, LPMAPISUP psup, BOOL fModify, <br>    LPPROFSECT pps, LPTSTR szPath, LPTSTR szPass, BOOL fIsSpooler, <br>    PMSL *ppmsl, PIMS *ppims); <br>static SCODE ScCreateMSL(PMSP pmsp, PMSL * ppmsl); <br>static BOOL FFindPropInPSPB(PSERVICEPBLK pspb, ULONG ulPT, LPSPropValue *ppval); <br>static SCODE ScGetFullFileName(PSERVICEPBLK pspb, BOOL *pfCreate, <br>    LPSTR pszPath); <br> <br>/* <br> *  MSP_Logon <br> * <br> *  Purpose: <br> *      Logs in one user to the message store and returns a logon object <br> *      and a message store object.  Gets credentials through the <br> *      profile or a dialog.  Prompts if more information is needed. <br> * <br> *  Arguments: <br> *      pmsp                MSPROVIDER object returned at INIT time. <br> *      psup                Pointer to MAPI Support object. <br> *      ulUIParam           Handle to parent window cast to a ULONG. <br> *      szProfileName       String with the name of profile. <br> *                          (UNICODE if MAPI_UNICODE flag set in ulFlags) <br> *      cbEntryID           Size of lpEntryID. <br> *      lpEntryID           Provider component of store resource EntryID. <br> *      ulFlags             Flags for access methods: <br> *                          MDB_WRITE           Write access. <br> *                          MAPI_BEST_ACCESS    Write access if possible. <br> *                          MDB_NO_DIALOG       No logon dialog. <br> *                          MAPI_UNICODE        If szProfileName UNICODE <br> *      piid                Identifies what interface is desired on the <br> *                          about-to-be-opened object. <br> *      lpcbSpoolSecurity   Address of the variable in which the <br> *                          provider returns size of *lppbSpoolSecurity. <br> *      lppbSpoolSecurity   Address to return validation data <br> *                          necessary for SpoolerLogon to <br> *                          piggyback off this logon session. <br> *      lpulLowLevelError   Possible low level error to return if <br> *                          error or MAPI_W_EXTENDED_WARNING is returned. <br> *      pszMessage          Error / Warning string on logon.  If MAPI_UNICODE <br> *                          is set in ulFlags then it is UNICODE. <br> *      ppmslogon           Address to return a pointer to MSLOGON <br> *                          object for use by MAPI.DLL. <br> *      ppmdb               Address of a pointer to the message <br> *                          store object for use by the client. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      May put up logon screen to select/open store if <br> *      MDB_NO_DIALOG is not set.  For store creation, Logon <br> *      creates "hidden" files for MDB management. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate memory. <br> *      MAPI_E_CALL_FAILED          Failure creating a new store. <br> *      MAPI_E_CALL_FAILED          Windowing system failure trying <br> *                                  to display logon UI. <br> *      MAPI_E_CORRUPT_STORE        One of the necessary store <br> *                                  files is missing. <br> *      MAPI_E_LOGON_FAILED         Insufficient or bad credentials. <br> */ <br>STDMETHODIMP <br>MSP_Logon(PMSP pmsp, LPMAPISUP psup, ULONG ulUIParam, LPSTR szProfileName, <br>    ULONG cbEntryID, LPENTRYID lpEntryID, ULONG ulFlags, LPCIID piid, <br>    ULONG * lpcbSpoolSecurity, LPBYTE * lppbSpoolSecurity, <br>    LPMAPIERROR * lppMapiError, LPMSLOGON * ppmslogon, LPMDB * ppmdb) <br>{ <br>    HRESULT hr = hrSuccess; <br>    HRESULT hrT; <br>    BOOL fRemember = FALSE;     /* Remember password in profile? */ <br>    BOOL fFoundPassword;        /* TRUE if the password was in the profile */ <br>    PIMS pims = NULL;           /* Internal IMsgStore implementation */ <br>    PMSL pmsl = NULL;           /* logon object to give to MAPI */ <br>    TCHAR szPath[MAX_PATH];     /* Path to store root */ <br>    TCHAR szPass[ACCTSIZE];     /* Store account password */ <br>    PEID peid = (PEID) lpEntryID; <br>    LPPROFSECT pps = NULL;      /* our profile section */ <br> <br>    MSP_CheckParameters( <br>            pmsp,  <br>            IMSProvider, <br>            Logon, <br>            (pmsp,  <br>            psup,  <br>            ulUIParam,  <br>            szProfileName,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulFlags,  <br>            piid,  <br>            lpcbSpoolSecurity,  <br>            lppbSpoolSecurity,  <br>            lppMapiError, <br>            ppmslogon,  <br>            ppmdb)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br> <br>    MSP_EnterCriticalSection(pmsp); <br> <br>    AssertSz(!pmsp-&gt;fInvalid, "This MSProvider has already been shutdown"); <br> <br>    *lpcbSpoolSecurity = 0L; <br>    *lppbSpoolSecurity = NULL; <br>    *lppMapiError = NULL; <br>    *ppmslogon = NULL; <br>    *ppmdb = NULL; <br> <br>    if (piid &amp;&amp; !FQueryInterface(OT_MSGSTORE, piid)) <br>    { <br>        hr = ResultFromScode(E_NOINTERFACE); <br>        goto exit; <br>    } <br> <br>    hr = psup-&gt;lpVtbl-&gt;OpenProfileSection(psup, NULL, MAPI_MODIFY, &amp;pps); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Get the full path to the store out of the EntryID */ <br> <br>    if (peid == NULL) <br>    { <br>        hr = ResultFromScode(MAPI_E_UNCONFIGURED); <br>        goto exit; <br>    } <br>    else if (FIsInvalidEID(cbEntryID, peid, NULL)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INVALID_PARAMETER); <br>        goto exit; <br>    } <br> <br>    lstrcpy(szPath, peid-&gt;szPath); <br> <br>    DebugTrace("\nSMS: MSP_Logon %s\n\n", szPath); <br>     <br>    /* If we can piggyback on an existing open message store on this */ <br>    /* session then do so. If we piggyback, then don't return a logon */ <br>    /* object or addref the support object. */ <br> <br>    if (FAlreadyOpenStore(pmsp, szPath, &amp;pims)) <br>    { <br>        DebugTrace("\nSMS: Piggybacking client logon\n"); <br>        Assert(hr == hrSuccess); <br>        goto exit; <br>    } <br> <br>    /* Get store credentials from profile. */ <br> <br>    hr = HrGetProfileCred(&amp;pmsp-&gt;lmr, pps, szPass, &amp;fFoundPassword); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* If the password was in the profile, then the user wanted us to */ <br>    /* remember it (that's the only way it would be in the profile). */ <br> <br>    if (fFoundPassword) <br>        fRemember = TRUE; <br> <br>    while (TRUE) <br>    { <br>        SCODE sc; <br> <br>        hr = HrCheckAndOpenStore(pmsp, psup, <br>            !!(ulFlags &amp; (MDB_WRITE | MAPI_BEST_ACCESS)), pps, szPath, <br>            szPass, FALSE, &amp;pmsl, &amp;pims); <br>        if (hr == hrSuccess) <br>            break; <br> <br>        sc = GetScode(hr); <br> <br>        /* Preset hr to the value that will cause MAPI to bring up our */ <br>        /* config UI */ <br> <br>        hr = ResultFromScode(MAPI_E_UNCONFIGURED); <br> <br>        if (!(ulFlags &amp; MDB_NO_DIALOG)) <br>        { <br>            if (sc == MAPI_E_LOGON_FAILED) <br>            { <br>                hr = HrGetPassword(pmsp-&gt;hInst, psup, &amp;pmsp-&gt;lmr, ulUIParam, <br>                    szPath, szPass, &amp;fRemember); <br>            } <br>            else if (sc == MAPI_E_NOT_FOUND) <br>            { <br>                MessageBox(NULL, "The path to the message store is invalid.", <br>                    "Sample Message Store", <br>                    MB_OK | MB_TASKMODAL | MB_SETFOREGROUND); <br>            } <br>        } <br> <br>        if (hr != hrSuccess) <br>            goto exit; <br>    } <br> <br>    /* Complete regular logon tasks. */ <br> <br>    /* Update saved credentials if they have changed. */ <br> <br>    hrT = HrSetProfileCred(pps, szPass, szPath, fRemember,  <br>        pims-&gt;eidStore.cb, pims-&gt;eidStore.lpb, &amp;pims-&gt;uidResource); <br> <br>    if (hrT == hrSuccess) <br>        hrT = pps-&gt;lpVtbl-&gt;SaveChanges(pps, 0); <br> <br>    /* Make the profile section permanent. */ <br>    if (hrT == hrSuccess) <br>        hrT = psup-&gt;lpVtbl-&gt;ModifyProfile(psup, 0); <br> <br>    hr = psup-&gt;lpVtbl-&gt;SetProviderUID(psup, &amp;pims-&gt;uidResource, 0L); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrSetupPrivateNotifications(pims); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* This call sets [out] parameters, and should therefore be the last */ <br>    /* call that could fail. */ <br>    hr = HrGetSpoolSecurity(szPath, szPass, &amp;pims-&gt;lmr, <br>        lpcbSpoolSecurity, lppbSpoolSecurity); <br> <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Add this new store to the list of open stores. */ <br>    OBJ_Enqueue((POBJ) pims, (POBJ) pmsp); <br> <br>    UlAddRef(psup);         /* I'm keeping a reference */ <br> <br>    Assert(hr == hrSuccess);    /* no error */ <br> <br>exit: <br>    if (hr == hrSuccess) <br>    { <br>        /* Fill in [out] parameters. */ <br>        *ppmdb = (LPMDB) pims; <br>        *ppmslogon = (LPMSLOGON) pmsl; <br>    } <br>    else <br>    { <br>        UlRelease(pims); <br> <br>        /* Releasing the pmsl must come after releasing the pims. */ <br>        UlRelease(pmsl); <br> <br>        Assert(*lpcbSpoolSecurity == 0L); <br>        Assert(*lppbSpoolSecurity == NULL); <br>        Assert(*lppMapiError == NULL); <br>        Assert(*ppmslogon == NULL); <br>        Assert(*ppmdb == NULL); <br>    } <br> <br>    UlRelease(pps); <br> <br>    MSP_LeaveCriticalSection(pmsp); <br> <br>    DebugTraceResult(MSP_Logon, hr); <br>    return HrCheckHr(hr, IMSProvider_Logon); <br>} <br> <br>/* <br> *  MSP_SpoolerLogon <br> * <br> *  Purpose: <br> *      Logs in the Spooler to this message store. <br> * <br> *  Arguments: <br> *      psup            Pointer to MAPI Support object. <br> *      ulUIParam           HWND of parent window <br> *      szProfileName       Name of profile <br> *      cbEntryID           Size of lpEntryID. <br> *      lpEntryID           Provider component of store resource <br> *                          EntryID. <br> *      ulFlags             Flags.  See Logon above, except <br> *                          MDB_NO_DIALOG is normally (always?) <br> *                          set on this call. <br> *      piid                IID of desired interface for ppmdb <br> *      cbSpoolSecurity     Size of data in lpbSpoolSecurity. <br> *      lpbSpoolSecurity    Validation data necessary for <br> *                          SpoolerLogon to complete. <br> *      lpulLowLevelError   Possible low level error to return if <br> *                          error or MAPI_W_EXTENDED_WARNING is returned. <br> *      pszMessage          Error / Warning string on logon.  If MAPI_UNICODE <br> *                          is set in ulFlags then it is UNICODE. <br> *      ppmslogon           Address to return a pointer to MSLOGON <br> *                          object for use by MAPI.DLL. <br> *      ppmdb               Address of a pointer to the Spooler <br> *                          Message Store Object. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      May put up logon screen to select/open store if <br> *      MDB_NO_DIALOG is not set.  Calls HrNewIMS to create the <br> *      message store object, which allocates memory. <br> * <br> *  Errors: <br> *      MAPI_E_NO_MEMORY        Could not allocate memory. <br> *      MAPI_E_LOGON_FAILED     Bad credentials <br> */ <br>STDMETHODIMP <br>MSP_SpoolerLogon(PMSP pmsp, LPMAPISUP psup, ULONG ulUIParam, <br>    LPTSTR szProfileName, ULONG cbEntryID, LPENTRYID lpEntryID, <br>    ULONG ulFlags, LPCIID piid, ULONG cbSpoolSecurity, <br>    LPBYTE lpbSpoolSecurity, LPMAPIERROR * lppMapiError, <br>    LPMSLOGON * ppmslogon, LPMDB * ppmdb) <br>{ <br>    TCHAR szPass[ACCTSIZE];     /* Store account password */ <br>    TCHAR szPath[MAX_PATH];     /* path to store root */ <br>    HRESULT hr = hrSuccess; <br>    PIMS pims = NULL; <br>    PMSL pmsl = NULL; <br>    LPPROFSECT pps = NULL;      /* our profile section */ <br> <br>    MSP_CheckParameters( <br>            pmsp,  <br>            IMSProvider, <br>            SpoolerLogon, <br>            (pmsp,  <br>            psup,  <br>            ulUIParam,  <br>            szProfileName,  <br>            cbEntryID,  <br>            lpEntryID,  <br>            ulFlags,  <br>            piid,  <br>            cbSpoolSecurity,  <br>            lpbSpoolSecurity,  <br>            lppMapiError,  <br>            ppmslogon,  <br>            ppmdb)); <br> <br>    #ifdef VALIDATE <br>    if (ulFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br>    #endif <br>         <br>    MSP_EnterCriticalSection(pmsp); <br> <br>    AssertSz(!pmsp-&gt;fInvalid, "This MSProvider has already been shutdown"); <br> <br>    *lppMapiError = NULL; <br>    *ppmslogon = NULL; <br>    *ppmdb = NULL; <br> <br>    if (piid &amp;&amp; !FQueryInterface(OT_MSGSTORE, piid)) <br>    { <br>        hr = ResultFromScode(MAPI_E_INTERFACE_NOT_SUPPORTED); <br>        goto exit; <br>    } <br> <br>    hr = psup-&gt;lpVtbl-&gt;OpenProfileSection(psup, NULL, MAPI_MODIFY, &amp;pps); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    DecodeSpoolSecurity(cbSpoolSecurity, lpbSpoolSecurity, szPath, szPass); <br> <br>    DebugTrace("\nSMS: MSP_SpoolerLogon %s\n\n",szPath); <br> <br>    /* If we can piggyback on an existing open message store */ <br>    /* on this session then do so. If we piggyback, then don't return */ <br>    /* a logon object or addref the support object. */ <br> <br>    if (FAlreadyOpenStore(pmsp, szPath, &amp;pims)) <br>    { <br>        DebugTrace("\nSMS: Piggybacking spooler logon\n"); <br>        goto exit; <br>    } <br> <br> <br>    hr = HrCheckAndOpenStore(pmsp, psup, TRUE, pps, szPath, szPass, TRUE, <br>        &amp;pmsl, &amp;pims); <br>    if (hr == hrSuccess) <br>        hr = psup-&gt;lpVtbl-&gt;SetProviderUID(psup, &amp;pims-&gt;uidResource, 0L); <br>    if (hr == hrSuccess) <br>        hr = HrSetupPrivateNotifications(pims); <br> <br>    if (hr == hrSuccess) <br>    { <br>        /* Add this new store to the list of open stores. */ <br>        OBJ_Enqueue((POBJ) pims, (POBJ) pmsp); <br>        UlAddRef(psup); <br>    } <br> <br>exit: <br>    if (hr == hrSuccess) <br>    { <br>        *ppmdb = (LPMDB) pims; <br>        *ppmslogon = (LPMSLOGON) pmsl; <br>    } <br> <br>    UlRelease(pps); <br> <br>    MSP_LeaveCriticalSection(pmsp); <br> <br>    DebugTraceResult(MSP_SpoolerLogon, hr); <br>    return hr; <br>} <br> <br>/* <br> -  MSL_Release <br> - <br> */ <br> <br>STDMETHODIMP_(ULONG) MSL_Release(PMSL pmsl) <br>{ <br>    LONG cRef; <br> <br>    MSL_EnterCriticalSection(pmsl); <br> <br>    AssertSz1(pmsl-&gt;cRef &gt; 0, "MSL_Release(): Bogus cRef (%08lX)", pmsl-&gt;cRef); <br> <br>    cRef = --pmsl-&gt;cRef; <br> <br>    MSL_LeaveCriticalSection(pmsl); <br> <br>    if (cRef == 0) <br>    { <br>        Assert(pmsl-&gt;pims == NULL); <br>        DeleteCriticalSection(&amp;pmsl-&gt;cs); <br>        LMFree(&amp;pmsl-&gt;lmr, pmsl); <br>    } <br> <br>    return (cRef); <br>} <br> <br>/* <br> *  MSL_Logoff() <br> */ <br> <br>STDMETHODIMP MSL_Logoff(PMSL pmsl, ULONG * pulFlags) <br>{ <br>    MSL_CheckParameters( <br>            pmsl,  <br>            IMSLogon, <br>            Logoff, <br>            (pmsl, <br>            pulFlags)); <br> <br>    MSL_EnterCriticalSection(pmsl); <br> <br>    AssertSz(!pmsl-&gt;fInvalid, "Logon object already logged off"); <br> <br>    if (pmsl-&gt;pims) <br>        OBJ_Destroy((POBJ) pmsl-&gt;pims); <br>    else <br>        MSL_LeaveCriticalSection(pmsl); <br> <br>#ifdef DEBUG <br>    pmsl-&gt;fInvalid = TRUE; <br>#endif <br> <br>    return (hrSuccess); <br>} <br> <br>/* <br> *  MSL_OpenStatusEntry() <br> * <br> *  MAPI has determined that the client call to OpenStatusEntry <br> *  is for OUR row in the status table.  Open the Status Object <br> *  appropriate for our store. <br> * <br> *  This object is logically part of the store, and can be made <br> *  invalid when the store (either the MSLogon or LPMDB object, <br> *  at our choice) goes away. <br> */ <br> <br>STDMETHODIMP MSL_OpenStatusEntry(PMSL pmsl, LPCIID lpiid, ULONG ulFlags, <br>    ULONG * lpulObjType, LPVOID * lppEntry) <br>{ <br>    MSL_CheckParameters( <br>    pmsl,  <br>    IMSLogon, <br>    OpenStatusEntry, <br>    (pmsl,  <br>    lpiid,  <br>    ulFlags,  <br>    lpulObjType,  <br>    lppEntry)); <br> <br>    AssertSz(!pmsl-&gt;fInvalid, "Logon object already logged off"); <br> <br>    DebugTraceSc(MSL_OpenStatusEntry, MAPI_E_NO_SUPPORT); <br>    return ResultFromScode(MAPI_E_NO_SUPPORT); <br>} <br> <br>STDAPI SMSServiceEntry(HINSTANCE hInst, LPMALLOC lpMalloc, LPMAPISUP psup, <br>        ULONG ulUIParam, ULONG ulSEFlags, ULONG ulContext, ULONG cvals, <br>        LPSPropValue pvals, LPPROVIDERADMIN lpAdminProviders, <br>        LPMAPIERROR FAR *lppMapiError) <br>{ <br>    HRESULT             hr; <br>    LPALLOCATEBUFFER    lpAllocBuff; <br>    LPALLOCATEMORE      lpAllocMore; <br>    LPFREEBUFFER        lpFreeBuff      = NULL; <br>    PMSP                pmsp            = NULL; <br>    LPPROFSECT          pps             = NULL; <br>    SERVICEPBLK         spb; <br>    ULONG               ulProvVer; <br>    ULONG               cvalsProf; <br>    LPSPropValue        pvalsProf       = NULL; <br> <br>    /* check the array of profile section objects */ <br>    if (IsBadReadPtr(psup, sizeof(LPMAPISUP)) <br>        ||  (cvals &amp;&amp; IsBadReadPtr(pvals, (UINT)(sizeof(SPropValue) * cvals)))) <br>        return ResultFromScode(MAPI_E_INVALID_PARAMETER); <br> <br>    if (ulSEFlags &amp; ~(MAPI_UNICODE <br>                    | MSG_SERVICE_UI_READ_ONLY <br>                    | SERVICE_UI_ALWAYS     /* Same value as UI_SERVICE */ <br>                    | SERVICE_UI_ALLOWED    /* New */ <br>                    | UI_CURRENT_PROVIDER_FIRST <br>                    | SERVICE_LOGON_FAILED)) <br>        return ResultFromScode(MAPI_E_UNKNOWN_FLAGS); <br> <br>    if (ulSEFlags &amp; MAPI_UNICODE) <br>        return ResultFromScode(MAPI_E_BAD_CHARWIDTH); <br> <br>    if (    (ulContext == MSG_SERVICE_INSTALL) <br>        ||  (ulContext == MSG_SERVICE_UNINSTALL) <br>        ||  (ulContext == MSG_SERVICE_DELETE)) <br>        return (hrSuccess); <br> <br>    if (ulContext != MSG_SERVICE_CONFIGURE &amp;&amp; ulContext != MSG_SERVICE_CREATE) <br>        return (ResultFromScode(MAPI_E_NO_SUPPORT)); <br> <br>    /* get the profile section for the provider */ <br>    hr = HrOpenSingleProvider(lpAdminProviders, &amp;pps); <br>    if (hr != hrSuccess) <br>        goto err; <br> <br>    /*  Get the memory allocation routines we'll be needing. */ <br>    hr = psup-&gt;lpVtbl-&gt;GetMemAllocRoutines(psup, &amp;lpAllocBuff, &amp;lpAllocMore, <br>            &amp;lpFreeBuff); <br>    if (hr != hrSuccess) <br>        goto err; <br> <br>    hr = MSProviderInit(hInst, lpMalloc, lpAllocBuff, lpAllocMore, <br>            lpFreeBuff, 0, CURRENT_SPI_VERSION, &amp;ulProvVer, <br>            &amp;(LPMSPROVIDER)pmsp); <br>    if (hr != hrSuccess) <br>        goto err; <br> <br>    /* get the properties out of the profile section that we will be */ <br>    /* be needing */ <br> <br>    hr = pps-&gt;lpVtbl-&gt;GetProps(pps, (LPSPropTagArray) &amp;ptaConfig, 0, <br>            &amp;cvalsProf, &amp;pvalsProf); <br>    if (HR_FAILED(hr)) <br>        goto err; <br> <br>    Assert (PROP_ID(pvalsProf[0].ulPropTag) == PROP_ID(PR_SMS_PATH)); <br>    Assert (PROP_ID(pvalsProf[1].ulPropTag) == PROP_ID(PR_SMS_PASSWORD)); <br>    Assert (PROP_ID(pvalsProf[2].ulPropTag) == PROP_ID(PR_SMS_REMEMBER_PW)); <br>    Assert (PROP_ID(pvalsProf[3].ulPropTag) == PROP_ID(PR_SMS_CREATE)); <br> <br>    /* initialize the service parameter block */ <br>    spb.pmsp            = pmsp; <br>    spb.pps             = pps; <br>    spb.psup            = psup; <br>    spb.ulUIParam       = ulUIParam; <br>    spb.ulSEFlags       = ulSEFlags; <br>    spb.ulContext       = ulContext; <br>    spb.cvalsProf       = cvalsProf; <br>    spb.pvalsProf       = pvalsProf; <br>    spb.cvalsClient     = cvals; <br>    spb.pvalsClient     = pvals; <br> <br>    hr = ResultFromScode(ScCreateOrConfigure(&amp;spb)); <br> <br>err: <br>    if (lpFreeBuff) <br>        (*lpFreeBuff)(pvalsProf); <br> <br>    UlRelease(pmsp); <br>    UlRelease(pps); <br> <br>    DebugTraceResult(SMSServiceEntry, hr); <br>    return hr; <br>} <br> <br>/* <br> *  Module internal functions <br> */ <br> <br>static HRESULT <br>HrOpenSingleProvider(LPPROVIDERADMIN padp, LPPROFSECT FAR *lppProfSect) <br>{ <br>    HRESULT     hr; <br>    LPMAPITABLE pmt = NULL; <br>    LPSRowSet   prws = NULL; <br>    LPSPropValue pval; <br>    SPropTagArray ptaProvUID = {1, {PR_PROVIDER_UID}}; <br> <br>    hr = padp-&gt;lpVtbl-&gt;GetProviderTable(padp, 0, &amp;pmt); <br>    if (hr) <br>        goto err; <br> <br>    hr = pmt-&gt;lpVtbl-&gt;SetColumns(pmt, &amp;ptaProvUID, 0L); <br>    if (hr) <br>        goto err; <br> <br>    hr = pmt-&gt;lpVtbl-&gt;QueryRows(pmt, 1, 0, &amp;prws); <br>    if (hr || prws == NULL || prws-&gt;cRows == 0) <br>    { <br>        hr = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto err; <br>    } <br> <br>    Assert(prws-&gt;aRow[0].cValues == 1); <br>    pval = prws-&gt;aRow[0].lpProps; <br>    if (!pval || pval-&gt;ulPropTag != PR_PROVIDER_UID) <br>    { <br>        /* The property we need is missing. Error. */ <br>        hr = ResultFromScode(MAPI_E_NOT_FOUND); <br>        goto err; <br>    } <br> <br>    /* Found the right property; use it to open our section */ <br>    hr = padp-&gt;lpVtbl-&gt;OpenProfileSection(padp, <br>        (LPMAPIUID) pval-&gt;Value.bin.lpb, NULL, MAPI_MODIFY, lppProfSect); <br> <br>err: <br>    FreeProws(prws); <br>    UlRelease(pmt); <br> <br>    DebugTraceResult(HrOpenSingleProvider, hr); <br>    return hr; <br>} <br> <br>static SCODE ScCreateOrConfigure(PSERVICEPBLK pspb) <br>{ <br>    SCODE           sc              = S_OK; <br>    LPSPropValue    pval; <br>    LPSTR           pszFileTitle; <br>    CHAR            szPath[MAX_PATH]; <br>    CHAR            szPass[ACCTSIZE]; <br>    LPPROFSECT      pps             = pspb-&gt;pps; <br>    BOOL            fNeedUI         = FALSE; <br>    BOOL            fAllowUI        = FALSE; <br>    BOOL            fCreate         = FALSE; <br>    BOOL            fRemember       = FALSE; <br> <br>    /* Check for UI */ <br> <br>    if (pspb-&gt;ulSEFlags &amp; SERVICE_UI_ALWAYS) <br>        fAllowUI = fNeedUI = TRUE; <br>    else     <br>        if (pspb-&gt;ulSEFlags &amp; SERVICE_UI_ALLOWED) <br>            fAllowUI = TRUE; <br>         <br>    if (FFindPropInPSPB(pspb, PR_SMS_PASSWORD, &amp;pval)) <br>    { <br>        ULONG cbPass; <br> <br>        /* Passwords must fit in ACCTSIZE bytes. Truncate the password if */ <br>        /* it's too long. */ <br> <br>        cbPass = lstrlenA(pval-&gt;Value.lpszA) + 1; <br>        if (cbPass &gt; ACCTSIZE) <br>            cbPass = ACCTSIZE; <br> <br>        memcpy(szPass, pval-&gt;Value.lpszA, (UINT) cbPass); <br>        szPass[cbPass - 1] = '\0'; <br> <br>        /* We found the password. Since we found it, assume that the */ <br>        /* user wants us to remember it. Only if PR_SMS_REMEMBER_PW is */ <br>        /* present and FALSE will we remove the password. */ <br> <br>        fRemember = TRUE; <br>    } <br>    else <br>        szPass[0] = '\0'; <br> <br>    if (FFindPropInPSPB(pspb, PR_SMS_CREATE, &amp;pval)) <br>        fCreate = pval-&gt;Value.b; <br> <br>    if (FFindPropInPSPB(pspb, PR_SMS_REMEMBER_PW, &amp;pval)) <br>        fRemember = pval-&gt;Value.b; <br> <br>    /* try to find the path in either the properties passed in, or */ <br>    /* the properties in the profile */ <br> <br>    if (    FFindPropInPSPB(pspb, PR_SMS_PATH, &amp;pval) <br>        &amp;&amp;  GetFullPathName(pval-&gt;Value.lpszA, MAX_PATH, szPath, <br>                &amp;pszFileTitle)) <br>    { <br>        DWORD   dwFA; <br> <br>        Assert (*(pszFileTitle - 1) == '\\'); <br> <br>        dwFA = GetFileAttributes(szPath); <br> <br>        /* If the file isn't there, and we aren't creating, then error. */ <br>        /* If the file is there, and we are creating, then error. */ <br> <br>        if (dwFA == 0xFFFFFFFF &amp;&amp; fCreate == FALSE) <br>        { <br>            sc = MAPI_E_NOT_FOUND; <br>            fNeedUI = TRUE; <br>        } <br>        else if (dwFA != 0xFFFFFFFF &amp;&amp; fCreate == TRUE) <br>        { <br>            sc = MAPI_E_NO_ACCESS; <br>            fNeedUI = TRUE; <br>        } <br>    } <br>    else <br>    { <br>        szPath[0] = '\0'; <br>        sc = MAPI_E_NOT_FOUND; <br>        fNeedUI = TRUE; <br>    } <br> <br>    while (TRUE) <br>    { <br>        if (sc == S_OK) <br>        { <br>            PMSL pmsl; <br>            PIMS pims; <br> <br>            /* Verify that everything works before we exit. */ <br>     <br>            if (fCreate) <br>                sc = ScCreateStore(pspb, szPath, szPass, &amp;pmsl, &amp;pims); <br>            else <br>                sc = GetScode(HrCheckAndOpenStore(pspb-&gt;pmsp, pspb-&gt;psup, <br>                    TRUE, pspb-&gt;pps, szPath, szPass, FALSE, &amp;pmsl, &amp;pims)); <br>            if (sc) <br>                fNeedUI = TRUE; <br>            else <br>            { <br>                HRESULT hrT; <br>     <br>                /* delete the unnecessary properties from the profile */ <br>                pps-&gt;lpVtbl-&gt;DeleteProps(pps, (LPSPropTagArray)&amp;ptaDel, <br>                    NULL); <br> <br>                /* Update saved credentials if they have changed. */ <br>             <br>                hrT = HrSetProfileCred(pps, szPass, szPath, fRemember,  <br>                    pims-&gt;eidStore.cb, pims-&gt;eidStore.lpb, <br>                    &amp;pims-&gt;uidResource); <br>             <br>                if (hrT == hrSuccess) <br>                    hrT = pps-&gt;lpVtbl-&gt;SaveChanges(pps, 0); <br>             <br>                /* Can't make the profile section permanent because */ <br>                /* the support object we are given for config doesn't */ <br>                /* support ModifyProfile. Make it permanent during Logon. */ <br>             <br>                /* Addref the support object because we kept a reference */ <br>                /* in pims, and releasing pims will release psup. We want */ <br>                /* the refcount on psup to be the same at config exit as */ <br>                /* it was when we were called. */ <br> <br>                UlAddRef(pspb-&gt;psup); </code></pre>
<p>
</p>
<pre><code><br>                UlRelease(pims); <br>                UlRelease(pmsl); <br>     <br>                if (!fNeedUI) <br>                    goto ret;   /* SUCCESS! */ <br>            } <br>        } <br>         <br>        if (fNeedUI &amp;&amp; !fAllowUI) <br>        { <br>            sc = MAPI_E_UNCONFIGURED; <br>            goto ret; <br>        } <br> <br>        /* Do the UI */ <br>     <br>        sc = GetScode(HrGetLogonDlgCred(pspb-&gt;pmsp-&gt;hInst, pspb-&gt;ulUIParam, <br>            szPath, szPass, &amp;fCreate, &amp;fRemember)); <br>         <br>        if (sc != S_OK) <br>            goto ret; <br> <br>        fNeedUI = FALSE; <br>    } <br> <br>ret: <br>    DebugTraceSc(ScCreateOrConfigure, sc); <br>    return sc; <br>} <br> <br>/* <br> -  ScCreateStore <br> - <br> *  Create a Sample Store out on disk. <br> * <br> *  Returns the pims which points to the store, and the <br> *  pmsl which points to the MSLogon object. <br> */ <br>static SCODE ScCreateStore(PSERVICEPBLK pspb, LPTSTR szPath, <br>    LPTSTR szPass, PMSL * ppmsl, PIMS * ppims) <br>{ <br>    HRESULT hr = hrSuccess; <br>    SCODE sc = S_OK; <br>    PRFS prfs = NULL;           /* Struct for receive folder settings */ <br>    BOOL fCreateDir = FALSE;    /* Was new directory created? */ <br>    BOOL fCreateProp = FALSE;   /* Was new MsgStore props file created? */ <br>    BOOL fCreateFld = FALSE;    /* Was new root folder created? */ <br>    BOOL fCreateRFS = FALSE;    /* Was receive folder file created? */ <br>    PIMS pims = NULL; <br>    PMSL pmsl = NULL; <br> <br>    /* Create the directory */ <br> <br>    if (!CreateDirectory(szPath, NULL)) <br>    { <br>        sc = MAPI_E_CALL_FAILED; <br>        goto exit; <br>    } <br> <br>    fCreateDir = TRUE; <br> <br>    /* Create file to hold receive folder settings */ <br> <br>    hr = OpenRFS(szPath, szFolderFileName, RFS_CREATE, &amp;prfs); <br>    if (hr != hrSuccess) <br>    { <br>        sc = GetScode(hr); <br>        goto exit; <br>    } <br> <br>    fCreateRFS = TRUE; <br> <br>    /* Create the MSLogon object. */ <br> <br>    sc = ScCreateMSL(pspb-&gt;pmsp, &amp;pmsl); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    /* Create instance, creates Message Store props file as well */ <br> <br>    hr = HrNewIMS(szPath, szPropFileName, pspb-&gt;pmsp, pmsl, prfs, <br>            pspb-&gt;pps, pspb-&gt;psup, TRUE, &amp;pims); <br>    if (hr != hrSuccess) <br>    { <br>        sc = GetScode(hr); <br>        goto exit; <br>    } <br> <br>    OBJ_SetFlag(pims, OBJF_MODIFY); <br>    pmsl-&gt;pims = pims; <br> <br>    fCreateProp = TRUE; <br> <br>    hr = HrInitIMSProps(pims, szPass); <br>    if (hr != hrSuccess) <br>    { <br>        sc = GetScode(hr); <br>        goto exit; <br>    } <br> <br>    /* Create file to hold root folder properties */ <br> <br>    { <br>        PEID peidTmp = NULL; <br> <br>        hr = HrCreateFolderStorage(NULL, FOLDER_ROOT, "", "", <br>            FALSE, pims, &amp;peidTmp); <br> <br>        if (hr != hrSuccess) <br>        { <br>            sc = GetScode(hr); <br>            goto exit; <br>        } <br> <br>        /* We can throw away the returned EntryID because we know */ <br>        /* how to construct the EntryID for the root folder when  */ <br>        /* we need to open it (see pims-&gt;OpenEntry()).           */ <br> <br>        LMFree(&amp;pspb-&gt;pmsp-&gt;lmr, peidTmp); <br>    } <br> <br>    fCreateFld = TRUE; <br> <br>    *ppmsl = pmsl; <br>    *ppims = pims; <br> <br>exit: <br>    if (sc != S_OK) <br>    { <br>        TCHAR rgch[MAX_PATH]; <br> <br>        if (pims) <br>        { <br>            FreeNull(pims-&gt;szStorePath); <br>            LMFree(&amp;pspb-&gt;pmsp-&gt;lmr, pims-&gt;eidStore.lpb); <br>            LMFree(&amp;pspb-&gt;pmsp-&gt;lmr, pims); <br>        } <br>        else if (prfs) <br>        { <br>            /* If we have an RFS but NO IMS, close RFS manually. */ <br>            NFSideAssertSz(CloseRFS(prfs) == hrSuccess, "RFS not closed"); <br>        } <br> <br>        if ( pmsl ) <br>        { <br>            pmsl-&gt;pims = NULL; <br> <br>            /* Releasing the pmsl must come after releasing the IMS. */ <br>            UlRelease(pmsl); <br>        } <br>         <br>        /* We need to use state flags to know how much work to undo  */ <br>        /* on a create because otherwise we may accidentally erase   */ <br>        /* files that we did not create (because they were created   */ <br>        /* by another Sample Store creation in a different session). */ <br> <br>        if (fCreateProp == TRUE) <br>        { <br>            if (FAppendPathNoMem(szPath, szPropFileName, MAX_PATH, rgch)) <br>                (void)DeleteFile(rgch); <br>            else <br>                TrapSz("Can't clean up create #1!"); <br>        } <br> <br>        if (fCreateRFS == TRUE) <br>        { <br>            if (FAppendPathNoMem(szPath, szFolderFileName, MAX_PATH, rgch)) <br>                (void)DeleteFile(rgch); <br>            else <br>                TrapSz("Can't clean up create #2!"); <br>        } <br> <br>        if (fCreateFld == TRUE) <br>        { <br>            if (FAppendPathNoMem(szPath, szPropertyFileName, MAX_PATH, rgch)) <br>                (void)DeleteFile(rgch); <br>            else <br>                TrapSz("Can't clean up create #3!"); <br>        } <br> <br>        if (fCreateDir == TRUE) <br>            (void)RemoveDirectory(szPath); <br>    } <br> <br>    DebugTraceSc(ScCreateStore, sc); <br>    return sc; <br>} <br> <br>/* <br> *  FAlreadyOpenStore <br> * <br> *  Purpose: <br> *      Searches the list of stores open in this MAPI session and <br> *      returns the MS object of a store that matches the path <br> *      that's passed in. <br> * <br> *  Arguments: <br> *      pmsp    Pointer to the Message Store Provider (MAPI Session <br> *              context).  This is where the list of open stores <br> *              lives. <br> *      szPath  String containing full path to the store to open. <br> *      ppims   Location in which to return the address of a <br> *              message store object already open (only valid if <br> *              the function returns TRUE). <br> * <br> *  Returns: <br> *      BOOL.  Will be TRUE if the message store is already open, <br> *      FALSE if not. <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>static BOOL FAlreadyOpenStore(PMSP pmsp, LPTSTR szPath, PIMS * ppims) <br>{ <br>    PIMS pimsPrev = NULL; <br> <br>    for (pimsPrev = (PIMS) pmsp-&gt;pobjHead; pimsPrev; <br>        pimsPrev = (PIMS) pimsPrev-&gt;pobjNext) <br>    { <br>        if (!lstrcmpi(pimsPrev-&gt;szStorePath, szPath)) <br>        { <br>            OBJ_EnterCriticalSection(pimsPrev); <br> <br>            if(!OBJ_TestFlag(pimsPrev, MSF_BEINGDESTROYED)) <br>            { <br>                *ppims = pimsPrev; <br>                UlAddRef(pimsPrev); <br> <br>                OBJ_LeaveCriticalSection(pimsPrev); <br>                return TRUE; <br>            } <br>             <br>            DebugTrace("SMS: Attempt to OpenMsgStore at %s while a another IMsgStore\n" <br>                        "object opened on this directory is being released\n", szPath); <br> <br>            OBJ_LeaveCriticalSection(pimsPrev); <br>        } <br>    } <br> <br>    return FALSE; <br>} <br> <br>/* <br> *  HrGetPassword <br> * <br> *  Purpose: <br> *      Get the password for a store interactively by putting up a dialog. <br> * <br> *  Parameters: <br> *      hInst       [in] Instance handle of my DLL <br> *      psup        [in] Pointer to the mapi support object. <br> *      plmr        [in] Pointer to the memory allocation routines. <br> *      ulUIParam   [in] Window handle cast to ULONG. <br> *      szPath      [in] The pathname to the top of the message store. <br> *      szPass      [out] Pointer to a buffer in which to place the password. <br> *      pfRemember  [out] Address of boolean: should the password be saved <br> *                        in profile? <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Puts up password dialog. <br> * <br> *  Errors: <br> *      None. <br> */ <br>static HRESULT HrGetPassword(HINSTANCE hInst, LPMAPISUP psup, PLMR plmr, <br>    ULONG ulUIParam, LPTSTR szPath, LPTSTR szPass, BOOL *pfRemember) <br>{ <br>    HRESULT hr = hrSuccess; <br>    DLGPSWD dlgpswd; <br> <br>    NFAssertSz(szPass, "Bad szPass"); <br> <br>    lstrcpy(dlgpswd.szPath, szPath); <br>    dlgpswd.psup = psup; <br>    dlgpswd.plmr = plmr; <br>    dlgpswd.fRemember = FALSE; <br>    dlgpswd.fCancel = FALSE; <br>    dlgpswd.lpCtl3d = CTL3D_Initialize(hInst); <br> <br>    if (DialogBoxParam(hInst, TEXT("PSWDDIALOGBOX"), (HWND) ulUIParam, <br>            (DLGPROC) PasswordDlgProc, (LPARAM) &amp;dlgpswd) == -1) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    if (dlgpswd.fCancel) <br>    { <br>        hr = ResultFromScode(MAPI_E_USER_CANCEL); <br>        goto exit; <br>    } <br> <br>    if (szPass) <br>        lstrcpy(szPass, dlgpswd.szPass); <br> <br>    if (pfRemember) <br>        *pfRemember = dlgpswd.fRemember; <br> <br>    Assert(hr == hrSuccess); <br> <br>exit: <br>    CTL3D_Uninitialize(dlgpswd.lpCtl3d); <br>    DebugTraceResult(HrGetPassword, hr); <br>    return hr; <br>} <br> <br>/* <br> *  PasswordDlgProc <br> * <br> *  Purpose: <br> *      Dialog procedure to handle password dialog events. <br> * <br> *  Parameters: <br> *      hDlg        Handle to the dialog. <br> *      message     Message to be handled. <br> *      wParam      Button ID if button is pressed. <br> *      lParam      Context parameter from dialog creation (see <br> *                  HrGetLogonDlgCred). <br> * <br> *  Returns: <br> *      BOOL.  TRUE if handled, FALSE if not <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDAPI_(BOOL) PasswordDlgProc(HWND hDlg, UINT message, WPARAM wParam, <br>    LPARAM lParam) <br>{ <br>    PDLGPSWD pdlgpswd; <br>    BOOL fHandled = FALSE; <br> <br>    AssertSz(hDlg, "Bad hDlg"); <br> <br>    switch (message) <br>    { <br>    case WM_INITDIALOG: <br>        { <br>            SetWindowLong(hDlg, DWL_USER, lParam); <br>            pdlgpswd = (PDLGPSWD) lParam; <br> <br>            CTL3D_Subclass(pdlgpswd-&gt;lpCtl3d, hDlg, CTL3D_ALL); <br> <br>#ifdef _WIN32 <br>            SetForegroundWindow(hDlg); <br>#endif <br>            BringWindowToTop(hDlg); <br> <br>            SetDlgItemText(hDlg, TEXT_PATH, pdlgpswd-&gt;szPath); <br> <br>            pdlgpswd-&gt;fRemember = FALSE; <br> <br>            fHandled = TRUE; <br>            break; <br>        } <br> <br>    case WM_COMMAND: <br>        { <br>            pdlgpswd = (PDLGPSWD) GetWindowLong(hDlg, DWL_USER); <br> <br>            switch (LOWORD(wParam)) <br>            { <br>            case IDOK: <br>                { <br>                    GetDlgItemText(hDlg, IDE_ACCOUNT_PASSWORD, <br>                        pdlgpswd-&gt;szPass, ACCTSIZE * sizeof(TCHAR)); <br> <br>                    if (HrConfirmCred(pdlgpswd-&gt;szPath, pdlgpswd-&gt;szPass, <br>                        pdlgpswd-&gt;psup, pdlgpswd-&gt;plmr) != hrSuccess) <br>                    { <br>                        /* put up a message box */ <br>                        MessageBox(hDlg, "Password is incorrect.", <br>                            "Sample Store Password", <br>                            MB_OK | MB_APPLMODAL | MB_SETFOREGROUND); <br> <br>                        /* highlight the password field */ <br>                        SetFocus(hDlg); <br>                        break; <br>                    } <br> <br>                    pdlgpswd-&gt;fRemember =  <br>                        IsDlgButtonChecked(hDlg, IDC_REMEMBER); <br> <br>                    EndDialog(hDlg, 0); <br>                    fHandled = TRUE; <br>                    break; <br>                } <br>            case IDCANCEL: <br>                { <br>                    pdlgpswd-&gt;fCancel = TRUE; <br>                    EndDialog(hDlg, 0); <br>                    fHandled = TRUE; <br>                    break; <br>                } <br>            default: <br>                { <br>                    fHandled = FALSE; <br>                    break; <br>                } <br>            } <br>        } <br> <br>    default: <br>        { <br>            fHandled = FALSE; <br>            break; <br>        } <br>    } <br> <br>    return fHandled; <br>} <br> <br>/* <br> *  HrGetLogonDlgCred <br> * <br> *  Purpose: <br> *      Obtain credentials interactively for opening a store by <br> *      putting up a dialog. <br> * <br> *  Parameters: <br> *      hInst       Instance of my DLL <br> *      ulUIParam   Window handle cast to ULONG. <br> *      szPath      Address of buffer in which to place the path to <br> *                  the root directory. <br> *      szPass      Address of buffer in which to place the logon <br> *                  Account Password. <br> *      pfCreate    Address of boolean: should store be created? <br> *      pfRemember  Address of boolean: should password be saved in profile? <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      Puts up dialog. <br> * <br> *  Errors: <br> *      None. <br> */ <br>static HRESULT HrGetLogonDlgCred(HINSTANCE hInst, ULONG ulUIParam, <br>    LPTSTR szPath, LPTSTR szPass, BOOL *pfCreate, BOOL *pfRemember) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LGNCRED lgncred; <br> <br>    NFAssertSz(szPass, "Bad szPass"); <br> <br>    lstrcpy(lgncred.szPath, szPath); <br>    lstrcpy(lgncred.szPass, szPass); <br>    lgncred.fCreate = FALSE; <br>    lgncred.fRemember = *pfRemember; <br>    lgncred.fCancel = FALSE; <br>    lgncred.ulFieldMask = (szPath ? LGNCRED_PATH : 0L) <br>                        | (szPass ? LGNCRED_PASS : 0L) <br>                        | (pfCreate ? LGNCRED_CREATE : 0L) <br>                        | LGNCRED_REMEMBER; <br> <br>    lgncred.lpCtl3d = CTL3D_Initialize(hInst); <br> <br>    if (DialogBoxParam(hInst, TEXT("LOGONDIALOGBOX"), (HWND) ulUIParam, <br>            (DLGPROC) LogonDlgProc, (LPARAM) &amp;lgncred) == -1) <br>    { <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>        goto exit; <br>    } <br> <br>    if (lgncred.fCancel) <br>    { <br>        hr = ResultFromScode(MAPI_E_USER_CANCEL); <br>        goto exit; <br>    } <br> <br>    if (szPath) <br>    { <br>        DWORD dwPathLength = 0L; <br>        LPTSTR szPathName = NULL; <br> <br>        dwPathLength = GetFullPathName(lgncred.szPath, MAX_PATH, <br>            szPath, &amp;szPathName); <br>        if (!dwPathLength || dwPathLength &gt; MAX_PATH) <br>        { <br>            hr = ResultFromScode(MAPI_E_UNCONFIGURED); <br>            goto exit; <br>        } <br>    } <br> <br>    if (szPass) <br>        lstrcpy(szPass, lgncred.szPass); <br> <br>    if (pfCreate) <br>        *pfCreate = lgncred.fCreate; <br> <br>    *pfRemember = lgncred.fRemember; <br> <br>    Assert(hr == hrSuccess); <br> <br>exit: <br>    CTL3D_Uninitialize(lgncred.lpCtl3d); <br> <br>    DebugTraceResult(HrGetLogonDlgCred, hr); <br>    return hr; <br>} <br> <br>/* <br> *  LogonDlgProc <br> * <br> *  Purpose: <br> *      Dialog procedure to handle logon events. <br> * <br> *  Parameters: <br> *      hDlg        Handle to the dialog. <br> *      message     Message to be handled. <br> *      wParam      Button ID if button is pressed. <br> *      lParam      Context parameter from dialog creation (see <br> *                  HrGetLogonDlgCred). <br> * <br> *  Returns: <br> *      BOOL.  TRUE if handled, FALSE if not <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>STDAPI_(BOOL) LogonDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam) <br>{ <br>    PLGNCRED plgncred; <br>    BOOL fHandled = FALSE; <br> <br>    AssertSz(hDlg, "Bad hDlg"); <br> <br>    switch (message) <br>    { <br>    case WM_INITDIALOG: <br>        { <br>            SetWindowLong(hDlg, DWL_USER, lParam); <br>            plgncred = (PLGNCRED) lParam; <br> <br>            CTL3D_Subclass(plgncred-&gt;lpCtl3d, hDlg, CTL3D_ALL); <br> <br>#ifdef _WIN32 <br>            SetForegroundWindow(hDlg); <br>#endif <br>            BringWindowToTop(hDlg); <br> <br>            if (plgncred-&gt;ulFieldMask &amp; LGNCRED_PATH) <br>                SetDlgItemText(hDlg, IDE_ROOT_PATH, plgncred-&gt;szPath); <br>            else <br>                EnableWindow(GetDlgItem(hDlg, IDE_ROOT_PATH), FALSE); <br> <br>            if (plgncred-&gt;ulFieldMask &amp; LGNCRED_PASS) <br>                SetDlgItemText(hDlg, IDE_ACCOUNT_PASSWORD, plgncred-&gt;szPass); <br>            else <br>                EnableWindow(GetDlgItem(hDlg, IDE_ACCOUNT_PASSWORD), FALSE); <br> <br>            if (!(plgncred-&gt;ulFieldMask &amp; LGNCRED_CREATE)) <br>                EnableWindow(GetDlgItem(hDlg, IDC_CREATE), FALSE); <br> <br>            if (plgncred-&gt;ulFieldMask &amp; LGNCRED_REMEMBER) <br>                CheckDlgButton(hDlg, IDC_REMEMBER, plgncred-&gt;fRemember); <br>            else <br>                EnableWindow(GetDlgItem(hDlg, IDC_REMEMBER), FALSE); <br> <br>            fHandled = TRUE; <br>            break; <br>        } <br> <br>    case WM_COMMAND: <br>        { <br>            plgncred = (PLGNCRED) GetWindowLong(hDlg, DWL_USER); <br> <br>            switch (LOWORD(wParam)) <br>            { <br>            case IDOK: <br>                { <br>                    if (plgncred-&gt;ulFieldMask &amp; LGNCRED_CREATE) <br>                    { <br>                        plgncred-&gt;fCreate = <br>                            IsDlgButtonChecked(hDlg, IDC_CREATE); <br>                    } <br> <br>                    if (plgncred-&gt;ulFieldMask &amp; LGNCRED_PATH) <br>                    { <br>                        GetDlgItemText(hDlg, IDE_ROOT_PATH, <br>                            plgncred-&gt;szPath, MAX_PATH * sizeof(TCHAR)); <br>                    } <br> <br>                    /* check if this is a valid path */ <br>                    if (!FIsValidPath(plgncred-&gt;szPath, plgncred-&gt;fCreate)) <br>                    { <br>                        /* put up a message box */ <br>                        MessageBox(hDlg, (plgncred-&gt;fCreate) ? <br>                            "Root directory can not be created." : <br>                            "Path to root directory not found.", <br>                            "Message Store Logon", MB_OK | MB_APPLMODAL | MB_SETFOREGROUND); <br> <br>                        /* highlight the path field */ <br>                        SetFocus(hDlg); <br>                        break; <br>                    } <br> <br>                    if (plgncred-&gt;ulFieldMask &amp; LGNCRED_PASS) <br>                    { <br>                        GetDlgItemText(hDlg, IDE_ACCOUNT_PASSWORD, <br>                            plgncred-&gt;szPass, ACCTSIZE * sizeof(TCHAR)); <br>                    } <br> <br>                    if (plgncred-&gt;ulFieldMask &amp; LGNCRED_REMEMBER) <br>                    { <br>                        plgncred-&gt;fRemember =  <br>                            IsDlgButtonChecked(hDlg, IDC_REMEMBER); <br>                    } <br> <br>                    EndDialog(hDlg, 0); <br>                    fHandled = TRUE; <br>                    break; <br>                } <br>            case IDCANCEL: <br>                { <br>                    plgncred-&gt;fCancel = TRUE; <br>                    EndDialog(hDlg, 0); <br>                    fHandled = TRUE; <br>                    break; <br>                } <br>            default: <br>                { <br>                    fHandled = FALSE; <br>                    break; <br>                } <br>            } <br>        } <br> <br>    default: <br>        { <br>            fHandled = FALSE; <br>            break; <br>        } <br>    } <br> <br>    return fHandled; <br>} <br> <br>/* <br> *  HrGetProfileCred <br> * <br> *  Purpose: <br> *      Obtain password programmatically by reading the <br> *      appropriate property out of the profile. If the  <br> *      property isn't there, don't fail the call. Return  <br> *      a NULL for the password, and clear the *pfFound flag. <br> * <br> *  Parameters: <br> *      plmr    Pointer to the MAPI linked memory routines <br> *      psup    Pointer to the MAPI support object (from which <br> *              we can get the current profile section). <br> *      szPass  Address of buffer in which to place the Logon <br> *              Account Password. <br> *      pfFound TRUE if the password was found in the profile. <br> *              FALSE if the password wasn't in the profile. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Errors: <br> *      None. <br> */ <br>static HRESULT <br>HrGetProfileCred(PLMR plmr, LPPROFSECT pps, LPTSTR szPass, BOOL *pfFound) <br>{ <br>    HRESULT hr; <br>    LPSPropValue pval = NULL; <br> <br>    AssertSz(szPass, "Bad szPass"); <br>    AssertSz(pps, "No profile section"); <br> <br>    hr = HrGetOneProp((LPMAPIPROP) pps, PR_SMS_PASSWORD, &amp;pval); <br> <br>    if (hr != hrSuccess) <br>    { <br>        *pfFound = FALSE; <br>        szPass[0] = (TCHAR) 0; <br>        hr = hrSuccess; <br>    } <br>    else <br>    { <br>        lstrcpy(szPass, pval[0].Value.LPSZ); <br>        *pfFound = TRUE; <br>    } <br> <br>    LMFree(plmr, pval); <br> <br>    DebugTraceResult(HrGetProfileCred, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrSetProfileCred <br> * <br> *  Purpose: <br> *      Save credential information in the profile for future <br> *      programmatic opening. <br> * <br> *  Parameters: <br> *      pps         Pointer to the profile section. <br> *      szPass      Logon Account Password. <br> *      szPath      Path name of root of the store <br> *      fRemember   TRUE means save the password in the store. <br> *      cbEntryID   Number of bytes in lpEntryID <br> *      lpEntryID   Pointer to Wrapped Store EntryID <br> *      puidRK      pointer to PR_RECORD_KEY data (always &amp;pims-&gt;uidResource) <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>static HRESULT HrSetProfileCred(LPPROFSECT pps, LPTSTR szPass, LPTSTR szPath, <br>    BOOL fRemember, ULONG cbEntryID, LPBYTE lpEntryID, LPMAPIUID puidRK) <br>{ <br>    HRESULT hr = hrSuccess; <br>    LPTSTR szDisplayName = NULL; <br>    SPropValue rgProps[7]; <br>    ULONG cValues; <br> <br>    AssertSz(pps, "Bad profile section"); <br>    AssertSz(szPass, "Bad szPass"); <br>    AssertSz(lpEntryID, "Bad lpEntryID"); <br> <br>    /* fill in the Display Name */ <br>    hr = HrAlloc((lstrlen(szDisplayPrefix) + lstrlen(szPath) + 1) <br>            * sizeof(TCHAR), &amp;szDisplayName); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    lstrcpy(szDisplayName, szDisplayPrefix); <br>    lstrcat(szDisplayName, szPath); <br> <br>    rgProps[0].ulPropTag = PR_PROVIDER_DISPLAY; <br>    rgProps[0].Value.LPSZ = szProviderDisplayName; <br> <br>    rgProps[1].ulPropTag = PR_DISPLAY_NAME; <br>    rgProps[1].Value.LPSZ = szDisplayName; <br> <br>    rgProps[2].ulPropTag = PR_ENTRYID; <br>    rgProps[2].Value.bin.cb = cbEntryID; <br>    rgProps[2].Value.bin.lpb = lpEntryID; <br> <br>    rgProps[3].ulPropTag = PR_SMS_PATH; <br>    rgProps[3].Value.LPSZ = szPath; <br> <br>    rgProps[4].ulPropTag = PR_MDB_PROVIDER; <br>    rgProps[4].Value.bin.cb = sizeof(MAPIUID); <br>    rgProps[4].Value.bin.lpb = (LPBYTE) &amp;uidProvider; <br> <br>    rgProps[5].ulPropTag = PR_RECORD_KEY; <br>    rgProps[5].Value.bin.cb = sizeof(MAPIUID); <br>    rgProps[5].Value.bin.lpb = (LPBYTE) puidRK; <br> <br>    cValues = 6; <br> <br>    if (fRemember) <br>    { <br>        rgProps[6].ulPropTag = PR_SMS_PASSWORD; <br>        rgProps[6].Value.LPSZ = szPass; <br>        ++cValues; <br>    } <br>    else <br>    { <br>        /* If the user doesn't want to remember the password, then we */ <br>        /* should try to remove it from the profile section. */ <br> <br>        (void) pps-&gt;lpVtbl-&gt;DeleteProps(pps, &amp;sptaPass, NULL); <br>    } <br> <br>    hr = pps-&gt;lpVtbl-&gt;SetProps(pps, cValues, rgProps, NULL); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>hr_err: <br>    FreeNull(szDisplayName); <br> <br>    DebugTraceResult(HrSetProfileCred, hr); <br>    return hr; <br>} <br> <br>/* <br> *  HrConfirmCred <br> * <br> *  Purpose: <br> *      Check user's store opening credentials against the account <br> *      information in the store. <br> * <br> *  Arguments: <br> *      szPath      Path to "root" directory of store. <br> *      szPass      Logon Account Password. <br> *      psup        Pointer to a MAPI Support object (passed to IMsgOnIStg). <br> *      plmr        Pointer to the linked mem alloc routines. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> */ <br>static HRESULT HrConfirmCred(LPTSTR szPath, LPTSTR szPass, LPMAPISUP psup, <br>    PLMR plmr) <br>{ <br>    HRESULT hr; <br>    LPMESSAGE lpmsg = NULL; <br>    LPSPropValue pval = NULL; <br>    LPTSTR szT = NULL; <br> <br>    AssertSz(szPath, "Bad szPath"); <br>    AssertSz(szPass, "Bad szPass"); <br> <br>    /* Open the message store props file as an IMessage instance. */ <br> <br>    hr = HrAppendPath(szPath, szPropFileName, &amp;szT); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    hr = HrOpenIMSPropsFileRetry(NULL, szT, plmr, psup, FALSE, &amp;lpmsg); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    /* Get password from the message store props file   */ <br>    /* and compare against the function parameter.      */ <br> <br>    hr = HrGetOneProp((LPMAPIPROP) lpmsg, PR_SMS_PASSWORD, &amp;pval); <br> <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    if (lstrcmp(szPass, pval[0].Value.LPSZ)) <br>        hr = ResultFromScode(MAPI_E_LOGON_FAILED); <br> <br>hr_err: <br>    FreeNull(szT); <br>    UlRelease(lpmsg); <br>    LMFree(plmr, pval); <br> <br>    DebugTraceResult(HrConfirmCred, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrFilePathExists <br> * <br> * Purpose: <br> *      Helper function for HrCheckStoreIntegrity. This function creates a <br> *      full pathname to the file given, and attempts to find it on disk. <br> * <br> * Returns: <br> *      HRESULT <br> * <br> *      If the file exists, and no other errors occur, the function returns <br> *      success. If the file doesn't exist, the function returns <br> *      MAPI_E_CORRUPT_STORE. If the file exists, but the find can't be closed, <br> *      the function returns MAPI_E_LOGON_FAILED. <br> */ <br>static HRESULT HrFilePathExists(LPTSTR szStorePath, LPTSTR szFileName) <br>{ <br>    LPTSTR szT = NULL; <br>    WIN32_FIND_DATA filedata; <br>    HANDLE hFindFile; <br>    HRESULT hr; <br> <br>    hr = HrAppendPath(szStorePath, szFileName, &amp;szT); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hFindFile = FindFirstFile(szT, &amp;filedata); <br>    if (hFindFile == INVALID_HANDLE_VALUE) <br>    { <br>        hr = ResultFromScode(MAPI_E_CORRUPT_STORE); <br>        goto exit; <br>    } <br> <br>    if (!FindClose(hFindFile)) <br>        hr = ResultFromScode(MAPI_E_LOGON_FAILED); <br> <br>exit: <br>    FreeNull(szT); <br>    return hr; <br>} <br> <br>/* <br> *  HrCheckStoreIntegrity <br> * <br> *  Purpose: <br> *      Quick check to see that all the necessary store components <br> *      exist in the proper place (store root).  The check of file <br> *      attributes assumes that OLE created its docfiles with <br> *      normal file attributes. <br> * <br> *  Arguments: <br> *      szPath      Path to "root" directory of store. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_CORRUPT_STORE    A necessary store component was <br> *                              missing. <br> */ <br>static HRESULT HrCheckStoreIntegrity(LPTSTR szStorePath) <br>{ <br>    HRESULT hr; <br> <br>    AssertSz(!IsBadStringPtr(szStorePath, (UINT) -1), "Bad szStorePath"); <br> <br>    /* Check for the message store properties file */ <br> <br>    hr = HrFilePathExists(szStorePath, szPropFileName); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    /* Check for the root folder properties file */ <br> <br>    hr = HrFilePathExists(szStorePath, szPropertyFileName); <br>    if (hr != hrSuccess) <br>        goto hr_err; <br> <br>    /* Check for the receive folder settings storage file */ <br> <br>    hr = HrFilePathExists(szStorePath, szFolderFileName); <br> <br>hr_err: <br>    DebugTraceResult(HrCheckStoreIntegrity, hr); <br>    return hr; <br>} <br> <br>/* <br> *  FIsValidPath <br> * <br> *  Purpose: <br> *      Returns TRUE if the path in szPath is a valid path to <br> *      to an existing directory if fCreate is FALSE. Or the <br> *      specified directory can be created if fCreate is TRUE. <br> * <br> *  Arguments: <br> *      szPath      Path to "root" directory of store. <br> *      fCreate         TRUE if directory is to be created. <br> * <br> *  Returns: <br> *      BOOL <br> * <br> *  Side effects: <br> *      None. <br> * <br> */ <br>static BOOL FIsValidPath(LPTSTR szPath, BOOL fCreate) <br>{ <br>    LPTSTR szLastSlash = NULL;  /* pointer to last slash in szPath */ <br>    DWORD dwAttributes; <br> <br>    if (*szPath == '\0') <br>        return FALSE; <br> <br>    /* if creating a root folder, the folder to check is the parent */ <br>    /* of the one in szPath */ <br>    if (fCreate) <br>    { <br>        /* must not already exist */ <br>        if (GetFileAttributes(szPath) != -1) <br>            return FALSE; <br> <br>        /* parent directory must exist */ <br>        szLastSlash = SzFindLastCh(szPath, '\\'); <br>        if (szLastSlash &amp;&amp; szLastSlash != szPath &amp;&amp; <br>            *(szLastSlash - 1) != ':') <br>        { <br>            *szLastSlash = '\0'; <br>        } <br>        else <br>        { <br>            /* creating a directory at the root level */ <br>            return TRUE; <br>        } <br>    } <br> <br>    /* get the attributes of the directory that must exist */ <br>    dwAttributes = GetFileAttributes(szPath); <br> <br>    /* restore szPath */ <br>    if (szLastSlash) <br>        *szLastSlash = '\\'; <br> <br>    return ((dwAttributes != -1) &amp;&amp; (dwAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)) ? <br>        TRUE : FALSE; <br>} <br> <br>/* <br> * HrGetSpoolSecurity <br> * <br> * Purpose <br> *          return the spooler security information for use in SpoolerLogon <br> * <br> * Parameters <br> *  szPath              path to root of store <br> *  szPass              store account password <br> *  plmr                pointer to the MAPI linked allocation routines <br> *  lpcbSpoolSecurity   byte count of the security information <br> *  lppbSpoolSecurity   security information <br> */ <br>static HRESULT HrGetSpoolSecurity(LPTSTR szPath, LPTSTR szPass, <br>    PLMR plmr, ULONG * lpcbSpoolSecurity, LPBYTE * lppbSpoolSecurity) <br>{ <br>    ULONG cbPath = Cbtszsize(szPath); <br>    ULONG cbPass = Cbtszsize(szPass); <br>    SCODE sc = S_OK; <br> <br>    /* allocate memory for the security information */ <br>    *lpcbSpoolSecurity = cbPass + cbPath; <br>    sc = LMAlloc(plmr, *lpcbSpoolSecurity, lppbSpoolSecurity); <br>    if (sc) <br>    { <br>        *lpcbSpoolSecurity = 0; <br>        DebugTraceSc(HrGetSpoolSecurity, sc); <br>        return ResultFromScode(sc); <br>    } <br> <br>    /* fill in the  spooler security information */ <br>    if (cbPath) <br>        memcpy(*lppbSpoolSecurity, szPath, (UINT) cbPath); <br>    if (cbPass) <br>        memcpy(*lppbSpoolSecurity + (UINT) cbPath, szPass, (UINT) cbPass); <br> <br>    return hrSuccess; <br>} <br> <br>/* <br> * DecodeSpoolSecurity <br> * <br> * Purpose <br> *          return the spooler security information for use in SpoolerLogon </code></pre>
<p>
</p>
<pre><code>* <br> * Parameters <br> *  cbSpoolSecurity     byte count of the security information <br> *  pbSpoolSecurity     security information <br> *  szPath              pointer to variable for path to root of store <br> *  szPass              poitner to varaible for store account password <br> */ <br>static void DecodeSpoolSecurity(ULONG cbSpoolSecurity, LPBYTE pbSpoolSecurity, <br>    LPTSTR szPath, LPTSTR szPass) <br>{ <br>    ULONG cbPath = 0; <br> <br>    lstrcpy(szPath, pbSpoolSecurity); <br>    cbPath = Cbtszsize(szPath); <br> <br>    lstrcpy(szPass, pbSpoolSecurity + cbPath); <br> <br>    return; <br>} <br> <br>/* <br> * HrCheckAndOpenStore <br> * <br> * Purpose <br> *          check the integrity of store specified in szPath and return <br> *          an open store if it's OK <br> * <br> * Parameters <br> *  pmsp                pointer to our MSProvider object <br> *  psup                mapi support object <br> *  fModify             TRUE if write access desired <br> *  pps                 pointer to our profile section <br> *  szPath              path name to root of the store <br> *  szPass              password to store <br> *  fIsSpooler          TRUE if this is a spooler logon <br> *  ppmsl               pointer to variable to hold MSLogon object <br> *  ppims               pointer to variable to hold the opened store object <br> */ <br>static HRESULT HrCheckAndOpenStore(PMSP pmsp, LPMAPISUP psup, BOOL fModify, <br>    LPPROFSECT pps, LPTSTR szPath, LPTSTR szPass, BOOL fIsSpooler, <br>    PMSL *ppmsl, PIMS *ppims) <br>{ <br>    HRESULT hr; <br>    PRFS prfs = NULL; <br>    PMSL pmsl = NULL; <br>    PIMS pims = NULL; <br>    SCODE sc; <br> <br>    *ppmsl = NULL; <br> <br>    hr = HrConfirmCred(szPath, szPass, psup, &amp;pmsp-&gt;lmr); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrCheckStoreIntegrity(szPath); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = OpenRFS(szPath, szFolderFileName, 0, &amp;prfs); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Create MSLogon object */ <br> <br>    sc = ScCreateMSL(pmsp, &amp;pmsl); <br>    if (sc != S_OK) <br>    { <br>        hr = ResultFromScode(sc); <br>        goto exit; <br>    } <br> <br>    /* Create Message Store object */ <br> <br>    hr = HrNewIMS(szPath, szPropFileName, pmsp, pmsl, prfs, pps, psup, <br>            FALSE, &amp;pims); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (fIsSpooler) <br>        OBJ_SetFlag(pims, MSF_SPOOLER); <br> <br>    if (fModify) <br>        OBJ_SetFlag(pims, OBJF_MODIFY); <br> <br>    pmsl-&gt;pims = pims; <br> <br>    *ppims = pims; <br>    *ppmsl = pmsl; <br> <br>exit: <br>    if (hr != hrSuccess) <br>    { <br>        /* If we have an RFS but failed to create the MS, close RFS manually. */ <br>        if (prfs) <br>            NFSideAssertSz(CloseRFS(prfs) == hrSuccess, "RFS not closed"); <br> <br>        UlRelease(pmsl); <br>        pmsl = NULL; <br>    } <br> <br>    DebugTraceResult(HrCheckAndOpenStore, hr); <br>    return hr; <br>} <br> <br>/* <br> * ScCreateMSL <br> * <br> * Purpose <br> *          returns a new logon object <br> * <br> * Parameters <br> *      pmsp    A pointer to the MS Provider object. <br> *      ppmsl   Location in which to return the address of the <br> *              newly allocated MSL object. <br> * <br> *  Returns: <br> *      SCODE <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate space for <br> *                                  the MSL object. <br> */ <br>static SCODE ScCreateMSL(PMSP pmsp, PMSL *ppmsl) <br>{ <br>    PMSL pmsl; <br>    SCODE sc; <br> <br>    sc = LMAllocZ(&amp;pmsp-&gt;lmr, sizeof(MSL), &amp;pmsl); <br> <br>    if (sc == S_OK) <br>    { <br>        OBJ_Initialize(pmsl, &amp;vtblMSL, OT_MSLOGON, NULL, &amp;pmsl-&gt;cs); <br> <br>        InitializeCriticalSection(&amp;pmsl-&gt;cs); <br> <br>        pmsl-&gt;lmr = pmsp-&gt;lmr; <br> <br>        *ppmsl = pmsl; <br>    } <br> <br>    DebugTraceSc(ScCreateMSL, sc); <br>    return sc; <br>} <br> <br>/* <br> *  FFindPropInPSPB <br> * <br> *  Purpose: <br> *      Look for the given property in the PSPB structure. Search the <br> *      client prop array before the profile prop array. <br> * <br> *  Arguments: <br> *      pspb    pointer to the service parameter block <br> *      ulPT    the property tag to look for <br> *      ppval   location to place the pointer to the pval <br> * <br> *  Returns: <br> */ <br>static BOOL FFindPropInPSPB(PSERVICEPBLK pspb, ULONG ulPT, LPSPropValue *ppval) <br>{ <br>    LPSPropValue pval; <br> <br>    /* First, look in the client's array. If it's not there, look for */ <br>    /* it in the profile array. */ <br> <br>    pval = PpropFindProp(pspb-&gt;pvalsClient, pspb-&gt;cvalsClient, ulPT); <br> <br>    if (!pval) <br>        pval = PpropFindProp(pspb-&gt;pvalsProf, pspb-&gt;cvalsProf, ulPT); <br> <br>    if (pval) <br>    { <br>        *ppval = pval; <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>/* <br> *  ScGetFullFileName <br> * <br> *  Purpose: <br> *      Look for the file path and name in the property list given.  If <br> *      found, convert it to a full (non-relative) path name, and check for <br> *      the existence of the directory. Note that we return values even  <br> *      when an error occurs. <br> * <br> *  Arguments: <br> * <br> *  Returns: <br> */ <br>static SCODE ScGetFullFileName(PSERVICEPBLK pspb, BOOL *pfCreate, <br>    LPSTR pszPath) <br>{ <br>    SCODE           sc  = S_OK; <br>    LPSTR           pszFileTitle; <br>    LPSPropValue    pval; <br>    BOOL            fCreate = FALSE; <br> <br>    *pszPath = '\0'; <br>    *pfCreate = FALSE; <br> <br>    /* get the path to the file */ <br>    if (    FFindPropInPSPB(pspb, PR_SMS_PATH, &amp;pval) <br>        &amp;&amp;  GetFullPathName(pval-&gt;Value.lpszA, MAX_PATH, pszPath, <br>                &amp;pszFileTitle)) <br>    { <br>        DWORD   dwFA; <br>        LPSPropValue pvalT; <br> <br>        if (FFindPropInPSPB(pspb, PR_SMS_CREATE, &amp;pvalT)) <br>            *pfCreate = pvalT-&gt;Value.b; <br> <br>        Assert (*(pszFileTitle - 1) == '\\'); <br> <br>        dwFA = GetFileAttributes(pszPath); <br> <br>        /* If the file isn't there, and we aren't creating, then error. */ <br>        /* If the file is there, and we are creating, then error. */ <br> <br>        if (dwFA == 0xFFFFFFFF &amp;&amp; *pfCreate == FALSE) <br>            sc = MAPI_E_NOT_FOUND; <br>        else if (dwFA != 0xFFFFFFFF &amp;&amp; *pfCreate == TRUE) <br>            sc = MAPI_E_NO_ACCESS; <br>    } <br>    else <br>    { <br>        *pszPath = '\0'; <br>        sc = MAPI_E_NOT_FOUND; <br>    } <br> <br>    DebugTraceSc(ScGetFullFileName, sc); <br>    return sc; <br>} <br> <br> <br></code></pre>
<p>&nbsp;</p></body>
</HTML>
