<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML dir=ltr>
<HEAD>
<META HTTP-EQUIV="Content-Type" Content="text/html; charset=Windows-1252">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-83731338-2"></script><script>  window.dataLayer = window.dataLayer || [];  function gtag(){dataLayer.push(arguments);}  gtag('js', new Date());  gtag('config', 'UA-83731338-2');</script><title>MSPMISC.C</title>
<link disabled rel=stylesheet href=../../../../../backsdk3.css>
<style type="text/css">
@import url(../../../../../backsdk4.css);
</style>
</HEAD>
<BODY BGCOLOR = #FFFFFF TEXT = #000000>
<h2><a name="_code_context2092"></a>MSPMISC.C</h2>
<pre><code>/* <br> *  M S P M I S C . C <br> * <br> *  Utility functions needed by the MAPI Sample Store Provider. <br> * <br> *  Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved. <br> */ <br> <br>#include "msp.h" <br> <br>/* <br> *  Memory allocation and release functions.  They use the lpMalloc <br> *  interface supplied by MAPI during provider initialization. <br> * <br> *  For internal memory allocations the Sample Store Provider uses <br> *  the lpMalloc passed by MAPI on MSProviderInit().  For simplicity <br> *  of coding we keep the pointer to the lpMalloc in a <br> *  per-process global (which requires mucho work on Win16) instead <br> *  of forcing ScAlloc() calls to pass in the pointer on each and every <br> *  allocation.  We trade off code size with speed (on Win16) because <br> *  of the searching necessary in finding the per-instance globals. <br> * <br> *  When multiple MSProviderInit's are done on the same process <br> *  (by opening one or more stores on two different MAPI Profiles <br> *  on the same process) we use the lpMalloc from the first init <br> *  for all allocations, keeping a refcount of MSProviderInit's <br> *  that have been done in order to know when to free the lpMalloc. <br> * <br> *  As a result we don't necessary use the lpMalloc for store X that <br> *  was passed in when store X was opened, but as long as MAPI gives <br> *  us the Component Object's lpMalloc on each open we're fine. <br> */ <br> <br>SCODE ScAlloc(ULONG lcb, LPVOID * ppv) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br> <br>    Assert(pinst); <br>    Assert(pinst-&gt;lpmalloc); <br> <br>    *ppv = pinst-&gt;lpmalloc-&gt;lpVtbl-&gt;Alloc(pinst-&gt;lpmalloc, lcb); <br>    if (*ppv != NULL) <br>        return S_OK; <br> <br>    DebugTraceSc(ScAlloc, MAPI_E_NOT_ENOUGH_MEMORY); <br>    return (MAPI_E_NOT_ENOUGH_MEMORY); <br>} <br> <br>SCODE ScAllocZ(ULONG lcb, LPVOID * ppv) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br> <br>    Assert(pinst); <br>    Assert(pinst-&gt;lpmalloc); <br> <br>    *ppv = pinst-&gt;lpmalloc-&gt;lpVtbl-&gt;Alloc(pinst-&gt;lpmalloc, lcb); <br>    if (*ppv != NULL) <br>    { <br>        memset(*ppv, 0, (size_t) lcb); <br>        return S_OK; <br>    } <br> <br>    DebugTraceSc(ScAllocZ, MAPI_E_NOT_ENOUGH_MEMORY); <br>    return (MAPI_E_NOT_ENOUGH_MEMORY); <br>} <br> <br>SCODE ScRealloc(ULONG lcb, LPVOID pvOrig, LPVOID * ppv) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br>    LPVOID pvNew; <br> <br>    Assert(pinst); <br>    Assert(pinst-&gt;lpmalloc); <br> <br>    pvNew = pinst-&gt;lpmalloc-&gt;lpVtbl-&gt;Realloc(pinst-&gt;lpmalloc, pvOrig, lcb); <br>    if (pvNew != NULL) <br>    { <br>        *ppv = pvNew; <br>        return S_OK; <br>    } <br> <br>    DebugTraceSc(ScRealloc, MAPI_E_NOT_ENOUGH_MEMORY); <br>    return (MAPI_E_NOT_ENOUGH_MEMORY); <br>} <br> <br>void FreeNull(LPVOID pv) <br>{ <br>    if (pv) <br>    { <br>        PINST pinst = (PINST) PvGetInstanceGlobals(); <br> <br>        Assert(pinst); <br>        Assert(pinst-&gt;lpmalloc); <br> <br>        pinst-&gt;lpmalloc-&gt;lpVtbl-&gt;Free(pinst-&gt;lpmalloc, pv); <br>    } <br>} <br> <br>/* Linked Memory Utilities ------------------------------------------------- */ <br> <br>SCODE LMAllocZ(PLMR plmr, ULONG lcb, LPVOID * ppv) <br>{ <br>    SCODE sc; <br> <br>    sc = LMAlloc(plmr, lcb, ppv); <br>    if (sc != S_OK) <br>        return (sc); <br> <br>    memset(*ppv, 0, (size_t) lcb); <br>    return (S_OK); <br>} <br> <br>/* <br> *  ScInitMSInstance <br> * <br> *  Remember the given lpMalloc in a per-instance variable that <br> *  can be looked up again in ScAlloc and FreeNull. <br> */ <br>SCODE ScInitMSInstance(LPMALLOC lpmalloc) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br>    SCODE sc; <br> <br>    Assert(lpmalloc); <br> <br>    if (pinst) <br>    { <br>        /* A usable allocator is already set.   */ <br>        /* Ignore the one we were passed in     */ <br>        /* and instead bump the refcount on the */ <br>        /* one we're going to use.              */ <br>        ++(pinst-&gt;cRef); <br>        return S_OK; <br>    } <br> <br>    /* In our debugging version wrap the allocator for <br>     * extra help locating memory leaks or other problems. <br>     * In both debug and non-debug versions, this statement <br>     * addrefs the allocator, and the DBGMEM_Shutdown at the <br>     * end does a release on the allocator. <br>     */ <br>    lpmalloc = DBGMEM_Encapsulate(lpmalloc, "Sample Store", 0); <br> <br>    pinst = (PINST) lpmalloc-&gt;lpVtbl-&gt;Alloc(lpmalloc, sizeof(INST)); <br> <br>    if (pinst == NULL) <br>    { <br>        sc = MAPI_E_NOT_ENOUGH_MEMORY; <br>        goto ret; <br>    } <br> <br>    sc = ScSetInstanceGlobals(pinst); <br>    if (sc != S_OK) <br>        goto ret; <br> <br>    pinst-&gt;cRef = 1; <br>    pinst-&gt;lpmalloc = lpmalloc; <br> <br>    return S_OK; <br> <br>ret: <br>    if (pinst) <br>        lpmalloc-&gt;lpVtbl-&gt;Free(lpmalloc, pinst); <br> <br>    DBGMEM_Shutdown(lpmalloc); <br>    DebugTraceSc(ScInitMSInstance, sc); <br>    return sc; <br>} <br> <br>void DeinitMSInstance(void) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br>    LPMALLOC lpmalloc; <br> <br>    if (!pinst || --(pinst-&gt;cRef) &gt; 0) <br>        return; <br> <br>    (void)ScSetInstanceGlobals(NULL); <br>    lpmalloc = pinst-&gt;lpmalloc; <br>    lpmalloc-&gt;lpVtbl-&gt;Free(lpmalloc, pinst); <br>    DBGMEM_Shutdown(lpmalloc); <br>} <br> <br>/* <br> *  SzBaseName <br> * <br> *  Purpose <br> *      return the base name of the object with the given eid <br> * <br> *  Parameters <br> *      peid                Pointer to entryID of object <br> * <br> *  Returns <br> *      LPTSTR              base name, ie sequence number and extension <br> * <br> *  Note                    no memory is allocated, returned value must be <br> *                          copied if it is to be saved. <br> */ <br>LPTSTR SzBaseName(PEID peid) <br>{ <br>    LPTSTR szName;              /* local name of object in lpEntryID */ <br>    LPTSTR szLastSlash;         /* position of last slash in peid */ <br> <br>    Assert(peid); <br> <br>    /* Note that the entryid pathname is always relative to the root of */ <br>    /* the store, and will therefore never contain a drive letter. */ <br> <br>    szLastSlash = SzFindLastCh(peid-&gt;szPath, '\\'); <br> <br>    if (NULL == szLastSlash) <br>    { <br>        szName = (LPTSTR) peid-&gt;szPath; <br>    } <br>    else <br>    { <br>        szName = szLastSlash + 1; <br>    } <br> <br>    return szName; <br>} <br> <br>/* <br> * FCheckEIDType <br> * <br> *  Purpose <br> *      This function checks the pathname extension portion of the given <br> *      entryid against the string given. Since files in the sample store <br> *      have extensions that depend on the type of object within, comparing <br> *      the extension will tell the caller whether the entryid is of the type <br> *      specified by the extension passed in. <br> * <br> *  Parameters <br> *      peid: A pointer to the entryid to check. <br> *      szExt: A pointer to the string containing the extension to compare. <br> * <br> *  Returns: TRUE if the extensions matched, FALSE otherwise. <br> */ <br>BOOL FCheckEIDType(PEID peid, LPSTR szExt) <br>{ <br>    BYTE *pb; <br> <br>    if (peid == NULL) <br>        return FALSE; <br> <br>    pb = (BYTE *) peid; <br>    pb += CbEID(peid); <br>    pb -= ((CCH_EXT + 1) * sizeof(TCHAR)); <br> <br>    return (lstrcmpi((LPTSTR) pb, szExt) == 0); <br>} <br> <br>/* <br> *  FIsRoot <br> * <br> *  Purpose     Determine if an EID is one for the root folder <br> * <br> *  Parameters  peid <br> * <br> *  Returns     TRUE or FALSE <br> */ <br>BOOL FIsRoot(PEID peid) <br>{ <br>    return (NULL == peid) || *(peid-&gt;szPath) == '\0'; <br>} <br> <br>/* <br> *  FIsFolder <br> * <br> *  Parameters  peid    pointer to entryid of object <br> * <br> *  Purpose     return TRUE if the entryID is one for a folder <br> * <br> *  Returns     TRUE If the entryID is one for a folder, FALSE otherwixe <br> * <br> */ <br>BOOL FIsFolder(PEID peid) <br>{ <br>    /* root is a folder */ <br>    if (FIsRoot(peid)) <br>        return TRUE; <br> <br>    return (FCheckEIDType(peid, FOLDER_EXT)); <br>} <br> <br>/* <br> *  FIsUnsavedMsg <br> * <br> *  Purpose     Determine if a message has had changes saved <br> * <br> *  Parameters  pimsg: A pointer to the message object to check. <br> * <br> *  SideEffect <br> *              Will say that a message is saved if another open version <br> *              has saved it. <br> * <br> *  Returns     TRUE or FALSE <br> */ <br>BOOL FIsUnsavedMsg(PIMSG pimsg) <br>{ <br>    return (FIsUnsavedEID((PEID) pimsg-&gt;peid)); <br>} <br> <br>/* <br> *  HrDeconstructEID <br> * <br> *  Purpose: <br> *      Given an EID, return its component parts (MAPIUID, path to <br> *      file, and file name).  This is NOT a general path parser. <br> *      Instead, because we know the exact structure of the EIDs <br> *      and paths we construct, we can directly access the <br> *      individual components. <br> * <br> *  Parameters <br> *      peid        EID to deconstruct. <br> *      ppuid       Location in which to return a pointer to the <br> *                  EID's MAPIUID. <br> *      pszPath     Location in which to return a pointer to the <br> *                  EID's file path. <br> *      pszFile     Location in which to return a pointer to the <br> *                  EID's file name. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Size effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Could not allocate memory for <br> *                                  some or all of the return <br> *                                  parameters. <br> */ <br>HRESULT HrDeconstructEID(PEID peid, LPMAPIUID *ppuid, LPTSTR *pszPath, <br>    LPTSTR *pszFile) <br>{ <br>    SCODE sc; <br>    LPMAPIUID puid = NULL; <br>    LPTSTR szPath = NULL; <br>    LPTSTR szFile = NULL; <br>    LPTSTR szT = NULL; <br>    LPTSTR szEnd = NULL; <br> <br>    AssertSz(!IsBadReadPtr(peid, CbNewEID(0)), "Bad peid #1"); <br>    AssertSz(!IsBadReadPtr(peid, CbEID(peid)), "Bad peid #2"); <br>    AssertSz(!IsBadWritePtr(ppuid, sizeof(LPMAPIUID)), "Bad ppuid"); <br>    AssertSz(!IsBadWritePtr(pszPath, sizeof(LPTSTR)), "Bad pszPath"); <br>    AssertSz(!IsBadWritePtr(pszFile, sizeof(LPTSTR)), "Bad pszFile"); <br> <br>    *ppuid = NULL; <br>    *pszPath = NULL; <br>    *pszFile = NULL; <br> <br>    /* Get the UID out */ <br> <br>    sc = ScAlloc(sizeof(MAPIUID), &amp;puid); <br>    if (sc != S_OK) <br>        goto exit; <br>    *puid = peid-&gt;uidResource; <br> <br>    /* Get the path and file name out */ <br>    szT = SzFindLastCh(peid-&gt;szPath, '\\'); <br>    if (szT) <br>        szT++; <br>    else <br>        szT = peid-&gt;szPath; <br> <br>    szEnd = (TCHAR *) ((BYTE *) peid + CbEID(peid)); <br>    sc = ScAlloc((szEnd - szT) * sizeof(TCHAR), &amp;szFile); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    if ((LPBYTE) szEnd - (LPBYTE) szT) <br>        memcpy(szFile, szT, (LPBYTE) szEnd - (LPBYTE) szT); <br> <br>    if (szT != peid-&gt;szPath) <br>    { <br>        sc = ScAlloc((LPBYTE) szT - (LPBYTE) (peid-&gt;szPath), &amp;szPath); <br>        if (sc != S_OK) <br>            goto exit; <br> <br>        /* We copy the trailing backslash along with the rest of   */ <br>        /* the string, then overwrite it with the NULL terminator. */ <br>        memcpy(szPath, peid-&gt;szPath, (LPBYTE) szT - (LPBYTE) (peid-&gt;szPath)); <br>        *(szPath + (szT - peid-&gt;szPath) - 1) = '\0'; <br>    } <br>    else <br>    { <br>        sc = ScAlloc(sizeof(TCHAR), (PPV) &amp;szPath); <br>        if (sc != S_OK) <br>            goto exit; <br> <br>        *szPath = '\0'; <br>    } <br> <br>exit: <br>    if (sc) <br>    { <br>        (void)FreeNull((LPVOID) puid); <br>        (void)FreeNull((LPVOID) szPath); <br>        (void)FreeNull((LPVOID) szFile); <br>    } <br>    else <br>    { <br>        *ppuid = puid; <br>        *pszPath = szPath; <br>        *pszFile = szFile; <br>    } <br> <br>    DebugTraceSc(HrDeconstructEID, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  HrAppendPath <br> * <br> *  Purpose: <br> *      Concatenate a path onto another, allocating space for the <br> *      result. <br> * <br> *  Parameters <br> *      szBase          Beginning of concatenated path. <br> *      szAppend        End of concatenated path. <br> *      pszFullPath     Pointer in which to place a pointer to the <br> *                      newly allocated concatenated path. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      MAPI_E_NOT_ENOUGH_MEMORY    Unable to allocate memory for <br> *                                  the return variable. <br> */ <br>HRESULT HrAppendPath(LPTSTR szBase, LPTSTR szAppend, LPTSTR * pszFullPath) <br>{ <br>    SCODE sc = S_OK; <br>    TCHAR rgch[512]; <br> <br>    AssertSz(szBase, "Bad szBase"); <br>    AssertSz(szAppend, "Bad szAppend"); <br>    AssertSz(pszFullPath, "Bad pszFullPath"); <br>    AssertSz(szAppend[0] != '\\', <br>        "szAppend not relative path"); <br> <br>    if (!FAppendPathNoMem(szBase, szAppend, sizeof rgch / sizeof rgch[0], <br>            rgch)) <br>    { <br>        sc = MAPI_E_STRING_TOO_LONG; <br>        goto exit; <br>    } <br> <br>    sc = ScAlloc(Cbtszsize(rgch), (PPV) pszFullPath); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    lstrcpy(*pszFullPath, rgch); <br> <br>exit: <br>    DebugTraceSc(HrAppendPath, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> *  FAppendPathNoMem <br> * <br> *  Purpose: <br> *      Concatenate two parts of a file path, returning result in a <br> *      preallocated buffer. <br> * <br> *  Parameters <br> *      szBase          First part of path to concatenate. <br> *      szAppend        Second part of path to concatenate. <br> *      cchFullPath     Size of return buffer. <br> *      szFullPath      Return buffer. <br> * <br> *  Returns: <br> *      BOOL.  TRUE if the return buffer is large enough to hold <br> *      the resultant string, FALSE if the buffer is not large <br> *      enough (value in szFullPath is undefined). <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      None. <br> */ <br>BOOL FAppendPathNoMem(LPTSTR szBase, LPTSTR szAppend, ULONG cchFullPath, <br>    LPTSTR szFullPath) <br>{ <br>    UINT cchBase = 0; <br>    UINT cchAppend = 0; <br>    UINT cchFull = 0; <br>    BOOLEAN fPostSlash = FALSE; <br> <br>    AssertSz(szBase, "Bad szBase"); <br>    AssertSz(szAppend, "Bad szAppend"); <br>    AssertSz(szFullPath, "Bad szFullPath"); <br>    AssertSz(szAppend[0] != '\\', <br>        "szAppend not relative path"); <br> <br>    cchBase = lstrlen(szBase); <br>    cchAppend = lstrlen(szAppend); <br> <br>    /* Check if szBase has trailing backslash, else we'll need to add it */ <br> <br>    if (*(szBase + cchBase - 1) == '\\') <br>    { <br>        fPostSlash = TRUE; <br>        cchFull = cchBase + cchAppend + 1; <br>    } <br>    else <br>    { <br>        fPostSlash = FALSE; <br>        cchFull = cchBase + cchAppend + 2; <br>    } <br> <br>    if (cchFull &lt;= cchFullPath) <br>    { <br>        lstrcpy(szFullPath, szBase); <br>        if (!fPostSlash) <br>        { <br>            lstrcat(szFullPath, TEXT("\\")); <br>        } <br>        lstrcat(szFullPath, szAppend); <br> <br>        return TRUE; <br>    } <br> <br>    return FALSE; <br>} <br> <br>/* <br> *  ReplaceExt <br> * <br> *  Purpose: <br> *      Substitute the filename extension in szFile with the new <br> *      one passed in as szExt.  It is the caller's <br> *      responsibility to ensure that the filename has room for the <br> *      new extension.  Also, the extension must include the <br> *      period. <br> * <br> *  Parameters <br> *      szFile      Filename on which to operate. <br> *      szExt       New extension. <br> * <br> *  Returns: <br> *      void. <br> */ <br>void ReplaceExt(LPTSTR szFile, LPTSTR szExt) <br>{ <br>    LPTSTR szT = NULL; <br> <br>    AssertSz(!IsBadStringPtr(szFile, (UINT) -1), "Bad szFile"); <br>    AssertSz(!IsBadStringPtr(szExt, (UINT) -1), "Bad szExt"); <br> <br>    szT = SzFindLastCh(szFile, '.'); <br> <br>    if (szT) <br>        lstrcpy(szT, szExt); <br>    #ifdef DEBUG <br>    else <br>        TrapSz("No extension found on szFile. Not replacing extension."); <br>    #endif <br> <br>    return; <br>} <br> <br>/* <br> *  HrConstructEID <br> * <br> *  Purpose     return an new EntryID for an object <br> * <br> *  Parameters <br> *      puidStore       UID for the store containing the object <br> *      plmr            Pointer to the MAPI linked memory allocators. <br> *      szNewName       new root relative path name of the object <br> *      ppeidNew        address of pointer to new entryID <br> * <br> *  Returns: <br> *      ULONG, PEID <br> */ <br>HRESULT HrConstructEID(LPMAPIUID puidStore, PLMR plmr, LPSTR szNewName, <br>    PEID *ppeidNew) <br>{ <br>    PEID peidNew;               /* new entry id */ <br>    ULONG cbEID;                /* number of bytes in the new entry id */ <br>    ULONG cbNewName; <br>    SCODE sc; <br> <br>    cbNewName = lstrlen(szNewName) + 1; /* we count the NULL terminator */ <br>    cbEID = CbNewEID(cbNewName); <br> <br>    /* allocate space for the new entry id */ <br>    /* Use the MAPI allocator because it may be returned to the client */ <br>    /* Note that we zero-fill this allocation so that the entryid produced */ <br>    /* by identical input parameters will always be the same. If we didn't */ <br>    /* zero fill, the pad bytes after the version would be randomly filled. */ <br> <br>    sc = LMAllocZ(plmr, cbEID, (PPV) &amp;peidNew); <br>    if (sc != S_OK) <br>        goto exit; <br> <br>    *(DWORD *) (peidNew-&gt;abFlags) = (DWORD) 0; <br>    peidNew-&gt;uidResource = *puidStore; <br>    peidNew-&gt;bVersion = SMPMS_VERSION; <br> <br>    lstrcpy(peidNew-&gt;szPath, szNewName); <br> <br>    if (peidNew-&gt;szPath[0]) <br>        AnsiLowerBuff(peidNew-&gt;szPath, lstrlen(peidNew-&gt;szPath)); <br> <br>    *ppeidNew = peidNew; <br> <br>exit: <br>    DebugTraceSc(HrConstructEID, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> * HrGetParentEID <br> * <br> *  Purpose         construct an entry id for the parent of peid. This <br> *                  assumes that all files in the sample message store  <br> *                  are CCH_NAME chars long (including NULL). <br> * <br> *  Parameters <br> *      plmr        Pointer to the MAPI linked memory allocators. <br> *      peid        entry id of object whose parent is requested <br> *      ppeidParent pointer to parent's peid <br> * <br> */ <br>HRESULT HrGetParentEID(PLMR plmr, PEID peid, PEID *ppeidParent) <br>{ <br>    HRESULT hr; <br>    ULONG cbParentName = sizeof(TCHAR); /* number of bytes in szParentName */ <br>    LPTSTR szParentName = NULL; /* name of parent */ <br> <br>    if (CbEIDPath(peid) &gt; (CCH_NAME * sizeof(TCHAR))) <br>        cbParentName = CbEIDPath(peid) - (CCH_NAME * sizeof(TCHAR)); <br> <br>    hr = HrAlloc(cbParentName, (PPV) &amp;szParentName); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    if (cbParentName &gt; sizeof(TCHAR)) <br>        memcpy(szParentName, peid-&gt;szPath, (UINT) cbParentName); <br>    szParentName[cbParentName - sizeof(TCHAR)] = 0; <br> <br>    hr = HrConstructEID(&amp;(peid-&gt;uidResource), plmr, szParentName, <br>        ppeidParent); <br> <br>exit: <br>    FreeNull(szParentName); <br>    DebugTraceResult(HrGetParentEID, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrOpenParent <br> * <br> * Purpose  open the parent folder of the given entry id <br> * <br> * Parameters <br> *  pims    store in which the object is <br> *  peid    entry id of object whose parent is to be opened <br> *  ulFlags MAPI_MODIFY if you want write permission on the store <br> *  ppifld  pointer to variable to hold open parent <br> */ <br>HRESULT HrOpenParent(PIMS pims, PEID peid, ULONG ulFlags, PIFLD * ppifld) <br>{ <br>    HRESULT hr = hrSuccess; <br>    PEID peidParent = NULL; <br>    ULONG ulObjectType; <br> <br>    Assert(pims); <br>    Assert(peid); <br>    Assert(ppifld); <br> <br>    *ppifld = NULL; <br>    hr = HrGetParentEID(&amp;pims-&gt;lmr, peid, &amp;peidParent); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = pims-&gt;lpVtbl-&gt;OpenEntry(pims, CbEID(peidParent), <br>        (LPENTRYID) peidParent, NULL, ulFlags, &amp;ulObjectType, <br>        (LPUNKNOWN *) ppifld); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    Assert(ulObjectType == MAPI_FOLDER); <br> <br>exit: <br>    LMFree(&amp;pims-&gt;lmr, peidParent); <br> <br>    DebugTraceResult(HrOpenParent, hr); <br>    return hr; <br>} <br> <br>/* <br> * FreePropArrays <br> * <br> * Purpose      deallocate space for PropTag, PropValue and PropAttr arrays <br> *              allocated with HrAllocPropArrays <br> * Parameters <br> *  ppval       address of property value array <br> *  pptaga  address of the property tag array <br> *  ppatra  address of the property attribute array <br> */ <br>void FreePropArrays(LPSPropValue *ppval, LPSPropTagArray *pptaga, <br>    LPSPropAttrArray *ppatra) <br>{ <br>    Assert(ppval); <br>    Assert(pptaga); <br>    Assert(ppatra); <br> <br>    FreeNull(*ppval); <br>    FreeNull(*pptaga); <br>    FreeNull(*ppatra); <br> <br>    *ppval = NULL; <br>    *pptaga = NULL; <br>    *ppatra = NULL; <br>} <br> <br>/* <br> * HrAllocPropArrays <br> * <br> * Purpose      allocate space for PropTag, PropValue and PropAttr arrays <br> *              Free with FreeNull or FreePropArrays <br> * Parameters <br> *  cProps  number of properties in the arrays <br> *  ppval   address of property value array <br> *  pptaga  address of the property tag array <br> *  ppatra  address of the property attribute array <br> */ <br>HRESULT HrAllocPropArrays(ULONG cProps, LPSPropValue *ppval, <br>    LPSPropTagArray *pptaga, LPSPropAttrArray *ppatra) <br>{ <br>    HRESULT hr; <br> <br>    /* All three pointers must be provided. */ <br>    Assert(!IsBadWritePtr(ppval, sizeof(LPSPropValue))); <br>    Assert(!IsBadWritePtr(pptaga, sizeof(LPSPropTagArray))); <br>    Assert(!IsBadWritePtr(ppatra, sizeof(LPSPropAttrArray))); <br> <br>    /* All must be zero on entry for our cleanup mechanism. */ <br>    AssertSz(!*ppval, "bad ppval"); <br>    AssertSz(!*pptaga, "bad pptaga"); <br>    AssertSz(!*ppatra, "bad ppatra"); <br> <br>    hr = HrAlloc(cProps * sizeof(SPropValue), ppval); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrAlloc(CbNewSPropTagArray(cProps), pptaga); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    hr = HrAlloc(CbNewSPropAttrArray(cProps), ppatra); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>exit: <br>    if (hr != hrSuccess) <br>        FreePropArrays(ppval, pptaga, ppatra); <br> <br>    DebugTraceResult(HrAllocPropArrays, hr); <br>    return hr; <br>} <br> <br>/* <br> * ProcessGetProps <br> * <br> *  Purpose <br> *      Helper routine from HrWrap_GetProps. Folder and message objects in <br> *      the sample store keep a few property values in memory so that when <br> *      we move or copy a folder or message, the entryid, parent entryid, <br> *      and (for copied messages) record key are correct. This routine  <br> *      overrides the value returned from IMessage for any in-memory  <br> *      properties. We keep a very small placeholder property for each <br> *      of the in-memory properties on disk and mark it read-only and  <br> *      not deletable. This keeps SetProps from succeeding on these <br> *      properties. All properties that we override in this function are <br> *      PT_BINARY property types, so HrWrap_GetProps only calls this  <br> *      function if the property it is looking for is a PT_BINARY. <br> * <br> *      This function tries to find the property that the client is  <br> *      requesting in the in-memory array of properties stored with the <br> *      object. If the routine finds the property, then it tries to allocate <br> *      and copy the correct data into the client's array. If the allocation <br> *      fails, the routine fills in a PT_ERROR into the client's property <br> *      value. Note that HrWrap_GetProps needs to watch for PT_ERROR coming <br> *      back and return the appropriate warning to the client.  <br> *      If the routine doesn't find the property, then it returns to <br> *      HrWrap_GetProps without modifying the client's array at all. <br> * <br> *  Parameters <br> *      pvalClient: A pointer to the property value to search for in our <br> *          in-memory property array. This function may MODIFY this value. <br> *      cvalInt: The number of in-memory properties on this object. If the <br> *          object has no in-memory properties, this value will be zero. <br> *      pvalInt: A pointer to the object's array of in-memory properties. <br> *      plmr: A pointer to the linked memory allocation routines. <br> *      pvOrig: The original allocated pointer (AllocateMore needs this). <br> * <br> *  Returns <br> *      None. May have modified the client's property value if there was <br> *      a matching entry in the in-memory array. <br> */ <br>static void ProcessGetProps(LPSPropValue pvalClient, ULONG cvalInt, <br>    LPSPropValue pvalInt, PLMR plmr, LPVOID pvOrig) <br>{ <br>    ULONG ulClientID = PROP_ID(pvalClient-&gt;ulPropTag); <br>    ULONG ulClientType = PROP_TYPE(pvalClient-&gt;ulPropTag); <br>    LPSPropValue pvalT; <br>    LPSPropValue pvalTMac; <br> <br>    pvalT = pvalInt; <br>    pvalTMac = pvalT + cvalInt; <br> <br>    for (; pvalT &lt; pvalTMac; ++pvalT) <br>    { <br>        LPVOID pv; <br>        ULONG cb; <br>        SCODE sc; <br> <br>        AssertSz(PROP_TYPE(pvalT-&gt;ulPropTag) == PT_BINARY, <br>            "Code assumes all internal props are PT_BINARY"); <br> <br>        if (ulClientID == PROP_ID(pvalT-&gt;ulPropTag)) <br>        { <br>            cb = pvalT-&gt;Value.bin.cb; <br>            pv = pvalT-&gt;Value.bin.lpb; <br> <br>            /* Link onto returned data our extra info. */ <br>            sc = LMAllocMore(plmr, cb, pvOrig, &amp;pvalClient-&gt;Value.bin.lpb); <br>            if (sc != S_OK) <br>            { <br>                pvalClient-&gt;Value.err = sc; <br>                pvalClient-&gt;ulPropTag = PROP_TAG(PT_ERROR, ulClientID); <br>            } <br>            else <br>            { <br>                pvalClient-&gt;Value.bin.cb = cb; <br>                if (cb) <br>                    memcpy(pvalClient-&gt;Value.bin.lpb, pv, (UINT) cb); <br>                pvalClient-&gt;ulPropTag = PROP_TAG(PT_BINARY, ulClientID); <br>            } <br> <br>            break; <br>        } <br>    } <br> <br>    return; <br>} <br> <br>/* <br> * HrWrap_GetProps <br> * <br> * Purpose <br> *  Adjust return from GetProps (Store, Folder, Message, etc) for wrapped <br> *  values of PR_STORE_ENTRYID, PR_STORE_RECORD_KEY and (if a store) <br> *  PR_ENTRYID. Doesn't allow the return of PR_ENTRYID for an unsaved <br> *  message. Also overwrites values for properties that the object has <br> *  cached in memory using the helper routine ProcessGetProps. <br> *               <br> * Parameters <br> *  hr              HRESULT from the original GetProps call. <br> *  pims            pointer to the message store object <br> *  cvalInt         the number of property values that are held in memory  <br> *                  associated with the object. <br> *  pvalInt         a pointer to the array of in-memory properties associated <br> *                  with the object. May be NULL if cvalInt is 0. <br> *  pcValues        The number of values in client's PropValue array <br> *  ppval           a pointer to the client's PropValue array <br> *  fStore          TRUE if the object given the GetProps call was the <br> *                  message store object. <br> *  fTagsSpecified  TRUE if the client specified a proptag array on the call; <br> *                  FALSE if the client passed NULL for the proptag array. <br> * <br> * Coding comments: <br> *  The objects must contain these properties, of the appropriate <br> *  type, but it isn't necessary that their values IN the objects be <br> *  accurate. The KEYS, for example, don't even have to be 16 bytes. <br> * <br> *  The result code may be adjusted depending on whether this routine <br> *  or the underlying property implementation, ran out of memory <br> *  while dealing with one of these. <br> * <br> *  The PR_RECORD_KEY (a UID) in a Store IS the right value, <br> *  and does not need to be wrapped. <br> */ <br>HRESULT HrWrap_GetProps(HRESULT hr, PIMS pims, ULONG cvalInt, <br>    LPSPropValue pvalInt, ULONG * pcValues, LPSPropValue * ppval, <br>    BOOL fStore, BOOL fTagsSpecified, POBJ pobj) <br>{ <br>    /* Warning: pcValues and ppval parameters may not           */ <br>    /* have been validated.  Do not dereference them unless     */ <br>    /* the "hr" says everything succeeded so far.               */ <br> <br>    BOOL fErrors = FALSE; <br>    LPSPropValue pval; <br>    LPSPropValue pvalMac; <br> <br>    /* No work to do unless the GetProps() generally succeeded. */ <br>    if (HR_FAILED(hr)) <br>        goto exit; <br> <br>    pval = *ppval; <br>    pvalMac = pval + *pcValues; <br> <br>    for (; pval &lt; pvalMac; ++pval) <br>    { <br>        UINT ulType = (UINT) PROP_TYPE(pval-&gt;ulPropTag); <br>        UINT ulID; <br>        LPVOID pv; <br>        ULONG cb; <br>        SCODE sc; <br> <br>        if(pval-&gt;ulPropTag == PR_ACCESS_LEVEL) <br>        { <br>            pval-&gt;Value.l = OBJ_TestFlag(pobj, OBJF_MODIFY) ? MAPI_MODIFY : 0; <br>        } <br>         <br>        if(pval-&gt;ulPropTag == PR_ACCESS) <br>        { <br>            if(OT_FOLDER == pobj-&gt;wType) <br>            { <br>                pval-&gt;Value.l = MAPI_ACCESS_READ; <br>             <br>                if(OBJ_TestFlag(pobj, OBJF_MODIFY)) <br>                    pval-&gt;Value.l |= MAPI_ACCESS_MODIFY | <br>                                    MAPI_ACCESS_CREATE_CONTENTS | <br>                                    MAPI_ACCESS_CREATE_HIERARCHY; <br> <br>                if(OBJ_TestFlag(pobj-&gt;pobjParent, OBJF_MODIFY)) <br>                    pval-&gt;Value.l |= MAPI_ACCESS_DELETE; <br>            } <br>            else if(OT_MESSAGE == pobj-&gt;wType) <br>            { <br>                pval-&gt;Value.l = MAPI_ACCESS_READ; <br>             <br>                if(OBJ_TestFlag(pobj, OBJF_MODIFY)) <br>                    pval-&gt;Value.l |= MAPI_ACCESS_MODIFY; <br> <br>                if(OBJ_TestFlag(pobj-&gt;pobjParent, OBJF_MODIFY)) <br>                    pval-&gt;Value.l |= MAPI_ACCESS_DELETE; <br>            } <br>            else <br>            { <br>                pval-&gt;ulPropTag = PROP_TAG(PT_ERROR, PROP_ID(PR_ACCESS)); <br>                pval-&gt;Value.err = MAPI_E_NOT_FOUND; <br>            } <br>        } <br> <br>        if (ulType != PT_BINARY &amp;&amp; ulType != PT_ERROR) <br>            continue; <br> <br>        if (ulType == PT_ERROR &amp;&amp; pval-&gt;Value.err == MAPI_E_UNEXPECTED_TYPE) <br>        { <br>            fErrors = TRUE; <br>            continue; <br>        } <br> <br>        if (cvalInt != 0) <br>        { <br>            ProcessGetProps(pval, cvalInt, pvalInt, &amp;pims-&gt;lmr, <br>                (LPVOID) *ppval); <br> <br>            /* Recompute the prop type in case ProcessGetProps changed it. */ <br>            ulType = (UINT) PROP_TYPE(pval-&gt;ulPropTag); <br>        } <br> <br>        /* These values should be computed here just in case ProcessGetProps */ <br>        /* modifies pval. */ <br> <br>        ulID = (UINT) PROP_ID(pval-&gt;ulPropTag); <br> <br>        if (ulID == PROP_ID(PR_STORE_RECORD_KEY)) <br>        { <br>            cb = sizeof(pims-&gt;uidResource); <br>            pv = &amp;pims-&gt;uidResource; </code></pre>
<p>
</p>
<pre><code>} <br>        else if (ulID == PROP_ID(PR_STORE_ENTRYID) <br>            || (fStore &amp;&amp; ulID == PROP_ID(PR_ENTRYID))) <br>        { <br>            cb = pims-&gt;eidStore.cb; <br>            pv = pims-&gt;eidStore.lpb; <br>        } <br>        else if (ulID == PROP_ID(PR_ENTRYID) &amp;&amp; ulType != PT_ERROR) <br>        { <br>            /* entryid of a message doesn't exist until SaveChanges(). */ <br>            if (FIsUnsavedEID((PEID) pval-&gt;Value.bin.lpb)) <br>            { <br>                if (fTagsSpecified) <br>                { <br>                    fErrors = TRUE; <br>                    pval-&gt;ulPropTag = PROP_TAG(PT_ERROR, ulID); <br>                    pval-&gt;Value.err = MAPI_E_NOT_FOUND; <br>                } <br>                else <br>                { <br>                    /* The client wants all properties, and did not */ <br>                    /* specify a prop tag array. The client therefore */ <br>                    /* doesn't want NOT_FOUND errors. */ <br>                    /* Overwrite the error entry with the last SPropValue */ <br>                    /* in the array. */ <br> <br>                    (*pcValues)--; <br>                    pvalMac--; <br> <br>                    if (pval &lt; pvalMac) <br>                    { <br>                        memcpy(pval, pvalMac, sizeof(SPropValue)); <br>                        --pval; /* redo this value, since we just changed it */ <br>                    } <br>                } <br>            } <br>            continue; <br>        } <br>        else <br>        { <br>            /* Remember if any errors occur in final array. */ <br>            if (ulType == PT_ERROR) <br>            { <br>                if (    pval-&gt;Value.err == MAPI_E_NOT_FOUND <br>                    &amp;&amp;  !fTagsSpecified) <br>                { <br>                    /* The client wants all properties, and did not */ <br>                    /* specify a prop tag array. The client therefore */ <br>                    /* doesn't want NOT_FOUND errors. */ <br>                    /* Overwrite the error entry with the last SPropValue */ <br>                    /* in the array. */ <br> <br>                    (*pcValues)--; <br>                    pvalMac--; <br> <br>                    if (pval &lt; pvalMac) <br>                    { <br>                        memcpy(pval, pvalMac, sizeof(SPropValue)); <br>                        --pval; /* redo this value, since we just changed it */ <br>                    } <br>                } <br>                else <br>                    fErrors = TRUE; <br>            } <br>            continue; <br>        } <br> <br>        /* Link onto returned data our extra info. */ <br>        sc = LMAllocMore(&amp;pims-&gt;lmr, cb, (LPVOID) *ppval, <br>            &amp;pval-&gt;Value.bin.lpb); <br>        if (sc != S_OK) <br>        { <br>            fErrors = TRUE; <br>            pval-&gt;Value.err = sc; <br>            pval-&gt;ulPropTag = PROP_TAG(PT_ERROR, ulID); <br>        } <br>        else <br>        { <br>            pval-&gt;Value.bin.cb = cb; <br>            if (cb) <br>                memcpy(pval-&gt;Value.bin.lpb, pv, (UINT) cb); <br>            pval-&gt;ulPropTag = PROP_TAG(PT_BINARY, ulID); <br>        } <br>    } <br> <br>    /* Adjust HRESULT based on PT_ERRORs now. */ <br>    if (!fErrors) <br>        hr = hrSuccess; <br>    else if (hr == hrSuccess) <br>        hr = ResultFromScode(MAPI_W_ERRORS_RETURNED); <br> <br>exit: <br>    #ifdef DEBUG <br>    if (GetScode(hr) != MAPI_W_ERRORS_RETURNED) <br>        DebugTraceResult(HrWrap_GetProps, hr); <br>    #endif <br> <br>    return hr; <br>} <br> <br>/* <br> * FIsSubmittedMessage <br> * <br> * Purpose      return TRUE if the message (specified by entryid) is submitted. <br> * <br> * Parameters <br> *  pims        A pointer to the message store object. <br> *  peid        The entryid of message to check. <br> */ <br>BOOL FIsSubmittedMessage(PIMS pims, PEID peid) <br>{ <br>    HRESULT hr; <br>    PIMSG pimsgT = NULL; <br>    ULONG ulObjType; <br> <br>    hr = pims-&gt;lpVtbl-&gt;OpenEntry(pims, CbEID(peid), (LPENTRYID) peid, <br>        NULL, MAPI_MODIFY, &amp;ulObjType, (LPUNKNOWN *) &amp;pimsgT); <br> <br>    UlRelease(pimsgT); <br> <br>    return (GetScode(hr) == MAPI_E_SUBMITTED); <br>} <br> <br>/* <br> *  HrOpenIMsgSession <br> * <br> *  Purpose: <br> *      Open an IMsgSession, and return the pointer to the caller. <br> * <br> *  Parameters <br> *      ppmsgsess: Pointer to the location to return the opened msg session. <br> * <br> *  Returns: <br> *      HRESULT <br> */ <br>HRESULT HrOpenIMsgSession(LPMSGSESS *ppmsgsess) <br>{ <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br> <br>    Assert(pinst); <br>    Assert(pinst-&gt;lpmalloc); <br> <br>    if (pinst == NULL) <br>        return ResultFromScode(MAPI_E_CALL_FAILED); <br> <br>    return ResultFromScode(OpenIMsgSession(pinst-&gt;lpmalloc, 0L, ppmsgsess)); <br>} <br> <br>/* <br> *  HrOpenIMsg <br> * <br> *  Purpose: <br> *      Open the file given as a docfile, and then create an IMSG.DLL <br> *      object on top of the storage. <br> * <br> *  Parameters <br> *      pmsgsess    The message session to open the message within. <br> *                  May be NULL (for ConfirmCred in msplogon to work). <br> *      szFile      The file to open. <br> *      plmr        a pointer to the linked memory routines. <br> *      psup        a pointer to the MAPI support object. <br> *      fCreate     TRUE means the caller wants to create the storage. <br> *                  FALSE means open an existing storage. <br> *      fModify     TRUE means the caller wants read/write access. <br> *                  FALSE means read-only access. (This argument is  <br> *                  ignored when fCreate is TRUE; in that case, the <br> *                  file is always opened read/write.) <br> *      fExclusive  TRUE means the caller wants exclusive access to the <br> *                  storage, and to fail creation if the storage already <br> *                  exists. <br> *      ppmsg       Address of a location in which to return a <br> *                  pointer to the newly opened IMessage instance. <br> * <br> *  Returns: <br> *      HRESULT <br> * <br> *  Side effects: <br> *      None. <br> * <br> *  Errors: <br> *      IMessage on IStorage opening errors. <br> */ <br>HRESULT HrOpenIMsg(LPMSGSESS pmsgsess, LPSTR szFile, PLMR plmr, LPMAPISUP psup, <br>    BOOL fCreate, BOOL fModify, BOOL fExclusive, LPMESSAGE *ppmsg) <br>{ <br>    HRESULT hr; <br>    SCODE sc; <br>    DWORD grfMode; <br>    LPSTORAGE lpstg = NULL; <br>    PINST pinst = (PINST) PvGetInstanceGlobals(); <br> <br>#ifdef _WIN32 <br>    OLE_CHAR szOle[MAX_PATH]; <br>    int cbFile = 0L; <br>#else <br>    OLE_CHAR *szOle = NULL; <br>#endif <br> <br>    Assert(pinst); <br>    Assert(pinst-&gt;lpmalloc); <br> <br>#ifdef _WIN32 <br>    cbFile = 1 + lstrlen(szFile); <br>    Assert(cbFile &lt; MAX_PATH); <br> <br>    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szFile, cbFile, szOle, cbFile); <br>#else <br>    szOle = szFile; <br>#endif <br> <br>    grfMode = STGM_TRANSACTED; <br> <br>    if (fExclusive) <br>    { <br>        grfMode |= STGM_SHARE_EXCLUSIVE; <br> <br>        if (fCreate) <br>            grfMode |= STGM_FAILIFTHERE; <br>    } <br>    else <br>        grfMode |= STGM_SHARE_DENY_NONE; <br> <br>    if (fCreate) <br>    { <br>        grfMode |= (STGM_READWRITE | STGM_CREATE); <br> <br>        hr = StgCreateDocfile(szOle, grfMode, 0, &amp;lpstg); <br> <br>        /* Commit docfile changes.  If we don't do this now, the file on  */ <br>        /* disk will NOT be a docfile (i.e. OLE2 will not recognize it as */ <br>        /* a docfile) if opened again with no other changes made to it.   */ <br> <br>        if (hr == hrSuccess) <br>            hr = lpstg-&gt;lpVtbl-&gt;Commit(lpstg, 0); <br>    } <br>    else <br>    { <br>        if (fModify) <br>            grfMode |= STGM_READWRITE; <br>        else <br>            grfMode |= STGM_READ; <br> <br>        hr = StgOpenStorage(szOle, NULL, grfMode, NULL, 0, &amp;lpstg); <br>    } <br> <br>    if (hr != hrSuccess) <br>    { <br>        sc = MapStorageSCode(GetScode(hr)); <br>        goto exit; <br>    } <br> <br>    sc = OpenIMsgOnIStg(pmsgsess, plmr-&gt;lpAllocBuf, plmr-&gt;lpAllocMore, <br>        plmr-&gt;lpFreeBuf, pinst-&gt;lpmalloc, psup, lpstg, NULL, 0, 0, ppmsg); <br> <br>    UlRelease(lpstg); <br> <br>exit: <br>    if (sc != S_OK &amp;&amp; fCreate) <br>        DeleteFile(szFile); <br> <br>    DebugTraceSc(HrOpenIMsg, sc); <br>    return ResultFromScode(sc); <br>} <br> <br>/* <br> * HrSetOneROProp <br> * <br> *  Purpose <br> *      The sample store needs to change properties that the client isn't <br> *      allowed to change. This function allows the sample store to change <br> *      a single property in the underlying IMessage object by first <br> *      setting the attributes on that property to allow it to be written, <br> *      then writing the property, and finally, setting the attributes back <br> *      to once again only allow reading. Note that if the sample store  <br> *      calls this routine on a property that is writable, this routine <br> *      will make it non-writable. <br> * <br> *  Parameters <br> *      lpmsg: A pointer to the IMessage object in which to set the property. <br> *      plmr: A pointer to the linked memory allocation routines. <br> *      ulPT: The property tag to set within the object. <br> *      pv: A pointer to the property value to set. <br> */ <br>HRESULT HrSetOneROProp(LPMESSAGE lpmsg, PLMR plmr, ULONG ulPT, LPVOID pv) <br>{ <br>    HRESULT hr; <br>    LPSPropAttrArray patra = NULL; <br>    LPSPropProblemArray pprba = NULL; <br> <br>    SizedSPropTagArray(1, spta); <br> <br>    /* Should be changing the pval array inside the object. */ <br> <br>    AssertSz(   ulPT != PR_ENTRYID <br>            &amp;&amp;  ulPT != PR_PARENT_ENTRYID <br>            &amp;&amp;  ulPT != PR_RECORD_KEY <br>            &amp;&amp;  ulPT != PR_INSTANCE_KEY, "Changing internal props in IMSG"); <br> <br>    spta.cValues = 1; <br>    spta.aulPropTag[0] = ulPT; <br> <br>    /* Get current attributes and make the properties writable */ <br> <br>    hr = GetAttribIMsgOnIStg(lpmsg, (LPSPropTagArray) &amp;spta, &amp;patra); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    patra-&gt;aPropAttr[0] |= PROPATTR_WRITEABLE; <br> <br>    hr = SetAttribIMsgOnIStg(lpmsg, (LPSPropTagArray) &amp;spta, patra, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>    hr = HrSetSingleProp((LPMAPIPROP) lpmsg, plmr, ulPT, pv); <br>    if (hr != hrSuccess) <br>        goto exit; <br> <br>    /* Restore the attribute */ <br> <br>    patra-&gt;aPropAttr[0] &amp;= ~PROPATTR_WRITEABLE; <br> <br>    hr = SetAttribIMsgOnIStg(lpmsg, (LPSPropTagArray) &amp;spta, patra, &amp;pprba); <br>    if (hr != hrSuccess || pprba) <br>        goto exit; <br> <br>exit: <br>    if (pprba) <br>    { <br>        LMFree(plmr, pprba); <br>        hr = ResultFromScode(MAPI_E_CALL_FAILED); <br>    } <br> <br>    LMFree(plmr, patra); <br> <br>    DebugTraceResult(HrSetOneROProp, hr); <br>    return hr; <br>} <br> <br>/* <br> * HrGetSingleProp <br> * <br> *  Purpose <br> *      Gets a property from an object, and returns the value by stuffing <br> *      it into a separately passed pointer. This function is nice because <br> *      it doesn't require the caller to have an SPropValue around simply <br> *      to retrieve the value of a property that is a known size. <br> * <br> *  Parameters <br> *      pmprop  The property object to get the property from. <br> *      plmr    Pointer to MAPI's linked memory routines. <br> *      ulPT    The property tag to get. <br> *      pv      A pointer to the location to place the value of the property. <br> * <br> *  Returns <br> *      HRESULT. No warnings are returned because this function retrieves <br> *      only one property at a time. <br> */ <br>HRESULT HrGetSingleProp(LPMAPIPROP pmprop, PLMR plmr, ULONG ulPT, LPVOID pv) <br>{ <br>    LPSPropValue pval = NULL; <br>    SCODE sc; <br>    HRESULT hr; <br>    ULONG cValues; <br> <br>    SizedSPropTagArray(1, spta); <br> <br>    spta.cValues = 1; <br>    spta.aulPropTag[0] = ulPT; <br> <br>    hr = pmprop-&gt;lpVtbl-&gt;GetProps(pmprop, (LPSPropTagArray) &amp;spta, 0, /* ansi */ <br>        &amp;cValues, &amp;pval); <br> <br>    sc = GetScode(hr); <br> <br>    if ((sc != S_OK) <br>        &amp;&amp; (sc != MAPI_W_ERRORS_RETURNED)) <br>        goto exit; <br> <br>    switch (PROP_TYPE(pval-&gt;ulPropTag)) <br>    { <br>    case PT_I2: <br>    case PT_BOOLEAN: <br>        Assert(!IsBadWritePtr(pv, sizeof(short))); <br>        *(short *)pv = pval-&gt;Value.i; <br>        break; <br> <br>    case PT_LONG: <br>    case PT_R4: <br>        Assert(!IsBadWritePtr(pv, sizeof(LONG))); <br>        *(LONG *) pv = pval-&gt;Value.l; <br>        break; <br> <br>    case PT_DOUBLE: <br>    case PT_APPTIME: <br>    case PT_SYSTIME: <br>    case PT_I8: <br>    case PT_CURRENCY: <br>        Assert(!IsBadWritePtr(pv, sizeof(LARGE_INTEGER))); <br>        *(LARGE_INTEGER *) pv = pval-&gt;Value.li; <br>        break; <br> <br>    case PT_ERROR: <br>        sc = pval-&gt;Value.err; <br>        break; <br> <br>    default: <br>        TrapSz1("Unimplemented PROP_TYPE %08lX passed in.", <br>            PROP_TYPE(pval-&gt;ulPropTag)); <br>    } <br> <br>    LMFree(plmr, pval); <br> <br>exit: <br>    AssertSz1(sc &lt;= 0, "Logic error: sc %s returned from HrGetSingleProp.", <br>        SzDecodeScode(sc)); <br> <br>    DebugTraceSc(HrGetSingleProp, sc); <br>    return (ResultFromScode(sc)); <br>} <br> <br>/* <br> *  HrSetSingleProp <br> * <br> *  Purpose: <br> *      Sets one property and its separately passed value. This function <br> *      is nice because it doesn't require the caller to have a SPropValue <br> *      to pass in. <br> * <br> *  Parameters <br> *      pmprop  The property object to set the property into. <br> *      plmr    Pointer to MAPI's linked memory routines. <br> *      ulPT    The property to set <br> *      pv      A pointer to the value of the property <br> * <br> *  Returns: <br> *  Any errors from SetProps. Note that no warnings or problem arrays are <br> *      returned because this routine only sets one property. <br> */ <br>HRESULT HrSetSingleProp(LPMAPIPROP pmprop, PLMR plmr, ULONG ulPT, LPVOID pv) <br>{ <br>    HRESULT hr; <br>    SPropValue sval; <br>    LPSPropProblemArray pprba = NULL; <br> <br>    sval.ulPropTag = ulPT; <br> <br>    switch (PROP_TYPE(ulPT)) <br>    { <br>    case PT_I2: <br>    case PT_BOOLEAN: <br>        sval.Value.i = *(short *)pv; <br>        break; <br> <br>    case PT_LONG: <br>    case PT_R4: <br>    case PT_UNICODE: <br>    case PT_STRING8: <br>    case PT_CLSID: <br>        AssertSz(sizeof(LPVOID) == sizeof(LONG), <br>            "Pointers are not the size of a long on this machine"); <br>        sval.Value.l = *(LONG *) pv; <br>        break; <br> <br>    case PT_DOUBLE: <br>    case PT_APPTIME: <br>    case PT_SYSTIME: <br>    case PT_I8: <br>    case PT_CURRENCY: <br>    case PT_OBJECT: <br>    case PT_BINARY: <br>        sval.Value.li = *(LARGE_INTEGER *) pv; <br>        break; <br> <br>    default: <br>        TrapSz1("Unimplemented PROP_TYPE %08lX passed in.", PROP_TYPE(ulPT)); <br>    } <br> <br>    hr = pmprop-&gt;lpVtbl-&gt;SetProps(pmprop, 1, &amp;sval, &amp;pprba); <br> <br>    if (hr == hrSuccess &amp;&amp; pprba) <br>        hr = ResultFromScode(pprba-&gt;aProblem[0].scode); <br> <br>    LMFree(plmr, pprba); <br> <br>    DebugTraceResult(HrSetSingleProp, hr); <br>    return hr; <br>} <br> <br>/* <br> *  FContainsProp <br> * <br> *  Purpose: <br> *      returns whether or not a PropTag exists in a PropTagArray <br> * <br> *  Parameters <br> *      ulPropTag   The property to search for. <br> *      ptaga       A pointer to the SPropTagArray to search. May be null, <br> *                  in which case, the function will return FALSE. <br> * <br> *  Returns: <br> *      TRUE    if ulPropTag is in ptaga <br> *      FALSE   if not <br> */ <br>BOOL FContainsProp(ULONG ulPropTag, LPSPropTagArray ptaga) <br>{ <br>    ULONG *pulPropTag; <br>    ULONG *pulPropMax; <br> <br>    if (!ptaga) <br>        return FALSE; <br> <br>    pulPropTag = ptaga-&gt;aulPropTag; <br>    pulPropMax = pulPropTag + ptaga-&gt;cValues; <br> <br>    while (pulPropTag &lt; pulPropMax) <br>    { <br>        if (ulPropTag == *pulPropTag) <br>            return TRUE; <br> <br>        pulPropTag++; <br>    } <br> <br>    return FALSE; <br>} </code></pre>
<p>&nbsp;</p></body>
</HTML>
